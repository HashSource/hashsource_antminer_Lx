/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_1CDA8();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// int __fastcall zlog_init(_DWORD); weak
// char *strstr(const char *haystack, const char *needle);
// int __fastcall zlog_get_category(_DWORD); weak
// int raise(int sig);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int _res_init(void);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int printf(const char *format, ...);
// int truncate(const char *file, __off_t length);
// FILE *fopen(const char *filename, const char *modes);
// int pthread_attr_destroy(pthread_attr_t *attr);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int tcflush(int fd, int queue_selector);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int tolower(int c);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// __off_t lseek(int fd, __off_t offset, int whence);
// double pow(double x, double y);
// int ftell(FILE *stream);
// int memcmp(const void *s1, const void *s2, size_t n);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// unsigned int sleep(unsigned int seconds);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// char *strdup(const char *s);
// int pthread_setcancelstate(int state, int *oldstate);
// uint16_t htons(uint16_t hostshort);
// int pthread_condattr_init(pthread_condattr_t *attr);
// speed_t cfgetispeed(const struct termios *termios_p);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// void *realloc(void *ptr, size_t size);
// int pthread_condattr_setclock(pthread_condattr_t *attr, __clockid_t clock_id);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int strcasecmp(const char *s1, const char *s2);
int __fastcall sub_1D020(int ver, const char *filename, struct stat *stat_buf); // idb
// int _xstat(int ver, const char *filename, struct stat *stat_buf);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int cfsetospeed(struct termios *termios_p, speed_t speed);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int ioctl(int fd, unsigned int request, ...);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int sched_yield(void);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// char *getenv(const char *name);
// int puts(const char *s);
// int sysinfo(struct sysinfo *info);
// void *malloc(size_t size);
// int settimeofday(const struct timeval *tv, const struct timezone *tz);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
// int system(const char *command);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// struct tm *localtime(const time_t *timer);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// const unsigned __int16 **_ctype_b_loc(void);
// __pid_t getpid(void);
// void exit(int status);
// int syscall(int sysno, ...);
// int flock(int fd, int operation);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// int round(void); weak
// char *strchr(const char *s, int c);
// int pthread_setcanceltype(int type, int *oldtype);
// int nice(int inc);
// int fprintf(FILE *stream, const char *format, ...);
// int cfsetispeed(struct termios *termios_p, speed_t speed);
// int fcntl(int fd, int cmd, ...);
// double sqrt(double x);
// speed_t cfgetospeed(const struct termios *termios_p);
// int pthread_attr_init(pthread_attr_t *attr);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// void *memset(void *s, int c, size_t n);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int putchar(int c);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// int fscanf(FILE *stream, const char *format, ...);
// unsigned __int64 strtoull(const char *nptr, char **endptr, int base);
// int fgetc(FILE *stream);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// ssize_t write(int fd, const void *buf, size_t n);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// double difftime(time_t time1, time_t time0);
// void *memchr(const void *s, int c, size_t n);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// int access(const char *name, int type);
// int rand(void);
// int fclose(FILE *stream);
// void pthread_exit(void *retval);
// int __fastcall zlog_fini(_DWORD); weak
// char *strtok(char *s, const char *delim);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// int shutdown(int fd, int how);
// FILE *popen(const char *command, const char *modes);
// int stime(const time_t *when);
// uint32_t htonl(uint32_t hostlong);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int listen(int fd, int n);
// int __fastcall zlog_reload(_DWORD); weak
// int pthread_join(pthread_t th, void **thread_return);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int atoi(const char *nptr);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
// in_addr_t inet_addr(const char *cp);
// void pthread_testcancel(void);
// struct hostent *gethostbyname(const char *name);
// int fseek(FILE *stream, int off, int whence);
// __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int tcgetattr(int fd, struct termios *termios_p);
// int pclose(FILE *stream);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...); // idb
int sub_1D520();
int deregister_tm_clones(); // idb
int register_tm_clones(); // idb
int sub_1D594();
void __fastcall sub_1D5B0(int a1);
int __fastcall sub_1D618(int result, int a2, unsigned int a3);
int __fastcall sub_1D730(unsigned __int8 a1);
int __fastcall sub_1D7A4(unsigned __int8 a1);
_BYTE *__fastcall sub_1D8C8(_BYTE *result);
uint32_t __cdecl swab32(uint32_t v);
int __fastcall sub_1D95C(int result, _DWORD *a2, int a3);
_DWORD *__fastcall sub_1DAAC(int a1, _DWORD *a2);
_DWORD *__fastcall sub_1DB28(int a1, _DWORD *a2);
_DWORD *__fastcall sub_1DBA4(int a1, _DWORD *a2);
_DWORD *__fastcall sub_1DC14(int a1, _DWORD *a2);
_DWORD *__fastcall sub_1DC98(int a1, _DWORD *a2);
int __fastcall sub_1DD08(int result);
int __fastcall sub_1DE14(int result, const char **a2);
int __fastcall sub_1DF60(int result);
char __fastcall set_elapsed_time_validity(char result);
int get_miner_elapsed_time();
time_t set_miner_start_time();
__int64 api_flush();
int __fastcall update_rate_ideal(int a1);
int get_total_nonce_rate();
void get_total_accept_rate();
int __fastcall sub_1E9F4(json_t *a1, const char **a2);
int __fastcall sub_1EF90(json_t *a1, const char **a2);
int __fastcall sub_1F6E4(json_t *a1, const char **a2);
int __fastcall sub_20588(json_t *a1, const char **a2);
int sub_20B4C();
int __fastcall sub_20C5C(json_t *a1, const char **a2);
int __fastcall sub_20DF0(int a1, int a2);
int __fastcall sub_20F64(int result, char a2, int a3, const char *a4);
int __fastcall sub_211A8(json_t *a1, int a2);
int __fastcall sub_21EB0(json_t *a1, int a2);
size_t __fastcall sub_22A40(size_t result, int a2, const char *a3);
int __fastcall sub_22B04(json_t *a1, int a2, int a3);
int __fastcall sub_23FF8(json_t *a1, int a2);
int __fastcall sub_24244(json_t *a1, int a2);
int __fastcall sub_244B0(json_t *a1, int a2);
int __fastcall sub_246D8(json_t *a1, int a2);
int __fastcall sub_24B50(int a1, int a2, const char *a3);
int __fastcall sub_24EF4(int a1, int a2, const char *a3);
int __fastcall sub_251C4(int a1, int a2, const char *a3);
int __fastcall sub_25494(json_t *a1, int a2, const char *a3);
int __fastcall sub_25A08(json_t *a1, int a2, char *a3);
int __fastcall sub_25E80(json_t *a1, int a2, const char *a3);
int __fastcall sub_263D4(json_t *a1, int a2, char *a3);
int __fastcall sub_268EC(json_t *a1, int a2, const char *a3);
_DWORD *print_summary();
int __fastcall sub_27FF4(const char *a1, signed int a2, int a3);
int sub_28180();
int __fastcall sub_2863C(const char *a1, int a2, char *a3, char *a4, _DWORD *a5);
int __fastcall sub_288B8(int result, char *a2);
int __fastcall sub_28D88(json_t *a1, const char *a2, int a3, unsigned int a4);
int *__fastcall sub_29034(int *result);
char *__fastcall sub_290A8(char *a1, const json_t *a2);
const json_t *__fastcall sub_2924C(char *a1, const json_t *a2);
int __fastcall sub_29550(const json_t *a1, char *a2);
int __fastcall sub_29740(int a1, int a2);
char __fastcall sub_29A00(char result);
int is_fixed_freq_mode();
int api();
void __fastcall sub_2A4D0(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_2A538(int a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_2A570(int a1, __int64 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_2A5A4(int a1, __int64 a2);
int __fastcall sub_2A5D8(int a1, void *(*a2)(void *));
void __fastcall sub_2A644(int a1);
void *__fastcall sub_2A68C(_DWORD *a1, const char **a2);
int __fastcall sub_2A6EC(int result, int a2, unsigned int a3);
int __fastcall sub_2A804(unsigned __int8 a1);
int __fastcall sub_2A878(unsigned __int8 a1);
_BYTE *__fastcall sub_2A99C(_BYTE *result);
int __fastcall get_currentalgo(char *a1, size_t a2);
int __fastcall workio_submit_work(int a1, pthread_mutex_t *a2);
int __fastcall update_recorded_timeout_value(unsigned __int64 a1);
void __fastcall __noreturn work_generator_thread(_DWORD *a1);
void __fastcall __noreturn nonce_submit_thread(int a1);
char *__fastcall parse_arg(char *result, char *a2);
void __fastcall parse_config(const json_t *a1, int a2);
char *__fastcall sub_2CE3C(int a1, _DWORD *a2);
int __fastcall sub_2CFB4(int a1);
int sub_2D2F4();
int make_fake_version();
__int64 read_version_file();
int __fastcall godminer_chip_status_monitor(int a1);
bool __fastcall godminer_fan_monitor(int a1);
int godminer_register_status_monitor();
int __fastcall sub_2DF70(const char *a1);
bool sub_2E168();
int sub_2E198();
_DWORD *sub_2E254();
int set_working_voltage_and_runtime_freq();
int setsystime_basestampfile();
int update_timestamp_file();
__int64 call_setsystime_from_http();
void *droa_log_init();
int get_miner_status();
void update_droa_log();
bool check_test_pool();
int compare_nvdata_bin();
int record_nvdata_droalog();
int droa_macro_check();
int __fastcall main(int argc, const char **argv, const char **envp);
int __fastcall sub_30D14(int a1, int a2, int a3);
void __fastcall sub_30D40(int a1, int a2, int a3, int a4, int a5, int a6);
int __fastcall sub_30E2C(unsigned __int8 a1);
int __fastcall sub_30EA0(unsigned __int8 a1);
_BYTE *__fastcall sub_30FC4(_BYTE *result);
int __fastcall get_miner_info(int a1);
int get_error_type();
int __fastcall sub_311F4(int result);
int __fastcall sub_312B8(char *a1, size_t a2, int a3);
bool __cdecl packed_rename(CURL *curl, pool *pool);
int get_miner_sale_hashrate();
int get_miner_qualified_hashrate();
int get_theory_hashrate();
int __fastcall http_test_bm(int a1, char *a2, pool *a3);
void http_test_case_init();
void __fastcall sub_321E8(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_32250(int a1, __int64 a2);
int __fastcall sub_32284(int a1, void *(*a2)(void *));
int __fastcall sub_322F0(int result, int a2, unsigned int a3);
int __fastcall sub_32408(unsigned __int8 a1);
int __fastcall sub_3247C(unsigned __int8 a1);
_BYTE *__fastcall sub_325A0(_BYTE *result);
int __fastcall sub_3260C(unsigned __int8 *a1);
int sub_32824();
int get_current_pool();
bool __fastcall current_pool_changed(int a1);
int __fastcall wait_pool_to_be_current(int a1);
int __fastcall wait_pool_to_be_current_timeout(int a1);
int __fastcall set_current_pool(int a1);
char *add_pool();
pool *add_url(); // idb
int __fastcall sub_32ECC(int a1, const char *a2);
int __fastcall set_url(const char *a1);
int __fastcall set_user(const char *a1);
int __fastcall set_pass(const char *a1);
int __fastcall sub_3345C(int a1);
bool __fastcall sub_335C0(pthread_mutex_t *a1);
int __fastcall pool_tset(int a1, unsigned __int8 *a2, char a3);
int __fastcall pool_tclear(int a1, unsigned __int8 *a2, char a3);
int __fastcall pool_tget(pthread_mutex_t *a1, unsigned __int8 *a2);
int __fastcall pool_twait_to_be_expected_and_set(int a1, _BYTE *a2, char a3, char a4, struct timespec *abstime);
int switch_pools();
_DWORD *sub_33A40();
_DWORD *__fastcall sub_33AE4(_DWORD *a1, char a2);
_DWORD *__fastcall pool_alive(int a1);
int __fastcall pool_died(int *a1);
int check_pool_worker();
void load_factory_pools();
int __fastcall share_result(int a1, int a2, unsigned __int8 *a3, double *a4);
int __fastcall update_pool_diff1_of_all_runtimes(int a1);
int create_pool_stratum_threads();
int check_pools_valid();
int custom_param_check();
int __fastcall judge_load_config(const char *a1);
int *__fastcall sub_353B4(int *result);
int *sub_35534();
int reload_pool();
int sock_blocks();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_362BC(int a1, __int64 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_362F0(int a1, const char *a2);
int __fastcall sub_36328(int result, int a2, unsigned int a3);
int __fastcall sub_36440(unsigned __int8 a1);
int __fastcall sub_364B4(unsigned __int8 a1);
_BYTE *__fastcall sub_365D8(_BYTE *result);
char *__fastcall stratum_buffer_append(int a1, const char *a2);
int __fastcall stratum_send_line(pthread_mutex_t *a1, const char *a2);
char *__fastcall stratum_recv_line(pthread_mutex_t *a1);
int __fastcall stratum_socket_full(int a1, __time_t a2);
int __fastcall stratum_connect(int a1);
int __fastcall stratum_disconnect(pthread_mutex_t *a1);
int __fastcall stratum_thread(int a1);
int __fastcall stratum_check(int *a1);
void __cdecl _list_add(list_head *new, list_head *prev, list_head *next);
void __cdecl list_add_tail(list_head *new, list_head *head);
void __cdecl _list_del(list_head *prev, list_head *next);
void __cdecl list_del(list_head *entry);
int __cdecl list_empty(list_head *head);
int __fastcall sub_38C50(int result, int a2, unsigned int a3);
int __fastcall sub_38D68(unsigned __int8 a1);
int __fastcall sub_38DDC(unsigned __int8 a1);
_BYTE *__fastcall sub_38F00(_BYTE *result);
int __fastcall extract_byte_from_hex(const char *a1, int a2);
int __fastcall format_hashrate_string(const char *a1, char *a2);
int __fastcall format_hashrate_double(const char *a1, double *a2, char *a3);
int __fastcall rev(int result, int a2);
int __fastcall bin2hex(int result, int a2, unsigned int a3);
void *__fastcall abin2hex(int a1, unsigned int a2);
bool __fastcall hex2bin(_BYTE *a1, char *a2, int a3);
int __fastcall sub_39CA0(unsigned __int8 a1);
int __fastcall str2hex(int a1, int a2, int a3);
int __fastcall valid_hex(const char *a1);
int __fastcall valid_ascii(const char *a1);
int __fastcall reverse_hex(int result, unsigned int a2);
char *tq_new();
void __fastcall tq_free(char *a1);
int __fastcall sub_3A424(int a1, char a2);
void __cdecl tq_freeze(thread_q *tq);
void __cdecl mg_iobuf_free(timeval *tv);
int __fastcall tq_push(int a1, int a2);
int __fastcall tq_pop(int a1, const struct timespec *a2);
int __fastcall sub_3A6EC(int a1, int a2);
int __fastcall cgtime(struct timeval *a1);
_DWORD *__fastcall cgtimer_sub(_DWORD *result, _DWORD *a2, _DWORD *a3);
int __fastcall sub_3A890(const char *a1, int *a2, int a3, int a4);
int __fastcall get_server_port_from_url(const char *a1, char *a2, _WORD *a3);
int __fastcall find_min_and_max_float(int result, int a2, float *a3, float *a4);
int *__fastcall find_min_and_max_int(int *result, int a2, _DWORD *a3, _DWORD *a4);
int __fastcall calc_mean(int result, int a2);
double __fastcall calc_stdd(int a1, int a2);
bool __fastcall check_value_valid_with_stdd(int a1, int a2, int a3);
int __fastcall cmpfunc_float(float *a1, float *a2);
int __fastcall cmpfunc_int(_DWORD *a1, _DWORD *a2);
int __fastcall CalcFileMD5(const char *a1, _BYTE *a2);
int __fastcall sub_3B2A0(int result, int a2, int a3, int a4);
unsigned int __fastcall sub_3B2C0(int a1, unsigned int a2);
int __fastcall sub_3B334(int a1, int a2, int a3, int a4);
int __fastcall sub_3B4A0(int a1, _BYTE *a2, int a3, int *a4, int a5);
int __fastcall sub_3B9E8(int a1, int a2, char *a3, int a4, int *a5, char a6);
int __fastcall getopt(int a1, int a2, char *a3);
int __fastcall getopt_long(int a1, int a2, char *a3, int a4, int *a5);
int __fastcall getopt_long_only(int a1, int a2, char *a3, int a4, int *a5);
int __cdecl dump_to_strbuffer(const char *buffer, size_t size, void *data);
int __fastcall sub_3C680(const void *a1, size_t a2, _DWORD *a3);
int __fastcall sub_3C70C(const void *a1, size_t a2, FILE *a3);
int __fastcall sub_3C764(const void *a1, size_t a2, int *a3);
int __fastcall dump_indent(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5);
int __fastcall sub_3C8E4(const char *a1, int a2, int (__fastcall *a3)(const char *, int, int), int a4, __int16 a5);
int __cdecl compare_keys(const void *key1, const void *key2);
int __fastcall sub_3CC8C(hashtable_t *a1, const void *a2, char *a3, size_t a4);
int __fastcall sub_3CD08(_DWORD *a1, int a2, int a3, hashtable_t *a4, int (__fastcall *a5)(const char *, int, int), int a6);
char *__fastcall json_dumps(_DWORD *a1, int a2);
int __fastcall json_dumpb(_DWORD *a1, int a2, int a3, int a4);
int __fastcall json_dumpf(_DWORD *a1, int a2, int a3);
int __fastcall json_dumpfd(_DWORD *a1, int a2, int a3);
int __fastcall json_dump_file(_DWORD *a1, const char *a2, int a3);
int __fastcall json_dump_callback(_DWORD *a1, int (__fastcall *a2)(const char *, int, int), int a3, int a4);
void __cdecl jsonp_error_init(json_error_t *error, const char *source);
char *__fastcall jsonp_error_set_source(char *result, const char *a2);
int jsonp_error_set(int a1, int a2, int a3, int a4, char a5, char *format, ...);
int __fastcall jsonp_error_vset(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg);
void __fastcall sub_3DB5C(int a1);
int __fastcall sub_3DBC4(unsigned __int8 *a1, unsigned int a2, int a3);
void __cdecl list_init(list_t *list);
void __cdecl list_insert(list_t *list, list_t *node);
_DWORD *__fastcall sub_3EB74(_DWORD *result);
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket);
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list);
pair_t *__cdecl hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const char *key, size_t hash);
int __fastcall sub_3ED70(int a1, const char *a2, size_t a3);
void __cdecl hashtable_do_clear(hashtable_t *hashtable);
int __fastcall sub_3EF50(int a1);
int __cdecl hashtable_init(hashtable_t *hashtable);
void __cdecl hashtable_close(hashtable_t *hashtable);
int __cdecl hashtable_set(hashtable_t *hashtable, const char *key, json_t *value);
void *__cdecl hashtable_get(hashtable_t *hashtable, const char *key);
int __fastcall hashtable_del(int a1, char *a2);
void __fastcall hashtable_clear(int a1);
void *__cdecl hashtable_iter(hashtable_t *hashtable);
char *__fastcall hashtable_iter_at(int a1, char *a2);
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter);
void *__cdecl hashtable_iter_key(void *iter);
void *__cdecl hashtable_iter_value(void *iter);
void __fastcall hashtable_iter_set(int a1, int a2);
int __fastcall sub_3F7A4(int a1);
int __fastcall sub_3F814(int *a1);
int __fastcall sub_3F8BC(int *a1);
int sub_3F924();
int __fastcall json_object_seed(int result);
void __fastcall sub_3FA50(int a1);
int sub_3FAB8(int result, int a2, int a3, const char *a4, ...);
int __fastcall stream_init(int result, int a2, int a3);
int __fastcall sub_3FCF4(int a1, int a2);
_DWORD *__fastcall sub_3FF74(_DWORD *result, int a2);
int __cdecl lex_get(lex_t *lex, json_error_t *error);
void __cdecl lex_save(lex_t *lex, int c);
int __cdecl lex_get_save(lex_t *lex, json_error_t *error);
void __cdecl lex_unget(lex_t *lex, int c);
_DWORD *__fastcall sub_40138(_DWORD *result, int a2);
void __cdecl lex_save_cached(lex_t *lex);
void __cdecl lex_free_string(lex_t *lex);
int __fastcall sub_40258(int a1);
void __fastcall sub_40360(int a1, json_error_t *a2);
int __fastcall sub_40980(int a1, int a2, json_error_t *a3);
int __cdecl lex_scan(lex_t *lex, json_error_t *error);
char *__cdecl lex_steal_string(lex_t *lex, size_t *out_len);
int __fastcall lex_init(int a1, int a2, int a3, int a4);
void __cdecl lex_close(lex_t *lex);
json_t *__fastcall sub_41124(int a1, int a2, json_error_t *a3);
json_t *__fastcall sub_41388(int a1, int a2, json_error_t *a3);
json_t *__fastcall sub_414B0(int a1, char a2, json_error_t *a3);
json_t *__fastcall sub_4171C(int a1, char a2, int a3);
int __fastcall sub_41848(_DWORD *a1);
json_t *__fastcall json_loads(int a1, int a2, json_error_t *a3);
int __cdecl buffer_get(void *data);
json_t *__fastcall json_loadb(int a1, int a2, int a3, json_error_t *a4);
json_t *__fastcall json_loadf(int a1, int a2, json_error_t *a3);
int __fastcall sub_41BAC(int *a1);
json_t *__fastcall json_loadfd(int a1, int a2, json_error_t *a3);
json_t *__fastcall json_load_file(const char *a1, int a2, json_error_t *a3);
int __fastcall sub_41DB0(int a1);
json_t *__fastcall json_load_callback(int a1, int a2, int a3, json_error_t *a4);
void *__cdecl jsonp_malloc(size_t size);
void __cdecl jsonp_free(void *ptr);
char *__cdecl jsonp_strdup(const char *str);
char *__cdecl jsonp_strndup(const char *str, size_t len);
void *(*__fastcall json_set_alloc_funcs(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size);
_DWORD *__fastcall json_get_alloc_funcs(_DWORD *result, _DWORD *a2);
int __fastcall sub_42130(int result);
void __fastcall sub_42190(int a1);
void *__fastcall sub_421F8(_DWORD *a1, int a2, int a3, int a4);
int __fastcall sub_422CC(_DWORD *a1);
int __fastcall sub_424BC(_DWORD *a1);
char *sub_4250C(int *a1, const char *a2, char a3, char *format, ...);
char *__fastcall sub_42598(int a1, char ***a2, const char *a3, size_t *a4, _DWORD *a5, int a6);
json_t *__fastcall sub_42988(int a1, char ***a2);
json_t *__fastcall sub_42BB8(int a1, int a2);
json_t *__fastcall sub_42D20(int a1, char ***a2);
void *__fastcall sub_42E4C(int a1, int **a2, int a3);
_QWORD *__fastcall sub_42F48(int *a1, __int64 a2);
double *__fastcall sub_42FAC(int *a1);
json_t *__fastcall sub_43068(int a1, int **a2);
int __fastcall sub_432E8(int a1, const json_t *a2, const char ***a3);
int __fastcall sub_4381C(int a1, const json_t *a2, int a3);
int __fastcall sub_43B38(int a1, const json_t *a2, const char ***a3);
json_t *__fastcall json_vpack_ex(json_error_t *a1, int a2, _BYTE *a3, int *a4);
json_t *json_pack_ex(json_error_t *a1, int a2, _BYTE *a3, ...);
json_t *json_pack(_BYTE *a1, ...);
int __fastcall json_vunpack_ex(const json_t *a1, json_error_t *a2, int a3, _BYTE *a4, const char **a5);
int json_unpack_ex(const json_t *a1, json_error_t *a2, int a3, _BYTE *a4, ...);
int json_unpack(const json_t *a1, _BYTE *a2, ...);
int __cdecl strbuffer_init(strbuffer_t *strbuff);
void __cdecl strbuffer_close(strbuffer_t *strbuff);
void __cdecl strbuffer_clear(strbuffer_t *strbuff);
const char *__cdecl strbuffer_value(const strbuffer_t *strbuff);
int __fastcall strbuffer_steal_value(int *a1);
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, char byte);
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const char *data, size_t size);
char __cdecl strbuffer_pop(strbuffer_t *strbuff);
void __cdecl to_locale(strbuffer_t *strbuffer);
void __cdecl from_locale(char *buffer);
int __fastcall jsonp_strtod(strbuffer_t *a1, double *a2);
int __cdecl jsonp_dtostr(char *buffer, size_t size, double value, int precision);
int __cdecl utf8_encode(int32_t codepoint, char *buffer, size_t *size);
size_t __cdecl utf8_check_first(char byte);
size_t __cdecl utf8_check_full(const char *buffer, size_t size, int32_t *codepoint);
const char *__cdecl utf8_iterate(const char *buffer, size_t bufsize, int32_t *codepoint);
int __fastcall utf8_check_string(int a1, unsigned int a2);
int __fastcall sub_454C0(int result);
void __fastcall sub_45520(int a1);
int __cdecl json_object_set_nocheck(json_t *object, const char *key, json_t *value);
int __cdecl json_array_append(json_t *array, json_t *value);
_DWORD *__fastcall json_init(_DWORD *result, int a2);
char *json_object();
void __cdecl json_delete_object(json_object_t *object);
size_t __cdecl json_object_size(const json_t *json);
json_t *__cdecl json_object_get(const json_t *json, const char *key);
int __cdecl json_object_set_new_nocheck(json_t *json, const char *key, json_t *value);
int __fastcall json_object_set_new(json_t *a1, const char *a2, json_t *a3);
int __fastcall json_object_del(_DWORD *a1, char *a2);
int __fastcall json_object_clear(_DWORD *a1);
int __fastcall json_object_update(json_t *a1, json_t *a2);
int __fastcall json_object_update_existing(json_t *a1, json_t *a2);
int __fastcall json_object_update_missing(json_t *a1, json_t *a2);
void *__cdecl json_object_iter(json_t *json);
char *__fastcall json_object_iter_at(_DWORD *a1, char *a2);
void *__cdecl json_object_iter_next(json_t *json, void *iter);
const char *__cdecl json_object_iter_key(void *iter);
void *__fastcall json_object_iter_value(void *a1);
int __fastcall json_object_iter_set_new(_DWORD *a1, int a2, int a3);
void *__cdecl json_object_key_to_iter(const char *key);
int __fastcall sub_45F3C(const json_t *a1, const json_t *a2);
char *__fastcall sub_4602C(json_t *a1);
char *__fastcall sub_460EC(json_t *a1);
_DWORD *json_array();
void __cdecl json_delete_array(json_array_t *array);
size_t __cdecl json_array_size(const json_t *json);
json_t *__cdecl json_array_get(const json_t *json, size_t index);
int __fastcall json_array_set_new(_DWORD *a1, unsigned int a2, int a3);
void *__fastcall sub_4645C(int a1, int a2, int a3, int a4);
void __cdecl array_copy(json_t **dest, size_t dpos, json_t **src, size_t spos, size_t count);
json_t **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy);
int __cdecl json_array_append_new(json_t *json, json_t *value);
int __fastcall json_array_insert_new(int a1, size_t a2, int a3);
int __fastcall json_array_remove(_DWORD *a1, unsigned int a2);
int __fastcall json_array_clear(_DWORD *a1);
int __fastcall json_array_extend(int a1, int a2);
int __fastcall sub_46B54(const json_t *a1, const json_t *a2);
json_t *__fastcall sub_46C0C(const json_t *a1);
json_t *__fastcall sub_46C94(const json_t *a1);
_DWORD *__fastcall sub_46D28(const char *a1, size_t a2, int a3);
_DWORD *__fastcall json_string_nocheck(const char *a1);
_DWORD *__fastcall json_stringn_nocheck(const char *a1, size_t a2);
json_t *__cdecl jsonp_stringn_nocheck_own(const char *value, size_t len);
_DWORD *__fastcall json_string(const char *a1);
_DWORD *__fastcall json_stringn(const char *a1, size_t a2);
const char *__cdecl json_string_value(const json_t *json);
size_t __cdecl json_string_length(const json_t *json);
int __fastcall json_string_set_nocheck(int a1, const char *a2);
int __fastcall json_string_setn_nocheck(int a1, const char *a2, size_t a3);
int __fastcall json_string_set(int a1, const char *a2);
int __fastcall json_string_setn(int a1, const char *a2, size_t a3);
void __cdecl json_delete_string(json_string_t *string);
bool __fastcall sub_471D4(int a1, int a2);
_DWORD *__fastcall sub_47254(int a1);
json_t *__fastcall json_vsprintf(const char *a1, void *a2);
json_t *json_sprintf(const char *a1, ...);
_QWORD *__fastcall json_integer(__int64 a1);
__int64 __fastcall json_integer_value(int a1);
int __fastcall json_integer_set(int a1, __int64 a2);
void __cdecl p_close(cgsem_t *cgsem);
bool __fastcall sub_474F0(int a1, int a2);
_QWORD *__fastcall sub_47544(int a1);
double *json_real();
void json_real_value();
int __fastcall json_real_set(int a1);
void __fastcall sub_47728(void *a1);
int sub_4774C();
double *sub_477A0();
void __fastcall json_number_value(_DWORD *a1);
json_t *json_true(); // idb
void *json_false();
void *json_null();
void __cdecl json_delete(json_t *json);
int __fastcall json_equal(const json_t *a1, const json_t *a2);
void *__fastcall json_copy(json_t *a1);
void *__fastcall json_deep_copy(const json_t *a1);
void __fastcall sub_47BE8(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_47C50(int a1, __int64 a2);
int __fastcall sub_47C84(int result, int a2, unsigned int a3);
int __fastcall sub_47D9C(unsigned __int8 a1);
int __fastcall sub_47E10(unsigned __int8 a1);
_BYTE *__fastcall sub_47F34(_BYTE *result);
int __fastcall stratum_set_diff_or_target_base(int a1, int a2, const json_t *a3);
int __fastcall stratum_handle_method_base(int a1, int a2, int a3);
int __fastcall pre_stratum_handle_method_base(int a1, int a2, int a3, _DWORD *a4);
int __fastcall stratum_subscribe_base(int a1, int *a2);
int __fastcall stratum_authorize_base(int a1, int a2);
int __fastcall stratum_login_base(int a1, int a2);
int __fastcall stratum_handle_response_base(int a1, int a2, int a3);
int __fastcall settime_based_notify_ntime(const char *a1);
int __fastcall set_frontend_runtime_type(int a1, int a2);
int frontend_runtime_instance();
int __fastcall sub_4A1B0(int result, int a2, unsigned int a3);
int __fastcall sub_4A2C8(unsigned __int8 a1);
int __fastcall sub_4A33C(unsigned __int8 a1);
_BYTE *__fastcall sub_4A460(_BYTE *result);
unsigned int __fastcall sub_4A4CC(unsigned int a1);
int __fastcall sub_4A4F4(int a1, int *a2, const json_t *a3);
int __fastcall sub_4B290(int a1, int a2, const json_t *a3, size_t a4);
int __fastcall sub_4B7A8(int a1, int a2);
void __cdecl gen_hash(unsigned __int8 *data, unsigned __int8 *hash, int len);
void __cdecl flip32(void *dest_p, const void *src_p);
int __fastcall sub_4B8FC(int a1, int a2, char *a3);
void *frontend_runtime_ltc();
unsigned int __fastcall sub_4BBB0(unsigned int a1);
void __fastcall sub_4BBD8(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4BC40(int a1, __int64 a2);
int __fastcall sub_4BC74(int result, int a2, unsigned int a3);
int __fastcall sub_4BD8C(unsigned __int8 a1);
int __fastcall sub_4BE00(unsigned __int8 a1);
_BYTE *__fastcall sub_4BF24(_BYTE *result);
int __fastcall stratum_handle_method_x7(int a1, int a2, int a3);
int __fastcall pre_stratum_handle_method_x7(int a1, int a2, int a3, _DWORD *a4);
int __fastcall stratum_login_x7(int a1, int *a2);
int __fastcall sub_4CF84(int a1, int *a2, const json_t *a3);
int __fastcall sub_4E190(int a1, int a2);
int __fastcall sub_4E210(int a1, int a2, char *a3);
int __fastcall stratum_handle_response_x7(int a1, int a2, int a3);
void *frontend_runtime_x7();
int __fastcall sub_4EA88(int result, int a2, unsigned int a3);
int __fastcall sub_4EBA0(unsigned __int8 a1);
int __fastcall sub_4EC14(unsigned __int8 a1);
_BYTE *__fastcall sub_4ED38(_BYTE *result);
int __fastcall sub_4EDA4(int a1, int a2);
int sub_4EF98();
int __fastcall sub_4EFD0(int a1);
int __fastcall set_frequency_with_voltage_1491(int a1);
void *machine_runtime_ctrl_ltc_1491();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4FC8C(int a1, __int64 a2);
int __fastcall sub_4FCC0(int result, int a2, unsigned int a3);
int __fastcall sub_4FDD8(unsigned __int8 a1);
int __fastcall sub_4FE4C(unsigned __int8 a1);
_BYTE *__fastcall sub_4FF70(_BYTE *result);
char *__fastcall sub_4FFDC(const char *a1);
char *__fastcall sub_5005C(const char *a1);
int __fastcall get_chip_ft_correspond(_DWORD *a1, _DWORD *a2);
int __fastcall support_of_sleepmode(unsigned int a1);
_DWORD *sub_501D8();
int __fastcall sub_50364(int a1);
char *__cdecl mg_unlist(const char *arg);
int __fastcall set_baud_base(int a1, int a2);
int __fastcall check_bringup_temperature_base(int a1);
int __fastcall calc_startup_fan_pwm_base(int a1);
int __fastcall get_working_voltage_base(int a1);
void __fastcall __noreturn check_working_voltage(int a1);
void __fastcall __noreturn check_working_freq(int a1);
int __fastcall update_and_automatic_set_freq(_BYTE *a1);
void __noreturn check_working_freq_new();
int __fastcall start_voltage_monitor_base(void *a1);
int __fastcall start_freq_compensate_thread_base(void *a1);
void __fastcall __noreturn check_working_temp(int a1);
int __fastcall start_temp_monitor_base(void *a1);
void __noreturn stop_voltage_monitor_base();
void __noreturn stop_temp_monitor_base();
int __fastcall set_voltage_base(int a1, int a2);
int __fastcall set_frequency_with_voltage_base(int a1);
int __fastcall check_asic_num_base(int a1);
int __fastcall check_temperature_base(int a1, int *a2, int *a3);
int rename_miner_by_eeprom_info_base();
int __fastcall hot_cold_restart_base(int a1);
int __fastcall start_mining_base(int a1);
int stop_mining_base();
int reset_mining_base();
int sub_54F74();
void calc_freq_compensate_by_temp_base();
int machine_info_init();
int __fastcall sub_55114(const char *a1, _DWORD *a2, _DWORD *a3);
int __fastcall set_voltage_and_freq_by_eeprom_chip_ft(_DWORD *a1, _DWORD *a2);
int set_target_temp_by_eeprom_chip_ft();
int __fastcall hardware_init(const char *a1);
int __fastcall check_if_bringup_temp_valid(int a1);
int __fastcall thread_monitor_temperature_in_startup_stage(int a1);
int __fastcall sub_566F4(int result, int a2, unsigned int a3);
int __fastcall sub_5680C(unsigned __int8 a1);
int __fastcall sub_56880(unsigned __int8 a1);
_BYTE *__fastcall sub_569A4(_BYTE *result);
_DWORD *__fastcall machine_runtime_init(int a1, int a2);
void __fastcall machine_runtime_exit(void *a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_56C30(int a1, __int64 a2);
int __fastcall sub_56C64(int result, int a2, unsigned int a3);
int __fastcall sub_56D7C(unsigned __int8 a1);
int __fastcall sub_56DF0(unsigned __int8 a1);
_BYTE *__fastcall sub_56F14(_BYTE *result);
int __fastcall set_voltage_MP2973(int a1);
int __fastcall sub_57324(int a1, int a2);
int __fastcall sub_57410(int a1, int a2);
int __fastcall sub_576D0(int a1, int a2, int a3, int a4);
int __fastcall sub_5780C(int a1);
int set_frequency_with_voltage_x7_2044();
int __fastcall check_asic_num_x7(int a1);
int __fastcall start_mining_x7(int a1);
void *machine_runtime_ctrl_x7_2044();
int __fastcall sub_58818(int a1);
int __fastcall sub_5887C(int a1);
int __fastcall sub_58904(int a1, int a2, int a3, char a4, int a5, int a6);
int __fastcall sub_58970(int a1, int a2, int a3, char a4, int a5, int a6, int a7, int a8);
int __fastcall update_chip_x7(char a1, float *a2);
int __fastcall sub_5990C(int result, int a2, unsigned int a3);
int __fastcall sub_59A24(unsigned __int8 a1);
int __fastcall sub_59A98(unsigned __int8 a1);
_BYTE *__fastcall sub_59BBC(_BYTE *result);
int __fastcall chip_update_xmr_routine(int a1);
int __fastcall dhash_content_init(int a1);
void __fastcall dhash_content_exit(void *a1);
int __fastcall sub_5A03C(int result, int a2, unsigned int a3);
int __fastcall sub_5A154(unsigned __int8 a1);
int __fastcall sub_5A1C8(unsigned __int8 a1);
_BYTE *__fastcall sub_5A2EC(_BYTE *result);
unsigned int __fastcall sub_5A358(unsigned int a1);
void __fastcall sub_5A380(const unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
unsigned int __fastcall sub_5A3CC(unsigned int result, int a2);
int __fastcall sub_5A454(int a1, int *a2, char a3);
int __fastcall sub_5A70C(int a1, __int64 *a2);
int __fastcall sub_5A840(int a1, int a2, int a3);
void *dhash_content_ltc_1491();
__uint64_t __cdecl _uint64_identity(__uint64_t __x);
void *__fastcall diff_to_target_ltc(void *a1);
int __fastcall target_to_diff_ltc(int a1);
int target_to_double_diff_ltc();
int __fastcall sub_5ADE0(int result, int a2, unsigned int a3);
int __fastcall sub_5AEF8(unsigned __int8 a1);
int __fastcall sub_5AF6C(unsigned __int8 a1);
_BYTE *__fastcall sub_5B090(_BYTE *result);
int __fastcall sub_5B0FC(int a1, int *a2);
int __fastcall sub_5B1AC(int a1, __int64 *a2);
int __fastcall sub_5B300(int a1, int a2, int a3);
void *dhash_content_x7_2044();
unsigned int __fastcall sub_5B660(int a1, unsigned int a2);
void sub_5B6A4();
int le256todouble();
int le256_target_to_double_diff_base();
void *__fastcall diff_to_le256_target_base(void *a1);
int __fastcall le256_target_to_diff_base(int a1);
int __fastcall be256todouble(int a1);
int __fastcall be256_target_to_double_diff_base(int a1);
void *__fastcall diff_to_be256_target_base(void *a1);
int __fastcall be256_target_to_diff_base(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5C1BC(int a1, __int64 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5C1F0(int a1, __int64 a2);
__int64 check_fan_valid();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5C648(int a1, const char *a2);
int __fastcall sub_5C680(int result, int a2, unsigned int a3);
int __fastcall sub_5C798(unsigned __int8 a1);
int __fastcall sub_5C80C(unsigned __int8 a1);
_BYTE *__fastcall sub_5C930(_BYTE *result);
int __fastcall sub_5C99C(int a1, void *(*a2)(void *));
void __noreturn heartbeat_on_device();
int psu_watchdog();
int start_heartbeat_thread();
void __fastcall __noreturn stop_heartbeat_thread(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5D2D8(int a1, __int64 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5D30C(int a1, const char *a2);
int __fastcall sub_5D344(int result, int a2, unsigned int a3);
int __fastcall sub_5D45C(unsigned __int8 a1);
int __fastcall sub_5D4D0(unsigned __int8 a1);
_BYTE *__fastcall sub_5D5F4(_BYTE *result);
int __fastcall sub_5D660(int a1, void *(*a2)(void *));
int sub_5D6CC();
void __noreturn watchpool_thread();
int __fastcall sub_5DA64(int a1);
unsigned int sub_5DABC();
void sub_5DBC0();
int start_watchpool_thread();
int start_api_thread();
int create_pool_connect();
int check_pool_connect();
int __fastcall sub_5E7AC(int result, int a2, unsigned int a3);
int __fastcall sub_5E8C4(unsigned __int8 a1);
int __fastcall sub_5E938(unsigned __int8 a1);
_BYTE *__fastcall sub_5EA5C(_BYTE *result);
int __fastcall check_sn(int a1);
int __fastcall fan_get_check_fan_speed(int a1);
int fan_pwm_get();
int __fastcall fan_pwm_set(unsigned int a1);
int fan_pwm_set_max();
__int64 __fastcall read_feedback_voltage(int a1);
__int64 sub_5F1E8();
int sub_5F3D0();
int __fastcall sub_5F7C0(int a1);
int __fastcall sub_5F7FC(unsigned int a1, unsigned int a2);
int sub_5FB68();
int __fastcall sub_5FD30(int a1, int a2);
int __fastcall sub_5FEF0(int a1, int a2);
int power_on();
unsigned int all_dev_poweroff();
unsigned int power_off();
int __fastcall power_info_init(int a1, int a2, int a3, int a4, int a5);
int __fastcall set_power_init_status(char a1);
int is_power_init();
int is_power_on();
int __fastcall power_init(char a1, int a2);
int __fastcall set_current_voltage(int a1);
int __fastcall set_voltage(int a1, char a2);
int __fastcall set_voltage_by_steps(int a1, char a2, unsigned int a3);
int get_current_voltage();
int get_working_voltage();
int get_max_voltage();
int __fastcall set_working_voltage(char a1);
int is_check_asic_voltage_enable();
int __fastcall set_check_asic_voltage(char a1);
int __fastcall sub_61B68(int result, int a2, unsigned int a3);
int __fastcall sub_61C80(unsigned __int8 a1);
int __fastcall sub_61CF4(unsigned __int8 a1);
_BYTE *__fastcall sub_61E18(_BYTE *result);
int sub_61E84();
int sub_62104();
signed int sub_62264();
int sub_623C4();
int sub_625D4();
signed int __fastcall get_temp(int a1);
int sub_62A34();
int sub_62C30();
int __fastcall sub_62D88(int result);
int __fastcall sub_62EC8(char a1);
int set_pwm_by_temp();
int __fastcall fan_control_info_init(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_63518(int a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_63550(int a1, __int64 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_63584(int a1, char a2);
int __fastcall sub_635C0(int result, int a2, unsigned int a3);
int __fastcall sub_636D8(unsigned __int8 a1);
int __fastcall sub_6374C(unsigned __int8 a1);
_BYTE *__fastcall sub_63870(_BYTE *result);
int __fastcall sub_638DC(int a1, char a2);
int __fastcall sub_64390(char a1);
int __fastcall sub_64568(char a1);
int __fastcall sub_64668(char a1, _BYTE *a2);
int __fastcall sub_64BD0(char a1);
void sub_64C80();
_DWORD *__fastcall get_miner_working_status(_DWORD *a1);
char *get_miner_working_status_p();
void update_miner_working_status();
int __fastcall task_check_miner_status(int a1);
void __fastcall sub_6545C(int a1);
int sub_654C4();
char *get_miner_6060info_status();
int __fastcall set_miner_6060info_status_fan_err(int a1, char a2);
int __fastcall set_miner_6060info_status_high_temp_err(char a1);
int __fastcall set_miner_6060info_uneffective_temp_err(char a1);
int __fastcall set_miner_6060info_status_low_temp_err(char a1);
int __fastcall set_miner_6060info_low_hashrate_err(int a1, char a2);
int __fastcall set_miner_6060info_runtime_bad_asic_err(int a1, char a2);
int __fastcall set_miner_6060info_network_lost_err(char a1);
int __fastcall set_miner_6060info_asic_num_less_than_design_err(int a1, char a2);
int __fastcall set_miner_6060info_malloc_failed_err(char a1);
int __fastcall set_miner_6060info_board_num_less_than_design_err(char a1);
int reset_miner_6060info_status();
int miner_6060info_errorcode_init();
int miner_6060info_errorcode_uninit();
int __fastcall get_errstr_from_json_by_errorcode(const char *a1, char *a2, size_t a3);
int __fastcall get_reason_suggestion_from_json_by_errorcode(const char *a1, char *a2, char *a3, size_t a4);
int __fastcall set_json_info_by_errorcode_and_time(json_t *a1, const char *a2, time_t a3);
int __fastcall sweep_get_error_code(json_t *a1);
int __fastcall sub_67E90(int result, int a2, unsigned int a3);
int __fastcall sub_67FA8(unsigned __int8 a1);
int __fastcall sub_6801C(unsigned __int8 a1);
_BYTE *__fastcall sub_68140(_BYTE *result);
int sub_681AC();
int sub_68310();
int sub_68474();
int sub_685D8();
__int64 sub_6873C();
_DWORD *sub_68DF8();
int miner_monitor_init();
void miner_monitor_deinit();
int do_miner_monitor_start();
int miner_monitor_start();
int miner_monitor_stop();
void __fastcall __spoils<R1,R2,R3,R12,LR> read_status_from_monitor(void *a1, int a2);
int __fastcall add_temperature_observer(int a1);
int __fastcall add_hashrate_observer(int a1);
int __fastcall add_chip_status_observer(int a1);
int __fastcall add_fanspeed_observer(int a1);
int __fastcall read_system_status_from_monitor(int a1);
char *__fastcall get_flag_from_monitor(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_69B80(int a1, __int64 a2);
int __fastcall chip_speed_test(int a1);
int __fastcall update_str_and_flag(unsigned __int64 a1, unsigned __int64 *a2);
int __fastcall sub_6A418(int result);
int __fastcall update_chip_status(int a1, unsigned int a2, int a3);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6A588(int a1, __int64 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6A5BC(int a1, __int64 a2);
int __fastcall update_fanspeed(int a1, _DWORD *a2, int a3);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6B078(int a1, __int64 a2);
int __fastcall sub_6B0AC(int a1);
_QWORD *__fastcall update_hashrate(int a1, int a2, _QWORD *a3);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6BF10(int a1, __int64 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6BF44(int a1, __int64 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6BF78(int a1, __int64 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6BFAC(int a1, __int64 a2);
int __fastcall sub_6BFE0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9);
void *__fastcall init_temp_senor_info(int a1);
int __fastcall update_temperature(int a1, _DWORD *a2, int a3);
int __fastcall runtime_ctrl(int a1);
int query_device_num();
int __fastcall redirect_nonce_output(int result, int a2);
void *__fastcall get_all_created_runtime(_DWORD *a1);
int check_and_destroy_abnormal_runtime();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6EBCC(int a1, __int64 a2);
int __fastcall sub_6EC00(int a1);
bool __fastcall sub_6ED60(int a1);
int __fastcall set_remain_debug_print_time(int a1, __int64 a2);
int __fastcall set_remain_debug_print_lines(int a1, __int64 a2);
int __fastcall set_debug_always_print(int a1, char a2);
unsigned int __fastcall check_and_print_uart_debug_log(int a1, int a2, unsigned __int8 *a3, int a4, char a5);
void __fastcall sub_6F280(int a1);
int __fastcall sub_6F2E8(const char *a1);
int __fastcall sub_6F35C(const char *a1);
int __fastcall sub_6F3C0(const char *a1);
int __fastcall sub_6F424(const char *a1);
int sub_6F488();
int sub_6F4E0();
int sub_6F6C8();
void *sub_6F7B4();
void sub_6F838();
int __fastcall sub_6F850(const json_t *a1);
int __fastcall sub_6FD8C(const json_t *a1);
int __fastcall sub_70010(const json_t *a1);
int __fastcall sub_70BDC(const json_t *a1);
int __fastcall sub_725CC(const json_t *a1);
int __fastcall sub_732BC(const json_t *a1);
int __fastcall sub_73BE8(const json_t *a1);
int __fastcall sub_74514(const json_t *a1);
int __fastcall sub_74A68(const json_t *a1);
int __fastcall sub_74EF0(const json_t *a1);
int __fastcall sub_7581C(const json_t *a1);
int __fastcall sub_75B94(const json_t *a1);
int platform_is_adjustable_power();
int platform_is_check_asic_voltage_enable();
int platfrom_get_check_asic_voltage();
int platform_get_machine_name();
int platform_get_chain_num();
int platform_get_chain_domain_num();
int platform_get_chain_asic_num();
int platform_get_domain_asic_num();
int __fastcall platform_get_chip_type(int a1);
int __fastcall platform_get_asic_big_core_num(int a1);
int __fastcall platform_get_asic_little_core_num(int a1);
int __fastcall platform_get_core_little_core_num(int a1);
int __fastcall platform_get_asic_domain_num(int a1);
int platform_is_pic_mcu_en();
int __fastcall platform_get_asic_addr_interval(int a1);
int __fastcall platform_get_chain_sensor_mode(int a1);
int __fastcall platform_get_chain_sensor_num(int a1);
int __fastcall platform_get_sensor_addr(int a1, int a2);
int platform_is_asic_sensor_air_in();
int __fastcall platform_get_sensor_max_chip_temp(int a1);
int __fastcall platform_get_sensor_max_pcb_temp(int a1);
int __fastcall platform_get_sensor_min_pcb_temp(int a1);
int __fastcall platform_get_sensor_max_uneffective_count(int a1);
int platform_get_fan_num();
int __fastcall platform_get_fan_max_speed(int a1);
int __fastcall platform_get_fan_min_speed(int a1);
int __fastcall platform_get_fan_control_info(int result);
int __fastcall platform_get_pic_device_high(int a1);
int platform_get_psu_gpio_port();
int __fastcall platform_is_psu_supported(__int16 a1);
int __fastcall sub_778A0(int a1, int a2, int a3, int a4);
int platform_topol_init();
int (**dev_ctrl())();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_77CB0(int a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_77CE8(int a1, __int64 a2);
int __fastcall sub_77D1C(int result, int a2, unsigned int a3);
int __fastcall sub_77E34(unsigned __int8 a1);
int __fastcall sub_77EA8(unsigned __int8 a1);
_BYTE *__fastcall sub_77FCC(_BYTE *result);
_BYTE *__fastcall sub_78038(_BYTE *result, int a2);
unsigned int __fastcall sub_780BC(unsigned int a1);
int __fastcall sub_780E4(unsigned __int16 a1);
int __fastcall sub_78114(int a1, char a2);
int __fastcall sub_781DC(int a1, unsigned int a2);
int __fastcall sub_78978(int a1);
int __fastcall sub_78A8C(int a1);
int __fastcall sub_78BA0(int a1, char a2);
int __fastcall sub_78CE8(int a1, char a2);
int __fastcall sub_78E30(int a1, unsigned __int8 a2);
int __fastcall sub_79000(int a1, unsigned __int8 a2, int a3);
int __fastcall sub_791F8(int a1, int a2);
int __fastcall sub_79360(int a1, int a2);
int __fastcall sub_794C8(int a1, int a2);
int __fastcall sub_79630(int a1, int a2);
int __fastcall sub_79798(int a1, int a2);
int __fastcall sub_79B74(int a1, int a2);
int __fastcall sub_79CDC(int a1, int a2);
int __fastcall sub_79E44(int a1, int a2, char a3);
bool __fastcall sub_7A3EC(int a1, int a2, int *a3);
int __fastcall sub_7AB90(int a1, int a2, char a3);
unsigned int *__fastcall sub_7AEFC(unsigned int *result);
unsigned int *__fastcall sub_7B35C(unsigned int *result);
int __fastcall sub_7B7AC(int a1, int a2, char a3, char a4);
int __fastcall sub_7B9E4(int a1, int a2);
int __fastcall sub_7BBEC(int a1, char a2, int a3);
int __fastcall sub_7BE00(int a1);
int __fastcall sub_7C140(int a1, int a2);
int __fastcall sub_7C714(int a1);
int __fastcall sub_7CCD8(int a1, int a2);
int __fastcall sub_7CE48(int a1, unsigned __int8 a2, int a3);
int __fastcall sub_7D01C(int a1, unsigned __int8 a2, char a3, int a4);
int __fastcall sub_7D094(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_7D274(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, int a7);
int __fastcall sub_7D338(int a1, int a2, _DWORD *a3, int a4);
int __fastcall sub_7D470(int a1, int a2, _DWORD *a3, int a4);
int __fastcall sub_7D5A8(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_7D670(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_7D738(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_7D9A0(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_7DC08(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_7DF0C(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_7E0A4(int a1);
int __fastcall sub_7E0F8(int a1);
int __fastcall sub_7E178(int a1, void *a2, unsigned int a3);
int __fastcall sub_7E454(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_7E534(int a1, int a2, void *a3);
int __fastcall sub_7E7E0(int a1, char a2, char a3, int a4, void *dest);
int __fastcall sub_7EAA0(int a1, __int16 a2, int a3);
int __fastcall sub_7EB10(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_7EB88(int a1, __int16 a2, int a3);
int __fastcall sub_7EC08(int a1, __int16 a2, int a3, char a4);
int __fastcall sub_7EC90(int a1);
int __fastcall sub_7ECC8(int a1, __int16 a2, int a3);
int __fastcall sub_7ED50(int a1, __int16 a2, int a3);
int __fastcall sub_7EDD8(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_7EE74(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_7EF14(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_7EFA8(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_7F334(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_7F6C8(int a1, char a2, __int16 a3, void *a4);
int __fastcall sub_7FA40(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_8060C(int a1, char a2, __int16 a3, __int16 a4, void *dest);
int __fastcall global_idx_init_ltc(int a1);
int __fastcall global_idx_free_ltc(int a1);
__int64 __fastcall sub_80A10(int a1, unsigned __int8 a2);
int __fastcall sub_80BE8(int a1, int a2, int a3);
int __fastcall work_2_packet_ltc(int a1, int a2, _BYTE *a3, _DWORD *a4);
__int64 __fastcall sub_81220(int a1, int a2, int a3);
int __fastcall packet_2_nonce_ltc(_DWORD *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
int __fastcall sub_818D8(_DWORD *a1);
int __fastcall get_chip_temperature_str_ltc(int a1, char *a2, unsigned int a3);
int __fastcall calc_chip_temp_min_max_avg_ltc(int a1, _DWORD *a2, _DWORD *a3, int *a4, _DWORD *a5);
int __fastcall sub_81F84(int a1, int a2, _DWORD *a3);
int __fastcall sub_8292C(int a1, int a2);
int sub_830DC();
int __fastcall sub_83104(int a1, int a2);
int __fastcall sub_83148(int a1, int a2);
int sub_83320();
int __fastcall sub_83350(int a1, int a2);
int __fastcall sub_83394(int a1);
int sub_8341C();
int sub_83440();
int __fastcall sub_83464(int a1, unsigned __int8 a2);
int __fastcall send_online_work_ltc(int a1);
int __fastcall top_init_ltc(int a1);
int __fastcall dhash_start_ltc(int a1);
int mg_unpack();
int sub_83A30();
int __fastcall sub_83A5C(int a1, int a2);
int __fastcall setup_all_chip_ltc(int a1);
int __fastcall set_baud_ltc(int a1, int a2);
int __fastcall sub_8404C(int a1, int a2);
int __fastcall check_nonce_ltc(int a1, int a2);
int get_chip_status_ltc();
int __fastcall softreset_all_chip_ltc(int a1);
int __fastcall get_theory_hashrate_ltc(int a1, double *a2);
void sub_84610();
int __fastcall get_sale_hashrate_ltc(int a1, double *a2, _DWORD *a3);
void sub_846F8();
int __fastcall get_qualify_hashrate_ltc(int a1, double *a2);
int __fastcall get_qualify_nonce_num_ltc(int a1, float *a2);
int __fastcall set_sensor_extern_mode_ltc(int a1);
int __fastcall read_sensor_temp_local_ltc(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall read_sensor_temp_remote_ltc(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall parameter_update_ltc(int a1, char a2, int a3, char a4, int a5);
int overclock_update_ltc();
int get_pcba_test_level_ltc();
int __fastcall get_packet_remain_len_ltc(int a1);
int __fastcall adjust_working_freq_ltc(int a1, int a2);
int __fastcall chip_temp_ltc_1491(int a1, int a2);
int __fastcall send_fake_work_ltc(int a1);
void *runtime_ctrl_ltc_1491();
int __fastcall set_chip_reg_ltc(int a1, int a2);
int __fastcall sync_get_status_unclear_ltc(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_status_ltc(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_chip_reg_ltc(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall set_core_reg_ltc(int a1, int a2);
int __fastcall sync_get_core_reg_ltc(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall set_core_enable_ltc(int a1, int a2, __useconds_t a3);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_86850(int a1, __int64 a2);
int __fastcall sub_86884(int result, int a2, unsigned int a3);
int __fastcall sub_8699C(unsigned __int8 a1);
int __fastcall sub_86A10(unsigned __int8 a1);
_BYTE *__fastcall sub_86B34(_BYTE *result);
_BYTE *__fastcall sub_86BA0(_BYTE *result, int a2);
int __fastcall chip_setting_buadrate_ltc(int a1, int a2);
int __fastcall chip_setting_software_reset_ltc(int a1);
int __fastcall chip_setting_software_bridge_or_core_reset_ltc(int a1, int a2, int a3);
int __fastcall chip_setting_misc_ltc(int a1, int a2, int a3, int a4, int a5);
int __fastcall chip_setting_core_command_ltc(int a1, int a2);
unsigned int *__fastcall sub_8744C(unsigned int *result);
int __fastcall chip_setting_freq_ltc(int a1, char a2, int a3, int a4);
int __fastcall sweep_chip_setting_freq_ltc(int a1, char a2, int a3);
int __fastcall chip_setting_ticket_mask_ltc(int a1, unsigned int a2);
int __fastcall chip_setting_gen_nonce_cnt_ltc(int a1, int a2);
bool __fastcall chip_setting_check_bist_ltc(int a1, unsigned __int8 a2, int a3, int a4);
int __fastcall chip_setting_reset_bist_ltc(int a1, char a2, int a3, char a4, int a5);
int __fastcall chip_setting_core_error_ctrl_ltc(int a1);
int __fastcall chip_setting_working_mode_ltc(int a1, char a2, int a3, char a4, int a5, unsigned __int8 a6);
int __fastcall chip_setting_gen_nonce_count_ltc(int a1, char a2, int a3, char a4, char a5, __int16 a6);
int __fastcall chip_setting_share_mode_ltc(int a1);
int __fastcall chip_setting_io_drive_ltc(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_89210(int a1, __int64 a2);
int __fastcall sub_89244(int result, int a2, unsigned int a3);
int __fastcall sub_8935C(unsigned __int8 a1);
int __fastcall sub_893D0(unsigned __int8 a1);
_BYTE *__fastcall sub_894F4(_BYTE *result);
int __fastcall global_idx_init_x7(int a1);
int __fastcall global_idx_free_x7(int a1);
__int64 __fastcall sub_895FC(int a1, unsigned __int8 a2);
int __fastcall sub_897E8(int a1);
int __fastcall sub_89984(__int64 a1);
int __fastcall work_2_packet_x7(int a1, int a2, void *a3, _DWORD *a4);
__int64 __fastcall sub_8A348(int a1, int a2, int a3);
int __fastcall packet_2_nonce_x7(unsigned int *a1, char *a2, int a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
int __fastcall sub_8AA6C(int *a1);
int __fastcall sub_8ACA4(int a1, int a2);
int __fastcall read_rxu_status_x7(int a1, void *a2, _DWORD *a3);
int __fastcall restart_one_chip_x7(int a1, int a2);
int sub_8B3EC();
int sub_8B414();
int sub_8B43C();
int sub_8B468();
int sub_8B490();
int sub_8B4C0();
int sub_8B4E4();
int sub_8B508();
int top_init_x7();
int __fastcall dhash_start_x7(int a1);
int sub_8B6A4();
int sub_8B6D0();
int __fastcall setup_all_chip_x7(int *a1);
int set_baud_x7();
int __fastcall sub_8B99C(int a1);
int __fastcall check_nonce_x7(int a1, _DWORD *a2);
int get_chip_status_x7();
int softreset_all_chip_x7();
int __fastcall get_theory_hashrate_x7(int a1, _QWORD *a2);
void sub_8BD04();
int __fastcall get_sale_hashrate_x7(int a1, double *a2, _DWORD *a3);
int get_qualify_hashrate_x7();
int __fastcall get_qualify_nonce_num_x7(int a1, float *a2);
int set_sensor_extern_mode_x7();
int __fastcall read_sensor_temp_local_x7(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, char a9);
int __fastcall read_sensor_temp_remote_x7(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, char a9);
int __fastcall parameter_update_x7(int a1);
int overclock_update_x7();
int get_pcba_test_level_x7();
int __fastcall get_packet_remain_len_x7(int a1);
int adjust_working_freq_x7();
int __fastcall send_fake_work_x7(int a1);
int __fastcall dhash_mining_reset_x7(int a1);
void *runtime_ctrl_x7_2044();
int __fastcall try_get_seed_status(int a1, int a2, int a3, _DWORD *a4);
int __fastcall try_get_msg_ack(int a1, int a2, int a3, _DWORD *a4);
int __fastcall check_chip_msg_ack_thread(char *a1);
int __fastcall check_chip_msg_ack_x7(int a1, _BYTE *a2, int a3);
int __fastcall x7_chip_seed_status_init(_DWORD *a1);
int __fastcall sub_8D668(int a1, int a2, int a3, int a4);
int __fastcall reset_chip_seed_status(int a1, unsigned __int8 a2);
int __fastcall chip_seed_status_set_calculating(int a1, unsigned __int8 a2);
int __fastcall update_seed_status_receive_ack(int a1, unsigned __int8 a2, const void *a3);
int __fastcall update_seed_status_expired(int a1, unsigned __int8 a2);
int __fastcall update_outdated_chip_seed(int a1, unsigned __int8 a2);
int __fastcall scanseed(int a1);
int __fastcall scan_rxu_hang(int a1);
int __fastcall backend_init_x7(int a1);
int __fastcall backend_exit_x7(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_8F818(int a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_8F850(int a1, __int64 a2);
int __fastcall sub_8F884(int result, int a2, unsigned int a3);
int __fastcall sub_8F99C(unsigned __int8 a1);
int __fastcall sub_8FA10(unsigned __int8 a1);
_BYTE *__fastcall sub_8FB34(_BYTE *result);
int __fastcall wait_x7_chip_setting_not_pending(int a1);
int __fastcall set_x7_chip_setting_pending(int a1, int a2);
int __fastcall x7_chip_finish_pending(int a1);
int __fastcall set_chip_reg_x7(int a1, unsigned __int8 *a2);
int __fastcall sync_get_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, unsigned __int64 a7, char a8);
int __fastcall sync_get_rxu_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, unsigned __int64 a7);
int __fastcall sync_get_temperature_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, unsigned __int64 a7);
int __fastcall sync_unblocked_get_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int __fastcall sync_unblocked_get_msg_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int __fastcall sync_get_seed_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, unsigned __int64 a7);
int __fastcall sync_unblocked_get_seed_status_x7(int a1, int a2, int a3, int a4, _DWORD *a5);
int __fastcall sync_get_chip_reg_x7(int a1, int a2, unsigned __int8 *a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall sync_get_chip_rxu_status_reg_x7(int a1, int a2, unsigned __int8 *a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall sync_get_chip_temperature_reg_x7(int a1, int a2, unsigned __int8 *a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall chip_setting_get_addr_x7(int *a1, unsigned int a2);
int __fastcall chip_setting_seed_x7(int a1, const void *a2, unsigned __int8 a3, void *a4, unsigned __int8 a5);
int __fastcall chip_setting_msg_x7(int a1, const void *a2, unsigned __int8 a3, char a4);
int __fastcall chip_setting_baud_x7(int a1, int a2);
int __fastcall chip_setting_get_md5sum_x7(int a1, int a2, unsigned __int8 a3, const void *a4, size_t n, _BYTE *a6);
int __fastcall chip_setting_get_restart_reg_x7(int a1, unsigned __int8 a2, _DWORD *a3);
int __fastcall chip_setting_send_update_cmd_x7(int a1, int a2, unsigned __int8 a3, _BYTE *a4);
int __fastcall chip_setting_restart_one_chip_x7(int a1, unsigned __int8 a2, _DWORD *a3);
int __fastcall chip_setting_read_one_sensor_temp_x7(int a1, _DWORD *a2, _DWORD *a3, char a4);
int __fastcall chip_setting_read_all_sensor_temp(int a1, void *a2, int a3, _DWORD *a4);
int __fastcall chip_setting_get_all_rxu_status(int a1, void *a2, int a3, _DWORD *a4);
int __fastcall chip_setting_send_update_single_packet(int a1, const void *a2, unsigned __int8 a3, char a4);
int __fastcall sub_93C84(char a1);
__int64 __fastcall sub_93CF0(int a1, int a2, unsigned int a3);
int __fastcall sub_93E7C(int a1, int a2);
bool __fastcall sub_93F38(int a1, int a2);
int __fastcall sub_93FF4(int a1, unsigned __int8 a2, const void *a3, unsigned int a4, unsigned __int8 a5, void *dest, size_t n);
bool __fastcall sub_944F0(int a1, char a2, char a3, const void *a4, size_t n);
bool __fastcall sub_94594(int a1, char a2, char a3, void *dest, size_t n);
bool __fastcall sub_94624(int a1, char a2, unsigned __int8 a3);
int __fastcall get_chain_mps_voltage1(int a1, char a2, unsigned __int16 *a3);
int __fastcall get_chain_mps_voltage2(int a1, char a2, unsigned __int16 *a3);
int __fastcall set_chain_mps_voltage(int a1, char a2, unsigned __int16 a3, unsigned __int16 a4);
char __fastcall set_pic_device_high(char result);
_BYTE *__fastcall sub_953E4(_BYTE *result, char a2, int a3, unsigned __int8 a4);
int __fastcall sub_95588(unsigned __int8 a1, int a2, unsigned __int8 a3, void *a4, unsigned __int8 a5);
int __fastcall sub_95620(int a1, int a2, _BYTE *a3, unsigned __int8 *a4);
int __fastcall pic1704_get_sw_version(char a1, _BYTE *a2);
int __fastcall pic1704_jump_to_app(char a1);
int __fastcall pic1704_reset(char a1);
int __fastcall pic1704_enable_disable_dc_dc(char a1, char a2);
int __fastcall pic1704_erase_program(char a1);
int __fastcall pic1704_heart_beat(char a1);
int __fastcall sub_95ED8(char a1, int a2);
int __fastcall pic1704_update_app_program(unsigned __int8 a1);
int __fastcall pic1704_set_voltage(char a1, unsigned __int8 a2);
bool __fastcall sub_96828(unsigned __int8 *a1);
__int64 __fastcall sub_96A24(unsigned int a1);
int __fastcall pic1704_get_an_voltage1(char a1);
int __fastcall pic1704_get_an_voltage2(char a1, char a2);
int __fastcall pic1704_get_single_voltage(char a1, int *a2);
int __fastcall pic1704_get_all_voltage(char a1, int *a2, int *a3, int *a4);
int __fastcall pic1704_voltage_clamp_ctrl(char a1, char a2);
int __fastcall pic1704_get_PDCx(char a1, int *a2, int *a3, int *a4);
int __fastcall pic1704_get_raw_crab_voltage(char a1, int *a2, int *a3, int *a4, int *a5);
int __fastcall pic1704_write_iic(char a1, char a2);
int __fastcall pic1704_read_iic(char a1, char a2, _BYTE *a3);
int __fastcall pic1704_write_flash(char a1, const void *a2, char a3, size_t a4);
int __fastcall pic1704_read_flash(char a1, void *a2, char a3, size_t a4);
int __fastcall open_pic(unsigned __int8 a1);
int __fastcall close_pic(int result);
int __fastcall sub_97F6C(int a1);
unsigned int __fastcall sub_97FB0(unsigned __int8 a1, const char *a2);
int sub_980C4();
int fan_init();
int fan_uninit();
int __fastcall fan_get_realtime_speed(unsigned int a1);
int fan_get_max_num();
int __fastcall QMap<tagE_LEVEL,MFaultLabel::FaultType>::empty(int a1);
int fan_turn_on();
int fan_turn_off();
void sub_98860();
int fpga_init();
void fpga_uninit();
int fpga_read();
int fpga_write();
int get_fpga_map_mem_addr();
int get_hardware_version();
void fpga_reset();
int __fastcall iic_init(int a1);
int __fastcall iic_uninit(int a1);
int __fastcall iic_read(int a1, void *a2, size_t a3);
int __fastcall iic_write(int a1, int a2, unsigned int a3);
int __fastcall iic_read_reg(int a1, _BYTE *a2, unsigned int a3, int a4, unsigned int a5);
size_t __fastcall iic_write_reg(int a1, _BYTE *a2, int a3, const void *a4, size_t n);
int bitmain_power_on();
int bitmain_power_off();
int __fastcall set_status(int result);
int __fastcall pwm_init(unsigned int a1, int a2);
int __fastcall pwm_uninit(int a1);
int __fastcall pwm_set(int a1, unsigned int a2);
int __fastcall pwm_get(int a1, _DWORD *a2);
int sub_9A3EC();
int __fastcall sub_9A5C4(_DWORD *a1, _DWORD *a2);
int __fastcall sub_9A5FC(unsigned int a1);
int __fastcall sub_9A6FC(int a1);
int __fastcall sub_9A828(int a1, char a2);
int ui_init();
void ui_uninit();
int __fastcall sub_9AC3C(int result, int *a2);
int __fastcall sub_9AD70(int result, int a2, int *a3);
void __fastcall sub_9AFA4(int a1, int a2, int a3);
int __fastcall sub_9B198(unsigned int a1, int a2);
int __fastcall sub_9B59C(unsigned int a1, int a2);
int red_led_on();
int red_led_off();
int red_led_flicker();
int green_led_on();
int green_led_off();
int green_led_flicker();
int beeper_on();
int beeper_off();
int beeper_flicker();
int __fastcall reg_key_callback(int (__fastcall *a1)(int, bool));
int __fastcall unreg_key_callback(int (__fastcall *a1)(int, bool));
int __fastcall lcd_show_result(unsigned __int8 a1, int a2, unsigned int a3);
int lcd_clear_result();
int hal_led_red_addr();
int hal_led_green_addr();
int hal_key_reset_addr();
int hal_key_ipreport_addr();
int __fastcall hal_chain_uart_addr(int a1);
int __fastcall hal_chain_plug_addr(int a1);
int __fastcall hal_chain_reset_addr(int a1);
int hal_chain_max_num();
int __fastcall hal_fan_addr(int a1);
int __fastcall hal_fan_max_speed(int a1);
int hal_fan_number();
int __fastcall eeprom_open(unsigned int a1);
unsigned int __fastcall eeprom_close(unsigned int result);
int __fastcall eeprom_write(unsigned int a1, char a2, int a3, unsigned int a4);
int __fastcall eeprom_read(unsigned int a1, char a2, int a3, unsigned int a4);
void sub_9D164();
int sub_9D24C();
int __fastcall sub_9D4A8(_BYTE *a1, unsigned __int8 *a2);
int __fastcall eeprom_verify_fixture_crc(_BYTE *a1, unsigned __int8 *a2);
int __fastcall sub_9D6A8(_BYTE *a1, char *a2);
int __fastcall sub_9D9AC(_BYTE *a1, char *a2);
int __fastcall eeprom_decode_fixture_info(_BYTE *a1, char *a2);
int __fastcall init_eeprom_fmt_info(_BYTE *a1, char a2);
__int64 __fastcall eeprom_dump_fixture(int a1);
int __fastcall sub_9F374(_BYTE *a1, int a2);
int __fastcall eeprom_trans_raw2layout(_BYTE *a1, int a2);
int __fastcall sub_A0414(_BYTE *a1, int a2);
_DWORD *__fastcall add_eeprom_device(int a1);
int __fastcall eeprom_load_one_chain(unsigned int a1, int a2);
int __fastcall eeprom_rewrite_one_chain(unsigned int a1, int a2, int a3, int a4);
int __fastcall eeprom_vol_freq_override(int a1, int a2);
int eeprom_load();
int __fastcall eeprom_get_voltage(int a1, _DWORD *a2);
int eeprom_get_max_voltage();
int __fastcall eeprom_get_PT2_freq(int a1, _DWORD *a2);
int eeprom_get_min_freq();
int __fastcall eeprom_get_fmt_version(int a1, _BYTE *a2);
int is_eeprom_loaded();
int __fastcall sub_A28E4(int a1);
int __fastcall sub_A29FC(int a1);
int __fastcall sub_A2B14(int a1);
int __fastcall sub_A2C2C(int a1);
int __fastcall sub_A2D44(int a1);
int __fastcall sub_A2E5C(int a1, char *a2);
int __fastcall sub_A2FD0(int a1, char *a2);
int __fastcall sub_A3144(int a1, void *a2);
int __fastcall sub_A32AC(int a1);
int __fastcall api_get_eeprom_nonce_response_rate(int a1, _DWORD *a2);
int __fastcall api_get_eeprom_PT2_freq(int a1);
int __fastcall api_get_eeprom_sweep_freq(int a1);
int __fastcall api_get_eeprom_voltage(int a1);
int __fastcall api_get_eeprom_chip_marking(int a1);
int __fastcall api_get_eeprom_chip_bin(int a1);
int __fastcall api_get_eeprom_chip_ft(int a1);
int __fastcall api_get_eeprom_test_standard_code(int a1);
int __fastcall api_get_eeprom_chip_sn(int a1);
int __fastcall api_get_eeprom_miner_type(int a1, void *a2);
int __fastcall api_get_eeprom_chain_load_state(int a1);
int __fastcall api_get_eeprom_pcb_version(int a1, char *a2);
int __fastcall api_get_eeprom_bom_version(int a1, char *a2);
int __fastcall api_get_eeprom_phy_seq_level(int a1);
int __fastcall api_get_eeprom_fmt_version(int a1);
int __fastcall api_get_eeprom_asic_freqs(int a1, void *a2, float *a3);
unsigned int __fastcall sub_A3F88(unsigned int a1);
unsigned int __fastcall sub_A3FB0(int a1, unsigned int a2);
int __fastcall sub_A3FF4(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall sub_A4484(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4);
bool is_power_status_with_64bits();
int __fastcall sub_A47D0(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5);
int __fastcall sub_A4A58(int a1);
int __fastcall sub_A4D8C(int a1);
int __fastcall sub_A50C0(int a1);
int __fastcall sub_A53FC(int a1, unsigned __int8 a2);
int __fastcall sub_A579C(int a1);
int __fastcall sub_A57D4(int a1);
int __fastcall sub_A5AF0(int a1, unsigned __int8 a2);
int __fastcall sub_A5E70(int a1);
void sub_A618C();
void bitmain_get_sample_voltage();
int __fastcall sub_A6474(int a1);
int bitmain_get_power_status();
int __fastcall bitmain_set_watchdog(char a1);
int bitmain_power_open();
int bitmain_power_close();
int bitmain_power_fw_version();
int bitmain_power_version();
void bitmain_get_voltage();
int bitmain_set_voltage();
int __fastcall bitmain_set_voltage_by_n(unsigned __int8 a1);
void bitmain_convert_N_to_V_calibration();
int sub_A7928();
int bitmain_convert_V_to_N();
void bitmain_convert_N_to_V();
int __fastcall bitmain_power_read(unsigned __int8 a1, int a2, unsigned __int8 a3);
bool is_power_protocal_v2();
int __fastcall sub_A8B08(int a1, unsigned int a2, unsigned __int64 a3, int a4);
int __fastcall sub_A8CC4(int a1);
bool sub_A8FE8();
int __fastcall sub_A9034(int a1, int a2);
void sub_A9108();
int __fastcall sub_A9658(unsigned __int16 a1);
int get_power_voltage_calibration_data();
int bitmain_get_miner_power();
int __fastcall tsensor_open(unsigned int a1, int a2, unsigned __int8 a3);
int __fastcall tsensor_close(unsigned int a1);
int __fastcall tsensor_write(unsigned int a1, unsigned __int8 a2, char a3, int a4, unsigned int a5);
int __fastcall tsensor_read(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, unsigned int a5);
int __fastcall sub_AB0EC(unsigned int a1, unsigned __int8 a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_AB2BC(int a1, __int64 a2);
unsigned int __fastcall sub_AB2F0(int a1, int a2, unsigned __int8 *a3, int a4);
unsigned int __fastcall sub_AB334(int a1, int a2, unsigned __int8 *a3, int a4);
int __fastcall send_work(int a1);
int __fastcall platform_check_repeat_nonce(_DWORD *a1, int a2, unsigned __int8 *a3);
int __fastcall scanhash(_DWORD *a1);
int __fastcall get_response(int a1);
int __fastcall backend_exit_base(int a1);
int __fastcall async_push_work_base(int a1, char *a2);
int set_frequency_by_temp_single_base();
int update_temp_bias_freq_base();
int set_frequency_automatic_single_base();
int __fastcall get_chip_temperature_str_base(int a1, _BYTE *a2, unsigned int a3);
int set_frequency_single_base();
int __fastcall push_work_base(int a1, int a2);
int __fastcall pop_ans_base(int a1, char *a2);
int __fastcall try_pop_ans_base(int a1, char *a2);
int __fastcall backend_init_base(int a1);
int __fastcall reset_base(int a1);
int __fastcall dhash_mining_start_base(int a1);
int __fastcall dhash_mining_stop_base(int a1);
int __fastcall dhash_mining_reset_base(int a1);
int __fastcall set_chipaddr_base(int a1, int a2, int a3);
int __fastcall set_inactive_base(int a1);
int __fastcall set_chip_reg_base(int a1, int a2);
int __fastcall sync_get_status_unclear_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_dag_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_dag_node_rvn(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_chip_reg_base(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall sync_get_dag_node_base(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall set_core_reg_base(int a1, int a2);
int __fastcall set_core_reg_rvn(int a1, int a2);
int __fastcall set_core_reg_base_9(int a1, int a2);
int __fastcall sync_get_core_reg_base_3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall sync_get_core_reg_rvn(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall sync_get_core_reg_base(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall sync_get_status_base2(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_chip_reg_rvn(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall sync_get_chip_reg_base2(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall sync_get_chip_reg_base3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall sync_get_status_base4(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall set_core_reg_base2(int a1, int a2);
int __fastcall sync_get_core_reg_base2(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall set_core_enable_base(int a1, int *a2, __useconds_t a3);
int __fastcall set_core_enable_base2(int a1, int a2, __useconds_t a3);
int __fastcall sync_get_status_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_status_base3(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_core_reg_base3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall get_fake_regio_runtime(int a1);
int __fastcall set_chipaddr_by_id(int a1, int a2, int a3);
int __fastcall set_inactive_by_id(int a1);
int __fastcall set_chip_reg_by_id(int a1, int a2);
int __fastcall set_core_reg_by_id(int a1, int a2);
int __fastcall sync_get_chip_reg_by_id(int a1, int a2, int a3, int a4, int a5);
int __fastcall sync_get_core_reg_by_id(int a1, int a2, int a3, int a4, int a5);
unsigned int __fastcall sub_B18C8(unsigned int a1);
unsigned int __fastcall sub_B18F0(int a1, int a2, unsigned __int8 *a3, int a4);
int __fastcall reverse_byte_order_16(unsigned __int16 a1);
unsigned int __fastcall reverse_byte_order_32(unsigned int a1);
int __fastcall send_command_packet(int a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall convert_offset_to_chain_id(int a1);
int scan_miner_device_hal();
int __fastcall dev_init_hal(int a1);
int dev_init_hal_pcba();
int __fastcall dev_init_pic_for_one_chain(int a1);
int __fastcall sub_dev_init_hal(unsigned int a1);
int __fastcall dev_is_valid_hal(int a1);
int __fastcall set_dev_invalid_hal(int result);
int __fastcall dev_config_hal(__int16 *a1);
int __fastcall dev_config_one_chain_baud(int a1, __int16 *a2);
int __fastcall dump_log_hal(const char *a1, int a2, int a3, int a4);
int __fastcall dev_send_work_cmd_hal(int a1, int a2, unsigned int a3);
int __fastcall dev_send_reg_cmd_hal(int a1, int a2, unsigned int a3);
int __fastcall dev_read_nonce_reg_data_hal(int a1, void *a2, size_t a3);
int dev_get_nonce_reg_fifo_size_hal();
int dev_get_reg_fifo_capacity_hal();
int dev_get_work_fifo_capacity_hal();
int dev_dma_rw_dispatcher_hal();
int cli_ssh_init();
int __fastcall power_on_hal(int a1, unsigned __int16 a2, int a3);
int __fastcall power_off_hal(int a1);
int __fastcall hardreset_hal(int a1);
int __fastcall chain_reset_high_hal(int a1);
int __fastcall chain_reset_low_hal(int a1);
int __fastcall softreset_hal(int a1);
int __fastcall heartbeat_to_hal(int a1);
int __fastcall pic_operation_to_hal(int a1, int a2, unsigned int a3, void *a4);
int (**dev_ctrl_hal())();
_DWORD *__fastcall new_c_map(int a1, int a2, int a3);
int __fastcall insert_c_map(int *a1, const void *a2, size_t a3, const void *a4, size_t a5);
bool __fastcall exists_c_map(int *a1, int a2);
int __fastcall remove_c_map(int *a1, int a2);
int __fastcall find_c_map(int *a1, int a2, void **a3);
int __fastcall delete_c_map(void ***a1);
_DWORD *__fastcall sub_B37F8(int *a1);
int __fastcall sub_B3838(int a1);
void *__fastcall sub_B38DC(int a1);
void *__fastcall sub_B390C(int a1, const void *a2, size_t a3);
_DWORD *__fastcall new_iterator_c_map(int a1);
void __fastcall delete_iterator_c_map(void *a1);
_DWORD *__fastcall sub_B3A44(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_B3B58(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall new_c_rb(int a1, int a2, int a3);
_DWORD *__fastcall sub_B3D34(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall find_c_rb(int a1, int a2);
int __fastcall insert_c_rb(int a1, const void *a2, size_t a3, const void *a4, size_t a5);
int *__fastcall sub_B42BC(int *result, int a2);
int *__fastcall sub_B45B4(int *a1, int *a2);
int *__fastcall remove_c_rb(int a1, int a2);
void __fastcall sub_B4874(int a1, int a2);
int __fastcall delete_c_rb(void **a1);
_DWORD *__fastcall minimum_c_rb(int a1, _DWORD *a2);
int __fastcall maximum_c_rb(int a1, int a2);
bool __fastcall empty_c_rb(_DWORD *a1);
int *__fastcall tree_successor(int *a1, int a2);
int __fastcall sub_B4C50(_DWORD **a1);
int __fastcall sub_B4CBC(int result, _DWORD *a2);
void __cdecl endian_flip32(void *dest_p, const void *src_p);
int __fastcall sub_B4D40(int a1, int a2);
int __fastcall sub_B4D88(int a1, _DWORD *a2);
int __fastcall sub_B4DF4(int a1, _DWORD *a2);
int __fastcall sub_B4E30(int a1, _DWORD *a2, int a3, _DWORD *a4);
void *__fastcall clib_copy(void *a1, const void *a2, size_t a3);
void *__fastcall clib_get(void *a1, const void *a2, size_t a3);
void **__fastcall new_clib_object(const void *a1, size_t a2);
int __fastcall get_raw_clib_object(int a1, void **a2);
void *__fastcall replace_raw_clib_object(void **a1, const void *a2, size_t a3);
void __fastcall delete_clib_object(void **a1);
char *__fastcall clib_strdup(const char *a1);
int __fastcall sub_B5138(unsigned __int8 a1, int a2, unsigned int a3);
int __fastcall sub_B5184(unsigned __int8 a1, void *a2, size_t a3);
int __fastcall sub_B51D0(unsigned __int8 a1, char a2, char a3, int a4, int a5);
int __fastcall sub_B56B8(unsigned __int8 a1, char a2, char a3, int a4, int a5);
int __fastcall sub_B5BBC(unsigned __int8 a1, char a2, _WORD *a3);
int __fastcall sub_B5C4C(int a1, char a2, unsigned __int16 a3);
int __fastcall get_chain_isl_voltage(unsigned __int8 a1, int a2, int a3);
int __fastcall set_chain_isl_voltage(int a1, unsigned __int16 a2);
unsigned int *__fastcall sub_B61C4(unsigned int *result);
int platform_init();
void platform_uninit();
void *__fastcall get_system_capability(void *result);
int __fastcall sub_B6DC4(const char *a1, int a2);
int __fastcall get_uuid(void *a1);
int __fastcall get_mac(int a1);
int __fastcall chain_reset_low(int a1);
int __fastcall chain_reset_high(int a1);
int __fastcall chain_reset(int a1);
int get_hash_on_plug();
int enable_bypass_mode();
int __fastcall sub_B7538(_DWORD *a1, _DWORD *a2);
int sub_B7570();
int gpio_init();
int gpio_uninit();
int __fastcall gpio_reg_callback(int a1, int a2);
int __fastcall gpio_unreg_callback(int a1, int a2);
int __fastcall gpio_export(int a1);
int __fastcall gpio_unexport(int a1);
int __fastcall gpio_direction(int a1, int a2);
int __fastcall gpio_read(int a1, _BYTE *a2);
int __fastcall gpio_write(int a1, char a2);
int __fastcall is_gpio_exist(int a1);
int __fastcall sub_B9658(_DWORD *a1, _DWORD *a2);
int __fastcall i2c_init(const char *a1);
int __fastcall i2c_uninit(int a1);
int __fastcall i2c_read(int a1, void *a2, size_t a3);
int __fastcall i2c_write(int a1, int a2, unsigned int a3);
int __fastcall i2c_ioctl(int a1, __int16 a2, int a3);
int __fastcall i2c_get_fd_from_ctx(int a1);
int __fastcall cgsleep_ms(int a1);
int sub_BAE88();
ssize_t sub_BAEA0();
ssize_t sub_BAF9C();
ssize_t sub_BB098();
ssize_t sub_BB194();
int sub_BB290();
int i2c_sim_init();
int i2c_sim_uninit();
void sub_BBEBC();
void sub_BC0D4();
int sub_BC2F0();
int sub_BC318();
int sub_BC348();
int __fastcall sub_BC480(char a1);
int __fastcall sub_BC4D8(unsigned __int8 a1);
int __fastcall sub_BC668(char a1);
int __fastcall i2c_sim_send_cmd(char a1, char a2, char a3, unsigned __int8 a4, unsigned __int8 a5);
int __fastcall lcd_init(const char *a1);
int __fastcall lcd_write(int a1, unsigned __int8 a2, int a3, unsigned int a4);
int lcd_flush();
int __fastcall lcd_clear(int a1);
int __fastcall lcd_uninit(int a1);
int __fastcall sub_BD250(_DWORD *a1, _DWORD *a2);
int uart_init();
int uart_uninit();
int __fastcall sub_BD3DC(const char *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_BD558(int a1);
int __fastcall sub_BD580(int a1);
int __fastcall sub_BD674(int a1);
int __fastcall uart_send(int a1, int a2, unsigned int a3);
int __fastcall uart_receive(int a1, void *a2, size_t a3, int a4);
int __fastcall sub_BDD70(int a1, speed_t *a2, _DWORD *a3);
int __fastcall sub_BDFBC(int a1);
int __fastcall sub_BE0AC(int a1, int a2, int *a3);
int __fastcall sub_BE20C(int a1, int *a2, unsigned int a3);
int __fastcall sub_BE3A8(int a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_BE514(int a1, int *a2, unsigned int a3);
int __fastcall uart_set_config(int a1, int a2, int *a3, unsigned int a4);
int __fastcall uart_get_config(int a1, int a2, speed_t *a3, _DWORD *a4);
int high_speed_uart_set_config();
int high_speed_uart_get_config();
int __fastcall uart_flush(int a1);
int __fastcall uart_flush_tx(int a1);
int __fastcall uart_flush_rx(int a1);
int __fastcall uart_get_readable_byte_num(int a1);
unsigned int __fastcall sub_BF258(unsigned int a1);
int __cdecl convirt_total_rate(int totalRate);
unsigned int __fastcall sub_BF2A4(unsigned int result, int a2, unsigned int a3);
const void *__fastcall sub_BF324(const void *a1, _DWORD *a2, int a3);
_DWORD *__fastcall sub_C2974(_DWORD *result);
void *__fastcall sub_C2A30(_DWORD *a1, int a2);
const void *__fastcall sub_C2D68(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int *__fastcall sub_C2FF4(int *result, _DWORD *a2);
const void *__fastcall sub_C38AC(_DWORD *a1, int a2, _DWORD *a3);
int __fastcall sub_C3B68(int result, int a2);
int __fastcall scrypt_regenhash(_DWORD *a1, int a2);
int __fastcall scrypt_test(int a1, int a2, unsigned int a3);
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
void __cdecl sha256_init(sha256_ctx *ctx);
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
int __fastcall sub_C468C(__int16 a1, char a2);
int __fastcall BM_CRC16(char *a1, int a2);
int __fastcall BM_CRC16_WITH_KEY(char *a1, int a2, unsigned __int16 a3);
int BM_CRC8();
int __fastcall BM_CRC5(_BYTE *a1, unsigned int a2);
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len);
int __fastcall sub_C4AD8(unsigned __int8 *a1);
char *__fastcall sub_C4B40(char *a1, const void *a2, size_t a3);
int __fastcall sub_C4C24(int a1, int a2);
int __fastcall sub_C4C5C(_DWORD *a1, int *a2);
int __fastcall sub_C4CD0(int a1, int a2);
int __fastcall sub_C4E34(int *a1, unsigned __int8 *a2);
void __fastcall map_deinit_(int a1);
int __fastcall map_get_(int *a1, unsigned __int8 *a2);
int __fastcall map_set_(int *a1, unsigned __int8 *a2, const void *a3, size_t a4);
void __fastcall map_remove_(int *a1, unsigned __int8 *a2);
_DWORD *__fastcall map_iter_(_DWORD *result);
int __fastcall map_next_(_DWORD *a1, _DWORD *a2);
size_t __fastcall statusServiceThread(int a1);
int httpListenThread();
__int64 start_http_thread();
int log_init();
int __fastcall log_uninit(int a1);
int log_reload();
int __fastcall log_droa(const char *a1);
int __fastcall my_system(const char *a1);
int __fastcall sub_C6EC4(int a1, const char *a2, const char *a3, const char *a4);
int __fastcall sub_C7148(int a1);
int __fastcall sub_C74B8(int a1, const char *a2, const char *a3);
void __fastcall __noreturn sub_C76AC(int a1);
void cal_log_init();
int logfmt_raw(void *a1, size_t a2, int a3, ...);
int V_LOCK();
int V_UNLOCK();
int __fastcall V_STR(int a1, const char *a2, const char *a3);
int __fastcall V_FLOAT(int a1, const char *a2);
int __fastcall V_BOOL(int a1, const char *a2, char a3);
int __fastcall V_INT(int a1, const char *a2, __int64 a3);
void *new_observable_subject();
void __fastcall destroy_observable_subject(void *a1);
int __fastcall subject_observe(int result, int a2);
int __fastcall subject_notify_all(int result, int a2);
int sub_C82FC();
int __fastcall send_line(int a1, const char *a2);
int __fastcall socket_full(int a1, __time_t a2);
int __fastcall keep_sockalive(int a1);
void *new_task_timer();
int __fastcall add_new_task(int a1, int a2, int a3);
int __fastcall task_timer_thread(int a1);
int __fastcall _exec_all_task(int result);
int __fastcall start_task_timer(int a1);
int __fastcall stop_task_timer(int result);
void __fastcall destroy_task_timer(_BYTE *a1);
int __fastcall force_exec_all_task(int a1);
int __fastcall _init_pipe_of_queue(int *a1, int a2, int a3);
void __fastcall _deinit_pipe_of_queue(int *a1);
char *__fastcall queue_new(int a1, int a2);
void __fastcall queue_free(int a1);
int __fastcall queue_enqueue(int a1, char *a2, int a3);
int __fastcall clean_up(pthread_mutex_t *a1);
void __fastcall queue_dequeue(int a1, char *a2, unsigned int a3);
int __fastcall queue_dequeue_for(int a1, char *a2, unsigned int a3, _DWORD *a4);
int __fastcall queue_clear(int a1);
int __fastcall queue_try_dequeue(int a1, char *a2, unsigned int a3);
int __fastcall queue_element_num(int a1);
int __fastcall queue_force_wakeup(int a1);
unsigned int *__fastcall xxtea_encode(unsigned int *a1, unsigned int a2, int a3);
int __fastcall xxtea_decode(unsigned int *a1, unsigned int a2, int a3);
int __fastcall data_enc(unsigned int *a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall data_dec(unsigned int *a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall sub_CA794(int a1);
int __fastcall pipe_elem_size(int a1);
_DWORD *__fastcall sub_CA7E4(_DWORD *a1, _DWORD *a2);
int __fastcall sub_CA858(int a1, int a2, int a3, int a4, int a5);
bool __fastcall sub_CA89C(int a1, int a2, unsigned int a3, unsigned int a4);
int __fastcall sub_CA8EC(int a1, int a2, unsigned int a3, unsigned int a4, int a5);
unsigned int __fastcall sub_CA980(int a1, unsigned int a2, unsigned int a3);
unsigned int __fastcall sub_CA9DC(unsigned int a1, unsigned int a2, int a3);
char *__fastcall sub_CAA3C(char *a1, const void *a2, size_t a3);
unsigned int __fastcall sub_CAA7C(unsigned int a1);
_DWORD *__fastcall sub_CAB24(_DWORD *result);
_DWORD *__fastcall sub_CAB78(int a1);
int __fastcall sub_CABBC(int a1);
_DWORD *__fastcall pipe_new(int a1, int a2);
int __fastcall pipe_producer_new(int a1);
int __fastcall pipe_consumer_new(int a1);
void __fastcall sub_CAE8C(int a1);
void __fastcall pipe_free(int a1);
void __fastcall pipe_producer_free(int a1);
void __fastcall pipe_consumer_free(int a1);
char *__fastcall sub_CB204(const void *a1, int a2, const void *a3, unsigned int a4, int a5, char *a6);
_DWORD *__fastcall sub_CB2C4(_DWORD *a1, int a2, unsigned int a3, _BYTE *a4);
_DWORD *sub_CB478(_DWORD *a1, _DWORD *a2, ...);
unsigned int __fastcall sub_CB5FC(int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5, char *a6, size_t a7);
_DWORD *__fastcall sub_CB718(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __fastcall _pipe_push(_DWORD *a1, char *a2, unsigned int a3, _BYTE *a4);
int __fastcall pipe_push(_DWORD *a1, char *a2, int a3, _BYTE *a4);
_DWORD *__fastcall sub_CBAF8(_DWORD *a1, _DWORD *a2);
unsigned int *__fastcall sub_CBBF8(unsigned int *a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5, int a6, char *dest, size_t n, unsigned int *a9);
int sub_CBD9C(_DWORD *a1, ...);
size_t __fastcall sub_CBEFC(_DWORD *a1, void *a2, size_t a3);
int __fastcall pipe_pop(_DWORD *a1, char *a2, int a3);
size_t __fastcall pipe_pop_eager(_DWORD *a1, void *a2, int a3);
int __fastcall pipe_reserve(_DWORD *a1, int a2);
int __fastcall sub_CC4FC(unsigned int a1, unsigned int a2);
int __fastcall sub_CC518(int a1, unsigned int a2);
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2); // idb
int __fastcall sub_CC7AC(int a1, unsigned int a2);
int __fastcall sub_CCAD4(__int64 a1);
int __fastcall sub_CCAE4(__int64 a1);
int __fastcall sub_CCCD0(__int64 a1);
int __fastcall sub_CCDFC(unsigned __int64 a1, unsigned __int64 a2);
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
int __fastcall init(int a1, int a2, int a3);
int _libc_csu_fini(); // weak
int __fastcall sub_CCFF8(char *filename, struct stat *stat_buf); // idb
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

Elf32_Sym stru_13878 = { 6993u, 737116u, 228u, 18u, 0u, 13u }; // weak
__int16 word_1C200 = 1; // weak
__int16 word_1C41C = 1; // weak
_UNKNOWN loc_1FF00; // weak
_UNKNOWN loc_70800; // weak
_UNKNOWN loc_7A11C; // weak
_UNKNOWN loc_CC560; // weak
char byte_CD240[248] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  'R',
  'a',
  't',
  'e',
  ' ',
  'i',
  's',
  ' ',
  'l',
  'o',
  'w',
  'e',
  'r',
  ' ',
  't',
  'h',
  'a',
  'n',
  ' ',
  'i',
  'd',
  'e',
  'a',
  'l',
  ' ',
  'r',
  'a',
  't',
  'e',
  '\0',
  '\0',
  '\0',
  '@',
  '\xD2',
  '\f',
  '\0',
  'D',
  '\xD2',
  '\f',
  '\0',
  '(',
  '\xD2',
  '\f',
  '\0',
  ',',
  '\xD2',
  '\f',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  'C',
  'a',
  'n',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'c',
  'o',
  'n',
  'n',
  'e',
  'c',
  't',
  ' ',
  't',
  'o',
  ' ',
  'p',
  'o',
  'o',
  'l',
  '\0',
  '@',
  '\xD2',
  '\f',
  '\0',
  '|',
  '\xD2',
  '\f',
  '\0',
  '(',
  '\xD2',
  '\f',
  '\0',
  ',',
  '\xD2',
  '\f',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  'W',
  'r',
  'o',
  'n',
  'g',
  ' ',
  'n',
  'u',
  'm',
  'b',
  'e',
  'r',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\xD2',
  '\f',
  '\0',
  '\xAC',
  '\xD2',
  '\f',
  '\0',
  '(',
  '\xD2',
  '\f',
  '\0',
  ',',
  '\xD2',
  '\f',
  '\0',
  ',',
  '\xD2',
  '\f',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  'T',
  'e',
  'm',
  'p',
  ' ',
  'i',
  's',
  ' ',
  't',
  'o',
  'o',
  ' ',
  'h',
  'i',
  'g',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\xD2',
  '\f',
  '\0',
  '\xDC',
  '\xD2',
  '\f',
  '\0',
  '\xAC',
  '\xD2',
  '\f',
  '\0',
  '(',
  '\xD2',
  '\f',
  '\0',
  '(',
  '\xD2',
  '\f',
  '\0',
  '(',
  '\xD2',
  '\f',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFE',
  '\xFF',
  '\xFF',
  '\xFF',
  'd',
  'o',
  'w',
  'n',
  'l',
  'o',
  'a',
  'd',
  'i',
  'n',
  'g',
  '\0',
  'u',
  'p',
  'd',
  'a',
  't',
  'i',
  'n',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\xD2',
  '\f',
  '\0',
  '\x14',
  '\xD3',
  '\f',
  '\0',
  ' ',
  '\xD3',
  '\f',
  '\0'
}; // weak
char *off_D7024 = "algo"; // weak
_UNKNOWN unk_D746C; // weak
char byte_D87E4[4] = { '\0', '\0', '\0', '\0' }; // weak
int dword_D985C[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char byte_D9EAC = '\0'; // weak
char *off_DA358[8] = { "object", "array", "string", "integer", "real", "true", "false", "null" }; // weak
char byte_DA738[176] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  'c',
  'k',
  'b',
  '_',
  '2',
  '0',
  '4',
  '0',
  '\0',
  '\0',
  '\0',
  '\0',
  'c',
  'k',
  'b',
  '_',
  '2',
  '0',
  '4',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  'k',
  'd',
  'a',
  '_',
  '2',
  '1',
  '1',
  '0',
  '\0',
  '\0',
  '\0',
  '\0',
  'h',
  'n',
  's',
  '_',
  '2',
  '1',
  '3',
  '0',
  '\0',
  '\0',
  '\0',
  '\0',
  'd',
  'c',
  'r',
  '_',
  '1',
  '7',
  '2',
  '7',
  '\0',
  '\0',
  '\0',
  '\0',
  'd',
  'a',
  's',
  'h',
  '_',
  '1',
  '7',
  '6',
  '6',
  '\0',
  '\0',
  '\0',
  'e',
  't',
  'h',
  '_',
  '2',
  '2',
  '8',
  '0',
  '\0',
  '\0',
  '\0',
  '\0',
  'e',
  't',
  'h',
  '_',
  '2',
  '2',
  '8',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  'l',
  't',
  'c',
  '_',
  '1',
  '4',
  '9',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  'e',
  'c',
  '_',
  '1',
  '7',
  '4',
  '6',
  '\0',
  '\0',
  '\0',
  '\0',
  'r',
  'v',
  'n',
  '_',
  '2',
  '0',
  '4',
  '4',
  '\0',
  '\0',
  '\0',
  '\0',
  'k',
  'a',
  's',
  '_',
  '2',
  '3',
  '8',
  '0',
  '\0',
  '\0',
  '\0',
  '\0',
  'k',
  's',
  '5',
  '_',
  '2',
  '3',
  '8',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  'x',
  '7',
  '_',
  '2',
  '0',
  '4',
  '4',
  '\0',
  'u',
  'n',
  'k',
  'o',
  'n',
  'w',
  '\0',
  '\0'
}; // weak
char asc_DAF50[2] = "\b"; // weak
_WORD word_E1000[4292] =
{
  -1728,
  2205,
  0,
  0,
  -1600,
  2207,
  0,
  0,
  -2112,
  2209,
  0,
  0,
  -576,
  2211,
  0,
  0,
  -320,
  2213,
  0,
  0,
  -192,
  2215,
  0,
  0,
  -192,
  2217,
  0,
  0,
  -64,
  2219,
  0,
  0,
  -64,
  2221,
  0,
  0,
  -576,
  2223,
  0,
  0,
  -64,
  2225,
  0,
  0,
  -2752,
  2227,
  0,
  0,
  -576,
  2229,
  0,
  0,
  -1088,
  2231,
  0,
  0,
  -192,
  2233,
  0,
  0,
  -320,
  2235,
  0,
  0,
  -832,
  2237,
  0,
  0,
  -192,
  2239,
  0,
  0,
  -320,
  2241,
  0,
  0,
  -448,
  2243,
  0,
  0,
  -192,
  2245,
  0,
  0,
  -704,
  2247,
  0,
  0,
  -64,
  2249,
  0,
  0,
  -448,
  2251,
  0,
  0,
  -1088,
  2253,
  0,
  0,
  -448,
  2255,
  0,
  0,
  -832,
  2257,
  0,
  0,
  -576,
  2259,
  0,
  0,
  -64,
  2261,
  0,
  0,
  -192,
  2263,
  0,
  0,
  -1344,
  2265,
  0,
  0,
  -64,
  2267,
  0,
  0,
  -576,
  2269,
  0,
  0,
  -704,
  2271,
  0,
  0,
  -448,
  2273,
  0,
  0,
  -448,
  2275,
  0,
  0,
  -320,
  2277,
  0,
  0,
  -1856,
  2279,
  0,
  0,
  -1600,
  2281,
  0,
  0,
  -1088,
  2283,
  0,
  0,
  -320,
  2285,
  0,
  0,
  -2752,
  2287,
  0,
  0,
  -1088,
  2289,
  0,
  0,
  -448,
  2291,
  0,
  0,
  -960,
  2293,
  0,
  0,
  -192,
  2295,
  0,
  0,
  -1472,
  2297,
  0,
  0,
  -576,
  2299,
  0,
  0,
  -1088,
  2301,
  0,
  0,
  -1856,
  2303,
  0,
  0,
  -64,
  2305,
  0,
  0,
  -2112,
  2307,
  0,
  0,
  -64,
  2309,
  0,
  0,
  -64,
  2311,
  0,
  0,
  -576,
  2313,
  0,
  0,
  -2624,
  2315,
  0,
  0,
  -1344,
  2317,
  0,
  0,
  -576,
  2319,
  0,
  0,
  -448,
  2321,
  0,
  0,
  -960,
  2323,
  0,
  0,
  -1088,
  2325,
  0,
  0,
  -320,
  2327,
  0,
  0,
  -64,
  2329,
  0,
  0,
  -960,
  2331,
  0,
  0,
  -448,
  2333,
  0,
  0,
  -448,
  2335,
  0,
  0,
  -192,
  2337,
  0,
  0,
  -448,
  2339,
  0,
  0,
  -1216,
  2341,
  0,
  0,
  -192,
  2343,
  0,
  0,
  -448,
  2345,
  0,
  0,
  -192,
  2347,
  0,
  0,
  -1344,
  2349,
  0,
  0,
  -704,
  2351,
  0,
  0,
  -832,
  2353,
  0,
  0,
  -192,
  2355,
  0,
  0,
  -64,
  2357,
  0,
  0,
  -1344,
  2359,
  0,
  0,
  -320,
  2361,
  0,
  0,
  -832,
  2363,
  0,
  0,
  -192,
  2365,
  0,
  0,
  -320,
  2367,
  0,
  0,
  -448,
  2369,
  0,
  0,
  -576,
  2371,
  0,
  0,
  -1856,
  2373,
  0,
  0,
  -1472,
  2375,
  0,
  0,
  -1216,
  2377,
  0,
  0,
  -4544,
  2379,
  0,
  0,
  -64,
  2381,
  0,
  0,
  -448,
  2383,
  0,
  0,
  -1472,
  2385,
  0,
  0,
  -704,
  2387,
  0,
  0,
  -64,
  2389,
  0,
  0,
  -576,
  2391,
  0,
  0,
  -832,
  2393,
  0,
  0,
  -192,
  2395,
  0,
  0,
  -320,
  2397,
  0,
  0,
  -1984,
  2399,
  0,
  0,
  -1600,
  2401,
  0,
  0,
  -3008,
  2403,
  0,
  0,
  -2368,
  2405,
  0,
  0,
  -192,
  2407,
  0,
  0,
  -3648,
  2409,
  0,
  0,
  -1088,
  2411,
  0,
  0,
  -576,
  2413,
  0,
  0,
  -320,
  2415,
  0,
  0,
  -1216,
  2417,
  0,
  0,
  -832,
  2419,
  0,
  0,
  -576,
  2421,
  0,
  0,
  -1216,
  2423,
  0,
  0,
  -1344,
  2425,
  0,
  0,
  -192,
  2427,
  0,
  0,
  -64,
  2429,
  0,
  0,
  -1984,
  2431,
  0,
  0,
  -1472,
  2433,
  0,
  0,
  -64,
  2435,
  0,
  0,
  -576,
  2437,
  0,
  0,
  -1344,
  2439,
  0,
  0,
  -448,
  2441,
  0,
  0,
  -448,
  2443,
  0,
  0,
  -704,
  2445,
  0,
  0,
  -1472,
  2447,
  0,
  0,
  -192,
  2449,
  0,
  0,
  -320,
  2451,
  0,
  0,
  -3136,
  2453,
  0,
  0,
  -64,
  2455,
  0,
  0,
  -704,
  2457,
  0,
  0,
  -1216,
  2459,
  0,
  0,
  -448,
  2461,
  0,
  0,
  -192,
  2463,
  0,
  0,
  -320,
  2465,
  0,
  0,
  -576,
  2467,
  0,
  0,
  -704,
  2469,
  0,
  0,
  -2240,
  2471,
  0,
  0,
  -192,
  2473,
  0,
  0,
  -704,
  2475,
  0,
  0,
  -320,
  2477,
  0,
  0,
  -64,
  2479,
  0,
  0,
  -320,
  2481,
  0,
  0,
  -448,
  2483,
  0,
  0,
  -448,
  2485,
  0,
  0,
  -1472,
  2487,
  0,
  0,
  -64,
  2489,
  0,
  0,
  -960,
  2491,
  0,
  0,
  -192,
  2493,
  0,
  0,
  -448,
  2495,
  0,
  0,
  -960,
  2497,
  0,
  0,
  -704,
  2499,
  0,
  0,
  -1088,
  2501,
  0,
  0,
  -1216,
  2503,
  0,
  0,
  -192,
  2505,
  0,
  0,
  -64,
  2507,
  0,
  0,
  -448,
  2509,
  0,
  0,
  -576,
  2511,
  0,
  0,
  -832,
  2513,
  0,
  0,
  -960,
  2515,
  0,
  0,
  -576,
  2517,
  0,
  0,
  -704,
  2519,
  0,
  0,
  -1728,
  2521,
  0,
  0,
  -192,
  2523,
  0,
  0,
  -832,
  2525,
  0,
  0,
  -64,
  2527,
  0,
  0,
  -192,
  2529,
  0,
  0,
  -320,
  2531,
  0,
  0,
  -576,
  2533,
  0,
  0,
  -960,
  2535,
  0,
  0,
  -320,
  2537,
  0,
  0,
  -192,
  2539,
  0,
  0,
  -960,
  2541,
  0,
  0,
  -1088,
  2543,
  0,
  0,
  -448,
  2545,
  0,
  0,
  -320,
  2547,
  0,
  0,
  -64,
  2549,
  0,
  0,
  -1216,
  2551,
  0,
  0,
  -576,
  2553,
  0,
  0,
  -1600,
  2555,
  0,
  0,
  -64,
  2557,
  0,
  0,
  -576,
  2559,
  0,
  0,
  -64,
  2561,
  0,
  0,
  -192,
  2563,
  0,
  0,
  -1344,
  2565,
  0,
  0,
  -704,
  2567,
  0,
  0,
  -64,
  2569,
  0,
  0,
  -960,
  2571,
  0,
  0,
  -1216,
  2573,
  0,
  0,
  -1600,
  2575,
  0,
  0,
  -192,
  2577,
  0,
  0,
  -704,
  2579,
  0,
  0,
  -448,
  2581,
  0,
  0,
  -192,
  2583,
  0,
  0,
  -448,
  2585,
  0,
  0,
  -1216,
  2587,
  0,
  0,
  -192,
  2589,
  0,
  0,
  -3008,
  2591,
  0,
  0,
  -832,
  2593,
  0,
  0,
  -192,
  2595,
  0,
  0,
  -64,
  2597,
  0,
  0,
  -64,
  2599,
  0,
  0,
  -320,
  2601,
  0,
  0,
  -320,
  2603,
  0,
  0,
  -4800,
  2605,
  0,
  0,
  -192,
  2607,
  0,
  0,
  -64,
  2609,
  0,
  0,
  -960,
  2611,
  0,
  0,
  -320,
  2613,
  0,
  0,
  -2240,
  2615,
  0,
  0,
  -64,
  2617,
  0,
  0,
  -1344,
  2619,
  0,
  0,
  -320,
  2621,
  0,
  0,
  -192,
  2623,
  0,
  0,
  -320,
  2625,
  0,
  0,
  -320,
  2627,
  0,
  0,
  -448,
  2629,
  0,
  0,
  -1088,
  2631,
  0,
  0,
  -448,
  2633,
  0,
  0,
  -5184,
  2635,
  0,
  0,
  -704,
  2637,
  0,
  0,
  -832,
  2639,
  0,
  0,
  -1600,
  2641,
  0,
  0,
  -2112,
  2643,
  0,
  0,
  -832,
  2645,
  0,
  0,
  -192,
  2647,
  0,
  0,
  -704,
  2649,
  0,
  0,
  -704,
  2651,
  0,
  0,
  -832,
  2653,
  0,
  0,
  -192,
  2655,
  0,
  0,
  -1216,
  2657,
  0,
  0,
  -64,
  2659,
  0,
  0,
  -1088,
  2661,
  0,
  0,
  -1088,
  2663,
  0,
  0,
  -64,
  2665,
  0,
  0,
  -320,
  2667,
  0,
  0,
  -3392,
  2669,
  0,
  0,
  -2496,
  2671,
  0,
  0,
  -576,
  2673,
  0,
  0,
  -64,
  2675,
  0,
  0,
  -576,
  2677,
  0,
  0,
  -192,
  2679,
  0,
  0,
  -1856,
  2681,
  0,
  0,
  -192,
  2683,
  0,
  0,
  -704,
  2685,
  0,
  0,
  -832,
  2687,
  0,
  0,
  -576,
  2689,
  0,
  0,
  -320,
  2691,
  0,
  0,
  -1472,
  2693,
  0,
  0,
  -192,
  2695,
  0,
  0,
  -704,
  2697,
  0,
  0,
  -704,
  2699,
  0,
  0,
  -1728,
  2701,
  0,
  0,
  -192,
  2703,
  0,
  0,
  -320,
  2705,
  0,
  0,
  -960,
  2707,
  0,
  0,
  -1856,
  2709,
  0,
  0,
  -1984,
  2711,
  0,
  0,
  -448,
  2713,
  0,
  0,
  -960,
  2715,
  0,
  0,
  -320,
  2717,
  0,
  0,
  -448,
  2719,
  0,
  0,
  -1344,
  2721,
  0,
  0,
  -1600,
  2723,
  0,
  0,
  -960,
  2725,
  0,
  0,
  -320,
  2727,
  0,
  0,
  -1216,
  2729,
  0,
  0,
  -64,
  2731,
  0,
  0,
  -576,
  2733,
  0,
  0,
  -1472,
  2735,
  0,
  0,
  -832,
  2737,
  0,
  0,
  -192,
  2739,
  0,
  0,
  -1216,
  2741,
  0,
  0,
  -576,
  2743,
  0,
  0,
  -1344,
  2745,
  0,
  0,
  -320,
  2747,
  0,
  0,
  -192,
  2749,
  0,
  0,
  -320,
  2751,
  0,
  0,
  -448,
  2753,
  0,
  0,
  -64,
  2755,
  0,
  0,
  -192,
  2757,
  0,
  0,
  -1856,
  2759,
  0,
  0,
  -448,
  2761,
  0,
  0,
  -2240,
  2763,
  0,
  0,
  -64,
  2765,
  0,
  0,
  -960,
  2767,
  0,
  0,
  -2112,
  2769,
  0,
  0,
  -2624,
  2771,
  0,
  0,
  -1728,
  2773,
  0,
  0,
  -1344,
  2775,
  0,
  0,
  -1472,
  2777,
  0,
  0,
  -64,
  2779,
  0,
  0,
  -960,
  2781,
  0,
  0,
  -320,
  2783,
  0,
  0,
  -960,
  2785,
  0,
  0,
  -576,
  2787,
  0,
  0,
  -2368,
  2789,
  0,
  0,
  -448,
  2791,
  0,
  0,
  -320,
  2793,
  0,
  0,
  -1600,
  2795,
  0,
  0,
  -1344,
  2797,
  0,
  0,
  -5952,
  2799,
  0,
  0,
  -448,
  2801,
  0,
  0,
  -192,
  2803,
  0,
  0,
  -192,
  2805,
  0,
  0,
  -320,
  2807,
  0,
  0,
  -1344,
  2809,
  0,
  0,
  -576,
  2811,
  0,
  0,
  -320,
  2813,
  0,
  0,
  -448,
  2815,
  0,
  0,
  -320,
  2817,
  0,
  0,
  -704,
  2819,
  0,
  0,
  -1344,
  2821,
  0,
  0,
  -960,
  2823,
  0,
  0,
  -832,
  2825,
  0,
  0,
  -192,
  2827,
  0,
  0,
  -1472,
  2829,
  0,
  0,
  -1600,
  2831,
  0,
  0,
  -1728,
  2833,
  0,
  0,
  -192,
  2835,
  0,
  0,
  -1472,
  2837,
  0,
  0,
  -576,
  2839,
  0,
  0,
  -320,
  2841,
  0,
  0,
  -832,
  2843,
  0,
  0,
  -1344,
  2845,
  0,
  0,
  -576,
  2847,
  0,
  0,
  -448,
  2849,
  0,
  0,
  -1344,
  2851,
  0,
  0,
  -2240,
  2853,
  0,
  0,
  -704,
  2855,
  0,
  0,
  -64,
  2857,
  0,
  0,
  -3776,
  2859,
  0,
  0,
  -1984,
  2861,
  0,
  0,
  -1600,
  2863,
  0,
  0,
  -704,
  2865,
  0,
  0,
  -64,
  2867,
  0,
  0,
  -1216,
  2869,
  0,
  0,
  -1088,
  2871,
  0,
  0,
  -1088,
  2873,
  0,
  0,
  -192,
  2875,
  0,
  0,
  -2880,
  2877,
  0,
  0,
  -64,
  2879,
  0,
  0,
  -448,
  2881,
  0,
  0,
  -576,
  2883,
  0,
  0,
  -448,
  2885,
  0,
  0,
  -2880,
  2887,
  0,
  0,
  -2496,
  2889,
  0,
  0,
  -1984,
  2891,
  0,
  0,
  -192,
  2893,
  0,
  0,
  -320,
  2895,
  0,
  0,
  -64,
  2897,
  0,
  0,
  -192,
  2899,
  0,
  0,
  -2624,
  2901,
  0,
  0,
  -1472,
  2903,
  0,
  0,
  -192,
  2905,
  0,
  0,
  -704,
  2907,
  0,
  0,
  -448,
  2909,
  0,
  0,
  -64,
  2911,
  0,
  0,
  -576,
  2913,
  0,
  0,
  -320,
  2915,
  0,
  0,
  -576,
  2917,
  0,
  0,
  -1088,
  2919,
  0,
  0,
  -320,
  2921,
  0,
  0,
  -448,
  2923,
  0,
  0,
  -320,
  2925,
  0,
  0,
  -1216,
  2927,
  0,
  0,
  -192,
  2929,
  0,
  0,
  -2624,
  2931,
  0,
  0,
  -448,
  2933,
  0,
  0,
  -192,
  2935,
  0,
  0,
  -2240,
  2937,
  0,
  0,
  -1088,
  2939,
  0,
  0,
  -960,
  2941,
  0,
  0,
  -192,
  2943,
  0,
  0,
  -448,
  2945,
  0,
  0,
  -1216,
  2947,
  0,
  0,
  -704,
  2949,
  0,
  0,
  -64,
  2951,
  0,
  0,
  -960,
  2953,
  0,
  0,
  -960,
  2955,
  0,
  0,
  -1216,
  2957,
  0,
  0,
  -576,
  2959,
  0,
  0,
  -960,
  2961,
  0,
  0,
  -1472,
  2963,
  0,
  0,
  -64,
  2965,
  0,
  0,
  -2496,
  2967,
  0,
  0,
  -64,
  2969,
  0,
  0,
  -448,
  2971,
  0,
  0,
  -3392,
  2973,
  0,
  0,
  -64,
  2975,
  0,
  0,
  -192,
  2977,
  0,
  0,
  -576,
  2979,
  0,
  0,
  -320,
  2981,
  0,
  0,
  -832,
  2983,
  0,
  0,
  -192,
  2985,
  0,
  0,
  -3392,
  2987,
  0,
  0,
  -64,
  2989,
  0,
  0,
  -320,
  2991,
  0,
  0,
  -448,
  2993,
  0,
  0,
  -64,
  2995,
  0,
  0,
  -192,
  2997,
  0,
  0,
  -448,
  2999,
  0,
  0,
  -64,
  3001,
  0,
  0,
  -192,
  3003,
  0,
  0,
  -448,
  3005,
  0,
  0,
  -1600,
  3007,
  0,
  0,
  -576,
  3009,
  0,
  0,
  -64,
  3011,
  0,
  0,
  -1600,
  3013,
  0,
  0,
  -192,
  3015,
  0,
  0,
  -64,
  3017,
  0,
  0,
  -2112,
  3019,
  0,
  0,
  -320,
  3021,
  0,
  0,
  -320,
  3023,
  0,
  0,
  -1728,
  3025,
  0,
  0,
  -576,
  3027,
  0,
  0,
  -448,
  3029,
  0,
  0,
  -64,
  3031,
  0,
  0,
  -1856,
  3033,
  0,
  0,
  -64,
  3035,
  0,
  0,
  -576,
  3037,
  0,
  0,
  -1088,
  3039,
  0,
  0,
  -320,
  3041,
  0,
  0,
  -192,
  3043,
  0,
  0,
  -960,
  3045,
  0,
  0,
  -1984,
  3047,
  0,
  0,
  -832,
  3049,
  0,
  0,
  -1856,
  3051,
  0,
  0,
  -320,
  3053,
  0,
  0,
  -1344,
  3055,
  0,
  0,
  -960,
  3057,
  0,
  0,
  -64,
  3059,
  0,
  0,
  -64,
  3061,
  0,
  0,
  -320,
  3063,
  0,
  0,
  -64,
  3065,
  0,
  0,
  -1984,
  3067,
  0,
  0,
  -576,
  3069,
  0,
  0,
  -448,
  3071,
  0,
  0,
  -192,
  3073,
  0,
  0,
  -192,
  3075,
  0,
  0,
  -64,
  3077,
  0,
  0,
  -64,
  3079,
  0,
  0,
  -320,
  3081,
  0,
  0,
  -1472,
  3083,
  0,
  0,
  -64,
  3085,
  0,
  0,
  -704,
  3087,
  0,
  0,
  -1088,
  3089,
  0,
  0,
  -960,
  3091,
  0,
  0,
  -576,
  3093,
  0,
  0,
  -1088,
  3095,
  0,
  0,
  -192,
  3097,
  0,
  0,
  -1728,
  3099,
  0,
  0,
  -64,
  3101,
  0,
  0,
  -448,
  3103,
  0,
  0,
  -1344,
  3105,
  0,
  0,
  -64,
  3107,
  0,
  0,
  -64,
  3109,
  0,
  0,
  -320,
  3111,
  0,
  0,
  -832,
  3113,
  0,
  0,
  -1984,
  3115,
  0,
  0,
  -192,
  3117,
  0,
  0,
  -64,
  3119,
  0,
  0,
  -64,
  3121,
  0,
  0,
  -576,
  3123,
  0,
  0,
  -1088,
  3125,
  0,
  0,
  -64,
  3127,
  0,
  0,
  -2112,
  3129,
  0,
  0,
  -448,
  3131,
  0,
  0,
  -960,
  3133,
  0,
  0,
  -3264,
  3135,
  0,
  0,
  -1856,
  3137,
  0,
  0,
  -832,
  3139,
  0,
  0,
  -576,
  3141,
  0,
  0,
  -448,
  3143,
  0,
  0,
  -64,
  3145,
  0,
  0,
  -320,
  3147,
  0,
  0,
  -3904,
  3149,
  0,
  0,
  -448,
  3151,
  0,
  0,
  -320,
  3153,
  0,
  0,
  -448,
  3155,
  0,
  0,
  -832,
  3157,
  0,
  0,
  -704,
  3159,
  0,
  0,
  -1216,
  3161,
  0,
  0,
  -576,
  3163,
  0,
  0,
  -192,
  3165,
  0,
  0,
  -1216,
  3167,
  0,
  0,
  -64,
  3169,
  0,
  0,
  -1088,
  3171,
  0,
  0,
  -1216,
  3173,
  0,
  0,
  -448,
  3175,
  0,
  0,
  -192,
  3177,
  0,
  0,
  -448,
  3179,
  0,
  0,
  -1216,
  3181,
  0,
  0,
  -576,
  3183,
  0,
  0,
  -832,
  3185,
  0,
  0,
  -1344,
  3187,
  0,
  0,
  -576,
  3189,
  0,
  0,
  -1088,
  3191,
  0,
  0,
  -192,
  3193,
  0,
  0,
  -1472,
  3195,
  0,
  0,
  -1472,
  3197,
  0,
  0,
  -64,
  3199,
  0,
  0,
  -704,
  3201,
  0,
  0,
  -448,
  3203,
  0,
  0,
  -1984,
  3205,
  0,
  0,
  -192,
  3207,
  0,
  0,
  -448,
  3209,
  0,
  0,
  -64,
  3211,
  0,
  0,
  -1728,
  3213,
  0,
  0,
  -64,
  3215,
  0,
  0,
  -576,
  3217,
  0,
  0,
  -1088,
  3219,
  0,
  0,
  -320,
  3221,
  0,
  0,
  -448,
  3223,
  0,
  0,
  -960,
  3225,
  0,
  0,
  -832,
  3227,
  0,
  0,
  -1984,
  3229,
  0,
  0,
  -320,
  3231,
  0,
  0,
  -832,
  3233,
  0,
  0,
  -64,
  3235,
  0,
  0,
  -704,
  3237,
  0,
  0,
  -2624,
  3239,
  0,
  0,
  -64,
  3241,
  0,
  0,
  -960,
  3243,
  0,
  0,
  -2240,
  3245,
  0,
  0,
  -576,
  3247,
  0,
  0,
  -576,
  3249,
  0,
  0,
  -2240,
  3251,
  0,
  0,
  -192,
  3253,
  0,
  0,
  -192,
  3255,
  0,
  0,
  -704,
  3257,
  0,
  0,
  -1728,
  3259,
  0,
  0,
  -704,
  3261,
  0,
  0,
  -320,
  3263,
  0,
  0,
  -448,
  3265,
  0,
  0,
  -960,
  3267,
  0,
  0,
  -64,
  3269,
  0,
  0,
  -64,
  3271,
  0,
  0,
  -320,
  3273,
  0,
  0,
  -704,
  3275,
  0,
  0,
  -960,
  3277,
  0,
  0,
  -1088,
  3279,
  0,
  0,
  -64,
  3281,
  0,
  0,
  -448,
  3283,
  0,
  0,
  -704,
  3285,
  0,
  0,
  -64,
  3287,
  0,
  0,
  -192,
  3289,
  0,
  0,
  -960,
  3291,
  0,
  0,
  -832,
  3293,
  0,
  0,
  -1344,
  3295,
  0,
  0,
  -704,
  3297,
  0,
  0,
  -1472,
  3299,
  0,
  0,
  -576,
  3301,
  0,
  0,
  -192,
  3303,
  0,
  0,
  -320,
  3305,
  0,
  0,
  -2496,
  3307,
  0,
  0,
  -192,
  3309,
  0,
  0,
  -704,
  3311,
  0,
  0,
  -3136,
  3313,
  0,
  0,
  -704,
  3315,
  0,
  0,
  -320,
  3317,
  0,
  0,
  -448,
  3319,
  0,
  0,
  -1088,
  3321,
  0,
  0,
  -2752,
  3323,
  0,
  0,
  -64,
  3325,
  0,
  0,
  -960,
  3327,
  0,
  0,
  -1856,
  3329,
  0,
  0,
  -1216,
  3331,
  0,
  0,
  -192,
  3333,
  0,
  0,
  -320,
  3335,
  0,
  0,
  -64,
  3337,
  0,
  0,
  -1344,
  3339,
  0,
  0,
  -64,
  3341,
  0,
  0,
  -448,
  3343,
  0,
  0,
  -1728,
  3345,
  0,
  0,
  -1472,
  3347,
  0,
  0,
  -576,
  3349,
  0,
  0,
  -704,
  3351,
  0,
  0,
  -448,
  3353,
  0,
  0,
  -192,
  3355,
  0,
  0,
  -576,
  3357,
  0,
  0,
  -832,
  3359,
  0,
  0,
  -576,
  3361,
  0,
  0,
  -1472,
  3363,
  0,
  0,
  -1472,
  3365,
  0,
  0,
  -64,
  3367,
  0,
  0,
  -576,
  3369,
  0,
  0,
  -320,
  3371,
  0,
  0,
  -576,
  3373,
  0,
  0,
  -320,
  3375,
  0,
  0,
  -2240,
  3377,
  0,
  0,
  -1344,
  3379,
  0,
  0,
  -704,
  3381,
  0,
  0,
  -1088,
  3383,
  0,
  0,
  -64,
  3385,
  0,
  0,
  -4160,
  3387,
  0,
  0,
  -64,
  3389,
  0,
  0,
  -576,
  3391,
  0,
  0,
  -192,
  3393,
  0,
  0,
  -320,
  3395,
  0,
  0,
  -960,
  3397,
  0,
  0,
  -1728,
  3399,
  0,
  0,
  -320,
  3401,
  0,
  0,
  -576,
  3403,
  0,
  0,
  -2240,
  3405,
  0,
  0,
  -704,
  3407,
  0,
  0,
  -832,
  3409,
  0,
  0,
  -320,
  3411,
  0,
  0,
  -1216,
  3413,
  0,
  0,
  -1600,
  3415,
  0,
  0,
  -576,
  3417,
  0,
  0,
  -448,
  3419,
  0,
  0,
  -1344,
  3421,
  0,
  0,
  -320,
  3423,
  0,
  0,
  -1472,
  3425,
  0,
  0,
  -64,
  3427,
  0,
  0,
  -192,
  3429,
  0,
  0,
  -64,
  3431,
  0,
  0,
  -192,
  3433,
  0,
  0,
  -192,
  3435,
  0,
  0,
  -64,
  3437,
  0,
  0,
  -64,
  3439,
  0,
  0,
  -320,
  3441,
  0,
  0,
  -1216,
  3443,
  0,
  0,
  -2880,
  3445,
  0,
  0,
  -1344,
  3447,
  0,
  0,
  -1984,
  3449,
  0,
  0,
  -448,
  3451,
  0,
  0,
  -960,
  3453,
  0,
  0,
  -704,
  3455,
  0,
  0,
  -64,
  3457,
  0,
  0,
  -192,
  3459,
  0,
  0,
  -320,
  3461,
  0,
  0,
  -1600,
  3463,
  0,
  0,
  -320,
  3465,
  0,
  0,
  -320,
  3467,
  0,
  0,
  -448,
  3469,
  0,
  0,
  -1088,
  3471,
  0,
  0,
  -2368,
  3473,
  0,
  0,
  -192,
  3475,
  0,
  0,
  -1856,
  3477,
  0,
  0,
  -64,
  3479,
  0,
  0,
  -64,
  3481,
  0,
  0,
  -960,
  3483,
  0,
  0,
  -704,
  3485,
  0,
  0,
  -832,
  3487,
  0,
  0,
  -576,
  3489,
  0,
  0,
  -1600,
  3491,
  0,
  0,
  -1728,
  3493,
  0,
  0,
  -704,
  3495,
  0,
  0,
  -1600,
  3497,
  0,
  0,
  -64,
  3499,
  0,
  0,
  -1728,
  3501,
  0,
  0,
  -1216,
  3503,
  0,
  0,
  -64,
  3505,
  0,
  0,
  -5312,
  3507,
  0,
  0,
  -1088,
  3509,
  0,
  0,
  -64,
  3511,
  0,
  0,
  -1088,
  3513,
  0,
  0,
  -64,
  3515,
  0,
  0,
  -2496,
  3517,
  0,
  0,
  -1856,
  3519,
  0,
  0,
  -1088,
  3521,
  0,
  0,
  -448,
  3523,
  0,
  0,
  -320,
  3525,
  0,
  0,
  -64,
  3527,
  0,
  0,
  -64,
  3529,
  0,
  0,
  -704,
  3531,
  0,
  0,
  -448,
  3533,
  0,
  0,
  -1344,
  3535,
  0,
  0,
  -192,
  3537,
  0,
  0,
  -704,
  3539,
  0,
  0,
  -1216,
  3541,
  0,
  0,
  -192,
  3543,
  0,
  0,
  -1984,
  3545,
  0,
  0,
  -64,
  3547,
  0,
  0,
  -192,
  3549,
  0,
  0,
  -1600,
  3551,
  0,
  0,
  -448,
  3553,
  0,
  0,
  -2112,
  3555,
  0,
  0,
  -1472,
  3557,
  0,
  0,
  -1344,
  3559,
  0,
  0,
  -704,
  3561,
  0,
  0,
  -320,
  3563,
  0,
  0,
  -1600,
  3565,
  0,
  0,
  -1856,
  3567,
  0,
  0,
  -832,
  3569,
  0,
  0,
  -2368,
  3571,
  0,
  0,
  -3776,
  3573,
  0,
  0,
  -2752,
  3575,
  0,
  0,
  -2496,
  3577,
  0,
  0,
  -576,
  3579,
  0,
  0,
  -64,
  3581,
  0,
  0,
  -192,
  3583,
  0,
  0,
  -320,
  3585,
  0,
  0,
  -704,
  3587,
  0,
  0,
  -192,
  3589,
  0,
  0,
  -1856,
  3591,
  0,
  0,
  -448,
  3593,
  0,
  0,
  -64,
  3595,
  0,
  0,
  -960,
  3597,
  0,
  0,
  -832,
  3599,
  0,
  0,
  -3520,
  3601,
  0,
  0,
  -1472,
  3603,
  0,
  0,
  -64,
  3605,
  0,
  0,
  -576,
  3607,
  0,
  0,
  -1344,
  3609,
  0,
  0,
  -320,
  3611,
  0,
  0,
  -576,
  3613,
  0,
  0,
  -1728,
  3615,
  0,
  0,
  -704,
  3617,
  0,
  0,
  -1216,
  3619,
  0,
  0,
  -320,
  3621,
  0,
  0,
  -832,
  3623,
  0,
  0,
  -2752,
  3625,
  0,
  0,
  -192,
  3627,
  0,
  0,
  -448,
  3629,
  0,
  0,
  -64,
  3631,
  0,
  0,
  -192,
  3633,
  0,
  0,
  -1984,
  3635,
  0,
  0,
  -576,
  3637,
  0,
  0,
  -3008,
  3639,
  0,
  0,
  -1088,
  3641,
  0,
  0,
  -576,
  3643,
  0,
  0,
  -2624,
  3645,
  0,
  0,
  -320,
  3647,
  0,
  0,
  -64,
  3649,
  0,
  0,
  -2240,
  3651,
  0,
  0,
  -1600,
  3653,
  0,
  0,
  -448,
  3655,
  0,
  0,
  -192,
  3657,
  0,
  0,
  -448,
  3659,
  0,
  0,
  -448,
  3661,
  0,
  0,
  -1088,
  3663,
  0,
  0,
  -320,
  3665,
  0,
  0,
  -192,
  3667,
  0,
  0,
  -192,
  3669,
  0,
  0,
  -320,
  3671,
  0,
  0,
  -192,
  3673,
  0,
  0,
  -704,
  3675,
  0,
  0,
  -704,
  3677,
  0,
  0,
  -576,
  3679,
  0,
  0,
  -704,
  3681,
  0,
  0,
  -1216,
  3683,
  0,
  0,
  -448,
  3685,
  0,
  0,
  -576,
  3687,
  0,
  0,
  -1856,
  3689,
  0,
  0,
  -64,
  3691,
  0,
  0,
  -1728,
  3693,
  0,
  0,
  -832,
  3695,
  0,
  0,
  -64,
  3697,
  0,
  0,
  -1344,
  3699,
  0,
  0,
  -2624,
  3701,
  0,
  0,
  -448,
  3703,
  0,
  0,
  -192,
  3705,
  0,
  0,
  -1856,
  3707,
  0,
  0,
  -64,
  3709,
  0,
  0,
  -960,
  3711,
  0,
  0,
  -320,
  3713,
  0,
  0,
  -64,
  3715,
  0,
  0,
  -192,
  3717,
  0,
  0,
  -64,
  3719,
  0,
  0,
  -448,
  3721,
  0,
  0,
  -1472,
  3723,
  0,
  0,
  -64,
  3725,
  0,
  0,
  -1600,
  3727,
  0,
  0,
  -576,
  3729,
  0,
  0,
  -320,
  3731,
  0,
  0,
  -448,
  3733,
  0,
  0,
  -960,
  3735,
  0,
  0,
  -704,
  3737,
  0,
  0,
  -192,
  3739,
  0,
  0,
  -1728,
  3741,
  0,
  0,
  -1472,
  3743,
  0,
  0,
  -64,
  3745,
  0,
  0,
  -192,
  3747,
  0,
  0,
  -64,
  3749,
  0,
  0,
  -1216,
  3751,
  0,
  0,
  -1088,
  3753,
  0,
  0,
  -704,
  3755,
  0,
  0,
  -64,
  3757,
  0,
  0,
  -192,
  3759,
  0,
  0,
  -1088,
  3761,
  0,
  0,
  -1600,
  3763,
  0,
  0,
  -192,
  3765,
  0,
  0,
  -64,
  3767,
  0,
  0,
  -576,
  3769,
  0,
  0,
  -2240,
  3771,
  0,
  0,
  -1216,
  3773,
  0,
  0,
  -64,
  3775,
  0,
  0,
  -1472,
  3777,
  0,
  0,
  -64,
  3779,
  0,
  0,
  -64,
  3781,
  0,
  0,
  -576,
  3783,
  0,
  0,
  -2368,
  3785,
  0,
  0,
  -832,
  3787,
  0,
  0,
  -704,
  3789,
  0,
  0,
  -448,
  3791,
  0,
  0,
  -576,
  3793,
  0,
  0,
  -1344,
  3795,
  0,
  0,
  -4672,
  3797,
  0,
  0,
  -192,
  3799,
  0,
  0,
  -320,
  3801,
  0,
  0,
  -320,
  3803,
  0,
  0,
  -832,
  3805,
  0,
  0,
  -576,
  3807,
  0,
  0,
  -64,
  3809,
  0,
  0,
  -448,
  3811,
  0,
  0,
  -192,
  3813,
  0,
  0,
  -64,
  3815,
  0,
  0,
  -960,
  3817,
  0,
  0,
  -1728,
  3819,
  0,
  0,
  -64,
  3821,
  0,
  0,
  -960,
  3823,
  0,
  0,
  -1472,
  3825,
  0,
  0,
  -832,
  3827,
  0,
  0,
  -64,
  3829,
  0,
  0,
  -320,
  3831,
  0,
  0,
  -1472,
  3833,
  0,
  0,
  -960,
  3835,
  0,
  0,
  -3264,
  3837,
  0,
  0,
  -448,
  3839,
  0,
  0,
  -64,
  3841,
  0,
  0,
  -960,
  3843,
  0,
  0,
  -64,
  3845,
  0,
  0,
  -64,
  3847,
  0,
  0,
  -192,
  3849,
  0,
  0,
  -448,
  3851,
  0,
  0,
  -192,
  3853,
  0,
  0,
  -192,
  3855,
  0,
  0,
  -1856,
  3857,
  0,
  0,
  -448,
  3859,
  0,
  0,
  -320,
  3861,
  0,
  0,
  -3520,
  3863,
  0,
  0,
  -448,
  3865,
  0,
  0,
  -192,
  3867,
  0,
  0,
  -832,
  3869,
  0,
  0,
  -960,
  3871,
  0,
  0,
  -960,
  3873,
  0,
  0,
  -320,
  3875,
  0,
  0,
  -576,
  3877,
  0,
  0,
  -192,
  3879,
  0,
  0,
  -320,
  3881,
  0,
  0,
  -448,
  3883,
  0,
  0,
  -320,
  3885,
  0,
  0,
  -704,
  3887,
  0,
  0,
  -1216,
  3889,
  0,
  0,
  -320,
  3891,
  0,
  0,
  -448,
  3893,
  0,
  0,
  -1728,
  3895,
  0,
  0,
  -576,
  3897,
  0,
  0,
  -448,
  3899,
  0,
  0,
  -64,
  3901,
  0,
  0,
  -1472,
  3903,
  0,
  0,
  -320,
  3905,
  0,
  0,
  -64,
  3907,
  0,
  0,
  -1344,
  3909,
  0,
  0,
  -2624,
  3911,
  0,
  0,
  -192,
  3913,
  0,
  0,
  -2880,
  3915,
  0,
  0,
  -1216,
  3917,
  0,
  0,
  -576,
  3919,
  0,
  0,
  -576,
  3921,
  0,
  0,
  -1088,
  3923,
  0,
  0,
  -64,
  3925,
  0,
  0,
  -960,
  3927,
  0,
  0,
  -704,
  3929,
  0,
  0,
  -576,
  3931,
  0,
  0,
  -192,
  3933,
  0,
  0,
  -64,
  3935,
  0,
  0,
  -1216,
  3937,
  0,
  0,
  -704,
  3939,
  0,
  0,
  -448,
  3941,
  0,
  0,
  -576,
  3943,
  0,
  0,
  -1344,
  3945,
  0,
  0,
  -1472,
  3947,
  0,
  0,
  -192,
  3949,
  0,
  0,
  -1728,
  3951,
  0,
  0,
  -1600,
  3953,
  0,
  0,
  -192,
  3955,
  0,
  0,
  -192,
  3957,
  0,
  0,
  -448,
  3959,
  0,
  0,
  -1728,
  3961,
  0,
  0,
  -320,
  3963,
  0,
  0,
  -448,
  3965,
  0,
  0,
  -960,
  3967,
  0,
  0,
  -2496,
  3969,
  0,
  0,
  -448,
  3971,
  0,
  0,
  -1728,
  3973,
  0,
  0,
  -192,
  3975,
  0,
  0,
  -1216,
  3977,
  0,
  0,
  -832,
  3979,
  0,
  0,
  -576,
  3981,
  0,
  0,
  -2752,
  3983,
  0,
  0,
  -192,
  3985,
  0,
  0,
  -704,
  3987,
  0,
  0,
  -704,
  3989,
  0,
  0,
  -64,
  3991,
  0,
  0,
  -192,
  3993,
  0,
  0,
  -1984,
  3995,
  0,
  0,
  -960,
  3997,
  0,
  0,
  -576,
  3999,
  0,
  0,
  -320,
  4001,
  0,
  0,
  -1728,
  4003,
  0,
  0,
  -192,
  4005,
  0,
  0,
  -320,
  4007,
  0,
  0,
  -64,
  4009,
  0,
  0,
  -1728,
  4011,
  0,
  0,
  -320,
  4013,
  0,
  0,
  -832,
  4015,
  0,
  0,
  -704,
  4017,
  0,
  0,
  -64,
  4019,
  0,
  0,
  -576,
  4021,
  0,
  0,
  -192,
  4023,
  0,
  0,
  -64,
  4025,
  0,
  0,
  -64,
  4027,
  0,
  0,
  -1472,
  4029,
  0,
  0,
  -64,
  4031,
  0,
  0,
  -576,
  4033,
  0,
  0,
  -2112,
  4035,
  0,
  0,
  -1600,
  4037,
  0,
  0,
  -1344,
  4039,
  0,
  0,
  -576,
  4041,
  0,
  0,
  -3008,
  4043,
  0,
  0,
  -192,
  4045,
  0,
  0,
  -2240,
  4047,
  0,
  0,
  -2368,
  4049,
  0,
  0,
  -1344,
  4051,
  0,
  0,
  -1728,
  4053,
  0,
  0,
  -704,
  4055,
  0,
  0,
  -1600,
  4057,
  0,
  0,
  -192,
  4059,
  0,
  0,
  -1088,
  4061,
  0,
  0,
  -576,
  4063,
  0,
  0,
  -1344,
  4065,
  0,
  0,
  -64,
  4067,
  0,
  0,
  -448,
  4069,
  0,
  0,
  -320,
  4071,
  0,
  0,
  -320,
  4073,
  0,
  0,
  -448,
  4075,
  0,
  0,
  -192,
  4077,
  0,
  0,
  -448,
  4079,
  0,
  0,
  -960,
  4081,
  0,
  0,
  -320,
  4083,
  0,
  0,
  -2368,
  4085,
  0,
  0,
  -576,
  4087,
  0,
  0,
  -1728,
  4089,
  0,
  0,
  -1216,
  4091,
  0,
  0,
  -1600,
  4093,
  0,
  0,
  -192,
  4095,
  0,
  0,
  -320,
  4097,
  0,
  0,
  -1344,
  4099,
  0,
  0,
  -576,
  4101,
  0,
  0,
  -448,
  4103,
  0,
  0,
  -448,
  4105,
  0,
  0,
  -576,
  4107,
  0,
  0,
  -704,
  4109,
  0,
  0,
  -1344,
  4111,
  0,
  0,
  -320,
  4113,
  0,
  0,
  -320,
  4115,
  0,
  0,
  -832,
  4117,
  0,
  0,
  -704,
  4119,
  0,
  0,
  -64,
  4121,
  0,
  0,
  -192,
  4123,
  0,
  0,
  -320,
  4125,
  0,
  0,
  -704,
  4127,
  0,
  0,
  -64,
  4129,
  0,
  0,
  -3008,
  4131,
  0,
  0,
  -1088,
  4133,
  0,
  0,
  -64,
  4135,
  0,
  0,
  -1856,
  4137,
  0,
  0,
  -1856,
  4139,
  0,
  0,
  -576,
  4141,
  0,
  0,
  -192,
  4143,
  0,
  0,
  -320,
  4145,
  0,
  0,
  -192,
  4147,
  0,
  0,
  -1344,
  4149,
  0,
  0,
  -64,
  4151,
  0,
  0,
  -192,
  4153,
  0,
  0,
  -320,
  4155,
  0,
  0,
  -320,
  4157,
  0,
  0,
  -192,
  4159,
  0,
  0,
  -1344,
  4161,
  0,
  0,
  -448,
  4163,
  0,
  0,
  -192,
  4165,
  0,
  0,
  -192,
  4167,
  0,
  0,
  -448,
  4169,
  0,
  0,
  -576,
  4171,
  0,
  0,
  -192,
  4173,
  0,
  0,
  -704,
  4175,
  0,
  0,
  -960,
  4177,
  0,
  0,
  -3392,
  4179,
  0,
  0,
  -64,
  4181,
  0,
  0,
  -1728,
  4183,
  0,
  0,
  -704,
  4185,
  0,
  0,
  -1472,
  4187,
  0,
  0,
  -448,
  4189,
  0,
  0,
  -704,
  4191,
  0,
  0,
  -448,
  4193,
  0,
  0,
  -64,
  4195,
  0,
  0,
  -1472,
  4197,
  0,
  0,
  -704,
  4199,
  0,
  0,
  -64,
  4201,
  0,
  0,
  -320,
  4203,
  0,
  0,
  -448,
  4205,
  0,
  0,
  -192,
  4207,
  0,
  0,
  -192,
  4209,
  0,
  0,
  -448,
  4211,
  0,
  0,
  -832,
  4213,
  0,
  0,
  -2112,
  4215,
  0,
  0,
  -1472,
  4217,
  0,
  0,
  -1344,
  4219,
  0,
  0,
  -320,
  4221,
  0,
  0,
  -1088,
  4223,
  0,
  0,
  -64,
  4225,
  0,
  0,
  -576,
  4227,
  0,
  0,
  -448,
  4229,
  0,
  0,
  -1344,
  4231,
  0,
  0,
  -576,
  4233,
  0,
  0,
  -832,
  4235,
  0,
  0,
  -576,
  4237,
  0,
  0,
  -4032,
  4239,
  0,
  0,
  -1088,
  4241,
  0,
  0,
  -448,
  4243,
  0,
  0,
  -320,
  4245,
  0,
  0,
  -1600,
  4247,
  0,
  0,
  -1216,
  4249,
  0,
  0,
  -1344,
  4251,
  0,
  0,
  -320,
  4253,
  0,
  0,
  -64,
  4255,
  0,
  0,
  -192,
  4257,
  0,
  0,
  -448,
  4259,
  0,
  0,
  -1344,
  4261,
  0,
  0,
  -1728,
  4263,
  0,
  0,
  -320,
  4265,
  0,
  0,
  -1600,
  4267,
  0,
  0,
  -192,
  4269,
  0,
  0,
  -64,
  4271,
  0,
  0,
  -1216,
  4273,
  0,
  0,
  -960,
  4275,
  0,
  0,
  -1600,
  4277,
  0,
  0,
  -448,
  4279,
  0,
  0,
  -2624,
  4281,
  0,
  0,
  -832,
  4283,
  0,
  0,
  -192,
  4285,
  0,
  0,
  -192,
  4287,
  0,
  0,
  -1472,
  4289,
  0,
  0,
  -1600,
  4291,
  0,
  0,
  -192,
  4293,
  0,
  0,
  -64,
  4295,
  0,
  0,
  -576,
  4297,
  0,
  0,
  -1088,
  4299,
  0,
  0,
  -320,
  4301,
  0,
  0,
  -448,
  4303,
  0,
  0,
  -704,
  4305,
  0,
  0,
  -64,
  4307,
  0,
  0,
  -1344,
  4309,
  0,
  0,
  -960,
  4311,
  0,
  0,
  -1472,
  4313,
  0,
  0,
  -192,
  4315,
  0,
  0,
  -704,
  4317,
  0,
  0,
  -448,
  4319,
  0,
  0,
  -448,
  4321,
  0,
  0,
  -320,
  4323,
  0,
  0,
  -320,
  4325,
  0,
  0,
  -64,
  4327,
  0,
  0,
  -576,
  4329,
  0,
  0,
  -448,
  4331,
  0,
  0,
  -448,
  4333,
  0,
  0,
  -960,
  4335,
  0,
  0,
  -320,
  4337,
  0,
  0,
  -64,
  4339,
  0,
  0,
  -320,
  4341,
  0,
  0,
  -1088,
  4343,
  0,
  0,
  -192,
  4345,
  0,
  0,
  -320,
  4347,
  0,
  0,
  -64,
  4349,
  0,
  0
}; // weak
_UNKNOWN unk_F4240; // weak
char asc_FDFA4[2] = "\b"; // weak
_UNKNOWN unk_FE502; // weak
char asc_119FA0[2] = "\b"; // weak
_UNKNOWN unk_1242BC; // weak
_UNKNOWN unk_1244AC; // weak
_UNKNOWN unk_12DDA8; // weak
_UNKNOWN unk_13775C; // weak
char a0123456789abcd[61] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_bitmain_get_miner_power"; // weak
char aPqt[4] = "PQT"; // weak
char aIn[3] = "in"; // weak
char a01[3] = "01"; // weak
_UNKNOWN unk_13B65C; // weak
_UNKNOWN unk_13B68C; // weak
_UNKNOWN unk_13B6B0; // weak
_DWORD dword_13B6DC[16] = { 1, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1568 }; // weak
_WORD crc_itu_t_table[256] =
{
  0,
  4129,
  8258,
  12387,
  16516,
  20645,
  24774,
  28903,
  -32504,
  -28375,
  -24246,
  -20117,
  -15988,
  -11859,
  -7730,
  -3601,
  4657,
  528,
  12915,
  8786,
  21173,
  17044,
  29431,
  25302,
  -27847,
  -31976,
  -19589,
  -23718,
  -11331,
  -15460,
  -3073,
  -7202,
  9314,
  13379,
  1056,
  5121,
  25830,
  29895,
  17572,
  21637,
  -23190,
  -19125,
  -31448,
  -27383,
  -6674,
  -2609,
  -14932,
  -10867,
  13907,
  9842,
  5649,
  1584,
  30423,
  26358,
  22165,
  18100,
  -18597,
  -22662,
  -26855,
  -30920,
  -2081,
  -6146,
  -10339,
  -14404,
  18628,
  22757,
  26758,
  30887,
  2112,
  6241,
  10242,
  14371,
  -13876,
  -9747,
  -5746,
  -1617,
  -30392,
  -26263,
  -22262,
  -18133,
  23285,
  19156,
  31415,
  27286,
  6769,
  2640,
  14899,
  10770,
  -9219,
  -13348,
  -1089,
  -5218,
  -25735,
  -29864,
  -17605,
  -21734,
  27814,
  31879,
  19684,
  23749,
  11298,
  15363,
  3168,
  7233,
  -4690,
  -625,
  -12820,
  -8755,
  -21206,
  -17141,
  -29336,
  -25271,
  32407,
  28342,
  24277,
  20212,
  15891,
  11826,
  7761,
  3696,
  -97,
  -4162,
  -8227,
  -12292,
  -16613,
  -20678,
  -24743,
  -28808,
  -28280,
  -32343,
  -20022,
  -24085,
  -12020,
  -16083,
  -3762,
  -7825,
  4224,
  161,
  12482,
  8419,
  20484,
  16421,
  28742,
  24679,
  -31815,
  -27752,
  -23557,
  -19494,
  -15555,
  -11492,
  -7297,
  -3234,
  689,
  4752,
  8947,
  13010,
  16949,
  21012,
  25207,
  29270,
  -18966,
  -23093,
  -27224,
  -31351,
  -2706,
  -6833,
  -10964,
  -15091,
  13538,
  9411,
  5280,
  1153,
  29798,
  25671,
  21540,
  17413,
  -22565,
  -18438,
  -30823,
  -26696,
  -6305,
  -2178,
  -14563,
  -10436,
  9939,
  14066,
  1681,
  5808,
  26199,
  30326,
  17941,
  22068,
  -9908,
  -13971,
  -1778,
  -5841,
  -26168,
  -30231,
  -18038,
  -22101,
  22596,
  18533,
  30726,
  26663,
  6336,
  2273,
  14466,
  10403,
  -13443,
  -9380,
  -5313,
  -1250,
  -29703,
  -25640,
  -21573,
  -17510,
  19061,
  23124,
  27191,
  31254,
  2801,
  6864,
  10931,
  14994,
  -722,
  -4849,
  -8852,
  -12979,
  -16982,
  -21109,
  -25112,
  -29239,
  31782,
  27655,
  23652,
  19525,
  15522,
  11395,
  7392,
  3265,
  -4321,
  -194,
  -12451,
  -8324,
  -20581,
  -16454,
  -28711,
  -24584,
  28183,
  32310,
  20053,
  24180,
  11923,
  16050,
  3793,
  7920
}; // weak
_BYTE chCRCHTalbe[256] =
{
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64
}; // weak
_BYTE chCRCLTalbe[256] =
{
  0,
  -64,
  -63,
  1,
  -61,
  3,
  2,
  -62,
  -58,
  6,
  7,
  -57,
  5,
  -59,
  -60,
  4,
  -52,
  12,
  13,
  -51,
  15,
  -49,
  -50,
  14,
  10,
  -54,
  -53,
  11,
  -55,
  9,
  8,
  -56,
  -40,
  24,
  25,
  -39,
  27,
  -37,
  -38,
  26,
  30,
  -34,
  -33,
  31,
  -35,
  29,
  28,
  -36,
  20,
  -44,
  -43,
  21,
  -41,
  23,
  22,
  -42,
  -46,
  18,
  19,
  -45,
  17,
  -47,
  -48,
  16,
  -16,
  48,
  49,
  -15,
  51,
  -13,
  -14,
  50,
  54,
  -10,
  -9,
  55,
  -11,
  53,
  52,
  -12,
  60,
  -4,
  -3,
  61,
  -1,
  63,
  62,
  -2,
  -6,
  58,
  59,
  -5,
  57,
  -7,
  -8,
  56,
  40,
  -24,
  -23,
  41,
  -21,
  43,
  42,
  -22,
  -18,
  46,
  47,
  -17,
  45,
  -19,
  -20,
  44,
  -28,
  36,
  37,
  -27,
  39,
  -25,
  -26,
  38,
  34,
  -30,
  -29,
  35,
  -31,
  33,
  32,
  -32,
  -96,
  96,
  97,
  -95,
  99,
  -93,
  -94,
  98,
  102,
  -90,
  -89,
  103,
  -91,
  101,
  100,
  -92,
  108,
  -84,
  -83,
  109,
  -81,
  111,
  110,
  -82,
  -86,
  106,
  107,
  -85,
  105,
  -87,
  -88,
  104,
  120,
  -72,
  -71,
  121,
  -69,
  123,
  122,
  -70,
  -66,
  126,
  127,
  -65,
  125,
  -67,
  -68,
  124,
  -76,
  116,
  117,
  -75,
  119,
  -73,
  -74,
  118,
  114,
  -78,
  -77,
  115,
  -79,
  113,
  112,
  -80,
  80,
  -112,
  -111,
  81,
  -109,
  83,
  82,
  -110,
  -106,
  86,
  87,
  -105,
  85,
  -107,
  -108,
  84,
  -100,
  92,
  93,
  -99,
  95,
  -97,
  -98,
  94,
  90,
  -102,
  -101,
  91,
  -103,
  89,
  88,
  -104,
  -120,
  72,
  73,
  -119,
  75,
  -117,
  -118,
  74,
  78,
  -114,
  -113,
  79,
  -115,
  77,
  76,
  -116,
  68,
  -124,
  -123,
  69,
  -121,
  71,
  70,
  -122,
  -126,
  66,
  67,
  -125,
  65,
  -127,
  128,
  64
}; // weak
_UNKNOWN *off_14CEF0 = (_UNKNOWN *)0x1D5AD; // weak
_UNKNOWN *off_14CEF4 = (_UNKNOWN *)0x1D595; // weak
char *off_14D378 = "127.0.0.1"; // weak
int opt_bitmain_work_mode = 2; // weak
char *opt_api_description[2] = { "jansson 2.12", "rate" }; // weak
char *off_14D384 = "rate"; // weak
char *old_cmds = "summary"; // weak
char *new_cmds[2] = { "summary", "1.0.0" }; // weak
char *off_14D568[18] =
{
  "ckb_2040",
  "ckb_2042",
  "kda_2110",
  "hns_2130",
  "dcr_1727",
  "dash_1766",
  "eth_2280",
  "eth_2282",
  "ltc_1491",
  "zec_1746",
  "rvn_2044",
  "kas_2380",
  "ks5_2382",
  "x7_2044",
  "unkonw",
  "AT24C02D",
  "AT24C512C",
  "unknow"
}; // weak
int opt_algo = 14; // weak
char *efactor[3] = { "MCT:", "str", "None" }; // weak
int freq_scan_status = 1; // weak
int opterr = 1; // weak
int optind = 1; // weak
int optopt = 63; // weak
char *off_14DE88 = &byte_D9EAC; // weak
int dword_14DE8C = -1; // weak
int dword_14DE90 = -1; // weak
int dword_14DE94 = -1; // weak
void *(*off_14DE98)(size_t size) = &malloc; // weak
void (*off_14DE9C)(void *ptr) = &free; // weak
_UNKNOWN unk_14DEA0; // weak
_UNKNOWN unk_14DEA8; // weak
_UNKNOWN unk_14DEB0; // weak
int dword_14E3A4 = 25; // weak
char *off_14E3AC[18] =
{
  "ckb_2040",
  "ckb_2042",
  "kda_2110",
  "hns_2130",
  "dcr_1727",
  "dash_1766",
  "eth_2280",
  "eth_2282",
  "ltc_1491",
  "zec_1746",
  "rvn_2044",
  "kas_2380",
  "ks5_2382",
  "x7_2044",
  "unkonw",
  "AT24C02D",
  "AT24C512C",
  "unknow"
}; // weak
char *off_14E4A8 = "E1V01B1C1 BIN1"; // weak
char *off_14E5D4 = "E1V01B1C1 BIN1"; // weak
int dword_14E700 = -64; // weak
int dword_14E900 = 25; // weak
int dword_14E904 = 1; // weak
int fan_pwm = 100; // weak
int dword_14F3D0 = 3; // weak
int dword_14F3D4 = 0; // weak
int dword_14F3D8 = 0; // weak
int dword_14F3DC = 5; // weak
int dword_14F3E0 = 0; // weak
int dword_14F3E4 = 5; // weak
int dword_14F3E8 = 0; // weak
int dword_14F3EC = 0; // weak
int dword_14F3F0 = 0; // weak
int dword_14F3F4 = 0; // weak
int dword_14F3F8 = 0; // weak
int dword_14F3FC = 0; // weak
int dword_14F400 = 0; // weak
int dword_14F404 = 2147483648; // weak
int dword_14F408 = 8; // weak
int dword_14F40C = 3; // weak
int dword_14F410 = 2147483647; // weak
char byte_14F510 = '\x01'; // weak
char *off_14F610[19] =
{
  "/etc/errorcode.json",
  "ckb_2040",
  "ckb_2042",
  "kda_2110",
  "hns_2130",
  "dcr_1727",
  "dash_1766",
  "eth_2280",
  "eth_2282",
  "ltc_1491",
  "zec_1746",
  "rvn_2044",
  "kas_2380",
  "ks5_2382",
  "x7_2044",
  "unkonw",
  "AT24C02D",
  "AT24C512C",
  "unknow"
}; // weak
int dword_14F908 = 15; // weak
char *off_14FC00[3] = { "AT24C02D", "AT24C512C", "unknow" }; // weak
char *off_14FC40[3] = { "TMP451", "LM75A", "unknow" }; // weak
char *off_14FC80[3] = { "air_in", "air_out", "unkonw" }; // weak
char *off_14FCA0[3] = { "top", "bottom", "unkonw" }; // weak
_DWORD dword_14FDF8[110] =
{
  1,
  10,
  11,
  20,
  21,
  30,
  31,
  40,
  41,
  50,
  51,
  2,
  9,
  12,
  19,
  22,
  29,
  32,
  39,
  42,
  49,
  52,
  3,
  8,
  13,
  18,
  23,
  28,
  33,
  38,
  43,
  48,
  53,
  4,
  7,
  14,
  17,
  24,
  27,
  34,
  37,
  44,
  47,
  54,
  5,
  6,
  15,
  16,
  25,
  26,
  35,
  36,
  45,
  46,
  55,
  106,
  105,
  96,
  95,
  86,
  85,
  76,
  75,
  66,
  65,
  56,
  107,
  104,
  97,
  94,
  87,
  84,
  77,
  74,
  67,
  64,
  57,
  108,
  103,
  98,
  93,
  88,
  83,
  78,
  73,
  68,
  63,
  58,
  109,
  102,
  99,
  92,
  89,
  82,
  79,
  72,
  69,
  62,
  59,
  110,
  101,
  100,
  91,
  90,
  81,
  80,
  71,
  70,
  61,
  60
}; // weak
_UNKNOWN *sensor_info_ltc_1491 = &sensors_ltc_1491; // weak
__int64 qword_14FFE4 = 8589934592LL; // weak
__int64 qword_14FFEC = 343597383775LL; // weak
__int64 qword_14FFF4 = 8589934552LL; // weak
_UNKNOWN unk_14FFFC; // weak
_UNKNOWN unk_150000; // weak
_UNKNOWN *sensor_info_x7_2044 = &sensors_x7_2044; // weak
__int64 qword_150394 = 25769803776LL; // weak
__int64 qword_15039C = 365072220245LL; // weak
__int64 qword_1503A4 = 8589934572LL; // weak
int dword_1503AC = -64; // weak
_DWORD dword_1505A8[8] = { 0, 0, 0, 0, -1, -1, -1, -1 }; // weak
char *fan_name[8] = { "3", "1", "4", "2", "x", "x", "x", "x" }; // weak
int dword_1505E8 = 412; // weak
int dword_1505EC = -1; // weak
char *lcd_path = "/dev/bitmain-lcd"; // weak
int dword_1505F4 = 1; // weak
_DWORD dword_1505F8[64] =
{
  0,
  1,
  426,
  427,
  1,
  2,
  428,
  429,
  2,
  3,
  430,
  431,
  3,
  4,
  432,
  433,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
_DWORD dword_1506F8[24] =
{
  0,
  0,
  7000,
  1,
  1,
  7000,
  2,
  2,
  7000,
  3,
  3,
  7000,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0
}; // weak
int dword_150758 = 434; // weak
int dword_15075C = 435; // weak
int dword_150760 = 447; // weak
int dword_150764 = 406; // weak
int (*off_150BB8[26])() =
{
  &scan_miner_device_hal,
  &sub_dev_init_hal,
  &dev_init_hal,
  &dev_init_hal_pcba,
  &dev_config_hal,
  &dev_config_one_chain_baud,
  &power_on_hal,
  &power_off_hal,
  &hardreset_hal,
  &chain_reset_high_hal,
  &chain_reset_low_hal,
  &softreset_hal,
  &convert_offset_to_chain_id,
  &dev_send_work_cmd_hal,
  &dev_send_reg_cmd_hal,
  &dev_read_nonce_reg_data_hal,
  &dev_get_reg_fifo_capacity_hal,
  &dev_get_work_fifo_capacity_hal,
  &dev_get_nonce_reg_fifo_size_hal,
  &dev_dma_rw_dispatcher_hal,
  &heartbeat_to_hal,
  &pic_operation_to_hal,
  &cli_ssh_init,
  &dev_is_valid_hal,
  &set_dev_invalid_hal,
  &dev_init_pic_for_one_chain
}; // weak
int dword_150C20 = -1; // weak
int dword_150C24 = -1; // weak
int dword_150C28 = -1; // weak
_DWORD sha256_h0[8] =
{
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
}; // weak
_DWORD sha256_k[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
int listen_sockfd = -1; // weak
char *off_15104C[19] =
{
  "miner_droa",
  "ckb_2040",
  "ckb_2042",
  "kda_2110",
  "hns_2130",
  "dcr_1727",
  "dash_1766",
  "eth_2280",
  "eth_2282",
  "ltc_1491",
  "zec_1746",
  "rvn_2044",
  "kas_2380",
  "ks5_2382",
  "x7_2044",
  "unkonw",
  "AT24C02D",
  "AT24C512C",
  "unknow"
}; // weak
_UNKNOWN xxtea_key; // weak
int stdin; // weak
char byte_15127C; // weak
char byte_151280; // weak
char byte_151281; // weak
char byte_151282; // weak
int dword_151284; // weak
char byte_151288[16]; // weak
int dword_151298; // weak
int dword_15129C; // weak
int dword_1512A0; // weak
double dbl_1512A8; // weak
int dword_1512B0; // weak
double dbl_1512B8; // weak
char opt_api_remote; // weak
char opt_protocol; // weak
char opt_custom_power_mode; // weak
char is_test_pool; // weak
int default_config; // weak
int opt_version_path; // weak
_QWORD max_timeout_value[10]; // weak
char g_miner_version[64]; // weak
char g_miner_compiletime[64]; // weak
char g_miner_type[64]; // weak
int opt_custom_freq; // weak
char opt_custom_voltage_swith; // weak
int opt_custom_voltage; // weak
int opt_target_temp_bonus; // weak
char opt_chip_update; // weak
int chip_update_param; // weak
int opt_machine_type; // weak
int g_chain_number; // weak
int g_hash_rate_5s; // weak
char g_bsn[64]; // weak
char byte_151450; // weak
char byte_151490; // weak
char byte_1514D0; // weak
char pwr_sn; // weak
int dword_151850; // weak
int dword_151854; // weak
_DWORD dword_151858[16]; // weak
char pools_active; // weak
int pools; // weak
int total_pools; // weak
int dword_1518A4; // weak
pthread_mutex_t stru_1518A8; // weak
pthread_cond_t stru_1518C0; // weak
pthread_mutex_t stru_1518F0; // weak
int dword_151908; // weak
int dword_15190C; // weak
int dword_151910; // weak
int dword_151914; // weak
char byte_151918[2304]; // weak
int dword_152218; // weak
int dword_15221C; // weak
char byte_152220; // weak
double dbl_152228[32]; // weak
int dword_152328; // weak
int hashtable_seed; // weak
_UNKNOWN unk_152330; // weak
char byte_152331; // weak
int dword_152334; // weak
int dword_152338; // weak
int dword_15233C; // weak
int dword_152340; // weak
int dword_152344; // weak
int dword_152348; // weak
int dword_15234C; // weak
int dword_152350; // weak
int dword_152354; // weak
int dword_152358; // weak
int dword_15235C; // weak
int dword_152360; // weak
int dword_152364; // weak
int dword_152368; // weak
int dword_15236C; // weak
int dword_152370; // weak
int dword_152374; // weak
int dword_152378; // weak
int dword_15237C; // weak
int dword_152388; // weak
int dword_15238C; // weak
int dword_152390; // weak
int dword_152394; // weak
int dword_152398; // weak
int dword_15239C; // weak
int dword_1523A0; // weak
int dword_1523A4; // weak
int dword_1523A8; // weak
int dword_1523AC; // weak
int dword_1523B0; // weak
int dword_1523B4; // weak
int dword_1523B8; // weak
int dword_1523BC; // weak
int dword_1523C0; // weak
int dword_1523C4; // weak
int dword_1523C8; // weak
int dword_1523CC; // weak
int dword_1523DC; // weak
int dword_1523E0; // weak
int dword_1523E4; // weak
int dword_1523E8; // weak
char byte_1523EC; // weak
char byte_1523ED; // weak
int dword_1523F0; // weak
int dword_1523F4; // weak
int dword_1523F8; // weak
double dbl_152400; // weak
char g_miner_sn[20]; // weak
int g_miner_sn_file_path; // weak
char fan_pwm_fixed; // weak
char byte_152421; // weak
int dword_152424; // weak
char byte_152428; // weak
char byte_15242C; // weak
_UNKNOWN unk_152430; // weak
int dword_152434; // weak
char byte_152438; // weak
int dword_15243C; // weak
char byte_152440; // weak
char byte_152441; // weak
int dword_152444; // weak
int dword_152448; // weak
float flt_152450; // weak
float flt_152454; // weak
float flt_152458; // weak
float flt_15245C; // weak
int dword_152460; // weak
int dword_152464; // weak
int dword_152468; // weak
int dword_15246C; // weak
char byte_15247C; // weak
int dword_152480; // weak
int dword_152484; // weak
int dword_152488; // weak
int dword_15248C; // weak
double dbl_152490; // weak
char byte_152498; // weak
char byte_152499; // weak
char byte_15249A; // weak
char byte_15249B; // weak
char byte_15249C; // weak
char byte_15249D; // weak
char byte_15249E; // weak
char byte_15249F; // weak
char byte_1524A0; // weak
_BYTE algn_1524A1[7]; // weak
int dword_1524A8; // weak
char byte_1524AC; // weak
pthread_mutex_t stru_1524B0; // weak
char byte_1524C8; // weak
int dword_1524CC; // weak
int dword_1524D0; // weak
int dword_1524D4; // weak
int dword_1524D8; // weak
char byte_1524DC; // weak
int dword_1524E0; // weak
pthread_mutex_t miner_6060info_lock; // weak
int dword_152500; // weak
pthread_mutex_t stru_152504; // weak
char byte_15251C; // weak
char byte_15251D; // weak
char byte_152520[]; // weak
int dword_152524; // weak
double dbl_152528; // weak
char byte_152530; // weak
int dword_152534; // weak
double dbl_152538; // weak
char byte_152540; // weak
int dword_152544; // weak
double dbl_152548; // weak
char byte_1528D0; // weak
int dword_1528D4; // weak
double dbl_1528D8; // weak
char byte_1528E0; // weak
int dword_1528E4; // weak
double dbl_1528E8; // weak
char byte_1528F0; // weak
int dword_1528F4; // weak
double dbl_1528F8; // weak
_DWORD dword_152900[896]; // weak
_QWORD qword_153700[160]; // weak
int dword_153C00; // weak
int dword_153C04; // weak
int dword_153C08; // weak
int dword_153C0C; // weak
int dword_153C10; // weak
int dword_153C14; // weak
_BYTE byte_153C1C[16]; // weak
char fan_inited; // weak
int dword_153C30; // weak
_UNKNOWN unk_153C38; // weak
_UNKNOWN unk_153D38; // weak
_UNKNOWN unk_153E38; // weak
_BYTE byte_153F38[16]; // weak
_QWORD qword_153F48[16]; // weak
_UNKNOWN unk_153FC8; // weak
char byte_15F4C8; // weak
_DWORD dword_15F4D8[16]; // weak
_DWORD dword_15F518[16]; // weak
_DWORD dword_15F558[16]; // weak
_DWORD dword_15F598[16]; // weak
_DWORD dword_15F5D8[16]; // weak
_DWORD dword_15F618[16]; // weak
_DWORD dword_15F658[16]; // weak
_DWORD dword_15F698[64]; // weak
int dword_15F798; // weak
pthread_mutex_t stru_15F79C; // weak
_BYTE byte_15F7B4[4]; // weak
_UNKNOWN unk_15F7B8; // weak
_UNKNOWN unk_15F7BC; // weak
pthread_mutex_t stru_15F7C0[3]; // weak
pthread_mutex_t stru_15F808[3]; // weak
_BYTE byte_15F850[4]; // weak
int dword_15F854; // weak
_UNKNOWN pending; // weak
pthread_mutex_t i2c_mutex_all; // weak
char byte_15F930; // weak
int dword_15F934; // weak
int dword_15F938; // weak
_DWORD dword_15F93C[8]; // weak
_DWORD dword_15F95C[8]; // weak
pthread_mutex_t stru_15F97C; // weak
_UNKNOWN unk_15F994; // weak
int dword_15F998; // weak
pthread_mutex_t stru_15F9AC; // weak
int dword_15F9C4; // weak
int dword_15F9C8; // weak
int dword_15F9CC; // weak
int dword_15F9D0; // weak
int (__fastcall *dword_15F9D4[5])(int, bool); // weak
_DWORD dword_15F9E8[32]; // weak
int dword_15FA68; // weak
_DWORD dword_15FA6C[16]; // weak
int dword_15FAAC; // weak
pthread_mutex_t power_mutex; // weak
int dword_15FAD0; // weak
int dword_15FAD4; // weak
int dword_15FAD8; // weak
int dword_15FADC; // weak
_DWORD dword_15FAE8[4]; // weak
__int16 word_15FAF8; // weak
int dword_15FAFC; // weak
char byte_15FB00; // weak
int dword_15FBA0; // weak
char byte_15FBA8; // weak
unsigned __int8 byte_15FBAC[1088]; // weak
_DWORD dword_15FFF0[256]; // weak
int total_chain; // weak
int platform_inited; // weak
unsigned int dword_1603F8[73]; // weak
int dword_16051C; // weak
int dword_160520; // weak
int dword_160524; // weak
pthread_mutex_t stru_160528; // weak
pthread_mutex_t stru_160540; // weak
int dword_160558; // weak
pthread_mutex_t stru_16055C; // weak
int dword_160574; // weak
int dword_160578; // weak
int dword_16057C; // weak
int dword_160580; // weak
int dword_160584; // weak
pthread_mutex_t stru_160588; // weak
_UNKNOWN unk_1605A0; // weak
pthread_mutex_t stru_1605E0[16]; // weak
pthread_mutex_t stru_160760[16]; // weak
int dword_1608E0; // weak
char ExitServer; // weak
int (__fastcall *http_test_case)(_DWORD, _DWORD, _DWORD); // weak
int opt_zlog_conf_file; // weak
int g_zc; // weak
int g_temp_zc; // weak
int g_fan_zc; // weak
int g_hash_zc; // weak
int g_droa_zc; // weak
int dword_16090C; // weak
char byte_160936; // weak
int dword_16096C; // weak
pthread_mutex_t stru_160970; // weak
int dword_160988; // weak
double total_stale; // weak
double total_diff_accepted; // weak
double total_discarded; // weak
double total_diff_rejected; // weak
int total_ro; // weak
int last_getwork; // weak
int total_go; // weak
double total_accepted; // weak
double total_getworks; // weak
double total_diff_stale; // weak
int new_blocks; // weak
int local_work; // weak
double total_rejected; // weak
double total_diff1; // weak
int send_job_timer; // weak
int dword_1609F8; // weak
_UNKNOWN stratum_thr_info; // weak
int thr_info; // weak
int dword_161004; // weak
int dword_161030; // weak
int dword_161060; // weak
int dword_161064; // weak
int dword_161090; // weak
int search_failed_info; // weak
_UNKNOWN reject_reason_map; // weak
int optreset; // weak
int optarg; // weak
int topol_machine; // weak
int dword_161240; // weak
int dword_161244; // weak
int dword_161248; // weak
int dword_16124C; // weak
int dword_161250; // weak
int dword_161254; // weak
char byte_161258; // weak
int dword_16125C; // weak
int dword_161260; // weak
int dword_161264; // weak
int dword_161268; // weak
int dword_16126C; // weak
int dword_161270; // weak
int dword_161274; // weak
int dword_161278; // weak
int dword_16127C; // weak
int dword_161280; // weak
int dword_161284; // weak
float flt_161288; // weak
float flt_16128C; // weak
float flt_161290; // weak
float flt_161294; // weak
int dword_161298; // weak
int dword_16129C; // weak
char byte_1612A0; // weak
char byte_1612A1; // weak
int dword_1612A4; // weak
int dword_1612A8; // weak
int dword_1612AC; // weak
int dword_1612B4; // weak
int dword_1612B8; // weak
_UNKNOWN unk_1612C0; // weak
_UNKNOWN last_blob_x7; // weak
_UNKNOWN last_work_packet; // weak
pthread_mutex_t msg_ack_lock[3]; // weak
_DWORD last_work_len[3]; // weak
pthread_cond_t msg_check_process_wakeup_cond[3]; // weak
_DWORD x7_chip_seed_status[3]; // weak
char last_blob_len; // weak
pthread_mutex_t last_work_lock[3]; // weak
int last_start_nonce_x7; // weak
_UNKNOWN last_seed_hash_x7; // weak
_DWORD g_bitmain_pic_state[32]; // weak
_DWORD g_chain_info[32]; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0001CD9C) --------------------------------------------------------
// Alternative name is '_init'
int init_proc()
{
  return sub_1D520();
}

//----- (0001CDA8) --------------------------------------------------------
void sub_1CDA8()
{
  JUMPOUT(0);
}
// 1CDB4: control flows out of bounds to 0

//----- (0001D020) --------------------------------------------------------
// attributes: thunk
int __fastcall sub_1D020(int ver, const char *filename, struct stat *stat_buf)
{
  return _xstat(ver, filename, stat_buf);
}

//----- (0001D4F0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())_libc_csu_fini,
    a1,
    va);
  abort();
}
// 1D4FA: positive sp value 4 has been found
// 1D50C: variable 'v4' is possibly undefined
// CCFB8: using guessed type int init();
// CCFF4: using guessed type int _libc_csu_fini();

//----- (0001D520) --------------------------------------------------------
int sub_1D520()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 1D144: using guessed type int _gmon_start__(void);

//----- (0001D544) --------------------------------------------------------
int deregister_tm_clones()
{
  return 1380984;
}

//----- (0001D568) --------------------------------------------------------
int register_tm_clones()
{
  return 1380984;
}

//----- (0001D594) --------------------------------------------------------
int sub_1D594()
{
  int result; // r0

  if ( !byte_15127C )
  {
    result = deregister_tm_clones();
    byte_15127C = 1;
  }
  return result;
}
// 15127C: using guessed type char byte_15127C;

//----- (0001D5B0) --------------------------------------------------------
void __fastcall sub_1D5B0(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (0001D618) --------------------------------------------------------
int __fastcall sub_1D618(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 1D684: variable 'v3' is possibly undefined

//----- (0001D730) --------------------------------------------------------
int __fastcall sub_1D730(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0001D7A4) --------------------------------------------------------
int __fastcall sub_1D7A4(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/util.h",
    144,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0001D8C8) --------------------------------------------------------
_BYTE *__fastcall sub_1D8C8(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0001D934) --------------------------------------------------------
uint32_t __cdecl swab32(uint32_t v)
{
  return bswap32(v);
}

//----- (0001D95C) --------------------------------------------------------
int __fastcall sub_1D95C(int result, _DWORD *a2, int a3)
{
  json_t *v3; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v7; // [sp+Ch] [bp-10h]
  int i; // [sp+14h] [bp-8h]

  v7 = (json_t *)result;
  if ( result && a2 )
  {
    for ( i = 0; i < a2[2]; ++i )
    {
      if ( a3 == *(_DWORD *)(a2[4] + 4 * i) )
      {
        v3 = (json_t *)json_string(*(const char **)(a2[3] + 4 * i));
        json_object_set_new(v7, "status", v3);
        v4 = (json_t *)json_integer(*(int *)(a2[4] + 4 * i));
        json_object_set_new(v7, "code", v4);
        v5 = (json_t *)json_string(*(const char **)(a2[5] + 4 * i));
        return json_object_set_new(v7, "msg", v5);
      }
    }
  }
  return result;
}

//----- (0001DAAC) --------------------------------------------------------
_DWORD *__fastcall sub_1DAAC(int a1, _DWORD *a2)
{
  _DWORD *result; // r0
  int v4; // [sp+Ch] [bp-20h] BYREF
  char v5; // [sp+11h] [bp-1Bh]
  _DWORD *v6; // [sp+20h] [bp-Ch]
  int v7; // [sp+24h] [bp-8h]

  v6 = a2;
  result = get_miner_working_status(&v4);
  v7 = 0;
  if ( a1 )
  {
    if ( v5 )
      v7 = -1;
    else
      v7 = 0;
    return (_DWORD *)sub_1D95C(a1, v6, v7);
  }
  return result;
}

//----- (0001DB28) --------------------------------------------------------
_DWORD *__fastcall sub_1DB28(int a1, _DWORD *a2)
{
  _DWORD *result; // r0
  int v4; // [sp+Ch] [bp-20h] BYREF
  char v5; // [sp+12h] [bp-1Ah]
  _DWORD *v6; // [sp+20h] [bp-Ch]
  int v7; // [sp+24h] [bp-8h]

  v6 = a2;
  result = get_miner_working_status(&v4);
  v7 = 0;
  if ( a1 )
  {
    if ( v5 )
      v7 = -1;
    else
      v7 = 0;
    return (_DWORD *)sub_1D95C(a1, v6, v7);
  }
  return result;
}

//----- (0001DBA4) --------------------------------------------------------
_DWORD *__fastcall sub_1DBA4(int a1, _DWORD *a2)
{
  _DWORD *result; // r0
  int v4; // [sp+Ch] [bp-20h] BYREF
  char v5; // [sp+10h] [bp-1Ch]
  _DWORD *v6; // [sp+20h] [bp-Ch]
  int v7; // [sp+24h] [bp-8h]

  v6 = a2;
  result = get_miner_working_status(&v4);
  v7 = 0;
  if ( a1 )
  {
    if ( v5 )
      v7 = -1;
    return (_DWORD *)sub_1D95C(a1, v6, v7);
  }
  return result;
}

//----- (0001DC14) --------------------------------------------------------
_DWORD *__fastcall sub_1DC14(int a1, _DWORD *a2)
{
  _DWORD *result; // r0
  int v4; // [sp+Ch] [bp-20h] BYREF
  _DWORD *v5; // [sp+20h] [bp-Ch]
  int v6; // [sp+24h] [bp-8h]

  v5 = a2;
  result = get_miner_working_status(&v4);
  v6 = 0;
  if ( a1 )
  {
    if ( (_BYTE)v4 )
      v6 = -1;
    if ( BYTE2(v4) )
      v6 = -2;
    return (_DWORD *)sub_1D95C(a1, v5, v6);
  }
  return result;
}

//----- (0001DC98) --------------------------------------------------------
_DWORD *__fastcall sub_1DC98(int a1, _DWORD *a2)
{
  _DWORD *result; // r0
  int v4; // [sp+Ch] [bp-20h] BYREF
  char v5; // [sp+15h] [bp-17h]
  _DWORD *v6; // [sp+20h] [bp-Ch]
  int v7; // [sp+24h] [bp-8h]

  v6 = a2;
  result = get_miner_working_status(&v4);
  v7 = 0;
  if ( a1 )
  {
    if ( v5 )
      v7 = -2;
    return (_DWORD *)sub_1D95C(a1, v6, v7);
  }
  return result;
}

//----- (0001DD08) --------------------------------------------------------
int __fastcall sub_1DD08(int result)
{
  json_t *v1; // r0
  json_t *v2; // [sp+4h] [bp-10h]
  char *v3; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  v2 = (json_t *)result;
  if ( result )
  {
    for ( i = 0; (&off_14D384)[6 * i]; ++i )
    {
      v3 = json_object();
      v1 = (json_t *)json_string((&off_14D384)[6 * i]);
      json_object_set_new((json_t *)v3, "type", v1);
      ((void (__fastcall *)(char *, char **))(&off_14D384)[6 * i + 1])(v3, &(&off_14D384)[6 * i]);
      result = json_array_append_new(v2, (json_t *)v3);
    }
  }
  return result;
}
// 14D384: using guessed type char *off_14D384;

//----- (0001DE14) --------------------------------------------------------
int __fastcall sub_1DE14(int result, const char **a2)
{
  json_t *v2; // r0
  json_t *v3; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v7; // [sp+4h] [bp-30h]
  _QWORD v8[2]; // [sp+Ch] [bp-28h] BYREF
  _QWORD s[2]; // [sp+1Ch] [bp-18h] BYREF
  json_t *v10; // [sp+2Ch] [bp-8h]

  v7 = (json_t *)result;
  memset(s, 0, sizeof(s));
  memset(v8, 0, sizeof(v8));
  if ( result )
  {
    if ( a2 )
    {
      v10 = (json_t *)json_object();
      v2 = (json_t *)json_string("S");
      json_object_set_new(v10, "STATUS", v2);
      v3 = (json_t *)json_integer(dword_151284);
      json_object_set_new(v10, "when", v3);
      snprintf((char *)s, 0x10u, "%s", *a2);
      v4 = (json_t *)json_string((const char *)s);
      json_object_set_new(v10, "Msg", v4);
      snprintf((char *)v8, 0x10u, "%s", a2[1]);
      v5 = (json_t *)json_string((const char *)v8);
      json_object_set_new(v10, "api_version", v5);
      return json_object_set_new(v7, "STATUS", v10);
    }
  }
  return result;
}
// 151284: using guessed type int dword_151284;

//----- (0001DF60) --------------------------------------------------------
int __fastcall sub_1DF60(int result)
{
  json_t *v1; // r0
  json_t *v2; // r0
  json_t *v3; // r0
  json_t *v4; // [sp+4h] [bp-D0h]
  _QWORD v5[8]; // [sp+Ch] [bp-C8h] BYREF
  _QWORD v6[8]; // [sp+4Ch] [bp-88h] BYREF
  _QWORD s[8]; // [sp+8Ch] [bp-48h] BYREF
  json_t *v8; // [sp+CCh] [bp-8h]

  v4 = (json_t *)result;
  memset(s, 0, sizeof(s));
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  if ( result )
  {
    v8 = (json_t *)json_object();
    snprintf((char *)s, 0x40u, "%s", g_miner_version);
    v1 = (json_t *)json_string((const char *)s);
    json_object_set_new(v8, "miner_version", v1);
    snprintf((char *)v6, 0x40u, "%s", g_miner_compiletime);
    v2 = (json_t *)json_string((const char *)v6);
    json_object_set_new(v8, "CompileTime", v2);
    snprintf((char *)v5, 0x40u, "%s", g_miner_type);
    v3 = (json_t *)json_string((const char *)v5);
    json_object_set_new(v8, "type", v3);
    return json_object_set_new(v4, "INFO", v8);
  }
  return result;
}

//----- (0001E110) --------------------------------------------------------
char __fastcall set_elapsed_time_validity(char result)
{
  byte_151280 = result;
  return result;
}
// 151280: using guessed type char byte_151280;

//----- (0001E144) --------------------------------------------------------
int get_miner_elapsed_time()
{
  int result; // r0
  int v1; // r4
  int *v2; // r0
  char *v3; // r0
  char v4[20]; // [sp+10h] [bp-1054h] BYREF
  struct sysinfo info; // [sp+1010h] [bp-54h] BYREF

  result = sysinfo(&info);
  if ( result )
  {
    V_LOCK();
    v1 = *_errno_location();
    v2 = _errno_location();
    v3 = strerror(*v2);
    logfmt_raw(v4, 0x1000u, 0, "Failed to get sysinfo, errno:%u, reason:%s", v1, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_miner_elapsed_time",
      22,
      338,
      40,
      v4);
    result = time(0);
    dword_15129C = result;
  }
  else
  {
    dword_15129C = info.uptime;
  }
  return result;
}
// 1D474: using guessed type int zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151280: using guessed type char byte_151280;
// 151298: using guessed type int dword_151298;
// 15129C: using guessed type int dword_15129C;
// 1608F0: using guessed type int g_zc;

//----- (0001E29C) --------------------------------------------------------
time_t set_miner_start_time()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  time_t result; // r0
  char v4[12]; // [sp+10h] [bp-114Ch] BYREF
  struct sysinfo info; // [sp+1010h] [bp-14Ch] BYREF
  char s[260]; // [sp+1050h] [bp-10Ch] BYREF

  if ( sysinfo(&info) )
  {
    v0 = *_errno_location();
    v1 = _errno_location();
    v2 = strerror(*v1);
    sprintf(s, "Failed to get sysinfo, errno:%u, reason:%s", v0, v2);
    result = time(0);
    dword_151298 = result;
    dword_15129C = result + 1;
  }
  else
  {
    dword_151298 = info.uptime;
    dword_15129C = info.uptime + 1;
    sprintf(s, "%s total_tv_start_sys=%ld total_tv_end_sys=%ld", "set_miner_start_time", info.uptime, info.uptime + 1);
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "%s", s);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/api_new.c",
             147,
             "set_miner_start_time",
             20,
             373,
             60,
             v4);
  }
  return result;
}
// 1D474: using guessed type int zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151298: using guessed type int dword_151298;
// 15129C: using guessed type int dword_15129C;
// 1608F0: using guessed type int g_zc;

//----- (0001E418) --------------------------------------------------------
__int64 api_flush()
{
  local_work = 0;
  new_blocks = 0;
  dword_1512A0 = 0;
  last_getwork = 0;
  total_getworks = 0.0;
  total_stale = 0.0;
  total_discarded = 0.0;
  total_go = 0;
  total_ro = 0;
  total_accepted = 0.0;
  total_rejected = 0.0;
  total_diff1 = 0.0;
  total_diff_accepted = 0.0;
  total_diff_rejected = 0.0;
  total_diff_stale = 0.0;
  dbl_1512A8 = 0.0;
  *(_QWORD *)&dword_1512B0 = 0;
  dbl_1512B8 = 0.0;
  return 0;
}
// 1512A0: using guessed type int dword_1512A0;
// 1512A8: using guessed type double dbl_1512A8;
// 1512B0: using guessed type int dword_1512B0;
// 1512B8: using guessed type double dbl_1512B8;
// 160990: using guessed type double total_stale;
// 160998: using guessed type double total_diff_accepted;
// 1609A0: using guessed type double total_discarded;
// 1609A8: using guessed type double total_diff_rejected;
// 1609B0: using guessed type int total_ro;
// 1609B4: using guessed type int last_getwork;
// 1609B8: using guessed type int total_go;
// 1609C0: using guessed type double total_accepted;
// 1609C8: using guessed type double total_getworks;
// 1609D0: using guessed type double total_diff_stale;
// 1609D8: using guessed type int new_blocks;
// 1609DC: using guessed type int local_work;
// 1609E0: using guessed type double total_rejected;
// 1609E8: using guessed type double total_diff1;

//----- (0001E564) --------------------------------------------------------
int __fastcall update_rate_ideal(int a1)
{
  int result; // r0

  result = strcmp((const char *)(a1 + 304), "D7");
  if ( result )
    return strcmp((const char *)(a1 + 304), "D7e");
  return result;
}

//----- (0001E7B8) --------------------------------------------------------
int get_total_nonce_rate()
{
  int result; // r0
  float v1; // [sp+4h] [bp-18h] BYREF
  _DWORD v2[2]; // [sp+8h] [bp-14h] BYREF
  int i; // [sp+10h] [bp-Ch]
  float v4; // [sp+14h] [bp-8h]

  v2[0] = 0;
  v4 = 0.0;
  v2[1] = get_all_created_runtime(v2);
  result = is_eeprom_loaded();
  if ( result )
  {
    for ( i = 0; i < v2[0]; ++i )
    {
      v1 = 0.0;
      result = api_get_eeprom_nonce_response_rate(i, &v1);
      if ( !result )
        v4 = v4 + v1;
    }
  }
  return result;
}

//----- (0001E8B8) --------------------------------------------------------
void get_total_accept_rate()
{
  int v0; // [sp+4h] [bp-18h]
  int i; // [sp+Ch] [bp-10h]
  int v2; // [sp+10h] [bp-Ch]
  int v3; // [sp+14h] [bp-8h]

  v3 = 0;
  v2 = 0;
  for ( i = 0; i < total_pools; ++i )
  {
    v0 = *(_DWORD *)(pools + 4 * i);
    if ( v0 )
    {
      v3 = (int)((double)v3 + *(double *)(v0 + 1960));
      v2 = (int)((double)v2 + *(double *)(v0 + 1968));
    }
  }
}
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;

//----- (0001E9F4) --------------------------------------------------------
int __fastcall sub_1E9F4(json_t *a1, const char **a2)
{
  double v3; // d0
  char *v4; // r4
  json_t *v5; // r0
  double *v6; // r0
  double *v7; // r0
  double *v8; // r0
  double *v9; // r0
  json_t *v10; // r0
  json_t *v11; // r0
  json_t *v12; // r0
  _BYTE v14[224]; // [sp+10h] [bp-11ACh] BYREF
  const char **v15; // [sp+F0h] [bp-10CCh]
  json_t *v16; // [sp+F4h] [bp-10C8h]
  char v17[68]; // [sp+F8h] [bp-10C4h] BYREF
  double v18; // [sp+10F8h] [bp-C4h] BYREF
  _BYTE v19[12]; // [sp+1100h] [bp-BCh] BYREF
  float v20; // [sp+110Ch] [bp-B0h]
  float v21; // [sp+1110h] [bp-ACh]
  float v22; // [sp+1114h] [bp-A8h]
  float v23; // [sp+1118h] [bp-A4h]
  double v24; // [sp+1120h] [bp-9Ch]
  __int64 v25; // [sp+1130h] [bp-8Ch]
  int v26; // [sp+113Ch] [bp-80h] BYREF
  __int64 v27; // [sp+1140h] [bp-7Ch] BYREF
  float v28; // [sp+1148h] [bp-74h]
  float v29; // [sp+114Ch] [bp-70h]
  double v30; // [sp+1150h] [bp-6Ch]
  __int64 v31; // [sp+1158h] [bp-64h]
  double v32; // [sp+1160h] [bp-5Ch]
  double v33; // [sp+1168h] [bp-54h]
  double v34; // [sp+1170h] [bp-4Ch]
  double v35; // [sp+1178h] [bp-44h]
  double v36; // [sp+1180h] [bp-3Ch]
  const char **v37; // [sp+1188h] [bp-34h]
  _DWORD *all_created_runtime; // [sp+118Ch] [bp-30h]
  int v39; // [sp+1190h] [bp-2Ch]
  json_t *v40; // [sp+1194h] [bp-28h]
  json_t *v41; // [sp+1198h] [bp-24h]
  json_t *v42; // [sp+119Ch] [bp-20h]
  int v43; // [sp+11A0h] [bp-1Ch]
  int i; // [sp+11A4h] [bp-18h]
  void *v45; // [sp+11A8h] [bp-14h]
  void *ptr; // [sp+11ACh] [bp-10h]

  v16 = a1;
  v15 = a2;
  v43 = 0;
  i = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  v27 = 0;
  v26 = 0;
  v39 = frontend_runtime_instance();
  all_created_runtime = get_all_created_runtime(&v26);
  v45 = 0;
  ptr = 0;
  v37 = v15;
  if ( v15 )
  {
    sub_1DE14((int)v16, v37);
    sub_1DF60((int)v16);
    v40 = (json_t *)json_array();
    v42 = (json_t *)json_object();
    read_system_status_from_monitor((int)v19);
    v3 = v24;
    format_hashrate_double(*(const char **)(*(_DWORD *)(v39 + 72) + 16), &v18, (char *)&v27);
    v36 = v3;
    v35 = v3 * v20;
    v34 = v3 * v21;
    v33 = v3 * v22;
    v32 = v3 * v23;
    v31 = v25;
    *(double *)&g_hash_rate_5s = v35;
    if ( v26 > 0 )
    {
      v45 = malloc(224 * v26);
      ptr = malloc(4 * v26);
      for ( i = 0; i < v26; ++i )
      {
        v4 = (char *)v45 + 224 * i;
        read_status_from_monitor(v14, all_created_runtime[i]);
        memcpy(v4, v14, 0xE0u);
        *((_DWORD *)ptr + i) = *(_DWORD *)(all_created_runtime[i] + 252);
      }
    }
    get_miner_elapsed_time();
    v30 = v3;
    get_total_nonce_rate();
    v29 = *(float *)&v3;
    get_total_accept_rate();
    v28 = *(float *)&v3;
    v5 = (json_t *)json_integer((__int64)v30);
    json_object_set_new(v42, "elapsed", v5);
    sub_CCAE4((__int64)(v35 * 100.0));
    v6 = json_real();
    json_object_set_new(v42, "rate_5s", (json_t *)v6);
    sub_CCAE4((__int64)(v32 * 100.0));
    v7 = json_real();
    json_object_set_new(v42, "rate_avg", (json_t *)v7);
    sub_CCAE4((__int64)(v33 * 100.0));
    v8 = json_real();
    json_object_set_new(v42, "rate_30m", (json_t *)v8);
    sub_CCAE4((__int64)(v18 * 100.0));
    v9 = json_real();
    json_object_set_new(v42, "rate_ideal", (json_t *)v9);
    v10 = (json_t *)json_string((const char *)&v27);
    json_object_set_new(v42, "rate_unit", v10);
    v11 = (json_t *)json_integer(v31);
    json_object_set_new(v42, "hw_all", v11);
    v12 = (json_t *)json_integer(*(__int64 *)&dbl_1512B8);
    json_object_set_new(v42, "bestshare", v12);
    v41 = (json_t *)json_array();
    sub_1DD08((int)v41);
    json_object_set_new(v42, "status", v41);
    json_array_append_new(v40, v42);
    json_object_set_new(v16, "SUMMARY", v40);
    if ( v26 > 0 )
    {
      free(ptr);
      free(v45);
    }
    return v43;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "%s: input bad api param", "get_summary");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_summary",
      11,
      525,
      100,
      v17);
    return -2147483646;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512B8: using guessed type double dbl_1512B8;
// 151408: using guessed type int g_hash_rate_5s;
// 1608F0: using guessed type int g_zc;

//----- (0001EF90) --------------------------------------------------------
int __fastcall sub_1EF90(json_t *a1, const char **a2)
{
  float v2; // s0
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v6; // r0
  json_t *v7; // r0
  json_t *v8; // r0
  json_t *v9; // r0
  json_t *v10; // r0
  json_t *v11; // r0
  json_t *v12; // r0
  json_t *v13; // r0
  json_t *v14; // r0
  json_t *v15; // r0
  double *v16; // r0
  json_t *v17; // r0
  json_t *v18; // r0
  json_t *v19; // r0
  json_t *v20; // r0
  char v24[24]; // [sp+1Ch] [bp-1158h] BYREF
  char v25[24]; // [sp+101Ch] [bp-158h] BYREF
  char v26[16]; // [sp+1034h] [bp-140h] BYREF
  char v27[12]; // [sp+1044h] [bp-130h] BYREF
  char v28[128]; // [sp+1050h] [bp-124h] BYREF
  char s[128]; // [sp+10D0h] [bp-A4h] BYREF
  int v30; // [sp+1150h] [bp-24h]
  float v31; // [sp+1154h] [bp-20h]
  unsigned int v32; // [sp+1158h] [bp-1Ch]
  json_t *v33; // [sp+115Ch] [bp-18h]
  json_t *v34; // [sp+1160h] [bp-14h]
  const char **v35; // [sp+1164h] [bp-10h]
  int v36; // [sp+1168h] [bp-Ch]
  int i; // [sp+116Ch] [bp-8h]

  v36 = 0;
  v35 = a2;
  v34 = 0;
  v33 = 0;
  i = 0;
  memset(s, 0, sizeof(s));
  memset(v28, 0, sizeof(v28));
  memset(v27, 0, sizeof(v27));
  memset(v26, 0, sizeof(v26));
  memset(v25, 0, sizeof(v25));
  v32 = 0;
  if ( v35 && a1 )
  {
    sub_1DE14((int)a1, v35);
    sub_1DF60((int)a1);
    v34 = (json_t *)json_array();
    get_total_nonce_rate();
    v31 = v2;
    for ( i = 0; i < total_pools; ++i )
    {
      v30 = *(_DWORD *)(pools + 4 * i);
      if ( v30 )
      {
        v33 = (json_t *)json_object();
        v4 = (json_t *)json_integer(i);
        json_object_set_new(v33, "index", v4);
        memset(s, 0, sizeof(s));
        snprintf(s, 0x80u, "%s", *(const char **)(v30 + 12));
        v5 = (json_t *)json_string(s);
        json_object_set_new(v33, "url", v5);
        memset(v28, 0, sizeof(v28));
        snprintf(v28, 0x80u, "%s", *(const char **)(v30 + 16));
        v6 = (json_t *)json_string(v28);
        json_object_set_new(v33, "user", v6);
        memset(v27, 0, sizeof(v27));
        if ( *(_BYTE *)(v30 + 1904) )
          strcpy(v27, "Dead");
        else
          strcpy(v27, "Alive");
        v7 = (json_t *)json_string(v27);
        json_object_set_new(v33, "status", v7);
        v8 = (json_t *)json_integer(*(int *)(v30 + 4));
        json_object_set_new(v33, "priority", v8);
        v9 = (json_t *)json_integer(*(unsigned int *)(v30 + 1632));
        json_object_set_new(v33, "getworks", v9);
        v10 = (json_t *)json_integer(*(_QWORD *)(v30 + 1928));
        json_object_set_new(v33, "accepted", v10);
        v11 = (json_t *)json_integer(*(_QWORD *)(v30 + 1936));
        json_object_set_new(v33, "rejected", v11);
        v12 = (json_t *)json_integer(*(unsigned int *)(v30 + 1944));
        json_object_set_new(v33, "discarded", v12);
        v13 = (json_t *)json_integer(*(unsigned int *)(v30 + 1640));
        json_object_set_new(v33, "stale", v13);
        memset(v26, 0, sizeof(v26));
        snprintf(v26, 0x10u, "%s", (const char *)(v30 + 1976));
        v14 = (json_t *)json_string(v26);
        json_object_set_new(v33, "diff", v14);
        v15 = (json_t *)json_integer(*(_QWORD *)(v30 + 1992));
        json_object_set_new(v33, "diff1", v15);
        v16 = json_real();
        json_object_set_new(v33, "diffa", (json_t *)v16);
        v17 = (json_t *)json_integer((__int64)*(double *)(v30 + 1968));
        json_object_set_new(v33, "diffr", v17);
        v18 = (json_t *)json_integer((__int64)*(double *)(v30 + 1816));
        json_object_set_new(v33, "diffs", v18);
        v19 = (json_t *)json_integer((__int64)*(double *)(v30 + 1624));
        json_object_set_new(v33, "lsdiff", v19);
        memset(v25, 0, sizeof(v25));
        if ( *(int *)(v30 + 1616) > 0 )
        {
          v32 = time(0) - *(_DWORD *)(v30 + 1616);
          snprintf(v25, 0x18u, "%d:%d:%d", v32 / 0xE10, v32 % 0xE10 / 0x3C, v32 % 0xE10 % 0x3C);
        }
        else
        {
          strcpy(v25, "0");
        }
        v20 = (json_t *)json_string(v25);
        json_object_set_new(v33, "lstime", v20);
        json_array_append_new(v34, v33);
      }
    }
    json_object_set_new(a1, "POOLS", v34);
    return v36;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v24, 0x1000u, 0, "%s: input bad api param", "get_pools");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_pools",
      9,
      602,
      100,
      v24,
      a2);
    return -2147483646;
  }
}
// 1F11C: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;

//----- (0001F6E4) --------------------------------------------------------
int __fastcall sub_1F6E4(json_t *a1, const char **a2)
{
  double v3; // d0
  char *v4; // r4
  json_t *v5; // r0
  double *v6; // r0
  double *v7; // r0
  double *v8; // r0
  double *v9; // r0
  json_t *v10; // r0
  json_t *v11; // r0
  json_t *v12; // r0
  json_t *v13; // r0
  int v14; // r1
  double v15; // d8
  double v16; // r0
  double v17; // d16
  double *v18; // r0
  json_t *v19; // r0
  json_t *v20; // r0
  double *v21; // r0
  double *v22; // r0
  json_t *v23; // r0
  json_t *v24; // r0
  json_t *v25; // r0
  json_t *v26; // r0
  json_t *v27; // r0
  json_t *v28; // r0
  json_t *v29; // r0
  json_t *v30; // r0
  json_t *v31; // r0
  json_t *v32; // r3
  const char *eeprom_chip_sn; // r0
  json_t *v34; // r0
  json_t *v35; // r3
  _BYTE v37[224]; // [sp+10h] [bp-15CCh] BYREF
  const char **v38; // [sp+F0h] [bp-14ECh]
  json_t *v39; // [sp+F4h] [bp-14E8h]
  char v40[32]; // [sp+FCh] [bp-14E0h] BYREF
  int v41; // [sp+10FCh] [bp-4E0h] BYREF
  double v42; // [sp+1100h] [bp-4DCh] BYREF
  int v43; // [sp+1108h] [bp-4D4h] BYREF
  int v44; // [sp+110Ch] [bp-4D0h]
  int v45; // [sp+1110h] [bp-4CCh]
  float v46; // [sp+1114h] [bp-4C8h]
  float v47; // [sp+1118h] [bp-4C4h]
  float v48; // [sp+111Ch] [bp-4C0h]
  float v49; // [sp+1120h] [bp-4BCh]
  double v50; // [sp+1128h] [bp-4B4h]
  __int64 v51; // [sp+1138h] [bp-4A4h]
  char v52[12]; // [sp+1140h] [bp-49Ch] BYREF
  _QWORD v53[3]; // [sp+1540h] [bp-9Ch] BYREF
  float v54; // [sp+1558h] [bp-84h]
  float v55; // [sp+155Ch] [bp-80h]
  __int64 v56; // [sp+1560h] [bp-7Ch]
  double v57; // [sp+1568h] [bp-74h]
  double v58; // [sp+1570h] [bp-6Ch]
  double v59; // [sp+1578h] [bp-64h]
  double v60; // [sp+1580h] [bp-5Ch]
  double v61; // [sp+1588h] [bp-54h]
  int v62; // [sp+1594h] [bp-48h]
  _DWORD *all_created_runtime; // [sp+1598h] [bp-44h]
  json_t *v64; // [sp+159Ch] [bp-40h]
  json_t *v65; // [sp+15A0h] [bp-3Ch]
  json_t *v66; // [sp+15A4h] [bp-38h]
  json_t *v67; // [sp+15A8h] [bp-34h]
  json_t *v68; // [sp+15ACh] [bp-30h]
  const char **v69; // [sp+15B0h] [bp-2Ch]
  int v70; // [sp+15B4h] [bp-28h]
  void *ptr; // [sp+15B8h] [bp-24h]
  void *v72; // [sp+15BCh] [bp-20h]
  int i; // [sp+15C0h] [bp-1Ch]
  signed int j; // [sp+15C4h] [bp-18h]

  v39 = a1;
  v38 = a2;
  v70 = 0;
  i = 0;
  j = 0;
  v69 = a2;
  v68 = 0;
  v67 = 0;
  v66 = 0;
  v65 = 0;
  v64 = 0;
  v53[0] = 0;
  v41 = 0;
  v72 = 0;
  ptr = 0;
  all_created_runtime = get_all_created_runtime(&v41);
  v62 = frontend_runtime_instance();
  if ( v69 && v39 )
  {
    sub_1DE14((int)v39, v69);
    sub_1DF60((int)v39);
    v68 = (json_t *)json_array();
    read_system_status_from_monitor((int)&v43);
    v3 = v50;
    format_hashrate_double(*(const char **)(*(_DWORD *)(v62 + 72) + 16), &v42, (char *)v53);
    v61 = v3;
    v60 = v3 * v46;
    v59 = v3 * v47;
    v58 = v3 * v48;
    v57 = v3 * v49;
    v56 = v51;
    if ( v41 > 0 )
    {
      v72 = malloc(224 * v41);
      ptr = malloc(4 * v41);
      for ( i = 0; i < v41; ++i )
      {
        v4 = (char *)v72 + 224 * i;
        read_status_from_monitor(v37, all_created_runtime[i]);
        memcpy(v4, v37, 0xE0u);
        *((_DWORD *)ptr + i) = *(_DWORD *)(all_created_runtime[i] + 252);
      }
    }
    v67 = (json_t *)json_object();
    get_total_nonce_rate();
    v55 = *(float *)&v3;
    get_total_accept_rate();
    v54 = *(float *)&v3;
    get_miner_elapsed_time();
    *(double *)&v53[2] = v3;
    v5 = (json_t *)json_integer((__int64)v3);
    json_object_set_new(v67, "elapsed", v5);
    sub_CCAE4((__int64)(v60 * 100.0));
    v6 = json_real();
    json_object_set_new(v67, "rate_5s", (json_t *)v6);
    sub_CCAE4((__int64)(v57 * 100.0));
    v7 = json_real();
    json_object_set_new(v67, "rate_avg", (json_t *)v7);
    sub_CCAE4((__int64)(v58 * 100.0));
    v8 = json_real();
    json_object_set_new(v67, "rate_30m", (json_t *)v8);
    sub_CCAE4((__int64)(v42 * 0.972 * 10.0));
    v9 = json_real();
    json_object_set_new(v67, "rate_ideal", (json_t *)v9);
    v10 = (json_t *)json_string((const char *)v53);
    json_object_set_new(v67, "rate_unit", v10);
    v11 = (json_t *)json_integer(v41);
    json_object_set_new(v67, "chain_num", v11);
    v12 = (json_t *)json_integer(v44);
    json_object_set_new(v67, "fan_num", v12);
    v66 = (json_t *)json_array();
    for ( i = 0; i < v44; ++i )
    {
      v13 = (json_t *)json_integer(*(int *)(v45 + 4 * i));
      json_array_append_new(v66, v13);
    }
    json_object_set_new(v67, "fan", v66);
    if ( v56 + *(_QWORD *)&total_diff1 )
    {
      LODWORD(v15) = sub_CCAD4(v56);
      HIDWORD(v15) = v14;
      LODWORD(v16) = sub_CCAD4(v56 + *(_QWORD *)&total_diff1);
      v17 = v15 / v16;
    }
    else
    {
      v17 = 0.0;
    }
    *(double *)&v53[1] = v17;
    sub_CCAE4((__int64)(v17 * 100.0 * 10000.0));
    v18 = json_real();
    json_object_set_new(v67, "hwp_total", (json_t *)v18);
    v65 = (json_t *)json_array();
    for ( i = 0; i < v41; ++i )
    {
      v64 = (json_t *)json_object();
      v19 = (json_t *)json_integer(*((int *)ptr + i));
      json_object_set_new(v64, "index", v19);
      v20 = (json_t *)json_integer(*((int *)v72 + 56 * i + 20));
      json_object_set_new(v64, "freq_avg", v20);
      v58 = v61 * *((float *)v72 + 56 * i + 11);
      v42 = *((double *)v72 + 28 * i + 7) * v61;
      sub_CCAE4((__int64)(v42 * 100.0));
      v21 = json_real();
      json_object_set_new(v64, "rate_ideal", (json_t *)v21);
      sub_CCAE4((__int64)(v58 * 100.0));
      v22 = json_real();
      json_object_set_new(v64, "rate_real", (json_t *)v22);
      v23 = (json_t *)json_integer(*((int *)v72 + 56 * i + 18));
      json_object_set_new(v64, "asic_num", v23);
      if ( *((_DWORD *)v72 + 56 * i + 19) )
      {
        strcpy(v52, *((const char **)v72 + 56 * i + 19));
        for ( j = 0; strlen(v52) > j; ++j )
        {
          if ( v52[j] != 111 && v52[j] != 32 )
            v52[j] = 120;
        }
        v24 = (json_t *)json_string(v52);
        json_object_set_new(v64, "asic", v24);
      }
      v66 = (json_t *)json_array();
      for ( j = 0; j < *((_DWORD *)v72 + 56 * i + 7); ++j )
      {
        v25 = (json_t *)json_integer(0);
        json_array_append_new(v66, v25);
      }
      for ( j = 0; j < *((_DWORD *)v72 + 56 * i + 8); ++j )
      {
        v26 = (json_t *)json_integer(0);
        json_array_append_new(v66, v26);
      }
      json_object_set_new(v64, "temp_pic", v66);
      v66 = (json_t *)json_array();
      for ( j = 0; j < *((_DWORD *)v72 + 56 * i + 7); ++j )
      {
        v27 = (json_t *)json_integer(*(int *)(*((_DWORD *)v72 + 56 * i + 1) + 4 * j));
        json_array_append_new(v66, v27);
      }
      for ( j = 0; j < *((_DWORD *)v72 + 56 * i + 8); ++j )
      {
        v28 = (json_t *)json_integer(*(int *)(*((_DWORD *)v72 + 56 * i + 3) + 4 * j));
        json_array_append_new(v66, v28);
      }
      json_object_set_new(v64, "temp_pcb", v66);
      v66 = (json_t *)json_array();
      for ( j = 0; j < *((_DWORD *)v72 + 56 * i + 7); ++j )
      {
        v29 = (json_t *)json_integer(*(int *)(*((_DWORD *)v72 + 56 * i + 2) + 4 * j));
        json_array_append_new(v66, v29);
      }
      for ( j = 0; j < *((_DWORD *)v72 + 56 * i + 8); ++j )
      {
        v30 = (json_t *)json_integer(*(int *)(*((_DWORD *)v72 + 56 * i + 4) + 4 * j));
        json_array_append_new(v66, v30);
      }
      json_object_set_new(v64, "temp_chip", v66);
      v31 = (json_t *)json_integer(*((_QWORD *)v72 + 28 * i + 11));
      json_object_set_new(v64, "hw", v31);
      if ( is_eeprom_loaded() )
      {
        if ( is_eeprom_loaded() )
          v32 = json_true();
        else
          v32 = (json_t *)json_false();
        json_object_set_new(v64, "eeprom_loaded", v32);
        if ( api_get_eeprom_chip_sn(i) )
        {
          eeprom_chip_sn = (const char *)api_get_eeprom_chip_sn(i);
          v34 = (json_t *)json_string(eeprom_chip_sn);
          json_object_set_new(v64, "sn", v34);
        }
      }
      else
      {
        if ( is_eeprom_loaded() )
          v35 = json_true();
        else
          v35 = (json_t *)json_false();
        json_object_set_new(v64, "eeprom_loaded", v35);
      }
      json_array_append_new(v65, v64);
    }
    json_object_set_new(v67, "chain", v65);
    json_array_append_new(v68, v67);
    json_object_set_new(v39, "STATS", v68);
    if ( v41 > 0 )
    {
      free(ptr);
      free(v72);
    }
    return v70;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v40, 0x1000u, 0, "%s: input bad api param", "get_stats");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_stats",
      9,
      737,
      100,
      v40);
    return -2147483646;
  }
}
// 1FD18: variable 'v14' is possibly undefined
// 1FD4C: variable 'v16' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 1609E8: using guessed type double total_diff1;

//----- (00020588) --------------------------------------------------------
int __fastcall sub_20588(json_t *a1, const char **a2)
{
  char *v3; // r4
  unsigned __int64 v4; // r2
  double v5; // d0
  json_t *v6; // r0
  json_t *v7; // r0
  json_t *v8; // r0
  json_t *v9; // r0
  _BYTE v11[224]; // [sp+10h] [bp-1164h] BYREF
  const char **v12; // [sp+F0h] [bp-1084h]
  json_t *v13; // [sp+F4h] [bp-1080h]
  char v14[56]; // [sp+FCh] [bp-1078h] BYREF
  int v15; // [sp+10FCh] [bp-78h] BYREF
  double v16; // [sp+1100h] [bp-74h] BYREF
  __int64 v17; // [sp+1108h] [bp-6Ch] BYREF
  __int64 s; // [sp+1110h] [bp-64h] BYREF
  json_t *v19; // [sp+1118h] [bp-5Ch]
  json_t *v20; // [sp+111Ch] [bp-58h]
  json_t *v21; // [sp+1120h] [bp-54h]
  json_t *v22; // [sp+1124h] [bp-50h]
  json_t *v23; // [sp+1128h] [bp-4Ch]
  int v24; // [sp+112Ch] [bp-48h]
  _DWORD *all_created_runtime; // [sp+1130h] [bp-44h]
  const char **v26; // [sp+1134h] [bp-40h]
  int v27; // [sp+1138h] [bp-3Ch]
  int v28; // [sp+113Ch] [bp-38h]
  int v29; // [sp+1140h] [bp-34h]
  int v30; // [sp+1144h] [bp-30h]
  void *ptr; // [sp+1148h] [bp-2Ch]
  void *v32; // [sp+114Ch] [bp-28h]
  double v33; // [sp+1150h] [bp-24h]
  int i; // [sp+115Ch] [bp-18h]
  int j; // [sp+1160h] [bp-14h]
  int v36; // [sp+1164h] [bp-10h]

  v13 = a1;
  v12 = a2;
  v30 = 0;
  i = 0;
  j = 0;
  v36 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 0;
  s = 0;
  v17 = 0;
  v33 = 1.0;
  v26 = a2;
  v15 = 0;
  v32 = 0;
  ptr = 0;
  all_created_runtime = get_all_created_runtime(&v15);
  v24 = frontend_runtime_instance();
  v23 = 0;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  if ( v12 && v26 )
  {
    sub_1DE14((int)v13, v26);
    sub_1DF60((int)v13);
    if ( v15 > 0 )
    {
      v32 = malloc(224 * v15);
      ptr = malloc(4 * v15);
      for ( i = 0; i < v15; ++i )
      {
        v3 = (char *)v32 + 224 * i;
        read_status_from_monitor(v11, all_created_runtime[i]);
        memcpy(v3, v11, 0xE0u);
        *((_DWORD *)ptr + i) = *(_DWORD *)(all_created_runtime[i] + 252);
      }
      v4 = *((_QWORD *)v32 + 27);
      if ( v4 > 0x18 )
        LODWORD(v4) = 24;
      v36 = v4;
      v29 = *((_DWORD *)v32 + 52);
      v5 = *((double *)v32 + 7);
      format_hashrate_double(*(const char **)(*(_DWORD *)(v24 + 72) + 16), &v16, (char *)&v17);
      v33 = v5;
    }
    v23 = (json_t *)json_array();
    v20 = (json_t *)json_object();
    if ( !v15 )
    {
      format_hashrate_double(*(const char **)(*(_DWORD *)(v24 + 72) + 16), &v16, (char *)&v17);
      v33 = 1.0;
    }
    v6 = (json_t *)json_string((const char *)&v17);
    json_object_set_new(v20, "unit", v6);
    v22 = (json_t *)json_array();
    for ( i = 0; i < v36; ++i )
    {
      memset(&s, 0, sizeof(s));
      snprintf((char *)&s, 8u, "%dmin", 15 * (i + 1));
      v7 = (json_t *)json_string((const char *)&s);
      json_array_append_new(v22, v7);
    }
    json_object_set_new(v20, "xAxis", v22);
    v22 = (json_t *)json_array();
    for ( i = 0; i < v15; ++i )
    {
      v21 = (json_t *)json_object();
      memset(&s, 0, sizeof(s));
      snprintf((char *)&s, 8u, "chain%d", *((_DWORD *)ptr + i));
      v8 = (json_t *)json_string((const char *)&s);
      json_object_set_new(v21, "name", v8);
      v19 = (json_t *)json_array();
      for ( j = 0; j < v36; ++j )
      {
        v16 = *((float *)v32 + 56 * i + j + 28) * v33;
        v9 = (json_t *)json_integer((__int64)v16);
        json_array_append_new(v19, v9);
      }
      json_object_set_new(v21, "data", v19);
      json_array_append_new(v22, v21);
    }
    json_object_set_new(v20, "series", v22);
    json_array_append_new(v23, v20);
    json_object_set_new(v13, "RATE", v23);
    if ( v15 > 0 )
    {
      free(ptr);
      free(v32);
    }
    return v30;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "%s: input bad api param", "get_rate");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_rate",
      8,
      925,
      100,
      v14);
    return -2147483646;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00020B4C) --------------------------------------------------------
int sub_20B4C()
{
  int result; // r0
  char v1[12]; // [sp+10h] [bp-100Ch] BYREF
  int v2; // [sp+1010h] [bp-Ch]
  int v3; // [sp+1014h] [bp-8h]

  v2 = 0;
  v3 = 0;
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "START %s", "load_default_config_without_restart");
  V_UNLOCK();
  result = zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/api_new.c",
             147,
             "load_default_config_without_restart",
             35,
             1000,
             20,
             v1);
  if ( default_config )
  {
    result = access((const char *)default_config, 4);
    if ( !result )
    {
      result = judge_load_config((const char *)default_config);
      v3 = result;
    }
  }
  if ( (v3 & 1) != 0 )
    return reload_pool();
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512C4: using guessed type int default_config;
// 1608F0: using guessed type int g_zc;

//----- (00020C5C) --------------------------------------------------------
int __fastcall sub_20C5C(json_t *a1, const char **a2)
{
  char v6[48]; // [sp+1Ch] [bp-1030h] BYREF
  int v7; // [sp+101Ch] [bp-30h] BYREF
  __int64 v8; // [sp+1020h] [bp-2Ch]
  json_t *v9; // [sp+1028h] [bp-24h]
  const char **v10; // [sp+102Ch] [bp-20h]
  int v11; // [sp+1030h] [bp-1Ch]
  int v12; // [sp+1034h] [bp-18h]
  void *all_created_runtime; // [sp+1038h] [bp-14h]
  int v14; // [sp+103Ch] [bp-10h]
  int v15; // [sp+1040h] [bp-Ch]
  int v16; // [sp+1044h] [bp-8h]

  v15 = 0;
  v16 = 0;
  v8 = 0;
  v7 = 0;
  v14 = frontend_runtime_instance();
  all_created_runtime = get_all_created_runtime(&v7);
  v12 = 0;
  v11 = 0;
  v10 = a2;
  if ( a2 )
  {
    sub_1DE14((int)a1, v10);
    sub_1DF60((int)a1);
    v9 = 0;
    v9 = (json_t *)json_array();
    sweep_get_error_code(v9);
    json_object_set_new(a1, "WARNING", v9);
    return v15;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "%s: input bad api param", "get_warnings");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_warnings",
      12,
      1030,
      100,
      v6);
    return -2147483646;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00020DF0) --------------------------------------------------------
int __fastcall sub_20DF0(int a1, int a2)
{
  char v6[8]; // [sp+1Ch] [bp-1008h] BYREF
  int v7; // [sp+101Ch] [bp-8h]

  v7 = 0;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "<<<<<<<<<<<<<<<<<<<<exec %s start>>>>>>>>>>>>>>>>", "reload_config");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "reload_config",
    13,
    1048,
    20,
    v6,
    a2,
    a1);
  if ( strcmp(byte_151288, off_14D378) )
    return -2147483643;
  sub_20B4C();
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "<<<<<<<<<<<<<<<<<<<<exec %s end>>>>>>>>>>>>>>>>>>", "reload_config");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "reload_config",
    13,
    1055,
    20,
    v6);
  return v7;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D378: using guessed type char *off_14D378;
// 1608F0: using guessed type int g_zc;

//----- (00020F64) --------------------------------------------------------
int __fastcall sub_20F64(int result, char a2, int a3, const char *a4)
{
  const char *v4; // r3
  json_t *v5; // r0
  json_t *v6; // r0
  json_t *v7; // r0
  json_t *v8; // r0
  json_t *v9; // r0
  json_t *v10; // r0
  json_t *v14; // [sp+Ch] [bp-48h]
  _QWORD v15[6]; // [sp+14h] [bp-40h] BYREF
  char s[4]; // [sp+44h] [bp-10h] BYREF
  json_t *v17; // [sp+48h] [bp-Ch]
  json_t *v18; // [sp+4Ch] [bp-8h]

  v14 = (json_t *)result;
  v18 = 0;
  v17 = 0;
  *(_WORD *)s = 0;
  memset(v15, 0, sizeof(v15));
  if ( result && a4 )
  {
    v18 = (json_t *)json_array();
    v17 = (json_t *)json_object();
    if ( a2 )
      v4 = "S";
    else
      v4 = "E";
    snprintf(s, 2u, "%s", v4);
    v5 = (json_t *)json_string(s);
    json_object_set_new(v17, "STATUS", v5);
    v6 = (json_t *)json_integer(dword_151284);
    json_object_set_new(v17, "When", v6);
    v7 = (json_t *)json_integer(a3);
    json_object_set_new(v17, "Code", v7);
    if ( a3 == 7 )
      snprintf((char *)v15, 0x30u, a4, total_pools);
    else
      snprintf((char *)v15, 0x30u, "%s", a4);
    v8 = (json_t *)json_string((const char *)v15);
    json_object_set_new(v17, "Msg", v8);
    v9 = (json_t *)json_string(opt_api_description[0]);
    json_object_set_new(v17, "Description", v9);
    json_array_append_new(v18, v17);
    result = json_object_set_new(v14, "STATUS", v18);
    if ( a2 != 1 )
    {
      v10 = (json_t *)json_integer(1);
      return json_object_set_new(v14, "id", v10);
    }
  }
  return result;
}
// 14D380: using guessed type char *opt_api_description[2];
// 151284: using guessed type int dword_151284;
// 1518A0: using guessed type int total_pools;

//----- (000211A8) --------------------------------------------------------
int __fastcall sub_211A8(json_t *a1, int a2)
{
  double v3; // d0
  double v4; // r0
  double v5; // d16
  double v6; // d16
  json_t *v7; // r0
  double *v8; // r0
  double *v9; // r0
  double *v10; // r0
  json_t *v11; // r0
  json_t *v12; // r0
  json_t *v13; // r0
  json_t *v14; // r0
  json_t *v15; // r0
  double *v16; // r0
  json_t *v17; // r0
  json_t *v18; // r0
  json_t *v19; // r0
  json_t *v20; // r0
  json_t *v21; // r0
  json_t *v22; // r0
  double *v23; // r0
  double *v24; // r0
  double *v25; // r0
  double *v26; // r0
  double *v27; // r0
  json_t *v28; // r0
  int v29; // r1
  double v30; // d8
  double v31; // r0
  double v32; // d16
  double *v33; // r0
  double v34; // d8
  double v35; // r0
  double v36; // d16
  double *v37; // r0
  double v38; // d16
  double *v39; // r0
  double v40; // d16
  double *v41; // r0
  json_t *v42; // r0
  json_t *v43; // r0
  json_t *v44; // r0
  json_t *v45; // r0
  json_t *v46; // r0
  char v49[80]; // [sp+24h] [bp-1190h] BYREF
  int v50; // [sp+1024h] [bp-190h] BYREF
  double v51; // [sp+1028h] [bp-18Ch] BYREF
  char v52[32]; // [sp+1034h] [bp-180h] BYREF
  char v53[32]; // [sp+1054h] [bp-160h] BYREF
  char v54[32]; // [sp+1074h] [bp-140h] BYREF
  char v55[32]; // [sp+1094h] [bp-120h] BYREF
  char v56[32]; // [sp+10B4h] [bp-100h] BYREF
  char v57[12]; // [sp+10D4h] [bp-E0h] BYREF
  _BYTE v58[12]; // [sp+10E0h] [bp-D4h] BYREF
  float v59; // [sp+10ECh] [bp-C8h]
  float v60; // [sp+10F0h] [bp-C4h]
  float v61; // [sp+10F4h] [bp-C0h]
  float v62; // [sp+10F8h] [bp-BCh]
  double v63; // [sp+1100h] [bp-B4h]
  __int64 v64; // [sp+1110h] [bp-A4h]
  double v65; // [sp+1118h] [bp-9Ch]
  double v66; // [sp+1120h] [bp-94h]
  double v67; // [sp+1128h] [bp-8Ch]
  double v68; // [sp+1130h] [bp-84h]
  float v69; // [sp+1138h] [bp-7Ch]
  float v70; // [sp+113Ch] [bp-78h]
  double v71; // [sp+1140h] [bp-74h]
  double v72; // [sp+1148h] [bp-6Ch]
  double v73; // [sp+1150h] [bp-64h]
  __int64 v74; // [sp+1158h] [bp-5Ch]
  double v75; // [sp+1160h] [bp-54h]
  double v76; // [sp+1168h] [bp-4Ch]
  double v77; // [sp+1170h] [bp-44h]
  double v78; // [sp+1178h] [bp-3Ch]
  double v79; // [sp+1180h] [bp-34h]
  int v80; // [sp+1188h] [bp-2Ch]
  void *all_created_runtime; // [sp+118Ch] [bp-28h]
  int v82; // [sp+1190h] [bp-24h]
  json_t *v83; // [sp+1194h] [bp-20h]
  json_t *v84; // [sp+1198h] [bp-1Ch]
  int v85; // [sp+119Ch] [bp-18h]

  v85 = 0;
  v84 = 0;
  v83 = 0;
  v82 = a2;
  v50 = 0;
  all_created_runtime = get_all_created_runtime(&v50);
  v80 = frontend_runtime_instance();
  if ( v82 && a1 )
  {
    sub_20F64((int)a1, 1, 11, *(const char **)(v82 + 8));
    v84 = (json_t *)json_array();
    v83 = (json_t *)json_object();
    read_system_status_from_monitor((int)v58);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v80 + 72) + 16), v56);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v80 + 72) + 16), v55);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v80 + 72) + 16), v54);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v80 + 72) + 16), v53);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v80 + 72) + 16), v52);
    v3 = v63;
    format_hashrate_double(*(const char **)(*(_DWORD *)(v80 + 72) + 16), &v51, v57);
    v79 = v3;
    v78 = v3 * v59;
    v77 = v3 * v60;
    v76 = v3 * v61;
    v75 = v3 * v62;
    v74 = v64;
    get_miner_elapsed_time();
    v73 = v3;
    LODWORD(v4) = sub_CCAE4(*(__int64 *)&total_accepted);
    if ( v73 == 0.0 )
      v5 = 1.0;
    else
      v5 = v73;
    v72 = v4 / v5 * 60.0;
    if ( v73 == 0.0 )
      v6 = 1.0;
    else
      v6 = v73;
    v71 = (total_diff_accepted + total_diff_rejected + total_diff_stale) / v6 * 60.0;
    get_total_nonce_rate();
    v70 = *(float *)&v3;
    get_total_accept_rate();
    v69 = *(float *)&v3;
    v7 = (json_t *)json_integer((__int64)v73);
    json_object_set_new(v83, "Elapsed", v7);
    sub_CCAE4((__int64)(v78 * 100.0));
    v8 = json_real();
    json_object_set_new(v83, "GHS 5s", (json_t *)v8);
    sub_CCAE4((__int64)(v75 * 100.0));
    v9 = json_real();
    json_object_set_new(v83, "GHS av", (json_t *)v9);
    sub_CCAE4((__int64)(v76 * 100.0));
    v10 = json_real();
    json_object_set_new(v83, "GHS 30m", (json_t *)v10);
    v11 = (json_t *)json_integer((unsigned int)dword_1512A0);
    json_object_set_new(v83, "Found Blocks", v11);
    v12 = (json_t *)json_integer(*(__int64 *)&total_getworks);
    json_object_set_new(v83, "Getwork", v12);
    v13 = (json_t *)json_integer(*(__int64 *)&total_accepted);
    json_object_set_new(v83, "Accepted", v13);
    v14 = (json_t *)json_integer(*(__int64 *)&total_rejected);
    json_object_set_new(v83, "Rejected", v14);
    v15 = (json_t *)json_integer(v74);
    json_object_set_new(v83, "Hardware Errors", v15);
    sub_CCAE4((__int64)(v72 * 100.0));
    v16 = json_real();
    json_object_set_new(v83, "Utility", (json_t *)v16);
    v17 = (json_t *)json_integer(*(__int64 *)&total_discarded);
    json_object_set_new(v83, "Discarded", v17);
    v18 = (json_t *)json_integer(*(__int64 *)&total_stale);
    json_object_set_new(v83, "Stale", v18);
    v19 = (json_t *)json_integer((unsigned int)total_go);
    json_object_set_new(v83, "Get Failures", v19);
    v20 = (json_t *)json_integer((unsigned int)local_work);
    json_object_set_new(v83, "Local Work", v20);
    v21 = (json_t *)json_integer((unsigned int)total_ro);
    json_object_set_new(v83, "Remote Failures", v21);
    v22 = (json_t *)json_integer((unsigned int)new_blocks);
    json_object_set_new(v83, "Network Blocks", v22);
    sub_CCAE4((__int64)(dbl_1512A8 * 100.0));
    v23 = json_real();
    json_object_set_new(v83, "Total MH", (json_t *)v23);
    v24 = json_real();
    json_object_set_new(v83, "Work Utility", (json_t *)v24);
    sub_CCAE4((__int64)(total_diff_accepted * 100.0));
    v25 = json_real();
    json_object_set_new(v83, "Difficulty Accepted", (json_t *)v25);
    sub_CCAE4((__int64)(total_diff_rejected * 100.0));
    v26 = json_real();
    json_object_set_new(v83, "Difficulty Rejected", (json_t *)v26);
    sub_CCAE4((__int64)(total_diff_stale * 100.0));
    v27 = json_real();
    json_object_set_new(v83, "Difficulty Stale", (json_t *)v27);
    v28 = (json_t *)json_integer(*(__int64 *)&dbl_1512B8);
    json_object_set_new(v83, "Best Share", v28);
    if ( v74 + *(_QWORD *)&total_diff1 )
    {
      LODWORD(v30) = sub_CCAD4(v74);
      HIDWORD(v30) = v29;
      LODWORD(v31) = sub_CCAD4(v74 + *(_QWORD *)&total_diff1);
      v32 = v30 / v31;
    }
    else
    {
      v32 = 0.0;
    }
    v68 = v32;
    sub_CCAE4((__int64)(v32 * 100.0));
    v33 = json_real();
    json_object_set_new(v83, "Device Hardware%", (json_t *)v33);
    if ( *(_QWORD *)&total_diff1 )
    {
      v34 = total_diff_rejected;
      LODWORD(v35) = sub_CCAE4(*(__int64 *)&total_diff1);
      v36 = v34 / v35;
    }
    else
    {
      v36 = 0.0;
    }
    v67 = v36;
    sub_CCAE4((__int64)(v36 * 100.0));
    v37 = json_real();
    json_object_set_new(v83, "Device Rejected%", (json_t *)v37);
    if ( total_diff_accepted + total_diff_rejected + total_diff_stale == 0.0 )
      v38 = 0.0;
    else
      v38 = total_diff_rejected / (total_diff_accepted + total_diff_rejected + total_diff_stale);
    v66 = v38;
    sub_CCAE4((__int64)(v38 * 100.0));
    v39 = json_real();
    json_object_set_new(v83, "Pool Rejected%", (json_t *)v39);
    if ( total_diff_accepted + total_diff_rejected + total_diff_stale == 0.0 )
      v40 = 0.0;
    else
      v40 = total_diff_stale / (total_diff_accepted + total_diff_rejected + total_diff_stale);
    v65 = v40;
    sub_CCAE4((__int64)(v40 * 100.0));
    v41 = json_real();
    json_object_set_new(v83, "Pool Stale%", (json_t *)v41);
    v42 = (json_t *)json_integer(last_getwork);
    json_object_set_new(v83, "Last getwork", v42);
    v43 = (json_t *)json_string(v56);
    json_object_set_new(v83, "RT HASHRATE", v43);
    v44 = (json_t *)json_string(v53);
    json_object_set_new(v83, "AV HASHRATE", v44);
    v45 = (json_t *)json_string(v52);
    json_object_set_new(v83, "THEORY HASHRATE", v45);
    json_array_append_new(v84, v83);
    json_object_set_new(a1, "SUMMARY", v84);
    v46 = (json_t *)json_integer(1);
    json_object_set_new(a1, "id", v46);
    return v85;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v49, 0x1000u, 0, "%s: input bad api param", "get_summary_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_summary_old",
      15,
      1123,
      100,
      v49);
    return -2147483646;
  }
}
// 211A8: too many cbuild loops
// 21494: variable 'v4' is possibly undefined
// 21AC0: variable 'v29' is possibly undefined
// 21AF4: variable 'v31' is possibly undefined
// 21B94: variable 'v35' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512A0: using guessed type int dword_1512A0;
// 1512A8: using guessed type double dbl_1512A8;
// 1512B8: using guessed type double dbl_1512B8;
// 1608F0: using guessed type int g_zc;
// 160990: using guessed type double total_stale;
// 160998: using guessed type double total_diff_accepted;
// 1609A0: using guessed type double total_discarded;
// 1609A8: using guessed type double total_diff_rejected;
// 1609B0: using guessed type int total_ro;
// 1609B4: using guessed type int last_getwork;
// 1609B8: using guessed type int total_go;
// 1609C0: using guessed type double total_accepted;
// 1609C8: using guessed type double total_getworks;
// 1609D0: using guessed type double total_diff_stale;
// 1609D8: using guessed type int new_blocks;
// 1609DC: using guessed type int local_work;
// 1609E0: using guessed type double total_rejected;
// 1609E8: using guessed type double total_diff1;

//----- (00021EB0) --------------------------------------------------------
int __fastcall sub_21EB0(json_t *a1, int a2)
{
  json_t *v3; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v6; // r0
  json_t *v7; // r0
  json_t *v8; // r0
  json_t *v9; // r0
  json_t *v10; // r0
  json_t *v11; // r0
  json_t *v12; // r0
  json_t *v13; // r0
  json_t *v14; // r0
  json_t *v15; // r0
  json_t *v16; // r0
  json_t *v17; // r0
  json_t *v18; // r0
  json_t *v19; // r0
  json_t *v20; // r0
  json_t *v21; // r0
  double *v22; // r0
  double *v23; // r0
  double *v24; // r0
  double *v25; // r0
  json_t *v26; // r3
  json_t *v27; // r0
  json_t *v28; // r0
  json_t *v29; // r0
  double *v30; // r0
  double v31; // d16
  double *v32; // r0
  double v33; // d16
  double *v34; // r0
  json_t *v35; // r0
  char v39[32]; // [sp+24h] [bp-1160h] BYREF
  char v40[24]; // [sp+1024h] [bp-160h] BYREF
  char v41[12]; // [sp+103Ch] [bp-148h] BYREF
  char v42[128]; // [sp+1048h] [bp-13Ch] BYREF
  char s[128]; // [sp+10C8h] [bp-BCh] BYREF
  double v44; // [sp+1148h] [bp-3Ch]
  int v45; // [sp+1150h] [bp-34h]
  int v46; // [sp+1154h] [bp-30h]
  __int64 v47; // [sp+1158h] [bp-2Ch]
  double v48; // [sp+1160h] [bp-24h]
  unsigned int v49; // [sp+116Ch] [bp-18h]
  json_t *v50; // [sp+1170h] [bp-14h]
  json_t *v51; // [sp+1174h] [bp-10h]
  int v52; // [sp+1178h] [bp-Ch]
  int i; // [sp+117Ch] [bp-8h]

  v52 = 0;
  v51 = 0;
  v50 = 0;
  i = 0;
  memset(s, 0, sizeof(s));
  memset(v42, 0, sizeof(v42));
  memset(v41, 0, sizeof(v41));
  memset(v40, 0, sizeof(v40));
  v49 = 0;
  v48 = 0.0;
  v47 = 0;
  v46 = a2;
  if ( a2 && a1 )
  {
    if ( total_pools )
    {
      sub_20F64((int)a1, 1, 7, *(const char **)(v46 + 8));
      v51 = (json_t *)json_array();
      for ( i = 0; i < total_pools; ++i )
      {
        v45 = *(_DWORD *)(pools + 4 * i);
        v50 = (json_t *)json_object();
        v3 = (json_t *)json_integer(i);
        json_object_set_new(v50, "POOL", v3);
        memset(s, 0, sizeof(s));
        snprintf(s, 0x80u, "%s", *(const char **)(v45 + 12));
        v4 = (json_t *)json_string(s);
        json_object_set_new(v50, "URL", v4);
        memset(v41, 0, sizeof(v41));
        if ( *(_BYTE *)(v45 + 1904) )
          strcpy(v41, "Deed");
        else
          strcpy(v41, "Alive");
        v5 = (json_t *)json_string(v41);
        json_object_set_new(v50, "Status", v5);
        v6 = (json_t *)json_integer(*(int *)(v45 + 4));
        json_object_set_new(v50, "Priority", v6);
        v7 = (json_t *)json_integer(*(int *)(v45 + 1636));
        json_object_set_new(v50, "Quota", v7);
        v8 = (json_t *)json_string("N");
        json_object_set_new(v50, "Long Poll", v8);
        v9 = (json_t *)json_integer(*(unsigned int *)(v45 + 1632));
        json_object_set_new(v50, "Getworks", v9);
        v10 = (json_t *)json_integer(*(_QWORD *)(v45 + 1928));
        json_object_set_new(v50, "Accepted", v10);
        v11 = (json_t *)json_integer(*(_QWORD *)(v45 + 1936));
        json_object_set_new(v50, "Rejected", v11);
        v12 = (json_t *)json_integer(*(unsigned int *)(v45 + 1944));
        json_object_set_new(v50, "Discarded", v12);
        v13 = (json_t *)json_integer(*(unsigned int *)(v45 + 1640));
        json_object_set_new(v50, "Stale", v13);
        v14 = (json_t *)json_integer(*(unsigned int *)(v45 + 1948));
        json_object_set_new(v50, "Get Failures", v14);
        v15 = (json_t *)json_integer(*(unsigned int *)(v45 + 1952));
        json_object_set_new(v50, "Remote Failures", v15);
        memset(v42, 0, sizeof(v42));
        snprintf(v42, 0x80u, "%s", *(const char **)(v45 + 16));
        v16 = (json_t *)json_string(v42);
        json_object_set_new(v50, "User", v16);
        memset(v40, 0, sizeof(v40));
        if ( *(int *)(v45 + 1616) > 0 )
        {
          v49 = time(0) - *(_DWORD *)(v45 + 1616);
          snprintf(v40, 0x18u, "%d:%d:%d", v49 / 0xE10, v49 % 0xE10 / 0x3C, v49 % 0xE10 % 0x3C);
        }
        else
        {
          strcpy(v40, "0");
        }
        v17 = (json_t *)json_string(v40);
        json_object_set_new(v50, "Last Share Time", v17);
        sprintf((char *)(v45 + 1976), "%8.4f", *(double *)(v45 + 1808));
        v18 = (json_t *)json_string((const char *)(v45 + 1976));
        json_object_set_new(v50, "Diff", v18);
        v19 = (json_t *)json_integer(*(_QWORD *)(v45 + 1992));
        json_object_set_new(v50, "Diff1 Shares", v19);
        v20 = (json_t *)json_string(byte_CD240);
        json_object_set_new(v50, "Proxy Type", v20);
        v21 = (json_t *)json_string(byte_CD240);
        json_object_set_new(v50, "Proxy", v21);
        sub_CCAE4((__int64)(*(double *)(v45 + 1960) * 100.0));
        v22 = json_real();
        json_object_set_new(v50, "Difficulty Accepted", (json_t *)v22);
        sub_CCAE4((__int64)(*(double *)(v45 + 1968) * 100.0));
        v23 = json_real();
        json_object_set_new(v50, "Difficulty Rejected", (json_t *)v23);
        sub_CCAE4((__int64)(*(double *)(v45 + 1816) * 100.0));
        v24 = json_real();
        json_object_set_new(v50, "Difficulty Stale", (json_t *)v24);
        sub_CCAE4((__int64)(*(double *)(v45 + 1624) * 100.0));
        v25 = json_real();
        json_object_set_new(v50, "Last Share Difficulty", (json_t *)v25);
        if ( *(_BYTE *)(v45 + 28) )
          v26 = json_true();
        else
          v26 = (json_t *)json_false();
        json_object_set_new(v50, "Has Stratum", v26);
        v27 = json_true();
        json_object_set_new(v50, "Stratum Active", v27);
        v28 = (json_t *)json_string(byte_CD240);
        json_object_set_new(v50, "Stratum URL", v28);
        v29 = (json_t *)json_false();
        json_object_set_new(v50, "Has GBT", v29);
        v30 = json_real();
        json_object_set_new(v50, "Best Share", (json_t *)v30);
        if ( *(double *)(v45 + 1960) + *(double *)(v45 + 1968) + *(double *)(v45 + 1816) == 0.0 )
          v31 = 0.0;
        else
          v31 = *(double *)(v45 + 1968) / (*(double *)(v45 + 1960) + *(double *)(v45 + 1968) + *(double *)(v45 + 1816));
        v48 = v31;
        sub_CCAE4((__int64)(v31 * 100.0));
        v32 = json_real();
        json_object_set_new(v50, "Pool Rejected%", (json_t *)v32);
        if ( *(double *)(v45 + 1960) + *(double *)(v45 + 1968) + *(double *)(v45 + 1816) == 0.0 )
          v33 = 0.0;
        else
          v33 = *(double *)(v45 + 1816) / (*(double *)(v45 + 1960) + *(double *)(v45 + 1968) + *(double *)(v45 + 1816));
        v44 = v33;
        sub_CCAE4((__int64)(v33 * 100.0));
        v34 = json_real();
        json_object_set_new(v50, "Pool Stale%%", (json_t *)v34);
        json_array_append_new(v51, v50);
      }
      json_object_set_new(a1, "POOLS", v51);
      v35 = (json_t *)json_integer(1);
      json_object_set_new(a1, "id", v35);
    }
    else
    {
      sub_20F64((int)a1, 0, 8, "No pools");
    }
    return v52;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v39, 0x1000u, 0, "%s: input bad api param", "get_pools_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_pools_old",
      13,
      1216,
      100,
      v39);
    return -2147483646;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;

//----- (00022A40) --------------------------------------------------------
size_t __fastcall sub_22A40(size_t result, int a2, const char *a3)
{
  size_t v5; // [sp+Ch] [bp-10h]
  int i; // [sp+10h] [bp-Ch]
  size_t v7; // [sp+14h] [bp-8h]

  v5 = result;
  v7 = 0;
  for ( i = 0; i < a2; ++i )
  {
    sprintf((char *)&a3[v7], "%d-", *(_DWORD *)(v5 + 4 * i));
    result = strlen(a3);
    v7 = result;
  }
  a3[v7 - 1] = 45;
  a3[v7 - 1] = 0;
  return result;
}

//----- (00022B04) --------------------------------------------------------
int __fastcall sub_22B04(json_t *a1, int a2, int a3)
{
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v6; // r0
  json_t *v7; // r0
  char *v8; // r4
  json_t *v9; // r0
  json_t *v10; // r0
  double v11; // d0
  double v12; // r0
  double v13; // d16
  double v14; // d16
  json_t *v15; // r0
  double *v16; // r0
  double *v17; // r0
  double *v18; // r0
  double *v19; // r0
  json_t *v20; // r0
  json_t *v21; // r0
  int v22; // r3
  json_t *v23; // r0
  json_t *v24; // r0
  json_t *v25; // r0
  int v26; // r3
  json_t *v27; // r0
  int v28; // r3
  json_t *v29; // r0
  int v30; // r3
  json_t *v31; // r0
  json_t *v32; // r0
  json_t *v33; // r0
  json_t *v34; // r0
  json_t *v35; // r0
  json_t *v36; // r0
  json_t *v37; // r0
  json_t *v38; // r0
  json_t *v39; // r0
  json_t *v40; // r0
  double *v41; // r0
  json_t *v42; // r0
  json_t *v43; // r0
  json_t *v44; // r0
  json_t *v45; // r0
  json_t *v46; // r0
  _BYTE v48[228]; // [sp+10h] [bp-13BCh] BYREF
  int v49; // [sp+F4h] [bp-12D8h]
  int v50; // [sp+F8h] [bp-12D4h]
  json_t *v51; // [sp+FCh] [bp-12D0h]
  char v52[72]; // [sp+104h] [bp-12C8h] BYREF
  char v53[12]; // [sp+1104h] [bp-2C8h] BYREF
  int v54; // [sp+1110h] [bp-2BCh] BYREF
  int v55; // [sp+1114h] [bp-2B8h] BYREF
  int v56; // [sp+1118h] [bp-2B4h] BYREF
  int v57; // [sp+111Ch] [bp-2B0h] BYREF
  double v58; // [sp+1120h] [bp-2ACh] BYREF
  char v59[32]; // [sp+1128h] [bp-2A4h] BYREF
  char v60[32]; // [sp+1148h] [bp-284h] BYREF
  char v61[32]; // [sp+1168h] [bp-264h] BYREF
  char v62[32]; // [sp+1188h] [bp-244h] BYREF
  char v63[12]; // [sp+11A8h] [bp-224h] BYREF
  int v64; // [sp+11B4h] [bp-218h] BYREF
  char v65[4]; // [sp+11B8h] [bp-214h] BYREF
  int v66; // [sp+11BCh] [bp-210h]
  int v67; // [sp+11C0h] [bp-20Ch]
  float v68; // [sp+11C4h] [bp-208h]
  float v69; // [sp+11C8h] [bp-204h]
  float v70; // [sp+11CCh] [bp-200h]
  float v71; // [sp+11D0h] [bp-1FCh]
  double v72; // [sp+11D8h] [bp-1F4h]
  char s[256]; // [sp+11F0h] [bp-1DCh] BYREF
  char v74[32]; // [sp+12F0h] [bp-DCh] BYREF
  _QWORD v75[3]; // [sp+1310h] [bp-BCh] BYREF
  float v76; // [sp+1328h] [bp-A4h]
  float v77; // [sp+132Ch] [bp-A0h]
  double v78; // [sp+1330h] [bp-9Ch]
  double v79; // [sp+1338h] [bp-94h]
  double v80; // [sp+1340h] [bp-8Ch]
  double v81; // [sp+1348h] [bp-84h]
  double v82; // [sp+1350h] [bp-7Ch]
  double v83; // [sp+1358h] [bp-74h]
  double v84; // [sp+1360h] [bp-6Ch]
  double v85; // [sp+1368h] [bp-64h]
  int v86; // [sp+1374h] [bp-58h]
  _DWORD *all_created_runtime; // [sp+1378h] [bp-54h]
  int v88; // [sp+137Ch] [bp-50h]
  double v89; // [sp+1380h] [bp-4Ch]
  int v90; // [sp+1388h] [bp-44h]
  int v91; // [sp+138Ch] [bp-40h]
  int v92; // [sp+1390h] [bp-3Ch]
  int v93; // [sp+1394h] [bp-38h]
  json_t *v94; // [sp+1398h] [bp-34h]
  json_t *v95; // [sp+139Ch] [bp-30h]
  __int64 v96; // [sp+13A0h] [bp-2Ch]
  int v97; // [sp+13A8h] [bp-24h]
  int v98; // [sp+13ACh] [bp-20h]
  unsigned __int8 v99; // [sp+13B3h] [bp-19h]
  void *ptr; // [sp+13B4h] [bp-18h]
  void *v101; // [sp+13B8h] [bp-14h]
  int i; // [sp+13BCh] [bp-10h]

  v51 = a1;
  v50 = a2;
  v49 = a3;
  v95 = 0;
  v94 = 0;
  v93 = 0;
  i = 0;
  v92 = 0;
  v91 = 0;
  memset(v75, 0, 16);
  memset(v74, 0, sizeof(v74));
  memset(s, 0, sizeof(s));
  v90 = 0;
  v64 = 0;
  v101 = 0;
  ptr = 0;
  v99 = 0;
  v98 = -100;
  v97 = 0x7FFFFFFF;
  v96 = 0;
  v89 = 0.0;
  v88 = v50;
  if ( v50 && v51 )
  {
    sub_20F64((int)v51, 1, 70, *(const char **)(v88 + 8));
    v95 = (json_t *)json_array();
    v94 = (json_t *)json_object();
    v4 = (json_t *)json_string("2.12");
    json_object_set_new(v94, "BMMiner", v4);
    v5 = (json_t *)json_string(g_miner_version);
    json_object_set_new(v94, "Miner", v5);
    v6 = (json_t *)json_string(g_miner_compiletime);
    json_object_set_new(v94, "CompileTime", v6);
    v7 = (json_t *)json_string(g_miner_type);
    json_object_set_new(v94, "Type", v7);
    json_array_append_new(v95, v94);
    read_system_status_from_monitor((int)v65);
    all_created_runtime = get_all_created_runtime(&v64);
    v86 = frontend_runtime_instance();
    if ( v64 > 0 )
    {
      v101 = malloc(224 * v64);
      ptr = malloc(4 * v64);
      for ( i = 0; i < v64; ++i )
      {
        v8 = (char *)v101 + 224 * i;
        read_status_from_monitor(v48, all_created_runtime[i]);
        memcpy(v8, v48, 0xE0u);
        *((_DWORD *)ptr + i) = *(_DWORD *)(all_created_runtime[i] + 252) + 1;
      }
    }
    v94 = (json_t *)json_object();
    v9 = (json_t *)json_integer(i);
    json_object_set_new(v94, "STATS", v9);
    snprintf((char *)v75, 0x10u, "BTM_SOC%d", i);
    v10 = (json_t *)json_string((const char *)v75);
    json_object_set_new(v94, "ID", v10);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v86 + 72) + 16), v62);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v86 + 72) + 16), v61);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v86 + 72) + 16), v60);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v86 + 72) + 16), v59);
    v11 = v72;
    format_hashrate_double(*(const char **)(*(_DWORD *)(v86 + 72) + 16), &v58, v63);
    v85 = v11;
    v84 = v11 * v68;
    v83 = v11 * v69;
    v82 = v11 * v70;
    v81 = v11 * v71;
    get_miner_elapsed_time();
    v80 = v11;
    LODWORD(v12) = sub_CCAE4(*(__int64 *)&total_accepted);
    if ( v80 == 0.0 )
      v13 = 1.0;
    else
      v13 = v80;
    v79 = v12 / v13 * 60.0;
    if ( v80 == 0.0 )
      v14 = 1.0;
    else
      v14 = v80;
    v78 = (total_diff_accepted + total_diff_rejected + total_diff_stale) / v14 * 60.0;
    get_total_nonce_rate();
    v77 = *(float *)&v11;
    get_total_accept_rate();
    v76 = *(float *)&v11;
    v15 = (json_t *)json_integer((__int64)v80);
    json_object_set_new(v94, "Elapsed", v15);
    sub_CCAE4((__int64)(v84 * 100.0));
    v16 = json_real();
    json_object_set_new(v94, "GHS 5s", (json_t *)v16);
    sub_CCAE4((__int64)(v81 * 100.0));
    v17 = json_real();
    json_object_set_new(v94, "GHS av", (json_t *)v17);
    sub_CCAE4((__int64)(v82 * 100.0));
    v18 = json_real();
    json_object_set_new(v94, "rate_30m", (json_t *)v18);
    sub_CCAE4((__int64)(v58 * 100.0));
    v19 = json_real();
    json_object_set_new(v94, "total_rateideal", (json_t *)v19);
    v20 = (json_t *)json_integer(opt_bitmain_work_mode);
    json_object_set_new(v94, "Mode", v20);
    v21 = (json_t *)json_integer(v64);
    json_object_set_new(v94, "miner_count", v21);
    for ( i = 0; i < v64; ++i )
    {
      v22 = *((_DWORD *)v101 + 56 * i + 20);
      if ( v97 < v22 )
        v22 = v97;
      v97 = v22;
    }
    v23 = (json_t *)json_integer(v97);
    json_object_set_new(v94, "frequency", v23);
    v24 = (json_t *)json_integer(v66);
    json_object_set_new(v94, "fan_num", v24);
    for ( i = 0; i < v66; ++i )
    {
      memset(v74, 0, sizeof(v74));
      snprintf(v74, 0x20u, "fan%d", i + 1);
      v25 = (json_t *)json_integer(*(int *)(v67 + 4 * i));
      json_object_set_new(v94, v74, v25);
    }
    for ( i = 0; i < v64; ++i )
    {
      v99 += *((_DWORD *)v101 + 56 * i + 7) + *((_DWORD *)v101 + 56 * i + 8);
      v26 = *((_DWORD *)v101 + 56 * i + 5);
      if ( v98 >= v26 )
        v26 = v98;
      v98 = v26;
    }
    v27 = (json_t *)json_integer(v99);
    json_object_set_new(v94, "temp_num", v27);
    for ( i = 0; i < v64; ++i )
    {
      v57 = 0;
      v56 = 0;
      v55 = 0;
      v54 = 0;
      v90 = -255;
      find_min_and_max_int(*((int **)v101 + 56 * i + 1), *((_DWORD *)v101 + 56 * i + 7), &v57, &v56);
      find_min_and_max_int(*((int **)v101 + 56 * i + 3), *((_DWORD *)v101 + 56 * i + 8), &v55, &v54);
      v28 = v56;
      if ( v54 >= v56 )
        v28 = v54;
      v90 = v28;
      sprintf(v74, "temp%d", *((_DWORD *)ptr + i));
      v29 = (json_t *)json_integer(v90);
      json_object_set_new(v94, v74, v29);
      v90 = -255;
      v54 = 0;
      v55 = 0;
      v56 = 0;
      v57 = 0;
      find_min_and_max_int(*((int **)v101 + 56 * i + 2), *((_DWORD *)v101 + 56 * i + 7), &v57, &v56);
      find_min_and_max_int(*((int **)v101 + 56 * i + 4), *((_DWORD *)v101 + 56 * i + 8), &v55, &v54);
      v30 = v56;
      if ( v54 >= v56 )
        v30 = v54;
      v90 = v30;
      sprintf(v74, "temp2_%d", *((_DWORD *)ptr + i));
      v31 = (json_t *)json_integer(v90);
      json_object_set_new(v94, v74, v31);
    }
    for ( i = 0; i < v64; ++i )
    {
      memset(v74, 0, sizeof(v74));
      memset(s, 0, sizeof(s));
      snprintf(v74, 0x20u, "temp_in_pcb_%d", *((_DWORD *)ptr + i));
      sub_22A40(*((_DWORD *)v101 + 56 * i + 1), *((_DWORD *)v101 + 56 * i + 7), s);
      v32 = (json_t *)json_string(s);
      json_object_set_new(v94, v74, v32);
    }
    for ( i = 0; i < v64; ++i )
    {
      memset(v74, 0, sizeof(v74));
      memset(s, 0, sizeof(s));
      snprintf(v74, 0x20u, "temp_out_pcb_%d", *((_DWORD *)ptr + i));
      sub_22A40(*((_DWORD *)v101 + 56 * i + 3), *((_DWORD *)v101 + 56 * i + 8), s);
      v33 = (json_t *)json_string(s);
      json_object_set_new(v94, v74, v33);
    }
    for ( i = 0; i < v64; ++i )
    {
      memset(v74, 0, sizeof(v74));
      memset(s, 0, sizeof(s));
      snprintf(v74, 0x20u, "temp_in_chip_%d", *((_DWORD *)ptr + i));
      sub_22A40(*((_DWORD *)v101 + 56 * i + 2), *((_DWORD *)v101 + 56 * i + 7), s);
      v34 = (json_t *)json_string(s);
      json_object_set_new(v94, v74, v34);
    }
    for ( i = 0; i < v64; ++i )
    {
      memset(v74, 0, sizeof(v74));
      memset(s, 0, sizeof(s));
      snprintf(v74, 0x20u, "temp_out_chip_%d", *((_DWORD *)ptr + i));
      sub_22A40(*((_DWORD *)v101 + 56 * i + 3), *((_DWORD *)v101 + 56 * i + 8), s);
      v35 = (json_t *)json_string(s);
      json_object_set_new(v94, v74, v35);
    }
    v36 = (json_t *)json_integer(v98);
    json_object_set_new(v94, "temp_max", v36);
    for ( i = 0; i < v64; ++i )
    {
      memset(v74, 0, sizeof(v74));
      snprintf(v74, 0x20u, "chain_acn%d", *((_DWORD *)ptr + i));
      v37 = (json_t *)json_integer(*((int *)v101 + 56 * i + 18));
      json_object_set_new(v94, v74, v37);
    }
    for ( i = 0; i < v64; ++i )
    {
      sprintf(v53, "chain_acs%d", *((_DWORD *)ptr + i));
      memset(v74, 0, sizeof(v74));
      memset(s, 0, sizeof(s));
      snprintf(v74, 0x20u, "chain_acs%d", *((_DWORD *)ptr + i));
      snprintf(s, 0x100u, "%s", *((const char **)v101 + 56 * i + 19));
      v38 = (json_t *)json_string(s);
      json_object_set_new(v94, v74, v38);
    }
    for ( i = 0; i < v64; ++i )
    {
      memset(v74, 0, sizeof(v74));
      snprintf(v74, 0x20u, "chain_hw%d", *((_DWORD *)ptr + i));
      v39 = (json_t *)json_integer(*((_QWORD *)v101 + 28 * i + 11));
      json_object_set_new(v94, v74, v39);
      v96 += *((_QWORD *)v101 + 28 * i + 11);
    }
    v40 = (json_t *)json_integer(v96);
    json_object_set_new(v94, "no_matching_work", v40);
    for ( i = 0; i < v64; ++i )
    {
      memset(v74, 0, sizeof(v74));
      snprintf(v74, 0x20u, "chain_rate%d", *((_DWORD *)ptr + i));
      *(double *)&v75[2] = *((float *)v101 + 56 * i + 12) / 1000.0 / 1000.0 / 1000.0;
      v41 = json_real();
      json_object_set_new(v94, v74, (json_t *)v41);
    }
    for ( i = 0; i < v64; ++i )
    {
      format_hashrate_string(*(const char **)(*(_DWORD *)(v86 + 72) + 16), v52);
      snprintf(v74, 0x20u, "CHAIN AVG HASHRATE%d", *((_DWORD *)ptr + i));
      v42 = (json_t *)json_string(v52);
      json_object_set_new(v94, v74, v42);
    }
    for ( i = 0; i < v64; ++i )
    {
      memset(v74, 0, sizeof(v74));
      snprintf(v74, 0x20u, "freq%d", *((_DWORD *)ptr + i));
      v43 = (json_t *)json_integer(*((int *)v101 + 56 * i + 20));
      json_object_set_new(v94, v74, v43);
    }
    v44 = (json_t *)json_string(g_miner_version);
    json_object_set_new(v94, "miner_version", v44);
    v45 = (json_t *)json_string(0);
    json_object_set_new(v94, "miner_id", v45);
    json_array_append_new(v95, v94);
    json_object_set_new(v51, "STATS", v95);
    v46 = (json_t *)json_integer(1);
    json_object_set_new(v51, "id", v46);
    if ( v64 > 0 )
    {
      free(ptr);
      free(v101);
    }
    return v93;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v52, 0x1000u, 0, "%s: input bad api param", "get_stats_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_stats_old",
      13,
      1366,
      100,
      v52);
    return -2147483646;
  }
}
// 23050: variable 'v12' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D37C: using guessed type int opt_bitmain_work_mode;
// 1608F0: using guessed type int g_zc;
// 160998: using guessed type double total_diff_accepted;
// 1609A8: using guessed type double total_diff_rejected;
// 1609C0: using guessed type double total_accepted;
// 1609D0: using guessed type double total_diff_stale;

//----- (00023FF8) --------------------------------------------------------
int __fastcall sub_23FF8(json_t *a1, int a2)
{
  json_t *v3; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v6; // r0
  json_t *v7; // r0
  json_t *v8; // r0
  char v11[20]; // [sp+20h] [bp-1014h] BYREF
  int v12; // [sp+1020h] [bp-14h]
  int v13; // [sp+1024h] [bp-10h]
  json_t *v14; // [sp+1028h] [bp-Ch]
  json_t *v15; // [sp+102Ch] [bp-8h]

  v13 = 0;
  v14 = 0;
  v15 = 0;
  v12 = a2;
  if ( a2 && a1 )
  {
    sub_20F64((int)a1, 1, 22, *(const char **)(v12 + 8));
    v14 = (json_t *)json_array();
    v15 = (json_t *)json_object();
    v3 = (json_t *)json_string("2.12");
    json_object_set_new(v15, "BMMiner", v3);
    v4 = (json_t *)json_string("3.1");
    json_object_set_new(v15, "API", v4);
    v5 = (json_t *)json_string(g_miner_version);
    json_object_set_new(v15, "Miner", v5);
    v6 = (json_t *)json_string(g_miner_compiletime);
    json_object_set_new(v15, "CompileTime", v6);
    v7 = (json_t *)json_string(g_miner_type);
    json_object_set_new(v15, "Type", v7);
    json_array_append_new(v14, v15);
    json_object_set_new(a1, "VERSION", v14);
    v8 = (json_t *)json_integer(1);
    json_object_set_new(a1, "id", v8);
    return v13;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "%s: input bad api param", "get_version_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_version_old",
      15,
      1625,
      100,
      v11);
    return -2147483646;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00024244) --------------------------------------------------------
int __fastcall sub_24244(json_t *a1, int a2)
{
  int v3; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v6; // r0
  char v9[40]; // [sp+24h] [bp-1028h] BYREF
  _DWORD v10[2]; // [sp+1024h] [bp-28h] BYREF
  char *v11; // [sp+102Ch] [bp-20h]
  int *v12; // [sp+1030h] [bp-1Ch]
  int v13; // [sp+1034h] [bp-18h]
  json_t *i; // [sp+1038h] [bp-14h]
  json_t *v15; // [sp+103Ch] [bp-10h]
  int v16; // [sp+1040h] [bp-Ch]
  int v17; // [sp+1044h] [bp-8h]

  v17 = 0;
  v15 = 0;
  i = 0;
  v13 = a2;
  v12 = (int *)&reject_reason_map;
  v16 = 0;
  map_iter_(v10);
  if ( v13 && a1 )
  {
    sub_20F64((int)a1, 1, 71, *(const char **)(v13 + 8));
    v15 = (json_t *)json_array();
    for ( i = (json_t *)json_object(); ; json_object_set_new(i, v11, v4) )
    {
      v11 = (char *)map_next_(v12, v10);
      if ( !v11 )
        break;
      ++v16;
      v3 = map_get_(v12, (unsigned __int8 *)v11);
      v12[3] = v3;
      v4 = (json_t *)json_integer(*(int *)v12[3]);
    }
    v5 = (json_t *)json_integer(v16);
    json_object_set_new(i, "total_reason", v5);
    json_array_append_new(v15, i);
    json_object_set_new(a1, "REJECT_REASON", v15);
    v6 = (json_t *)json_integer(1);
    json_object_set_new(a1, "id", v6);
    return v17;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "%s: input bad api param", "get_reject_summary_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_reject_summary_old",
      22,
      1657,
      100,
      v9);
    return -2147483646;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000244B0) --------------------------------------------------------
int __fastcall sub_244B0(json_t *a1, int a2)
{
  json_t *v3; // r0
  json_t *v4; // r0
  char v7[56]; // [sp+24h] [bp-1038h] BYREF
  char dest[32]; // [sp+1024h] [bp-38h] BYREF
  int v9; // [sp+1044h] [bp-18h]
  json_t *v10; // [sp+1048h] [bp-14h]
  json_t *v11; // [sp+104Ch] [bp-10h]
  int i; // [sp+1050h] [bp-Ch]
  int v13; // [sp+1054h] [bp-8h]

  v13 = 0;
  v11 = 0;
  v10 = 0;
  v9 = a2;
  if ( a2 && a1 )
  {
    sub_20F64((int)a1, 1, 72, *(const char **)(v9 + 8));
    v11 = (json_t *)json_array();
    v10 = (json_t *)json_object();
    memcpy(dest, "timeout", 7u);
    dest[8] = 0;
    for ( i = 0; i <= 9; ++i )
    {
      dest[7] = i + 48;
      v3 = (json_t *)json_integer(max_timeout_value[i]);
      json_object_set_new(v10, dest, v3);
    }
    json_array_append_new(v11, v10);
    json_object_set_new(a1, "TIMEOUT_REASON", v11);
    v4 = (json_t *)json_integer(1);
    json_object_set_new(a1, "id", v4);
    return v13;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "%s: input bad api param", "get_timeout_summary_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_timeout_summary_old",
      23,
      1686,
      100,
      v7);
    return -2147483646;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512D0: using guessed type _QWORD max_timeout_value[10];
// 1608F0: using guessed type int g_zc;

//----- (000246D8) --------------------------------------------------------
int __fastcall sub_246D8(json_t *a1, int a2)
{
  int *current_pool; // r0
  json_t *v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int (**v8)(); // r0
  int v9; // r0
  json_t *v10; // r0
  json_t *v11; // r0
  char v14[28]; // [sp+20h] [bp-205Ch] BYREF
  char v15[28]; // [sp+1020h] [bp-105Ch] BYREF
  char v16[60]; // [sp+1040h] [bp-103Ch] BYREF
  int v17; // [sp+2040h] [bp-3Ch] BYREF
  int v18; // [sp+2044h] [bp-38h]
  int v19; // [sp+2048h] [bp-34h]
  _DWORD *all_created_runtime; // [sp+204Ch] [bp-30h]
  int v21; // [sp+2050h] [bp-2Ch]
  json_t *v22; // [sp+2054h] [bp-28h]
  json_t *v23; // [sp+2058h] [bp-24h]
  int v24; // [sp+205Ch] [bp-20h]
  int v25; // [sp+2060h] [bp-1Ch]
  int i; // [sp+2064h] [bp-18h]
  int j; // [sp+2068h] [bp-14h]
  int k; // [sp+206Ch] [bp-10h]

  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = a2;
  v17 = 0;
  all_created_runtime = get_all_created_runtime(&v17);
  v25 = 0;
  if ( v21 && a1 )
  {
    sub_20F64((int)a1, 1, 73, *(const char **)(v21 + 8));
    v23 = (json_t *)json_array();
    v22 = (json_t *)json_object();
    current_pool = (int *)get_current_pool();
    v4 = (json_t *)json_integer(*current_pool);
    json_object_set_new(v22, "current_pool", v4);
    for ( i = 0; i < v17; ++i )
    {
      v25 = snprintf(
              v16,
              0x1000u,
              "device %d wc %llu nc %llu detail:",
              *(_DWORD *)(all_created_runtime[i] + 248),
              *(_QWORD *)(all_created_runtime[i] + 440),
              *(_QWORD *)(all_created_runtime[i] + 448));
      v19 = *(_DWORD *)(all_created_runtime[i] + 336);
      for ( j = 0; j < v19; ++j )
      {
        v18 = *(_DWORD *)(all_created_runtime[i] + 456) + 48 * j;
        v5 = snprintf(&v16[v25], 4096 - v25, "%d:", j + 1);
        v25 += v5;
        for ( k = 0; k <= 5; ++k )
        {
          v6 = snprintf(&v16[v25], 4096 - v25, " %llu", *(_QWORD *)(v18 + 8 * k));
          v25 += v6;
        }
        v7 = snprintf(&v16[v25], 4096 - v25, " /");
        v25 += v7;
      }
      v8 = dev_ctrl();
      v9 = ((int (__fastcall *)(_DWORD))v8[12])(*(_DWORD *)(all_created_runtime[i] + 248));
      sprintf(v15, "chain%d", v9);
      v10 = (json_t *)json_string(v16);
      json_object_set_new(v22, v15, v10);
    }
    json_array_append_new(v23, v22);
    json_object_set_new(a1, "NONCENUM_REASON", v23);
    v11 = (json_t *)json_integer(1);
    json_object_set_new(a1, "id", v11);
    return v24;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "%s: input bad api param", "get_noncenum_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "get_noncenum_old",
      16,
      1720,
      100,
      v14);
    return -2147483646;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00024B50) --------------------------------------------------------
int __fastcall sub_24B50(int a1, int a2, const char *a3)
{
  char v6[32]; // [sp+34h] [bp-1060h] BYREF
  _DWORD s[4]; // [sp+1054h] [bp-40h] BYREF
  int v8; // [sp+1064h] [bp-30h] BYREF
  char *nptr; // [sp+1068h] [bp-2Ch] BYREF
  unsigned __int8 v10; // [sp+106Fh] [bp-25h]
  unsigned int v11; // [sp+1070h] [bp-24h]
  unsigned __int16 v12; // [sp+1074h] [bp-20h]
  unsigned __int8 v13; // [sp+1076h] [bp-1Eh]
  unsigned __int8 v14; // [sp+1077h] [bp-1Dh]
  _DWORD *all_created_runtime; // [sp+1078h] [bp-1Ch]
  int v16; // [sp+107Ch] [bp-18h]
  int v17; // [sp+1080h] [bp-14h]
  char *v18; // [sp+1084h] [bp-10h]

  v16 = 0;
  v8 = 0;
  v17 = a2;
  v18 = (char *)a3;
  all_created_runtime = get_all_created_runtime(&v8);
  if ( v8 > 0 )
  {
    if ( v17 && a1 )
    {
      sub_20F64(a1, 1, 78, *(const char **)(v17 + 8));
      if ( v18 && *v18 )
      {
        nptr = v18;
        v14 = strtol(v18, &nptr, 10);
        ++nptr;
        v13 = strtol(nptr, &nptr, 10);
        ++nptr;
        v12 = strtol(nptr, &nptr, 16);
        ++nptr;
        v11 = strtoul(nptr, &nptr, 16);
        v10 = v13 * *(_DWORD *)(all_created_runtime[v14] + 356);
        V_LOCK();
        logfmt_raw(
          v6,
          0x1000u,
          0,
          "%s: set chain_offset %d chain %d chip %d chipaddr %x reg %x to %08x",
          "set_chipreg_old",
          v14,
          *(_DWORD *)(all_created_runtime[v14] + 252),
          v13,
          v10,
          v12,
          v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/api_new.c",
          147,
          "set_chipreg_old",
          15,
          1797,
          40,
          v6);
        memset(s, 0, sizeof(s));
        LOBYTE(s[2]) = 0;
        BYTE1(s[2]) = v10;
        HIWORD(s[2]) = v12;
        s[0] = v11;
        return (*(int (__fastcall **)(_DWORD, _DWORD *))(all_created_runtime[v14] + 268))(all_created_runtime[v14], s);
      }
      else
      {
        return -2147483646;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "%s: input bad api param", "set_chipreg_old");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "set_chipreg_old",
        15,
        1782,
        100,
        v6);
      return -2147483646;
    }
  }
  else
  {
    sub_20F64(a1, 0, 10, "No ASCs");
    return -2147483647;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00024EF4) --------------------------------------------------------
int __fastcall sub_24EF4(int a1, int a2, const char *a3)
{
  char v6[28]; // [sp+20h] [bp-105Ch] BYREF
  int v7; // [sp+1050h] [bp-2Ch] BYREF
  char *nptr; // [sp+1054h] [bp-28h] BYREF
  __int64 v9; // [sp+1058h] [bp-24h]
  unsigned __int8 v10; // [sp+1067h] [bp-15h]
  _DWORD *all_created_runtime; // [sp+1068h] [bp-14h]
  int v12; // [sp+106Ch] [bp-10h]
  int v13; // [sp+1070h] [bp-Ch]
  char *v14; // [sp+1074h] [bp-8h]

  v12 = 0;
  v7 = 0;
  v13 = a2;
  v14 = (char *)a3;
  all_created_runtime = get_all_created_runtime(&v7);
  if ( v7 > 0 )
  {
    if ( v13 && a1 )
    {
      sub_20F64(a1, 1, 80, *(const char **)(v13 + 8));
      if ( v14 && *v14 )
      {
        nptr = v14;
        v10 = strtol(v14, &nptr, 10);
        ++nptr;
        v9 = strtoll(nptr, &nptr, 10);
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, "%s: set chain_offset %d uart print time %lld ms", "set_uart_print_time", v10, v9);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/api_new.c",
          147,
          "set_uart_print_time",
          19,
          1842,
          40,
          v6);
        set_remain_debug_print_time(all_created_runtime[v10] + 1144, v9);
        set_remain_debug_print_time(all_created_runtime[v10] + 1216, v9);
        return v12;
      }
      else
      {
        return -2147483646;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "%s: input bad api param", "set_uart_print_time");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "set_uart_print_time",
        19,
        1831,
        100,
        v6);
      return -2147483646;
    }
  }
  else
  {
    sub_20F64(a1, 0, 10, "No ASCs");
    return -2147483647;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000251C4) --------------------------------------------------------
int __fastcall sub_251C4(int a1, int a2, const char *a3)
{
  char v6[28]; // [sp+20h] [bp-105Ch] BYREF
  int v7; // [sp+1050h] [bp-2Ch] BYREF
  char *nptr; // [sp+1054h] [bp-28h] BYREF
  __int64 v9; // [sp+1058h] [bp-24h]
  unsigned __int8 v10; // [sp+1067h] [bp-15h]
  _DWORD *all_created_runtime; // [sp+1068h] [bp-14h]
  int v12; // [sp+106Ch] [bp-10h]
  int v13; // [sp+1070h] [bp-Ch]
  char *v14; // [sp+1074h] [bp-8h]

  v12 = 0;
  v7 = 0;
  v13 = a2;
  v14 = (char *)a3;
  all_created_runtime = get_all_created_runtime(&v7);
  if ( v7 > 0 )
  {
    if ( v13 && a1 )
    {
      sub_20F64(a1, 1, 81, *(const char **)(v13 + 8));
      if ( v14 && *v14 )
      {
        nptr = v14;
        v10 = strtol(v14, &nptr, 10);
        ++nptr;
        v9 = strtoll(nptr, &nptr, 10);
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, "%s: set chain_offset %d uart print lines %lld", "set_uart_print_lines", v10, v9);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/api_new.c",
          147,
          "set_uart_print_lines",
          20,
          1885,
          40,
          v6);
        set_remain_debug_print_lines(all_created_runtime[v10] + 1144, v9);
        set_remain_debug_print_lines(all_created_runtime[v10] + 1216, v9);
        return v12;
      }
      else
      {
        return -2147483646;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "%s: input bad api param", "set_uart_print_lines");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "set_uart_print_lines",
        20,
        1874,
        100,
        v6);
      return -2147483646;
    }
  }
  else
  {
    sub_20F64(a1, 0, 10, "No ASCs");
    return -2147483647;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00025494) --------------------------------------------------------
int __fastcall sub_25494(json_t *a1, int a2, const char *a3)
{
  json_t *v4; // r0
  size_t v5; // r4
  int v6; // r6
  int v7; // r5
  uint32_t v8; // r0
  json_t *v9; // r0
  int (**v10)(); // r0
  int v11; // r0
  char v14[68]; // [sp+28h] [bp-1084h] BYREF
  char v15[32]; // [sp+1028h] [bp-84h] BYREF
  int v16; // [sp+1048h] [bp-64h] BYREF
  _WORD s[8]; // [sp+104Ch] [bp-60h] BYREF
  int v18; // [sp+105Ch] [bp-50h] BYREF
  char *nptr; // [sp+1060h] [bp-4Ch] BYREF
  unsigned __int8 v20; // [sp+1066h] [bp-46h]
  unsigned __int8 v21; // [sp+1067h] [bp-45h]
  int v22; // [sp+1068h] [bp-44h]
  char *v23; // [sp+106Ch] [bp-40h]
  void *ptr; // [sp+1070h] [bp-3Ch]
  size_t size; // [sp+1074h] [bp-38h]
  int v26; // [sp+1078h] [bp-34h]
  unsigned __int8 v27; // [sp+107Eh] [bp-2Eh]
  unsigned __int8 v28; // [sp+107Fh] [bp-2Dh]
  _DWORD *all_created_runtime; // [sp+1080h] [bp-2Ch]
  int i; // [sp+1084h] [bp-28h]
  int v31; // [sp+1088h] [bp-24h]
  json_t *v32; // [sp+108Ch] [bp-20h]
  int v33; // [sp+1090h] [bp-1Ch]
  char *v34; // [sp+1094h] [bp-18h]

  v31 = 0;
  v32 = 0;
  v33 = a2;
  v34 = (char *)a3;
  all_created_runtime = get_all_created_runtime(&v18);
  if ( v18 > 0 )
  {
    if ( v33 && a1 )
    {
      sub_20F64((int)a1, 1, 74, *(const char **)(v33 + 8));
      if ( v34 && *v34 )
      {
        nptr = v34;
        v28 = strtol(v34, &nptr, 10);
        ++nptr;
        v27 = strtoul(nptr, &nptr, 16);
        memset(s, 0, sizeof(s));
        s[5] = v27;
        LOBYTE(s[4]) = 1;
        v32 = (json_t *)json_array();
        v26 = *(_DWORD *)(all_created_runtime[v28] + 336);
        size = 64;
        ptr = malloc(12 * v26);
        v23 = (char *)malloc(size);
        (*(void (__fastcall **)(_DWORD, _WORD *, int, void *, int *))(all_created_runtime[v28] + 288))(
          all_created_runtime[v28],
          s,
          v26,
          ptr,
          &v16);
        v22 = snprintf(v23, size, "chain %d detect %d chips", *(_DWORD *)(all_created_runtime[v28] + 252), v16);
        v4 = (json_t *)json_string(v23);
        json_array_append_new(v32, v4);
        ++nptr;
        for ( i = strtol(nptr, &nptr, 10); i; --i )
        {
          ++nptr;
          v21 = strtol(nptr, &nptr, 10);
          v20 = v21 * *(_DWORD *)(all_created_runtime[v28] + 356);
          V_LOCK();
          logfmt_raw(
            v14,
            0x1000u,
            0,
            "%s: set chain_id %d chain %d chip_id %d chip_addr %x reg_addr %x",
            "get_target_chipreg_old",
            v28,
            *(_DWORD *)(all_created_runtime[v28] + 252),
            v21,
            v20,
            v27);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/api_new.c",
            147,
            "get_target_chipreg_old",
            22,
            1951,
            40,
            v14);
          v5 = size;
          v6 = *((unsigned __int8 *)ptr + 12 * v21 + 4);
          v7 = *((unsigned __int16 *)ptr + 6 * v21 + 3);
          v8 = swab32(*((_DWORD *)ptr + 3 * v21));
          v22 = snprintf(v23, v5, "chip %02x reg %02x data %08x", v6, v7, v8);
          v9 = (json_t *)json_string(v23);
          json_array_append_new(v32, v9);
        }
        v10 = dev_ctrl();
        v11 = ((int (__fastcall *)(_DWORD))v10[12])(*(_DWORD *)(all_created_runtime[v28] + 248));
        sprintf(v15, "chain%d", v11);
        json_object_set_new(a1, v15, v32);
        free(v23);
        free(ptr);
        return v31;
      }
      else
      {
        return -2147483646;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v14, 0x1000u, 0, "%s: input bad api param", "get_target_chipreg_old");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "get_target_chipreg_old",
        22,
        1920,
        100,
        v14);
      return -2147483646;
    }
  }
  else
  {
    sub_20F64((int)a1, 0, 10, "No ASCs");
    return -2147483647;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00025A08) --------------------------------------------------------
int __fastcall sub_25A08(json_t *a1, int a2, char *a3)
{
  json_t *v4; // r0
  size_t v5; // r4
  int v6; // r6
  int v7; // r5
  uint32_t v8; // r0
  json_t *v9; // r0
  int (**v10)(); // r0
  int v11; // r0
  int v13; // [sp+4h] [bp-10A0h]
  char v15[64]; // [sp+24h] [bp-1080h] BYREF
  unsigned __int8 v16; // [sp+1027h] [bp-7Dh] BYREF
  char v17[32]; // [sp+1028h] [bp-7Ch] BYREF
  int v18; // [sp+1048h] [bp-5Ch] BYREF
  _WORD v19[8]; // [sp+104Ch] [bp-58h] BYREF
  int v20; // [sp+105Ch] [bp-48h] BYREF
  char *v21; // [sp+1060h] [bp-44h]
  void *ptr; // [sp+1064h] [bp-40h]
  size_t size; // [sp+1068h] [bp-3Ch]
  int v24; // [sp+106Ch] [bp-38h]
  _DWORD *all_created_runtime; // [sp+1070h] [bp-34h]
  char *s; // [sp+1074h] [bp-30h]
  int v27; // [sp+1078h] [bp-2Ch]
  int v28; // [sp+107Ch] [bp-28h]
  json_t *v29; // [sp+1080h] [bp-24h]
  int v30; // [sp+1084h] [bp-20h]
  int i; // [sp+1088h] [bp-1Ch]
  int j; // [sp+108Ch] [bp-18h]

  v30 = 0;
  v29 = 0;
  v28 = 0;
  v20 = 0;
  v27 = a2;
  s = a3;
  all_created_runtime = get_all_created_runtime(&v20);
  if ( v20 > 0 )
  {
    if ( v27 && a1 )
    {
      sub_20F64((int)a1, 1, 75, *(const char **)(v27 + 8));
      if ( s && *s && strlen(s) == 2 && hex2bin(&v16, s, 1) )
      {
        memset(v19, 0, sizeof(v19));
        LOBYTE(v19[4]) = 1;
        v19[5] = v16;
        for ( i = 0; i < v20; ++i )
        {
          v29 = (json_t *)json_array();
          v24 = *(_DWORD *)(all_created_runtime[i] + 336);
          size = 64;
          ptr = malloc(12 * v24);
          v21 = (char *)malloc(size);
          (*(void (__fastcall **)(_DWORD, _WORD *, int, void *, int *, int, int, _DWORD))(all_created_runtime[i] + 288))(
            all_created_runtime[i],
            v19,
            v24,
            ptr,
            &v18,
            v13,
            2000,
            0);
          v28 = snprintf(
                  v21,
                  size,
                  "=========================================chain %d detect %d chips",
                  *(_DWORD *)(all_created_runtime[i] + 252),
                  v18);
          v4 = (json_t *)json_string(v21);
          json_array_append_new(v29, v4);
          for ( j = 0; j < v18; ++j )
          {
            v5 = size;
            v6 = *((unsigned __int8 *)ptr + 12 * j + 4);
            v7 = *((unsigned __int16 *)ptr + 6 * j + 3);
            v8 = swab32(*((_DWORD *)ptr + 3 * j));
            v28 = snprintf(v21, v5, "chip %02x reg %02x data %08x", v6, v7, v8);
            v9 = (json_t *)json_string(v21);
            json_array_append_new(v29, v9);
          }
          v10 = dev_ctrl();
          v11 = ((int (__fastcall *)(_DWORD))v10[12])(*(_DWORD *)(all_created_runtime[i] + 248));
          sprintf(v17, "chain%d", v11);
          json_object_set_new(a1, v17, v29);
          free(v21);
          free(ptr);
        }
        return v30;
      }
      else
      {
        return -2147483646;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, "%s: input bad api param", "get_chipreg_old");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "get_chipreg_old",
        15,
        1987,
        100,
        v15);
      return -2147483646;
    }
  }
  else
  {
    sub_20F64((int)a1, 0, 10, "No ASCs");
    return -2147483647;
  }
}
// 25CCC: variable 'v13' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00025E80) --------------------------------------------------------
int __fastcall sub_25E80(json_t *a1, int a2, const char *a3)
{
  json_t *v4; // r0
  size_t v5; // r4
  int v6; // r5
  uint32_t v7; // r0
  json_t *v8; // r0
  int (**v9)(); // r0
  int v10; // r0
  int v12; // [sp+4h] [bp-10A0h]
  char v14[60]; // [sp+28h] [bp-107Ch] BYREF
  char v15[32]; // [sp+102Ch] [bp-78h] BYREF
  int v16; // [sp+104Ch] [bp-58h] BYREF
  _WORD s[8]; // [sp+1050h] [bp-54h] BYREF
  int v18; // [sp+1060h] [bp-44h] BYREF
  char *nptr; // [sp+1064h] [bp-40h] BYREF
  char *v20; // [sp+1068h] [bp-3Ch]
  void *ptr; // [sp+106Ch] [bp-38h]
  size_t size; // [sp+1070h] [bp-34h]
  int v23; // [sp+1074h] [bp-30h]
  unsigned __int8 v24; // [sp+107Ah] [bp-2Ah]
  unsigned __int8 v25; // [sp+107Bh] [bp-29h]
  _DWORD *all_created_runtime; // [sp+107Ch] [bp-28h]
  char *v27; // [sp+1080h] [bp-24h]
  int v28; // [sp+1084h] [bp-20h]
  int i; // [sp+1088h] [bp-1Ch]
  int v30; // [sp+108Ch] [bp-18h]
  json_t *v31; // [sp+1090h] [bp-14h]
  int v32; // [sp+1094h] [bp-10h]

  v30 = 0;
  v31 = 0;
  v32 = 0;
  v18 = 0;
  v28 = a2;
  v27 = (char *)a3;
  all_created_runtime = get_all_created_runtime(&v18);
  if ( v18 > 0 )
  {
    if ( v28 && a1 )
    {
      sub_20F64((int)a1, 1, 76, *(const char **)(v28 + 8));
      if ( v27 && *v27 )
      {
        nptr = v27;
        v25 = strtol(v27, &nptr, 10);
        ++nptr;
        v24 = strtol(nptr, &nptr, 10);
        memset(s, 0, sizeof(s));
        HIBYTE(s[4]) = v24 * *(_DWORD *)(all_created_runtime[v25] + 356);
        LOBYTE(s[4]) = 0;
        ++nptr;
        s[5] = strtoul(nptr, &nptr, 16);
        LOBYTE(s[6]) = -1;
        v31 = (json_t *)json_array();
        v23 = *(_DWORD *)(all_created_runtime[v25] + 340) * *(_DWORD *)(all_created_runtime[v25] + 336);
        size = 64;
        ptr = malloc(12 * v23);
        v20 = (char *)malloc(size);
        V_LOCK();
        logfmt_raw(
          v14,
          0x1000u,
          0,
          "chip_offset: %d, chip_id: %d, chip_addr: %x, reg_addr: %x, core_no: %d",
          v25,
          v24,
          HIBYTE(s[4]),
          s[5],
          v23);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/api_new.c",
          147,
          "get_target_corereg_old",
          22,
          2077,
          40,
          v14);
        (*(void (__fastcall **)(_DWORD, _WORD *, int, void *, int *, int, int, _DWORD))(all_created_runtime[v25] + 300))(
          all_created_runtime[v25],
          s,
          v23,
          ptr,
          &v16,
          v12,
          2000,
          0);
        v32 = snprintf(
                v20,
                size,
                "=========================================chain %d detect %d cores",
                *(_DWORD *)(all_created_runtime[v25] + 252),
                v16);
        v4 = (json_t *)json_string(v20);
        json_array_append_new(v31, v4);
        for ( i = 0; i < v16; ++i )
        {
          v5 = size;
          v6 = *((unsigned __int8 *)ptr + 12 * i + 8);
          v7 = swab32(*((_DWORD *)ptr + 3 * i));
          v32 = snprintf(v20, v5, "core %02x data %08x", v6, v7);
          v8 = (json_t *)json_string(v20);
          json_array_append_new(v31, v8);
        }
        v9 = dev_ctrl();
        v10 = ((int (__fastcall *)(_DWORD))v9[12])(*(_DWORD *)(all_created_runtime[v25] + 248));
        sprintf(v15, "chain%d", v10);
        json_object_set_new(a1, v15, v31);
        free(v20);
        free(ptr);
        return v30;
      }
      else
      {
        return -2147483646;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v14, 0x1000u, 0, "%s: input bad api param", "get_target_corereg_old");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "get_target_corereg_old",
        22,
        2053,
        100,
        v14);
      return -2147483646;
    }
  }
  else
  {
    sub_20F64((int)a1, 0, 10, "No ASCs");
    return -2147483647;
  }
}
// 2625C: variable 'v12' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000263D4) --------------------------------------------------------
int __fastcall sub_263D4(json_t *a1, int a2, char *a3)
{
  json_t *v4; // r0
  size_t v5; // r4
  int v6; // r7
  int v7; // r5
  int v8; // r6
  uint32_t v9; // r0
  json_t *v10; // r0
  int (**v11)(); // r0
  int v12; // r0
  int v14; // [sp+4h] [bp-10A0h]
  char v16[68]; // [sp+20h] [bp-1084h] BYREF
  _BYTE v17[4]; // [sp+1020h] [bp-84h] BYREF
  char v18[32]; // [sp+1024h] [bp-80h] BYREF
  int v19; // [sp+1044h] [bp-60h] BYREF
  _WORD v20[8]; // [sp+1048h] [bp-5Ch] BYREF
  int v21; // [sp+1058h] [bp-4Ch] BYREF
  char *v22; // [sp+105Ch] [bp-48h]
  void *ptr; // [sp+1060h] [bp-44h]
  size_t size; // [sp+1064h] [bp-40h]
  int v25; // [sp+1068h] [bp-3Ch]
  signed int v26; // [sp+106Ch] [bp-38h]
  _DWORD *all_created_runtime; // [sp+1070h] [bp-34h]
  char *s; // [sp+1074h] [bp-30h]
  int v29; // [sp+1078h] [bp-2Ch]
  int v30; // [sp+107Ch] [bp-28h]
  json_t *v31; // [sp+1080h] [bp-24h]
  int v32; // [sp+1084h] [bp-20h]
  int i; // [sp+1088h] [bp-1Ch]
  int j; // [sp+108Ch] [bp-18h]

  v32 = 0;
  v31 = 0;
  v30 = 0;
  v21 = 0;
  v29 = a2;
  s = a3;
  all_created_runtime = get_all_created_runtime(&v21);
  if ( v21 > 0 )
  {
    if ( v29 && a1 )
    {
      sub_20F64((int)a1, 1, 77, *(const char **)(v29 + 8));
      v26 = strlen(s);
      if ( s && *s && (v26 == 2 || v26 == 4) && hex2bin(v17, s, v26 / 2) )
      {
        memset(v20, 0, sizeof(v20));
        v20[4] = 1;
        v20[5] = v17[0];
        LOBYTE(v20[6]) = -1;
        if ( v26 == 4 )
          v20[5] = (v20[5] << 8) | v17[1];
        for ( i = 0; i < v21; ++i )
        {
          v31 = (json_t *)json_array();
          v25 = *(_DWORD *)(all_created_runtime[i] + 340) * *(_DWORD *)(all_created_runtime[i] + 336);
          size = 64;
          ptr = malloc(12 * v25);
          v22 = (char *)malloc(size);
          (*(void (__fastcall **)(_DWORD, _WORD *, int, void *, int *, int, int, _DWORD))(all_created_runtime[i] + 300))(
            all_created_runtime[i],
            v20,
            v25,
            ptr,
            &v19,
            v14,
            2000,
            0);
          v30 = snprintf(
                  v22,
                  size,
                  "=========================================chain %d detect %d cores",
                  *(_DWORD *)(all_created_runtime[i] + 252),
                  v19);
          v4 = (json_t *)json_string(v22);
          json_array_append_new(v31, v4);
          for ( j = 0; j < v19; ++j )
          {
            v5 = size;
            v6 = *((unsigned __int8 *)ptr + 12 * j + 4);
            v7 = *((unsigned __int8 *)ptr + 12 * j + 8);
            v8 = *((unsigned __int16 *)ptr + 6 * j + 3);
            v9 = swab32(*((_DWORD *)ptr + 3 * j));
            v30 = snprintf(v22, v5, "chip %02x core %02x reg %04x data %08x", v6, v7, v8, v9);
            v10 = (json_t *)json_string(v22);
            json_array_append_new(v31, v10);
          }
          v11 = dev_ctrl();
          v12 = ((int (__fastcall *)(_DWORD))v11[12])(*(_DWORD *)(all_created_runtime[i] + 248));
          sprintf(v18, "chain%d", v12);
          json_object_set_new(a1, v18, v31);
          free(v22);
          free(ptr);
        }
        return v32;
      }
      else
      {
        return -2147483646;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v16, 0x1000u, 0, "%s: input bad api param", "get_corereg_old");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "get_corereg_old",
        15,
        2118,
        100,
        v16);
      return -2147483646;
    }
  }
  else
  {
    sub_20F64((int)a1, 0, 10, "No ASCs");
    return -2147483647;
  }
}
// 26718: variable 'v14' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000268EC) --------------------------------------------------------
int __fastcall sub_268EC(json_t *a1, int a2, const char *a3)
{
  int (**v4)(); // r0
  json_t *v5; // r0
  char v9[24]; // [sp+24h] [bp-1018h] BYREF
  int v10; // [sp+1024h] [bp-18h]
  int v11; // [sp+1028h] [bp-14h]
  json_t *v12; // [sp+102Ch] [bp-10h]
  int v13; // [sp+1030h] [bp-Ch]
  int v14; // [sp+1034h] [bp-8h]

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = a2;
  if ( a2 && a1 )
  {
    sub_20F64((int)a1, 1, 79, *(const char **)(v14 + 8));
    v12 = (json_t *)json_array();
    v10 = atoi(a3);
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "parameter = \"%s\", config = %d.", a3, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "reset_fpga_baud_old",
      19,
      2178,
      100,
      v9);
    v4 = dev_ctrl();
    ((void (__fastcall *)(int))v4[4])(v10);
    json_object_set_new(a1, "FPGA_BAUD", v12);
    v5 = (json_t *)json_integer(1);
    json_object_set_new(a1, "id", v5);
    return v11;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "%s: input bad api param", "reset_fpga_baud_old");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "reset_fpga_baud_old",
      19,
      2171,
      100,
      v9);
    return -2147483646;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00026B24) --------------------------------------------------------
_DWORD *print_summary()
{
  double v0; // d0
  double v1; // r0
  int v2; // r1
  double v3; // d8
  double v4; // r0
  int v5; // r1
  double v6; // d8
  double v7; // r0
  _DWORD *result; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  char v12[40]; // [sp+1Ch] [bp-20A8h] BYREF
  char v13[40]; // [sp+101Ch] [bp-10A8h] BYREF
  int v14; // [sp+201Ch] [bp-A8h] BYREF
  char v15[24]; // [sp+2020h] [bp-A4h] BYREF
  float v16; // [sp+2038h] [bp-8Ch]
  int v17; // [sp+2050h] [bp-74h]
  int v18; // [sp+2054h] [bp-70h]
  int v19; // [sp+205Ch] [bp-68h]
  int v20; // [sp+2060h] [bp-64h]
  _DWORD *v21; // [sp+2064h] [bp-60h]
  int v22; // [sp+2068h] [bp-5Ch]
  int j; // [sp+206Ch] [bp-58h]
  int k; // [sp+2070h] [bp-54h]
  int m; // [sp+2074h] [bp-50h]
  double v26; // [sp+2078h] [bp-4Ch]
  double v27; // [sp+2080h] [bp-44h]
  __int64 v28; // [sp+2088h] [bp-3Ch]
  double v29; // [sp+2090h] [bp-34h]
  int v30; // [sp+209Ch] [bp-28h]
  double v31; // [sp+20A0h] [bp-24h]
  int i; // [sp+20A8h] [bp-1Ch]
  int v33; // [sp+20ACh] [bp-18h]

  read_system_status_from_monitor((int)v15);
  v26 = v16 / 1000.0 / 1000.0;
  get_miner_elapsed_time();
  v27 = v0;
  LODWORD(v28) = (int)v0 / 3600;
  HIDWORD(v28) = (int)v0 % 3600 / 60;
  v30 = (int)v0 % 60;
  LODWORD(v1) = sub_CCAE4(*(__int64 *)&total_accepted);
  v29 = v1 / v27 * 60.0;
  v31 = (total_diff_accepted + total_diff_rejected + total_diff_stale) / v27 * 60.0;
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Summary of runtime statistics:");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2206,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Runtime: %d hrs : %d mins : %d secs", v28, v30);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2207,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Average hashrate: %.1f Mhash/s", v26);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2208,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Total got job from pools: %lld", total_getworks);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2209,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Total generated local work  %d", local_work);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2210,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Solved blocks: %d", dword_1512A0);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2211,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Share submissions: %lld", *(_QWORD *)&total_rejected + *(_QWORD *)&total_accepted);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2212,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Accepted shares: %lld", total_accepted);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2213,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Rejected shares: %lld", total_rejected);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2214,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Accepted difficulty shares: %1.f", total_diff_accepted);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2215,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Rejected difficulty shares: %1.f", total_diff_rejected);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2216,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Total Hardware errors %llu", v17, v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2217,
    80,
    v12);
  if ( *(_QWORD *)&total_accepted || *(_QWORD *)&total_rejected )
  {
    V_LOCK();
    LODWORD(v3) = sub_CCAE4(
                    3LL * *(_QWORD *)&total_rejected
                  + vshld_n_s64(3LL * *(_QWORD *)&total_rejected, 5u)
                  + *(_QWORD *)&total_rejected);
    HIDWORD(v3) = v2;
    LODWORD(v4) = sub_CCAE4(*(_QWORD *)&total_rejected + *(_QWORD *)&total_accepted);
    logfmt_raw(v12, 0x1000u, 0, "Reject ratio: %.1f%%", v3 / v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "print_summary",
      13,
      2220,
      80,
      v12);
  }
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Utility (accepted shares / min): %.2f/min", v29);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2222,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Work Utility (diff1 shares solved / min): %.2f/min", v31);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2223,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Stale submissions discarded due to new blocks: %lld", total_stale);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2224,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Unable to get work from server occasions: %d", total_go);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2225,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Submitting work remotely delay occasions: %d", total_ro);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2226,
    80,
    v12);
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "New blocks detected on network: %d", new_blocks);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2227,
    80,
    v12);
  if ( total_pools > 0 )
  {
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "Summary of pool statistics:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "print_summary",
      13,
      2231,
      80,
      v12);
    for ( i = 0; i < total_pools; ++i )
    {
      v33 = *(_DWORD *)(pools + 4 * i);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "Pool: %s", *(_DWORD *)(v33 + 12));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "print_summary",
        13,
        2236,
        80,
        v12);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "User: %s", *(_DWORD *)(v33 + 16));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "print_summary",
        13,
        2237,
        80,
        v12);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "Share submissions: %lld", *(_QWORD *)(v33 + 1936) + *(_QWORD *)(v33 + 1928));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "print_summary",
        13,
        2238,
        80,
        v12);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "Accepted shares: %lld", *(_DWORD *)(v33 + 1928), *(_DWORD *)(v33 + 1932));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "print_summary",
        13,
        2239,
        80,
        v12);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "Rejected shares: %lld", *(_DWORD *)(v33 + 1936), *(_DWORD *)(v33 + 1940));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "print_summary",
        13,
        2240,
        80,
        v12);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "Accepted difficulty shares: %1.f", *(_DWORD *)(v33 + 1960), *(_DWORD *)(v33 + 1964));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "print_summary",
        13,
        2241,
        80,
        v12);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "Rejected difficulty shares: %1.f", *(_DWORD *)(v33 + 1968), *(_DWORD *)(v33 + 1972));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "print_summary",
        13,
        2242,
        80,
        v12);
      if ( *(_QWORD *)(v33 + 1928) || *(_QWORD *)(v33 + 1936) )
      {
        V_LOCK();
        LODWORD(v6) = sub_CCAE4(
                        3LL * *(_QWORD *)(v33 + 1936)
                      + vshld_n_s64(3LL * *(_QWORD *)(v33 + 1936), 5u)
                      + *(_QWORD *)(v33 + 1936));
        HIDWORD(v6) = v5;
        LODWORD(v7) = sub_CCAE4(*(_QWORD *)(v33 + 1936) + *(_QWORD *)(v33 + 1928));
        logfmt_raw(v12, 0x1000u, 0, "Reject ratio: %.1f%%", v6 / v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/api_new.c",
          147,
          "print_summary",
          13,
          2245,
          80,
          v12);
      }
    }
  }
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "Summary of per device statistics:");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/api_new.c",
    147,
    "print_summary",
    13,
    2250,
    80,
    v12);
  v14 = 0;
  result = get_all_created_runtime(&v14);
  v21 = result;
  v22 = 0;
  for ( j = 0; j < v14; ++j )
  {
    v22 = snprintf(
            v13,
            0x1000u,
            "chain %d device %d wc %llu nc %llu detail: ",
            *(_DWORD *)(v21[j] + 252),
            *(_DWORD *)(v21[j] + 248),
            *(_QWORD *)(v21[j] + 440),
            *(_QWORD *)(v21[j] + 448));
    v20 = *(_DWORD *)(v21[j] + 336);
    for ( k = 0; k < v20; ++k )
    {
      v19 = *(_DWORD *)(v21[j] + 456) + 48 * k;
      v9 = snprintf(&v13[v22], 4096 - v22, "%d:", k + 1);
      v22 += v9;
      for ( m = 0; m <= 5; ++m )
      {
        v10 = snprintf(&v13[v22], 4096 - v22, " %llu", *(_QWORD *)(v19 + 8 * m));
        v22 += v10;
      }
      v11 = snprintf(&v13[v22], 4096 - v22, " /");
      v22 += v11;
    }
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "%s", v13);
    V_UNLOCK();
    result = (_DWORD *)zlog(
                         g_zc,
                         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rele"
                         "ase/build/godminer-origin_godminer-branch1/api_new.c",
                         147,
                         "print_summary",
                         13,
                         2270,
                         80,
                         v12);
  }
  return result;
}
// 26B64: variable 'v0' is possibly undefined
// 26C40: variable 'v1' is possibly undefined
// 2734C: variable 'v2' is possibly undefined
// 27380: variable 'v4' is possibly undefined
// 27BD4: variable 'v5' is possibly undefined
// 27C08: variable 'v7' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512A0: using guessed type int dword_1512A0;
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;
// 160990: using guessed type double total_stale;
// 160998: using guessed type double total_diff_accepted;
// 1609A8: using guessed type double total_diff_rejected;
// 1609B0: using guessed type int total_ro;
// 1609B8: using guessed type int total_go;
// 1609C0: using guessed type double total_accepted;
// 1609C8: using guessed type double total_getworks;
// 1609D0: using guessed type double total_diff_stale;
// 1609D8: using guessed type int new_blocks;
// 1609DC: using guessed type int local_work;
// 1609E0: using guessed type double total_rejected;

//----- (00027FF4) --------------------------------------------------------
int __fastcall sub_27FF4(const char *a1, signed int a2, int a3)
{
  _QWORD dest[2]; // [sp+10h] [bp-1Ch] BYREF
  int v7; // [sp+20h] [bp-Ch]
  int i; // [sp+24h] [bp-8h]

  v7 = 0;
  i = 0;
  memset(dest, 0, sizeof(dest));
  if ( !a1 || a2 <= 0 || a2 > 16 )
    return -2147483646;
  strncpy((char *)dest, a1, a2);
  if ( a3 )
  {
    if ( a3 == 1 || a3 == 2 )
    {
      for ( i = 0; (&old_cmds)[4 * i]; ++i )
      {
        if ( !strcmp((const char *)dest, (&old_cmds)[4 * i]) )
          return i;
      }
    }
  }
  else
  {
    for ( i = 0; new_cmds[3 * i]; ++i )
    {
      if ( !strcmp((const char *)dest, new_cmds[3 * i]) )
        return i;
    }
  }
  return -2147483645;
}
// 14D414: using guessed type char *old_cmds;
// 14D514: using guessed type char *new_cmds[2];

//----- (00028180) --------------------------------------------------------
int sub_28180()
{
  int *v1; // r0
  int *v2; // r0
  char *v3; // r0
  char v5[20]; // [sp+10h] [bp-1054h] BYREF
  int optval; // [sp+1010h] [bp-54h] BYREF
  struct addrinfo *pai; // [sp+1014h] [bp-50h] BYREF
  addrinfo req; // [sp+1018h] [bp-4Ch] BYREF
  char s[12]; // [sp+1038h] [bp-2Ch] BYREF
  time_t v10; // [sp+1044h] [bp-20h]
  socklen_t v11; // [sp+1048h] [bp-1Ch]
  char *v12; // [sp+104Ch] [bp-18h]
  __int16 v13; // [sp+1052h] [bp-12h]
  int v14; // [sp+1054h] [bp-10h]
  int fd; // [sp+1058h] [bp-Ch]
  struct addrinfo *i; // [sp+105Ch] [bp-8h]

  v13 = 4028;
  fd = 0;
  v14 = 0;
  sprintf(s, "%d", 4028);
  memset(&req, 0, sizeof(req));
  req.ai_flags = 1;
  req.ai_family = 0;
  if ( getaddrinfo("0.0.0.0", s, &req, &pai) )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s: exec getaddrinfo() failed", "api_init_socket");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "api_init_socket",
      15,
      2352,
      100,
      v5);
    return -2147483642;
  }
  else
  {
    for ( i = pai; i; i = i->ai_next )
    {
      fd = socket(pai->ai_family, 1, 0);
      if ( fd > 0 )
        break;
    }
    if ( fd == -1 )
    {
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "%s: exec socket() failed", "api_init_socket");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "api_init_socket",
        15,
        2367,
        100,
        v5);
      return -2147483642;
    }
    else
    {
      optval = 1;
      v11 = 4;
      setsockopt(fd, 1, 2, &optval, 4u);
      v10 = time(0);
      while ( !v14 )
      {
        if ( bind(fd, i->ai_addr, i->ai_addrlen) >= 0 )
        {
          v14 = 1;
        }
        else
        {
          v1 = _errno_location();
          v12 = strerror(*v1);
          if ( time(0) - v10 > 61 )
            break;
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, "%s: api bind to port %d failed, trying again in 30sec", "api_init_socket", v13);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/api_new.c",
            147,
            "api_init_socket",
            15,
            2385,
            80,
            v5);
          sleep(0x1Eu);
        }
      }
      freeaddrinfo(pai);
      if ( v14 )
      {
        if ( listen(fd, 100) >= 0 )
        {
          return fd;
        }
        else
        {
          V_LOCK();
          v2 = _errno_location();
          v3 = strerror(*v2);
          logfmt_raw(v5, 0x1000u, 0, "%s: exec listen() failed (%s)", "api_init_socket", v3);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/api_new.c",
            147,
            "api_init_socket",
            15,
            2401,
            100,
            v5);
          close(fd);
          return -2147483642;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, "api bind to port %d, failed (%s)", v13, v12);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/api_new.c",
          147,
          "api_init_socket",
          15,
          2395,
          100,
          v5);
        return -2147483642;
      }
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0002863C) --------------------------------------------------------
int __fastcall sub_2863C(const char *a1, int a2, char *a3, char *a4, _DWORD *a5)
{
  const char *v5; // r0
  const char *v6; // r0
  char v11[12]; // [sp+20h] [bp-110Ch] BYREF
  _BYTE v12[252]; // [sp+1020h] [bp-10Ch] BYREF
  const json_t *v13; // [sp+111Ch] [bp-10h]
  const json_t *v14; // [sp+1120h] [bp-Ch]
  int v15; // [sp+1124h] [bp-8h]

  v15 = 0;
  v14 = 0;
  v13 = 0;
  v14 = json_loads((int)a1, 0, (json_error_t *)v12);
  if ( v14 && !*(_DWORD *)v14 )
  {
    v13 = json_object_get(v14, "command");
    if ( v13 && *(_DWORD *)v13 == 2 )
    {
      v5 = json_string_value(v13);
      snprintf(a3, 0x10u, "%s", v5);
      v13 = json_object_get(v14, "new_api");
      if ( v13 && *(_DWORD *)v13 == 5 )
      {
        *a5 = 0;
      }
      else
      {
        v13 = json_object_get(v14, "parameter");
        if ( v13 && *(_DWORD *)v13 == 2 )
        {
          v6 = json_string_value(v13);
          snprintf(a4, 0x20u, "%s", v6);
        }
        *a5 = 1;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "%s error: format error about command", "parse_recv_buf");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "parse_recv_buf",
        14,
        2439,
        100,
        v11);
      v15 = -2147483641;
    }
    sub_1D5B0((int)v14);
  }
  else
  {
    *a5 = 2;
    snprintf(a3, 0x10u, "%s", a1);
  }
  return v15;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000288B8) --------------------------------------------------------
int __fastcall sub_288B8(int result, char *a2)
{
  int v2; // r3
  bool v3; // r3
  size_t v4; // r4
  int *v5; // r0
  char *v6; // r0
  bool v7; // r3
  int *v9; // [sp+14h] [bp-10C0h]
  fd_set v10; // [sp+1Ch] [bp-10B8h] BYREF
  char v11[56]; // [sp+9Ch] [bp-1038h] BYREF
  struct timeval timeout; // [sp+109Ch] [bp-38h] BYREF
  fd_set *v13; // [sp+10A4h] [bp-30h]
  int v14; // [sp+10A8h] [bp-2Ch]
  int v15; // [sp+10ACh] [bp-28h]
  int v16; // [sp+10B0h] [bp-24h]
  void *buf; // [sp+10B4h] [bp-20h]
  unsigned int i; // [sp+10B8h] [bp-1Ch]
  int v19; // [sp+10BCh] [bp-18h]
  size_t n; // [sp+10C0h] [bp-14h]
  bool v21; // [sp+10C7h] [bp-Dh]

  v9 = (int *)result;
  v19 = 0;
  n = 0;
  v21 = 0;
  v15 = 0;
  v14 = 0;
  v16 = 0;
  buf = 0;
  if ( result && a2 )
  {
    result = strlen(a2);
    v19 = result + 1;
    buf = a2;
    n = result + 1;
    while ( !v21 )
    {
      timeout.tv_sec = 0;
      timeout.tv_usec = 50000;
      v13 = &v10;
      for ( i = 0; i <= 0x1F; ++i )
        v13->__fds_bits[i] = 0;
      v2 = *v9 & 0x1F;
      if ( *v9 <= 0 )
        v2 = -(-*v9 & 0x1F);
      v10.__fds_bits[*v9 / 32] |= 1 << v2;
      v15 = select(*v9 + 1, 0, &v10, 0, &timeout);
      if ( v15 <= 0 )
      {
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, "%s: send select failed, ret = %d", "send_api_result", v15);
        V_UNLOCK();
        return zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/buil"
                 "d/godminer-origin_godminer-branch1/api_new.c",
                 147,
                 "send_api_result",
                 15,
                 2489,
                 100,
                 v11);
      }
      result = send(*v9, buf, n, 0);
      v14 = result;
      if ( result >= 0 )
      {
        n -= v14;
        buf = (char *)buf + v14;
        if ( !v14 )
          ++v16;
        v7 = (int)n <= 0 || v16 > 2;
        v21 = v7;
      }
      else
      {
        ++v16;
        if ( *_errno_location() != 11 && *_errno_location() != 11 )
        {
          V_LOCK();
          v4 = v19 - n;
          v5 = _errno_location();
          v6 = strerror(*v5);
          logfmt_raw(v11, 0x1000u, 0, "%s: send (%d:%d) failed %s", "send_api_result", v19, v4, v6);
          V_UNLOCK();
          return zlog(
                   g_zc,
                   "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bu"
                   "ild/godminer-origin_godminer-branch1/api_new.c",
                   147,
                   "send_api_result",
                   15,
                   2503,
                   100,
                   v11);
        }
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, "%s: send EAGAIN ", "send_api_result");
        V_UNLOCK();
        result = zlog(
                   g_zc,
                   "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bu"
                   "ild/godminer-origin_godminer-branch1/api_new.c",
                   147,
                   "send_api_result",
                   15,
                   2499,
                   20,
                   v11);
        v3 = (int)n <= 0 || v16 > 2;
        v21 = v3;
      }
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00028D88) --------------------------------------------------------
int __fastcall sub_28D88(json_t *a1, const char *a2, int a3, unsigned int a4)
{
  int v4; // r3
  size_t v5; // r0
  json_t *v6; // r0
  char s[100]; // [sp+14h] [bp-78h] BYREF
  int v13; // [sp+78h] [bp-14h]
  int v14; // [sp+7Ch] [bp-10h]

  v14 = -2147483647;
  v13 = 0;
  memset(s, 0, sizeof(s));
  if ( !a2 || !a1 || a4 > 2 )
    return -2147483646;
  v5 = strlen(a2);
  v14 = sub_27FF4(a2, v5, a4);
  if ( v14 >= 0 )
  {
    v13 = v14;
    if ( !a4 )
    {
      v14 = ((int (__fastcall *)(json_t *, char **))new_cmds[3 * v13 + 2])(a1, &new_cmds[3 * v13]);
      v4 = v14;
      if ( v14 >= 0 )
        return v4;
      if ( v14 == -2147483646 )
        strcpy(s, "bad param");
      goto LABEL_10;
    }
    if ( a3 )
      v14 = ((int (__fastcall *)(json_t *, char **, int))(&old_cmds)[4 * v13 + 3])(a1, &(&old_cmds)[4 * v13], a3);
    else
      v14 = ((int (__fastcall *)(json_t *, char **, _DWORD))(&old_cmds)[4 * v13 + 3])(a1, &(&old_cmds)[4 * v13], 0);
  }
  else
  {
    if ( !a4 )
    {
      if ( v14 == -2147483645 )
        snprintf(s, 0x64u, "not support (%s)", a2);
      else
        strcpy(s, "bad param");
LABEL_10:
      v6 = (json_t *)json_string(s);
      json_object_set_new(a1, "error_message", v6);
      return v4;
    }
    v4 = v14;
    if ( v14 == -2147483645 )
      sub_20F64((int)a1, 0, 14, "Invalid command");
  }
  return v4;
}
// 28F94: conditional instruction was optimized away because %var_84.4==2
// 29028: variable 'v4' is possibly undefined
// 14D414: using guessed type char *old_cmds;
// 14D514: using guessed type char *new_cmds[2];

//----- (00029034) --------------------------------------------------------
int *__fastcall sub_29034(int *result)
{
  int *v1; // [sp+Ch] [bp-8h]

  byte_151282 = 1;
  v1 = result;
  if ( *result != -1 )
  {
    shutdown(*result, 2);
    result = (int *)close(*v1);
    *v1 = -1;
  }
  return result;
}
// 151282: using guessed type char byte_151282;

//----- (000290A8) --------------------------------------------------------
char *__fastcall sub_290A8(char *a1, const json_t *a2)
{
  double v2; // d0
  char *result; // r0
  __int64 v4; // r0
  const char *v5; // r0
  char s[256]; // [sp+10h] [bp-104h] BYREF

  result = (char *)memset(s, 0, sizeof(s));
  if ( a1 && a2 )
  {
    switch ( *(_DWORD *)a2 )
    {
      case 6:
        strcpy(s, "false");
        break;
      case 5:
        strcpy(s, "true");
        break;
      case 3:
        v4 = json_integer_value((int)a2);
        snprintf(s, 0x100u, "%lld", v4);
        break;
      case 4:
        json_real_value();
        snprintf(s, 0x100u, "%.2lf", v2);
        break;
      case 2:
        v5 = json_string_value(a2);
        snprintf(s, 0x100u, "%s", v5);
        break;
    }
    return strcat(a1, s);
  }
  return result;
}
// 290F0: conditional instruction was optimized away because %var_108.4!=0
// 2912C: conditional instruction was optimized away because %var_108.4!=0
// 29168: conditional instruction was optimized away because %var_108.4!=0
// 291B0: conditional instruction was optimized away because %var_108.4!=0
// 291F8: conditional instruction was optimized away because %var_108.4!=0
// 291E8: variable 'v2' is possibly undefined

//----- (0002924C) --------------------------------------------------------
const json_t *__fastcall sub_2924C(char *a1, const json_t *a2)
{
  const json_t *result; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  _DWORD v9[5]; // [sp+Ch] [bp-138h]
  char s[256]; // [sp+20h] [bp-124h] BYREF
  signed int v11; // [sp+120h] [bp-24h]
  int v12; // [sp+124h] [bp-20h]
  const json_t *v13; // [sp+128h] [bp-1Ch]
  json_t *v14; // [sp+12Ch] [bp-18h]
  char *src; // [sp+130h] [bp-14h]
  signed int j; // [sp+134h] [bp-10h]
  int i; // [sp+138h] [bp-Ch]
  const json_t *v18; // [sp+13Ch] [bp-8h]

  v18 = 0;
  v14 = 0;
  v13 = 0;
  memset(s, 0, sizeof(s));
  j = 0;
  result = (const json_t *)"SUMMARY";
  v9[0] = "SUMMARY";
  v9[1] = "POOLS";
  v9[2] = "STATS";
  v9[3] = "DEVS";
  v9[4] = "VERSION";
  src = 0;
  v11 = 0;
  v12 = 5;
  for ( i = 0; i < v12; ++i )
  {
    result = json_object_get(a2, (const char *)v9[i]);
    v18 = result;
    if ( result )
    {
      if ( *(_DWORD *)v18 == 1 )
        break;
    }
  }
  if ( i < v12 )
  {
    if ( !i || i == 4 )
    {
      snprintf(s, 0x100u, "%s,", (const char *)v9[i]);
      strcat(a1, s);
    }
    result = (const json_t *)json_array_size(v18);
    v11 = (signed int)result;
    for ( j = 0; j < v11; ++j )
    {
      result = json_array_get(v18, j);
      v14 = result;
      if ( result && !*(_DWORD *)v14 )
      {
        v3 = json_object_iter(v14);
        for ( src = (char *)json_object_iter_key(v3); src; src = (char *)json_object_iter_key(v5) )
        {
          v6 = json_object_key_to_iter(src);
          v13 = (const json_t *)json_object_iter_value(v6);
          if ( !v13 )
            break;
          strcat(a1, src);
          *(_WORD *)&a1[strlen(a1)] = 61;
          sub_290A8(a1, v13);
          *(_WORD *)&a1[strlen(a1)] = 44;
          v4 = json_object_key_to_iter(src);
          v5 = json_object_iter_next(v14, v4);
        }
        result = (const json_t *)strlen(a1);
        *((_BYTE *)result + (_DWORD)a1 - 1) = 124;
        if ( j != v11 - 1 )
        {
          result = (const json_t *)strlen(a1);
          *((_BYTE *)result + (_DWORD)a1) = 44;
        }
      }
    }
  }
  return result;
}

//----- (00029550) --------------------------------------------------------
int __fastcall sub_29550(const json_t *a1, char *a2)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  const json_t *v10; // [sp+14h] [bp-18h]
  json_t *v11; // [sp+18h] [bp-14h]
  json_t *v12; // [sp+1Ch] [bp-10h]
  char *src; // [sp+24h] [bp-8h]

  if ( !a1 || !a2 )
    return -2147483641;
  v12 = json_object_get(a1, "STATUS");
  if ( !v12 || *(_DWORD *)v12 != 1 )
    return -2147483646;
  v11 = json_array_get(v12, 0);
  if ( !v11 || *(_DWORD *)v11 )
    return -2147483646;
  v3 = json_object_iter(v11);
  for ( src = (char *)json_object_iter_key(v3); src; src = (char *)json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(src);
    v10 = (const json_t *)json_object_iter_value(v6);
    if ( !v10 )
      break;
    strcat(a2, src);
    *(_WORD *)&a2[strlen(a2)] = 61;
    sub_290A8(a2, v10);
    *(_WORD *)&a2[strlen(a2)] = 44;
    v4 = json_object_key_to_iter(src);
    v5 = json_object_iter_next(v11, v4);
  }
  a2[strlen(a2) - 1] = 124;
  sub_2924C(a2, a1);
  return 0;
}

//----- (00029740) --------------------------------------------------------
int __fastcall sub_29740(int a1, int a2)
{
  const char *v3; // r0
  size_t v4; // r0
  char s[16]; // [sp+10h] [bp-13Ch] BYREF
  _BYTE v8[252]; // [sp+20h] [bp-12Ch] BYREF
  void *ptr; // [sp+11Ch] [bp-30h]
  json_t *v10; // [sp+120h] [bp-2Ch]
  char *v11; // [sp+124h] [bp-28h]
  const json_t *v12; // [sp+128h] [bp-24h]
  json_t *v13; // [sp+12Ch] [bp-20h]
  const json_t *v14; // [sp+130h] [bp-1Ch]
  const json_t *v15; // [sp+134h] [bp-18h]
  int v16; // [sp+138h] [bp-14h]
  int v17; // [sp+13Ch] [bp-10h]
  unsigned int v18; // [sp+140h] [bp-Ch]
  signed int i; // [sp+144h] [bp-8h]

  v16 = 0;
  i = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  memset(s, 0, sizeof(s));
  v17 = 0;
  ptr = 0;
  v15 = json_loads(a2, 0, (json_error_t *)v8);
  if ( !v15 || *(_DWORD *)v15 )
    return -2147483645;
  v14 = json_object_get(v15, "command");
  if ( v14 && *(_DWORD *)v14 == 1 )
  {
    v13 = json_object_get(v15, "new_api");
    v18 = !v13 || *(_DWORD *)v13 != 5;
    v11 = json_object();
    for ( i = 0; ; ++i )
    {
      v4 = json_array_size(v14);
      if ( v4 <= i )
        break;
      v12 = json_array_get(v14, i);
      if ( !v12 || i > 10 )
        break;
      if ( *(_DWORD *)v12 == 2 )
      {
        memset(s, 0, sizeof(s));
        v3 = json_string_value(v12);
        snprintf(s, 0x10u, "%s", v3);
        if ( strcmp(s, "reload") || v18 )
        {
          v10 = (json_t *)json_object();
          sub_28D88(v10, s, 0, v18);
          json_object_set_new((json_t *)v11, s, v10);
        }
        else
        {
          v17 = 1;
        }
      }
    }
    ptr = json_dumps(v11, 24576);
    sub_288B8(a1, (char *)ptr);
    free(ptr);
    if ( v17 == 1 )
      sub_28D88((json_t *)v11, "reload", 0, 0);
    sub_1D5B0((int)v11);
    sub_1D5B0((int)v15);
    return v16;
  }
  else
  {
    sub_1D5B0((int)v15);
    return -2147483645;
  }
}
// 2989C: conditional instruction was optimized away because %var_20.4!=0

//----- (00029A00) --------------------------------------------------------
char __fastcall sub_29A00(char result)
{
  byte_151281 = result;
  return result;
}
// 151281: using guessed type char byte_151281;

//----- (00029A34) --------------------------------------------------------
int is_fixed_freq_mode()
{
  return (unsigned __int8)byte_151281;
}
// 151281: using guessed type char byte_151281;

//----- (00029A58) --------------------------------------------------------
int api()
{
  int result; // r0
  int *v1; // r0
  char *v2; // r0
  size_t v3; // r0
  struct __jmp_buf_tag v4; // [sp+10h] [bp-B20Ch] BYREF
  char v5[244]; // [sp+128h] [bp-B0F4h] BYREF
  char v6[244]; // [sp+1128h] [bp-A0F4h] BYREF
  char v7[244]; // [sp+2128h] [bp-90F4h] BYREF
  char v8[244]; // [sp+3128h] [bp-80F4h] BYREF
  char v9[244]; // [sp+4128h] [bp-70F4h] BYREF
  char v10[244]; // [sp+5128h] [bp-60F4h] BYREF
  char v11[244]; // [sp+6128h] [bp-50F4h] BYREF
  char v12[244]; // [sp+7128h] [bp-40F4h] BYREF
  _DWORD v13[2]; // [sp+8128h] [bp-30F4h] BYREF
  int v14; // [sp+8130h] [bp-30ECh] BYREF
  int v15; // [sp+8134h] [bp-30E8h] BYREF
  int v16; // [sp+8138h] [bp-30E4h] BYREF
  unsigned int v17; // [sp+813Ch] [bp-30E0h] BYREF
  char v18[32]; // [sp+8140h] [bp-30DCh] BYREF
  char v19[16]; // [sp+8160h] [bp-30BCh] BYREF
  char v20[4096]; // [sp+8170h] [bp-30ACh] BYREF
  char v21[8192]; // [sp+9170h] [bp-20ACh] BYREF
  socklen_t addr_len; // [sp+B170h] [bp-ACh] BYREF
  struct sockaddr addr; // [sp+B174h] [bp-A8h] BYREF
  int v24; // [sp+B1F4h] [bp-28h] BYREF
  int fd; // [sp+B1F8h] [bp-24h] BYREF
  int v26; // [sp+B1FCh] [bp-20h]
  ssize_t v27; // [sp+B200h] [bp-1Ch]
  char *v28; // [sp+B204h] [bp-18h]
  void *ptr; // [sp+B208h] [bp-14h]
  int *p_fd; // [sp+B20Ch] [bp-10h]
  void (__fastcall *v31)(int *); // [sp+B210h] [bp-Ch]

  v26 = 0;
  fd = -1;
  v24 = -1;
  v27 = 0;
  memset(v21, 0, sizeof(v21));
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  memset(v18, 0, sizeof(v18));
  v17 = 2;
  v28 = 0;
  ptr = 0;
  result = is_fixed_freq_mode();
  if ( !result )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Start api function");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/api_new.c",
      147,
      "api",
      3,
      2800,
      60,
      v5);
    v31 = (void (__fastcall *)(int *))sub_29034;
    p_fd = &fd;
    if ( _sigsetjmp(&v4, 0) )
    {
      v31(p_fd);
      _pthread_unwind_next((__pthread_unwind_buf_t *)&v4);
    }
    _pthread_register_cancel((__pthread_unwind_buf_t *)&v4);
    v26 = sub_28180();
    if ( v26 >= 0 )
    {
      fd = v26;
      sub_29A00(1);
      while ( byte_151282 != 1 )
      {
        addr_len = 128;
        v24 = accept(fd, &addr, &addr_len);
        if ( v24 < 0 )
        {
          V_LOCK();
          v1 = _errno_location();
          v2 = strerror(*v1);
          logfmt_raw(v7, 0x1000u, 0, "%s: exec accept failed (%s)", "api", v2);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/api_new.c",
            147,
            "api",
            3,
            2820,
            100,
            v7);
          break;
        }
        v16 = 1;
        v15 = 5;
        v14 = 2;
        setsockopt(v24, 1, 9, &v16, 4u);
        setsockopt(v24, 6, 1, &v16, 4u);
        setsockopt(v24, 6, 6, &v16, 4u);
        setsockopt(v24, 6, 4, &v15, 4u);
        setsockopt(v24, 6, 5, &v14, 4u);
        v13[0] = 10;
        v13[1] = 0;
        v26 = setsockopt(v24, 1, 21, v13, 8u);
        if ( v26 )
        {
          V_LOCK();
          logfmt_raw(v8, 0x1000u, 0, "%s:setsocket SO_SNDTIMEO failed\n", "api");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/api_new.c",
            147,
            "api",
            3,
            2839,
            100,
            v8);
          close(v24);
        }
        v26 = setsockopt(v24, 1, 20, v13, 8u);
        if ( v26 )
        {
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, "%s:setsocket SO_RCVTIMEO failed\n", "api");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/api_new.c",
            147,
            "api",
            3,
            2845,
            100,
            v9);
          close(v24);
        }
        v27 = recv(v24, v21, 0xFFFu, 0);
        if ( v27 >= 0 )
        {
          v21[v27] = 0;
          memset(v19, 0, sizeof(v19));
          memset(v18, 0, sizeof(v18));
          memset(byte_151288, 0, sizeof(byte_151288));
          dword_151284 = time(0);
          getnameinfo(&addr, 0x80u, byte_151288, 0x10u, 0, 0, 1u);
          V_LOCK();
          logfmt_raw(v10, 0x1000u, 0, "connect_addr: %s", byte_151288);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/api_new.c",
            147,
            "api",
            3,
            2862,
            20,
            v10);
          strlen(v21);
          v26 = sub_29740((int)&v24, (int)v21);
          if ( v26 )
          {
            v28 = json_object();
            v3 = strlen(v21);
            v26 = sub_2863C(v21, v3 + 1, v19, v18, &v17);
            if ( v26 >= 0 )
            {
              sub_28D88((json_t *)v28, v19, (int)v18, v17);
            }
            else
            {
              V_LOCK();
              logfmt_raw(v11, 0x1000u, 0, "%s: input invaild param format", "api");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/api_new.c",
                147,
                "api",
                3,
                2877,
                100,
                v11);
              sub_20F64((int)v28, 0, 24, "Missing JSON 'command'");
            }
            if ( v17 == 2 )
            {
              memset(v20, 0, sizeof(v20));
              sub_29550((const json_t *)v28, v20);
              sub_288B8((int)&v24, v20);
              sub_1D5B0((int)v28);
            }
            else
            {
              ptr = json_dumps(v28, 24576);
              sub_288B8((int)&v24, (char *)ptr);
              sub_1D5B0((int)v28);
              free(ptr);
            }
          }
        }
        else
        {
          v21[0] = 0;
        }
        close(v24);
      }
      _pthread_unregister_cancel((__pthread_unwind_buf_t *)&v4);
      v31(p_fd);
      sub_29A00(0);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "End api function !!!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/api_new.c",
        147,
        "api",
        3,
        2908,
        60,
        v12);
      return close(fd);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "%s: init socket failed", "api");
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/api_new.c",
               147,
               "api",
               3,
               2807,
               100,
               v6);
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151282: using guessed type char byte_151282;
// 151284: using guessed type int dword_151284;
// 1608F0: using guessed type int g_zc;

//----- (0002A4D0) --------------------------------------------------------
void __fastcall sub_2A4D0(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (0002A538) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_2A538(int a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (0002A570) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_2A570(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0002A5A4) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_2A5A4(int a1, __int64 a2)
{
  V_INT(a1, "poolno", a2);
}

//----- (0002A5D8) --------------------------------------------------------
int __fastcall sub_2A5D8(int a1, void *(*a2)(void *))
{
  int v5; // [sp+Ch] [bp-8h]

  pthread_attr_init((pthread_attr_t *)(a1 + 8));
  v5 = pthread_create((pthread_t *)(a1 + 4), (const pthread_attr_t *)(a1 + 8), a2, (void *)a1);
  pthread_attr_destroy((pthread_attr_t *)(a1 + 8));
  return v5;
}

//----- (0002A644) --------------------------------------------------------
void __fastcall sub_2A644(int a1)
{
  if ( *(_DWORD *)(a1 + 1124) )
  {
    free(*(void **)(a1 + 1124));
    *(_DWORD *)(a1 + 1124) = 0;
  }
}

//----- (0002A68C) --------------------------------------------------------
void *__fastcall sub_2A68C(_DWORD *a1, const char **a2)
{
  void *result; // r0

  result = memcpy(a1, a2, 0x470u);
  if ( a2[281] )
  {
    result = strdup(a2[281]);
    a1[281] = result;
  }
  return result;
}

//----- (0002A6EC) --------------------------------------------------------
int __fastcall sub_2A6EC(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 2A758: variable 'v3' is possibly undefined

//----- (0002A804) --------------------------------------------------------
int __fastcall sub_2A804(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0002A878) --------------------------------------------------------
int __fastcall sub_2A878(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/util.h",
    144,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0002A99C) --------------------------------------------------------
_BYTE *__fastcall sub_2A99C(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0002AA08) --------------------------------------------------------
int __fastcall get_currentalgo(char *a1, size_t a2)
{
  return snprintf(a1, a2, "%s", off_14D568[opt_algo]);
}
// 14D568: using guessed type char *off_14D568[18];
// 14D664: using guessed type int opt_algo;

//----- (0002AA54) --------------------------------------------------------
int __fastcall workio_submit_work(int a1, pthread_mutex_t *a2)
{
  unsigned int v3; // r2
  char v7[28]; // [sp+38h] [bp-1C5Ch] BYREF
  _BYTE v8[12]; // [sp+1038h] [bp-C5Ch] BYREF
  _DWORD v9[7]; // [sp+1C38h] [bp-5Ch] BYREF
  int v10; // [sp+1C54h] [bp-40h]
  _DWORD v11[7]; // [sp+1C58h] [bp-3Ch] BYREF
  int v12; // [sp+1C74h] [bp-20h]
  unsigned __int8 v13; // [sp+1C7Fh] [bp-15h]
  int v14; // [sp+1C80h] [bp-14h]
  int v15; // [sp+1C84h] [bp-10h]

  v15 = 0;
  v14 = frontend_runtime_instance();
  if ( pool_tget(a2, (unsigned __int8 *)&a2[79].__size[8]) )
  {
    V_LOCK();
    sub_2A5A4((int)v9, a2->__lock);
    logfmt_raw(v7, 0x1000u, 0, v10, v9[0], v9[1], v9[2], v9[3], v9[4], v9[5], v9[6], v10, "submit idle pool's nonce.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "workio_submit_work",
      18,
      148,
      20,
      v7);
    return 0;
  }
  else
  {
    update_pool_diff1_of_all_runtimes((int)a2);
    (*(void (__fastcall **)(int, pthread_mutex_t *, _BYTE *))(v14 + 32))(a1, a2, v8);
    do
    {
      v13 = (*(int (__fastcall **)(pthread_mutex_t *, _BYTE *))(v14 + 12))(a2, v8);
      if ( v13 != 1 )
      {
        ++total_ro;
        ++a2[81].__owner;
        v3 = dword_151854++;
        if ( !(v3 % 0x2710) )
        {
          V_LOCK();
          sub_2A5A4((int)v11, a2->__lock);
          logfmt_raw(
            v7,
            0x1000u,
            0,
            v12,
            v11[0],
            v11[1],
            v11[2],
            v11[3],
            v11[4],
            v11[5],
            v11[6],
            v12,
            "submit_upstream_work stratum_send_line failed %d count %d",
            v13,
            v15);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/god-miner.c",
            149,
            "workio_submit_work",
            18,
            162,
            100,
            v7);
        }
      }
      ++v15;
    }
    while ( v15 <= 3 && v13 != 1 );
    return v13;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151854: using guessed type int dword_151854;
// 1608F0: using guessed type int g_zc;
// 1609B0: using guessed type int total_ro;

//----- (0002AD78) --------------------------------------------------------
int __fastcall update_recorded_timeout_value(unsigned __int64 a1)
{
  int i; // [sp+8h] [bp-14h]
  int v3; // [sp+Ch] [bp-10h]
  unsigned __int64 v4; // [sp+10h] [bp-Ch]

  v4 = -1;
  v3 = 0;
  for ( i = 0; i <= 9; ++i )
  {
    if ( v4 > max_timeout_value[i] )
    {
      v4 = max_timeout_value[i];
      v3 = i;
    }
  }
  if ( a1 > v4 )
    max_timeout_value[v3] = a1;
  return a1;
}
// 1512D0: using guessed type _QWORD max_timeout_value[10];

//----- (0002AE48) --------------------------------------------------------
void __fastcall __noreturn work_generator_thread(_DWORD *a1)
{
  int v1; // r0
  bool v2; // r3
  char v3[40]; // [sp+1Ch] [bp-14E8h] BYREF
  struct timespec v4; // [sp+101Ch] [bp-4E8h] BYREF
  struct timespec abstime; // [sp+1024h] [bp-4E0h] BYREF
  int v6; // [sp+102Ch] [bp-4D8h] BYREF
  _DWORD v7[285]; // [sp+1030h] [bp-4D4h] BYREF
  int *v8; // [sp+14A4h] [bp-60h]
  struct timespec *v9; // [sp+14A8h] [bp-5Ch]
  int *v10; // [sp+14ACh] [bp-58h]
  int *v11; // [sp+14B0h] [bp-54h]
  int v12; // [sp+14B4h] [bp-50h]
  struct timespec *p_abstime; // [sp+14B8h] [bp-4Ch]
  int v14; // [sp+14BCh] [bp-48h]
  struct timespec *tp; // [sp+14C0h] [bp-44h]
  int v16; // [sp+14C4h] [bp-40h]
  int v17; // [sp+14C8h] [bp-3Ch]
  _DWORD *v18; // [sp+14CCh] [bp-38h]
  _DWORD *all_created_runtime; // [sp+14D0h] [bp-34h]
  int v20; // [sp+14D4h] [bp-30h]
  int i; // [sp+14D8h] [bp-2Ch]
  char v22; // [sp+14DFh] [bp-25h]
  double v23; // [sp+14E0h] [bp-24h]
  int v24; // [sp+14E8h] [bp-1Ch]
  char *s; // [sp+14ECh] [bp-18h]
  int current_pool; // [sp+14F0h] [bp-14h]
  int v27; // [sp+14F4h] [bp-10h]

  v18 = a1;
  v17 = *a1;
  v6 = 0;
  v20 = frontend_runtime_instance();
  all_created_runtime = get_all_created_runtime(&v6);
  v24 = 0;
  v23 = NAN;
  v22 = 0;
  memset(v7, 0, 0x470u);
  for ( i = 0; i < v6; ++i )
  {
    if ( *(_QWORD *)&v23 > *(_QWORD *)(all_created_runtime[i] + 1120) )
      v23 = *(double *)(all_created_runtime[i] + 1120);
  }
  s = (char *)calloc(1u, 0x40u);
  snprintf(s, 0x40u, "%.10s_%d", "work_generator_thread", 0);
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v3, 0x1000u, 0, "%s on pid %ld", s, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/god-miner.c",
    149,
    "work_generator_thread",
    21,
    208,
    40,
    v3);
  prctl(15, s);
  tp = (struct timespec *)&send_job_timer;
  clock_gettime(1, (struct timespec *)&send_job_timer);
  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v27 = 0;
              current_pool = get_current_pool();
              if ( current_pool )
                break;
              V_LOCK();
              logfmt_raw(v3, 0x1000u, 0, "work generator: current pool is NULL");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/god-miner.c",
                149,
                "work_generator_thread",
                21,
                227,
                20,
                v3);
            }
            if ( !pool_tget((pthread_mutex_t *)current_pool, (unsigned __int8 *)(current_pool + 1904)) )
              break;
            sleep(0);
          }
          v14 = LODWORD(v23);
          p_abstime = &abstime;
          clock_gettime(1, &v4);
          v12 = v4.tv_nsec + 1000 * (v14 - (_DWORD)&unk_F4240 * (v14 / 1000000));
          p_abstime->tv_sec = v4.tv_sec + v12 / 1000000000 + v14 / 1000000;
          p_abstime->tv_nsec = v12 % 1000000000;
          v16 = pool_twait_to_be_expected_and_set(current_pool, (_BYTE *)(current_pool + 1916), 1, 0, &abstime);
          if ( v16 != 1 )
            break;
          V_LOCK();
          logfmt_raw(v3, 0x1000u, 0, "pool has been changed");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/god-miner.c",
            149,
            "work_generator_thread",
            21,
            239,
            20,
            v3);
          sleep(0);
        }
        if ( v16 == 110 )
        {
          V_LOCK();
          logfmt_raw(v3, 0x1000u, 0, "Wait for new job timeout");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/god-miner.c",
            149,
            "work_generator_thread",
            21,
            243,
            20,
            v3);
        }
        else
        {
          V_LOCK();
          logfmt_raw(v3, 0x1000u, 0, "New job has come");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/god-miner.c",
            149,
            "work_generator_thread",
            21,
            245,
            20,
            v3);
        }
        pthread_mutex_lock((pthread_mutex_t *)(current_pool + 1592));
        if ( !pool_tget((pthread_mutex_t *)current_pool, (unsigned __int8 *)(current_pool + 1584)) )
          break;
        pthread_mutex_unlock((pthread_mutex_t *)(current_pool + 1592));
        V_LOCK();
        logfmt_raw(
          v3,
          0x1000u,
          0,
          "work generator: jobid %p cancel %d",
          *(_DWORD *)(current_pool + 1580),
          *(unsigned __int8 *)(current_pool + 1584));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/god-miner.c",
          149,
          "work_generator_thread",
          21,
          251,
          20,
          v3);
        sleep(0);
      }
      if ( (*(int (__fastcall **)(_DWORD *, int))(v20 + 36))(v7, current_pool) == 2 )
      {
        V_LOCK();
        logfmt_raw(
          v3,
          0x1000u,
          0,
          "poolno=%d work generator switched to new job %s",
          *(_DWORD *)current_pool,
          *(_DWORD *)(current_pool + 1580));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/god-miner.c",
          149,
          "work_generator_thread",
          21,
          258,
          20,
          v3);
        ++*(_QWORD *)&total_getworks;
        ++*(_DWORD *)(current_pool + 1632);
        sub_2A644((int)v7);
        sub_2A68C(v7, (const char **)(current_pool + 456));
        v22 = 1;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(current_pool + 1592));
    }
    while ( !v7[281] );
    v7[274] = *(_DWORD *)(current_pool + 80);
    for ( i = 0; ; ++i )
    {
      if ( i >= v6 )
        goto LABEL_30;
      pthread_mutex_lock((pthread_mutex_t *)(current_pool + 1592));
      if ( (*(int (__fastcall **)(_DWORD *, int))(v20 + 36))(v7, current_pool) == 2 )
        break;
      v2 = v22 && !i;
      (**(void (__fastcall ***)(_DWORD *, int, int))(v20 + 72))(v7, current_pool, v2);
      pthread_mutex_unlock((pthread_mutex_t *)(current_pool + 1592));
      ++local_work;
      last_getwork = time(0);
      (*(void (__fastcall **)(_DWORD, _DWORD *))(*(_DWORD *)(v20 + 72) + 4))(all_created_runtime[i], v7);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(current_pool + 1592));
LABEL_30:
    if ( v22 )
    {
      v22 = 0;
      V_LOCK();
      v11 = &send_job_timer;
      clock_gettime(1, (struct timespec *)&dword_1609F8);
      logfmt_raw(
        v3,
        0x1000u,
        0,
        "New job pushed after %lld ms",
        (v11[3] - v11[1]) / 1000000
      + vshld_n_s64(4 * (vshld_n_s64(v11[2] - *v11, 5u) - (v11[2] - *v11)) + v11[2] - *v11, 3u));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "work_generator_thread",
        21,
        289,
        20,
        v3);
    }
    else
    {
      V_LOCK();
      v10 = &send_job_timer;
      clock_gettime(1, (struct timespec *)&dword_1609F8);
      logfmt_raw(
        v3,
        0x1000u,
        0,
        "Updated job pushed after %lld ms",
        (v10[3] - v10[1]) / 1000000
      + vshld_n_s64(4 * (vshld_n_s64(v10[2] - *v10, 5u) - (v10[2] - *v10)) + v10[2] - *v10, 3u));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "work_generator_thread",
        21,
        291,
        20,
        v3);
    }
    v8 = &send_job_timer;
    clock_gettime(1, (struct timespec *)&dword_1609F8);
    update_recorded_timeout_value((v8[2] - *v8) * (unsigned __int64)(unsigned int)&unk_F4240 + (v8[3] - v8[1]) / 1000);
    v9 = (struct timespec *)&send_job_timer;
    clock_gettime(1, (struct timespec *)&send_job_timer);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 1609B4: using guessed type int last_getwork;
// 1609C8: using guessed type double total_getworks;
// 1609DC: using guessed type int local_work;
// 1609F0: using guessed type int send_job_timer;
// 1609F8: using guessed type int dword_1609F8;

//----- (0002BA58) --------------------------------------------------------
void __fastcall __noreturn nonce_submit_thread(int a1)
{
  int v1; // r0
  pthread_t v2; // r0
  char v3[36]; // [sp+18h] [bp-2064h] BYREF
  _QWORD v4[4]; // [sp+1018h] [bp-1064h] BYREF
  _DWORD v5[3]; // [sp+1BD0h] [bp-4ACh] BYREF
  int v6; // [sp+2040h] [bp-3Ch] BYREF
  _DWORD *v7; // [sp+2044h] [bp-38h]
  int v8; // [sp+2048h] [bp-34h]
  char *s; // [sp+204Ch] [bp-30h]
  int *all_created_runtime; // [sp+2050h] [bp-2Ch]
  pthread_mutex_t *v11; // [sp+2054h] [bp-28h]
  double v12; // [sp+2058h] [bp-24h]
  int v13; // [sp+2064h] [bp-18h]
  int v14; // [sp+2068h] [bp-14h]
  int v15; // [sp+206Ch] [bp-10h]

  v12 = 0.0;
  v14 = a1;
  v13 = 0;
  v15 = frontend_runtime_instance();
  all_created_runtime = (int *)get_all_created_runtime(&v6);
  s = (char *)calloc(1u, 0x40u);
  snprintf(s, 0x40u, "%.10s_%d", "nonce_submit_thread", 0);
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v3, 0x1000u, 0, "%s on pid %ld", s, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/god-miner.c",
    149,
    "nonce_submit_thread",
    19,
    317,
    40,
    v3);
  prctl(15, s);
  v2 = pthread_self();
  pthread_detach(v2);
  v8 = *all_created_runtime;
  while ( 1 )
  {
    (*(void (__fastcall **)(int, _QWORD *))(v8 + 44))(v8, v4);
    v7 = v4;
    if ( v4[0] >= (unsigned __int64)total_pools )
      v11 = 0;
    else
      v11 = *(pthread_mutex_t **)(pools + 4 * *v7);
    if ( v11 )
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)v11 + 1592));
      sub_2A644((int)v5);
      sub_2A68C(v5, (const char **)&v11[19]);
      v13 = (*(int (__fastcall **)(_DWORD *, pthread_mutex_t *, _QWORD *))(*(_DWORD *)(v15 + 72) + 8))(v5, v11, v4);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)v11 + 1592));
      if ( v13 == 1 )
      {
        ++*(_QWORD *)&total_stale;
        ++v11[68].__owner;
        *((double *)&v11[75].__align + 2) = *((double *)&v11[75].__align + 2) + *((double *)&v11[75].__align + 1);
        total_diff_stale = *((double *)&v11[75].__align + 1) + total_diff_stale;
      }
      else
      {
        workio_submit_work((int)v5, v11);
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "the pool is NULL");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "nonce_submit_thread",
        19,
        332,
        80,
        v3);
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;
// 160990: using guessed type double total_stale;
// 1609D0: using guessed type double total_diff_stale;

//----- (0002BDD8) --------------------------------------------------------
char *__fastcall parse_arg(char *result, char *a2)
{
  size_t v2; // r2
  int v4[4]; // [sp+1Ch] [bp-1110h] BYREF
  _BYTE v5[160]; // [sp+78h] [bp-10B4h] BYREF
  char v6[20]; // [sp+118h] [bp-1014h] BYREF
  const json_t *file; // [sp+1118h] [bp-14h]
  int i; // [sp+111Ch] [bp-10h]
  size_t n; // [sp+1120h] [bp-Ch]
  int v10; // [sp+1124h] [bp-8h]

  if ( result == (char *)118 )
  {
    opt_version_path = (int)a2;
    return result;
  }
  if ( (int)result > 118 )
  {
    if ( result == (char *)1033 )
      return result;
    if ( (int)result > 1033 )
    {
      if ( result == (char *)1035 )
      {
        n = atoi(a2);
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, "1035 v: %d!", n);
        V_UNLOCK();
        result = (char *)zlog(
                           g_zc,
                           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/re"
                           "lease/build/godminer-origin_godminer-branch1/god-miner.c",
                           149,
                           "parse_arg",
                           9,
                           483,
                           40,
                           v6);
        if ( n < 2 )
        {
          opt_custom_power_mode = n;
        }
        else
        {
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, "power mode value error!");
          V_UNLOCK();
          return (char *)zlog(
                           g_zc,
                           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/re"
                           "lease/build/godminer-origin_godminer-branch1/god-miner.c",
                           149,
                           "parse_arg",
                           9,
                           485,
                           100,
                           v6);
        }
        return result;
      }
      if ( (int)result < 1035 )
      {
        result = (char *)atoi(a2);
        n = (size_t)result;
        if ( (int)result < 0 || (int)n > 100 )
        {
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, "fan_pwm value error!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/god-miner.c",
            149,
            "parse_arg",
            9,
            474,
            100,
            v6);
          exit(1);
        }
        if ( (int)n < 30 )
        {
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, "fan-pwm shouldn't be set to %d, reset it to %d!", n, 30);
          V_UNLOCK();
          result = (char *)zlog(
                             g_zc,
                             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                             "release/build/godminer-origin_godminer-branch1/god-miner.c",
                             149,
                             "parse_arg",
                             9,
                             478,
                             80,
                             v6);
        }
        v2 = 30;
        if ( (int)n > 30 )
          v2 = n;
        fan_pwm = v2;
        return result;
      }
      if ( result == (char *)1036 )
        return result;
      if ( result == (char *)2030 )
      {
        result = (char *)strcmp(a2, "app");
        if ( result )
        {
          result = (char *)strcmp(a2, "fir");
          if ( result )
          {
            V_LOCK();
            logfmt_raw(v6, 0x1000u, 0, "invalid input!\n");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/god-miner.c",
              149,
              "parse_arg",
              9,
              512,
              100,
              v6);
            exit(1);
          }
          chip_update_param = 0;
        }
        else
        {
          chip_update_param = 1;
        }
        opt_chip_update = 1;
        return result;
      }
    }
    else
    {
      if ( result == (char *)1030 )
      {
        opt_api_remote = 1;
        return result;
      }
      if ( result == (char *)1032 )
        return result;
      if ( result == (char *)122 )
      {
        if ( opt_zlog_conf_file )
          free((void *)opt_zlog_conf_file);
        result = strdup(a2);
        opt_zlog_conf_file = (int)result;
        return result;
      }
    }
LABEL_77:
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "unknow config parameter!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "parse_arg",
      9,
      518,
      100,
      v6);
    exit(1);
  }
  if ( result == (char *)99 )
  {
    file = json_load_file(a2, 0, (json_error_t *)v4);
    if ( file && !*(_DWORD *)file )
    {
      parse_config(file, (int)a2);
      sub_2A4D0((int)file);
    }
    else if ( v4[0] >= 0 )
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "%s:%d: %s", a2, v4[0], v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "parse_arg",
        9,
        401,
        100,
        v6);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "%s", v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "parse_arg",
        9,
        399,
        100,
        v6);
    }
    if ( default_config )
    {
      free((void *)default_config);
      default_config = 0;
    }
    result = strdup(a2);
    default_config = (int)result;
    return result;
  }
  if ( (int)result > 99 )
  {
    if ( result == (char *)111 )
    {
      result = (char *)set_url(a2);
      v10 = (int)result;
      if ( result )
      {
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, "%s", v10);
        V_UNLOCK();
        return (char *)zlog(
                         g_zc,
                         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rele"
                         "ase/build/godminer-origin_godminer-branch1/god-miner.c",
                         149,
                         "parse_arg",
                         9,
                         439,
                         100,
                         v6);
      }
      return result;
    }
    if ( (int)result > 111 )
    {
      if ( result == (char *)112 )
      {
        v10 = set_pass(a2);
        if ( !v10 )
          return sub_2A99C(a2);
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, "%s", v10);
        V_UNLOCK();
        return (char *)zlog(
                         g_zc,
                         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rele"
                         "ase/build/godminer-origin_godminer-branch1/god-miner.c",
                         149,
                         "parse_arg",
                         9,
                         418,
                         100,
                         v6);
      }
      if ( result == (char *)117 )
      {
        result = (char *)set_user(a2);
        v10 = (int)result;
        if ( result )
        {
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, "%s", v10);
          V_UNLOCK();
          return (char *)zlog(
                           g_zc,
                           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/re"
                           "lease/build/godminer-origin_godminer-branch1/god-miner.c",
                           149,
                           "parse_arg",
                           9,
                           431,
                           100,
                           v6);
        }
        return result;
      }
    }
    else if ( result == (char *)104 )
    {
      V_LOCK();
      logfmt_raw(
        v6,
        0x1000u,
        0,
        "Usage: GODMINER [OPTIONS]\n"
        "Options:\n"
        "  -a, --algo=ALGO       specify the algorithm to use\n"
        "                          eth_1798         ethash\n"
        "                          ckb_2040         eaglesong\n"
        "                          ckb_2042         eaglesong\n"
        "                          kda_2110         blake2s\n"
        "                          dcr_1727         blaker14\n"
        "                          hns_2130         blake2s\n"
        "                          dash_1766        x11\n"
        "                          xmr_2042         xmr\n"
        "  -o, --url=URL         URL of mining server\n"
        "  -u, --user=USERNAME   username for mining server\n"
        "  -p, --pass=PASSWORD   password for mining server\n"
        "  -P, --protocol        verbose dump of protocol-level activities\n"
        "      --api-remote      Allow remote control\n"
        "  -c, --config=FILE     load a JSON-format configuration file\n"
        "  -v, --version         display version information and exit\n"
        "  -F, --bitmain-fan-ctrl  set if fixed fan's pwm\n"
        "      --bitmain-fan-pwm=N set pwm value when fan pwm fixed\n"
        "      --bitmain-freq=N  set working freq\n"
        "      --bitmain-voltage=N  set working power voltage\n"
        "  -z, --zlog=FILE       load a zlog configuration file\n"
        "  -h, --help            display this help text and exit\n");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "parse_arg",
        9,
        493,
        40,
        v6);
      exit(0);
    }
    goto LABEL_77;
  }
  if ( result == (char *)80 )
  {
    opt_protocol = 1;
  }
  else if ( result == (char *)97 )
  {
    for ( i = 0; i <= 13; ++i )
    {
      result = (char *)strlen(off_14D568[i]);
      n = (size_t)result;
      if ( result )
      {
        result = (char *)strncasecmp(a2, off_14D568[i], n);
        if ( !result && !a2[n] )
        {
          opt_algo = i;
          break;
        }
      }
    }
    if ( i == 14 )
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "Unknown algo parameter '%s'", a2);
      V_UNLOCK();
      return (char *)zlog(
                       g_zc,
                       "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/releas"
                       "e/build/godminer-origin_godminer-branch1/god-miner.c",
                       149,
                       "parse_arg",
                       9,
                       382,
                       100,
                       v6);
    }
  }
  else
  {
    if ( result != (char *)70 )
      goto LABEL_77;
    fan_pwm_fixed = 1;
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D568: using guessed type char *off_14D568[18];
// 14D664: using guessed type int opt_algo;
// 14F19C: using guessed type int fan_pwm;
// 1512C0: using guessed type char opt_api_remote;
// 1512C1: using guessed type char opt_protocol;
// 1512C2: using guessed type char opt_custom_power_mode;
// 1512C4: using guessed type int default_config;
// 1512C8: using guessed type int opt_version_path;
// 1513F4: using guessed type char opt_chip_update;
// 1513F8: using guessed type int chip_update_param;
// 152420: using guessed type char fan_pwm_fixed;
// 1608EC: using guessed type int opt_zlog_conf_file;
// 1608F0: using guessed type int g_zc;

//----- (0002C9A4) --------------------------------------------------------
void __fastcall parse_config(const json_t *a1, int a2)
{
  double v2; // d0
  const char *v3; // r0
  int v4; // r0
  size_t v5; // r0
  int v6; // [sp+10h] [bp-1044h]
  char v8[56]; // [sp+1Ch] [bp-1038h] BYREF
  char v9[16]; // [sp+101Ch] [bp-38h] BYREF
  char s[16]; // [sp+102Ch] [bp-28h] BYREF
  json_t *v11; // [sp+103Ch] [bp-18h]
  void *ptr; // [sp+1040h] [bp-14h]
  const json_t *v13; // [sp+1044h] [bp-10h]
  size_t j; // [sp+1048h] [bp-Ch]
  int i; // [sp+104Ch] [bp-8h]

  v6 = a2;
  for ( i = 0; i <= 18 && (&off_D7024)[4 * i]; ++i )
  {
    v13 = json_object_get(a1, (&off_D7024)[4 * i]);
    if ( v13 )
    {
      if ( (&off_D7024)[4 * i + 1] && *(_DWORD *)v13 == 2 )
      {
        v3 = json_string_value(v13);
        ptr = strdup(v3);
        if ( !ptr )
          return;
        parse_arg((&off_D7024)[4 * i + 3], ptr);
        free(ptr);
      }
      else if ( (&off_D7024)[4 * i + 1] && *(_DWORD *)v13 == 3 )
      {
        v4 = json_integer_value((int)v13);
        sprintf(s, "%d", v4);
        parse_arg((&off_D7024)[4 * i + 3], s);
      }
      else if ( (&off_D7024)[4 * i + 1] && *(_DWORD *)v13 == 4 )
      {
        json_real_value();
        sprintf(v9, "%f", v2);
        parse_arg((&off_D7024)[4 * i + 3], v9);
      }
      else if ( (&off_D7024)[4 * i + 1] && *(_DWORD *)v13 == 1 )
      {
        for ( j = 0; ; ++j )
        {
          v5 = json_array_size(v13);
          if ( j >= v5 )
            break;
          v11 = json_array_get(v13, j);
          if ( !v11 )
            break;
          if ( *(_DWORD *)v11 )
          {
            V_LOCK();
            logfmt_raw(v8, 0x1000u, 0, "JSON %s array value invalid", (&off_D7024)[4 * i]);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/god-miner.c",
              149,
              "parse_config",
              12,
              556,
              100,
              v8);
          }
          else
          {
            parse_config(v11, 0);
          }
        }
      }
      else if ( (&off_D7024)[4 * i + 1] )
      {
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, "JSON option %s invalid", (&off_D7024)[4 * i]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/god-miner.c",
          149,
          "parse_config",
          12,
          564,
          100,
          v8,
          v6);
      }
      else if ( *(_DWORD *)v13 == 5 )
      {
        parse_arg((&off_D7024)[4 * i + 3], &unk_D746C);
      }
    }
  }
}
// 2CA4C: conditional instruction was optimized away because %var_C.4!=0
// 2CAE0: conditional instruction was optimized away because %var_C.4!=0
// 2CB6C: conditional instruction was optimized away because %var_C.4!=0
// 2CBF0: conditional instruction was optimized away because %var_C.4!=0
// 2CD30: conditional instruction was optimized away because %var_C.4!=0
// 2CB98: variable 'v2' is possibly undefined
// 2CDF4: variable 'v6' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 2BDD8: using guessed type int __fastcall parse_arg(_DWORD, _DWORD);
// D7024: using guessed type char *off_D7024;
// 1608F0: using guessed type int g_zc;

//----- (0002CE3C) --------------------------------------------------------
char *__fastcall sub_2CE3C(int a1, _DWORD *a2)
{
  char *result; // r0
  char v5[8]; // [sp+1Ch] [bp-1008h] BYREF
  char *v6; // [sp+101Ch] [bp-8h]

  while ( 1 )
  {
    result = (char *)getopt_long(a1, (int)a2, "a:c:hp:Po:u:v:F", (int)&off_D7024, 0);
    v6 = result;
    if ( (int)result < 0 )
      break;
    parse_arg(v6, (char *)optarg);
  }
  if ( a1 > optind )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s: unsupported non-option argument -- '%s'", *a2, a2[optind]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "parse_cmdline",
      13,
      580,
      100,
      v5);
    exit(1);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// D7024: using guessed type char *off_D7024;
// 14DE80: using guessed type int optind;
// 1608F0: using guessed type int g_zc;
// 161238: using guessed type int optarg;

//----- (0002CFB4) --------------------------------------------------------
int __fastcall sub_2CFB4(int a1)
{
  int result; // r0
  char v2[4]; // [sp+18h] [bp-1004h] BYREF

  switch ( a1 )
  {
    case 2:
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "SIGINT received, exiting");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "signal_handler",
        14,
        590,
        80,
        v2);
      print_summary();
      exit(0);
      return result;
    case 3:
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "SIGQUIT received, exiting");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "signal_handler",
        14,
        595,
        80,
        v2);
      print_summary();
      exit(0);
      return result;
    case 10:
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "SIGUSR1 received, reload log");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "signal_handler",
        14,
        610,
        80,
        v2);
      result = log_reload();
      break;
    case 11:
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "SIGSEGV received, exiting");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "signal_handler",
        14,
        605,
        80,
        v2);
      print_summary();
      exit(0);
      return result;
    case 15:
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "SIGTERM received, exiting");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "signal_handler",
        14,
        600,
        80,
        v2);
      print_summary();
      exit(0);
      return result;
    default:
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "catch signal %d, it should not be here");
      V_UNLOCK();
      result = zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/buil"
                 "d/godminer-origin_godminer-branch1/god-miner.c",
                 149,
                 "signal_handler",
                 14,
                 614,
                 80,
                 v2);
      break;
  }
  return result;
}
// 2CFE8: control flows out of bounds to 2CFEC
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0002D2F4) --------------------------------------------------------
int sub_2D2F4()
{
  char v1[16]; // [sp+14h] [bp-1010h] BYREF
  int v2; // [sp+1014h] [bp-10h]
  int hardware_version; // [sp+1018h] [bp-Ch]
  int v4; // [sp+101Ch] [bp-8h]

  hardware_version = get_hardware_version();
  v4 = BYTE2(hardware_version);
  v2 = (unsigned __int8)hardware_version;
  V_LOCK();
  logfmt_raw(
    v1,
    0x1000u,
    0,
    "godminer Version = 0x%04X %s",
    (unsigned __int16)hardware_version,
    "2.0.0_release_clean_master_62efe336adce4a2cd0126a04d0c912151939985c_Aug 21 2024 19:33:46");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/god-miner.c",
    149,
    "init_miner_version",
    18,
    657,
    40,
    v1);
  return sprintf(g_miner_version, "%d.%d-%s", v2, v4, "2.0.0");
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0002D3F8) --------------------------------------------------------
int make_fake_version()
{
  char s[64]; // [sp+8h] [bp-44h] BYREF

  sprintf(s, "%s %s", "Aug 21 2024", "19:33:46");
  strcpy(g_miner_compiletime, s);
  strcpy(g_miner_type, "Antminer unknow");
  return *(_DWORD *)"Antminer unknow";
}

//----- (0002D464) --------------------------------------------------------
__int64 read_version_file()
{
  char v1[16]; // [sp+14h] [bp-1110h] BYREF
  char s[256]; // [sp+1014h] [bp-110h] BYREF
  FILE *stream; // [sp+1114h] [bp-10h]
  signed int v4; // [sp+1118h] [bp-Ch]
  char *v5; // [sp+111Ch] [bp-8h]

  stream = fopen((const char *)opt_version_path, "rb");
  memset(s, 0, sizeof(s));
  v4 = 0;
  v5 = 0;
  if ( stream )
  {
    v4 = fread(s, 1u, 0x100u, stream);
    if ( v4 > 0 )
    {
      v5 = strchr(s, 10);
      if ( v5 )
      {
        memcpy(g_miner_compiletime, s, v5 - s);
        strcpy(s, v5 + 1);
        v5 = strchr(s, 10);
        if ( v5 )
          memcpy(g_miner_type, s, v5 - s);
        else
          strcpy(g_miner_type, s);
      }
      else
      {
        strcpy(g_miner_compiletime, s);
      }
      if ( g_miner_compiletime[strlen(g_miner_compiletime) - 1] == 10 )
        g_miner_compiletime[strlen(g_miner_compiletime) - 1] = 0;
      if ( g_miner_compiletime[strlen(g_miner_compiletime) - 1] == 13 )
        g_miner_compiletime[strlen(g_miner_compiletime) - 1] = 0;
      if ( g_miner_type[strlen(g_miner_type) - 1] == 10 )
        g_miner_type[strlen(g_miner_type) - 1] = 0;
      if ( g_miner_type[strlen(g_miner_type) - 1] == 13 )
        g_miner_type[strlen(g_miner_type) - 1] = 0;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, "Read miner version file %s error %d", opt_version_path, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "read_version_file",
        17,
        682,
        100,
        v1);
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, "Open miner version file %s error", opt_version_path);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "read_version_file",
      17,
      677,
      100,
      v1);
  }
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "Miner compile time: %s type: %s", g_miner_compiletime, g_miner_type);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/god-miner.c",
           149,
           "read_version_file",
           17,
           717,
           60,
           v1);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512C8: using guessed type int opt_version_path;
// 1608F0: using guessed type int g_zc;

//----- (0002D89C) --------------------------------------------------------
int __fastcall godminer_chip_status_monitor(int a1)
{
  unsigned __int64 v1; // d17
  unsigned __int64 v2; // r2
  char v5[28]; // [sp+30h] [bp-105Ch] BYREF
  _DWORD v6[7]; // [sp+1030h] [bp-5Ch] BYREF
  int v7; // [sp+104Ch] [bp-40h]
  int v8; // [sp+1054h] [bp-38h]
  char *v9; // [sp+1058h] [bp-34h]
  int v10; // [sp+105Ch] [bp-30h]
  char *v11; // [sp+1060h] [bp-2Ch]
  int v12; // [sp+1064h] [bp-28h]
  char *v13; // [sp+1068h] [bp-24h]
  int v14; // [sp+106Ch] [bp-20h]
  char *v15; // [sp+1070h] [bp-1Ch]
  char *miner_working_status_p; // [sp+1074h] [bp-18h]
  pthread_mutex_t *current_pool; // [sp+1078h] [bp-14h]
  char *flag_from_monitor; // [sp+107Ch] [bp-10h]

  flag_from_monitor = get_flag_from_monitor(a1);
  current_pool = (pthread_mutex_t *)get_current_pool();
  miner_working_status_p = get_miner_working_status_p();
  v15 = flag_from_monitor + 48;
  v14 = 1;
  LODWORD(v1) = 1;
  if ( (vshld_u64(1u, v1) & *((_QWORD *)flag_from_monitor + 6)) != 0 )
  {
    if ( (unsigned __int8)pool_tget(current_pool, (unsigned __int8 *)&current_pool[79].__size[8]) != 1 )
    {
      set_miner_6060info_runtime_bad_asic_err(*(_DWORD *)(a1 + 252), 1);
      miner_working_status_p[16] = 1;
    }
    v13 = flag_from_monitor + 48;
    v12 = 1;
    LODWORD(v1) = 1;
    *((_QWORD *)flag_from_monitor + 7) |= vshld_u64(1u, v1);
  }
  v11 = flag_from_monitor + 48;
  v10 = 2;
  LODWORD(v1) = 2;
  HIDWORD(v2) = (vshld_u64(1u, v1) & *((_QWORD *)flag_from_monitor + 6)) != 0;
  if ( BYTE4(v2) )
  {
    if ( (unsigned __int8)pool_tget(current_pool, (unsigned __int8 *)&current_pool[79].__size[8]) != 1 )
    {
      V_LOCK();
      sub_2A570((int)v6, *(int *)(a1 + 252));
      logfmt_raw(v5, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "some chip working slow");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "godminer_chip_status_monitor",
        28,
        750,
        20,
        v5);
      set_miner_6060info_runtime_bad_asic_err(*(_DWORD *)(a1 + 252), 1);
      miner_working_status_p[17] = 1;
    }
    v9 = flag_from_monitor + 48;
    v8 = 2;
    LODWORD(v1) = 2;
    v2 = vshld_u64(1u, v1) | *((_QWORD *)flag_from_monitor + 7);
    *((_QWORD *)flag_from_monitor + 7) = v2;
  }
  return HIDWORD(v2);
}
// 2D904: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0002DB98) --------------------------------------------------------
bool __fastcall godminer_fan_monitor(int a1)
{
  unsigned __int64 v1; // d17
  _BOOL4 v2; // r3
  char v5[52]; // [sp+30h] [bp-1074h] BYREF
  _DWORD v6[7]; // [sp+1030h] [bp-74h] BYREF
  int v7; // [sp+104Ch] [bp-58h]
  _DWORD v8[7]; // [sp+1050h] [bp-54h] BYREF
  int v9; // [sp+106Ch] [bp-38h]
  int v10; // [sp+1070h] [bp-34h]
  char *v11; // [sp+1074h] [bp-30h]
  int v12; // [sp+1078h] [bp-2Ch]
  char *v13; // [sp+107Ch] [bp-28h]
  int v14; // [sp+1080h] [bp-24h]
  char *v15; // [sp+1084h] [bp-20h]
  int v16; // [sp+1088h] [bp-1Ch]
  char *v17; // [sp+108Ch] [bp-18h]
  char *miner_working_status_p; // [sp+1090h] [bp-14h]
  char *flag_from_monitor; // [sp+1094h] [bp-10h]

  ++dword_151858[*(_DWORD *)(a1 + 248)];
  miner_working_status_p = get_miner_working_status_p();
  flag_from_monitor = get_flag_from_monitor(a1);
  v17 = flag_from_monitor + 32;
  v16 = 1;
  LODWORD(v1) = 1;
  if ( (vshld_u64(1u, v1) & *((_QWORD *)flag_from_monitor + 4)) != 0 )
  {
    V_LOCK();
    sub_2A538((int)v6, "fan lost");
    logfmt_raw(v5, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "fan lost happend");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "godminer_fan_monitor",
      20,
      775,
      20,
      v5);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Sweep error string = %s.", "F:1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "godminer_fan_monitor",
      20,
      776,
      100,
      v5);
    v15 = flag_from_monitor + 32;
    v14 = 1;
    LODWORD(v1) = 1;
    *((_QWORD *)flag_from_monitor + 5) |= vshld_u64(1u, v1);
    miner_working_status_p[18] = 1;
  }
  v13 = flag_from_monitor + 32;
  v12 = 0;
  LODWORD(v1) = 0;
  v2 = (vshld_u64(1u, v1) & *((_QWORD *)flag_from_monitor + 4)) != 0;
  if ( v2 )
  {
    V_LOCK();
    sub_2A538((int)v8, "fan slow");
    logfmt_raw(v5, 0x1000u, 0, v9, v8[0], v8[1], v8[2], v8[3], v8[4], v8[5], v8[6], v9, "fan slow happend");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "godminer_fan_monitor",
      20,
      784,
      20,
      v5);
    v11 = flag_from_monitor + 32;
    v10 = 0;
    LODWORD(v1) = 0;
    *((_QWORD *)flag_from_monitor + 5) |= vshld_u64(1u, v1);
    v2 = (_BOOL4)miner_working_status_p;
    miner_working_status_p[19] = 1;
  }
  return v2;
}
// 2DC24: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151858: using guessed type _DWORD dword_151858[16];
// 1608F0: using guessed type int g_zc;

//----- (0002DF48) --------------------------------------------------------
int godminer_register_status_monitor()
{
  add_chip_status_observer((int)godminer_chip_status_monitor);
  return add_fanspeed_observer((int)godminer_fan_monitor);
}

//----- (0002DF70) --------------------------------------------------------
int __fastcall sub_2DF70(const char *a1)
{
  _QWORD dest[4]; // [sp+8h] [bp-17Ch] BYREF
  _QWORD command[8]; // [sp+28h] [bp-15Ch] BYREF
  char s[256]; // [sp+68h] [bp-11Ch] BYREF
  int v6; // [sp+168h] [bp-1Ch]
  size_t n; // [sp+16Ch] [bp-18h]
  FILE *stream; // [sp+170h] [bp-14h]
  size_t i; // [sp+174h] [bp-10h]
  size_t v10; // [sp+178h] [bp-Ch]
  int v11; // [sp+17Ch] [bp-8h]

  memset(s, 0, sizeof(s));
  v11 = 0;
  memset(command, 0, sizeof(command));
  snprintf((char *)command, 0x40u, "pidof %s", a1);
  stream = popen((const char *)command, "r");
  if ( stream )
  {
    while ( fgets(s, 256, stream) )
      ;
    pclose(stream);
    stream = 0;
    v10 = 0;
    for ( i = 1; strlen(s) >= i; ++i )
    {
      memset(dest, 0, sizeof(dest));
      if ( ((*_ctype_b_loc())[(unsigned __int8)s[i - 1]] & 0x2000) != 0 )
      {
        n = i - v10 - 1;
        strncpy((char *)dest, &s[v10], n);
        v10 = i;
        v6 = atoi((const char *)dest);
        if ( v6 > 0 )
          ++v11;
      }
    }
  }
  if ( v11 > 0 )
    printf("%d instance of %s is already Running on this machine!\n", v11, a1);
  return v11;
}

//----- (0002E168) --------------------------------------------------------
bool sub_2E168()
{
  return sub_2DF70("godminer") > 1;
}

//----- (0002E198) --------------------------------------------------------
int sub_2E198()
{
  int result; // r0
  int v1; // [sp+Ch] [bp-18h] BYREF
  _DWORD *all_created_runtime; // [sp+10h] [bp-14h]
  int i; // [sp+14h] [bp-10h]

  v1 = 0;
  all_created_runtime = get_all_created_runtime(&v1);
  result = is_eeprom_loaded();
  if ( result )
  {
    for ( i = 0; i < v1; ++i )
      result = (*(int (__fastcall **)(_DWORD, int, int, int, int))(all_created_runtime[i] + 164))(
                 all_created_runtime[i],
                 1,
                 opt_custom_freq,
                 1,
                 opt_custom_voltage);
  }
  return result;
}
// 1513E4: using guessed type int opt_custom_freq;
// 1513EC: using guessed type int opt_custom_voltage;

//----- (0002E254) --------------------------------------------------------
_DWORD *sub_2E254()
{
  _DWORD *result; // r0
  int (**v1)(); // r0
  int v2; // [sp+4h] [bp-10h] BYREF
  _DWORD *v3; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  v2 = 0;
  result = get_all_created_runtime(&v2);
  v3 = result;
  for ( i = 0; i < v2; ++i )
  {
    v1 = dev_ctrl();
    result = (_DWORD *)((int (__fastcall *)(_DWORD))v1[20])(*(_DWORD *)(v3[i] + 248));
  }
  return result;
}

//----- (0002E2D8) --------------------------------------------------------
int set_working_voltage_and_runtime_freq()
{
  int v0; // r3
  int v1; // r3
  int v2; // r0
  int v3; // r0
  signed int v4; // r2
  int v5; // r3
  char v7[44]; // [sp+10h] [bp-102Ch] BYREF
  int v8; // [sp+1010h] [bp-2Ch] BYREF
  int v9; // [sp+1014h] [bp-28h]
  int v10; // [sp+1018h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+101Ch] [bp-20h]
  int working_voltage; // [sp+1020h] [bp-1Ch]
  int current_voltage; // [sp+1024h] [bp-18h]
  bool v14; // [sp+102Ah] [bp-12h]
  char v15; // [sp+102Bh] [bp-11h]
  int v16; // [sp+102Ch] [bp-10h]
  int i; // [sp+1030h] [bp-Ch]
  int j; // [sp+1034h] [bp-8h]

  working_voltage = get_working_voltage();
  current_voltage = get_current_voltage();
  v8 = 0;
  all_created_runtime = get_all_created_runtime(&v8);
  if ( (unsigned __int8)is_power_init() != 1 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "%s, power has not init!", "set_working_voltage_and_runtime_freq");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "set_working_voltage_and_runtime_freq",
      36,
      1493,
      100,
      v7);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "Sweep error string = %s.", "V:1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "set_working_voltage_and_runtime_freq",
      36,
      1494,
      100,
      v7);
    return -1;
  }
  else
  {
    v0 = opt_algo;
    if ( opt_algo == 8 )
    {
      v14 = 0;
      v15 = 0;
      if ( working_voltage >= current_voltage )
        v1 = 7;
      else
        v1 = -7;
      v10 = v1;
      v9 = 25;
      while ( 1 )
      {
        if ( v14 )
        {
          v0 = (unsigned __int8)v15 ^ 1;
          if ( v15 == 1 )
            break;
        }
        if ( !v14 )
        {
          v16 = 0;
          for ( i = 0; i < v8; ++i )
          {
            v2 = (*(int (__fastcall **)(_DWORD, int))(all_created_runtime[i] + 188))(all_created_runtime[i], v9);
            v16 |= v2;
          }
          v14 = v16 == 0;
          if ( v16 )
          {
            usleep((__useconds_t)sub_30D40);
            for ( j = 0; j < v8; ++j )
            {
              v3 = (*(int (__fastcall **)(_DWORD, int))(all_created_runtime[j] + 188))(all_created_runtime[j], v9);
              v16 |= v3;
            }
            v14 = v16 == 0;
          }
        }
        v4 = abs32(current_voltage - working_voltage);
        v5 = v10;
        if ( v10 < 0 )
          v5 = -v10;
        if ( v4 <= v5 )
        {
          if ( current_voltage != working_voltage )
          {
            current_voltage = working_voltage;
            set_voltage(working_voltage, 1);
          }
        }
        else
        {
          current_voltage += v10;
          set_voltage(current_voltage, 1);
        }
        if ( current_voltage == working_voltage )
          v15 = 1;
        sub_2E254();
      }
    }
  }
  return v0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D664: using guessed type int opt_algo;
// 1608F0: using guessed type int g_zc;

//----- (0002E680) --------------------------------------------------------
int setsystime_basestampfile()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  struct stat v4; // [sp+10h] [bp-106Ch] BYREF
  char v5[20]; // [sp+68h] [bp-1014h] BYREF
  time_t when; // [sp+1068h] [bp-14h] BYREF
  FILE *stream; // [sp+106Ch] [bp-10h]

  stream = fopen("/nvdata/timestamp.data", "r+");
  if ( stream )
  {
    when = 0;
    fscanf(stream, "%ld", &when);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "timestamp file=%ld", when);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "setsystime_basestampfile",
      24,
      1606,
      40,
      v5);
    if ( when )
      stime(&when);
  }
  else
  {
    stream = fopen("/nvdata/timestamp.data", "w+");
    if ( !stream )
    {
      V_LOCK();
      v0 = *_errno_location();
      v1 = _errno_location();
      v2 = strerror(*v1);
      logfmt_raw(v5, 0x1000u, 0, "file op errno = %d reason = %s", v0, v2);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/god-miner.c",
               149,
               "setsystime_basestampfile",
               24,
               1583,
               40,
               v5);
    }
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "sys time ref file time");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "setsystime_basestampfile",
      24,
      1589,
      40,
      v5);
    if ( sub_CCFF8("/config/sn", &v4) && sub_CCFF8("/config/passwd", &v4) && sub_CCFF8("/config/shadow", &v4) )
    {
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "No ref time file");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "setsystime_basestampfile",
        24,
        1597,
        40,
        v5);
    }
    else
    {
      fprintf(stream, "%ld", v4.st_ctim.tv_sec);
      stime(&v4.st_ctim.tv_sec);
    }
    fflush(stream);
  }
  return fclose(stream);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0002E9F0) --------------------------------------------------------
int update_timestamp_file()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  char v4[20]; // [sp+18h] [bp-1014h] BYREF
  time_t timer; // [sp+1018h] [bp-14h] BYREF
  FILE *stream; // [sp+101Ch] [bp-10h]

  stream = fopen("/nvdata/timestamp.data", "w");
  if ( stream )
  {
    time(&timer);
    fprintf(stream, "%ld", timer);
    fflush(stream);
    return fclose(stream);
  }
  else
  {
    V_LOCK();
    v0 = *_errno_location();
    v1 = _errno_location();
    v2 = strerror(*v1);
    logfmt_raw(v4, 0x1000u, 0, "file op errno = %d reason = %s", v0, v2);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/god-miner.c",
             149,
             "update_timestamp_file",
             21,
             1623,
             40,
             v4);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0002EB18) --------------------------------------------------------
__int64 call_setsystime_from_http()
{
  char v1[12]; // [sp+10h] [bp-200Ch] BYREF
  char v2[4096]; // [sp+1010h] [bp-100Ch] BYREF
  int v3; // [sp+2010h] [bp-Ch]
  int v4; // [sp+2014h] [bp-8h]

  v3 = 0;
  strcpy(v2, "/www/pages/cgi-bin/getandsettime.cgi");
  v4 = 36;
  v4 = my_system(v2);
  if ( v4 )
    setsystime_basestampfile();
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "port system time result=%d", v4);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/god-miner.c",
           149,
           "call_setsystime_from_http",
           25,
           1656,
           40,
           v1);
}
// 2EB88: conditional instruction was optimized away because %var_4.4==24
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0002ECB0) --------------------------------------------------------
void *droa_log_init()
{
  void *result; // r0
  size_t v1; // r0
  char v2[24]; // [sp+14h] [bp-1018h] BYREF
  char *s; // [sp+1014h] [bp-18h]
  void *v4; // [sp+1018h] [bp-14h]
  int i; // [sp+101Ch] [bp-10h]

  result = get_all_created_runtime(&g_chain_number);
  v4 = result;
  for ( i = 0; i < g_chain_number; ++i )
  {
    if ( (unsigned int)i <= 0xF )
    {
      s = (char *)api_get_eeprom_chip_sn(i);
      v1 = strlen(s);
      strncpy(&g_bsn[64 * i], s, v1);
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "droa board_sn:%s", &g_bsn[64 * i]);
      V_UNLOCK();
      result = (void *)zlog(
                         g_zc,
                         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rele"
                         "ase/build/godminer-origin_godminer-branch1/god-miner.c",
                         149,
                         "droa_log_init",
                         13,
                         1670,
                         60,
                         v2);
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151400: using guessed type int g_chain_number;
// 1608F0: using guessed type int g_zc;

//----- (0002EDE0) --------------------------------------------------------
int get_miner_status()
{
  int v1; // [sp+0h] [bp-1Ch] BYREF
  unsigned __int8 v2; // [sp+4h] [bp-18h]
  unsigned __int8 v3; // [sp+5h] [bp-17h]
  unsigned __int8 v4; // [sp+6h] [bp-16h]
  unsigned __int8 v5; // [sp+7h] [bp-15h]
  unsigned __int8 v6; // [sp+8h] [bp-14h]
  unsigned __int8 v7; // [sp+10h] [bp-Ch]
  unsigned __int8 v8; // [sp+11h] [bp-Bh]
  unsigned __int8 v9; // [sp+12h] [bp-Ah]
  unsigned __int8 v10; // [sp+13h] [bp-9h]
  int v11; // [sp+14h] [bp-8h]

  v11 = 0;
  get_miner_working_status(&v1);
  return (v7 << 12)
       | (v8 << 11)
       | (v9 << 10)
       | (v10 << 9)
       | ((unsigned __int8)v1 << 8)
       | (BYTE1(v1) << 7)
       | (BYTE2(v1) << 6)
       | (32 * HIBYTE(v1))
       | (16 * v2)
       | (8 * v3)
       | (4 * v4)
       | (2 * v5)
       | v6;
}

//----- (0002EEA8) --------------------------------------------------------
void update_droa_log()
{
  double v0; // d0
  int v1; // r4
  int tm_mday; // r5
  int tm_hour; // r8
  int tm_min; // r9
  int tm_sec; // r10
  double v6; // r6
  int miner_status; // r0
  size_t v8; // r0
  double v9; // r4
  int v10; // r0
  int v11; // [sp+28h] [bp-1054h]
  struct tm v12; // [sp+34h] [bp-1048h] BYREF
  time_t timer; // [sp+1034h] [bp-48h] BYREF
  struct timeval tv; // [sp+1038h] [bp-44h] BYREF
  int v15; // [sp+1040h] [bp-3Ch]
  void *s; // [sp+1044h] [bp-38h]
  FILE *stream; // [sp+1048h] [bp-34h]
  int v18; // [sp+104Ch] [bp-30h]

  stream = fopen("/tmp/miner/droa.log", "r+");
  if ( stream )
  {
    v18 = 0;
    fseek(stream, -2, 2);
    while ( fgetc(stream) != 10 )
    {
      fseek(stream, -2, 1);
      ++v18;
    }
    fseek(stream, -++v18, 2);
    s = malloc(0x200u);
    memset(s, 0, 0x200u);
    fgets((char *)s, 512, stream);
    if ( strstr((const char *)s, "RTime:") )
    {
      v15 = 0;
      tv.tv_sec = 0;
      tv.tv_usec = 0;
      gettimeofday(&tv, 0);
      timer = tv.tv_sec;
      localtime_r(&timer, &v12);
      fseek(stream, -v18, 2);
      v15 = ftell(stream);
      memset(s, 0, 0x200u);
      v1 = v12.tm_year + 1900;
      v11 = v12.tm_mon + 1;
      tm_mday = v12.tm_mday;
      tm_hour = v12.tm_hour;
      tm_min = v12.tm_min;
      tm_sec = v12.tm_sec;
      get_miner_elapsed_time();
      v6 = *(double *)&g_hash_rate_5s;
      miner_status = get_miner_status();
      sprintf(
        (char *)s,
        "%d-%02d-%02d %02d:%02d:%02d RTime:%f,AR:%f,RStat:%d\n",
        v1,
        v11,
        tm_mday,
        tm_hour,
        tm_min,
        tm_sec,
        v0,
        v6,
        miner_status);
      fprintf(stream, (const char *)s);
      fflush(stream);
      fclose(stream);
      v8 = strlen((const char *)s);
      truncate("/tmp/miner/droa.log", v8 + v15);
    }
    else
    {
      fflush(stream);
      fclose(stream);
      get_miner_elapsed_time();
      v9 = *(double *)&g_hash_rate_5s;
      v10 = get_miner_status();
      snprintf((char *)&v12, 0x1000u, "RTime:%f,AR:%f,RStat:%d", v0, v9, v10);
      log_droa((const char *)&v12);
    }
    free(s);
    s = 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(&v12, 0x1000u, 0, "droalog open failed in 3 minute");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "update_droa_log",
      15,
      1763,
      40,
      (const char *)&v12);
  }
}
// 2F0DC: variable 'v0' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151408: using guessed type int g_hash_rate_5s;
// 1608F0: using guessed type int g_zc;

//----- (0002F22C) --------------------------------------------------------
bool check_test_pool()
{
  char v1[20]; // [sp+10h] [bp-1014h] BYREF
  int v2; // [sp+1010h] [bp-14h]
  int i; // [sp+1014h] [bp-10h]
  char v4; // [sp+101Bh] [bp-9h]
  int v5; // [sp+101Ch] [bp-8h]

  v5 = 0;
  v4 = 0;
  for ( i = 0; i < total_pools; ++i )
  {
    v2 = *(_DWORD *)(pools + 4 * i);
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, "droa optpools=%d,%s", i, *(_DWORD *)(v2 + 12));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "check_test_pool",
      15,
      1773,
      40,
      v1);
    if ( strstr(*(const char **)(v2 + 12), "TEST") )
      ++v5;
  }
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "droa TEST count=%d", v5);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/god-miner.c",
    149,
    "check_test_pool",
    15,
    1780,
    40,
    v1);
  is_test_pool = v5 > 2;
  return v5 > 2;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512C3: using guessed type char is_test_pool;
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;

//----- (0002F410) --------------------------------------------------------
int compare_nvdata_bin()
{
  const char *v0; // r3
  char v3[12]; // [sp+10h] [bp-100Ch] BYREF
  unsigned __int8 v4; // [sp+1013h] [bp-9h]
  unsigned int i; // [sp+1014h] [bp-8h]

  v4 = 0;
  for ( i = 0; i <= 0xB; ++i )
  {
    if ( strstr(efactor[22 * i + 1], "str") )
    {
      if ( *efactor[22 * i + 3] )
        v0 = efactor[22 * i + 3];
      else
        v0 = "None";
      if ( strcmp((const char *)&efactor[22 * i + 5] + 1, v0) )
      {
        V_LOCK();
        logfmt_raw(
          v3,
          0x1000u,
          0,
          "droa,%s strcmp different, %s,%s",
          efactor[22 * i],
          (char *)&efactor[22 * i + 5] + 1,
          efactor[22 * i + 3]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/god-miner.c",
          149,
          "compare_nvdata_bin",
          18,
          1799,
          40,
          v3);
        v4 = 1;
        return 1;
      }
    }
    else if ( LOBYTE(efactor[22 * i + 5]) != (unsigned __int8)*efactor[22 * i + 4] )
    {
      V_LOCK();
      logfmt_raw(
        v3,
        0x1000u,
        0,
        "droa,%s intcmp different, readback=%d,cmp=%d",
        efactor[22 * i],
        LOBYTE(efactor[22 * i + 5]),
        (unsigned __int8)*efactor[22 * i + 4]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "compare_nvdata_bin",
        18,
        1808,
        40,
        v3);
      v4 = 1;
      return 1;
    }
  }
  return v4;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D668: using guessed type char *efactor[3];
// 1608F0: using guessed type int g_zc;

//----- (0002F750) --------------------------------------------------------
int record_nvdata_droalog()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  const char *v4; // r4
  int v5; // r5
  int v6; // r6
  int v7; // r7
  int v8; // r8
  const char *v9; // r3
  const char *v10; // r1
  const char *v11; // r0
  const char *v12; // r12
  const char *v13; // r2
  int v14; // r0
  const char *v15; // r4
  int v16; // r5
  int v17; // r6
  int v18; // r7
  int v19; // lr
  const char *v20; // r3
  const char *v21; // r1
  const char *v22; // r0
  const char *v23; // r12
  const char *v24; // r2
  const char *v25; // r5
  size_t v26; // r6
  size_t v27; // r0
  size_t v28; // r0
  char v29; // r0
  const char *v30; // r4
  int v31; // r5
  int chain_domain_num; // r6
  int chain_asic_num; // r7
  int domain_asic_num; // r8
  const char *v35; // r3
  const char *v36; // r1
  const char *v37; // r0
  const char *v38; // r12
  const char *v39; // r2
  int miner_status; // r0
  const char *v41; // r4
  int v42; // r5
  int v43; // r6
  int v44; // r7
  int v45; // lr
  const char *v46; // r3
  const char *v47; // r1
  const char *v48; // r0
  const char *v49; // r12
  const char *v50; // r2
  int v51; // r0
  char v52[512]; // [sp+34h] [bp-1228h] BYREF
  char v53[40]; // [sp+234h] [bp-1028h] BYREF
  FILE *stream; // [sp+1234h] [bp-28h]
  unsigned int i; // [sp+1238h] [bp-24h]
  char *haystack; // [sp+123Ch] [bp-20h]

  droa_log_init();
  stream = fopen("/nvdata/mbin.data", "r+");
  if ( stream )
  {
    haystack = 0;
    memset(v52, 0, sizeof(v52));
    fgets(v52, 511, stream);
    for ( haystack = strtok(v52, ","); haystack; haystack = strtok(0, ",") )
    {
      for ( i = 0; i <= 0xB; ++i )
      {
        if ( strstr(haystack, efactor[22 * i]) )
        {
          if ( strstr(efactor[22 * i + 1], "str") )
          {
            v25 = &haystack[strlen(efactor[22 * i])];
            v26 = strlen(haystack);
            v27 = strlen(efactor[22 * i]);
            strncpy((char *)&efactor[22 * i + 5] + 1, v25, v26 - v27);
          }
          else
          {
            v28 = strlen(efactor[22 * i]);
            v29 = atoi(&haystack[v28]);
            LOBYTE(efactor[22 * i + 5]) = v29;
          }
        }
      }
    }
    if ( compare_nvdata_bin() )
    {
      fclose(stream);
      stream = 0;
      V_LOCK();
      logfmt_raw(v53, 0x1000u, 0, "droa bin data changed, need update droa bin data");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "record_nvdata_droalog",
        21,
        1886,
        40,
        v53);
      stream = fopen("/nvdata/mbin.data", "w");
      if ( stream )
      {
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "update droa bin data");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/god-miner.c",
          149,
          "record_nvdata_droalog",
          21,
          1892,
          40,
          v53);
        if ( g_miner_sn )
          v30 = &g_miner_sn;
        else
          v30 = "None";
        v31 = g_chain_number;
        chain_domain_num = platform_get_chain_domain_num();
        chain_asic_num = platform_get_chain_asic_num();
        domain_asic_num = platform_get_domain_asic_num();
        if ( g_bsn[0] )
          v35 = g_bsn;
        else
          v35 = "None";
        if ( byte_151450 )
          v36 = &byte_151450;
        else
          v36 = "None";
        if ( byte_151490 )
          v37 = &byte_151490;
        else
          v37 = "None";
        if ( byte_1514D0 )
          v38 = &byte_1514D0;
        else
          v38 = "None";
        if ( pwr_sn )
          v39 = &pwr_sn;
        else
          v39 = "None";
        snprintf(
          v53,
          0x1000u,
          "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
          g_miner_compiletime,
          g_miner_type,
          v30,
          v31,
          chain_domain_num,
          chain_asic_num,
          domain_asic_num,
          v35,
          v36,
          v37,
          v38,
          v39);
        log_droa(v53);
        miner_status = get_miner_status();
        snprintf(v53, 0x1000u, "InitStat:%d", miner_status);
        log_droa(v53);
        if ( g_miner_sn )
          v41 = &g_miner_sn;
        else
          v41 = "None";
        v42 = g_chain_number;
        v43 = platform_get_chain_domain_num();
        v44 = platform_get_chain_asic_num();
        v45 = platform_get_domain_asic_num();
        if ( g_bsn[0] )
          v46 = g_bsn;
        else
          v46 = "None";
        if ( byte_151450 )
          v47 = &byte_151450;
        else
          v47 = "None";
        if ( byte_151490 )
          v48 = &byte_151490;
        else
          v48 = "None";
        if ( byte_1514D0 )
          v49 = &byte_1514D0;
        else
          v49 = "None";
        if ( pwr_sn )
          v50 = &pwr_sn;
        else
          v50 = "None";
        fprintf(
          stream,
          "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
          g_miner_compiletime,
          g_miner_type,
          v41,
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50);
        fflush(stream);
        return fclose(stream);
      }
      else
      {
        V_LOCK();
        logfmt_raw(v53, 0x1000u, 0, "droa log miner bin data update failed");
        V_UNLOCK();
        return zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/buil"
                 "d/godminer-origin_godminer-branch1/god-miner.c",
                 149,
                 "record_nvdata_droalog",
                 21,
                 1910,
                 40,
                 v53);
      }
    }
    else
    {
      v51 = get_miner_status();
      snprintf(v53, 0x1000u, "InitStat:%d", v51);
      return log_droa(v53);
    }
  }
  else
  {
    stream = fopen("/nvdata/mbin.data", "w+");
    if ( stream )
    {
      if ( g_miner_sn )
        v4 = &g_miner_sn;
      else
        v4 = "None";
      v5 = g_chain_number;
      v6 = platform_get_chain_domain_num();
      v7 = platform_get_chain_asic_num();
      v8 = platform_get_domain_asic_num();
      if ( g_bsn[0] )
        v9 = g_bsn;
      else
        v9 = "None";
      if ( byte_151450 )
        v10 = &byte_151450;
      else
        v10 = "None";
      if ( byte_151490 )
        v11 = &byte_151490;
      else
        v11 = "None";
      if ( byte_1514D0 )
        v12 = &byte_1514D0;
      else
        v12 = "None";
      if ( pwr_sn )
        v13 = &pwr_sn;
      else
        v13 = "None";
      snprintf(
        v53,
        0x1000u,
        "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
        g_miner_compiletime,
        g_miner_type,
        v4,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        v11,
        v12,
        v13);
      log_droa(v53);
      v14 = get_miner_status();
      snprintf(v53, 0x1000u, "InitStat:%d", v14);
      log_droa(v53);
      if ( g_miner_sn )
        v15 = &g_miner_sn;
      else
        v15 = "None";
      v16 = g_chain_number;
      v17 = platform_get_chain_domain_num();
      v18 = platform_get_chain_asic_num();
      v19 = platform_get_domain_asic_num();
      if ( g_bsn[0] )
        v20 = g_bsn;
      else
        v20 = "None";
      if ( byte_151450 )
        v21 = &byte_151450;
      else
        v21 = "None";
      if ( byte_151490 )
        v22 = &byte_151490;
      else
        v22 = "None";
      if ( byte_1514D0 )
        v23 = &byte_1514D0;
      else
        v23 = "None";
      if ( pwr_sn )
        v24 = &pwr_sn;
      else
        v24 = "None";
      fprintf(
        stream,
        "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
        g_miner_compiletime,
        g_miner_type,
        v15,
        v16,
        v17,
        v18,
        v19,
        v20,
        v21,
        v22,
        v23,
        v24);
      fflush(stream);
      return fclose(stream);
    }
    else
    {
      V_LOCK();
      v0 = *_errno_location();
      v1 = _errno_location();
      v2 = strerror(*v1);
      logfmt_raw(v53, 0x1000u, 0, "file op errno = %d reason = %s", v0, v2);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/god-miner.c",
               149,
               "record_nvdata_droalog",
               21,
               1831,
               40,
               v53);
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D668: using guessed type char *efactor[3];
// 151400: using guessed type int g_chain_number;
// 151450: using guessed type char byte_151450;
// 151490: using guessed type char byte_151490;
// 1514D0: using guessed type char byte_1514D0;
// 151810: using guessed type char pwr_sn;
// 152408: using guessed type char g_miner_sn;
// 1608F0: using guessed type int g_zc;

//----- (0003026C) --------------------------------------------------------
int droa_macro_check()
{
  int result; // r0
  int v1; // r4
  int *v2; // r0
  char *v3; // r0
  char v4[16]; // [sp+14h] [bp-1010h] BYREF
  FILE *stream; // [sp+1014h] [bp-10h]

  result = access("/nvdata/droaswitch", 0);
  if ( result )
  {
    stream = fopen("/nvdata/droaswitch", "w");
    if ( stream )
    {
      return fclose(stream);
    }
    else
    {
      V_LOCK();
      v1 = *_errno_location();
      v2 = _errno_location();
      v3 = strerror(*v2);
      logfmt_raw(v4, 0x1000u, 0, "cswitch file ret=%d,reason=%s", v1, v3);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/god-miner.c",
               149,
               "droa_macro_check",
               16,
               1930,
               60,
               v4);
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0003037C) --------------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v7[44]; // [sp+18h] [bp-102Ch] BYREF
  int v8; // [sp+1018h] [bp-2Ch]
  int *v9; // [sp+101Ch] [bp-28h]
  int v10; // [sp+1020h] [bp-24h]
  int v11; // [sp+1024h] [bp-20h]
  int v12; // [sp+1028h] [bp-1Ch]
  int v13; // [sp+102Ch] [bp-18h]
  int v14; // [sp+1030h] [bp-14h]
  void *v15; // [sp+1034h] [bp-10h]
  int v16; // [sp+1038h] [bp-Ch]
  _DWORD *v17; // [sp+103Ch] [bp-8h]

  v12 = 0;
  v11 = 0;
  v10 = 0;
  v13 = 0;
  v16 = 0;
  v14 = 0;
  if ( sub_2E168() )
  {
    printf("godminer is forbidden to start again as it is already started, will exit immediately.");
    return 1;
  }
  else
  {
    if ( log_init() )
      puts("log init error!");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "release version");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "main",
      4,
      1969,
      40,
      v7);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "asic mode");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "main",
      4,
      1974,
      40,
      v7);
    sub_2CE3C(argc, argv);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "opt_algo %d, %s", opt_algo, off_14D568[opt_algo]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/god-miner.c",
      149,
      "main",
      4,
      1978,
      20,
      v7);
    custom_param_check();
    if ( opt_chip_update )
    {
      if ( chip_update_xmr_routine(chip_update_param) )
        return -1;
      else
        return 0;
    }
    else if ( total_pools )
    {
      check_test_pool();
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "Droa is_test_pool=%d", (unsigned __int8)is_test_pool);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "main",
        4,
        2007,
        40,
        v7);
      cal_log_init();
      droa_macro_check();
      if ( opt_version_path )
        read_version_file();
      else
        make_fake_version();
      if ( opt_api_remote )
      {
        pools_active = 1;
        start_api_thread();
      }
      v15 = (void *)dhash_content_init(opt_algo);
      if ( v15 )
      {
        set_frontend_runtime_type((int)v15, opt_algo);
        check_pool_worker();
        v16 = hardware_init((const char *)opt_algo);
        if ( v16 )
        {
          return v16;
        }
        else
        {
          v17 = machine_runtime_init(opt_machine_type, opt_algo);
          if ( v17 )
          {
            sub_2D2F4();
            check_sn(v17[31]);
            sub_2E198();
            http_test_case_init();
            start_http_thread();
            if ( check_pool_connect() == 305 )
            {
              return 1;
            }
            else
            {
              v16 = ((int (__fastcall *)(_DWORD *))v17[12])(v17);
              if ( v16 )
              {
                return v16;
              }
              else
              {
                signal(2, (__sighandler_t)sub_2CFB4);
                signal(3, (__sighandler_t)sub_2CFB4);
                signal(15, (__sighandler_t)sub_2CFB4);
                signal(11, (__sighandler_t)sub_2CFB4);
                signal(10, (__sighandler_t)sub_2CFB4);
                signal(13, (__sighandler_t)1);
                V_LOCK();
                logfmt_raw(v7, 0x1000u, 0, "always catch signal!");
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/god-miner.c",
                  149,
                  "main",
                  4,
                  2096,
                  40,
                  v7);
                if ( create_pool_connect() == 305 )
                {
                  return 1;
                }
                else
                {
                  v9 = &thr_info;
                  thr_info = 0;
                  v8 = sub_2A5D8((int)&thr_info, (void *(*)(void *))work_generator_thread);
                  if ( v8 )
                  {
                    V_LOCK();
                    logfmt_raw(v7, 0x1000u, 0, "work generator thread %d create failed");
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release"
                      "/build/godminer-origin_godminer-branch1/god-miner.c",
                      149,
                      "main",
                      4,
                      2107,
                      100,
                      v7);
                    return 1;
                  }
                  else
                  {
                    v9 = &dword_161030;
                    dword_161030 = 1;
                    v8 = sub_2A5D8((int)&dword_161030, (void *(*)(void *))nonce_submit_thread);
                    if ( v8 )
                    {
                      V_LOCK();
                      logfmt_raw(v7, 0x1000u, 0, "simulation submit thread create failed");
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/relea"
                        "se/build/godminer-origin_godminer-branch1/god-miner.c",
                        149,
                        "main",
                        4,
                        2115,
                        100,
                        v7);
                      return 1;
                    }
                    else
                    {
                      miner_monitor_init();
                      if ( is_test_pool != 1 )
                      {
                        V_LOCK();
                        logfmt_raw(v7, 0x1000u, 0, "record droalogs");
                        V_UNLOCK();
                        zlog(
                          g_zc,
                          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rel"
                          "ease/build/godminer-origin_godminer-branch1/god-miner.c",
                          149,
                          "main",
                          4,
                          2125,
                          40,
                          v7);
                        record_nvdata_droalog();
                      }
                      godminer_register_status_monitor();
                      miner_monitor_start();
                      sleep(5u);
                      set_miner_start_time();
                      set_elapsed_time_validity(1);
                      start_watchpool_thread();
                      sleep(5u);
                      ((void (__fastcall *)(_DWORD *))v17[3])(v17);
                      pthread_join(dword_161004, 0);
                      V_LOCK();
                      logfmt_raw(v7, 0x1000u, 0, "workio threads dead, exiting.");
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/relea"
                        "se/build/godminer-origin_godminer-branch1/god-miner.c",
                        149,
                        "main",
                        4,
                        2182,
                        80,
                        v7);
                      print_summary();
                      dhash_content_exit(v15);
                      ((void (*)(void))v17[5])();
                      machine_runtime_exit((void *)dword_151850);
                      return 0;
                    }
                  }
                }
              }
            }
          }
          else
          {
            printf("invalid pointer(%s)!\n", "machine_runtime");
            return 3;
          }
        }
      }
      else
      {
        printf("invalid pointer(%s)!\n", "dhash_content");
        return 3;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "Need to specify at least one pool server.");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "main",
        4,
        2000,
        80,
        v7);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "Pool setup failed!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/god-miner.c",
        149,
        "main",
        4,
        2001,
        100,
        v7);
      return 1;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D568: using guessed type char *off_14D568[18];
// 14D664: using guessed type int opt_algo;
// 1512C0: using guessed type char opt_api_remote;
// 1512C3: using guessed type char is_test_pool;
// 1512C8: using guessed type int opt_version_path;
// 1513F4: using guessed type char opt_chip_update;
// 1513F8: using guessed type int chip_update_param;
// 1513FC: using guessed type int opt_machine_type;
// 151850: using guessed type int dword_151850;
// 151898: using guessed type char pools_active;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;
// 161000: using guessed type int thr_info;
// 161004: using guessed type int dword_161004;
// 161030: using guessed type int dword_161030;

//----- (00030D14) --------------------------------------------------------
int __fastcall sub_30D14(int a1, int a2, int a3)
{
  _BYTE v4[40]; // [sp+18h] [bp-2Ch] BYREF

  memset(v4, 0, 16);
  return sub_30D40(a1, a2, a3, v4);
}
// 30D40: using guessed type int __fastcall sub_30D40(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00030D40) --------------------------------------------------------
void __fastcall sub_30D40(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // r11
  __int64 v7; // d16
  __int64 v8; // d17
  _QWORD *v9; // r3
  char v10; // r1

  v9 = (_QWORD *)(a4 + 10);
  *v9 = v7;
  v9[1] = v8;
  *(_DWORD *)(v6 - 8) = 0;
  while ( *(_DWORD *)(v6 - 60) && *(int *)(v6 - 8) <= 29 )
  {
    sub_CC7AC(*(_DWORD *)(v6 - 60), *(_DWORD *)(v6 - 64));
    *(_BYTE *)(v6 - 48 + (*(_DWORD *)(v6 - 8))++) = v10 + 48;
    *(_DWORD *)(v6 - 60) = sub_CC518(*(_DWORD *)(v6 - 60), *(_DWORD *)(v6 - 64));
  }
  *(_DWORD *)(v6 - 12) = 0;
  *(_DWORD *)(v6 - 16) = *(_DWORD *)(v6 - 8) - 1;
  while ( *(_DWORD *)(v6 - 12) < *(_DWORD *)(v6 - 8) )
    *(_BYTE *)(*(_DWORD *)(v6 - 56) + (*(_DWORD *)(v6 - 12))++) = *(_BYTE *)(v6 - 48 + (*(_DWORD *)(v6 - 16))--);
  __asm { POP             {R11,PC} }
}
// 30E28: unbalanced stack, ignored a potential tail call
// 30D44: variable 'v7' is possibly undefined
// 30D44: variable 'v8' is possibly undefined
// 30D4C: variable 'v6' is possibly undefined
// 30D80: variable 'v10' is possibly undefined

//----- (00030E2C) --------------------------------------------------------
int __fastcall sub_30E2C(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (00030EA0) --------------------------------------------------------
int __fastcall sub_30EA0(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/util.h",
    144,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00030FC4) --------------------------------------------------------
_BYTE *__fastcall sub_30FC4(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00031030) --------------------------------------------------------
int __fastcall get_miner_info(int a1)
{
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  _DWORD v8[2]; // [sp+Ch] [bp-18h] BYREF
  int v9; // [sp+14h] [bp-10h]
  int v10; // [sp+18h] [bp-Ch]
  int i; // [sp+1Ch] [bp-8h]

  v10 = 0;
  v9 = 12;
  v8[0] = 0;
  v8[1] = get_all_created_runtime(v8);
  for ( i = 0; i < v8[0]; ++i )
  {
    v1 = sprintf((char *)(a1 + v10), "chain%d_voltage=%d;", i + 1, v9);
    v10 += v1;
    v2 = sprintf((char *)(a1 + v10), "chain%d_voladded=%d;", i + 1, 0);
    v10 += v2;
    v3 = sprintf((char *)(a1 + v10), "chain%d_basefreq=%d;", i + 1, 0);
    v10 += v3;
    v4 = sprintf((char *)(a1 + v10), "chain%d_badcore=%d;", i + 1, 0);
    v10 += v4;
  }
  v5 = sprintf((char *)(a1 + v10), "chainnum=%d;", v8[0]);
  return sprintf((char *)(a1 + v10 + v5), "version=%s;", g_miner_compiletime);
}

//----- (000311D0) --------------------------------------------------------
int get_error_type()
{
  return freq_scan_status;
}
// 14DB84: using guessed type int freq_scan_status;

//----- (000311F4) --------------------------------------------------------
int __fastcall sub_311F4(int result)
{
  if ( result == 1 )
  {
    freq_scan_status = 1;
  }
  else if ( result == 2 )
  {
    freq_scan_status = 2;
    strcpy((char *)&search_failed_info, "R:1");
    return *(_DWORD *)"R:1";
  }
  else
  {
    freq_scan_status = 0;
    if ( result )
    {
      strcpy((char *)&search_failed_info, "unknown");
      return *(_DWORD *)"unknown";
    }
  }
  return result;
}
// 14DB84: using guessed type int freq_scan_status;
// 161120: using guessed type int search_failed_info;

//----- (000312B8) --------------------------------------------------------
int __fastcall sub_312B8(char *a1, size_t a2, int a3)
{
  if ( freq_scan_status == 1 )
  {
    snprintf(a1, a2, "%d", a3);
  }
  else if ( freq_scan_status == 2 )
  {
    snprintf(a1, a2, "%s:%s", "searchfailed", (const char *)&search_failed_info);
  }
  else
  {
    snprintf(a1, a2, "searching");
  }
  return 0;
}
// 14DB84: using guessed type int freq_scan_status;
// 161120: using guessed type int search_failed_info;

//----- (0003137C) --------------------------------------------------------
bool __cdecl packed_rename(CURL *curl, pool *pool)
{
  return 0;
}

//----- (000313A4) --------------------------------------------------------
int get_miner_sale_hashrate()
{
  double v0; // d0
  int v1; // r0
  double v3; // d0
  unsigned int v5; // [sp+4h] [bp-68h] BYREF
  int v6; // [sp+8h] [bp-64h] BYREF
  char v7[12]; // [sp+Ch] [bp-60h] BYREF
  double v8; // [sp+18h] [bp-54h] BYREF
  double v9[2]; // [sp+20h] [bp-4Ch] BYREF
  int v10; // [sp+30h] [bp-3Ch]
  char *miner_6060info_status; // [sp+34h] [bp-38h]
  double v12; // [sp+38h] [bp-34h]
  double v13; // [sp+40h] [bp-2Ch]
  int v14; // [sp+48h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+4Ch] [bp-20h]
  int k; // [sp+50h] [bp-1Ch]
  int j; // [sp+54h] [bp-18h]
  int i; // [sp+58h] [bp-14h]
  int v19; // [sp+5Ch] [bp-10h]
  double v20; // [sp+60h] [bp-Ch]

  v6 = 0;
  all_created_runtime = get_all_created_runtime(&v6);
  v14 = 0;
  v5 = 1;
  v19 = 0;
  get_miner_elapsed_time();
  v13 = v0;
  v12 = 0.0;
  miner_6060info_status = get_miner_6060info_status();
  v9[0] = 0.0;
  v20 = 0.0;
  for ( i = 0; i < v6; ++i )
  {
    v1 = (*(int (__fastcall **)(_DWORD, double *, unsigned int *))(all_created_runtime[i] + 140))(
           all_created_runtime[i],
           &v8,
           &v5);
    v19 |= v1;
    v20 = v20 + v8;
  }
  v12 = 0.0;
  if ( v13 - 0.0 >= 1.0 )
  {
    if ( v19 )
    {
      sub_311F4(2);
      strcpy((char *)&search_failed_info, "R:1");
    }
    if ( *miner_6060info_status )
    {
      sub_311F4(2);
      strcpy((char *)&search_failed_info, "P:1");
    }
    for ( j = 0; j <= 7; ++j )
    {
      if ( miner_6060info_status[16 * j + 48] )
      {
        sub_311F4(2);
        snprintf((char *)&search_failed_info, 0x100u, "F%d:1", j);
      }
    }
    for ( k = 0; k <= 15; ++k )
    {
      if ( miner_6060info_status[16 * k + 432] )
      {
        sub_311F4(2);
        snprintf((char *)&search_failed_info, 0x100u, "J%d:1", k);
      }
    }
    v10 = frontend_runtime_instance();
    v3 = v20;
    format_hashrate_double(*(const char **)(*(_DWORD *)(v10 + 72) + 16), v9, v7);
    v9[1] = v3;
    v14 = (int)v9[0];
    return sub_CC518((int)v9[0] * v5, v5);
  }
  else
  {
    sub_311F4(0);
    return v14;
  }
}
// 313E4: variable 'v0' is possibly undefined
// 161120: using guessed type int search_failed_info;

//----- (00031658) --------------------------------------------------------
int get_miner_qualified_hashrate()
{
  sub_311F4(1);
  return get_miner_sale_hashrate();
}

//----- (00031678) --------------------------------------------------------
int get_theory_hashrate()
{
  double v0; // d0
  int v1; // r0
  char v4[12]; // [sp+0h] [bp-54h] BYREF
  int v5; // [sp+Ch] [bp-48h] BYREF
  double v6; // [sp+10h] [bp-44h] BYREF
  double v7; // [sp+18h] [bp-3Ch] BYREF
  int v8; // [sp+24h] [bp-30h]
  double v9; // [sp+28h] [bp-2Ch]
  double v10; // [sp+30h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+38h] [bp-1Ch]
  int i; // [sp+3Ch] [bp-18h]
  int v13; // [sp+40h] [bp-14h]
  int v14; // [sp+44h] [bp-10h]
  double v15; // [sp+48h] [bp-Ch]

  v5 = 0;
  all_created_runtime = get_all_created_runtime(&v5);
  v13 = 0;
  get_miner_elapsed_time();
  v10 = v0;
  v9 = 0.0;
  v15 = 0.0;
  v7 = 0.0;
  for ( i = 0; i < v5; ++i )
  {
    v1 = (*(int (__fastcall **)(_DWORD, double *))(all_created_runtime[i] + 136))(all_created_runtime[i], &v6);
    v13 |= v1;
    v15 = v15 + v6;
  }
  v9 = 0.0;
  if ( v10 - 0.0 >= 1.0 )
  {
    v8 = frontend_runtime_instance();
    format_hashrate_double(*(const char **)(*(_DWORD *)(v8 + 72) + 16), &v7, v4);
    if ( v13 )
    {
      sub_311F4(2);
    }
    else
    {
      v14 = (int)v7;
      sub_311F4(1);
    }
    return v14;
  }
  else
  {
    sub_311F4(0);
    return (int)v7;
  }
}
// 31678: too many cbuild loops
// 316A8: variable 'v0' is possibly undefined

//----- (000317F4) --------------------------------------------------------
int __fastcall http_test_bm(int a1, char *a2, pool *a3)
{
  int miner_sale_hashrate; // r0
  size_t v4; // r0
  const char *v5; // r12
  char *v6; // r5
  int v7; // r1
  int v8; // r2
  int v9; // r3
  char v10; // r2
  int v11; // r0
  char v17[20]; // [sp+20h] [bp-1054h] BYREF
  __int64 ptr; // [sp+1020h] [bp-54h] BYREF
  __int16 v19; // [sp+1028h] [bp-4Ch]
  __int64 v20; // [sp+102Ah] [bp-4Ah]
  int v21; // [sp+1034h] [bp-40h] BYREF
  int v22; // [sp+1038h] [bp-3Ch] BYREF
  int v23; // [sp+103Ch] [bp-38h] BYREF
  int miner_qualified_hashrate; // [sp+1040h] [bp-34h]
  int v25; // [sp+1044h] [bp-30h]
  FILE *stream; // [sp+1048h] [bp-2Ch]
  int v27; // [sp+104Ch] [bp-28h]
  _DWORD *all_created_runtime; // [sp+1050h] [bp-24h]
  int v29; // [sp+1054h] [bp-20h]
  int miner_power; // [sp+1058h] [bp-1Ch]
  int i; // [sp+105Ch] [bp-18h]

  v23 = -1;
  v22 = -1;
  v21 = 0;
  v29 = 0;
  all_created_runtime = get_all_created_runtime(&v21);
  if ( strstr((const char *)(a1 + 4), "/rate") )
  {
    miner_qualified_hashrate = 0;
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "cmd : get rate");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/http_test.c",
      149,
      "http_test_bm",
      12,
      310,
      20,
      v17);
    miner_qualified_hashrate = get_miner_qualified_hashrate();
    sub_312B8(a2, (size_t)a3, miner_qualified_hashrate);
    return 0;
  }
  if ( strstr((const char *)(a1 + 4), "/test") )
  {
    _isoc99_sscanf(a1 + 4, "/test.%d.%d", &v23, &v22);
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "cmd : get test = %d", v23);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/http_test.c",
      149,
      "http_test_bm",
      12,
      317,
      20,
      v17);
    if ( v23 == 523 )
      get_miner_info((int)a2);
    else
      sprintf(a2, "OK get test=%d", v23);
    return 0;
  }
  if ( strstr((const char *)(a1 + 4), "/ideal_rate") )
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "cmd : get ideal rate");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/http_test.c",
      149,
      "http_test_bm",
      12,
      331,
      20,
      v17);
    miner_sale_hashrate = get_miner_sale_hashrate();
    sub_312B8(a2, (size_t)a3, miner_sale_hashrate);
    return 0;
  }
  if ( strstr((const char *)(a1 + 4), "/max_rate") )
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "cmd : get max rate");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/http_test.c",
      149,
      "http_test_bm",
      12,
      337,
      20,
      v17);
    v25 = 102 * get_theory_hashrate() / 100;
    sub_312B8(a2, (size_t)a3, v25);
    return 0;
  }
  if ( strstr((const char *)(a1 + 4), "/miner_status") )
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "cmd : get miner status");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/http_test.c",
      149,
      "http_test_bm",
      12,
      343,
      20,
      v17);
    packed_rename((CURL *)a2, a3);
    return 0;
  }
  if ( strstr((const char *)(a1 + 4), "/productName") )
  {
    V_LOCK();
    v4 = strlen(g_miner_type);
    logfmt_raw(v17, 0x1000u, 0, "cmd : get miner type[%d] %s", v4, g_miner_type);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/http_test.c",
      149,
      "http_test_bm",
      12,
      348,
      20,
      v17);
    strcpy(a2, g_miner_type);
    return 0;
  }
  if ( !strncmp((const char *)(a1 + 4), "/get_sn", 7u) )
  {
    v27 = 0;
    ptr = 0;
    v19 = 0;
    v20 = 0;
    stream = 0;
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "cmd : get miner sn");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/http_test.c",
      149,
      "http_test_bm",
      12,
      356,
      20,
      v17);
    stream = fopen((const char *)g_miner_sn_file_path, "r");
    if ( stream )
    {
      fread(&ptr, 0x11u, 1u, stream);
      fclose(stream);
    }
    else
    {
      v27 = -1;
    }
    if ( !(_BYTE)ptr )
      v27 = -2;
    if ( v27 )
      strcpy(a2, "no miner sn stored on board");
    else
      snprintf(a2, 0x12u, "%s", (const char *)&ptr);
    return 0;
  }
  if ( !strncmp((const char *)(a1 + 4), "/set_sn", 7u) )
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "cmd : set miner sn, doesn't spport");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/http_test.c",
      149,
      "http_test_bm",
      12,
      430,
      80,
      v17);
    v5 = "doesn't support sn set in Release mode";
    v6 = a2;
    do
    {
      v7 = *((_DWORD *)v5 + 1);
      v8 = *((_DWORD *)v5 + 2);
      v9 = *((_DWORD *)v5 + 3);
      *(_DWORD *)v6 = *(_DWORD *)v5;
      *((_DWORD *)v6 + 1) = v7;
      *((_DWORD *)v6 + 2) = v8;
      *((_DWORD *)v6 + 3) = v9;
      v5 += 16;
      v6 += 16;
    }
    while ( v5 != "e mode" );
    *(_DWORD *)v6 = *(_DWORD *)v5;
    v10 = v5[6];
    *((_WORD *)v6 + 2) = *((_WORD *)v5 + 2);
    v6[6] = v10;
    return 0;
  }
  if ( !strncmp((const char *)(a1 + 4), "/miner_power", 0xCu) )
  {
    miner_power = bitmain_get_miner_power();
    snprintf(a2, (size_t)a3, "miner power:%d", miner_power);
    return 0;
  }
  if ( !strncmp((const char *)(a1 + 4), "/miner_temp", 0xBu) )
  {
    for ( i = 0; i < v21; ++i )
    {
      if ( *(_BYTE *)(all_created_runtime[i] + 256) )
      {
        (*(void (__fastcall **)(_DWORD, char *, int))(all_created_runtime[i] + 208))(all_created_runtime[i], v17, 4000);
        v11 = snprintf(&a2[v29], (size_t)a3 - v29, "chain_fd %d:\n%s\n", *(_DWORD *)(all_created_runtime[i] + 252), v17);
        v29 += v11;
      }
    }
    return 0;
  }
  return -1;
}
// 1D24C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15241C: using guessed type int g_miner_sn_file_path;
// 1608F0: using guessed type int g_zc;

//----- (000321BC) --------------------------------------------------------
void http_test_case_init()
{
  http_test_case = http_test_bm;
}
// 1608E8: using guessed type _UNKNOWN *http_test_case;

//----- (000321E8) --------------------------------------------------------
void __fastcall sub_321E8(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (00032250) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_32250(int a1, __int64 a2)
{
  V_INT(a1, "poolno", a2);
}

//----- (00032284) --------------------------------------------------------
int __fastcall sub_32284(int a1, void *(*a2)(void *))
{
  int v5; // [sp+Ch] [bp-8h]

  pthread_attr_init((pthread_attr_t *)(a1 + 8));
  v5 = pthread_create((pthread_t *)(a1 + 4), (const pthread_attr_t *)(a1 + 8), a2, (void *)a1);
  pthread_attr_destroy((pthread_attr_t *)(a1 + 8));
  return v5;
}

//----- (000322F0) --------------------------------------------------------
int __fastcall sub_322F0(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 3235C: variable 'v3' is possibly undefined

//----- (00032408) --------------------------------------------------------
int __fastcall sub_32408(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0003247C) --------------------------------------------------------
int __fastcall sub_3247C(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/util.h",
    144,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000325A0) --------------------------------------------------------
_BYTE *__fastcall sub_325A0(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0003260C) --------------------------------------------------------
int __fastcall sub_3260C(unsigned __int8 *a1)
{
  int result; // r0
  char v3[12]; // [sp+18h] [bp-100Ch] BYREF
  _DWORD *v4; // [sp+1018h] [bp-Ch]
  int *v5; // [sp+101Ch] [bp-8h]

  v5 = (int *)&reject_reason_map;
  if ( (unsigned int)dword_151914 <= 0x13 )
  {
    if ( !dword_151914 )
    {
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "reject reason init %d", dword_151914);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "reject_reason_history_update",
        28,
        48,
        40,
        v3);
      memset(&reject_reason_map, 0, 0x14u);
    }
    result = map_get_(v5, a1);
    v5[3] = result;
    v4 = (_DWORD *)v5[3];
    if ( v4 )
    {
      ++*v4;
    }
    else
    {
      ++dword_151914;
      v5[4] = 1;
      return map_set_(v5, a1, v5 + 4, 4u);
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "only support %d reject reasons", dword_151914);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/pool.c",
             144,
             "reject_reason_history_update",
             28,
             43,
             20,
             v3);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151914: using guessed type int dword_151914;
// 1608F0: using guessed type int g_zc;

//----- (00032824) --------------------------------------------------------
int sub_32824()
{
  int v0; // r0
  _DWORD v2[2]; // [sp+0h] [bp-14h] BYREF
  unsigned __int8 *v3; // [sp+8h] [bp-Ch]
  int *v4; // [sp+Ch] [bp-8h]

  v4 = (int *)&reject_reason_map;
  map_iter_(v2);
  puts("--------reject_reason_history_dump:-------");
  while ( 1 )
  {
    v3 = (unsigned __int8 *)map_next_(v4, v2);
    if ( !v3 )
      break;
    v0 = map_get_(v4, v3);
    v4[3] = v0;
    printf("%s happened %d times\n", (const char *)v3, *(_DWORD *)v4[3]);
  }
  return puts("---------------------end------------------");
}

//----- (000328D0) --------------------------------------------------------
int get_current_pool()
{
  int v1; // [sp+4h] [bp-8h]

  pthread_mutex_lock(&stru_1518A8);
  v1 = dword_1518A4;
  pthread_mutex_unlock(&stru_1518A8);
  return v1;
}
// 1518A4: using guessed type int dword_1518A4;
// 1518A8: using guessed type pthread_mutex_t stru_1518A8;

//----- (00032914) --------------------------------------------------------
bool __fastcall current_pool_changed(int a1)
{
  return get_current_pool() != a1;
}

//----- (00032954) --------------------------------------------------------
int __fastcall wait_pool_to_be_current(int a1)
{
  pthread_mutex_lock(&stru_1518A8);
  while ( a1 != dword_1518A4 )
    pthread_cond_wait(&stru_1518C0, &stru_1518A8);
  return pthread_mutex_unlock(&stru_1518A8);
}
// 1518A4: using guessed type int dword_1518A4;
// 1518A8: using guessed type pthread_mutex_t stru_1518A8;
// 1518C0: using guessed type pthread_cond_t stru_1518C0;

//----- (000329B8) --------------------------------------------------------
int __fastcall wait_pool_to_be_current_timeout(int a1)
{
  struct timespec tp; // [sp+8h] [bp-24h] BYREF
  struct timespec abstime; // [sp+10h] [bp-1Ch] BYREF
  int v5; // [sp+18h] [bp-14h]
  struct timespec *p_abstime; // [sp+1Ch] [bp-10h]
  int v7; // [sp+20h] [bp-Ch]
  int v8; // [sp+24h] [bp-8h]

  v8 = 1;
  v7 = 1;
  p_abstime = &abstime;
  clock_gettime(1, &tp);
  v5 = tp.tv_nsec + 1000 * (v7 - (_DWORD)&unk_F4240 * (v7 / 1000000));
  p_abstime->tv_sec = tp.tv_sec + v5 / 1000000000 + v7 / 1000000;
  p_abstime->tv_nsec = v5 % 1000000000;
  pthread_mutex_lock(&stru_1518A8);
  if ( a1 != dword_1518A4 )
    pthread_cond_timedwait(&stru_1518C0, &stru_1518A8, &abstime);
  return pthread_mutex_unlock(&stru_1518A8);
}
// 1518A4: using guessed type int dword_1518A4;
// 1518A8: using guessed type pthread_mutex_t stru_1518A8;
// 1518C0: using guessed type pthread_cond_t stru_1518C0;

//----- (00032B08) --------------------------------------------------------
int __fastcall set_current_pool(int a1)
{
  pthread_mutex_lock(&stru_1518A8);
  dword_1518A4 = a1;
  pthread_cond_broadcast(&stru_1518C0);
  return pthread_mutex_unlock(&stru_1518A8);
}
// 1518A4: using guessed type int dword_1518A4;
// 1518A8: using guessed type pthread_mutex_t stru_1518A8;
// 1518C0: using guessed type pthread_cond_t stru_1518C0;

//----- (00032B58) --------------------------------------------------------
char *add_pool()
{
  int v0; // r2
  char v2[8]; // [sp+14h] [bp-1008h] BYREF
  char *v3; // [sp+1014h] [bp-8h]

  v3 = (char *)calloc(0x7D0u, 1u);
  if ( !v3 )
  {
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "Failed to malloc pool in add_pool");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/pool.c",
      144,
      "add_pool",
      8,
      125,
      100,
      v2);
    set_miner_6060info_malloc_failed_err(1);
    exit(1);
  }
  *((_DWORD *)v3 + 1) = total_pools;
  *(_DWORD *)v3 = *((_DWORD *)v3 + 1);
  pools = (int)realloc((void *)pools, 4 * (total_pools + 2));
  v0 = total_pools++;
  *(_DWORD *)(pools + 4 * v0) = v3;
  *((_DWORD *)v3 + 9) = -1;
  *((_DWORD *)v3 + 11) = 0;
  v3[28] = 1;
  v3[1648] = 0;
  v3[1656] = 0;
  *((_DWORD *)v3 + 437) = 0;
  *((_DWORD *)v3 + 439) = 0;
  *((_QWORD *)v3 + 221) = 0;
  *((_DWORD *)v3 + 444) = 0;
  memset(v3 + 1684, 0, 0x40u);
  *((_QWORD *)v3 + 226) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v3 + 1592), 0);
  pthread_mutex_init((pthread_mutex_t *)v3 + 76, 0);
  pthread_condattr_init((pthread_condattr_t *)v3 + 462);
  pthread_condattr_setclock((pthread_condattr_t *)v3 + 462, 1);
  pthread_cond_init((pthread_cond_t *)(v3 + 1856), (const pthread_condattr_t *)v3 + 462);
  pthread_mutex_init((pthread_mutex_t *)v3 + 2, 0);
  pthread_mutex_init((pthread_mutex_t *)(v3 + 1592), 0);
  pthread_mutex_init((pthread_mutex_t *)(v3 + 1780), 0);
  pthread_mutex_init((pthread_mutex_t *)(v3 + 1660), 0);
  v3[1916] = 0;
  v3[1904] = 1;
  *((_DWORD *)v3 + 477) = -1;
  return v3;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;

//----- (00032E54) --------------------------------------------------------
pool *add_url()
{
  if ( ++dword_151908 > total_pools )
    add_pool();
  return *(pool **)(pools + 4 * (dword_151908 + 0x3FFFFFFF));
}
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 151908: using guessed type int dword_151908;

//----- (00032ECC) --------------------------------------------------------
int __fastcall sub_32ECC(int a1, const char *a2)
{
  char *v2; // r3
  size_t v3; // r0
  int result; // r0
  char v7[8]; // [sp+1Ch] [bp-1008h] BYREF
  char *src; // [sp+101Ch] [bp-8h]

  src = strstr(a2, "://");
  if ( src )
    v2 = src + 3;
  else
    v2 = (char *)a2;
  src = v2;
  if ( v2 == a2 )
  {
    if ( *src )
    {
      if ( *(_DWORD *)(a1 + 12) )
        free(*(void **)(a1 + 12));
      v3 = strlen(src);
      *(_DWORD *)(a1 + 12) = malloc(v3 + 128);
      sprintf(*(char **)(a1 + 12), "stratum+tcp://%s", src);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "invalid URL -- '%s'", a2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "setup_url",
        9,
        187,
        100,
        v7);
      if ( *(_DWORD *)(a1 + 12) )
        free(*(void **)(a1 + 12));
      *(_DWORD *)(a1 + 12) = strdup(byte_D87E4);
    }
  }
  else
  {
    if ( strncasecmp(a2, "http://", 7u) && strncasecmp(a2, "https://", 8u) && strncasecmp(a2, "stratum+tcp://", 0xEu) )
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "unknown protocol -- '%s'", a2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "setup_url",
        9,
        178,
        100,
        v7);
    }
    if ( *(_DWORD *)(a1 + 12) )
      free(*(void **)(a1 + 12));
    *(_DWORD *)(a1 + 12) = strdup(a2);
    strcpy((char *)(*(_DWORD *)(a1 + 12) + src - a2), src);
  }
  result = strncasecmp(*(const char **)(a1 + 12), "stratum", 7u);
  *(_BYTE *)(a1 + 28) = result == 0;
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000332A0) --------------------------------------------------------
int __fastcall set_url(const char *a1)
{
  pool *v3; // [sp+Ch] [bp-8h]

  v3 = add_url();
  sub_32ECC((int)v3, a1);
  return 0;
}

//----- (000332D4) --------------------------------------------------------
int __fastcall set_user(const char *a1)
{
  int v3; // [sp+Ch] [bp-8h]

  if ( ++dword_15190C > total_pools )
    add_pool();
  v3 = *(_DWORD *)(pools + 4 * (dword_15190C + 0x3FFFFFFF));
  if ( *(_DWORD *)(v3 + 16) )
    free(*(void **)(v3 + 16));
  *(_DWORD *)(v3 + 16) = strdup(a1);
  return 0;
}
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 15190C: using guessed type int dword_15190C;

//----- (00033398) --------------------------------------------------------
int __fastcall set_pass(const char *a1)
{
  int v3; // [sp+Ch] [bp-8h]

  if ( ++dword_151910 > total_pools )
    add_pool();
  v3 = *(_DWORD *)(pools + 4 * (dword_151910 + 0x3FFFFFFF));
  if ( *(_DWORD *)(v3 + 20) )
    free(*(void **)(v3 + 20));
  *(_DWORD *)(v3 + 20) = strdup(a1);
  return 0;
}
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 151910: using guessed type int dword_151910;

//----- (0003345C) --------------------------------------------------------
int __fastcall sub_3345C(int a1)
{
  char v4[16]; // [sp+1Ch] [bp-1010h] BYREF
  int v5; // [sp+101Ch] [bp-10h]
  int i; // [sp+1020h] [bp-Ch]
  int v7; // [sp+1024h] [bp-8h]

  v7 = 0;
  for ( i = 0; i < total_pools; ++i )
  {
    v5 = *(_DWORD *)(pools + 4 * i);
    if ( a1 == *(_DWORD *)(v5 + 4) )
    {
      v7 = v5;
      break;
    }
  }
  if ( v7 )
    return v7;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "WTF No pool %d found!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/pool.c",
    144,
    "priority_pool",
    13,
    254,
    100,
    v4);
  return *(_DWORD *)(pools + 4 * a1);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;

//----- (000335C0) --------------------------------------------------------
bool __fastcall sub_335C0(pthread_mutex_t *a1)
{
  return pool_tget(a1, (unsigned __int8 *)&a1[79].__size[8]) != 0;
}

//----- (00033608) --------------------------------------------------------
int __fastcall pool_tset(int a1, unsigned __int8 *a2, char a3)
{
  unsigned __int8 v7; // [sp+17h] [bp-5h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1824));
  v7 = *a2;
  *a2 = 1;
  if ( a3 )
    pthread_cond_broadcast((pthread_cond_t *)(a1 + 1856));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1824));
  return v7;
}

//----- (00033688) --------------------------------------------------------
int __fastcall pool_tclear(int a1, unsigned __int8 *a2, char a3)
{
  unsigned __int8 v7; // [sp+17h] [bp-5h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1824));
  v7 = *a2;
  *a2 = 0;
  if ( a3 )
    pthread_cond_broadcast((pthread_cond_t *)(a1 + 1856));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1824));
  return v7;
}

//----- (00033708) --------------------------------------------------------
int __fastcall pool_tget(pthread_mutex_t *a1, unsigned __int8 *a2)
{
  unsigned __int8 v5; // [sp+Fh] [bp-5h]

  pthread_mutex_lock(a1 + 76);
  v5 = *a2;
  pthread_mutex_unlock(a1 + 76);
  return v5;
}

//----- (00033758) --------------------------------------------------------
int __fastcall pool_twait_to_be_expected_and_set(int a1, _BYTE *a2, char a3, char a4, struct timespec *abstime)
{
  int v10; // [sp+14h] [bp-8h]

  v10 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1824));
  if ( abstime )
  {
    while ( a3 != *a2 )
    {
      v10 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 1856), (pthread_mutex_t *)(a1 + 1824), abstime);
      if ( v10 == 110 )
        break;
      if ( !v10 && current_pool_changed(a1) )
      {
        v10 = 1;
        break;
      }
    }
  }
  else
  {
    while ( a3 != *a2 )
      v10 = pthread_cond_wait((pthread_cond_t *)(a1 + 1856), (pthread_mutex_t *)(a1 + 1824));
  }
  if ( !v10 )
    *a2 = a4;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1824));
  return v10;
}

//----- (00033890) --------------------------------------------------------
int switch_pools()
{
  int result; // r0
  char v1[20]; // [sp+10h] [bp-1014h] BYREF
  pthread_mutex_t *v2; // [sp+1010h] [bp-14h]
  pthread_mutex_t *v3; // [sp+1014h] [bp-10h]
  int lock; // [sp+1018h] [bp-Ch]
  int i; // [sp+101Ch] [bp-8h]

  pthread_mutex_lock(&stru_1518A8);
  v3 = (pthread_mutex_t *)dword_1518A4;
  lock = *(_DWORD *)dword_1518A4;
  for ( i = 0; i < total_pools; ++i )
  {
    v2 = (pthread_mutex_t *)sub_3345C(i);
    if ( !sub_335C0(v2) )
    {
      lock = v2->__lock;
      break;
    }
  }
  v2 = *(pthread_mutex_t **)(pools + 4 * lock);
  pthread_mutex_unlock(&stru_1518A8);
  set_current_pool((int)v2);
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "Switching pool %d to pool %d", v3->__lock, v2->__lock);
  V_UNLOCK();
  result = zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/pool.c",
             144,
             "switch_pools",
             12,
             366,
             40,
             v1);
  if ( v2 != v3 )
  {
    pthread_mutex_lock(v3 + 76);
    pthread_cond_broadcast((pthread_cond_t *)(&v3[77].__align + 2));
    return pthread_mutex_unlock(v3 + 76);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1518A4: using guessed type int dword_1518A4;
// 1518A8: using guessed type pthread_mutex_t stru_1518A8;
// 1608F0: using guessed type int g_zc;

//----- (00033A40) --------------------------------------------------------
_DWORD *sub_33A40()
{
  _DWORD *result; // r0
  int v1; // [sp+0h] [bp-14h] BYREF
  _DWORD *v2; // [sp+4h] [bp-10h]
  int j; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  v1 = 0;
  result = get_all_created_runtime(&v1);
  v2 = result;
  for ( i = 0; i < v1; ++i )
  {
    for ( j = 0; j <= 31; ++j )
      *(_BYTE *)(v2[i] + j + 536) = 1;
  }
  return result;
}

//----- (00033AE4) --------------------------------------------------------
_DWORD *__fastcall sub_33AE4(_DWORD *a1, char a2)
{
  _DWORD *result; // r0
  int v5; // [sp+Ch] [bp-10h] BYREF
  _DWORD *v6; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  v5 = 0;
  result = get_all_created_runtime(&v5);
  v6 = result;
  for ( i = 0; i < v5; ++i )
    *(_BYTE *)(v6[i] + *a1 + 536) = a2;
  return result;
}

//----- (00033B70) --------------------------------------------------------
_DWORD *__fastcall pool_alive(int a1)
{
  _DWORD *result; // r0

  result = (_DWORD *)pool_tclear(a1, (unsigned __int8 *)(a1 + 1904), 0);
  if ( result )
    return sub_33AE4((_DWORD *)a1, 0);
  return result;
}

//----- (00033BBC) --------------------------------------------------------
int __fastcall pool_died(int *a1)
{
  int result; // r0
  char v3[12]; // [sp+30h] [bp-104Ch] BYREF
  _DWORD v4[7]; // [sp+1030h] [bp-4Ch] BYREF
  int v5; // [sp+104Ch] [bp-30h]
  _DWORD v6[7]; // [sp+1050h] [bp-2Ch] BYREF
  int v7; // [sp+106Ch] [bp-10h]

  result = pool_tset((int)a1, (unsigned __int8 *)a1 + 1904, 0);
  if ( (unsigned __int8)result != 1 )
  {
    cgtime((struct timeval *)(a1 + 477));
    sub_33AE4(a1, 1);
    if ( a1 == (int *)get_current_pool() )
    {
      V_LOCK();
      sub_32250((int)v4, *a1);
      logfmt_raw(v3, 0x1000u, 0, v5, v4[0], v4[1], v4[2], v4[3], v4[4], v4[5], v4[6], v5, "not responding!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "pool_died",
        9,
        404,
        80,
        v3);
      return switch_pools();
    }
    else
    {
      V_LOCK();
      sub_32250((int)v6, *a1);
      logfmt_raw(v3, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "failed to return work");
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/pool.c",
               144,
               "pool_died",
               9,
               407,
               20,
               v3);
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00033DD4) --------------------------------------------------------
int check_pool_worker()
{
  char v1[16]; // [sp+14h] [bp-1010h] BYREF
  int v2; // [sp+1014h] [bp-10h]
  int v3; // [sp+1018h] [bp-Ch]
  int i; // [sp+101Ch] [bp-8h]

  v2 = 0;
  v3 = 0;
  for ( i = 0; i < total_pools; ++i )
  {
    if ( **(_BYTE **)(*(_DWORD *)(pools + 4 * i) + 12) )
    {
      if ( **(_BYTE **)(*(_DWORD *)(pools + 4 * i) + 16) )
      {
        ++v2;
      }
      else
      {
        V_LOCK();
        logfmt_raw(v1, 0x1000u, 0, "Blank worker exists.");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/pool.c",
          144,
          "check_pool_worker",
          17,
          421,
          100,
          v1);
      }
    }
  }
  if ( !v2 )
  {
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, "No valid pools, please configure them first!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/pool.c",
      144,
      "check_pool_worker",
      17,
      427,
      100,
      v1);
    return -1;
  }
  return v3;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;

//----- (00033F98) --------------------------------------------------------
void load_factory_pools()
{
  ;
}

//----- (00033FB0) --------------------------------------------------------
int __fastcall share_result(int a1, int a2, unsigned __int8 *a3, double *a4)
{
  unsigned int v4; // r3
  int v5; // r1
  unsigned int v6; // r3
  int v7; // r1
  char v12[20]; // [sp+38h] [bp-1054h] BYREF
  _DWORD v13[7]; // [sp+1038h] [bp-54h] BYREF
  int v14; // [sp+1054h] [bp-38h]
  _DWORD v15[7]; // [sp+1058h] [bp-34h] BYREF
  int v16; // [sp+1074h] [bp-18h]
  int v17; // [sp+107Ch] [bp-10h]

  pthread_mutex_lock(&stru_1518F0);
  if ( a1 )
  {
    ++*(_QWORD *)&total_accepted;
    total_diff_accepted = a4[226] + total_diff_accepted;
    ++*((_QWORD *)a4 + 241);
    a4[245] = a4[245] + a4[226];
    *((_DWORD *)a4 + 404) = time(0);
    a4[203] = a4[226];
  }
  else
  {
    total_diff_rejected = a4[226] + total_diff_rejected;
    a4[246] = a4[246] + a4[226];
    ++*((_QWORD *)a4 + 242);
    ++*(_QWORD *)&total_rejected;
  }
  pthread_mutex_unlock(&stru_1518F0);
  if ( !a1 )
  {
    v17 = *((_DWORD *)a4 + 484);
    if ( a3 )
    {
      sub_3260C(a3);
      v4 = v17;
      if ( v17 < 1 )
        v4 = 1;
      sub_CC7AC(v17 % 10 + v17 % 100 + v17 % 1000 + v17 % 10000, v4);
      if ( !v5 )
      {
        V_LOCK();
        sub_32250((int)v13, *(int *)a4);
        logfmt_raw(
          v12,
          0x1000u,
          0,
          v14,
          v13[0],
          v13[1],
          v13[2],
          v13[3],
          v13[4],
          v13[5],
          v13[6],
          v14,
          "reject reason: %s",
          a3);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/pool.c",
          144,
          "share_result",
          12,
          577,
          80,
          v12);
      }
    }
    else
    {
      sub_3260C("NULL");
      v6 = v17;
      if ( v17 < 1 )
        v6 = 1;
      sub_CC7AC(v17 % 10 + v17 % 100 + v17 % 1000 + v17 % 10000, v6);
      if ( !v7 )
      {
        V_LOCK();
        sub_32250((int)v15, *(int *)a4);
        logfmt_raw(
          v12,
          0x1000u,
          0,
          v16,
          v15[0],
          v15[1],
          v15[2],
          v15[3],
          v15[4],
          v15[5],
          v15[6],
          v16,
          "reject reason:: NULL");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/pool.c",
          144,
          "share_result",
          12,
          583,
          80,
          v12);
      }
    }
  }
  return 1;
}
// 34304: variable 'v5' is possibly undefined
// 344B0: variable 'v7' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1518F0: using guessed type pthread_mutex_t stru_1518F0;
// 1608F0: using guessed type int g_zc;
// 160998: using guessed type double total_diff_accepted;
// 1609A8: using guessed type double total_diff_rejected;
// 1609C0: using guessed type double total_accepted;
// 1609E0: using guessed type double total_rejected;

//----- (0003457C) --------------------------------------------------------
int __fastcall update_pool_diff1_of_all_runtimes(int a1)
{
  __int64 v1; // r0
  int v4; // [sp+Ch] [bp-20h] BYREF
  _DWORD *all_created_runtime; // [sp+10h] [bp-1Ch]
  int i; // [sp+14h] [bp-18h]
  double v7; // [sp+18h] [bp-14h]

  v4 = 0;
  all_created_runtime = get_all_created_runtime(&v4);
  v7 = 0.0;
  for ( i = 0; i < v4; ++i )
    *(_QWORD *)&v7 += *(_QWORD *)(all_created_runtime[i] + 8 * (*(_DWORD *)a1 + 71));
  *(_QWORD *)&total_diff1 += *(_QWORD *)&v7 - *(_QWORD *)&dbl_152228[*(_DWORD *)a1];
  v1 = *(_QWORD *)(a1 + 1992);
  *(_QWORD *)(a1 + 1992) = *(_QWORD *)&v7 - *(_QWORD *)&dbl_152228[*(_DWORD *)a1] + v1;
  dbl_152228[*(_DWORD *)a1] = v7;
  return v1;
}
// 152228: using guessed type double dbl_152228[32];
// 1609E8: using guessed type double total_diff1;

//----- (000346DC) --------------------------------------------------------
int create_pool_stratum_threads()
{
  char v2[24]; // [sp+14h] [bp-1018h] BYREF
  _DWORD *v4; // [sp+1018h] [bp-14h]
  int v5; // [sp+101Ch] [bp-10h]
  int v6; // [sp+1020h] [bp-Ch]
  int i; // [sp+1024h] [bp-8h]

  v6 = 0;
  byte_152220 = 1;
  set_current_pool(*(_DWORD *)pools);
  for ( i = 0; i < total_pools; ++i )
  {
    v5 = *(_DWORD *)(pools + 4 * i);
    if ( *(_BYTE *)(v5 + 28) )
    {
      v4 = (_DWORD *)((char *)&stratum_thr_info + 48 * i);
      *v4 = i + 4;
      v4[11] = tq_new();
      if ( !v4[11] )
        return -1;
      tq_push(v4[11], v5);
      if ( sub_32284((int)v4, (void *(*)(void *))stratum_thread) )
      {
        V_LOCK();
        logfmt_raw(v2, 0x1000u, 0, "stratum thread create failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/pool.c",
          144,
          "create_pool_stratum_threads",
          27,
          628,
          100,
          v2);
        return -1;
      }
    }
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 152220: using guessed type char byte_152220;
// 1608F0: using guessed type int g_zc;

//----- (00034890) --------------------------------------------------------
int check_pools_valid()
{
  int v1; // [sp+0h] [bp-Ch]
  int i; // [sp+4h] [bp-8h]

  pools_active = 0;
  update_miner_working_status();
  v1 = 0;
  for ( i = 0; i < total_pools; ++i )
  {
    if ( *(_BYTE *)(*(_DWORD *)(pools + 4 * i) + 28) && stratum_check(*(int **)(pools + 4 * i)) )
      ++v1;
  }
  if ( v1 )
  {
    set_miner_6060info_network_lost_err(0);
    red_led_off();
  }
  else
  {
    set_miner_6060info_network_lost_err(1);
    red_led_on();
  }
  return v1;
}
// 151898: using guessed type char pools_active;
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;

//----- (00034984) --------------------------------------------------------
int custom_param_check()
{
  char v1[4]; // [sp+10h] [bp-1004h] BYREF

  if ( opt_algo == 12 || opt_algo == 8 )
  {
    if ( fan_pwm_fixed )
    {
      fan_pwm_fixed = 0;
      V_LOCK();
      logfmt_raw(
        v1,
        0x1000u,
        0,
        "fan_pwm_ctrl is not allowed. upgrade firmware without selecting \"Keep the Same Settings\" may resolve this warning");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "custom_param_check",
        18,
        678,
        40,
        v1);
    }
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D664: using guessed type int opt_algo;
// 152420: using guessed type char fan_pwm_fixed;
// 1608F0: using guessed type int g_zc;

//----- (00034A5C) --------------------------------------------------------
int __fastcall judge_load_config(const char *a1)
{
  char *v2; // r4
  const char *v3; // r0
  char *v4; // r4
  const char *v5; // r0
  char *v6; // r4
  const char *v7; // r0
  size_t v8; // r0
  const char *v9; // r0
  char v12[40]; // [sp+1Ch] [bp-1128h] BYREF
  _BYTE v13[92]; // [sp+101Ch] [bp-128h] BYREF
  int v14; // [sp+1078h] [bp-CCh] BYREF
  int v15; // [sp+1118h] [bp-2Ch]
  bool v16; // [sp+111Fh] [bp-25h]
  int v17; // [sp+1120h] [bp-24h]
  const json_t *v18; // [sp+1124h] [bp-20h]
  const json_t *v19; // [sp+1128h] [bp-1Ch]
  const json_t *v20; // [sp+112Ch] [bp-18h]
  const json_t *file; // [sp+1130h] [bp-14h]
  signed int i; // [sp+1134h] [bp-10h]

  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "start %s", "judge_load_config");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/pool.c",
    144,
    "judge_load_config",
    17,
    686,
    20,
    v12);
  v17 = 0;
  file = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  i = 0;
  if ( a1 )
  {
    file = json_load_file(a1, 0, (json_error_t *)v13);
    if ( file && !*(_DWORD *)file )
    {
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "%s: after json_load_file", "judge_load_config");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "judge_load_config",
        17,
        704,
        20,
        v12);
      v18 = json_object_get(file, "pools");
      if ( v18 && *(_DWORD *)v18 == 1 )
      {
        dword_152218 = json_array_size(v18);
        for ( i = 0; ; ++i )
        {
          v8 = json_array_size(v18);
          if ( v8 <= i )
            break;
          v19 = json_array_get(v18, i);
          if ( !v19 )
            break;
          if ( *(_DWORD *)v19 )
            break;
          if ( i > 2 )
            break;
          v20 = json_object_get(v19, "url");
          if ( !v20 )
            break;
          if ( *(_DWORD *)v20 != 2 )
            break;
          v2 = &byte_151918[768 * i];
          v3 = json_string_value(v20);
          snprintf(v2, 0x100u, "%s", v3);
          v20 = json_object_get(v19, "user");
          if ( !v20 )
            break;
          if ( *(_DWORD *)v20 != 2 )
            break;
          v4 = &byte_151918[768 * i + 256];
          v5 = json_string_value(v20);
          snprintf(v4, 0x100u, "%s", v5);
          v20 = json_object_get(v19, "pass");
          if ( !v20 || *(_DWORD *)v20 != 2 )
            break;
          v6 = &byte_151918[768 * i + 512];
          v7 = json_string_value(v20);
          snprintf(v6, 0x100u, "%s", v7);
          V_LOCK();
          logfmt_raw(
            v12,
            0x1000u,
            0,
            "%s %s %s",
            &byte_151918[768 * i],
            &byte_151918[768 * i + 256],
            &byte_151918[768 * i + 512]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/pool.c",
            144,
            "judge_load_config",
            17,
            728,
            20,
            v12);
        }
        v17 &= ~1u;
        if ( total_pools == dword_152218 )
        {
          for ( i = 0; i < total_pools; ++i )
          {
            if ( strcmp(*(const char **)(*(_DWORD *)(pools + 4 * i) + 12), &byte_151918[768 * i])
              || strcmp(*(const char **)(*(_DWORD *)(pools + 4 * i) + 16), &byte_151918[768 * i + 256])
              || strcmp(*(const char **)(*(_DWORD *)(pools + 4 * i) + 20), &byte_151918[768 * i + 512]) )
            {
              v17 |= 1u;
              break;
            }
          }
        }
        else
        {
          v17 |= 1u;
        }
      }
      else
      {
        v17 &= ~1u;
      }
      v20 = json_object_get(file, "bitmain-freq-level");
      if ( !v20 || *(_DWORD *)v20 != 2 )
        v17 &= ~2u;
      v20 = json_object_get(file, "bitmain-fan-ctrl");
      if ( v20 && *(_DWORD *)v20 == 5 || v20 && *(_DWORD *)v20 == 6 )
      {
        v16 = *(_DWORD *)v20 == 5;
        if ( v16 == fan_pwm_fixed )
        {
          v17 &= ~4u;
        }
        else
        {
          v17 |= 4u;
          fan_pwm_fixed = v16;
        }
      }
      else
      {
        v17 &= ~4u;
      }
      v20 = json_object_get(file, "bitmain-fan-pwm");
      if ( v20 && *(_DWORD *)v20 == 2 )
      {
        v9 = json_string_value(v20);
        v15 = atoi(v9);
        if ( v15 == fan_pwm )
        {
          v17 &= ~8u;
        }
        else
        {
          v17 |= 8u;
          fan_pwm = v15;
        }
      }
      else
      {
        v17 &= ~8u;
      }
      sub_321E8((int)file);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "ret = 0x%x", v17);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "judge_load_config",
        17,
        787,
        20,
        v12);
      custom_param_check();
      return v17;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "%s: JSON decode of file '%s' failed %s", "judge_load_config", a1, &v14);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "judge_load_config",
        17,
        701,
        100,
        v12);
      return v17;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "%s: bad param", "judge_load_config");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/pool.c",
      144,
      "judge_load_config",
      17,
      695,
      100,
      v12);
    return v17;
  }
}
// 35238: masking with 0x1 was optimized away because r3.1 <= 0x1
// 3520C: conditional instruction was optimized away because %var_10.4!=0
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14F19C: using guessed type int fan_pwm;
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 152218: using guessed type int dword_152218;
// 152420: using guessed type char fan_pwm_fixed;
// 1608F0: using guessed type int g_zc;

//----- (000353B4) --------------------------------------------------------
int *__fastcall sub_353B4(int *result)
{
  int v1; // [sp+Ch] [bp-10h]
  int v2; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]
  int j; // [sp+14h] [bp-8h]

  v2 = total_pools - 1;
  for ( i = 0; i < total_pools; ++i )
  {
    v1 = *(_DWORD *)(pools + 4 * i);
    if ( *(_DWORD *)(v1 + 4) > result[1] )
      --*(_DWORD *)(v1 + 4);
  }
  if ( v2 > *result )
  {
    for ( j = *result; j < v2; ++j )
    {
      *(_DWORD *)(pools + 4 * j) = *(_DWORD *)(pools + 4 * (j + 1));
      **(_DWORD **)(pools + 4 * j) = j;
    }
  }
  *result = total_pools--;
  return result;
}
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;

//----- (00035534) --------------------------------------------------------
int *sub_35534()
{
  pthread_t v0; // r0
  char v2[4224]; // [sp+1Ch] [bp-10B0h] BYREF
  _DWORD *v3; // [sp+109Ch] [bp-30h]
  _DWORD *v5; // [sp+10A4h] [bp-28h]
  unsigned __int8 *v6; // [sp+10A8h] [bp-24h]
  _DWORD *v7; // [sp+10ACh] [bp-20h]
  _DWORD *v8; // [sp+10B0h] [bp-1Ch]
  int v9; // [sp+10B4h] [bp-18h]
  int v10; // [sp+10B8h] [bp-14h]
  int *v11; // [sp+10BCh] [bp-10h]
  char v12; // [sp+10C3h] [bp-9h]
  int i; // [sp+10C4h] [bp-8h]

  v12 = 0;
  v9 = 0;
  v10 = total_pools;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "pool_change_function");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/pool.c",
    144,
    "pool_change_function",
    20,
    826,
    20,
    v2);
  v0 = pthread_self();
  pthread_detach(v0);
  v11 = &dword_161060;
  if ( dword_161064 )
  {
    pthread_cancel(v11[1]);
    v11[1] = 0;
    usleep((__useconds_t)"time");
    v12 = 1;
  }
  for ( i = 0; i < v10; ++i )
  {
    v3 = *(_DWORD **)(pools + 4 * i);
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "before add pool, pool->pool_no = %d, pool->rpc_url = %s", *v3, v3[3]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/pool.c",
      144,
      "pool_change_function",
      20,
      842,
      20,
      v2);
  }
  for ( i = 0; i < dword_152218; ++i )
  {
    set_url(&byte_151918[768 * i]);
    set_user(&byte_151918[768 * i + 256]);
    set_pass(&byte_151918[768 * i + 512]);
  }
  if ( v10 == total_pools )
  {
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "Input pool error, try again");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/pool.c",
      144,
      "pool_change_function",
      20,
      852,
      100,
      v2);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "total_pools = %d, need to remove %d pools", total_pools, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/pool.c",
      144,
      "pool_change_function",
      20,
      856,
      20,
      v2);
    for ( i = 0; i < total_pools; ++i )
    {
      v5 = *(_DWORD **)(pools + 4 * i);
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "after add pool, pool->pool_no = %d, pool->rpc_url = %s", *v5, v5[3]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "pool_change_function",
        20,
        859,
        20,
        v2);
    }
    for ( i = 0; i < v10; ++i )
    {
      v6 = *(unsigned __int8 **)pools;
      v11 = (int *)((char *)&stratum_thr_info + 48 * i);
      if ( v11[1] )
      {
        pthread_cancel(v11[1]);
        v11[1] = 0;
      }
      if ( v11[11] )
      {
        tq_free((char *)v11[11]);
        v11[11] = 0;
      }
      pool_tclear((int)v6, v6 + 1916, 0);
      pool_tset((int)v6, v6 + 1904, 0);
      --dword_151910;
      --dword_15190C;
      --dword_151908;
      sub_353B4((int *)v6);
      *(_DWORD *)&v2[4 * i + 4096] = v6;
    }
    sub_33A40();
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "total_pools after removed = %d", total_pools);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/pool.c",
      144,
      "pool_change_function",
      20,
      884,
      20,
      v2);
    for ( i = 0; i < total_pools; ++i )
    {
      v7 = *(_DWORD **)(pools + 4 * i);
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "after reload pool, pool->pool_no = %d, pool->rpc_url = %s", *v7, v7[3]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "pool_change_function",
        20,
        887,
        20,
        v2);
    }
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "reload new pool configuration, check pool connect");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/pool.c",
      144,
      "pool_change_function",
      20,
      890,
      40,
      v2);
    sleep(5u);
    if ( byte_152220 )
    {
      create_pool_stratum_threads();
    }
    else if ( check_pools_valid() <= 0 )
    {
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "no new pools could be valid");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "pool_change_function",
        20,
        901,
        40,
        v2);
    }
    do
    {
      sleep(1u);
      ++v9;
    }
    while ( pools_active != 1 && v9 <= 7 );
    set_miner_start_time();
    api_flush();
    if ( pools_active != 1 )
    {
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "error pool input");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "pool_change_function",
        20,
        915,
        100,
        v2);
      for ( i = 0; i < total_pools; ++i )
      {
        v8 = *(_DWORD **)(pools + 4 * i);
        V_LOCK();
        logfmt_raw(v2, 0x1000u, 0, "pool%d, url = %s, user = %s, pass = %s", *v8, v8[3], v8[4], v8[5]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/pool.c",
          144,
          "pool_change_function",
          20,
          918,
          100,
          v2);
      }
    }
  }
  if ( v12 )
  {
    v11 = &dword_161060;
    dword_161060 = 2;
    if ( sub_32284((int)&dword_161060, (void *(*)(void *))watchpool_thread) )
    {
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "watchpool thread create failed!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/pool.c",
        144,
        "pool_change_function",
        20,
        928,
        100,
        v2);
      exit(1);
    }
  }
  for ( i = 0; i < v10; ++i )
  {
    if ( *(_DWORD *)&v2[4 * i + 4096] )
      pool_tset(*(_DWORD *)&v2[4 * i + 4096], (unsigned __int8 *)(*(_DWORD *)&v2[4 * i + 4096] + 1904), 1);
  }
  sleep(0xAu);
  for ( i = 0; i < v10; ++i )
  {
    pool_tset(*(_DWORD *)&v2[4 * i + 4096], (unsigned __int8 *)(*(_DWORD *)&v2[4 * i + 4096] + 1904), 1);
    if ( *(_DWORD *)&v2[4 * i + 4096] )
      free(*(void **)&v2[4 * i + 4096]);
  }
  dword_15221C = 0;
  return &dword_15221C;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151898: using guessed type char pools_active;
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 151908: using guessed type int dword_151908;
// 15190C: using guessed type int dword_15190C;
// 151910: using guessed type int dword_151910;
// 152218: using guessed type int dword_152218;
// 15221C: using guessed type int dword_15221C;
// 152220: using guessed type char byte_152220;
// 1608F0: using guessed type int g_zc;
// 161060: using guessed type int dword_161060;
// 161064: using guessed type int dword_161064;

//----- (0003613C) --------------------------------------------------------
int reload_pool()
{
  int result; // r0
  char v1[4]; // [sp+10h] [bp-1004h] BYREF

  if ( dword_15221C )
  {
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, "config too fast, pool is changing, please wait");
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/pool.c",
             144,
             "reload_pool",
             11,
             956,
             100,
             v1);
  }
  else
  {
    result = pthread_create((pthread_t *)&dword_15221C, 0, (void *(*)(void *))sub_35534, 0);
    if ( result )
    {
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, "Failed to create pool_change_thread");
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/pool.c",
               144,
               "reload_pool",
               11,
               954,
               100,
               v1);
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15221C: using guessed type int dword_15221C;
// 1608F0: using guessed type int g_zc;

//----- (00036270) --------------------------------------------------------
int sock_blocks()
{
  return *_errno_location() == 11 || *_errno_location() == 11;
}

//----- (000362BC) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_362BC(int a1, __int64 a2)
{
  V_INT(a1, "poolno", a2);
}

//----- (000362F0) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_362F0(int a1, const char *a2)
{
  V_STR(a1, "pool", a2);
}

//----- (00036328) --------------------------------------------------------
int __fastcall sub_36328(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 36394: variable 'v3' is possibly undefined

//----- (00036440) --------------------------------------------------------
int __fastcall sub_36440(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (000364B4) --------------------------------------------------------
int __fastcall sub_364B4(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/util.h",
    144,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000365D8) --------------------------------------------------------
_BYTE *__fastcall sub_365D8(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00036644) --------------------------------------------------------
char *__fastcall stratum_buffer_append(int a1, const char *a2)
{
  size_t v5; // [sp+8h] [bp-Ch]
  size_t v6; // [sp+Ch] [bp-8h]

  v6 = strlen(*(const char **)(a1 + 44));
  v5 = strlen(a2) + v6 + 1;
  if ( v5 >= *(_DWORD *)(a1 + 40) )
  {
    *(_DWORD *)(a1 + 40) = (v5 & 0xFFFFC000) + 0x4000;
    *(_DWORD *)(a1 + 44) = realloc(*(void **)(a1 + 44), *(_DWORD *)(a1 + 40));
  }
  return strcpy((char *)(*(_DWORD *)(a1 + 44) + v6), a2);
}

//----- (00036704) --------------------------------------------------------
int __fastcall stratum_send_line(pthread_mutex_t *a1, const char *a2)
{
  char v5[52]; // [sp+30h] [bp-1034h] BYREF
  _DWORD v6[7]; // [sp+1030h] [bp-34h] BYREF
  int v7; // [sp+104Ch] [bp-18h]
  unsigned __int8 v8; // [sp+1057h] [bp-Dh]

  v8 = 0;
  if ( opt_protocol )
  {
    V_LOCK();
    sub_362BC((int)v6, a1->__lock);
    logfmt_raw(v5, 0x1000u, 0, v7, v6[0], v6[1], v6[2], v6[3], v6[4], v6[5], v6[6], v7, "> %s", a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_send_line",
      17,
      31,
      60,
      v5);
  }
  pthread_mutex_lock(a1 + 2);
  v8 = send_line(a1[1].__kind, a2);
  pthread_mutex_unlock(a1 + 2);
  return v8;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512C1: using guessed type char opt_protocol;
// 1608F0: using guessed type int g_zc;

//----- (0003687C) --------------------------------------------------------
char *__fastcall stratum_recv_line(pthread_mutex_t *a1)
{
  int *v1; // r0
  int *v2; // r0
  char v5[104]; // [sp+34h] [bp-5068h] BYREF
  char v6[16384]; // [sp+1034h] [bp-4068h] BYREF
  time_t timer; // [sp+5034h] [bp-68h] BYREF
  _DWORD v8[7]; // [sp+5038h] [bp-64h] BYREF
  int v9; // [sp+5054h] [bp-48h]
  _DWORD v10[7]; // [sp+5058h] [bp-44h] BYREF
  int v11; // [sp+5074h] [bp-28h]
  size_t v12; // [sp+5078h] [bp-24h]
  char *s; // [sp+507Ch] [bp-20h]
  signed int v14; // [sp+5080h] [bp-1Ch]
  char *v15; // [sp+5084h] [bp-18h]
  ssize_t v16; // [sp+5088h] [bp-14h]
  char v17; // [sp+508Fh] [bp-Dh]

  v15 = 0;
  pthread_mutex_lock(a1 + 2);
  if ( strchr((const char *)a1[1].__spins, 10) || a1[1].__kind == -1 )
    goto LABEL_15;
  v17 = 1;
  time(&timer);
  while ( 1 )
  {
    memset(v6, 0, sizeof(v6));
    v16 = recv(a1[1].__kind, v6, 0x3FFCu, 0);
    if ( !v16 )
    {
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "stratum_recv_line read 0 bytes");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/stratum_handler.c",
        155,
        "stratum_recv_line",
        17,
        58,
        20,
        v5);
      v17 = 0;
      goto LABEL_13;
    }
    if ( v16 < 0 )
      break;
    stratum_buffer_append((int)a1, v6);
LABEL_11:
    if ( time(0) - timer > 59 || strchr((const char *)a1[1].__spins, 10) )
      goto LABEL_13;
  }
  V_LOCK();
  v1 = _errno_location();
  logfmt_raw(v5, 0x1000u, 0, "stratum_recv_line recv failed err %zd %d", v16, *v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/stratum_handler.c",
    155,
    "stratum_recv_line",
    17,
    63,
    20,
    v5);
  if ( (unsigned __int8)sock_blocks() == 1 && (unsigned __int8)socket_full(a1[1].__kind, 1) == 1 )
    goto LABEL_11;
  V_LOCK();
  v2 = _errno_location();
  logfmt_raw(v5, 0x1000u, 0, "stratum_recv_line recv failed detailed error %d", *v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/stratum_handler.c",
    155,
    "stratum_recv_line",
    17,
    65,
    20,
    v5);
  v17 = 0;
LABEL_13:
  if ( v17 != 1 )
  {
    V_LOCK();
    sub_362BC((int)v8, a1->__lock);
    logfmt_raw(v6, 0x1000u, 0, v9, v8[0], v8[1], v8[2], v8[3], v8[4], v8[5], v8[6], v9, "stratum_recv_line failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_recv_line",
      17,
      74,
      20,
      v6);
    goto LABEL_20;
  }
LABEL_15:
  v14 = strlen((const char *)a1[1].__spins);
  s = strtok((char *)a1[1].__spins, "\n");
  if ( s )
  {
    v15 = strdup(s);
    v12 = strlen(v15);
    if ( v14 <= (int)(v12 + 1) )
      *(_BYTE *)a1[1].__spins = 0;
    else
      memmove(a1[1].__list.__next, (const void *)(a1[1].__spins + v12 + 1), v14 - v12 + 1);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "stratum_recv_line failed to parse a newline-terminated string");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_recv_line",
      17,
      82,
      100,
      v6);
  }
LABEL_20:
  pthread_mutex_unlock(a1 + 2);
  if ( v15 && opt_protocol )
  {
    V_LOCK();
    sub_362BC((int)v10, a1->__lock);
    logfmt_raw(v6, 0x1000u, 0, v11, v10[0], v10[1], v10[2], v10[3], v10[4], v10[5], v10[6], v11, "< %s", v15);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_recv_line",
      17,
      97,
      60,
      v6);
  }
  return v15;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512C1: using guessed type char opt_protocol;
// 1608F0: using guessed type int g_zc;

//----- (00036EEC) --------------------------------------------------------
int __fastcall stratum_socket_full(int a1, __time_t a2)
{
  size_t v2; // r0
  char v7[4]; // [sp+18h] [bp-1004h] BYREF

  V_LOCK();
  v2 = strlen(*(const char **)(a1 + 44));
  logfmt_raw(v7, 0x1000u, 0, "stratum_socket_full sockbuf len %zu", v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/stratum_handler.c",
    155,
    "stratum_socket_full",
    19,
    104,
    20,
    v7);
  return **(_BYTE **)(a1 + 44) || socket_full(*(_DWORD *)(a1 + 36), a2);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0003700C) --------------------------------------------------------
int __fastcall stratum_connect(int a1)
{
  int *v1; // r0
  char *v2; // r0
  int *v3; // r0
  char *v4; // r0
  char v7[20]; // [sp+30h] [bp-1154h] BYREF
  int optval; // [sp+1030h] [bp-154h] BYREF
  uint16_t v9; // [sp+1036h] [bp-14Eh] BYREF
  char cp[256]; // [sp+1038h] [bp-14Ch] BYREF
  struct sockaddr addr; // [sp+1138h] [bp-4Ch] BYREF
  _DWORD v12[7]; // [sp+1148h] [bp-3Ch] BYREF
  int v13; // [sp+1164h] [bp-20h]
  int v14; // [sp+1168h] [bp-1Ch]
  char **h_addr_list; // [sp+116Ch] [bp-18h]
  struct hostent *v16; // [sp+1170h] [bp-14h]
  unsigned __int8 v17; // [sp+1177h] [bp-Dh]

  v17 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  if ( !strncasecmp(*(const char **)(a1 + 32), "stratum+tcp://", 0xEu)
    && (unsigned __int8)get_server_port_from_url((const char *)(*(_DWORD *)(a1 + 32) + 14), cp, &v9) == 1 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "url: %s, server: %s, port: %d", *(_DWORD *)(a1 + 32), cp, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_connect",
      15,
      120,
      20,
      v7);
    if ( !*(_DWORD *)(a1 + 44) )
    {
      *(_DWORD *)(a1 + 44) = calloc(0x4000u, 1u);
      *(_DWORD *)(a1 + 40) = 0x4000;
    }
    **(_BYTE **)(a1 + 44) = 0;
    if ( *(_DWORD *)(a1 + 36) == -1 )
    {
      *(_DWORD *)(a1 + 36) = socket(2, 1, 6);
      if ( *(_DWORD *)(a1 + 36) == -1 )
      {
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "stratum socket creat failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/stratum_handler.c",
          155,
          "stratum_connect",
          15,
          135,
          100,
          v7);
        goto LABEL_24;
      }
      optval = 1;
      if ( setsockopt(*(_DWORD *)(a1 + 36), 1, 2, &optval, 4u) )
      {
        V_LOCK();
        v1 = _errno_location();
        v2 = strerror(*v1);
        logfmt_raw(v7, 0x1000u, 0, "API setsockopt SO_REUSEADDR failed (ignored): %s", v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/stratum_handler.c",
          155,
          "stratum_connect",
          15,
          145,
          100,
          v7);
      }
    }
    if ( inet_addr(cp) == -1 )
    {
      if ( _res_init() < 0 )
      {
        close(*(_DWORD *)(a1 + 36));
        *(_DWORD *)(a1 + 36) = -1;
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "poolno %d res_init error", *(_DWORD *)a1);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/stratum_handler.c",
          155,
          "stratum_connect",
          15,
          160,
          100,
          v7);
        goto LABEL_24;
      }
      v16 = gethostbyname(cp);
      if ( !v16 )
      {
        close(*(_DWORD *)(a1 + 36));
        *(_DWORD *)(a1 + 36) = -1;
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "ip address config error");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/stratum_handler.c",
          155,
          "stratum_connect",
          15,
          169,
          20,
          v7);
        goto LABEL_24;
      }
      h_addr_list = v16->h_addr_list;
      v14 = 0;
      if ( *h_addr_list )
        *(_DWORD *)&addr.sa_data[2] = *(_DWORD *)h_addr_list[v14];
    }
    else
    {
      *(_DWORD *)&addr.sa_data[2] = inet_addr(cp);
    }
    addr.sa_family = 2;
    *(_WORD *)addr.sa_data = htons(v9);
    if ( connect(*(_DWORD *)(a1 + 36), &addr, 0x10u) >= 0 )
    {
      keep_sockalive(*(_DWORD *)(a1 + 36));
      v17 = 1;
    }
    else
    {
      if ( dword_152328 <= 3 )
      {
        V_LOCK();
        v3 = _errno_location();
        v4 = strerror(*v3);
        logfmt_raw(v7, 0x1000u, 0, "Error connecting to server, error code: %s", v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/stratum_handler.c",
          155,
          "stratum_connect",
          15,
          197,
          100,
          v7);
      }
      close(*(_DWORD *)(a1 + 36));
      *(_DWORD *)(a1 + 36) = -1;
    }
  }
  else
  {
    V_LOCK();
    sub_362F0((int)v12, *(const char **)(a1 + 32));
    logfmt_raw(v7, 0x1000u, 0, v13, v12[0], v12[1], v12[2], v12[3], v12[4], v12[5], v12[6], v13, "prase url err!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_connect",
      15,
      117,
      100,
      v7);
  }
LABEL_24:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 48));
  return v17;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152328: using guessed type int dword_152328;
// 1608F0: using guessed type int g_zc;

//----- (0003778C) --------------------------------------------------------
int __fastcall stratum_disconnect(pthread_mutex_t *a1)
{
  char v3[44]; // [sp+30h] [bp-102Ch] BYREF
  _DWORD v4[7]; // [sp+1030h] [bp-2Ch] BYREF
  int v5; // [sp+104Ch] [bp-10h]

  pthread_mutex_lock(a1 + 2);
  if ( a1[1].__kind != -1 )
  {
    shutdown(a1[1].__kind, 2);
    close(a1[1].__kind);
    a1[1].__kind = -1;
    *(_BYTE *)a1[1].__spins = 0;
    V_LOCK();
    sub_362BC((int)v4, a1->__lock);
    logfmt_raw(v3, 0x1000u, 0, v5, v4[0], v4[1], v4[2], v4[3], v4[4], v4[5], v4[6], v5, "pool disconnect");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_disconnect",
      18,
      227,
      20,
      v3);
  }
  return pthread_mutex_unlock(a1 + 2);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00037914) --------------------------------------------------------
int __fastcall stratum_thread(int a1)
{
  pthread_t v1; // r0
  int v2; // r0
  char *v3; // r0
  __int64 v4; // r0
  int v5; // r4
  int v6; // r5
  _DWORD *current_pool; // r0
  __int64 v8; // r0
  char v10[60]; // [sp+38h] [bp-10BCh] BYREF
  _DWORD v11[7]; // [sp+1038h] [bp-BCh] BYREF
  int v12; // [sp+1054h] [bp-A0h]
  _DWORD v13[7]; // [sp+1058h] [bp-9Ch] BYREF
  int v14; // [sp+1074h] [bp-80h]
  _DWORD v15[7]; // [sp+1078h] [bp-7Ch] BYREF
  int v16; // [sp+1094h] [bp-60h]
  _DWORD v17[7]; // [sp+1098h] [bp-5Ch] BYREF
  int v18; // [sp+10B4h] [bp-40h]
  void *ptr; // [sp+10BCh] [bp-38h]
  double v20; // [sp+10C0h] [bp-34h]
  int v21; // [sp+10CCh] [bp-28h]
  unsigned int seconds; // [sp+10D0h] [bp-24h]
  char v23; // [sp+10D7h] [bp-1Dh]
  int v24; // [sp+10D8h] [bp-1Ch]
  __time_t v25; // [sp+10DCh] [bp-18h]
  unsigned __int8 *v26; // [sp+10E0h] [bp-14h]
  char *s; // [sp+10E4h] [bp-10h]

  v21 = a1;
  v24 = frontend_runtime_instance();
  v23 = 1;
  v25 = 0;
  seconds = 30;
  v1 = pthread_self();
  pthread_detach(v1);
  v25 = *(_DWORD *)(*(_DWORD *)(v24 + 72) + 20);
  v26 = (unsigned __int8 *)tq_pop(*(_DWORD *)(v21 + 44), 0);
  if ( v26 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "stratum_thread pool %s", *((_DWORD *)v26 + 3));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_thread",
      14,
      249,
      20,
      v10);
    s = (char *)calloc(1u, 0x40u);
    snprintf(s, 0x40u, "%.10s_%d", "stratum_thread", *(_DWORD *)v26);
    V_LOCK();
    v2 = syscall(224);
    logfmt_raw(v10, 0x1000u, 0, "%s on pid %ld", s, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_thread",
      14,
      251,
      40,
      v10);
    prctl(15, s);
    v3 = strdup(*((const char **)v26 + 3));
    *((_DWORD *)v26 + 8) = v3;
    if ( *((_DWORD *)v26 + 8) )
    {
      pool_tset((int)v26, v26 + 1904, 0);
      pool_tclear((int)v26, v26 + 1916, 0);
      dword_152328 = 0;
      while ( 1 )
      {
        v20 = 0.0;
        while ( *((_DWORD *)v26 + 9) == -1 )
        {
          if ( (*(unsigned __int8 (__fastcall **)(unsigned __int8 *))v24)(v26) != 1
            || (*(unsigned __int8 (__fastcall **)(int, unsigned __int8 *))(v24 + 16))(v24, v26) != 1 )
          {
            (*(void (__fastcall **)(unsigned __int8 *))(v24 + 4))(v26);
            pool_tclear((int)v26, v26 + 1916, 0);
            pool_died((int *)v26);
            v4 = (*(_QWORD *)&v20)++;
            if ( !(v4 % 50) )
            {
              V_LOCK();
              sub_362BC((int)v11, *(int *)v26);
              logfmt_raw(
                v10,
                0x1000u,
                0,
                v12,
                v11[0],
                v11[1],
                v11[2],
                v11[3],
                v11[4],
                v11[5],
                v11[6],
                v12,
                "...retry after %d seconds failures %d",
                seconds,
                v20);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/stratum_handler.c",
                155,
                "stratum_thread",
                14,
                284,
                100,
                v10);
            }
            sleep(seconds);
          }
          else
          {
            V_LOCK();
            v5 = *(_DWORD *)v26;
            v6 = *((_DWORD *)v26 + 8);
            current_pool = (_DWORD *)get_current_pool();
            logfmt_raw(v10, 0x1000u, 0, "pool %d is active, pool url %s, current_pool %d", v5, v6, *current_pool);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/stratum_handler.c",
              155,
              "stratum_thread",
              14,
              290,
              20,
              v10);
            pool_alive((int)v26);
            if ( v23 )
            {
              v23 = 0;
              switch_pools();
            }
          }
        }
        wait_pool_to_be_current_timeout((int)v26);
        if ( (unsigned __int8)stratum_socket_full((int)v26, v25) != 1 )
        {
          V_LOCK();
          sub_362BC((int)v13, *(int *)v26);
          logfmt_raw(
            v10,
            0x1000u,
            0,
            v14,
            v13[0],
            v13[1],
            v13[2],
            v13[3],
            v13[4],
            v13[5],
            v13[6],
            v14,
            "stratum connection timeout");
          V_UNLOCK();
          v8 = zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/buil"
                 "d/godminer-origin_godminer-branch1/stratum_handler.c",
                 155,
                 "stratum_thread",
                 14,
                 304,
                 100,
                 v10);
          ptr = 0;
        }
        else
        {
          ptr = (void *)(*(int (__fastcall **)(unsigned __int8 *))(v24 + 8))(v26);
        }
        if ( ptr )
        {
          if ( !(*(int (__fastcall **)(int, unsigned __int8 *, void *))(v24 + 20))(v24, v26, ptr) )
            (*(void (__fastcall **)(int, void *, unsigned __int8 *))(v24 + 28))(v24, ptr, v26);
          free(ptr);
          pools_active = 1;
        }
        else
        {
          ++total_go;
          ++*((_DWORD *)v26 + 487);
          pools_active = 0;
          (*(void (__fastcall **)(unsigned __int8 *, _DWORD))(v24 + 4))(v26, HIDWORD(v8));
          pool_tclear((int)v26, v26 + 1916, 0);
          pool_died((int *)v26);
          V_LOCK();
          sub_362BC((int)v15, *(int *)v26);
          logfmt_raw(
            v10,
            0x1000u,
            0,
            v16,
            v15[0],
            v15[1],
            v15[2],
            v15[3],
            v15[4],
            v15[5],
            v15[6],
            v16,
            "stratum connection interrupted");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/stratum_handler.c",
            155,
            "stratum_thread",
            14,
            332,
            20,
            v10);
          sleep(seconds);
        }
      }
    }
  }
  V_LOCK();
  sub_362BC((int)v17, *(int *)v26);
  logfmt_raw(v10, 0x1000u, 0, v18, v17[0], v17[1], v17[2], v17[3], v17[4], v17[5], v17[6], v18, "stratum thread out");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/stratum_handler.c",
    155,
    "stratum_thread",
    14,
    339,
    60,
    v10);
  return 0;
}
// 37F64: variable 'v8' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151898: using guessed type char pools_active;
// 152328: using guessed type int dword_152328;
// 1608F0: using guessed type int g_zc;
// 1609B8: using guessed type int total_go;

//----- (00038118) --------------------------------------------------------
int __fastcall stratum_check(int *a1)
{
  __int64 v1; // r0
  char v5[32]; // [sp+34h] [bp-1060h] BYREF
  _BYTE v6[4]; // [sp+1034h] [bp-60h] BYREF
  _DWORD v7[7]; // [sp+1038h] [bp-5Ch] BYREF
  int v8; // [sp+1054h] [bp-40h]
  _DWORD v9[7]; // [sp+1058h] [bp-3Ch] BYREF
  int v10; // [sp+1074h] [bp-20h]
  int v11; // [sp+1078h] [bp-1Ch]
  unsigned int seconds; // [sp+107Ch] [bp-18h]
  __time_t v13; // [sp+1080h] [bp-14h]
  void *ptr; // [sp+1084h] [bp-10h]

  v11 = frontend_runtime_instance();
  seconds = 30;
  v13 = *(_DWORD *)(*(_DWORD *)(v11 + 72) + 20);
  if ( !a1 || !a1[3] || !a1[4] )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "stratum check, no pool %d, empty url or user", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_check",
      13,
      359,
      100,
      v5);
LABEL_20:
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Sweep error string = N%d:1", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_check",
      13,
      441,
      100,
      v5);
    return 0;
  }
  if ( a1[8] )
    free((void *)a1[8]);
  a1[8] = (int)strdup((const char *)a1[3]);
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "stratum check pool %d, pool url: %s", *a1, a1[3]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/stratum_handler.c",
    155,
    "stratum_check",
    13,
    367,
    40,
    v5);
  pool_tset((int)a1, (unsigned __int8 *)a1 + 1904, 0);
  pool_tclear((int)a1, (unsigned __int8 *)a1 + 1916, 0);
  pool_tclear((int)a1, (unsigned __int8 *)a1 + 8, 0);
  if ( (*(unsigned __int8 (__fastcall **)(int *))v11)(a1) != 1 )
  {
    (*(void (__fastcall **)(int *))(v11 + 4))(a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "stratum create tcp connection failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_check",
      13,
      376,
      100,
      v5);
    goto LABEL_20;
  }
  if ( (*(unsigned __int8 (__fastcall **)(int, int *))(v11 + 16))(v11, a1) != 1 )
  {
    (*(void (__fastcall **)(int *))(v11 + 4))(a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "stratum login failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_check",
      13,
      383,
      100,
      v5);
    goto LABEL_20;
  }
  while ( 1 )
  {
    wait_pool_to_be_current_timeout((int)a1);
    if ( (unsigned __int8)stratum_socket_full((int)a1, v13) != 1 )
    {
      V_LOCK();
      sub_362BC((int)v7, *a1);
      logfmt_raw(v5, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "stratum connection timeout");
      V_UNLOCK();
      v1 = zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/stratum_handler.c",
             155,
             "stratum_check",
             13,
             393,
             100,
             v5);
      ptr = 0;
    }
    else
    {
      ptr = (void *)(*(int (__fastcall **)(int *))(v11 + 8))(a1);
    }
    if ( ptr )
      break;
    ++total_go;
    ++a1[487];
    (*(void (__fastcall **)(int *, _DWORD))(v11 + 4))(a1, HIDWORD(v1));
    pool_tclear((int)a1, (unsigned __int8 *)a1 + 1916, 0);
    pool_died(a1);
    V_LOCK();
    sub_362BC((int)v9, *a1);
    logfmt_raw(
      v5,
      0x1000u,
      0,
      v10,
      v9[0],
      v9[1],
      v9[2],
      v9[3],
      v9[4],
      v9[5],
      v9[6],
      v10,
      "stratum connection interrupted");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_check",
      13,
      408,
      20,
      v5);
    sleep(seconds);
  }
  if ( !(*(int (__fastcall **)(int, int *, void *, _BYTE *))(v11 + 24))(v11, a1, ptr, v6)
    && !(*(int (__fastcall **)(int, void *, int *))(v11 + 28))(v11, ptr, a1) )
  {
    free(ptr);
    (*(void (__fastcall **)(int *))(v11 + 4))(a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "unsuitable pool configuration, notify from pool:%d dose not match the machine", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_check",
      13,
      426,
      100,
      v5);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Sweep error string = N%d:2.", *a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/stratum_handler.c",
      155,
      "stratum_check",
      13,
      427,
      100,
      v5);
    return 0;
  }
  free(ptr);
  pool_tset((int)a1, (unsigned __int8 *)a1 + 8, 0);
  pool_tclear((int)a1, (unsigned __int8 *)a1 + 1904, 0);
  pools_active = 1;
  update_miner_working_status();
  (*(void (__fastcall **)(int *))(v11 + 4))(a1);
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "pool %d is valid, url: \"%s\"", *a1, a1[3]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/stratum_handler.c",
    155,
    "stratum_check",
    13,
    437,
    40,
    v5);
  return 1;
}
// 3868C: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151898: using guessed type char pools_active;
// 1608F0: using guessed type int g_zc;
// 1609B8: using guessed type int total_go;

//----- (00038AF8) --------------------------------------------------------
void __cdecl _list_add(list_head *a1, list_head *prev, list_head *next)
{
  *((_DWORD *)next + 1) = a1;
  *(_DWORD *)a1 = next;
  *((_DWORD *)a1 + 1) = prev;
  *(_DWORD *)prev = a1;
}

//----- (00038B50) --------------------------------------------------------
void __cdecl list_add_tail(list_head *a1, list_head *head)
{
  _list_add(a1, *((list_head **)head + 1), head);
}

//----- (00038B88) --------------------------------------------------------
void __cdecl _list_del(list_head *prev, list_head *next)
{
  *((_DWORD *)next + 1) = prev;
  *(_DWORD *)prev = next;
}

//----- (00038BC4) --------------------------------------------------------
void __cdecl list_del(list_head *entry)
{
  _list_del(*((list_head **)entry + 1), *(list_head **)entry);
  *(_DWORD *)entry = 0;
  *((_DWORD *)entry + 1) = 0;
}

//----- (00038C14) --------------------------------------------------------
int __cdecl list_empty(list_head *head)
{
  return head == *(list_head **)head;
}

//----- (00038C50) --------------------------------------------------------
int __fastcall sub_38C50(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 38CBC: variable 'v3' is possibly undefined

//----- (00038D68) --------------------------------------------------------
int __fastcall sub_38D68(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (00038DDC) --------------------------------------------------------
int __fastcall sub_38DDC(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/util.h",
    144,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00038F00) --------------------------------------------------------
_BYTE *__fastcall sub_38F00(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00038F6C) --------------------------------------------------------
int __fastcall extract_byte_from_hex(const char *a1, int a2)
{
  char v5[16]; // [sp+1Ch] [bp-1010h] BYREF
  int v6; // [sp+101Ch] [bp-10h]
  int v7; // [sp+1020h] [bp-Ch]
  unsigned __int8 v8; // [sp+1026h] [bp-6h]
  unsigned __int8 v9; // [sp+1027h] [bp-5h]

  if ( (strlen(a1) & 1) != 0 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Provided hex %s is not valid!", a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/util.c",
      144,
      "extract_byte_from_hex",
      21,
      29,
      100,
      v5);
  }
  v8 = tolower((unsigned __int8)a1[a2]);
  v9 = tolower((unsigned __int8)a1[a2 + 1]);
  if ( (unsigned __int8)sub_38D68(v8) != 1 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Hex character %d is not valid!", v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/util.c",
      144,
      "extract_byte_from_hex",
      21,
      36,
      100,
      v5);
  }
  if ( (unsigned __int8)sub_38D68(v9) != 1 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Hex character %d is not valid!", v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/util.c",
      144,
      "extract_byte_from_hex",
      21,
      39,
      100,
      v5);
  }
  v7 = 16 * sub_38DDC(v8);
  v6 = sub_38DDC(v9);
  if ( v7 + v6 > 255 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "The provided hex %s at index %d is not a valid byte!", a1, a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/util.c",
      144,
      "extract_byte_from_hex",
      21,
      46,
      100,
      v5);
  }
  return (unsigned __int8)(v7 + v6);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000392C8) --------------------------------------------------------
int __fastcall format_hashrate_string(const char *a1, char *a2)
{
  double v2; // d0
  double v6; // [sp+18h] [bp-1014h]
  char v7[8]; // [sp+24h] [bp-1008h] BYREF
  unsigned __int8 v8; // [sp+1027h] [bp-5h]

  v6 = v2;
  v8 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "format hashrate string %f %s", v2, a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/util.c",
    144,
    "format_hashrate_string",
    22,
    56,
    20,
    v7);
  if ( v2 >= 10000.0 )
  {
    if ( v2 >= 10000000.0 )
    {
      if ( v2 >= 1.0e10 )
      {
        v8 = 71;
        v6 = v2 * 0.000000001;
      }
      else
      {
        v8 = 77;
        v6 = v2 * 0.000001;
      }
    }
    else
    {
      v8 = 75;
      v6 = v2 * 0.001;
    }
  }
  if ( v8 )
    return sprintf(a2, "%.2f %c%s/s", v6, v8, a1);
  else
    return sprintf(a2, "%.2f %s/s", v6, a1);
}
// 392E4: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000395D8) --------------------------------------------------------
int __fastcall format_hashrate_double(const char *a1, double *a2, char *a3)
{
  double v3; // d0
  char v8[20]; // [sp+28h] [bp-1014h] BYREF
  double v9; // [sp+1028h] [bp-14h]
  unsigned __int8 v10; // [sp+1037h] [bp-5h]

  v10 = 0;
  v9 = 0.0;
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "format hashrate double %f %s", v3, a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/util.c",
    144,
    "format_hashrate_double",
    22,
    91,
    20,
    v8);
  if ( v3 >= 10000.0 )
  {
    if ( v3 >= 10000000.0 )
    {
      if ( v3 >= 1.0e10 )
      {
        v10 = 71;
        v9 = 0.000000001;
      }
      else
      {
        v10 = 77;
        v9 = 0.000001;
      }
    }
    else
    {
      v10 = 75;
      v9 = 0.001;
    }
  }
  else
  {
    v9 = 1.0;
  }
  *a2 = v3 * v9;
  if ( v10 )
    return sprintf(a3, "%c%s/s", v10, a1);
  else
    return sprintf(a3, "%s/s", a1);
}
// 39674: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00039898) --------------------------------------------------------
int __fastcall rev(int result, int a2)
{
  char v2; // [sp+Fh] [bp-Dh]
  int i; // [sp+10h] [bp-Ch]
  int v4; // [sp+14h] [bp-8h]

  v4 = 0;
  for ( i = a2 - 1; v4 < i; --i )
  {
    v2 = *(_BYTE *)(result + v4);
    *(_BYTE *)(result + v4) = *(_BYTE *)(result + i);
    *(_BYTE *)(result + i) = v2;
    ++v4;
  }
  return result;
}

//----- (00039944) --------------------------------------------------------
int __fastcall bin2hex(int result, int a2, unsigned int a3)
{
  int v5; // [sp+Ch] [bp-10h]
  unsigned int i; // [sp+14h] [bp-8h]

  v5 = result;
  for ( i = 0; i < a3; ++i )
    result = sprintf((char *)(v5 + 2 * i), "%02x", *(unsigned __int8 *)(a2 + i));
  return result;
}

//----- (000399C0) --------------------------------------------------------
void *__fastcall abin2hex(int a1, unsigned int a2)
{
  void *v6; // [sp+Ch] [bp-8h]

  v6 = malloc(2 * a2 + 1);
  if ( v6 )
  {
    bin2hex((int)v6, a1, a2);
    return v6;
  }
  else
  {
    set_miner_6060info_malloc_failed_err(1);
    return 0;
  }
}

//----- (00039A2C) --------------------------------------------------------
bool __fastcall hex2bin(_BYTE *a1, char *a2, int a3)
{
  char v8[12]; // [sp+20h] [bp-100Ch] BYREF
  char *endptr; // [sp+1020h] [bp-Ch] BYREF
  char nptr[4]; // [sp+1024h] [bp-8h] BYREF

  nptr[2] = 0;
  while ( *a2 && a3 )
  {
    if ( !a2[1] )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "hex2bin str truncated");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/util.c",
        144,
        "hex2bin",
        7,
        160,
        100,
        v8);
      return 0;
    }
    nptr[0] = *a2;
    nptr[1] = a2[1];
    *a1 = strtol(nptr, &endptr, 16);
    if ( *endptr )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "hex2bin failed on '%s'", nptr);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/util.c",
        144,
        "hex2bin",
        7,
        167,
        100,
        v8);
      return 0;
    }
    ++a1;
    a2 += 2;
    --a3;
  }
  return a3 == 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00039CA0) --------------------------------------------------------
int __fastcall sub_39CA0(unsigned __int8 a1)
{
  int v1; // r3

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return (unsigned __int8)(a1 - 48);
  if ( a1 > 0x60u && a1 <= 0x66u )
    return (unsigned __int8)(a1 - 87);
  v1 = a1;
  if ( a1 > 0x40u )
  {
    v1 = a1;
    if ( a1 <= 0x46u )
      return (unsigned __int8)(a1 - 55);
  }
  return v1;
}

//----- (00039D3C) --------------------------------------------------------
int __fastcall str2hex(int a1, int a2, int a3)
{
  char v7; // [sp+13h] [bp-9h]
  int i; // [sp+14h] [bp-8h]

  for ( i = 0; i < a3; i += 2 )
  {
    v7 = sub_39CA0(*(_BYTE *)(a2 + i));
    *(_BYTE *)(a1 + i / 2) = (16 * v7) | sub_39CA0(*(_BYTE *)(a2 + i + 1));
  }
  return a3 / 2;
}

//----- (00039E18) --------------------------------------------------------
int __fastcall valid_hex(const char *a1)
{
  char v4[16]; // [sp+1Ch] [bp-1010h] BYREF
  unsigned __int8 v5; // [sp+101Eh] [bp-Eh]
  unsigned __int8 v6; // [sp+101Fh] [bp-Dh]
  signed int i; // [sp+1020h] [bp-Ch]
  signed int v8; // [sp+1024h] [bp-8h]

  v6 = 0;
  if ( a1 )
  {
    v8 = strlen(a1);
    for ( i = 0; i < v8; ++i )
    {
      v5 = a1[i];
      if ( dword_D985C[v5] < 0 )
      {
        V_LOCK();
        logfmt_raw(v4, 0x1000u, 0, "Invalid charpassed to valid_hex");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/util.c",
          144,
          "valid_hex",
          9,
          237,
          20,
          v4);
        return v6;
      }
    }
    v6 = 1;
    return 1;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "Null string passed to valid_hex");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/util.c",
      144,
      "valid_hex",
      9,
      227,
      20,
      v4);
    return v6;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// D985C: using guessed type int dword_D985C[256];
// 1608F0: using guessed type int g_zc;

//----- (00039FD4) --------------------------------------------------------
int __fastcall valid_ascii(const char *a1)
{
  char v4[20]; // [sp+18h] [bp-1014h] BYREF
  unsigned __int8 v5; // [sp+101Bh] [bp-11h]
  signed int v6; // [sp+101Ch] [bp-10h]
  signed int i; // [sp+1020h] [bp-Ch]
  unsigned __int8 v8; // [sp+1027h] [bp-5h]

  v5 = 0;
  if ( a1 )
  {
    v6 = strlen(a1);
    if ( v6 )
    {
      for ( i = 0; i < v6; ++i )
      {
        v8 = a1[i];
        if ( v8 <= 0x1Fu || v8 > 0x7Eu )
        {
          V_LOCK();
          logfmt_raw(v4, 0x1000u, 0, "Invalid char passed to valid_ascii");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/util.c",
            144,
            "valid_ascii",
            11,
            267,
            20,
            v4);
          return v5;
        }
      }
      v5 = 1;
      return 1;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "Zero length string passed to valid_ascii");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/util.c",
        144,
        "valid_ascii",
        11,
        258,
        20,
        v4);
      return v5;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "Null string passed to valid_ascii");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/util.c",
      144,
      "valid_ascii",
      11,
      252,
      20,
      v4);
    return v5;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0003A218) --------------------------------------------------------
int __fastcall reverse_hex(int result, unsigned int a2)
{
  char v2; // [sp+Fh] [bp-Dh]
  unsigned int i; // [sp+14h] [bp-8h]

  for ( i = 0; i < a2 >> 1; ++i )
  {
    v2 = *(_BYTE *)(result + i);
    *(_BYTE *)(result + i) = *(_BYTE *)(result + a2 - i - 1);
    *(_BYTE *)(result + a2 - i - 1) = v2;
  }
  return result;
}

//----- (0003A2D4) --------------------------------------------------------
char *tq_new()
{
  char *v2; // [sp+4h] [bp-8h]

  v2 = (char *)calloc(1u, 0x58u);
  if ( !v2 )
    return 0;
  *(_DWORD *)v2 = v2;
  *((_DWORD *)v2 + 1) = v2;
  pthread_mutex_init((pthread_mutex_t *)(v2 + 12), 0);
  pthread_cond_init((pthread_cond_t *)(v2 + 40), 0);
  return v2;
}

//----- (0003A358) --------------------------------------------------------
void __fastcall tq_free(char *a1)
{
  int v2; // [sp+8h] [bp-Ch]
  char *ptr; // [sp+Ch] [bp-8h]

  if ( a1 )
  {
    ptr = (char *)(*(_DWORD *)a1 - 4);
    v2 = **(_DWORD **)a1 - 4;
    while ( ptr + 4 != a1 )
    {
      list_del((list_head *)(ptr + 4));
      free(ptr);
      ptr = (char *)v2;
      v2 = *(_DWORD *)(v2 + 4) - 4;
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    memset(a1, 0, 0x58u);
    free(a1);
  }
}

//----- (0003A424) --------------------------------------------------------
int __fastcall sub_3A424(int a1, char a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12));
}

//----- (0003A484) --------------------------------------------------------
void __cdecl tq_freeze(thread_q *tq)
{
  sub_3A424((int)tq, 1);
}

//----- (0003A4AC) --------------------------------------------------------
void __cdecl mg_iobuf_free(timeval *tv)
{
  sub_3A424((int)tv, 0);
}

//----- (0003A4D4) --------------------------------------------------------
int __fastcall tq_push(int a1, int a2)
{
  _DWORD *ptr; // [sp+8h] [bp-Ch]
  unsigned __int8 v7; // [sp+Fh] [bp-5h]

  v7 = 1;
  ptr = calloc(1u, 0xCu);
  if ( !ptr )
    return 0;
  *ptr = a2;
  ptr[1] = ptr + 1;
  ptr[2] = ptr + 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  if ( *(_BYTE *)(a1 + 8) != 1 )
  {
    list_add_tail((list_head *)(ptr + 1), (list_head *)a1);
  }
  else
  {
    free(ptr);
    v7 = 0;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12));
  return v7;
}

//----- (0003A5C8) --------------------------------------------------------
int __fastcall tq_pop(int a1, const struct timespec *a2)
{
  int *ptr; // [sp+Ch] [bp-10h]
  int v6; // [sp+10h] [bp-Ch]
  int v7; // [sp+14h] [bp-8h]

  v7 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  if ( !list_empty((list_head *)a1)
    || (!a2
      ? (v6 = pthread_cond_wait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 12)))
      : (v6 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 12), a2)),
        !v6 && !list_empty((list_head *)a1)) )
  {
    ptr = (int *)(*(_DWORD *)a1 - 4);
    v7 = *ptr;
    list_del(*(list_head **)a1);
    free(ptr);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12));
  return v7;
}

//----- (0003A6EC) --------------------------------------------------------
int __fastcall sub_3A6EC(int a1, int a2)
{
  int i; // [sp+10h] [bp-Ch]
  int v6; // [sp+14h] [bp-8h]

  v6 = 0;
  for ( i = 0; i <= 31; i += 4 )
    v6 += sprintf(
            (char *)(a1 + v6),
            "%02x%02x%02x%02x ",
            *(unsigned __int8 *)(a2 + i),
            *(unsigned __int8 *)(a2 + i + 1),
            *(unsigned __int8 *)(a2 + i + 2),
            *(unsigned __int8 *)(a2 + i + 3));
  return a1;
}

//----- (0003A7CC) --------------------------------------------------------
int __fastcall cgtime(struct timeval *a1)
{
  return gettimeofday(a1, 0);
}

//----- (0003A7F4) --------------------------------------------------------
_DWORD *__fastcall cgtimer_sub(_DWORD *result, _DWORD *a2, _DWORD *a3)
{
  *a3 = *result - *a2;
  a3[1] = result[1] - a2[1];
  if ( (int)a3[1] < 0 )
  {
    --*a3;
    a3[1] += 1000000;
  }
  return result;
}

//----- (0003A890) --------------------------------------------------------
int __fastcall sub_3A890(const char *a1, int *a2, int a3, int a4)
{
  int result; // r0
  char v9[12]; // [sp+20h] [bp-100Ch] BYREF
  char *endptr; // [sp+1020h] [bp-Ch] BYREF
  int v11; // [sp+1024h] [bp-8h]

  result = strtol(a1, &endptr, 0);
  v11 = result;
  if ( *endptr || !*a1 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "'%s' is not a number", a1);
    V_UNLOCK();
    result = zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/util.c",
               144,
               "opt_set_longval",
               15,
               474,
               100,
               v9);
  }
  if ( v11 == 0x7FFFFFFF || v11 == 0x80000000 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "'%s' is out of range", a1);
    V_UNLOCK();
    result = zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/util.c",
               144,
               "opt_set_longval",
               15,
               476,
               100,
               v9);
  }
  if ( v11 < a3 && v11 > a4 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "'%s' is out of range", a1);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/util.c",
             144,
             "opt_set_longval",
             15,
             480,
             100,
             v9);
  }
  else
  {
    *a2 = v11;
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0003AB0C) --------------------------------------------------------
int __fastcall get_server_port_from_url(const char *a1, char *a2, _WORD *a3)
{
  int v7; // [sp+14h] [bp-18h] BYREF
  char *v8; // [sp+18h] [bp-14h]
  unsigned __int8 v9; // [sp+1Fh] [bp-Dh]

  v9 = 0;
  if ( a1 )
  {
    v8 = strchr(a1, 58);
    if ( v8 )
    {
      if ( v8 != a1 )
      {
        strncpy(a2, a1, v8 - a1);
        a2[v8 - a1] = 0;
        if ( v8 + 1 - a1 < strlen(a1) )
        {
          sub_3A890(v8 + 1, &v7, 0, 0xFFFF);
          *a3 = v7;
          return 1;
        }
      }
    }
  }
  return v9;
}

//----- (0003AC0C) --------------------------------------------------------
int __fastcall find_min_and_max_float(int result, int a2, float *a3, float *a4)
{
  int i; // [sp+14h] [bp-10h]
  float v5; // [sp+18h] [bp-Ch]
  float v6; // [sp+1Ch] [bp-8h]

  v6 = INFINITY;
  v5 = -INFINITY;
  for ( i = 0; i < a2; ++i )
  {
    if ( v6 > *(float *)(result + 4 * i) )
      v6 = *(float *)(result + 4 * i);
    if ( v5 < *(float *)(result + 4 * i) )
      v5 = *(float *)(result + 4 * i);
  }
  *a3 = v6;
  *a4 = v5;
  return result;
}

//----- (0003AD08) --------------------------------------------------------
int *__fastcall find_min_and_max_int(int *result, int a2, _DWORD *a3, _DWORD *a4)
{
  int i; // [sp+14h] [bp-10h]
  int v5; // [sp+18h] [bp-Ch]
  int v6; // [sp+1Ch] [bp-8h]

  if ( a2 > 0 )
  {
    v6 = *result;
    v5 = *result;
    for ( i = 1; i < a2; ++i )
    {
      if ( v6 > result[i] )
        v6 = result[i];
      if ( v5 < result[i] )
        v5 = result[i];
    }
    *a3 = v6;
    *a4 = v5;
  }
  return result;
}

//----- (0003AE0C) --------------------------------------------------------
int __fastcall calc_mean(int result, int a2)
{
  int i; // [sp+8h] [bp-Ch]
  int v3; // [sp+Ch] [bp-8h]

  v3 = 0;
  for ( i = 0; i < a2; ++i )
    v3 += *(_DWORD *)(result + 4 * i);
  return result;
}

//----- (0003AEA0) --------------------------------------------------------
double __fastcall calc_stdd(int a1, int a2)
{
  double v2; // d0
  double v3; // r0
  double v4; // r2
  double v5; // d0
  double y_4; // [sp+8h] [bp-1Ch]
  int i; // [sp+14h] [bp-10h]
  double v11; // [sp+18h] [bp-Ch]

  v11 = 0.0;
  LODWORD(v3) = calc_mean(a1, a2);
  y_4 = v2;
  for ( i = 0; i < a2; ++i )
  {
    LODWORD(v4) = a1;
    HIDWORD(v4) = *(_DWORD *)(a1 + 4 * i);
    v5 = (double)SHIDWORD(v4) - y_4;
    v3 = pow(v3, v4);
    v11 = v11 + v5;
  }
  return sqrt(v3);
}
// 3AED8: variable 'v2' is possibly undefined
// 3AF14: variable 'v3' is possibly undefined

//----- (0003AF70) --------------------------------------------------------
bool __fastcall check_value_valid_with_stdd(int a1, int a2, int a3)
{
  double v3; // d0
  char v9[36]; // [sp+38h] [bp-1024h] BYREF
  double v10; // [sp+1038h] [bp-24h]
  double v11; // [sp+1040h] [bp-1Ch]
  double v12; // [sp+1048h] [bp-14h]
  double v13; // [sp+1050h] [bp-Ch]

  calc_mean(a1, a2);
  v13 = v3;
  calc_stdd(a1, a2);
  v12 = v3;
  v11 = v3 - v3;
  v10 = v3 + v3;
  V_LOCK();
  logfmt_raw(
    v9,
    0x1000u,
    0,
    "mean:%.4f, stdd:%.4f, min_value:%.4f, max_value:%.4f, to_check:%.4f",
    v3,
    v3,
    v3 - v3,
    v3 + v3,
    (double)a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/util.c",
    144,
    "check_value_valid_with_stdd",
    27,
    571,
    20,
    v9);
  return v11 <= (double)a3 && v10 >= (double)a3 || v12 < 2.0;
}
// 3AFC4: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0003B12C) --------------------------------------------------------
int __fastcall cmpfunc_float(float *a1, float *a2)
{
  return (int)(float)(*a1 - *a2);
}

//----- (0003B16C) --------------------------------------------------------
int __fastcall cmpfunc_int(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0003B1A4) --------------------------------------------------------
int __fastcall CalcFileMD5(const char *a1, _BYTE *a2)
{
  _BYTE *v3; // r3
  const unsigned __int16 *v4; // r4
  char s[412]; // [sp+8h] [bp-1B4h] BYREF
  int v8; // [sp+1A4h] [bp-18h]
  FILE *stream; // [sp+1A8h] [bp-14h]
  int i; // [sp+1ACh] [bp-10h]

  sprintf(s, "md5sum %.256s 2>/dev/null", a1);
  stream = popen(s, "r");
  if ( !stream )
    return -1;
  for ( i = 0; i <= 31; ++i )
  {
    v4 = *_ctype_b_loc();
    v8 = fgetc(stream);
    if ( (v4[v8] & 0x1000) == 0 )
      break;
    v3 = a2++;
    *v3 = v8;
  }
  *a2 = 0;
  pclose(stream);
  return i != 32;
}

//----- (0003B2A0) --------------------------------------------------------
int __fastcall sub_3B2A0(int result, int a2, int a3, int a4)
{
  int savedregs_4; // [sp+4h] [bp+4h]

  savedregs_4 = result;
  return result;
}

//----- (0003B2C0) --------------------------------------------------------
unsigned int __fastcall sub_3B2C0(int a1, unsigned int a2)
{
  unsigned int v2; // r1
  unsigned int v3; // r1
  unsigned int v5; // [sp+0h] [bp-14h]
  int v6; // [sp+4h] [bp-10h]
  unsigned int i; // [sp+Ch] [bp-8h]

  v5 = a2;
  sub_CC7AC(a1, a2);
  for ( i = v2; i; i = v3 )
  {
    v6 = v5;
    v5 = i;
    sub_CC7AC(v6, i);
  }
  return v5;
}
// 3B2E8: variable 'v2' is possibly undefined
// 3B314: variable 'v3' is possibly undefined

//----- (0003B334) --------------------------------------------------------
int __fastcall sub_3B334(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v9; // [sp+14h] [bp-28h]
  int v10; // [sp+18h] [bp-24h]
  signed int v11; // [sp+20h] [bp-1Ch]
  int v12; // [sp+24h] [bp-18h]
  int v13; // [sp+28h] [bp-14h]
  int v14; // [sp+2Ch] [bp-10h]
  int j; // [sp+30h] [bp-Ch]
  signed int i; // [sp+34h] [bp-8h]

  v13 = a2 - a1;
  v12 = a3 - a2;
  v11 = sub_3B2C0(a2 - a1, a3 - a2);
  result = sub_CC518(a3 - a1, v11);
  for ( i = 0; i < v11; ++i )
  {
    v10 = a2 + i;
    v14 = a2 + i;
    for ( j = 0; j < result; ++j )
    {
      if ( v14 < a2 )
        v14 += v12;
      else
        v14 -= v13;
      v9 = *(_DWORD *)(a4 + 4 * v14);
      *(_DWORD *)(a4 + 4 * v14) = *(_DWORD *)(a4 + 4 * v10);
      *(_DWORD *)(a4 + 4 * v10) = v9;
    }
  }
  return result;
}

//----- (0003B4A0) --------------------------------------------------------
int __fastcall sub_3B4A0(int a1, _BYTE *a2, int a3, int *a4, int a5)
{
  size_t v5; // r2
  int v7; // r2
  int v8; // r3
  int v9; // r3
  char *s; // [sp+14h] [bp-18h]
  int v16; // [sp+18h] [bp-14h]
  int i; // [sp+1Ch] [bp-10h]
  size_t n; // [sp+20h] [bp-Ch]
  char *v19; // [sp+24h] [bp-8h]

  s = off_14DE88;
  v16 = -1;
  ++optind;
  v19 = strchr(off_14DE88, 61);
  if ( v19 )
  {
    n = v19 - s;
    ++v19;
  }
  else
  {
    n = strlen(s);
  }
  for ( i = 0; ; ++i )
  {
    v5 = a3;
    if ( !*(_DWORD *)(a3 + 16 * i) )
      goto LABEL_18;
    if ( !strncmp(s, *(const char **)(a3 + 16 * i), n) )
    {
      v5 = strlen(*(const char **)(a3 + 16 * i));
      if ( n == v5 )
      {
        v16 = i;
LABEL_18:
        if ( v16 == -1 )
        {
          if ( a5 )
          {
            --optind;
            return -1;
          }
          else
          {
            if ( opterr )
            {
              v9 = (unsigned __int8)*a2;
              if ( v9 != 58 )
                sub_3B2A0((int)"unknown option -- %s", (int)s, v5, v9);
            }
            optopt = 0;
            return 63;
          }
        }
        else if ( *(_DWORD *)(a3 + 16 * v16 + 4) || !v19 )
        {
          if ( *(_DWORD *)(a3 + 16 * v16 + 4) == 1 || *(_DWORD *)(a3 + 16 * v16 + 4) == 2 )
          {
            if ( v19 )
            {
              optarg = (int)v19;
            }
            else if ( *(_DWORD *)(a3 + 16 * v16 + 4) == 1 )
            {
              v7 = optind++;
              optarg = *(_DWORD *)(a1 + 4 * v7);
            }
          }
          if ( *(_DWORD *)(a3 + 16 * v16 + 4) != 1 || optarg )
          {
            if ( a4 )
              *a4 = v16;
            if ( *(_DWORD *)(a3 + 16 * v16 + 8) )
            {
              **(_DWORD **)(a3 + 16 * v16 + 8) = *(_DWORD *)(a3 + 16 * v16 + 12);
              return 0;
            }
            else
            {
              return *(_DWORD *)(a3 + 16 * v16 + 12);
            }
          }
          else
          {
            if ( opterr )
            {
              v8 = (unsigned __int8)*a2;
              if ( v8 != 58 )
                sub_3B2A0((int)"option requires an argument -- %s", (int)s, a3, v8);
            }
            if ( *(_DWORD *)(a3 + 16 * v16 + 8) )
              optopt = 0;
            else
              optopt = *(_DWORD *)(a3 + 16 * v16 + 12);
            --optind;
            if ( *a2 == 58 )
              return 58;
            else
              return 63;
          }
        }
        else
        {
          if ( opterr && *a2 != 58 )
            sub_3B2A0((int)"option doesn't take an argument -- %.*s", n, (int)s, n);
          if ( *(_DWORD *)(a3 + 16 * v16 + 8) )
            optopt = 0;
          else
            optopt = *(_DWORD *)(a3 + 16 * v16 + 12);
          if ( *a2 == 58 )
            return 58;
          else
            return 63;
        }
      }
      if ( !a5 || n != 1 )
        break;
    }
LABEL_16:
    ;
  }
  if ( v16 == -1 )
  {
    v16 = i;
    goto LABEL_16;
  }
  if ( opterr && *a2 != 58 )
    sub_3B2A0((int)"ambiguous option -- %.*s", n, (int)s, n);
  optopt = 0;
  return 63;
}
// 14DE7C: using guessed type int opterr;
// 14DE80: using guessed type int optind;
// 14DE84: using guessed type int optopt;
// 14DE88: using guessed type char *off_14DE88;
// 161238: using guessed type int optarg;

//----- (0003B9E8) --------------------------------------------------------
int __fastcall sub_3B9E8(int a1, int a2, char *a3, int a4, int *a5, char a6)
{
  int v7; // r2
  char *v8; // r2
  int v9; // r3
  int v10; // r3
  int v11; // r3
  char *s; // [sp+Ch] [bp-20h]
  char *v17; // [sp+1Ch] [bp-10h]
  _BYTE *v18; // [sp+1Ch] [bp-10h]
  int c; // [sp+20h] [bp-Ch]
  int ca; // [sp+20h] [bp-Ch]
  int cb; // [sp+20h] [bp-Ch]
  _BOOL4 v22; // [sp+24h] [bp-8h]

  s = a3;
  if ( !a3 )
    return -1;
  if ( dword_14DE94 == -1 )
    dword_14DE94 = getenv("POSIXLY_CORRECT") != 0;
  if ( dword_14DE94 || *s == 43 )
  {
    a6 &= ~1u;
  }
  else if ( *s == 45 )
  {
    a6 |= 2u;
  }
  if ( *s == 43 || *s == 45 )
    ++s;
  if ( !optind )
  {
    optreset = 1;
    optind = 1;
  }
  optarg = 0;
  if ( optreset )
  {
    dword_14DE90 = -1;
    dword_14DE8C = -1;
  }
  while ( 1 )
  {
    if ( !optreset && *off_14DE88 )
      goto LABEL_46;
    optreset = 0;
    if ( a1 <= optind )
    {
      off_14DE88 = &byte_D9EAC;
      if ( dword_14DE90 == -1 )
      {
        if ( dword_14DE8C != -1 )
          optind = dword_14DE8C;
      }
      else
      {
        sub_3B334(dword_14DE8C, dword_14DE90, optind, a2);
        optind -= dword_14DE90 - dword_14DE8C;
      }
      dword_14DE90 = -1;
      dword_14DE8C = -1;
      return -1;
    }
    off_14DE88 = *(char **)(a2 + 4 * optind);
    if ( *off_14DE88 == 45 && (off_14DE88[1] || strchr(s, 45)) )
      break;
    off_14DE88 = &byte_D9EAC;
    if ( (a6 & 2) != 0 )
    {
      v7 = optind++;
      optarg = *(_DWORD *)(a2 + 4 * v7);
      return 1;
    }
    if ( (a6 & 1) == 0 )
      return -1;
    if ( dword_14DE8C == -1 )
    {
      dword_14DE8C = optind;
    }
    else if ( dword_14DE90 != -1 )
    {
      sub_3B334(dword_14DE8C, dword_14DE90, optind, a2);
      dword_14DE8C = optind - (dword_14DE90 - dword_14DE8C);
      dword_14DE90 = -1;
    }
    ++optind;
  }
  if ( dword_14DE8C != -1 && dword_14DE90 == -1 )
    dword_14DE90 = optind;
  if ( off_14DE88[1] )
  {
    if ( *++off_14DE88 == 45 && !off_14DE88[1] )
    {
      ++optind;
      off_14DE88 = &byte_D9EAC;
      if ( dword_14DE90 != -1 )
      {
        sub_3B334(dword_14DE8C, dword_14DE90, optind, a2);
        optind -= dword_14DE90 - dword_14DE8C;
      }
      dword_14DE90 = -1;
      dword_14DE8C = -1;
      return -1;
    }
  }
LABEL_46:
  if ( a4 && *(char **)(a2 + 4 * optind) != off_14DE88 && (*off_14DE88 == 45 || (a6 & 4) != 0) )
  {
    v22 = 0;
    if ( *off_14DE88 == 45 )
    {
      ++off_14DE88;
    }
    else if ( *off_14DE88 != 58 )
    {
      v22 = strchr(s, (unsigned __int8)*off_14DE88) != 0;
    }
    c = sub_3B4A0(a2, s, a4, a5, v22);
    if ( c != -1 )
    {
      off_14DE88 = &byte_D9EAC;
      return c;
    }
  }
  v8 = off_14DE88++;
  ca = (unsigned __int8)*v8;
  if ( ca == 58 || ca == 45 && *off_14DE88 || (v17 = strchr(s, ca)) == 0 )
  {
    if ( ca == 45 && !*off_14DE88 )
      return -1;
    if ( !*off_14DE88 )
      v8 = (char *)++optind;
    if ( opterr )
    {
      v9 = (unsigned __int8)*s;
      if ( v9 != 58 )
        sub_3B2A0((int)"unknown option -- %c", ca, (int)v8, v9);
    }
    optopt = ca;
    return 63;
  }
  if ( a4 && ca == 87 && v17[1] == 59 )
  {
    if ( !*off_14DE88 )
    {
      if ( a1 <= ++optind )
      {
        off_14DE88 = &byte_D9EAC;
        if ( opterr )
        {
          v10 = (unsigned __int8)*s;
          if ( v10 != 58 )
            sub_3B2A0((int)"option requires an argument -- %c", 87, (int)&byte_D9EAC, v10);
        }
        optopt = 87;
        if ( *s == 58 )
          return 58;
        else
          return 63;
      }
      off_14DE88 = *(char **)(a2 + 4 * optind);
    }
    cb = sub_3B4A0(a2, s, a4, a5, 0);
    off_14DE88 = &byte_D9EAC;
    return cb;
  }
  v18 = v17 + 1;
  if ( *v18 != 58 )
  {
    if ( !*off_14DE88 )
      ++optind;
    return ca;
  }
  optarg = 0;
  if ( *off_14DE88 )
  {
    optarg = (int)off_14DE88;
LABEL_96:
    off_14DE88 = &byte_D9EAC;
    ++optind;
    return ca;
  }
  if ( v18[1] == 58 )
    goto LABEL_96;
  if ( a1 > ++optind )
  {
    optarg = *(_DWORD *)(a2 + 4 * optind);
    goto LABEL_96;
  }
  off_14DE88 = &byte_D9EAC;
  if ( opterr )
  {
    v11 = (unsigned __int8)*s;
    if ( v11 != 58 )
      sub_3B2A0((int)"option requires an argument -- %c", ca, (int)&byte_D9EAC, v11);
  }
  optopt = ca;
  if ( *s == 58 )
    return 58;
  else
    return 63;
}
// 3C22C: variable 'v8' is possibly undefined
// D9EAC: using guessed type char byte_D9EAC;
// 14DE7C: using guessed type int opterr;
// 14DE80: using guessed type int optind;
// 14DE84: using guessed type int optopt;
// 14DE88: using guessed type char *off_14DE88;
// 14DE8C: using guessed type int dword_14DE8C;
// 14DE90: using guessed type int dword_14DE90;
// 14DE94: using guessed type int dword_14DE94;
// 161234: using guessed type int optreset;
// 161238: using guessed type int optarg;

//----- (0003C55C) --------------------------------------------------------
int __fastcall getopt(int a1, int a2, char *a3)
{
  return sub_3B9E8(a1, a2, a3, 0, 0, 0);
}

//----- (0003C5A8) --------------------------------------------------------
int __fastcall getopt_long(int a1, int a2, char *a3, int a4, int *a5)
{
  return sub_3B9E8(a1, a2, a3, a4, a5, 1);
}

//----- (0003C5F8) --------------------------------------------------------
int __fastcall getopt_long_only(int a1, int a2, char *a3, int a4, int *a5)
{
  return sub_3B9E8(a1, a2, a3, a4, a5, 5);
}

//----- (0003C648) --------------------------------------------------------
int __cdecl dump_to_strbuffer(const char *buffer, size_t size, void *data)
{
  return strbuffer_append_bytes((strbuffer_t *)data, buffer, size);
}

//----- (0003C680) --------------------------------------------------------
int __fastcall sub_3C680(const void *a1, size_t a2, _DWORD *a3)
{
  if ( a3[1] + a2 <= *a3 )
    memcpy((void *)(a3[2] + a3[1]), a1, a2);
  a3[1] += a2;
  return 0;
}

//----- (0003C70C) --------------------------------------------------------
int __fastcall sub_3C70C(const void *a1, size_t a2, FILE *a3)
{
  if ( fwrite(a1, a2, 1u, a3) == 1 )
    return 0;
  else
    return -1;
}

//----- (0003C764) --------------------------------------------------------
int __fastcall sub_3C764(const void *a1, size_t a2, int *a3)
{
  if ( write(*a3, a1, a2) == a2 )
    return 0;
  else
    return -1;
}

//----- (0003C7C4) --------------------------------------------------------
int __fastcall dump_indent(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  int v6; // r3
  int v9; // [sp+14h] [bp-10h]
  unsigned int v10; // [sp+1Ch] [bp-8h]

  if ( (a1 & 0x1F) == 0 )
  {
    if ( a3 && (a1 & 0x20) == 0 )
      return a4(" ", 1, a5);
    return 0;
  }
  v10 = a2 * (a1 & 0x1F);
  if ( !a4("\n", 1, a5) )
  {
    while ( v10 )
    {
      v6 = v10;
      if ( v10 >= 0x20 )
        v6 = 32;
      v9 = v6;
      if ( a4("                                ", v6, a5) )
        return -1;
      v10 -= v9;
    }
    return 0;
  }
  return -1;
}
// 3C7C4: invalid function type 'int __cdecl dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data)' has been ignored

//----- (0003C8E4) --------------------------------------------------------
int __fastcall sub_3C8E4(const char *a1, int a2, int (__fastcall *a3)(const char *, int, int), int a4, __int16 a5)
{
  char s[16]; // [sp+18h] [bp-34h] BYREF
  int32_t v12; // [sp+28h] [bp-24h] BYREF
  int v13; // [sp+2Ch] [bp-20h]
  int v14; // [sp+30h] [bp-1Ch]
  const char *v15; // [sp+34h] [bp-18h]
  int v16; // [sp+38h] [bp-14h]
  char *v17; // [sp+3Ch] [bp-10h]
  const char *v18; // [sp+40h] [bp-Ch]
  const char *v19; // [sp+44h] [bp-8h]

  v12 = 0;
  if ( !a3("\"", 1, a4) )
  {
    v19 = a1;
    v18 = a1;
    v15 = &a1[a2];
    while ( 1 )
    {
      while ( v18 < v15 )
      {
        v18 = utf8_iterate(v19, v15 - v19, &v12);
        if ( !v18 )
          return -1;
        if ( v12 == 92 || v12 == 34 || v12 <= 31 || (a5 & 0x400) != 0 && v12 == 47 || (a5 & 0x40) != 0 && v12 > 127 )
          break;
        v19 = v18;
      }
      if ( v19 != a1 && a3(a1, v19 - a1, a4) )
        return -1;
      if ( v18 == v19 )
        return a3("\"", 1, a4);
      v16 = 2;
      if ( v12 == 12 )
      {
        v17 = "\\f";
        goto LABEL_44;
      }
      if ( v12 > 12 )
      {
        if ( v12 == 34 )
        {
          v17 = "\\\"";
          goto LABEL_44;
        }
        if ( v12 > 34 )
        {
          if ( v12 == 47 )
          {
            v17 = "\\/";
            goto LABEL_44;
          }
          if ( v12 == 92 )
          {
            v17 = "\\\\";
            goto LABEL_44;
          }
        }
        else if ( v12 == 13 )
        {
          v17 = "\\r";
          goto LABEL_44;
        }
      }
      else
      {
        switch ( v12 )
        {
          case 9:
            v17 = "\\t";
            goto LABEL_44;
          case 10:
            v17 = "\\n";
            goto LABEL_44;
          case 8:
            v17 = "\\b";
            goto LABEL_44;
        }
      }
      if ( v12 >= 0x10000 )
      {
        v12 -= 0x10000;
        v14 = (v12 >> 10) & 0x3FF | 0xD800;
        v13 = v12 & 0x3FF | 0xDC00;
        snprintf(s, 0xDu, "\\u%04X\\u%04X", v14, v13);
        v16 = 12;
      }
      else
      {
        snprintf(s, 0xDu, "\\u%04X", v12);
        v16 = 6;
      }
      v17 = s;
LABEL_44:
      if ( a3(v17, v16, a4) )
        return -1;
      v19 = v18;
      a1 = v18;
    }
  }
  return -1;
}

//----- (0003CC4C) --------------------------------------------------------
int __cdecl compare_keys(const void *key1, const void *key2)
{
  return strcmp(*(const char **)key1, *(const char **)key2);
}

//----- (0003CC8C) --------------------------------------------------------
int __fastcall sub_3CC8C(hashtable_t *a1, const void *a2, char *a3, size_t a4)
{
  json_t *v5; // r0

  snprintf(a3, a4, "%p", a2);
  if ( hashtable_get(a1, a3) )
    return -1;
  v5 = (json_t *)json_null();
  return hashtable_set(a1, a3, v5);
}

//----- (0003CD08) --------------------------------------------------------
int __fastcall sub_3CD08(
        _DWORD *a1,
        int a2,
        int a3,
        hashtable_t *a4,
        int (__fastcall *a5)(const char *, int, int),
        int a6)
{
  double v6; // d0
  __int64 v8; // r0
  double v9; // r2
  const char *v10; // r4
  size_t v11; // r0
  json_t *v12; // r0
  const char **v13; // r4
  size_t v14; // r0
  size_t v15; // r0
  void *v16; // r0
  int v18; // [sp+0h] [bp-E4h]
  unsigned int v21; // [sp+10h] [bp-D4h]
  char s[100]; // [sp+18h] [bp-CCh] BYREF
  char v24[12]; // [sp+7Ch] [bp-68h] BYREF
  char v25[12]; // [sp+88h] [bp-5Ch] BYREF
  json_t *v26; // [sp+94h] [bp-50h]
  char *v27; // [sp+98h] [bp-4Ch]
  void *base; // [sp+9Ch] [bp-48h]
  size_t nmemb; // [sp+A0h] [bp-44h]
  char *v30; // [sp+A4h] [bp-40h]
  void *v31; // [sp+A8h] [bp-3Ch]
  size_t v32; // [sp+ACh] [bp-38h]
  unsigned int v33; // [sp+B0h] [bp-34h]
  int v34; // [sp+B4h] [bp-30h]
  double v35; // [sp+B8h] [bp-2Ch]
  int v36; // [sp+C0h] [bp-24h]
  size_t i; // [sp+C4h] [bp-20h]
  int v38; // [sp+C8h] [bp-1Ch]
  const char *v39; // [sp+CCh] [bp-18h]
  void *v40; // [sp+D0h] [bp-14h]
  size_t j; // [sp+D4h] [bp-10h]

  v36 = a2 & 0x10000;
  v21 = a2 & 0xFFFEFFFF;
  if ( a1 )
  {
    switch ( *a1 )
    {
      case 0:
        if ( (a2 & 0x20) != 0 )
        {
          v39 = ":";
          v38 = 1;
        }
        else
        {
          v39 = ": ";
          v38 = 2;
        }
        if ( sub_3CC8C(a4, a1, v24, 0xBu) )
          return -1;
        v40 = json_object_iter((json_t *)a1);
        if ( !v36 && a5("{", 1, a6) )
          return -1;
        if ( v40 )
        {
          if ( dump_indent(v21, a3 + 1, 0, a5, a6) )
            return -1;
          if ( (v21 & 0x80) == 0 )
          {
            while ( 1 )
            {
              if ( !v40 )
                goto LABEL_82;
              v31 = json_object_iter_next((json_t *)a1, v40);
              v30 = (char *)json_object_iter_key(v40);
              v15 = strlen(v30);
              sub_3C8E4(v30, v15, a5, a6, v21);
              if ( a5(v39, v38, a6) )
                return -1;
              v16 = json_object_iter_value(v40);
              if ( sub_3CD08(v16, v21, a3 + 1, a4, a5, a6) )
                return -1;
              if ( v31 )
              {
                if ( a5(",", 1, a6) || dump_indent(v21, a3 + 1, 1, a5, a6) )
                  return -1;
              }
              else if ( dump_indent(v21, a3, 0, a5, a6) )
              {
                return -1;
              }
              v40 = v31;
            }
          }
          nmemb = json_object_size((const json_t *)a1);
          base = jsonp_malloc(4 * nmemb);
          if ( !base )
            return -1;
          i = 0;
          while ( v40 )
          {
            v13 = (const char **)((char *)base + 4 * i);
            *v13 = json_object_iter_key(v40);
            v40 = json_object_iter_next((json_t *)a1, v40);
            ++i;
          }
          qsort(base, nmemb, 4u, (__compar_fn_t)compare_keys);
          for ( i = 0; i < nmemb; ++i )
          {
            v27 = (char *)*((_DWORD *)base + i);
            v26 = json_object_get((const json_t *)a1, v27);
            v14 = strlen(v27);
            sub_3C8E4(v27, v14, a5, a6, v21);
            if ( a5(v39, v38, a6) || sub_3CD08(v26, v21, a3 + 1, a4, a5, a6) )
            {
LABEL_67:
              jsonp_free(base);
              return -1;
            }
            if ( i >= nmemb - 1 )
            {
              if ( dump_indent(v21, a3, 0, a5, a6) )
                goto LABEL_67;
            }
            else if ( a5(",", 1, a6) || dump_indent(v21, a3 + 1, 1, a5, a6) )
            {
              goto LABEL_67;
            }
          }
          jsonp_free(base);
LABEL_82:
          hashtable_del((int)a4, v24);
          if ( v36 )
            return 0;
        }
        else
        {
          hashtable_del((int)a4, v24);
          if ( v36 )
            return 0;
        }
        return a5("}", 1, a6);
      case 1:
        if ( sub_3CC8C(a4, a1, v25, 0xBu) )
          return -1;
        v32 = json_array_size((const json_t *)a1);
        if ( !v36 && a5("[", 1, a6) )
          return -1;
        if ( v32 )
        {
          if ( dump_indent(v21, a3 + 1, 0, a5, a6) )
            return -1;
          for ( j = 0; j < v32; ++j )
          {
            v12 = json_array_get((const json_t *)a1, j);
            if ( sub_3CD08(v12, v21, a3 + 1, a4, a5, a6) )
              return -1;
            if ( j >= v32 - 1 )
            {
              if ( dump_indent(v21, a3, 0, a5, a6) )
                return -1;
            }
            else if ( a5(",", 1, a6) || dump_indent(v21, a3 + 1, 1, a5, a6) )
            {
              return -1;
            }
          }
          hashtable_del((int)a4, v25);
          if ( v36 )
            return 0;
        }
        else
        {
          hashtable_del((int)a4, v25);
          if ( v36 )
            return 0;
        }
        return a5("]", 1, a6);
      case 2:
        v10 = json_string_value((const json_t *)a1);
        v11 = json_string_length((const json_t *)a1);
        return sub_3C8E4(v10, v11, a5, a6, v21);
      case 3:
        v8 = json_integer_value((int)a1);
        v33 = snprintf(s, 0x64u, "%lld", v8);
        if ( v33 < 0x64 )
          return a5(s, v33, a6);
        else
          return -1;
      case 4:
        json_real_value();
        v35 = v6;
        LODWORD(v9) = (unsigned __int16)v21 >> 11;
        HIDWORD(v9) = s;
        v34 = jsonp_dtostr(s, 0x64u, v9, v18);
        if ( v34 >= 0 )
          return a5(s, v34, a6);
        else
          return -1;
      case 5:
        return a5("true", 4, a6);
      case 6:
        return a5("false", 5, a6);
      case 7:
        return a5("null", 4, a6);
      default:
        return -1;
    }
  }
  return -1;
}
// 3CD60: control flows out of bounds to 3CD64
// 3CE54: variable 'v6' is possibly undefined
// 3CE74: variable 'v18' is possibly undefined

//----- (0003D628) --------------------------------------------------------
char *__fastcall json_dumps(_DWORD *a1, int a2)
{
  const char *v3; // r0
  _BYTE v7[12]; // [sp+8h] [bp-14h] BYREF
  char *v8; // [sp+14h] [bp-8h]

  if ( strbuffer_init((strbuffer_t *)v7) )
    return 0;
  if ( json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))dump_to_strbuffer, (int)v7, a2) )
  {
    v8 = 0;
  }
  else
  {
    v3 = strbuffer_value((const strbuffer_t *)v7);
    v8 = jsonp_strdup(v3);
  }
  strbuffer_close((strbuffer_t *)v7);
  return v8;
}

//----- (0003D6C4) --------------------------------------------------------
int __fastcall json_dumpb(_DWORD *a1, int a2, int a3, int a4)
{
  int v6; // [sp+14h] [bp-10h] BYREF
  int v7; // [sp+18h] [bp-Ch]
  int v8; // [sp+1Ch] [bp-8h]

  v6 = a3;
  v7 = 0;
  v8 = a2;
  if ( json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))sub_3C680, (int)&v6, a4) )
    return 0;
  else
    return v7;
}

//----- (0003D734) --------------------------------------------------------
int __fastcall json_dumpf(_DWORD *a1, int a2, int a3)
{
  return json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))sub_3C70C, a2, a3);
}

//----- (0003D774) --------------------------------------------------------
int __fastcall json_dumpfd(_DWORD *a1, int a2, int a3)
{
  _DWORD v4[2]; // [sp+8h] [bp-Ch] BYREF

  v4[1] = a1;
  v4[0] = a2;
  return json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))sub_3C764, (int)v4, a3);
}

//----- (0003D7B4) --------------------------------------------------------
int __fastcall json_dump_file(_DWORD *a1, const char *a2, int a3)
{
  int v7; // [sp+10h] [bp-Ch]
  FILE *stream; // [sp+14h] [bp-8h]

  stream = fopen(a2, "w");
  if ( !stream )
    return -1;
  v7 = json_dumpf(a1, (int)stream, a3);
  if ( fclose(stream) )
    return -1;
  else
    return v7;
}

//----- (0003D834) --------------------------------------------------------
int __fastcall json_dump_callback(_DWORD *a1, int (__fastcall *a2)(const char *, int, int), int a3, int a4)
{
  _BYTE v10[28]; // [sp+18h] [bp-24h] BYREF
  int v11; // [sp+34h] [bp-8h]

  if ( (a4 & 0x200) == 0 && (!a1 || *a1 != 1) && (!a1 || *a1) )
    return -1;
  if ( hashtable_init((hashtable_t *)v10) )
    return -1;
  v11 = sub_3CD08(a1, a4, 0, (hashtable_t *)v10, a2, a3);
  hashtable_close((hashtable_t *)v10);
  return v11;
}

//----- (0003D908) --------------------------------------------------------
void __cdecl jsonp_error_init(json_error_t *error, const char *source)
{
  if ( error )
  {
    *((_BYTE *)error + 92) = 0;
    *(_DWORD *)error = -1;
    *((_DWORD *)error + 1) = -1;
    *((_DWORD *)error + 2) = 0;
    if ( source )
      jsonp_error_set_source((char *)error, source);
    else
      *((_BYTE *)error + 12) = 0;
  }
}

//----- (0003D98C) --------------------------------------------------------
char *__fastcall jsonp_error_set_source(char *result, const char *a2)
{
  char *v3; // [sp+4h] [bp-10h]
  size_t v4; // [sp+Ch] [bp-8h]

  v3 = result;
  if ( result && a2 )
  {
    v4 = strlen(a2);
    if ( v4 > 0x4F )
    {
      memcpy(v3 + 12, "...", 3u);
      return strncpy(v3 + 15, &a2[v4 - 76], 0x4Du);
    }
    else
    {
      return strncpy(v3 + 12, a2, v4 + 1);
    }
  }
  return result;
}

//----- (0003DA58) --------------------------------------------------------
int jsonp_error_set(int a1, int a2, int a3, int a4, char a5, char *format, ...)
{
  va_list va; // [sp+38h] [bp+Ch] BYREF

  va_start(va, format);
  return jsonp_error_vset(a1, a2, a3, a4, a5, format, va);
}

//----- (0003DAB4) --------------------------------------------------------
int __fastcall jsonp_error_vset(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg)
{
  int v7; // [sp+Ch] [bp-8h]

  v7 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, arg);
      *(_BYTE *)(v7 + 250) = 0;
      *(_BYTE *)(v7 + 251) = a5;
    }
  }
  return result;
}

//----- (0003DB5C) --------------------------------------------------------
void __fastcall sub_3DB5C(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (0003DBC4) --------------------------------------------------------
int __fastcall sub_3DBC4(unsigned __int8 *a1, unsigned int a2, int a3)
{
  int v3; // r3
  unsigned int v5; // [sp+8h] [bp-2Ch]
  unsigned __int8 *v6; // [sp+18h] [bp-1Ch]
  unsigned __int16 *v7; // [sp+1Ch] [bp-18h]
  _DWORD *v8; // [sp+20h] [bp-14h]
  int v9; // [sp+24h] [bp-10h]
  int v10; // [sp+24h] [bp-10h]
  int v11; // [sp+24h] [bp-10h]
  int v12; // [sp+24h] [bp-10h]
  int v13; // [sp+24h] [bp-10h]
  int v14; // [sp+24h] [bp-10h]
  int v15; // [sp+24h] [bp-10h]
  int v16; // [sp+24h] [bp-10h]
  int v17; // [sp+24h] [bp-10h]
  int v18; // [sp+24h] [bp-10h]
  int v19; // [sp+24h] [bp-10h]
  int v20; // [sp+24h] [bp-10h]
  int v21; // [sp+24h] [bp-10h]
  int v22; // [sp+24h] [bp-10h]
  int v23; // [sp+24h] [bp-10h]
  int v24; // [sp+28h] [bp-Ch]
  int v25; // [sp+28h] [bp-Ch]
  int v26; // [sp+28h] [bp-Ch]
  int v27; // [sp+28h] [bp-Ch]
  int v28; // [sp+28h] [bp-Ch]
  int v29; // [sp+28h] [bp-Ch]
  int v30; // [sp+28h] [bp-Ch]
  int v31; // [sp+28h] [bp-Ch]
  int v32; // [sp+28h] [bp-Ch]
  int v33; // [sp+28h] [bp-Ch]
  int v34; // [sp+28h] [bp-Ch]
  int v35; // [sp+28h] [bp-Ch]
  int v36; // [sp+28h] [bp-Ch]
  int v37; // [sp+28h] [bp-Ch]
  int v38; // [sp+28h] [bp-Ch]
  int v39; // [sp+2Ch] [bp-8h]
  int v40; // [sp+2Ch] [bp-8h]
  int v41; // [sp+2Ch] [bp-8h]
  int v42; // [sp+2Ch] [bp-8h]
  int v43; // [sp+2Ch] [bp-8h]
  int v44; // [sp+2Ch] [bp-8h]
  int v45; // [sp+2Ch] [bp-8h]
  int v46; // [sp+2Ch] [bp-8h]
  int v47; // [sp+2Ch] [bp-8h]
  int v48; // [sp+2Ch] [bp-8h]
  int v49; // [sp+2Ch] [bp-8h]
  int v50; // [sp+2Ch] [bp-8h]
  int v51; // [sp+2Ch] [bp-8h]

  v5 = a2;
  v9 = a2 + a3 - 559038737;
  v24 = v9;
  v39 = v9;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( ((unsigned __int8)a1 & 1) != 0 )
    {
      v6 = a1;
      while ( v5 > 0xC )
      {
        v33 = v24 + v6[4] + (v6[5] << 8) + (v6[6] << 16) + (v6[7] << 24);
        v18 = v9 + v6[8] + (v6[9] << 8) + (v6[10] << 16) + (v6[11] << 24);
        v47 = __ROR4__(v18, 28) ^ (v39 + *v6 + (v6[1] << 8) + (v6[2] << 16) + (v6[3] << 24) - v18);
        v19 = v18 + v33;
        v34 = __ROR4__(v47, 26) ^ (v33 - v47);
        v48 = v47 + v19;
        v20 = __ROR4__(v34, 24) ^ (v19 - v34);
        v35 = v34 + v48;
        v49 = __ROR4__(v20, 16) ^ (v48 - v20);
        v21 = v20 + v35;
        v36 = __ROR4__(v49, 13) ^ (v35 - v49);
        v39 = v49 + v21;
        v9 = __ROR4__(v36, 28) ^ (v21 - v36);
        v24 = v36 + v39;
        v5 -= 12;
        v6 += 12;
      }
      switch ( v5 )
      {
        case 0u:
          return v9;
        case 1u:
          goto LABEL_52;
        case 2u:
          goto LABEL_51;
        case 3u:
          goto LABEL_50;
        case 4u:
          goto LABEL_49;
        case 5u:
          goto LABEL_48;
        case 6u:
          goto LABEL_47;
        case 7u:
          goto LABEL_46;
        case 8u:
          goto LABEL_45;
        case 9u:
          goto LABEL_44;
        case 0xAu:
          goto LABEL_43;
        case 0xBu:
          goto LABEL_42;
        case 0xCu:
          v9 += v6[11] << 24;
LABEL_42:
          v9 += v6[10] << 16;
LABEL_43:
          v9 += v6[9] << 8;
LABEL_44:
          v9 += v6[8];
LABEL_45:
          v24 += v6[7] << 24;
LABEL_46:
          v24 += v6[6] << 16;
LABEL_47:
          v24 += v6[5] << 8;
LABEL_48:
          v24 += v6[4];
LABEL_49:
          v39 += v6[3] << 24;
LABEL_50:
          v39 += v6[2] << 16;
LABEL_51:
          v39 += v6[1] << 8;
LABEL_52:
          v43 = v39 + *v6;
          break;
      }
    }
    else
    {
      v7 = (unsigned __int16 *)a1;
      while ( v5 > 0xC )
      {
        v29 = v24 + v7[2] + (v7[3] << 16);
        v14 = v9 + v7[4] + (v7[5] << 16);
        v44 = __ROR4__(v14, 28) ^ (v39 + *v7 + (v7[1] << 16) - v14);
        v15 = v14 + v29;
        v30 = __ROR4__(v44, 26) ^ (v29 - v44);
        v45 = v44 + v15;
        v16 = __ROR4__(v30, 24) ^ (v15 - v30);
        v31 = v30 + v45;
        v46 = __ROR4__(v16, 16) ^ (v45 - v16);
        v17 = v16 + v31;
        v32 = __ROR4__(v46, 13) ^ (v31 - v46);
        v39 = v46 + v17;
        v9 = __ROR4__(v32, 28) ^ (v17 - v32);
        v24 = v32 + v39;
        v5 -= 12;
        v7 += 6;
      }
      switch ( v5 )
      {
        case 0u:
          return v9;
        case 1u:
          v43 = v39 + *(unsigned __int8 *)v7;
          break;
        case 2u:
          goto LABEL_34;
        case 3u:
          v39 += *((unsigned __int8 *)v7 + 2) << 16;
LABEL_34:
          v43 = v39 + *v7;
          break;
        case 4u:
          goto LABEL_32;
        case 5u:
          v24 += *((unsigned __int8 *)v7 + 4);
LABEL_32:
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
        case 6u:
          goto LABEL_30;
        case 7u:
          v24 += *((unsigned __int8 *)v7 + 6) << 16;
LABEL_30:
          v24 += v7[2];
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
        case 8u:
          goto LABEL_28;
        case 9u:
          v9 += *((unsigned __int8 *)v7 + 8);
LABEL_28:
          v24 += v7[2] + (v7[3] << 16);
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
        case 0xAu:
          goto LABEL_26;
        case 0xBu:
          v9 += *((unsigned __int8 *)v7 + 10) << 16;
LABEL_26:
          v9 += v7[4];
          v24 += v7[2] + (v7[3] << 16);
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
        case 0xCu:
          v9 += v7[4] + (v7[5] << 16);
          v24 += v7[2] + (v7[3] << 16);
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
      }
    }
LABEL_54:
    v22 = (v24 ^ v9) - __ROR4__(v24, 18);
    v50 = (v22 ^ v43) - __ROR4__(v22, 21);
    v37 = (v50 ^ v24) - __ROR4__(v50, 7);
    v23 = (v37 ^ v22) - __ROR4__(v37, 16);
    v51 = (v23 ^ v50) - __ROR4__(v23, 28);
    v38 = (v51 ^ v37) - __ROR4__(v51, 18);
    return (v38 ^ v23) - __ROR4__(v38, 8);
  }
  else
  {
    v8 = a1;
    while ( v5 > 0xC )
    {
      v25 = v24 + v8[1];
      v10 = v9 + v8[2];
      v40 = __ROR4__(v10, 28) ^ (v39 + *v8 - v10);
      v11 = v10 + v25;
      v26 = __ROR4__(v40, 26) ^ (v25 - v40);
      v41 = v40 + v11;
      v12 = __ROR4__(v26, 24) ^ (v11 - v26);
      v27 = v26 + v41;
      v42 = __ROR4__(v12, 16) ^ (v41 - v12);
      v13 = v12 + v27;
      v28 = __ROR4__(v42, 13) ^ (v27 - v42);
      v39 = v42 + v13;
      v9 = __ROR4__(v28, 28) ^ (v13 - v28);
      v24 = v28 + v39;
      v5 -= 12;
      v8 += 3;
    }
    switch ( v5 )
    {
      case 0u:
        v3 = v9;
        break;
      case 1u:
        v43 = v39 + (unsigned __int8)*v8;
        goto LABEL_54;
      case 2u:
        v43 = v39 + (unsigned __int16)*v8;
        goto LABEL_54;
      case 3u:
        v43 = v39 + (*v8 & 0xFFFFFF);
        goto LABEL_54;
      case 4u:
        v43 = v39 + *v8;
        goto LABEL_54;
      case 5u:
        v24 += (unsigned __int8)v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 6u:
        v24 += (unsigned __int16)v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 7u:
        v24 += v8[1] & 0xFFFFFF;
        v43 = v39 + *v8;
        goto LABEL_54;
      case 8u:
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 9u:
        v9 += (unsigned __int8)v8[2];
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 0xAu:
        v9 += (unsigned __int16)v8[2];
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 0xBu:
        v9 += v8[2] & 0xFFFFFF;
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 0xCu:
        v9 += v8[2];
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
    }
  }
  return v3;
}
// 3DDD8: control flows out of bounds to 3DDDC
// 3E294: control flows out of bounds to 3E298
// 3E840: control flows out of bounds to 3E844
// 3DDD4: the default case was optimized away because %var_2C.4<Du
// 3E290: the default case was optimized away because %var_2C.4<Du
// 3E83C: the default case was optimized away because %var_2C.4<Du

//----- (0003EAE0) --------------------------------------------------------
void __cdecl list_init(list_t *list)
{
  *((_DWORD *)list + 1) = list;
  *(_DWORD *)list = list;
}

//----- (0003EB18) --------------------------------------------------------
void __cdecl list_insert(list_t *list, list_t *node)
{
  *((_DWORD *)node + 1) = list;
  *(_DWORD *)node = *(_DWORD *)list;
  *(_DWORD *)(*(_DWORD *)list + 4) = node;
  *(_DWORD *)list = node;
}

//----- (0003EB74) --------------------------------------------------------
_DWORD *__fastcall sub_3EB74(_DWORD *result)
{
  *(_DWORD *)(*result + 4) = result[1];
  *(_DWORD *)result[1] = *result;
  return result;
}

//----- (0003EBBC) --------------------------------------------------------
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket)
{
  return *(hashtable_t **)bucket == (hashtable_t *)((char *)hashtable + 12)
      && *(_DWORD *)bucket == *((_DWORD *)bucket + 1);
}

//----- (0003EC1C) --------------------------------------------------------
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list)
{
  if ( bucket_is_empty(hashtable, bucket) )
  {
    list_insert((hashtable_t *)((char *)hashtable + 12), list);
    *((_DWORD *)bucket + 1) = list;
    *(_DWORD *)bucket = *((_DWORD *)bucket + 1);
  }
  else
  {
    list_insert(*(list_t **)bucket, list);
    *(_DWORD *)bucket = list;
  }
}

//----- (0003ECAC) --------------------------------------------------------
pair_t *__cdecl hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const char *key, size_t hash)
{
  int i; // [sp+14h] [bp-8h]

  if ( bucket_is_empty(hashtable, bucket) )
    return 0;
  for ( i = *(_DWORD *)bucket; ; i = *(_DWORD *)(i + 4) )
  {
    if ( hash == *(_DWORD *)(i + 16) && !strcmp((const char *)(i + 24), key) )
      return (pair_t *)i;
    if ( i == *((_DWORD *)bucket + 1) )
      break;
  }
  return 0;
}

//----- (0003ED70) --------------------------------------------------------
int __fastcall sub_3ED70(int a1, const char *a2, size_t a3)
{
  pair_t *pair; // [sp+14h] [bp-10h]
  int v7; // [sp+18h] [bp-Ch]

  v7 = *(_DWORD *)(a1 + 4) + 8 * (((1 << *(_DWORD *)(a1 + 8)) - 1) & a3);
  pair = hashtable_find_pair((hashtable_t *)a1, (bucket_t *)v7, a2, a3);
  if ( !pair )
    return -1;
  if ( pair == *(pair_t **)v7 && pair == *(pair_t **)(v7 + 4) )
  {
    *(_DWORD *)(v7 + 4) = a1 + 12;
    *(_DWORD *)v7 = *(_DWORD *)(v7 + 4);
  }
  else if ( pair == *(pair_t **)v7 )
  {
    *(_DWORD *)v7 = *((_DWORD *)pair + 1);
  }
  else if ( pair == *(pair_t **)(v7 + 4) )
  {
    *(_DWORD *)(v7 + 4) = *(_DWORD *)pair;
  }
  sub_3EB74(pair);
  sub_3EB74((_DWORD *)pair + 2);
  sub_3DB5C(*((_DWORD *)pair + 5));
  jsonp_free(pair);
  --*(_DWORD *)a1;
  return 0;
}

//----- (0003EEDC) --------------------------------------------------------
void __cdecl hashtable_do_clear(hashtable_t *hashtable)
{
  _DWORD *v2; // [sp+10h] [bp-Ch]
  _DWORD *i; // [sp+14h] [bp-8h]

  for ( i = (_DWORD *)*((_DWORD *)hashtable + 4); i != (_DWORD *)((char *)hashtable + 12); i = v2 )
  {
    v2 = (_DWORD *)i[1];
    sub_3DB5C(i[5]);
    jsonp_free(i);
  }
}

//----- (0003EF50) --------------------------------------------------------
int __fastcall sub_3EF50(int a1)
{
  int v2; // r3
  int v3; // r1
  int v6; // [sp+10h] [bp-1Ch]
  void *v7; // [sp+14h] [bp-18h]
  int v8; // [sp+1Ch] [bp-10h]
  unsigned int i; // [sp+20h] [bp-Ch]
  int v10; // [sp+24h] [bp-8h]

  v8 = *(_DWORD *)(a1 + 8) + 1;
  v7 = jsonp_malloc(8 * (1 << v8));
  if ( !v7 )
    return -1;
  jsonp_free(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 4) = v7;
  *(_DWORD *)(a1 + 8) = v8;
  for ( i = 0; i < 1 << *(_DWORD *)(a1 + 8); ++i )
  {
    v2 = *(_DWORD *)(a1 + 4) + 8 * i;
    *(_DWORD *)(v2 + 4) = a1 + 12;
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8 * i) = *(_DWORD *)(v2 + 4);
  }
  v10 = *(_DWORD *)(a1 + 16);
  list_init((list_t *)(a1 + 12));
  while ( v10 != a1 + 12 )
  {
    v6 = *(_DWORD *)(v10 + 4);
    sub_CC4FC(*(_DWORD *)(v10 + 16), 1 << v8);
    insert_to_bucket((hashtable_t *)a1, (bucket_t *)(*(_DWORD *)(a1 + 4) + 8 * v3), (list_t *)v10);
    v10 = v6;
  }
  return 0;
}
// 3F09C: variable 'v3' is possibly undefined

//----- (0003F0E0) --------------------------------------------------------
int __cdecl hashtable_init(hashtable_t *hashtable)
{
  int v2; // r3
  unsigned int i; // [sp+Ch] [bp-8h]

  *(_DWORD *)hashtable = 0;
  *((_DWORD *)hashtable + 2) = 3;
  *((_DWORD *)hashtable + 1) = jsonp_malloc(8 << *((_DWORD *)hashtable + 2));
  if ( !*((_DWORD *)hashtable + 1) )
    return -1;
  list_init((hashtable_t *)((char *)hashtable + 12));
  list_init((hashtable_t *)((char *)hashtable + 20));
  for ( i = 0; i < 1 << *((_DWORD *)hashtable + 2); ++i )
  {
    v2 = *((_DWORD *)hashtable + 1) + 8 * i;
    *(_DWORD *)(v2 + 4) = (char *)hashtable + 12;
    *(_DWORD *)(*((_DWORD *)hashtable + 1) + 8 * i) = *(_DWORD *)(v2 + 4);
  }
  return 0;
}

//----- (0003F1E4) --------------------------------------------------------
void __cdecl hashtable_close(hashtable_t *hashtable)
{
  hashtable_do_clear(hashtable);
  jsonp_free(*((void **)hashtable + 1));
}

//----- (0003F218) --------------------------------------------------------
int __cdecl hashtable_set(hashtable_t *hashtable, const char *key, json_t *value)
{
  size_t v4; // r0
  size_t v9; // [sp+14h] [bp-18h]
  pair_t *pair; // [sp+18h] [bp-14h]
  char *v11; // [sp+18h] [bp-14h]
  bucket_t *v12; // [sp+1Ch] [bp-10h]
  size_t v13; // [sp+24h] [bp-8h]

  if ( !(*(_DWORD *)hashtable >> *((_DWORD *)hashtable + 2)) || !sub_3EF50((int)hashtable) )
  {
    v4 = strlen(key);
    v13 = sub_3DBC4((unsigned __int8 *)key, v4, hashtable_seed);
    v12 = (bucket_t *)(*((_DWORD *)hashtable + 1) + 8 * (((1 << *((_DWORD *)hashtable + 2)) - 1) & v13));
    pair = hashtable_find_pair(hashtable, v12, key, v13);
    if ( pair )
    {
      sub_3DB5C(*((_DWORD *)pair + 5));
      *((_DWORD *)pair + 5) = value;
    }
    else
    {
      v9 = strlen(key);
      if ( v9 > 0xFFFFFFE6 )
        return -1;
      v11 = (char *)jsonp_malloc(v9 + 25);
      if ( !v11 )
        return -1;
      *((_DWORD *)v11 + 4) = v13;
      strncpy(v11 + 24, key, v9 + 1);
      *((_DWORD *)v11 + 5) = value;
      list_init((list_t *)v11);
      list_init((list_t *)(v11 + 8));
      insert_to_bucket(hashtable, v12, (list_t *)v11);
      list_insert((hashtable_t *)((char *)hashtable + 20), (list_t *)(v11 + 8));
      ++*(_DWORD *)hashtable;
    }
    return 0;
  }
  return -1;
}
// 15232C: using guessed type int hashtable_seed;

//----- (0003F3F8) --------------------------------------------------------
void *__cdecl hashtable_get(hashtable_t *hashtable, const char *key)
{
  size_t v2; // r0
  pair_t *pair; // [sp+Ch] [bp-10h]
  size_t v8; // [sp+14h] [bp-8h]

  v2 = strlen(key);
  v8 = sub_3DBC4((unsigned __int8 *)key, v2, hashtable_seed);
  pair = hashtable_find_pair(
           hashtable,
           (bucket_t *)(*((_DWORD *)hashtable + 1) + 8 * (v8 & ((1 << *((_DWORD *)hashtable + 2)) - 1))),
           key,
           v8);
  if ( pair )
    return (void *)*((_DWORD *)pair + 5);
  else
    return 0;
}
// 15232C: using guessed type int hashtable_seed;

//----- (0003F4A4) --------------------------------------------------------
int __fastcall hashtable_del(int a1, char *a2)
{
  size_t v2; // r0
  size_t v6; // [sp+Ch] [bp-8h]

  v2 = strlen(a2);
  v6 = sub_3DBC4((unsigned __int8 *)a2, v2, hashtable_seed);
  return sub_3ED70(a1, a2, v6);
}
// 15232C: using guessed type int hashtable_seed;

//----- (0003F500) --------------------------------------------------------
void __fastcall hashtable_clear(int a1)
{
  int v1; // r3
  unsigned int i; // [sp+Ch] [bp-8h]

  hashtable_do_clear((hashtable_t *)a1);
  for ( i = 0; i < 1 << *(_DWORD *)(a1 + 8); ++i )
  {
    v1 = *(_DWORD *)(a1 + 4) + 8 * i;
    *(_DWORD *)(v1 + 4) = a1 + 12;
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8 * i) = *(_DWORD *)(v1 + 4);
  }
  list_init((list_t *)(a1 + 12));
  list_init((list_t *)(a1 + 20));
  *(_DWORD *)a1 = 0;
}

//----- (0003F5C0) --------------------------------------------------------
void *__cdecl hashtable_iter(hashtable_t *hashtable)
{
  return hashtable_iter_next(hashtable, (char *)hashtable + 20);
}

//----- (0003F5F4) --------------------------------------------------------
char *__fastcall hashtable_iter_at(int a1, char *a2)
{
  size_t v2; // r0
  pair_t *pair; // [sp+Ch] [bp-10h]
  size_t v8; // [sp+14h] [bp-8h]

  v2 = strlen(a2);
  v8 = sub_3DBC4((unsigned __int8 *)a2, v2, hashtable_seed);
  pair = hashtable_find_pair(
           (hashtable_t *)a1,
           (bucket_t *)(*(_DWORD *)(a1 + 4) + 8 * (v8 & ((1 << *(_DWORD *)(a1 + 8)) - 1))),
           a2,
           v8);
  if ( pair )
    return (char *)pair + 8;
  else
    return 0;
}
// 15232C: using guessed type int hashtable_seed;

//----- (0003F6A0) --------------------------------------------------------
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter)
{
  if ( *((hashtable_t **)iter + 1) == (hashtable_t *)((char *)hashtable + 20) )
    return 0;
  else
    return (void *)*((_DWORD *)iter + 1);
}

//----- (0003F6F4) --------------------------------------------------------
void *__cdecl hashtable_iter_key(void *iter)
{
  return (char *)iter + 16;
}

//----- (0003F728) --------------------------------------------------------
void *__cdecl hashtable_iter_value(void *iter)
{
  return (void *)*((_DWORD *)iter + 3);
}

//----- (0003F75C) --------------------------------------------------------
void __fastcall hashtable_iter_set(int a1, int a2)
{
  int v3; // [sp+Ch] [bp-8h]

  v3 = a1 - 8;
  sub_3DB5C(*(_DWORD *)(a1 + 12));
  *(_DWORD *)(v3 + 20) = a2;
}

//----- (0003F7A4) --------------------------------------------------------
int __fastcall sub_3F7A4(int a1)
{
  int v2; // [sp+8h] [bp-Ch]
  unsigned int i; // [sp+Ch] [bp-8h]

  v2 = 0;
  for ( i = 0; i <= 3; ++i )
    v2 = (v2 << 8) | *(unsigned __int8 *)(a1 + i);
  return v2;
}

//----- (0003F814) --------------------------------------------------------
int __fastcall sub_3F814(int *a1)
{
  _BYTE buf[4]; // [sp+Ch] [bp-10h] BYREF
  _BOOL4 v5; // [sp+10h] [bp-Ch]
  int fd; // [sp+14h] [bp-8h]

  fd = open("/dev/urandom", 0);
  if ( fd == -1 )
    return 1;
  v5 = read(fd, buf, 4u) == 4;
  close(fd);
  if ( !v5 )
    return 1;
  *a1 = sub_3F7A4((int)buf);
  return 0;
}

//----- (0003F8BC) --------------------------------------------------------
int __fastcall sub_3F8BC(int *a1)
{
  struct timeval tv; // [sp+8h] [bp-Ch] BYREF

  gettimeofday(&tv, 0);
  *a1 = tv.tv_sec ^ tv.tv_usec;
  *a1 ^= getpid();
  return 0;
}

//----- (0003F924) --------------------------------------------------------
int sub_3F924()
{
  int v1; // [sp+0h] [bp-Ch] BYREF

  v1 = 0;
  if ( sub_3F814(&v1) != 0 )
    sub_3F8BC(&v1);
  if ( !v1 )
    return 1;
  return v1;
}

//----- (0003F99C) --------------------------------------------------------
int __fastcall json_object_seed(int result)
{
  unsigned __int8 v1; // r2
  int v2; // r3
  int v3; // [sp+Ch] [bp-8h]

  v3 = result;
  if ( !hashtable_seed )
  {
    do
    {
      v1 = __ldrex((unsigned __int8 *)&unk_152330);
      result = __strex(1u, (unsigned __int8 *)&unk_152330);
    }
    while ( result );
    if ( v1 != 1 )
    {
      if ( !v3 )
      {
        result = sub_3F924();
        v3 = result;
      }
      __dmb(0xBu);
      hashtable_seed = v3;
    }
    else
    {
      do
      {
        result = sched_yield();
        v2 = hashtable_seed;
        __dmb(0xBu);
      }
      while ( !v2 );
    }
  }
  return result;
}
// 15232C: using guessed type int hashtable_seed;

//----- (0003FA50) --------------------------------------------------------
void __fastcall sub_3FA50(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (0003FAB8) --------------------------------------------------------
int sub_3FAB8(int result, int a2, int a3, const char *a4, ...)
{
  int v6; // [sp+1Ch] [bp-164h]
  char v7[159]; // [sp+20h] [bp-160h] BYREF
  char v8; // [sp+BFh] [bp-C1h]
  char s[160]; // [sp+C0h] [bp-C0h] BYREF
  __gnuc_va_list arg; // [sp+160h] [bp-20h]
  const char *v11; // [sp+164h] [bp-1Ch]
  char v12[4]; // [sp+168h] [bp-18h]
  int v13; // [sp+16Ch] [bp-14h]
  int v14; // [sp+170h] [bp-10h]
  int v15; // [sp+174h] [bp-Ch]
  const char *varg_r3; // [sp+184h] [bp+4h]
  va_list va; // [sp+188h] [bp+8h] BYREF

  va_start(va, a4);
  varg_r3 = a4;
  v6 = result;
  v15 = -1;
  v14 = -1;
  v13 = 0;
  *(_DWORD *)v12 = s;
  if ( result )
  {
    va_copy(arg, va);
    vsnprintf(s, 0xA0u, varg_r3, va);
    s[159] = 0;
    if ( a2 )
    {
      v11 = strbuffer_value((const strbuffer_t *)(a2 + 40));
      v15 = *(_DWORD *)(a2 + 24);
      v14 = *(_DWORD *)(a2 + 28);
      v13 = *(_DWORD *)(a2 + 36);
      if ( v11 && *v11 )
      {
        if ( *(_DWORD *)(a2 + 44) <= 0x14u )
        {
          snprintf(v7, 0xA0u, "%s near '%s'", s, v11);
          v8 = 0;
          *(_DWORD *)v12 = v7;
        }
      }
      else
      {
        if ( a3 == 8 )
          LOBYTE(a3) = 6;
        if ( *(_DWORD *)(a2 + 20) == -2 )
        {
          *(_DWORD *)v12 = s;
        }
        else
        {
          snprintf(v7, 0xA0u, "%s near end of file", s);
          v8 = 0;
          *(_DWORD *)v12 = v7;
        }
      }
    }
    return jsonp_error_set(v6, v15, v14, v13, a3, "%s", *(const char **)v12);
  }
  return result;
}

//----- (0003FC6C) --------------------------------------------------------
int __fastcall stream_init(int result, int a2, int a3)
{
  *(_DWORD *)result = a2;
  *(_DWORD *)(result + 4) = a3;
  *(_BYTE *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 1;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 36) = 0;
  return result;
}
// 3FC6C: invalid function type 'void __cdecl stream_init(stream_t *stream, get_func get, void *data)' has been ignored

//----- (0003FCF4) --------------------------------------------------------
int __fastcall sub_3FCF4(int a1, int a2)
{
  int v3; // r3
  size_t v7; // [sp+14h] [bp-10h]
  int v8; // [sp+18h] [bp-Ch]
  int v9; // [sp+18h] [bp-Ch]
  unsigned int i; // [sp+1Ch] [bp-8h]

  if ( *(_DWORD *)(a1 + 20) )
    return *(_DWORD *)(a1 + 20);
  if ( !*(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8) )
  {
    v8 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    if ( v8 == -1 )
    {
      *(_DWORD *)(a1 + 20) = -1;
      return -1;
    }
    *(_BYTE *)(a1 + 8) = v8;
    *(_DWORD *)(a1 + 16) = 0;
    if ( v8 <= 127 || v8 > 255 )
    {
      *(_BYTE *)(a1 + 9) = 0;
    }
    else
    {
      v7 = utf8_check_first(v8);
      if ( !v7 )
        goto LABEL_20;
      for ( i = 1; i < v7; *(_BYTE *)(a1 + i++ + 8) = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4)) )
        ;
      if ( !utf8_check_full((const char *)(a1 + 8), v7, 0) )
      {
LABEL_20:
        *(_DWORD *)(a1 + 20) = -2;
        sub_3FAB8(a2, a1, 5, "unable to decode byte 0x%x", v8);
        return -2;
      }
      *(_BYTE *)(a1 + v7 + 8) = 0;
    }
  }
  v3 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v3 + 1;
  v9 = *(unsigned __int8 *)(a1 + v3 + 8);
  ++*(_DWORD *)(a1 + 36);
  if ( v9 == 10 )
  {
    ++*(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 28) = 0;
  }
  else if ( utf8_check_first(v9) )
  {
    ++*(_DWORD *)(a1 + 28);
  }
  return v9;
}

//----- (0003FF74) --------------------------------------------------------
_DWORD *__fastcall sub_3FF74(_DWORD *result, int a2)
{
  _DWORD *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( a2 != -1 && a2 != -2 )
  {
    --result[9];
    if ( a2 == 10 )
    {
      --result[6];
      result[7] = result[8];
    }
    else
    {
      result = (_DWORD *)utf8_check_first(a2);
      if ( result )
        --v2[7];
    }
    --v2[4];
  }
  return result;
}

//----- (0004003C) --------------------------------------------------------
int __cdecl lex_get(lex_t *lex, json_error_t *error)
{
  return sub_3FCF4((int)lex, (int)error);
}

//----- (00040070) --------------------------------------------------------
void __cdecl lex_save(lex_t *lex, int c)
{
  strbuffer_append_byte((lex_t *)((char *)lex + 40), c);
}

//----- (000400AC) --------------------------------------------------------
int __cdecl lex_get_save(lex_t *lex, json_error_t *error)
{
  int v4; // [sp+Ch] [bp-8h]

  v4 = sub_3FCF4((int)lex, (int)error);
  if ( v4 != -1 && v4 != -2 )
    lex_save(lex, v4);
  return v4;
}

//----- (00040108) --------------------------------------------------------
void __cdecl lex_unget(lex_t *lex, int c)
{
  sub_3FF74(lex, c);
}

//----- (00040138) --------------------------------------------------------
_DWORD *__fastcall sub_40138(_DWORD *result, int a2)
{
  _DWORD *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( a2 != -1 && a2 != -2 )
  {
    sub_3FF74(result, a2);
    return (_DWORD *)strbuffer_pop((strbuffer_t *)(v2 + 10));
  }
  return result;
}

//----- (00040190) --------------------------------------------------------
void __cdecl lex_save_cached(lex_t *lex)
{
  while ( *((_BYTE *)lex + *((_DWORD *)lex + 4) + 8) )
  {
    lex_save(lex, *((unsigned __int8 *)lex + *((_DWORD *)lex + 4) + 8));
    ++*((_DWORD *)lex + 4);
    ++*((_DWORD *)lex + 9);
  }
}

//----- (00040214) --------------------------------------------------------
void __cdecl lex_free_string(lex_t *lex)
{
  jsonp_free(*((void **)lex + 16));
  *((_DWORD *)lex + 16) = 0;
  *((_DWORD *)lex + 17) = 0;
}

//----- (00040258) --------------------------------------------------------
int __fastcall sub_40258(int a1)
{
  unsigned __int8 v3; // [sp+Fh] [bp-Dh]
  int v4; // [sp+10h] [bp-Ch]
  int v5; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  v4 = 0;
  for ( i = 1; i <= 4; ++i )
  {
    v3 = *(_BYTE *)(a1 + i);
    v5 = 16 * v4;
    if ( v3 <= 0x2Fu || v3 > 0x39u )
    {
      if ( v3 <= 0x60u || v3 > 0x7Au )
      {
        if ( v3 <= 0x40u || v3 > 0x5Au )
          return -1;
        v4 = v5 + v3 - 55;
      }
      else
      {
        v4 = v5 + v3 - 87;
      }
    }
    else
    {
      v4 = v5 + v3 - 48;
    }
  }
  return v4;
}

//----- (00040360) --------------------------------------------------------
void __fastcall sub_40360(int a1, json_error_t *a2)
{
  int v2; // r3
  char *v3; // r2
  char *v4; // r3
  size_t v7; // [sp+14h] [bp-20h] BYREF
  int v8; // [sp+18h] [bp-1Ch]
  int32_t v9; // [sp+1Ch] [bp-18h]
  int i; // [sp+20h] [bp-14h]
  char *v11; // [sp+24h] [bp-10h]
  const char *v12; // [sp+28h] [bp-Ch]
  int save; // [sp+2Ch] [bp-8h]

  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 60) = -1;
  save = lex_get_save((lex_t *)a1, a2);
  while ( save != 34 )
  {
    if ( save == -2 )
      goto LABEL_77;
    if ( save == -1 )
    {
      sub_3FAB8((int)a2, a1, 6, "premature end of input");
LABEL_77:
      lex_free_string((lex_t *)a1);
      return;
    }
    if ( (unsigned int)save < 0x20 )
    {
      sub_40138((_DWORD *)a1, save);
      if ( save == 10 )
        sub_3FAB8((int)a2, a1, 8, "unexpected newline");
      else
        sub_3FAB8((int)a2, a1, 8, "control character 0x%x", save);
      goto LABEL_77;
    }
    if ( save == 92 )
    {
      save = lex_get_save((lex_t *)a1, a2);
      if ( save != 117 )
      {
        if ( save != 34
          && save != 92
          && save != 47
          && save != 98
          && save != 102
          && save != 110
          && save != 114
          && save != 116 )
        {
LABEL_18:
          sub_3FAB8((int)a2, a1, 8, "invalid escape");
          goto LABEL_77;
        }
        goto LABEL_32;
      }
      save = lex_get_save((lex_t *)a1, a2);
      for ( i = 0; i <= 3; ++i )
      {
        if ( (save <= 47 || save > 57) && (save <= 64 || save > 70) && (save <= 96 || save > 102) )
          goto LABEL_18;
        save = lex_get_save((lex_t *)a1, a2);
      }
    }
    else
    {
LABEL_32:
      save = lex_get_save((lex_t *)a1, a2);
    }
  }
  v11 = (char *)jsonp_malloc(*(_DWORD *)(a1 + 44) + 1);
  if ( !v11 )
    goto LABEL_77;
  *(_DWORD *)(a1 + 64) = v11;
  v12 = strbuffer_value((const strbuffer_t *)(a1 + 40)) + 1;
  while ( *v12 != 34 )
  {
    if ( *v12 == 92 )
    {
      if ( *++v12 == 117 )
      {
        v9 = sub_40258((int)v12);
        if ( v9 < 0 )
          goto LABEL_39;
        v12 += 5;
        if ( v9 < 55296 || v9 >= 56320 )
        {
          if ( v9 >= 56320 && v9 < 57344 )
          {
LABEL_52:
            sub_3FAB8((int)a2, a1, 8, "invalid Unicode '\\u%04X'", v9);
            goto LABEL_77;
          }
        }
        else
        {
          if ( *v12 != 92 || v12[1] != 117 )
            goto LABEL_52;
          v8 = sub_40258((int)++v12);
          if ( v8 < 0 )
          {
LABEL_39:
            sub_3FAB8((int)a2, a1, 8, "invalid Unicode escape '%.6s'", v12 - 1);
            goto LABEL_77;
          }
          v12 += 5;
          if ( v8 < 56320 || v8 >= 57344 )
          {
            sub_3FAB8((int)a2, a1, 8, "invalid Unicode '\\u%04X\\u%04X'", v9, v8);
            goto LABEL_77;
          }
          v9 = ((v9 - 55296) << 10) + v8 - 56320 + 0x10000;
        }
        utf8_encode(v9, v11, &v7);
        v11 += v7;
      }
      else
      {
        v2 = *(unsigned __int8 *)v12;
        if ( v2 == 98 )
        {
          *v11 = 8;
        }
        else if ( *(unsigned __int8 *)v12 > 0x62u )
        {
          if ( v2 == 110 )
          {
            *v11 = 10;
          }
          else if ( *(unsigned __int8 *)v12 > 0x6Eu )
          {
            if ( v2 == 114 )
            {
              *v11 = 13;
            }
            else if ( v2 == 116 )
            {
              *v11 = 9;
            }
          }
          else if ( v2 == 102 )
          {
            *v11 = 12;
          }
        }
        else if ( v2 == 47 || v2 == 92 || v2 == 34 )
        {
          *v11 = *v12;
        }
        ++v11;
        ++v12;
      }
    }
    else
    {
      v3 = (char *)v12++;
      v4 = v11++;
      *v4 = *v3;
    }
  }
  *v11 = 0;
  *(_DWORD *)(a1 + 68) = &v11[-*(_DWORD *)(a1 + 64)];
  *(_DWORD *)(a1 + 60) = 256;
}

//----- (00040980) --------------------------------------------------------
int __fastcall sub_40980(int a1, int a2, json_error_t *a3)
{
  int save; // [sp+8h] [bp-24h]
  int v7; // [sp+8h] [bp-24h]
  double v9; // [sp+10h] [bp-1Ch] BYREF
  char *endptr; // [sp+18h] [bp-14h] BYREF
  char *nptr; // [sp+1Ch] [bp-10h]
  signed __int64 v12; // [sp+20h] [bp-Ch]

  save = a2;
  *(_DWORD *)(a1 + 60) = -1;
  if ( a2 == 45 )
    save = lex_get_save((lex_t *)a1, a3);
  if ( save == 48 )
  {
    save = lex_get_save((lex_t *)a1, a3);
    if ( save > 47 && save <= 57 )
    {
LABEL_6:
      sub_40138((_DWORD *)a1, save);
      return -1;
    }
  }
  else
  {
    if ( save <= 47 || save > 57 )
      goto LABEL_6;
    do
      save = lex_get_save((lex_t *)a1, a3);
    while ( save > 47 && save <= 57 );
  }
  if ( (*(_DWORD *)(a1 + 52) & 8) != 0 || save == 46 || save == 69 || save == 101 )
  {
    if ( save == 46 )
    {
      v7 = lex_get((lex_t *)a1, a3);
      if ( v7 <= 47 || v7 > 57 )
      {
        lex_unget((lex_t *)a1, v7);
        return -1;
      }
      lex_save((lex_t *)a1, v7);
      do
        save = lex_get_save((lex_t *)a1, a3);
      while ( save > 47 && save <= 57 );
    }
    if ( save == 69 || save == 101 )
    {
      save = lex_get_save((lex_t *)a1, a3);
      if ( save == 43 || save == 45 )
        save = lex_get_save((lex_t *)a1, a3);
      if ( save <= 47 || save > 57 )
        goto LABEL_6;
      do
        save = lex_get_save((lex_t *)a1, a3);
      while ( save > 47 && save <= 57 );
    }
    sub_40138((_DWORD *)a1, save);
    if ( jsonp_strtod((strbuffer_t *)(a1 + 40), &v9) )
    {
      sub_3FAB8((int)a3, a1, 15, "real number overflow");
      return -1;
    }
    *(_DWORD *)(a1 + 60) = 258;
    *(double *)(a1 + 64) = v9;
    return 0;
  }
  else
  {
    sub_40138((_DWORD *)a1, save);
    nptr = (char *)strbuffer_value((const strbuffer_t *)(a1 + 40));
    *_errno_location() = 0;
    v12 = strtoll(nptr, &endptr, 10);
    if ( *_errno_location() == 34 )
    {
      if ( v12 >= 0 )
      {
        *_errno_location() = 0;
        v12 = strtoull(nptr, &endptr, 10);
        if ( *_errno_location() == 34 )
        {
          sub_3FAB8((int)a3, a1, 15, "too big integer");
          return -1;
        }
      }
      else
      {
        sub_3FAB8((int)a3, a1, 15, "too big negative integer");
      }
    }
    *(_DWORD *)(a1 + 60) = 257;
    *(_QWORD *)(a1 + 64) = v12;
    return 0;
  }
}

//----- (00040D30) --------------------------------------------------------
int __cdecl lex_scan(lex_t *lex, json_error_t *error)
{
  char *s1; // [sp+8h] [bp-Ch]
  int v6; // [sp+Ch] [bp-8h]
  int save; // [sp+Ch] [bp-8h]

  strbuffer_clear((lex_t *)((char *)lex + 40));
  if ( *((_DWORD *)lex + 15) == 256 )
    lex_free_string(lex);
  do
  {
    do
      v6 = lex_get(lex, error);
    while ( v6 == 32 );
  }
  while ( v6 == 9 || v6 == 10 || v6 == 13 );
  if ( v6 == -1 )
  {
    *((_DWORD *)lex + 15) = 0;
  }
  else if ( v6 == -2 )
  {
    *((_DWORD *)lex + 15) = -1;
  }
  else
  {
    lex_save(lex, v6);
    if ( v6 == 123 || v6 == 125 || v6 == 91 || v6 == 93 || v6 == 58 || v6 == 44 )
    {
      *((_DWORD *)lex + 15) = v6;
    }
    else if ( v6 == 34 )
    {
      sub_40360((int)lex, error);
    }
    else if ( v6 > 47 && v6 <= 57 || v6 == 45 )
    {
      sub_40980((int)lex, v6, error);
    }
    else if ( (v6 <= 64 || v6 > 90) && (v6 <= 96 || v6 > 122) )
    {
      lex_save_cached(lex);
      *((_DWORD *)lex + 15) = -1;
    }
    else
    {
      do
      {
        do
          save = lex_get_save(lex, error);
        while ( save > 64 && save <= 90 );
      }
      while ( save > 96 && save <= 122 );
      sub_40138(lex, save);
      s1 = (char *)strbuffer_value((lex_t *)((char *)lex + 40));
      if ( !strcmp(s1, "true") )
      {
        *((_DWORD *)lex + 15) = 259;
      }
      else if ( !strcmp(s1, "false") )
      {
        *((_DWORD *)lex + 15) = 260;
      }
      else if ( !strcmp(s1, "null") )
      {
        *((_DWORD *)lex + 15) = 261;
      }
      else
      {
        *((_DWORD *)lex + 15) = -1;
      }
    }
  }
  return *((_DWORD *)lex + 15);
}

//----- (00040FF0) --------------------------------------------------------
char *__cdecl lex_steal_string(lex_t *lex, size_t *out_len)
{
  char *v3; // [sp+Ch] [bp-8h]

  v3 = 0;
  if ( *((_DWORD *)lex + 15) == 256 )
  {
    v3 = (char *)*((_DWORD *)lex + 16);
    *out_len = *((_DWORD *)lex + 17);
    *((_DWORD *)lex + 16) = 0;
    *((_DWORD *)lex + 17) = 0;
  }
  return v3;
}

//----- (00041064) --------------------------------------------------------
int __fastcall lex_init(int a1, int a2, int a3, int a4)
{
  stream_init(a1, a2, a4);
  if ( strbuffer_init((strbuffer_t *)(a1 + 40)) )
    return -1;
  *(_DWORD *)(a1 + 52) = a3;
  *(_DWORD *)(a1 + 60) = -1;
  return 0;
}
// 41064: invalid function type 'int __cdecl lex_init(lex_t *lex, get_func get, size_t flags, void *data)' has been ignored

//----- (000410E0) --------------------------------------------------------
void __cdecl lex_close(lex_t *lex)
{
  if ( *((_DWORD *)lex + 15) == 256 )
    lex_free_string(lex);
  strbuffer_close((lex_t *)((char *)lex + 40));
}

//----- (00041124) --------------------------------------------------------
json_t *__fastcall sub_41124(int a1, int a2, json_error_t *a3)
{
  size_t n; // [sp+10h] [bp-14h] BYREF
  json_t *v9; // [sp+14h] [bp-10h]
  void *s; // [sp+18h] [bp-Ch]
  json_t *v11; // [sp+1Ch] [bp-8h]

  v11 = (json_t *)json_object();
  if ( !v11 )
    return 0;
  lex_scan((lex_t *)a1, a3);
  if ( *(_DWORD *)(a1 + 60) == 125 )
    return v11;
  while ( 1 )
  {
    if ( *(_DWORD *)(a1 + 60) != 256 )
    {
      sub_3FAB8((int)a3, a1, 8, "string or '}' expected");
      goto LABEL_24;
    }
    s = lex_steal_string((lex_t *)a1, &n);
    if ( !s )
      return 0;
    if ( memchr(s, 0, n) )
    {
      jsonp_free(s);
      sub_3FAB8((int)a3, a1, 13, "NUL byte in object key not supported");
      goto LABEL_24;
    }
    if ( (a2 & 1) != 0 && json_object_get(v11, (const char *)s) )
    {
      jsonp_free(s);
      sub_3FAB8((int)a3, a1, 14, "duplicate object key");
      goto LABEL_24;
    }
    lex_scan((lex_t *)a1, a3);
    if ( *(_DWORD *)(a1 + 60) != 58 )
    {
      jsonp_free(s);
      sub_3FAB8((int)a3, a1, 8, "':' expected");
      goto LABEL_24;
    }
    lex_scan((lex_t *)a1, a3);
    v9 = (json_t *)sub_414B0(a1, a2, a3);
    if ( !v9 || json_object_set_new_nocheck(v11, (const char *)s, v9) )
    {
      jsonp_free(s);
      goto LABEL_24;
    }
    jsonp_free(s);
    lex_scan((lex_t *)a1, a3);
    if ( *(_DWORD *)(a1 + 60) != 44 )
      break;
    lex_scan((lex_t *)a1, a3);
  }
  if ( *(_DWORD *)(a1 + 60) == 125 )
    return v11;
  sub_3FAB8((int)a3, a1, 8, "'}' expected");
LABEL_24:
  sub_3FA50((int)v11);
  return 0;
}
// 414B0: using guessed type int __fastcall sub_414B0(_DWORD, _DWORD, _DWORD);

//----- (00041388) --------------------------------------------------------
json_t *__fastcall sub_41388(int a1, int a2, json_error_t *a3)
{
  json_t *v8; // [sp+10h] [bp-Ch]
  json_t *v9; // [sp+14h] [bp-8h]

  v9 = (json_t *)json_array();
  if ( !v9 )
    return 0;
  lex_scan((lex_t *)a1, a3);
  if ( *(_DWORD *)(a1 + 60) == 93 )
    return v9;
  while ( *(_DWORD *)(a1 + 60) )
  {
    v8 = (json_t *)sub_414B0(a1, a2, a3);
    if ( !v8 || json_array_append_new(v9, v8) )
      goto LABEL_13;
    lex_scan((lex_t *)a1, a3);
    if ( *(_DWORD *)(a1 + 60) != 44 )
      break;
    lex_scan((lex_t *)a1, a3);
  }
  if ( *(_DWORD *)(a1 + 60) == 93 )
    return v9;
  sub_3FAB8((int)a3, a1, 8, "']' expected");
LABEL_13:
  sub_3FA50((int)v9);
  return 0;
}
// 414B0: using guessed type int __fastcall sub_414B0(_DWORD, _DWORD, _DWORD);

//----- (000414B0) --------------------------------------------------------
json_t *__fastcall sub_414B0(int a1, char a2, json_error_t *a3)
{
  int v4; // r3
  size_t n; // [sp+14h] [bp-10h]
  void *s; // [sp+18h] [bp-Ch]
  json_t *v10; // [sp+1Ch] [bp-8h]

  if ( ++*(_DWORD *)(a1 + 56) > 0x800u )
  {
    sub_3FAB8((int)a3, a1, 2, "maximum parsing depth reached");
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 60);
  if ( v4 == 257 )
  {
    v10 = (json_t *)json_integer(*(_QWORD *)(a1 + 64));
  }
  else if ( v4 > 257 )
  {
    if ( v4 == 259 )
    {
      v10 = json_true();
    }
    else if ( v4 < 259 )
    {
      v10 = (json_t *)json_real();
    }
    else if ( v4 == 260 )
    {
      v10 = (json_t *)json_false();
    }
    else
    {
      if ( v4 != 261 )
        goto LABEL_29;
      v10 = (json_t *)json_null();
    }
  }
  else if ( v4 == 91 )
  {
    v10 = sub_41388(a1, a2, a3);
  }
  else
  {
    if ( v4 <= 91 )
    {
      if ( v4 == -1 )
      {
        sub_3FAB8((int)a3, a1, 8, "invalid token");
        return 0;
      }
LABEL_29:
      sub_3FAB8((int)a3, a1, 8, "unexpected token");
      return 0;
    }
    if ( v4 == 123 )
    {
      v10 = sub_41124(a1, a2, a3);
    }
    else
    {
      if ( v4 != 256 )
        goto LABEL_29;
      s = *(void **)(a1 + 64);
      n = *(_DWORD *)(a1 + 68);
      if ( (a2 & 0x10) == 0 && memchr(s, 0, n) )
      {
        sub_3FAB8((int)a3, a1, 11, "\\u0000 is not allowed without JSON_ALLOW_NUL");
        return 0;
      }
      v10 = jsonp_stringn_nocheck_own((const char *)s, n);
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 68) = 0;
    }
  }
  if ( !v10 )
    return 0;
  --*(_DWORD *)(a1 + 56);
  return v10;
}

//----- (0004171C) --------------------------------------------------------
json_t *__fastcall sub_4171C(int a1, char a2, int a3)
{
  json_t *v8; // [sp+14h] [bp-8h]

  *(_DWORD *)(a1 + 56) = 0;
  lex_scan((lex_t *)a1, (json_error_t *)a3);
  if ( (a2 & 4) != 0 || *(_DWORD *)(a1 + 60) == 91 || *(_DWORD *)(a1 + 60) == 123 )
  {
    v8 = sub_414B0(a1, a2, (json_error_t *)a3);
    if ( v8 )
    {
      if ( (a2 & 2) != 0 || (lex_scan((lex_t *)a1, (json_error_t *)a3), !*(_DWORD *)(a1 + 60)) )
      {
        if ( a3 )
          *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 36);
        return v8;
      }
      else
      {
        sub_3FAB8(a3, a1, 7, "end of file expected");
        sub_3FA50((int)v8);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_3FAB8(a3, a1, 8, "'[' or '{' expected");
    return 0;
  }
}

//----- (00041848) --------------------------------------------------------
int __fastcall sub_41848(_DWORD *a1)
{
  unsigned __int8 v3; // [sp+Bh] [bp-9h]

  v3 = *(_BYTE *)(*a1 + a1[1]);
  if ( !v3 )
    return -1;
  ++a1[1];
  return v3;
}

//----- (000418B8) --------------------------------------------------------
json_t *__fastcall json_loads(int a1, int a2, json_error_t *a3)
{
  _DWORD v8[2]; // [sp+10h] [bp-5Ch] BYREF
  _BYTE v9[76]; // [sp+18h] [bp-54h] BYREF
  json_t *v10; // [sp+64h] [bp-8h]

  jsonp_error_init(a3, "<string>");
  if ( a1 )
  {
    v8[0] = a1;
    v8[1] = 0;
    if ( lex_init((int)v9, 268360, a2, (int)v8) )
    {
      return 0;
    }
    else
    {
      v10 = sub_4171C((int)v9, a2, (int)a3);
      lex_close((lex_t *)v9);
      return v10;
    }
  }
  else
  {
    sub_3FAB8((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (0004197C) --------------------------------------------------------
int __cdecl buffer_get(void *data)
{
  if ( *((_DWORD *)data + 2) >= *((_DWORD *)data + 1) )
    return -1;
  return *(unsigned __int8 *)(*(_DWORD *)data + (*((_DWORD *)data + 2))++);
}

//----- (000419F8) --------------------------------------------------------
json_t *__fastcall json_loadb(int a1, int a2, int a3, json_error_t *a4)
{
  _DWORD v10[3]; // [sp+14h] [bp-60h] BYREF
  _BYTE v11[76]; // [sp+20h] [bp-54h] BYREF
  json_t *v12; // [sp+6Ch] [bp-8h]

  jsonp_error_init(a4, "<buffer>");
  if ( a1 )
  {
    v10[0] = a1;
    v10[2] = 0;
    v10[1] = a2;
    if ( lex_init((int)v11, 268668, a3, (int)v10) )
    {
      return 0;
    }
    else
    {
      v12 = sub_4171C((int)v11, a3, (int)a4);
      lex_close((lex_t *)v11);
      return v12;
    }
  }
  else
  {
    sub_3FAB8((int)a4, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (00041AC8) --------------------------------------------------------
json_t *__fastcall json_loadf(int a1, int a2, json_error_t *a3)
{
  _BYTE v8[72]; // [sp+10h] [bp-54h] BYREF
  json_t *v9; // [sp+58h] [bp-Ch]
  const char *v10; // [sp+5Ch] [bp-8h]

  if ( a1 == stdin )
    v10 = "<stdin>";
  else
    v10 = "<stream>";
  jsonp_error_init(a3, v10);
  if ( a1 )
  {
    if ( lex_init((int)v8, (int)fgetc, a2, a1) )
    {
      return 0;
    }
    else
    {
      v9 = sub_4171C((int)v8, a2, (int)a3);
      lex_close((lex_t *)v8);
      return v9;
    }
  }
  else
  {
    sub_3FAB8((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}
// 151278: using guessed type int stdin;

//----- (00041BAC) --------------------------------------------------------
int __fastcall sub_41BAC(int *a1)
{
  unsigned __int8 buf; // [sp+Fh] [bp-5h] BYREF

  if ( read(*a1, &buf, 1u) == 1 )
    return buf;
  else
    return -1;
}

//----- (00041BF8) --------------------------------------------------------
json_t *__fastcall json_loadfd(int a1, int a2, json_error_t *a3)
{
  int v7; // [sp+Ch] [bp-58h] BYREF
  _BYTE v8[72]; // [sp+10h] [bp-54h] BYREF
  json_t *v9; // [sp+58h] [bp-Ch]
  const char *v10; // [sp+5Ch] [bp-8h]

  v7 = a1;
  if ( a1 )
    v10 = "<stream>";
  else
    v10 = "<stdin>";
  jsonp_error_init(a3, v10);
  if ( v7 >= 0 )
  {
    if ( lex_init((int)v8, 269228, a2, (int)&v7) )
    {
      return 0;
    }
    else
    {
      v9 = sub_4171C((int)v8, a2, (int)a3);
      lex_close((lex_t *)v8);
      return v9;
    }
  }
  else
  {
    sub_3FAB8((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (00041CD0) --------------------------------------------------------
json_t *__fastcall json_load_file(const char *a1, int a2, json_error_t *a3)
{
  int *v4; // r0
  char *v5; // r0
  json_t *v10; // [sp+18h] [bp-Ch]
  FILE *stream; // [sp+1Ch] [bp-8h]

  jsonp_error_init(a3, a1);
  if ( a1 )
  {
    stream = fopen(a1, "rb");
    if ( stream )
    {
      v10 = json_loadf((int)stream, a2, a3);
      fclose(stream);
      return v10;
    }
    else
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      sub_3FAB8((int)a3, 0, 3, "unable to open %s: %s", a1, v5);
      return 0;
    }
  }
  else
  {
    sub_3FAB8((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (00041DB0) --------------------------------------------------------
int __fastcall sub_41DB0(int a1)
{
  if ( *(_DWORD *)(a1 + 1028) >= *(_DWORD *)(a1 + 1024) )
  {
    *(_DWORD *)(a1 + 1028) = 0;
    *(_DWORD *)(a1 + 1024) = (*(int (__fastcall **)(int, int, _DWORD))(a1 + 1032))(a1, 1024, *(_DWORD *)(a1 + 1036));
    if ( !*(_DWORD *)(a1 + 1024) || *(_DWORD *)(a1 + 1024) == -1 )
      return -1;
  }
  return *(unsigned __int8 *)(a1 + (*(_DWORD *)(a1 + 1028))++);
}

//----- (00041E74) --------------------------------------------------------
json_t *__fastcall json_load_callback(int a1, int a2, int a3, json_error_t *a4)
{
  _DWORD v10[260]; // [sp+10h] [bp-464h] BYREF
  _BYTE v11[76]; // [sp+420h] [bp-54h] BYREF
  json_t *v12; // [sp+46Ch] [bp-8h]

  memset(v10, 0, sizeof(v10));
  v10[258] = a1;
  v10[259] = a2;
  jsonp_error_init(a4, "<callback>");
  if ( a1 )
  {
    if ( lex_init((int)v11, 269744, a3, (int)v10) )
    {
      return 0;
    }
    else
    {
      v12 = sub_4171C((int)v11, a3, (int)a4);
      lex_close((lex_t *)v11);
      return v12;
    }
  }
  else
  {
    sub_3FAB8((int)a4, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (00041F58) --------------------------------------------------------
void *__cdecl jsonp_malloc(size_t size)
{
  if ( size )
    return off_14DE98(size);
  else
    return 0;
}
// 14DE98: using guessed type void *(*off_14DE98)(size_t size);

//----- (00041FA0) --------------------------------------------------------
void __cdecl jsonp_free(void *ptr)
{
  if ( ptr )
    off_14DE9C(ptr);
}
// 14DE9C: using guessed type void (*off_14DE9C)(void *ptr);

//----- (00041FE0) --------------------------------------------------------
char *__cdecl jsonp_strdup(const char *str)
{
  size_t v1; // r0

  v1 = strlen(str);
  return jsonp_strndup(str, v1);
}

//----- (00042018) --------------------------------------------------------
char *__cdecl jsonp_strndup(const char *str, size_t len)
{
  void *dest; // [sp+Ch] [bp-8h]

  dest = jsonp_malloc(len + 1);
  if ( !dest )
    return 0;
  memcpy(dest, str, len);
  *((_BYTE *)dest + len) = 0;
  return (char *)dest;
}

//----- (00042088) --------------------------------------------------------
void *(*__fastcall json_set_alloc_funcs(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size)
{
  off_14DE98 = result;
  off_14DE9C = a2;
  return result;
}
// 14DE98: using guessed type void *(*off_14DE98)(size_t size);
// 14DE9C: using guessed type void (*off_14DE9C)(void *ptr);

//----- (000420CC) --------------------------------------------------------
_DWORD *__fastcall json_get_alloc_funcs(_DWORD *result, _DWORD *a2)
{
  if ( result )
    *result = off_14DE98;
  if ( a2 )
    *a2 = off_14DE9C;
  return result;
}
// 14DE98: using guessed type void *(*off_14DE98)(size_t size);
// 14DE9C: using guessed type void (*off_14DE9C)(void *ptr);

//----- (00042130) --------------------------------------------------------
int __fastcall sub_42130(int result)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2

  if ( result && *(_DWORD *)(result + 4) != -1 )
  {
    v1 = (unsigned int *)(result + 4);
    do
      v2 = __ldrex(v1);
    while ( __strex(v2 + 1, v1) );
    __dmb(0xBu);
  }
  return result;
}

//----- (00042190) --------------------------------------------------------
void __fastcall sub_42190(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (000421F8) --------------------------------------------------------
void *__fastcall sub_421F8(_DWORD *a1, int a2, int a3, int a4)
{
  void *result; // r0

  a1[14] = a2;
  a1[15] = a3;
  *a1 = a4;
  a1[1] = *a1;
  memset(a1 + 2, 0, 0x10u);
  memset(a1 + 6, 0, 0x10u);
  result = memset(a1 + 10, 0, 0x10u);
  a1[16] = 1;
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = 0;
  return result;
}

//----- (000422CC) --------------------------------------------------------
int __fastcall sub_422CC(_DWORD *a1)
{
  _DWORD *v1; // r12
  _DWORD *v2; // r3
  int result; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r2
  int v9; // r3
  _BYTE *v11; // [sp+Ch] [bp-8h]

  v1 = a1 + 2;
  v2 = a1 + 6;
  result = a1[6];
  v4 = v2[1];
  v5 = v2[2];
  v6 = v2[3];
  *v1 = result;
  v1[1] = v4;
  v1[2] = v5;
  v1[3] = v6;
  if ( a1[10] )
  {
    result = a1[10];
    v7 = a1[11];
    v8 = a1[12];
    v9 = a1[13];
    a1[6] = result;
    a1[7] = v7;
    a1[8] = v8;
    a1[9] = v9;
    a1[10] = 0;
  }
  else if ( *((_BYTE *)a1 + 36) || *(_BYTE *)a1[1] )
  {
    v11 = (_BYTE *)a1[1];
    ++a1[17];
    ++a1[18];
    while ( *v11 == 32 || *v11 == 9 || *v11 == 10 || *v11 == 44 || *v11 == 58 )
    {
      if ( *v11 == 10 )
      {
        ++a1[16];
        a1[17] = 1;
      }
      else
      {
        ++a1[17];
      }
      ++a1[18];
      ++v11;
    }
    *((_BYTE *)a1 + 36) = *v11;
    a1[6] = a1[16];
    a1[7] = a1[17];
    a1[8] = a1[18];
    if ( *v11 )
      ++v11;
    a1[1] = v11;
  }
  return result;
}

//----- (000424BC) --------------------------------------------------------
int __fastcall sub_424BC(_DWORD *a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  _DWORD *v4; // r12
  int result; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3

  v1 = a1[7];
  v2 = a1[8];
  v3 = a1[9];
  a1[10] = a1[6];
  a1[11] = v1;
  a1[12] = v2;
  a1[13] = v3;
  v4 = a1 + 6;
  result = a1[2];
  v6 = a1[3];
  v7 = a1[4];
  v8 = a1[5];
  a1[6] = result;
  v4[1] = v6;
  v4[2] = v7;
  v4[3] = v8;
  return result;
}

//----- (0004250C) --------------------------------------------------------
char *sub_4250C(int *a1, const char *a2, char a3, char *format, ...)
{
  va_list va; // [sp+38h] [bp+8h] BYREF

  va_start(va, format);
  jsonp_error_vset(a1[14], a1[6], a1[7], a1[8], a3, format, va);
  return jsonp_error_set_source((char *)a1[14], a2);
}

//----- (00042598) --------------------------------------------------------
char *__fastcall sub_42598(int a1, char ***a2, const char *a3, size_t *a4, _DWORD *a5, int a6)
{
  char **v6; // r3
  char **v8; // r3
  size_t *v9; // r3
  size_t *v10; // r3
  size_t v11; // r3
  int v17; // [sp+18h] [bp-1Ch] BYREF
  size_t v18; // [sp+1Ch] [bp-18h]
  char *s; // [sp+24h] [bp-10h]
  unsigned __int8 v20; // [sp+2Bh] [bp-9h]
  size_t v21; // [sp+2Ch] [bp-8h]

  sub_422CC((_DWORD *)a1);
  v20 = *(_BYTE *)(a1 + 36);
  sub_424BC((_DWORD *)a1);
  *a5 = 0;
  if ( v20 == 35 || v20 == 37 || v20 == 43 )
  {
    if ( a6 )
    {
      sub_4250C((int *)a1, "<format>", 9, "Cannot use '%c' on optional strings", v20);
      *(_DWORD *)(a1 + 76) = 1;
      return 0;
    }
    else
    {
      if ( strbuffer_init((strbuffer_t *)&v17) )
      {
        sub_4250C((int *)a1, "<internal>", 1, "Out of memory");
        *(_DWORD *)(a1 + 76) = 1;
      }
      do
      {
        v8 = (*a2)++;
        s = *v8;
        if ( !s )
        {
          sub_4250C((int *)a1, "<args>", 12, "NULL %s", a3);
          *(_DWORD *)(a1 + 76) = 1;
        }
        sub_422CC((_DWORD *)a1);
        if ( *(_BYTE *)(a1 + 36) == 35 )
        {
          v9 = (size_t *)(*a2)++;
          v21 = *v9;
        }
        else if ( *(_BYTE *)(a1 + 36) == 37 )
        {
          v10 = (size_t *)(*a2)++;
          v21 = *v10;
        }
        else
        {
          sub_424BC((_DWORD *)a1);
          if ( *(_DWORD *)(a1 + 76) )
            v11 = 0;
          else
            v11 = strlen(s);
          v21 = v11;
        }
        if ( !*(_DWORD *)(a1 + 76) && strbuffer_append_bytes((strbuffer_t *)&v17, s, v21) == -1 )
        {
          sub_4250C((int *)a1, "<internal>", 1, "Out of memory");
          *(_DWORD *)(a1 + 76) = 1;
        }
        sub_422CC((_DWORD *)a1);
      }
      while ( *(_BYTE *)(a1 + 36) == 43 );
      sub_424BC((_DWORD *)a1);
      if ( *(_DWORD *)(a1 + 76) )
      {
        strbuffer_close((strbuffer_t *)&v17);
        return 0;
      }
      else if ( utf8_check_string(v17, v18) )
      {
        *a4 = v18;
        *a5 = 1;
        return (char *)strbuffer_steal_value(&v17);
      }
      else
      {
        sub_4250C((int *)a1, "<args>", 5, "Invalid UTF-8 %s", a3);
        strbuffer_close((strbuffer_t *)&v17);
        *(_DWORD *)(a1 + 76) = 1;
        return 0;
      }
    }
  }
  else
  {
    v6 = (*a2)++;
    s = *v6;
    if ( s )
    {
      v21 = strlen(s);
      if ( utf8_check_string((int)s, v21) )
      {
        *a4 = v21;
        return s;
      }
      else
      {
        sub_4250C((int *)a1, "<args>", 5, "Invalid UTF-8 %s", a3);
        *(_DWORD *)(a1 + 76) = 1;
        return 0;
      }
    }
    else
    {
      if ( !a6 )
      {
        sub_4250C((int *)a1, "<args>", 12, "NULL %s", a3);
        *(_DWORD *)(a1 + 76) = 1;
      }
      return 0;
    }
  }
}

//----- (00042988) --------------------------------------------------------
json_t *__fastcall sub_42988(int a1, char ***a2)
{
  int v6; // [sp+10h] [bp-1Ch] BYREF
  size_t v7; // [sp+14h] [bp-18h] BYREF
  json_t *v8; // [sp+18h] [bp-14h]
  char v9; // [sp+1Fh] [bp-Dh]
  char *v10; // [sp+20h] [bp-Ch]
  json_t *v11; // [sp+24h] [bp-8h]

  v11 = (json_t *)json_object();
  sub_422CC((_DWORD *)a1);
  while ( *(_BYTE *)(a1 + 36) != 125 )
  {
    if ( !*(_BYTE *)(a1 + 36) )
    {
      sub_4250C((int *)a1, "<format>", 9, "Unexpected end of format string");
      goto LABEL_23;
    }
    if ( *(_BYTE *)(a1 + 36) != 115 )
    {
      sub_4250C((int *)a1, "<format>", 9, "Expected format 's', got '%c'", *(unsigned __int8 *)(a1 + 36));
      goto LABEL_23;
    }
    v10 = sub_42598(a1, a2, "object key", &v7, &v6, 0);
    sub_422CC((_DWORD *)a1);
    sub_422CC((_DWORD *)a1);
    v9 = *(_BYTE *)(a1 + 36);
    sub_424BC((_DWORD *)a1);
    v8 = (json_t *)sub_43068(a1, a2);
    if ( v8 )
    {
      if ( *(_DWORD *)(a1 + 76) )
        sub_42190((int)v8);
      if ( !*(_DWORD *)(a1 + 76) && json_object_set_new_nocheck(v11, v10, v8) )
      {
        sub_4250C((int *)a1, "<internal>", 1, "Unable to add key \"%s\"", v10);
        *(_DWORD *)(a1 + 76) = 1;
      }
      if ( v6 )
        jsonp_free(v10);
    }
    else
    {
      if ( v6 )
        jsonp_free(v10);
      if ( v9 != 42 )
      {
        sub_4250C((int *)a1, "<args>", 12, "NULL object value");
        *(_DWORD *)(a1 + 76) = 1;
      }
    }
    sub_422CC((_DWORD *)a1);
  }
  if ( !*(_DWORD *)(a1 + 76) )
    return v11;
LABEL_23:
  sub_42190((int)v11);
  return 0;
}
// 43068: using guessed type int __fastcall sub_43068(_DWORD, _DWORD);

//----- (00042BB8) --------------------------------------------------------
json_t *__fastcall sub_42BB8(int a1, int a2)
{
  json_t *v6; // [sp+Ch] [bp-10h]
  char v7; // [sp+13h] [bp-9h]
  json_t *v8; // [sp+14h] [bp-8h]

  v8 = (json_t *)json_array();
  sub_422CC((_DWORD *)a1);
  while ( *(_BYTE *)(a1 + 36) != 93 )
  {
    if ( !*(_BYTE *)(a1 + 36) )
    {
      sub_4250C((int *)a1, "<format>", 9, "Unexpected end of format string");
      goto LABEL_17;
    }
    sub_422CC((_DWORD *)a1);
    v7 = *(_BYTE *)(a1 + 36);
    sub_424BC((_DWORD *)a1);
    v6 = (json_t *)sub_43068(a1, a2);
    if ( v6 )
    {
      if ( *(_DWORD *)(a1 + 76) )
        sub_42190((int)v6);
      if ( !*(_DWORD *)(a1 + 76) && json_array_append_new(v8, v6) )
      {
        sub_4250C((int *)a1, "<internal>", 1, "Unable to append to array");
        *(_DWORD *)(a1 + 76) = 1;
      }
    }
    else if ( v7 != 42 )
    {
      *(_DWORD *)(a1 + 76) = 1;
    }
    sub_422CC((_DWORD *)a1);
  }
  if ( !*(_DWORD *)(a1 + 76) )
    return v8;
LABEL_17:
  sub_42190((int)v8);
  return 0;
}
// 43068: using guessed type int __fastcall sub_43068(_DWORD, _DWORD);

//----- (00042D20) --------------------------------------------------------
json_t *__fastcall sub_42D20(int a1, char ***a2)
{
  _BOOL4 v2; // r3
  int v7; // [sp+14h] [bp-18h] BYREF
  size_t v8; // [sp+18h] [bp-14h] BYREF
  char *v9; // [sp+1Ch] [bp-10h]
  _BOOL4 v10; // [sp+20h] [bp-Ch]
  char v11; // [sp+27h] [bp-5h]

  sub_422CC((_DWORD *)a1);
  v11 = *(_BYTE *)(a1 + 36);
  v2 = v11 == 63 || v11 == 42;
  v10 = v2;
  if ( !v2 )
    sub_424BC((_DWORD *)a1);
  v9 = sub_42598(a1, a2, "string", &v8, &v7, v10);
  if ( v9 )
  {
    if ( *(_DWORD *)(a1 + 76) )
    {
      return 0;
    }
    else if ( v7 )
    {
      return jsonp_stringn_nocheck_own(v9, v8);
    }
    else
    {
      return (json_t *)json_stringn_nocheck(v9, v8);
    }
  }
  else if ( v11 != 63 || *(_DWORD *)(a1 + 76) )
  {
    return 0;
  }
  else
  {
    return (json_t *)json_null();
  }
}

//----- (00042E4C) --------------------------------------------------------
void *__fastcall sub_42E4C(int a1, int **a2, int a3)
{
  int *v3; // r3
  char v9; // [sp+17h] [bp-5h]

  sub_422CC((_DWORD *)a1);
  v9 = *(_BYTE *)(a1 + 36);
  if ( v9 != 63 && v9 != 42 )
    sub_424BC((_DWORD *)a1);
  v3 = (*a2)++;
  if ( *v3 )
  {
    if ( a3 )
      return (void *)sub_42130(*v3);
    else
      return (void *)*v3;
  }
  else if ( v9 == 42 )
  {
    return 0;
  }
  else if ( v9 == 63 )
  {
    return json_null();
  }
  else
  {
    sub_4250C((int *)a1, "<args>", 12, "NULL object");
    *(_DWORD *)(a1 + 76) = 1;
    return 0;
  }
}

//----- (00042F48) --------------------------------------------------------
_QWORD *__fastcall sub_42F48(int *a1, __int64 a2)
{
  _QWORD *v6; // [sp+14h] [bp-8h]

  v6 = json_integer(a2);
  if ( !v6 )
  {
    sub_4250C(a1, "<internal>", 1, "Out of memory", a2);
    a1[19] = 1;
  }
  return v6;
}

//----- (00042FAC) --------------------------------------------------------
double *__fastcall sub_42FAC(int *a1)
{
  double *v4; // [sp+14h] [bp-8h]

  v4 = json_real();
  if ( v4 )
  {
    if ( json_real_set((int)v4) )
    {
      sub_42190((int)v4);
      sub_4250C(a1, "<args>", 15, "Invalid floating point value");
      a1[19] = 1;
      return 0;
    }
    else
    {
      return v4;
    }
  }
  else
  {
    sub_4250C(a1, "<internal>", 1, "Out of memory");
    a1[19] = 1;
    return 0;
  }
}

//----- (00043068) --------------------------------------------------------
json_t *__fastcall sub_43068(int a1, int **a2)
{
  json_t *v2; // r3
  int *v3; // r3
  int *v4; // r3
  __int64 *v5; // r3

  switch ( *(_BYTE *)(a1 + 36) )
  {
    case 'I':
      v5 = (__int64 *)(((unsigned int)*a2 + 7) & 0xFFFFFFF8);
      *a2 = (int *)(v5 + 1);
      v2 = (json_t *)sub_42F48((int *)a1, *v5);
      break;
    case 'O':
      v2 = (json_t *)sub_42E4C(a1, a2, 1);
      break;
    case '[':
      v2 = sub_42BB8(a1, (int)a2);
      break;
    case 'b':
      v3 = (*a2)++;
      if ( *v3 )
        v2 = json_true();
      else
        v2 = (json_t *)json_false();
      break;
    case 'f':
      *a2 = (int *)((((unsigned int)*a2 + 7) & 0xFFFFFFF8) + 8);
      v2 = (json_t *)sub_42FAC((int *)a1);
      break;
    case 'i':
      v4 = (*a2)++;
      v2 = (json_t *)sub_42F48((int *)a1, *v4);
      break;
    case 'n':
      v2 = (json_t *)json_null();
      break;
    case 'o':
      v2 = (json_t *)sub_42E4C(a1, a2, 0);
      break;
    case 's':
      v2 = sub_42D20(a1, (char ***)a2);
      break;
    case '{':
      v2 = sub_42988(a1, (char ***)a2);
      break;
    default:
      sub_4250C((int *)a1, "<format>", 9, "Unexpected format character '%c'", *(unsigned __int8 *)(a1 + 36));
      *(_DWORD *)(a1 + 76) = 1;
      v2 = 0;
      break;
  }
  return v2;
}
// 43090: control flows out of bounds to 43094

//----- (000432E8) --------------------------------------------------------
int __fastcall sub_432E8(int a1, const json_t *a2, const char ***a3)
{
  int v4; // r3
  int v5; // r3
  const char **v6; // r3
  json_t *v7; // r0
  size_t v8; // r0
  void *v9; // r0
  size_t v10; // r0
  void *v11; // r0
  void *v12; // r0
  void *v13; // r0
  const char *v14; // r3
  _BYTE v19[12]; // [sp+18h] [bp-54h] BYREF
  _DWORD v20[7]; // [sp+24h] [bp-48h] BYREF
  const char *v21; // [sp+40h] [bp-2Ch]
  int v23; // [sp+48h] [bp-24h]
  int appended; // [sp+4Ch] [bp-20h]
  char *s; // [sp+50h] [bp-1Ch]
  int v26; // [sp+54h] [bp-18h]
  json_t *v27; // [sp+58h] [bp-14h]
  int v28; // [sp+5Ch] [bp-10h]
  _BOOL4 v29; // [sp+60h] [bp-Ch]
  int v30; // [sp+64h] [bp-8h]

  v30 = -1;
  v29 = 0;
  v28 = 0;
  if ( hashtable_init((hashtable_t *)v20) )
  {
    sub_4250C((int *)a1, "<internal>", 1, "Out of memory");
    return -1;
  }
  else
  {
    if ( a2 && *(_DWORD *)a2 )
    {
      sub_4250C((int *)a1, "<validation>", 10, "Expected object, got %s", off_DA358[*(_DWORD *)a2]);
    }
    else
    {
      sub_422CC((_DWORD *)a1);
      while ( *(_BYTE *)(a1 + 36) != 125 )
      {
        v26 = 0;
        if ( v29 )
        {
          if ( v29 )
            v4 = 33;
          else
            v4 = 42;
          sub_4250C((int *)a1, "<format>", 9, "Expected '}' after '%c', got '%c'", v4, *(unsigned __int8 *)(a1 + 36));
          goto LABEL_57;
        }
        switch ( *(_BYTE *)(a1 + 36) )
        {
          case 0:
            sub_4250C((int *)a1, "<format>", 9, "Unexpected end of format string");
            goto LABEL_57;
          case 0x21:
          case 0x2A:
            if ( *(_BYTE *)(a1 + 36) == 33 )
              v5 = 1;
            else
              v5 = -1;
            v29 = v5;
            sub_422CC((_DWORD *)a1);
            break;
          case 0x73:
            v6 = (*a3)++;
            v21 = *v6;
            if ( !v21 )
            {
              sub_4250C((int *)a1, "<args>", 12, "NULL object key");
              goto LABEL_57;
            }
            sub_422CC((_DWORD *)a1);
            if ( *(_BYTE *)(a1 + 36) == 63 )
            {
              v28 = 1;
              v26 = 1;
              sub_422CC((_DWORD *)a1);
            }
            if ( a2 )
            {
              v27 = json_object_get(a2, v21);
              if ( !v27 && !v26 )
              {
                sub_4250C((int *)a1, "<validation>", 16, "Object item not found: %s", v21);
                goto LABEL_57;
              }
            }
            else
            {
              v27 = 0;
            }
            if ( sub_43B38(a1, v27, a3) )
              goto LABEL_57;
            v7 = (json_t *)json_null();
            hashtable_set((hashtable_t *)v20, v21, v7);
            sub_422CC((_DWORD *)a1);
            break;
          default:
            sub_4250C((int *)a1, "<format>", 9, "Expected format 's', got '%c'", *(unsigned __int8 *)(a1 + 36));
            goto LABEL_57;
        }
      }
      if ( !v29 )
        v29 = (*(_DWORD *)(a1 + 60) & 2) != 0;
      if ( !a2 || !v29 )
        goto LABEL_56;
      appended = 1;
      v23 = 0;
      if ( v28 || (v8 = json_object_size(a2), v8 != v20[0]) )
      {
        v9 = json_object_iter(a2);
        for ( s = (char *)json_object_iter_key(v9); s; s = (char *)json_object_iter_key(v12) )
        {
          v13 = json_object_key_to_iter(s);
          if ( !json_object_iter_value(v13) )
            break;
          if ( !hashtable_get((hashtable_t *)v20, s) )
          {
            ++v23;
            if ( appended == 1 )
            {
              appended = strbuffer_init((strbuffer_t *)v19);
            }
            else if ( !appended )
            {
              appended = strbuffer_append_bytes((strbuffer_t *)v19, ", ", 2u);
            }
            if ( !appended )
            {
              v10 = strlen(s);
              appended = strbuffer_append_bytes((strbuffer_t *)v19, s, v10);
            }
          }
          v11 = json_object_key_to_iter(s);
          v12 = json_object_iter_next(a2, v11);
        }
      }
      if ( v23 )
      {
        if ( appended )
          v14 = "<unknown>";
        else
          v14 = strbuffer_value((const strbuffer_t *)v19);
        sub_4250C((int *)a1, "<validation>", 7, "%li object item(s) left unpacked: %s", v23, v14);
        strbuffer_close((strbuffer_t *)v19);
      }
      else
      {
LABEL_56:
        v30 = 0;
      }
    }
LABEL_57:
    hashtable_close((hashtable_t *)v20);
    return v30;
  }
}
// 43368: conditional instruction was optimized away because %var_58.4!=0
// 43B38: using guessed type int __fastcall sub_43B38(_DWORD, _DWORD, _DWORD);
// DA358: using guessed type char *off_DA358[8];

//----- (0004381C) --------------------------------------------------------
int __fastcall sub_4381C(int a1, const json_t *a2, int a3)
{
  int v4; // r3
  int v5; // r3
  int v6; // r0
  size_t v11; // [sp+18h] [bp-14h]
  json_t *v12; // [sp+1Ch] [bp-10h]
  _BOOL4 v13; // [sp+20h] [bp-Ch]
  size_t v14; // [sp+24h] [bp-8h]

  v14 = 0;
  v13 = 0;
  if ( !a2 || *(_DWORD *)a2 == 1 )
  {
    sub_422CC((_DWORD *)a1);
    while ( *(_BYTE *)(a1 + 36) != 93 )
    {
      if ( v13 )
      {
        if ( v13 )
          v4 = 33;
        else
          v4 = 42;
        sub_4250C((int *)a1, "<format>", 9, "Expected ']' after '%c', got '%c'", v4, *(unsigned __int8 *)(a1 + 36));
        return -1;
      }
      if ( !*(_BYTE *)(a1 + 36) )
      {
        sub_4250C((int *)a1, "<format>", 9, "Unexpected end of format string");
        return -1;
      }
      if ( *(_BYTE *)(a1 + 36) == 33 || *(_BYTE *)(a1 + 36) == 42 )
      {
        if ( *(_BYTE *)(a1 + 36) == 33 )
          v5 = 1;
        else
          v5 = -1;
        v13 = v5;
        sub_422CC((_DWORD *)a1);
      }
      else
      {
        if ( !strchr("{[siIbfFOon", *(unsigned __int8 *)(a1 + 36)) )
        {
          sub_4250C((int *)a1, "<format>", 9, "Unexpected format character '%c'", *(unsigned __int8 *)(a1 + 36));
          return -1;
        }
        if ( a2 )
        {
          v12 = json_array_get(a2, v14);
          if ( !v12 )
          {
            sub_4250C((int *)a1, "<validation>", 17, "Array index %lu out of range", v14);
            return -1;
          }
          v6 = sub_43B38(a1, v12, a3);
        }
        else
        {
          v6 = sub_43B38(a1, 0, a3);
        }
        if ( v6 )
          return -1;
        sub_422CC((_DWORD *)a1);
        ++v14;
      }
    }
    if ( !v13 )
      v13 = (*(_DWORD *)(a1 + 60) & 2) != 0;
    if ( a2 && v13 && v14 != json_array_size(a2) )
    {
      v11 = json_array_size(a2) - v14;
      sub_4250C((int *)a1, "<validation>", 7, "%li array item(s) left unpacked", v11);
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_4250C((int *)a1, "<validation>", 10, "Expected array, got %s", off_DA358[*(_DWORD *)a2]);
    return -1;
  }
}
// 43B38: using guessed type int __fastcall sub_43B38(_DWORD, _DWORD, _DWORD);
// DA358: using guessed type char *off_DA358[8];

//----- (00043B38) --------------------------------------------------------
int __fastcall sub_43B38(int a1, const json_t *a2, const char ***a3)
{
  __int64 v3; // d0
  const char ***v5; // r3
  size_t **v6; // r3
  const char **v7; // r3
  __int64 **v8; // r3
  const char **v9; // r3
  const char **v10; // r3
  const char **v11; // r3
  const char **v12; // r3
  char *v17; // [sp+18h] [bp-24h]
  __int64 *v18; // [sp+1Ch] [bp-20h]
  char *v19; // [sp+28h] [bp-14h]
  char *v20; // [sp+2Ch] [bp-10h]
  const char **v21; // [sp+30h] [bp-Ch]
  size_t *v22; // [sp+34h] [bp-8h]

  switch ( *(_BYTE *)(a1 + 36) )
  {
    case 'F':
      if ( !a2 || *(_DWORD *)a2 == 3 || *(_DWORD *)a2 == 4 )
      {
        if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
        {
          v11 = (*a3)++;
          v17 = (char *)*v11;
          if ( a2 )
          {
            json_number_value(a2);
            *(_QWORD *)v17 = v3;
          }
        }
        return 0;
      }
      else
      {
        sub_4250C((int *)a1, "<validation>", 10, "Expected real or integer, got %s", off_DA358[*(_DWORD *)a2]);
        return -1;
      }
    case 'I':
      if ( a2 && *(_DWORD *)a2 != 3 )
        goto LABEL_20;
      if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
      {
        v8 = (__int64 **)(*a3)++;
        if ( a2 )
        {
          v18 = *v8;
          *v18 = json_integer_value((int)a2);
        }
      }
      return 0;
    case 'O':
      if ( a2 && (*(_DWORD *)(a1 + 60) & 1) == 0 )
        sub_42130((int)a2);
      goto LABEL_57;
    case '[':
      return sub_4381C(a1, a2, (int)a3);
    case 'b':
      if ( !a2 || *(_DWORD *)a2 == 5 || *(_DWORD *)a2 == 6 )
      {
        if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
        {
          v9 = (*a3)++;
          if ( a2 )
            *(_DWORD *)*v9 = *(_DWORD *)a2 == 5;
        }
        return 0;
      }
      else
      {
        sub_4250C((int *)a1, "<validation>", 10, "Expected true or false, got %s", off_DA358[*(_DWORD *)a2]);
        return -1;
      }
    case 'f':
      if ( !a2 || *(_DWORD *)a2 == 4 )
      {
        if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
        {
          v10 = (*a3)++;
          v19 = (char *)*v10;
          if ( a2 )
          {
            json_real_value();
            *(_QWORD *)v19 = v3;
          }
        }
        return 0;
      }
      else
      {
        sub_4250C((int *)a1, "<validation>", 10, "Expected real, got %s", off_DA358[*(_DWORD *)a2]);
        return -1;
      }
    case 'i':
      if ( !a2 || *(_DWORD *)a2 == 3 )
      {
        if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
        {
          v7 = (*a3)++;
          if ( a2 )
          {
            v20 = (char *)*v7;
            *(_DWORD *)v20 = json_integer_value((int)a2);
          }
        }
        return 0;
      }
      else
      {
LABEL_20:
        sub_4250C((int *)a1, "<validation>", 10, "Expected integer, got %s", off_DA358[*(_DWORD *)a2]);
        return -1;
      }
    case 'n':
      if ( !a2 || *(_DWORD *)a2 == 7 )
        return 0;
      sub_4250C((int *)a1, "<validation>", 10, "Expected null, got %s", off_DA358[*(_DWORD *)a2]);
      return -1;
    case 'o':
LABEL_57:
      if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
      {
        v12 = (*a3)++;
        if ( a2 )
          *(_DWORD *)*v12 = a2;
      }
      return 0;
    case 's':
      if ( a2 && *(_DWORD *)a2 != 2 )
      {
        sub_4250C((int *)a1, "<validation>", 10, "Expected string, got %s", off_DA358[*(_DWORD *)a2]);
        return -1;
      }
      if ( (*(_DWORD *)(a1 + 60) & 1) != 0 )
        return 0;
      v22 = 0;
      v5 = (const char ***)(*a3)++;
      v21 = *v5;
      if ( !*v5 )
      {
        sub_4250C((int *)a1, "<args>", 12, "NULL string argument");
        return -1;
      }
      sub_422CC((_DWORD *)a1);
      if ( *(_BYTE *)(a1 + 36) == 37 )
      {
        v6 = (size_t **)(*a3)++;
        v22 = *v6;
        if ( !*v6 )
        {
          sub_4250C((int *)a1, "<args>", 12, "NULL string length argument");
          return -1;
        }
      }
      else
      {
        sub_424BC((_DWORD *)a1);
      }
      if ( a2 )
      {
        *v21 = json_string_value(a2);
        if ( v22 )
          *v22 = json_string_length(a2);
      }
      return 0;
    case '{':
      return sub_432E8(a1, a2, a3);
    default:
      sub_4250C((int *)a1, "<format>", 9, "Unexpected format character '%c'", *(unsigned __int8 *)(a1 + 36));
      return -1;
  }
}
// 43B64: control flows out of bounds to 43B68
// 43C84: conditional instruction was optimized away because %var_28.4!=0
// 43E04: conditional instruction was optimized away because %var_28.4!=0
// 43EC4: conditional instruction was optimized away because %var_28.4!=0
// 43F84: conditional instruction was optimized away because %var_28.4!=0
// 43FA0: conditional instruction was optimized away because %var_28.4!=0
// 44034: conditional instruction was optimized away because %var_28.4!=0
// 44078: conditional instruction was optimized away because %var_28.4!=0
// 44134: conditional instruction was optimized away because %var_28.4!=0
// 44150: conditional instruction was optimized away because %var_28.4!=0
// 44284: conditional instruction was optimized away because %var_28.4!=0
// 44114: variable 'v3' is possibly undefined
// DA358: using guessed type char *off_DA358[8];

//----- (00044314) --------------------------------------------------------
json_t *__fastcall json_vpack_ex(json_error_t *a1, int a2, _BYTE *a3, int *a4)
{
  int *v10; // [sp+18h] [bp-5Ch] BYREF
  int v11[9]; // [sp+1Ch] [bp-58h] BYREF
  char v12; // [sp+40h] [bp-34h]
  json_t *v13; // [sp+6Ch] [bp-8h]

  if ( a3 && *a3 )
  {
    jsonp_error_init(a1, 0);
    sub_421F8(v11, (int)a1, a2, (int)a3);
    sub_422CC(v11);
    v10 = a4;
    v13 = sub_43068((int)v11, &v10);
    if ( v13 )
    {
      sub_422CC(v11);
      if ( v12 )
      {
        sub_42190((int)v13);
        sub_4250C(v11, "<format>", 9, "Garbage after format string");
        return 0;
      }
      else
      {
        return v13;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    jsonp_error_init(a1, "<format>");
    jsonp_error_set((int)a1, -1, -1, 0, 4, "NULL or empty format string");
    return 0;
  }
}

//----- (00044440) --------------------------------------------------------
json_t *json_pack_ex(json_error_t *a1, int a2, _BYTE *a3, ...)
{
  va_list varg_r3; // [sp+1Ch] [bp+8h] BYREF

  va_start(varg_r3, a3);
  return json_vpack_ex(a1, a2, a3, (int *)varg_r3);
}

//----- (00044490) --------------------------------------------------------
json_t *json_pack(_BYTE *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  return json_vpack_ex(0, 0, a1, (int *)varg_r1);
}

//----- (000444D8) --------------------------------------------------------
int __fastcall json_vunpack_ex(const json_t *a1, json_error_t *a2, int a3, _BYTE *a4, const char **a5)
{
  const char **v11; // [sp+1Ch] [bp-58h] BYREF
  int v12[9]; // [sp+20h] [bp-54h] BYREF
  char v13; // [sp+44h] [bp-30h]

  if ( a1 )
  {
    if ( a4 && *a4 )
    {
      jsonp_error_init(a2, 0);
      sub_421F8(v12, (int)a2, a3, (int)a4);
      sub_422CC(v12);
      v11 = a5;
      if ( sub_43B38((int)v12, a1, &v11) )
      {
        return -1;
      }
      else
      {
        sub_422CC(v12);
        if ( v13 )
        {
          sub_4250C(v12, "<format>", 9, "Garbage after format string");
          return -1;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      jsonp_error_init(a2, "<format>");
      jsonp_error_set((int)a2, -1, -1, 0, 4, "NULL or empty format string");
      return -1;
    }
  }
  else
  {
    jsonp_error_init(a2, "<root>");
    jsonp_error_set((int)a2, -1, -1, 0, 12, "NULL root value");
    return -1;
  }
}

//----- (00044644) --------------------------------------------------------
int json_unpack_ex(const json_t *a1, json_error_t *a2, int a3, _BYTE *a4, ...)
{
  va_list va; // [sp+30h] [bp+8h] BYREF

  va_start(va, a4);
  return json_vunpack_ex(a1, a2, a3, a4, (const char **)va);
}

//----- (000446A0) --------------------------------------------------------
int json_unpack(const json_t *a1, _BYTE *a2, ...)
{
  va_list varg_r2; // [sp+28h] [bp+8h] BYREF

  va_start(varg_r2, a2);
  return json_vunpack_ex(a1, 0, 0, a2, (const char **)varg_r2);
}

//----- (000446F4) --------------------------------------------------------
int __cdecl strbuffer_init(strbuffer_t *strbuff)
{
  *((_DWORD *)strbuff + 2) = 16;
  *((_DWORD *)strbuff + 1) = 0;
  *(_DWORD *)strbuff = jsonp_malloc(*((_DWORD *)strbuff + 2));
  if ( !*(_DWORD *)strbuff )
    return -1;
  **(_BYTE **)strbuff = 0;
  return 0;
}

//----- (00044770) --------------------------------------------------------
void __cdecl strbuffer_close(strbuffer_t *strbuff)
{
  if ( *(_DWORD *)strbuff )
    jsonp_free(*(void **)strbuff);
  *((_DWORD *)strbuff + 2) = 0;
  *((_DWORD *)strbuff + 1) = 0;
  *(_DWORD *)strbuff = 0;
}

//----- (000447D0) --------------------------------------------------------
void __cdecl strbuffer_clear(strbuffer_t *strbuff)
{
  *((_DWORD *)strbuff + 1) = 0;
  **(_BYTE **)strbuff = 0;
}

//----- (0004480C) --------------------------------------------------------
const char *__cdecl strbuffer_value(const strbuffer_t *strbuff)
{
  return *(const char **)strbuff;
}

//----- (00044834) --------------------------------------------------------
int __fastcall strbuffer_steal_value(int *a1)
{
  int v2; // [sp+Ch] [bp-8h]

  v2 = *a1;
  *a1 = 0;
  return v2;
}

//----- (00044870) --------------------------------------------------------
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, char byte)
{
  char v3; // [sp+3h] [bp-9h] BYREF
  strbuffer_t *v4; // [sp+4h] [bp-8h]

  v4 = strbuff;
  v3 = byte;
  return strbuffer_append_bytes(strbuff, &v3, 1u);
}

//----- (000448AC) --------------------------------------------------------
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const char *data, size_t size)
{
  size_t v4; // r3
  void *dest; // [sp+10h] [bp-Ch]
  size_t v10; // [sp+14h] [bp-8h]

  if ( size < *((_DWORD *)strbuff + 2) - *((_DWORD *)strbuff + 1) )
    goto LABEL_11;
  if ( *((int *)strbuff + 2) >= 0 && size != -1 && *((_DWORD *)strbuff + 1) <= -2 - size )
  {
    v4 = 2 * *((_DWORD *)strbuff + 2);
    if ( *((_DWORD *)strbuff + 1) + size + 1 >= v4 )
      v4 = *((_DWORD *)strbuff + 1) + size + 1;
    v10 = v4;
    dest = jsonp_malloc(v4);
    if ( !dest )
      return -1;
    memcpy(dest, *(const void **)strbuff, *((_DWORD *)strbuff + 1));
    jsonp_free(*(void **)strbuff);
    *(_DWORD *)strbuff = dest;
    *((_DWORD *)strbuff + 2) = v10;
LABEL_11:
    memcpy((void *)(*(_DWORD *)strbuff + *((_DWORD *)strbuff + 1)), data, size);
    *((_DWORD *)strbuff + 1) += size;
    *(_BYTE *)(*(_DWORD *)strbuff + *((_DWORD *)strbuff + 1)) = 0;
    return 0;
  }
  return -1;
}

//----- (00044A24) --------------------------------------------------------
char __cdecl strbuffer_pop(strbuffer_t *strbuff)
{
  int v1; // r2
  char v4; // [sp+Fh] [bp-5h]

  if ( !*((_DWORD *)strbuff + 1) )
    return 0;
  v1 = *(_DWORD *)strbuff;
  --*((_DWORD *)strbuff + 1);
  v4 = *(_BYTE *)(v1 + *((_DWORD *)strbuff + 1));
  *(_BYTE *)(*(_DWORD *)strbuff + *((_DWORD *)strbuff + 1)) = 0;
  return v4;
}

//----- (00044AB0) --------------------------------------------------------
void __cdecl to_locale(strbuffer_t *strbuffer)
{
  struct lconv *v1; // r0
  char *v3; // [sp+8h] [bp-Ch]
  char *decimal_point; // [sp+Ch] [bp-8h]

  v1 = localeconv();
  decimal_point = v1->decimal_point;
  if ( *v1->decimal_point != 46 )
  {
    v3 = strchr(*(const char **)strbuffer, 46);
    if ( v3 )
      *v3 = *decimal_point;
  }
}

//----- (00044B24) --------------------------------------------------------
void __cdecl from_locale(char *buffer)
{
  struct lconv *v1; // r0
  char *v3; // [sp+8h] [bp-Ch]

  v1 = localeconv();
  if ( *v1->decimal_point != 46 )
  {
    v3 = strchr(buffer, *(unsigned __int8 *)v1->decimal_point);
    if ( v3 )
      *v3 = 46;
  }
}

//----- (00044B94) --------------------------------------------------------
int __fastcall jsonp_strtod(strbuffer_t *a1, double *a2)
{
  double v2; // d0
  char *endptr; // [sp+Ch] [bp-10h] BYREF
  double v8; // [sp+10h] [bp-Ch]

  to_locale(a1);
  *_errno_location() = 0;
  strtod(*(const char **)a1, &endptr);
  v8 = v2;
  if ( (v2 > 1.79769313e308 || v8 < -1.79769313e308) && *_errno_location() == 34 )
    return -1;
  *a2 = v8;
  return 0;
}
// 44BD8: variable 'v2' is possibly undefined

//----- (00044C50) --------------------------------------------------------
int __cdecl jsonp_dtostr(char *buffer, size_t size, double value, int precision)
{
  double v4; // d0
  int v7; // [sp+Ch] [bp-28h]
  signed int v10; // [sp+20h] [bp-14h]
  int v11; // [sp+24h] [bp-10h]
  _BYTE *src; // [sp+28h] [bp-Ch]
  char *dest; // [sp+2Ch] [bp-8h]
  _BYTE *desta; // [sp+2Ch] [bp-8h]

  v7 = LODWORD(value);
  if ( !LODWORD(value) )
    v7 = 17;
  v10 = snprintf(buffer, size, "%.*g", v7, v4);
  if ( v10 < 0 )
    return -1;
  v11 = v10;
  if ( v10 >= size )
    return -1;
  from_locale(buffer);
  if ( !strchr(buffer, 46) && !strchr(buffer, 101) )
  {
    if ( size <= v10 + 3 )
      return -1;
    buffer[v10] = 46;
    buffer[v10 + 1] = 48;
    buffer[v10 + 2] = 0;
    v11 = v10 + 2;
  }
  dest = strchr(buffer, 101);
  if ( dest )
  {
    desta = dest + 1;
    src = desta + 1;
    if ( *desta == 45 )
      ++desta;
    while ( *src == 48 )
      ++src;
    if ( src != desta )
    {
      memmove(desta, src, v11 - (src - buffer));
      v11 -= src - desta;
    }
  }
  return v11;
}
// 44C9C: variable 'v4' is possibly undefined

//----- (00044E50) --------------------------------------------------------
int __cdecl utf8_encode(int32_t codepoint, char *buffer, size_t *size)
{
  if ( codepoint >= 0 )
  {
    if ( codepoint > 127 )
    {
      if ( codepoint >= 2048 )
      {
        if ( codepoint >= 0x10000 )
        {
          if ( codepoint >= 1114112 )
            return -1;
          *buffer = ((codepoint >> 18) & 7) - 16;
          buffer[1] = ((codepoint >> 12) & 0x3F) + 0x80;
          buffer[2] = ((codepoint >> 6) & 0x3F) + 0x80;
          buffer[3] = (codepoint & 0x3F) + 0x80;
          *size = 4;
        }
        else
        {
          *buffer = ((codepoint >> 12) & 0xF) - 32;
          buffer[1] = ((codepoint >> 6) & 0x3F) + 0x80;
          buffer[2] = (codepoint & 0x3F) + 0x80;
          *size = 3;
        }
      }
      else
      {
        *buffer = ((codepoint >> 6) & 0x1F) - 64;
        buffer[1] = (codepoint & 0x3F) + 0x80;
        *size = 2;
      }
    }
    else
    {
      *buffer = codepoint;
      *size = 1;
    }
    return 0;
  }
  return -1;
}

//----- (00045068) --------------------------------------------------------
size_t __cdecl utf8_check_first(char byte)
{
  if ( byte >= 0 )
    return 1;
  if ( (unsigned __int8)byte <= 0xBFu )
    return 0;
  if ( (unsigned __int8)byte == 192 || (unsigned __int8)byte == 193 )
    return 0;
  if ( (unsigned __int8)byte > 0xC1u && (unsigned __int8)byte <= 0xDFu )
    return 2;
  if ( (unsigned __int8)byte > 0xDFu && (unsigned __int8)byte <= 0xEFu )
    return 3;
  if ( (unsigned __int8)byte <= 0xEFu || (unsigned __int8)byte > 0xF4u )
    return 0;
  return 4;
}

//----- (0004514C) --------------------------------------------------------
size_t __cdecl utf8_check_full(const char *buffer, size_t size, int32_t *codepoint)
{
  _BYTE v5[5]; // [sp+17h] [bp-Dh]
  size_t i; // [sp+1Ch] [bp-8h]

  *(_DWORD *)v5 = *(unsigned __int8 *)buffer;
  switch ( size )
  {
    case 2u:
      *(_DWORD *)&v5[1] = v5[0] & 0x1F;
      break;
    case 3u:
      *(_DWORD *)&v5[1] = v5[0] & 0xF;
      break;
    case 4u:
      *(_DWORD *)&v5[1] = v5[0] & 7;
      break;
    default:
      return 0;
  }
  for ( i = 1; i < size; ++i )
  {
    v5[0] = buffer[i];
    if ( v5[0] >= 0 || v5[0] > 0xBFu )
      return 0;
    *(_DWORD *)&v5[1] = (*(_DWORD *)&v5[1] << 6) + (v5[0] & 0x3F);
  }
  if ( *(int *)&v5[1] >= 1114112 )
    return 0;
  if ( *(int *)&v5[1] >= 55296 && *(int *)&v5[1] < 57344 )
    return 0;
  if ( size == 2 && *(int *)&v5[1] <= 127 || size == 3 && *(int *)&v5[1] < 2048 || size == 4 && *(int *)&v5[1] < 0x10000 )
    return 0;
  if ( codepoint )
    *codepoint = *(_DWORD *)&v5[1];
  return 1;
}

//----- (000452F8) --------------------------------------------------------
const char *__cdecl utf8_iterate(const char *buffer, size_t bufsize, int32_t *codepoint)
{
  int32_t v8; // [sp+10h] [bp-Ch] BYREF
  size_t v9; // [sp+14h] [bp-8h]

  if ( !bufsize )
    return buffer;
  v9 = utf8_check_first(*buffer);
  if ( !v9 )
    return 0;
  if ( v9 == 1 )
  {
    v8 = *(unsigned __int8 *)buffer;
  }
  else if ( v9 > bufsize || !utf8_check_full(buffer, v9, &v8) )
  {
    return 0;
  }
  if ( codepoint )
    *codepoint = v8;
  return &buffer[v9];
}

//----- (000453D0) --------------------------------------------------------
int __fastcall utf8_check_string(int a1, unsigned int a2)
{
  unsigned int v6; // [sp+8h] [bp-Ch]
  unsigned int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i < a2; ++i )
  {
    v6 = utf8_check_first(*(_BYTE *)(a1 + i));
    if ( !v6 )
      return 0;
    if ( v6 > 1 )
    {
      if ( v6 > a2 - i )
        return 0;
      if ( !utf8_check_full((const char *)(a1 + i), v6, 0) )
        return 0;
      i = v6 + i - 1;
    }
  }
  return 1;
}

//----- (000454C0) --------------------------------------------------------
int __fastcall sub_454C0(int result)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2

  if ( result && *(_DWORD *)(result + 4) != -1 )
  {
    v1 = (unsigned int *)(result + 4);
    do
      v2 = __ldrex(v1);
    while ( __strex(v2 + 1, v1) );
    __dmb(0xBu);
  }
  return result;
}

//----- (00045520) --------------------------------------------------------
void __fastcall sub_45520(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (00045588) --------------------------------------------------------
int __cdecl json_object_set_nocheck(json_t *object, const char *key, json_t *value)
{
  json_t *v3; // r0

  v3 = (json_t *)sub_454C0((int)value);
  return json_object_set_new_nocheck(object, key, v3);
}

//----- (000455CC) --------------------------------------------------------
int __cdecl json_array_append(json_t *array, json_t *value)
{
  json_t *v2; // r0

  v2 = (json_t *)sub_454C0((int)value);
  return json_array_append_new(array, v2);
}

//----- (00045608) --------------------------------------------------------
_DWORD *__fastcall json_init(_DWORD *result, int a2)
{
  *result = a2;
  result[1] = 1;
  return result;
}
// 45608: invalid function type 'void __cdecl json_init(json_t *json, json_type type)' has been ignored

//----- (00045644) --------------------------------------------------------
char *json_object()
{
  char *v2; // [sp+4h] [bp-8h]

  v2 = (char *)jsonp_malloc(0x24u);
  if ( !v2 )
    return 0;
  if ( !hashtable_seed )
    json_object_seed(0);
  json_init(v2, 0);
  if ( !hashtable_init((hashtable_t *)(v2 + 8)) )
    return v2;
  jsonp_free(v2);
  return 0;
}
// 15232C: using guessed type int hashtable_seed;

//----- (000456D8) --------------------------------------------------------
void __cdecl json_delete_object(json_object_t *object)
{
  hashtable_close((json_object_t *)((char *)object + 8));
  jsonp_free(object);
}

//----- (0004570C) --------------------------------------------------------
size_t __cdecl json_object_size(const json_t *json)
{
  if ( json && !*(_DWORD *)json )
    return *((_DWORD *)json + 2);
  else
    return 0;
}

//----- (00045760) --------------------------------------------------------
json_t *__cdecl json_object_get(const json_t *json, const char *key)
{
  if ( key && json && !*(_DWORD *)json )
    return (json_t *)hashtable_get((const json_t *)((char *)json + 8), key);
  else
    return 0;
}

//----- (000457D0) --------------------------------------------------------
int __cdecl json_object_set_new_nocheck(json_t *json, const char *key, json_t *value)
{
  if ( !value )
    return -1;
  if ( key && json && !*(_DWORD *)json && json != value && !hashtable_set((json_t *)((char *)json + 8), key, value) )
    return 0;
  sub_45520((int)value);
  return -1;
}

//----- (00045890) --------------------------------------------------------
int __fastcall json_object_set_new(json_t *a1, const char *a2, json_t *a3)
{
  size_t v3; // r0

  if ( a2 )
  {
    v3 = strlen(a2);
    if ( utf8_check_string((int)a2, v3) )
      return json_object_set_new_nocheck(a1, a2, a3);
  }
  sub_45520((int)a3);
  return -1;
}

//----- (00045908) --------------------------------------------------------
int __fastcall json_object_del(_DWORD *a1, char *a2)
{
  if ( a2 && a1 && !*a1 )
    return hashtable_del((int)(a1 + 2), a2);
  else
    return -1;
}

//----- (00045978) --------------------------------------------------------
int __fastcall json_object_clear(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return -1;
  hashtable_clear((int)(a1 + 2));
  return 0;
}

//----- (000459D4) --------------------------------------------------------
int __fastcall json_object_update(json_t *a1, json_t *a2)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  json_t *v10; // [sp+8h] [bp-Ch]
  const char *i; // [sp+Ch] [bp-8h]

  if ( !a1 || *(_DWORD *)a1 || !a2 || *(_DWORD *)a2 )
    return -1;
  v3 = json_object_iter(a2);
  for ( i = json_object_iter_key(v3); i; i = json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(i);
    v10 = (json_t *)json_object_iter_value(v6);
    if ( !v10 )
      break;
    if ( json_object_set_nocheck(a1, i, v10) )
      return -1;
    v4 = json_object_key_to_iter(i);
    v5 = json_object_iter_next(a2, v4);
  }
  return 0;
}

//----- (00045AD0) --------------------------------------------------------
int __fastcall json_object_update_existing(json_t *a1, json_t *a2)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  json_t *v10; // [sp+8h] [bp-Ch]
  const char *i; // [sp+Ch] [bp-8h]

  if ( !a1 || *(_DWORD *)a1 || !a2 || *(_DWORD *)a2 )
    return -1;
  v3 = json_object_iter(a2);
  for ( i = json_object_iter_key(v3); i; i = json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(i);
    v10 = (json_t *)json_object_iter_value(v6);
    if ( !v10 )
      break;
    if ( json_object_get(a1, i) )
      json_object_set_nocheck(a1, i, v10);
    v4 = json_object_key_to_iter(i);
    v5 = json_object_iter_next(a2, v4);
  }
  return 0;
}

//----- (00045BD0) --------------------------------------------------------
int __fastcall json_object_update_missing(json_t *a1, json_t *a2)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  json_t *v10; // [sp+8h] [bp-Ch]
  const char *i; // [sp+Ch] [bp-8h]

  if ( !a1 || *(_DWORD *)a1 || !a2 || *(_DWORD *)a2 )
    return -1;
  v3 = json_object_iter(a2);
  for ( i = json_object_iter_key(v3); i; i = json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(i);
    v10 = (json_t *)json_object_iter_value(v6);
    if ( !v10 )
      break;
    if ( !json_object_get(a1, i) )
      json_object_set_nocheck(a1, i, v10);
    v4 = json_object_key_to_iter(i);
    v5 = json_object_iter_next(a2, v4);
  }
  return 0;
}

//----- (00045CD0) --------------------------------------------------------
void *__cdecl json_object_iter(json_t *json)
{
  if ( json && !*(_DWORD *)json )
    return hashtable_iter((json_t *)((char *)json + 8));
  else
    return 0;
}

//----- (00045D2C) --------------------------------------------------------
char *__fastcall json_object_iter_at(_DWORD *a1, char *a2)
{
  if ( a2 && a1 && !*a1 )
    return hashtable_iter_at((int)(a1 + 2), a2);
  else
    return 0;
}

//----- (00045D9C) --------------------------------------------------------
void *__cdecl json_object_iter_next(json_t *json, void *iter)
{
  if ( json && !*(_DWORD *)json && iter )
    return hashtable_iter_next((json_t *)((char *)json + 8), iter);
  else
    return 0;
}

//----- (00045E0C) --------------------------------------------------------
const char *__cdecl json_object_iter_key(void *iter)
{
  if ( iter )
    return (const char *)hashtable_iter_key(iter);
  else
    return 0;
}

//----- (00045E48) --------------------------------------------------------
void *__fastcall json_object_iter_value(void *a1)
{
  if ( a1 )
    return hashtable_iter_value(a1);
  else
    return 0;
}

//----- (00045E84) --------------------------------------------------------
int __fastcall json_object_iter_set_new(_DWORD *a1, int a2, int a3)
{
  if ( a1 && !*a1 && a2 && a3 )
  {
    hashtable_iter_set(a2, a3);
    return 0;
  }
  else
  {
    sub_45520(a3);
    return -1;
  }
}

//----- (00045EFC) --------------------------------------------------------
void *__cdecl json_object_key_to_iter(const char *key)
{
  if ( key )
    return (void *)(key - 16);
  else
    return 0;
}

//----- (00045F3C) --------------------------------------------------------
int __fastcall sub_45F3C(const json_t *a1, const json_t *a2)
{
  size_t v2; // r4
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0
  json_t *v11; // [sp+Ch] [bp-18h]
  const json_t *v12; // [sp+10h] [bp-14h]
  const char *i; // [sp+14h] [bp-10h]

  v2 = json_object_size(a1);
  if ( v2 != json_object_size(a2) )
    return 0;
  v4 = json_object_iter(a1);
  for ( i = json_object_iter_key(v4); i; i = json_object_iter_key(v6) )
  {
    v7 = json_object_key_to_iter(i);
    v12 = (const json_t *)json_object_iter_value(v7);
    if ( !v12 )
      break;
    v11 = json_object_get(a2, i);
    if ( !json_equal(v12, v11) )
      return 0;
    v5 = json_object_key_to_iter(i);
    v6 = json_object_iter_next(a1, v5);
  }
  return 1;
}

//----- (0004602C) --------------------------------------------------------
char *__fastcall sub_4602C(json_t *a1)
{
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  json_t *v8; // [sp+Ch] [bp-10h]
  char *v9; // [sp+10h] [bp-Ch]
  const char *i; // [sp+14h] [bp-8h]

  v9 = json_object();
  if ( !v9 )
    return 0;
  v2 = json_object_iter(a1);
  for ( i = json_object_iter_key(v2); i; i = json_object_iter_key(v4) )
  {
    v5 = json_object_key_to_iter(i);
    v8 = (json_t *)json_object_iter_value(v5);
    if ( !v8 )
      break;
    json_object_set_nocheck((json_t *)v9, i, v8);
    v3 = json_object_key_to_iter(i);
    v4 = json_object_iter_next(a1, v3);
  }
  return v9;
}

//----- (000460EC) --------------------------------------------------------
char *__fastcall sub_460EC(json_t *a1)
{
  json_t *v2; // r0
  const json_t *v5; // [sp+8h] [bp-14h]
  const char *v6; // [sp+Ch] [bp-10h]
  char *v7; // [sp+10h] [bp-Ch]
  void *i; // [sp+14h] [bp-8h]

  v7 = json_object();
  if ( !v7 )
    return 0;
  for ( i = json_object_iter(a1); i; i = json_object_iter_next(a1, i) )
  {
    v6 = json_object_iter_key(i);
    v5 = (const json_t *)json_object_iter_value(i);
    v2 = (json_t *)json_deep_copy(v5);
    json_object_set_new_nocheck((json_t *)v7, v6, v2);
  }
  return v7;
}

//----- (00046188) --------------------------------------------------------
_DWORD *json_array()
{
  _DWORD *v2; // [sp+4h] [bp-8h]

  v2 = jsonp_malloc(0x14u);
  if ( !v2 )
    return 0;
  json_init(v2, 1);
  v2[3] = 0;
  v2[2] = 8;
  v2[4] = jsonp_malloc(4 * v2[2]);
  if ( v2[4] )
    return v2;
  jsonp_free(v2);
  return 0;
}

//----- (0004622C) --------------------------------------------------------
void __cdecl json_delete_array(json_array_t *array)
{
  unsigned int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i < *((_DWORD *)array + 3); ++i )
    sub_45520(*(_DWORD *)(*((_DWORD *)array + 4) + 4 * i));
  jsonp_free(*((void **)array + 4));
  jsonp_free(array);
}

//----- (000462AC) --------------------------------------------------------
size_t __cdecl json_array_size(const json_t *json)
{
  if ( json && *(_DWORD *)json == 1 )
    return *((_DWORD *)json + 3);
  else
    return 0;
}

//----- (000462F8) --------------------------------------------------------
json_t *__cdecl json_array_get(const json_t *json, size_t index)
{
  if ( !json || *(_DWORD *)json != 1 )
    return 0;
  if ( index < *((_DWORD *)json + 3) )
    return *(json_t **)(*((_DWORD *)json + 4) + 4 * index);
  return 0;
}

//----- (0004637C) --------------------------------------------------------
int __fastcall json_array_set_new(_DWORD *a1, unsigned int a2, int a3)
{
  if ( !a3 )
    return -1;
  if ( a1 && *a1 == 1 && a1 != (_DWORD *)a3 && a2 < a1[3] )
  {
    sub_45520(*(_DWORD *)(a1[4] + 4 * a2));
    *(_DWORD *)(a1[4] + 4 * a2) = a3;
    return 0;
  }
  else
  {
    sub_45520(a3);
    return -1;
  }
}

//----- (0004645C) --------------------------------------------------------
void *__fastcall sub_4645C(int a1, int a2, int a3, int a4)
{
  return memmove((void *)(*(_DWORD *)(a1 + 16) + 4 * a2), (const void *)(*(_DWORD *)(a1 + 16) + 4 * a3), 4 * a4);
}

//----- (000464BC) --------------------------------------------------------
void __cdecl array_copy(json_t **dest, size_t dpos, json_t **src, size_t spos, size_t count)
{
  memcpy(&dest[dpos], &src[spos], 4 * count);
}

//----- (00046514) --------------------------------------------------------
json_t **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy)
{
  size_t v4; // r3
  void *v8; // [sp+1Ch] [bp-10h]
  size_t v9; // [sp+20h] [bp-Ch]
  json_t **v10; // [sp+24h] [bp-8h]

  if ( *((_DWORD *)array + 3) + amount <= *((_DWORD *)array + 2) )
    return (json_t **)*((_DWORD *)array + 4);
  v10 = (json_t **)*((_DWORD *)array + 4);
  v4 = *((_DWORD *)array + 2) + amount;
  if ( 2 * *((_DWORD *)array + 2) >= v4 )
    v4 = 2 * *((_DWORD *)array + 2);
  v9 = v4;
  v8 = jsonp_malloc(4 * v4);
  if ( !v8 )
    return 0;
  *((_DWORD *)array + 2) = v9;
  *((_DWORD *)array + 4) = v8;
  if ( !copy )
    return v10;
  array_copy(*((json_t ***)array + 4), 0, v10, 0, *((_DWORD *)array + 3));
  jsonp_free(v10);
  return (json_t **)*((_DWORD *)array + 4);
}

//----- (00046624) --------------------------------------------------------
int __cdecl json_array_append_new(json_t *json, json_t *value)
{
  if ( !value )
    return -1;
  if ( json && *(_DWORD *)json == 1 && json != value && json_array_grow(json, 1u, 1) )
  {
    *(_DWORD *)(*((_DWORD *)json + 4) + 4 * (*((_DWORD *)json + 3))++) = value;
    return 0;
  }
  else
  {
    sub_45520((int)value);
    return -1;
  }
}

//----- (00046700) --------------------------------------------------------
int __fastcall json_array_insert_new(int a1, size_t a2, int a3)
{
  json_t **v8; // [sp+18h] [bp-Ch]

  if ( !a3 )
    return -1;
  if ( a1 && *(_DWORD *)a1 == 1 && a1 != a3 && a2 <= *(_DWORD *)(a1 + 12) )
  {
    v8 = json_array_grow((json_array_t *)a1, 1u, 0);
    if ( v8 )
    {
      if ( v8 == *(json_t ***)(a1 + 16) )
      {
        sub_4645C(a1, a2 + 1, a2, *(_DWORD *)(a1 + 12) - a2);
      }
      else
      {
        array_copy(*(json_t ***)(a1 + 16), 0, v8, 0, a2);
        array_copy(*(json_t ***)(a1 + 16), a2 + 1, v8, a2, *(_DWORD *)(a1 + 12) - a2);
        jsonp_free(v8);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * a2) = a3;
      ++*(_DWORD *)(a1 + 12);
      return 0;
    }
    else
    {
      sub_45520(a3);
      return -1;
    }
  }
  else
  {
    sub_45520(a3);
    return -1;
  }
}

//----- (00046898) --------------------------------------------------------
int __fastcall json_array_remove(_DWORD *a1, unsigned int a2)
{
  if ( !a1 || *a1 != 1 )
    return -1;
  if ( a2 >= a1[3] )
    return -1;
  sub_45520(*(_DWORD *)(a1[4] + 4 * a2));
  if ( a2 < a1[3] - 1 )
    sub_4645C((int)a1, a2, a2 + 1, a1[3] - a2 - 1);
  --a1[3];
  return 0;
}

//----- (0004697C) --------------------------------------------------------
int __fastcall json_array_clear(_DWORD *a1)
{
  unsigned int i; // [sp+Ch] [bp-8h]

  if ( !a1 || *a1 != 1 )
    return -1;
  for ( i = 0; i < a1[3]; ++i )
    sub_45520(*(_DWORD *)(a1[4] + 4 * i));
  a1[3] = 0;
  return 0;
}

//----- (00046A20) --------------------------------------------------------
int __fastcall json_array_extend(int a1, int a2)
{
  unsigned int i; // [sp+1Ch] [bp-8h]

  if ( !a1 || *(_DWORD *)a1 != 1 || !a2 || *(_DWORD *)a2 != 1 )
    return -1;
  if ( !json_array_grow((json_array_t *)a1, *(_DWORD *)(a2 + 12), 1) )
    return -1;
  for ( i = 0; i < *(_DWORD *)(a2 + 12); ++i )
    sub_454C0(*(_DWORD *)(*(_DWORD *)(a2 + 16) + 4 * i));
  array_copy(*(json_t ***)(a1 + 16), *(_DWORD *)(a1 + 12), *(json_t ***)(a2 + 16), 0, *(_DWORD *)(a2 + 12));
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a2 + 12);
  return 0;
}

//----- (00046B54) --------------------------------------------------------
int __fastcall sub_46B54(const json_t *a1, const json_t *a2)
{
  json_t *v6; // [sp+8h] [bp-14h]
  json_t *v7; // [sp+Ch] [bp-10h]
  size_t v8; // [sp+10h] [bp-Ch]
  size_t i; // [sp+14h] [bp-8h]

  v8 = json_array_size(a1);
  if ( v8 != json_array_size(a2) )
    return 0;
  for ( i = 0; i < v8; ++i )
  {
    v7 = json_array_get(a1, i);
    v6 = json_array_get(a2, i);
    if ( !json_equal(v7, v6) )
      return 0;
  }
  return 1;
}
// 47960: using guessed type int __fastcall json_equal(_DWORD, _DWORD);

//----- (00046C0C) --------------------------------------------------------
json_t *__fastcall sub_46C0C(const json_t *a1)
{
  json_t *v2; // r0
  json_t *v5; // [sp+8h] [bp-Ch]
  size_t i; // [sp+Ch] [bp-8h]

  v5 = (json_t *)json_array();
  if ( !v5 )
    return 0;
  for ( i = 0; i < json_array_size(a1); ++i )
  {
    v2 = json_array_get(a1, i);
    json_array_append(v5, v2);
  }
  return v5;
}

//----- (00046C94) --------------------------------------------------------
json_t *__fastcall sub_46C94(const json_t *a1)
{
  json_t *v2; // r0
  json_t *v3; // r0
  json_t *v6; // [sp+8h] [bp-Ch]
  size_t i; // [sp+Ch] [bp-8h]

  v6 = (json_t *)json_array();
  if ( !v6 )
    return 0;
  for ( i = 0; i < json_array_size(a1); ++i )
  {
    v2 = json_array_get(a1, i);
    v3 = (json_t *)json_deep_copy(v2);
    json_array_append_new(v6, v3);
  }
  return v6;
}
// 47B28: using guessed type int __fastcall json_deep_copy(_DWORD);

//----- (00046D28) --------------------------------------------------------
_DWORD *__fastcall sub_46D28(const char *a1, size_t a2, int a3)
{
  _DWORD *v6; // [sp+10h] [bp-Ch]
  char *v7; // [sp+14h] [bp-8h]

  if ( !a1 )
    return 0;
  if ( a3 )
  {
    v7 = (char *)a1;
  }
  else
  {
    v7 = jsonp_strndup(a1, a2);
    if ( !v7 )
      return 0;
  }
  v6 = jsonp_malloc(0x10u);
  if ( v6 )
  {
    json_init(v6, 2);
    v6[2] = v7;
    v6[3] = a2;
    return v6;
  }
  else
  {
    jsonp_free(v7);
    return 0;
  }
}

//----- (00046DF0) --------------------------------------------------------
_DWORD *__fastcall json_string_nocheck(const char *a1)
{
  size_t v2; // r0

  if ( !a1 )
    return 0;
  v2 = strlen(a1);
  return sub_46D28(a1, v2, 0);
}

//----- (00046E40) --------------------------------------------------------
_DWORD *__fastcall json_stringn_nocheck(const char *a1, size_t a2)
{
  return sub_46D28(a1, a2, 0);
}

//----- (00046E74) --------------------------------------------------------
json_t *__cdecl jsonp_stringn_nocheck_own(const char *value, size_t len)
{
  return (json_t *)sub_46D28(value, len, 1);
}

//----- (00046EA8) --------------------------------------------------------
_DWORD *__fastcall json_string(const char *a1)
{
  size_t v2; // r0

  if ( !a1 )
    return 0;
  v2 = strlen(a1);
  return json_stringn(a1, v2);
}

//----- (00046EF4) --------------------------------------------------------
_DWORD *__fastcall json_stringn(const char *a1, size_t a2)
{
  if ( a1 && utf8_check_string((int)a1, a2) )
    return json_stringn_nocheck(a1, a2);
  else
    return 0;
}

//----- (00046F50) --------------------------------------------------------
const char *__cdecl json_string_value(const json_t *json)
{
  if ( json && *(_DWORD *)json == 2 )
    return (const char *)*((_DWORD *)json + 2);
  else
    return 0;
}

//----- (00046F9C) --------------------------------------------------------
size_t __cdecl json_string_length(const json_t *json)
{
  if ( json && *(_DWORD *)json == 2 )
    return *((_DWORD *)json + 3);
  else
    return 0;
}

//----- (00046FE8) --------------------------------------------------------
int __fastcall json_string_set_nocheck(int a1, const char *a2)
{
  size_t v3; // r0

  if ( !a2 )
    return -1;
  v3 = strlen(a2);
  return json_string_setn_nocheck(a1, a2, v3);
}

//----- (0004703C) --------------------------------------------------------
int __fastcall json_string_setn_nocheck(int a1, const char *a2, size_t a3)
{
  char *v7; // [sp+14h] [bp-8h]

  if ( !a1 || *(_DWORD *)a1 != 2 || !a2 )
    return -1;
  v7 = jsonp_strndup(a2, a3);
  if ( !v7 )
    return -1;
  jsonp_free(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 12) = a3;
  return 0;
}

//----- (000470E8) --------------------------------------------------------
int __fastcall json_string_set(int a1, const char *a2)
{
  size_t v3; // r0

  if ( !a2 )
    return -1;
  v3 = strlen(a2);
  return json_string_setn(a1, a2, v3);
}

//----- (0004713C) --------------------------------------------------------
int __fastcall json_string_setn(int a1, const char *a2, size_t a3)
{
  if ( a2 && utf8_check_string((int)a2, a3) )
    return json_string_setn_nocheck(a1, a2, a3);
  else
    return -1;
}

//----- (000471A0) --------------------------------------------------------
void __cdecl json_delete_string(json_string_t *string)
{
  jsonp_free(*((void **)string + 2));
  jsonp_free(string);
}

//----- (000471D4) --------------------------------------------------------
bool __fastcall sub_471D4(int a1, int a2)
{
  return *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && !memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), *(_DWORD *)(a1 + 12));
}

//----- (00047254) --------------------------------------------------------
_DWORD *__fastcall sub_47254(int a1)
{
  return json_stringn_nocheck(*(const char **)(a1 + 8), *(_DWORD *)(a1 + 12));
}

//----- (00047298) --------------------------------------------------------
json_t *__fastcall json_vsprintf(const char *a1, void *a2)
{
  char *s; // [sp+Ch] [bp-10h]
  size_t v6; // [sp+10h] [bp-Ch]
  int v7; // [sp+14h] [bp-8h]

  v7 = 0;
  v6 = vsnprintf(0, 0, a1, a2);
  if ( !v6 )
    return (json_t *)json_string(byte_DA738);
  s = (char *)jsonp_malloc(v6 + 1);
  if ( s )
  {
    vsnprintf(s, v6 + 1, a1, a2);
    if ( utf8_check_string((int)s, v6) )
      return jsonp_stringn_nocheck_own(s, v6);
    else
      jsonp_free(s);
  }
  return (json_t *)v7;
}

//----- (00047384) --------------------------------------------------------
json_t *json_sprintf(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  return json_vsprintf(a1, varg_r1);
}

//----- (000473C4) --------------------------------------------------------
_QWORD *__fastcall json_integer(__int64 a1)
{
  _QWORD *v4; // [sp+Ch] [bp-8h]

  v4 = jsonp_malloc(0x10u);
  if ( !v4 )
    return 0;
  json_init(v4, 3);
  v4[1] = a1;
  return v4;
}
// 473C4: invalid function type 'json_t *__cdecl json_integer(json_int_t value)' has been ignored

//----- (00047420) --------------------------------------------------------
__int64 __fastcall json_integer_value(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

//----- (00047474) --------------------------------------------------------
int __fastcall json_integer_set(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (000474CC) --------------------------------------------------------
void __cdecl p_close(cgsem_t *cgsem)
{
  jsonp_free(cgsem);
}

//----- (000474F0) --------------------------------------------------------
bool __fastcall sub_474F0(int a1, int a2)
{
  __int64 v2; // r4

  v2 = json_integer_value(a1);
  return v2 == json_integer_value(a2);
}

//----- (00047544) --------------------------------------------------------
_QWORD *__fastcall sub_47544(int a1)
{
  __int64 v1; // r0

  v1 = json_integer_value(a1);
  return json_integer(v1);
}

//----- (00047580) --------------------------------------------------------
double *json_real()
{
  double v0; // d0
  double *v3; // [sp+Ch] [bp-8h]

  if ( fabs(v0) > 1.79769313e308 )
    return 0;
  v3 = (double *)jsonp_malloc(0x10u);
  if ( !v3 )
    return 0;
  json_init(v3, 4);
  v3[1] = v0;
  return v3;
}
// 475A8: variable 'v0' is possibly undefined

//----- (00047630) --------------------------------------------------------
void json_real_value()
{
  ;
}

//----- (00047684) --------------------------------------------------------
int __fastcall json_real_set(int a1)
{
  double v1; // d0

  if ( !a1 || *(_DWORD *)a1 != 4 || fabs(v1) > 1.79769313e308 )
    return -1;
  *(double *)(a1 + 8) = v1;
  return 0;
}
// 476CC: variable 'v1' is possibly undefined

//----- (00047728) --------------------------------------------------------
void __fastcall sub_47728(void *a1)
{
  jsonp_free(a1);
}

//----- (0004774C) --------------------------------------------------------
int sub_4774C()
{
  json_real_value();
  json_real_value();
  return 1;
}

//----- (000477A0) --------------------------------------------------------
double *sub_477A0()
{
  json_real_value();
  return json_real();
}

//----- (000477D4) --------------------------------------------------------
void __fastcall json_number_value(_DWORD *a1)
{
  __int64 v1; // r0

  if ( a1 && *a1 == 3 )
  {
    v1 = json_integer_value((int)a1);
    sub_CCAE4(v1);
  }
  else if ( a1 )
  {
    if ( *a1 == 4 )
      json_real_value();
  }
}

//----- (0004786C) --------------------------------------------------------
json_t *json_true()
{
  return (json_t *)&unk_14DEA0;
}

//----- (0004788C) --------------------------------------------------------
void *json_false()
{
  return &unk_14DEA8;
}

//----- (000478AC) --------------------------------------------------------
void *json_null()
{
  return &unk_14DEB0;
}

//----- (000478CC) --------------------------------------------------------
void __cdecl json_delete(json_t *json)
{
  if ( json )
  {
    switch ( *(_DWORD *)json )
    {
      case 0:
        json_delete_object(json);
        break;
      case 1:
        json_delete_array(json);
        break;
      case 2:
        json_delete_string(json);
        break;
      case 3:
        p_close(json);
        break;
      case 4:
        sub_47728(json);
        break;
      default:
        return;
    }
  }
}
// 478F8: control flows out of bounds to 478FC

//----- (00047960) --------------------------------------------------------
int __fastcall json_equal(const json_t *a1, const json_t *a2)
{
  int v2; // r3

  if ( !a1 || !a2 )
    return 0;
  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return 0;
  if ( a1 == a2 )
    return 1;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      v2 = sub_45F3C(a1, a2);
      break;
    case 1:
      v2 = sub_46B54(a1, a2);
      break;
    case 2:
      v2 = sub_471D4((int)a1, (int)a2);
      break;
    case 3:
      v2 = sub_474F0((int)a1, (int)a2);
      break;
    case 4:
      v2 = sub_4774C();
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}
// 479DC: control flows out of bounds to 479E0
// 45F3C: using guessed type int __fastcall sub_45F3C(_DWORD, _DWORD);

//----- (00047A68) --------------------------------------------------------
void *__fastcall json_copy(json_t *a1)
{
  void *v1; // r3

  if ( !a1 )
    return 0;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      v1 = sub_4602C(a1);
      break;
    case 1:
      v1 = sub_46C0C(a1);
      break;
    case 2:
      v1 = sub_47254((int)a1);
      break;
    case 3:
      v1 = sub_47544((int)a1);
      break;
    case 4:
      v1 = sub_477A0();
      break;
    case 5:
    case 6:
    case 7:
      v1 = a1;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}
// 47A9C: control flows out of bounds to 47AA0

//----- (00047B28) --------------------------------------------------------
void *__fastcall json_deep_copy(const json_t *a1)
{
  void *v1; // r3

  if ( !a1 )
    return 0;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      v1 = (void *)sub_460EC(a1);
      break;
    case 1:
      v1 = sub_46C94(a1);
      break;
    case 2:
      v1 = sub_47254((int)a1);
      break;
    case 3:
      v1 = sub_47544((int)a1);
      break;
    case 4:
      v1 = sub_477A0();
      break;
    case 5:
    case 6:
    case 7:
      v1 = a1;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}
// 47B5C: control flows out of bounds to 47B60
// 460EC: using guessed type int __fastcall sub_460EC(_DWORD);

//----- (00047BE8) --------------------------------------------------------
void __fastcall sub_47BE8(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (00047C50) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_47C50(int a1, __int64 a2)
{
  V_INT(a1, "poolno", a2);
}

//----- (00047C84) --------------------------------------------------------
int __fastcall sub_47C84(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 47CF0: variable 'v3' is possibly undefined

//----- (00047D9C) --------------------------------------------------------
int __fastcall sub_47D9C(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (00047E10) --------------------------------------------------------
int __fastcall sub_47E10(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00047F34) --------------------------------------------------------
_BYTE *__fastcall sub_47F34(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00047FA0) --------------------------------------------------------
int __fastcall stratum_set_diff_or_target_base(int a1, int a2, const json_t *a3)
{
  double v3; // d0
  json_t *v4; // r0
  size_t v6; // r0
  json_t *v7; // r0
  int v9; // [sp+4h] [bp-1058h]
  char v13[36]; // [sp+38h] [bp-1024h] BYREF
  double v14; // [sp+1038h] [bp-24h]
  int v15; // [sp+1040h] [bp-1Ch]
  char *s; // [sp+1044h] [bp-18h]

  v15 = a2 + 456;
  if ( !json_array_get(a3, 0) || *(_DWORD *)json_array_get(a3, 0) != 2 )
  {
    v7 = json_array_get(a3, 0);
    json_number_value(v7);
    v14 = v3;
    if ( v3 == 0.0 )
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "Stratum set target: invalid parameters");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/frontend/frontend_base.c",
        162,
        "stratum_set_diff_or_target_base",
        31,
        35,
        100,
        v13);
      return 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 1592));
    *(double *)(v15 + 1064) = v14;
    *(_QWORD *)(a2 + 448) = *(_QWORD *)(v15 + 1064);
    *(_QWORD *)(a2 + 1808) = *(_QWORD *)(a2 + 448);
    (*(void (__fastcall **)(int))(a1 + 64))(v15 + 1032);
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "%s diff from pool: %lf", "stratum_set_diff_or_target_base", v9, v14);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_base.c",
      162,
      "stratum_set_diff_or_target_base",
      31,
      42,
      20,
      v13);
    V_LOCK();
    logfmt_raw(
      v13,
      0x1000u,
      0,
      "%s target:%08x %08x %08x %08x %08x %08x %08x %08x ",
      "stratum_set_diff_or_target_base",
      *(_DWORD *)(v15 + 1032),
      *(_DWORD *)(v15 + 1036),
      *(_DWORD *)(v15 + 1040),
      *(_DWORD *)(v15 + 1044),
      *(_DWORD *)(v15 + 1048),
      *(_DWORD *)(v15 + 1052),
      *(_DWORD *)(v15 + 1056),
      *(_DWORD *)(v15 + 1060));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_base.c",
      162,
      "stratum_set_diff_or_target_base",
      31,
      43,
      20,
      v13);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 1592));
    return 1;
  }
  v4 = json_array_get(a3, 0);
  s = (char *)json_string_value(v4);
  if ( s && strlen(s) == 64 )
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "%s target from pool: %s", "stratum_set_diff_or_target_base", s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_base.c",
      162,
      "stratum_set_diff_or_target_base",
      31,
      24,
      20,
      v13);
    v6 = strlen(s);
    hex2bin(v13, s, v6 >> 1);
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 1592));
    memcpy((void *)(v15 + 1032), v13, 0x20u);
    (*(void (__fastcall **)(char *))(a1 + 68))(v13);
    *(double *)(v15 + 1064) = v3;
    *(_QWORD *)(a2 + 448) = *(_QWORD *)(v15 + 1064);
    *(_QWORD *)(a2 + 1808) = *(_QWORD *)(a2 + 448);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 1592));
    return 1;
  }
  V_LOCK();
  logfmt_raw(v13, 0x1000u, 0, "Stratum set target: invalid parameters");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/frontend/frontend_base.c",
    162,
    "stratum_set_diff_or_target_base",
    31,
    20,
    100,
    v13);
  return 0;
}
// 4820C: variable 'v3' is possibly undefined
// 483FC: variable 'v9' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004855C) --------------------------------------------------------
int __fastcall stratum_handle_method_base(int a1, int a2, int a3)
{
  json_t *v3; // r0
  char v8[28]; // [sp+20h] [bp-111Ch] BYREF
  _DWORD v9[23]; // [sp+1020h] [bp-11Ch] BYREF
  _DWORD v10[41]; // [sp+107Ch] [bp-C0h] BYREF
  char *s1; // [sp+1120h] [bp-1Ch]
  const json_t *v12; // [sp+1124h] [bp-18h]
  json_t *v13; // [sp+1128h] [bp-14h]
  unsigned __int8 v14; // [sp+112Fh] [bp-Dh]

  v14 = 0;
  v12 = json_loads(a3, 0, (json_error_t *)v9);
  if ( !v12 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "JSON decode failed(%d): %s", v9[0], v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_base.c",
      162,
      "stratum_handle_method_base",
      26,
      65,
      100,
      v8);
    goto LABEL_18;
  }
  v3 = json_object_get(v12, "method");
  s1 = (char *)json_string_value(v3);
  if ( s1 )
  {
    v13 = json_object_get(v12, "params");
    if ( !v13 )
      v13 = json_object_get(v12, "result");
    v10[40] = json_object_get(v12, "id");
    if ( !strcasecmp(s1, "mining.notify") )
    {
      v14 = (*(int (__fastcall **)(int, int, json_t *))(a1 + 48))(a1, a2, v13);
      if ( v14 )
      {
LABEL_8:
        pool_tset(a2, (unsigned __int8 *)(a2 + 1916), 1);
        goto LABEL_18;
      }
      goto LABEL_15;
    }
    if ( !strcasecmp(s1, "mining.set_difficulty") || !strcasecmp(s1, "mining.set_target") )
    {
      v14 = (*(int (__fastcall **)(int, int, json_t *))(a1 + 56))(a1, a2, v13);
      goto LABEL_18;
    }
    if ( !strcasecmp(s1, "mining.set_extranonce") )
    {
      v14 = (*(int (__fastcall **)(int, int, json_t *, _DWORD))(a1 + 52))(a1, a2, v13, 0);
      if ( v14 )
        goto LABEL_8;
LABEL_15:
      pool_tclear(a2, (unsigned __int8 *)(a2 + 1916), 0);
      goto LABEL_18;
    }
    if ( v14 != 1 )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "unknown stratum method %s!", a3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/frontend/frontend_base.c",
        162,
        "stratum_handle_method_base",
        26,
        105,
        80,
        v8);
    }
  }
LABEL_18:
  if ( v12 )
    sub_47BE8((int)v12);
  return v14;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000489AC) --------------------------------------------------------
int __fastcall pre_stratum_handle_method_base(int a1, int a2, int a3, _DWORD *a4)
{
  json_t *v4; // r0
  char v10[20]; // [sp+20h] [bp-1114h] BYREF
  _DWORD v11[23]; // [sp+1020h] [bp-114h] BYREF
  _DWORD v12[41]; // [sp+107Ch] [bp-B8h] BYREF
  char *s1; // [sp+1120h] [bp-14h]
  const json_t *v14; // [sp+1124h] [bp-10h]
  json_t *v15; // [sp+1128h] [bp-Ch]
  unsigned __int8 v16; // [sp+112Fh] [bp-5h]

  v16 = 0;
  v14 = json_loads(a3, 0, (json_error_t *)v11);
  if ( v14 )
  {
    v4 = json_object_get(v14, "method");
    s1 = (char *)json_string_value(v4);
    if ( s1 )
    {
      v15 = json_object_get(v14, "params");
      if ( !v15 )
        v15 = json_object_get(v14, "result");
      v12[40] = json_object_get(v14, "id");
      if ( !strcasecmp(s1, "mining.notify") )
      {
        v16 = (*(int (__fastcall **)(int, int, json_t *))(a1 + 48))(a1, a2, v15);
        if ( v16 )
        {
          *a4 = "notify";
          pool_tset(a2, (unsigned __int8 *)(a2 + 1916), 1);
        }
        else
        {
          pool_tclear(a2, (unsigned __int8 *)(a2 + 1916), 0);
        }
      }
      else if ( !strcasecmp(s1, "mining.set_difficulty") || !strcasecmp(s1, "mining.set_target") )
      {
        *a4 = "set diff or target";
        v16 = (*(int (__fastcall **)(int, int, json_t *))(a1 + 56))(a1, a2, v15);
      }
      else if ( v16 != 1 )
      {
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, "unknown stratum method %s!", a3);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/frontend/frontend_base.c",
          162,
          "pre_stratum_handle_method_base",
          30,
          156,
          80,
          v10);
      }
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "JSON decode failed(%d): %s", v11[0], v12);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_base.c",
      162,
      "pre_stratum_handle_method_base",
      30,
      123,
      100,
      v10);
  }
  if ( v14 )
    sub_47BE8((int)v14);
  return v16;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00048D64) --------------------------------------------------------
int __fastcall stratum_subscribe_base(int a1, int *a2)
{
  size_t v3; // r3
  json_t *v4; // r0
  int v5; // r3
  char v9[72]; // [sp+34h] [bp-1148h] BYREF
  _DWORD v10[23]; // [sp+1034h] [bp-148h] BYREF
  int v11; // [sp+1090h] [bp-ECh] BYREF
  _DWORD v12[7]; // [sp+1130h] [bp-4Ch] BYREF
  int v13; // [sp+114Ch] [bp-30h]
  json_t *v14; // [sp+1154h] [bp-28h]
  json_t *v15; // [sp+1158h] [bp-24h]
  int v16; // [sp+115Ch] [bp-20h]
  void *dest; // [sp+1160h] [bp-1Ch]
  char v18; // [sp+1166h] [bp-16h]
  unsigned __int8 v19; // [sp+1167h] [bp-15h]
  const json_t *v20; // [sp+1168h] [bp-14h]
  void *ptr; // [sp+116Ch] [bp-10h]

  ptr = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v16 = 0;
  if ( *((_BYTE *)a2 + 1656) )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "pool %d is jsonrpc_2, no need to subscribe", *a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_base.c",
      162,
      "stratum_subscribe_base",
      22,
      174,
      20,
      v9);
    return 1;
  }
  else
  {
    while ( 1 )
    {
      v3 = a2[18] ? strlen((const char *)a2[18]) + 128 : 128;
      dest = malloc(v3);
      if ( v18 )
        strcpy((char *)dest, "{\"id\": 1, \"method\": \"mining.subscribe\", \"params\": [\"ckbminer-v1.0.0\", null]}");
      else
        strcpy((char *)dest, "{\"id\": 1, \"method\": \"mining.subscribe\", \"params\": [\"GodMiner/2.0.0\", null]}");
      if ( (*(unsigned __int8 (__fastcall **)(int *, void *))(a1 + 12))(a2, dest) != 1 )
      {
        V_LOCK();
        logfmt_raw(v9, 0x1000u, 0, "stratum_subscribe send failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/frontend/frontend_base.c",
          162,
          "stratum_subscribe_base",
          22,
          190,
          100,
          v9);
      }
      else if ( (unsigned __int8)socket_full(a2[9], 30) != 1 )
      {
        V_LOCK();
        sub_47C50((int)v12, *a2);
        logfmt_raw(
          v9,
          0x1000u,
          0,
          v13,
          v12[0],
          v12[1],
          v12[2],
          v12[3],
          v12[4],
          v12[5],
          v12[6],
          v13,
          "stratum_subscribe timed out");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/frontend/frontend_base.c",
          162,
          "stratum_subscribe_base",
          22,
          195,
          100,
          v9);
      }
      else
      {
        ptr = (void *)(*(int (__fastcall **)(int *))(a1 + 8))(a2);
        if ( ptr )
        {
          v20 = json_loads((int)ptr, 0, (json_error_t *)v10);
          if ( ptr )
            free(ptr);
          if ( v20 )
          {
            v15 = json_object_get(v20, "result");
            v14 = json_object_get(v20, "error");
            v4 = json_object_get(v20, "id");
            v16 = json_integer_value((int)v4);
            if ( v16 == 1 && v15 && *(_DWORD *)v15 != 7 && (!v14 || *(_DWORD *)v14 == 7) )
            {
              if ( (*(unsigned __int8 (__fastcall **)(int, int *, json_t *, int))(a1 + 52))(a1, a2, v15, 1) == 1 )
              {
                v19 = 1;
                a2[480] = 2;
              }
            }
            else if ( v18 )
            {
              if ( v14 )
                dest = json_dumps(v14, 3);
              else
                dest = strdup("(unknown reason)");
              V_LOCK();
              logfmt_raw(v9, 0x1000u, 0, "JSON-RPC call failed: %s, req_id=%d", dest, v16);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/frontend/frontend_base.c",
                162,
                "stratum_subscribe_base",
                22,
                221,
                100,
                v9);
            }
          }
          else
          {
            V_LOCK();
            logfmt_raw(v9, 0x1000u, 0, "JSON decode failed(%d): %s", v10[0], &v11);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/frontend/frontend_base.c",
              162,
              "stratum_subscribe_base",
              22,
              206,
              100,
              v9);
          }
        }
      }
      if ( v19 )
      {
        if ( a2[8] )
        {
          if ( strstr((const char *)a2[8], "nicehash") )
          {
            v5 = a2[480];
            a2[480] = v5 + 1;
            sprintf((char *)dest, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v5);
            if ( (*(int (__fastcall **)(int *, void *))(a1 + 12))(a2, dest) )
            {
              if ( socket_full(a2[9], 30) )
                (*(void (__fastcall **)(int *))(a1 + 8))(a2);
            }
          }
        }
      }
      if ( dest )
        free(dest);
      if ( v20 )
        sub_47BE8((int)v20);
      if ( v19 == 1 || !ptr || v18 == 1 )
        break;
      v18 = 1;
    }
    return v19;
  }
}
// 49204: conditional instruction was optimized away because %var_1C.4!=0
// 4922C: conditional instruction was optimized away because %var_20.4!=0
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00049504) --------------------------------------------------------
int __fastcall stratum_authorize_base(int a1, int a2)
{
  size_t v2; // r4
  size_t v3; // r0
  int v4; // r2
  json_t *v5; // r0
  char v9[36]; // [sp+18h] [bp-1124h] BYREF
  _DWORD v10[23]; // [sp+1018h] [bp-124h] BYREF
  int v11; // [sp+1074h] [bp-C8h] BYREF
  json_t *v12; // [sp+1114h] [bp-28h]
  json_t *v13; // [sp+1118h] [bp-24h]
  void *ptr; // [sp+111Ch] [bp-20h]
  char *s; // [sp+1120h] [bp-1Ch]
  int v16; // [sp+1124h] [bp-18h]
  const json_t *v17; // [sp+1128h] [bp-14h]
  unsigned __int8 v18; // [sp+112Fh] [bp-Dh]

  v17 = 0;
  v18 = 0;
  v16 = 0;
  v2 = strlen(*(const char **)(a2 + 16));
  v3 = strlen(*(const char **)(a2 + 20));
  s = (char *)malloc(v2 + v3 + 80);
  v4 = *(_DWORD *)(a2 + 1920);
  *(_DWORD *)(a2 + 1920) = v4 + 1;
  sprintf(
    s,
    "{\"id\":%d,\"method\":\"mining.authorize\",\"params\":[\"%s\",\"%s\"]}",
    v4,
    *(const char **)(a2 + 16),
    *(const char **)(a2 + 20));
  if ( (*(unsigned __int8 (__fastcall **)(int, char *))(a1 + 12))(a2, s) == 1 )
  {
    while ( 1 )
    {
      ptr = (void *)(*(int (__fastcall **)(int))(a1 + 8))(a2);
      if ( !ptr )
        break;
      if ( (*(unsigned __int8 (__fastcall **)(int, int, void *))(a1 + 20))(a1, a2, ptr) != 1 )
      {
        v17 = json_loads((int)ptr, 0, (json_error_t *)v10);
        if ( ptr )
          free(ptr);
        if ( v17 )
        {
          v13 = json_object_get(v17, "result");
          v12 = json_object_get(v17, "error");
          v5 = json_object_get(v17, "id");
          v16 = json_integer_value((int)v5);
          if ( v16 == *(_DWORD *)(a2 + 1920) - 1 && v13 && *(_DWORD *)v13 != 6 && (!v12 || *(_DWORD *)v12 == 7) )
          {
            v18 = 1;
          }
          else
          {
            V_LOCK();
            logfmt_raw(v9, 0x1000u, 0, "Stratum authentication failed, req_id=%d", v16);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/frontend/frontend_base.c",
              162,
              "stratum_authorize_base",
              22,
              293,
              100,
              v9);
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, "JSON decode failed(%d): %s", v10[0], &v11);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/frontend/frontend_base.c",
            162,
            "stratum_authorize_base",
            22,
            283,
            100,
            v9);
        }
        break;
      }
      free(ptr);
    }
  }
  if ( s )
    free(s);
  if ( v17 )
    sub_47BE8((int)v17);
  return v18;
}
// 4980C: conditional instruction was optimized away because %var_1C.4!=0
// 49834: conditional instruction was optimized away because %var_20.4!=0
// 496AC: conditional instruction was optimized away because %ptr.4!=0
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00049918) --------------------------------------------------------
int __fastcall stratum_login_base(int a1, int a2)
{
  return (*(int (__fastcall **)(int, int))(a1 + 40))(a1, a2) && (*(int (__fastcall **)(int, int))(a1 + 44))(a1, a2);
}

//----- (0004998C) --------------------------------------------------------
int __fastcall stratum_handle_response_base(int a1, int a2, int a3)
{
  bool v3; // r3
  bool v4; // r3
  int v5; // r4
  unsigned __int8 *v6; // r2
  json_t *v7; // r0
  char v10[32]; // [sp+24h] [bp-1120h] BYREF
  _DWORD v11[23]; // [sp+1024h] [bp-120h] BYREF
  int v12; // [sp+1080h] [bp-C4h] BYREF
  char *s1; // [sp+1120h] [bp-24h]
  json_t *v14; // [sp+1124h] [bp-20h]
  const json_t *v15; // [sp+1128h] [bp-1Ch]
  const json_t *v16; // [sp+112Ch] [bp-18h]
  const json_t *v17; // [sp+1130h] [bp-14h]
  unsigned __int8 v18; // [sp+1136h] [bp-Eh]
  unsigned __int8 v19; // [sp+1137h] [bp-Dh]

  v19 = 0;
  v18 = 0;
  v17 = json_loads(a2, 0, (json_error_t *)v11);
  if ( !v17 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "JSON decode failed(%d): %s", v11[0], &v12);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_base.c",
      162,
      "stratum_handle_response_base",
      28,
      321,
      40,
      v10);
    goto LABEL_37;
  }
  v16 = json_object_get(v17, "result");
  v15 = json_object_get(v17, "error");
  v14 = json_object_get(v17, "id");
  if ( v16 && *(_DWORD *)v16 != 7 )
  {
    if ( v16 == json_false() )
    {
      v18 = 0;
    }
    else
    {
      s1 = (char *)json_string_value(v16);
      v3 = s1 && !strcmp(s1, "ok") && v15 && *(_DWORD *)v15 == 7;
      v18 = v3;
    }
  }
  else
  {
    v18 = 0;
  }
  if ( v16 == json_true() )
  {
    v4 = v15 && *(_DWORD *)v15 == 7;
    if ( v4 || v15 == 0 )
      v18 = 1;
  }
  if ( !v14 || *(_DWORD *)v14 == 7 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "%s json id is null!", "stratum_handle_response_base");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_base.c",
      162,
      "stratum_handle_response_base",
      28,
      345,
      20,
      v10);
    goto LABEL_37;
  }
  if ( *(_BYTE *)(a3 + 1656) )
  {
    if ( v16 || v15 )
    {
      v5 = v18;
      if ( v15 )
        v6 = (unsigned __int8 *)json_string_value(v15);
      else
        v6 = 0;
LABEL_36:
      share_result(v5, 0, v6, (double *)a3);
      v19 = 1;
    }
  }
  else if ( v16 && json_integer_value((int)v14) >= 4 )
  {
    v5 = v18;
    if ( v15 )
    {
      v7 = json_array_get(v15, 1u);
      v6 = (unsigned __int8 *)json_string_value(v7);
    }
    else
    {
      v6 = 0;
    }
    goto LABEL_36;
  }
LABEL_37:
  if ( v17 )
    sub_47BE8((int)v17);
  return v19;
}
// 49AD4: conditional instruction was optimized away because %var_10.4!=0
// 49C04: conditional instruction was optimized away because %var_18.4!=0
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00049DBC) --------------------------------------------------------
int __fastcall settime_based_notify_ntime(const char *a1)
{
  char v3[16]; // [sp+1Ch] [bp-1010h] BYREF
  struct timeval tv; // [sp+101Ch] [bp-10h] BYREF
  unsigned int v5; // [sp+1024h] [bp-8h]

  v5 = strtol(a1, 0, 16);
  if ( byte_152331 == 1 || !v5 )
    return 0;
  tv = 0;
  gettimeofday(&tv, 0);
  if ( v5 <= tv.tv_sec )
    return 0;
  tv.tv_sec = v5;
  settimeofday(&tv, 0);
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "settime notify.ntime successfuly");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/frontend/frontend_base.c",
    162,
    "settime_based_notify_ntime",
    26,
    383,
    60,
    v3);
  byte_152331 = 1;
  return 1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152331: using guessed type char byte_152331;
// 1608F0: using guessed type int g_zc;

//----- (00049F14) --------------------------------------------------------
int __fastcall set_frontend_runtime_type(int a1, int a2)
{
  char v5[12]; // [sp+18h] [bp-100Ch] BYREF
  unsigned int i; // [sp+1018h] [bp-Ch]
  int v7; // [sp+101Ch] [bp-8h]

  v7 = 0;
  for ( i = 0; i <= 1 && a2 != *(_DWORD *)&asc_DAF50[12 * i]; ++i )
    ;
  if ( i != 2 && *(_DWORD *)&asc_DAF50[12 * i + 8] )
  {
    v7 = (*(int (**)(void))&asc_DAF50[12 * i + 8])();
    if ( v7 )
    {
      *(_DWORD *)(v7 + 72) = a1;
      if ( dword_152334 )
        free((void *)dword_152334);
      *(_DWORD *)(v7 + 76) = a2;
      dword_152334 = v7;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "ALGO %d does not define Frontend_Base", a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_interface.c",
      167,
      "set_frontend_runtime_type",
      25,
      66,
      100,
      v5);
  }
  return v7;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152334: using guessed type int dword_152334;
// 1608F0: using guessed type int g_zc;

//----- (0004A100) --------------------------------------------------------
int frontend_runtime_instance()
{
  char v2[4]; // [sp+10h] [bp-1004h] BYREF

  if ( dword_152334 )
    return dword_152334;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "frontend runtime type not set");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/frontend/frontend_interface.c",
    167,
    "frontend_runtime_instance",
    25,
    85,
    100,
    v2);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152334: using guessed type int dword_152334;
// 1608F0: using guessed type int g_zc;

//----- (0004A1B0) --------------------------------------------------------
int __fastcall sub_4A1B0(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 4A21C: variable 'v3' is possibly undefined

//----- (0004A2C8) --------------------------------------------------------
int __fastcall sub_4A2C8(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0004A33C) --------------------------------------------------------
int __fastcall sub_4A33C(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004A460) --------------------------------------------------------
_BYTE *__fastcall sub_4A460(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0004A4CC) --------------------------------------------------------
unsigned int __fastcall sub_4A4CC(unsigned int a1)
{
  return bswap32(a1);
}

//----- (0004A4F4) --------------------------------------------------------
int __fastcall sub_4A4F4(int a1, int *a2, const json_t *a3)
{
  json_t *v3; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  size_t v6; // r3
  json_t *v7; // r0
  json_t *v8; // r0
  json_t *v9; // r0
  size_t v10; // r3
  json_t *v11; // r0
  bool v12; // r3
  size_t v13; // r0
  size_t v14; // r0
  size_t v15; // r0
  size_t v16; // r0
  size_t v17; // r0
  char *v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  int v22; // r1
  int v23; // r2
  int v24; // r3
  json_t *v25; // r0
  void **v26; // r4
  _DWORD *v27; // lr
  int v28; // r1
  int v29; // r2
  int v30; // r3
  int v31; // r1
  int v32; // r2
  int v33; // r3
  char v37[16]; // [sp+24h] [bp-1090h] BYREF
  int v38; // [sp+1024h] [bp-90h] BYREF
  int v39; // [sp+1028h] [bp-8Ch] BYREF
  int v40; // [sp+102Ch] [bp-88h] BYREF
  int v41; // [sp+1030h] [bp-84h] BYREF
  int v42; // [sp+1034h] [bp-80h]
  int v43; // [sp+1038h] [bp-7Ch]
  int v44; // [sp+103Ch] [bp-78h]
  int v45; // [sp+1040h] [bp-74h]
  int v46; // [sp+1044h] [bp-70h]
  int v47; // [sp+1048h] [bp-6Ch]
  int v48; // [sp+104Ch] [bp-68h]
  char *v49; // [sp+1050h] [bp-64h]
  size_t v50; // [sp+1054h] [bp-60h]
  void *ptr; // [sp+1058h] [bp-5Ch]
  size_t n; // [sp+105Ch] [bp-58h]
  size_t nmemb; // [sp+1060h] [bp-54h]
  bool v54; // [sp+1067h] [bp-4Dh]
  signed int v55; // [sp+1068h] [bp-4Ch]
  const json_t *v56; // [sp+106Ch] [bp-48h]
  int *v57; // [sp+1070h] [bp-44h]
  void *v58; // [sp+1074h] [bp-40h]
  int i; // [sp+1078h] [bp-3Ch]
  signed int j; // [sp+107Ch] [bp-38h]
  char *s2; // [sp+1080h] [bp-34h]
  char *s; // [sp+1084h] [bp-30h]
  char *v63; // [sp+1088h] [bp-2Ch]
  char *v64; // [sp+108Ch] [bp-28h]
  char *v65; // [sp+1090h] [bp-24h]
  char *v66; // [sp+1094h] [bp-20h]
  char *v67; // [sp+1098h] [bp-1Ch]
  unsigned __int8 v68; // [sp+109Fh] [bp-15h]
  size_t v69; // [sp+10A0h] [bp-14h]
  void *src; // [sp+10A4h] [bp-10h]

  s2 = 0;
  s = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  src = 0;
  v58 = 0;
  v57 = a2 + 114;
  v56 = json_array_get(a3, 4u);
  if ( v56 && *(_DWORD *)v56 == 1 )
  {
    v55 = json_array_size(v56);
    v3 = json_array_get(a3, v69);
    s2 = (char *)json_string_value(v3);
    v4 = json_array_get(a3, v69 + 1);
    s = (char *)json_string_value(v4);
    v5 = json_array_get(a3, v69 + 2);
    v63 = (char *)json_string_value(v5);
    v6 = v69 + 3;
    v69 += 4;
    v7 = json_array_get(a3, v6);
    v64 = (char *)json_string_value(v7);
    v8 = json_array_get(a3, v69 + 1);
    v65 = (char *)json_string_value(v8);
    v9 = json_array_get(a3, v69 + 2);
    v66 = (char *)json_string_value(v9);
    v10 = v69 + 3;
    v69 += 4;
    v11 = json_array_get(a3, v10);
    v67 = (char *)json_string_value(v11);
    v12 = json_array_get(a3, v69) && *(_DWORD *)json_array_get(a3, v69) == 5;
    v54 = v12;
    if ( (unsigned __int8)valid_ascii(s2) != 1
      || (unsigned __int8)valid_hex(s) != 1
      || (unsigned __int8)valid_hex(v63) != 1
      || (unsigned __int8)valid_hex(v64) != 1
      || (unsigned __int8)valid_hex(v65) != 1
      || (unsigned __int8)valid_hex(v66) != 1
      || (unsigned __int8)valid_hex(v67) != 1 )
    {
      V_LOCK();
      logfmt_raw(v37, 0x1000u, 0, "Stratum notify: invalid parameters");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
        173,
        "stratum_notify_ltc",
        18,
        59,
        100,
        v37);
    }
    else
    {
      v13 = strlen(s);
      hex2bin(&v41, s, v13 >> 1);
      nmemb = strlen(v63) >> 1;
      src = calloc(nmemb, 1u);
      if ( src )
      {
        hex2bin(src, v63, nmemb);
        n = strlen(v64) >> 1;
        v58 = calloc(n, 1u);
        if ( v58 )
        {
          hex2bin(v58, v64, n);
          v14 = strlen(v65);
          hex2bin(&v40, v65, v14 >> 1);
          v15 = strlen(v66);
          hex2bin(&v39, v66, v15 >> 1);
          v16 = strlen(v67);
          hex2bin(&v38, v67, v16 >> 1);
          if ( v57 )
          {
            if ( v57[281] && !strcmp((const char *)v57[281], s2) )
            {
              V_LOCK();
              logfmt_raw(v37, 0x1000u, 0, "Stratum notify: new job's job_id doesnot change, %s, %s", v57[281], s2);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
                173,
                "stratum_notify_ltc",
                18,
                84,
                80,
                v37);
            }
            if ( strlen(s2) > 0x3F )
            {
              V_LOCK();
              v17 = strlen(s2);
              logfmt_raw(v37, 0x1000u, 0, "Stratum notify: job_id len = %s, len %d >= %d", s2, v17, 64);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
                173,
                "stratum_notify_ltc",
                18,
                87,
                80,
                v37);
            }
            pthread_mutex_lock((pthread_mutex_t *)(a2 + 398));
            ptr = (void *)v57[281];
            v18 = strdup(s2);
            v57[281] = (int)v18;
            if ( ptr )
            {
              free(ptr);
              ptr = 0;
            }
            if ( a2[75] )
            {
              free((void *)a2[75]);
              a2[75] = 0;
            }
            a2[74] = a2[19] + nmemb + a2[21] + n;
            v50 = a2[74];
            a2[75] = (int)calloc(v50, 1u);
            if ( a2[75] )
            {
              memcpy((void *)a2[75], src, nmemb);
              memcpy((void *)(a2[75] + nmemb), (const void *)a2[20], a2[19]);
              memcpy((void *)(a2[75] + a2[19] + nmemb + a2[21]), v58, n);
              a2[22] = a2[19] + nmemb;
              v19 = v42;
              v20 = v43;
              v21 = v44;
              a2[25] = v41;
              a2[26] = v19;
              a2[27] = v20;
              a2[28] = v21;
              v22 = v46;
              v23 = v47;
              v24 = v48;
              a2[29] = v45;
              a2[30] = v22;
              a2[31] = v23;
              a2[32] = v24;
              a2[83] = v40;
              a2[86] = v39;
              a2[89] = v38;
              for ( i = 0; i < a2[81]; ++i )
              {
                if ( *(_DWORD *)(a2[82] + 4 * i) )
                {
                  free(*(void **)(a2[82] + 4 * i));
                  *(_DWORD *)(a2[82] + 4 * i) = 0;
                }
              }
              a2[81] = 0;
              if ( v55 )
              {
                a2[82] = (int)realloc((void *)a2[82], 4 * v55);
                for ( j = 0; j < v55; ++j )
                {
                  v25 = json_array_get(v56, j);
                  v49 = (char *)json_string_value(v25);
                  v26 = (void **)(a2[82] + 4 * j);
                  *v26 = malloc(0x20u);
                  hex2bin(*(_BYTE **)(a2[82] + 4 * j), v49, 32);
                }
                a2[81] = v55;
              }
              memset(v57 + 2, 0, 0x50u);
              v57[2] = v40;
              v27 = v57 + 3;
              v28 = v42;
              v29 = v43;
              v30 = v44;
              v57[3] = v41;
              v27[1] = v28;
              v27[2] = v29;
              v27[3] = v30;
              v31 = v46;
              v32 = v47;
              v33 = v48;
              v27[4] = v45;
              v27[5] = v31;
              v27[6] = v32;
              v27[7] = v33;
              v57[19] = v38;
              v57[20] = v39;
              *((_BYTE *)a2 + 444) = v54;
              *(_QWORD *)v57 = *a2;
              v68 = 1;
              pthread_mutex_unlock((pthread_mutex_t *)(a2 + 398));
            }
            else
            {
              V_LOCK();
              logfmt_raw(v37, 0x1000u, 0, "Failed to calloc pool coinbase");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
                173,
                "stratum_notify_ltc",
                18,
                98,
                100,
                v37);
              pthread_mutex_unlock((pthread_mutex_t *)(a2 + 398));
            }
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v37, 0x1000u, 0, "Failed to calloc pool coinbase2");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
            173,
            "stratum_notify_ltc",
            18,
            74,
            100,
            v37);
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v37, 0x1000u, 0, "Failed to calloc pool coinbase1");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
          173,
          "stratum_notify_ltc",
          18,
          67,
          100,
          v37);
      }
    }
  }
  if ( v58 )
  {
    free(v58);
    v58 = 0;
  }
  if ( src )
  {
    free(src);
    src = 0;
  }
  return v68;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004B290) --------------------------------------------------------
int __fastcall sub_4B290(int a1, int a2, const json_t *a3, size_t a4)
{
  json_t *v4; // r0
  json_t *v5; // r0
  char v11[20]; // [sp+20h] [bp-1014h] BYREF
  size_t *v12; // [sp+1020h] [bp-14h]
  int v13; // [sp+1024h] [bp-10h]
  char *s; // [sp+1028h] [bp-Ch]
  int v15; // [sp+102Ch] [bp-8h]

  v15 = 0;
  v13 = a2 + 456;
  v4 = json_array_get(a3, a4);
  s = (char *)json_string_value(v4);
  if ( !s || (strlen(s) & 1) != 0 )
  {
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "Failed to get extranonce1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
      173,
      "stratum_parse_extranonce_ltc",
      28,
      154,
      100,
      v11,
      a4,
      a3);
    return 0;
  }
  v5 = json_array_get(a3, a4 + 1);
  v15 = json_integer_value((int)v5);
  if ( v15 < 2 || v15 > 16 )
  {
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "Get invalid n2size in parse_extranonce, xn2_size=%d", v15);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
      173,
      "stratum_parse_extranonce_ltc",
      28,
      159,
      60,
      v11);
    return 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 1592));
  if ( *(_DWORD *)(a2 + 80) )
  {
    free(*(void **)(a2 + 80));
    *(_DWORD *)(a2 + 80) = 0;
  }
  *(_DWORD *)(a2 + 76) = strlen(s) >> 1;
  *(_DWORD *)(a2 + 80) = calloc(1u, *(_DWORD *)(a2 + 76));
  if ( !*(_DWORD *)(a2 + 80) )
  {
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "Failed to alloc xnonce1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
      173,
      "stratum_parse_extranonce_ltc",
      28,
      168,
      100,
      v11);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 1592));
    return 0;
  }
  hex2bin(*(_BYTE **)(a2 + 80), s, *(_DWORD *)(a2 + 76));
  *(_DWORD *)(a2 + 84) = v15;
  if ( *(_DWORD *)(v13 + 1132) )
  {
    free(*(void **)(v13 + 1132));
    *(_DWORD *)(v13 + 1132) = 0;
  }
  *(_DWORD *)(v13 + 1132) = calloc(1u, 0x14u);
  if ( *(_DWORD *)(v13 + 1132) )
  {
    v12 = *(size_t **)(v13 + 1132);
    *v12 = v15;
    memset(v12 + 1, 0, *v12);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 1592));
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "Stratum set nonce1 %s, nonce2 size=%d", s, v15);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_ltc/fronted_ltc.c",
      173,
      "stratum_parse_extranonce_ltc",
      28,
      194,
      20,
      v11);
    return 1;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "work->private");
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004B7A8) --------------------------------------------------------
int __fastcall sub_4B7A8(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 1124)
    && *(_DWORD *)(a2 + 1580)
    && !strcmp(*(const char **)(a1 + 1124), *(const char **)(a2 + 1580)) )
  {
    return 0;
  }
  else
  {
    return 2;
  }
}

//----- (0004B828) --------------------------------------------------------
void __cdecl gen_hash(unsigned __int8 *data, unsigned __int8 *hash, int len)
{
  unsigned __int8 v4[32]; // [sp+10h] [bp-24h] BYREF

  sha256(data, len, v4);
  sha256(v4, 0x20u, hash);
}

//----- (0004B874) --------------------------------------------------------
void __cdecl flip32(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp-10h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = sub_4A4CC(*((_DWORD *)src_p + i));
}

//----- (0004B8FC) --------------------------------------------------------
int __fastcall sub_4B8FC(int a1, int a2, char *a3)
{
  int v4; // r3
  char v9[12]; // [sp+28h] [bp-44h] BYREF
  char v10[36]; // [sp+34h] [bp-38h] BYREF
  char v11[12]; // [sp+58h] [bp-14h] BYREF
  unsigned int *v12; // [sp+64h] [bp-8h]

  v12 = *(unsigned int **)(a1 + 1132);
  if ( v12 )
  {
    bin2hex((int)v11, a1 + 1072, 4u);
    bin2hex((int)v10, (int)(v12 + 1), *v12);
    bin2hex((int)v9, a1 + 1100, 4u);
    v4 = *(_DWORD *)(a2 + 1920);
    *(_DWORD *)(a2 + 1920) = v4 + 1;
    snprintf(
      a3,
      0xC00u,
      "{\"id\":%d,\"method\":\"mining.submit\",\"params\":[\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"]}",
      v4,
      *(const char **)(a2 + 16),
      *(const char **)(a1 + 1124),
      v10,
      v9,
      v11);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0004BA04) --------------------------------------------------------
void *frontend_runtime_ltc()
{
  void *dest; // [sp+4h] [bp-8h]

  dword_152338 = (int)stratum_connect;
  dword_15233C = (int)stratum_disconnect;
  dword_152340 = (int)stratum_recv_line;
  dword_152344 = (int)stratum_send_line;
  dword_152348 = (int)stratum_login_base;
  dword_15234C = (int)stratum_handle_method_base;
  dword_152350 = (int)pre_stratum_handle_method_base;
  dword_152354 = (int)stratum_handle_response_base;
  dword_152358 = 309500;
  dword_15235C = 309160;
  dword_152360 = (int)stratum_subscribe_base;
  dword_152364 = (int)stratum_authorize_base;
  dword_152368 = 304372;
  dword_15236C = 307856;
  dword_152370 = (int)stratum_set_diff_or_target_base;
  dword_152374 = (int)target_to_diff_ltc;
  dword_152378 = (int)diff_to_target_ltc;
  dword_15237C = (int)target_to_double_diff_ltc;
  dest = calloc(1u, 0x50u);
  memcpy(dest, &dword_152338, 0x50u);
  return dest;
}
// 152338: using guessed type int dword_152338;
// 15233C: using guessed type int dword_15233C;
// 152340: using guessed type int dword_152340;
// 152344: using guessed type int dword_152344;
// 152348: using guessed type int dword_152348;
// 15234C: using guessed type int dword_15234C;
// 152350: using guessed type int dword_152350;
// 152354: using guessed type int dword_152354;
// 152358: using guessed type int dword_152358;
// 15235C: using guessed type int dword_15235C;
// 152360: using guessed type int dword_152360;
// 152364: using guessed type int dword_152364;
// 152368: using guessed type int dword_152368;
// 15236C: using guessed type int dword_15236C;
// 152370: using guessed type int dword_152370;
// 152374: using guessed type int dword_152374;
// 152378: using guessed type int dword_152378;
// 15237C: using guessed type int dword_15237C;

//----- (0004BBB0) --------------------------------------------------------
unsigned int __fastcall sub_4BBB0(unsigned int a1)
{
  return bswap32(a1);
}

//----- (0004BBD8) --------------------------------------------------------
void __fastcall sub_4BBD8(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (0004BC40) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4BC40(int a1, __int64 a2)
{
  V_INT(a1, "poolno", a2);
}

//----- (0004BC74) --------------------------------------------------------
int __fastcall sub_4BC74(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 4BCE0: variable 'v3' is possibly undefined

//----- (0004BD8C) --------------------------------------------------------
int __fastcall sub_4BD8C(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0004BE00) --------------------------------------------------------
int __fastcall sub_4BE00(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004BF24) --------------------------------------------------------
_BYTE *__fastcall sub_4BF24(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0004BF90) --------------------------------------------------------
int __fastcall stratum_handle_method_x7(int a1, int a2, int a3)
{
  json_t *v3; // r0
  char v8[16]; // [sp+24h] [bp-1110h] BYREF
  _DWORD v9[23]; // [sp+1024h] [bp-110h] BYREF
  int v10; // [sp+1080h] [bp-B4h] BYREF
  json_t *v11; // [sp+1120h] [bp-14h]
  char *s1; // [sp+1124h] [bp-10h]
  unsigned __int8 v13; // [sp+112Bh] [bp-9h]
  const json_t *v14; // [sp+112Ch] [bp-8h]

  v13 = 0;
  v14 = json_loads(a3, 0, (json_error_t *)v9);
  if ( v14 )
  {
    v3 = json_object_get(v14, "method");
    s1 = (char *)json_string_value(v3);
    if ( s1 )
    {
      v11 = json_object_get(v14, "params");
      if ( v11 )
      {
        if ( !strcasecmp(s1, "job") )
        {
          v13 = (*(int (__fastcall **)(int, int, json_t *))(a1 + 48))(a1, a2, v11);
          if ( v13 )
            pool_tset(a2, (unsigned __int8 *)(a2 + 1916), 1);
          else
            pool_tclear(a2, (unsigned __int8 *)(a2 + 1916), 0);
        }
        else if ( v13 != 1 )
        {
          V_LOCK();
          logfmt_raw(v8, 0x1000u, 0, "unknown stratum method %s!", a3);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
            172,
            "stratum_handle_method_x7",
            24,
            42,
            80,
            v8);
        }
      }
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "JSON decode failed(%d): %s", v9[0], &v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_handle_method_x7",
      24,
      20,
      100,
      v8);
  }
  if ( v14 )
    sub_4BBD8((int)v14);
  return v13;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004C270) --------------------------------------------------------
int __fastcall pre_stratum_handle_method_x7(int a1, int a2, int a3, _DWORD *a4)
{
  json_t *v4; // r0
  char v10[16]; // [sp+24h] [bp-1110h] BYREF
  _DWORD v11[23]; // [sp+1024h] [bp-110h] BYREF
  int v12; // [sp+1080h] [bp-B4h] BYREF
  json_t *v13; // [sp+1120h] [bp-14h]
  char *s1; // [sp+1124h] [bp-10h]
  unsigned __int8 v15; // [sp+112Bh] [bp-9h]
  const json_t *v16; // [sp+112Ch] [bp-8h]

  v15 = 0;
  v16 = json_loads(a3, 0, (json_error_t *)v11);
  if ( v16 )
  {
    v4 = json_object_get(v16, "method");
    s1 = (char *)json_string_value(v4);
    if ( s1 )
    {
      v13 = json_object_get(v16, "params");
      if ( v13 )
      {
        if ( !strcasecmp(s1, "job") )
        {
          v15 = (*(int (__fastcall **)(int, int, json_t *))(a1 + 48))(a1, a2, v13);
          if ( v15 )
          {
            *a4 = "notify";
            pool_tset(a2, (unsigned __int8 *)(a2 + 1916), 1);
          }
          else
          {
            pool_tclear(a2, (unsigned __int8 *)(a2 + 1916), 0);
          }
        }
        else if ( v15 != 1 )
        {
          V_LOCK();
          logfmt_raw(v10, 0x1000u, 0, "unknown stratum method %s!", a3);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
            172,
            "pre_stratum_handle_method_x7",
            28,
            83,
            80,
            v10);
        }
      }
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "JSON decode failed(%d): %s", v11[0], &v12);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "pre_stratum_handle_method_x7",
      28,
      60,
      100,
      v10);
  }
  if ( v16 )
    sub_4BBD8((int)v16);
  return v15;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004C574) --------------------------------------------------------
int __fastcall stratum_login_x7(int a1, int *a2)
{
  size_t v2; // r4
  size_t v3; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  int v6; // r5
  json_t *v7; // r0
  const char *v8; // r0
  json_t *v9; // r0
  const char *v10; // r0
  json_t *v11; // r0
  const char *v12; // r0
  json_t *v13; // r0
  const char *v14; // r0
  char v18[40]; // [sp+3Ch] [bp-11E8h] BYREF
  _DWORD v19[23]; // [sp+103Ch] [bp-1E8h] BYREF
  int v20; // [sp+1098h] [bp-18Ch] BYREF
  _DWORD v21[7]; // [sp+1138h] [bp-ECh] BYREF
  int v22; // [sp+1154h] [bp-D0h]
  _DWORD v23[7]; // [sp+1158h] [bp-CCh] BYREF
  int v24; // [sp+1174h] [bp-B0h]
  _DWORD v25[7]; // [sp+1178h] [bp-ACh] BYREF
  int v26; // [sp+1194h] [bp-90h]
  _DWORD v27[7]; // [sp+1198h] [bp-8Ch] BYREF
  int v28; // [sp+11B4h] [bp-70h]
  _DWORD v29[7]; // [sp+11B8h] [bp-6Ch] BYREF
  int v30; // [sp+11D4h] [bp-50h]
  _DWORD v31[7]; // [sp+11D8h] [bp-4Ch] BYREF
  int v32; // [sp+11F4h] [bp-30h]
  json_t *v33; // [sp+11F8h] [bp-2Ch]
  const json_t *v34; // [sp+11FCh] [bp-28h]
  unsigned __int8 v35; // [sp+1203h] [bp-21h]
  char *s; // [sp+1204h] [bp-20h]
  void *ptr; // [sp+1208h] [bp-1Ch]
  const json_t *v38; // [sp+120Ch] [bp-18h]
  int v39; // [sp+1210h] [bp-14h]
  const json_t *v40; // [sp+1214h] [bp-10h]

  v38 = 0;
  v35 = 0;
  v39 = 0;
  *((_BYTE *)a2 + 1656) = 1;
  v2 = strlen((const char *)a2[4]);
  v3 = strlen((const char *)a2[5]);
  s = (char *)malloc(v2 + v3 + 128);
  sprintf(
    s,
    "{\"id\": %d, \"jsonrpc\":\"2.0\", \"method\":\"login\", \"params\": {\"login\":\"%s\", \"pass\":\"%s\", \"agent\":\""
    "USER_AGENT\", \"algo\":[\"rx/0\"]}}",
    1,
    (const char *)a2[4],
    (const char *)a2[5]);
  if ( (*(unsigned __int8 (__fastcall **)(int *, char *))(a1 + 12))(a2, s) == 1 )
  {
    while ( 1 )
    {
      ptr = (void *)(*(int (__fastcall **)(int *))(a1 + 8))(a2);
      if ( !ptr )
        break;
      if ( (*(unsigned __int8 (__fastcall **)(int, int *, void *))(a1 + 20))(a1, a2, ptr) != 1 )
      {
        v38 = json_loads((int)ptr, 0, (json_error_t *)v19);
        if ( ptr )
          free(ptr);
        if ( v38 )
        {
          v4 = json_object_get(v38, "id");
          v39 = json_integer_value((int)v4);
          if ( v39 == 1 )
          {
            v40 = json_object_get(v38, "error");
            if ( !v40 || *(_DWORD *)v40 == 7 )
            {
              v34 = json_object_get(v38, "result");
              if ( v34 && !*(_DWORD *)v34 )
              {
                v9 = json_object_get(v34, "status");
                v10 = json_string_value(v9);
                if ( !strcasecmp(v10, "OK") )
                {
                  pthread_mutex_lock((pthread_mutex_t *)(a2 + 415));
                  v11 = json_object_get(v34, "id");
                  v12 = json_string_value(v11);
                  strcpy((char *)a2 + 1684, v12);
                  v13 = json_object_get(v34, "id");
                  v14 = json_string_value(v13);
                  if ( strlen(v14) > 0x3F )
                  {
                    V_LOCK();
                    sub_4BC40((int)v29, *a2);
                    logfmt_raw(
                      v18,
                      0x1000u,
                      0,
                      v30,
                      v29[0],
                      v29[1],
                      v29[2],
                      v29[3],
                      v29[4],
                      v29[5],
                      v29[6],
                      v30,
                      "rpc id len larger than 64!");
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release"
                      "/build/godminer-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
                      172,
                      "stratum_login_x7",
                      16,
                      155,
                      80,
                      v18);
                  }
                  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 415));
                  v33 = json_object_get(v34, "job");
                  if ( v33 && !*(_DWORD *)v33 )
                  {
                    if ( (*(int (__fastcall **)(int, int *, json_t *))(a1 + 48))(a1, a2, v33) )
                      pool_tset((int)a2, (unsigned __int8 *)a2 + 1916, 1);
                    else
                      pool_tclear((int)a2, (unsigned __int8 *)a2 + 1916, 0);
                    a2[480] = 2;
                    v35 = 1;
                  }
                  else
                  {
                    V_LOCK();
                    sub_4BC40((int)v31, *a2);
                    logfmt_raw(
                      v18,
                      0x1000u,
                      0,
                      v32,
                      v31[0],
                      v31[1],
                      v31[2],
                      v31[3],
                      v31[4],
                      v31[5],
                      v31[6],
                      v32,
                      "login failed result job object error");
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release"
                      "/build/godminer-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
                      172,
                      "stratum_login_x7",
                      16,
                      161,
                      80,
                      v18);
                  }
                }
                else
                {
                  V_LOCK();
                  sub_4BC40((int)v27, *a2);
                  logfmt_raw(
                    v18,
                    0x1000u,
                    0,
                    v28,
                    v27[0],
                    v27[1],
                    v27[2],
                    v27[3],
                    v27[4],
                    v27[5],
                    v27[6],
                    v28,
                    "login failed, status error");
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/b"
                    "uild/godminer-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
                    172,
                    "stratum_login_x7",
                    16,
                    148,
                    80,
                    v18);
                }
              }
              else
              {
                V_LOCK();
                sub_4BC40((int)v25, *a2);
                logfmt_raw(
                  v18,
                  0x1000u,
                  0,
                  v26,
                  v25[0],
                  v25[1],
                  v25[2],
                  v25[3],
                  v25[4],
                  v25[5],
                  v25[6],
                  v26,
                  "login failed, result object error");
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
                  172,
                  "stratum_login_x7",
                  16,
                  143,
                  80,
                  v18);
              }
            }
            else
            {
              V_LOCK();
              sub_4BC40((int)v23, *a2);
              v5 = json_object_get(v40, "code");
              v6 = json_integer_value((int)v5);
              v7 = json_object_get(v40, "message");
              v8 = json_string_value(v7);
              logfmt_raw(
                v18,
                0x1000u,
                0,
                v24,
                v23[0],
                v23[1],
                v23[2],
                v23[3],
                v23[4],
                v23[5],
                v23[6],
                v24,
                "login failed, reason: %d %s",
                v6,
                v8);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
                172,
                "stratum_login_x7",
                16,
                136,
                20,
                v18);
            }
          }
          else
          {
            V_LOCK();
            sub_4BC40((int)v21, *a2);
            logfmt_raw(
              v18,
              0x1000u,
              0,
              v22,
              v21[0],
              v21[1],
              v21[2],
              v21[3],
              v21[4],
              v21[5],
              v21[6],
              v22,
              "login failed, req id %d != 1",
              v39);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
              172,
              "stratum_login_x7",
              16,
              129,
              80,
              v18);
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v18, 0x1000u, 0, "JSON decode failed(%d): %s", v19[0], &v20);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
            172,
            "stratum_login_x7",
            16,
            123,
            100,
            v18);
        }
        break;
      }
      free(ptr);
    }
  }
  if ( s )
    free(s);
  if ( v38 )
    sub_4BBD8((int)v38);
  return v35;
}
// 4C710: conditional instruction was optimized away because %ptr.4!=0
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004CF84) --------------------------------------------------------
int __fastcall sub_4CF84(int a1, int *a2, const json_t *a3)
{
  json_t *v3; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v6; // r0
  json_t *v7; // r0
  json_t *v8; // r0
  json_t *v9; // r0
  json_t *v10; // r0
  json_t *v11; // r0
  json_t *v12; // r0
  json_t *v13; // r0
  json_t *v14; // r0
  __int64 v15; // r0
  int v16; // r0
  __int64 v17; // r2
  int v18; // r1
  char *v19; // r0
  double v21; // r0
  char v25[32]; // [sp+3Ch] [bp-10E0h] BYREF
  char v26; // [sp+103Fh] [bp-DDh]
  __int64 v27; // [sp+1040h] [bp-DCh] BYREF
  unsigned int v28; // [sp+104Ch] [bp-D0h] BYREF
  _DWORD v29[7]; // [sp+1050h] [bp-CCh] BYREF
  int v30; // [sp+106Ch] [bp-B0h]
  _DWORD v31[7]; // [sp+1070h] [bp-ACh] BYREF
  int v32; // [sp+108Ch] [bp-90h]
  _DWORD v33[7]; // [sp+1090h] [bp-8Ch] BYREF
  int v34; // [sp+10ACh] [bp-70h]
  _DWORD v35[7]; // [sp+10B0h] [bp-6Ch] BYREF
  int v36; // [sp+10CCh] [bp-50h]
  char *dest; // [sp+10D0h] [bp-4Ch]
  int *v38; // [sp+10D4h] [bp-48h]
  unsigned int v39; // [sp+10D8h] [bp-44h]
  unsigned int v40; // [sp+10DCh] [bp-40h]
  size_t v41; // [sp+10E0h] [bp-3Ch]
  char *src; // [sp+10E4h] [bp-38h]
  char *s1; // [sp+10E8h] [bp-34h]
  unsigned __int8 v44; // [sp+10EFh] [bp-2Dh]
  int *v45; // [sp+10F0h] [bp-2Ch]
  char *s2; // [sp+10F4h] [bp-28h]
  char *s; // [sp+10F8h] [bp-24h]
  char *v48; // [sp+10FCh] [bp-20h]
  __int64 v49; // [sp+1100h] [bp-1Ch]
  char *v50; // [sp+110Ch] [bp-10h]

  v50 = 0;
  s2 = 0;
  v48 = 0;
  src = 0;
  s = 0;
  s1 = 0;
  v44 = 0;
  v45 = a2 + 114;
  if ( a3 && *(_DWORD *)a3 == 1 )
  {
    v3 = json_array_get(a3, 0);
    s2 = (char *)json_string_value(v3);
    v4 = json_array_get(a3, 1u);
    v50 = (char *)json_string_value(v4);
    v5 = json_array_get(a3, 2u);
    s = (char *)json_string_value(v5);
    v6 = json_array_get(a3, 3u);
    v48 = (char *)json_string_value(v6);
    v7 = json_array_get(a3, 5u);
    v49 = json_integer_value((int)v7);
  }
  else
  {
    v8 = json_object_get(a3, "blob");
    v50 = (char *)json_string_value(v8);
    v9 = json_object_get(a3, "job_id");
    s2 = (char *)json_string_value(v9);
    v10 = json_object_get(a3, "target");
    v48 = (char *)json_string_value(v10);
    v11 = json_object_get(a3, "seed_hash");
    s = (char *)json_string_value(v11);
    v12 = json_object_get(a3, "height");
    v49 = json_integer_value((int)v12);
  }
  v13 = json_object_get(a3, "id");
  src = (char *)json_string_value(v13);
  v14 = json_object_get(a3, "algo");
  s1 = (char *)json_string_value(v14);
  if ( (unsigned __int8)valid_ascii(s2) != 1
    || (unsigned __int8)valid_hex(v50) != 1
    || (unsigned __int8)valid_hex(v48) != 1
    || (unsigned __int8)valid_hex(s) != 1
    || strlen(s) - 64 > 1 )
  {
    V_LOCK();
    logfmt_raw(v25, 0x1000u, 0, "Stratum notify: invalid parameters");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_notify_x7",
      17,
      211,
      100,
      v25);
    return v44;
  }
  if ( s1 && valid_ascii(s1) && strcasecmp(s1, "rx/0") )
  {
    V_LOCK();
    sub_4BC40((int)v29, *a2);
    logfmt_raw(
      v25,
      0x1000u,
      0,
      v30,
      v29[0],
      v29[1],
      v29[2],
      v29[3],
      v29[4],
      v29[5],
      v29[6],
      v30,
      "Stratum notify: algo type is not rx/0");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_notify_x7",
      17,
      217,
      100,
      v25);
    return v44;
  }
  if ( src && valid_ascii(src) )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 415));
    strcpy((char *)a2 + 1684, src);
    if ( strlen(src) > 0x3F )
    {
      V_LOCK();
      sub_4BC40((int)v31, *a2);
      logfmt_raw(
        v25,
        0x1000u,
        0,
        v32,
        v31[0],
        v31[1],
        v31[2],
        v31[3],
        v31[4],
        v31[5],
        v31[6],
        v32,
        "rpc id len larger than 64!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
        172,
        "stratum_notify_x7",
        17,
        226,
        80,
        v25);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 415));
  }
  if ( a2[444] && !strcmp((const char *)a2[444], s2) && a2 == (int *)get_current_pool() )
  {
    V_LOCK();
    logfmt_raw(v25, 0x1000u, 0, "Stratum notify: new job's job_id doesnot change, %s, %s", a2[444], s2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_notify_x7",
      17,
      233,
      80,
      v25);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 445));
  if ( a2[444] )
  {
    free((void *)a2[444]);
    a2[444] = 0;
  }
  a2[444] = (int)strdup(s2);
  if ( a2[437] )
  {
    free((void *)a2[437]);
    a2[437] = 0;
  }
  a2[439] = strlen(v50) >> 1;
  a2[437] = (int)calloc(a2[439], 1u);
  if ( !a2[437] )
  {
    V_LOCK();
    logfmt_raw(v25, 0x1000u, 0, "Failed to calloc pool rpc2_blob");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_notify_x7",
      17,
      244,
      100,
      v25);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 445));
    return v44;
  }
  if ( (unsigned int)a2[439] <= 0x2A || (unsigned int)a2[439] > 0xC6 )
  {
    V_LOCK();
    sub_4BC40((int)v33, *a2);
    logfmt_raw(
      v25,
      0x1000u,
      0,
      v34,
      v33[0],
      v33[1],
      v33[2],
      v33[3],
      v33[4],
      v33[5],
      v33[6],
      v34,
      "rpc blob len (%d) error!",
      a2[439]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_notify_x7",
      17,
      250,
      100,
      v25);
    V_LOCK();
    sub_4BC40((int)v35, *a2);
    logfmt_raw(v25, 0x1000u, 0, v36, v35[0], v35[1], v35[2], v35[3], v35[4], v35[5], v35[6], v36, "blob %s", v50);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_notify_x7",
      17,
      251,
      100,
      v25);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 445));
    return v44;
  }
  hex2bin((_BYTE *)a2[437], v50, a2[439]);
  v41 = strlen(v48) >> 1;
  if ( v41 != 4 && v41 != 8 && v41 != 32 )
  {
    V_LOCK();
    logfmt_raw(v25, 0x1000u, 0, "Stratum notify target len larger than 32");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_notify_x7",
      17,
      260,
      80,
      v25);
  }
  switch ( v41 )
  {
    case 4u:
      hex2bin(&v28, v48, 4);
      if ( v28 )
      {
        LODWORD(v15) = sub_CCDFC(0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFF / v28);
        *((_QWORD *)a2 + 221) = v15;
      }
      else
      {
        V_LOCK();
        logfmt_raw(v25, 0x1000u, 0, "Stratum notify target is zero!");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
          172,
          "stratum_notify_x7",
          17,
          267,
          100,
          v25);
      }
      break;
    case 0x20u:
      v40 = sub_4BBB0((unsigned __int8)*v48);
      v39 = v40;
      if ( v40 )
      {
        v16 = sub_CCDFC(0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFF / v39);
        LODWORD(v17) = v16 + 0x80000000;
        HIDWORD(v17) = v18 - !__CFADD__(v16, 0x80000000);
        *((_QWORD *)a2 + 221) = v17;
      }
      else
      {
        V_LOCK();
        logfmt_raw(v25, 0x1000u, 0, "Stratum notify target is zero!");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
          172,
          "stratum_notify_x7",
          17,
          282,
          100,
          v25);
      }
      break;
    case 8u:
      hex2bin(&v27, v48, 8);
      *((_QWORD *)a2 + 221) = v27;
      break;
  }
  if ( a2[438] )
  {
    free((void *)a2[438]);
    a2[438] = 0;
  }
  if ( a2[440] )
  {
    free((void *)a2[440]);
    a2[440] = 0;
  }
  a2[440] = (int)calloc(1u, 4u);
  *(_DWORD *)a2[440] = 32;
  a2[438] = (int)calloc(*(_DWORD *)a2[440], 1u);
  if ( !a2[438] )
  {
    V_LOCK();
    logfmt_raw(v25, 0x1000u, 0, "Failed to calloc pool rpc2_blob2");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_notify_x7",
      17,
      301,
      100,
      v25);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 445));
    return v44;
  }
  hex2bin((_BYTE *)a2[438], s, *(_DWORD *)a2[440]);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 445));
  if ( !v45 )
    return v44;
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 398));
  *(_QWORD *)v45 = *a2;
  if ( v45[281] )
  {
    free((void *)v45[281]);
    v45[281] = 0;
  }
  v19 = strdup(s2);
  v45[281] = (int)v19;
  v26 = a2[439];
  *((_BYTE *)v45 + 8) = v26;
  memcpy((char *)v45 + 9, (const void *)a2[437], a2[439]);
  v38 = v45 + 12;
  v45[12] = -1;
  if ( v45[283] )
  {
    free((void *)v45[283]);
    v45[283] = 0;
  }
  v45[283] = (int)calloc(1u, 0x90u);
  if ( v45[283] )
  {
    dest = (char *)v45[283];
    strcpy(dest, (const char *)a2 + 1684);
    memcpy(dest + 64, (const void *)a2[438], 0x20u);
    *((_QWORD *)dest + 12) = v49;
    *((_QWORD *)dest + 13) = *((_QWORD *)a2 + 221);
    LODWORD(v21) = sub_CCAD4(*((_QWORD *)a2 + 221));
    *((double *)v45 + 133) = 1.84467441e19 / v21;
    *((_QWORD *)a2 + 226) = *((_QWORD *)v45 + 133);
    sprintf((char *)a2 + 1976, "%13.2f", *((double *)a2 + 226));
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 398));
    return 1;
  }
  printf("invalid pointer(%s)!\n", "work->private");
  return 0;
}
// 4DB94: variable 'v15' is possibly undefined
// 4DC80: variable 'v18' is possibly undefined
// 4E0E4: variable 'v21' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004E190) --------------------------------------------------------
int __fastcall sub_4E190(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 1124)
    && *(_DWORD *)(a2 + 1580)
    && !strcmp(*(const char **)(a1 + 1124), *(const char **)(a2 + 1580)) )
  {
    return 0;
  }
  else
  {
    return 2;
  }
}

//----- (0004E210) --------------------------------------------------------
int __fastcall sub_4E210(int a1, int a2, char *a3)
{
  int v4; // r3
  char v9[68]; // [sp+24h] [bp-58h] BYREF
  char v10[12]; // [sp+68h] [bp-14h] BYREF
  const char *v11; // [sp+74h] [bp-8h]

  v11 = *(const char **)(a1 + 1132);
  if ( v11 )
  {
    bin2hex((int)v10, a1 + 1072, 4u);
    bin2hex((int)v9, (int)(v11 + 112), 0x20u);
    v4 = *(_DWORD *)(a2 + 1920);
    *(_DWORD *)(a2 + 1920) = v4 + 1;
    snprintf(
      a3,
      0xC00u,
      "{\"id\":%d,\"jsonrpc\":\"2.0\",\"method\":\"submit\",\"params\":{\"id\":\"%s\",\"job_id\":\"%s\",\"nonce\":\"%s\","
      "\"result\":\"%s\",\"algo\":\"rx/0\"}}",
      v4,
      v11,
      *(const char **)(a1 + 1124),
      v10,
      v9);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0004E2E8) --------------------------------------------------------
int __fastcall stratum_handle_response_x7(int a1, int a2, int a3)
{
  json_t *v3; // r0
  const char *v4; // r0
  json_t *v5; // r0
  unsigned __int8 *v6; // r0
  char v10[32]; // [sp+24h] [bp-1120h] BYREF
  _DWORD v11[23]; // [sp+1024h] [bp-120h] BYREF
  _DWORD v12[41]; // [sp+1080h] [bp-C4h] BYREF
  unsigned __int8 v13; // [sp+1127h] [bp-1Dh]
  json_t *v14; // [sp+1128h] [bp-1Ch]
  const json_t *v15; // [sp+112Ch] [bp-18h]
  const json_t *v16; // [sp+1130h] [bp-14h]
  const json_t *v17; // [sp+1134h] [bp-10h]
  json_t *v18; // [sp+1138h] [bp-Ch]
  json_t *v19; // [sp+113Ch] [bp-8h]

  v13 = 0;
  v15 = json_loads(a2, 0, (json_error_t *)v11);
  if ( !v15 )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "JSON decode failed(%d): %s", v11[0], v12);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
      172,
      "stratum_handle_response_x7",
      26,
      380,
      40,
      v10);
    goto LABEL_26;
  }
  v14 = json_object_get(v15, "id");
  v18 = json_object_get(v15, "jsonrpc");
  v17 = json_object_get(v15, "error");
  v16 = json_object_get(v15, "result");
  v19 = json_object_get(v16, "job");
  if ( v19 )
  {
    v13 = (*(int (__fastcall **)(int, int, json_t *))(a1 + 48))(a1, a3, v19);
    if ( v13 )
      pool_tset(a3, (unsigned __int8 *)(a3 + 1916), 1);
    else
      pool_tclear(a3, (unsigned __int8 *)(a3 + 1916), 0);
  }
  else
  {
    if ( !v14 || *(_DWORD *)v14 == 7 )
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "%s json id is null!", "stratum_handle_response_x7");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
        172,
        "stratum_handle_response_x7",
        26,
        400,
        20,
        v10);
      goto LABEL_26;
    }
    if ( !v17 )
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "%s no error value!", "stratum_handle_response_x7");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
        172,
        "stratum_handle_response_x7",
        26,
        410,
        20,
        v10);
      goto LABEL_26;
    }
    if ( *(_DWORD *)v17 == 7 )
    {
      if ( !v16
        || *(_DWORD *)v16
        || !json_object_get(v16, "status")
        || *(_DWORD *)json_object_get(v16, "status") != 2
        || (v3 = json_object_get(v16, "status"), v4 = json_string_value(v3), strcasecmp(v4, "OK")) )
      {
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, "%s result value error!", "stratum_handle_response_x7");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
          172,
          "stratum_handle_response_x7",
          26,
          419,
          20,
          v10);
        goto LABEL_26;
      }
      share_result(1, 0, 0, (double *)a3);
    }
    else
    {
      if ( *(_DWORD *)v17 || !json_object_get(v17, "message") || *(_DWORD *)json_object_get(v17, "message") != 2 )
      {
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, "%s error value error!", "stratum_handle_response_x7");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/frontend/frontend_x7/frontend_x7.c",
          172,
          "stratum_handle_response_x7",
          26,
          428,
          20,
          v10);
        goto LABEL_26;
      }
      v5 = json_object_get(v17, "message");
      v6 = (unsigned __int8 *)json_string_value(v5);
      share_result(0, 0, v6, (double *)a3);
      v12[40] = json_integer_value((int)v14);
    }
    v13 = 1;
  }
LABEL_26:
  if ( v15 )
    sub_4BBD8((int)v15);
  return v13;
}
// 4E50C: conditional instruction was optimized away because %var_18.4!=0
// 4E79C: conditional instruction was optimized away because %var_C.4!=0
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004E8F0) --------------------------------------------------------
void *frontend_runtime_x7()
{
  void *dest; // [sp+4h] [bp-8h]

  dword_152388 = (int)stratum_connect;
  dword_15238C = (int)stratum_disconnect;
  dword_152390 = (int)stratum_recv_line;
  dword_152394 = (int)stratum_send_line;
  dword_152398 = (int)stratum_login_x7;
  dword_15239C = (int)stratum_handle_method_x7;
  dword_1523A0 = (int)pre_stratum_handle_method_x7;
  dword_1523A4 = (int)stratum_handle_response_x7;
  dword_1523A8 = 320016;
  dword_1523AC = 319888;
  dword_1523B0 = (int)stratum_subscribe_base;
  dword_1523B4 = (int)stratum_authorize_base;
  dword_1523B8 = 315268;
  dword_1523BC = 0;
  dword_1523C0 = 0;
  dword_1523C4 = 0;
  dword_1523C8 = 0;
  dword_1523CC = 0;
  dest = calloc(1u, 0x54u);
  memcpy(dest, &dword_152388, 0x54u);
  return dest;
}
// 152388: using guessed type int dword_152388;
// 15238C: using guessed type int dword_15238C;
// 152390: using guessed type int dword_152390;
// 152394: using guessed type int dword_152394;
// 152398: using guessed type int dword_152398;
// 15239C: using guessed type int dword_15239C;
// 1523A0: using guessed type int dword_1523A0;
// 1523A4: using guessed type int dword_1523A4;
// 1523A8: using guessed type int dword_1523A8;
// 1523AC: using guessed type int dword_1523AC;
// 1523B0: using guessed type int dword_1523B0;
// 1523B4: using guessed type int dword_1523B4;
// 1523B8: using guessed type int dword_1523B8;
// 1523BC: using guessed type int dword_1523BC;
// 1523C0: using guessed type int dword_1523C0;
// 1523C4: using guessed type int dword_1523C4;
// 1523C8: using guessed type int dword_1523C8;
// 1523CC: using guessed type int dword_1523CC;

//----- (0004EA88) --------------------------------------------------------
int __fastcall sub_4EA88(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 4EAF4: variable 'v3' is possibly undefined

//----- (0004EBA0) --------------------------------------------------------
int __fastcall sub_4EBA0(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0004EC14) --------------------------------------------------------
int __fastcall sub_4EC14(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004ED38) --------------------------------------------------------
_BYTE *__fastcall sub_4ED38(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0004EDA4) --------------------------------------------------------
int __fastcall sub_4EDA4(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+0h] [bp-64h]
  _DWORD v5[9]; // [sp+8h] [bp-5Ch]
  _DWORD v6[9]; // [sp+2Ch] [bp-38h]
  int v7; // [sp+50h] [bp-14h]
  int v8; // [sp+54h] [bp-10h]
  int i; // [sp+58h] [bp-Ch]
  int v10; // [sp+5Ch] [bp-8h]

  v4 = a2;
  v10 = 0;
  v6[0] = *(_DWORD *)"<";
  v6[1] = *(_DWORD *)"2";
  v6[2] = *(_DWORD *)"%";
  v6[3] = *(_DWORD *)" ";
  v6[4] = 17;
  v6[5] = 8;
  v6[6] = 0;
  v6[7] = -6;
  v6[8] = -19;
  v5[0] = -10;
  v5[1] = 0;
  v5[2] = 10;
  v5[3] = 20;
  v5[4] = 30;
  v5[5] = 40;
  v5[6] = 50;
  v5[7] = 60;
  v5[8] = 70;
  v8 = 9;
  if ( a2 >= dword_14E3A4 )
  {
    if ( a2 > dword_14E3A4 )
      v4 = a2 - 1;
  }
  else
  {
    v4 = a2 + 1;
  }
  v7 = v4 - *(_DWORD *)(a1 + 96);
  dword_14E3A4 = v4;
  for ( i = 0; i < v8 - 1; ++i )
  {
    if ( v7 > v6[i + 1] && v7 <= v6[i] )
    {
      v10 = v5[i];
      break;
    }
  }
  if ( v7 > v6[0] )
    v10 = v5[0];
  if ( v7 <= v6[v8 - 1] )
    v10 = v5[v8 - 1];
  v2 = v10;
  if ( v10 >= 100 )
    v2 = 100;
  if ( v5[0] >= v2 )
    return v5[0];
  return v2;
}
// 14E3A4: using guessed type int dword_14E3A4;

//----- (0004EF98) --------------------------------------------------------
int sub_4EF98()
{
  return 0;
}

//----- (0004EFD0) --------------------------------------------------------
int __fastcall sub_4EFD0(int a1)
{
  if ( a1 == -64 )
    return 60;
  if ( a1 < -10 )
    return 40;
  if ( a1 > 34 )
    return 80;
  return 60;
}

//----- (0004F030) --------------------------------------------------------
int __fastcall set_frequency_with_voltage_1491(int a1)
{
  float v1; // r3
  int v3; // r0
  int v4; // r3
  char v5; // r0
  int v6; // r0
  int v7; // r3
  char v8; // r0
  int v9; // r0
  int v10; // r3
  char v11; // r0
  char v14[16]; // [sp+1Ch] [bp-1090h] BYREF
  pthread_t newthread; // [sp+101Ch] [bp-90h] BYREF
  struct timespec v16[2]; // [sp+1020h] [bp-8Ch] BYREF
  int v17; // [sp+1030h] [bp-7Ch] BYREF
  int v18; // [sp+1034h] [bp-78h] BYREF
  int v19; // [sp+1038h] [bp-74h] BYREF
  struct timespec *v20; // [sp+103Ch] [bp-70h]
  struct timespec *tp; // [sp+1040h] [bp-6Ch]
  int v22; // [sp+1044h] [bp-68h]
  int v23; // [sp+1048h] [bp-64h]
  int v24; // [sp+104Ch] [bp-60h]
  int v25; // [sp+1050h] [bp-5Ch]
  int v26; // [sp+1054h] [bp-58h]
  int v27; // [sp+1058h] [bp-54h]
  float v28; // [sp+105Ch] [bp-50h]
  int v29; // [sp+1060h] [bp-4Ch]
  int working_voltage; // [sp+1064h] [bp-48h]
  unsigned int v31; // [sp+1068h] [bp-44h]
  int v32; // [sp+106Ch] [bp-40h]
  float v33; // [sp+1070h] [bp-3Ch]
  float v34; // [sp+1074h] [bp-38h]
  _DWORD *all_created_runtime; // [sp+1078h] [bp-34h]
  int v36; // [sp+107Ch] [bp-30h]
  int j; // [sp+1080h] [bp-2Ch]
  float v38; // [sp+1084h] [bp-28h]
  int v39; // [sp+1088h] [bp-24h]
  int current_voltage; // [sp+108Ch] [bp-20h]
  int v41; // [sp+1090h] [bp-1Ch]
  int v42; // [sp+1094h] [bp-18h]
  int k; // [sp+1098h] [bp-14h]
  int i; // [sp+109Ch] [bp-10h]

  v36 = 0;
  v19 = 0;
  all_created_runtime = get_all_created_runtime(&v19);
  v34 = 12.5;
  v38 = (float)*(int *)(*all_created_runtime + 464);
  if ( *(float *)(*all_created_runtime + 1104) <= *(float *)(a1 + 112) )
    v1 = *(float *)(*all_created_runtime + 1104);
  else
    v1 = *(float *)(a1 + 112);
  v33 = v1;
  v41 = 120000;
  v32 = (int)(float)((float)(v1 - v38) / v34);
  v18 = -64;
  v17 = 255;
  v31 = 10;
  current_voltage = get_current_voltage();
  working_voltage = get_working_voltage();
  v29 = 0;
  v39 = working_voltage;
  v42 = sub_CC518(current_voltage - working_voltage, v31);
  v28 = v33 * *(float *)(a1 + 120);
  if ( *(_DWORD *)(a1 + 100) != -64 )
  {
    v29 = (*(int (__fastcall **)(int, _DWORD))a1)(a1, *(_DWORD *)(a1 + 100));
    v39 = v29 + working_voltage;
    v42 = sub_CC518(current_voltage - (v29 + working_voltage), v31);
  }
  for ( i = 0; i < v32; ++i )
  {
    v38 = v38 + v34;
    if ( v38 > 850.0 )
    {
      v38 = 850.0;
      break;
    }
    for ( j = 0; j < v19; ++j )
    {
      if ( !all_created_runtime[j] )
      {
        printf("invalid pointer(%s)!\n", "be_runtimes[b]");
        return 3;
      }
      v36 = (*(int (__fastcall **)(_DWORD, _DWORD))(all_created_runtime[j] + 192))(all_created_runtime[j], 0);
      if ( v36 )
        return v36;
    }
    usleep(*(_DWORD *)(a1 + 108));
    if ( current_voltage > (int)(2 * v31 + v39) && v38 > v28 && i >= v32 - v42 )
    {
      current_voltage -= v31;
      v36 = (*(int (__fastcall **)(int, int))(a1 + 28))(a1, current_voltage);
      if ( v36 )
        return v36;
      usleep((__useconds_t)sub_30D40);
    }
  }
  v36 = check_temperature_base(a1, &v18, &v17);
  if ( v36 )
    return v36;
  if ( v18 <= 69 && v17 <= 69 )
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "Warming up chains, please wait...");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/ltc_1491/machine_runtime_ltc_1491.c",
      189,
      "set_frequency_with_voltage_1491",
      31,
      188,
      60,
      v14);
  }
  while ( v18 <= 69 && v17 <= 69 && v41 > 0 )
  {
    tp = v16;
    clock_gettime(1, v16);
    fan_pwm_set(0x1Eu);
    sleep(1u);
    for ( j = 0; j < v19; ++j )
    {
      v36 = check_temperature_base(a1, &v18, &v17);
      if ( v36 )
        return v36;
      if ( !dword_1523DC )
      {
        V_LOCK();
        logfmt_raw(v14, 0x1000u, 0, "warming up, min temp %d max temp %d", v18, v17);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/ltc_1491/machine_runtime_ltc_1491.c",
          189,
          "set_frequency_with_voltage_1491",
          31,
          198,
          40,
          v14);
      }
      dword_1523DC = (dword_1523DC + 1) % 10;
    }
    v20 = v16;
    clock_gettime(1, &v16[1]);
    v41 -= (v20[1].tv_nsec - v20->tv_nsec) / 1000000
         + vshld_n_s64(
             4 * (vshld_n_s64(v20[1].tv_sec - v20->tv_sec, 5u) - (v20[1].tv_sec - v20->tv_sec))
           + v20[1].tv_sec
           - v20->tv_sec,
             3u);
  }
  fan_pwm_set(0x32u);
  pthread_create(&newthread, 0, (void *(*)(void *))thread_monitor_temperature_in_startup_stage, (void *)a1);
  if ( *(int *)(a1 + 100) > 7 )
  {
    if ( *(int *)(a1 + 100) > 32 )
    {
      v9 = get_current_voltage();
      v27 = v9;
      v26 = 1350;
      v10 = v9 - 1350;
      if ( v9 - 1350 < 0 )
        v10 = 1350 - v9;
      if ( v10 > 9 )
      {
        V_LOCK();
        logfmt_raw(v14, 0x1000u, 0, "cur_voltage:%d, set voltage to %d", v27, v26);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/ltc_1491/machine_runtime_ltc_1491.c",
          189,
          "set_frequency_with_voltage_1491",
          31,
          232,
          40,
          v14);
        v11 = is_power_init();
        set_voltage_by_steps(v26, v11, 0x64u);
      }
    }
    else
    {
      v6 = get_current_voltage();
      v25 = v6;
      v24 = 1390;
      v7 = v6 - 1390;
      if ( v6 - 1390 < 0 )
        v7 = 1390 - v6;
      if ( v7 > 9 )
      {
        V_LOCK();
        logfmt_raw(v14, 0x1000u, 0, "cur_voltage:%d, set voltage to %d", v25, v24);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/ltc_1491/machine_runtime_ltc_1491.c",
          189,
          "set_frequency_with_voltage_1491",
          31,
          222,
          40,
          v14);
        v8 = is_power_init();
        set_voltage_by_steps(v24, v8, 0x64u);
      }
    }
  }
  else
  {
    v3 = get_current_voltage();
    v23 = v3;
    v22 = 1420;
    v4 = v3 - 1420;
    if ( v3 - 1420 < 0 )
      v4 = 1420 - v3;
    if ( v4 > 9 )
    {
      V_LOCK();
      logfmt_raw(v14, 0x1000u, 0, "cur_voltage:%d, set voltage to %d", v23, v22);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/ltc_1491/machine_runtime_ltc_1491.c",
        189,
        "set_frequency_with_voltage_1491",
        31,
        212,
        40,
        v14);
      v5 = is_power_init();
      set_voltage_by_steps(v22, v5, 0x64u);
    }
  }
  *(_BYTE *)(a1 + 128) = 1;
  sleep(1u);
  pthread_join(newthread, 0);
  v34 = 6.25;
  v32 = (int)(float)((float)(v33 - v38) / 6.25);
  for ( k = 0; k < v32; ++k )
  {
    v38 = v38 + v34;
    for ( j = 0; j < v19; ++j )
    {
      if ( !all_created_runtime[j] )
      {
        printf("invalid pointer(%s)!\n", "be_runtimes[b]");
        return 3;
      }
      v36 = (*(int (__fastcall **)(_DWORD, _DWORD))(all_created_runtime[j] + 192))(all_created_runtime[j], 0);
      if ( v36 )
        return v36;
    }
    usleep(*(_DWORD *)(a1 + 108));
  }
  return v36;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1523DC: using guessed type int dword_1523DC;
// 1608F0: using guessed type int g_zc;

//----- (0004FB00) --------------------------------------------------------
void *machine_runtime_ctrl_ltc_1491()
{
  _DWORD s[33]; // [sp+0h] [bp-8Ch] BYREF
  void *dest; // [sp+84h] [bp-8h]

  memset(s, 0, sizeof(s));
  s[0] = 322980;
  s[1] = 323480;
  s[2] = get_working_voltage_base;
  s[3] = start_voltage_monitor_base;
  s[6] = 323536;
  s[7] = set_voltage_base;
  s[8] = start_freq_compensate_thread_base;
  s[9] = calc_freq_compensate_by_temp_base;
  s[10] = set_baud_base;
  s[11] = set_frequency_with_voltage_1491;
  s[12] = start_mining_base;
  s[14] = stop_mining_base;
  s[15] = reset_mining_base;
  s[16] = check_asic_num_base;
  s[17] = check_bringup_temperature_base;
  s[18] = hot_cold_restart_base;
  s[22] = &word_1C200;
  s[23] = 1500000;
  s[26] = 1500;
  s[27] = 500000;
  s[28] = 1157234688;
  s[30] = 1065353216;
  s[31] = "/config/sn";
  dest = calloc(1u, 0x84u);
  if ( dest )
  {
    memcpy(dest, s, 0x84u);
    return dest;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "new_machine_runtime");
    return 0;
  }
}
// 1C200: using guessed type __int16 word_1C200;

//----- (0004FC8C) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4FC8C(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0004FCC0) --------------------------------------------------------
int __fastcall sub_4FCC0(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 4FD2C: variable 'v3' is possibly undefined

//----- (0004FDD8) --------------------------------------------------------
int __fastcall sub_4FDD8(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0004FE4C) --------------------------------------------------------
int __fastcall sub_4FE4C(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0004FF70) --------------------------------------------------------
_BYTE *__fastcall sub_4FF70(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0004FFDC) --------------------------------------------------------
char *__fastcall sub_4FFDC(const char *a1)
{
  int n; // [sp+Ch] [bp-10h]
  char *v4; // [sp+10h] [bp-Ch]
  char *dest; // [sp+14h] [bp-8h]

  dest = (char *)calloc(1u, 8u);
  v4 = strchr(a1, 95);
  n = v4 - a1;
  if ( v4 && n <= 7 )
    strncpy(dest, a1, n);
  return dest;
}

//----- (0005005C) --------------------------------------------------------
char *__fastcall sub_5005C(const char *a1)
{
  size_t v1; // r4
  char *v4; // [sp+8h] [bp-14h]
  char *dest; // [sp+Ch] [bp-10h]

  dest = (char *)calloc(1u, 8u);
  v4 = strchr(a1, 95);
  if ( v4 )
  {
    v1 = strlen(a1);
    if ( v1 - strlen(v4) <= 7 )
      strcpy(dest, v4 + 1);
  }
  return dest;
}

//----- (000500E4) --------------------------------------------------------
int __fastcall get_chip_ft_correspond(_DWORD *a1, _DWORD *a2)
{
  if ( opt_algo == 11 )
    *a1 = &off_14E4A8;
  else
    *a1 = &off_14E5D4;
  *a2 = 25;
  return 0;
}
// 14D664: using guessed type int opt_algo;
// 14E4A8: using guessed type char *off_14E4A8;
// 14E5D4: using guessed type char *off_14E5D4;

//----- (00050150) --------------------------------------------------------
int __fastcall support_of_sleepmode(unsigned int a1)
{
  return a1 <= 2 || a1 == 4 || a1 == 3 || a1 == 5 || a1 == 8;
}

//----- (000501D8) --------------------------------------------------------
_DWORD *sub_501D8()
{
  _DWORD *result; // r0
  char v1[16]; // [sp+14h] [bp-1010h] BYREF
  int v2; // [sp+1014h] [bp-10h] BYREF
  int i; // [sp+1018h] [bp-Ch]
  _DWORD *v4; // [sp+101Ch] [bp-8h]

  v2 = 0;
  result = get_all_created_runtime(&v2);
  v4 = result;
  for ( i = 0; i < v2; ++i )
  {
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, "chain[%d] %s", i, v4[i] + 320);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "show_backend_info",
      17,
      82,
      20,
      v1);
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, "chain[%d] %x", i, *(_DWORD *)(v4[i] + 328));
    V_UNLOCK();
    result = (_DWORD *)zlog(
                         g_zc,
                         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rele"
                         "ase/build/godminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
                         176,
                         "show_backend_info",
                         17,
                         83,
                         20,
                         v1);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00050364) --------------------------------------------------------
int __fastcall sub_50364(int a1)
{
  int v1; // r4
  int v2; // r4
  int v3; // r4
  int v4; // r4
  int v5; // r4
  int psu_gpio_port; // r0
  int v9; // [sp+8h] [bp-24h] BYREF
  __int16 v10; // [sp+Ch] [bp-20h] BYREF
  _DWORD *all_created_runtime; // [sp+10h] [bp-1Ch]
  void *ptr; // [sp+14h] [bp-18h]
  char *src; // [sp+18h] [bp-14h]
  int i; // [sp+1Ch] [bp-10h]

  src = sub_4FFDC(off_14E3AC[a1]);
  ptr = sub_5005C(off_14E3AC[a1]);
  v10 = 0;
  str2hex((int)&v10, (int)ptr, 4);
  v9 = 0;
  all_created_runtime = get_all_created_runtime(&v9);
  for ( i = 0; i < v9; ++i )
  {
    strcpy((char *)(all_created_runtime[i] + 320), src);
    *(_DWORD *)(all_created_runtime[i] + 328) = ((unsigned __int8)v10 << 8) | HIBYTE(v10);
    *(_DWORD *)(all_created_runtime[i] + 1128) = platform_is_adjustable_power();
    v1 = all_created_runtime[i];
    *(_DWORD *)(v1 + 396) = platform_get_chain_sensor_num(i);
    v2 = all_created_runtime[i];
    *(_DWORD *)(v2 + 400) = platform_get_sensor_max_chip_temp(i);
    v3 = all_created_runtime[i];
    *(_DWORD *)(v3 + 404) = platform_get_sensor_max_pcb_temp(i);
    v4 = all_created_runtime[i];
    *(_DWORD *)(v4 + 408) = platform_get_sensor_min_pcb_temp(i);
    v5 = all_created_runtime[i];
    *(_DWORD *)(v5 + 412) = platform_get_sensor_max_uneffective_count(i);
  }
  free(src);
  free(ptr);
  psu_gpio_port = platform_get_psu_gpio_port();
  set_status(psu_gpio_port);
  return 0;
}
// 14E3AC: using guessed type char *off_14E3AC[18];

//----- (00050564) --------------------------------------------------------
char *__cdecl mg_unlist(const char *arg)
{
  return 0;
}

//----- (00050588) --------------------------------------------------------
int __fastcall set_baud_base(int a1, int a2)
{
  int chain_domain_num; // r0
  int domain_asic_num; // r0
  int v4; // r4
  char asic_addr_interval; // r0
  int (**v6)(); // r0
  char v9[52]; // [sp+18h] [bp-1034h] BYREF
  int v10; // [sp+1018h] [bp-34h] BYREF
  char v11; // [sp+101Fh] [bp-2Dh]
  int v12; // [sp+1020h] [bp-2Ch]
  int v13; // [sp+1024h] [bp-28h]
  int v14; // [sp+1028h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+102Ch] [bp-20h]
  int i; // [sp+1030h] [bp-1Ch]
  int v17; // [sp+1034h] [bp-18h]
  int j; // [sp+1038h] [bp-14h]
  int v19; // [sp+103Ch] [bp-10h]

  v19 = 0;
  v10 = 0;
  all_created_runtime = get_all_created_runtime(&v10);
  if ( a2 > 3000000 )
  {
    v14 = 3;
    v17 = 0;
    V_LOCK();
    chain_domain_num = platform_get_chain_domain_num();
    logfmt_raw(v9, 0x1000u, 0, "chain_domain_num:%d", chain_domain_num);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "set_baud_base",
      13,
      153,
      20,
      v9);
    V_LOCK();
    domain_asic_num = platform_get_domain_asic_num();
    logfmt_raw(v9, 0x1000u, 0, "domain_asic_num :%d", domain_asic_num);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "set_baud_base",
      13,
      154,
      20,
      v9);
    for ( i = platform_get_chain_domain_num() - v14; i >= 0; i -= v14 )
    {
      v4 = i + 1;
      v13 = platform_get_domain_asic_num() * v4 - 1;
      ++v17;
      v12 = 3 * v17 + 15;
      for ( j = 0; j < v10; ++j )
      {
        asic_addr_interval = platform_get_asic_addr_interval(j);
        v11 = asic_addr_interval * v13;
        (*(void (__fastcall **)(_DWORD, _DWORD, int))(all_created_runtime[j] + 104))(
          all_created_runtime[j],
          (unsigned __int8)(asic_addr_interval * v13),
          v12);
      }
    }
    usleep((__useconds_t)"time");
  }
  for ( j = 0; j < v10; ++j )
  {
    (*(void (__fastcall **)(_DWORD, int))(all_created_runtime[j] + 88))(all_created_runtime[j], a2);
    usleep(0x2710u);
  }
  v6 = dev_ctrl();
  ((void (__fastcall *)(int))v6[4])(a2);
  usleep(0x2710u);
  return v19;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000508A0) --------------------------------------------------------
int __fastcall check_bringup_temperature_base(int a1)
{
  int v1; // r3
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int *v6; // lr
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // lr
  int v15; // r1
  int v16; // r2
  int v17; // r3
  char v20[32]; // [sp+34h] [bp-1320h] BYREF
  int v21; // [sp+1034h] [bp-320h]
  int v22; // [sp+1038h] [bp-31Ch]
  int v23; // [sp+103Ch] [bp-318h]
  int v24; // [sp+1040h] [bp-314h]
  int v25; // [sp+1044h] [bp-310h]
  int v26; // [sp+1048h] [bp-30Ch]
  int v27; // [sp+104Ch] [bp-308h]
  int v28; // [sp+1050h] [bp-304h]
  int v29; // [sp+1054h] [bp-300h]
  int v30; // [sp+1058h] [bp-2FCh]
  int v31; // [sp+105Ch] [bp-2F8h]
  int v32; // [sp+1060h] [bp-2F4h]
  int v33; // [sp+1064h] [bp-2F0h]
  int v34; // [sp+1068h] [bp-2ECh]
  int v35; // [sp+106Ch] [bp-2E8h] BYREF
  _DWORD v36[64]; // [sp+1070h] [bp-2E4h] BYREF
  _DWORD v37[64]; // [sp+1170h] [bp-1E4h] BYREF
  _DWORD v38[7]; // [sp+1270h] [bp-E4h] BYREF
  int v39; // [sp+128Ch] [bp-C8h]
  _DWORD v40[7]; // [sp+1290h] [bp-C4h] BYREF
  int v41; // [sp+12ACh] [bp-A8h]
  _DWORD v42[7]; // [sp+12B0h] [bp-A4h] BYREF
  int v43; // [sp+12CCh] [bp-88h]
  _DWORD v44[7]; // [sp+12D0h] [bp-84h] BYREF
  int v45; // [sp+12ECh] [bp-68h]
  _DWORD v46[7]; // [sp+12F0h] [bp-64h] BYREF
  int v47; // [sp+130Ch] [bp-48h]
  int v48; // [sp+1310h] [bp-44h]
  int v49; // [sp+1314h] [bp-40h]
  void *ptr; // [sp+1318h] [bp-3Ch]
  _DWORD *all_created_runtime; // [sp+131Ch] [bp-38h]
  int v52; // [sp+1320h] [bp-34h]
  int v53; // [sp+1324h] [bp-30h]
  int v54; // [sp+1328h] [bp-2Ch]
  int v55; // [sp+132Ch] [bp-28h]
  int v56; // [sp+1330h] [bp-24h]
  int v57; // [sp+1334h] [bp-20h]
  int v58; // [sp+1338h] [bp-1Ch]
  int j; // [sp+133Ch] [bp-18h]
  int i; // [sp+1340h] [bp-14h]
  int k; // [sp+1344h] [bp-10h]

  v52 = 0;
  v53 = 256;
  v54 = 255;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  v35 = 0;
  all_created_runtime = get_all_created_runtime(&v35);
  for ( i = 0; i < v35; ++i )
  {
    v1 = *(_DWORD *)(all_created_runtime[i] + 396);
    if ( v53 < v1 )
      v1 = v53;
    v53 = v1;
  }
  if ( v53 == 256 )
    v53 = 2;
  ptr = calloc(v53 * v35, 0xCu);
  if ( ptr )
  {
    for ( i = 0; i < v35; ++i )
      (*(void (__fastcall **)(_DWORD, char *))(all_created_runtime[i] + 228))(
        all_created_runtime[i],
        (char *)ptr + 12 * v53 * i);
    for ( j = 0; j < v53; ++j )
    {
      for ( i = 0; i < v35; ++i )
      {
        v3 = *(_DWORD *)(all_created_runtime[i] + 392);
        v4 = *(_DWORD *)(all_created_runtime[i] + 396);
        v5 = *(_DWORD *)(all_created_runtime[i] + 400);
        v6 = (int *)(all_created_runtime[i] + 404);
        v28 = *(_DWORD *)(all_created_runtime[i] + 388);
        v29 = v3;
        v30 = v4;
        v31 = v5;
        v7 = v6[1];
        v8 = v6[2];
        v32 = *v6;
        v33 = v7;
        v34 = v8;
        v48 = v28 + 24 * j;
        if ( *((_DWORD *)ptr + 3 * v53 * i + 3 * j + 1) != -64 )
        {
          if ( *(_DWORD *)(v48 + 12) )
          {
            if ( *(_DWORD *)(v48 + 12) == 1 )
            {
              v10 = v56++;
              v36[v10] = *((_DWORD *)ptr + 3 * v53 * i + 3 * j + 1);
              V_LOCK();
              sub_4FC8C((int)v40, *(int *)(all_created_runtime[i] + 252));
              logfmt_raw(
                v20,
                0x1000u,
                0,
                v41,
                v40[0],
                v40[1],
                v40[2],
                v40[3],
                v40[4],
                v40[5],
                v40[6],
                v41,
                "chip temp max: %d",
                *((_DWORD *)ptr + 3 * v53 * i + 3 * j + 1));
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
                176,
                "check_bringup_temperature_base",
                30,
                221,
                40,
                v20);
            }
          }
          else
          {
            v9 = v55++;
            v37[v9] = *((_DWORD *)ptr + 3 * v53 * i + 3 * j + 1);
            V_LOCK();
            sub_4FC8C((int)v38, *(int *)(all_created_runtime[i] + 252));
            logfmt_raw(
              v20,
              0x1000u,
              0,
              v39,
              v38[0],
              v38[1],
              v38[2],
              v38[3],
              v38[4],
              v38[5],
              v38[6],
              v39,
              "chip temp min: %d",
              *((_DWORD *)ptr + 3 * v53 * i + 3 * j + 1));
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
              176,
              "check_bringup_temperature_base",
              30,
              218,
              40,
              v20);
          }
        }
      }
    }
    for ( i = 0; i < v35; ++i )
    {
      v11 = *(_DWORD *)(all_created_runtime[i] + 392);
      v12 = *(_DWORD *)(all_created_runtime[i] + 396);
      v13 = *(_DWORD *)(all_created_runtime[i] + 400);
      v14 = (int *)(all_created_runtime[i] + 404);
      v21 = *(_DWORD *)(all_created_runtime[i] + 388);
      v22 = v11;
      v23 = v12;
      v24 = v13;
      v15 = v14[1];
      v16 = v14[2];
      v25 = *v14;
      v26 = v15;
      v27 = v16;
      for ( k = 0; k < v53; ++k )
      {
        if ( *((_DWORD *)ptr + 3 * v53 * i + 3 * k + 1) == -64 )
        {
          V_LOCK();
          sub_4FC8C((int)v42, *(int *)(all_created_runtime[i] + 252));
          logfmt_raw(
            v20,
            0x1000u,
            0,
            v43,
            v42[0],
            v42[1],
            v42[2],
            v42[3],
            v42[4],
            v42[5],
            v42[6],
            v43,
            "sensor_addr %02x, J0:6",
            *(_DWORD *)(v21 + 24 * k + 20));
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
            176,
            "check_bringup_temperature_base",
            30,
            244,
            100,
            v20);
        }
        else
        {
          v49 = v21 + 24 * k;
          if ( *(_DWORD *)(v49 + 12) )
          {
            if ( *(_DWORD *)(v49 + 12) == 1 )
            {
              if ( check_value_valid_with_stdd((int)v36, v56, *((_DWORD *)ptr + 3 * v53 * i + 3 * k + 1)) )
              {
                ++v58;
              }
              else
              {
                V_LOCK();
                sub_4FC8C((int)v46, *(int *)(all_created_runtime[i] + 252));
                logfmt_raw(
                  v20,
                  0x1000u,
                  0,
                  v47,
                  v46[0],
                  v46[1],
                  v46[2],
                  v46[3],
                  v46[4],
                  v46[5],
                  v46[6],
                  v47,
                  "sensor_addr %02x, J0:6",
                  *(_DWORD *)(v49 + 20));
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
                  176,
                  "check_bringup_temperature_base",
                  30,
                  259,
                  100,
                  v20);
              }
            }
          }
          else if ( check_value_valid_with_stdd((int)v37, v55, *((_DWORD *)ptr + 3 * v53 * i + 3 * k + 1)) )
          {
            ++v57;
            v17 = *((_DWORD *)ptr + 3 * v53 * i + 3 * k + 1);
            if ( v54 < v17 )
              v17 = v54;
            v54 = v17;
          }
          else
          {
            V_LOCK();
            sub_4FC8C((int)v44, *(int *)(all_created_runtime[i] + 252));
            logfmt_raw(
              v20,
              0x1000u,
              0,
              v45,
              v44[0],
              v44[1],
              v44[2],
              v44[3],
              v44[4],
              v44[5],
              v44[6],
              v45,
              "sensor_addr %02x, J0:6",
              *(_DWORD *)(v49 + 20));
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
              176,
              "check_bringup_temperature_base",
              30,
              251,
              100,
              v20);
          }
        }
      }
    }
    free(ptr);
    if ( v57 <= 0 || v58 <= 0 )
    {
      V_LOCK();
      logfmt_raw(v20, 0x1000u, 0, "J0:6, temp sensor error, pls check it, and reboot system");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "check_bringup_temperature_base",
        30,
        271,
        100,
        v20);
      while ( 1 )
        ;
    }
    *(_DWORD *)(a1 + 100) = v54;
    return v52;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "sensor_status");
    return 3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000512A8) --------------------------------------------------------
int __fastcall calc_startup_fan_pwm_base(int a1)
{
  if ( a1 == -64 )
    return 40;
  if ( a1 < -10 )
    return 40;
  if ( a1 > 34 )
    return 80;
  return 60;
}

//----- (00051308) --------------------------------------------------------
int __fastcall get_working_voltage_base(int a1)
{
  int v1; // r0
  int v2; // r3
  char v5[24]; // [sp+20h] [bp-1024h] BYREF
  int v6; // [sp+38h] [bp-100Ch]
  int v7; // [sp+1020h] [bp-24h]
  signed int v8; // [sp+1024h] [bp-20h]
  signed int temp; // [sp+1028h] [bp-1Ch]
  int working_voltage; // [sp+102Ch] [bp-18h]
  int v11; // [sp+1030h] [bp-14h]
  int v12; // [sp+1034h] [bp-10h]

  v12 = 0;
  v11 = 0;
  temp = get_temp(1);
  v8 = get_temp(2);
  working_voltage = get_working_voltage();
  if ( temp != -64 )
  {
    if ( dword_14E700 - temp <= 5 )
    {
      dword_1523F0 = 0;
      v12 = 0;
    }
    else if ( ++dword_1523F0 > 1 )
    {
      v12 = 20;
    }
    dword_14E700 = temp;
    v11 = (*(int (__fastcall **)(int, signed int))a1)(a1, temp);
    v7 = 65;
    platform_get_fan_control_info((int)v5);
    v7 = v6;
    v1 = (*(int (__fastcall **)(int, signed int, signed int, int))(a1 + 4))(a1, temp, v8, v6);
    v12 += v1;
  }
  V_LOCK();
  logfmt_raw(
    v5,
    0x1000u,
    0,
    "pcb_temp_min:%d, chip_temp_max:%d, working_voltage:%d, compensate:%d, bias:%d",
    temp,
    v8,
    working_voltage,
    v11,
    v12);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "get_working_voltage_base",
    24,
    330,
    20,
    v5);
  v2 = *(_DWORD *)(a1 + 104);
  if ( working_voltage + v11 + v12 < v2 )
    return working_voltage + v11 + v12;
  return v2;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14E700: using guessed type int dword_14E700;
// 1523F0: using guessed type int dword_1523F0;
// 1608F0: using guessed type int g_zc;

//----- (00051554) --------------------------------------------------------
void __fastcall __noreturn check_working_voltage(int a1)
{
  int v1; // r0
  int v2; // r3
  char v3; // r0
  char v4; // r0
  char v5[24]; // [sp+1Ch] [bp-1018h] BYREF
  int v6; // [sp+101Ch] [bp-18h] BYREF
  int v7; // [sp+1020h] [bp-14h]
  int current_voltage; // [sp+1024h] [bp-10h]
  void *all_created_runtime; // [sp+1028h] [bp-Ch]
  int v10; // [sp+102Ch] [bp-8h]

  v6 = 0;
  v10 = a1;
  all_created_runtime = get_all_created_runtime(&v6);
  while ( 1 )
  {
    current_voltage = get_current_voltage();
    v1 = (*(int (__fastcall **)(int))(v10 + 8))(v10);
    v7 = v1;
    v2 = current_voltage - v1;
    if ( current_voltage - v1 < 0 )
      v2 = v1 - current_voltage;
    if ( v2 > 9 )
    {
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "cur_voltage:%d, set voltage to %d", current_voltage, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "check_working_voltage",
        21,
        351,
        40,
        v5);
      if ( opt_algo == 9 )
      {
        (*(void (__fastcall **)(int, int))(v10 + 28))(v10, v7);
      }
      else if ( opt_algo == 11 || opt_algo == 12 )
      {
        v3 = is_power_init();
        set_voltage_by_steps(v7, v3, 0x14u);
      }
      else
      {
        v4 = is_power_init();
        set_voltage_by_steps(v7, v4, 0x64u);
      }
    }
    sleep(1u);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D664: using guessed type int opt_algo;
// 1608F0: using guessed type int g_zc;

//----- (000516E8) --------------------------------------------------------
void __fastcall __noreturn check_working_freq(int a1)
{
  float v1; // s0
  int v2; // [sp+24h] [bp-1068h]
  char v3[16]; // [sp+3Ch] [bp-1050h] BYREF
  int v4; // [sp+103Ch] [bp-50h] BYREF
  _QWORD v5[3]; // [sp+1040h] [bp-4Ch] BYREF
  int v6; // [sp+1058h] [bp-34h]
  int v7; // [sp+105Ch] [bp-30h]
  float v8; // [sp+1060h] [bp-2Ch]
  float v9; // [sp+1064h] [bp-28h]
  float v10; // [sp+1068h] [bp-24h]
  signed int temp; // [sp+106Ch] [bp-20h]
  _DWORD *all_created_runtime; // [sp+1070h] [bp-1Ch]
  int v13; // [sp+1074h] [bp-18h]
  int j; // [sp+1078h] [bp-14h]
  int i; // [sp+107Ch] [bp-10h]

  v4 = 0;
  v13 = a1;
  all_created_runtime = get_all_created_runtime(&v4);
  while ( 1 )
  {
    temp = get_temp(1);
    if ( temp != -64 )
    {
      (*(void (__fastcall **)(int, signed int))(v13 + 36))(v13, temp);
      v10 = v1;
      for ( i = 0; i < v4; ++i )
      {
        for ( j = 0; j < *(_DWORD *)(all_created_runtime[i] + 336); ++j )
        {
          pthread_mutex_lock((pthread_mutex_t *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 20));
          *(float *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 8) = v10;
          v9 = v10 + *(float *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 4);
          v8 = *(float *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 12);
          pthread_mutex_unlock((pthread_mutex_t *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 20));
          if ( v8 != v9 )
          {
            if ( !j )
            {
              V_LOCK();
              logfmt_raw(
                v3,
                0x1000u,
                0,
                "before set_frequency_by_temp base freq %.2f bias freq %.2f cur freq %.2f",
                *(float *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 4),
                *(float *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 8),
                *(float *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 12));
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
                176,
                "check_working_freq",
                18,
                399,
                20,
                v3);
              if ( v8 > v9 && v10 < -1.0 )
              {
                V_LOCK();
                sub_4FC8C((int)v5, *(int *)(all_created_runtime[i] + 252));
                logfmt_raw(
                  v3,
                  0x1000u,
                  0,
                  v7,
                  v5[0],
                  v5[1],
                  v5[2],
                  v6,
                  v7,
                  "Chip temperature is too high, enable protection. Bias freq:%.2f",
                  v2,
                  v10);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
                  176,
                  "check_working_freq",
                  18,
                  402,
                  80,
                  v3);
              }
            }
            v1 = v9;
            (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(all_created_runtime[i] + 196))(
              all_created_runtime[i],
              0,
              (unsigned __int8)j);
          }
        }
      }
    }
    sleep(1u);
  }
}
// 51758: variable 'v1' is possibly undefined
// 51A44: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00051B30) --------------------------------------------------------
int __fastcall update_and_automatic_set_freq(_BYTE *a1)
{
  int v3; // [sp+8h] [bp-24h] BYREF
  char v4; // [sp+Fh] [bp-1Dh]
  signed int temp; // [sp+10h] [bp-1Ch]
  _DWORD *all_created_runtime; // [sp+14h] [bp-18h]
  int j; // [sp+18h] [bp-14h]
  unsigned __int8 v8; // [sp+1Fh] [bp-Dh]
  float v9; // [sp+20h] [bp-Ch]
  int i; // [sp+24h] [bp-8h]

  v3 = 0;
  v9 = 0.0;
  all_created_runtime = get_all_created_runtime(&v3);
  temp = get_temp(1);
  v8 = 0;
  v4 = 0;
  if ( temp == -64 )
  {
    *a1 = 0;
  }
  else
  {
    *a1 = 1;
    for ( i = 0; i < v3; ++i )
    {
      (*(void (__fastcall **)(_DWORD, signed int))(all_created_runtime[i] + 200))(all_created_runtime[i], temp);
      v9 = 0.0;
      for ( j = 0; j < *(_DWORD *)(all_created_runtime[i] + 336); ++j )
      {
        v4 = (*(int (__fastcall **)(_DWORD, _DWORD, _DWORD))(all_created_runtime[i] + 204))(
               all_created_runtime[i],
               0,
               (unsigned __int8)j);
        if ( v4 )
          v8 = 1;
        pthread_mutex_lock((pthread_mutex_t *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 20));
        v9 = v9 + *(float *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 12);
        pthread_mutex_unlock((pthread_mutex_t *)(*(_DWORD *)(all_created_runtime[i] + 528) + 44 * j + 20));
      }
      *(_DWORD *)(all_created_runtime[i] + 464) = (int)(float)(v9 / (float)*(int *)(all_created_runtime[i] + 336));
      *(float *)(all_created_runtime[i] + 1104) = v9 / (float)*(int *)(all_created_runtime[i] + 336);
    }
  }
  return v8;
}

//----- (00051DDC) --------------------------------------------------------
void __noreturn check_working_freq_new()
{
  char v0[8]; // [sp+1Ch] [bp-1008h] BYREF
  char v1; // [sp+101Fh] [bp-5h] BYREF

  v1 = 1;
  while ( 1 )
  {
    update_and_automatic_set_freq(&v1);
    if ( v1 != 1 )
    {
      V_LOCK();
      logfmt_raw(v0, 0x1000u, 0, "%s, read temp failed", "check_working_freq_new");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "check_working_freq_new",
        22,
        466,
        100,
        v0);
    }
    sleep(1u);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00051EAC) --------------------------------------------------------
int __fastcall start_voltage_monitor_base(void *a1)
{
  char v3[8]; // [sp+1Ch] [bp-1008h] BYREF

  if ( pthread_create((pthread_t *)&dword_1523E0, 0, (void *(*)(void *))check_working_voltage, a1) )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "voltage monitor create failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_voltage_monitor_base",
      26,
      477,
      100,
      v3);
    return 5;
  }
  else
  {
    pthread_detach(dword_1523E0);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "start_voltage_monitor");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_voltage_monitor_base",
      26,
      481,
      60,
      v3);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1523E0: using guessed type int dword_1523E0;
// 1608F0: using guessed type int g_zc;

//----- (00052010) --------------------------------------------------------
int __fastcall start_freq_compensate_thread_base(void *a1)
{
  char v3[8]; // [sp+1Ch] [bp-1008h] BYREF

  if ( pthread_create((pthread_t *)&dword_1523E4, 0, (void *(*)(void *))check_working_freq_new, a1) )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "freq_compensate_thread create failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_freq_compensate_thread_base",
      33,
      491,
      100,
      v3);
    return 5;
  }
  else
  {
    pthread_detach(dword_1523E4);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "start freq_compensate_thread");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_freq_compensate_thread_base",
      33,
      495,
      60,
      v3);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1523E4: using guessed type int dword_1523E4;
// 1608F0: using guessed type int g_zc;

//----- (00052174) --------------------------------------------------------
void __fastcall __noreturn check_working_temp(int a1)
{
  while ( 1 )
  {
    get_current_voltage();
    (*(void (__fastcall **)(int))(a1 + 68))(a1);
    sleep(0x12Cu);
  }
}

//----- (000521B8) --------------------------------------------------------
int __fastcall start_temp_monitor_base(void *a1)
{
  char v3[8]; // [sp+1Ch] [bp-1008h] BYREF

  if ( pthread_create((pthread_t *)&dword_1523E8, 0, (void *(*)(void *))check_working_temp, a1) )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "temp monitor create failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_temp_monitor_base",
      23,
      516,
      100,
      v3);
    return 5;
  }
  else
  {
    pthread_detach(dword_1523E8);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "start_temp_monitor");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_temp_monitor_base",
      23,
      520,
      60,
      v3);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1523E8: using guessed type int dword_1523E8;
// 1608F0: using guessed type int g_zc;

//----- (0005231C) --------------------------------------------------------
void __noreturn stop_voltage_monitor_base()
{
  pthread_exit(&dword_1523E0);
}
// 1523E0: using guessed type int dword_1523E0;

//----- (00052330) --------------------------------------------------------
void __noreturn stop_temp_monitor_base()
{
  pthread_exit(&dword_1523E8);
}
// 1523E8: using guessed type int dword_1523E8;

//----- (00052344) --------------------------------------------------------
int __fastcall set_voltage_base(int a1, int a2)
{
  char v2; // r0

  v2 = is_power_init();
  set_voltage(a2, v2);
  return 0;
}

//----- (00052384) --------------------------------------------------------
int __fastcall set_frequency_with_voltage_base(int a1)
{
  float v1; // r3
  int v3; // r3
  int v4; // r4
  int eeprom_PT2_freq; // r0
  char v8[60]; // [sp+20h] [bp-227Ch] BYREF
  char v9[32]; // [sp+1020h] [bp-127Ch] BYREF
  char v10[4096]; // [sp+1040h] [bp-125Ch] BYREF
  float v11; // [sp+2040h] [bp-25Ch] BYREF
  float v12[128]; // [sp+2044h] [bp-258h] BYREF
  int v13; // [sp+2244h] [bp-58h] BYREF
  int eeprom_sweep_freq; // [sp+2248h] [bp-54h]
  int v15; // [sp+224Ch] [bp-50h]
  int v16; // [sp+2250h] [bp-4Ch]
  float v17; // [sp+2254h] [bp-48h]
  int v18; // [sp+2258h] [bp-44h]
  int working_voltage; // [sp+225Ch] [bp-40h]
  unsigned int v20; // [sp+2260h] [bp-3Ch]
  float v21; // [sp+2264h] [bp-38h]
  float v22; // [sp+2268h] [bp-34h]
  _DWORD *all_created_runtime; // [sp+226Ch] [bp-30h]
  int v24; // [sp+2270h] [bp-2Ch]
  int j; // [sp+2274h] [bp-28h]
  float v26; // [sp+2278h] [bp-24h]
  float v27; // [sp+227Ch] [bp-20h]
  int current_voltage; // [sp+2280h] [bp-1Ch]
  int v29; // [sp+2284h] [bp-18h]
  int i; // [sp+2288h] [bp-14h]
  unsigned int k; // [sp+228Ch] [bp-10h]

  v24 = 0;
  v13 = 0;
  all_created_runtime = get_all_created_runtime(&v13);
  current_voltage = 0;
  v22 = 6.25;
  v27 = *(float *)(*all_created_runtime + 1100);
  if ( *(float *)(*all_created_runtime + 1104) <= *(float *)(a1 + 112) )
    v1 = *(float *)(*all_created_runtime + 1104);
  else
    v1 = *(float *)(a1 + 112);
  v21 = v1;
  v20 = 10;
  v29 = 0;
  working_voltage = get_working_voltage();
  if ( (unsigned __int8)is_check_asic_voltage_enable() != 1 )
  {
    v24 = set_check_asic_voltage(1);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "set high voltage befor rise freq.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "set_frequency_with_voltage_base",
      31,
      574,
      40,
      v8);
  }
  if ( *(_DWORD *)(a1 + 100) != -64 )
    v29 = (*(int (__fastcall **)(int, _DWORD))a1)(a1, *(_DWORD *)(a1 + 100));
  v18 = v29 + working_voltage;
  v17 = v21 * *(float *)(a1 + 120);
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "Initializing chip cluster, please wait, this may take up to 2 minutes...");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "set_frequency_with_voltage_base",
    31,
    584,
    60,
    v8);
  current_voltage = get_current_voltage();
  v16 = sub_CC518(current_voltage - v18, v20);
  v15 = (int)(float)((float)(v21 - v27) / v22);
  for ( i = 0; i < v15; ++i )
  {
    v27 = v27 + v22;
    for ( j = 0; j < v13; ++j )
    {
      if ( !all_created_runtime[j] )
      {
        printf("invalid pointer(%s)!\n", "be_runtimes[b]");
        return 3;
      }
      v24 = (*(int (__fastcall **)(_DWORD, _DWORD))(all_created_runtime[j] + 192))(all_created_runtime[j], 0);
      if ( v24 )
        return v24;
      usleep(*(_DWORD *)(a1 + 108));
    }
    if ( current_voltage > (int)(2 * v20 + v18) && v27 > v17 && i >= v15 - v16 )
    {
      current_voltage -= v20;
      v24 = (*(int (__fastcall **)(int, int))(a1 + 28))(a1, current_voltage);
      if ( v24 )
        return v24;
      usleep((__useconds_t)sub_30D40);
    }
  }
  if ( v27 != v21 )
  {
    for ( j = 0; j < v13; ++j )
    {
      v24 = (*(int (__fastcall **)(_DWORD, _DWORD))(all_created_runtime[j] + 192))(all_created_runtime[j], 0);
      if ( v24 )
        return v24;
      usleep(*(_DWORD *)(a1 + 108));
    }
  }
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "set PT2_freq to %.2f, current voltage %d", v21, current_voltage);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "set_frequency_with_voltage_base",
    31,
    619,
    60,
    v8);
  if ( byte_1523ED != 1 )
  {
    for ( j = 0; j < v13; ++j )
    {
      if ( api_get_eeprom_fmt_version(*(_DWORD *)(all_created_runtime[j] + 248)) == 4
        && !api_get_eeprom_asic_freqs(*(_DWORD *)(all_created_runtime[j] + 248), v12, &v11) )
      {
        v26 = 0.0;
        memset(v10, 0, sizeof(v10));
        for ( k = 0; k < *(_DWORD *)(all_created_runtime[j] + 336); ++k )
        {
          v26 = v26 + v12[k];
          sprintf(v9, "ASIC-%03d [%.2f] ", k, v12[k]);
          strcat(v10, v9);
          if ( (k & 7) == 7 )
            *(_WORD *)&v10[strlen(v10)] = 10;
        }
        v26 = v26 / (float)*(int *)(all_created_runtime[j] + 336);
        (*(void (__fastcall **)(_DWORD, float *))(all_created_runtime[j] + 216))(all_created_runtime[j], v12);
        v3 = all_created_runtime[j];
        *(_DWORD *)(v3 + 464) = (int)v26;
        *(float *)(all_created_runtime[j] + 1104) = (float)*(int *)(v3 + 464);
        eeprom_sweep_freq = api_get_eeprom_sweep_freq(j);
        V_LOCK();
        v4 = *(_DWORD *)(all_created_runtime[j] + 248);
        eeprom_PT2_freq = api_get_eeprom_PT2_freq(j);
        logfmt_raw(
          v8,
          0x1000u,
          0,
          "chain:%d, PT2_freq: %d, sweep_average_freq: %.2f, sweep_level_freq: %d  sweep_matrix:\n%s",
          v4,
          eeprom_PT2_freq,
          v26,
          eeprom_sweep_freq,
          v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
          176,
          "set_frequency_with_voltage_base",
          31,
          652,
          40,
          v8);
      }
    }
  }
  return v24;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1523ED: using guessed type char byte_1523ED;
// 1608F0: using guessed type int g_zc;

//----- (00052C7C) --------------------------------------------------------
int __fastcall check_asic_num_base(int a1)
{
  int (**v2)(); // r0
  int (**v3)(); // r0
  int (**v4)(); // r0
  int (**v5)(); // r0
  char v8[28]; // [sp+18h] [bp-109Ch] BYREF
  _DWORD s[32]; // [sp+1018h] [bp-9Ch] BYREF
  int v10; // [sp+1098h] [bp-1Ch] BYREF
  int j; // [sp+109Ch] [bp-18h]
  int k; // [sp+10A0h] [bp-14h]
  int v13; // [sp+10A4h] [bp-10h]
  _DWORD *all_created_runtime; // [sp+10A8h] [bp-Ch]
  int i; // [sp+10ACh] [bp-8h]

  v13 = 0;
  v10 = 0;
  all_created_runtime = get_all_created_runtime(&v10);
  for ( i = 0; i < v10; ++i )
  {
    if ( !all_created_runtime[i] )
    {
      printf("invalid pointer(%s)!\n", "be_runtimes[c]");
      return 3;
    }
    v2 = dev_ctrl();
    ((void (__fastcall *)(int))v2[7])(i);
  }
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "all backend runtimes have been poweroff.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "check_asic_num_base",
    19,
    673,
    60,
    v8);
  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "start to check asic num test loop");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "check_asic_num_base",
    19,
    678,
    60,
    v8);
  for ( j = 1; j <= 1000; ++j )
  {
    for ( i = 0; i < v10; ++i )
    {
      v3 = dev_ctrl();
      ((void (__fastcall *)(int))v3[10])(i);
    }
    if ( power_init(byte_1523EC, v10) )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "power init error!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "check_asic_num_base",
        19,
        687,
        100,
        v8);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "Sweep error string = %s.", "V:1");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "check_asic_num_base",
        19,
        688,
        100,
        v8);
      return 300;
    }
    for ( i = 0; i < v10; ++i )
    {
      v4 = dev_ctrl();
      ((void (__fastcall *)(int))v4[9])(i);
    }
    (*(void (__fastcall **)(int, _DWORD))(a1 + 40))(a1, *(_DWORD *)(a1 + 88));
    for ( i = 0; i < v10; ++i )
    {
      v13 = (*(int (__fastcall **)(_DWORD))all_created_runtime[i])(all_created_runtime[i]);
      if ( !v13 )
      {
        for ( k = 0; k <= 2; ++k )
        {
          v5 = dev_ctrl();
          ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v5[6])(
            *(_DWORD *)(all_created_runtime[i] + 248),
            *(_DWORD *)(all_created_runtime[i] + 1108),
            *(_DWORD *)(all_created_runtime[i] + 1128));
          (*(void (__fastcall **)(_DWORD))(all_created_runtime[i] + 232))(all_created_runtime[i]);
          v13 = (*(int (__fastcall **)(_DWORD))(all_created_runtime[i] + 220))(all_created_runtime[i]);
          if ( !v13 )
            break;
        }
        if ( v13 )
          ++s[2 * i];
        (*(void (__fastcall **)(_DWORD))(all_created_runtime[i] + 28))(all_created_runtime[i]);
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, "chain[%d] check asic num test, loop:%d done, total failed times:%d", i, j, s[2 * i]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
          176,
          "check_asic_num_base",
          19,
          719,
          60,
          v8);
      }
    }
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1523EC: using guessed type char byte_1523EC;
// 1608F0: using guessed type int g_zc;

//----- (000532AC) --------------------------------------------------------
int __fastcall check_temperature_base(int a1, int *a2, int *a3)
{
  int v3; // r3
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int *v8; // lr
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r3
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int *v16; // lr
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r3
  int v21; // r3
  int v22; // r3
  char v26[48]; // [sp+3Ch] [bp-12F0h] BYREF
  int v27; // [sp+103Ch] [bp-2F0h]
  int v28; // [sp+1040h] [bp-2ECh]
  int v29; // [sp+1044h] [bp-2E8h]
  int v30; // [sp+1048h] [bp-2E4h]
  int v31; // [sp+104Ch] [bp-2E0h]
  int v32; // [sp+1050h] [bp-2DCh]
  int v33; // [sp+1054h] [bp-2D8h]
  int v34; // [sp+1058h] [bp-2D4h]
  int v35; // [sp+105Ch] [bp-2D0h]
  int v36; // [sp+1060h] [bp-2CCh]
  int v37; // [sp+1064h] [bp-2C8h]
  int v38; // [sp+1068h] [bp-2C4h]
  int v39; // [sp+106Ch] [bp-2C0h]
  int v40; // [sp+1070h] [bp-2BCh]
  _DWORD v41[129]; // [sp+1074h] [bp-2B8h] BYREF
  _DWORD v42[7]; // [sp+1278h] [bp-B4h] BYREF
  int v43; // [sp+1294h] [bp-98h]
  _DWORD v44[7]; // [sp+1298h] [bp-94h] BYREF
  int v45; // [sp+12B4h] [bp-78h]
  _DWORD v46[7]; // [sp+12B8h] [bp-74h] BYREF
  int v47; // [sp+12D4h] [bp-58h]
  int v48; // [sp+12DCh] [bp-50h]
  int v49; // [sp+12E0h] [bp-4Ch]
  void *ptr; // [sp+12E4h] [bp-48h]
  _DWORD *all_created_runtime; // [sp+12E8h] [bp-44h]
  int v52; // [sp+12ECh] [bp-40h]
  int k; // [sp+12F0h] [bp-3Ch]
  int j; // [sp+12F4h] [bp-38h]
  int v55; // [sp+12F8h] [bp-34h]
  int i; // [sp+12FCh] [bp-30h]
  int v57; // [sp+1300h] [bp-2Ch]
  int v58; // [sp+1304h] [bp-28h]
  int v59; // [sp+1308h] [bp-24h]
  int v60; // [sp+130Ch] [bp-20h]
  int v61; // [sp+1310h] [bp-1Ch]
  int v62; // [sp+1314h] [bp-18h]
  int v63; // [sp+1318h] [bp-14h]
  int v64; // [sp+131Ch] [bp-10h]

  v58 = 0;
  v59 = 256;
  v60 = 255;
  v62 = -64;
  v61 = 0;
  v63 = 0;
  v64 = 0;
  v57 = 0;
  v41[0] = 0;
  v52 = 3;
  v55 = 0;
  all_created_runtime = get_all_created_runtime(v41);
  for ( i = 0; i < v41[0]; ++i )
  {
    v3 = *(_DWORD *)(all_created_runtime[i] + 396);
    if ( v59 < v3 )
      v3 = v59;
    v59 = v3;
  }
  if ( v59 == 256 )
    v59 = 2;
  ptr = calloc(v59 * v41[0], 0xCu);
  if ( ptr )
  {
    for ( i = 0; i < v41[0]; ++i )
    {
      v55 = 0;
      while ( (*(int (__fastcall **)(_DWORD, char *))(all_created_runtime[i] + 228))(
                all_created_runtime[i],
                (char *)ptr + 12 * v59 * i) )
      {
        if ( v55 >= v52 )
        {
          V_LOCK();
          logfmt_raw(v26, 0x1000u, 0, "%s, %d read temp err", "check_temperature_base", 761);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
            176,
            "check_temperature_base",
            22,
            761,
            100,
            v26);
          v58 = 4;
        }
        ++v55;
      }
      usleep(0x1388u);
    }
    for ( j = 0; j < v59; ++j )
    {
      for ( i = 0; i < v41[0]; ++i )
      {
        v5 = *(_DWORD *)(all_created_runtime[i] + 392);
        v6 = *(_DWORD *)(all_created_runtime[i] + 396);
        v7 = *(_DWORD *)(all_created_runtime[i] + 400);
        v8 = (int *)(all_created_runtime[i] + 404);
        v34 = *(_DWORD *)(all_created_runtime[i] + 388);
        v35 = v5;
        v36 = v6;
        v37 = v7;
        v9 = v8[1];
        v10 = v8[2];
        v38 = *v8;
        v39 = v9;
        v40 = v10;
        v48 = v34 + 24 * j;
        if ( *((_DWORD *)ptr + 3 * v59 * i + 3 * j + 1) != -64 )
        {
          if ( *(_DWORD *)(v48 + 12) )
          {
            if ( *(_DWORD *)(v48 + 12) == 1 )
            {
              v12 = v63++;
              v41[v12 + 1] = *((_DWORD *)ptr + 3 * v59 * i + 3 * j + 1);
              V_LOCK();
              sub_4FC8C((int)v44, *(int *)(all_created_runtime[i] + 252));
              logfmt_raw(
                v26,
                0x1000u,
                0,
                v45,
                v44[0],
                v44[1],
                v44[2],
                v44[3],
                v44[4],
                v44[5],
                v44[6],
                v45,
                "chip temp max: %d",
                *((_DWORD *)ptr + 3 * v59 * i + 3 * j + 1));
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
                176,
                "check_temperature_base",
                22,
                780,
                20,
                v26);
            }
          }
          else
          {
            v11 = v61++;
            v41[v11 + 65] = *((_DWORD *)ptr + 3 * v59 * i + 3 * j + 1);
            V_LOCK();
            sub_4FC8C((int)v42, *(int *)(all_created_runtime[i] + 252));
            logfmt_raw(
              v26,
              0x1000u,
              0,
              v43,
              v42[0],
              v42[1],
              v42[2],
              v42[3],
              v42[4],
              v42[5],
              v42[6],
              v43,
              "chip temp min: %d",
              *((_DWORD *)ptr + 3 * v59 * i + 3 * j + 1));
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
              176,
              "check_temperature_base",
              22,
              777,
              20,
              v26);
          }
        }
      }
    }
    for ( i = 0; i < v41[0]; ++i )
    {
      v13 = *(_DWORD *)(all_created_runtime[i] + 392);
      v14 = *(_DWORD *)(all_created_runtime[i] + 396);
      v15 = *(_DWORD *)(all_created_runtime[i] + 400);
      v16 = (int *)(all_created_runtime[i] + 404);
      v27 = *(_DWORD *)(all_created_runtime[i] + 388);
      v28 = v13;
      v29 = v14;
      v30 = v15;
      v17 = v16[1];
      v18 = v16[2];
      v31 = *v16;
      v32 = v17;
      v33 = v18;
      for ( k = 0; k < v59; ++k )
      {
        if ( *((_DWORD *)ptr + 3 * v59 * i + 3 * k + 1) == -64 )
        {
          V_LOCK();
          sub_4FC8C((int)v46, *(int *)(all_created_runtime[i] + 252));
          logfmt_raw(
            v26,
            0x1000u,
            0,
            v47,
            v46[0],
            v46[1],
            v46[2],
            v46[3],
            v46[4],
            v46[5],
            v46[6],
            v47,
            "sensor_addr %02x, J0:6",
            *(_DWORD *)(v27 + 24 * k + 20));
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
            176,
            "check_temperature_base",
            22,
            791,
            100,
            v26);
        }
        else
        {
          v49 = v27 + 24 * k;
          if ( *(_DWORD *)(v49 + 12) )
          {
            if ( *(_DWORD *)(v49 + 12) == 1 )
            {
              ++v57;
              v21 = *((_DWORD *)ptr + 3 * v59 * i + 3 * k + 1);
              if ( v60 < v21 )
                v21 = v60;
              v60 = v21;
              v22 = *((_DWORD *)ptr + 3 * v59 * i + 3 * k + 1);
              if ( v62 >= v22 )
                v22 = v62;
              v62 = v22;
            }
          }
          else
          {
            ++v64;
            v19 = *((_DWORD *)ptr + 3 * v59 * i + 3 * k + 1);
            if ( v60 < v19 )
              v19 = v60;
            v60 = v19;
            v20 = *((_DWORD *)ptr + 3 * v59 * i + 3 * k + 1);
            if ( v62 >= v20 )
              v20 = v62;
            v62 = v20;
          }
        }
      }
    }
    free(ptr);
    *a2 = v60;
    *a3 = v62;
    return v58;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "sensor_status");
    return 3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00053BC0) --------------------------------------------------------
int rename_miner_by_eeprom_info_base()
{
  return 0;
}

//----- (00053BE4) --------------------------------------------------------
int __fastcall hot_cold_restart_base(int a1)
{
  __int64 v1; // r0
  int (**v2)(); // r0
  int (**v3)(); // r0
  int (**v4)(); // r0
  int (**v5)(); // r0
  int (**v6)(); // r0
  char v9[32]; // [sp+1Ch] [bp-1020h] BYREF
  int v10; // [sp+101Ch] [bp-20h] BYREF
  unsigned int seconds; // [sp+1020h] [bp-1Ch]
  int k; // [sp+1024h] [bp-18h]
  int v13; // [sp+1028h] [bp-14h]
  _DWORD *all_created_runtime; // [sp+102Ch] [bp-10h]
  int i; // [sp+1030h] [bp-Ch]
  int j; // [sp+1034h] [bp-8h]

  v13 = 0;
  v10 = 0;
  all_created_runtime = get_all_created_runtime(&v10);
  for ( i = 0; i <= 14; ++i )
  {
    power_on();
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "----%s, No.%d begin----", "hot_cold_restart_base", i + 1);
    V_UNLOCK();
    v1 = zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
           176,
           "hot_cold_restart_base",
           21,
           831,
           60,
           v9);
    for ( j = 0; j < v10; ++j )
    {
      v2 = dev_ctrl();
      ((void (__fastcall *)(_DWORD))v2[8])(*(_DWORD *)(all_created_runtime[j] + 248));
      sleep(5u);
      for ( k = 0; k <= 2; ++k )
      {
        v3 = dev_ctrl();
        ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v3[6])(
          *(_DWORD *)(all_created_runtime[j] + 248),
          *(_DWORD *)(all_created_runtime[j] + 1108),
          *(_DWORD *)(all_created_runtime[j] + 1128));
        v13 = (*(int (__fastcall **)(_DWORD))(all_created_runtime[j] + 220))(all_created_runtime[j]);
        if ( !v13 )
          break;
      }
      (*(void (__fastcall **)(_DWORD))(all_created_runtime[j] + 232))(all_created_runtime[j]);
    }
    for ( j = 0; j < v10; ++j )
    {
      HIDWORD(v1) = all_created_runtime;
      if ( *(_DWORD *)(all_created_runtime[j] + 424) != *(_DWORD *)(all_created_runtime[j] + 336) )
      {
        V_LOCK();
        logfmt_raw(
          v9,
          0x1000u,
          0,
          "chain %d check asic number error before increasing freq",
          *(_DWORD *)(all_created_runtime[j] + 252));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
          176,
          "hot_cold_restart_base",
          21,
          850,
          100,
          v9);
LABEL_29:
        fan_pwm_set_max();
        power_off();
        V_LOCK();
        logfmt_raw(v9, 0x1000u, 0, "----%s failed----", "hot_cold_restart_base");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
          176,
          "hot_cold_restart_base",
          21,
          893,
          60,
          v9);
        while ( 1 )
          sleep(1u);
      }
    }
    (*(void (__fastcall **)(int, _DWORD))(a1 + 68))(a1, HIDWORD(v1));
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "check bringup temperature %d C", *(_DWORD *)(a1 + 100));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "hot_cold_restart_base",
      21,
      855,
      60,
      v9);
    check_if_bringup_temp_valid(a1);
    v13 = (*(int (__fastcall **)(int))(a1 + 44))(a1);
    if ( v13 )
      goto LABEL_29;
    for ( j = 0; j < v10; ++j )
    {
      v13 = (*(int (__fastcall **)(_DWORD))(all_created_runtime[j] + 220))(all_created_runtime[j]);
      if ( *(_DWORD *)(all_created_runtime[j] + 424) != *(_DWORD *)(all_created_runtime[j] + 336) )
      {
        V_LOCK();
        logfmt_raw(
          v9,
          0x1000u,
          0,
          "chain %d check asic number error after increasing freq",
          *(_DWORD *)(all_created_runtime[j] + 252));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
          176,
          "hot_cold_restart_base",
          21,
          866,
          100,
          v9);
        goto LABEL_29;
      }
    }
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "----%s, No.%d end----", "hot_cold_restart_base", i + 1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "hot_cold_restart_base",
      21,
      870,
      60,
      v9);
    seconds = 120;
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "----cooling for %d seconds----", seconds);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "hot_cold_restart_base",
      21,
      872,
      60,
      v9);
    power_off();
    fan_pwm_set_max();
    for ( j = 0; j < v10; ++j )
    {
      v4 = dev_ctrl();
      ((void (__fastcall *)(_DWORD))v4[8])(*(_DWORD *)(all_created_runtime[j] + 248));
      v5 = dev_ctrl();
      ((void (__fastcall *)(int))v5[10])(j);
    }
    sleep(seconds);
  }
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "----%s success----", "hot_cold_restart_base");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "hot_cold_restart_base",
    21,
    883,
    60,
    v9);
  power_on();
  for ( j = 0; j < v10; ++j )
  {
    v6 = dev_ctrl();
    ((void (__fastcall *)(_DWORD))v6[8])(*(_DWORD *)(all_created_runtime[j] + 248));
  }
  return 0;
}
// 53F2C: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00054454) --------------------------------------------------------
int __fastcall start_mining_base(int a1)
{
  int (**v2)(); // r0
  int (__fastcall *v3)(int, int); // r4
  int v4; // r0
  int (**v5)(); // r0
  __int64 v6; // r0
  char v9[40]; // [sp+1Ch] [bp-1028h] BYREF
  int v10; // [sp+101Ch] [bp-28h] BYREF
  unsigned int v11; // [sp+1020h] [bp-24h]
  int *v12; // [sp+1024h] [bp-20h]
  int j; // [sp+1028h] [bp-1Ch]
  int v14; // [sp+102Ch] [bp-18h]
  _DWORD *all_created_runtime; // [sp+1030h] [bp-14h]
  int i; // [sp+1034h] [bp-10h]

  v14 = 0;
  v10 = 0;
  all_created_runtime = get_all_created_runtime(&v10);
  for ( i = 0; i < v10; ++i )
  {
    if ( !all_created_runtime[i] )
    {
      printf("invalid pointer(%s)!\n", "be_runtimes[c]");
      return 3;
    }
    v2 = dev_ctrl();
    ((void (__fastcall *)(int))v2[7])(i);
  }
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "all backend runtimes have been poweroff.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "start_mining_base",
    17,
    914,
    60,
    v9);
  if ( support_of_sleepmode(*(_DWORD *)(a1 + 80)) && opt_custom_power_mode == 1 )
  {
    byte_1523EC = 1;
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "sleep on!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_mining_base",
      17,
      920,
      60,
      v9);
  }
  if ( power_init(byte_1523EC, v10) )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, ">> power init error, check PSU please <<");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_mining_base",
      17,
      923,
      100,
      v9);
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "Sweep error string = %s.", "V:1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_mining_base",
      17,
      924,
      100,
      v9);
    return 300;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, ">> power init success <<");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "start_mining_base",
      17,
      927,
      40,
      v9);
    if ( start_heartbeat_thread() )
    {
      return start_heartbeat_thread();
    }
    else if ( opt_algo == 9
           && (v3 = *(int (__fastcall **)(int, int))(a1 + 28),
               v4 = platfrom_get_check_asic_voltage(),
               (v14 = v3(a1, v4)) != 0) )
    {
      return v14;
    }
    else
    {
      (*(void (__fastcall **)(int, _DWORD))(a1 + 40))(a1, *(_DWORD *)(a1 + 88));
      for ( i = 0; i < v10; ++i )
      {
        v14 = (*(int (__fastcall **)(_DWORD))all_created_runtime[i])(all_created_runtime[i]);
        if ( v14 )
          return v14;
      }
      for ( i = 0; i < v10; ++i )
      {
        for ( j = 0; j <= 2; ++j )
        {
          v5 = dev_ctrl();
          ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v5[6])(
            *(_DWORD *)(all_created_runtime[i] + 248),
            *(_DWORD *)(all_created_runtime[i] + 1108),
            *(_DWORD *)(all_created_runtime[i] + 1128));
          v14 = (*(int (__fastcall **)(_DWORD))(all_created_runtime[i] + 220))(all_created_runtime[i]);
          if ( !v14 )
            break;
        }
        (*(void (__fastcall **)(_DWORD))(all_created_runtime[i] + 232))(all_created_runtime[i]);
      }
      if ( v14 )
      {
        return v14;
      }
      else
      {
        check_and_destroy_abnormal_runtime();
        v12 = (int *)get_all_created_runtime(&v10);
        if ( v10 > 0 )
        {
          (*(void (__fastcall **)(int))(a1 + 68))(a1);
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, "check bringup temperature %d C", *(_DWORD *)(a1 + 100));
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
            176,
            "start_mining_base",
            17,
            976,
            60,
            v9);
          check_if_bringup_temp_valid(a1);
          v11 = (*(int (__fastcall **)(_DWORD))(a1 + 24))(*(_DWORD *)(a1 + 100));
          fan_pwm_set(v11);
          for ( i = 0; i < v10; ++i )
          {
            redirect_nonce_output(*v12, v12[i]);
            (*(void (__fastcall **)(int))(v12[i] + 240))(v12[i]);
          }
          if ( *(_DWORD *)(a1 + 80) == 9 )
          {
            (*(void (__fastcall **)(int))(a1 + 68))(a1);
            V_LOCK();
            logfmt_raw(v9, 0x1000u, 0, "check bringup temperature %d C", *(_DWORD *)(a1 + 100));
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
              176,
              "start_mining_base",
              17,
              992,
              60,
              v9);
          }
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, "Initializing, please wait, this may take up 1 minute...");
          V_UNLOCK();
          v6 = zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/buil"
                 "d/godminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
                 176,
                 "start_mining_base",
                 17,
                 999,
                 60,
                 v9);
          v14 = (*(int (__fastcall **)(int, _DWORD))(a1 + 44))(a1, HIDWORD(v6));
          if ( v14 )
          {
            fan_pwm_set_max();
            return v14;
          }
          else
          {
            for ( i = 0; i < v10; ++i )
              (*(void (__fastcall **)(int))(v12[i] + 16))(v12[i]);
            return v14;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, "there is no qualified device remain after check abnormal runtime!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
            176,
            "start_mining_base",
            17,
            962,
            100,
            v9);
          return 102;
        }
      }
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D664: using guessed type int opt_algo;
// 1512C2: using guessed type char opt_custom_power_mode;
// 1523EC: using guessed type char byte_1523EC;
// 1608F0: using guessed type int g_zc;

//----- (00054E18) --------------------------------------------------------
int stop_mining_base()
{
  int (**v1)(); // r0
  int (**v2)(); // r0
  int v4; // [sp+8h] [bp-14h] BYREF
  _DWORD *all_created_runtime; // [sp+Ch] [bp-10h]
  int i; // [sp+10h] [bp-Ch]
  int v7; // [sp+14h] [bp-8h]

  v7 = 0;
  v4 = 0;
  all_created_runtime = get_all_created_runtime(&v4);
  for ( i = 0; i < v4; ++i )
  {
    if ( !all_created_runtime[i] )
    {
      printf("invalid pointer(%s)!\n", "be_runtimes[c]");
      return 3;
    }
    v7 = (*(int (__fastcall **)(_DWORD))(all_created_runtime[i] + 20))(all_created_runtime[i]);
    if ( v7 )
      return v7;
    v1 = dev_ctrl();
    ((void (__fastcall *)(int))v1[7])(i);
    usleep((__useconds_t)"time");
  }
  v2 = dev_ctrl();
  ((void (__fastcall *)(__int16 *))v2[4])(&word_1C200);
  usleep(0x2710u);
  return v7;
}
// 1C200: using guessed type __int16 word_1C200;

//----- (00054F48) --------------------------------------------------------
int reset_mining_base()
{
  return 0;
}

//----- (00054F74) --------------------------------------------------------
int sub_54F74()
{
  return 0;
}

//----- (00054F9C) --------------------------------------------------------
void calc_freq_compensate_by_temp_base()
{
  ;
}

//----- (00054FC8) --------------------------------------------------------
int machine_info_init()
{
  char v2[8]; // [sp+14h] [bp-1008h] BYREF
  int status; // [sp+1014h] [bp-8h]

  status = 0;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "platform_topol_init");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "machine_info_init",
    17,
    1083,
    20,
    v2);
  status = platform_topol_init();
  if ( status )
    exit(status);
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "check_machine_info");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "machine_info_init",
    17,
    1087,
    20,
    v2);
  status = sub_54F74();
  if ( status )
    return status;
  else
    return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00055114) --------------------------------------------------------
int __fastcall sub_55114(const char *a1, _DWORD *a2, _DWORD *a3)
{
  char v8[20]; // [sp+20h] [bp-1014h] BYREF
  int v9; // [sp+1020h] [bp-14h] BYREF
  int v10; // [sp+1024h] [bp-10h] BYREF
  int *v11; // [sp+1028h] [bp-Ch]
  int i; // [sp+102Ch] [bp-8h]

  v10 = 0;
  v11 = &v10;
  *a2 = 0;
  *a3 = 0;
  v9 = 0;
  get_chip_ft_correspond(v11, &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_DWORD *)(*v11 + 12 * i) && strstr(*(const char **)(*v11 + 12 * i), a1) )
    {
      *a2 = *(_DWORD *)(*v11 + 12 * i + 4);
      *a3 = *(_DWORD *)(*v11 + 12 * i + 8);
      return 0;
    }
  }
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "chip_ft %s not in lists", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "get_voltage_and_freq_by_chip_ft",
    31,
    1113,
    100,
    v8);
  return 303;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00055314) --------------------------------------------------------
int __fastcall set_voltage_and_freq_by_eeprom_chip_ft(_DWORD *a1, _DWORD *a2)
{
  int v3; // r2
  int v4; // r2
  char v8[28]; // [sp+18h] [bp-119Ch] BYREF
  char s[384]; // [sp+1018h] [bp-19Ch] BYREF
  _DWORD v10[2]; // [sp+1198h] [bp-1Ch] BYREF
  int eeprom_chip_bin; // [sp+11A0h] [bp-14h]
  const char *eeprom_chip_ft; // [sp+11A4h] [bp-10h]
  int j; // [sp+11A8h] [bp-Ch]
  int i; // [sp+11ACh] [bp-8h]

  eeprom_chip_ft = 0;
  eeprom_chip_bin = 0;
  *a1 = 0;
  *a2 = 0xFFFF;
  v10[1] = get_all_created_runtime(v10);
  for ( i = 0; i < v10[0]; ++i )
  {
    eeprom_chip_ft = (const char *)api_get_eeprom_chip_ft(i);
    eeprom_chip_bin = api_get_eeprom_chip_bin(i);
    snprintf(s, 0x100u, "%s BIN%d", eeprom_chip_ft, eeprom_chip_bin);
    if ( sub_55114(s, &s[4 * i + 320], &s[4 * i + 256]) )
      return 303;
  }
  for ( j = 0; j < v10[0]; ++j )
  {
    v3 = *(_DWORD *)&s[4 * j + 320];
    if ( v3 < *a1 )
      v3 = *a1;
    *a1 = v3;
    v4 = *a2;
    if ( *a2 >= *(_DWORD *)&s[4 * j + 256] )
      v4 = *(_DWORD *)&s[4 * j + 256];
    *a2 = v4;
  }
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "%s vol:%d,freq:%d", "set_voltage_and_freq_by_eeprom_chip_ft", *a1, *a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "set_voltage_and_freq_by_eeprom_chip_ft",
    38,
    1154,
    40,
    v8);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00055588) --------------------------------------------------------
int set_target_temp_by_eeprom_chip_ft()
{
  int v0; // r3
  char v2[28]; // [sp+10h] [bp-111Ch] BYREF
  char s[256]; // [sp+1010h] [bp-11Ch] BYREF
  _DWORD v4[2]; // [sp+1110h] [bp-1Ch] BYREF
  int eeprom_chip_bin; // [sp+1118h] [bp-14h]
  int i; // [sp+111Ch] [bp-10h]
  int v7; // [sp+1120h] [bp-Ch]
  const char *eeprom_chip_ft; // [sp+1124h] [bp-8h]

  eeprom_chip_ft = 0;
  eeprom_chip_bin = 0;
  v7 = 0;
  v4[1] = get_all_created_runtime(v4);
  for ( i = 0; i < v4[0]; ++i )
  {
    eeprom_chip_ft = (const char *)api_get_eeprom_chip_ft(i);
    eeprom_chip_bin = api_get_eeprom_chip_bin(i);
    snprintf(s, 0x100u, "%s BIN%d", eeprom_chip_ft, eeprom_chip_bin);
    if ( strstr(s, "C2 BIN2") || strstr(s, "C2 BIN3") || strstr(s, "C2 BIN4") || strstr(s, "C2 BIN5") )
    {
      v0 = v7;
      if ( v7 >= -5 )
        v0 = -5;
      v7 = v0;
    }
  }
  opt_target_temp_bonus = v7;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "opt_target_temp_bonus %d", opt_target_temp_bonus);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/machine_runtime_base.c",
    176,
    "set_target_temp_by_eeprom_chip_ft",
    33,
    1190,
    40,
    v2);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1513F0: using guessed type int opt_target_temp_bonus;
// 1608F0: using guessed type int g_zc;

//----- (00055760) --------------------------------------------------------
int __fastcall hardware_init(const char *a1)
{
  char pic_device_high; // r0
  int (*v3)(); // r4
  int chain_num; // r0
  int (**v5)(); // r0
  int (**v6)(); // r0
  int v7; // r0
  int (**v8)(); // r0
  int v9; // r0
  int (**v10)(); // r0
  int v11; // r0
  int (**v12)(); // r0
  int v13; // r0
  int (**v14)(); // r0
  int v15; // r0
  char v18[40]; // [sp+34h] [bp-1068h] BYREF
  __int16 v19; // [sp+1034h] [bp-68h]
  char v20; // [sp+1036h] [bp-66h]
  int v21; // [sp+1038h] [bp-64h]
  int v22[14]; // [sp+103Ch] [bp-60h] BYREF
  int device_num; // [sp+1074h] [bp-28h]
  int i; // [sp+1078h] [bp-24h]
  int v25; // [sp+107Ch] [bp-20h]
  int v26; // [sp+1080h] [bp-1Ch]
  int j; // [sp+1084h] [bp-18h]
  char *eeprom_chain_load_state; // [sp+1088h] [bp-14h]
  int v29; // [sp+108Ch] [bp-10h]

  eeprom_chain_load_state = 0;
  v25 = -1;
  if ( is_test_pool != 1 )
  {
    V_LOCK();
    logfmt_raw(v18, 0x1000u, 0, "Miner Bootsup");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "hardware_init",
      13,
      1205,
      40,
      v18);
    strcpy(v18, "Miner Bootsup");
    log_droa(v18);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v18, 0x1000u, 0, "Test pool is Ture");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "hardware_init",
      13,
      1210,
      40,
      v18);
  }
  eeprom_chain_load_state = (char *)machine_info_init();
  if ( eeprom_chain_load_state )
    return (int)eeprom_chain_load_state;
  platform_get_fan_control_info((int)v22);
  fan_control_info_init(
    v22[0],
    v22[1],
    v22[2],
    v22[3],
    v22[4],
    v22[5],
    v22[6],
    v22[7],
    v22[8],
    v22[9],
    v22[10],
    v22[11],
    v22[12]);
  if ( platform_is_pic_mcu_en() )
  {
    pic_device_high = platform_get_pic_device_high(0);
    set_pic_device_high(pic_device_high);
  }
  v3 = dev_ctrl()[2];
  chain_num = platform_get_chain_num();
  if ( ((int (__fastcall *)(int))v3)(chain_num) )
  {
    V_LOCK();
    logfmt_raw(v18, 0x1000u, 0, "dev init failed!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
      176,
      "hardware_init",
      13,
      1226,
      100,
      v18);
    return 301;
  }
  else
  {
    check_fan_valid();
    device_num = query_device_num();
    if ( device_num > 0 )
    {
      for ( i = 0; i < device_num; ++i )
      {
        v5 = dev_ctrl();
        ((void (__fastcall *)(int))v5[10])(i);
        if ( !runtime_ctrl((int)a1) )
        {
          V_LOCK();
          logfmt_raw(v18, 0x1000u, 0, "runtime ctrl error!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
            176,
            "hardware_init",
            13,
            1246,
            80,
            v18);
          return 301;
        }
      }
      sub_50364((int)a1);
      for ( i = 0; i < device_num; ++i )
      {
        V_LOCK();
        v6 = dev_ctrl();
        v7 = ((int (__fastcall *)(int))v6[12])(i);
        logfmt_raw(v18, 0x1000u, 0, "eeprom add device: %d", v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
          176,
          "hardware_init",
          13,
          1255,
          60,
          v18);
        v8 = dev_ctrl();
        v9 = ((int (__fastcall *)(int))v8[12])(i);
        add_eeprom_device(v9);
      }
      v25 = eeprom_load();
      if ( v25 )
      {
        V_LOCK();
        logfmt_raw(v18, 0x1000u, 0, "EEPROM load error!, pls check it");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
          176,
          "hardware_init",
          13,
          1287,
          100,
          v18);
        V_LOCK();
        logfmt_raw(v18, 0x1000u, 0, "Sweep error string = %s.", "J255:4");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
          176,
          "hardware_init",
          13,
          1288,
          100,
          v18);
        return 302;
      }
      else
      {
        v26 = 0;
        for ( j = 0; j < device_num; ++j )
        {
          v21 = 0;
          v19 = 0;
          v20 = 0;
          v22[13] = 0;
          eeprom_chain_load_state = (char *)api_get_eeprom_chain_load_state(j);
          if ( eeprom_chain_load_state == (char *)-1 )
          {
            ++v26;
            V_LOCK();
            v10 = dev_ctrl();
            v11 = ((int (__fastcall *)(int))v10[12])(j);
            logfmt_raw(v18, 0x1000u, 0, "g_eeprom_data is not ready, chain = %d", v11);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
              176,
              "hardware_init",
              13,
              1306,
              100,
              v18);
          }
          else if ( !eeprom_chain_load_state )
          {
            ++v26;
            V_LOCK();
            v12 = dev_ctrl();
            v13 = ((int (__fastcall *)(int))v12[12])(j);
            logfmt_raw(v18, 0x1000u, 0, "Chain%d load EEPROM error.", v13);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
              176,
              "hardware_init",
              13,
              1309,
              100,
              v18);
            V_LOCK();
            v14 = dev_ctrl();
            v15 = ((int (__fastcall *)(int))v14[12])(j);
            logfmt_raw(v18, 0x1000u, 0, "Sweep error string = J%d:4.", v15);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
              176,
              "hardware_init",
              13,
              1310,
              100,
              v18);
          }
        }
        if ( v26 )
        {
          V_LOCK();
          logfmt_raw(v18, 0x1000u, 0, "Error! EEPROM data corrupted. pls check it");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
            176,
            "hardware_init",
            13,
            1336,
            100,
            v18);
          V_LOCK();
          logfmt_raw(v18, 0x1000u, 0, "Sweep error string = %s.", "J255:4");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
            176,
            "hardware_init",
            13,
            1337,
            100,
            v18);
          return 302;
        }
        else
        {
          eeprom_chain_load_state = mg_unlist(a1);
          if ( eeprom_chain_load_state )
          {
            return (int)eeprom_chain_load_state;
          }
          else
          {
            v29 = 0;
            if ( !v25 )
            {
              opt_custom_freq = eeprom_get_min_freq();
              opt_custom_voltage = eeprom_get_max_voltage();
              V_LOCK();
              logfmt_raw(v18, 0x1000u, 0, "MAX voltage: %d", opt_custom_voltage);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
                176,
                "hardware_init",
                13,
                1402,
                40,
                v18);
              V_LOCK();
              logfmt_raw(v18, 0x1000u, 0, "MIN freq: %d", opt_custom_freq);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
                176,
                "hardware_init",
                13,
                1403,
                40,
                v18);
            }
            sub_501D8();
            return (int)eeprom_chain_load_state;
          }
        }
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v18, 0x1000u, 0, "query_device_num error code %d and then exit", device_num);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "hardware_init",
        13,
        1237,
        100,
        v18);
      return 301;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512C3: using guessed type char is_test_pool;
// 1513E4: using guessed type int opt_custom_freq;
// 1513EC: using guessed type int opt_custom_voltage;
// 1608F0: using guessed type int g_zc;

//----- (0005622C) --------------------------------------------------------
int __fastcall check_if_bringup_temp_valid(int a1)
{
  int (**v1)(); // r0
  char v4[24]; // [sp+1Ch] [bp-1018h] BYREF
  int v5; // [sp+101Ch] [bp-18h] BYREF
  _DWORD *all_created_runtime; // [sp+1020h] [bp-14h]
  int i; // [sp+1024h] [bp-10h]
  int j; // [sp+1028h] [bp-Ch]
  int v9; // [sp+102Ch] [bp-8h]

  v9 = 50;
  all_created_runtime = get_all_created_runtime(&v5);
  for ( i = 0; i < v5; ++i )
  {
    if ( *(_DWORD *)(all_created_runtime[i] + 408) > *(_DWORD *)(a1 + 100) || v9 <= *(_DWORD *)(a1 + 100) )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "bringup temperature unacceptable! refuse to start mining");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "check_if_bringup_temp_valid",
        27,
        1424,
        100,
        v4);
      for ( j = 0; j < i; ++j )
      {
        (*(void (__fastcall **)(_DWORD))(all_created_runtime[j] + 20))(all_created_runtime[j]);
        v1 = dev_ctrl();
        ((void (__fastcall *)(_DWORD))v1[7])(*(_DWORD *)(all_created_runtime[j] + 248));
      }
      power_off();
      while ( 1 )
        sleep(1u);
    }
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000563F0) --------------------------------------------------------
int __fastcall thread_monitor_temperature_in_startup_stage(int a1)
{
  int v1; // r3
  int v2; // r3
  char v5[36]; // [sp+18h] [bp-1024h] BYREF
  int v6; // [sp+1018h] [bp-24h] BYREF
  int v7; // [sp+101Ch] [bp-20h] BYREF
  int v8; // [sp+1020h] [bp-1Ch] BYREF
  int v9; // [sp+1024h] [bp-18h]
  int v10; // [sp+1028h] [bp-14h]
  int v11; // [sp+102Ch] [bp-10h]
  void *all_created_runtime; // [sp+1030h] [bp-Ch]
  int v13; // [sp+1034h] [bp-8h]

  v8 = 0;
  all_created_runtime = get_all_created_runtime(&v8);
  v13 = a1;
  v9 = 0;
  v7 = -64;
  v6 = 255;
  v11 = 0;
  v10 = 0;
  while ( 1 )
  {
    v9 = check_temperature_base(v13, &v7, &v6);
    if ( v9 )
    {
      ++v11;
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "read temperature error");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "thread_monitor_temperature_in_startup_stage",
        43,
        1456,
        100,
        v5);
    }
    else
    {
      v11 = 0;
    }
    v1 = v7;
    if ( v6 >= v7 )
      v1 = v6;
    if ( *(_DWORD *)(*(_DWORD *)all_created_runtime + 400) >= v1 )
    {
      v10 = 0;
    }
    else
    {
      ++v10;
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "read temperature exceed limit!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "thread_monitor_temperature_in_startup_stage",
        43,
        1465,
        100,
        v5);
    }
    if ( v11 > 1 || v10 > 1 )
      fan_pwm_set_max();
    if ( !dword_1523F4 )
    {
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "warming up, min temp %d max temp %d", v7, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/machine_runtime_base.c",
        176,
        "thread_monitor_temperature_in_startup_stage",
        43,
        1475,
        40,
        v5);
    }
    dword_1523F4 = (dword_1523F4 + 1) % 10;
    if ( *(_BYTE *)(v13 + 128) )
      break;
    sleep(1u);
  }
  v2 = v13;
  *(_BYTE *)(v13 + 128) = 0;
  return v2;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1523F4: using guessed type int dword_1523F4;
// 1608F0: using guessed type int g_zc;

//----- (000566F4) --------------------------------------------------------
int __fastcall sub_566F4(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 56760: variable 'v3' is possibly undefined

//----- (0005680C) --------------------------------------------------------
int __fastcall sub_5680C(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (00056880) --------------------------------------------------------
int __fastcall sub_56880(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000569A4) --------------------------------------------------------
_BYTE *__fastcall sub_569A4(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00056A10) --------------------------------------------------------
_DWORD *__fastcall machine_runtime_init(int a1, int a2)
{
  char v4[12]; // [sp+18h] [bp-100Ch] BYREF
  int i; // [sp+1018h] [bp-Ch]
  _DWORD *v6; // [sp+101Ch] [bp-8h]

  v6 = 0;
  for ( i = 0; !i && a2 != *(_DWORD *)"\b"; ++i )
    ;
  if ( i != 1 && machine_runtime_ctrl_ltc_1491 )
  {
    v6 = machine_runtime_ctrl_ltc_1491();
    v6[20] = a2;
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "miner type: %d", a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_interface.c",
      181,
      "machine_runtime_init",
      20,
      78,
      20,
      v4);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "not support miner type: %d", a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/machine_runtime_interface.c",
      181,
      "machine_runtime_init",
      20,
      72,
      100,
      v4);
  }
  return v6;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00056BF8) --------------------------------------------------------
void __fastcall machine_runtime_exit(void *a1)
{
  if ( a1 )
    free(a1);
}

//----- (00056C30) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_56C30(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (00056C64) --------------------------------------------------------
int __fastcall sub_56C64(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 56CD0: variable 'v3' is possibly undefined

//----- (00056D7C) --------------------------------------------------------
int __fastcall sub_56D7C(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (00056DF0) --------------------------------------------------------
int __fastcall sub_56DF0(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00056F14) --------------------------------------------------------
_BYTE *__fastcall sub_56F14(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00056F80) --------------------------------------------------------
int __fastcall set_voltage_MP2973(int a1)
{
  int v1; // r3
  char v4[40]; // [sp+34h] [bp-1068h] BYREF
  int v5; // [sp+1034h] [bp-68h] BYREF
  _DWORD v6[7]; // [sp+1038h] [bp-64h] BYREF
  int v7; // [sp+1054h] [bp-48h]
  _DWORD v8[7]; // [sp+1058h] [bp-44h] BYREF
  int v9; // [sp+1074h] [bp-28h]
  int v10; // [sp+1078h] [bp-24h]
  int j; // [sp+107Ch] [bp-20h]
  int i; // [sp+1080h] [bp-1Ch]
  int v13; // [sp+1084h] [bp-18h]
  _DWORD *all_created_runtime; // [sp+1088h] [bp-14h]
  unsigned int v15; // [sp+108Ch] [bp-10h]

  v13 = 0;
  all_created_runtime = get_all_created_runtime(&v5);
  v15 = a1 + 150;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set all chain target voltage is %d mV", v15);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
    187,
    "set_voltage_MP2973",
    18,
    35,
    40,
    v4);
  if ( v15 > 0x672 )
  {
    v1 = 1650;
  }
  else
  {
    v1 = v15;
    if ( v15 < 0x546 )
      v1 = 1350;
  }
  v10 = v1;
  if ( v15 != v1 )
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "target voltage not in [%d %d], set to %d mV", 1350, 1650, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
      187,
      "set_voltage_MP2973",
      18,
      38,
      80,
      v4);
  }
  for ( i = 0; i < v5; ++i )
  {
    for ( j = 0; j <= 2; ++j )
    {
      if ( !set_chain_mps_voltage(*(_DWORD *)(all_created_runtime[i] + 252), 0, v10, v10) )
      {
        V_LOCK();
        sub_56C30((int)v8, i);
        logfmt_raw(
          v4,
          0x1000u,
          0,
          v9,
          v8[0],
          v8[1],
          v8[2],
          v8[3],
          v8[4],
          v8[5],
          v8[6],
          v9,
          "set voltage to %d successfully",
          v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
          187,
          "set_voltage_MP2973",
          18,
          49,
          20,
          v4);
        break;
      }
      V_LOCK();
      sub_56C30((int)v6, i);
      logfmt_raw(
        v4,
        0x1000u,
        0,
        v7,
        v6[0],
        v6[1],
        v6[2],
        v6[3],
        v6[4],
        v6[5],
        v6[6],
        v7,
        "set_chain_mps_voltage failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        187,
        "set_voltage_MP2973",
        18,
        46,
        100,
        v4);
    }
    if ( j > 2 )
      v13 = 109;
  }
  return v13;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00057324) --------------------------------------------------------
int __fastcall sub_57324(int a1, int a2)
{
  signed int v3; // r2
  int v4; // r3
  int current_voltage; // [sp+8h] [bp-14h]
  int v8; // [sp+Ch] [bp-10h]
  int v9; // [sp+10h] [bp-Ch]
  int v10; // [sp+14h] [bp-8h]

  v10 = 0;
  v9 = 10;
  current_voltage = get_current_voltage();
  v8 = a2 - current_voltage;
  if ( a2 == current_voltage )
    return 0;
  if ( v8 < 0 )
    v9 = -10;
  while ( 1 )
  {
    v3 = abs32(v8);
    v4 = v9;
    if ( v9 < 0 )
      v4 = -v9;
    if ( v3 <= v4 )
      break;
    current_voltage += v9;
    v8 -= v9;
    v10 = set_voltage_MP2973(current_voltage);
  }
  if ( a2 != current_voltage )
    v10 = set_voltage_MP2973(a2);
  set_current_voltage(a2);
  return v10;
}

//----- (00057410) --------------------------------------------------------
int __fastcall sub_57410(int a1, int a2)
{
  int v2; // r3
  __int64 v4; // [sp+Ch] [bp-50h]
  int v5; // [sp+14h] [bp-48h]
  __int64 v6; // [sp+18h] [bp-44h]
  __int64 v7; // [sp+20h] [bp-3Ch]
  _DWORD v8[7]; // [sp+28h] [bp-34h]
  int v9; // [sp+44h] [bp-18h]
  int v10; // [sp+48h] [bp-14h]
  int i; // [sp+4Ch] [bp-10h]
  int v12; // [sp+50h] [bp-Ch]
  int v13; // [sp+54h] [bp-8h]

  v8[0] = 17;
  v8[1] = 12;
  v8[2] = 7;
  v8[3] = -3;
  v8[4] = -8;
  v8[5] = -13;
  v8[6] = -18;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v13 = 0;
  v10 = a2 - *(_DWORD *)(a1 + 96);
  v12 = 0;
  v9 = 7;
  if ( a2 >= dword_14E900 )
    v12 = 3;
  if ( a2 == dword_14E900 )
    return dword_1523F8;
  for ( i = 0; i < v9 - 1; ++i )
  {
    if ( v10 > v8[i + 1] + v12 && v10 <= v8[i] + v12 )
    {
      v13 = *((_DWORD *)&v4 + i);
      break;
    }
  }
  if ( v10 > v8[0] + v12 )
    v13 = 0;
  if ( v10 <= v8[v9 - 1] + v12 )
    v13 = *((_DWORD *)&v4 + v9 - 1);
  if ( v13 < dword_1523F8 && a2 <= dword_14E900 )
    v13 = dword_1523F8;
  if ( v13 > dword_1523F8 && a2 >= dword_14E900 )
    v13 = dword_1523F8;
  if ( a2 != dword_14E900 )
    dword_14E900 = a2;
  if ( v13 != dword_1523F8 )
    dword_1523F8 = v13;
  if ( v13 <= 0 )
    return 0;
  v2 = v13;
  if ( v13 >= 120 )
    return 120;
  return v2;
}
// 14E900: using guessed type int dword_14E900;
// 1523F8: using guessed type int dword_1523F8;

//----- (000576D0) --------------------------------------------------------
int __fastcall sub_576D0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+14h] [bp-8h]

  v5 = 0;
  if ( a3 >= a4 || dword_14E904 > 120 )
    dword_14E904 = 0;
  if ( a3 < a4 && dword_14E904 && a2 )
  {
    v5 = 10 * (20 * (a4 - a3) / 100);
    ++dword_14E904;
  }
  if ( a2 <= 0 && dword_14E904 )
  {
    v5 = 20;
    ++dword_14E904;
  }
  return v5;
}
// 14E904: using guessed type int dword_14E904;

//----- (0005780C) --------------------------------------------------------
int __fastcall sub_5780C(int a1)
{
  if ( a1 == -64 )
    return 100;
  if ( a1 < -10 )
    return 60;
  if ( a1 > 34 )
    return 80;
  return 70;
}

//----- (0005786C) --------------------------------------------------------
int set_frequency_with_voltage_x7_2044()
{
  return 0;
}

//----- (00057890) --------------------------------------------------------
int __fastcall check_asic_num_x7(int a1)
{
  int (**v2)(); // r0
  int (**v3)(); // r0
  int (**v4)(); // r0
  char v7[28]; // [sp+18h] [bp-109Ch] BYREF
  _DWORD s[32]; // [sp+1018h] [bp-9Ch] BYREF
  int v9; // [sp+1098h] [bp-1Ch] BYREF
  _DWORD *all_created_runtime; // [sp+109Ch] [bp-18h]
  int i; // [sp+10A0h] [bp-14h]
  int j; // [sp+10A4h] [bp-10h]
  int k; // [sp+10A8h] [bp-Ch]
  int v14; // [sp+10ACh] [bp-8h]

  v14 = 0;
  v9 = 0;
  all_created_runtime = get_all_created_runtime(&v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( !all_created_runtime[i] )
    {
      printf("invalid pointer(%s)!\n", "be_runtimes[c]");
      return 3;
    }
    v2 = dev_ctrl();
    ((void (__fastcall *)(int))v2[7])(i);
  }
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "all backend runtimes have been poweroff.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
    187,
    "check_asic_num_x7",
    17,
    195,
    60,
    v7);
  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "start to check asic num test loop");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
    187,
    "check_asic_num_x7",
    17,
    200,
    60,
    v7);
  for ( j = 1; j <= 1000; ++j )
  {
    for ( i = 0; i < v9; ++i )
    {
      v3 = dev_ctrl();
      ((void (__fastcall *)(int))v3[10])(i);
    }
    if ( power_init(0, v9) )
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "power init error!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        187,
        "check_asic_num_x7",
        17,
        207,
        100,
        v7);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "Sweep error string = %s.", "V:1");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        187,
        "check_asic_num_x7",
        17,
        208,
        100,
        v7);
      return 300;
    }
    (*(void (__fastcall **)(int, _DWORD))(a1 + 40))(a1, *(_DWORD *)(a1 + 88));
    for ( i = 0; i < v9; ++i )
    {
      v14 = (*(int (__fastcall **)(_DWORD))all_created_runtime[i])(all_created_runtime[i]);
      if ( !v14 )
      {
        v4 = dev_ctrl();
        ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v4[6])(
          *(_DWORD *)(all_created_runtime[i] + 248),
          *(_DWORD *)(all_created_runtime[i] + 1108),
          *(_DWORD *)(all_created_runtime[i] + 1128));
      }
    }
    for ( i = 0; i < v9; ++i )
    {
      for ( k = 0; k <= 0; ++k )
      {
        (*(void (__fastcall **)(_DWORD))(all_created_runtime[i] + 232))(all_created_runtime[i]);
        v14 = (*(int (__fastcall **)(_DWORD))(all_created_runtime[i] + 220))(all_created_runtime[i]);
        if ( !v14 )
          break;
      }
      if ( v14 )
      {
        ++s[2 * i];
        sleep(0xAu);
      }
      (*(void (__fastcall **)(_DWORD))(all_created_runtime[i] + 28))(all_created_runtime[i]);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "chain[%d] check asic num test, loop:%d done, total failed times:%d", i, j, s[2 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        187,
        "check_asic_num_x7",
        17,
        234,
        60,
        v7);
    }
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00057EA8) --------------------------------------------------------
int __fastcall start_mining_x7(int a1)
{
  int (**v2)(); // r0
  int (**v3)(); // r0
  __int64 v4; // r0
  char v7[32]; // [sp+1Ch] [bp-1020h] BYREF
  int v8; // [sp+101Ch] [bp-20h] BYREF
  unsigned int v9; // [sp+1020h] [bp-1Ch]
  int *v10; // [sp+1024h] [bp-18h]
  _DWORD *all_created_runtime; // [sp+1028h] [bp-14h]
  int i; // [sp+102Ch] [bp-10h]
  int j; // [sp+1030h] [bp-Ch]
  int v14; // [sp+1034h] [bp-8h]

  v14 = 0;
  v8 = 0;
  all_created_runtime = get_all_created_runtime(&v8);
  for ( i = 0; i < v8; ++i )
  {
    if ( !all_created_runtime[i] )
    {
      printf("invalid pointer(%s)!\n", "be_runtimes[c]");
      return 3;
    }
    v2 = dev_ctrl();
    ((void (__fastcall *)(int))v2[7])(i);
  }
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "all backend runtimes have been poweroff.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
    187,
    "start_mining_x7",
    15,
    252,
    60,
    v7);
  if ( power_init(0, v8) )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, ">> power init error, check PSU please <<");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
      187,
      "start_mining_x7",
      15,
      257,
      100,
      v7);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "Sweep error string = %s.", "V:1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
      187,
      "start_mining_x7",
      15,
      258,
      100,
      v7);
    return 300;
  }
  else if ( start_heartbeat_thread() )
  {
    return start_heartbeat_thread();
  }
  else
  {
    (*(void (__fastcall **)(int, _DWORD))(a1 + 40))(a1, *(_DWORD *)(a1 + 88));
    for ( i = 0; i < v8; ++i )
    {
      v14 = (*(int (__fastcall **)(_DWORD))all_created_runtime[i])(all_created_runtime[i]);
      if ( !v14 )
      {
        v3 = dev_ctrl();
        ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v3[6])(
          *(_DWORD *)(all_created_runtime[i] + 248),
          *(_DWORD *)(all_created_runtime[i] + 1108),
          *(_DWORD *)(all_created_runtime[i] + 1128));
      }
    }
    for ( i = 0; i < v8; ++i )
    {
      for ( j = 0; j <= 0; ++j )
      {
        (*(void (__fastcall **)(_DWORD))(all_created_runtime[i] + 232))(all_created_runtime[i]);
        v14 = (*(int (__fastcall **)(_DWORD))(all_created_runtime[i] + 220))(all_created_runtime[i]);
        if ( !v14 )
          break;
      }
      if ( v14 )
        sleep(0xAu);
    }
    check_and_destroy_abnormal_runtime();
    v10 = (int *)get_all_created_runtime(&v8);
    if ( v8 > 0 )
    {
      v14 = (*(int (__fastcall **)(int, _DWORD))(a1 + 40))(a1, *(_DWORD *)(a1 + 92));
      if ( v14 )
      {
        return v14;
      }
      else
      {
        (*(void (__fastcall **)(int))(a1 + 68))(a1);
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "first time check temperature %d C", *(_DWORD *)(a1 + 100));
        V_UNLOCK();
        v4 = zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
               187,
               "start_mining_x7",
               15,
               300,
               60,
               v7);
        v9 = (*(int (__fastcall **)(_DWORD, _DWORD))(a1 + 24))(*(_DWORD *)(a1 + 100), HIDWORD(v4));
        fan_pwm_set(v9);
        for ( i = 0; i < v8; ++i )
        {
          redirect_nonce_output(*v10, v10[i]);
          (*(void (__fastcall **)(int))(v10[i] + 240))(v10[i]);
        }
        if ( support_of_sleepmode(*(_DWORD *)(a1 + 80)) && *(_DWORD *)&opt_custom_power_mode == 1
          || (v14 = (*(int (__fastcall **)(int))(a1 + 44))(a1)) == 0 )
        {
          for ( i = 0; i < v8; ++i )
          {
            (*(void (__fastcall **)(int))(v10[i] + 4))(v10[i]);
            (*(void (__fastcall **)(int, _DWORD))(v10[i] + 124))(v10[i], *(_DWORD *)(a1 + 84));
            (*(void (__fastcall **)(int))(v10[i] + 16))(v10[i]);
          }
          return v14;
        }
        else
        {
          return v14;
        }
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "there is no qualified device remain after check abnormal runtime!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        187,
        "start_mining_x7",
        15,
        290,
        100,
        v7);
      return 102;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1512C2: using guessed type char opt_custom_power_mode;
// 1608F0: using guessed type int g_zc;

//----- (00058694) --------------------------------------------------------
void *machine_runtime_ctrl_x7_2044()
{
  _DWORD s[33]; // [sp+0h] [bp-8Ch] BYREF
  void *dest; // [sp+84h] [bp-8h]

  memset(s, 0, sizeof(s));
  s[0] = 357392;
  s[1] = 358096;
  s[2] = get_working_voltage_base;
  s[3] = start_voltage_monitor_base;
  s[5] = stop_voltage_monitor_base;
  s[6] = 358412;
  s[7] = 357156;
  s[10] = set_baud_base;
  s[11] = set_frequency_with_voltage_x7_2044;
  s[12] = start_mining_x7;
  s[14] = stop_mining_base;
  s[15] = reset_mining_base;
  s[16] = check_asic_num_x7;
  s[17] = check_bringup_temperature_base;
  s[21] = 35;
  s[22] = &word_1C200;
  s[23] = &word_1C200;
  s[24] = 23;
  s[26] = 1500;
  s[27] = sub_30D40;
  s[28] = 1157234688;
  s[30] = 1065353216;
  s[31] = "/config/sn";
  dest = calloc(1u, 0x84u);
  if ( dest )
  {
    memcpy(dest, s, 0x84u);
    return dest;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "new_machine_runtime");
    return 0;
  }
}
// 1C200: using guessed type __int16 word_1C200;

//----- (00058818) --------------------------------------------------------
int __fastcall sub_58818(int a1)
{
  **(_DWORD **)(a1 + 16) = chip_setting_send_update_cmd_x7(
                             *(_DWORD *)a1,
                             *(_DWORD *)(*(_DWORD *)a1 + 336),
                             *(_BYTE *)(a1 + 8),
                             *(_BYTE **)(a1 + 12));
  return 0;
}

//----- (0005887C) --------------------------------------------------------
int __fastcall sub_5887C(int a1)
{
  **(_DWORD **)(a1 + 24) = chip_setting_get_md5sum_x7(
                             *(_DWORD *)a1,
                             *(_DWORD *)(*(_DWORD *)a1 + 336),
                             *(_BYTE *)(a1 + 8),
                             *(const void **)(a1 + 12),
                             *(_DWORD *)(a1 + 16),
                             *(_BYTE **)(a1 + 20));
  return 0;
}

//----- (00058904) --------------------------------------------------------
int __fastcall sub_58904(int a1, int a2, int a3, char a4, int a5, int a6)
{
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_BYTE *)(a1 + 8) = a4;
  *(_DWORD *)(a1 + 12) = a5;
  *(_DWORD *)(a1 + 16) = a6;
  return 0;
}

//----- (00058970) --------------------------------------------------------
int __fastcall sub_58970(int a1, int a2, int a3, char a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_BYTE *)(a1 + 8) = a4;
  *(_DWORD *)(a1 + 12) = a5;
  *(_DWORD *)(a1 + 16) = a6;
  *(_DWORD *)(a1 + 20) = a7;
  *(_DWORD *)(a1 + 24) = a8;
  return 0;
}

//----- (000589F4) --------------------------------------------------------
int __fastcall update_chip_x7(char a1, float *a2)
{
  unsigned int v3; // r3
  int v4; // r3
  float v5; // s15
  char v9[72]; // [sp+3Ch] [bp-1308h] BYREF
  float v10; // [sp+103Ch] [bp-308h]
  int v11; // [sp+1040h] [bp-304h]
  _DWORD v12[6]; // [sp+1044h] [bp-300h]
  __int16 v13; // [sp+105Ch] [bp-2E8h] BYREF
  char v14; // [sp+105Eh] [bp-2E6h]
  _DWORD v15[6]; // [sp+1060h] [bp-2E4h] BYREF
  unsigned int v16; // [sp+1078h] [bp-2CCh]
  int v17; // [sp+107Ch] [bp-2C8h] BYREF
  _BYTE v18[64]; // [sp+1080h] [bp-2C4h] BYREF
  int v19; // [sp+10C0h] [bp-284h] BYREF
  _DWORD v20[50]; // [sp+10C4h] [bp-280h] BYREF
  unsigned int v21; // [sp+118Ch] [bp-1B8h]
  _BYTE v22[128]; // [sp+1190h] [bp-1B4h] BYREF
  char v23[128]; // [sp+1210h] [bp-134h] BYREF
  _DWORD v24[7]; // [sp+1290h] [bp-B4h] BYREF
  int v25; // [sp+12ACh] [bp-98h]
  _DWORD v26[7]; // [sp+12B0h] [bp-94h] BYREF
  int v27; // [sp+12CCh] [bp-78h]
  _DWORD v28[7]; // [sp+12D0h] [bp-74h] BYREF
  int v29; // [sp+12ECh] [bp-58h]
  int status_x7; // [sp+12F4h] [bp-50h]
  signed int v31; // [sp+12F8h] [bp-4Ch]
  int off; // [sp+12FCh] [bp-48h]
  void *ptr; // [sp+1300h] [bp-44h]
  int i; // [sp+1304h] [bp-40h]
  int j; // [sp+1308h] [bp-3Ch]
  int k; // [sp+130Ch] [bp-38h]
  int m; // [sp+1310h] [bp-34h]
  int n; // [sp+1314h] [bp-30h]
  int ii; // [sp+1318h] [bp-2Ch]
  char v40; // [sp+131Dh] [bp-27h]
  char v41; // [sp+131Eh] [bp-26h]
  char v42; // [sp+131Fh] [bp-25h]
  _DWORD *all_created_runtime; // [sp+1320h] [bp-24h]
  float v44; // [sp+1324h] [bp-20h]
  char *filename; // [sp+1328h] [bp-1Ch]
  unsigned int seconds; // [sp+132Ch] [bp-18h]
  unsigned int v47; // [sp+1330h] [bp-14h]
  FILE *stream; // [sp+1334h] [bp-10h]

  strcpy(v23, "/usr/bin/update_app.zip");
  memset(&v23[24], 0, 0x68u);
  strcpy(v22, "/usr/bin/update_total.zip");
  memset(&v22[26], 0, 0x66u);
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  v40 = 0;
  memset(v18, 0, sizeof(v18));
  v41 = 0;
  v42 = 0;
  all_created_runtime = get_all_created_runtime(&v17);
  v13 = 0;
  v14 = 0;
  seconds = 300;
  v44 = *a2;
  v10 = 0.7;
  v11 = 1050253722;
  if ( a1 )
  {
    filename = v23;
    seconds = 300;
  }
  else
  {
    filename = v22;
    seconds = 1200;
  }
  printf(" %s \n", filename);
  stream = fopen(filename, "r");
  if ( stream )
  {
    fseek(stream, 0, 2);
    v47 = ftell(stream);
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "begin sending update_packets");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
      187,
      "update_chip_x7",
      14,
      487,
      40,
      v9);
    while ( 1 )
    {
      while ( 1 )
      {
        ptr = malloc(0x20Cu);
        memset(ptr, 0, 0x20Cu);
        for ( i = 0; i < v17; ++i )
        {
          status_x7 = sync_unblocked_get_status_x7(all_created_runtime[i], 17, 1, (int)ptr, 20, &v19);
          if ( status_x7 )
          {
            V_LOCK();
            logfmt_raw(v9, 0x1000u, 0, "get update ack packet failed,err code:%d", status_x7);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
              187,
              "update_chip_x7",
              14,
              511,
              100,
              v9);
            free(ptr);
            fclose(stream);
            return 109;
          }
          if ( v19 )
          {
            v16 = *((_DWORD *)ptr + 3);
            v3 = v16;
            if ( v21 < v16 )
              v3 = v21;
            v21 = v3;
            V_LOCK();
            logfmt_raw(v9, 0x1000u, 0, "recv send_again packet, ack_packet_num %d", v21);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
              187,
              "update_chip_x7",
              14,
              501,
              20,
              v9);
          }
        }
        free(ptr);
        off = 196 * v21;
        v4 = v47;
        if ( 196 * v21 < v47 )
          v4 = 196 * v21;
        off = v4;
        if ( (float)((float)((float)((float)((float)(1.0 - v44) * (float)(unsigned int)v4) / (float)v47) * v10) + v44) >= *a2 )
          v5 = (float)((float)((float)((float)(1.0 - v44) * (float)(unsigned int)off) / (float)v47) * v10) + v44;
        else
          v5 = *a2;
        *a2 = v5;
        fseek(stream, off, 0);
        v31 = fread(&v20[1], 1u, 0xC4u, stream);
        if ( v31 < 0 )
        {
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, "err occured while reading file %s ", filename);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
            187,
            "update_chip_x7",
            14,
            526,
            100,
            v9);
          fclose(stream);
          return 306;
        }
        if ( !v31 )
          break;
        v40 = 0;
        v20[0] = v21;
        for ( j = 0; j < v17; ++j )
          chip_setting_send_update_single_packet(all_created_runtime[j], v20, v31 + 4, a1);
        ++v21;
      }
      if ( v40 == 1 )
        break;
      sleep(5u);
      v40 = 1;
    }
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "send packet complete, prepare checking md5 and update, don't shutdown");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
      187,
      "update_chip_x7",
      14,
      549,
      40,
      v9);
    if ( CalcFileMD5(filename, v18) )
    {
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, "run cmd \"md5sum\" failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        187,
        "update_chip_x7",
        14,
        552,
        100,
        v9);
      fclose(stream);
      return 306;
    }
    else
    {
      for ( k = 0; k < v17; ++k )
      {
        v12[k + 3] = malloc(0x1Cu);
        sub_58970(
          v12[k + 3],
          all_created_runtime[k],
          *(_DWORD *)(all_created_runtime[k] + 336),
          a1,
          (int)v18,
          32,
          (int)&v13 + k,
          (int)&v15[k]);
        pthread_create(&v15[k + 3], 0, (void *(*)(void *))sub_5887C, (void *)v12[k + 3]);
      }
      for ( m = 0; m < v17; ++m )
      {
        pthread_join(v15[m + 3], 0);
        free((void *)v12[m + 3]);
        status_x7 = v15[m];
        if ( status_x7 )
        {
          fclose(stream);
          return 306;
        }
        if ( *((unsigned __int8 *)&v13 + m) != *(_DWORD *)(all_created_runtime[m] + 336) )
        {
          fclose(stream);
          return 102;
        }
      }
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, "updating...");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
        187,
        "update_chip_x7",
        14,
        579,
        40,
        v9);
      for ( n = 0; n < v17; ++n )
      {
        v12[n] = malloc(0x14u);
        sub_58904(
          v12[n],
          all_created_runtime[n],
          *(_DWORD *)(all_created_runtime[n] + 336),
          a1,
          (int)&v13 + n,
          (int)&v15[n]);
        pthread_create(&v15[n + 3], 0, (void *(*)(void *))sub_58818, (void *)v12[n]);
      }
      for ( ii = 0; ii < v17; ++ii )
      {
        pthread_join(v15[ii + 3], 0);
        free((void *)v12[ii]);
        status_x7 = v15[ii];
        if ( status_x7 )
        {
          V_LOCK();
          sub_56C30((int)v24, *(int *)(all_created_runtime[ii] + 252));
          logfmt_raw(
            v9,
            0x1000u,
            0,
            v25,
            v24[0],
            v24[1],
            v24[2],
            v24[3],
            v24[4],
            v24[5],
            v24[6],
            v25,
            "chip update err code %d, wait %ds and shutdown...",
            status_x7,
            seconds);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
            187,
            "update_chip_x7",
            14,
            596,
            100,
            v9);
          sleep(seconds);
          fclose(stream);
          return 306;
        }
        if ( *((unsigned __int8 *)&v13 + ii) != *(_DWORD *)(all_created_runtime[ii] + 336) )
        {
          V_LOCK();
          sub_56C30((int)v26, *(int *)(all_created_runtime[ii] + 252));
          logfmt_raw(
            v9,
            0x1000u,
            0,
            v27,
            v26[0],
            v26[1],
            v26[2],
            v26[3],
            v26[4],
            v26[5],
            v26[6],
            v27,
            "chip update err code %d, wait %ds and shutdown...",
            status_x7,
            seconds);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
            187,
            "update_chip_x7",
            14,
            603,
            100,
            v9);
          sleep(seconds);
          fclose(stream);
          return 102;
        }
        V_LOCK();
        sub_56C30((int)v28, *(int *)(all_created_runtime[ii] + 252));
        logfmt_raw(
          v9,
          0x1000u,
          0,
          v29,
          v28[0],
          v28[1],
          v28[2],
          v28[3],
          v28[4],
          v28[5],
          v28[6],
          v29,
          "chip update complete");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
          187,
          "update_chip_x7",
          14,
          608,
          40,
          v9);
        *a2 = 1.0;
      }
      fclose(stream);
      return 0;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "open file %s failed", filename);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/machine_runtime/x7_2044/machine_runtime_x7_2044.c",
      187,
      "update_chip_x7",
      14,
      481,
      100,
      v9);
    return 306;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005990C) --------------------------------------------------------
int __fastcall sub_5990C(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 59978: variable 'v3' is possibly undefined

//----- (00059A24) --------------------------------------------------------
int __fastcall sub_59A24(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (00059A98) --------------------------------------------------------
int __fastcall sub_59A98(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00059BBC) --------------------------------------------------------
_BYTE *__fastcall sub_59BBC(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00059C28) --------------------------------------------------------
int __fastcall chip_update_xmr_routine(int a1)
{
  char v4[44]; // [sp+18h] [bp-102Ch] BYREF
  int v5; // [sp+1018h] [bp-2Ch] BYREF
  _DWORD *v6; // [sp+101Ch] [bp-28h]
  void *v7; // [sp+1020h] [bp-24h]
  char *miner_working_status_p; // [sp+1024h] [bp-20h]
  void *all_created_runtime; // [sp+1028h] [bp-1Ch]
  int v10; // [sp+102Ch] [bp-18h]
  int v11; // [sp+1030h] [bp-14h]
  int v12; // [sp+1034h] [bp-10h]
  int v13; // [sp+1038h] [bp-Ch]
  int v14; // [sp+103Ch] [bp-8h]

  v13 = 0;
  v12 = 0;
  v14 = 0;
  v11 = 0;
  v10 = 0;
  all_created_runtime = 0;
  v5 = 0;
  miner_working_status_p = get_miner_working_status_p();
  miner_working_status_p[9] = 1;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "chip update mode");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/chip_update/chip_update.c",
    163,
    "chip_update_xmr_routine",
    23,
    28,
    40,
    v4);
  start_api_thread();
  v7 = (void *)dhash_content_init(opt_algo);
  if ( v7 )
  {
    set_frontend_runtime_type((int)v7, opt_algo);
    v10 = hardware_init((const char *)opt_algo);
    if ( v10 )
    {
      return v10;
    }
    else
    {
      v6 = machine_runtime_init(opt_machine_type, opt_algo);
      if ( v6 )
      {
        v10 = ((int (__fastcall *)(_DWORD *))v6[12])(v6);
        if ( v10 )
        {
          return v10;
        }
        else
        {
          sleep(5u);
          ((void (__fastcall *)(_DWORD *))v6[3])(v6);
          all_created_runtime = get_all_created_runtime(&v5);
          miner_working_status_p[9] = 0;
          dhash_content_exit(v7);
          if ( update_chip_x7(a1 != 0, (float *)miner_working_status_p + 3) )
            return -1;
          else
            return 0;
        }
      }
      else
      {
        printf("invalid pointer(%s)!\n", "machine_runtime");
        return 3;
      }
    }
  }
  else
  {
    printf("invalid pointer(%s)!\n", "dhash_content");
    return 3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D664: using guessed type int opt_algo;
// 1513FC: using guessed type int opt_machine_type;
// 1608F0: using guessed type int g_zc;

//----- (00059E90) --------------------------------------------------------
int __fastcall dhash_content_init(int a1)
{
  char v3[12]; // [sp+18h] [bp-100Ch] BYREF
  int v4; // [sp+1018h] [bp-Ch]
  unsigned int i; // [sp+101Ch] [bp-8h]

  v4 = 0;
  for ( i = 0; i <= 1 && a1 != *(_DWORD *)&asc_FDFA4[12 * i]; ++i )
    ;
  if ( i != 2 && *(_DWORD *)&asc_FDFA4[12 * i + 8] )
    return (*(int (**)(void))&asc_FDFA4[12 * i + 8])();
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "ALGO %d does not define dhash_content", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/dhash_content/dhash_content.c",
    167,
    "dhash_content_init",
    18,
    64,
    100,
    v3);
  return v4;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005A004) --------------------------------------------------------
void __fastcall dhash_content_exit(void *a1)
{
  if ( a1 )
    free(a1);
}

//----- (0005A03C) --------------------------------------------------------
int __fastcall sub_5A03C(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 5A0A8: variable 'v3' is possibly undefined

//----- (0005A154) --------------------------------------------------------
int __fastcall sub_5A154(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0005A1C8) --------------------------------------------------------
int __fastcall sub_5A1C8(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005A2EC) --------------------------------------------------------
_BYTE *__fastcall sub_5A2EC(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0005A358) --------------------------------------------------------
unsigned int __fastcall sub_5A358(unsigned int a1)
{
  return bswap32(a1);
}

//----- (0005A380) --------------------------------------------------------
void __fastcall sub_5A380(const unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 v4[32]; // [sp+10h] [bp-24h] BYREF

  sha256(a1, a3, v4);
  sha256(v4, 0x20u, a2);
}

//----- (0005A3CC) --------------------------------------------------------
unsigned int __fastcall sub_5A3CC(unsigned int result, int a2)
{
  unsigned int v3; // [sp+10h] [bp-14h]
  int i; // [sp+14h] [bp-10h]

  v3 = result;
  for ( i = 0; i <= 7; ++i )
  {
    result = sub_5A358(*(_DWORD *)(a2 + 4 * i));
    *(_DWORD *)(v3 + 4 * i) = result;
  }
  return result;
}

//----- (0005A454) --------------------------------------------------------
int __fastcall sub_5A454(int a1, int *a2, char a3)
{
  size_t v4; // r3
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v14; // [sp+14h] [bp-78h] BYREF
  int v15; // [sp+18h] [bp-74h]
  int v16; // [sp+1Ch] [bp-70h]
  int v17; // [sp+20h] [bp-6Ch]
  int v18; // [sp+24h] [bp-68h]
  int v19; // [sp+28h] [bp-64h]
  int v20; // [sp+2Ch] [bp-60h]
  int v21; // [sp+30h] [bp-5Ch]
  _BYTE v22[32]; // [sp+34h] [bp-58h] BYREF
  int v23; // [sp+54h] [bp-38h] BYREF
  int v24; // [sp+58h] [bp-34h]
  int v25; // [sp+5Ch] [bp-30h]
  int v26; // [sp+60h] [bp-2Ch]
  int v27; // [sp+64h] [bp-28h]
  int v28; // [sp+68h] [bp-24h]
  int v29; // [sp+6Ch] [bp-20h]
  int v30; // [sp+70h] [bp-1Ch]
  int *v31; // [sp+74h] [bp-18h]
  int *v32; // [sp+78h] [bp-14h]
  size_t n; // [sp+7Ch] [bp-10h]
  size_t *v34; // [sp+80h] [bp-Ch]
  int i; // [sp+84h] [bp-8h]

  v34 = *(size_t **)(a1 + 1132);
  if ( v34 )
  {
    v4 = *v34;
    if ( *v34 >= 8 )
      v4 = 8;
    n = v4;
    if ( a3 && *((_BYTE *)a2 + 444) )
      dbl_152400 = 0.0;
    memset(v34 + 1, 0, *v34);
    if ( n )
    {
      memcpy(v34 + 1, &dbl_152400, n);
      ++*(_QWORD *)&dbl_152400;
    }
    memcpy((void *)(a2[75] + a2[22]), v34 + 1, *v34);
    sub_5A380((const unsigned __int8 *)a2[75], (unsigned __int8 *)&v23, a2[74]);
    v14 = v23;
    v15 = v24;
    v16 = v25;
    v17 = v26;
    v18 = v27;
    v19 = v28;
    v20 = v29;
    v21 = v30;
    for ( i = 0; i < a2[81]; ++i )
    {
      memcpy(v22, *(const void **)(a2[82] + 4 * i), sizeof(v22));
      sub_5A380((const unsigned __int8 *)&v14, (unsigned __int8 *)&v23, 0x40u);
      v14 = v23;
      v15 = v24;
      v16 = v25;
      v17 = v26;
      v18 = v27;
      v19 = v28;
      v20 = v29;
      v21 = v30;
    }
    v32 = &v14;
    v31 = &v23;
    sub_5A3CC((unsigned int)&v23, (int)&v14);
    memcpy((void *)(a1 + 8), a2 + 116, 0x50u);
    v5 = v24;
    v6 = v25;
    v7 = v26;
    *(_DWORD *)(a1 + 44) = v23;
    *(_DWORD *)(a1 + 48) = v5;
    *(_DWORD *)(a1 + 52) = v6;
    *(_DWORD *)(a1 + 56) = v7;
    v8 = v28;
    v9 = v29;
    v10 = v30;
    *(_DWORD *)(a1 + 60) = v27;
    *(_DWORD *)(a1 + 64) = v8;
    *(_DWORD *)(a1 + 68) = v9;
    *(_DWORD *)(a1 + 72) = v10;
    memcpy((void *)(a1 + 1032), a2 + 372, 0x20u);
    *(_DWORD *)(a1 + 1100) = a2[89];
    *(_QWORD *)a1 = *a2;
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}
// 152400: using guessed type double dbl_152400;

//----- (0005A70C) --------------------------------------------------------
int __fastcall sub_5A70C(int a1, __int64 *a2)
{
  __int64 v6; // [sp+8h] [bp-E4h] BYREF
  char v7[64]; // [sp+10h] [bp-DCh] BYREF
  _BYTE v8[80]; // [sp+50h] [bp-9Ch] BYREF
  int v9; // [sp+A0h] [bp-4Ch]
  _BYTE v10[32]; // [sp+A4h] [bp-48h] BYREF
  _DWORD v11[8]; // [sp+C4h] [bp-28h] BYREF
  size_t *v12; // [sp+E4h] [bp-8h]

  v12 = (size_t *)*((_DWORD *)a2 + 283);
  if ( v12 )
  {
    v6 = *a2;
    strcpy(v7, *((const char **)a2 + 281));
    memcpy(v8, a2 + 1, sizeof(v8));
    v9 = target_to_diff_ltc((int)(a2 + 129));
    memcpy(v10, a2 + 129, sizeof(v10));
    memcpy(v11, v12 + 1, *v12);
    v11[4] = *v12;
    v11[5] = *((_DWORD *)a2 + 275);
    (*(void (__fastcall **)(int, __int64 *))(a1 + 32))(a1, &v6);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0005A840) --------------------------------------------------------
int __fastcall sub_5A840(int a1, int a2, int a3)
{
  size_t *v6; // [sp+10h] [bp-Ch]

  v6 = *(size_t **)(a1 + 1132);
  if ( v6 )
  {
    if ( !*(_DWORD *)(a2 + 1580) || !strcmp((const char *)(a3 + 16), *(const char **)(a2 + 1580)) )
    {
      if ( *v6 == *(_DWORD *)(a3 + 104) )
      {
        *(_QWORD *)(a1 + 1072) = (int)_byteswap_ulong(*(_DWORD *)(a3 + 80));
        memcpy(v6 + 1, (const void *)(a3 + 86), *v6);
        *(_DWORD *)(a1 + 1100) = *(_DWORD *)(a3 + 108);
        return 0;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0005A990) --------------------------------------------------------
void *dhash_content_ltc_1491()
{
  _QWORD src[3]; // [sp+4h] [bp-20h] BYREF
  void *dest; // [sp+1Ch] [bp-8h]

  src[2] = 0x3C001062A8LL;
  src[0] = 0x5A70C0005A454LL;
  src[1] = 370752;
  dest = calloc(1u, 0x18u);
  memcpy(dest, src, 0x18u);
  return dest;
}

//----- (0005AA20) --------------------------------------------------------
__uint64_t __cdecl _uint64_identity(__uint64_t __x)
{
  return __x;
}

//----- (0005AA48) --------------------------------------------------------
void *__fastcall diff_to_target_ltc(void *a1)
{
  double v1; // d0
  double v2; // r0
  double v3; // r0
  double v4; // r0
  __uint64_t v5; // r0
  double v7; // [sp+0h] [bp-54h]
  _QWORD src[4]; // [sp+14h] [bp-40h] BYREF
  __uint64_t *v10; // [sp+34h] [bp-20h]
  unsigned __int64 v11; // [sp+38h] [bp-1Ch]
  double v12; // [sp+40h] [bp-14h]
  double v13; // [sp+48h] [bp-Ch]

  v7 = v1;
  if ( v1 <= 0.0 )
    v7 = 1.0;
  v13 = 2.69595353e67 * 65536.0 / v7;
  v12 = v13 / 6.27710174e57;
  v11 = (unsigned __int64)(v13 / 6.27710174e57);
  v10 = &src[3];
  src[3] = _uint64_identity(v11);
  LODWORD(v2) = sub_CCAD4(v11);
  v13 = v13 - v2 * 6.27710174e57;
  v12 = v13 / 3.40282367e38;
  v11 = (unsigned __int64)(v13 / 3.40282367e38);
  v10 = &src[2];
  src[2] = _uint64_identity(v11);
  LODWORD(v3) = sub_CCAD4(v11);
  v13 = v13 - v3 * 3.40282367e38;
  v12 = v13 / 1.84467441e19;
  v11 = (unsigned __int64)(v13 / 1.84467441e19);
  v10 = &src[1];
  src[1] = _uint64_identity(v11);
  LODWORD(v4) = sub_CCAD4(v11);
  v12 = v4 * 1.84467441e19;
  v13 = v13 - v4 * 1.84467441e19;
  v11 = (unsigned __int64)v13;
  v10 = src;
  v5 = _uint64_identity((unsigned __int64)v13);
  *v10 = v5;
  return memcpy(a1, src, 0x20u);
}
// 5AA58: variable 'v1' is possibly undefined
// 5AB1C: variable 'v2' is possibly undefined
// 5AB98: variable 'v3' is possibly undefined
// 5AC0C: variable 'v4' is possibly undefined

//----- (0005AC98) --------------------------------------------------------
int __fastcall target_to_diff_ltc(int a1)
{
  int j; // [sp+14h] [bp-18h]
  int i; // [sp+18h] [bp-14h]
  unsigned __int8 v5; // [sp+1Fh] [bp-Dh]

  v5 = 0;
  for ( i = 24; i >= 0; i -= 8 )
  {
    for ( j = 63; j >= 0; --j )
    {
      if ( ((*(_QWORD *)(a1 + i) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (0005AD78) --------------------------------------------------------
int target_to_double_diff_ltc()
{
  return le256todouble();
}

//----- (0005ADE0) --------------------------------------------------------
int __fastcall sub_5ADE0(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 5AE4C: variable 'v3' is possibly undefined

//----- (0005AEF8) --------------------------------------------------------
int __fastcall sub_5AEF8(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0005AF6C) --------------------------------------------------------
int __fastcall sub_5AF6C(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005B090) --------------------------------------------------------
_BYTE *__fastcall sub_5B090(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0005B0FC) --------------------------------------------------------
int __fastcall sub_5B0FC(int a1, int *a2)
{
  if ( *(_DWORD *)(a1 + 1132) )
  {
    memcpy((void *)(a1 + 8), a2 + 116, *((unsigned __int8 *)a2 + 464) + 1);
    *(_QWORD *)a1 = *a2;
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0005B1AC) --------------------------------------------------------
int __fastcall sub_5B1AC(int a1, __int64 *a2)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3
  __int64 v12; // [sp+8h] [bp-194h] BYREF
  char v13[64]; // [sp+10h] [bp-18Ch] BYREF
  int v14; // [sp+50h] [bp-14Ch]
  int v15; // [sp+54h] [bp-148h]
  int v16; // [sp+58h] [bp-144h]
  int v17; // [sp+5Ch] [bp-140h]
  int v18; // [sp+60h] [bp-13Ch]
  int v19; // [sp+64h] [bp-138h]
  int v20; // [sp+68h] [bp-134h]
  int v21; // [sp+6Ch] [bp-130h]
  __int64 v22; // [sp+70h] [bp-12Ch]
  __int64 v23; // [sp+78h] [bp-124h]
  char v24[64]; // [sp+80h] [bp-11Ch] BYREF
  int v25; // [sp+C0h] [bp-DCh] BYREF
  _BYTE n[14]; // [sp+186h] [bp-16h]
  char *src; // [sp+194h] [bp-8h]

  src = (char *)*((_DWORD *)a2 + 283);
  if ( src )
  {
    v12 = *a2;
    strcpy(v13, src);
    v3 = *((_DWORD *)src + 17);
    v4 = *((_DWORD *)src + 18);
    v5 = *((_DWORD *)src + 19);
    v14 = *((_DWORD *)src + 16);
    v15 = v3;
    v16 = v4;
    v17 = v5;
    v6 = *((_DWORD *)src + 21);
    v7 = *((_DWORD *)src + 22);
    v8 = *((_DWORD *)src + 23);
    v18 = *((_DWORD *)src + 20);
    v19 = v6;
    v20 = v7;
    v21 = v8;
    v22 = *((_QWORD *)src + 12);
    v23 = *((_QWORD *)src + 13);
    strcpy(v24, *((const char **)a2 + 281));
    n[0] = *((_BYTE *)a2 + 8);
    memcpy(&v25, (char *)a2 + 9, n[0]);
    *(_DWORD *)&n[1] = *((_DWORD *)a2 + 12);
    (*(void (__fastcall **)(int, __int64 *))(a1 + 32))(a1, &v12);
    return 0;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}

//----- (0005B300) --------------------------------------------------------
int __fastcall sub_5B300(int a1, int a2, int a3)
{
  char v7[12]; // [sp+20h] [bp-100Ch] BYREF
  char *s2; // [sp+1020h] [bp-Ch]
  int v9; // [sp+1024h] [bp-8h]

  v9 = a3;
  s2 = *(char **)(a1 + 1132);
  if ( s2 )
  {
    if ( *(_DWORD *)(a2 + 1588) )
    {
      if ( !strcmp((const char *)(v9 + 16), s2)
        && !memcmp((const void *)(v9 + 80), s2 + 64, 0x20u)
        && *(_QWORD *)(v9 + 112) == *((_QWORD *)s2 + 12)
        && *(_QWORD *)(v9 + 120) == *((_QWORD *)s2 + 13)
        && (!*(_DWORD *)(a2 + 1580) || !strcmp((const char *)(v9 + 128), *(const char **)(a2 + 1580))) )
      {
        *(_QWORD *)(a1 + 1072) = (int)_byteswap_ulong(*(_DWORD *)(v9 + 192));
        *(_DWORD *)(a1 + 1072) = *(_DWORD *)(v9 + 192);
        memcpy(s2 + 112, (const void *)(v9 + 196), 0x20u);
        return 0;
      }
      else
      {
        V_LOCK();
        logfmt_raw(
          v7,
          0x1000u,
          0,
          "stale nonce, ans_id: %s ,pool_job_id: %s, chip_id %d, core_id %d",
          v9 + 128,
          *(_DWORD *)(a2 + 1580),
          *(_DWORD *)(v9 + 8),
          *(_DWORD *)(v9 + 12));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/dhash_content/x7/x7_2044/x7_2044_content.c",
          180,
          "nonce_pop_handler_x7_2044",
          25,
          55,
          20,
          v7);
        return 1;
      }
    }
    else
    {
      printf("invalid pointer(%s)!\n", "pool->work.private");
      return 3;
    }
  }
  else
  {
    printf("invalid pointer(%s)!\n", "private");
    return 3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005B5D4) --------------------------------------------------------
void *dhash_content_x7_2044()
{
  _QWORD src[3]; // [sp+4h] [bp-20h] BYREF
  void *dest; // [sp+1Ch] [bp-8h]

  src[2] = 0x5A001166B0LL;
  src[0] = 0x5B1AC0005B0FCLL;
  src[1] = 373504;
  dest = calloc(1u, 0x18u);
  memcpy(dest, src, 0x18u);
  return dest;
}

//----- (0005B660) --------------------------------------------------------
unsigned int __fastcall sub_5B660(int a1, unsigned int a2)
{
  return bswap32(a2);
}

//----- (0005B6A4) --------------------------------------------------------
void sub_5B6A4()
{
  ;
}

//----- (0005B6CC) --------------------------------------------------------
int le256todouble()
{
  __int64 v0; // r0
  __int64 v1; // r0
  __int64 v2; // r0
  __int64 v3; // r0

  sub_5B6A4();
  sub_CCAD4(v0);
  sub_5B6A4();
  sub_CCAD4(v1);
  sub_5B6A4();
  sub_CCAD4(v2);
  sub_5B6A4();
  return sub_CCAD4(v3);
}
// 5B70C: variable 'v0' is possibly undefined
// 5B750: variable 'v1' is possibly undefined
// 5B79C: variable 'v2' is possibly undefined
// 5B7E4: variable 'v3' is possibly undefined

//----- (0005B828) --------------------------------------------------------
int le256_target_to_double_diff_base()
{
  return le256todouble();
}

//----- (0005B88C) --------------------------------------------------------
void *__fastcall diff_to_le256_target_base(void *a1)
{
  double v1; // d0
  double v2; // d1
  __int64 v3; // r0
  double v4; // r0
  __int64 v5; // r0
  double v6; // r0
  __int64 v7; // r0
  double v8; // r0
  __int64 v9; // r0
  double v11; // [sp+18h] [bp-1054h]
  char v13[64]; // [sp+2Ch] [bp-1040h] BYREF
  _BYTE src[32]; // [sp+102Ch] [bp-40h] BYREF
  _BYTE *v15; // [sp+104Ch] [bp-20h]
  __int64 v16; // [sp+1050h] [bp-1Ch]
  double v17; // [sp+1058h] [bp-14h]
  double v18; // [sp+1060h] [bp-Ch]

  v11 = v1;
  if ( v1 <= 0.0 )
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "Diff zero passed to set_target");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/dhash_content/base_common.c",
      165,
      "diff_to_le256_target_base",
      25,
      57,
      20,
      v13);
    v11 = 1.0;
  }
  v18 = v2 / v11;
  v17 = v2 / v11 / 6.27710174e57;
  v16 = (unsigned __int64)v17;
  v15 = &src[24];
  sub_5B6A4();
  *(_QWORD *)v15 = v3;
  LODWORD(v4) = sub_CCAD4(v16);
  v18 = v18 - v4 * 6.27710174e57;
  v17 = v18 / 3.40282367e38;
  v16 = (unsigned __int64)(v18 / 3.40282367e38);
  v15 = &src[16];
  sub_5B6A4();
  *(_QWORD *)v15 = v5;
  LODWORD(v6) = sub_CCAD4(v16);
  v18 = v18 - v6 * 3.40282367e38;
  v17 = v18 / 1.84467441e19;
  v16 = (unsigned __int64)(v18 / 1.84467441e19);
  v15 = &src[8];
  sub_5B6A4();
  *(_QWORD *)v15 = v7;
  LODWORD(v8) = sub_CCAD4(v16);
  v17 = v8 * 1.84467441e19;
  v18 = v18 - v8 * 1.84467441e19;
  v16 = (unsigned __int64)v18;
  v15 = src;
  sub_5B6A4();
  *(_QWORD *)v15 = v9;
  return memcpy(a1, src, 0x20u);
}
// 5B8B4: variable 'v1' is possibly undefined
// 5B9A4: variable 'v2' is possibly undefined
// 5B9EC: variable 'v3' is possibly undefined
// 5BA18: variable 'v4' is possibly undefined
// 5BA68: variable 'v5' is possibly undefined
// 5BA94: variable 'v6' is possibly undefined
// 5BAE4: variable 'v7' is possibly undefined
// 5BB08: variable 'v8' is possibly undefined
// 5BB4C: variable 'v9' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005BB90) --------------------------------------------------------
int __fastcall le256_target_to_diff_base(int a1)
{
  int j; // [sp+Ch] [bp-10h]
  int i; // [sp+10h] [bp-Ch]
  unsigned __int8 v5; // [sp+17h] [bp-5h]

  v5 = 0;
  for ( i = 31; i >= 0; --i )
  {
    for ( j = 7; j >= 0; --j )
    {
      if ( (((int)*(unsigned __int8 *)(a1 + i) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (0005BC44) --------------------------------------------------------
int __fastcall be256todouble(int a1)
{
  __int64 v1; // r0
  __int64 v2; // r0
  __int64 v3; // r0
  __int64 v4; // r0

  LODWORD(v1) = sub_5B660(*(_DWORD *)a1, *(_DWORD *)(a1 + 4));
  sub_CCAD4(v1);
  LODWORD(v2) = sub_5B660(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  sub_CCAD4(v2);
  LODWORD(v3) = sub_5B660(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  sub_CCAD4(v3);
  LODWORD(v4) = sub_5B660(*(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 28));
  return sub_CCAD4(v4);
}
// 5BC80: variable 'v1' is possibly undefined
// 5BCC4: variable 'v2' is possibly undefined
// 5BD10: variable 'v3' is possibly undefined
// 5BD5C: variable 'v4' is possibly undefined

//----- (0005BDA0) --------------------------------------------------------
int __fastcall be256_target_to_double_diff_base(int a1)
{
  return be256todouble(a1);
}

//----- (0005BE04) --------------------------------------------------------
void *__fastcall diff_to_be256_target_base(void *a1)
{
  double v1; // d0
  double v2; // d1
  __int64 v3; // r0
  double v4; // r0
  __int64 v5; // r0
  double v6; // r0
  __int64 v7; // r0
  double v8; // r0
  __int64 v9; // r0
  double v11; // [sp+18h] [bp-1054h]
  char v13[64]; // [sp+2Ch] [bp-1040h] BYREF
  _BYTE src[32]; // [sp+102Ch] [bp-40h] BYREF
  _BYTE *v15; // [sp+104Ch] [bp-20h]
  unsigned __int64 v16; // [sp+1050h] [bp-1Ch]
  double v17; // [sp+1058h] [bp-14h]
  double v18; // [sp+1060h] [bp-Ch]

  v11 = v1;
  if ( v1 <= 0.0 )
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "Diff zero passed to set_target");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/dhash_content/base_common.c",
      165,
      "diff_to_be256_target_base",
      25,
      169,
      20,
      v13);
    v11 = 1.0;
  }
  v18 = v2 / v11;
  v17 = v2 / v11 / 6.27710174e57;
  v16 = (unsigned __int64)v17;
  v15 = src;
  LODWORD(v3) = sub_5B660((unsigned __int64)v17, (unsigned __int64)v17 >> 32);
  *(_QWORD *)v15 = v3;
  LODWORD(v4) = sub_CCAD4(v16);
  v18 = v18 - v4 * 6.27710174e57;
  v17 = v18 / 3.40282367e38;
  v16 = (unsigned __int64)(v18 / 3.40282367e38);
  v15 = &src[8];
  LODWORD(v5) = sub_5B660(v16, HIDWORD(v16));
  *(_QWORD *)v15 = v5;
  LODWORD(v6) = sub_CCAD4(v16);
  v18 = v18 - v6 * 3.40282367e38;
  v17 = v18 / 1.84467441e19;
  v16 = (unsigned __int64)(v18 / 1.84467441e19);
  v15 = &src[16];
  LODWORD(v7) = sub_5B660(v16, HIDWORD(v16));
  *(_QWORD *)v15 = v7;
  LODWORD(v8) = sub_CCAD4(v16);
  v17 = v8 * 1.84467441e19;
  v18 = v18 - v8 * 1.84467441e19;
  v16 = (unsigned __int64)v18;
  v15 = &src[24];
  LODWORD(v9) = sub_5B660((unsigned __int64)v18, (unsigned __int64)v18 >> 32);
  *(_QWORD *)v15 = v9;
  return memcpy(a1, src, 0x20u);
}
// 5BE2C: variable 'v1' is possibly undefined
// 5BF1C: variable 'v2' is possibly undefined
// 5BF60: variable 'v3' is possibly undefined
// 5BF8C: variable 'v4' is possibly undefined
// 5BFDC: variable 'v5' is possibly undefined
// 5C008: variable 'v6' is possibly undefined
// 5C058: variable 'v7' is possibly undefined
// 5C07C: variable 'v8' is possibly undefined
// 5C0C4: variable 'v9' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005C108) --------------------------------------------------------
int __fastcall be256_target_to_diff_base(int a1)
{
  int j; // [sp+Ch] [bp-10h]
  int i; // [sp+10h] [bp-Ch]
  unsigned __int8 v5; // [sp+17h] [bp-5h]

  v5 = 0;
  for ( i = 0; i <= 31; ++i )
  {
    for ( j = 7; j >= 0; --j )
    {
      if ( (((int)*(unsigned __int8 *)(a1 + i) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (0005C1BC) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5C1BC(int a1, __int64 a2)
{
  V_INT(a1, "fanid", a2);
}

//----- (0005C1F0) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5C1F0(int a1, __int64 a2)
{
  V_INT(a1, "fanspeed", a2);
}

//----- (0005C224) --------------------------------------------------------
__int64 check_fan_valid()
{
  int fan_max_speed; // r0
  int v1; // r0
  int v2; // r0
  int v3; // r0
  char v5[44]; // [sp+50h] [bp-106Ch] BYREF
  _DWORD v6[7]; // [sp+1050h] [bp-6Ch] BYREF
  int v7; // [sp+106Ch] [bp-50h]
  _DWORD v8[8]; // [sp+1070h] [bp-4Ch] BYREF
  int realtime_speed; // [sp+1090h] [bp-2Ch]
  int v10; // [sp+1094h] [bp-28h]
  int fan_num; // [sp+1098h] [bp-24h]
  int v12; // [sp+109Ch] [bp-20h]
  int v13; // [sp+10A0h] [bp-1Ch]
  int i; // [sp+10A4h] [bp-18h]
  int j; // [sp+10A8h] [bp-14h]
  int k; // [sp+10ACh] [bp-10h]

  v13 = 0;
  if ( fan_inited != 1 )
  {
    fan_init();
    fan_inited = 1;
  }
  green_led_off();
  red_led_off();
  fan_pwm_set_max();
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "Begain check_fan_valid");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/check_fan.c",
    160,
    "check_fan_valid",
    15,
    31,
    20,
    v5);
  fan_num = platform_get_fan_num();
  v12 = 0;
  do
  {
    v12 = 0;
    for ( i = 0; i < fan_num; ++i )
    {
      realtime_speed = fan_get_realtime_speed(i);
      if ( realtime_speed != -1 )
      {
        fan_max_speed = platform_get_fan_max_speed(i);
        v1 = fan_get_check_fan_speed(fan_max_speed);
        if ( realtime_speed >= v1 )
          ++v12;
      }
    }
    usleep(0x7A120u);
    if ( !(++v13 % 20) )
      fan_pwm_set_max();
    if ( v12 < fan_num && !(v13 % 120) )
    {
      red_led_on();
      for ( j = 0; j < fan_num; ++j )
      {
        v10 = fan_get_realtime_speed(j);
        if ( v10 != -1 )
        {
          v2 = platform_get_fan_max_speed(j);
          v3 = fan_get_check_fan_speed(v2);
          if ( v10 >= v3 )
            continue;
        }
        V_LOCK();
        sub_5C1BC((int)v6, j);
        sub_5C1F0((int)v8, v10 & ~(v10 >> 31));
        logfmt_raw(
          v5,
          0x1000u,
          0,
          v7,
          v6[0],
          v6[1],
          v6[2],
          v6[3],
          v6[4],
          v6[5],
          v6[6],
          v7,
          v8[0],
          v8[1],
          v8[2],
          v8[3],
          v8[4],
          v8[5],
          v8[6],
          v8[7],
          "%2d(corresponding to FAN%s on control board PCB)",
          j,
          fan_name[j]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/check_fan.c",
          160,
          "check_fan_valid",
          15,
          52,
          100,
          v5);
        set_miner_6060info_status_fan_err(j, 1);
      }
    }
  }
  while ( v12 < fan_num );
  for ( k = 0; k < fan_num; ++k )
    set_miner_6060info_status_fan_err(k, 0);
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "check_fan_speed ok, fan_num = %d", v12);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/miner_util/check_fan.c",
           160,
           "check_fan_valid",
           15,
           61,
           60,
           v5);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1505C8: using guessed type char *fan_name[8];
// 153C2C: using guessed type char fan_inited;
// 1608F0: using guessed type int g_zc;

//----- (0005C648) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5C648(int a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (0005C680) --------------------------------------------------------
int __fastcall sub_5C680(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 5C6EC: variable 'v3' is possibly undefined

//----- (0005C798) --------------------------------------------------------
int __fastcall sub_5C798(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0005C80C) --------------------------------------------------------
int __fastcall sub_5C80C(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005C930) --------------------------------------------------------
_BYTE *__fastcall sub_5C930(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0005C99C) --------------------------------------------------------
int __fastcall sub_5C99C(int a1, void *(*a2)(void *))
{
  int v5; // [sp+Ch] [bp-8h]

  pthread_attr_init((pthread_attr_t *)(a1 + 8));
  v5 = pthread_create((pthread_t *)(a1 + 4), (const pthread_attr_t *)(a1 + 8), a2, (void *)a1);
  pthread_attr_destroy((pthread_attr_t *)(a1 + 8));
  return v5;
}

//----- (0005CA08) --------------------------------------------------------
void __noreturn heartbeat_on_device()
{
  int (**v0)(); // r0
  char v1[56]; // [sp+2Ch] [bp-1038h] BYREF
  int v2; // [sp+102Ch] [bp-38h] BYREF
  _DWORD v3[7]; // [sp+1030h] [bp-34h] BYREF
  int v4; // [sp+104Ch] [bp-18h]
  _DWORD *all_created_runtime; // [sp+1050h] [bp-14h]
  int i; // [sp+1054h] [bp-10h]

  v2 = 0;
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "heartbeat_on_device");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/check_heartbeat.c",
    166,
    "heartbeat_on_device",
    19,
    54,
    60,
    v1);
  while ( 1 )
  {
    all_created_runtime = get_all_created_runtime(&v2);
    for ( i = 0; i < v2; ++i )
    {
      v0 = dev_ctrl();
      if ( !((int (__fastcall *)(_DWORD))v0[20])(*(_DWORD *)(all_created_runtime[i] + 248)) )
      {
        V_LOCK();
        sub_5C648((int)v3, "pic lost");
        logfmt_raw(v1, 0x1000u, 0, v4, v3[0], v3[1], v3[2], v3[3], v3[4], v3[5], v3[6], v4, "heartbeat failed!");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/check_heartbeat.c",
          166,
          "heartbeat_on_device",
          19,
          62,
          100,
          v1);
      }
      sleep(5u);
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005CBB8) --------------------------------------------------------
int psu_watchdog()
{
  double v0; // d0
  int v1; // r3
  const char *v2; // r3
  char v4[28]; // [sp+10h] [bp-101Ch] BYREF
  int v5; // [sp+1010h] [bp-1Ch]
  int power_status; // [sp+1014h] [bp-18h]
  double v7; // [sp+1018h] [bp-14h]
  int current_voltage; // [sp+1020h] [bp-Ch]
  int v9; // [sp+1024h] [bp-8h]

  v7 = -1.0;
  current_voltage = 0;
  v5 = 0;
  v9 = 0;
  power_status = bitmain_set_watchdog(1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "enable power watchdog: 0x%04x", power_status);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/check_heartbeat.c",
    166,
    "psu_watchdog",
    12,
    77,
    60,
    v4);
  if ( power_status == 1 )
  {
    while ( 1 )
    {
      pthread_setcancelstate(1, 0);
      read_feedback_voltage(0);
      v7 = v0;
      current_voltage = get_current_voltage();
      if ( is_power_on() )
      {
        if ( v7 >= 0.0 )
        {
          if ( v7 * 100.0 <= (double)current_voltage * 1.1 && v7 * 100.0 >= (double)current_voltage * 0.9 )
          {
            v9 = 0;
          }
          else
          {
            V_LOCK();
            if ( v7 * 100.0 - (double)current_voltage <= 0.0 )
              v2 = "drop";
            else
              v2 = "rise";
            logfmt_raw(
              v4,
              0x1000u,
              0,
              ">> chain avg vol %s from %d to %.2f, pls check <<",
              v2,
              current_voltage,
              v7 * 100.0);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/miner_util/check_heartbeat.c",
              166,
              "psu_watchdog",
              12,
              93,
              80,
              v4);
            ++v9;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v4, 0x1000u, 0, ">> read_feedback_voltage failed!, pls check <<");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/check_heartbeat.c",
            166,
            "psu_watchdog",
            12,
            89,
            100,
            v4);
          ++v9;
        }
        V_LOCK();
        logfmt_raw(v4, 0x1000u, 0, "cur_voltage = %d, avg_voltage = %.2f", current_voltage);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/check_heartbeat.c",
          166,
          "psu_watchdog",
          12,
          99,
          20,
          v4);
      }
      power_status = bitmain_get_power_status();
      if ( power_status )
      {
        V_LOCK();
        logfmt_raw(v4, 0x1000u, 0, ">> power status error, ret %d, err_times %d <<", power_status, ++v5);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/check_heartbeat.c",
          166,
          "psu_watchdog",
          12,
          110,
          80,
          v4);
        v1 = v9;
        if ( v9 )
          return v1;
        v1 = v5;
        if ( v5 > 3 )
          return v1;
      }
      else
      {
        v5 = 0;
      }
      if ( v9 > 3 )
        break;
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      sleep(0xAu);
    }
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, ">> feedback voltage: too many times error, pls check <<");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_heartbeat.c",
      166,
      "psu_watchdog",
      12,
      117,
      100,
      v4);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "%s enable power watchdog failed!", "psu_watchdog");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_heartbeat.c",
      166,
      "psu_watchdog",
      12,
      79,
      100,
      v4);
    return 0;
  }
  return v1;
}
// 5CD20: variable 'v0' is possibly undefined
// 5D100: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005D128) --------------------------------------------------------
int start_heartbeat_thread()
{
  char v2[12]; // [sp+10h] [bp-100Ch] BYREF
  _DWORD *v3; // [sp+1010h] [bp-Ch]
  int v4; // [sp+1014h] [bp-8h]

  v3 = calloc(1u, 0x30u);
  *v3 = 5;
  v4 = -1;
  if ( platform_is_pic_mcu_en() )
    v4 = sub_5C99C((int)v3, (void *(*)(void *))heartbeat_on_device);
  else
    v4 = sub_5C99C((int)v3, (void *(*)(void *))psu_watchdog);
  if ( v4 )
  {
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "heartbeat thread create failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_heartbeat.c",
      166,
      "start_heartbeat_thread",
      22,
      136,
      100,
      v2);
    return 5;
  }
  else
  {
    pthread_detach(v3[1]);
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "start_heartbeat_thread");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_heartbeat.c",
      166,
      "start_heartbeat_thread",
      22,
      140,
      60,
      v2);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005D2B8) --------------------------------------------------------
void __fastcall __noreturn stop_heartbeat_thread(int a1)
{
  pthread_exit((void *)(a1 + 4));
}

//----- (0005D2D8) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5D2D8(int a1, __int64 a2)
{
  V_INT(a1, "poolno", a2);
}

//----- (0005D30C) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5D30C(int a1, const char *a2)
{
  V_STR(a1, "pool", a2);
}

//----- (0005D344) --------------------------------------------------------
int __fastcall sub_5D344(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 5D3B0: variable 'v3' is possibly undefined

//----- (0005D45C) --------------------------------------------------------
int __fastcall sub_5D45C(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0005D4D0) --------------------------------------------------------
int __fastcall sub_5D4D0(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005D5F4) --------------------------------------------------------
_BYTE *__fastcall sub_5D5F4(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0005D660) --------------------------------------------------------
int __fastcall sub_5D660(int a1, void *(*a2)(void *))
{
  int v5; // [sp+Ch] [bp-8h]

  pthread_attr_init((pthread_attr_t *)(a1 + 8));
  v5 = pthread_create((pthread_t *)(a1 + 4), (const pthread_attr_t *)(a1 + 8), a2, (void *)a1);
  pthread_attr_destroy((pthread_attr_t *)(a1 + 8));
  return v5;
}

//----- (0005D6CC) --------------------------------------------------------
int sub_5D6CC()
{
  int result; // r0
  char v1[8]; // [sp+14h] [bp-1008h] BYREF
  int v2; // [sp+1014h] [bp-8h]

  result = nice(10);
  v2 = result;
  if ( !result )
  {
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, "Unable to set thread to low priority");
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/miner_util/check_pool.c",
             161,
             "set_lowprio",
             11,
             18,
             20,
             v1);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005D774) --------------------------------------------------------
void __noreturn watchpool_thread()
{
  pthread_t v0; // r0
  int v1; // r0
  signed int count; // r4
  char v3[36]; // [sp+50h] [bp-1064h] BYREF
  struct timeval v4; // [sp+1050h] [bp-64h] BYREF
  _DWORD v5[7]; // [sp+1058h] [bp-5Ch] BYREF
  int v6; // [sp+1074h] [bp-40h]
  _DWORD v7[8]; // [sp+1078h] [bp-3Ch] BYREF
  pthread_mutex_t *v8; // [sp+1098h] [bp-1Ch]
  pthread_mutex_t *current_pool; // [sp+109Ch] [bp-18h]
  char *s; // [sp+10A0h] [bp-14h]
  int i; // [sp+10A4h] [bp-10h]

  v0 = pthread_self();
  pthread_detach(v0);
  pthread_setcanceltype(1, 0);
  sub_5D6CC();
  s = (char *)calloc(1u, 0x40u);
  snprintf(s, 0x40u, "%.10s_%d", "watchpool_thread", 0);
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v3, 0x1000u, 0, "%s on pid %ld", s, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/check_pool.c",
    161,
    "watchpool_thread",
    16,
    31,
    40,
    v3);
  prctl(15, s);
  while ( 1 )
  {
    cgtime(&v4);
    for ( i = 0; i < total_pools; ++i )
    {
      v8 = *(pthread_mutex_t **)(pools + 4 * i);
      if ( (unsigned __int8)pool_tget(v8, (unsigned __int8 *)&v8[79].__size[8]) != 1 )
      {
        count = v8->__count;
        if ( count < *(_DWORD *)(get_current_pool() + 4) && v4.tv_sec - v8[79].__kind > 120 )
        {
          V_LOCK();
          sub_5D2D8((int)v5, v8->__lock);
          sub_5D30C((int)v7, (const char *)v8->__kind);
          logfmt_raw(
            v3,
            0x1000u,
            0,
            v6,
            v5[0],
            v5[1],
            v5[2],
            v5[3],
            v5[4],
            v5[5],
            v5[6],
            v6,
            v7[0],
            v7[1],
            v7[2],
            v7[3],
            v7[4],
            v7[5],
            v7[6],
            v7[7],
            "stable for >%d seconds",
            120);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/check_pool.c",
            161,
            "watchpool_thread",
            16,
            50,
            80,
            v3);
          switch_pools();
        }
      }
    }
    current_pool = (pthread_mutex_t *)get_current_pool();
    if ( pool_tget(current_pool, (unsigned __int8 *)&current_pool[79].__size[8]) )
      switch_pools();
    sleep(0x1Eu);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;

//----- (0005DA64) --------------------------------------------------------
int __fastcall sub_5DA64(int a1)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  sub_5D6CC();
  api();
  *(_DWORD *)(a1 + 4) = 0;
  return 0;
}

//----- (0005DABC) --------------------------------------------------------
unsigned int sub_5DABC()
{
  unsigned int result; // r0
  int v1; // [sp+4h] [bp-10h] BYREF
  _DWORD *all_created_runtime; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  v1 = 0;
  all_created_runtime = get_all_created_runtime(&v1);
  for ( i = 0; i < v1; ++i )
  {
    (*(void (__fastcall **)(_DWORD))(all_created_runtime[i] + 20))(all_created_runtime[i]);
    (*(void (__fastcall **)(_DWORD))(all_created_runtime[i] + 28))(all_created_runtime[i]);
  }
  if ( v1 )
    fan_pwm_set(0x14u);
  green_led_on();
  result = red_led_on();
  while ( pools_active != 1 )
    result = sleep(1u);
  return result;
}
// 151898: using guessed type char pools_active;

//----- (0005DBC0) --------------------------------------------------------
void sub_5DBC0()
{
  ;
}

//----- (0005DBD8) --------------------------------------------------------
int start_watchpool_thread()
{
  char v2[12]; // [sp+10h] [bp-100Ch] BYREF
  int *v4; // [sp+1014h] [bp-8h]

  v4 = &dword_161060;
  dword_161060 = 2;
  if ( !sub_5D660((int)&dword_161060, (void *(*)(void *))watchpool_thread) )
    return 0;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "watchpool thread create failed");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/check_pool.c",
    161,
    "start_watchpool_thread",
    22,
    127,
    100,
    v2);
  return 5;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161060: using guessed type int dword_161060;

//----- (0005DCAC) --------------------------------------------------------
int start_api_thread()
{
  char v2[12]; // [sp+10h] [bp-100Ch] BYREF
  int *v4; // [sp+1014h] [bp-8h]

  v4 = &dword_161090;
  dword_161090 = 3;
  if ( !sub_5D660((int)&dword_161090, (void *(*)(void *))sub_5DA64) )
    return 0;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "api thread create failed");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/check_pool.c",
    161,
    "start_api_thread",
    16,
    139,
    100,
    v2);
  return 5;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 5DA64: using guessed type int sub_5DA64();
// 1608F0: using guessed type int g_zc;
// 161090: using guessed type int dword_161090;

//----- (0005DD80) --------------------------------------------------------
int create_pool_connect()
{
  bool v1; // r3
  char v3[20]; // [sp+10h] [bp-1014h] BYREF
  int v4; // [sp+1010h] [bp-14h]
  int v5; // [sp+1014h] [bp-10h]
  int v6; // [sp+1018h] [bp-Ch]
  int i; // [sp+101Ch] [bp-8h]

  v5 = 0;
  sub_5DBC0();
  if ( create_pool_stratum_threads() )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "stratum thread create failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_pool.c",
      161,
      "create_pool_connect",
      19,
      153,
      100,
      v3);
    return 1;
  }
  else
  {
    v6 = 0;
    do
    {
      sleep(1u);
      ++v6;
    }
    while ( pools_active != 1 && v6 <= 59 );
    if ( pools_active != 1 )
    {
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "No servers were found that could be used to get work from.");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/check_pool.c",
        161,
        "create_pool_connect",
        19,
        165,
        100,
        v3);
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "Please check the details from the list below of the servers you have input.");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/check_pool.c",
        161,
        "create_pool_connect",
        19,
        166,
        100,
        v3);
      V_LOCK();
      logfmt_raw(
        v3,
        0x1000u,
        0,
        "Most likely you have input the wrong URL, forgotten to add a port, have not set up workers, or the network was disconnected.");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/check_pool.c",
        161,
        "create_pool_connect",
        19,
        167,
        100,
        v3);
      for ( i = 0; i < total_pools; ++i )
      {
        v4 = *(_DWORD *)(pools + 4 * i);
        V_LOCK();
        logfmt_raw(
          v3,
          0x1000u,
          0,
          "Pool: %d  URL: %s\tUser: %s  Password: %s",
          *(_DWORD *)v4,
          *(_DWORD *)(v4 + 12),
          *(_DWORD *)(v4 + 16),
          *(_DWORD *)(v4 + 20));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/check_pool.c",
          161,
          "create_pool_connect",
          19,
          173,
          80,
          v3);
        if ( *(_DWORD *)(v4 + 20) && *(_DWORD *)(v4 + 16) )
        {
          v1 = strstr(*(const char **)(v4 + 20), "stats") || !strcmp(*(const char **)(v4 + 16), "benchmark");
          *(_BYTE *)(v4 + 1648) = v1;
        }
      }
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "No servers could be used!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/check_pool.c",
        161,
        "create_pool_connect",
        19,
        179,
        100,
        v3);
      sub_5DABC();
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "Pool is activing, exiting and restart.");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/check_pool.c",
        161,
        "create_pool_connect",
        19,
        181,
        80,
        v3);
      return 0;
    }
    else
    {
      return v5;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151898: using guessed type char pools_active;
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;

//----- (0005E260) --------------------------------------------------------
int check_pool_connect()
{
  bool v0; // r1
  int v1; // r3
  char v3[20]; // [sp+10h] [bp-1014h] BYREF
  int v4; // [sp+1010h] [bp-14h]
  int v5; // [sp+1014h] [bp-10h]
  int v6; // [sp+1018h] [bp-Ch]
  int i; // [sp+101Ch] [bp-8h]

  v6 = 0;
  sub_5DBC0();
  if ( check_pools_valid() <= 0 )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "No servers were found that could be used to get work from.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_pool.c",
      161,
      "check_pool_connect",
      18,
      202,
      100,
      v3);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "Please check the details from the list below of the servers you have input.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_pool.c",
      161,
      "check_pool_connect",
      18,
      203,
      100,
      v3);
    V_LOCK();
    logfmt_raw(
      v3,
      0x1000u,
      0,
      "Most likely you have input the wrong URL, forgotten to add a port, have not set up workers, or the network was disconnected.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_pool.c",
      161,
      "check_pool_connect",
      18,
      204,
      100,
      v3);
    for ( i = 0; i < total_pools; ++i )
    {
      V_LOCK();
      logfmt_raw(
        v3,
        0x1000u,
        0,
        "Pool: %d  URL: %s\tUser: %s  Password: %s",
        **(_DWORD **)(pools + 4 * i),
        *(_DWORD *)(*(_DWORD *)(pools + 4 * i) + 12),
        *(_DWORD *)(*(_DWORD *)(pools + 4 * i) + 16),
        *(_DWORD *)(*(_DWORD *)(pools + 4 * i) + 20));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/check_pool.c",
        161,
        "check_pool_connect",
        18,
        208,
        80,
        v3);
      if ( *(_DWORD *)(*(_DWORD *)(pools + 4 * i) + 20) && *(_DWORD *)(*(_DWORD *)(pools + 4 * i) + 16) )
      {
        v0 = strstr(*(const char **)(*(_DWORD *)(pools + 4 * i) + 20), "stats")
          || !strcmp(*(const char **)(*(_DWORD *)(pools + 4 * i) + 16), "benchmark");
        *(_BYTE *)(*(_DWORD *)(pools + 4 * i) + 1648) = v0;
      }
    }
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "No servers could be used!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_pool.c",
      161,
      "check_pool_connect",
      18,
      212,
      100,
      v3);
    v4 = 1;
    while ( pools_active != 1 )
    {
      v5 = 0;
      while ( pools_active != 1 && v5 < 60 * v4 )
      {
        ++v5;
        sleep(1u);
      }
      v1 = v4 + 1;
      if ( v4 + 1 >= 20 )
        v1 = 20;
      v4 = v1;
      check_pools_valid();
    }
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "Pool is activing.");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_pool.c",
      161,
      "check_pool_connect",
      18,
      225,
      80,
      v3);
  }
  return v6;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151898: using guessed type char pools_active;
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1608F0: using guessed type int g_zc;

//----- (0005E7AC) --------------------------------------------------------
int __fastcall sub_5E7AC(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 5E818: variable 'v3' is possibly undefined

//----- (0005E8C4) --------------------------------------------------------
int __fastcall sub_5E8C4(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0005E938) --------------------------------------------------------
int __fastcall sub_5E938(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005EA5C) --------------------------------------------------------
_BYTE *__fastcall sub_5EA5C(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0005EAC8) --------------------------------------------------------
int __fastcall check_sn(int a1)
{
  size_t v2; // r0
  char v4[32]; // [sp+1Ch] [bp-1020h] BYREF
  __int64 ptr; // [sp+101Ch] [bp-20h] BYREF
  __int16 v6; // [sp+1024h] [bp-18h]
  __int64 v7; // [sp+1026h] [bp-16h]
  char *v8; // [sp+1030h] [bp-Ch]
  FILE *stream; // [sp+1034h] [bp-8h]

  ptr = 0;
  v6 = 0;
  v7 = 0;
  stream = 0;
  if ( a1 )
    g_miner_sn_file_path = a1;
  else
    g_miner_sn_file_path = (int)"/config/sn";
  stream = fopen((const char *)g_miner_sn_file_path, "r");
  if ( stream )
  {
    if ( fread(&ptr, 0x11u, 1u, stream) )
    {
      v8 = strstr((const char *)&ptr, "\r\n");
      if ( v8 )
        strncpy(g_miner_sn, (const char *)&ptr, v8 - (char *)&ptr);
      else
        strcpy(g_miner_sn, (const char *)&ptr);
      if ( g_miner_sn[strlen(g_miner_sn) - 1] == 10 )
        g_miner_sn[strlen(g_miner_sn) - 1] = 0;
      if ( g_miner_sn[strlen(g_miner_sn) - 1] == 13 )
        g_miner_sn[strlen(g_miner_sn) - 1] = 0;
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "droa miner sn: %s", &ptr);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/check_sn.c",
        159,
        "check_sn",
        8,
        49,
        60,
        v4);
      fclose(stream);
      return 0;
    }
    else
    {
      if ( (_BYTE)ptr )
      {
        V_LOCK();
        v2 = strlen((const char *)&ptr);
        logfmt_raw(v4, 0x1000u, 0, "miner sn: not support length %d:%s", v2, &ptr);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/check_sn.c",
          159,
          "check_sn",
          8,
          55,
          100,
          v4);
      }
      else
      {
        V_LOCK();
        logfmt_raw(v4, 0x1000u, 0, "miner sn: is NULL");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/check_sn.c",
          159,
          "check_sn",
          8,
          57,
          100,
          v4);
      }
      return 1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "miner has no sn!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/check_sn.c",
      159,
      "check_sn",
      8,
      23,
      100,
      v4);
    return 2;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15241C: using guessed type int g_miner_sn_file_path;
// 1608F0: using guessed type int g_zc;

//----- (0005EEB8) --------------------------------------------------------
int __fastcall fan_get_check_fan_speed(int a1)
{
  return 90 * a1 / 110;
}

//----- (0005EEFC) --------------------------------------------------------
int fan_pwm_get()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  if ( byte_152421 != 1 )
  {
    dword_152424 = pwm_init(0, 1);
    byte_152421 = 1;
  }
  pwm_get(dword_152424, &v1);
  return v1;
}
// 152421: using guessed type char byte_152421;
// 152424: using guessed type int dword_152424;

//----- (0005EF7C) --------------------------------------------------------
int __fastcall fan_pwm_set(unsigned int a1)
{
  int result; // r0

  if ( byte_152421 != 1 )
  {
    dword_152424 = pwm_init(0, 100);
    byte_152421 = 1;
  }
  if ( a1 > 0x64 )
    a1 = 100;
  result = fan_pwm_get();
  if ( a1 != result )
  {
    if ( fan_pwm_fixed )
      return pwm_set(dword_152424, fan_pwm);
    else
      return pwm_set(dword_152424, a1);
  }
  return result;
}
// 14F19C: using guessed type int fan_pwm;
// 152420: using guessed type char fan_pwm_fixed;
// 152421: using guessed type char byte_152421;
// 152424: using guessed type int dword_152424;

//----- (0005F064) --------------------------------------------------------
int fan_pwm_set_max()
{
  int result; // r0

  if ( byte_152421 != 1 )
  {
    dword_152424 = pwm_init(0, 100);
    byte_152421 = 1;
  }
  result = fan_pwm_get();
  if ( result != 100 )
    return pwm_set(dword_152424, 0x64u);
  return result;
}
// 152421: using guessed type char byte_152421;
// 152424: using guessed type int dword_152424;

//----- (0005F0E8) --------------------------------------------------------
__int64 __fastcall read_feedback_voltage(int a1)
{
  double v1; // d0
  int v3; // [sp+4h] [bp-1020h]
  char v5[12]; // [sp+18h] [bp-100Ch] BYREF
  double v6; // [sp+1018h] [bp-Ch]

  v6 = 0.0;
  if ( platform_is_pic_mcu_en() )
    pic1704_get_an_voltage1(a1);
  else
    bitmain_get_sample_voltage();
  v6 = v1;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "read_feedback_voltage chain = %d, voltage = %f", a1, v3, v1);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/miner_util/power_api.c",
           160,
           "read_feedback_voltage",
           21,
           57,
           20,
           v5);
}
// 5F138: variable 'v1' is possibly undefined
// 5F180: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005F1E8) --------------------------------------------------------
__int64 sub_5F1E8()
{
  double v0; // d0
  int (**v1)(); // r0
  int v2; // r0
  int (**v3)(); // r0
  int v4; // r0
  char v6[28]; // [sp+10h] [bp-101Ch] BYREF
  double v7; // [sp+1010h] [bp-1Ch]
  double v8; // [sp+1018h] [bp-14h]
  int i; // [sp+1020h] [bp-Ch]
  int device_num; // [sp+1024h] [bp-8h]

  v8 = 0.0;
  device_num = query_device_num();
  for ( i = 0; i < device_num; ++i )
  {
    v1 = dev_ctrl();
    v2 = ((int (__fastcall *)(int))v1[12])(i);
    read_feedback_voltage(v2);
    v7 = v0;
    V_LOCK();
    v3 = dev_ctrl();
    v4 = ((int (__fastcall *)(int))v3[12])(i);
    logfmt_raw(v6, 0x1000u, 0, "chain %d feedback voltage = %.2f", v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "get_minimal_feedback_voltage",
      28,
      69,
      40,
      v6);
    if ( v7 > 0.1 && (v8 > v7 || v8 < 0.1) )
      v8 = v7;
  }
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "the minimal voltage = %.2f", v8);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/miner_util/power_api.c",
           160,
           "get_minimal_feedback_voltage",
           28,
           74,
           20,
           v6);
}
// 5F238: variable 'v0' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005F3D0) --------------------------------------------------------
int sub_5F3D0()
{
  double v0; // d0
  int v3; // [sp+4h] [bp-1030h]
  char v4[28]; // [sp+18h] [bp-101Ch] BYREF
  int v5; // [sp+1018h] [bp-1Ch]
  int current_voltage; // [sp+101Ch] [bp-18h]
  double v7; // [sp+1020h] [bp-14h]
  double v8; // [sp+1028h] [bp-Ch]

  v5 = 3;
  current_voltage = get_current_voltage();
  v7 = (double)current_voltage * 0.75 / 100.0;
  v8 = 0.0;
  while ( 1 )
  {
    sleep(1u);
    if ( !platform_is_pic_mcu_en() )
      break;
    sub_5F1E8();
    v8 = v0;
    if ( v0 >= v7 )
    {
      V_LOCK();
      logfmt_raw(
        v4,
        0x1000u,
        0,
        "power voltage qualified! centi_voltage %d feedback_voltage %f qualified_vol %f",
        current_voltage);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "check_feedback_voltage",
        22,
        95,
        80,
        v4);
      goto LABEL_12;
    }
    V_LOCK();
    logfmt_raw(
      v4,
      0x1000u,
      0,
      "power voltage can not meet the target! centi_voltage %d feedback_voltage %f qualified_vol %f",
      current_voltage);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "check_feedback_voltage",
      22,
      91,
      80,
      v4);
LABEL_11:
    if ( !--v5 )
      goto LABEL_12;
  }
  read_feedback_voltage(0);
  v8 = v0;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "read fb voltage %.2f", v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "check_feedback_voltage",
    22,
    100,
    20,
    v4);
  if ( v8 >= 0.0 )
  {
    if ( v8 * 100.0 <= (double)current_voltage * 1.1 && v8 * 100.0 >= (double)current_voltage * 0.9 )
      goto LABEL_12;
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "power voltage qualified! centi_voltage %d fb_vol %f", current_voltage, v3, v8 * 100.0);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "check_feedback_voltage",
      22,
      107,
      100,
      v4);
    goto LABEL_11;
  }
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "read_feedback_voltage_from_psu failed!");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "check_feedback_voltage",
    22,
    102,
    80,
    v4);
LABEL_12:
  if ( v5 )
    return 0;
  else
    return -1;
}
// 5F438: variable 'v0' is possibly undefined
// 5F710: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005F7C0) --------------------------------------------------------
int __fastcall sub_5F7C0(int a1)
{
  int v1; // r3

  v1 = a1 & ~(a1 >> 31);
  if ( v1 >= 255 )
    return 255;
  return v1;
}

//----- (0005F7FC) --------------------------------------------------------
int __fastcall sub_5F7FC(unsigned int a1, unsigned int a2)
{
  double v2; // d0
  int v3; // r3
  int v4; // r2
  int v5; // r3
  int v7; // [sp+4h] [bp-1028h]
  unsigned int v9; // [sp+14h] [bp-1018h]
  char v10[16]; // [sp+1Ch] [bp-1010h] BYREF
  int v11; // [sp+101Ch] [bp-10h]

  v9 = a1;
  v11 = a1;
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "step n from %d to %d", v9, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "stepN",
    5,
    127,
    40,
    v10);
  while ( v9 != a2 )
  {
    bitmain_convert_N_to_V();
    bitmain_convert_N_to_V();
    if ( fabs(v2 - v2) <= 0.5 )
      break;
    if ( v9 >= a2 )
    {
      v5 = a2 - v9;
      if ( (int)(a2 - v9) < 0 )
        v5 = v9 - a2;
      v4 = v5 / -2;
    }
    else
    {
      v3 = a2 - v9;
      if ( (int)(a2 - v9) < 0 )
        v3 = v9 - a2;
      v4 = v3 / 2;
    }
    v11 += v4;
    V_LOCK();
    bitmain_convert_N_to_V();
    logfmt_raw(v10, 0x1000u, 0, "set N to %d, voltage = %.2f", v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "stepN",
      5,
      131,
      40,
      v10);
    bitmain_set_voltage_by_n(v11);
    v9 = v11;
  }
  if ( v9 != a2 )
  {
    V_LOCK();
    bitmain_convert_N_to_V();
    logfmt_raw(v10, 0x1000u, 0, "final set N to %d, voltage = %.2f", a2, v7, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "stepN",
      5,
      137,
      40,
      v10);
    bitmain_set_voltage_by_n(a2);
  }
  return 0;
}
// 5FA68: variable 'v2' is possibly undefined
// 5FAE8: variable 'v7' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005FB68) --------------------------------------------------------
int sub_5FB68()
{
  double v0; // d0
  double v1; // r2
  char v4[44]; // [sp+10h] [bp-102Ch] BYREF
  double v5; // [sp+1010h] [bp-2Ch]
  int chain_num; // [sp+101Ch] [bp-20h]
  double v7; // [sp+1020h] [bp-1Ch]
  int v8; // [sp+1028h] [bp-14h]
  int v9; // [sp+102Ch] [bp-10h]
  int i; // [sp+1030h] [bp-Ch]
  int v11; // [sp+1034h] [bp-8h]

  v7 = 0.0;
  v11 = 0;
  v9 = 100;
  v8 = 0;
  chain_num = platform_get_chain_num();
  while ( ++v11 < v9 )
  {
    for ( i = 0; i < chain_num; ++i )
    {
      read_feedback_voltage(i);
      v5 = v0;
      if ( v7 >= v0 )
        v1 = v7;
      else
        v1 = v5;
      v7 = v1;
    }
    if ( v7 <= 10.0 )
    {
      if ( v7 <= 4.0 )
        return 0;
      if ( v9 > 2 )
        v11 = 0;
      v9 = 2;
    }
    else
    {
      if ( v9 > 20 )
        v11 = 0;
      v9 = 20;
    }
    ++v8;
    sleep(1u);
    if ( v8 > 20 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "APW discharge too slow OR pic adc wrong");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "wait_for_psu_discharge",
        22,
        187,
        100,
        v4);
      return -1;
    }
  }
  return 0;
}
// 5FBBC: variable 'v0' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005FD30) --------------------------------------------------------
int __fastcall sub_5FD30(int a1, int a2)
{
  char v6[16]; // [sp+1Ch] [bp-1010h] BYREF
  int v7; // [sp+101Ch] [bp-10h]
  double v8; // [sp+1020h] [bp-Ch]

  v8 = (double)a1 / 100.0;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set voltage to %lf", v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "set_voltage_without_feedback",
    28,
    197,
    40,
    v6);
  v7 = bitmain_set_voltage();
  if ( v7 >= 0 )
  {
    usleep(0x7A120u);
    *(_DWORD *)(a2 + 28) = a1;
    *(_DWORD *)(a2 + 32) = *(_DWORD *)(a2 + 28);
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "bitmain_set_voltage failed, return code:%x", v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "set_voltage_without_feedback",
      28,
      200,
      100,
      v6);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0005FEF0) --------------------------------------------------------
int __fastcall sub_5FEF0(int a1, int a2)
{
  double v2; // d0
  double v3; // d16
  char v8[52]; // [sp+28h] [bp-1034h] BYREF
  int v9; // [sp+1028h] [bp-34h]
  int v10; // [sp+102Ch] [bp-30h]
  int v11; // [sp+1030h] [bp-2Ch]
  int v12; // [sp+1034h] [bp-28h]
  double v13; // [sp+1038h] [bp-24h]
  double v14; // [sp+1040h] [bp-1Ch]
  int v15; // [sp+1048h] [bp-14h]
  int v16; // [sp+104Ch] [bp-10h]
  double v17; // [sp+1050h] [bp-Ch]

  v12 = 0;
  v11 = 255;
  v13 = (double)a1 / 100.0;
  v14 = 0.0;
  v17 = (double)*(int *)(a2 + 32) / 100.0;
  v2 = v13;
  v15 = bitmain_set_voltage();
  while ( 1 )
  {
    sub_5F1E8();
    v14 = v2;
    v16 = bitmain_convert_V_to_N();
    if ( *(_DWORD *)(a2 + 32) )
      v3 = (double)*(int *)(a2 + 32) / 100.0;
    else
      v3 = v14;
    v17 = v3;
    v2 = v3;
    v10 = bitmain_convert_V_to_N();
    v9 = v15 - v16;
    if ( v14 < 0.1 )
    {
      v12 = -1;
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "minimal feedback voltage is zero");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "set_voltage_with_feedback",
        25,
        227,
        80,
        v8);
      goto LABEL_12;
    }
    if ( !v9 )
      goto LABEL_12;
    V_LOCK();
    logfmt_raw(
      v8,
      0x1000u,
      0,
      "board voltage = %.2f, target voltage = %.2f, power real voltage = %.2f, steps = %d",
      v14,
      v13,
      v17,
      v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "set_voltage_with_feedback",
      25,
      231,
      40,
      v8);
    if ( (unsigned int)(v10 + v9) >= 0x100 )
      break;
    sub_5F7FC(v10, v10 + v9);
    v10 += v9;
    v10 = sub_5F7C0(v10);
    bitmain_convert_N_to_V();
    *(_DWORD *)(a2 + 32) = (int)(v3 * 100.0);
    if ( fabs(v14 - v13) > 0.1 )
    {
      if ( v11-- )
        continue;
    }
    goto LABEL_12;
  }
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "overflow to the N limitation");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "set_voltage_with_feedback",
    25,
    234,
    100,
    v8);
  v12 = -2;
LABEL_12:
  if ( v12 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "fail to set taget voltage = %.2f, feedback_vol = %.2f", v13, v14);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "set_voltage_with_feedback",
      25,
      247,
      100,
      v8);
  }
  else
  {
    V_LOCK();
    bitmain_convert_N_to_V();
    logfmt_raw(
      v8,
      0x1000u,
      0,
      "set to target voltage = %.2f, power real voltage = %.2f, feed back voltage = %.2f",
      v13,
      v3,
      v14);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "set_voltage_with_feedback",
      25,
      244,
      40,
      v8);
    *(_DWORD *)(a2 + 28) = a1;
  }
  return v12;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000603D8) --------------------------------------------------------
int power_on()
{
  int result; // r0

  result = bitmain_power_on();
  byte_152440 = 1;
  return result;
}
// 152440: using guessed type char byte_152440;

//----- (000603FC) --------------------------------------------------------
unsigned int all_dev_poweroff()
{
  int (**v0)(); // r0
  int v2; // [sp+4h] [bp-10h] BYREF
  _DWORD *all_created_runtime; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  v2 = 0;
  all_created_runtime = get_all_created_runtime(&v2);
  for ( i = 0; i < v2; ++i )
  {
    (*(void (__fastcall **)(_DWORD))(all_created_runtime[i] + 20))(all_created_runtime[i]);
    v0 = dev_ctrl();
    ((void (__fastcall *)(_DWORD))v0[7])(*(_DWORD *)(all_created_runtime[i] + 248));
  }
  return power_off();
}

//----- (000604B8) --------------------------------------------------------
unsigned int power_off()
{
  bitmain_power_off();
  byte_152440 = 0;
  return sleep(1u);
}
// 152440: using guessed type char byte_152440;

//----- (000604E4) --------------------------------------------------------
int __fastcall power_info_init(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)&byte_15242C = a1;
  unk_152430 = a2;
  dword_152434 = a3;
  *(_DWORD *)&byte_152438 = a4;
  dword_15243C = a5;
  return 0;
}
// 15242C: using guessed type char byte_15242C;
// 152434: using guessed type int dword_152434;
// 152438: using guessed type char byte_152438;
// 15243C: using guessed type int dword_15243C;

//----- (00060530) --------------------------------------------------------
int __fastcall set_power_init_status(char a1)
{
  byte_152428 = a1;
  return 0;
}
// 152428: using guessed type char byte_152428;

//----- (00060568) --------------------------------------------------------
int is_power_init()
{
  return (unsigned __int8)byte_152428;
}
// 152428: using guessed type char byte_152428;

//----- (0006058C) --------------------------------------------------------
int is_power_on()
{
  return (unsigned __int8)byte_152440;
}
// 152440: using guessed type char byte_152440;

//----- (000605B0) --------------------------------------------------------
int __fastcall power_init(char a1, int a2)
{
  int (**v3)(); // r0
  int (**v4)(); // r0
  int (**v5)(); // r0
  int (**v6)(); // r0
  int (**v7)(); // r0
  int v9; // [sp+10h] [bp-1024h] BYREF
  char v10; // [sp+17h] [bp-101Dh]
  char v11[24]; // [sp+1Ch] [bp-1018h] BYREF
  int j; // [sp+101Ch] [bp-18h]
  int i; // [sp+1020h] [bp-14h]
  int power_status; // [sp+1024h] [bp-10h]
  void *all_created_runtime; // [sp+1028h] [bp-Ch]
  unsigned __int16 v16; // [sp+102Ch] [bp-8h]
  unsigned __int16 v17; // [sp+102Eh] [bp-6h]

  v9 = a2;
  v10 = a1;
  power_status = 0;
  all_created_runtime = get_all_created_runtime(&v9);
  if ( (unsigned __int8)platform_is_adjustable_power() != 1 )
  {
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "%s, current algo donot use adjustable power!", "power_init");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "power_init",
      10,
      309,
      100,
      v11);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "Sweep error string = %s.", "V:2");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "power_init",
      10,
      310,
      100,
      v11);
    return -1;
  }
  else
  {
    v16 = bitmain_power_version();
    if ( platform_is_psu_supported(v16) )
    {
      if ( (unsigned __int8)platform_is_pic_mcu_en() != 1 )
      {
        v16 = bitmain_set_watchdog(0);
        if ( v16 )
        {
          V_LOCK();
          logfmt_raw(v11, 0x1000u, 0, "disable power watchdog: %04x", v16);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/power_api.c",
            160,
            "power_init",
            10,
            323,
            100,
            v11);
          return power_status;
        }
        sleep(1u);
      }
      power_off();
      if ( v10 )
      {
        fan_pwm_set(0);
        while ( 1 )
        {
          fan_pwm_set(0);
          sleep(0xAu);
        }
      }
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "Initializing the power, please wait, this may take up 1 minute...");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "power_init",
        10,
        338,
        60,
        v11);
      sleep(0x1Eu);
      if ( (unsigned __int8)platform_is_pic_mcu_en() != 1 )
        sub_5FB68();
      v17 = bitmain_power_fw_version();
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "bitmain power fw version: %04x", v17);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "power_init",
        10,
        347,
        60,
        v11);
      byte_152441 = 0;
      dword_152444 = 0;
      dword_152448 = 0;
      byte_152428 = 1;
      if ( opt_custom_voltage_swith || is_eeprom_loaded() )
        dword_152434 = opt_custom_voltage;
      byte_15242C = platform_is_adjustable_power();
      byte_152438 = platform_is_check_asic_voltage_enable();
      dword_15243C = platfrom_get_check_asic_voltage();
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "Power init:");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "power_init",
        10,
        368,
        20,
        v11);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "current_voltage_raw\t\t= %d", dword_152444);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "power_init",
        10,
        369,
        20,
        v11);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "working_voltage_raw\t\t= %d", dword_152434);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "power_init",
        10,
        370,
        20,
        v11);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "check_asic_voltage_enable\t= %d", (unsigned __int8)byte_152438);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "power_init",
        10,
        371,
        20,
        v11);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "check_asic_voltage_raw\t= %d", dword_15243C);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "power_init",
        10,
        372,
        20,
        v11);
      if ( is_check_asic_voltage_enable() )
        power_status = set_check_asic_voltage(0);
      else
        power_status = set_working_voltage(0);
      if ( power_status )
      {
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, "set_voltage_by_steps error!");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/power_api.c",
          160,
          "power_init",
          10,
          380,
          100,
          v11);
        return -1;
      }
      else
      {
        for ( i = 0; i <= 19; ++i )
        {
          if ( v16 == 113 || v16 == 116 )
          {
            power_status = 0;
            break;
          }
          power_status = bitmain_get_power_status();
          if ( !power_status )
          {
            power_status = 0;
            break;
          }
          if ( !((i + 1) % 5) )
          {
            V_LOCK();
            logfmt_raw(v11, 0x1000u, 0, ">> bitmain_get_power_status failed(%d) <<", power_status);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/miner_util/power_api.c",
              160,
              "power_init",
              10,
              394,
              100,
              v11);
          }
          sleep(3u);
        }
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, "bitmain_get_power_status end!");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/power_api.c",
          160,
          "power_init",
          10,
          401,
          20,
          v11);
        power_on();
        usleep(0x61A80u);
        for ( j = 0; j < v9; ++j )
        {
          v3 = dev_ctrl();
          ((void (__fastcall *)(int))v3[9])(j);
          sleep(1u);
          v4 = dev_ctrl();
          ((void (__fastcall *)(int))v4[10])(j);
          usleep(0x493E0u);
          v5 = dev_ctrl();
          ((void (__fastcall *)(int))v5[9])(j);
          sleep(1u);
          v6 = dev_ctrl();
          ((void (__fastcall *)(int))v6[10])(j);
          usleep(0x493E0u);
          v7 = dev_ctrl();
          ((void (__fastcall *)(int))v7[9])(j);
        }
        if ( sub_5F3D0() )
        {
          V_LOCK();
          logfmt_raw(v11, 0x1000u, 0, "check_feedback_voltage error!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/power_api.c",
            160,
            "power_init",
            10,
            419,
            100,
            v11);
          return -1;
        }
        else
        {
          V_LOCK();
          logfmt_raw(v11, 0x1000u, 0, "check_feedback_voltage end!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/power_api.c",
            160,
            "power_init",
            10,
            424,
            40,
            v11);
          return power_status;
        }
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "Not support power version, %04x", v16);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/power_api.c",
        160,
        "power_init",
        10,
        316,
        100,
        v11);
      return -1;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1513E8: using guessed type char opt_custom_voltage_swith;
// 1513EC: using guessed type int opt_custom_voltage;
// 152428: using guessed type char byte_152428;
// 15242C: using guessed type char byte_15242C;
// 152434: using guessed type int dword_152434;
// 152438: using guessed type char byte_152438;
// 15243C: using guessed type int dword_15243C;
// 152441: using guessed type char byte_152441;
// 152444: using guessed type int dword_152444;
// 152448: using guessed type int dword_152448;
// 1608F0: using guessed type int g_zc;

//----- (00061148) --------------------------------------------------------
int __fastcall set_current_voltage(int a1)
{
  dword_152444 = a1;
  return 0;
}
// 152444: using guessed type int dword_152444;

//----- (0006117C) --------------------------------------------------------
int __fastcall set_voltage(int a1, char a2)
{
  char v5[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a2 != 1 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "set_voltage power is not inited");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "set_voltage",
      11,
      438,
      100,
      v5);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Sweep error string = %s.", "V:1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "set_voltage",
      11,
      439,
      100,
      v5);
    return -1;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "set_voltage to %d", a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "set_voltage",
      11,
      442,
      40,
      v5);
    return sub_5FD30(a1, (int)&byte_152428);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152428: using guessed type char byte_152428;
// 1608F0: using guessed type int g_zc;

//----- (00061354) --------------------------------------------------------
int __fastcall set_voltage_by_steps(int a1, char a2, unsigned int a3)
{
  signed int v4; // r2
  int v5; // r3
  char v9[20]; // [sp+20h] [bp-1014h] BYREF
  int v10; // [sp+1020h] [bp-14h]
  int current_voltage; // [sp+1024h] [bp-10h]
  int v12; // [sp+1028h] [bp-Ch]
  signed int v13; // [sp+102Ch] [bp-8h]

  if ( a2 != 1 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "Sweep error string = %s.", "V:1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "set_voltage_by_steps",
      20,
      449,
      100,
      v9);
    return -1;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "set_voltage_by_steps to %d", a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "set_voltage_by_steps",
      20,
      453,
      40,
      v9);
    v10 = 0;
    if ( a3 > 0x64 )
      a3 = 100;
    v13 = a3 / 0xA;
    current_voltage = get_current_voltage();
    v12 = a1 - current_voltage;
    if ( a1 == current_voltage )
    {
      return 0;
    }
    else
    {
      if ( v12 < 0 )
        v13 = -v13;
      while ( 1 )
      {
        v4 = abs32(v12);
        v5 = v13;
        if ( v13 < 0 )
          v5 = -v13;
        if ( v4 <= v5 )
          break;
        current_voltage += v13;
        v12 -= v13;
        sub_5FD30(current_voltage, (int)&byte_152428);
      }
      if ( a1 != current_voltage )
        sub_5FD30(a1, (int)&byte_152428);
      return v10;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152428: using guessed type char byte_152428;
// 1608F0: using guessed type int g_zc;

//----- (000615E4) --------------------------------------------------------
int get_current_voltage()
{
  char v2[4]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_152428 == 1 )
    return dword_152444;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "Sweep error string = %s.", "V:1");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "get_current_voltage",
    19,
    496,
    100,
    v2);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152428: using guessed type char byte_152428;
// 152444: using guessed type int dword_152444;
// 1608F0: using guessed type int g_zc;

//----- (000616A8) --------------------------------------------------------
int get_working_voltage()
{
  char v2[4]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_152428 == 1 )
    return dword_152434;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "Sweep error string = %s.", "V:1");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "get_working_voltage",
    19,
    506,
    100,
    v2);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152428: using guessed type char byte_152428;
// 152434: using guessed type int dword_152434;
// 1608F0: using guessed type int g_zc;

//----- (0006176C) --------------------------------------------------------
int get_max_voltage()
{
  double v0; // d0
  char v3[4]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_152428 != 1 )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "Sweep error string = %s.", "V:1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/power_api.c",
      160,
      "get_max_voltage",
      15,
      516,
      100,
      v3);
    return -1;
  }
  else
  {
    bitmain_convert_N_to_V();
    return (int)(v0 * 100.0);
  }
}
// 61828: variable 'v0' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152428: using guessed type char byte_152428;
// 1608F0: using guessed type int g_zc;

//----- (00061848) --------------------------------------------------------
int __fastcall set_working_voltage(char a1)
{
  char v3[8]; // [sp+1Ch] [bp-1008h] BYREF
  __int16 v4; // [sp+101Eh] [bp-6h]

  v4 = 0;
  if ( a1 )
    v4 = set_voltage_by_steps(dword_152434, byte_152428, 0x64u);
  else
    v4 = set_voltage(dword_152434, byte_152428);
  if ( !v4 )
    return 0;
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "set_working_voltage error!");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "set_working_voltage",
    19,
    532,
    100,
    v3);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152428: using guessed type char byte_152428;
// 152434: using guessed type int dword_152434;
// 1608F0: using guessed type int g_zc;

//----- (00061978) --------------------------------------------------------
int is_check_asic_voltage_enable()
{
  return byte_15242C && byte_152438;
}
// 15242C: using guessed type char byte_15242C;
// 152438: using guessed type char byte_152438;

//----- (000619CC) --------------------------------------------------------
int __fastcall set_check_asic_voltage(char a1)
{
  char v4[8]; // [sp+1Ch] [bp-1008h] BYREF
  int v5; // [sp+101Ch] [bp-8h]

  v5 = 0;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set_check_asic_voltage");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "set_check_asic_voltage",
    22,
    548,
    40,
    v4);
  if ( a1 )
    v5 = set_voltage_by_steps(dword_15243C, byte_152428, 0x64u);
  else
    v5 = set_voltage(dword_15243C, byte_152428);
  if ( !v5 )
    return 0;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set_check_asic_voltage error!");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/power_api.c",
    160,
    "set_check_asic_voltage",
    22,
    556,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152428: using guessed type char byte_152428;
// 15243C: using guessed type int dword_15243C;
// 1608F0: using guessed type int g_zc;

//----- (00061B68) --------------------------------------------------------
int __fastcall sub_61B68(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 61BD4: variable 'v3' is possibly undefined

//----- (00061C80) --------------------------------------------------------
int __fastcall sub_61C80(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (00061CF4) --------------------------------------------------------
int __fastcall sub_61CF4(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00061E18) --------------------------------------------------------
_BYTE *__fastcall sub_61E18(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00061E84) --------------------------------------------------------
int sub_61E84()
{
  signed int v1; // r3
  _BYTE v3[224]; // [sp+10h] [bp-11ECh] BYREF
  char v4[12]; // [sp+F0h] [bp-110Ch] BYREF
  void *dest[57]; // [sp+10F0h] [bp-10Ch] BYREF
  int v6; // [sp+11D4h] [bp-28h] BYREF
  void *ptr; // [sp+11D8h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+11DCh] [bp-20h]
  signed int k; // [sp+11E0h] [bp-1Ch]
  int j; // [sp+11E4h] [bp-18h]
  int i; // [sp+11E8h] [bp-14h]
  int v12; // [sp+11ECh] [bp-10h]
  size_t nmemb; // [sp+11F0h] [bp-Ch]
  signed int v14; // [sp+11F4h] [bp-8h]

  v6 = 0;
  v14 = 0x80000000;
  all_created_runtime = get_all_created_runtime(&v6);
  nmemb = 0;
  v12 = 0;
  for ( i = 0; i < v6; ++i )
  {
    read_status_from_monitor(dest, all_created_runtime[i]);
    nmemb += (size_t)dest[8];
  }
  ptr = calloc(nmemb, 4u);
  if ( ptr )
  {
    for ( j = 0; j < v6; ++j )
    {
      read_status_from_monitor(v3, all_created_runtime[j]);
      memcpy(dest, v3, 0xE0u);
      memcpy((char *)ptr + 4 * v12, dest[4], 4 * (int)dest[8]);
      v12 += (int)dest[8];
    }
    for ( k = 0; k < (int)nmemb; ++k )
    {
      v1 = *((_DWORD *)ptr + k);
      if ( v14 >= v1 )
        v1 = v14;
      v14 = v1;
    }
    free(ptr);
    dword_14F404 = v14;
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "max temp chip: %d", v14);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/set_pwm_by_temp.c",
      166,
      "get_max_chip_temp",
      17,
      59,
      20,
      v4);
    return v14;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "temp_out_chip");
    return dword_14F404;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14F404: using guessed type int dword_14F404;
// 1608F0: using guessed type int g_zc;

//----- (00062104) --------------------------------------------------------
int sub_62104()
{
  int v0; // r3
  int v1; // r3
  _BYTE src[224]; // [sp+0h] [bp-1DCh] BYREF
  _DWORD dest[56]; // [sp+E0h] [bp-FCh] BYREF
  int v5; // [sp+1C0h] [bp-1Ch] BYREF
  int *all_created_runtime; // [sp+1C4h] [bp-18h]
  int k; // [sp+1C8h] [bp-14h]
  int j; // [sp+1CCh] [bp-10h]
  int i; // [sp+1D0h] [bp-Ch]
  int v10; // [sp+1D4h] [bp-8h]

  v5 = 0;
  v10 = 0x7FFFFFFF;
  all_created_runtime = (int *)get_all_created_runtime(&v5);
  if ( v5 > 0 )
  {
    read_status_from_monitor(dest, *all_created_runtime);
    for ( i = 0; i < v5; ++i )
    {
      read_status_from_monitor(src, all_created_runtime[i]);
      memcpy(dest, src, sizeof(dest));
      for ( j = 0; j < dest[7]; ++j )
      {
        v0 = *(_DWORD *)(dest[2] + 4 * j);
        if ( v10 < v0 )
          v0 = v10;
        v10 = v0;
      }
      for ( k = 0; k < dest[8]; ++k )
      {
        v1 = *(_DWORD *)(dest[4] + 4 * k);
        if ( v10 < v1 )
          v1 = v10;
        v10 = v1;
      }
    }
  }
  return v10;
}

//----- (00062264) --------------------------------------------------------
signed int sub_62264()
{
  signed int v0; // r3
  signed int v1; // r3
  _BYTE src[224]; // [sp+0h] [bp-1DCh] BYREF
  _DWORD dest[56]; // [sp+E0h] [bp-FCh] BYREF
  int v5; // [sp+1C0h] [bp-1Ch] BYREF
  int *all_created_runtime; // [sp+1C4h] [bp-18h]
  int k; // [sp+1C8h] [bp-14h]
  int j; // [sp+1CCh] [bp-10h]
  int i; // [sp+1D0h] [bp-Ch]
  signed int v10; // [sp+1D4h] [bp-8h]

  v5 = 0;
  v10 = 0x80000000;
  all_created_runtime = (int *)get_all_created_runtime(&v5);
  if ( v5 > 0 )
  {
    read_status_from_monitor(dest, *all_created_runtime);
    for ( i = 0; i < v5; ++i )
    {
      read_status_from_monitor(src, all_created_runtime[i]);
      memcpy(dest, src, sizeof(dest));
      for ( j = 0; j < dest[7]; ++j )
      {
        v0 = *(_DWORD *)(dest[1] + 4 * j);
        if ( v10 >= v0 )
          v0 = v10;
        v10 = v0;
      }
      for ( k = 0; k < dest[8]; ++k )
      {
        v1 = *(_DWORD *)(dest[3] + 4 * k);
        if ( v10 >= v1 )
          v1 = v10;
        v10 = v1;
      }
    }
  }
  return v10;
}

//----- (000623C4) --------------------------------------------------------
int sub_623C4()
{
  int v1; // r3
  int v2; // r3
  int v3; // r3
  _DWORD *v5; // [sp+0h] [bp-114h] BYREF
  size_t nmemb[2]; // [sp+E0h] [bp-34h] BYREF
  int temp; // [sp+E8h] [bp-2Ch]
  int v8; // [sp+ECh] [bp-28h]
  void *ptr; // [sp+F0h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+F4h] [bp-20h]
  int v11; // [sp+F8h] [bp-1Ch]
  int v12; // [sp+FCh] [bp-18h]
  int v13; // [sp+100h] [bp-14h]
  int j; // [sp+104h] [bp-10h]
  int i; // [sp+108h] [bp-Ch]
  int v16; // [sp+10Ch] [bp-8h]

  nmemb[0] = 0;
  v16 = -64;
  v13 = -64;
  v12 = 0;
  v11 = 0;
  all_created_runtime = get_all_created_runtime(nmemb);
  ptr = calloc(nmemb[0], 4u);
  if ( ptr )
  {
    v8 = 0;
    temp = 0;
    nmemb[1] = 0;
    for ( i = 0; i < (int)nmemb[0]; ++i )
    {
      read_status_from_monitor(&v5, all_created_runtime[i]);
      *((_DWORD *)ptr + i) = *v5;
    }
    for ( j = 0; j < (int)nmemb[0]; ++j )
    {
      v1 = *((_DWORD *)ptr + j);
      if ( v16 >= v1 )
        v1 = v16;
      v16 = v1;
    }
    temp = get_temp(2);
    if ( temp != -64 && (int)nmemb[0] > 0 )
    {
      v2 = dword_14F408 + temp - *(_DWORD *)(*all_created_runtime + 400);
      v8 = 2 * (v2 & ~(v2 >> 31));
      v16 += v8;
      v3 = dword_14F40C + temp - *(_DWORD *)(*all_created_runtime + 400);
      v8 = 2 * (v3 & ~(v3 >> 31));
      v16 += v8;
    }
    free(ptr);
    return v16;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "temp_avg_chip_local");
    return 255;
  }
}
// 62914: using guessed type int __fastcall get_temp(_DWORD);
// 14F408: using guessed type int dword_14F408;
// 14F40C: using guessed type int dword_14F40C;

//----- (000625D4) --------------------------------------------------------
int sub_625D4()
{
  int v1; // r3
  _BYTE v3[224]; // [sp+10h] [bp-11ECh] BYREF
  char v4[12]; // [sp+F0h] [bp-110Ch] BYREF
  void *dest[57]; // [sp+10F0h] [bp-10Ch] BYREF
  int v6; // [sp+11D4h] [bp-28h] BYREF
  void *ptr; // [sp+11D8h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+11DCh] [bp-20h]
  int i; // [sp+11E0h] [bp-1Ch]
  int v10; // [sp+11E4h] [bp-18h]
  size_t nmemb; // [sp+11E8h] [bp-14h]
  int v12; // [sp+11ECh] [bp-10h]
  signed int k; // [sp+11F0h] [bp-Ch]
  int j; // [sp+11F4h] [bp-8h]

  v6 = 0;
  v12 = 0x7FFFFFFF;
  all_created_runtime = get_all_created_runtime(&v6);
  nmemb = 0;
  v10 = 0;
  for ( i = 0; i < v6; ++i )
  {
    read_status_from_monitor(dest, all_created_runtime[i]);
    nmemb += (size_t)dest[7];
  }
  ptr = calloc(nmemb, 4u);
  if ( ptr )
  {
    for ( j = 0; j < v6; ++j )
    {
      read_status_from_monitor(v3, all_created_runtime[j]);
      memcpy(dest, v3, 0xE0u);
      memcpy((char *)ptr + 4 * v10, dest[1], 4 * (int)dest[7]);
      v10 += (int)dest[7];
    }
    for ( k = 0; k < (int)nmemb; ++k )
    {
      if ( check_value_valid_with_stdd((int)ptr, nmemb, *((_DWORD *)ptr + k)) )
      {
        v1 = *((_DWORD *)ptr + k);
        if ( v12 < v1 )
          v1 = v12;
        v12 = v1;
      }
      else
      {
        V_LOCK();
        logfmt_raw(v4, 0x1000u, 0, "%d C, most likely a bad sensor", *((_DWORD *)ptr + k));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/set_pwm_by_temp.c",
          166,
          "get_min_pcb_temp",
          16,
          169,
          20,
          v4);
      }
    }
    free(ptr);
    dword_14F410 = v12;
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "min temp pcb: %d", v12);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/set_pwm_by_temp.c",
      166,
      "get_min_pcb_temp",
      16,
      175,
      20,
      v4);
    return v12;
  }
  else
  {
    printf("invalid pointer(%s)!\n", "temp_in_pcb");
    return dword_14F410;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14F410: using guessed type int dword_14F410;
// 1608F0: using guessed type int g_zc;

//----- (00062914) --------------------------------------------------------
signed int __fastcall get_temp(int a1)
{
  char v3[8]; // [sp+1Ch] [bp-1008h] BYREF
  signed int v4; // [sp+101Ch] [bp-8h]

  switch ( a1 )
  {
    case 0:
      v4 = sub_62264();
      break;
    case 1:
      v4 = sub_625D4();
      break;
    case 2:
      v4 = sub_61E84();
      break;
    case 3:
      v4 = sub_62104();
      break;
    case 4:
      v4 = sub_623C4();
      break;
    default:
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "%s unknow temp type %d", a1);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/set_pwm_by_temp.c",
        166,
        "get_temp",
        8,
        201,
        100,
        v3);
      v4 = 0x7FFFFFFF;
      break;
  }
  return v4;
}
// 62944: control flows out of bounds to 62948
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00062A34) --------------------------------------------------------
int sub_62A34()
{
  int v0; // r2
  int v1; // r3
  signed int temp; // [sp+4h] [bp-18h]
  int v4; // [sp+14h] [bp-8h]

  temp = get_temp(1);
  if ( temp > 18 )
  {
    if ( temp > 33 )
    {
      if ( temp > 38 )
      {
        if ( temp > 48 )
        {
          if ( temp > 55 )
            v4 = 100;
          else
            v4 = (int)((double)(temp - 48) * 5.71428571 + 60.0);
        }
        else
        {
          v4 = (int)((double)(temp - 38) + 50.0);
        }
      }
      else
      {
        v4 = 50;
      }
    }
    else
    {
      v4 = (int)((double)(temp - 18) * 0.666666667 + 40.0);
    }
  }
  else
  {
    v4 = 40;
  }
  if ( get_temp(dword_14F3DC) >= dword_14F3E0 )
    v4 = 100;
  v0 = dword_14F3D4;
  if ( dword_14F3D4 < v4 )
    v0 = v4;
  v1 = dword_14F3D8;
  if ( v0 < dword_14F3D8 )
    return v0;
  return v1;
}
// 62AC8: conditional instruction was optimized away because %var_14.4>=22
// 62AEC: conditional instruction was optimized away because %var_14.4>=27
// 62B34: conditional instruction was optimized away because %var_14.4>=31
// 14F3D4: using guessed type int dword_14F3D4;
// 14F3D8: using guessed type int dword_14F3D8;
// 14F3DC: using guessed type int dword_14F3DC;
// 14F3E0: using guessed type int dword_14F3E0;

//----- (00062C30) --------------------------------------------------------
int sub_62C30()
{
  int v0; // r2
  int v1; // r3
  signed int temp; // [sp+4h] [bp-18h]
  int v4; // [sp+14h] [bp-8h]

  temp = get_temp(1);
  if ( temp > 13 )
  {
    if ( temp > 32 )
      v4 = (int)((double)(temp - 32) * 1.42857143 + 60.0);
    else
      v4 = (int)((double)(temp - 13) * 2.10526316 + 20.0);
  }
  else
  {
    v4 = 20;
  }
  if ( get_temp(dword_14F3DC) >= dword_14F3E0 )
    v4 = 100;
  v0 = dword_14F3D4;
  if ( dword_14F3D4 < v4 )
    v0 = v4;
  v1 = dword_14F3D8;
  if ( v0 < dword_14F3D8 )
    return v0;
  return v1;
}
// 14F3D4: using guessed type int dword_14F3D4;
// 14F3D8: using guessed type int dword_14F3D8;
// 14F3DC: using guessed type int dword_14F3DC;
// 14F3E0: using guessed type int dword_14F3E0;

//----- (00062D88) --------------------------------------------------------
int __fastcall sub_62D88(int result)
{
  *(float *)(result + 32) = *(float *)(result + 8) - *(float *)(result + 12);
  *(_DWORD *)(result + 40) = *(_DWORD *)(result + 36);
  *(_DWORD *)(result + 36) = *(_DWORD *)(result + 32);
  return result;
}

//----- (00062EC8) --------------------------------------------------------
int __fastcall sub_62EC8(char a1)
{
  float v1; // s0
  float v2; // s15
  int v6; // [sp+10h] [bp-Ch]
  int v7; // [sp+14h] [bp-8h]
  int v8; // [sp+14h] [bp-8h]

  flt_15245C = (float)get_temp(dword_14F3E4);
  v7 = fan_pwm_get();
  sub_62D88((int)&flt_152450);
  v6 = (int)v1;
  if ( a1 && v6 < -20 )
    v6 = -20;
  v8 = v7 + v6;
  if ( get_temp(dword_14F3DC) >= dword_14F3E0 )
    v8 = 100;
  if ( (float)v8 >= flt_152454 )
    v2 = (float)v8;
  else
    v2 = flt_152454;
  if ( v2 > flt_152450 )
    return (int)flt_152450;
  if ( (float)v8 >= flt_152454 )
    return (int)(float)v8;
  return (int)flt_152454;
}
// 62F34: variable 'v1' is possibly undefined
// 14F3DC: using guessed type int dword_14F3DC;
// 14F3E0: using guessed type int dword_14F3E0;
// 14F3E4: using guessed type int dword_14F3E4;
// 152450: using guessed type float flt_152450;
// 152454: using guessed type float flt_152454;
// 15245C: using guessed type float flt_15245C;

//----- (00063068) --------------------------------------------------------
int set_pwm_by_temp()
{
  __int64 v0; // r0
  __int64 v2; // [sp+10h] [bp-1Ch]
  unsigned int v3; // [sp+1Ch] [bp-10h]
  unsigned int v4; // [sp+1Ch] [bp-10h]
  unsigned int v5; // [sp+1Ch] [bp-10h]

  if ( byte_15247C != 1 )
  {
    clock_gettime(1, (struct timespec *)&dword_152480);
    dbl_152490 = 0.0;
    byte_15247C = 1;
    goto LABEL_8;
  }
  clock_gettime(1, (struct timespec *)&dword_152488);
  v0 = (dword_15248C - dword_152484) / 1000000;
  v2 = v0
     + vshld_n_s64(
         4 * (vshld_n_s64(dword_152488 - dword_152480, 5u) - (dword_152488 - dword_152480))
       + dword_152488
       - dword_152480,
         3u);
  if ( *(__int64 *)&dbl_152490 < 20 && (LODWORD(v0) = v2, v2 >= dword_14F3EC)
    || *(__int64 *)&dbl_152490 >= 20 && (LODWORD(v0) = v2, v2 >= dword_14F3F0) )
  {
    clock_gettime(1, (struct timespec *)&dword_152480);
    ++*(_QWORD *)&dbl_152490;
LABEL_8:
    if ( dword_14F3D0 == 1 )
    {
      v4 = sub_62C30();
      LODWORD(v0) = fan_pwm_set(v4);
    }
    else if ( dword_14F3D0 )
    {
      if ( dword_14F3D0 == 2 )
      {
        v5 = sub_62EC8(*(_QWORD *)&dbl_152490 < 21LL);
        LODWORD(v0) = fan_pwm_set(v5);
      }
      else
      {
        LODWORD(v0) = fan_pwm_set(0x64u);
      }
    }
    else
    {
      v3 = sub_62A34();
      LODWORD(v0) = fan_pwm_set(v3);
    }
  }
  return v0;
}
// 14F3D0: using guessed type int dword_14F3D0;
// 14F3EC: using guessed type int dword_14F3EC;
// 14F3F0: using guessed type int dword_14F3F0;
// 15247C: using guessed type char byte_15247C;
// 152480: using guessed type int dword_152480;
// 152484: using guessed type int dword_152484;
// 152488: using guessed type int dword_152488;
// 15248C: using guessed type int dword_15248C;
// 152490: using guessed type double dbl_152490;

//----- (000632D0) --------------------------------------------------------
int __fastcall fan_control_info_init(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  char v14[4]; // [sp+38h] [bp-1004h] BYREF
  int varg_r0; // [sp+1040h] [bp+4h]
  int varg_r1; // [sp+1044h] [bp+8h]
  int varg_r2; // [sp+1048h] [bp+Ch]
  int varg_r3; // [sp+104Ch] [bp+10h]

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  dword_14F3D0 = a1;
  dword_14F3D4 = a2;
  dword_14F3D8 = a3;
  dword_14F3DC = a4;
  dword_14F3E0 = a5;
  dword_14F3E4 = a6;
  dword_14F3E8 = a7;
  dword_14F3EC = a8;
  dword_14F3F0 = a9;
  dword_14F3F4 = a10;
  dword_14F3F8 = a11;
  dword_14F3FC = a12;
  dword_14F400 = a13;
  memset(&flt_152450, 0, 0x2Cu);
  if ( dword_14F3D0 == 2 )
  {
    dword_152460 = dword_14F3F4;
    dword_152464 = dword_14F3F8;
    dword_152468 = dword_14F3FC;
    dword_15246C = dword_14F400;
    flt_152458 = (float)dword_14F3E8;
    flt_152454 = (float)dword_14F3D4;
    flt_152450 = (float)dword_14F3D8;
  }
  V_LOCK();
  logfmt_raw(
    v14,
    0x1000u,
    0,
    "startup P: %f, p: %f, i: %f, d: %f   target: %f, min %f, max %f",
    *(float *)&dword_152460,
    *(float *)&dword_152464,
    *(float *)&dword_152468,
    *(float *)&dword_15246C,
    flt_152458,
    flt_152454,
    flt_152450);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/set_pwm_by_temp.c",
    166,
    "fan_control_info_init",
    21,
    375,
    20,
    v14);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14F3D0: using guessed type int dword_14F3D0;
// 14F3D4: using guessed type int dword_14F3D4;
// 14F3D8: using guessed type int dword_14F3D8;
// 14F3DC: using guessed type int dword_14F3DC;
// 14F3E0: using guessed type int dword_14F3E0;
// 14F3E4: using guessed type int dword_14F3E4;
// 14F3E8: using guessed type int dword_14F3E8;
// 14F3EC: using guessed type int dword_14F3EC;
// 14F3F0: using guessed type int dword_14F3F0;
// 14F3F4: using guessed type int dword_14F3F4;
// 14F3F8: using guessed type int dword_14F3F8;
// 14F3FC: using guessed type int dword_14F3FC;
// 14F400: using guessed type int dword_14F400;
// 152450: using guessed type float flt_152450;
// 152454: using guessed type float flt_152454;
// 152458: using guessed type float flt_152458;
// 152460: using guessed type int dword_152460;
// 152464: using guessed type int dword_152464;
// 152468: using guessed type int dword_152468;
// 15246C: using guessed type int dword_15246C;
// 1608F0: using guessed type int g_zc;

//----- (00063518) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_63518(int a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (00063550) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_63550(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (00063584) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_63584(int a1, char a2)
{
  V_BOOL(a1, "poweroff", a2);
}

//----- (000635C0) --------------------------------------------------------
int __fastcall sub_635C0(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 6362C: variable 'v3' is possibly undefined

//----- (000636D8) --------------------------------------------------------
int __fastcall sub_636D8(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0006374C) --------------------------------------------------------
int __fastcall sub_6374C(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00063870) --------------------------------------------------------
_BYTE *__fastcall sub_63870(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (000638DC) --------------------------------------------------------
int __fastcall sub_638DC(int a1, char a2)
{
  unsigned __int64 v2; // d17
  int v3; // r1
  __int64 v4; // r2
  char v8[40]; // [sp+54h] [bp-11E8h] BYREF
  int v9; // [sp+1054h] [bp-1E8h] BYREF
  _QWORD s[2]; // [sp+1058h] [bp-1E4h] BYREF
  _DWORD v11[7]; // [sp+1068h] [bp-1D4h] BYREF
  int v12; // [sp+1084h] [bp-1B8h]
  _DWORD v13[8]; // [sp+1088h] [bp-1B4h] BYREF
  _DWORD v14[7]; // [sp+10A8h] [bp-194h] BYREF
  int v15; // [sp+10C4h] [bp-178h]
  _DWORD v16[8]; // [sp+10C8h] [bp-174h] BYREF
  _DWORD v17[7]; // [sp+10E8h] [bp-154h] BYREF
  int v18; // [sp+1104h] [bp-138h]
  _DWORD v19[8]; // [sp+1108h] [bp-134h] BYREF
  _DWORD v20[7]; // [sp+1128h] [bp-114h] BYREF
  int v21; // [sp+1144h] [bp-F8h]
  _DWORD v22[8]; // [sp+1148h] [bp-F4h] BYREF
  _DWORD v23[7]; // [sp+1168h] [bp-D4h] BYREF
  int v24; // [sp+1184h] [bp-B8h]
  _DWORD v25[39]; // [sp+1188h] [bp-B4h] BYREF
  _DWORD *all_created_runtime; // [sp+1224h] [bp-18h]
  int i; // [sp+1228h] [bp-14h]
  char *flag_from_monitor; // [sp+122Ch] [bp-10h]

  v9 = 0;
  all_created_runtime = get_all_created_runtime(&v9);
  memset(s, 0, sizeof(s));
  for ( i = 0; i < v9; ++i )
  {
    flag_from_monitor = get_flag_from_monitor(all_created_runtime[i]);
    v25[38] = flag_from_monitor + 16;
    v25[37] = 0;
    LODWORD(v2) = 0;
    if ( (vshld_u64(1u, v2) & *((_QWORD *)flag_from_monitor + 2)) != 0 )
    {
      v25[36] = flag_from_monitor + 16;
      v25[35] = 0;
      LODWORD(v2) = 0;
      *((_QWORD *)flag_from_monitor + 3) |= vshld_u64(1u, v2);
      if ( a2 )
      {
        V_LOCK();
        sub_63550((int)v11, *(int *)(all_created_runtime[i] + 252));
        sub_63518((int)v13, "temp lost");
        logfmt_raw(
          v8,
          0x1000u,
          0,
          v12,
          v11[0],
          v11[1],
          v11[2],
          v11[3],
          v11[4],
          v11[5],
          v11[6],
          v12,
          v13[0],
          v13[1],
          v13[2],
          v13[3],
          v13[4],
          v13[5],
          v13[6],
          v13[7],
          "%s",
          "check_temp");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
          183,
          "check_temp",
          10,
          36,
          100,
          v8);
        v25[34] = s;
        v25[33] = 0;
        LODWORD(v2) = 0;
        s[0] |= vshld_u64(1u, v2);
      }
    }
    v25[32] = flag_from_monitor + 16;
    v25[31] = 1;
    LODWORD(v2) = 1;
    if ( (vshld_u64(1u, v2) & *((_QWORD *)flag_from_monitor + 2)) != 0 )
    {
      v25[30] = flag_from_monitor + 16;
      v25[29] = 1;
      LODWORD(v2) = 1;
      *((_QWORD *)flag_from_monitor + 3) |= vshld_u64(1u, v2);
      if ( a2 )
      {
        V_LOCK();
        sub_63550((int)v14, *(int *)(all_created_runtime[i] + 252));
        sub_63518((int)v16, "temp too high");
        logfmt_raw(
          v8,
          0x1000u,
          0,
          v15,
          v14[0],
          v14[1],
          v14[2],
          v14[3],
          v14[4],
          v14[5],
          v14[6],
          v15,
          v16[0],
          v16[1],
          v16[2],
          v16[3],
          v16[4],
          v16[5],
          v16[6],
          v16[7],
          "%s",
          "check_temp");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
          183,
          "check_temp",
          10,
          44,
          100,
          v8);
        v25[28] = s;
        v25[27] = 1;
        LODWORD(v2) = 1;
        s[0] |= vshld_u64(1u, v2);
      }
    }
    v25[26] = flag_from_monitor + 16;
    v25[25] = 2;
    LODWORD(v2) = 2;
    if ( (vshld_u64(1u, v2) & *((_QWORD *)flag_from_monitor + 2)) != 0 )
    {
      v25[24] = flag_from_monitor + 16;
      v25[23] = 2;
      LODWORD(v2) = 2;
      *((_QWORD *)flag_from_monitor + 3) |= vshld_u64(1u, v2);
      if ( a2 )
      {
        V_LOCK();
        sub_63550((int)v17, *(int *)(all_created_runtime[i] + 252));
        sub_63518((int)v19, "temp too low");
        logfmt_raw(
          v8,
          0x1000u,
          0,
          v18,
          v17[0],
          v17[1],
          v17[2],
          v17[3],
          v17[4],
          v17[5],
          v17[6],
          v18,
          v19[0],
          v19[1],
          v19[2],
          v19[3],
          v19[4],
          v19[5],
          v19[6],
          v19[7],
          "%s",
          "check_temp");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
          183,
          "check_temp",
          10,
          52,
          100,
          v8);
        v25[22] = s;
        v25[21] = 2;
        LODWORD(v2) = 2;
        s[0] |= vshld_u64(1u, v2);
      }
    }
    v25[20] = flag_from_monitor + 16;
    v25[19] = 3;
    LODWORD(v2) = 3;
    if ( (vshld_u64(1u, v2) & *((_QWORD *)flag_from_monitor + 2)) != 0 )
    {
      v25[18] = flag_from_monitor + 16;
      v25[17] = 3;
      LODWORD(v2) = 3;
      *((_QWORD *)flag_from_monitor + 3) |= vshld_u64(1u, v2);
      if ( a2 )
      {
        V_LOCK();
        sub_63550((int)v20, *(int *)(all_created_runtime[i] + 252));
        sub_63518((int)v22, "read no temp");
        logfmt_raw(
          v8,
          0x1000u,
          0,
          v21,
          v20[0],
          v20[1],
          v20[2],
          v20[3],
          v20[4],
          v20[5],
          v20[6],
          v21,
          v22[0],
          v22[1],
          v22[2],
          v22[3],
          v22[4],
          v22[5],
          v22[6],
          v22[7],
          "%s",
          "check_temp");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
          183,
          "check_temp",
          10,
          60,
          100,
          v8);
        v25[16] = s;
        v25[15] = 3;
        LODWORD(v2) = 3;
        s[0] |= vshld_u64(1u, v2);
      }
    }
    v25[14] = flag_from_monitor + 16;
    v25[13] = 4;
    LODWORD(v2) = 4;
    if ( (vshld_u64(1u, v2) & *((_QWORD *)flag_from_monitor + 2)) != 0 )
    {
      v25[12] = flag_from_monitor + 16;
      v25[11] = 4;
      LODWORD(v2) = 4;
      *((_QWORD *)flag_from_monitor + 3) |= vshld_u64(1u, v2);
      if ( a2 )
      {
        V_LOCK();
        sub_63550((int)v23, *(int *)(all_created_runtime[i] + 252));
        sub_63518((int)v25, "uneffective temp exceed limit");
        logfmt_raw(
          v8,
          0x1000u,
          0,
          v24,
          v23[0],
          v23[1],
          v23[2],
          v23[3],
          v23[4],
          v23[5],
          v23[6],
          v24,
          v25[0],
          v25[1],
          v25[2],
          v25[3],
          v25[4],
          v25[5],
          v25[6],
          v25[7],
          "%s",
          "check_temp");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
          183,
          "check_temp",
          10,
          68,
          100,
          v8);
        v25[10] = s;
        v25[9] = 4;
        LODWORD(v2) = 4;
        s[0] |= vshld_u64(1u, v2);
      }
    }
  }
  v3 = HIDWORD(s[0]);
  v4 = s[1];
  *(_DWORD *)a1 = s[0];
  *(_DWORD *)(a1 + 4) = v3;
  *(_QWORD *)(a1 + 8) = v4;
  return a1;
}
// 63988: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00064390) --------------------------------------------------------
int __fastcall sub_64390(char a1)
{
  unsigned __int64 v1; // d17
  char v5[72]; // [sp+34h] [bp-1048h] BYREF
  int v6; // [sp+1034h] [bp-48h] BYREF
  _DWORD v7[7]; // [sp+1038h] [bp-44h] BYREF
  int v8; // [sp+1054h] [bp-28h]
  int v9; // [sp+1058h] [bp-24h]
  char *v10; // [sp+105Ch] [bp-20h]
  int v11; // [sp+1060h] [bp-1Ch]
  char *v12; // [sp+1064h] [bp-18h]
  char *flag_from_monitor; // [sp+1068h] [bp-14h]
  int *all_created_runtime; // [sp+106Ch] [bp-10h]

  v6 = 0;
  all_created_runtime = (int *)get_all_created_runtime(&v6);
  flag_from_monitor = get_flag_from_monitor(*all_created_runtime);
  v12 = flag_from_monitor + 32;
  v11 = 2;
  LODWORD(v1) = 2;
  if ( (vshld_u64(1u, v1) & *((_QWORD *)flag_from_monitor + 4)) == 0 )
    return 0;
  v10 = flag_from_monitor + 32;
  v9 = 2;
  LODWORD(v1) = 2;
  *((_QWORD *)flag_from_monitor + 5) |= vshld_u64(1u, v1);
  if ( !a1 )
    return 0;
  V_LOCK();
  sub_63518((int)v7, "fan error exceed limit");
  logfmt_raw(v5, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "%s", "check_fan_err");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
    183,
    "check_fan_err",
    13,
    85,
    100,
    v5);
  return 1;
}
// 64404: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00064568) --------------------------------------------------------
int __fastcall sub_64568(char a1)
{
  unsigned __int64 v1; // d17
  _DWORD v4[3]; // [sp+Ch] [bp-20h] BYREF
  char *flag_from_monitor; // [sp+18h] [bp-14h]
  _DWORD *all_created_runtime; // [sp+1Ch] [bp-10h]
  int i; // [sp+20h] [bp-Ch]
  unsigned __int8 v8; // [sp+27h] [bp-5h]

  v8 = 0;
  v4[0] = 0;
  all_created_runtime = get_all_created_runtime(v4);
  for ( i = 0; i < v4[0]; ++i )
  {
    flag_from_monitor = get_flag_from_monitor(all_created_runtime[i]);
    v4[2] = flag_from_monitor;
    v4[1] = 0;
    LODWORD(v1) = 0;
    if ( (vshld_u64(1u, v1) & *(_QWORD *)flag_from_monitor) != 0 && a1 )
      v8 = 1;
  }
  return v8;
}
// 645EC: variable 'v1' is possibly undefined

//----- (00064668) --------------------------------------------------------
int __fastcall sub_64668(char a1, _BYTE *a2)
{
  int v2; // r3
  char v6[52]; // [sp+30h] [bp-1074h] BYREF
  _DWORD v7[7]; // [sp+1030h] [bp-74h] BYREF
  int v8; // [sp+104Ch] [bp-58h]
  _DWORD v9[7]; // [sp+1050h] [bp-54h] BYREF
  int v10; // [sp+106Ch] [bp-38h]
  int *v11; // [sp+1074h] [bp-30h]
  struct timespec *v12; // [sp+1078h] [bp-2Ch]
  struct timespec *tp; // [sp+107Ch] [bp-28h]
  pthread_mutex_t *v14; // [sp+1080h] [bp-24h]
  unsigned int seconds; // [sp+1084h] [bp-20h]
  __int64 v16; // [sp+1088h] [bp-1Ch]
  unsigned __int8 v17; // [sp+1093h] [bp-11h]
  int i; // [sp+1094h] [bp-10h]

  v17 = 0;
  if ( byte_1524C8 != 1 )
  {
    tp = (struct timespec *)&dword_1524CC;
    clock_gettime(1, (struct timespec *)&dword_1524CC);
    byte_1524C8 = 1;
  }
  for ( i = 0; i < total_pools; ++i )
  {
    v14 = *(pthread_mutex_t **)(pools + 4 * i);
    if ( (unsigned __int8)pool_tget(v14, (unsigned __int8 *)&v14[79].__size[8]) != 1 && pools_active )
    {
      v12 = (struct timespec *)&dword_1524CC;
      clock_gettime(1, (struct timespec *)&dword_1524CC);
      set_miner_6060info_network_lost_err(0);
    }
  }
  v11 = &dword_1524CC;
  clock_gettime(1, (struct timespec *)&dword_1524D4);
  v16 = (dword_1524D8 - dword_1524D0) / 1000000
      + vshld_n_s64(
          4 * (vshld_n_s64(dword_1524D4 - dword_1524CC, 5u) - (dword_1524D4 - dword_1524CC))
        + dword_1524D4
        - dword_1524CC,
          3u);
  if ( byte_1524DC && v16 <= 59999 )
  {
    seconds = rand() % 120 + 60;
    V_LOCK();
    logfmt_raw(
      v6,
      0x1000u,
      0,
      "The pool connection recovered after the system poweroff. Exit and restart mining(%d)!",
      seconds);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
      183,
      "check_lost_connection_to_pool",
      29,
      137,
      80,
      v6);
    sleep(seconds);
    exit(1);
  }
  if ( a1 )
  {
    if ( v16 <= 60000 )
    {
      dword_1524E0 = 0;
    }
    else
    {
      v2 = dword_1524E0++;
      if ( !(v2 % 60) )
      {
        V_LOCK();
        sub_63518((int)v7, "net lost");
        logfmt_raw(
          v6,
          0x1000u,
          0,
          v8,
          v7[0],
          v7[1],
          v7[2],
          v7[3],
          v7[4],
          v7[5],
          v7[6],
          v8,
          "lost internet for %d seconds",
          (int)v16 / 1000);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
          183,
          "check_lost_connection_to_pool",
          29,
          145,
          100,
          v6);
        set_miner_6060info_network_lost_err(1);
      }
      v17 = 1;
    }
    if ( (unsigned int)"ce/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/backend_ltc_1491/chip_reg_io_ltc_1491.c" < v16
      && byte_1524DC != 1 )
    {
      V_LOCK();
      sub_63518((int)v9, "net lost");
      logfmt_raw(
        v6,
        0x1000u,
        0,
        v10,
        v9[0],
        v9[1],
        v9[2],
        v9[3],
        v9[4],
        v9[5],
        v9[6],
        v10,
        "lost internet %d seconds > 20 minutes, poweroff.",
        (int)v16 / 1000);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
        183,
        "check_lost_connection_to_pool",
        29,
        156,
        120,
        v6);
      *a2 = 1;
      byte_1524DC = 1;
    }
  }
  return v17;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 151898: using guessed type char pools_active;
// 15189C: using guessed type int pools;
// 1518A0: using guessed type int total_pools;
// 1524C8: using guessed type char byte_1524C8;
// 1524CC: using guessed type int dword_1524CC;
// 1524D0: using guessed type int dword_1524D0;
// 1524D4: using guessed type int dword_1524D4;
// 1524D8: using guessed type int dword_1524D8;
// 1524DC: using guessed type char byte_1524DC;
// 1524E0: using guessed type int dword_1524E0;
// 1608F0: using guessed type int g_zc;

//----- (00064BD0) --------------------------------------------------------
int __fastcall sub_64BD0(char a1)
{
  byte_14F510 = byte_14F510 == 0;
  if ( a1 )
  {
    green_led_off();
    if ( byte_14F510 )
      return red_led_on();
    else
      return red_led_off();
  }
  else
  {
    red_led_off();
    if ( byte_14F510 )
      return green_led_on();
    else
      return green_led_off();
  }
}
// 14F510: using guessed type char byte_14F510;

//----- (00064C80) --------------------------------------------------------
void sub_64C80()
{
  byte_152498 = 0;
  byte_152499 = 0;
  byte_15249A = 0;
  byte_15249B = 0;
  byte_15249C = 0;
  byte_15249D = 0;
  byte_15249E = 0;
  byte_15249F = 0;
  byte_1524A0 = 0;
}
// 152498: using guessed type char byte_152498;
// 152499: using guessed type char byte_152499;
// 15249A: using guessed type char byte_15249A;
// 15249B: using guessed type char byte_15249B;
// 15249C: using guessed type char byte_15249C;
// 15249D: using guessed type char byte_15249D;
// 15249E: using guessed type char byte_15249E;
// 15249F: using guessed type char byte_15249F;
// 1524A0: using guessed type char byte_1524A0;

//----- (00064D28) --------------------------------------------------------
_DWORD *__fastcall get_miner_working_status(_DWORD *a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3

  if ( byte_1524AC != 1 )
  {
    sub_64C80();
    byte_1524AC = 1;
    byte_15249E = pools_active != 1;
  }
  v1 = *(_DWORD *)&byte_15249C;
  v2 = *(_DWORD *)&byte_1524A0;
  v3 = *(_DWORD *)&algn_1524A1[3];
  *a1 = *(_DWORD *)&byte_152498;
  a1[1] = v1;
  a1[2] = v2;
  a1[3] = v3;
  a1[4] = dword_1524A8;
  return a1;
}
// 151898: using guessed type char pools_active;
// 152498: using guessed type char byte_152498;
// 15249C: using guessed type char byte_15249C;
// 15249E: using guessed type char byte_15249E;
// 1524A0: using guessed type char byte_1524A0;
// 1524A1: using guessed type _BYTE[7];
// 1524A8: using guessed type int dword_1524A8;
// 1524AC: using guessed type char byte_1524AC;

//----- (00064DD8) --------------------------------------------------------
char *get_miner_working_status_p()
{
  return &byte_152498;
}
// 152498: using guessed type char byte_152498;

//----- (00064DF8) --------------------------------------------------------
void update_miner_working_status()
{
  byte_15249E = pools_active != 1;
}
// 151898: using guessed type char pools_active;
// 15249E: using guessed type char byte_15249E;

//----- (00064E50) --------------------------------------------------------
int __fastcall task_check_miner_status(int a1)
{
  unsigned __int64 v1; // d17
  bool v2; // r3
  __int64 v4; // [sp+40h] [bp-1094h] BYREF
  int v5; // [sp+48h] [bp-108Ch]
  int v6; // [sp+4Ch] [bp-1088h]
  int v7; // [sp+54h] [bp-1080h]
  char v8[60]; // [sp+58h] [bp-107Ch] BYREF
  int v9; // [sp+1058h] [bp-7Ch] BYREF
  unsigned __int8 v10; // [sp+105Fh] [bp-75h] BYREF
  __int64 v11; // [sp+1060h] [bp-74h] BYREF
  int v12; // [sp+1068h] [bp-6Ch]
  int v13; // [sp+106Ch] [bp-68h]
  _DWORD v14[7]; // [sp+1070h] [bp-64h] BYREF
  int v15; // [sp+108Ch] [bp-48h]
  int v16; // [sp+1094h] [bp-40h]
  __int64 *v17; // [sp+1098h] [bp-3Ch]
  int v18; // [sp+109Ch] [bp-38h]
  __int64 *v19; // [sp+10A0h] [bp-34h]
  int v20; // [sp+10A4h] [bp-30h]
  __int64 *v21; // [sp+10A8h] [bp-2Ch]
  int v22; // [sp+10ACh] [bp-28h]
  __int64 *v23; // [sp+10B0h] [bp-24h]
  bool v24; // [sp+10B5h] [bp-1Fh]
  char v25; // [sp+10B6h] [bp-1Eh]
  char v26; // [sp+10B7h] [bp-1Dh]
  _DWORD *all_created_runtime; // [sp+10B8h] [bp-1Ch]
  unsigned __int8 v28; // [sp+10BFh] [bp-15h]
  bool v29; // [sp+10C0h] [bp-14h]
  bool v30; // [sp+10C1h] [bp-13h]
  char v31; // [sp+10C2h] [bp-12h]
  unsigned __int8 v32; // [sp+10C3h] [bp-11h]
  int i; // [sp+10C4h] [bp-10h]

  v7 = a1;
  v10 = 0;
  if ( byte_1524AC != 1 )
  {
    sub_64C80();
    byte_1524AC = 1;
  }
  pthread_mutex_lock(&stru_1524B0);
  v31 = byte_1524A0 == 0;
  sub_638DC((int)&v4, byte_1524A0 == 0);
  v11 = v4;
  v12 = v5;
  v13 = v6;
  v23 = &v11;
  v22 = 1;
  LODWORD(v1) = 1;
  v30 = (vshld_u64(1u, v1) & v4) != 0;
  if ( v30 )
    set_miner_6060info_status_high_temp_err(1);
  v21 = &v11;
  v20 = 2;
  LODWORD(v1) = 2;
  v29 = (vshld_u64(1u, v1) & v11) != 0;
  if ( v29 )
    set_miner_6060info_status_low_temp_err(1);
  v28 = sub_64390(v31);
  v9 = 0;
  all_created_runtime = get_all_created_runtime(&v9);
  for ( i = 0; i < v9; ++i )
    v31 = (unsigned __int8)(v31 & *(_BYTE *)(all_created_runtime[i] + 258)) != 0;
  v26 = sub_64568(v31);
  v25 = sub_64668(v31, &v10);
  v17 = &v11;
  v16 = 3;
  LODWORD(v1) = 3;
  v24 = (vshld_u64(1u, v1) & v11) != 0;
  v19 = &v11;
  v18 = 4;
  LODWORD(v1) = 4;
  if ( (vshld_u64(1u, v1) & v11) != 0 )
  {
    v32 = 1;
    set_miner_6060info_uneffective_temp_err(1);
  }
  else
  {
    v32 = 0;
  }
  if ( byte_1524A0 != 1 && (v30 || v29 || v28 || v24 || v32 || v10) )
  {
    byte_1524A0 = 1;
    all_dev_poweroff();
    V_LOCK();
    sub_63584((int)v14, 1);
    logfmt_raw(
      v8,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "high temp %d low temp %d fan err %d read no temp %d, uneffective temp %d, lost connection too long %d",
      v30,
      v29,
      v28,
      v24,
      v32,
      v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/check_miner_status.c",
      183,
      "task_check_miner_status",
      23,
      317,
      120,
      v8);
  }
  byte_15249F = v30 || v29 || v24 || v32 || v28 || v26 || v25 || byte_1524A0;
  if ( v31 )
  {
    byte_152498 = v30;
    byte_152499 = v29;
    byte_15249C = v28;
    v2 = v26 || byte_1524A0;
    byte_15249D = v2;
    byte_15249E = v25;
    byte_15249A = v24;
    byte_15249B = v32;
  }
  pthread_mutex_unlock(&stru_1524B0);
  sub_64BD0(byte_15249F);
  if ( v30 || v24 || v32 || v10 )
    return fan_pwm_set_max();
  else
    return set_pwm_by_temp();
}
// 653C0: masking with 0x1 was optimized away because r3.1 <= 0x1
// 64F3C: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152498: using guessed type char byte_152498;
// 152499: using guessed type char byte_152499;
// 15249A: using guessed type char byte_15249A;
// 15249B: using guessed type char byte_15249B;
// 15249C: using guessed type char byte_15249C;
// 15249D: using guessed type char byte_15249D;
// 15249E: using guessed type char byte_15249E;
// 15249F: using guessed type char byte_15249F;
// 1524A0: using guessed type char byte_1524A0;
// 1524AC: using guessed type char byte_1524AC;
// 1524B0: using guessed type pthread_mutex_t stru_1524B0;
// 1608F0: using guessed type int g_zc;

//----- (0006545C) --------------------------------------------------------
void __fastcall sub_6545C(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (000654C4) --------------------------------------------------------
int sub_654C4()
{
  int j; // [sp+0h] [bp-Ch]
  int i; // [sp+4h] [bp-8h]

  if ( byte_15251D )
    return -1;
  for ( i = 0; i <= 7; ++i )
    *(_QWORD *)&byte_152520[16 * i + 56] = 2592000;
  for ( j = 0; j <= 15; ++j )
  {
    *(_QWORD *)&byte_152520[16 * j + 696] = 2592000;
    *(_QWORD *)&byte_152520[16 * j + 184] = 600;
    *(_QWORD *)&byte_152520[16 * j + 440] = 600;
  }
  *(_QWORD *)&dbl_1528F8 = 2592000;
  *(_QWORD *)&dbl_152528 = 2592000;
  *(_QWORD *)&dbl_152538 = 2592000;
  *(_QWORD *)&dbl_1528E8 = 2592000;
  *(_QWORD *)&dbl_1528D8 = 2592000;
  *(_QWORD *)&dbl_152548 = 2592000;
  byte_15251D = 1;
  return 0;
}
// 15251D: using guessed type char byte_15251D;
// 152528: using guessed type double dbl_152528;
// 152538: using guessed type double dbl_152538;
// 152548: using guessed type double dbl_152548;
// 1528D8: using guessed type double dbl_1528D8;
// 1528E8: using guessed type double dbl_1528E8;
// 1528F8: using guessed type double dbl_1528F8;

//----- (0006568C) --------------------------------------------------------
char *get_miner_6060info_status()
{
  return byte_152520;
}

//----- (000656AC) --------------------------------------------------------
int __fastcall set_miner_6060info_status_fan_err(int a1, char a2)
{
  double v2; // d0
  __int64 v3; // r2
  int v6; // [sp+14h] [bp-1098h]
  char v7[20]; // [sp+18h] [bp-1094h] BYREF
  char v8[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v9; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  v6 = a1;
  if ( a1 > 7 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "check_fan_index_valid failed, fan_index >= FAN_MAX");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
      179,
      "set_miner_6060info_status_fan_err",
      33,
      92,
      40,
      v8);
    v6 = 0;
  }
  pthread_mutex_lock(&miner_6060info_lock);
  byte_152520[16 * v6 + 48] = a2;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_152520[16 * v6 + 48] )
  {
    difftime(tv.tv_sec, *(_DWORD *)&byte_152520[16 * v6 + 52]);
    v3 = (__int64)v2 - *(_QWORD *)&byte_152520[16 * v6 + 56];
    if ( HIDWORD(v3) - ((unsigned int)(__int64)v2 == *(_DWORD *)&byte_152520[16 * v6 + 56]) < 0 == __OFSUB__(
                                                                                                     HIDWORD(v3),
                                                                                                     0,
                                                                                                     (unsigned int)(__int64)v2 != *(_DWORD *)&byte_152520[16 * v6 + 56]) )
    {
      snprintf(v7, 0x80u, "F%d:1", v6);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "Sweep error string = %s", v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_status_fan_err",
        33,
        95,
        100,
        v8);
    }
  }
  v9.tv_sec = 0;
  v9.tv_usec = 0;
  if ( byte_152520[16 * v6 + 48] )
  {
    gettimeofday(&v9, 0);
    *(_DWORD *)&byte_152520[16 * v6 + 52] = v9.tv_sec;
  }
  else
  {
    *(_DWORD *)&byte_152520[16 * v6 + 52] = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 6582C: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 1608F0: using guessed type int g_zc;

//----- (000659C8) --------------------------------------------------------
int __fastcall set_miner_6060info_status_high_temp_err(char a1)
{
  double v1; // d0
  int v4[5]; // [sp+18h] [bp-1094h] BYREF
  char v5[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v6; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  pthread_mutex_lock(&miner_6060info_lock);
  byte_152520[0] = a1;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_152520[0] )
  {
    difftime(tv.tv_sec, dword_152524);
    if ( (int)(((unsigned __int64)((__int64)v1 - *(_QWORD *)&dbl_152528) >> 32)
             - ((unsigned int)(__int64)v1 == LODWORD(dbl_152528))) < 0 == __OFSUB__(
                                                                            (unsigned __int64)((__int64)v1
                                                                                             - *(_QWORD *)&dbl_152528) >> 32,
                                                                            0,
                                                                            (unsigned int)(__int64)v1 != LODWORD(dbl_152528)) )
    {
      v4[0] = 3226192;
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "Sweep error string = %s", v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_status_high_temp_err",
        39,
        103,
        100,
        v5);
    }
  }
  v6.tv_sec = 0;
  v6.tv_usec = 0;
  if ( byte_152520[0] )
  {
    gettimeofday(&v6, 0);
    dword_152524 = v6.tv_sec;
  }
  else
  {
    dword_152524 = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 65A6C: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 152524: using guessed type int dword_152524;
// 152528: using guessed type double dbl_152528;
// 1608F0: using guessed type int g_zc;

//----- (00065BA0) --------------------------------------------------------
int __fastcall set_miner_6060info_uneffective_temp_err(char a1)
{
  double v1; // d0
  int v4[5]; // [sp+18h] [bp-1094h] BYREF
  char v5[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v6; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  pthread_mutex_lock(&miner_6060info_lock);
  byte_152540 = a1;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_152540 )
  {
    difftime(tv.tv_sec, dword_152544);
    if ( (int)(((unsigned __int64)((__int64)v1 - *(_QWORD *)&dbl_152548) >> 32)
             - ((unsigned int)(__int64)v1 == LODWORD(dbl_152548))) < 0 == __OFSUB__(
                                                                            (unsigned __int64)((__int64)v1
                                                                                             - *(_QWORD *)&dbl_152548) >> 32,
                                                                            0,
                                                                            (unsigned int)(__int64)v1 != LODWORD(dbl_152548)) )
    {
      v4[0] = 3553866;
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "Sweep error string = %s", v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_uneffective_temp_err",
        39,
        111,
        100,
        v5);
    }
  }
  v6.tv_sec = 0;
  v6.tv_usec = 0;
  if ( byte_152540 )
  {
    gettimeofday(&v6, 0);
    dword_152544 = v6.tv_sec;
  }
  else
  {
    dword_152544 = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 65C44: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 152540: using guessed type char byte_152540;
// 152544: using guessed type int dword_152544;
// 152548: using guessed type double dbl_152548;
// 1608F0: using guessed type int g_zc;

//----- (00065D78) --------------------------------------------------------
int __fastcall set_miner_6060info_status_low_temp_err(char a1)
{
  double v1; // d0
  int v4[5]; // [sp+18h] [bp-1094h] BYREF
  char v5[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v6; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  pthread_mutex_lock(&miner_6060info_lock);
  byte_152530 = a1;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_152530 )
  {
    difftime(tv.tv_sec, dword_152534);
    if ( (int)(((unsigned __int64)((__int64)v1 - *(_QWORD *)&dbl_152538) >> 32)
             - ((unsigned int)(__int64)v1 == LODWORD(dbl_152538))) < 0 == __OFSUB__(
                                                                            (unsigned __int64)((__int64)v1
                                                                                             - *(_QWORD *)&dbl_152538) >> 32,
                                                                            0,
                                                                            (unsigned int)(__int64)v1 != LODWORD(dbl_152538)) )
    {
      v4[0] = 3291728;
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "Sweep error string = %s", v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_status_low_temp_err",
        38,
        119,
        100,
        v5);
    }
  }
  v6.tv_sec = 0;
  v6.tv_usec = 0;
  if ( byte_152530 )
  {
    gettimeofday(&v6, 0);
    dword_152534 = v6.tv_sec;
  }
  else
  {
    dword_152534 = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 65E1C: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 152530: using guessed type char byte_152530;
// 152534: using guessed type int dword_152534;
// 152538: using guessed type double dbl_152538;
// 1608F0: using guessed type int g_zc;

//----- (00065F50) --------------------------------------------------------
int __fastcall set_miner_6060info_low_hashrate_err(int a1, char a2)
{
  double v2; // d0
  __int64 v3; // r2
  int v6; // [sp+14h] [bp-1098h]
  char v7[20]; // [sp+18h] [bp-1094h] BYREF
  char v8[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v9; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  v6 = a1;
  if ( a1 > 15 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "check_chain_index_valid failed, chain_index >= PLATFORM_MAX_CHAIN_NUM");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
      179,
      "set_miner_6060info_low_hashrate_err",
      35,
      124,
      40,
      v8);
    v6 = 0;
  }
  pthread_mutex_lock(&miner_6060info_lock);
  byte_152520[16 * v6 + 176] = a2;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_152520[16 * v6 + 176] )
  {
    difftime(tv.tv_sec, *(_DWORD *)&byte_152520[16 * v6 + 180]);
    v3 = (__int64)v2 - *(_QWORD *)&byte_152520[16 * v6 + 184];
    if ( HIDWORD(v3) - ((unsigned int)(__int64)v2 == *(_DWORD *)&byte_152520[16 * v6 + 184]) < 0 == __OFSUB__(HIDWORD(v3), 0, (unsigned int)(__int64)v2 != *(_DWORD *)&byte_152520[16 * v6 + 184]) )
    {
      snprintf(v7, 0x80u, "R%d:1", v6);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "Sweep error string = %s", v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_low_hashrate_err",
        35,
        127,
        100,
        v8);
    }
  }
  v9.tv_sec = 0;
  v9.tv_usec = 0;
  if ( byte_152520[16 * v6 + 176] )
  {
    gettimeofday(&v9, 0);
    *(_DWORD *)&byte_152520[16 * v6 + 180] = v9.tv_sec;
  }
  else
  {
    *(_DWORD *)&byte_152520[16 * v6 + 180] = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 660D0: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 1608F0: using guessed type int g_zc;

//----- (0006626C) --------------------------------------------------------
int __fastcall set_miner_6060info_runtime_bad_asic_err(int a1, char a2)
{
  double v2; // d0
  __int64 v3; // r2
  int v6; // [sp+14h] [bp-1098h]
  char v7[20]; // [sp+18h] [bp-1094h] BYREF
  char v8[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v9; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  v6 = a1;
  if ( a1 > 15 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "check_chain_index_valid failed, chain_index >= PLATFORM_MAX_CHAIN_NUM");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
      179,
      "set_miner_6060info_runtime_bad_asic_err",
      39,
      133,
      40,
      v8);
    v6 = 0;
  }
  pthread_mutex_lock(&miner_6060info_lock);
  byte_152520[16 * v6 + 432] = a2;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_152520[16 * v6 + 432] )
  {
    difftime(tv.tv_sec, *(_DWORD *)&byte_152520[16 * v6 + 436]);
    v3 = (__int64)v2 - *(_QWORD *)&byte_152520[16 * v6 + 440];
    if ( HIDWORD(v3) - ((unsigned int)(__int64)v2 == *(_DWORD *)&byte_152520[16 * v6 + 440]) < 0 == __OFSUB__(HIDWORD(v3), 0, (unsigned int)(__int64)v2 != *(_DWORD *)&byte_152520[16 * v6 + 440]) )
    {
      snprintf(v7, 0x80u, "J%d:1", v6);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "Sweep error string = %s", v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_runtime_bad_asic_err",
        39,
        136,
        100,
        v8);
    }
  }
  v9.tv_sec = 0;
  v9.tv_usec = 0;
  if ( byte_152520[16 * v6 + 432] )
  {
    gettimeofday(&v9, 0);
    *(_DWORD *)&byte_152520[16 * v6 + 436] = v9.tv_sec;
  }
  else
  {
    *(_DWORD *)&byte_152520[16 * v6 + 436] = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 663EC: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 1608F0: using guessed type int g_zc;

//----- (00066588) --------------------------------------------------------
int __fastcall set_miner_6060info_network_lost_err(char a1)
{
  double v1; // d0
  int v4[5]; // [sp+18h] [bp-1094h] BYREF
  char v5[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v6; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  pthread_mutex_lock(&miner_6060info_lock);
  byte_1528D0 = a1;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_1528D0 )
  {
    difftime(tv.tv_sec, dword_1528D4);
    if ( (int)(((unsigned __int64)((__int64)v1 - *(_QWORD *)&dbl_1528D8) >> 32)
             - ((unsigned int)(__int64)v1 == LODWORD(dbl_1528D8))) < 0 == __OFSUB__(
                                                                            (unsigned __int64)((__int64)v1
                                                                                             - *(_QWORD *)&dbl_1528D8) >> 32,
                                                                            0,
                                                                            (unsigned int)(__int64)v1 != LODWORD(dbl_1528D8)) )
    {
      v4[0] = 3422798;
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "Sweep error string = %s", v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_network_lost_err",
        35,
        144,
        100,
        v5);
    }
  }
  v6.tv_sec = 0;
  v6.tv_usec = 0;
  if ( byte_1528D0 )
  {
    gettimeofday(&v6, 0);
    dword_1528D4 = v6.tv_sec;
  }
  else
  {
    dword_1528D4 = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 6662C: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 1528D0: using guessed type char byte_1528D0;
// 1528D4: using guessed type int dword_1528D4;
// 1528D8: using guessed type double dbl_1528D8;
// 1608F0: using guessed type int g_zc;

//----- (00066760) --------------------------------------------------------
int __fastcall set_miner_6060info_asic_num_less_than_design_err(int a1, char a2)
{
  double v2; // d0
  __int64 v3; // r2
  int v6; // [sp+14h] [bp-1098h]
  char v7[20]; // [sp+18h] [bp-1094h] BYREF
  char v8[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v9; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  v6 = a1;
  if ( a1 > 15 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "check_chain_index_valid failed, chain_index >= PLATFORM_MAX_CHAIN_NUM");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
      179,
      "set_miner_6060info_asic_num_less_than_design_err",
      48,
      150,
      40,
      v8);
    v6 = 0;
  }
  pthread_mutex_lock(&miner_6060info_lock);
  byte_152520[16 * v6 + 688] = a2;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_152520[16 * v6 + 688] )
  {
    difftime(tv.tv_sec, *(_DWORD *)&byte_152520[16 * v6 + 692]);
    v3 = (__int64)v2 - *(_QWORD *)&byte_152520[16 * v6 + 696];
    if ( HIDWORD(v3) - ((unsigned int)(__int64)v2 == *(_DWORD *)&byte_152520[16 * v6 + 696]) < 0 == __OFSUB__(HIDWORD(v3), 0, (unsigned int)(__int64)v2 != *(_DWORD *)&byte_152520[16 * v6 + 696]) )
    {
      snprintf(v7, 0x80u, "J%d:2", v6);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "Sweep error string = %s", v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_asic_num_less_than_design_err",
        48,
        153,
        100,
        v8);
    }
  }
  v9.tv_sec = 0;
  v9.tv_usec = 0;
  if ( byte_152520[16 * v6 + 688] )
  {
    gettimeofday(&v9, 0);
    *(_DWORD *)&byte_152520[16 * v6 + 692] = v9.tv_sec;
  }
  else
  {
    *(_DWORD *)&byte_152520[16 * v6 + 692] = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 668E0: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 1608F0: using guessed type int g_zc;

//----- (00066A7C) --------------------------------------------------------
int __fastcall set_miner_6060info_malloc_failed_err(char a1)
{
  double v1; // d0
  int v4[5]; // [sp+18h] [bp-1094h] BYREF
  char v5[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v6; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  pthread_mutex_lock(&miner_6060info_lock);
  byte_1528E0 = a1;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_1528E0 )
  {
    difftime(tv.tv_sec, dword_1528E4);
    if ( (int)(((unsigned __int64)((__int64)v1 - *(_QWORD *)&dbl_1528E8) >> 32)
             - ((unsigned int)(__int64)v1 == LODWORD(dbl_1528E8))) < 0 == __OFSUB__(
                                                                            (unsigned __int64)((__int64)v1
                                                                                             - *(_QWORD *)&dbl_1528E8) >> 32,
                                                                            0,
                                                                            (unsigned int)(__int64)v1 != LODWORD(dbl_1528E8)) )
    {
      v4[0] = 3226189;
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "Sweep error string = %s", v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_malloc_failed_err",
        36,
        161,
        100,
        v5);
    }
  }
  v6.tv_sec = 0;
  v6.tv_usec = 0;
  if ( byte_1528E0 )
  {
    gettimeofday(&v6, 0);
    dword_1528E4 = v6.tv_sec;
  }
  else
  {
    dword_1528E4 = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 66B20: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 1528E0: using guessed type char byte_1528E0;
// 1528E4: using guessed type int dword_1528E4;
// 1528E8: using guessed type double dbl_1528E8;
// 1608F0: using guessed type int g_zc;

//----- (00066C54) --------------------------------------------------------
int __fastcall set_miner_6060info_board_num_less_than_design_err(char a1)
{
  double v1; // d0
  int v4[5]; // [sp+18h] [bp-1094h] BYREF
  char v5[20]; // [sp+98h] [bp-1014h] BYREF
  struct timeval v6; // [sp+1098h] [bp-14h] BYREF
  struct timeval tv; // [sp+10A0h] [bp-Ch] BYREF

  pthread_mutex_lock(&miner_6060info_lock);
  byte_1528F0 = a1;
  sub_654C4();
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_1528F0 )
  {
    difftime(tv.tv_sec, dword_1528F4);
    if ( (int)(((unsigned __int64)((__int64)v1 - *(_QWORD *)&dbl_1528F8) >> 32)
             - ((unsigned int)(__int64)v1 == LODWORD(dbl_1528F8))) < 0 == __OFSUB__(
                                                                            (unsigned __int64)((__int64)v1
                                                                                             - *(_QWORD *)&dbl_1528F8) >> 32,
                                                                            0,
                                                                            (unsigned int)(__int64)v1 != LODWORD(dbl_1528F8)) )
    {
      v4[0] = 3684938;
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "Sweep error string = %s", v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "set_miner_6060info_board_num_less_than_design_err",
        49,
        169,
        100,
        v5);
    }
  }
  v6.tv_sec = 0;
  v6.tv_usec = 0;
  if ( byte_1528F0 )
  {
    gettimeofday(&v6, 0);
    dword_1528F4 = v6.tv_sec;
  }
  else
  {
    dword_1528F4 = 0;
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 66CF8: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 1528F0: using guessed type char byte_1528F0;
// 1528F4: using guessed type int dword_1528F4;
// 1528F8: using guessed type double dbl_1528F8;
// 1608F0: using guessed type int g_zc;

//----- (00066E2C) --------------------------------------------------------
int reset_miner_6060info_status()
{
  pthread_mutex_lock(&miner_6060info_lock);
  memset(byte_152520, 0, 0x3E0u);
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;

//----- (00066E68) --------------------------------------------------------
int miner_6060info_errorcode_init()
{
  char v2[64]; // [sp+14h] [bp-1100h] BYREF
  _BYTE v3[252]; // [sp+1014h] [bp-100h] BYREF

  pthread_mutex_lock(&stru_152504);
  if ( byte_15251C || access(off_14F610[0], 0) )
  {
    pthread_mutex_unlock(&stru_152504);
    return 0;
  }
  else
  {
    dword_152500 = (int)json_load_file(off_14F610[0], 0, (json_error_t *)v3);
    if ( dword_152500 && !*(_DWORD *)dword_152500 )
    {
      byte_15251C = 1;
      pthread_mutex_unlock(&stru_152504);
      return 1;
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v2,
        0x1000u,
        0,
        "%s, %d bad json format",
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        198);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "miner_6060info_errorcode_init",
        29,
        198,
        100,
        v2);
      pthread_mutex_unlock(&stru_152504);
      return 0;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14F610: using guessed type char *off_14F610[19];
// 152500: using guessed type int dword_152500;
// 152504: using guessed type pthread_mutex_t stru_152504;
// 15251C: using guessed type char byte_15251C;
// 1608F0: using guessed type int g_zc;

//----- (00067004) --------------------------------------------------------
int miner_6060info_errorcode_uninit()
{
  pthread_mutex_lock(&stru_152504);
  if ( byte_15251C == 1 )
  {
    byte_15251C = 0;
    usleep(0x3E8u);
    sub_6545C(dword_152500);
  }
  return pthread_mutex_unlock(&stru_152504);
}
// 152500: using guessed type int dword_152500;
// 152504: using guessed type pthread_mutex_t stru_152504;
// 15251C: using guessed type char byte_15251C;

//----- (00067080) --------------------------------------------------------
int __fastcall get_errstr_from_json_by_errorcode(const char *a1, char *a2, size_t a3)
{
  size_t v4; // r0
  char v9[44]; // [sp+20h] [bp-102Ch] BYREF
  const char *v10; // [sp+1020h] [bp-2Ch]
  const json_t *v11; // [sp+1024h] [bp-28h]
  const char *v12; // [sp+1028h] [bp-24h]
  const json_t *v13; // [sp+102Ch] [bp-20h]
  char *s2; // [sp+1030h] [bp-1Ch]
  const json_t *v15; // [sp+1034h] [bp-18h]
  char v16; // [sp+103Bh] [bp-11h]
  size_t i; // [sp+103Ch] [bp-10h]
  const json_t *v18; // [sp+1040h] [bp-Ch]
  const json_t *v19; // [sp+1044h] [bp-8h]

  v19 = 0;
  v18 = 0;
  if ( byte_15251C != 1 && (unsigned __int8)miner_6060info_errorcode_init() != 1 )
    return 0;
  v19 = json_object_get((const json_t *)dword_152500, "errorcode");
  if ( !v19 || *(_DWORD *)v19 != 1 )
  {
    V_LOCK();
    logfmt_raw(
      v9,
      0x1000u,
      0,
      "%s, %d bad errorcode format",
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
      234);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
      179,
      "get_errstr_from_json_by_errorcode",
      33,
      234,
      100,
      v9);
  }
  v16 = 0;
  for ( i = 0; ; ++i )
  {
    v4 = json_array_size(v19);
    if ( i >= v4 )
      break;
    v18 = json_array_get(v19, i);
    if ( !v18 || *(_DWORD *)v18 )
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "%s, %d bad object in errorcode",
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        243);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "get_errstr_from_json_by_errorcode",
        33,
        243,
        100,
        v9);
      return 0;
    }
    v15 = json_object_get(v18, "code");
    s2 = (char *)json_string_value(v15);
    if ( !strcmp(a1, s2) )
    {
      v13 = json_object_get(v18, "reason");
      v12 = json_string_value(v13);
      v11 = json_object_get(v18, "suggestion");
      v10 = json_string_value(v11);
      snprintf(a2, a3, "%s; %s; %s", s2, v12, v10);
      v16 = 1;
      break;
    }
  }
  if ( v16 == 1 )
    return 1;
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "error code %s does not exist in the file", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
    179,
    "get_errstr_from_json_by_errorcode",
    33,
    262,
    100,
    v9);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152500: using guessed type int dword_152500;
// 15251C: using guessed type char byte_15251C;
// 1608F0: using guessed type int g_zc;

//----- (00067430) --------------------------------------------------------
int __fastcall get_reason_suggestion_from_json_by_errorcode(const char *a1, char *a2, char *a3, size_t a4)
{
  size_t v5; // r0
  char v11[44]; // [sp+20h] [bp-102Ch] BYREF
  char *v12; // [sp+1020h] [bp-2Ch]
  const json_t *v13; // [sp+1024h] [bp-28h]
  char *format; // [sp+1028h] [bp-24h]
  const json_t *v15; // [sp+102Ch] [bp-20h]
  char *s2; // [sp+1030h] [bp-1Ch]
  const json_t *v17; // [sp+1034h] [bp-18h]
  char v18; // [sp+103Bh] [bp-11h]
  size_t i; // [sp+103Ch] [bp-10h]
  const json_t *v20; // [sp+1040h] [bp-Ch]
  const json_t *v21; // [sp+1044h] [bp-8h]

  v21 = 0;
  v20 = 0;
  if ( byte_15251C != 1 && (unsigned __int8)miner_6060info_errorcode_init() != 1 )
    return 0;
  v21 = json_object_get((const json_t *)dword_152500, "errorcode");
  if ( !v21 || *(_DWORD *)v21 != 1 )
  {
    V_LOCK();
    logfmt_raw(
      v11,
      0x1000u,
      0,
      "%s, %d bad errorcode format",
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
      281);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
      179,
      "get_reason_suggestion_from_json_by_errorcode",
      44,
      281,
      100,
      v11);
  }
  v18 = 0;
  for ( i = 0; ; ++i )
  {
    v5 = json_array_size(v21);
    if ( i >= v5 )
      break;
    v20 = json_array_get(v21, i);
    if ( !v20 || *(_DWORD *)v20 )
    {
      V_LOCK();
      logfmt_raw(
        v11,
        0x1000u,
        0,
        "%s, %d bad object in errorcode",
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        290);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
        179,
        "get_reason_suggestion_from_json_by_errorcode",
        44,
        290,
        100,
        v11);
      return 0;
    }
    v17 = json_object_get(v20, "code");
    s2 = (char *)json_string_value(v17);
    if ( !strcmp(a1, s2) )
    {
      v15 = json_object_get(v20, "reason");
      format = (char *)json_string_value(v15);
      snprintf(a2, a4, format);
      v13 = json_object_get(v20, "suggestion");
      v12 = (char *)json_string_value(v13);
      snprintf(a3, a4, v12);
      v18 = 1;
      break;
    }
  }
  if ( v18 == 1 )
    return 1;
  V_LOCK();
  logfmt_raw(v11, 0x1000u, 0, "error code %s does not exist in the file", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/miner_monitor/miner_6060info.c",
    179,
    "get_reason_suggestion_from_json_by_errorcode",
    44,
    311,
    100,
    v11);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 152500: using guessed type int dword_152500;
// 15251C: using guessed type char byte_15251C;
// 1608F0: using guessed type int g_zc;

//----- (000677F0) --------------------------------------------------------
int __fastcall set_json_info_by_errorcode_and_time(json_t *a1, const char *a2, time_t a3)
{
  int result; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v6; // r0
  json_t *v7; // r0
  time_t timer; // [sp+1Ch] [bp-348h] BYREF
  const char *v9; // [sp+20h] [bp-344h]
  json_t *v10; // [sp+24h] [bp-340h]
  struct tm tp; // [sp+28h] [bp-33Ch] BYREF
  char s[256]; // [sp+54h] [bp-310h] BYREF
  char v13[256]; // [sp+154h] [bp-210h] BYREF
  char v14[256]; // [sp+254h] [bp-110h] BYREF
  json_t *v15; // [sp+354h] [bp-10h]

  v10 = a1;
  v9 = a2;
  timer = a3;
  v15 = 0;
  if ( byte_15251C == 1 || (result = miner_6060info_errorcode_init(), (unsigned __int8)result == 1) )
  {
    result = get_reason_suggestion_from_json_by_errorcode(v9, v14, v13, 0x100u);
    if ( result )
    {
      v15 = (json_t *)json_object();
      v4 = (json_t *)json_string(v9);
      json_object_set_new(v15, "code", v4);
      v5 = (json_t *)json_string(v14);
      json_object_set_new(v15, "cause", v5);
      v6 = (json_t *)json_string(v13);
      json_object_set_new(v15, "suggestion", v6);
      localtime_r(&timer, &tp);
      snprintf(
        s,
        0x100u,
        "%d%02d%02d%02d%02d%02d",
        tp.tm_year + 1900,
        tp.tm_mon + 1,
        tp.tm_mday,
        tp.tm_hour,
        tp.tm_min,
        tp.tm_sec);
      v7 = (json_t *)json_string(s);
      json_object_set_new(v15, "timestamp", v7);
      return json_array_append_new(v10, v15);
    }
  }
  return result;
}
// 15251C: using guessed type char byte_15251C;

//----- (00067978) --------------------------------------------------------
int __fastcall sweep_get_error_code(json_t *a1)
{
  char s[128]; // [sp+Ch] [bp-1E8h] BYREF
  struct timeval v4; // [sp+8Ch] [bp-168h] BYREF
  struct timeval v5; // [sp+94h] [bp-160h] BYREF
  struct timeval v6; // [sp+9Ch] [bp-158h] BYREF
  struct timeval v7; // [sp+A4h] [bp-150h] BYREF
  struct timeval v8; // [sp+ACh] [bp-148h] BYREF
  struct timeval v9; // [sp+B4h] [bp-140h] BYREF
  struct timeval v10; // [sp+BCh] [bp-138h] BYREF
  struct timeval v11; // [sp+C4h] [bp-130h] BYREF
  struct timeval v12; // [sp+CCh] [bp-128h] BYREF
  struct timeval tv; // [sp+D4h] [bp-120h] BYREF
  int v14; // [sp+1DCh] [bp-18h]
  int m; // [sp+1E0h] [bp-14h]
  int k; // [sp+1E4h] [bp-10h]
  int j; // [sp+1E8h] [bp-Ch]
  int i; // [sp+1ECh] [bp-8h]

  v14 = 0;
  sub_654C4();
  miner_6060info_errorcode_init();
  pthread_mutex_lock(&miner_6060info_lock);
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  if ( byte_152520[0] )
  {
    strcpy(s, "P:1");
    set_json_info_by_errorcode_and_time(a1, s, dword_152524);
  }
  v12.tv_sec = 0;
  v12.tv_usec = 0;
  gettimeofday(&v12, 0);
  if ( byte_152530 )
  {
    strcpy(s, "P:2");
    set_json_info_by_errorcode_and_time(a1, s, dword_152534);
  }
  v11.tv_sec = 0;
  v11.tv_usec = 0;
  gettimeofday(&v11, 0);
  if ( byte_152540 )
  {
    strcpy(s, "J:6");
    set_json_info_by_errorcode_and_time(a1, s, dword_152544);
  }
  for ( i = 0; i <= 7; ++i )
  {
    v10.tv_sec = 0;
    v10.tv_usec = 0;
    gettimeofday(&v10, 0);
    if ( byte_152520[16 * i + 48] )
    {
      snprintf(s, 0x80u, "F%d:1", i);
      set_json_info_by_errorcode_and_time(a1, s, *(_DWORD *)&byte_152520[16 * i + 52]);
    }
  }
  for ( j = 0; j <= 15; ++j )
  {
    v9.tv_sec = 0;
    v9.tv_usec = 0;
    gettimeofday(&v9, 0);
    if ( byte_152520[16 * j + 176] )
    {
      snprintf(s, 0x80u, "R%d:1", j);
      set_json_info_by_errorcode_and_time(a1, s, *(_DWORD *)&byte_152520[16 * j + 180]);
    }
  }
  for ( k = 0; k <= 15; ++k )
  {
    v8.tv_sec = 0;
    v8.tv_usec = 0;
    gettimeofday(&v8, 0);
    if ( byte_152520[16 * k + 432] )
    {
      snprintf(s, 0x80u, "J%d:1", k);
      set_json_info_by_errorcode_and_time(a1, s, *(_DWORD *)&byte_152520[16 * k + 436]);
    }
  }
  for ( m = 0; m <= 15; ++m )
  {
    v7.tv_sec = 0;
    v7.tv_usec = 0;
    gettimeofday(&v7, 0);
    if ( byte_152520[16 * m + 688] )
    {
      snprintf(s, 0x80u, "J%d:2", m);
      set_json_info_by_errorcode_and_time(a1, s, *(_DWORD *)&byte_152520[16 * m + 692]);
    }
  }
  v6.tv_sec = 0;
  v6.tv_usec = 0;
  gettimeofday(&v6, 0);
  if ( byte_1528D0 )
  {
    strcpy(s, "N:4");
    set_json_info_by_errorcode_and_time(a1, s, dword_1528D4);
  }
  v5.tv_sec = 0;
  v5.tv_usec = 0;
  gettimeofday(&v5, 0);
  if ( byte_1528E0 )
  {
    strcpy(s, "M:1");
    set_json_info_by_errorcode_and_time(a1, s, dword_1528E4);
  }
  v4.tv_sec = 0;
  v4.tv_usec = 0;
  gettimeofday(&v4, 0);
  if ( byte_1528F0 )
  {
    strcpy(s, "J:8");
    set_json_info_by_errorcode_and_time(a1, s, dword_1528F4);
  }
  return pthread_mutex_unlock(&miner_6060info_lock);
}
// 1524E8: using guessed type pthread_mutex_t miner_6060info_lock;
// 152524: using guessed type int dword_152524;
// 152530: using guessed type char byte_152530;
// 152534: using guessed type int dword_152534;
// 152540: using guessed type char byte_152540;
// 152544: using guessed type int dword_152544;
// 1528D0: using guessed type char byte_1528D0;
// 1528D4: using guessed type int dword_1528D4;
// 1528E0: using guessed type char byte_1528E0;
// 1528E4: using guessed type int dword_1528E4;
// 1528F0: using guessed type char byte_1528F0;
// 1528F4: using guessed type int dword_1528F4;

//----- (00067E90) --------------------------------------------------------
int __fastcall sub_67E90(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 67EFC: variable 'v3' is possibly undefined

//----- (00067FA8) --------------------------------------------------------
int __fastcall sub_67FA8(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0006801C) --------------------------------------------------------
int __fastcall sub_6801C(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00068140) --------------------------------------------------------
_BYTE *__fastcall sub_68140(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (000681AC) --------------------------------------------------------
int sub_681AC()
{
  __int64 v0; // r0
  int v2; // [sp+8h] [bp-24h] BYREF
  _QWORD *v3; // [sp+Ch] [bp-20h]
  int v4; // [sp+10h] [bp-1Ch]
  _QWORD *v5; // [sp+14h] [bp-18h]
  int v6; // [sp+18h] [bp-14h]
  int i; // [sp+1Ch] [bp-10h]

  v2 = 0;
  LODWORD(v0) = get_all_created_runtime(&v2);
  v6 = v0;
  for ( i = 0; i < v2; ++i )
  {
    LODWORD(v0) = update_temperature(
                    *(_DWORD *)(v6 + 4 * i),
                    &dword_152900[56 * *(_DWORD *)(*(_DWORD *)(v6 + 4 * i) + 248)],
                    (int)&unk_153700 + 80 * *(_DWORD *)(*(_DWORD *)(v6 + 4 * i) + 248));
    v5 = (_QWORD *)v0;
    v4 = v0;
    if ( *(_QWORD *)v0 )
    {
      subject_notify_all(dword_153C08, *(_DWORD *)(v6 + 4 * i));
      v3 = v5;
      v0 = *v5;
      *v5 &= ~v5[1];
      v3[1] = 0;
    }
  }
  return v0;
}
// 152900: using guessed type _DWORD dword_152900[896];
// 153C08: using guessed type int dword_153C08;

//----- (00068310) --------------------------------------------------------
int sub_68310()
{
  __int64 v0; // r0
  int v2; // [sp+8h] [bp-24h] BYREF
  _QWORD *v3; // [sp+Ch] [bp-20h]
  int v4; // [sp+10h] [bp-1Ch]
  _QWORD *v5; // [sp+14h] [bp-18h]
  int v6; // [sp+18h] [bp-14h]
  int i; // [sp+1Ch] [bp-10h]

  v2 = 0;
  LODWORD(v0) = get_all_created_runtime(&v2);
  v6 = v0;
  for ( i = 0; i < v2; ++i )
  {
    LODWORD(v0) = update_hashrate(
                    *(_DWORD *)(v6 + 4 * i),
                    (int)&dword_152900[56 * *(_DWORD *)(*(_DWORD *)(v6 + 4 * i) + 248)],
                    &qword_153700[10 * *(_DWORD *)(*(_DWORD *)(v6 + 4 * i) + 248)]);
    v5 = (_QWORD *)v0;
    v4 = v0;
    if ( *(_QWORD *)v0 )
    {
      subject_notify_all(dword_153C0C, *(_DWORD *)(v6 + 4 * i));
      v3 = v5;
      v0 = *v5;
      *v5 &= ~v5[1];
      v3[1] = 0;
    }
  }
  return v0;
}
// 152900: using guessed type _DWORD dword_152900[896];
// 153700: using guessed type _QWORD qword_153700[160];
// 153C0C: using guessed type int dword_153C0C;

//----- (00068474) --------------------------------------------------------
int sub_68474()
{
  __int64 v0; // r0
  int v2; // [sp+8h] [bp-24h] BYREF
  _QWORD *v3; // [sp+Ch] [bp-20h]
  int v4; // [sp+10h] [bp-1Ch]
  _QWORD *v5; // [sp+14h] [bp-18h]
  int v6; // [sp+18h] [bp-14h]
  int i; // [sp+1Ch] [bp-10h]

  v2 = 0;
  LODWORD(v0) = get_all_created_runtime(&v2);
  v6 = v0;
  for ( i = 0; i < v2; ++i )
  {
    LODWORD(v0) = update_chip_status(
                    *(_DWORD *)(v6 + 4 * i),
                    (unsigned int)&dword_152900[56 * *(_DWORD *)(*(_DWORD *)(v6 + 4 * i) + 248)],
                    (int)&qword_153700[10 * *(_DWORD *)(*(_DWORD *)(v6 + 4 * i) + 248)]);
    v5 = (_QWORD *)v0;
    v4 = v0;
    if ( *(_QWORD *)v0 )
    {
      subject_notify_all(dword_153C10, *(_DWORD *)(v6 + 4 * i));
      v3 = v5;
      v0 = *v5;
      *v5 &= ~v5[1];
      v3[1] = 0;
    }
  }
  return v0;
}
// 152900: using guessed type _DWORD dword_152900[896];
// 153700: using guessed type _QWORD qword_153700[160];
// 153C10: using guessed type int dword_153C10;

//----- (000685D8) --------------------------------------------------------
int sub_685D8()
{
  __int64 v0; // r0
  int v2; // [sp+8h] [bp-24h] BYREF
  _QWORD *v3; // [sp+Ch] [bp-20h]
  int v4; // [sp+10h] [bp-1Ch]
  _QWORD *v5; // [sp+14h] [bp-18h]
  int v6; // [sp+18h] [bp-14h]
  int i; // [sp+1Ch] [bp-10h]

  v2 = 0;
  LODWORD(v0) = get_all_created_runtime(&v2);
  v6 = v0;
  for ( i = 0; i < v2; ++i )
  {
    LODWORD(v0) = update_fanspeed(
                    *(_DWORD *)(v6 + 4 * i),
                    &dword_152900[56 * *(_DWORD *)(*(_DWORD *)(v6 + 4 * i) + 248)],
                    (int)&qword_153700[10 * *(_DWORD *)(*(_DWORD *)(v6 + 4 * i) + 248)]);
    v5 = (_QWORD *)v0;
    v4 = v0;
    if ( *(_QWORD *)v0 )
    {
      subject_notify_all(dword_153C14, *(_DWORD *)(v6 + 4 * i));
      v3 = v5;
      v0 = *v5;
      *v5 &= ~v5[1];
      v3[1] = 0;
    }
  }
  return v0;
}
// 152900: using guessed type _DWORD dword_152900[896];
// 153700: using guessed type _QWORD qword_153700[160];
// 153C14: using guessed type int dword_153C14;

//----- (0006873C) --------------------------------------------------------
__int64 sub_6873C()
{
  __int64 result; // r0
  int (**v1)(); // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  char v10[20]; // [sp+20h] [bp-2194h] BYREF
  char v11[20]; // [sp+1020h] [bp-1194h] BYREF
  char v12[32]; // [sp+1040h] [bp-1174h] BYREF
  char v13[20]; // [sp+1060h] [bp-1154h] BYREF
  _BYTE v14[20]; // [sp+2060h] [bp-154h] BYREF
  int v15; // [sp+2090h] [bp-124h]
  int v16; // [sp+2094h] [bp-120h]
  _BYTE v17[44]; // [sp+2098h] [bp-11Ch] BYREF
  int v18; // [sp+20E0h] [bp-D4h]
  const char *v19; // [sp+20E4h] [bp-D0h]
  __int64 v20; // [sp+20F0h] [bp-C4h]
  int v21; // [sp+217Ch] [bp-38h] BYREF
  int v22; // [sp+2180h] [bp-34h]
  int v23; // [sp+2184h] [bp-30h]
  _DWORD *all_created_runtime; // [sp+2188h] [bp-2Ch]
  int v25; // [sp+218Ch] [bp-28h]
  int n; // [sp+2190h] [bp-24h]
  int m; // [sp+2194h] [bp-20h]
  int k; // [sp+2198h] [bp-1Ch]
  int j; // [sp+219Ch] [bp-18h]
  int i; // [sp+21A0h] [bp-14h]
  int v31; // [sp+21A4h] [bp-10h]

  v21 = 0;
  v25 = frontend_runtime_instance();
  all_created_runtime = get_all_created_runtime(&v21);
  v31 = 0;
  read_system_status_from_monitor((int)v14);
  format_hashrate_string(*(const char **)(*(_DWORD *)(v25 + 72) + 16), v12);
  format_hashrate_string(*(const char **)(*(_DWORD *)(v25 + 72) + 16), v11);
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "total avg hashrate %s 2min avg hashrate %s hw %llu", v12, v11, v15, v16);
  V_UNLOCK();
  result = zlog(
             g_hash_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/miner_util/miner_monitor/miner_monitor.c",
             178,
             "task_applog_printer",
             19,
             125,
             40,
             v10);
  for ( i = 0; i < v21; ++i )
  {
    read_status_from_monitor(v17, all_created_runtime[i]);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v25 + 72) + 16), v12);
    format_hashrate_string(*(const char **)(*(_DWORD *)(v25 + 72) + 16), v11);
    v1 = dev_ctrl();
    v2 = ((int (__fastcall *)(_DWORD))v1[12])(*(_DWORD *)(all_created_runtime[i] + 248));
    v31 = snprintf(
            v13,
            0x1000u,
            "chain %d device %d alive chip count %d avg hashrate %s 30min avg hashrate %s hw %llu\n",
            v2,
            *(_DWORD *)(all_created_runtime[i] + 248),
            v18,
            v12,
            v11,
            v20);
    v3 = snprintf(
           &v13[v31],
           4096 - v31,
           "wc %llu nc %llu chip status str %s detail:\n",
           *(_QWORD *)(all_created_runtime[i] + 440),
           *(_QWORD *)(all_created_runtime[i] + 448),
           v19);
    v31 += v3;
    v23 = *(_DWORD *)(all_created_runtime[i] + 336);
    for ( j = 0; j < v23; ++j )
    {
      v22 = *(_DWORD *)(all_created_runtime[i] + 456) + 48 * j;
      v4 = snprintf(&v13[v31], 4096 - v31, "%d:", j + 1);
      v31 += v4;
      for ( k = 0; k <= 5; ++k )
      {
        v5 = snprintf(&v13[v31], 4096 - v31, " %llu", *(_QWORD *)(v22 + 8 * k));
        v31 += v5;
      }
      v6 = snprintf(&v13[v31], 4096 - v31, " /");
      v31 += v6;
    }
    if ( opt_algo == 13 )
    {
      for ( m = 0; m < v23; ++m )
      {
        v7 = snprintf(&v13[v31], 0x2000 - v31, "\n------%d------", m + 1);
        v31 += v7;
        for ( n = 0; n < *(_DWORD *)(all_created_runtime[i] + 344); ++n )
        {
          if ( (n & 7) == 0 )
          {
            v8 = snprintf(&v13[v31], 0x2000 - v31, "\n");
            v31 += v8;
          }
          v9 = snprintf(
                 &v13[v31],
                 0x2000 - v31,
                 " %d:%d ",
                 n,
                 *(_DWORD *)(*(_DWORD *)(all_created_runtime[i] + 484)
                           + 4 * (m * *(_DWORD *)(all_created_runtime[i] + 344) + n)));
          v31 += v9;
        }
      }
    }
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "%s", v13);
    V_UNLOCK();
    result = zlog(
               g_hash_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/miner_util/miner_monitor/miner_monitor.c",
               178,
               "task_applog_printer",
               19,
               159,
               40,
               v10);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14D664: using guessed type int opt_algo;
// 1608FC: using guessed type int g_hash_zc;

//----- (00068DF8) --------------------------------------------------------
_DWORD *sub_68DF8()
{
  _DWORD *result; // r0
  _BYTE v1[44]; // [sp+8h] [bp-104h] BYREF
  float v2; // [sp+34h] [bp-D8h]
  double v3; // [sp+40h] [bp-CCh]
  int v4; // [sp+E8h] [bp-24h] BYREF
  char v5; // [sp+F0h] [bp-1Ch]
  int v6; // [sp+FCh] [bp-10h] BYREF
  _DWORD *all_created_runtime; // [sp+100h] [bp-Ch]
  int i; // [sp+104h] [bp-8h]

  v6 = 0;
  all_created_runtime = get_all_created_runtime(&v6);
  result = get_miner_working_status(&v4);
  if ( v5 != 1 )
  {
    for ( i = 0; i < v6; ++i )
    {
      result = v1;
      read_status_from_monitor(v1, all_created_runtime[i]);
      if ( v2 < v3 * 0.8 )
      {
        result = (_DWORD *)strcmp((const char *)(all_created_runtime[i] + 320), "ltc");
        if ( !result )
          result = (_DWORD *)(*(int (__fastcall **)(_DWORD))(all_created_runtime[i] + 24))(all_created_runtime[i]);
      }
    }
  }
  return result;
}

//----- (00068F28) --------------------------------------------------------
int miner_monitor_init()
{
  int (**v0)(); // r0
  int v2; // [sp+4h] [bp-10h]
  int j; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  v0 = dev_ctrl();
  v2 = (*v0)();
  for ( i = 0; i < v2; ++i )
  {
    *((_DWORD *)&unk_152900 + 56 * i + 19) = calloc(0x100u, 1u);
    **((_BYTE **)&unk_152900 + 56 * i + 19) = 63;
    *((_DWORD *)&unk_152900 + 56 * i + 26) = calloc(0x10u, 4u);
    *((_DWORD *)&unk_152900 + 56 * i + 27) = calloc(0x10u, 4u);
    *((_DWORD *)&unk_152900 + 56 * i + 2) = calloc(0x10u, 4u);
    *((_DWORD *)&unk_152900 + 56 * i + 1) = calloc(0x10u, 4u);
    *((_DWORD *)&unk_152900 + 56 * i) = calloc(0x10u, 4u);
    *((_DWORD *)&unk_152900 + 56 * i + 4) = calloc(0x10u, 4u);
    *((_DWORD *)&unk_152900 + 56 * i + 3) = calloc(0x10u, 4u);
    *((_DWORD *)&unk_152900 + 56 * i + 52) = 0;
    *((_QWORD *)&unk_152900 + 28 * i + 27) = 0;
    for ( j = 0; j <= 15; ++j )
    {
      *(_DWORD *)(*((_DWORD *)&unk_152900 + 56 * i + 2) + 4 * j) = -64;
      *(_DWORD *)(*((_DWORD *)&unk_152900 + 56 * i + 1) + 4 * j) = -64;
      *(_DWORD *)(*((_DWORD *)&unk_152900 + 56 * i) + 4 * j) = -64;
    }
    init_temp_senor_info((int)&unk_152900 + 224 * i);
  }
  dword_153C08 = (int)new_observable_subject();
  dword_153C0C = (int)new_observable_subject();
  dword_153C10 = (int)new_observable_subject();
  dword_153C14 = (int)new_observable_subject();
  dword_153C04 = (int)new_task_timer();
  add_new_task(dword_153C04, 426412, 1000);
  add_new_task(dword_153C04, 427124, 120000);
  add_new_task(dword_153C04, 427836, 60000);
  if ( is_test_pool != 1 )
  {
    add_new_task(dword_153C04, (int)update_droa_log, 180000);
    add_new_task(dword_153C04, (int)update_timestamp_file, 180000);
  }
  dword_153C00 = (int)new_task_timer();
  add_new_task(dword_153C00, 426768, 5000);
  add_new_task(dword_153C00, 427480, 1000);
  return add_new_task(dword_153C00, (int)task_check_miner_status, 1000);
}
// 1512C3: using guessed type char is_test_pool;
// 153C00: using guessed type int dword_153C00;
// 153C04: using guessed type int dword_153C04;
// 153C08: using guessed type int dword_153C08;
// 153C0C: using guessed type int dword_153C0C;
// 153C10: using guessed type int dword_153C10;
// 153C14: using guessed type int dword_153C14;

//----- (00069404) --------------------------------------------------------
void miner_monitor_deinit()
{
  int (**v0)(); // r0
  int v1; // [sp+0h] [bp-Ch]
  int i; // [sp+4h] [bp-8h]

  destroy_task_timer((_BYTE *)dword_153C00);
  destroy_task_timer((_BYTE *)dword_153C04);
  destroy_observable_subject((void *)dword_153C08);
  destroy_observable_subject((void *)dword_153C0C);
  destroy_observable_subject((void *)dword_153C10);
  destroy_observable_subject((void *)dword_153C14);
  v0 = dev_ctrl();
  v1 = (*v0)();
  for ( i = 0; i < v1; ++i )
  {
    free((void *)dword_152900[56 * i + 19]);
    free((void *)dword_152900[56 * i + 26]);
    free((void *)dword_152900[56 * i]);
    free((void *)dword_152900[56 * i + 2]);
    free((void *)dword_152900[56 * i + 1]);
    free((void *)dword_152900[56 * i + 4]);
    free((void *)dword_152900[56 * i + 3]);
  }
}
// 152900: using guessed type _DWORD dword_152900[896];
// 153C00: using guessed type int dword_153C00;
// 153C04: using guessed type int dword_153C04;
// 153C08: using guessed type int dword_153C08;
// 153C0C: using guessed type int dword_153C0C;
// 153C10: using guessed type int dword_153C10;
// 153C14: using guessed type int dword_153C14;

//----- (000695E4) --------------------------------------------------------
int do_miner_monitor_start()
{
  int v0; // r3
  int v2; // [sp+Ch] [bp-10h] BYREF
  _DWORD *all_created_runtime; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  v2 = 0;
  all_created_runtime = get_all_created_runtime(&v2);
  for ( i = 0; i < v2; ++i )
  {
    while ( *(_BYTE *)(all_created_runtime[i] + 258) != 1 )
      sleep(1u);
  }
  force_exec_all_task(dword_153C04);
  force_exec_all_task(dword_153C00);
  start_task_timer(dword_153C04);
  start_task_timer(dword_153C00);
  return v0;
}
// 696B8: variable 'v0' is possibly undefined
// 153C00: using guessed type int dword_153C00;
// 153C04: using guessed type int dword_153C04;

//----- (000696C4) --------------------------------------------------------
int miner_monitor_start()
{
  pthread_t newthread; // [sp+4h] [bp-8h] BYREF

  pthread_create(&newthread, 0, (void *(*)(void *))do_miner_monitor_start, 0);
  return pthread_detach(newthread);
}

//----- (00069700) --------------------------------------------------------
int miner_monitor_stop()
{
  stop_task_timer(dword_153C00);
  return stop_task_timer(dword_153C04);
}
// 153C00: using guessed type int dword_153C00;
// 153C04: using guessed type int dword_153C04;

//----- (00069738) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> read_status_from_monitor(void *a1, int a2)
{
  memcpy(a1, (char *)&unk_152900 + 224 * *(_DWORD *)(a2 + 248), 0xE0u);
}

//----- (00069788) --------------------------------------------------------
int __fastcall add_temperature_observer(int a1)
{
  return subject_observe(dword_153C08, a1);
}
// 153C08: using guessed type int dword_153C08;

//----- (000697BC) --------------------------------------------------------
int __fastcall add_hashrate_observer(int a1)
{
  return subject_observe(dword_153C0C, a1);
}
// 153C0C: using guessed type int dword_153C0C;

//----- (000697F0) --------------------------------------------------------
int __fastcall add_chip_status_observer(int a1)
{
  return subject_observe(dword_153C10, a1);
}
// 153C10: using guessed type int dword_153C10;

//----- (00069824) --------------------------------------------------------
int __fastcall add_fanspeed_observer(int a1)
{
  return subject_observe(dword_153C14, a1);
}
// 153C14: using guessed type int dword_153C14;

//----- (00069858) --------------------------------------------------------
int __fastcall read_system_status_from_monitor(int a1)
{
  int v1; // r1
  __int64 v2; // r2
  int v3; // r1
  __int64 v4; // r2
  int v5; // r1
  double v6; // r2
  int v7; // r1
  int v10; // [sp+Ch] [bp-48h] BYREF
  __int64 v11; // [sp+10h] [bp-44h]
  __int64 v12; // [sp+18h] [bp-3Ch]
  __int64 v13; // [sp+20h] [bp-34h]
  __int64 v14; // [sp+28h] [bp-2Ch]
  double v15; // [sp+30h] [bp-24h]
  double v16; // [sp+38h] [bp-1Ch]
  __int64 v17; // [sp+40h] [bp-14h]
  _DWORD *all_created_runtime; // [sp+48h] [bp-Ch]
  int i; // [sp+4Ch] [bp-8h]

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0;
  v10 = 0;
  all_created_runtime = get_all_created_runtime(&v10);
  LODWORD(v11) = v10;
  for ( i = 0; i < v10; ++i )
  {
    *((float *)&v12 + 1) = *((float *)&v12 + 1)
                         + *((float *)&unk_152900 + 56 * *(_DWORD *)(all_created_runtime[i] + 248) + 9);
    *(float *)&v13 = *(float *)&v13 + *((float *)&unk_152900 + 56 * *(_DWORD *)(all_created_runtime[i] + 248) + 10);
    *((float *)&v13 + 1) = *((float *)&v13 + 1)
                         + *((float *)&unk_152900 + 56 * *(_DWORD *)(all_created_runtime[i] + 248) + 11);
    *(float *)&v14 = *(float *)&v14 + *((float *)&unk_152900 + 56 * *(_DWORD *)(all_created_runtime[i] + 248) + 12);
    v17 += *((_QWORD *)&unk_152900 + 28 * *(_DWORD *)(all_created_runtime[i] + 248) + 11);
    v15 = v15 + *((double *)&unk_152900 + 28 * *(_DWORD *)(all_created_runtime[i] + 248) + 7);
    v16 = v16 + *((double *)&unk_152900 + 28 * *(_DWORD *)(all_created_runtime[i] + 248) + 8);
  }
  if ( v10 > 0 )
  {
    HIDWORD(v11) = *((_DWORD *)&unk_152900 + 56 * *(_DWORD *)(*all_created_runtime + 248) + 25);
    LODWORD(v12) = *((_DWORD *)&unk_152900 + 56 * *(_DWORD *)(*all_created_runtime + 248) + 26);
  }
  v1 = HIDWORD(v11);
  v2 = v12;
  *(_DWORD *)a1 = v11;
  *(_DWORD *)(a1 + 4) = v1;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = HIDWORD(v13);
  v4 = v14;
  *(_DWORD *)(a1 + 16) = v13;
  *(_DWORD *)(a1 + 20) = v3;
  *(_QWORD *)(a1 + 24) = v4;
  v5 = HIDWORD(v15);
  v6 = v16;
  *(_DWORD *)(a1 + 32) = LODWORD(v15);
  *(_DWORD *)(a1 + 36) = v5;
  *(double *)(a1 + 40) = v6;
  v7 = HIDWORD(v17);
  *(_DWORD *)(a1 + 48) = v17;
  *(_DWORD *)(a1 + 52) = v7;
  return a1;
}

//----- (00069B44) --------------------------------------------------------
char *__fastcall get_flag_from_monitor(int a1)
{
  return (char *)&unk_153700 + 80 * *(_DWORD *)(a1 + 248);
}

//----- (00069B80) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_69B80(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (00069BB4) --------------------------------------------------------
int __fastcall chip_speed_test(int a1)
{
  int v1; // r3
  bool v2; // nf
  int v3; // r2
  int v4; // r3
  int v5; // r2
  int v6; // r3
  int v7; // r2
  int v8; // r3
  int v9; // r2
  int v10; // r3
  int v11; // r3
  _BYTE v14[60]; // [sp+30h] [bp-243Ch] BYREF
  char v15[28]; // [sp+FD0h] [bp-149Ch] BYREF
  int v16; // [sp+1FD0h] [bp-49Ch] BYREF
  char v17; // [sp+1FD6h] [bp-496h]
  char v18[24]; // [sp+1FE4h] [bp-488h] BYREF
  float v19[17]; // [sp+23E4h] [bp-88h] BYREF
  __int64 v20; // [sp+2428h] [bp-44h] BYREF
  int v21; // [sp+2430h] [bp-3Ch]
  int v22; // [sp+2434h] [bp-38h]
  int v23; // [sp+2438h] [bp-34h]
  int v24; // [sp+243Ch] [bp-30h]
  int v25; // [sp+2440h] [bp-2Ch]
  int v26; // [sp+2444h] [bp-28h]
  int v27; // [sp+2448h] [bp-24h]
  int v28; // [sp+244Ch] [bp-20h]
  float i; // [sp+2450h] [bp-1Ch]
  int k; // [sp+2454h] [bp-18h]
  int j; // [sp+2458h] [bp-14h]
  int v32; // [sp+245Ch] [bp-10h]

  v32 = 0;
  v19[0] = 0.0;
  (*(void (__fastcall **)(int, float *))(a1 + 148))(a1, v19);
  v19[0] = v19[0] * 120.0;
  V_LOCK();
  logfmt_raw(v15, 0x1000u, 0, "qualify nonce count %f", v19[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_chip_status.c",
    203,
    "chip_speed_test",
    15,
    37,
    20,
    v15);
  get_miner_working_status(&v16);
  if ( v17 )
  {
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, "check lost connection to pool, keep the state of all chips!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_chip_status.c",
      203,
      "chip_speed_test",
      15,
      45,
      20,
      v15);
  }
  else
  {
    for ( i = 0.0; SLODWORD(i) < *(_DWORD *)(a1 + 336); ++LODWORD(i) )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 480) + 4 * LODWORD(i)) < (unsigned int)v19[0] )
      {
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 480) + 4 * LODWORD(i)) )
        {
          v6 = v32++;
          v7 = -v6;
          v2 = -v6 < 0;
          v8 = v6 & 0xF;
          v9 = v7 & 0xF;
          if ( !v2 )
            v8 = -v9;
          v19[v8 + 1] = i;
          *(_DWORD *)(*(_DWORD *)(a1 + 528) + 44 * LODWORD(i) + 16) = 3;
        }
        else
        {
          v1 = v32++;
          v3 = -v1;
          v2 = -v1 < 0;
          v4 = v1 & 0xF;
          v5 = v3 & 0xF;
          if ( !v2 )
            v4 = -v5;
          v19[v4 + 1] = i;
          *(_DWORD *)(*(_DWORD *)(a1 + 528) + 44 * LODWORD(i) + 16) = 2;
        }
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 528) + 44 * LODWORD(i) + 16) = 0;
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 480) + 4 * LODWORD(i)) = 0;
    }
    if ( v32 > *(_DWORD *)(a1 + 524) )
    {
      v28 = 0;
      v27 = snprintf(v18, 0x400u, "bad asic id:");
      v28 += v27;
      for ( j = 0; ; ++j )
      {
        v11 = v32;
        if ( v32 >= 16 )
          v11 = 16;
        if ( j >= v11 )
          break;
        v27 = snprintf(&v18[v28], 1024 - v28, "%03d ", v19[j + 1]);
        v28 += v27;
      }
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, "%s", v18);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_chip_status.c",
        203,
        "chip_speed_test",
        15,
        86,
        40,
        v15);
      (*(void (__fastcall **)(int, _BYTE *, int))(a1 + 208))(a1, v14, 4000);
      V_LOCK();
      sub_69B80((int)&v20, *(int *)(a1 + 252));
      logfmt_raw(v15, 0x1000u, 0, v26, v20, v21, v22, v23, v24, v25, v26, "%s", v14);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_chip_status.c",
        203,
        "chip_speed_test",
        15,
        89,
        60,
        v15);
    }
    else
    {
      for ( k = 0; ; ++k )
      {
        v10 = v32;
        if ( v32 >= 16 )
          v10 = 16;
        if ( k >= v10 )
          break;
        *(_DWORD *)(*(_DWORD *)(a1 + 528) + 44 * LODWORD(v19[k + 1]) + 16) = 0;
      }
    }
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0006A1B4) --------------------------------------------------------
int __fastcall update_str_and_flag(unsigned __int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // d17
  unsigned __int64 v3; // kr00_8
  int i; // [sp+28h] [bp-Ch]
  _BYTE *v6; // [sp+2Ch] [bp-8h]

  v3 = a1;
  *(_DWORD *)(HIDWORD(a1) + 72) = 0;
  v6 = *(_BYTE **)(HIDWORD(a1) + 76);
  for ( i = 0; i < *(_DWORD *)(v3 + 336); ++i )
  {
    switch ( *(_DWORD *)(*(_DWORD *)(v3 + 528) + 44 * i + 16) )
    {
      case 0:
        ++*(_DWORD *)(HIDWORD(v3) + 72);
        *v6++ = 111;
        break;
      case 1:
        *v6++ = 35;
        LODWORD(v2) = 0;
        a1 = vshld_u64(1u, v2) | *a2;
        *a2 = a1;
        break;
      case 2:
        *v6++ = 88;
        LODWORD(v2) = 1;
        a1 = vshld_u64(1u, v2) | *a2;
        *a2 = a1;
        break;
      case 3:
        *v6++ = 120;
        LODWORD(v2) = 2;
        a1 = vshld_u64(1u, v2) | *a2;
        *a2 = a1;
        break;
      default:
        *v6++ = 42;
        break;
    }
    if ( i && (i & 7) == 0 )
      *v6++ = 32;
  }
  *v6 = 0;
  return a1;
}
// 6A214: control flows out of bounds to 6A218
// 6A294: variable 'v2' is possibly undefined

//----- (0006A418) --------------------------------------------------------
int __fastcall sub_6A418(int result)
{
  int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i < *(_DWORD *)(result + 336); ++i )
    *(_DWORD *)(*(_DWORD *)(result + 528) + 44 * i + 16) = 0;
  return result;
}

//----- (0006A484) --------------------------------------------------------
int __fastcall update_chip_status(int a1, unsigned int a2, int a3)
{
  if ( byte_153C1C[*(_DWORD *)(a1 + 248)] != 1 )
  {
    sub_6A418(a1);
    *(_DWORD *)(a2 + 80) = *(_DWORD *)(a1 + 464);
    update_str_and_flag(__PAIR64__(a2, a1), (unsigned __int64 *)(a3 + 48));
    *(_DWORD *)(a2 + 72) = *(_DWORD *)(a1 + 424);
    byte_153C1C[*(_DWORD *)(a1 + 248)] = 1;
  }
  else if ( *(_BYTE *)(a1 + 258) == 1 )
  {
    *(_DWORD *)(a2 + 80) = *(_DWORD *)(a1 + 464);
    chip_speed_test(a1);
    update_str_and_flag(__PAIR64__(a2, a1), (unsigned __int64 *)(a3 + 48));
  }
  return a3 + 48;
}
// 153C1C: using guessed type _BYTE byte_153C1C[16];

//----- (0006A588) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6A588(int a1, __int64 a2)
{
  V_INT(a1, "fanid", a2);
}

//----- (0006A5BC) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6A5BC(int a1, __int64 a2)
{
  V_INT(a1, "fanspeed", a2);
}

//----- (0006A5F0) --------------------------------------------------------
int __fastcall update_fanspeed(int a1, _DWORD *a2, int a3)
{
  unsigned __int64 v3; // d17
  int v5; // r2
  int v6; // r3
  int v7; // r4
  int fan_max_speed; // r5
  char v13[32]; // [sp+64h] [bp-11A0h] BYREF
  __int64 v14; // [sp+1064h] [bp-1A0h]
  int v15; // [sp+106Ch] [bp-198h] BYREF
  _DWORD v16[7]; // [sp+1070h] [bp-194h] BYREF
  int v17; // [sp+108Ch] [bp-178h]
  _DWORD v18[8]; // [sp+1090h] [bp-174h] BYREF
  _DWORD v19[7]; // [sp+10B0h] [bp-154h] BYREF
  int v20; // [sp+10CCh] [bp-138h]
  _DWORD v21[8]; // [sp+10D0h] [bp-134h] BYREF
  _DWORD v22[7]; // [sp+10F0h] [bp-114h] BYREF
  int v23; // [sp+110Ch] [bp-F8h]
  _DWORD v24[8]; // [sp+1110h] [bp-F4h] BYREF
  _DWORD v25[7]; // [sp+1130h] [bp-D4h] BYREF
  int v26; // [sp+114Ch] [bp-B8h]
  _DWORD v27[8]; // [sp+1150h] [bp-B4h] BYREF
  _DWORD v28[7]; // [sp+1170h] [bp-94h] BYREF
  int v29; // [sp+118Ch] [bp-78h]
  _DWORD v30[18]; // [sp+1190h] [bp-74h] BYREF
  int realtime_speed; // [sp+11D8h] [bp-2Ch]
  int v32; // [sp+11DCh] [bp-28h]
  int fan_num; // [sp+11E0h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+11E4h] [bp-20h]
  int v35; // [sp+11E8h] [bp-1Ch]
  signed int i; // [sp+11ECh] [bp-18h]
  int j; // [sp+11F0h] [bp-14h]
  int k; // [sp+11F4h] [bp-10h]

  v15 = 0;
  all_created_runtime = get_all_created_runtime(&v15);
  if ( a1 != *all_created_runtime )
    return a3 + 32;
  if ( fan_inited != 1 )
  {
    fan_init();
    fan_inited = 1;
  }
  fan_num = platform_get_fan_num();
  v35 = 0;
  v14 = 0;
  for ( i = 0; i < fan_num; ++i )
  {
    realtime_speed = fan_get_realtime_speed(i);
    V_LOCK();
    sub_6A588((int)v16, i);
    sub_6A5BC((int)v18, realtime_speed);
    logfmt_raw(
      v13,
      0x1000u,
      0,
      v17,
      v16[0],
      v16[1],
      v16[2],
      v16[3],
      v16[4],
      v16[5],
      v16[6],
      v17,
      v18[0],
      v18[1],
      v18[2],
      v18[3],
      v18[4],
      v18[5],
      v18[6],
      v18[7],
      "%s",
      "update_fanspeed");
    V_UNLOCK();
    zlog(
      g_fan_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_fanspeed.c",
      200,
      "update_fanspeed",
      15,
      37,
      40,
      v13);
    if ( realtime_speed == -1 )
    {
      V_LOCK();
      sub_6A588((int)v22, i);
      sub_6A5BC((int)v24, realtime_speed & ~(realtime_speed >> 31));
      logfmt_raw(
        v13,
        0x1000u,
        0,
        v23,
        v22[0],
        v22[1],
        v22[2],
        v22[3],
        v22[4],
        v22[5],
        v22[6],
        v23,
        v24[0],
        v24[1],
        v24[2],
        v24[3],
        v24[4],
        v24[5],
        v24[6],
        v24[7],
        "%2d(corresponding to FAN%s on control board PCB)",
        i,
        fan_name[i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_fanspeed.c",
        200,
        "update_fanspeed",
        15,
        45,
        100,
        v13);
      *((_BYTE *)&v14 + i) = 1;
    }
    else
    {
      V_LOCK();
      sub_6A588((int)v19, i);
      sub_6A5BC((int)v21, realtime_speed);
      logfmt_raw(
        v13,
        0x1000u,
        0,
        v20,
        v19[0],
        v19[1],
        v19[2],
        v19[3],
        v19[4],
        v19[5],
        v19[6],
        v20,
        v21[0],
        v21[1],
        v21[2],
        v21[3],
        v21[4],
        v21[5],
        v21[6],
        v21[7],
        "%s",
        "update_fanspeed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_fanspeed.c",
        200,
        "update_fanspeed",
        15,
        39,
        20,
        v13);
      *(_DWORD *)(a2[27] + 4 * v35) = i;
      v5 = a2[26];
      v6 = v35++;
      *(_DWORD *)(v5 + 4 * v6) = realtime_speed;
    }
  }
  a2[25] = v35;
  if ( fan_num > a2[25] )
  {
    v30[17] = a3 + 32;
    v30[16] = 1;
    LODWORD(v3) = 1;
    *(_QWORD *)(a3 + 32) |= vshld_u64(1u, v3);
  }
  for ( j = 0; j < a2[25]; ++j )
  {
    if ( *(_DWORD *)(a2[26] + 4 * j) )
    {
      v7 = *(_DWORD *)(a2[26] + 4 * j);
      fan_max_speed = platform_get_fan_max_speed(j);
      if ( v7 >= fan_pwm_get() * fan_max_speed / 150 )
        continue;
    }
    v30[15] = a3 + 32;
    v30[14] = 0;
    LODWORD(v3) = 0;
    *(_QWORD *)(a3 + 32) |= vshld_u64(1u, v3);
    *((_BYTE *)&v14 + j) = 1;
  }
  v30[13] = a3 + 32;
  v30[12] = 1;
  LODWORD(v3) = 1;
  if ( (vshld_u64(1u, v3) & *(_QWORD *)(a3 + 32)) != 0
    || (v30[11] = a3 + 32, v30[10] = 0, LODWORD(v3) = 0, (vshld_u64(1u, v3) & *(_QWORD *)(a3 + 32)) != 0) )
  {
    if ( ++dword_153C30 > dword_14F908 )
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "fan_error_num: %d fan_num %d", dword_153C30, a2[25]);
      V_UNLOCK();
      if ( !*(_BYTE *)(a1 + 258) )
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_fanspeed.c",
          200,
          "update_fanspeed",
          15,
          65,
          20,
          v13);
      if ( dword_14F908 + 1 == dword_153C30 )
      {
        v30[9] = a3 + 32;
        v30[8] = 2;
        LODWORD(v3) = 2;
        *(_QWORD *)(a3 + 32) |= vshld_u64(1u, v3);
        for ( k = 0; k < fan_num; ++k )
        {
          v32 = fan_get_realtime_speed(k);
          V_LOCK();
          sub_6A588((int)v25, k);
          sub_6A5BC((int)v27, v32);
          logfmt_raw(
            v13,
            0x1000u,
            0,
            v26,
            v25[0],
            v25[1],
            v25[2],
            v25[3],
            v25[4],
            v25[5],
            v25[6],
            v26,
            v27[0],
            v27[1],
            v27[2],
            v27[3],
            v27[4],
            v27[5],
            v27[6],
            v27[7],
            "%s",
            "update_fanspeed");
          V_UNLOCK();
          zlog(
            g_fan_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_fanspeed.c",
            200,
            "update_fanspeed",
            15,
            72,
            40,
            v13);
          V_LOCK();
          sub_6A588((int)v28, k);
          sub_6A5BC((int)v30, v32 & ~(v32 >> 31));
          logfmt_raw(
            v13,
            0x1000u,
            0,
            v29,
            v28[0],
            v28[1],
            v28[2],
            v28[3],
            v28[4],
            v28[5],
            v28[6],
            v29,
            v30[0],
            v30[1],
            v30[2],
            v30[3],
            v30[4],
            v30[5],
            v30[6],
            v30[7],
            "%2d(corresponding to FAN%s on control board PCB)",
            k,
            fan_name[k]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_fanspeed.c",
            200,
            "update_fanspeed",
            15,
            73,
            100,
            v13);
          if ( *((_BYTE *)&v14 + k) )
            set_miner_6060info_status_fan_err(k, 1);
        }
      }
    }
  }
  else
  {
    dword_153C30 = 0;
  }
  return a3 + 32;
}
// 6AA90: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 14F908: using guessed type int dword_14F908;
// 1505C8: using guessed type char *fan_name[8];
// 153C2C: using guessed type char fan_inited;
// 153C30: using guessed type int dword_153C30;
// 1608F0: using guessed type int g_zc;
// 1608F8: using guessed type int g_fan_zc;

//----- (0006B078) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6B078(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0006B0AC) --------------------------------------------------------
int __fastcall sub_6B0AC(int a1)
{
  float v1; // s0
  int result; // r0
  unsigned int i; // [sp+10h] [bp-14h]
  float v5; // [sp+14h] [bp-10h]
  int v6; // [sp+18h] [bp-Ch]
  int v7; // [sp+18h] [bp-Ch]
  unsigned int v8; // [sp+1Ch] [bp-8h]

  v8 = (unsigned int)(float)(v1 / 5.0);
  v6 = *(_DWORD *)(a1 + 2880);
  v5 = 0.0;
  get_miner_elapsed_time();
  result = v8;
  if ( (unsigned __int64)v8 > *(_QWORD *)(a1 + 2888) )
    v8 = *(_DWORD *)(a1 + 2888);
  for ( i = 0; v8 > i; ++i )
  {
    v7 = v6 + 719;
    result = -1240768329 * v7;
    v6 = v7 % 720;
    v5 = v5 + *(float *)(a1 + 4 * v6);
  }
  return result;
}
// 6B0C8: variable 'v1' is possibly undefined

//----- (0006B1D8) --------------------------------------------------------
_QWORD *__fastcall update_hashrate(int a1, int a2, _QWORD *a3)
{
  unsigned __int64 v3; // d17
  float v4; // s16
  float v5; // s16
  float v6; // r0
  float v7; // r0
  double v8; // d17
  float v13[57]; // [sp+38h] [bp-11ECh] BYREF
  char v14[72]; // [sp+11Ch] [bp-1108h] BYREF
  int v15; // [sp+111Ch] [bp-108h] BYREF
  char v16; // [sp+1122h] [bp-102h]
  char v17; // [sp+1124h] [bp-100h]
  int v18; // [sp+1130h] [bp-F4h] BYREF
  char v19; // [sp+1136h] [bp-EEh]
  _BYTE v20[4]; // [sp+1144h] [bp-E0h] BYREF
  double v21; // [sp+1148h] [bp-DCh] BYREF
  __int64 v22; // [sp+1150h] [bp-D4h] BYREF
  __int64 v23; // [sp+1158h] [bp-CCh] BYREF
  _QWORD v24[3]; // [sp+1160h] [bp-C4h] BYREF
  __int64 v25; // [sp+1178h] [bp-ACh]
  struct timespec *v26; // [sp+1180h] [bp-A4h]
  int v27; // [sp+1184h] [bp-A0h]
  _QWORD *v28; // [sp+1188h] [bp-9Ch]
  int v29; // [sp+118Ch] [bp-98h]
  _QWORD *v30; // [sp+1190h] [bp-94h]
  struct timespec *v31; // [sp+1194h] [bp-90h]
  struct timespec *v32; // [sp+1198h] [bp-8Ch]
  struct timespec *v33; // [sp+119Ch] [bp-88h]
  struct timespec *v34; // [sp+11A0h] [bp-84h]
  struct timespec *v35; // [sp+11A4h] [bp-80h]
  struct timespec *v36; // [sp+11A8h] [bp-7Ch]
  struct timespec *tp; // [sp+11ACh] [bp-78h]
  struct timespec *v38; // [sp+11B0h] [bp-74h]
  struct timespec *v39; // [sp+11B4h] [bp-70h]
  double v40; // [sp+11B8h] [bp-6Ch]
  float v41; // [sp+11C4h] [bp-60h]
  float v42; // [sp+11C8h] [bp-5Ch]
  float v43; // [sp+11CCh] [bp-58h]
  __int64 v44; // [sp+11D0h] [bp-54h]
  __int64 v45; // [sp+11D8h] [bp-4Ch]
  int v46; // [sp+11E4h] [bp-40h]
  float v47; // [sp+11E8h] [bp-3Ch]
  float v48; // [sp+11ECh] [bp-38h]
  double v49; // [sp+11F0h] [bp-34h]
  int i; // [sp+11F8h] [bp-2Ch]
  int j; // [sp+11FCh] [bp-28h]
  struct timespec *v52; // [sp+1200h] [bp-24h]
  struct timespec *v53; // [sp+1204h] [bp-20h]
  struct timespec *v54; // [sp+1208h] [bp-1Ch]
  int v55; // [sp+120Ch] [bp-18h]

  (*(void (__fastcall **)(int, __int64 *))(a1 + 136))(a1, &v23);
  (*(void (__fastcall **)(int, __int64 *))(a1 + 144))(a1, &v22);
  (*(void (__fastcall **)(int, double *, _BYTE *))(a1 + 140))(a1, &v21, v20);
  *(_QWORD *)(a2 + 56) = v23;
  *(_QWORD *)(a2 + 64) = v22;
  v55 = *(_DWORD *)(a1 + 248);
  if ( v55 <= 16 )
  {
    v54 = (struct timespec *)((char *)&unk_153C38 + 16 * v55);
    v53 = (struct timespec *)((char *)&unk_153D38 + 16 * v55);
    v52 = (struct timespec *)((char *)&unk_153E38 + 16 * v55);
    if ( byte_153F38[v55] != 1 )
    {
      tp = v54;
      clock_gettime(1, v54);
      v38 = v53;
      clock_gettime(1, v53);
      v39 = v52;
      clock_gettime(1, v52);
      qword_153F48[v55] = 0;
      byte_153F38[v55] = 1;
    }
    if ( *(_QWORD *)(a1 + 448) || byte_15F4C8 == 1 )
    {
      if ( byte_15F4C8 != 1 )
        byte_15F4C8 = 1;
      v33 = v54;
      clock_gettime(1, v54 + 1);
      v3 = v33[1].tv_sec - v33->tv_sec;
      v47 = (float)((v33[1].tv_nsec - v33->tv_nsec) / 1000000 + vshld_n_s64(4 * (vshld_n_s64(v3, 5u) - v3) + v3, 3u))
          / 1000.0;
      v46 = (int)&unk_153FC8 + 2896 * v55;
      if ( v47 >= 5.0 )
      {
        v45 = *(_QWORD *)(a1 + 448);
        v44 = v45 - qword_153F48[v55];
        v48 = 0.0;
        get_miner_working_status(&v18);
        if ( v19 != 1 && (unsigned __int8)v18 != 1 )
        {
          v4 = COERCE_FLOAT(sub_CCCD0(v44)) / v47;
          LODWORD(v3) = *(_DWORD *)(a1 + 432);
          v48 = v4 * COERCE_FLOAT(sub_CCCD0(vshld_u64(1u, v3)));
        }
        V_LOCK();
        logfmt_raw(v14, 0x1000u, 0, "[HashRate] time_passed_sec: %.2f, nc %llu, new %llu, %.2f H/s", v47, v45, v44, v48);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_hashrate.c",
          200,
          "update_hashrate",
          15,
          126,
          20,
          v14);
        v32 = v54;
        clock_gettime(1, v54);
        *(float *)(v46 + 4 * (*(_DWORD *)(v46 + 2880))++) = v48;
        *(int *)(v46 + 2880) %= 720;
        qword_153F48[v55] = v45;
        v5 = *(float *)(a2 + 48);
        v6 = COERCE_FLOAT(sub_CCCD0(*(_QWORD *)(v46 + 2888)));
        v43 = v48 + (float)(v5 * v6);
        v7 = COERCE_FLOAT(sub_CCCD0(*(_QWORD *)(v46 + 2888) + 1LL));
        *(float *)(a2 + 48) = v43 / v7;
        ++*(_QWORD *)(v46 + 2888);
      }
      sub_6B0AC(v46);
      *(float *)(a2 + 36) = 5.0;
      sub_6B0AC(v46);
      *(_DWORD *)(a2 + 40) = 1114636288;
      sub_6B0AC(v46);
      *(_DWORD *)(a2 + 44) = 1155596288;
      v49 = 0.0;
      for ( i = 0; i < *(_DWORD *)(a1 + 336); ++i )
      {
        for ( j = 2; j <= 5; ++j )
          *(_QWORD *)&v49 += *(_QWORD *)(*(_DWORD *)(a1 + 456) + 48 * i + 8 * j);
      }
      *(double *)(a2 + 88) = v49;
      v31 = v53;
      clock_gettime(1, v53 + 1);
      v42 = (float)((v31[1].tv_nsec - v31->tv_nsec) / 1000000
                  + vshld_n_s64(
                      4 * (vshld_n_s64(v31[1].tv_sec - v31->tv_sec, 5u) - (v31[1].tv_sec - v31->tv_sec))
                    + v31[1].tv_sec
                    - v31->tv_sec,
                      3u))
          / 1000.0;
      if ( v42 >= 900.0 )
      {
        sub_6B0AC(v46);
        v41 = 900.0;
        if ( *(int *)(a2 + 208) <= 23 )
        {
          *(float *)(a2 + 4 * (*(_DWORD *)(a2 + 208) + 28)) = v41;
        }
        else
        {
          memcpy((void *)(a2 + 112), (const void *)(a2 + 116), 0x5Cu);
          *(float *)(a2 + 204) = v41;
        }
        ++*(_DWORD *)(a2 + 208);
        ++*(_QWORD *)(a2 + 216);
        v8 = v41;
        if ( v41 > v21 * 0.97 )
        {
          v28 = a3;
          v27 = 0;
          LODWORD(v8) = 0;
          a3[1] |= vshld_u64(1u, *(unsigned __int64 *)&v8);
          set_miner_6060info_low_hashrate_err(*(_DWORD *)(a1 + 252), 0);
        }
        else
        {
          v30 = a3;
          v29 = 0;
          LODWORD(v8) = 0;
          *a3 |= vshld_u64(1u, *(unsigned __int64 *)&v8);
          get_miner_working_status(&v15);
          if ( v17 != 1 && v16 != 1 )
          {
            V_LOCK();
            sub_6B078((int)v24, *(int *)(a1 + 252));
            logfmt_raw(
              v14,
              0x1000u,
              0,
              HIDWORD(v25),
              v24[0],
              v24[1],
              v24[2],
              v25,
              "%s low hashrate happened!",
              "update_hashrate");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_hashrate.c",
              200,
              "update_hashrate",
              15,
              173,
              80,
              v14);
            read_status_from_monitor(v13, a1);
            v40 = 1000000000.0;
            V_LOCK();
            logfmt_raw(v14, 0x1000u, 0, "no ratio hashrate last_5s: %f", v13[9] / v40);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_hashrate.c",
              200,
              "update_hashrate",
              15,
              176,
              80,
              v14);
            V_LOCK();
            logfmt_raw(v14, 0x1000u, 0, "no ratio hashrate last_30min: %f", v13[11] / v40);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_hashrate.c",
              200,
              "update_hashrate",
              15,
              177,
              80,
              v14);
            V_LOCK();
            logfmt_raw(v14, 0x1000u, 0, "no ratio hashrate lifetime: %f", v13[12] / v40);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_hashrate.c",
              200,
              "update_hashrate",
              15,
              178,
              80,
              v14);
            set_miner_6060info_low_hashrate_err(*(_DWORD *)(a1 + 252), 1);
          }
        }
        v26 = v53;
        clock_gettime(1, v53);
      }
    }
    else
    {
      v34 = v54;
      clock_gettime(1, v54);
      v35 = v53;
      clock_gettime(1, v53);
      v36 = v52;
      clock_gettime(1, v52);
      qword_153F48[v55] = 0;
    }
  }
  return a3;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 153F38: using guessed type _BYTE byte_153F38[16];
// 153F48: using guessed type _QWORD qword_153F48[16];
// 15F4C8: using guessed type char byte_15F4C8;
// 1608F0: using guessed type int g_zc;

//----- (0006BF10) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6BF10(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0006BF44) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6BF44(int a1, __int64 a2)
{
  V_INT(a1, "sensor", a2);
}

//----- (0006BF78) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6BF78(int a1, __int64 a2)
{
  V_INT(a1, "pcbtemp", a2);
}

//----- (0006BFAC) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6BFAC(int a1, __int64 a2)
{
  V_INT(a1, "chiptemp", a2);
}

//----- (0006BFE0) --------------------------------------------------------
int __fastcall sub_6BFE0(
        _DWORD *a1,
        _DWORD *a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7,
        _DWORD *a8,
        _DWORD *a9)
{
  int v9; // r1
  size_t v10; // r2
  int v11; // r3
  int v12; // r1
  int v13; // r2
  int v16; // [sp+88h] [bp-11A4h] BYREF
  int v17; // [sp+8Ch] [bp-11A0h]
  int v18; // [sp+90h] [bp-119Ch]
  int v19; // [sp+94h] [bp-1198h]
  int v20; // [sp+98h] [bp-1194h]
  int v21; // [sp+9Ch] [bp-1190h]
  int v22; // [sp+A0h] [bp-118Ch]
  int v23; // [sp+A4h] [bp-1188h]
  _DWORD *v24; // [sp+A8h] [bp-1184h]
  _DWORD *v25; // [sp+ACh] [bp-1180h]
  _DWORD *v26; // [sp+B0h] [bp-117Ch]
  _DWORD *v27; // [sp+B4h] [bp-1178h]
  char v28[48]; // [sp+BCh] [bp-1170h] BYREF
  int v29; // [sp+10BCh] [bp-170h]
  int v30; // [sp+10C0h] [bp-16Ch]
  size_t nmemb; // [sp+10C4h] [bp-168h]
  int v32; // [sp+10C8h] [bp-164h]
  int v33; // [sp+10CCh] [bp-160h]
  int v34; // [sp+10D0h] [bp-15Ch]
  int v35; // [sp+10D4h] [bp-158h]
  _DWORD v36[7]; // [sp+10D8h] [bp-154h] BYREF
  int v37; // [sp+10F4h] [bp-138h]
  _DWORD v38[7]; // [sp+10F8h] [bp-134h] BYREF
  int v39; // [sp+1114h] [bp-118h]
  _DWORD v40[8]; // [sp+1118h] [bp-114h] BYREF
  int v41; // [sp+1138h] [bp-F4h] BYREF
  int v42; // [sp+113Ch] [bp-F0h]
  int v43; // [sp+1140h] [bp-ECh]
  int v44; // [sp+1144h] [bp-E8h]
  int v45; // [sp+1148h] [bp-E4h]
  int v46; // [sp+114Ch] [bp-E0h]
  int v47; // [sp+1150h] [bp-DCh]
  int v48; // [sp+1154h] [bp-D8h]
  int v49; // [sp+1158h] [bp-D4h] BYREF
  int v50; // [sp+115Ch] [bp-D0h]
  int v51; // [sp+1160h] [bp-CCh]
  int v52; // [sp+1164h] [bp-C8h]
  int v53; // [sp+1168h] [bp-C4h]
  int v54; // [sp+116Ch] [bp-C0h]
  int v55; // [sp+1170h] [bp-BCh]
  int v56; // [sp+1174h] [bp-B8h]
  _DWORD v57[7]; // [sp+1178h] [bp-B4h] BYREF
  int v58; // [sp+1194h] [bp-98h]
  _DWORD v59[8]; // [sp+1198h] [bp-94h] BYREF
  int v60; // [sp+11B8h] [bp-74h] BYREF
  int v61; // [sp+11BCh] [bp-70h]
  int v62; // [sp+11C0h] [bp-6Ch]
  int v63; // [sp+11C4h] [bp-68h]
  int v64; // [sp+11C8h] [bp-64h]
  int v65; // [sp+11CCh] [bp-60h]
  int v66; // [sp+11D0h] [bp-5Ch]
  int v67; // [sp+11D4h] [bp-58h]
  int v68; // [sp+11D8h] [bp-54h] BYREF
  int v69; // [sp+11DCh] [bp-50h]
  int v70; // [sp+11E0h] [bp-4Ch]
  int v71; // [sp+11E4h] [bp-48h]
  int v72; // [sp+11E8h] [bp-44h]
  int v73; // [sp+11ECh] [bp-40h]
  int v74; // [sp+11F0h] [bp-3Ch]
  int v75; // [sp+11F4h] [bp-38h]
  int v76; // [sp+11FCh] [bp-30h]
  void *ptr; // [sp+1200h] [bp-2Ch]
  int v78; // [sp+1204h] [bp-28h]
  int v79; // [sp+1208h] [bp-24h]
  int v80; // [sp+120Ch] [bp-20h]
  int v81; // [sp+1210h] [bp-1Ch]
  int v82; // [sp+1214h] [bp-18h]
  signed int i; // [sp+1218h] [bp-14h]
  int v84; // [sp+121Ch] [bp-10h]

  v27 = a1;
  v26 = a2;
  v25 = a3;
  v24 = a4;
  v78 = -64;
  v79 = 0;
  v84 = 0;
  v9 = a1[98];
  v10 = a1[99];
  v11 = a1[100];
  v29 = a1[97];
  v30 = v9;
  nmemb = v10;
  v32 = v11;
  v12 = a1[102];
  v13 = a1[103];
  v33 = a1[101];
  v34 = v12;
  v35 = v13;
  ptr = calloc(nmemb, 0xCu);
  *v25 = -150;
  *v24 = 150;
  *a5 = -150;
  *a6 = 150;
  ((void (__fastcall *)(_DWORD *, void *))v27[57])(v27, ptr);
  for ( i = 0; i < (int)nmemb; ++i )
  {
    V_LOCK();
    sub_6BF10((int)v36, (int)v27[63]);
    logfmt_raw(
      v28,
      0x1000u,
      0,
      v37,
      v36[0],
      v36[1],
      v36[2],
      v36[3],
      v36[4],
      v36[5],
      v36[6],
      v37,
      "check_temperature, local:%d, remote:%d",
      *((_DWORD *)ptr + 3 * i),
      *((_DWORD *)ptr + 3 * i + 1));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
      203,
      "check_temperature",
      17,
      35,
      20,
      v28);
    v82 = 0;
    if ( *((_DWORD *)ptr + 3 * i) == -64 )
    {
      ++*a9;
    }
    else
    {
      v82 = 1;
      ++*a7;
      if ( *((_DWORD *)ptr + 3 * i) > *v25 )
        *v25 = *((_DWORD *)ptr + 3 * i);
      if ( *((_DWORD *)ptr + 3 * i) < *v24 )
        *v24 = *((_DWORD *)ptr + 3 * i);
    }
    v81 = 0;
    if ( *((_DWORD *)ptr + 3 * i + 1) == -64 )
    {
      ++*a9;
    }
    else
    {
      v81 = 1;
      ++*a8;
      if ( *((_DWORD *)ptr + 3 * i + 1) > *a5 )
        *a5 = *((_DWORD *)ptr + 3 * i + 1);
      if ( *((_DWORD *)ptr + 3 * i + 1) < *a6 )
        *a6 = *((_DWORD *)ptr + 3 * i + 1);
    }
    v80 = 0;
    if ( *((_DWORD *)ptr + 3 * i + 2) == -64 )
      ++*a9;
    else
      v80 = 1;
    v76 = v29 + 24 * i;
    if ( v26 )
    {
      if ( *(_DWORD *)(v76 + 12) )
      {
        if ( *(_DWORD *)(v76 + 12) == 1 )
        {
          if ( v82 )
            *(_DWORD *)(v26[3] + 4 * v84) = *((_DWORD *)ptr + 3 * i);
          if ( v81 )
            *(_DWORD *)(v26[4] + 4 * v84) = *((_DWORD *)ptr + 3 * i + 1);
          ++v84;
        }
      }
      else
      {
        if ( v82 )
          *(_DWORD *)(v26[1] + 4 * v79) = *((_DWORD *)ptr + 3 * i);
        if ( v81 )
          *(_DWORD *)(v26[2] + 4 * v79) = *((_DWORD *)ptr + 3 * i + 1);
        if ( v80 )
          *(_DWORD *)(*v26 + 4 * v79) = *((_DWORD *)ptr + 3 * i + 2);
        ++v79;
      }
    }
    V_LOCK();
    sub_6BF10((int)v38, (int)v27[63]);
    sub_6BF44((int)v40, *(int *)(v76 + 20));
    if ( v82 )
    {
      sub_6BF78((int)&v41, *((int *)ptr + 3 * i));
    }
    else
    {
      sub_6BF78((int)&v16, -256);
      v41 = v16;
      v42 = v17;
      v43 = v18;
      v44 = v19;
      v45 = v20;
      v46 = v21;
      v47 = v22;
      v48 = v23;
    }
    if ( v81 )
    {
      sub_6BFAC((int)&v49, *((int *)ptr + 3 * i + 1));
    }
    else
    {
      sub_6BFAC((int)&v16, -256);
      v49 = v16;
      v50 = v17;
      v51 = v18;
      v52 = v19;
      v53 = v20;
      v54 = v21;
      v55 = v22;
      v56 = v23;
    }
    logfmt_raw(
      v28,
      0x1000u,
      0,
      v39,
      v38[0],
      v38[1],
      v38[2],
      v38[3],
      v38[4],
      v38[5],
      v38[6],
      v39,
      v40[0],
      v40[1],
      v40[2],
      v40[3],
      v40[4],
      v40[5],
      v40[6],
      v40[7],
      v41,
      v42,
      v43,
      v44,
      v45,
      v46,
      v47,
      v48,
      v49,
      v50,
      v51,
      v52,
      v53,
      v54,
      v55,
      v56,
      "%s",
      "check_temperature");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
      203,
      "check_temperature",
      17,
      103,
      20,
      v28);
    V_LOCK();
    sub_6BF10((int)v57, (int)v27[63]);
    sub_6BF44((int)v59, *(int *)(v76 + 20));
    if ( v82 )
    {
      sub_6BF78((int)&v60, *((int *)ptr + 3 * i));
    }
    else
    {
      sub_6BF78((int)&v16, -256);
      v60 = v16;
      v61 = v17;
      v62 = v18;
      v63 = v19;
      v64 = v20;
      v65 = v21;
      v66 = v22;
      v67 = v23;
    }
    if ( v81 )
    {
      sub_6BFAC((int)&v68, *((int *)ptr + 3 * i + 1));
    }
    else
    {
      sub_6BFAC((int)&v16, -256);
      v68 = v16;
      v69 = v17;
      v70 = v18;
      v71 = v19;
      v72 = v20;
      v73 = v21;
      v74 = v22;
      v75 = v23;
    }
    logfmt_raw(
      v28,
      0x1000u,
      0,
      v58,
      v57[0],
      v57[1],
      v57[2],
      v57[3],
      v57[4],
      v57[5],
      v57[6],
      v58,
      v59[0],
      v59[1],
      v59[2],
      v59[3],
      v59[4],
      v59[5],
      v59[6],
      v59[7],
      v60,
      v61,
      v62,
      v63,
      v64,
      v65,
      v66,
      v67,
      v68,
      v69,
      v70,
      v71,
      v72,
      v73,
      v74,
      v75,
      "%s",
      "check_temperature");
    V_UNLOCK();
    zlog(
      g_temp_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
      203,
      "check_temperature",
      17,
      105,
      40,
      v28);
  }
  free(ptr);
  if ( *a7 == nmemb && *a8 == nmemb )
    return 0;
  else
    return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 1608F4: using guessed type int g_temp_zc;

//----- (0006CA64) --------------------------------------------------------
void *__fastcall init_temp_senor_info(int a1)
{
  void *result; // r0
  int v3; // [sp+Ch] [bp-30h]
  int v4; // [sp+14h] [bp-28h]
  int v5; // [sp+28h] [bp-14h] BYREF
  int v6; // [sp+2Ch] [bp-10h]
  void *v7; // [sp+30h] [bp-Ch]
  int i; // [sp+34h] [bp-8h]

  result = get_all_created_runtime(&v5);
  v7 = result;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  if ( v5 > 0 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)v7 + 388);
    v4 = *(_DWORD *)(*(_DWORD *)v7 + 396);
    result = *(void **)(*(_DWORD *)v7 + 404);
    for ( i = 0; i < v4; ++i )
    {
      v6 = v3 + 24 * i;
      if ( *(_DWORD *)(v6 + 12) )
      {
        if ( *(_DWORD *)(v6 + 12) == 1 )
          ++*(_DWORD *)(a1 + 32);
      }
      else
      {
        ++*(_DWORD *)(a1 + 28);
      }
    }
  }
  return result;
}

//----- (0006CB60) --------------------------------------------------------
int __fastcall update_temperature(int a1, _DWORD *a2, int a3)
{
  unsigned __int64 v3; // d17
  int v4; // r3
  _BYTE v10[32]; // [sp+44h] [bp-2120h] BYREF
  char v11[64]; // [sp+FE4h] [bp-1180h] BYREF
  unsigned int v12; // [sp+1FE4h] [bp-180h] BYREF
  int v13; // [sp+1FE8h] [bp-17Ch] BYREF
  int v14; // [sp+1FECh] [bp-178h] BYREF
  int v15; // [sp+1FF0h] [bp-174h] BYREF
  int v16; // [sp+1FF4h] [bp-170h] BYREF
  int v17; // [sp+1FF8h] [bp-16Ch] BYREF
  int v18; // [sp+1FFCh] [bp-168h] BYREF
  _DWORD v19[7]; // [sp+2000h] [bp-164h] BYREF
  int v20; // [sp+201Ch] [bp-148h]
  _DWORD v21[7]; // [sp+2020h] [bp-144h] BYREF
  int v22; // [sp+203Ch] [bp-128h]
  _DWORD v23[7]; // [sp+2040h] [bp-124h] BYREF
  int v24; // [sp+205Ch] [bp-108h]
  _DWORD v25[7]; // [sp+2060h] [bp-104h] BYREF
  int v26; // [sp+207Ch] [bp-E8h]
  _DWORD v27[7]; // [sp+2080h] [bp-E4h] BYREF
  int v28; // [sp+209Ch] [bp-C8h]
  _DWORD v29[7]; // [sp+20A0h] [bp-C4h] BYREF
  int v30; // [sp+20BCh] [bp-A8h]
  _DWORD v31[7]; // [sp+20C0h] [bp-A4h] BYREF
  int v32; // [sp+20DCh] [bp-88h]
  _DWORD v33[7]; // [sp+20E0h] [bp-84h] BYREF
  int v34; // [sp+20FCh] [bp-68h]
  _DWORD v35[7]; // [sp+2100h] [bp-64h] BYREF
  int v36; // [sp+211Ch] [bp-48h]
  int v37; // [sp+2124h] [bp-40h]
  int v38; // [sp+2128h] [bp-3Ch]
  int v39; // [sp+212Ch] [bp-38h]
  int v40; // [sp+2130h] [bp-34h]
  int v41; // [sp+2134h] [bp-30h]
  int v42; // [sp+2138h] [bp-2Ch]
  int v43; // [sp+213Ch] [bp-28h]
  int v44; // [sp+2140h] [bp-24h]
  int v45; // [sp+2144h] [bp-20h]
  int v46; // [sp+2148h] [bp-1Ch]
  int v47; // [sp+214Ch] [bp-18h]
  int v48; // [sp+2150h] [bp-14h]
  int v49; // [sp+2154h] [bp-10h]

  v14 = 0;
  v13 = 0;
  v12 = 0;
  if ( *(_BYTE *)(a1 + 258) )
    v4 = 0;
  else
    v4 = 5;
  v49 = v4;
  if ( *(_BYTE *)(a1 + 258) != 1 )
    return a3 + 16;
  if ( sub_6BFE0((_DWORD *)a1, a2, &v18, &v17, &v16, &v15, &v14, &v13, &v12) && *(_BYTE *)(a1 + 1096) != 1 )
  {
    if ( v49 )
    {
      V_LOCK();
      sub_6BF10((int)v19, *(int *)(a1 + 252));
      logfmt_raw(
        v11,
        0x1000u,
        0,
        v20,
        v19[0],
        v19[1],
        v19[2],
        v19[3],
        v19[4],
        v19[5],
        v19[6],
        v20,
        "read temp error! pcb temp count %d chip temp count %d uneffective value count %d",
        v14,
        v13,
        v12);
      V_UNLOCK();
      switch ( v49 )
      {
        case 5:
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
            203,
            "update_temperature",
            18,
            330,
            20,
            v11);
          break;
        case 4:
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
            203,
            "update_temperature",
            18,
            330,
            40,
            v11);
          break;
        case 3:
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
            203,
            "update_temperature",
            18,
            330,
            60,
            v11);
          break;
        case 2:
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
            203,
            "update_temperature",
            18,
            330,
            80,
            v11);
          break;
        case 1:
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
            203,
            "update_temperature",
            18,
            330,
            100,
            v11);
          break;
        case 0:
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
            203,
            "update_temperature",
            18,
            330,
            120,
            v11);
          break;
      }
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "Sweep error string = %s.", "J0:6");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
        203,
        "update_temperature",
        18,
        331,
        100,
        v11);
    }
    v48 = a3 + 16;
    v47 = 0;
    LODWORD(v3) = 0;
    *(_QWORD *)(a3 + 16) |= vshld_u64(1u, v3);
  }
  if ( v14 )
  {
    dword_15F4D8[*(_DWORD *)(a1 + 248)] = v18;
    a2[6] = v17;
    dword_15F518[*(_DWORD *)(a1 + 248)] = 0;
  }
  else if ( (int)++dword_15F518[*(_DWORD *)(a1 + 248)] > 2 )
  {
    V_LOCK();
    sub_6BF10((int)v21, *(int *)(a1 + 252));
    logfmt_raw(
      v11,
      0x1000u,
      0,
      v22,
      v21[0],
      v21[1],
      v21[2],
      v21[3],
      v21[4],
      v21[5],
      v21[6],
      v22,
      "read no sensor pcb temp exceed limit! (%d)",
      dword_15F518[*(_DWORD *)(a1 + 248)]);
    V_UNLOCK();
    switch ( v49 )
    {
      case 5:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          349,
          20,
          v11);
        break;
      case 4:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          349,
          40,
          v11);
        break;
      case 3:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          349,
          60,
          v11);
        break;
      case 2:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          349,
          80,
          v11);
        break;
      case 1:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          349,
          100,
          v11);
        break;
      case 0:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          349,
          120,
          v11);
        break;
    }
    v46 = a3 + 16;
    v45 = 3;
    LODWORD(v3) = 3;
    *(_QWORD *)(a3 + 16) |= vshld_u64(1u, v3);
  }
  if ( v13 )
  {
    a2[5] = v16;
    dword_15F558[*(_DWORD *)(a1 + 248)] = v15;
    dword_15F598[*(_DWORD *)(a1 + 248)] = 0;
  }
  else if ( (int)++dword_15F598[*(_DWORD *)(a1 + 248)] > 2 )
  {
    V_LOCK();
    sub_6BF10((int)v23, *(int *)(a1 + 252));
    logfmt_raw(
      v11,
      0x1000u,
      0,
      v24,
      v23[0],
      v23[1],
      v23[2],
      v23[3],
      v23[4],
      v23[5],
      v23[6],
      v24,
      "read no sensor chip temp exceed limit! (%d)",
      dword_15F598[*(_DWORD *)(a1 + 248)]);
    V_UNLOCK();
    switch ( v49 )
    {
      case 5:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          366,
          20,
          v11);
        break;
      case 4:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          366,
          40,
          v11);
        break;
      case 3:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          366,
          60,
          v11);
        break;
      case 2:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          366,
          80,
          v11);
        break;
      case 1:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          366,
          100,
          v11);
        break;
      case 0:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          366,
          120,
          v11);
        break;
    }
    v44 = a3 + 16;
    v43 = 3;
    LODWORD(v3) = 3;
    *(_QWORD *)(a3 + 16) |= vshld_u64(1u, v3);
  }
  if ( *(_DWORD *)(a1 + 412) >= v12 )
  {
    dword_15F5D8[*(_DWORD *)(a1 + 248)] = 0;
  }
  else if ( (int)++dword_15F5D8[*(_DWORD *)(a1 + 248)] > 2 )
  {
    V_LOCK();
    sub_6BF10((int)v25, *(int *)(a1 + 252));
    logfmt_raw(
      v11,
      0x1000u,
      0,
      v26,
      v25[0],
      v25[1],
      v25[2],
      v25[3],
      v25[4],
      v25[5],
      v25[6],
      v26,
      "uneffective temp exceed limit (%d), uneffective_value_count = %d!",
      dword_15F5D8[*(_DWORD *)(a1 + 248)],
      v12);
    V_UNLOCK();
    switch ( v49 )
    {
      case 5:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          377,
          20,
          v11);
        break;
      case 4:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          377,
          40,
          v11);
        break;
      case 3:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          377,
          60,
          v11);
        break;
      case 2:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          377,
          80,
          v11);
        break;
      case 1:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          377,
          100,
          v11);
        break;
      case 0:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          377,
          120,
          v11);
        break;
    }
    (*(void (__fastcall **)(int, _BYTE *, int))(a1 + 208))(a1, v10, 4000);
    V_LOCK();
    sub_6BF10((int)v27, *(int *)(a1 + 252));
    logfmt_raw(v11, 0x1000u, 0, v28, v27[0], v27[1], v27[2], v27[3], v27[4], v27[5], v27[6], v28, "%s", v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
      203,
      "update_temperature",
      18,
      380,
      60,
      v11);
    v42 = a3 + 16;
    v41 = 4;
    LODWORD(v3) = 4;
    *(_QWORD *)(a3 + 16) |= vshld_u64(1u, v3);
  }
  if ( a2[5] <= *(_DWORD *)(a1 + 400) && dword_15F4D8[*(_DWORD *)(a1 + 248)] <= *(_DWORD *)(a1 + 404) )
  {
    dword_15F618[*(_DWORD *)(a1 + 248)] = 0;
  }
  else if ( (int)++dword_15F618[*(_DWORD *)(a1 + 248)] > 2 )
  {
    V_LOCK();
    sub_6BF10((int)v29, *(int *)(a1 + 252));
    logfmt_raw(
      v11,
      0x1000u,
      0,
      v30,
      v29[0],
      v29[1],
      v29[2],
      v29[3],
      v29[4],
      v29[5],
      v29[6],
      v30,
      "high temp exceed limit (%d), max_chip_temp = %d, max_pcb_temp = %d!",
      dword_15F618[*(_DWORD *)(a1 + 248)],
      a2[5],
      dword_15F4D8[*(_DWORD *)(a1 + 248)]);
    V_UNLOCK();
    switch ( v49 )
    {
      case 5:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          395,
          20,
          v11);
        break;
      case 4:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          395,
          40,
          v11);
        break;
      case 3:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          395,
          60,
          v11);
        break;
      case 2:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          395,
          80,
          v11);
        break;
      case 1:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          395,
          100,
          v11);
        break;
      case 0:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          395,
          120,
          v11);
        break;
    }
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "Sweep error string = %s.", "P:1");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
      203,
      "update_temperature",
      18,
      396,
      100,
      v11);
    (*(void (__fastcall **)(int, _BYTE *, int))(a1 + 208))(a1, v10, 4000);
    V_LOCK();
    sub_6BF10((int)v31, *(int *)(a1 + 252));
    logfmt_raw(v11, 0x1000u, 0, v32, v31[0], v31[1], v31[2], v31[3], v31[4], v31[5], v31[6], v32, "%s", v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
      203,
      "update_temperature",
      18,
      399,
      60,
      v11);
    v40 = a3 + 16;
    v39 = 1;
    LODWORD(v3) = 1;
    *(_QWORD *)(a3 + 16) |= vshld_u64(1u, v3);
  }
  if ( a2[6] > *(_DWORD *)(a1 + 408) )
  {
    dword_15F658[*(_DWORD *)(a1 + 248)] = 0;
  }
  else if ( (int)++dword_15F658[*(_DWORD *)(a1 + 248)] > 2 )
  {
    V_LOCK();
    sub_6BF10((int)v33, *(int *)(a1 + 252));
    logfmt_raw(
      v11,
      0x1000u,
      0,
      v34,
      v33[0],
      v33[1],
      v33[2],
      v33[3],
      v33[4],
      v33[5],
      v33[6],
      v34,
      "low temp exceed limit (%d), min_pcb_temp = %d!",
      dword_15F658[*(_DWORD *)(a1 + 248)],
      a2[6]);
    V_UNLOCK();
    switch ( v49 )
    {
      case 5:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          414,
          20,
          v11);
        break;
      case 4:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          414,
          40,
          v11);
        break;
      case 3:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          414,
          60,
          v11);
        break;
      case 2:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          414,
          80,
          v11);
        break;
      case 1:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          414,
          100,
          v11);
        break;
      case 0:
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
          203,
          "update_temperature",
          18,
          414,
          120,
          v11);
        break;
    }
    (*(void (__fastcall **)(int, _BYTE *, int))(a1 + 208))(a1, v10, 4000);
    V_LOCK();
    sub_6BF10((int)v35, *(int *)(a1 + 252));
    logfmt_raw(v11, 0x1000u, 0, v36, v35[0], v35[1], v35[2], v35[3], v35[4], v35[5], v35[6], v36, "%s", v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/miner_util/miner_monitor/update_miner_status/update_temperature.c",
      203,
      "update_temperature",
      18,
      417,
      60,
      v11);
    v38 = a3 + 16;
    v37 = 2;
    LODWORD(v3) = 2;
    *(_QWORD *)(a3 + 16) |= vshld_u64(1u, v3);
  }
  return a3 + 16;
}
// 6CFF0: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F4D8: using guessed type _DWORD dword_15F4D8[16];
// 15F518: using guessed type _DWORD dword_15F518[16];
// 15F558: using guessed type _DWORD dword_15F558[16];
// 15F598: using guessed type _DWORD dword_15F598[16];
// 15F5D8: using guessed type _DWORD dword_15F5D8[16];
// 15F618: using guessed type _DWORD dword_15F618[16];
// 15F658: using guessed type _DWORD dword_15F658[16];
// 1608F0: using guessed type int g_zc;

//----- (0006E688) --------------------------------------------------------
int __fastcall runtime_ctrl(int a1)
{
  char v3[12]; // [sp+18h] [bp-100Ch] BYREF
  int v4; // [sp+1018h] [bp-Ch]
  unsigned int i; // [sp+101Ch] [bp-8h]

  v4 = 0;
  for ( i = 0; i <= 1 && a1 != *(_DWORD *)&asc_119FA0[12 * i]; ++i )
    ;
  if ( i != 2 && *(_DWORD *)&asc_119FA0[12 * i + 8] )
  {
    v4 = (*(int (**)(void))&asc_119FA0[12 * i + 8])();
    if ( v4 )
    {
      pthread_mutex_lock(&stru_15F79C);
      dword_15F698[dword_15F798] = v4;
      *(_DWORD *)(v4 + 248) = dword_15F798++;
      pthread_mutex_unlock(&stru_15F79C);
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "not support miner type: %d", a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_interface.c",
      165,
      "runtime_ctrl",
      12,
      69,
      100,
      v3);
  }
  return v4;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F698: using guessed type _DWORD dword_15F698[64];
// 15F798: using guessed type int dword_15F798;
// 15F79C: using guessed type pthread_mutex_t stru_15F79C;
// 1608F0: using guessed type int g_zc;

//----- (0006E86C) --------------------------------------------------------
int query_device_num()
{
  int (**v0)(); // r0

  v0 = dev_ctrl();
  return (*v0)();
}

//----- (0006E890) --------------------------------------------------------
int __fastcall redirect_nonce_output(int result, int a2)
{
  while ( result != *(_DWORD *)(result + 1004) && *(_DWORD *)(result + 1004) )
    *(_DWORD *)(result + 1004) = result;
  *(_DWORD *)(a2 + 1004) = result;
  return result;
}

//----- (0006E8F4) --------------------------------------------------------
void *__fastcall get_all_created_runtime(_DWORD *a1)
{
  pthread_mutex_lock(&stru_15F79C);
  *a1 = dword_15F798;
  pthread_mutex_unlock(&stru_15F79C);
  return &unk_15F698;
}
// 15F798: using guessed type int dword_15F798;
// 15F79C: using guessed type pthread_mutex_t stru_15F79C;

//----- (0006E94C) --------------------------------------------------------
int check_and_destroy_abnormal_runtime()
{
  char v1[12]; // [sp+10h] [bp-140Ch] BYREF
  _DWORD v2[256]; // [sp+1010h] [bp-40Ch] BYREF
  int i; // [sp+1410h] [bp-Ch]
  int v4; // [sp+1414h] [bp-8h]

  i = 0;
  memset(v2, 0, sizeof(v2));
  v4 = 0;
  pthread_mutex_lock(&stru_15F79C);
  for ( i = 0; i < dword_15F798; ++i )
  {
    if ( *(_DWORD *)(dword_15F698[i] + 424) == *(_DWORD *)(dword_15F698[i] + 336) )
    {
      v2[v4++] = dword_15F698[i];
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v1,
        0x1000u,
        0,
        "chain %d runtime check asic number error, destroy it!",
        *(_DWORD *)(dword_15F698[i] + 252));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_interface.c",
        165,
        "check_and_destroy_abnormal_runtime",
        34,
        124,
        80,
        v1);
      set_miner_6060info_asic_num_less_than_design_err(*(_DWORD *)(dword_15F698[i] + 252), 1);
      (*(void (__fastcall **)(_DWORD))(dword_15F698[i] + 20))(dword_15F698[i]);
      (*(void (__fastcall **)(_DWORD))(dword_15F698[i] + 28))(dword_15F698[i]);
      free((void *)dword_15F698[i]);
      dword_15F698[i] = 0;
    }
  }
  for ( i = 0; i < v4; ++i )
    dword_15F698[i] = v2[i];
  dword_15F798 = v4;
  return pthread_mutex_unlock(&stru_15F79C);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F698: using guessed type _DWORD dword_15F698[64];
// 15F798: using guessed type int dword_15F798;
// 15F79C: using guessed type pthread_mutex_t stru_15F79C;
// 1608F0: using guessed type int g_zc;

//----- (0006EBCC) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6EBCC(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0006EC00) --------------------------------------------------------
int __fastcall sub_6EC00(int a1)
{
  __int64 v1; // r4
  _DWORD *v4; // [sp+8h] [bp-1Ch]
  __int64 v5; // [sp+10h] [bp-14h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 44));
  v4 = (_DWORD *)(a1 + 16);
  clock_gettime(1, (struct timespec *)(a1 + 24));
  v5 = (v4[3] - v4[1]) / 1000000 + vshld_n_s64(4 * (vshld_n_s64(v4[2] - *v4, 5u) - (v4[2] - *v4)) + v4[2] - *v4, 3u);
  clock_gettime(1, (struct timespec *)(a1 + 16));
  v1 = v5;
  if ( v5 < 0 )
    v1 = 0;
  *(_QWORD *)(a1 + 8) -= v1;
  if ( *(int *)(a1 + 12) < 0 )
    *(_QWORD *)(a1 + 8) = 0;
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 44));
}

//----- (0006ED60) --------------------------------------------------------
bool __fastcall sub_6ED60(int a1)
{
  __int64 v2; // r2

  if ( *(_BYTE *)(a1 + 40) != 1 )
    return 0;
  sub_6EC00(a1);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 44));
  *(_BYTE *)(a1 + 40) = *(_BYTE *)a1 == 1 || *(__int64 *)(a1 + 8) >= 1 || *(__int64 *)(a1 + 32) >= 1;
  v2 = *(_QWORD *)(a1 + 32) - 1LL;
  if ( v2 < 0 )
    v2 = 0;
  *(_QWORD *)(a1 + 32) = v2;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 44));
  return *(_BYTE *)(a1 + 40) == 1;
}

//----- (0006EE84) --------------------------------------------------------
int __fastcall set_remain_debug_print_time(int a1, __int64 a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 44));
  *(_QWORD *)(a1 + 8) = a2;
  clock_gettime(1, (struct timespec *)(a1 + 16));
  if ( a2 >= 1 )
    *(_BYTE *)(a1 + 40) = 1;
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 44));
}

//----- (0006EF08) --------------------------------------------------------
int __fastcall set_remain_debug_print_lines(int a1, __int64 a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 44));
  *(_QWORD *)(a1 + 32) = a2;
  if ( a2 >= 1 )
    *(_BYTE *)(a1 + 40) = 1;
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 44));
}

//----- (0006EF70) --------------------------------------------------------
int __fastcall set_debug_always_print(int a1, char a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 44));
  *(_BYTE *)a1 = a2;
  if ( a2 )
    *(_BYTE *)(a1 + 40) = 1;
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 44));
}

//----- (0006EFD8) --------------------------------------------------------
unsigned int __fastcall check_and_print_uart_debug_log(int a1, int a2, unsigned __int8 *a3, int a4, char a5)
{
  unsigned int result; // r0
  unsigned __int8 *v6; // r3
  int v7; // r0
  _BYTE v12[28]; // [sp+38h] [bp-145Ch] BYREF
  char v13[28]; // [sp+438h] [bp-105Ch] BYREF
  int v14; // [sp+488h] [bp-100Ch] BYREF
  _DWORD v15[7]; // [sp+1438h] [bp-5Ch] BYREF
  int v16; // [sp+1454h] [bp-40h]
  _DWORD v17[7]; // [sp+1458h] [bp-3Ch] BYREF
  int v18; // [sp+1474h] [bp-20h]
  int i; // [sp+147Ch] [bp-18h]
  unsigned __int8 *v20; // [sp+1480h] [bp-14h]
  int v21; // [sp+1484h] [bp-10h]

  result = (unsigned int)&v14;
  if ( a2 )
  {
    result = sub_6ED60(a1);
    if ( result )
    {
      v21 = 0;
      v20 = a3;
      for ( i = 0; i < a2; ++i )
      {
        v6 = v20++;
        v7 = snprintf(&v12[v21], 1024 - v21, "%02x ", *v6);
        v21 += v7;
      }
      V_LOCK();
      if ( a5 )
      {
        sub_6EBCC((int)v15, a4);
        logfmt_raw(v13, 0x1000u, 0, v16, v15[0], v15[1], v15[2], v15[3], v15[4], v15[5], v15[6], v16, "Tx: %s", v12);
        V_UNLOCK();
        return zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/buil"
                 "d/godminer-origin_godminer-branch1/backend/uart_debug_logger.c",
                 165,
                 "check_and_print_uart_debug_log",
                 30,
                 83,
                 40,
                 v13);
      }
      else
      {
        sub_6EBCC((int)v17, a4);
        logfmt_raw(v13, 0x1000u, 0, v18, v17[0], v17[1], v17[2], v17[3], v17[4], v17[5], v17[6], v18, "Rx: %s", v12);
        V_UNLOCK();
        return zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/buil"
                 "d/godminer-origin_godminer-branch1/backend/uart_debug_logger.c",
                 165,
                 "check_and_print_uart_debug_log",
                 30,
                 85,
                 40,
                 v13);
      }
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0006F280) --------------------------------------------------------
void __fastcall sub_6F280(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (0006F2E8) --------------------------------------------------------
int __fastcall sub_6F2E8(const char *a1)
{
  unsigned int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    if ( !strcmp(a1, off_14FC40[i]) )
      return i;
  }
  return 3;
}
// 14FC40: using guessed type char *off_14FC40[3];

//----- (0006F35C) --------------------------------------------------------
int __fastcall sub_6F35C(const char *a1)
{
  int i; // [sp+Ch] [bp-8h]

  for ( i = 0; strcmp(a1, off_14FC80[i]); ++i )
    ;
  return i;
}
// 14FC80: using guessed type char *off_14FC80[3];

//----- (0006F3C0) --------------------------------------------------------
int __fastcall sub_6F3C0(const char *a1)
{
  int i; // [sp+Ch] [bp-8h]

  for ( i = 0; strcmp(a1, off_14FCA0[i]); ++i )
    ;
  return i;
}
// 14FCA0: using guessed type char *off_14FCA0[3];

//----- (0006F424) --------------------------------------------------------
int __fastcall sub_6F424(const char *a1)
{
  int i; // [sp+Ch] [bp-8h]

  for ( i = 0; strcmp(a1, off_14FC00[i]); ++i )
    ;
  return i;
}
// 14FC00: using guessed type char *off_14FC00[3];

//----- (0006F488) --------------------------------------------------------
int sub_6F488()
{
  dword_1612B8 = 1;
  return 0;
}
// 1612B8: using guessed type int dword_1612B8;

//----- (0006F4E0) --------------------------------------------------------
int sub_6F4E0()
{
  char v2[8]; // [sp+14h] [bp-1008h] BYREF
  size_t nmemb; // [sp+1014h] [bp-8h]

  nmemb = dword_161240;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "chain_num %d", nmemb);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/topol/topol.c",
    159,
    "_alloc_chain",
    12,
    81,
    20,
    v2);
  dword_161260 = (int)calloc(nmemb, 0x78u);
  if ( dword_161260 )
    return 0;
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "malloc %d chain_t failed", nmemb);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/topol/topol.c",
    159,
    "_alloc_chain",
    12,
    86,
    100,
    v2);
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "Sweep error string = %s.", "M:1");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/topol/topol.c",
    159,
    "_alloc_chain",
    12,
    87,
    100,
    v2);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161240: using guessed type int dword_161240;
// 161260: using guessed type int dword_161260;

//----- (0006F6C8) --------------------------------------------------------
int sub_6F6C8()
{
  int v0; // r4
  char v3[16]; // [sp+14h] [bp-1010h] BYREF
  size_t nmemb; // [sp+1014h] [bp-10h]

  nmemb = *(_DWORD *)(dword_161260 + 92);
  v0 = dword_161260;
  *(_DWORD *)(v0 + 84) = calloc(nmemb, 0x18u);
  if ( *(_DWORD *)(dword_161260 + 84) )
    return 0;
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "calloc sensor failed!");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/topol/topol.c",
    159,
    "_alloc_sensor",
    13,
    98,
    100,
    v3);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161260: using guessed type int dword_161260;

//----- (0006F7B4) --------------------------------------------------------
void *sub_6F7B4()
{
  void *result; // r0
  int v1; // [sp+0h] [bp-Ch]
  int i; // [sp+4h] [bp-8h]

  v1 = dword_161240;
  for ( i = 1; i < v1; ++i )
    result = memcpy((void *)(dword_161260 + 120 * i), (const void *)dword_161260, 0x78u);
  return result;
}
// 161240: using guessed type int dword_161240;
// 161260: using guessed type int dword_161260;

//----- (0006F838) --------------------------------------------------------
void sub_6F838()
{
  ;
}

//----- (0006F850) --------------------------------------------------------
int __fastcall sub_6F850(const json_t *a1)
{
  const char *v2; // r0
  size_t v3; // r0
  const char *v4; // r0
  const char *v5; // r0
  char v8[12]; // [sp+18h] [bp-100Ch] BYREF
  char *s; // [sp+1018h] [bp-Ch]
  const json_t *v10; // [sp+101Ch] [bp-8h]

  v10 = json_object_get(a1, "machine");
  if ( v10 && *(_DWORD *)v10 == 2 )
  {
    V_LOCK();
    v2 = json_string_value(v10);
    logfmt_raw(v8, 0x1000u, 0, "load machine %s conf", v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_machine",
      14,
      143,
      20,
      v8);
    s = (char *)json_string_value(v10);
    v3 = strlen(s);
    topol_machine = (int)calloc(v3 + 1, 1u);
    if ( topol_machine )
    {
      strcpy((char *)topol_machine, s);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "machine : %s ", topol_machine);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_machine",
        14,
        154,
        20,
        v8);
      v10 = json_object_get(a1, "hw_version");
      if ( v10 && *(_DWORD *)v10 == 2 )
      {
        V_LOCK();
        v4 = json_string_value(v10);
        logfmt_raw(v8, 0x1000u, 0, "hw_version: %s", v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_machine",
          14,
          162,
          20,
          v8);
        v10 = json_object_get(a1, "sw_version");
        if ( v10 && *(_DWORD *)v10 == 2 )
        {
          V_LOCK();
          v5 = json_string_value(v10);
          logfmt_raw(v8, 0x1000u, 0, "sw_version: %s", v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_machine",
            14,
            170,
            20,
            v8);
          return 0;
        }
        else
        {
          V_LOCK();
          logfmt_raw(v8, 0x1000u, 0, "get sw_version failed");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_machine",
            14,
            167,
            100,
            v8);
          return -1;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, "get hw_version failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_machine",
          14,
          159,
          100,
          v8);
        return -1;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "get machine failed, Cannot allocate space");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_machine",
        14,
        149,
        100,
        v8);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "get machine failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_machine",
      14,
      140,
      100,
      v8);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 16123C: using guessed type int topol_machine;

//----- (0006FD8C) --------------------------------------------------------
int __fastcall sub_6FD8C(const json_t *a1)
{
  const char *v2; // r0
  char v4[12]; // [sp+18h] [bp-100Ch] BYREF
  const json_t *v5; // [sp+1018h] [bp-Ch]
  const json_t *v6; // [sp+101Ch] [bp-8h]

  v5 = json_object_get(a1, "processor");
  if ( v5 && !*(_DWORD *)v5 )
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "processor:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_processor",
      16,
      185,
      20,
      v4);
    v6 = json_object_get(v5, "type");
    if ( v6 && *(_DWORD *)v6 == 2 )
    {
      V_LOCK();
      v2 = json_string_value(v6);
      logfmt_raw(v4, 0x1000u, 0, "type: %s", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_processor",
        16,
        193,
        20,
        v4);
      return 0;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "get type failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_processor",
        16,
        190,
        100,
        v4);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "get processor failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_processor",
      16,
      182,
      100,
      v4);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00070010) --------------------------------------------------------
int __fastcall sub_70010(const json_t *a1)
{
  const char *v2; // r0
  json_t *v3; // r0
  __int16 v4; // r0
  const char *v5; // r3
  bool v6; // r3
  const char *v7; // r3
  bool v8; // r3
  int v9; // r0
  int v10; // r0
  int v11; // r0
  char v13[16]; // [sp+1Ch] [bp-1010h] BYREF
  const json_t *v14; // [sp+101Ch] [bp-10h]
  signed int i; // [sp+1020h] [bp-Ch]
  const json_t *v16; // [sp+1024h] [bp-8h]

  v14 = json_object_get(a1, "power");
  if ( v14 && !*(_DWORD *)v14 )
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "power:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_power",
      12,
      208,
      20,
      v13);
    v16 = json_object_get(v14, "type");
    if ( v16 && *(_DWORD *)v16 == 2 )
    {
      V_LOCK();
      v2 = json_string_value(v16);
      logfmt_raw(v13, 0x1000u, 0, "type: %s", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_power",
        12,
        216,
        20,
        v13);
      v16 = json_object_get(v14, "version");
      if ( v16 && *(_DWORD *)v16 == 1 )
      {
        dword_16129C = json_array_size(v16);
        dword_1612B4 = (int)calloc(dword_16129C, 2u);
        for ( i = 0; i < dword_16129C; ++i )
        {
          v3 = json_array_get(v16, i);
          v4 = json_integer_value((int)v3);
          *(_WORD *)(dword_1612B4 + 2 * i) = v4;
          V_LOCK();
          logfmt_raw(v13, 0x1000u, 0, "psu version = 0x%x", *(unsigned __int16 *)(dword_1612B4 + 2 * i));
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_power",
            12,
            228,
            20,
            v13);
        }
        v16 = json_object_get(v14, "is_adjustable_power");
        if ( v16 && *(_DWORD *)v16 == 5 || v16 && *(_DWORD *)v16 == 6 )
        {
          V_LOCK();
          if ( v16 && *(_DWORD *)v16 == 5 )
            v5 = "true";
          else
            v5 = "false";
          logfmt_raw(v13, 0x1000u, 0, "is_adjustable_power: %s", v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_power",
            12,
            237,
            20,
            v13);
          v6 = v16 && *(_DWORD *)v16 == 5;
          byte_1612A0 = v6;
          v16 = json_object_get(v14, "check_asic_voltage_enable");
          if ( v16 && *(_DWORD *)v16 == 5 || v16 && *(_DWORD *)v16 == 6 )
          {
            V_LOCK();
            if ( v16 && *(_DWORD *)v16 == 5 )
              v7 = "true";
            else
              v7 = "false";
            logfmt_raw(v13, 0x1000u, 0, "check_asic_voltage_enable: %s", v7);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/topol/topol.c",
              159,
              "_parse_power",
              12,
              246,
              20,
              v13);
            v8 = v16 && *(_DWORD *)v16 == 5;
            byte_1612A1 = v8;
            v16 = json_object_get(v14, "check_asic_voltage");
            if ( v16 && *(_DWORD *)v16 == 3 )
            {
              V_LOCK();
              v9 = json_integer_value((int)v16);
              logfmt_raw(v13, 0x1000u, 0, "check_asic_voltage: %d", v9);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/topol/topol.c",
                159,
                "_parse_power",
                12,
                255,
                20,
                v13);
              dword_1612A4 = json_integer_value((int)v16);
              v16 = json_object_get(v14, "i2c_addr");
              if ( v16 && *(_DWORD *)v16 == 3 )
              {
                V_LOCK();
                v10 = json_integer_value((int)v16);
                logfmt_raw(v13, 0x1000u, 0, "i2c_addr: %d", v10);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/backend/topol/topol.c",
                  159,
                  "_parse_power",
                  12,
                  264,
                  20,
                  v13);
                dword_1612A8 = json_integer_value((int)v16);
                v16 = json_object_get(v14, "gpio");
                if ( v16 && *(_DWORD *)v16 == 3 )
                {
                  V_LOCK();
                  v11 = json_integer_value((int)v16);
                  logfmt_raw(v13, 0x1000u, 0, "gpio: %d", v11);
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/b"
                    "uild/godminer-origin_godminer-branch1/backend/topol/topol.c",
                    159,
                    "_parse_power",
                    12,
                    273,
                    20,
                    v13);
                  dword_1612AC = json_integer_value((int)v16);
                  return 0;
                }
                else
                {
                  V_LOCK();
                  logfmt_raw(v13, 0x1000u, 0, "get gpio failed");
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/b"
                    "uild/godminer-origin_godminer-branch1/backend/topol/topol.c",
                    159,
                    "_parse_power",
                    12,
                    270,
                    100,
                    v13);
                  return -1;
                }
              }
              else
              {
                V_LOCK();
                logfmt_raw(v13, 0x1000u, 0, "get i2c_addr failed");
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/backend/topol/topol.c",
                  159,
                  "_parse_power",
                  12,
                  261,
                  100,
                  v13);
                return -1;
              }
            }
            else
            {
              V_LOCK();
              logfmt_raw(v13, 0x1000u, 0, "get check_asic_voltage failed!");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/topol/topol.c",
                159,
                "_parse_power",
                12,
                252,
                100,
                v13);
              return -1;
            }
          }
          else
          {
            V_LOCK();
            logfmt_raw(v13, 0x1000u, 0, "get check_asic_voltage_enable failed!");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/topol/topol.c",
              159,
              "_parse_power",
              12,
              243,
              100,
              v13);
            return -1;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v13, 0x1000u, 0, "get is_adjustable_power failed!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_power",
            12,
            234,
            100,
            v13);
          return -1;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v13, 0x1000u, 0, "get version array failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_power",
          12,
          221,
          100,
          v13);
        return -1;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "get type failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_power",
        12,
        213,
        100,
        v13);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "get power failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_power",
      12,
      205,
      100,
      v13);
    return -1;
  }
}
// 70620: masking with 0x1 was optimized away because r3.1 <= 0x1
// 707CC: masking with 0x1 was optimized away because r3.1 <= 0x1
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 16129C: using guessed type int dword_16129C;
// 1612A0: using guessed type char byte_1612A0;
// 1612A1: using guessed type char byte_1612A1;
// 1612A4: using guessed type int dword_1612A4;
// 1612A8: using guessed type int dword_1612A8;
// 1612AC: using guessed type int dword_1612AC;
// 1612B4: using guessed type int dword_1612B4;

//----- (00070BDC) --------------------------------------------------------
int __fastcall sub_70BDC(const json_t *a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  __int64 v12; // r0
  double v13; // r0
  float v14; // s15
  int v15; // r0
  __int64 v16; // r0
  double v17; // r0
  float v18; // s15
  int v19; // r0
  __int64 v20; // r0
  double v21; // r0
  float v22; // s15
  int v23; // r0
  __int64 v24; // r0
  double v25; // r0
  float v26; // s15
  int v27; // r0
  int v28; // r0
  int v29; // r0
  int v30; // r0
  int v31; // r0
  int v32; // r0
  size_t v33; // r0
  char v35[40]; // [sp+1Ch] [bp-1028h] BYREF
  int v36; // [sp+101Ch] [bp-28h]
  int v37; // [sp+1020h] [bp-24h]
  const json_t *v38; // [sp+1024h] [bp-20h]
  size_t nmemb; // [sp+1028h] [bp-1Ch]
  size_t i; // [sp+102Ch] [bp-18h]
  const json_t *v41; // [sp+1030h] [bp-14h]
  json_t *v42; // [sp+1034h] [bp-10h]

  v36 = 0;
  v37 = 0;
  v41 = json_object_get(a1, "fan");
  if ( v41 && !*(_DWORD *)v41 )
  {
    v42 = json_object_get(v41, "fan_control_mode");
    if ( v42 && *(_DWORD *)v42 == 3 )
    {
      V_LOCK();
      v2 = json_integer_value((int)v42);
      logfmt_raw(v35, 0x1000u, 0, "fan_control_mode: %d", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_fan",
        10,
        298,
        20,
        v35);
      dword_161264 = json_integer_value((int)v42);
      v42 = json_object_get(v41, "pwm_percent_min");
      if ( v42 && *(_DWORD *)v42 == 3 )
      {
        V_LOCK();
        v3 = json_integer_value((int)v42);
        logfmt_raw(v35, 0x1000u, 0, "pwm_percent_min: %d", v3);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_fan",
          10,
          307,
          20,
          v35);
        dword_161268 = json_integer_value((int)v42);
        v42 = json_object_get(v41, "pwm_percent_max");
        if ( v42 && *(_DWORD *)v42 == 3 )
        {
          V_LOCK();
          v4 = json_integer_value((int)v42);
          logfmt_raw(v35, 0x1000u, 0, "pwm_percent_max: %d", v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_fan",
            10,
            316,
            20,
            v35);
          dword_16126C = json_integer_value((int)v42);
          v42 = json_object_get(v41, "full_speed_temp_type");
          if ( v42 && *(_DWORD *)v42 == 3 )
          {
            V_LOCK();
            v5 = json_integer_value((int)v42);
            logfmt_raw(v35, 0x1000u, 0, "full_speed_temp_type: %d", v5);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/topol/topol.c",
              159,
              "_parse_fan",
              10,
              325,
              20,
              v35);
            dword_161270 = json_integer_value((int)v42);
            v42 = json_object_get(v41, "full_speed_temp");
            if ( v42 && *(_DWORD *)v42 == 3 )
            {
              V_LOCK();
              v6 = json_integer_value((int)v42);
              logfmt_raw(v35, 0x1000u, 0, "full_speed_temp: %d", v6);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/topol/topol.c",
                159,
                "_parse_fan",
                10,
                334,
                20,
                v35);
              dword_161274 = json_integer_value((int)v42);
              v42 = json_object_get(v41, "target_temp_type");
              if ( v42 && *(_DWORD *)v42 == 3 )
              {
                V_LOCK();
                v7 = json_integer_value((int)v42);
                logfmt_raw(v35, 0x1000u, 0, "target_temp_type: %d", v7);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/backend/topol/topol.c",
                  159,
                  "_parse_fan",
                  10,
                  343,
                  20,
                  v35);
                dword_161278 = json_integer_value((int)v42);
                v42 = json_object_get(v41, "target_temp");
                if ( v42 && *(_DWORD *)v42 == 3 )
                {
                  V_LOCK();
                  v8 = json_integer_value((int)v42);
                  logfmt_raw(v35, 0x1000u, 0, "target_temp: %d", v8);
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/b"
                    "uild/godminer-origin_godminer-branch1/backend/topol/topol.c",
                    159,
                    "_parse_fan",
                    10,
                    352,
                    20,
                    v35);
                  dword_16127C = json_integer_value((int)v42);
                  v42 = json_object_get(v41, "initial_interval");
                  if ( v42 && *(_DWORD *)v42 == 3 )
                  {
                    V_LOCK();
                    v9 = json_integer_value((int)v42);
                    logfmt_raw(v35, 0x1000u, 0, "initial_interval: %d", v9);
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release"
                      "/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                      159,
                      "_parse_fan",
                      10,
                      361,
                      20,
                      v35);
                    dword_161280 = json_integer_value((int)v42);
                    v42 = json_object_get(v41, "interval");
                    if ( v42 && *(_DWORD *)v42 == 3 )
                    {
                      V_LOCK();
                      v10 = json_integer_value((int)v42);
                      logfmt_raw(v35, 0x1000u, 0, "interval: %d", v10);
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/relea"
                        "se/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                        159,
                        "_parse_fan",
                        10,
                        370,
                        20,
                        v35);
                      dword_161284 = json_integer_value((int)v42);
                      v42 = json_object_get(v41, "startup_Kp");
                      if ( v42 && *(_DWORD *)v42 == 3 )
                      {
                        V_LOCK();
                        v11 = json_integer_value((int)v42);
                        logfmt_raw(v35, 0x1000u, 0, "startup_Kp: %d", v11);
                        V_UNLOCK();
                        zlog(
                          g_zc,
                          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rel"
                          "ease/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                          159,
                          "_parse_fan",
                          10,
                          379,
                          20,
                          v35);
                        v12 = json_integer_value((int)v42);
                        LODWORD(v13) = sub_CCAE4(v12);
                        v14 = v13 / 100.0;
                        flt_161288 = v14;
                        v42 = json_object_get(v41, "Kp");
                        if ( v42 && *(_DWORD *)v42 == 3 )
                        {
                          V_LOCK();
                          v15 = json_integer_value((int)v42);
                          logfmt_raw(v35, 0x1000u, 0, "Kp: %d", v15);
                          V_UNLOCK();
                          zlog(
                            g_zc,
                            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/r"
                            "elease/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                            159,
                            "_parse_fan",
                            10,
                            388,
                            20,
                            v35);
                          v16 = json_integer_value((int)v42);
                          LODWORD(v17) = sub_CCAE4(v16);
                          v18 = v17 / 100.0;
                          flt_16128C = v18;
                          v42 = json_object_get(v41, "Ki");
                          if ( v42 && *(_DWORD *)v42 == 3 )
                          {
                            V_LOCK();
                            v19 = json_integer_value((int)v42);
                            logfmt_raw(v35, 0x1000u, 0, "Ki: %d", v19);
                            V_UNLOCK();
                            zlog(
                              g_zc,
                              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp"
                              "/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                              159,
                              "_parse_fan",
                              10,
                              397,
                              20,
                              v35);
                            v20 = json_integer_value((int)v42);
                            LODWORD(v21) = sub_CCAE4(v20);
                            v22 = v21 / 100.0;
                            flt_161290 = v22;
                            v42 = json_object_get(v41, "Kd");
                            if ( v42 && *(_DWORD *)v42 == 3 )
                            {
                              V_LOCK();
                              v23 = json_integer_value((int)v42);
                              logfmt_raw(v35, 0x1000u, 0, "Kd: %d", v23);
                              V_UNLOCK();
                              zlog(
                                g_zc,
                                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/t"
                                "mp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                159,
                                "_parse_fan",
                                10,
                                406,
                                20,
                                v35);
                              v24 = json_integer_value((int)v42);
                              LODWORD(v25) = sub_CCAE4(v24);
                              v26 = v25 / 100.0;
                              flt_161294 = v26;
                              v38 = json_object_get(v41, "speed_info");
                              if ( v38 && *(_DWORD *)v38 == 1 )
                              {
                                V_LOCK();
                                logfmt_raw(v35, 0x1000u, 0, "fan speed_info info:");
                                V_UNLOCK();
                                zlog(
                                  g_zc,
                                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot"
                                  "/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                  159,
                                  "_parse_fan",
                                  10,
                                  415,
                                  20,
                                  v35);
                                nmemb = json_array_size(v38);
                                dword_161298 = (int)calloc(nmemb, 0xCu);
                                if ( dword_161298 )
                                {
                                  for ( i = 0; ; ++i )
                                  {
                                    v33 = json_array_size(v38);
                                    if ( v33 <= i )
                                      break;
                                    v41 = json_array_get(v38, i);
                                    if ( !v41 || *(_DWORD *)v41 )
                                    {
                                      V_LOCK();
                                      logfmt_raw(v35, 0x1000u, 0, "get array %d failed", i);
                                      V_UNLOCK();
                                      zlog(
                                        g_zc,
                                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/bui"
                                        "ldroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                        159,
                                        "_parse_fan",
                                        10,
                                        429,
                                        100,
                                        v35);
                                      return -1;
                                    }
                                    v42 = json_object_get(v41, "id");
                                    if ( !v42 || *(_DWORD *)v42 != 3 )
                                    {
                                      V_LOCK();
                                      logfmt_raw(v35, 0x1000u, 0, "get array %d id failed", i);
                                      V_UNLOCK();
                                      zlog(
                                        g_zc,
                                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/bui"
                                        "ldroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                        159,
                                        "_parse_fan",
                                        10,
                                        436,
                                        100,
                                        v35);
                                      return -1;
                                    }
                                    V_LOCK();
                                    v27 = json_integer_value((int)v42);
                                    logfmt_raw(v35, 0x1000u, 0, "id: %d", v27);
                                    V_UNLOCK();
                                    zlog(
                                      g_zc,
                                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/build"
                                      "root/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                      159,
                                      "_parse_fan",
                                      10,
                                      439,
                                      20,
                                      v35);
                                    v28 = json_integer_value((int)v42);
                                    *(_DWORD *)(dword_161298 + 12 * i) = v28;
                                    v42 = json_object_get(v41, "max_speed");
                                    if ( !v42 || *(_DWORD *)v42 != 3 )
                                    {
                                      V_LOCK();
                                      logfmt_raw(v35, 0x1000u, 0, "get array %d max_speed failed", i);
                                      V_UNLOCK();
                                      zlog(
                                        g_zc,
                                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/bui"
                                        "ldroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                        159,
                                        "_parse_fan",
                                        10,
                                        445,
                                        100,
                                        v35);
                                      return -1;
                                    }
                                    V_LOCK();
                                    v29 = json_integer_value((int)v42);
                                    logfmt_raw(v35, 0x1000u, 0, "max_speed: %d", v29);
                                    V_UNLOCK();
                                    zlog(
                                      g_zc,
                                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/build"
                                      "root/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                      159,
                                      "_parse_fan",
                                      10,
                                      448,
                                      20,
                                      v35);
                                    v30 = json_integer_value((int)v42);
                                    *(_DWORD *)(dword_161298 + 12 * i + 8) = v30;
                                    v42 = json_object_get(v41, "min_speed");
                                    if ( !v42 || *(_DWORD *)v42 != 3 )
                                    {
                                      V_LOCK();
                                      logfmt_raw(v35, 0x1000u, 0, "get array %d min_speed failed", i);
                                      V_UNLOCK();
                                      zlog(
                                        g_zc,
                                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/bui"
                                        "ldroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                        159,
                                        "_parse_fan",
                                        10,
                                        454,
                                        100,
                                        v35);
                                      return -1;
                                    }
                                    V_LOCK();
                                    v31 = json_integer_value((int)v42);
                                    logfmt_raw(v35, 0x1000u, 0, "min_speed: %d", v31);
                                    V_UNLOCK();
                                    zlog(
                                      g_zc,
                                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/build"
                                      "root/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                      159,
                                      "_parse_fan",
                                      10,
                                      457,
                                      20,
                                      v35);
                                    v32 = json_integer_value((int)v42);
                                    *(_DWORD *)(dword_161298 + 12 * i + 4) = v32;
                                    ++dword_16125C;
                                  }
                                  return 0;
                                }
                                else
                                {
                                  V_LOCK();
                                  logfmt_raw(v35, 0x1000u, 0, "calloc topol_machine.fan_info.speeds failed!");
                                  V_UNLOCK();
                                  zlog(
                                    g_zc,
                                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildro"
                                    "ot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                    159,
                                    "_parse_fan",
                                    10,
                                    420,
                                    100,
                                    v35);
                                  return -1;
                                }
                              }
                              else
                              {
                                V_LOCK();
                                logfmt_raw(v35, 0x1000u, 0, "get fan speed_info failed");
                                V_UNLOCK();
                                zlog(
                                  g_zc,
                                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot"
                                  "/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                  159,
                                  "_parse_fan",
                                  10,
                                  412,
                                  100,
                                  v35);
                                return -1;
                              }
                            }
                            else
                            {
                              V_LOCK();
                              logfmt_raw(v35, 0x1000u, 0, "get Kd failed!");
                              V_UNLOCK();
                              zlog(
                                g_zc,
                                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/t"
                                "mp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                159,
                                "_parse_fan",
                                10,
                                403,
                                100,
                                v35);
                              return -1;
                            }
                          }
                          else
                          {
                            V_LOCK();
                            logfmt_raw(v35, 0x1000u, 0, "get Ki failed!");
                            V_UNLOCK();
                            zlog(
                              g_zc,
                              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp"
                              "/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                              159,
                              "_parse_fan",
                              10,
                              394,
                              100,
                              v35);
                            return -1;
                          }
                        }
                        else
                        {
                          V_LOCK();
                          logfmt_raw(v35, 0x1000u, 0, "get Kp failed!");
                          V_UNLOCK();
                          zlog(
                            g_zc,
                            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/r"
                            "elease/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                            159,
                            "_parse_fan",
                            10,
                            385,
                            100,
                            v35);
                          return -1;
                        }
                      }
                      else
                      {
                        V_LOCK();
                        logfmt_raw(v35, 0x1000u, 0, "get startup_Kp failed!");
                        V_UNLOCK();
                        zlog(
                          g_zc,
                          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rel"
                          "ease/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                          159,
                          "_parse_fan",
                          10,
                          376,
                          100,
                          v35);
                        return -1;
                      }
                    }
                    else
                    {
                      V_LOCK();
                      logfmt_raw(v35, 0x1000u, 0, "get interval failed!");
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/relea"
                        "se/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                        159,
                        "_parse_fan",
                        10,
                        367,
                        100,
                        v35);
                      return -1;
                    }
                  }
                  else
                  {
                    V_LOCK();
                    logfmt_raw(v35, 0x1000u, 0, "get initial_interval failed!");
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release"
                      "/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                      159,
                      "_parse_fan",
                      10,
                      358,
                      100,
                      v35);
                    return -1;
                  }
                }
                else
                {
                  V_LOCK();
                  logfmt_raw(v35, 0x1000u, 0, "get target_temp failed!");
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/b"
                    "uild/godminer-origin_godminer-branch1/backend/topol/topol.c",
                    159,
                    "_parse_fan",
                    10,
                    349,
                    100,
                    v35);
                  return -1;
                }
              }
              else
              {
                V_LOCK();
                logfmt_raw(v35, 0x1000u, 0, "get target_temp_type failed!");
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/backend/topol/topol.c",
                  159,
                  "_parse_fan",
                  10,
                  340,
                  100,
                  v35);
                return -1;
              }
            }
            else
            {
              V_LOCK();
              logfmt_raw(v35, 0x1000u, 0, "get full_speed_temp failed!");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/topol/topol.c",
                159,
                "_parse_fan",
                10,
                331,
                100,
                v35);
              return -1;
            }
          }
          else
          {
            V_LOCK();
            logfmt_raw(v35, 0x1000u, 0, "get full_speed_temp_type failed!");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/topol/topol.c",
              159,
              "_parse_fan",
              10,
              322,
              100,
              v35);
            return -1;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v35, 0x1000u, 0, "get pwm_percent_max failed!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_fan",
            10,
            313,
            100,
            v35);
          return -1;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v35, 0x1000u, 0, "get pwm_percent_min failed!");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_fan",
          10,
          304,
          100,
          v35);
        return -1;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v35, 0x1000u, 0, "get fan_control_mode failed!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_fan",
        10,
        295,
        100,
        v35);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v35, 0x1000u, 0, "get fan failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_fan",
      10,
      288,
      100,
      v35);
    return -1;
  }
}
// 71A0C: variable 'v13' is possibly undefined
// 71B7C: variable 'v17' is possibly undefined
// 71CEC: variable 'v21' is possibly undefined
// 71E68: variable 'v25' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 16125C: using guessed type int dword_16125C;
// 161264: using guessed type int dword_161264;
// 161268: using guessed type int dword_161268;
// 16126C: using guessed type int dword_16126C;
// 161270: using guessed type int dword_161270;
// 161274: using guessed type int dword_161274;
// 161278: using guessed type int dword_161278;
// 16127C: using guessed type int dword_16127C;
// 161280: using guessed type int dword_161280;
// 161284: using guessed type int dword_161284;
// 161288: using guessed type float flt_161288;
// 16128C: using guessed type float flt_16128C;
// 161290: using guessed type float flt_161290;
// 161294: using guessed type float flt_161294;
// 161298: using guessed type int dword_161298;

//----- (000725CC) --------------------------------------------------------
int __fastcall sub_725CC(const json_t *a1)
{
  const char *v2; // r0
  const char *v3; // r0
  const char *v4; // r0
  int v5; // r4
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  char v13[20]; // [sp+18h] [bp-1014h] BYREF
  const json_t *v14; // [sp+1018h] [bp-14h]
  const json_t *v15; // [sp+101Ch] [bp-10h]

  v14 = json_object_get(a1, "asic");
  if ( v14 && !*(_DWORD *)v14 )
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "asic:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_asic",
      11,
      476,
      20,
      v13);
    v15 = json_object_get(v14, "asic_id");
    if ( v15 && *(_DWORD *)v15 == 2 )
    {
      V_LOCK();
      v2 = json_string_value(v15);
      logfmt_raw(v13, 0x1000u, 0, "asic_id: %s", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_asic",
        11,
        484,
        20,
        v13);
      v15 = json_object_get(v14, "chip_type");
      if ( v15 && *(_DWORD *)v15 == 2 )
      {
        V_LOCK();
        v3 = json_string_value(v15);
        logfmt_raw(v13, 0x1000u, 0, "chip_type : %s", v3);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_asic",
          11,
          492,
          20,
          v13);
        v4 = json_string_value(v15);
        v5 = dword_161260;
        *(_DWORD *)(v5 + 24) = strtol(v4, 0, 0);
        if ( *(_DWORD *)(dword_161260 + 24) )
        {
          V_LOCK();
          logfmt_raw(v13, 0x1000u, 0, "chip_type 0x%x", *(_DWORD *)(dword_161260 + 24));
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_asic",
            11,
            500,
            20,
            v13);
          v15 = json_object_get(v14, "cycle_cnt");
          if ( v15 && *(_DWORD *)v15 == 3 )
          {
            V_LOCK();
            v6 = json_integer_value((int)v15);
            logfmt_raw(v13, 0x1000u, 0, "cycle_cnt : %d", v6);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/topol/topol.c",
              159,
              "_parse_asic",
              11,
              508,
              20,
              v13);
            *(_DWORD *)(dword_161260 + 28) = json_integer_value((int)v15);
            v15 = json_object_get(v14, "asic_big_core_num");
            if ( v15 && *(_DWORD *)v15 == 3 )
            {
              V_LOCK();
              v7 = json_integer_value((int)v15);
              logfmt_raw(v13, 0x1000u, 0, "asic_big_core_num: %d", v7);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/topol/topol.c",
                159,
                "_parse_asic",
                11,
                517,
                20,
                v13);
              *(_DWORD *)(dword_161260 + 36) = json_integer_value((int)v15);
              v15 = json_object_get(v14, "asic_little_core_num");
              if ( v15 && *(_DWORD *)v15 == 3 )
              {
                V_LOCK();
                v8 = json_integer_value((int)v15);
                logfmt_raw(v13, 0x1000u, 0, "asic_little_core_num %d", v8);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/backend/topol/topol.c",
                  159,
                  "_parse_asic",
                  11,
                  526,
                  20,
                  v13);
                *(_DWORD *)(dword_161260 + 40) = json_integer_value((int)v15);
                v15 = json_object_get(v14, "core_little_core_num");
                if ( v15 && *(_DWORD *)v15 == 3 )
                {
                  V_LOCK();
                  v9 = json_integer_value((int)v15);
                  logfmt_raw(v13, 0x1000u, 0, "core_little_core_num: %d", v9);
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/b"
                    "uild/godminer-origin_godminer-branch1/backend/topol/topol.c",
                    159,
                    "_parse_asic",
                    11,
                    535,
                    20,
                    v13);
                  *(_DWORD *)(dword_161260 + 44) = json_integer_value((int)v15);
                  v15 = json_object_get(v14, "asic_domain_num");
                  if ( v15 && *(_DWORD *)v15 == 3 )
                  {
                    V_LOCK();
                    v10 = json_integer_value((int)v15);
                    logfmt_raw(v13, 0x1000u, 0, "asic_domain_num : %d", v10);
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release"
                      "/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                      159,
                      "_parse_asic",
                      11,
                      544,
                      20,
                      v13);
                    *(_DWORD *)(dword_161260 + 48) = json_integer_value((int)v15);
                    v15 = json_object_get(v14, "asic_addr_interval");
                    if ( v15 && *(_DWORD *)v15 == 3 )
                    {
                      V_LOCK();
                      v11 = json_integer_value((int)v15);
                      logfmt_raw(v13, 0x1000u, 0, "asic_addr_interval : %d", v11);
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/relea"
                        "se/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                        159,
                        "_parse_asic",
                        11,
                        553,
                        20,
                        v13);
                      *(_DWORD *)(dword_161260 + 52) = json_integer_value((int)v15);
                      return 0;
                    }
                    else
                    {
                      V_LOCK();
                      logfmt_raw(v13, 0x1000u, 0, "get asic_addr_interval failed");
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/relea"
                        "se/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                        159,
                        "_parse_asic",
                        11,
                        550,
                        100,
                        v13);
                      return -1;
                    }
                  }
                  else
                  {
                    V_LOCK();
                    logfmt_raw(v13, 0x1000u, 0, "get asic_domain_num failed");
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release"
                      "/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                      159,
                      "_parse_asic",
                      11,
                      541,
                      100,
                      v13);
                    return -1;
                  }
                }
                else
                {
                  V_LOCK();
                  logfmt_raw(v13, 0x1000u, 0, "get core_little_core_num failed");
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/b"
                    "uild/godminer-origin_godminer-branch1/backend/topol/topol.c",
                    159,
                    "_parse_asic",
                    11,
                    532,
                    100,
                    v13);
                  return -1;
                }
              }
              else
              {
                V_LOCK();
                logfmt_raw(v13, 0x1000u, 0, "get asic_little_core_num failed");
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/backend/topol/topol.c",
                  159,
                  "_parse_asic",
                  11,
                  523,
                  100,
                  v13);
                return -1;
              }
            }
            else
            {
              V_LOCK();
              logfmt_raw(v13, 0x1000u, 0, "get asic_big_core_num failed");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/topol/topol.c",
                159,
                "_parse_asic",
                11,
                514,
                100,
                v13);
              return -1;
            }
          }
          else
          {
            V_LOCK();
            logfmt_raw(v13, 0x1000u, 0, "get cycle_cnt failed");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/topol/topol.c",
              159,
              "_parse_asic",
              11,
              505,
              100,
              v13);
            return -1;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v13, 0x1000u, 0, "convert chip_type failed");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_asic",
            11,
            497,
            100,
            v13);
          return -1;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v13, 0x1000u, 0, "get chip_type failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_asic",
          11,
          489,
          100,
          v13);
        return -1;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "get asic_id failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_asic",
        11,
        481,
        100,
        v13);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "get asic failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_asic",
      11,
      473,
      100,
      v13);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161260: using guessed type int dword_161260;

//----- (000732BC) --------------------------------------------------------
int __fastcall sub_732BC(const json_t *a1)
{
  int v2; // r0
  const char *v3; // r0
  const char *v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  int v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  int v13; // r0
  size_t v14; // r0
  char v16[28]; // [sp+18h] [bp-101Ch] BYREF
  const json_t *v17; // [sp+1018h] [bp-1Ch]
  size_t i; // [sp+101Ch] [bp-18h]
  const json_t *v19; // [sp+1020h] [bp-14h]
  int v20; // [sp+1024h] [bp-10h]
  _DWORD *v21; // [sp+1028h] [bp-Ch]
  const json_t *v22; // [sp+102Ch] [bp-8h]

  v17 = json_object_get(a1, "pic_sensor");
  if ( v17 && *(_DWORD *)v17 == 1 )
  {
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "pic sensor:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_pic_sensor",
      23,
      570,
      20,
      v16);
    for ( i = 0; ; ++i )
    {
      v14 = json_array_size(v17);
      if ( v14 <= i )
        break;
      v19 = json_array_get(v17, i);
      if ( !v19 || *(_DWORD *)v19 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_pic_sensor",
          23,
          577,
          100,
          v16);
        return -1;
      }
      v22 = json_object_get(v19, "index");
      if ( !v22 || *(_DWORD *)v22 != 3 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d index failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_pic_sensor",
          23,
          584,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v2 = json_integer_value((int)v22);
      logfmt_raw(v16, 0x1000u, 0, "index: %d", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_pic_sensor",
        23,
        587,
        20,
        v16);
      v20 = json_integer_value((int)v22);
      v21 = (_DWORD *)(*(_DWORD *)(dword_161260 + 84) + 24 * v20);
      *v21 = v20;
      v21[2] = 0;
      v22 = json_object_get(v19, "type");
      if ( !v22 || *(_DWORD *)v22 != 2 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d type failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_pic_sensor",
          23,
          596,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v3 = json_string_value(v22);
      logfmt_raw(v16, 0x1000u, 0, "type: %s", v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_pic_sensor",
        23,
        599,
        20,
        v16);
      v4 = json_string_value(v22);
      v5 = sub_6F2E8(v4);
      v21[1] = v5;
      v22 = json_object_get(v19, "iic");
      if ( !v22 || *(_DWORD *)v22 != 3 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d bind_asic failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_pic_sensor",
          23,
          605,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v6 = json_integer_value((int)v22);
      logfmt_raw(v16, 0x1000u, 0, "iic: %d", v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_pic_sensor",
        23,
        608,
        20,
        v16);
      v7 = json_integer_value((int)v22);
      v21[5] = v7;
      v22 = json_object_get(v19, "x");
      if ( !v22 || *(_DWORD *)v22 != 2 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d x failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_pic_sensor",
          23,
          614,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v8 = json_string_value(v22);
      logfmt_raw(v16, 0x1000u, 0, "x: %s", v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_pic_sensor",
        23,
        617,
        20,
        v16);
      v9 = json_string_value(v22);
      v10 = sub_6F35C(v9);
      v21[3] = v10;
      v22 = json_object_get(v19, "y");
      if ( !v22 || *(_DWORD *)v22 != 2 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d y failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_pic_sensor",
          23,
          623,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v11 = json_string_value(v22);
      logfmt_raw(v16, 0x1000u, 0, "y: %s", v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_pic_sensor",
        23,
        626,
        20,
        v16);
      v12 = json_string_value(v22);
      v13 = sub_6F3C0(v12);
      v21[4] = v13;
    }
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "get pic sensor failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_pic_sensor",
      23,
      567,
      100,
      v16);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161260: using guessed type int dword_161260;

//----- (00073BE8) --------------------------------------------------------
int __fastcall sub_73BE8(const json_t *a1)
{
  int v2; // r0
  const char *v3; // r0
  const char *v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  int v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  int v13; // r0
  size_t v14; // r0
  char v16[28]; // [sp+18h] [bp-101Ch] BYREF
  const json_t *v17; // [sp+1018h] [bp-1Ch]
  size_t i; // [sp+101Ch] [bp-18h]
  const json_t *v19; // [sp+1020h] [bp-14h]
  int v20; // [sp+1024h] [bp-10h]
  _DWORD *v21; // [sp+1028h] [bp-Ch]
  const json_t *v22; // [sp+102Ch] [bp-8h]

  v17 = json_object_get(a1, "ctrlboard_sensor");
  if ( v17 && *(_DWORD *)v17 == 1 )
  {
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "ctrlboard_sensor:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_ctrlboard_sensor",
      29,
      644,
      20,
      v16);
    for ( i = 0; ; ++i )
    {
      v14 = json_array_size(v17);
      if ( v14 <= i )
        break;
      v19 = json_array_get(v17, i);
      if ( !v19 || *(_DWORD *)v19 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_ctrlboard_sensor",
          29,
          651,
          100,
          v16);
        return -1;
      }
      v22 = json_object_get(v19, "index");
      if ( !v22 || *(_DWORD *)v22 != 3 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d index failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_ctrlboard_sensor",
          29,
          658,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v2 = json_integer_value((int)v22);
      logfmt_raw(v16, 0x1000u, 0, "index: %d", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_ctrlboard_sensor",
        29,
        661,
        20,
        v16);
      v20 = json_integer_value((int)v22);
      v21 = (_DWORD *)(*(_DWORD *)(dword_161260 + 84) + 24 * v20);
      *v21 = v20;
      v21[2] = 2;
      v22 = json_object_get(v19, "type");
      if ( !v22 || *(_DWORD *)v22 != 2 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d type failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_ctrlboard_sensor",
          29,
          670,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v3 = json_string_value(v22);
      logfmt_raw(v16, 0x1000u, 0, "type: %s", v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_ctrlboard_sensor",
        29,
        673,
        20,
        v16);
      v4 = json_string_value(v22);
      v5 = sub_6F2E8(v4);
      v21[1] = v5;
      v22 = json_object_get(v19, "iic");
      if ( !v22 || *(_DWORD *)v22 != 3 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d bind_asic failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_ctrlboard_sensor",
          29,
          679,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v6 = json_integer_value((int)v22);
      logfmt_raw(v16, 0x1000u, 0, "iic: %d", v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_ctrlboard_sensor",
        29,
        682,
        20,
        v16);
      v7 = json_integer_value((int)v22);
      v21[5] = v7;
      v22 = json_object_get(v19, "x");
      if ( !v22 || *(_DWORD *)v22 != 2 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d x failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_ctrlboard_sensor",
          29,
          688,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v8 = json_string_value(v22);
      logfmt_raw(v16, 0x1000u, 0, "x: %s", v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_ctrlboard_sensor",
        29,
        691,
        20,
        v16);
      v9 = json_string_value(v22);
      v10 = sub_6F35C(v9);
      v21[3] = v10;
      v22 = json_object_get(v19, "y");
      if ( !v22 || *(_DWORD *)v22 != 2 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d y failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_ctrlboard_sensor",
          29,
          697,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v11 = json_string_value(v22);
      logfmt_raw(v16, 0x1000u, 0, "y: %s", v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_ctrlboard_sensor",
        29,
        700,
        20,
        v16);
      v12 = json_string_value(v22);
      v13 = sub_6F3C0(v12);
      v21[4] = v13;
    }
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "get ctrlboard_sensor sensor failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_ctrlboard_sensor",
      29,
      641,
      100,
      v16);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161260: using guessed type int dword_161260;

//----- (00074514) --------------------------------------------------------
int __fastcall sub_74514(const json_t *a1)
{
  const char *v2; // r0
  int v3; // r0
  int v4; // r0
  char v6[16]; // [sp+1Ch] [bp-1010h] BYREF
  int v7; // [sp+101Ch] [bp-10h]
  const json_t *v8; // [sp+1020h] [bp-Ch]
  const json_t *v9; // [sp+1024h] [bp-8h]

  v7 = 0;
  v8 = json_object_get(a1, "pic");
  if ( v8 && !*(_DWORD *)v8 )
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "pic:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_pic",
      16,
      718,
      20,
      v6);
    v9 = json_object_get(v8, "type");
    if ( v9 && *(_DWORD *)v9 == 2 )
    {
      V_LOCK();
      v2 = json_string_value(v9);
      logfmt_raw(v6, 0x1000u, 0, "type: %s", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_pic",
        16,
        726,
        20,
        v6);
      v9 = json_object_get(v8, "i2c_addr");
      if ( v9 && *(_DWORD *)v9 == 3 )
      {
        V_LOCK();
        v3 = json_integer_value((int)v9);
        logfmt_raw(v6, 0x1000u, 0, "i2c_addr: %d", v3);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_pic",
          16,
          734,
          20,
          v6);
        v9 = json_object_get(v8, "device_high");
        if ( v9 && *(_DWORD *)v9 == 3 )
        {
          V_LOCK();
          v4 = json_integer_value((int)v9);
          logfmt_raw(v6, 0x1000u, 0, "device_high: %d", v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_chain_pic",
            16,
            742,
            20,
            v6);
          *(_DWORD *)(dword_161260 + 64) = json_integer_value((int)v9);
          if ( *(_DWORD *)(dword_161260 + 88) == 1 || *(_DWORD *)(dword_161260 + 88) == 2 )
            return sub_732BC(v8);
          return v7;
        }
        else
        {
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, "get device_high failed");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_chain_pic",
            16,
            739,
            100,
            v6);
          return -1;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, "get i2c_addr failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_pic",
          16,
          731,
          100,
          v6);
        return -1;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "get type failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_pic",
        16,
        723,
        100,
        v6);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "get pic failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_pic",
      16,
      715,
      100,
      v6);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161260: using guessed type int dword_161260;

//----- (00074A68) --------------------------------------------------------
int __fastcall sub_74A68(const json_t *a1)
{
  const char *v2; // r0
  const char *v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  char v8[32]; // [sp+1Ch] [bp-1020h] BYREF
  int j; // [sp+101Ch] [bp-20h]
  int v10; // [sp+1020h] [bp-1Ch]
  const json_t *v11; // [sp+1024h] [bp-18h]
  int i; // [sp+1028h] [bp-14h]
  const json_t *v13; // [sp+102Ch] [bp-10h]

  v10 = dword_161240;
  v11 = json_object_get(a1, "eeprom");
  if ( v11 && !*(_DWORD *)v11 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "eeprom:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_eeprom",
      19,
      764,
      20,
      v8);
    v13 = json_object_get(v11, "type");
    if ( v13 && *(_DWORD *)v13 == 2 )
    {
      V_LOCK();
      v2 = json_string_value(v13);
      logfmt_raw(v8, 0x1000u, 0, "type: %s", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_eeprom",
        19,
        772,
        20,
        v8);
      for ( i = 0; i < v10; ++i )
      {
        v3 = json_string_value(v13);
        v4 = sub_6F424(v3);
        *(_DWORD *)(dword_161260 + 120 * i + 112) = v4;
      }
      v13 = json_object_get(v11, "i2c_addr");
      if ( v13 && *(_DWORD *)v13 == 3 )
      {
        V_LOCK();
        v5 = json_integer_value((int)v13);
        logfmt_raw(v8, 0x1000u, 0, "i2c_addr: %d", v5);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_eeprom",
          19,
          784,
          20,
          v8);
        for ( j = 0; j < v10; ++j )
        {
          v6 = json_integer_value((int)v13);
          *(_DWORD *)(dword_161260 + 120 * j + 116) = v6;
        }
        return 0;
      }
      else
      {
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, "get i2c_addr failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_eeprom",
          19,
          781,
          100,
          v8);
        return -1;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "get type failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_eeprom",
        19,
        769,
        100,
        v8);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "get eeprom failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_eeprom",
      19,
      761,
      100,
      v8);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161240: using guessed type int dword_161240;
// 161260: using guessed type int dword_161260;

//----- (00074EF0) --------------------------------------------------------
int __fastcall sub_74EF0(const json_t *a1)
{
  int v2; // r0
  const char *v3; // r0
  const char *v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  int v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  int v13; // r0
  size_t v14; // r0
  char v16[28]; // [sp+18h] [bp-101Ch] BYREF
  const json_t *v17; // [sp+1018h] [bp-1Ch]
  size_t i; // [sp+101Ch] [bp-18h]
  const json_t *v19; // [sp+1020h] [bp-14h]
  int v20; // [sp+1024h] [bp-10h]
  _DWORD *v21; // [sp+1028h] [bp-Ch]
  const json_t *v22; // [sp+102Ch] [bp-8h]

  v17 = json_object_get(a1, "asic_sensor");
  if ( v17 && *(_DWORD *)v17 == 1 )
  {
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "asic_sensor:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_sensor",
      19,
      803,
      20,
      v16);
    for ( i = 0; ; ++i )
    {
      v14 = json_array_size(v17);
      if ( v14 <= i )
        break;
      v19 = json_array_get(v17, i);
      if ( !v19 || *(_DWORD *)v19 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_sensor",
          19,
          811,
          100,
          v16);
        return -1;
      }
      v22 = json_object_get(v19, "index");
      if ( !v22 || *(_DWORD *)v22 != 3 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d index failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_sensor",
          19,
          818,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v2 = json_integer_value((int)v22);
      logfmt_raw(v16, 0x1000u, 0, "index: %d", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_sensor",
        19,
        821,
        20,
        v16);
      v20 = json_integer_value((int)v22);
      v21 = (_DWORD *)(*(_DWORD *)(dword_161260 + 84) + 24 * v20);
      *v21 = v20;
      v21[2] = 1;
      v22 = json_object_get(v19, "type");
      if ( !v22 || *(_DWORD *)v22 != 2 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d type failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_sensor",
          19,
          830,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v3 = json_string_value(v22);
      logfmt_raw(v16, 0x1000u, 0, "type: %s", v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_sensor",
        19,
        833,
        20,
        v16);
      v4 = json_string_value(v22);
      v5 = sub_6F2E8(v4);
      v21[1] = v5;
      v22 = json_object_get(v19, "bind_asic");
      if ( !v22 || *(_DWORD *)v22 != 3 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d bind_asic failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_sensor",
          19,
          839,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v6 = json_integer_value((int)v22);
      logfmt_raw(v16, 0x1000u, 0, "bind_asic: %d", v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_sensor",
        19,
        842,
        20,
        v16);
      v7 = json_integer_value((int)v22);
      v21[5] = v7;
      v22 = json_object_get(v19, "x");
      if ( !v22 || *(_DWORD *)v22 != 2 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d x failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_sensor",
          19,
          848,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v8 = json_string_value(v22);
      logfmt_raw(v16, 0x1000u, 0, "x: %s", v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_sensor",
        19,
        851,
        20,
        v16);
      v9 = json_string_value(v22);
      v10 = sub_6F35C(v9);
      v21[3] = v10;
      v22 = json_object_get(v19, "y");
      if ( !v22 || *(_DWORD *)v22 != 2 )
      {
        V_LOCK();
        logfmt_raw(v16, 0x1000u, 0, "get array %d y failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_sensor",
          19,
          857,
          100,
          v16);
        return -1;
      }
      V_LOCK();
      v11 = json_string_value(v22);
      logfmt_raw(v16, 0x1000u, 0, "y: %s", v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_sensor",
        19,
        860,
        20,
        v16);
      v12 = json_string_value(v22);
      v13 = sub_6F3C0(v12);
      v21[4] = v13;
    }
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "get sensor failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_sensor",
      19,
      800,
      100,
      v16);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161260: using guessed type int dword_161260;

//----- (0007581C) --------------------------------------------------------
int __fastcall sub_7581C(const json_t *a1)
{
  int v2; // r0
  size_t v3; // r0
  char v5[20]; // [sp+18h] [bp-1014h] BYREF
  const json_t *v6; // [sp+1018h] [bp-14h]
  size_t i; // [sp+101Ch] [bp-10h]
  json_t *v8; // [sp+1020h] [bp-Ch]
  const json_t *v9; // [sp+1024h] [bp-8h]

  v6 = json_object_get(a1, "domain");
  if ( v6 && *(_DWORD *)v6 == 1 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "domain:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_domain",
      19,
      878,
      20,
      v5);
    for ( i = 0; ; ++i )
    {
      v3 = json_array_size(v6);
      if ( v3 <= i )
        break;
      v9 = json_array_get(v6, i);
      if ( !v9 || *(_DWORD *)v9 )
      {
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, "get array %d failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_domain",
          19,
          885,
          100,
          v5);
        return -1;
      }
      v8 = json_object_get(v9, "index");
      if ( !v8 || *(_DWORD *)v8 != 3 )
      {
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, "get array %d index failed", i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "_parse_chain_domain",
          19,
          892,
          100,
          v5);
        return -1;
      }
      V_LOCK();
      v2 = json_integer_value((int)v8);
      logfmt_raw(v5, 0x1000u, 0, "index: %d", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain_domain",
        19,
        895,
        20,
        v5);
    }
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "get domain failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain_domain",
      19,
      875,
      100,
      v5);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00075B94) --------------------------------------------------------
int __fastcall sub_75B94(const json_t *a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  const char *v8; // r3
  bool v9; // r3
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0
  int v15; // r0
  char v17[16]; // [sp+1Ch] [bp-1010h] BYREF
  const json_t *v18; // [sp+101Ch] [bp-10h]
  json_t *v19; // [sp+1020h] [bp-Ch]
  int v20; // [sp+1024h] [bp-8h]

  v18 = json_object_get(a1, "chain");
  if ( v18 && !*(_DWORD *)v18 )
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "chain:");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain",
      12,
      912,
      20,
      v17);
    v19 = json_object_get(v18, "chain_num");
    if ( v19 && *(_DWORD *)v19 == 3 )
    {
      V_LOCK();
      v2 = json_integer_value((int)v19);
      logfmt_raw(v17, 0x1000u, 0, "chain_num : %d", v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain",
        12,
        920,
        20,
        v17);
      dword_161240 = json_integer_value((int)v19);
      v20 = sub_6F4E0();
      if ( v20 )
      {
        return v20;
      }
      else
      {
        v19 = json_object_get(v18, "chain_row");
        if ( v19 && *(_DWORD *)v19 == 3 )
        {
          V_LOCK();
          v3 = json_integer_value((int)v19);
          logfmt_raw(v17, 0x1000u, 0, "chain_row: %d", v3);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_chain",
            12,
            931,
            20,
            v17);
          dword_161244 = json_integer_value((int)v19);
          v19 = json_object_get(v18, "chain_column");
          if ( v19 && *(_DWORD *)v19 == 3 )
          {
            V_LOCK();
            v4 = json_integer_value((int)v19);
            logfmt_raw(v17, 0x1000u, 0, "chain_column: %d", v4);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/topol/topol.c",
              159,
              "_parse_chain",
              12,
              940,
              20,
              v17);
            dword_161248 = json_integer_value((int)v19);
            v19 = json_object_get(v18, "chain_domain_num");
            if ( v19 && *(_DWORD *)v19 == 3 )
            {
              V_LOCK();
              v5 = json_integer_value((int)v19);
              logfmt_raw(v17, 0x1000u, 0, "chain_domain_num : %d", v5);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/topol/topol.c",
                159,
                "_parse_chain",
                12,
                949,
                20,
                v17);
              dword_16124C = json_integer_value((int)v19);
              v19 = json_object_get(v18, "chain_asic_num");
              if ( v19 && *(_DWORD *)v19 == 3 )
              {
                V_LOCK();
                v6 = json_integer_value((int)v19);
                logfmt_raw(v17, 0x1000u, 0, "chain_asic_num : %d", v6);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/backend/topol/topol.c",
                  159,
                  "_parse_chain",
                  12,
                  958,
                  20,
                  v17);
                dword_161250 = json_integer_value((int)v19);
                v19 = json_object_get(v18, "domain_asic_num");
                if ( v19 && *(_DWORD *)v19 == 3 )
                {
                  V_LOCK();
                  v7 = json_integer_value((int)v19);
                  logfmt_raw(v17, 0x1000u, 0, "domain_asic_num : %d", v7);
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/b"
                    "uild/godminer-origin_godminer-branch1/backend/topol/topol.c",
                    159,
                    "_parse_chain",
                    12,
                    967,
                    20,
                    v17);
                  dword_161254 = json_integer_value((int)v19);
                  v19 = json_object_get(v18, "pic_mcu_en");
                  if ( v19 && *(_DWORD *)v19 == 5 || v19 && *(_DWORD *)v19 == 6 )
                  {
                    V_LOCK();
                    if ( v19 && *(_DWORD *)v19 == 5 )
                      v8 = "true";
                    else
                      v8 = "false";
                    logfmt_raw(v17, 0x1000u, 0, "pic_mcu_en: %s", v8);
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release"
                      "/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                      159,
                      "_parse_chain",
                      12,
                      976,
                      20,
                      v17);
                    v9 = v19 && *(_DWORD *)v19 == 5;
                    byte_161258 = v9;
                    v19 = json_object_get(v18, "sensor_mode");
                    if ( v19 && *(_DWORD *)v19 == 3 )
                    {
                      V_LOCK();
                      v10 = json_integer_value((int)v19);
                      logfmt_raw(v17, 0x1000u, 0, "sensor mode : %d", v10);
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/relea"
                        "se/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                        159,
                        "_parse_chain",
                        12,
                        985,
                        20,
                        v17);
                      *(_DWORD *)(dword_161260 + 88) = json_integer_value((int)v19);
                      v19 = json_object_get(v18, "sensor_num");
                      if ( v19 && *(_DWORD *)v19 == 3 )
                      {
                        V_LOCK();
                        v11 = json_integer_value((int)v19);
                        logfmt_raw(v17, 0x1000u, 0, "sensor num : %d", v11);
                        V_UNLOCK();
                        zlog(
                          g_zc,
                          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rel"
                          "ease/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                          159,
                          "_parse_chain",
                          12,
                          994,
                          20,
                          v17);
                        *(_DWORD *)(dword_161260 + 92) = json_integer_value((int)v19);
                        v20 = sub_6F6C8();
                        if ( v20 )
                        {
                          return v20;
                        }
                        else
                        {
                          v19 = json_object_get(v18, "max_chip_temp");
                          if ( v19 && *(_DWORD *)v19 == 3 )
                          {
                            V_LOCK();
                            v12 = json_integer_value((int)v19);
                            logfmt_raw(v17, 0x1000u, 0, "max_chip_temp : %d", v12);
                            V_UNLOCK();
                            zlog(
                              g_zc,
                              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp"
                              "/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                              159,
                              "_parse_chain",
                              12,
                              1005,
                              20,
                              v17);
                            *(_DWORD *)(dword_161260 + 96) = json_integer_value((int)v19);
                            v19 = json_object_get(v18, "max_pcb_temp");
                            if ( v19 && *(_DWORD *)v19 == 3 )
                            {
                              V_LOCK();
                              v13 = json_integer_value((int)v19);
                              logfmt_raw(v17, 0x1000u, 0, "max_pcb_temp : %d", v13);
                              V_UNLOCK();
                              zlog(
                                g_zc,
                                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/t"
                                "mp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                159,
                                "_parse_chain",
                                12,
                                1014,
                                20,
                                v17);
                              *(_DWORD *)(dword_161260 + 100) = json_integer_value((int)v19);
                              v19 = json_object_get(v18, "min_pcb_temp");
                              if ( v19 && *(_DWORD *)v19 == 3 )
                              {
                                V_LOCK();
                                v14 = json_integer_value((int)v19);
                                logfmt_raw(v17, 0x1000u, 0, "min_pcb_temp : %d", v14);
                                V_UNLOCK();
                                zlog(
                                  g_zc,
                                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot"
                                  "/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                  159,
                                  "_parse_chain",
                                  12,
                                  1023,
                                  20,
                                  v17);
                                *(_DWORD *)(dword_161260 + 104) = json_integer_value((int)v19);
                                v19 = json_object_get(v18, "max_uneffective_count");
                                if ( v19 && *(_DWORD *)v19 == 3 )
                                {
                                  V_LOCK();
                                  v15 = json_integer_value((int)v19);
                                  logfmt_raw(v17, 0x1000u, 0, "max_uneffective_count : %d", v15);
                                  V_UNLOCK();
                                  zlog(
                                    g_zc,
                                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildro"
                                    "ot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                    159,
                                    "_parse_chain",
                                    12,
                                    1032,
                                    20,
                                    v17);
                                  *(_DWORD *)(dword_161260 + 108) = json_integer_value((int)v19);
                                  v20 = sub_725CC(v18);
                                  if ( v20 )
                                  {
                                    V_LOCK();
                                    logfmt_raw(v17, 0x1000u, 0, "parse asic failed");
                                    V_UNLOCK();
                                    zlog(
                                      g_zc,
                                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/build"
                                      "root/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                      159,
                                      "_parse_chain",
                                      12,
                                      1038,
                                      100,
                                      v17);
                                    return -1;
                                  }
                                  else if ( byte_161258 && (v20 = sub_74514(v18)) != 0 )
                                  {
                                    V_LOCK();
                                    logfmt_raw(v17, 0x1000u, 0, "parse chain pic failed");
                                    V_UNLOCK();
                                    zlog(
                                      g_zc,
                                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/build"
                                      "root/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                      159,
                                      "_parse_chain",
                                      12,
                                      1046,
                                      100,
                                      v17);
                                    return -1;
                                  }
                                  else if ( *(_DWORD *)(dword_161260 + 88) == 3 && (v20 = sub_73BE8(v18)) != 0 )
                                  {
                                    V_LOCK();
                                    logfmt_raw(v17, 0x1000u, 0, "parse chain ctrlboard failed");
                                    V_UNLOCK();
                                    zlog(
                                      g_zc,
                                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/build"
                                      "root/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                      159,
                                      "_parse_chain",
                                      12,
                                      1055,
                                      100,
                                      v17);
                                    return -1;
                                  }
                                  else if ( (!*(_DWORD *)(dword_161260 + 88) || *(_DWORD *)(dword_161260 + 88) == 2)
                                         && (v20 = sub_74EF0(v18)) != 0 )
                                  {
                                    V_LOCK();
                                    logfmt_raw(v17, 0x1000u, 0, "parse chain sensor failed");
                                    V_UNLOCK();
                                    zlog(
                                      g_zc,
                                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/build"
                                      "root/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                      159,
                                      "_parse_chain",
                                      12,
                                      1065,
                                      100,
                                      v17);
                                    return -1;
                                  }
                                  else
                                  {
                                    v20 = sub_74A68(v18);
                                    if ( v20 )
                                    {
                                      V_LOCK();
                                      logfmt_raw(v17, 0x1000u, 0, "parse chain eeprom failed");
                                      V_UNLOCK();
                                      zlog(
                                        g_zc,
                                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/bui"
                                        "ldroot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                        159,
                                        "_parse_chain",
                                        12,
                                        1073,
                                        100,
                                        v17);
                                      return -1;
                                    }
                                    else
                                    {
                                      sub_6F7B4();
                                      return 0;
                                    }
                                  }
                                }
                                else
                                {
                                  V_LOCK();
                                  logfmt_raw(v17, 0x1000u, 0, "get max_uneffective_count failed");
                                  V_UNLOCK();
                                  zlog(
                                    g_zc,
                                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildro"
                                    "ot/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                    159,
                                    "_parse_chain",
                                    12,
                                    1029,
                                    100,
                                    v17);
                                  return -1;
                                }
                              }
                              else
                              {
                                V_LOCK();
                                logfmt_raw(v17, 0x1000u, 0, "get min_pcb_temp failed");
                                V_UNLOCK();
                                zlog(
                                  g_zc,
                                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot"
                                  "/tmp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                  159,
                                  "_parse_chain",
                                  12,
                                  1020,
                                  100,
                                  v17);
                                return -1;
                              }
                            }
                            else
                            {
                              V_LOCK();
                              logfmt_raw(v17, 0x1000u, 0, "get max_pcb_temp failed");
                              V_UNLOCK();
                              zlog(
                                g_zc,
                                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/t"
                                "mp/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                                159,
                                "_parse_chain",
                                12,
                                1011,
                                100,
                                v17);
                              return -1;
                            }
                          }
                          else
                          {
                            V_LOCK();
                            logfmt_raw(v17, 0x1000u, 0, "get max_chip_temp failed");
                            V_UNLOCK();
                            zlog(
                              g_zc,
                              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp"
                              "/release/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                              159,
                              "_parse_chain",
                              12,
                              1002,
                              100,
                              v17);
                            return -1;
                          }
                        }
                      }
                      else
                      {
                        V_LOCK();
                        logfmt_raw(v17, 0x1000u, 0, "get sensor num failed");
                        V_UNLOCK();
                        zlog(
                          g_zc,
                          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/rel"
                          "ease/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                          159,
                          "_parse_chain",
                          12,
                          991,
                          100,
                          v17);
                        return -1;
                      }
                    }
                    else
                    {
                      V_LOCK();
                      logfmt_raw(v17, 0x1000u, 0, "get sensor_mode failed");
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/relea"
                        "se/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                        159,
                        "_parse_chain",
                        12,
                        982,
                        100,
                        v17);
                      return -1;
                    }
                  }
                  else
                  {
                    V_LOCK();
                    logfmt_raw(v17, 0x1000u, 0, "get pic_mcu_en failed!");
                    V_UNLOCK();
                    zlog(
                      g_zc,
                      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release"
                      "/build/godminer-origin_godminer-branch1/backend/topol/topol.c",
                      159,
                      "_parse_chain",
                      12,
                      973,
                      100,
                      v17);
                    return -1;
                  }
                }
                else
                {
                  V_LOCK();
                  logfmt_raw(v17, 0x1000u, 0, "get domain_asic_num failed");
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/b"
                    "uild/godminer-origin_godminer-branch1/backend/topol/topol.c",
                    159,
                    "_parse_chain",
                    12,
                    964,
                    100,
                    v17);
                  return -1;
                }
              }
              else
              {
                V_LOCK();
                logfmt_raw(v17, 0x1000u, 0, "get chain_asic_num failed");
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/backend/topol/topol.c",
                  159,
                  "_parse_chain",
                  12,
                  955,
                  100,
                  v17);
                return -1;
              }
            }
            else
            {
              V_LOCK();
              logfmt_raw(v17, 0x1000u, 0, "get chain_domain_num failed");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/topol/topol.c",
                159,
                "_parse_chain",
                12,
                946,
                100,
                v17);
              return -1;
            }
          }
          else
          {
            V_LOCK();
            logfmt_raw(v17, 0x1000u, 0, "get chain_column failed");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/topol/topol.c",
              159,
              "_parse_chain",
              12,
              937,
              100,
              v17);
            return -1;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v17, 0x1000u, 0, "get chain_row failed");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "_parse_chain",
            12,
            928,
            100,
            v17);
          return -1;
        }
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v17, 0x1000u, 0, "get chain_num failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "_parse_chain",
        12,
        917,
        100,
        v17);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "get chain failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "_parse_chain",
      12,
      909,
      100,
      v17);
    return -1;
  }
}
// 76694: masking with 0x1 was optimized away because r3.1 <= 0x1
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161240: using guessed type int dword_161240;
// 161244: using guessed type int dword_161244;
// 161248: using guessed type int dword_161248;
// 16124C: using guessed type int dword_16124C;
// 161250: using guessed type int dword_161250;
// 161254: using guessed type int dword_161254;
// 161258: using guessed type char byte_161258;
// 161260: using guessed type int dword_161260;

//----- (00077200) --------------------------------------------------------
int platform_is_adjustable_power()
{
  return (unsigned __int8)byte_1612A0;
}
// 1612A0: using guessed type char byte_1612A0;

//----- (00077224) --------------------------------------------------------
int platform_is_check_asic_voltage_enable()
{
  return (unsigned __int8)byte_1612A1;
}
// 1612A1: using guessed type char byte_1612A1;

//----- (00077248) --------------------------------------------------------
int platfrom_get_check_asic_voltage()
{
  return dword_1612A4;
}
// 1612A4: using guessed type int dword_1612A4;

//----- (0007726C) --------------------------------------------------------
int platform_get_machine_name()
{
  return topol_machine;
}
// 16123C: using guessed type int topol_machine;

//----- (00077290) --------------------------------------------------------
int platform_get_chain_num()
{
  return dword_161240;
}
// 161240: using guessed type int dword_161240;

//----- (000772B4) --------------------------------------------------------
int platform_get_chain_domain_num()
{
  return dword_16124C;
}
// 16124C: using guessed type int dword_16124C;

//----- (000772D8) --------------------------------------------------------
int platform_get_chain_asic_num()
{
  return dword_161250;
}
// 161250: using guessed type int dword_161250;

//----- (000772FC) --------------------------------------------------------
int platform_get_domain_asic_num()
{
  return dword_161254;
}
// 161254: using guessed type int dword_161254;

//----- (00077320) --------------------------------------------------------
int __fastcall platform_get_chip_type(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 24);
}
// 161260: using guessed type int dword_161260;

//----- (00077360) --------------------------------------------------------
int __fastcall platform_get_asic_big_core_num(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 36);
}
// 161260: using guessed type int dword_161260;

//----- (000773A0) --------------------------------------------------------
int __fastcall platform_get_asic_little_core_num(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 40);
}
// 161260: using guessed type int dword_161260;

//----- (000773E0) --------------------------------------------------------
int __fastcall platform_get_core_little_core_num(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 44);
}
// 161260: using guessed type int dword_161260;

//----- (00077420) --------------------------------------------------------
int __fastcall platform_get_asic_domain_num(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 48);
}
// 161260: using guessed type int dword_161260;

//----- (00077460) --------------------------------------------------------
int platform_is_pic_mcu_en()
{
  return (unsigned __int8)byte_161258;
}
// 161258: using guessed type char byte_161258;

//----- (00077484) --------------------------------------------------------
int __fastcall platform_get_asic_addr_interval(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 52);
}
// 161260: using guessed type int dword_161260;

//----- (000774C4) --------------------------------------------------------
int __fastcall platform_get_chain_sensor_mode(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 88);
}
// 161260: using guessed type int dword_161260;

//----- (00077504) --------------------------------------------------------
int __fastcall platform_get_chain_sensor_num(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 92);
}
// 161260: using guessed type int dword_161260;

//----- (00077544) --------------------------------------------------------
int __fastcall platform_get_sensor_addr(int a1, int a2)
{
  return *(_DWORD *)(*(_DWORD *)(dword_161260 + 120 * a1 + 84) + 24 * a2 + 20);
}
// 161260: using guessed type int dword_161260;

//----- (0007759C) --------------------------------------------------------
int platform_is_asic_sensor_air_in()
{
  return 0;
}

//----- (000775C0) --------------------------------------------------------
int __fastcall platform_get_sensor_max_chip_temp(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 96);
}
// 161260: using guessed type int dword_161260;

//----- (00077600) --------------------------------------------------------
int __fastcall platform_get_sensor_max_pcb_temp(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 100);
}
// 161260: using guessed type int dword_161260;

//----- (00077640) --------------------------------------------------------
int __fastcall platform_get_sensor_min_pcb_temp(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 104);
}
// 161260: using guessed type int dword_161260;

//----- (00077680) --------------------------------------------------------
int __fastcall platform_get_sensor_max_uneffective_count(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 108);
}
// 161260: using guessed type int dword_161260;

//----- (000776C0) --------------------------------------------------------
int platform_get_fan_num()
{
  return dword_16125C;
}
// 16125C: using guessed type int dword_16125C;

//----- (000776E4) --------------------------------------------------------
int __fastcall platform_get_fan_max_speed(int a1)
{
  return *(_DWORD *)(dword_161298 + 12 * a1 + 8);
}
// 161298: using guessed type int dword_161298;

//----- (00077724) --------------------------------------------------------
int __fastcall platform_get_fan_min_speed(int a1)
{
  return *(_DWORD *)(dword_161298 + 12 * a1 + 4);
}
// 161298: using guessed type int dword_161298;

//----- (00077764) --------------------------------------------------------
int __fastcall platform_get_fan_control_info(int result)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r1
  int v5; // r2
  int v6; // r3
  float v7; // r1
  float v8; // r2
  float v9; // r3

  v1 = dword_161268;
  v2 = dword_16126C;
  v3 = dword_161270;
  *(_DWORD *)result = dword_161264;
  *(_DWORD *)(result + 4) = v1;
  *(_DWORD *)(result + 8) = v2;
  *(_DWORD *)(result + 12) = v3;
  v4 = dword_161278;
  v5 = dword_16127C;
  v6 = dword_161280;
  *(_DWORD *)(result + 16) = dword_161274;
  *(_DWORD *)(result + 20) = v4;
  *(_DWORD *)(result + 24) = v5;
  *(_DWORD *)(result + 28) = v6;
  v7 = flt_161288;
  v8 = flt_16128C;
  v9 = flt_161290;
  *(_DWORD *)(result + 32) = dword_161284;
  *(float *)(result + 36) = v7;
  *(float *)(result + 40) = v8;
  *(float *)(result + 44) = v9;
  *(float *)(result + 48) = flt_161294;
  return result;
}
// 161264: using guessed type int dword_161264;
// 161268: using guessed type int dword_161268;
// 16126C: using guessed type int dword_16126C;
// 161270: using guessed type int dword_161270;
// 161274: using guessed type int dword_161274;
// 161278: using guessed type int dword_161278;
// 16127C: using guessed type int dword_16127C;
// 161280: using guessed type int dword_161280;
// 161284: using guessed type int dword_161284;
// 161288: using guessed type float flt_161288;
// 16128C: using guessed type float flt_16128C;
// 161290: using guessed type float flt_161290;
// 161294: using guessed type float flt_161294;

//----- (000777B4) --------------------------------------------------------
int __fastcall platform_get_pic_device_high(int a1)
{
  return *(_DWORD *)(dword_161260 + 120 * a1 + 64);
}
// 161260: using guessed type int dword_161260;

//----- (000777F4) --------------------------------------------------------
int platform_get_psu_gpio_port()
{
  return dword_1612AC;
}
// 1612AC: using guessed type int dword_1612AC;

//----- (00077818) --------------------------------------------------------
int __fastcall platform_is_psu_supported(__int16 a1)
{
  int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i < dword_16129C; ++i )
  {
    if ( a1 == *(_WORD *)(dword_1612B4 + 2 * i) )
      return 1;
  }
  return 0;
}
// 16129C: using guessed type int dword_16129C;
// 1612B4: using guessed type int dword_1612B4;

//----- (000778A0) --------------------------------------------------------
int __fastcall sub_778A0(int a1, int a2, int a3, int a4)
{
  return a4;
}

//----- (000778BC) --------------------------------------------------------
int platform_topol_init()
{
  int v1; // r0
  int v2; // r1
  int v3; // r2
  int v4; // r3
  char v6[8]; // [sp+14h] [bp-1108h] BYREF
  _BYTE v7[252]; // [sp+1014h] [bp-108h] BYREF
  const json_t *file; // [sp+1110h] [bp-Ch]
  int v9; // [sp+1114h] [bp-8h]

  v9 = 0;
  file = json_load_file("/etc/topol.conf", 0, (json_error_t *)v7);
  if ( file && !*(_DWORD *)file )
  {
    v9 = sub_6F850(file);
    if ( v9 )
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "parse machine failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/topol/topol.c",
        159,
        "platform_topol_init",
        19,
        1519,
        20,
        v6);
    }
    else
    {
      v9 = sub_6FD8C(file);
      if ( v9 )
      {
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, "parse processor failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/topol/topol.c",
          159,
          "platform_topol_init",
          19,
          1526,
          20,
          v6);
      }
      else
      {
        v9 = sub_70010(file);
        if ( v9 )
        {
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, "parse power failed");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/topol/topol.c",
            159,
            "platform_topol_init",
            19,
            1533,
            20,
            v6);
        }
        else
        {
          v9 = sub_70BDC(file);
          if ( v9 )
          {
            V_LOCK();
            logfmt_raw(v6, 0x1000u, 0, "parse fan failed");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/topol/topol.c",
              159,
              "platform_topol_init",
              19,
              1540,
              20,
              v6);
          }
          else
          {
            v9 = sub_75B94(file);
            if ( v9 )
            {
              V_LOCK();
              logfmt_raw(v6, 0x1000u, 0, "parse chain failed");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/topol/topol.c",
                159,
                "platform_topol_init",
                19,
                1548,
                20,
                v6);
            }
          }
        }
      }
    }
    sub_6F280((int)file);
    sub_778A0(v1, v2, v3, v4);
    if ( v9 )
      return 304;
    else
      return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "load topol config file %s failed", "/etc/topol.conf");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/topol/topol.c",
      159,
      "platform_topol_init",
      19,
      1512,
      20,
      v6);
    return -1;
  }
}
// 77C70: variable 'v1' is possibly undefined
// 77C70: variable 'v2' is possibly undefined
// 77C70: variable 'v3' is possibly undefined
// 77C70: variable 'v4' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00077C98) --------------------------------------------------------
int (**dev_ctrl())()
{
  return dev_ctrl_hal();
}

//----- (00077CB0) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_77CB0(int a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (00077CE8) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_77CE8(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (00077D1C) --------------------------------------------------------
int __fastcall sub_77D1C(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 77D88: variable 'v3' is possibly undefined

//----- (00077E34) --------------------------------------------------------
int __fastcall sub_77E34(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (00077EA8) --------------------------------------------------------
int __fastcall sub_77EA8(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00077FCC) --------------------------------------------------------
_BYTE *__fastcall sub_77FCC(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00078038) --------------------------------------------------------
_BYTE *__fastcall sub_78038(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (000780BC) --------------------------------------------------------
unsigned int __fastcall sub_780BC(unsigned int a1)
{
  return bswap32(a1);
}

//----- (000780E4) --------------------------------------------------------
int __fastcall sub_780E4(unsigned __int16 a1)
{
  return (unsigned __int16)__rev16(a1);
}

//----- (00078114) --------------------------------------------------------
int __fastcall sub_78114(int a1, char a2)
{
  int v5; // [sp+1Ch] [bp-30h] BYREF
  _DWORD v6[3]; // [sp+20h] [bp-2Ch] BYREF
  _WORD s[8]; // [sp+2Ch] [bp-20h] BYREF
  int v8; // [sp+3Ch] [bp-10h]

  memset(s, 0, sizeof(s));
  v8 = 0;
  v5 = 0;
  LOBYTE(s[4]) = 0;
  HIBYTE(s[4]) = *(_DWORD *)(a1 + 428) * a2;
  s[5] = 0;
  return (*(int (__fastcall **)(int, _WORD *, int, _DWORD *, int *))(a1 + 288))(a1, s, 1, v6, &v5);
}

//----- (000781DC) --------------------------------------------------------
int __fastcall sub_781DC(int a1, unsigned int a2)
{
  int v3; // [sp+4h] [bp-1618h]
  char v6[64]; // [sp+5Ch] [bp-15C0h] BYREF
  _BYTE v7[1024]; // [sp+105Ch] [bp-5C0h] BYREF
  _BYTE s[256]; // [sp+145Ch] [bp-1C0h] BYREF
  int v9; // [sp+155Ch] [bp-C0h] BYREF
  _WORD v10[8]; // [sp+1560h] [bp-BCh] BYREF
  _DWORD v11[7]; // [sp+1570h] [bp-ACh] BYREF
  int v12; // [sp+158Ch] [bp-90h]
  _DWORD v13[7]; // [sp+1590h] [bp-8Ch] BYREF
  int v14; // [sp+15ACh] [bp-70h]
  _DWORD v15[7]; // [sp+15B0h] [bp-6Ch] BYREF
  int v16; // [sp+15CCh] [bp-50h]
  _DWORD v17[8]; // [sp+15D0h] [bp-4Ch] BYREF
  unsigned int v18; // [sp+15F0h] [bp-2Ch]
  int i; // [sp+15F4h] [bp-28h]
  int v20; // [sp+15F8h] [bp-24h]
  char *v21; // [sp+15FCh] [bp-20h]
  unsigned int j; // [sp+1600h] [bp-1Ch]
  int v23; // [sp+1604h] [bp-18h]
  int v24; // [sp+1608h] [bp-14h]
  void *ptr; // [sp+160Ch] [bp-10h]

  v9 = 0;
  v24 = 0;
  v23 = 0;
  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "%s chip_no %d", "ChipSetting_get_addr_LTC_1491", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_get_addr_LTC_1491",
    29,
    50,
    20,
    v6);
  memset(v10, 0, sizeof(v10));
  LOBYTE(v10[4]) = 1;
  v10[5] = 0;
  ptr = malloc(12 * a2);
  memset(ptr, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, unsigned int, void *, int *, int, int, _DWORD))(a1 + 288))(
    a1,
    v10,
    a2,
    ptr,
    &v9,
    v3,
    3000,
    0);
  V_LOCK();
  sub_77CE8((int)v11, *(int *)(a1 + 252));
  logfmt_raw(
    v6,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "%s detect %d chips",
    "ChipSetting_get_addr_LTC_1491",
    v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_get_addr_LTC_1491",
    29,
    60,
    20,
    v6);
  for ( i = 0; i < v9; ++i )
  {
    v23 = (unsigned __int16)(*((_WORD *)ptr + 6 * i) << 8) | (unsigned __int8)BYTE1(*((_DWORD *)ptr + 3 * i));
    V_LOCK();
    logfmt_raw(
      v6,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v23,
      *(_DWORD *)(a1 + 328),
      i,
      *((unsigned __int16 *)ptr + 6 * i + 3),
      *((unsigned __int8 *)ptr + 12 * i + 4));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_addr_LTC_1491",
      29,
      64,
      20,
      v6);
    if ( v23 == *(_DWORD *)(a1 + 328) )
    {
      v18 = (unsigned int)*((unsigned __int8 *)ptr + 12 * i + 4) / *(_DWORD *)(a1 + 428);
      ++s[v18];
      ++v24;
      V_LOCK();
      sub_77CE8((int)v13, *(int *)(a1 + 252));
      logfmt_raw(
        v6,
        0x1000u,
        0,
        v14,
        v13[0],
        v13[1],
        v13[2],
        v13[3],
        v13[4],
        v13[5],
        v13[6],
        v14,
        "chip_id:%d, %03d",
        v18,
        *((unsigned __int8 *)ptr + 12 * i + 4));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_get_addr_LTC_1491",
        29,
        70,
        20,
        v6);
    }
  }
  v20 = 0;
  memset(v7, 0, sizeof(v7));
  v7[0] = 10;
  v21 = v7;
  for ( j = 0; j < a2; ++j )
  {
    if ( !s[j] )
    {
      sprintf(v21, "%03d ", j);
      v21 += 4;
      ++v20;
    }
  }
  if ( v24 < *(_DWORD *)(a1 + 336) )
  {
    V_LOCK();
    sub_77CE8((int)v15, *(int *)(a1 + 252));
    sub_77CB0((int)v17, "asic num error");
    logfmt_raw(
      v6,
      0x1000u,
      0,
      v16,
      v15[0],
      v15[1],
      v15[2],
      v15[3],
      v15[4],
      v15[5],
      v15[6],
      v16,
      v17[0],
      v17[1],
      v17[2],
      v17[3],
      v17[4],
      v17[5],
      v17[6],
      v17[7],
      "detected asic num less than design(%d<%d)",
      v24,
      *(_DWORD *)(a1 + 336));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_addr_LTC_1491",
      29,
      95,
      100,
      v6);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "bad asic: %s", v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_addr_LTC_1491",
      29,
      96,
      40,
      v6);
  }
  free(ptr);
  *(_DWORD *)(a1 + 424) = v24;
  return v9;
}
// 78378: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00078978) --------------------------------------------------------
int __fastcall sub_78978(int a1)
{
  char v3[24]; // [sp+1Ch] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+101Ch] [bp-18h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "bridge reset %s %02x", "ChipSetting_bridge_reset_LTC_1491", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_bridge_reset_LTC_1491",
    33,
    110,
    20,
    v3);
  memset(s, 0, sizeof(s));
  s[2] = 4456449;
  s[0] = 2;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00078A8C) --------------------------------------------------------
int __fastcall sub_78A8C(int a1)
{
  char v3[24]; // [sp+1Ch] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+101Ch] [bp-18h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_LTC_1491", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_software_reset_LTC_1491",
    35,
    123,
    20,
    v3);
  memset(s, 0, sizeof(s));
  s[2] = 4456449;
  s[0] = 3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00078BA0) --------------------------------------------------------
int __fastcall sub_78BA0(int a1, char a2)
{
  char v5[24]; // [sp+1Ch] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+101Ch] [bp-18h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_LTC_1491", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_software_reset_one_asic_LTC_1491",
    44,
    136,
    20,
    v5);
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = *(_DWORD *)(a1 + 428) * a2;
  HIWORD(s[2]) = 68;
  s[0] = 3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00078CE8) --------------------------------------------------------
int __fastcall sub_78CE8(int a1, char a2)
{
  char v5[24]; // [sp+1Ch] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+101Ch] [bp-18h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_core_LTC_1491", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_software_reset_one_asic_core_LTC_1491",
    49,
    149,
    20,
    v5);
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = *(_DWORD *)(a1 + 428) * a2;
  HIWORD(s[2]) = 68;
  s[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00078E30) --------------------------------------------------------
int __fastcall sub_78E30(int a1, unsigned __int8 a2)
{
  char v5[12]; // [sp+38h] [bp-104Ch] BYREF
  _DWORD s[4]; // [sp+1038h] [bp-4Ch] BYREF
  _DWORD v7[7]; // [sp+1048h] [bp-3Ch] BYREF
  int v8; // [sp+1064h] [bp-20h]
  int v9; // [sp+106Ch] [bp-18h]
  int v10; // [sp+1070h] [bp-14h]
  int v11; // [sp+1074h] [bp-10h]

  v11 = 0;
  v10 = a2;
  memset(s, 0, sizeof(s));
  V_LOCK();
  sub_77CE8((int)v7, *(int *)(a1 + 252));
  logfmt_raw(
    v5,
    0x1000u,
    0,
    v8,
    v7[0],
    v7[1],
    v7[2],
    v7[3],
    v7[4],
    v7[5],
    v7[6],
    v8,
    "set core ticket mask reg %02x tm %02x",
    255,
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_core_ticket_mask_LTC_1491",
    37,
    182,
    40,
    v5);
  s[2] = 16711681;
  s[0] = a2;
  BYTE2(s[3]) = 1;
  LOBYTE(s[3]) = -1;
  BYTE1(s[3]) = *(_DWORD *)(a1 + 340);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  usleep(0x3E8u);
  *(_DWORD *)(a1 + 432) = a2;
  return v9;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00079000) --------------------------------------------------------
int __fastcall sub_79000(int a1, unsigned __int8 a2, int a3)
{
  char v7[68]; // [sp+40h] [bp-1044h] BYREF
  _DWORD s[4]; // [sp+1040h] [bp-44h] BYREF
  _DWORD v9[7]; // [sp+1050h] [bp-34h] BYREF
  int v10; // [sp+106Ch] [bp-18h]
  int v11; // [sp+1070h] [bp-14h]
  unsigned __int8 v12; // [sp+1077h] [bp-Dh]

  v11 = 0;
  v12 = 0;
  if ( a2 <= *(int *)(a1 + 336) )
    v12 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a2);
  else
    v12 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = v12;
  HIWORD(s[2]) = 48;
  s[0] = a3;
  V_LOCK();
  sub_77CE8((int)v9, *(int *)(a1 + 252));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v10,
    v9[0],
    v9[1],
    v9[2],
    v9[3],
    v9[4],
    v9[5],
    v9[6],
    v10,
    "chip_id %02x, chip_addr %02x, set io drive strengh %08x",
    a2,
    v12,
    s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_io_drive_strenth_LTC_1491",
    37,
    215,
    40,
    v7);
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v11;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000791F8) --------------------------------------------------------
int __fastcall sub_791F8(int a1, int a2)
{
  char v5[68]; // [sp+30h] [bp-1044h] BYREF
  _DWORD s[4]; // [sp+1030h] [bp-44h] BYREF
  _DWORD v7[7]; // [sp+1040h] [bp-34h] BYREF
  int v8; // [sp+105Ch] [bp-18h]
  int v9; // [sp+1064h] [bp-10h]

  memset(s, 0, sizeof(s));
  s[2] = 1835009;
  s[0] = a2;
  V_LOCK();
  sub_77CE8((int)v7, *(int *)(a1 + 252));
  logfmt_raw(v5, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "set misc ctrl %08x", s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_misc_ctrl_LTC_1491",
    30,
    230,
    40,
    v5);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v9;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00079360) --------------------------------------------------------
int __fastcall sub_79360(int a1, int a2)
{
  char v5[68]; // [sp+30h] [bp-1044h] BYREF
  _DWORD s[4]; // [sp+1030h] [bp-44h] BYREF
  _DWORD v7[7]; // [sp+1040h] [bp-34h] BYREF
  int v8; // [sp+105Ch] [bp-18h]
  int v9; // [sp+1064h] [bp-10h]

  memset(s, 0, sizeof(s));
  s[2] = 6356993;
  s[0] = a2;
  V_LOCK();
  sub_77CE8((int)v7, *(int *)(a1 + 252));
  logfmt_raw(
    v5,
    0x1000u,
    0,
    v8,
    v7[0],
    v7[1],
    v7[2],
    v7[3],
    v7[4],
    v7[5],
    v7[6],
    v8,
    "set bist err num threshold %08x",
    s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_bist_threshold_set_rvn_LTC_1491",
    43,
    246,
    40,
    v5);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v9;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000794C8) --------------------------------------------------------
int __fastcall sub_794C8(int a1, int a2)
{
  char v5[68]; // [sp+30h] [bp-1044h] BYREF
  _DWORD s[4]; // [sp+1030h] [bp-44h] BYREF
  _DWORD v7[7]; // [sp+1040h] [bp-34h] BYREF
  int v8; // [sp+105Ch] [bp-18h]
  int v9; // [sp+1064h] [bp-10h]

  memset(s, 0, sizeof(s));
  s[2] = 6553601;
  s[0] = a2;
  V_LOCK();
  sub_77CE8((int)v7, *(int *)(a1 + 252));
  logfmt_raw(v5, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "set retin on %08x", s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_retin_on_rvn_LTC_1491",
    33,
    260,
    40,
    v5);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v9;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00079630) --------------------------------------------------------
int __fastcall sub_79630(int a1, int a2)
{
  char v5[68]; // [sp+30h] [bp-1044h] BYREF
  _DWORD s[4]; // [sp+1030h] [bp-44h] BYREF
  _DWORD v7[7]; // [sp+1040h] [bp-34h] BYREF
  int v8; // [sp+105Ch] [bp-18h]
  int v9; // [sp+1064h] [bp-10h]

  memset(s, 0, sizeof(s));
  s[2] = 3145729;
  s[0] = a2;
  V_LOCK();
  sub_77CE8((int)v7, *(int *)(a1 + 252));
  logfmt_raw(v5, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "set io drive strenth %08x", s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_io_drive_strenth_all_LTC_1491",
    41,
    274,
    40,
    v5);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v9;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00079798) --------------------------------------------------------
int __fastcall sub_79798(int a1, int a2)
{
  char v5[52]; // [sp+38h] [bp-1074h] BYREF
  int v6; // [sp+1038h] [bp-74h] BYREF
  int v7; // [sp+103Ch] [bp-70h] BYREF
  _DWORD s[4]; // [sp+1040h] [bp-6Ch] BYREF
  _DWORD v9[7]; // [sp+1050h] [bp-5Ch] BYREF
  int v10; // [sp+106Ch] [bp-40h]
  _DWORD v11[7]; // [sp+1070h] [bp-3Ch] BYREF
  int v12; // [sp+108Ch] [bp-20h]
  int v13; // [sp+1094h] [bp-18h]
  void *ptr; // [sp+1098h] [bp-14h]
  int i; // [sp+109Ch] [bp-10h]

  v7 = 0;
  memset(s, 0, sizeof(s));
  s[2] = 1835009;
  ptr = malloc(12 * *(_DWORD *)(a1 + 336));
  memset(ptr, 0, 12 * *(_DWORD *)(a1 + 336));
  (*(void (__fastcall **)(int, _DWORD *, _DWORD, void *, int *))(a1 + 288))(a1, s, *(_DWORD *)(a1 + 336), ptr, &v7);
  for ( i = 0; i < v7; ++i )
  {
    if ( *((_WORD *)ptr + 6 * i + 3) == 28 )
    {
      V_LOCK();
      sub_77CE8((int)v9, *(int *)(a1 + 252));
      logfmt_raw(
        v5,
        0x1000u,
        0,
        v10,
        v9[0],
        v9[1],
        v9[2],
        v9[3],
        v9[4],
        v9[5],
        v9[6],
        v10,
        "[MISC CTRL] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)ptr + 12 * i + 4),
        *((unsigned __int16 *)ptr + 6 * i + 3),
        *((_DWORD *)ptr + 3 * i));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_pll_sel_LTC_1491",
        28,
        296,
        20,
        v5);
    }
  }
  v6 = 0;
  sub_78038(&v6, *(_DWORD *)ptr);
  free(ptr);
  s[2] = 1835009;
  s[0] = v6 & 0xFFFFFFFB | (4 * (_BYTE)a2) & 4;
  V_LOCK();
  sub_77CE8((int)v11, *(int *)(a1 + 252));
  logfmt_raw(
    v5,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "set pll sel %u %08x",
    a2,
    s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_pll_sel_LTC_1491",
    28,
    308,
    40,
    v5);
  v13 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v13;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00079B74) --------------------------------------------------------
int __fastcall sub_79B74(int a1, int a2)
{
  char v5[68]; // [sp+30h] [bp-1044h] BYREF
  _DWORD s[4]; // [sp+1030h] [bp-44h] BYREF
  _DWORD v7[7]; // [sp+1040h] [bp-34h] BYREF
  int v8; // [sp+105Ch] [bp-18h]
  int v9; // [sp+1064h] [bp-10h]

  memset(s, 0, sizeof(s));
  s[2] = 5505025;
  s[0] = a2;
  V_LOCK();
  sub_77CE8((int)v7, *(int *)(a1 + 252));
  logfmt_raw(v5, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "set nonce len value %08x", s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_nonce_len_LTC_1491",
    30,
    324,
    40,
    v5);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v9;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00079CDC) --------------------------------------------------------
int __fastcall sub_79CDC(int a1, int a2)
{
  char v5[68]; // [sp+30h] [bp-1044h] BYREF
  _DWORD s[4]; // [sp+1030h] [bp-44h] BYREF
  _DWORD v7[7]; // [sp+1040h] [bp-34h] BYREF
  int v8; // [sp+105Ch] [bp-18h]
  int v9; // [sp+1064h] [bp-10h]

  memset(s, 0, sizeof(s));
  s[2] = 2883585;
  s[0] = a2;
  V_LOCK();
  sub_77CE8((int)v7, *(int *)(a1 + 252));
  logfmt_raw(v5, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "set io cfg value %08x", s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_io_cfg_LTC_1491",
    27,
    340,
    40,
    v5);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v9;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00079E44) --------------------------------------------------------
int __fastcall sub_79E44(int a1, int a2, char a3)
{
  char v7[24]; // [sp+4Ch] [bp-1098h] BYREF
  _DWORD s[4]; // [sp+104Ch] [bp-98h] BYREF
  int v9; // [sp+105Ch] [bp-88h] BYREF
  _DWORD v10[7]; // [sp+1060h] [bp-84h] BYREF
  int v11; // [sp+107Ch] [bp-68h]
  _DWORD v12[7]; // [sp+1080h] [bp-64h] BYREF
  int v13; // [sp+109Ch] [bp-48h]
  _DWORD v14[7]; // [sp+10A0h] [bp-44h] BYREF
  int v15; // [sp+10BCh] [bp-28h]
  void *ptr; // [sp+10C0h] [bp-24h]
  char v17; // [sp+10C7h] [bp-1Dh]
  int i; // [sp+10C8h] [bp-1Ch]
  int v19; // [sp+10CCh] [bp-18h]
  char v20; // [sp+10D3h] [bp-11h]
  int v21; // [sp+10D4h] [bp-10h]

  v19 = 0;
  v9 = 0;
  v21 = a3 & 1;
  v20 = 0;
  v17 = 0;
  if ( a2 == -1 || a2 > *(_DWORD *)(a1 + 336) )
    v20 = 1;
  else
    v17 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a2);
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = v17;
  HIWORD(s[2]) = 255;
  s[0] = 0;
  LOBYTE(s[3]) = 0;
  ptr = malloc(0xCu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 300))(a1, s, 1, ptr, &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *((_WORD *)ptr + 6 * i + 3) == 255 )
    {
      V_LOCK();
      sub_77CE8((int)v10, *(int *)(a1 + 252));
      logfmt_raw(
        v7,
        0x1000u,
        0,
        v11,
        v10[0],
        v10[1],
        v10[2],
        v10[3],
        v10[4],
        v10[5],
        v10[6],
        v11,
        "%s chip %02x, core %02x, reg %02x, core_mode %08x",
        "ChipSetting_same_nonce_LTC_1491",
        *((unsigned __int8 *)ptr + 12 * i + 4),
        *((unsigned __int8 *)ptr + 12 * i + 8),
        *((unsigned __int16 *)ptr + 6 * i + 3),
        *((_DWORD *)ptr + 3 * i));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_same_nonce_LTC_1491",
        31,
        375,
        20,
        v7);
      v21 = *((_DWORD *)ptr + 3 * i) | a3 & 1;
    }
    else
    {
      V_LOCK();
      sub_77CE8((int)v12, *(int *)(a1 + 252));
      logfmt_raw(
        v7,
        0x1000u,
        0,
        v13,
        v12[0],
        v12[1],
        v12[2],
        v12[3],
        v12[4],
        v12[5],
        v12[6],
        v13,
        "%s chip %02x, expected reg %02x, but %02x, core_mode %08x",
        "ChipSetting_same_nonce_LTC_1491",
        *((unsigned __int8 *)ptr + 12 * i + 4),
        255,
        *((unsigned __int16 *)ptr + 6 * i + 3),
        *((_DWORD *)ptr + 3 * i));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_same_nonce_LTC_1491",
        31,
        379,
        100,
        v7);
    }
  }
  free(ptr);
  LOBYTE(s[2]) = v20;
  BYTE1(s[2]) = v17;
  HIWORD(s[2]) = 255;
  LOBYTE(s[3]) = -1;
  s[0] = v21;
  v19 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  if ( v19 < 0 )
  {
    V_LOCK();
    sub_77CE8((int)v14, *(int *)(a1 + 252));
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "set same nonce failed! chip_id:%d",
      a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_same_nonce_LTC_1491",
      31,
      392,
      100,
      v7);
    return -1;
  }
  return v19;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007A3EC) --------------------------------------------------------
bool __fastcall sub_7A3EC(int a1, int a2, int *a3)
{
  const char *v3; // r3
  int v5; // [sp+4h] [bp-1108h]
  char v8[68]; // [sp+48h] [bp-10C4h] BYREF
  int v9; // [sp+1048h] [bp-C4h] BYREF
  int v10; // [sp+104Ch] [bp-C0h] BYREF
  _DWORD s[4]; // [sp+1050h] [bp-BCh] BYREF
  _DWORD v12[7]; // [sp+1060h] [bp-ACh] BYREF
  int v13; // [sp+107Ch] [bp-90h]
  _DWORD v14[7]; // [sp+1080h] [bp-8Ch] BYREF
  int v15; // [sp+109Ch] [bp-70h]
  _DWORD v16[7]; // [sp+10A0h] [bp-6Ch] BYREF
  int v17; // [sp+10BCh] [bp-50h]
  _DWORD v18[7]; // [sp+10C0h] [bp-4Ch] BYREF
  int v19; // [sp+10DCh] [bp-30h]
  void *v20; // [sp+10E0h] [bp-2Ch]
  int v21; // [sp+10E4h] [bp-28h]
  void *ptr; // [sp+10E8h] [bp-24h]
  int i; // [sp+10ECh] [bp-20h]
  int j; // [sp+10F0h] [bp-1Ch]
  int v25; // [sp+10F4h] [bp-18h]
  char v26; // [sp+10FBh] [bp-11h]
  int v27; // [sp+10FCh] [bp-10h]

  v10 = 0;
  v25 = 0;
  v27 = 0;
  v26 = 0;
  if ( a2 == -1 || a2 > *(_DWORD *)(a1 + 336) )
    v26 = 0;
  else
    v26 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a2);
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = v26;
  HIWORD(s[2]) = 60;
  ptr = malloc(0xCu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 288))(a1, s, 1, ptr, &v10);
  for ( i = 0; i < v10; ++i )
  {
    if ( *((_WORD *)ptr + 6 * i + 3) == 60 )
    {
      v9 = 0;
      sub_78038(&v9, *(_DWORD *)ptr);
      v25 += v9;
      V_LOCK();
      sub_77CE8((int)v12, *(int *)(a1 + 252));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v13,
        v12[0],
        v12[1],
        v12[2],
        v12[3],
        v12[4],
        v12[5],
        v12[6],
        v13,
        "[Top Nonce Cnt] asic %02x, reg %02x cnt %08x",
        *((unsigned __int8 *)ptr + 12 * i + 4),
        *((unsigned __int16 *)ptr + 6 * i + 3),
        v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_nonce_counter_LTC_1491",
        34,
        428,
        20,
        v8);
    }
  }
  free(ptr);
  *a3 = v25;
  memset(s, 0, sizeof(s));
  s[2] = 655360;
  s[0] = 1;
  LOBYTE(s[3]) = -1;
  v21 = *(_DWORD *)(a1 + 340);
  v20 = malloc(12 * v21);
  memset(v20, 0, 12 * v21);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
    a1,
    s,
    v21,
    v20,
    &v10,
    v5,
    2000,
    0);
  for ( j = 0; j < v10; ++j )
  {
    if ( *((_WORD *)v20 + 6 * j + 3) == 10 )
    {
      v27 += *((_DWORD *)v20 + 3 * j);
      V_LOCK();
      sub_77CE8((int)v14, *(int *)(a1 + 252));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v15,
        v14[0],
        v14[1],
        v14[2],
        v14[3],
        v14[4],
        v14[5],
        v14[6],
        v15,
        "%s chip %02x, core %02x, reg %02x, core_nonce_cnt %08x",
        "ChipSetting_nonce_counter_LTC_1491",
        *((unsigned __int8 *)v20 + 12 * j + 4),
        *((unsigned __int8 *)v20 + 12 * j + 8),
        *((unsigned __int16 *)v20 + 6 * j + 3),
        *((_DWORD *)v20 + 3 * j));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_nonce_counter_LTC_1491",
        34,
        451,
        20,
        v8);
    }
    else
    {
      V_LOCK();
      sub_77CE8((int)v16, *(int *)(a1 + 252));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v17,
        v16[0],
        v16[1],
        v16[2],
        v16[3],
        v16[4],
        v16[5],
        v16[6],
        v17,
        "%s chip %02x, expected reg %02x, but %02x, core_nonce_cnt %08x",
        "ChipSetting_nonce_counter_LTC_1491",
        *((unsigned __int8 *)v20 + 12 * j + 4),
        255,
        *((unsigned __int16 *)v20 + 6 * j + 3),
        *((_DWORD *)v20 + 3 * j));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_nonce_counter_LTC_1491",
        34,
        454,
        100,
        v8);
    }
  }
  free(v20);
  V_LOCK();
  sub_77CE8((int)v18, *(int *)(a1 + 252));
  if ( v25 == v27 )
    v3 = "Pass";
  else
    v3 = "Failed";
  logfmt_raw(
    v8,
    0x1000u,
    0,
    v19,
    v18[0],
    v18[1],
    v18[2],
    v18[3],
    v18[4],
    v18[5],
    v18[6],
    v19,
    "check nonce counter, top_nonce_cnt %d, core_nocne_cnt %d (%s)",
    v25,
    v27,
    v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_nonce_counter_LTC_1491",
    34,
    460,
    40,
    v8);
  return v25 != v27;
}
// 7A798: variable 'v5' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007AB90) --------------------------------------------------------
int __fastcall sub_7AB90(int a1, int a2, char a3)
{
  char v7[16]; // [sp+44h] [bp-1050h] BYREF
  int v8; // [sp+1044h] [bp-50h]
  _DWORD s[4]; // [sp+1048h] [bp-4Ch] BYREF
  _DWORD v10[7]; // [sp+1058h] [bp-3Ch] BYREF
  int v11; // [sp+1074h] [bp-20h]
  int v12; // [sp+1078h] [bp-1Ch]
  int v13; // [sp+107Ch] [bp-18h]
  int v14; // [sp+1080h] [bp-14h]
  int v15; // [sp+1084h] [bp-10h]

  v14 = 26;
  v15 = 0;
  v13 = 0;
  memset(s, 0, sizeof(s));
  s[2] = 6291457;
  if ( a2 == 1500000 )
    goto LABEL_21;
  if ( a2 > 1500000 )
  {
    if ( a2 == 3125000 )
      goto LABEL_20;
    if ( a2 > 3125000 )
    {
      if ( a2 == 6250000 )
      {
        v15 = 1;
        v14 = 1;
        goto LABEL_27;
      }
      if ( a2 == 12500000 )
      {
        v15 = 1;
        v14 = 0;
        goto LABEL_27;
      }
      goto LABEL_26;
    }
    if ( a2 != 1562500 )
    {
      if ( a2 != 3000000 )
        goto LABEL_26;
LABEL_20:
      v14 = 0;
      goto LABEL_27;
    }
LABEL_21:
    v14 = 1;
    goto LABEL_27;
  }
  if ( a2 == 460800 )
  {
    v14 = 6;
    goto LABEL_27;
  }
  if ( a2 > 460800 )
  {
    if ( a2 == 921600 || (_UNKNOWN *)a2 == &unk_FE502 )
    {
      v14 = 2;
      goto LABEL_27;
    }
  }
  else
  {
    if ( a2 == 38400 )
    {
      v14 = 80;
      goto LABEL_27;
    }
    if ( (__int16 *)a2 == &word_1C200 )
    {
      v14 = 26;
      goto LABEL_27;
    }
  }
LABEL_26:
  v14 = 26;
LABEL_27:
  if ( v15 )
    (*(void (__fastcall **)(int, int))(a1 + 192))(a1, 1);
  v8 = (v14 << 8) & 0x1FF00 | (16 * a3) & 0x30 | v15 & 1;
  s[0] = v8;
  V_LOCK();
  sub_77CE8((int)v10, *(int *)(a1 + 252));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "set fuart cfg value %08x/%d",
    s[0],
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_fuart_cfg_LTC_1491",
    30,
    528,
    40,
    v7);
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v12;
}
// 1C200: using guessed type __int16 word_1C200;
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007AEFC) --------------------------------------------------------
unsigned int *__fastcall sub_7AEFC(unsigned int *result)
{
  float v1; // s0
  char v2[40]; // [sp+34h] [bp-1028h] BYREF
  float v3; // [sp+1034h] [bp-28h]
  int v4; // [sp+1038h] [bp-24h]
  float v5; // [sp+103Ch] [bp-20h]
  float v6; // [sp+1040h] [bp-1Ch]
  int k; // [sp+1044h] [bp-18h]
  int j; // [sp+1048h] [bp-14h]
  int v9; // [sp+104Ch] [bp-10h]
  int i; // [sp+1050h] [bp-Ch]
  float v11; // [sp+1054h] [bp-8h]

  v6 = 0.0;
  v11 = 0.0;
  v9 = 32;
  j = 0;
  k = 0;
  *result = -1068236443;
  for ( i = 2; i > 0; --i )
  {
    for ( j = 0; j <= 7; ++j )
    {
      for ( k = j; k >= 0; --k )
      {
        v5 = (float)((float)((float)((float)((float)(j + 1) * v1) * (float)(k + 1)) * (float)i) / 25.0) * 100.0;
        if ( (int)v5 % 100 <= 50 )
          v9 = (int)v5 / 100;
        else
          v9 = (int)v5 / 100 + 1;
        v6 = (float)((float)v9 * 25.0) / (float)i;
        if ( v9 <= 250 && v9 > 15 && (i != 1 || v6 <= 3125.0) && v6 <= 3200.0 && v6 >= 2000.0 )
        {
          v4 = v6 > 2400.0;
          v11 = (float)((float)((float)((float)v9 * 25.0) / (float)i) / (float)(j + 1)) / (float)(k + 1);
          *result = (v4 << 28)
                  | (v9 << 16) & 0xFFF0000
                  | ((_WORD)i << 8) & 0x3F00
                  | (16 * (_BYTE)j) & 0x70
                  | k & 7
                  | 0xC0000000;
          v3 = fabsf(v11 - v1);
          if ( v3 < 3.0 )
          {
            V_LOCK();
            logfmt_raw(
              v2,
              0x1000u,
              0,
              "target_freq:%.2f actual_freq:%.2f,vco:%.2f fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
              v1,
              v11,
              v6,
              v9,
              i,
              j,
              k);
            V_UNLOCK();
            return (unsigned int *)zlog(
                                     g_zc,
                                     "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildr"
                                     "oot/tmp/release/build/godminer-origin_godminer-branch1/./backend/chip_setting.c",
                                     162,
                                     "inferred_plldivider",
                                     19,
                                     580,
                                     20,
                                     v2);
          }
          v11 = 0.0;
        }
      }
    }
  }
  return result;
}
// 7AFAC: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007B35C) --------------------------------------------------------
unsigned int *__fastcall sub_7B35C(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int *v4; // [sp+2Ch] [bp-1030h]
  char v5[40]; // [sp+34h] [bp-1028h] BYREF
  float v6; // [sp+1034h] [bp-28h]
  int v7; // [sp+1038h] [bp-24h]
  float v8; // [sp+103Ch] [bp-20h]
  float v9; // [sp+1040h] [bp-1Ch]
  signed int k; // [sp+1044h] [bp-18h]
  signed int j; // [sp+1048h] [bp-14h]
  int v12; // [sp+104Ch] [bp-10h]
  signed int i; // [sp+1050h] [bp-Ch]
  float v14; // [sp+1054h] [bp-8h]

  v4 = result;
  v9 = 0.0;
  v14 = 0.0;
  v12 = 32;
  j = 0;
  k = 0;
  *result = -1068236443;
  for ( i = 2; i > 0; --i )
  {
    for ( j = 0; j <= 7; ++j )
    {
      for ( k = j; k >= 0; --k )
      {
        v8 = (float)((float)((float)((float)((float)j * v1) * (float)k) * (float)i) / 25.0) * 100.0;
        if ( (int)v8 % 100 <= 50 )
          v12 = (int)v8 / 100;
        else
          v12 = (int)v8 / 100 + 1;
        v9 = (float)((float)v12 * 25.0) / (float)i;
        if ( v12 <= 250 && v12 > 15 && (i != 1 || v9 <= 3125.0) && v9 <= 3200.0 && v9 >= 2000.0 )
        {
          v7 = v9 > 2400.0;
          v2 = sub_CC518(25 * v12, i);
          v3 = sub_CC518(v2, j);
          result = (unsigned int *)sub_CC518(v3, k);
          v14 = (float)(int)result;
          *v4 = (v7 << 28)
              | (v12 << 16) & 0xFFF0000
              | ((_WORD)i << 8) & 0x3F00
              | (16 * (_BYTE)j) & 0x70
              | k & 7
              | 0xC0000000;
          v6 = fabsf(v14 - v1);
          if ( v6 < 3.0 )
          {
            V_LOCK();
            logfmt_raw(
              v5,
              0x1000u,
              0,
              "target_freq:%.2f actual_freq:%.2f,vco:%.2f fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
              v1,
              v14,
              v9,
              v12,
              i,
              j,
              k);
            V_UNLOCK();
            return (unsigned int *)zlog(
                                     g_zc,
                                     "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildr"
                                     "oot/tmp/release/build/godminer-origin_godminer-branch1/./backend/chip_setting.c",
                                     162,
                                     "inferred_plldivider_kas",
                                     23,
                                     630,
                                     20,
                                     v5);
          }
          v14 = 0.0;
        }
      }
    }
  }
  return result;
}
// 7B408: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007B7AC) --------------------------------------------------------
int __fastcall sub_7B7AC(int a1, int a2, char a3, char a4)
{
  float v4; // s0
  char v10[72]; // [sp+4Ch] [bp-1048h] BYREF
  _DWORD s[4]; // [sp+104Ch] [bp-48h] BYREF
  unsigned int v12; // [sp+105Ch] [bp-38h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp-34h] BYREF
  int v14; // [sp+107Ch] [bp-18h]
  float v15; // [sp+1080h] [bp-14h]
  int v16; // [sp+1084h] [bp-10h]

  v12 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = a3;
  BYTE1(s[2]) = a4;
  if ( a2 )
  {
    if ( a2 == 1 )
      HIWORD(s[2]) = 12;
  }
  else
  {
    HIWORD(s[2]) = 8;
  }
  sub_7B35C(&v12);
  v15 = v4;
  s[0] = v12;
  V_LOCK();
  sub_77CE8((int)v13, *(int *)(a1 + 252));
  logfmt_raw(
    v10,
    0x1000u,
    0,
    v14,
    v13[0],
    v13[1],
    v13[2],
    v13[3],
    v13[4],
    v13[5],
    v13[6],
    v14,
    "KAS_set pll_no %d freq: %.2f, expected freq: %.2f",
    a2,
    v15,
    v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_freq_kas_LTC_1491",
    29,
    657,
    40,
    v10);
  v16 = -1;
  if ( v15 > 0.0 )
    v16 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v16;
}
// 7B894: variable 'v4' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007B9E4) --------------------------------------------------------
int __fastcall sub_7B9E4(int a1, int a2)
{
  float v2; // s0
  char v6[72]; // [sp+4Ch] [bp-1048h] BYREF
  _DWORD s[4]; // [sp+104Ch] [bp-48h] BYREF
  unsigned int v8; // [sp+105Ch] [bp-38h] BYREF
  _DWORD v9[7]; // [sp+1060h] [bp-34h] BYREF
  int v10; // [sp+107Ch] [bp-18h]
  float v11; // [sp+1080h] [bp-14h]
  int v12; // [sp+1084h] [bp-10h]

  v8 = 0;
  memset(s, 0, sizeof(s));
  LOWORD(s[2]) = 1;
  if ( a2 )
  {
    if ( a2 == 1 )
      HIWORD(s[2]) = 12;
  }
  else
  {
    HIWORD(s[2]) = 8;
  }
  sub_7AEFC(&v8);
  v11 = v2;
  s[0] = v8;
  V_LOCK();
  sub_77CE8((int)v9, *(int *)(a1 + 252));
  logfmt_raw(
    v6,
    0x1000u,
    0,
    v10,
    v9[0],
    v9[1],
    v9[2],
    v9[3],
    v9[4],
    v9[5],
    v9[6],
    v10,
    "set pll_no %d freq: %.2f, expected freq: %.2f",
    a2,
    v11,
    v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_freq_LTC_1491",
    25,
    680,
    40,
    v6);
  v12 = -1;
  if ( v11 > 0.0 )
    v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v12;
}
// 7BA9C: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007BBEC) --------------------------------------------------------
int __fastcall sub_7BBEC(int a1, char a2, int a3)
{
  float v3; // s0
  int v5; // [sp+24h] [bp-1070h]
  char v9[72]; // [sp+4Ch] [bp-1048h] BYREF
  _DWORD s[4]; // [sp+104Ch] [bp-48h] BYREF
  unsigned int v11; // [sp+105Ch] [bp-38h] BYREF
  _DWORD v12[7]; // [sp+1060h] [bp-34h] BYREF
  int v13; // [sp+107Ch] [bp-18h]
  int v14; // [sp+1080h] [bp-14h]
  float v15; // [sp+1084h] [bp-10h]

  v11 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = *(_DWORD *)(a1 + 428) * a2;
  if ( a3 )
  {
    if ( a3 == 1 )
      HIWORD(s[2]) = 12;
  }
  else
  {
    HIWORD(s[2]) = 8;
  }
  sub_7AEFC(&v11);
  v15 = v3;
  s[0] = v11;
  V_LOCK();
  sub_77CE8((int)v12, *(int *)(a1 + 252));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v13,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v13,
    "set freq: %.2f, expected freq: %.2f",
    v5,
    v15,
    v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_one_asic_freq_LTC_1491",
    34,
    702,
    20,
    v9);
  v14 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v14;
}
// 7BCD8: variable 'v3' is possibly undefined
// 7BD68: variable 'v5' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007BE00) --------------------------------------------------------
int __fastcall sub_7BE00(int a1)
{
  int v2; // [sp+4h] [bp-10A8h]
  char v4[48]; // [sp+3Ch] [bp-1070h] BYREF
  int v5; // [sp+103Ch] [bp-70h] BYREF
  _WORD s[8]; // [sp+1040h] [bp-6Ch] BYREF
  _DWORD v7[7]; // [sp+1050h] [bp-5Ch] BYREF
  int v8; // [sp+106Ch] [bp-40h]
  _DWORD v9[7]; // [sp+1070h] [bp-3Ch] BYREF
  int v10; // [sp+108Ch] [bp-20h]
  void *ptr; // [sp+1094h] [bp-18h]
  int j; // [sp+1098h] [bp-14h]
  int i; // [sp+109Ch] [bp-10h]

  V_LOCK();
  sub_77CE8((int)v7, *(int *)(a1 + 252));
  logfmt_raw(
    v4,
    0x1000u,
    0,
    v8,
    v7[0],
    v7[1],
    v7[2],
    v7[3],
    v7[4],
    v7[5],
    v7[6],
    v8,
    "get start nonce offset %s chip_no %d",
    *(_DWORD *)(a1 + 336));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_start_nonce_offset_LTC_1491",
    39,
    749,
    20,
    v4);
  memset(s, 0, sizeof(s));
  LOBYTE(s[4]) = 1;
  ptr = malloc(12 * *(_DWORD *)(a1 + 336));
  for ( i = 0; i <= 1; ++i )
  {
    s[5] = 8 * (i + 2);
    memset(ptr, 0, 12 * *(_DWORD *)(a1 + 336));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, void *, int *, int, int, _DWORD))(a1 + 288))(
      a1,
      s,
      *(_DWORD *)(a1 + 336),
      ptr,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_77CE8((int)v9, *(int *)(a1 + 252));
      logfmt_raw(
        v4,
        0x1000u,
        0,
        v10,
        v9[0],
        v9[1],
        v9[2],
        v9[3],
        v9[4],
        v9[5],
        v9[6],
        v10,
        "start_nonce_offset asic %d, reg %02x SNO %08x",
        *((unsigned __int8 *)ptr + 12 * j + 4),
        *((unsigned __int16 *)ptr + 6 * j + 3),
        *((_DWORD *)ptr + 3 * j));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_start_nonce_offset_LTC_1491",
        39,
        762,
        40,
        v4);
    }
  }
  free(ptr);
  return v5;
}
// 7BFD0: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007C140) --------------------------------------------------------
int __fastcall sub_7C140(int a1, int a2)
{
  int v4; // [sp+4h] [bp-10F8h]
  char v7[60]; // [sp+40h] [bp-10BCh] BYREF
  int v8; // [sp+1040h] [bp-BCh] BYREF
  int v9; // [sp+1044h] [bp-B8h] BYREF
  _DWORD s[4]; // [sp+1048h] [bp-B4h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp-A4h] BYREF
  int v12; // [sp+1074h] [bp-88h]
  _DWORD v13[7]; // [sp+1078h] [bp-84h] BYREF
  int v14; // [sp+1094h] [bp-68h]
  _DWORD v15[7]; // [sp+1098h] [bp-64h] BYREF
  int v16; // [sp+10B4h] [bp-48h]
  _DWORD v17[7]; // [sp+10B8h] [bp-44h] BYREF
  int v18; // [sp+10D4h] [bp-28h]
  void *ptr; // [sp+10DCh] [bp-20h]
  int v20; // [sp+10E0h] [bp-1Ch]
  int v21; // [sp+10E4h] [bp-18h]
  int v22; // [sp+10E8h] [bp-14h]
  int i; // [sp+10ECh] [bp-10h]

  V_LOCK();
  sub_77CE8((int)v11, *(int *)(a1 + 252));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "set clock delay chip_no %d, value %08x",
    *(_DWORD *)(a1 + 336),
    a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_clock_delay_LTC_1491",
    32,
    777,
    40,
    v7);
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = 255;
  LOBYTE(s[3]) = -1;
  s[0] = a2;
  v21 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  if ( v21 >= 0 )
  {
    usleep((__useconds_t)"time");
    LOBYTE(s[3]) = 0;
    v22 = 0;
    v20 = *(_DWORD *)(a1 + 340) * *(_DWORD *)(a1 + 336);
    ptr = malloc(12 * v20);
    memset(ptr, 0, 12 * v20);
    (*(void (__fastcall **)(int, _DWORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
      a1,
      s,
      v20,
      ptr,
      &v9,
      v4,
      2000,
      0);
    for ( i = 0; i < v9; ++i )
    {
      v8 = 0;
      sub_78038(&v8, *((_DWORD *)ptr + 3 * i));
      if ( *((_WORD *)ptr + 6 * i + 3) == 255 )
      {
        ++v22;
        V_LOCK();
        sub_77CE8((int)v15, *(int *)(a1 + 252));
        logfmt_raw(
          v7,
          0x1000u,
          0,
          v16,
          v15[0],
          v15[1],
          v15[2],
          v15[3],
          v15[4],
          v15[5],
          v15[6],
          v16,
          "[DP] chip %02x, core %02x, reg %02x, clk_delay %08x",
          *((unsigned __int8 *)ptr + 12 * i + 4),
          *((unsigned __int8 *)ptr + 12 * i + 8),
          *((unsigned __int16 *)ptr + 6 * i + 3),
          v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/./backend/chip_setting.c",
          162,
          "ChipSetting_clock_delay_LTC_1491",
          32,
          802,
          20,
          v7);
      }
      else
      {
        V_LOCK();
        sub_77CE8((int)v17, *(int *)(a1 + 252));
        logfmt_raw(
          v7,
          0x1000u,
          0,
          v18,
          v17[0],
          v17[1],
          v17[2],
          v17[3],
          v17[4],
          v17[5],
          v17[6],
          v18,
          "[DP] chip %02x, expected reg %02x, but %02x, data %08x",
          *((unsigned __int8 *)ptr + 12 * i + 4),
          255,
          *((unsigned __int16 *)ptr + 6 * i + 3),
          v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/./backend/chip_setting.c",
          162,
          "ChipSetting_clock_delay_LTC_1491",
          32,
          805,
          100,
          v7);
      }
    }
    free(ptr);
    return v22;
  }
  else
  {
    V_LOCK();
    sub_77CE8((int)v13, *(int *)(a1 + 252));
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "%s failed, set reg:%02x",
      "ChipSetting_clock_delay_LTC_1491",
      HIWORD(s[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_clock_delay_LTC_1491",
      32,
      786,
      100,
      v7);
    return -1;
  }
}
// 7C448: variable 'v4' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007C714) --------------------------------------------------------
int __fastcall sub_7C714(int a1)
{
  int v3; // [sp+4h] [bp-10F8h]
  char v5[60]; // [sp+40h] [bp-10BCh] BYREF
  int v6; // [sp+1040h] [bp-BCh] BYREF
  int v7; // [sp+1044h] [bp-B8h] BYREF
  _DWORD s[4]; // [sp+1048h] [bp-B4h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp-A4h] BYREF
  int v10; // [sp+1074h] [bp-88h]
  _DWORD v11[7]; // [sp+1078h] [bp-84h] BYREF
  int v12; // [sp+1094h] [bp-68h]
  _DWORD v13[7]; // [sp+1098h] [bp-64h] BYREF
  int v14; // [sp+10B4h] [bp-48h]
  _DWORD v15[7]; // [sp+10B8h] [bp-44h] BYREF
  int v16; // [sp+10D4h] [bp-28h]
  void *ptr; // [sp+10DCh] [bp-20h]
  int v18; // [sp+10E0h] [bp-1Ch]
  int v19; // [sp+10E4h] [bp-18h]
  int v20; // [sp+10E8h] [bp-14h]
  int i; // [sp+10ECh] [bp-10h]

  V_LOCK();
  sub_77CE8((int)v9, *(int *)(a1 + 252));
  logfmt_raw(
    v5,
    0x1000u,
    0,
    v10,
    v9[0],
    v9[1],
    v9[2],
    v9[3],
    v9[4],
    v9[5],
    v9[6],
    v10,
    "get hash clock count chip_no %d",
    *(_DWORD *)(a1 + 336));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_hash_clock_count_LTC_1491",
    37,
    872,
    20,
    v5);
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = 255;
  s[0] = 1;
  LOBYTE(s[3]) = -1;
  v19 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  if ( v19 >= 0 )
  {
    usleep(0x4E20u);
    s[2] = 16711681;
    LOBYTE(s[3]) = 0;
    v20 = 0;
    v18 = *(_DWORD *)(a1 + 340) * *(_DWORD *)(a1 + 336);
    ptr = malloc(12 * v18);
    memset(ptr, 0, 12 * v18);
    (*(void (__fastcall **)(int, _DWORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
      a1,
      s,
      v18,
      ptr,
      &v7,
      v3,
      2000,
      0);
    for ( i = 0; i < v7; ++i )
    {
      v6 = 0;
      sub_78038(&v6, *((_DWORD *)ptr + 3 * i));
      if ( *((_WORD *)ptr + 6 * i + 3) == 255 )
      {
        ++v20;
        V_LOCK();
        sub_77CE8((int)v13, *(int *)(a1 + 252));
        logfmt_raw(
          v5,
          0x1000u,
          0,
          v14,
          v13[0],
          v13[1],
          v13[2],
          v13[3],
          v13[4],
          v13[5],
          v13[6],
          v14,
          "[Hash clk cnt] chip %02x, core %02x, reg %02x, clk_cnt %08x",
          *((unsigned __int8 *)ptr + 12 * i + 4),
          *((unsigned __int8 *)ptr + 12 * i + 8),
          *((unsigned __int16 *)ptr + 6 * i + 3),
          v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/./backend/chip_setting.c",
          162,
          "ChipSetting_hash_clock_count_LTC_1491",
          37,
          900,
          40,
          v5);
      }
      else
      {
        V_LOCK();
        sub_77CE8((int)v15, *(int *)(a1 + 252));
        logfmt_raw(
          v5,
          0x1000u,
          0,
          v16,
          v15[0],
          v15[1],
          v15[2],
          v15[3],
          v15[4],
          v15[5],
          v15[6],
          v16,
          "[Hash clk cnt] chip %02x, expected reg %02x, but %02x, clk_cnt %08x",
          *((unsigned __int8 *)ptr + 12 * i + 4),
          255,
          *((unsigned __int16 *)ptr + 6 * i + 3),
          v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/./backend/chip_setting.c",
          162,
          "ChipSetting_hash_clock_count_LTC_1491",
          37,
          903,
          100,
          v5);
      }
    }
    free(ptr);
    return v20;
  }
  else
  {
    V_LOCK();
    sub_77CE8((int)v11, *(int *)(a1 + 252));
    logfmt_raw(
      v5,
      0x1000u,
      0,
      v12,
      v11[0],
      v11[1],
      v11[2],
      v11[3],
      v11[4],
      v11[5],
      v11[6],
      v12,
      "%s failed, set reg:%02x",
      "ChipSetting_hash_clock_count_LTC_1491",
      HIWORD(s[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_hash_clock_count_LTC_1491",
      37,
      881,
      100,
      v5);
    return -1;
  }
}
// 7CA0C: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007CCD8) --------------------------------------------------------
int __fastcall sub_7CCD8(int a1, int a2)
{
  char v5[72]; // [sp+34h] [bp-1048h] BYREF
  _DWORD s[5]; // [sp+1034h] [bp-48h] BYREF
  _DWORD v7[7]; // [sp+1048h] [bp-34h] BYREF
  int v8; // [sp+1064h] [bp-18h]

  memset(s, 0, 0x10u);
  s[2] = 4194305;
  s[4] = a2;
  s[0] = a2;
  V_LOCK();
  sub_77CE8((int)v7, *(int *)(a1 + 252));
  logfmt_raw(v5, 0x1000u, 0, v8, v7[0], v7[1], v7[2], v7[3], v7[4], v7[5], v7[6], v8, "set analog value %08x", s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_analog_mux_LTC_1491",
    31,
    925,
    40,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007CE48) --------------------------------------------------------
int __fastcall sub_7CE48(int a1, unsigned __int8 a2, int a3)
{
  char v7[16]; // [sp+44h] [bp-1050h] BYREF
  _DWORD s[4]; // [sp+1044h] [bp-50h] BYREF
  int v9; // [sp+1054h] [bp-40h]
  _DWORD v10[7]; // [sp+1058h] [bp-3Ch] BYREF
  int v11; // [sp+1074h] [bp-20h]
  int v12; // [sp+107Ch] [bp-18h]
  int v13; // [sp+1080h] [bp-14h]
  int v14; // [sp+1084h] [bp-10h]

  v13 = 0;
  v12 = 1;
  v14 = 1;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = 92;
  v9 = (a3 << 16) | 3;
  s[0] = v9;
  V_LOCK();
  sub_77CE8((int)v10, *(int *)(a1 + 252));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "set uart relay, chip:%02x, %08x",
    a2,
    s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_uart_relay_LTC_1491",
    31,
    947,
    40,
    v7);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007D01C) --------------------------------------------------------
int __fastcall sub_7D01C(int a1, unsigned __int8 a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp-14h] BYREF
  __int64 v6; // [sp+18h] [bp-Ch]

  v5[1] = 0;
  v6 = a2;
  BYTE1(v6) = a3;
  WORD1(v6) = 255;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, v5);
}

//----- (0007D094) --------------------------------------------------------
int __fastcall sub_7D094(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  signed int v6; // r3
  int v12; // [sp+24h] [bp-30h] BYREF
  __int64 v13; // [sp+28h] [bp-2Ch] BYREF
  __int64 v14; // [sp+30h] [bp-24h]
  void *ptr; // [sp+38h] [bp-1Ch]
  size_t nmemb; // [sp+3Ch] [bp-18h]
  signed int j; // [sp+40h] [bp-14h]
  int i; // [sp+44h] [bp-10h]

  v13 = 0;
  v14 = 0;
  v6 = *(_DWORD *)(a1 + 336);
  if ( a6 < v6 )
    v6 = a6;
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  WORD1(v14) = 255;
  (*(void (__fastcall **)(int, __int64 *, size_t, void *, int *))(a1 + 288))(a1, &v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(*(_DWORD *)(a1 + 492) + j) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && a3 == *((unsigned __int8 *)ptr + 4) )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (0007D274) --------------------------------------------------------
int __fastcall sub_7D274(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, int a7)
{
  if ( sub_7D01C(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * a7);
  memset(a6, 0, 4 * a7);
  return sub_7D094(a1, a2, a3, s, a6, a7);
}

//----- (0007D338) --------------------------------------------------------
int __fastcall sub_7D338(int a1, int a2, _DWORD *a3, int a4)
{
  int v9; // [sp+28h] [bp-14h]
  _DWORD *ptr; // [sp+2Ch] [bp-10h]
  _DWORD *s; // [sp+30h] [bp-Ch]
  int i; // [sp+34h] [bp-8h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  *a3 = 0;
  v9 = sub_7D274(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(a2 + 4 * i) = HIBYTE(s[i]) - 64;
    a3[i] = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0007D470) --------------------------------------------------------
int __fastcall sub_7D470(int a1, int a2, _DWORD *a3, int a4)
{
  int v9; // [sp+28h] [bp-14h]
  _DWORD *ptr; // [sp+2Ch] [bp-10h]
  _DWORD *s; // [sp+30h] [bp-Ch]
  int i; // [sp+34h] [bp-8h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  *a3 = 0;
  v9 = sub_7D274(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(a2 + 4 * i) = HIBYTE(s[i]) - 64;
    a3[i] = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0007D5A8) --------------------------------------------------------
int __fastcall sub_7D5A8(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp-14h] BYREF
  unsigned int s; // [sp+24h] [bp-10h] BYREF
  int v10; // [sp+28h] [bp-Ch]
  unsigned int v11; // [sp+2Ch] [bp-8h]

  v10 = 0;
  *a3 = 0;
  *a2 = -64;
  v10 = sub_7D274(a1, 0, a4, 0, &s, &v8, 1);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 512) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (0007D670) --------------------------------------------------------
int __fastcall sub_7D670(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp-14h] BYREF
  unsigned int s; // [sp+24h] [bp-10h] BYREF
  int v10; // [sp+28h] [bp-Ch]
  unsigned int v11; // [sp+2Ch] [bp-8h]

  v10 = 0;
  *a3 = 0;
  *a2 = -64;
  v10 = sub_7D274(a1, 0, a4, 256, &s, &v8, 1);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 512) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (0007D738) --------------------------------------------------------
int __fastcall sub_7D738(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v10[12]; // [sp+20h] [bp-100Ch] BYREF
  char v11; // [sp+1023h] [bp-9h] BYREF
  int v12; // [sp+1024h] [bp-8h]

  *a3 = 0;
  *a2 = -64;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 252), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 252), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 252), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_read_sensor_temp_local_on_pic_LTC_1491",
        50,
        1110,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 252), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_read_sensor_temp_local_on_pic_LTC_1491",
      50,
      1099,
      20,
      v10);
    return v12;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007D9A0) --------------------------------------------------------
int __fastcall sub_7D9A0(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v10[12]; // [sp+20h] [bp-100Ch] BYREF
  char v11; // [sp+1023h] [bp-9h] BYREF
  int v12; // [sp+1024h] [bp-8h]

  *a3 = 0;
  *a2 = -64;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 252), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 252), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 252), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_read_sensor_temp_remote_on_pic_LTC_1491",
        51,
        1136,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 252), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_read_sensor_temp_remote_on_pic_LTC_1491",
      51,
      1125,
      20,
      v10);
    return v12;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007DC08) --------------------------------------------------------
int __fastcall sub_7DC08(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v10[56]; // [sp+44h] [bp-1038h] BYREF
  _BYTE v11[4]; // [sp+1044h] [bp-38h] BYREF
  _DWORD v12[7]; // [sp+1048h] [bp-34h] BYREF
  int v13; // [sp+1064h] [bp-18h]
  int v14; // [sp+106Ch] [bp-10h]

  V_LOCK();
  logfmt_raw(
    v10,
    0x1000u,
    0,
    "%s chain[%d] iic_addr:%d",
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_LTC_1491",
    *(_DWORD *)(a1 + 252),
    a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_read_sensor_temp_local_on_ctrlboard_LTC_1491",
    56,
    1150,
    20,
    v10);
  *a3 = 0;
  v14 = tsensor_read(*(_DWORD *)(a1 + 252), a4, 0, (int)v11, 2u);
  if ( v14 == 2 )
  {
    *a3 = 1;
    *a2 = v11[0];
    V_LOCK();
    sub_77CE8((int)v12, *(int *)(a1 + 252));
    logfmt_raw(
      v10,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      "read ctrlboard temp, local[%02x] %d",
      a4,
      *a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_LTC_1491",
      56,
      1162,
      20,
      v10);
    return v14;
  }
  else
  {
    *a2 = -64;
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *(_DWORD *)(a1 + 252));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_read_sensor_temp_local_on_ctrlboard_LTC_1491",
      56,
      1157,
      80,
      v10);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007DF0C) --------------------------------------------------------
int __fastcall sub_7DF0C(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  char v10[12]; // [sp+20h] [bp-100Ch] BYREF
  _BYTE v11[4]; // [sp+1020h] [bp-Ch] BYREF
  int v12; // [sp+1024h] [bp-8h]

  *a3 = 0;
  v12 = tsensor_read(*(_DWORD *)(a1 + 252), a4, 0, (int)v11, 2u);
  if ( v12 == 2 )
  {
    *a3 = 1;
    *a2 = v11[0] + *(unsigned __int8 *)(a1 + 1116);
    return v12;
  }
  else
  {
    *a2 = -64;
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "failed to read ctrlboard-temp for chain %d", *(_DWORD *)(a1 + 252));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_read_sensor_temp_remote_on_ctrlboard_LTC_1491",
      57,
      1176,
      80,
      v10,
      a4);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007E0A4) --------------------------------------------------------
int __fastcall sub_7E0A4(int a1)
{
  int v2; // [sp+8h] [bp-Ch]

  v2 = sub_7D01C(a1, 1u, 0, 26806532);
  usleep((__useconds_t)"time");
  return v2;
}

//----- (0007E0F8) --------------------------------------------------------
int __fastcall sub_7E0F8(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp-18h] BYREF
  int v4; // [sp+1Ch] [bp-8h]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep((__useconds_t)"time");
  return v4;
}

//----- (0007E178) --------------------------------------------------------
int __fastcall sub_7E178(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r3
  char v8[72]; // [sp+44h] [bp-1048h] BYREF
  int v9; // [sp+1044h] [bp-48h] BYREF
  _WORD s[8]; // [sp+1048h] [bp-44h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp-34h] BYREF
  int v12; // [sp+1074h] [bp-18h]
  void *src; // [sp+1078h] [bp-14h]
  int i; // [sp+107Ch] [bp-10h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  s[4] = 1;
  s[5] = 52;
  src = malloc(12 * *(_DWORD *)(a1 + 424));
  memset(src, 0, 12 * *(_DWORD *)(a1 + 424));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, void *, int *))(a1 + 288))(a1, s, *(_DWORD *)(a1 + 424), src, &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *((_WORD *)src + 6 * i + 3) == 52 )
    {
      V_LOCK();
      sub_77CE8((int)v11, *(int *)(a1 + 252));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)src + 12 * i + 4),
        *((unsigned __int16 *)src + 6 * i + 3),
        *((_DWORD *)src + 3 * i));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_get_crc_status_LTC_1491",
        35,
        1223,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = a3;
    if ( *(_DWORD *)(a1 + 424) < a3 )
      v3 = *(_DWORD *)(a1 + 424);
    memcpy(a2, src, 12 * v3);
  }
  free(src);
  return v9;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007E454) --------------------------------------------------------
int __fastcall sub_7E454(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp-24h] BYREF
  _DWORD s[4]; // [sp+24h] [bp-20h] BYREF
  void *ptr; // [sp+34h] [bp-10h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 292))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (0007E534) --------------------------------------------------------
unsigned int __fastcall sub_7E534(int a1, int a2, void *a3)
{
  unsigned int v3; // r3
  char v8[72]; // [sp+44h] [bp-1048h] BYREF
  unsigned int v9; // [sp+1044h] [bp-48h] BYREF
  _WORD s[8]; // [sp+1048h] [bp-44h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp-34h] BYREF
  int v12; // [sp+1074h] [bp-18h]
  void *src; // [sp+1078h] [bp-14h]
  int i; // [sp+107Ch] [bp-10h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  s[4] = 1;
  s[5] = a2;
  src = malloc(0x528u);
  memset(src, 0, 0x528u);
  (*(void (__fastcall **)(int, _WORD *, int, void *, unsigned int *))(a1 + 288))(a1, s, 110, src, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( a2 == *((unsigned __int16 *)src + 6 * i + 3) )
    {
      V_LOCK();
      sub_77CE8((int)v11, *(int *)(a1 + 252));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)src + 12 * i + 4),
        *((unsigned __int16 *)src + 6 * i + 3),
        *((_DWORD *)src + 3 * i));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_get_chip_status_LTC_1491",
        36,
        1276,
        20,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = *(_DWORD *)(a1 + 424);
    if ( v3 >= v9 )
      v3 = v9;
    memcpy(a3, src, 12 * v3);
  }
  free(src);
  return v9;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007E7E0) --------------------------------------------------------
int __fastcall sub_7E7E0(int a1, char a2, char a3, int a4, void *dest)
{
  int v5; // r3
  char v11[72]; // [sp+44h] [bp-1048h] BYREF
  int v12; // [sp+1044h] [bp-48h] BYREF
  _WORD s[8]; // [sp+1048h] [bp-44h] BYREF
  _DWORD v14[7]; // [sp+1058h] [bp-34h] BYREF
  int v15; // [sp+1074h] [bp-18h]
  void *src; // [sp+1078h] [bp-14h]
  int i; // [sp+107Ch] [bp-10h]

  v12 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[4]) = a2;
  HIBYTE(s[4]) = a3;
  s[5] = a4;
  src = malloc(0xCu);
  memset(src, 0, 0xCu);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *))(a1 + 288))(a1, s, 1, src, &v12);
  for ( i = 0; i < v12; ++i )
  {
    if ( a4 == *((unsigned __int16 *)src + 6 * i + 3) )
    {
      V_LOCK();
      sub_77CE8((int)v14, *(int *)(a1 + 252));
      logfmt_raw(
        v11,
        0x1000u,
        0,
        v15,
        v14[0],
        v14[1],
        v14[2],
        v14[3],
        v14[4],
        v14[5],
        v14[6],
        v15,
        "[Chip status] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)src + 12 * i + 4),
        *((unsigned __int16 *)src + 6 * i + 3),
        *((_DWORD *)src + 3 * i));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/./backend/chip_setting.c",
        162,
        "ChipSetting_get_chip_status_rvn_LTC_1491",
        40,
        1308,
        40,
        v11);
    }
  }
  if ( dest )
  {
    v5 = v12;
    if ( v12 >= 1 )
      v5 = 1;
    memcpy(dest, src, 12 * v5);
  }
  free(src);
  return v12;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007EAA0) --------------------------------------------------------
int __fastcall sub_7EAA0(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp-14h] BYREF
  __int64 v5; // [sp+18h] [bp-Ch]

  v4[1] = 0;
  v5 = 1;
  WORD1(v5) = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, v4);
}

//----- (0007EB10) --------------------------------------------------------
int __fastcall sub_7EB10(int a1, char a2, __int16 a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp-14h] BYREF
  __int64 v6; // [sp+18h] [bp-Ch]

  v5[1] = 0;
  v6 = 0;
  BYTE1(v6) = a2;
  WORD1(v6) = a3;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, v5);
}

//----- (0007EB88) --------------------------------------------------------
int __fastcall sub_7EB88(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp-18h] BYREF

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
}

//----- (0007EC08) --------------------------------------------------------
int __fastcall sub_7EC08(int a1, __int16 a2, int a3, char a4)
{
  _DWORD s[4]; // [sp+14h] [bp-18h] BYREF

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = a4;
  s[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
}

//----- (0007EC90) --------------------------------------------------------
int __fastcall sub_7EC90(int a1)
{
  return (*(int (__fastcall **)(int))(a1 + 264))(a1);
}

//----- (0007ECC8) --------------------------------------------------------
int __fastcall sub_7ECC8(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp-18h] BYREF

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOWORD(s[3]) = 16128;
  s[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
}

//----- (0007ED50) --------------------------------------------------------
int __fastcall sub_7ED50(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp-18h] BYREF

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOWORD(s[3]) = 16128;
  s[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
}

//----- (0007EDD8) --------------------------------------------------------
int __fastcall sub_7EDD8(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp-18h] BYREF
  int v10; // [sp+24h] [bp-8h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  usleep((__useconds_t)&stru_13878.st_size);
  return v10;
}
// 13878: using guessed type Elf32_Sym stru_13878;

//----- (0007EE74) --------------------------------------------------------
int __fastcall sub_7EE74(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp-18h] BYREF
  int v11; // [sp+24h] [bp-8h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  usleep((__useconds_t)&stru_13878.st_size);
  return v11;
}
// 13878: using guessed type Elf32_Sym stru_13878;

//----- (0007EF14) --------------------------------------------------------
int __fastcall sub_7EF14(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp-18h] BYREF
  int v10; // [sp+24h] [bp-8h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  usleep((__useconds_t)&stru_13878.st_size);
  return v10;
}
// 13878: using guessed type Elf32_Sym stru_13878;

//----- (0007EFA8) --------------------------------------------------------
int __fastcall sub_7EFA8(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-1098h]
  char v8; // [sp+42h] [bp-105Ah]
  char v10[16]; // [sp+4Ch] [bp-1050h] BYREF
  int v11; // [sp+104Ch] [bp-50h] BYREF
  _WORD s[8]; // [sp+1050h] [bp-4Ch] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp-3Ch] BYREF
  int v14; // [sp+107Ch] [bp-20h]
  void *src; // [sp+1084h] [bp-18h]
  int i; // [sp+1088h] [bp-14h]
  int v17; // [sp+108Ch] [bp-10h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 424);
  if ( a2 == 255 )
    v17 = 136 * *(_DWORD *)(a1 + 424);
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_LTC_1491", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_get_core_status_LTC_1491",
    36,
    1446,
    20,
    v10);
  memset(s, 0, sizeof(s));
  s[4] = 1;
  src = malloc(12 * v17);
  s[5] = a3;
  LOBYTE(s[6]) = v8;
  memset(src, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
    a1,
    s,
    v17,
    src,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_77CE8((int)v13, *(int *)(a1 + 252));
    logfmt_raw(
      v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      *((unsigned __int8 *)src + 12 * i + 4),
      *((unsigned __int8 *)src + 12 * i + 8),
      *((unsigned __int16 *)src + 6 * i + 3),
      *((_DWORD *)src + 3 * i));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_core_status_LTC_1491",
      36,
      1458,
      20,
      v10);
  }
  if ( a4 )
    memcpy(a4, src, 12 * v17);
  free(src);
  return v11;
}
// 7F188: variable 'v5' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007F334) --------------------------------------------------------
int __fastcall sub_7F334(int a1, __int16 a2, __int16 a3, void *a4)
{
  char v7; // [sp+42h] [bp-105Ah]
  char v9[16]; // [sp+4Ch] [bp-1050h] BYREF
  int v10; // [sp+104Ch] [bp-50h] BYREF
  _WORD s[8]; // [sp+1050h] [bp-4Ch] BYREF
  _DWORD v12[7]; // [sp+1060h] [bp-3Ch] BYREF
  int v13; // [sp+107Ch] [bp-20h]
  void *src; // [sp+1084h] [bp-18h]
  int i; // [sp+1088h] [bp-14h]
  int v16; // [sp+108Ch] [bp-10h]

  v7 = a2;
  v10 = 0;
  v16 = *(_DWORD *)(a1 + 424);
  if ( a2 == 255 )
    v16 = 136 * *(_DWORD *)(a1 + 424);
  memset(s, 0, sizeof(s));
  s[4] = 1;
  src = malloc(12 * v16);
  s[5] = a3;
  LOBYTE(s[6]) = v7;
  memset(src, 0, 12 * v16);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *))(a1 + 300))(a1, s, v16, src, &v10);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s core_no %d, response_num %d", "ChipSetting_get_core_status_debug_LTC_1491", v16, v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_get_core_status_debug_LTC_1491",
    42,
    1483,
    40,
    v9);
  for ( i = 0; i < v10; ++i )
  {
    V_LOCK();
    sub_77CE8((int)v12, *(int *)(a1 + 252));
    logfmt_raw(
      v9,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      *((unsigned __int8 *)src + 12 * i + 4),
      *((unsigned __int8 *)src + 12 * i + 8),
      *((unsigned __int16 *)src + 6 * i + 3),
      *((_DWORD *)src + 3 * i));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_core_status_debug_LTC_1491",
      42,
      1486,
      40,
      v9);
  }
  if ( a4 )
    memcpy(a4, src, 12 * v16);
  free(src);
  return v10;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007F6C8) --------------------------------------------------------
int __fastcall sub_7F6C8(int a1, char a2, __int16 a3, void *a4)
{
  int v4; // r5
  int v5; // r6
  int v6; // r7
  unsigned int v7; // r0
  int v9; // [sp+4h] [bp-10A0h]
  char v14[24]; // [sp+4Ch] [bp-1058h] BYREF
  int v15; // [sp+104Ch] [bp-58h] BYREF
  _WORD s[8]; // [sp+1050h] [bp-54h] BYREF
  _DWORD v17[7]; // [sp+1060h] [bp-44h] BYREF
  int v18; // [sp+107Ch] [bp-28h]
  void *src; // [sp+1084h] [bp-20h]
  int i; // [sp+1088h] [bp-1Ch]
  int v21; // [sp+108Ch] [bp-18h]

  v15 = 0;
  v21 = *(_DWORD *)(a1 + 424) << 6;
  V_LOCK();
  logfmt_raw(v14, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_cache_done_status_rvn_LTC_1491", v21);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_get_cache_done_status_rvn_LTC_1491",
    46,
    1506,
    40,
    v14);
  memset(s, 0, sizeof(s));
  s[4] = 0;
  src = malloc(12 * v21);
  s[5] = a3;
  LOBYTE(s[6]) = a2;
  memset(src, 0, 12 * v21);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
    a1,
    s,
    v21,
    src,
    &v15,
    v9,
    2000,
    0);
  for ( i = 0; i < v15; ++i )
  {
    V_LOCK();
    sub_77CE8((int)v17, *(int *)(a1 + 252));
    v4 = *((unsigned __int8 *)src + 12 * i + 4);
    v5 = *((unsigned __int8 *)src + 12 * i + 8);
    v6 = sub_780E4(*((_WORD *)src + 6 * i + 3));
    v7 = sub_780BC(*((_DWORD *)src + 3 * i));
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v18,
      v17[0],
      v17[1],
      v17[2],
      v17[3],
      v17[4],
      v17[5],
      v17[6],
      v18,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v4,
      v5,
      v6,
      v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_cache_done_status_rvn_LTC_1491",
      46,
      1518,
      40,
      v14);
  }
  if ( a4 )
    memcpy(a4, src, 12 * v21);
  free(src);
  return v15;
}
// 7F87C: variable 'v9' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0007FA40) --------------------------------------------------------
int __fastcall sub_7FA40(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-1128h]
  int v6; // [sp+4h] [bp-1128h]
  int v7; // [sp+4h] [bp-1128h]
  int v8; // [sp+4h] [bp-1128h]
  int v9; // [sp+4h] [bp-1128h]
  char v12; // [sp+42h] [bp-10EAh]
  char v14[32]; // [sp+4Ch] [bp-10E0h] BYREF
  int v15; // [sp+104Ch] [bp-E0h] BYREF
  _WORD s[8]; // [sp+1050h] [bp-DCh] BYREF
  _DWORD v17[7]; // [sp+1060h] [bp-CCh] BYREF
  int v18; // [sp+107Ch] [bp-B0h]
  _DWORD v19[7]; // [sp+1080h] [bp-ACh] BYREF
  int v20; // [sp+109Ch] [bp-90h]
  _DWORD v21[7]; // [sp+10A0h] [bp-8Ch] BYREF
  int v22; // [sp+10BCh] [bp-70h]
  _DWORD v23[7]; // [sp+10C0h] [bp-6Ch] BYREF
  int v24; // [sp+10DCh] [bp-50h]
  _DWORD v25[7]; // [sp+10E0h] [bp-4Ch] BYREF
  int v26; // [sp+10FCh] [bp-30h]
  int m; // [sp+1104h] [bp-28h]
  int k; // [sp+1108h] [bp-24h]
  int j; // [sp+110Ch] [bp-20h]
  int i; // [sp+1110h] [bp-1Ch]
  int n; // [sp+1114h] [bp-18h]
  int v32; // [sp+1118h] [bp-14h]
  void *src; // [sp+111Ch] [bp-10h]

  v12 = a2;
  v15 = 0;
  v32 = *(_DWORD *)(a1 + 424);
  if ( a2 == 255 )
    v32 = 136 * *(_DWORD *)(a1 + 424);
  V_LOCK();
  logfmt_raw(v14, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_5chips_LTC_1491", v32);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_get_core_status_5chips_LTC_1491",
    43,
    1535,
    20,
    v14);
  memset(s, 0, sizeof(s));
  s[4] = 0;
  src = malloc(12 * v32);
  s[5] = a3;
  LOBYTE(s[6]) = v12;
  memset(src, 0, 12 * v32);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
    a1,
    s,
    v32,
    src,
    &v15,
    v5,
    2000,
    0);
  for ( i = 0; i < v15; ++i )
  {
    V_LOCK();
    sub_77CE8((int)v17, *(int *)(a1 + 252));
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v18,
      v17[0],
      v17[1],
      v17[2],
      v17[3],
      v17[4],
      v17[5],
      v17[6],
      v18,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      *((unsigned __int8 *)src + 12 * i + 4),
      *((unsigned __int8 *)src + 12 * i + 8),
      *((unsigned __int16 *)src + 6 * i + 3),
      *((_DWORD *)src + 3 * i));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_core_status_5chips_LTC_1491",
      43,
      1547,
      20,
      v14);
  }
  s[4] = 13056;
  src = malloc(12 * v32);
  s[5] = a3;
  LOBYTE(s[6]) = v12;
  memset(src, 0, 12 * v32);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
    a1,
    s,
    v32,
    src,
    &v15,
    v6,
    2000,
    0);
  for ( j = 0; j < v15; ++j )
  {
    V_LOCK();
    sub_77CE8((int)v19, *(int *)(a1 + 252));
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v20,
      v19[0],
      v19[1],
      v19[2],
      v19[3],
      v19[4],
      v19[5],
      v19[6],
      v20,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      *((unsigned __int8 *)src + 12 * j + 4),
      *((unsigned __int8 *)src + 12 * j + 8),
      *((unsigned __int16 *)src + 6 * j + 3),
      *((_DWORD *)src + 3 * j));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_core_status_5chips_LTC_1491",
      43,
      1558,
      20,
      v14);
  }
  s[4] = 26112;
  src = malloc(12 * v32);
  s[5] = a3;
  LOBYTE(s[6]) = v12;
  memset(src, 0, 12 * v32);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
    a1,
    s,
    v32,
    src,
    &v15,
    v7,
    2000,
    0);
  for ( k = 0; k < v15; ++k )
  {
    V_LOCK();
    sub_77CE8((int)v21, *(int *)(a1 + 252));
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v22,
      v21[0],
      v21[1],
      v21[2],
      v21[3],
      v21[4],
      v21[5],
      v21[6],
      v22,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      *((unsigned __int8 *)src + 12 * k + 4),
      *((unsigned __int8 *)src + 12 * k + 8),
      *((unsigned __int16 *)src + 6 * k + 3),
      *((_DWORD *)src + 3 * k));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_core_status_5chips_LTC_1491",
      43,
      1569,
      20,
      v14);
  }
  s[4] = -26368;
  src = malloc(12 * v32);
  s[5] = a3;
  LOBYTE(s[6]) = v12;
  memset(src, 0, 12 * v32);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
    a1,
    s,
    v32,
    src,
    &v15,
    v8,
    2000,
    0);
  for ( m = 0; m < v15; ++m )
  {
    V_LOCK();
    sub_77CE8((int)v23, *(int *)(a1 + 252));
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v24,
      v23[0],
      v23[1],
      v23[2],
      v23[3],
      v23[4],
      v23[5],
      v23[6],
      v24,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      *((unsigned __int8 *)src + 12 * m + 4),
      *((unsigned __int8 *)src + 12 * m + 8),
      *((unsigned __int16 *)src + 6 * m + 3),
      *((_DWORD *)src + 3 * m));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_core_status_5chips_LTC_1491",
      43,
      1580,
      20,
      v14);
  }
  s[4] = -13312;
  src = malloc(12 * v32);
  s[5] = a3;
  LOBYTE(s[6]) = v12;
  memset(src, 0, 12 * v32);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
    a1,
    s,
    v32,
    src,
    &v15,
    v9,
    2000,
    0);
  for ( n = 0; n < v15; ++n )
  {
    V_LOCK();
    sub_77CE8((int)v25, *(int *)(a1 + 252));
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v26,
      v25[0],
      v25[1],
      v25[2],
      v25[3],
      v25[4],
      v25[5],
      v25[6],
      v26,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      *((unsigned __int8 *)src + 12 * n + 4),
      *((unsigned __int8 *)src + 12 * n + 8),
      *((unsigned __int16 *)src + 6 * n + 3),
      *((_DWORD *)src + 3 * n));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_core_status_5chips_LTC_1491",
      43,
      1591,
      20,
      v14);
  }
  if ( a4 )
    memcpy(a4, src, 12 * v32);
  free(src);
  return v15;
}
// 7FC20: variable 'v5' is possibly undefined
// 7FE30: variable 'v6' is possibly undefined
// 80040: variable 'v7' is possibly undefined
// 80250: variable 'v8' is possibly undefined
// 80460: variable 'v9' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008060C) --------------------------------------------------------
int __fastcall sub_8060C(int a1, char a2, __int16 a3, __int16 a4, void *dest)
{
  char v7; // [sp+40h] [bp-105Ch]
  char v10[16]; // [sp+4Ch] [bp-1050h] BYREF
  int v11; // [sp+104Ch] [bp-50h] BYREF
  _WORD s[8]; // [sp+1050h] [bp-4Ch] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp-3Ch] BYREF
  int v14; // [sp+107Ch] [bp-20h]
  void *src; // [sp+1084h] [bp-18h]
  int i; // [sp+1088h] [bp-14h]
  int v17; // [sp+108Ch] [bp-10h]

  v7 = a3;
  v11 = 0;
  v17 = 1;
  if ( a3 == 255 )
    v17 = 136;
  memset(s, 0, sizeof(s));
  LOBYTE(s[4]) = 0;
  HIBYTE(s[4]) = a2;
  src = malloc(12 * v17);
  s[5] = a4;
  LOBYTE(s[6]) = v7;
  memset(src, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *))(a1 + 300))(a1, s, v17, src, &v11);
  V_LOCK();
  logfmt_raw(
    v10,
    0x1000u,
    0,
    "%s core_no %d response_num %d",
    "ChipSetting_get_single_chip_core_status_LTC_1491",
    v17,
    v11);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./backend/chip_setting.c",
    162,
    "ChipSetting_get_single_chip_core_status_LTC_1491",
    48,
    1615,
    40,
    v10);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_77CE8((int)v13, *(int *)(a1 + 252));
    logfmt_raw(
      v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      *((unsigned __int8 *)src + 12 * i + 4),
      *((unsigned __int8 *)src + 12 * i + 8),
      *((unsigned __int16 *)src + 6 * i + 3),
      *((_DWORD *)src + 3 * i));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/./backend/chip_setting.c",
      162,
      "ChipSetting_get_single_chip_core_status_LTC_1491",
      48,
      1618,
      40,
      v10);
  }
  if ( dest )
    memcpy(dest, src, 12 * v17);
  free(src);
  return v11;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00080984) --------------------------------------------------------
int __fastcall global_idx_init_ltc(int a1)
{
  void *s; // [sp+Ch] [bp-8h]

  s = malloc(0x6A08u);
  memset(s, 0, 0x6A08u);
  *(_DWORD *)(a1 + 824) = s;
  printf("__custom_data init %p\n", s);
  return 0;
}

//----- (000809E0) --------------------------------------------------------
int __fastcall global_idx_free_ltc(int a1)
{
  free(*(void **)(a1 + 824));
  return 0;
}

//----- (00080A10) --------------------------------------------------------
__int64 __fastcall sub_80A10(int a1, unsigned __int8 a2)
{
  int v2; // r0
  char v6[12]; // [sp+18h] [bp-200Ch] BYREF
  _BYTE v7[12]; // [sp+1018h] [bp-100Ch] BYREF
  int v8; // [sp+2018h] [bp-Ch]
  unsigned int i; // [sp+201Ch] [bp-8h]

  v8 = 0;
  for ( i = 0; i <= 0x4F; ++i )
  {
    v2 = snprintf(&v7[v8], 4096 - v8, "%02x ", *(unsigned __int8 *)(a1 + i + 72));
    v8 += v2;
  }
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "ltc dump work jobid %s, work count %02x", a1 + 8, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "dump_work_ltc",
    13,
    133,
    20,
    v6);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "dump work: %s", v7);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
           181,
           "dump_work_ltc",
           13,
           134,
           20,
           v6);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00080BE8) --------------------------------------------------------
int __fastcall sub_80BE8(int a1, int a2, int a3)
{
  unsigned int v4; // [sp+14h] [bp-18h]
  unsigned int v5; // [sp+20h] [bp-Ch]

  v5 = (_byteswap_ulong(*(_DWORD *)a3) - a2) << 7;
  v4 = v5 & 0xFE01FFFF
     | (((unsigned __int8)(v5 >> 17)
       - *(unsigned __int8 *)(*(_DWORD *)(a1 + 492) + (unsigned int)(unsigned __int8)(v5 >> 17) / *(_DWORD *)(a1 + 428))) << 17);
  *(_BYTE *)a3 = HIBYTE(v4);
  *(_BYTE *)(a3 + 1) = BYTE2(v4);
  *(_BYTE *)(a3 + 2) = BYTE1(v4);
  *(_BYTE *)(a3 + 3) = v4;
  return 0;
}

//----- (00080D30) --------------------------------------------------------
int __fastcall work_2_packet_ltc(int a1, int a2, _BYTE *a3, _DWORD *a4)
{
  char v4; // r3
  char v8[24]; // [sp+24h] [bp-1018h] BYREF
  __int16 v9; // [sp+1026h] [bp-16h]
  int v10; // [sp+1028h] [bp-14h]
  int v11; // [sp+102Ch] [bp-10h]
  int v12; // [sp+1030h] [bp-Ch]
  _BYTE *v13; // [sp+1034h] [bp-8h]

  v13 = a3;
  v12 = a2;
  v11 = 0;
  v10 = *(_DWORD *)(a1 + 824);
  *a3 = 85;
  v13[1] = -86;
  v13[2] = 32;
  if ( *(_DWORD *)(a1 + 496) == 1 )
    v13[2] |= 0x10u;
  *(_QWORD *)(v10 + 8 * *(unsigned __int8 *)(v10 + 27136)) = *(_QWORD *)v12;
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 27136) + 4864)) = *(_DWORD *)(v12 + 152);
  memcpy((void *)(v10 + 32 * (*(unsigned __int8 *)(v10 + 27136) + 624)), (const void *)(v12 + 156), 0x20u);
  strcpy((char *)(v10 + ((*(unsigned __int8 *)(v10 + 27136) + 16) << 6)), (const char *)(v12 + 8));
  memcpy((void *)(v10 + 80 * *(unsigned __int8 *)(v10 + 27136) + 9216), (const void *)(v12 + 72), 0x50u);
  memcpy(
    (void *)(v10 + 16 * (*(unsigned __int8 *)(v10 + 27136) + 1504)),
    (const void *)(v12 + 188),
    *(_DWORD *)(v12 + 204));
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 27136) + 6528)) = *(_DWORD *)(v12 + 204);
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 27136) + 6656)) = *(_DWORD *)(v12 + 208);
  v4 = *(_BYTE *)(v10 + 27136);
  *(_BYTE *)(v10 + 27136) = v4 + 1;
  v13[3] = v4;
  *(_BYTE *)(v10 + 27136) &= ~0x80u;
  rev(v12 + 72, 80);
  memcpy(v13 + 4, (const void *)(v12 + 76), 0x4Cu);
  v13[80] = *(_BYTE *)(v12 + 72);
  v13[81] = *(_BYTE *)(v12 + 73);
  v13[82] = *(_BYTE *)(v12 + 74);
  v13[83] = *(_BYTE *)(v12 + 75);
  if ( !memcmp(&unk_1612C0, (const void *)(v12 + 76), 0x4Cu) )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
      181,
      "work_2_packet_ltc",
      17,
      202,
      80,
      v8);
    sub_80A10(v12, v13[3]);
  }
  memcpy(&unk_1612C0, (const void *)(v12 + 76), 0x4Cu);
  v11 = 82;
  v9 = BM_CRC16(v13 + 2, 82);
  v13[84] = HIBYTE(v9);
  v13[85] = v9;
  *a4 = 86;
  if ( *(_BYTE *)(a1 + 257) && *(_BYTE *)(a1 + 258) )
  {
    memset(*(void **)(a1 + 456), 0, 48 * *(_DWORD *)(a1 + 336));
    chip_setting_ticket_mask_ltc(a1, 0xFFFu);
    chip_setting_misc_ltc(a1, 0, 0, 1, 0);
    *(_BYTE *)(a1 + 257) = 0;
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00081220) --------------------------------------------------------
__int64 __fastcall sub_81220(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  char v9[52]; // [sp+40h] [bp-2034h] BYREF
  _BYTE v10[52]; // [sp+1040h] [bp-1034h] BYREF
  _DWORD v11[7]; // [sp+2040h] [bp-34h] BYREF
  int v12; // [sp+205Ch] [bp-18h]
  unsigned int i; // [sp+2060h] [bp-14h]
  int v14; // [sp+2064h] [bp-10h]

  v14 = 0;
  for ( i = 0; i <= 3; ++i )
  {
    v3 = snprintf(&v10[v14], 4096 - v14, "%02x ", *(unsigned __int8 *)(a2 + i + 3));
    v14 += v3;
  }
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "work_id: %02x diff %02x", *(unsigned __int8 *)(a2 + 8), *(_BYTE *)(a2 + 7) & 0x3F);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "dump_nonce_ltc",
    14,
    233,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "back nonce: %s", v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "dump_nonce_ltc",
    14,
    234,
    20,
    v9);
  i = 0;
  v14 = 0;
  while ( i <= 3 )
  {
    v4 = snprintf(&v10[v14], 4096 - v14, "%02x ", *(unsigned __int8 *)(a3 + i + 80));
    v14 += v4;
    ++i;
  }
  V_LOCK();
  sub_77CE8((int)v11, *(int *)(a1 + 252));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "asic %d core %d addr_interval %d",
    *(_DWORD *)(a3 + 8),
    *(_DWORD *)(a3 + 12),
    *(_DWORD *)(a1 + 428));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "dump_nonce_ltc",
    14,
    240,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "nonce: %s", v10);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
           181,
           "dump_nonce_ltc",
           14,
           241,
           20,
           v9);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00081608) --------------------------------------------------------
int __fastcall packet_2_nonce_ltc(_DWORD *a1, int a2, int a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  int v8; // r0
  int v9; // r1
  int v13; // [sp+14h] [bp-18h]
  unsigned __int16 v14; // [sp+1Ah] [bp-12h]
  unsigned __int8 v15; // [sp+1Fh] [bp-Dh]

  if ( *(_BYTE *)(a2 + 9) >> 7 != 1 )
    return 100;
  v14 = BM_CRC5((_BYTE *)(a2 + 2), 0x3Bu);
  if ( v14 == (*(_BYTE *)(a2 + 9) & 0x1F) )
  {
    v13 = a1[206];
    *(_QWORD *)a3 = *(_QWORD *)(v13 + 8 * *(unsigned __int8 *)(a2 + 8));
    *a7 = *(_DWORD *)(v13 + 8 * *(unsigned __int8 *)(a2 + 8));
    strcpy((char *)(a3 + 16), (const char *)(v13 + ((*(unsigned __int8 *)(a2 + 8) + 16) << 6)));
    *(_DWORD *)(a3 + 80) = *(_DWORD *)(a2 + 3);
    *(_BYTE *)(a3 + 84) = *(_BYTE *)(a2 + 7);
    *(_BYTE *)(a3 + 85) = *(_BYTE *)(a2 + 8);
    memcpy(
      (void *)(a3 + 86),
      (const void *)(v13 + 16 * (*(unsigned __int8 *)(a2 + 8) + 1504)),
      *(_DWORD *)(v13 + 4 * (*(unsigned __int8 *)(a2 + 8) + 6528)));
    *(_DWORD *)(a3 + 104) = *(_DWORD *)(v13 + 4 * (*(unsigned __int8 *)(a2 + 8) + 6528));
    *(_DWORD *)(a3 + 108) = *(_DWORD *)(v13 + 4 * (*(unsigned __int8 *)(a2 + 8) + 6656));
    v15 = (unsigned int)*(unsigned __int8 *)(a2 + 4) / a1[107];
    if ( v15 >= (int)a1[84] )
    {
      v8 = rand();
      sub_CC7AC(v8, a1[84]);
      *a6 = v9;
    }
    else
    {
      *a6 = v15;
    }
    *(_DWORD *)(a3 + 8) = *a6;
    *(_DWORD *)(a3 + 12) = *(unsigned __int8 *)(a2 + 3);
    *a5 = *(_DWORD *)(a3 + 80);
    *a4 = 1;
    return 0;
  }
  else
  {
    printf(
      "chain[%d] get nonce crc error calc value %04x expected value %04x\n",
      a1[62],
      v14,
      *(_BYTE *)(a2 + 9) & 0x1F);
    return 101;
  }
}
// 8187C: variable 'v9' is possibly undefined

//----- (000818D8) --------------------------------------------------------
int __fastcall sub_818D8(_DWORD *a1)
{
  int (**v1)(); // r0
  int (**v2)(); // r0
  char v6[52]; // [sp+38h] [bp-1034h] BYREF
  _DWORD v7[7]; // [sp+1038h] [bp-34h] BYREF
  int v8; // [sp+1054h] [bp-18h]
  unsigned int v9; // [sp+1058h] [bp-14h]
  unsigned int i; // [sp+105Ch] [bp-10h]

  v9 = a1[84];
  for ( i = 0; i <= 2; ++i )
  {
    sub_781DC((int)a1, v9);
    V_LOCK();
    sub_77CE8((int)v7, (int)a1[63]);
    logfmt_raw(
      v6,
      0x1000u,
      0,
      v8,
      v7[0],
      v7[1],
      v7[2],
      v7[3],
      v7[4],
      v7[5],
      v7[6],
      v8,
      "detect chip num %d design num %d",
      a1[106],
      v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
      181,
      "check_asic_num_ltc",
      18,
      301,
      60,
      v6);
    if ( v9 != a1[106] )
    {
      usleep(0x493E0u);
      v1 = dev_ctrl();
      ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v1[6])(a1[62], a1[277], a1[282]);
      v2 = dev_ctrl();
      ((void (__fastcall *)(_DWORD))v2[11])(a1[62]);
    }
    if ( v9 == a1[106] )
      break;
  }
  if ( v9 == a1[106] )
    return 0;
  else
    return 102;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00081AEC) --------------------------------------------------------
int __fastcall get_chip_temperature_str_ltc(int a1, char *a2, unsigned int a3)
{
  size_t v3; // r3
  size_t v5; // [sp+4h] [bp-20h]
  unsigned int v8; // [sp+10h] [bp-14h]
  int j; // [sp+14h] [bp-10h]
  int i; // [sp+18h] [bp-Ch]
  int v11; // [sp+1Ch] [bp-8h]

  *a2 = 0;
  v3 = a3;
  if ( a3 >= 0xFA0 )
    v3 = 4000;
  v5 = v3;
  v11 = snprintf(a2, v3, "chain %d, chip temperature array:", *(_DWORD *)(a1 + 252));
  for ( i = 0; i <= 9; ++i )
  {
    v11 += snprintf(&a2[v11], v5 - v11, "\n");
    for ( j = 0; j <= 10; ++j )
    {
      v8 = dword_14FDF8[11 * i + j] - 1;
      if ( v8 > 0x6D )
        v11 += snprintf(&a2[v11], v5 - v11, "XXX ");
      else
        v11 += snprintf(&a2[v11], v5 - v11, "%3d ", *(_DWORD *)(*(_DWORD *)(a1 + 528) + 44 * v8));
    }
  }
  return 0;
}
// 14FDF8: using guessed type _DWORD dword_14FDF8[110];

//----- (00081CD0) --------------------------------------------------------
int __fastcall calc_chip_temp_min_max_avg_ltc(int a1, _DWORD *a2, _DWORD *a3, int *a4, _DWORD *a5)
{
  int v5; // r3
  _DWORD *base; // [sp+14h] [bp-20h]
  int k; // [sp+1Ch] [bp-18h]
  int j; // [sp+20h] [bp-14h]
  int i; // [sp+24h] [bp-10h]
  int v16; // [sp+28h] [bp-Ch]
  signed int v17; // [sp+2Ch] [bp-8h]

  v17 = 0;
  v16 = 0;
  *a5 = 1;
  base = malloc(4 * *(_DWORD *)(a1 + 336));
  for ( i = 0; i < *(_DWORD *)(a1 + 336); ++i )
  {
    pthread_mutex_lock((pthread_mutex_t *)(*(_DWORD *)(a1 + 528) + 44 * i + 20));
    base[i] = *(_DWORD *)(*(_DWORD *)(a1 + 528) + 44 * i);
    pthread_mutex_unlock((pthread_mutex_t *)(*(_DWORD *)(a1 + 528) + 44 * i + 20));
  }
  qsort(base, *(_DWORD *)(a1 + 336), 4u, (__compar_fn_t)cmpfunc_int);
  *a2 = -64;
  for ( j = 0; ; ++j )
  {
    v5 = *(_DWORD *)(a1 + 336) - 1;
    if ( v5 >= 5 )
      v5 = 5;
    if ( j >= v5 )
      break;
    if ( base[j] != -64 )
    {
      *a2 = base[j];
      break;
    }
  }
  *a3 = base[*(_DWORD *)(a1 + 336) - 1];
  if ( *a3 > *a2 + 55 )
    *a5 = 0;
  for ( k = 4; k < *(_DWORD *)(a1 + 336) - 4; ++k )
  {
    v16 += base[k];
    ++v17;
  }
  if ( v17 <= 0 )
    *a5 = 0;
  else
    *a4 = sub_CC518(v16, v17);
  free(base);
  if ( *a5 )
    return 4;
  else
    return 0;
}

//----- (00081F84) --------------------------------------------------------
int __fastcall sub_81F84(int a1, int a2, _DWORD *a3)
{
  int v3; // r0
  float v4; // s15
  int v5; // r3
  int v6; // r3
  char v11[40]; // [sp+44h] [bp-2068h] BYREF
  int v12; // [sp+1044h] [bp-1068h] BYREF
  _BYTE v13[36]; // [sp+1048h] [bp-1064h] BYREF
  int v14; // [sp+1FE8h] [bp-C4h]
  int v15; // [sp+1FECh] [bp-C0h] BYREF
  _DWORD s[4]; // [sp+1FF0h] [bp-BCh] BYREF
  _DWORD v17[7]; // [sp+2000h] [bp-ACh] BYREF
  int v18; // [sp+201Ch] [bp-90h]
  _DWORD v19[7]; // [sp+2020h] [bp-8Ch] BYREF
  int v20; // [sp+203Ch] [bp-70h]
  _DWORD v21[7]; // [sp+2040h] [bp-6Ch] BYREF
  int v22; // [sp+205Ch] [bp-50h]
  _DWORD v23[7]; // [sp+2060h] [bp-4Ch] BYREF
  int v24; // [sp+207Ch] [bp-30h]
  int v25; // [sp+2080h] [bp-2Ch]
  void *ptr; // [sp+2084h] [bp-28h]
  int v27; // [sp+2088h] [bp-24h]
  int v28; // [sp+208Ch] [bp-20h]
  int i; // [sp+2090h] [bp-1Ch]
  int j; // [sp+2094h] [bp-18h]
  int k; // [sp+2098h] [bp-14h]
  float v32; // [sp+209Ch] [bp-10h]

  v15 = 0;
  v32 = 0.0;
  v28 = 0;
  v14 = 285212672;
  *a3 = 1;
  for ( i = 0; i < *(_DWORD *)(a1 + 336); ++i )
    *(_DWORD *)(a2 + 4 * i) = -1031798784;
  memset(s, 0, sizeof(s));
  s[2] = 9175041;
  s[0] = v14;
  v27 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  v14 = 285343744;
  memset(s, 0, sizeof(s));
  s[2] = 9175041;
  s[0] = 285343744;
  v3 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  v27 |= v3;
  usleep(0xC350u);
  memset(s, 0, sizeof(s));
  s[2] = 9437185;
  ptr = malloc(12 * *(_DWORD *)(a1 + 336));
  memset(ptr, 0, 12 * *(_DWORD *)(a1 + 336));
  (*(void (__fastcall **)(int, _DWORD *, _DWORD, void *, int *))(a1 + 288))(a1, s, *(_DWORD *)(a1 + 336), ptr, &v15);
  for ( j = 0; ; ++j )
  {
    v6 = v15;
    if ( *(_DWORD *)(a1 + 336) < v15 )
      v6 = *(_DWORD *)(a1 + 336);
    if ( j >= v6 )
      break;
    if ( *((_WORD *)ptr + 6 * j + 3) == 144 )
    {
      V_LOCK();
      sub_77CE8((int)v17, *(int *)(a1 + 252));
      logfmt_raw(
        v11,
        0x1000u,
        0,
        v18,
        v17[0],
        v17[1],
        v17[2],
        v17[3],
        v17[4],
        v17[5],
        v17[6],
        v18,
        "[MISC CTRL] asic %02x, reg %02x state %08x",
        *((unsigned __int8 *)ptr + 12 * j + 4),
        *((unsigned __int16 *)ptr + 6 * j + 3),
        *((_DWORD *)ptr + 3 * j));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
        181,
        "update_chip_temp_ltc",
        20,
        436,
        20,
        v11);
      if ( (*((_DWORD *)ptr + 3 * j) & 0x80) != 0 )
      {
        v12 = 0;
        sub_78038(&v12, *((_DWORD *)ptr + 3 * j));
        v4 = ((double)(unsigned __int16)v12 - 0.5) * 662.88 / 4096.0 - 287.48;
        v32 = v4;
        v5 = *(_DWORD *)(a1 + 336) - 1;
        if ( v5 >= *((_BYTE *)ptr + 12 * j + 4) >> 1 )
          v5 = *((_BYTE *)ptr + 12 * j + 4) >> 1;
        v25 = v5;
        if ( (float)(*(float *)(a2 + 4 * v5) + 64.0) < 0.1 && (float)(*(float *)(a2 + 4 * v25) + 64.0) > -0.1 )
        {
          *(float *)(a2 + 4 * v25) = v32;
          ++v28;
        }
      }
    }
  }
  (*(void (__fastcall **)(int, _BYTE *, int))(a1 + 208))(a1, v13, 4000);
  V_LOCK();
  sub_77CE8((int)v19, *(int *)(a1 + 252));
  logfmt_raw(v11, 0x1000u, 0, v20, v19[0], v19[1], v19[2], v19[3], v19[4], v19[5], v19[6], v20, "%s", v13);
  V_UNLOCK();
  zlog(
    g_temp_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "update_chip_temp_ltc",
    20,
    454,
    40,
    v11);
  if ( *(_DWORD *)(a1 + 336) - v28 > 4 )
  {
    *a3 = 0;
    V_LOCK();
    sub_77CE8((int)v21, *(int *)(a1 + 252));
    logfmt_raw(
      v11,
      0x1000u,
      0,
      v22,
      v21[0],
      v21[1],
      v21[2],
      v21[3],
      v21[4],
      v21[5],
      v21[6],
      v22,
      "is_temp_return 0 design %d valid_return_num: %d",
      *(_DWORD *)(a1 + 336),
      v28);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
      181,
      "update_chip_temp_ltc",
      20,
      458,
      60,
      v11);
    sub_781DC(a1, *(_DWORD *)(a1 + 336));
    V_LOCK();
    sub_77CE8((int)v23, *(int *)(a1 + 252));
    logfmt_raw(
      v11,
      0x1000u,
      0,
      v24,
      v23[0],
      v23[1],
      v23[2],
      v23[3],
      v23[4],
      v23[5],
      v23[6],
      v24,
      "detect chip num %d design num %d",
      *(_DWORD *)(a1 + 424),
      *(_DWORD *)(a1 + 336));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
      181,
      "update_chip_temp_ltc",
      20,
      460,
      60,
      v11);
  }
  for ( k = 0; k < *(_DWORD *)(a1 + 336); ++k )
  {
    pthread_mutex_lock((pthread_mutex_t *)(*(_DWORD *)(a1 + 528) + 44 * k + 20));
    *(_DWORD *)(*(_DWORD *)(a1 + 528) + 44 * k) = (int)*(float *)(a2 + 4 * k);
    pthread_mutex_unlock((pthread_mutex_t *)(*(_DWORD *)(a1 + 528) + 44 * k + 20));
  }
  free(ptr);
  return v27;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 1608F4: using guessed type int g_temp_zc;

//----- (0008292C) --------------------------------------------------------
int __fastcall sub_8292C(int a1, int a2)
{
  int v2; // r1
  int v3; // r2
  int v4; // r3
  int v5; // r1
  int v6; // r2
  char v11[72]; // [sp+3Ch] [bp-12C8h] BYREF
  int v12; // [sp+103Ch] [bp-2C8h] BYREF
  int v13; // [sp+1040h] [bp-2C4h] BYREF
  int v14; // [sp+1044h] [bp-2C0h] BYREF
  int v15; // [sp+1048h] [bp-2BCh] BYREF
  int v16; // [sp+104Ch] [bp-2B8h] BYREF
  _BYTE v17[440]; // [sp+1050h] [bp-2B4h] BYREF
  int v18; // [sp+1208h] [bp-FCh]
  int v19; // [sp+120Ch] [bp-F8h]
  int v20; // [sp+1210h] [bp-F4h]
  int v21; // [sp+1214h] [bp-F0h]
  int v22; // [sp+1218h] [bp-ECh]
  int v23; // [sp+121Ch] [bp-E8h]
  int v24; // [sp+1220h] [bp-E4h]
  int v25; // [sp+1224h] [bp-E0h] BYREF
  _DWORD v26[7]; // [sp+1228h] [bp-DCh] BYREF
  int v27; // [sp+1244h] [bp-C0h]
  _DWORD v28[7]; // [sp+1248h] [bp-BCh] BYREF
  int v29; // [sp+1264h] [bp-A0h]
  _DWORD v30[7]; // [sp+1268h] [bp-9Ch] BYREF
  int v31; // [sp+1284h] [bp-80h]
  _DWORD v32[7]; // [sp+1288h] [bp-7Ch] BYREF
  int v33; // [sp+12A4h] [bp-60h]
  _DWORD v34[7]; // [sp+12A8h] [bp-5Ch] BYREF
  int v35; // [sp+12C4h] [bp-40h]
  _DWORD *v36; // [sp+12CCh] [bp-38h]
  int v37; // [sp+12D0h] [bp-34h]
  int j; // [sp+12D4h] [bp-30h]
  int i; // [sp+12D8h] [bp-2Ch]
  int k; // [sp+12DCh] [bp-28h]
  int m; // [sp+12E0h] [bp-24h]
  int v42; // [sp+12E4h] [bp-20h]

  v25 = -64;
  v42 = -64;
  v2 = *(_DWORD *)(a1 + 392);
  v3 = *(_DWORD *)(a1 + 396);
  v4 = *(_DWORD *)(a1 + 400);
  v18 = *(_DWORD *)(a1 + 388);
  v19 = v2;
  v20 = v3;
  v21 = v4;
  v5 = *(_DWORD *)(a1 + 408);
  v6 = *(_DWORD *)(a1 + 412);
  v22 = *(_DWORD *)(a1 + 404);
  v23 = v5;
  v24 = v6;
  v15 = -64;
  v14 = -64;
  v13 = -64;
  v37 = 0;
  if ( a2 )
  {
    if ( *(_BYTE *)(a1 + 256) )
    {
      for ( i = 0; i <= 2; ++i )
      {
        sub_81F84(a1, (int)v17, &v16);
        if ( v16 )
          break;
      }
      if ( v16 )
      {
        for ( j = 0; j < v20; ++j )
        {
          calc_chip_temp_min_max_avg_ltc(a1, &v15, &v14, &v13, &v16);
          if ( v16 )
          {
            *(_DWORD *)(a2 + 12 * j + 8) = v13;
            if ( *(_DWORD *)(v18 + 24 * j + 12) )
            {
              if ( *(_DWORD *)(v18 + 24 * j + 12) == 1 )
                *(_DWORD *)(a2 + 12 * j + 4) = v14;
            }
            else
            {
              *(_DWORD *)(a2 + 12 * j + 4) = v15;
            }
          }
          else
          {
            V_LOCK();
            sub_77CE8((int)v28, *(int *)(a1 + 252));
            logfmt_raw(
              v11,
              0x1000u,
              0,
              v29,
              v28[0],
              v28[1],
              v28[2],
              v28[3],
              v28[4],
              v28[5],
              v28[6],
              v29,
              "calc temp failed, sensors may occur errors");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
              181,
              "read_temperature_ltc",
              20,
              523,
              100,
              v11);
            *(_DWORD *)(a2 + 12 * j + 8) = -64;
            *(_DWORD *)(a2 + 12 * j + 4) = -64;
            v37 = 4;
          }
        }
      }
      else
      {
        V_LOCK();
        sub_77CE8((int)v30, *(int *)(a1 + 252));
        logfmt_raw(
          v11,
          0x1000u,
          0,
          v31,
          v30[0],
          v30[1],
          v30[2],
          v30[3],
          v30[4],
          v30[5],
          v30[6],
          v31,
          "failed getting chip temp");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
          181,
          "read_temperature_ltc",
          20,
          532,
          100,
          v11);
        for ( k = 0; k < v20; ++k )
        {
          *(_DWORD *)(a2 + 12 * k + 8) = -64;
          *(_DWORD *)(a2 + 12 * k + 4) = -64;
        }
        v37 = 4;
      }
    }
    for ( m = 0; m < v20; ++m )
    {
      v36 = (_DWORD *)(v18 + 24 * m);
      v12 = 0;
      (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 156))(
        a1,
        &v25,
        &v12,
        *v36,
        v36[1],
        v36[2],
        v36[3],
        v36[4],
        v36[5]);
      if ( v12 )
      {
        if ( v25 < -63 )
        {
          v25 = -64;
          V_LOCK();
          sub_77CE8((int)v32, *(int *)(a1 + 252));
          logfmt_raw(
            v11,
            0x1000u,
            0,
            v33,
            v32[0],
            v32[1],
            v32[2],
            v32[3],
            v32[4],
            v32[5],
            v32[6],
            v33,
            "got uneffective temp, sensor[%d], addr:%02x",
            *v36,
            v36[5]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
            181,
            "read_temperature_ltc",
            20,
            552,
            100,
            v11);
        }
      }
      else
      {
        v25 = -64;
        V_LOCK();
        sub_77CE8((int)v34, *(int *)(a1 + 252));
        logfmt_raw(
          v11,
          0x1000u,
          0,
          v35,
          v34[0],
          v34[1],
          v34[2],
          v34[3],
          v34[4],
          v34[5],
          v34[6],
          v35,
          "read sensor failed, sensor[%d], addr:%02x",
          *v36,
          v36[5]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
          181,
          "read_temperature_ltc",
          20,
          557,
          100,
          v11);
      }
      *(_DWORD *)(a2 + 12 * m) = v25;
    }
    return v37;
  }
  else
  {
    V_LOCK();
    sub_77CE8((int)v26, *(int *)(a1 + 252));
    logfmt_raw(
      v11,
      0x1000u,
      0,
      v27,
      v26[0],
      v26[1],
      v26[2],
      v26[3],
      v26[4],
      v26[5],
      v26[6],
      v27,
      "input sensor_status NULL error");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
      181,
      "read_temperature_ltc",
      20,
      493,
      100,
      v11);
    return 4;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000830DC) --------------------------------------------------------
int sub_830DC()
{
  return 106;
}

//----- (00083104) --------------------------------------------------------
int __fastcall sub_83104(int a1, int a2)
{
  if ( sub_79798(a1, a2) )
    return 109;
  else
    return 0;
}

//----- (00083148) --------------------------------------------------------
int __fastcall sub_83148(int a1, int a2)
{
  float v2; // s0
  char v5[8]; // [sp+24h] [bp-1008h] BYREF
  int v6; // [sp+1024h] [bp-8h]

  v6 = 0;
  chip_setting_freq_ltc(a1, 1, 0, a2);
  *(_QWORD *)(a1 + 1120) = (unsigned __int64)(205520896.0 / (double)(int)v2 * 70.0 / 100.0);
  *(_DWORD *)(a1 + 464) = (int)v2;
  V_LOCK();
  logfmt_raw(
    v5,
    0x1000u,
    0,
    "timeout %ld frequency %d",
    *(_DWORD *)(a1 + 1120),
    *(_DWORD *)(a1 + 1124),
    *(_DWORD *)(a1 + 464));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "set_frequency_ltc",
    17,
    627,
    20,
    v5);
  return v6;
}
// 831C4: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00083320) --------------------------------------------------------
int sub_83320()
{
  return 0;
}

//----- (00083350) --------------------------------------------------------
int __fastcall sub_83350(int a1, int a2)
{
  if ( sub_7CCD8(a1, a2) )
    return 109;
  else
    return 0;
}

//----- (00083394) --------------------------------------------------------
int __fastcall sub_83394(int a1)
{
  int i; // [sp+14h] [bp-8h]

  for ( i = 10; i < 2 * *(_DWORD *)(a1 + 336); i += 10 )
  {
    if ( sub_7CE48(a1, i, 15) )
      return 109;
  }
  return 0;
}

//----- (0008341C) --------------------------------------------------------
int sub_8341C()
{
  return 0;
}

//----- (00083440) --------------------------------------------------------
int sub_83440()
{
  return 0;
}

//----- (00083464) --------------------------------------------------------
int __fastcall sub_83464(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  v5 = sub_CC518(256, a2);
  for ( i = 0; i < a2; ++i )
    *(_BYTE *)(a1 + i) = v5 * i;
  return v5;
}

//----- (000834F4) --------------------------------------------------------
int __fastcall send_online_work_ltc(int a1)
{
  int (**v1)(); // r0
  _BYTE dest[88]; // [sp+8h] [bp-64h] BYREF
  int v6; // [sp+60h] [bp-Ch]
  int v7; // [sp+64h] [bp-8h]

  v7 = 10;
  memcpy(dest, &unk_1242BC, 0x56u);
  v6 = 86;
  puts("send online pattern");
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1072));
  v1 = dev_ctrl();
  ((void (__fastcall *)(_DWORD, _BYTE *, int))v1[13])(*(_DWORD *)(a1 + 248), dest, v6);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1072));
  while ( v7-- )
    usleep(0x2710u);
  return 0;
}

//----- (000835AC) --------------------------------------------------------
int __fastcall top_init_ltc(int a1)
{
  char v4[56]; // [sp+1Ch] [bp-1038h] BYREF
  float v5; // [sp+102Ch] [bp-28h]
  float v6; // [sp+1030h] [bp-24h]
  int v7; // [sp+1034h] [bp-20h]
  int v8; // [sp+1038h] [bp-1Ch]
  int v9; // [sp+103Ch] [bp-18h]
  int v10; // [sp+1040h] [bp-14h]
  float i; // [sp+1044h] [bp-10h]
  int j; // [sp+1048h] [bp-Ch]
  int v13; // [sp+104Ch] [bp-8h]

  v13 = *(_DWORD *)(a1 + 336);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get chip address %s ", "top_init_ltc");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "top_init_ltc",
    12,
    717,
    20,
    v4);
  if ( sub_818D8((_DWORD *)a1) )
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "get chip address failed ");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
      181,
      "top_init_ltc",
      12,
      719,
      100,
      v4);
    return 102;
  }
  else
  {
    *(_DWORD *)(a1 + 428) = sub_83464(*(_DWORD *)(a1 + 492), v13);
    (*(void (__fastcall **)(int, _DWORD, int))(a1 + 260))(a1, *(_DWORD *)(a1 + 492), v13);
    v10 = 0;
    v9 = 0;
    v8 = 0;
    v7 = 0;
    chip_setting_misc_ltc(a1, 0, 0, 0, 0);
    v6 = 50.0;
    v5 = 50.0;
    for ( i = (float)*(int *)(a1 + 464) - 50.0; i >= v6; i = i - v5 )
    {
      (*(void (__fastcall **)(int, _DWORD))(a1 + 192))(a1, 0);
      usleep((__useconds_t)sub_30D40);
    }
    for ( j = 0; j <= 2; ++j )
      (*(void (__fastcall **)(int))(a1 + 60))(a1);
    chip_setting_working_mode_ltc(a1, 1, 0, *(_DWORD *)(a1 + 340), 0, 0xFFu);
    chip_setting_core_error_ctrl_ltc(a1);
    (*(void (__fastcall **)(int))(a1 + 36))(a1);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008390C) --------------------------------------------------------
int __fastcall dhash_start_ltc(int a1)
{
  char v3[44]; // [sp+30h] [bp-102Ch] BYREF
  _DWORD v4[7]; // [sp+1030h] [bp-2Ch] BYREF
  int v5; // [sp+104Ch] [bp-10h]

  V_LOCK();
  sub_77CE8((int)v4, *(int *)(a1 + 252));
  logfmt_raw(v3, 0x1000u, 0, v5, v4[0], v4[1], v4[2], v4[3], v4[4], v4[5], v4[6], v5, "dhash_start_ltc");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "dhash_start_ltc",
    15,
    756,
    20,
    v3);
  *(_BYTE *)(a1 + 257) = 1;
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00083A04) --------------------------------------------------------
int mg_unpack()
{
  return 0;
}

//----- (00083A30) --------------------------------------------------------
int sub_83A30()
{
  return 0;
}

//----- (00083A5C) --------------------------------------------------------
int __fastcall sub_83A5C(int a1, int a2)
{
  float v2; // s0
  float v3; // s1
  char v7[16]; // [sp+24h] [bp-1010h] BYREF
  float v8; // [sp+1024h] [bp-10h]
  __useconds_t useconds; // [sp+1028h] [bp-Ch]
  int v10; // [sp+102Ch] [bp-8h]

  v10 = 1;
  useconds = (__useconds_t)"time";
  if ( v3 >= 25.0 )
    useconds = (__useconds_t)sub_30D40;
  v8 = v2;
  do
  {
    sub_7B9E4(a1, a2);
    usleep(useconds);
    v8 = v2 + (float)((float)v10++ * v3);
  }
  while ( v8 <= *(float *)(a1 + 1104) );
  v8 = v8 - v3;
  if ( v8 < *(float *)(a1 + 1104) )
  {
    sub_7B9E4(a1, a2);
    usleep(useconds);
    v8 = *(float *)(a1 + 1104);
  }
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "Set chip final freq=%.2f", v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "set_working_freq_by_steps",
    25,
    803,
    40,
    v7);
  return 0;
}
// 83AC8: variable 'v3' is possibly undefined
// 83AE4: variable 'v2' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00083CA0) --------------------------------------------------------
int __fastcall setup_all_chip_ltc(int a1)
{
  char v4[40]; // [sp+1Ch] [bp-1028h] BYREF
  _DWORD s[7]; // [sp+101Ch] [bp-28h] BYREF
  int v6; // [sp+1038h] [bp-Ch]
  int v7; // [sp+103Ch] [bp-8h]

  v6 = *(_DWORD *)(a1 + 336);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "%s", "setup_all_chip_ltc");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "setup_all_chip_ltc",
    18,
    811,
    60,
    v4);
  if ( !sub_818D8((_DWORD *)a1) )
    return 102;
  *(_DWORD *)(a1 + 428) = sub_83464(*(_DWORD *)(a1 + 492), v6);
  (*(void (__fastcall **)(int, _DWORD, int))(a1 + 260))(a1, *(_DWORD *)(a1 + 492), v6);
  v7 = 0;
  s[6] = 0;
  s[5] = 1;
  s[4] = 0;
  chip_setting_misc_ltc(a1, 0, 0, 1, 0);
  chip_setting_ticket_mask_ltc(a1, 0xFFFFFFFF);
  chip_setting_working_mode_ltc(a1, 1, 0, *(_DWORD *)(a1 + 340), 0, 0xFFu);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "reset nonce count %s %02x", "setup_all_chip_ltc", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "setup_all_chip_ltc",
    18,
    828,
    40,
    v4);
  memset(s, 0, 0x10u);
  s[2] = 3932161;
  s[0] = 0;
  (*(void (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  *(_DWORD *)(a1 + 464) = 900;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get addr after open cores");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
    181,
    "setup_all_chip_ltc",
    18,
    840,
    60,
    v4);
  if ( sub_818D8((_DWORD *)a1) )
    return 0;
  else
    return 102;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008401C) --------------------------------------------------------
int __fastcall set_baud_ltc(int a1, int a2)
{
  return chip_setting_buadrate_ltc(a1, a2);
}

//----- (0008404C) --------------------------------------------------------
int __fastcall sub_8404C(int a1, int a2)
{
  int i; // [sp+10h] [bp-Ch]
  unsigned __int8 v4; // [sp+17h] [bp-5h]

  v4 = 1;
  for ( i = 7; i >= 0; --i )
  {
    if ( *(_DWORD *)(a1 + 4 * i) > *(_DWORD *)(a2 + 4 * i) )
      return 0;
    if ( *(_DWORD *)(a1 + 4 * i) < *(_DWORD *)(a2 + 4 * i) )
      return 1;
  }
  return v4;
}

//----- (00084128) --------------------------------------------------------
int __fastcall check_nonce_ltc(int a1, int a2)
{
  int v4; // [sp+Ch] [bp-1098h]
  char v7[8]; // [sp+1Ch] [bp-1088h] BYREF
  unsigned int v8; // [sp+101Ch] [bp-88h]
  _DWORD v9[8]; // [sp+1020h] [bp-84h] BYREF
  _DWORD dest[20]; // [sp+1040h] [bp-64h] BYREF
  int v11; // [sp+1090h] [bp-14h]
  unsigned int v12; // [sp+1094h] [bp-10h]
  int v13; // [sp+1098h] [bp-Ch]
  unsigned __int8 v14; // [sp+109Fh] [bp-5h]

  v11 = a2;
  v13 = *(_DWORD *)(a1 + 824);
  v12 = *(_DWORD *)(v13 + 4 * (*(unsigned __int8 *)(a2 + 85) + 4864));
  memcpy(dest, (const void *)(v13 + 80 * *(unsigned __int8 *)(a2 + 85) + 9216), sizeof(dest));
  v8 = _byteswap_ulong(*(_DWORD *)(v11 + 80));
  dest[19] = v8;
  scrypt_regenhash(v9, (int)dest);
  v14 = target_to_diff_ltc((int)v9);
  if ( v14 > 0x1Bu )
  {
    if ( (*(_BYTE *)(v11 + 84) & 0x20) != 0 )
    {
      if ( v14 <= 0x2Fu )
      {
        V_LOCK();
        logfmt_raw(
          v7,
          0x1000u,
          0,
          "calculate diff %02x, but ans diff %02x (bit5 is 1)",
          v14,
          *(unsigned __int8 *)(v11 + 84));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
          181,
          "check_nonce_ltc",
          15,
          922,
          20,
          v7,
          a2,
          a1);
        return 3;
      }
    }
    else if ( v14 != *(unsigned __int8 *)(v11 + 84) + 16 )
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "diff not match, calculate %02x ans diff %02x", v14, *(unsigned __int8 *)(v11 + 84));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
        181,
        "check_nonce_ltc",
        15,
        927,
        20,
        v7,
        a2,
        a1);
      return 3;
    }
    if ( v12 > v14 || (unsigned __int8)sub_8404C((int)v9, v13 + 32 * (*(unsigned __int8 *)(v11 + 85) + 624)) != 1 )
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "hw diff (%d<%d) not reach pool", v14, v12);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
        181,
        "check_nonce_ltc",
        15,
        933,
        20,
        v7,
        a2,
        a1);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "hw error calculate diff %02x ans diff %02x TICKET_MASK_ZERO_COUNT_LTC %02x",
      v14,
      *(unsigned __int8 *)(v11 + 84),
      28,
      v4,
      a2,
      a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
      181,
      "check_nonce_ltc",
      15,
      916,
      20,
      v7);
    return 2;
  }
}
// 84284: variable 'v4' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00084520) --------------------------------------------------------
int get_chip_status_ltc()
{
  return 0;
}

//----- (00084548) --------------------------------------------------------
int __fastcall softreset_all_chip_ltc(int a1)
{
  chip_setting_software_reset_ltc(a1);
  chip_setting_ticket_mask_ltc(a1, 0xFFFFFFFF);
  return 0;
}

//----- (0008457C) --------------------------------------------------------
int __fastcall get_theory_hashrate_ltc(int a1, double *a2)
{
  *a2 = (double)*(int *)(a1 + 336) * (*(float *)(a1 + 1104) / 50176.0) * 2048.0 * 1000.0 * 1000.0;
  return 0;
}

//----- (00084610) --------------------------------------------------------
void sub_84610()
{
  ;
}

//----- (0008463C) --------------------------------------------------------
int __fastcall get_sale_hashrate_ltc(int a1, double *a2, _DWORD *a3)
{
  float v3; // s0
  double v8; // [sp+10h] [bp-14h] BYREF
  float v9; // [sp+18h] [bp-Ch]
  int v10; // [sp+1Ch] [bp-8h]

  v10 = 0;
  v8 = 0.0;
  v9 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 136))(a1, &v8);
  if ( strcmp((const char *)(a1 + 304), "L9") )
    return 205;
  sub_84610();
  v9 = v3;
  *a2 = v3 * v8;
  *a3 = 1;
  return v10;
}
// 846B4: variable 'v3' is possibly undefined

//----- (000846F8) --------------------------------------------------------
void sub_846F8()
{
  ;
}

//----- (00084724) --------------------------------------------------------
int __fastcall get_qualify_hashrate_ltc(int a1, double *a2)
{
  float v2; // s0
  double v6; // [sp+8h] [bp-14h] BYREF
  float v7; // [sp+10h] [bp-Ch]
  int v8; // [sp+14h] [bp-8h]

  v8 = 0;
  v6 = 0.0;
  v7 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 136))(a1, &v6);
  if ( strcmp((const char *)(a1 + 304), "L9") )
    return 205;
  sub_846F8();
  v7 = v2;
  *a2 = v2 * v6;
  return v8;
}
// 84798: variable 'v2' is possibly undefined

//----- (000847D0) --------------------------------------------------------
int __fastcall get_qualify_nonce_num_ltc(int a1, float *a2)
{
  unsigned __int64 v2; // d17
  double v3; // d8
  double v4; // r0
  float v5; // s15
  double v9; // [sp+8h] [bp-1Ch] BYREF
  int v10; // [sp+14h] [bp-10h]

  v10 = 0;
  v9 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 136))(a1, &v9);
  v3 = v9;
  LODWORD(v2) = *(_DWORD *)(a1 + 432);
  LODWORD(v4) = sub_CCAD4(vshld_u64(1u, v2));
  v5 = v3 / v4 / 110.0 * 0.1;
  *a2 = v5;
  return v10;
}
// 847D0: too many cbuild loops
// 84828: variable 'v2' is possibly undefined
// 84838: variable 'v4' is possibly undefined

//----- (00084888) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_ltc(int a1)
{
  if ( !sub_7E0A4(a1) )
    *(_DWORD *)(a1 + 512) = 1;
  return 0;
}

//----- (000848C8) --------------------------------------------------------
int __fastcall read_sensor_temp_local_ltc(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int v11; // [sp+14h] [bp-8h]

  v11 = -1;
  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v11 = sub_7D5A8(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 492) + a9));
    }
    else if ( a6 == 2 )
    {
      v11 = sub_7DC08(a1, a2, a3, a9);
    }
  }
  else
  {
    v11 = sub_7D738(a1, a2, a3, a9);
  }
  if ( v11 == -1 )
    return 4;
  else
    return 0;
}

//----- (000849A0) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_ltc(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int v11; // [sp+14h] [bp-8h]

  v11 = -1;
  if ( a6 )
  {
    if ( a6 == 1 )
    {
      v11 = sub_7D670(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 492) + a9));
    }
    else if ( a6 == 2 )
    {
      v11 = sub_7DF0C(a1, a2, a3, a9);
    }
  }
  else
  {
    v11 = sub_7D9A0(a1, a2, a3, a9);
  }
  if ( v11 == -1 )
    return 4;
  else
    return 0;
}

//----- (00084A78) --------------------------------------------------------
int __fastcall parameter_update_ltc(int a1, char a2, int a3, char a4, int a5)
{
  if ( *(_BYTE *)(a1 + 256) != 1 )
  {
    if ( a2 && a3 >= 900 && a3 <= 1500 )
      *(float *)(a1 + 1104) = (float)a3;
    if ( a4 && a5 > 1319 && a5 <= 1500 )
      *(_DWORD *)(a1 + 1108) = a5;
  }
  return 0;
}

//----- (00084B44) --------------------------------------------------------
int overclock_update_ltc()
{
  return 0;
}

//----- (00084B6C) --------------------------------------------------------
int get_pcba_test_level_ltc()
{
  return 0;
}

//----- (00084B94) --------------------------------------------------------
int __fastcall get_packet_remain_len_ltc(int a1)
{
  int v2; // [sp+Ch] [bp-8h]

  v2 = *(unsigned __int8 *)(a1 + 2) - 1;
  if ( v2 > 8 )
    return 8;
  return v2;
}

//----- (00084BE0) --------------------------------------------------------
int __fastcall adjust_working_freq_ltc(int a1, int a2)
{
  float v5; // [sp+8h] [bp-Ch]
  int v6; // [sp+Ch] [bp-8h]

  v6 = 108;
  v5 = (float)(*(_DWORD *)(a1 + 464) + a2);
  if ( v5 >= *(float *)(a1 + 1104) )
  {
    v5 = *(float *)(a1 + 1104);
    v6 = 0;
LABEL_5:
    chip_setting_freq_ltc(a1, 1, 0, 0);
    *(_DWORD *)(a1 + 464) = (int)v5;
    return v6;
  }
  if ( v5 >= 900.0 )
    goto LABEL_5;
  return 108;
}

//----- (00084CAC) --------------------------------------------------------
int __fastcall chip_temp_ltc_1491(int a1, int a2)
{
  float v2; // s15
  char v7[24]; // [sp+3Ch] [bp-3058h] BYREF
  int v8; // [sp+103Ch] [bp-2058h] BYREF
  int v9; // [sp+1040h] [bp-2054h]
  char v10[4096]; // [sp+1044h] [bp-2050h] BYREF
  char v11[4096]; // [sp+2044h] [bp-1050h] BYREF
  int v12; // [sp+3044h] [bp-50h] BYREF
  _DWORD s[4]; // [sp+3048h] [bp-4Ch] BYREF
  _DWORD v14[7]; // [sp+3058h] [bp-3Ch] BYREF
  int v15; // [sp+3074h] [bp-20h]
  void *ptr; // [sp+3078h] [bp-1Ch]
  int v17; // [sp+307Ch] [bp-18h]
  float v18; // [sp+3080h] [bp-14h]
  int i; // [sp+3084h] [bp-10h]

  v12 = 0;
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  v18 = 0.0;
  v9 = 285212672;
  memset(s, 0, sizeof(s));
  s[2] = 9175041;
  s[0] = 285212672;
  v17 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  v9 = 285343744;
  memset(s, 0, sizeof(s));
  s[2] = 9175041;
  s[0] = 285343744;
  v17 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  memset(s, 0, sizeof(s));
  s[2] = 9437185;
  ptr = malloc(12 * *(_DWORD *)(a1 + 336));
  memset(ptr, 0, 12 * *(_DWORD *)(a1 + 336));
  (*(void (__fastcall **)(int, _DWORD *, _DWORD, void *, int *))(a1 + 288))(a1, s, *(_DWORD *)(a1 + 336), ptr, &v12);
  for ( i = 0; i < v12; ++i )
  {
    if ( *((_WORD *)ptr + 6 * i + 3) != 144 || (*((_DWORD *)ptr + 3 * i) & 0x80) == 0 )
    {
      free(ptr);
      return 306;
    }
    V_LOCK();
    sub_77CE8((int)v14, *(int *)(a1 + 252));
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[MISC CTRL] asic %02x, reg %02x state %08x",
      *((unsigned __int8 *)ptr + 12 * i + 4),
      *((unsigned __int16 *)ptr + 6 * i + 3),
      *((_DWORD *)ptr + 3 * i));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/backend_ltc_1491.c",
      181,
      "chip_temp_ltc_1491",
      18,
      1149,
      20,
      v7);
    v8 = 0;
    sub_78038(&v8, *((_DWORD *)ptr + 3 * i));
    v2 = ((double)(unsigned __int16)v8 - 0.5) * 662.88 / 4096.0 - 287.48;
    v18 = v2;
    *(float *)(a2 + 4 * (*((_BYTE *)ptr + 12 * i + 4) >> 1)) = v2;
    sprintf(v10, "%.1f ", v18);
    strcat(v11, v10);
  }
  printf("line:\n%s\n", v11);
  free(ptr);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000851E8) --------------------------------------------------------
int __fastcall send_fake_work_ltc(int a1)
{
  int (**v1)(); // r0
  unsigned int v2; // r0
  int (**v3)(); // r0
  _BYTE dest[88]; // [sp+8h] [bp-64h] BYREF
  unsigned int v8; // [sp+60h] [bp-Ch]
  int v9; // [sp+64h] [bp-8h]

  v9 = 3;
  memcpy(dest, &unk_1244AC, 0x56u);
  v8 = 86;
  printf("send %d triger work\n", 3);
  while ( v9-- )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1072));
    do
    {
      v1 = dev_ctrl();
      v2 = ((int (__fastcall *)(_DWORD))v1[17])(*(_DWORD *)(a1 + 248));
    }
    while ( v8 > v2 );
    v3 = dev_ctrl();
    ((void (__fastcall *)(_DWORD, _BYTE *, unsigned int))v3[13])(*(_DWORD *)(a1 + 248), dest, v8);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1072));
    usleep(0x2710u);
  }
  return 0;
}

//----- (000852D4) --------------------------------------------------------
void *runtime_ctrl_ltc_1491()
{
  _QWORD v1[162]; // [sp+0h] [bp-58Ch] BYREF
  void *dest; // [sp+584h] [bp-8h]

  memset(v1, 0, sizeof(v1));
  LODWORD(v1[0]) = backend_init_base;
  HIDWORD(v1[0]) = reset_base;
  LODWORD(v1[2]) = dhash_mining_start_base;
  HIDWORD(v1[2]) = dhash_mining_stop_base;
  LODWORD(v1[3]) = dhash_mining_reset_base;
  HIDWORD(v1[3]) = backend_exit_base;
  LODWORD(v1[4]) = push_work_base;
  HIDWORD(v1[4]) = send_fake_work_ltc;
  LODWORD(v1[5]) = async_push_work_base;
  HIDWORD(v1[5]) = pop_ans_base;
  LODWORD(v1[6]) = try_pop_ans_base;
  HIDWORD(v1[7]) = softreset_all_chip_ltc;
  LODWORD(v1[8]) = setup_all_chip_ltc;
  HIDWORD(v1[8]) = work_2_packet_ltc;
  LODWORD(v1[9]) = packet_2_nonce_ltc;
  HIDWORD(v1[9]) = check_nonce_ltc;
  LODWORD(v1[10]) = global_idx_init_ltc;
  HIDWORD(v1[10]) = global_idx_free_ltc;
  LODWORD(v1[11]) = set_baud_ltc;
  HIDWORD(v1[11]) = 536796;
  v1[12] = 0x8335000083104LL;
  v1[13] = 0x8341C00083394LL;
  HIDWORD(v1[14]) = 539184;
  LODWORD(v1[15]) = 539140;
  HIDWORD(v1[16]) = get_chip_status_ltc;
  LODWORD(v1[17]) = get_theory_hashrate_ltc;
  HIDWORD(v1[17]) = get_sale_hashrate_ltc;
  LODWORD(v1[18]) = get_qualify_hashrate_ltc;
  HIDWORD(v1[18]) = get_qualify_nonce_num_ltc;
  LODWORD(v1[19]) = set_sensor_extern_mode_ltc;
  HIDWORD(v1[19]) = read_sensor_temp_local_ltc;
  LODWORD(v1[20]) = read_sensor_temp_remote_ltc;
  HIDWORD(v1[20]) = parameter_update_ltc;
  LODWORD(v1[21]) = overclock_update_ltc;
  HIDWORD(v1[21]) = get_pcba_test_level_ltc;
  LODWORD(v1[22]) = get_packet_remain_len_ltc;
  HIDWORD(v1[23]) = adjust_working_freq_ltc;
  LODWORD(v1[24]) = 536904;
  HIDWORD(v1[24]) = set_frequency_by_temp_single_base;
  v1[25] = 0x83320000832F8LL;
  LODWORD(v1[26]) = get_chip_temperature_str_ltc;
  HIDWORD(v1[26]) = set_frequency_single_base;
  HIDWORD(v1[27]) = sub_818D8;
  HIDWORD(v1[28]) = 534828;
  LODWORD(v1[29]) = top_init_ltc;
  LODWORD(v1[30]) = dhash_start_ltc;
  HIDWORD(v1[30]) = chip_temp_ltc_1491;
  HIDWORD(v1[32]) = set_chipaddr_base;
  LODWORD(v1[33]) = set_inactive_base;
  HIDWORD(v1[33]) = set_chip_reg_ltc;
  LODWORD(v1[34]) = set_core_reg_ltc;
  HIDWORD(v1[34]) = set_core_reg_ltc;
  LODWORD(v1[35]) = set_core_enable_ltc;
  HIDWORD(v1[35]) = sync_get_status_ltc;
  LODWORD(v1[36]) = sync_get_chip_reg_ltc;
  HIDWORD(v1[37]) = sync_get_core_reg_ltc;
  v1[38] = 14668;
  v1[39] = 0;
  strcpy((char *)&v1[40], "1491");
  *(_WORD *)((char *)&v1[40] + 5) = 0;
  HIBYTE(v1[40]) = 0;
  v1[41] = 0x100001491LL;
  v1[42] = 0x880000006ELL;
  v1[43] = 0x1000000800LL;
  HIDWORD(v1[44]) = 2;
  HIDWORD(v1[46]) = unk_14FFFC;
  LODWORD(v1[47]) = unk_150000;
  HIDWORD(v1[48]) = sensor_info_ltc_1491;
  v1[49] = qword_14FFE4;
  v1[50] = qword_14FFEC;
  v1[51] = qword_14FFF4;
  HIDWORD(v1[53]) = 2;
  LODWORD(v1[54]) = 28;
  LODWORD(v1[58]) = 900;
  HIDWORD(v1[65]) = 2;
  HIDWORD(v1[103]) = 216;
  v1[104] = 0x400000070LL;
  v1[105] = 0xA00000056LL;
  v1[106] = 0x300000008LL;
  HIDWORD(v1[137]) = 1147207680;
  v1[138] = 0x57844960000LL;
  v1[140] = 159849;
  LODWORD(v1[141]) = 1;
  dest = calloc(1u, 0x510u);
  memcpy(dest, v1, 0x510u);
  return dest;
}
// 14FFE0: using guessed type _UNKNOWN *sensor_info_ltc_1491;
// 14FFE4: using guessed type __int64;
// 14FFEC: using guessed type __int64;
// 14FFF4: using guessed type __int64;

//----- (000857A0) --------------------------------------------------------
int __fastcall set_chip_reg_ltc(int a1, int a2)
{
  char v3; // r0
  unsigned __int8 v6[2]; // [sp+Ch] [bp-10h] BYREF
  char v7; // [sp+Eh] [bp-Eh] BYREF
  __int64 v8; // [sp+Fh] [bp-Dh]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v8 = 0;
  v6[0] = 85;
  v6[1] = -86;
  v7 = 1;
  v7 = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1E | 0x41;
  LOBYTE(v8) = 9;
  BYTE1(v8) = *(_BYTE *)(a2 + 9);
  BYTE2(v8) = *(_WORD *)(a2 + 10);
  *(_DWORD *)((char *)&v8 + 3) = reverse_byte_order_32(*(_DWORD *)a2);
  v3 = BM_CRC5(&v7, 0x40u);
  HIBYTE(v8) = HIBYTE(v8) & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, v6, 0xBu);
  return 0;
}

//----- (000858C4) --------------------------------------------------------
int __fastcall sync_get_status_unclear_ltc(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _DWORD v13[2]; // [sp+14h] [bp-28h] BYREF
  char v14[2]; // [sp+1Ch] [bp-20h] BYREF
  int v15; // [sp+1Eh] [bp-1Eh] BYREF
  char v16; // [sp+22h] [bp-1Ah]
  unsigned __int8 v17; // [sp+23h] [bp-19h]
  unsigned __int8 v18; // [sp+24h] [bp-18h]
  int v19; // [sp+28h] [bp-14h]
  int v20; // [sp+2Ch] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  v20 = 0;
  v19 = 0;
  sub_CCDFC(a5, 0x3E8u);
  v13[1] = (_DWORD)&unk_F4240 * v6;
  v13[0] = sub_CCDFC(a5, 0x3E8u);
  while ( v20 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v14, 9u, v13) == 110 )
    {
      v19 = 3;
      break;
    }
    if ( (unsigned __int8)v14[0] != 170 || v14[1] != 85 || (v18 & 0x80) != 0 )
    {
      v19 = 1;
      break;
    }
    v7 = v18 & 0x1F;
    if ( v7 == BM_CRC5(&v15, 0x33u) )
    {
      *(_BYTE *)(a3 + 12 * v20 + 4) = v16;
      *(_WORD *)(a3 + 12 * v20 + 6) = v17;
      *(_DWORD *)(a3 + 12 * v20) = v15;
      *(_BYTE *)(a3 + 12 * v20++ + 9) = (v18 >> 5) & 3;
    }
    else
    {
      v19 = 2;
    }
  }
  *a4 = v20;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v19;
}
// 8593C: variable 'v6' is possibly undefined

//----- (00085AD8) --------------------------------------------------------
int __fastcall sync_get_status_ltc(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _DWORD v13[2]; // [sp+14h] [bp-28h] BYREF
  char v14[2]; // [sp+1Ch] [bp-20h] BYREF
  char v15; // [sp+1Eh] [bp-1Eh] BYREF
  int v16; // [sp+1Fh] [bp-1Dh]
  char v17; // [sp+23h] [bp-19h]
  unsigned __int8 v18; // [sp+24h] [bp-18h]
  char v19; // [sp+25h] [bp-17h]
  int v20; // [sp+28h] [bp-14h]
  int v21; // [sp+2Ch] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  v21 = 0;
  v20 = 0;
  sub_CCDFC(a5, 0x3E8u);
  v13[1] = (_DWORD)&unk_F4240 * v6;
  v13[0] = sub_CCDFC(a5, 0x3E8u);
  while ( v21 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v14, 0xAu, v13) == 110 )
    {
      v20 = 3;
      break;
    }
    if ( (unsigned __int8)v14[0] != 170 || v14[1] != 85 || (v19 & 0x40) != 0 || v19 < 0 )
    {
      v20 = 1;
      break;
    }
    v7 = v19 & 0x1F;
    if ( v7 == BM_CRC5(&v15, 0x3Bu) )
    {
      *(_BYTE *)(a3 + 12 * v21 + 4) = v17;
      *(_WORD *)(a3 + 12 * v21 + 6) = v18;
      *(_DWORD *)(a3 + 12 * v21++) = v16;
    }
    else
    {
      v20 = 2;
    }
  }
  *a4 = v21;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v20;
}
// 85B60: variable 'v6' is possibly undefined

//----- (00085CE8) --------------------------------------------------------
int __fastcall sync_get_chip_reg_ltc(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _DWORD v15[2]; // [sp+14h] [bp-30h] BYREF
  char v16[2]; // [sp+1Ch] [bp-28h] BYREF
  char v17; // [sp+1Eh] [bp-26h] BYREF
  int v18; // [sp+1Fh] [bp-25h]
  char v19; // [sp+23h] [bp-21h]
  unsigned __int8 v20; // [sp+24h] [bp-20h]
  char v21; // [sp+25h] [bp-1Fh]
  _BYTE v22[7]; // [sp+28h] [bp-1Ch] BYREF
  int v23; // [sp+30h] [bp-14h]
  int v24; // [sp+34h] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  *(_DWORD *)v22 = 174677;
  *(_DWORD *)&v22[3] = 0;
  v22[2] = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 2;
  v22[2] = v22[2] & 0x1F | 0x40;
  v22[3] = 5;
  v22[4] = *(_BYTE *)(a2 + 9);
  v22[5] = *(_WORD *)(a2 + 10);
  v7 = BM_CRC5(&v22[2], 0x20u);
  v22[6] = v22[6] & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  send_command_packet(a1, v22, 7u);
  v24 = 0;
  v23 = 0;
  sub_CCDFC(a6, 0x3E8u);
  v15[1] = (_DWORD)&unk_F4240 * v8;
  v15[0] = sub_CCDFC(a6, 0x3E8u);
  while ( v24 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v16, 0xAu, v15) == 110 )
    {
      v23 = 3;
      break;
    }
    if ( (unsigned __int8)v16[0] != 170 || v16[1] != 85 || (v21 & 0x40) != 0 || v21 < 0 )
    {
      v23 = 1;
      break;
    }
    v9 = v21 & 0x1F;
    if ( v9 == BM_CRC5(&v17, 0x3Bu) )
    {
      *(_BYTE *)(a4 + 12 * v24 + 4) = v19;
      *(_WORD *)(a4 + 12 * v24 + 6) = v20;
      *(_DWORD *)(a4 + 12 * v24++) = v18;
    }
    else
    {
      v23 = 2;
    }
  }
  *a5 = v24;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v23;
}
// 85E54: variable 'v8' is possibly undefined

//----- (00085FDC) --------------------------------------------------------
int __fastcall set_core_reg_ltc(int a1, int a2)
{
  int v3; // r3
  char v4; // r0
  unsigned __int8 v8[2]; // [sp+Ch] [bp-10h] BYREF
  char v9; // [sp+Eh] [bp-Eh] BYREF
  __int64 v10; // [sp+Fh] [bp-Dh]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  chip_setting_core_command_ltc(a1, *(unsigned __int8 *)(a2 + 13));
  v10 = 0;
  v8[0] = 85;
  v8[1] = -86;
  v9 = 4;
  v9 = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 4;
  v9 = v9 & 0x1F | 0x40;
  LOBYTE(v10) = 9;
  BYTE1(v10) = *(_BYTE *)(a2 + 9);
  BYTE2(v10) = *(_WORD *)(a2 + 10) & 0xF;
  BYTE3(v10) = *(_BYTE *)(a2 + 12);
  v3 = (unsigned __int8)BYTE2(*(_DWORD *)a2) | *(_DWORD *)a2 & 0xFF00 | (*(_DWORD *)a2 << 16) & 0xFF0000;
  BYTE4(v10) = BYTE2(*(_DWORD *)a2);
  BYTE5(v10) = BYTE1(v3);
  BYTE6(v10) = BYTE2(v3);
  v4 = BM_CRC5(&v9, 0x40u);
  HIBYTE(v10) = HIBYTE(v10) & 0xE0 | v4 & 0x1F;
  send_command_packet(a1, v8, 0xBu);
  return 0;
}

//----- (00086180) --------------------------------------------------------
int __fastcall sync_get_core_reg_ltc(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  char v15[48]; // [sp+34h] [bp-1030h] BYREF
  _DWORD v16[2]; // [sp+1034h] [bp-30h] BYREF
  char v17[2]; // [sp+103Ch] [bp-28h] BYREF
  char v18; // [sp+103Eh] [bp-26h] BYREF
  unsigned __int8 v19; // [sp+103Fh] [bp-25h]
  unsigned int v20; // [sp+1040h] [bp-24h]
  unsigned __int8 v21; // [sp+1044h] [bp-20h]
  unsigned __int8 v22; // [sp+1045h] [bp-1Fh]
  char v23; // [sp+1046h] [bp-1Eh]
  __int64 v24; // [sp+1048h] [bp-1Ch] BYREF
  int v25; // [sp+1050h] [bp-14h]
  int v26; // [sp+1054h] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  chip_setting_core_command_ltc(a1, *(unsigned __int8 *)(a2 + 13));
  v24 = 371285;
  BYTE2(v24) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 5;
  BYTE2(v24) = BYTE2(v24) & 0x1F | 0x40;
  BYTE3(v24) = 6;
  BYTE4(v24) = *(_BYTE *)(a2 + 9);
  BYTE5(v24) = *(_WORD *)(a2 + 10) & 0xF;
  BYTE6(v24) = *(_BYTE *)(a2 + 12);
  v7 = BM_CRC5((_BYTE *)&v24 + 2, 0x28u);
  HIBYTE(v24) = HIBYTE(v24) & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = *(unsigned __int8 *)(a2 + 13);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  send_command_packet(a1, (unsigned __int8 *)&v24, 8u);
  v26 = 0;
  v25 = 0;
  sub_CCDFC(a6, 0x3E8u);
  v16[1] = (_DWORD)&unk_F4240 * v8;
  v16[0] = sub_CCDFC(a6, 0x3E8u);
  while ( v26 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v17, 0xBu, v16) == 110 )
    {
      v25 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(
      v15,
      0x1000u,
      0,
      "get core reg: chip addr %02x core id %02x reg addr %02x reg value %02x%02x%02x%02x",
      v21,
      v19,
      v22,
      (unsigned __int8)v20,
      BYTE1(v20),
      BYTE2(v20),
      HIBYTE(v20));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/chip_reg_io_ltc_1491.c",
      185,
      "sync_get_core_reg_ltc",
      21,
      381,
      20,
      v15);
    if ( (unsigned __int8)v17[0] != 170 || v17[1] != 85 || (v23 & 0x40) == 0 || v23 < 0 )
    {
      v25 = 1;
      break;
    }
    v9 = v23 & 0x1F;
    if ( v9 == BM_CRC5(&v18, 0x43u) )
    {
      *(_BYTE *)(a4 + 12 * v26 + 4) = v21;
      *(_WORD *)(a4 + 12 * v26 + 6) = v22;
      *(_BYTE *)(a4 + 12 * v26 + 8) = v19;
      *(_DWORD *)(a4 + 12 * v26++) = _byteswap_ulong(v20);
    }
    else
    {
      v25 = 2;
    }
  }
  *a5 = v26;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v25;
}
// 863A0: variable 'v8' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00086660) --------------------------------------------------------
int __fastcall set_core_enable_ltc(int a1, int a2, __useconds_t a3)
{
  char v8[12]; // [sp+20h] [bp-100Ch] BYREF
  int v9; // [sp+1020h] [bp-Ch]
  int i; // [sp+1024h] [bp-8h]

  for ( i = 0; i < *(unsigned __int8 *)(a2 + 13); ++i )
  {
    *(_DWORD *)a2 = 34047;
    *(_WORD *)(a2 + 10) = 0;
    *(_BYTE *)(a2 + 12) = i;
    *(_BYTE *)(a2 + 14) = 0;
    *(_BYTE *)(a2 + 15) = 0;
    v9 = (*(int (__fastcall **)(int, int))(a1 + 276))(a1, a2);
    if ( v9 )
    {
      V_LOCK();
      logfmt_raw(
        v8,
        0x1000u,
        0,
        "%s failed, reg:%02x, core_id:%d",
        "set_core_enable_ltc",
        *(unsigned __int16 *)(a2 + 10),
        i);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_ltc_1491/chip_reg_io_ltc_1491.c",
        185,
        "set_core_enable_ltc",
        19,
        425,
        100,
        v8);
      return v9;
    }
    usleep(a3);
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00086850) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_86850(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (00086884) --------------------------------------------------------
int __fastcall sub_86884(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 868F0: variable 'v3' is possibly undefined

//----- (0008699C) --------------------------------------------------------
int __fastcall sub_8699C(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (00086A10) --------------------------------------------------------
int __fastcall sub_86A10(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00086B34) --------------------------------------------------------
_BYTE *__fastcall sub_86B34(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00086BA0) --------------------------------------------------------
_BYTE *__fastcall sub_86BA0(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (00086C24) --------------------------------------------------------
int __fastcall chip_setting_buadrate_ltc(int a1, int a2)
{
  _DWORD s[4]; // [sp+8h] [bp-1Ch] BYREF
  unsigned int v6; // [sp+18h] [bp-Ch]
  char v7; // [sp+1Ch] [bp-8h]
  char v8; // [sp+1Dh] [bp-7h]
  unsigned __int16 v9; // [sp+1Eh] [bp-6h]

  v6 = 0;
  v9 = 26;
  v8 = 0;
  v7 = 0;
  memset(s, 0, sizeof(s));
  s[2] = 6291457;
  if ( a2 == 921600 )
    goto LABEL_27;
  if ( a2 > 921600 )
  {
    if ( a2 != 3000000 )
    {
      if ( a2 <= 3000000 )
      {
        if ( a2 == 1500000 || a2 == 1562500 )
        {
          v9 = 1;
          goto LABEL_33;
        }
        if ( (_UNKNOWN *)a2 != &unk_FE502 )
          goto LABEL_32;
LABEL_27:
        v9 = 2;
        goto LABEL_33;
      }
      if ( a2 == 6250000 )
      {
        v9 = 1;
        v8 = 1;
        goto LABEL_33;
      }
      if ( a2 == 12500000 )
      {
        v9 = 0;
        v8 = 1;
        goto LABEL_33;
      }
      if ( a2 != 3125000 )
        goto LABEL_32;
    }
    v9 = 0;
    goto LABEL_33;
  }
  if ( (__int16 *)a2 == &word_1C200 )
    goto LABEL_29;
  if ( a2 > (int)&word_1C200 )
  {
    if ( a2 == 446429 || a2 == 460800 )
    {
      v9 = 6;
      goto LABEL_33;
    }
    if ( (__int16 *)a2 != &word_1C41C )
      goto LABEL_32;
LABEL_29:
    v9 = 26;
    goto LABEL_33;
  }
  switch ( a2 )
  {
    case 9600:
      goto LABEL_31;
    case 38400:
      v9 = 80;
      goto LABEL_33;
    case 9586:
LABEL_31:
      v9 = 325;
      goto LABEL_33;
  }
LABEL_32:
  v9 = 26;
LABEL_33:
  if ( v8 )
    chip_setting_freq_ltc(a1, 1, 0, 1);
  v6 = (unsigned int)&loc_1FF00 & (v9 << 8) | (16 * v7) & 0x30 | v8 & 1;
  s[0] = v6;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1C200: using guessed type __int16 word_1C200;
// 1C41C: using guessed type __int16 word_1C41C;

//----- (00086EA8) --------------------------------------------------------
int __fastcall chip_setting_software_reset_ltc(int a1)
{
  char v3[32]; // [sp+1Ch] [bp-1020h] BYREF
  _DWORD s[4]; // [sp+101Ch] [bp-20h] BYREF
  int v5; // [sp+102Ch] [bp-10h]
  int v6; // [sp+1030h] [bp-Ch]
  void *ptr; // [sp+1034h] [bp-8h]

  ptr = calloc(0x100u, 0xCu);
  v6 = 0;
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "chip_setting_software_reset_ltc", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_software_reset_ltc",
    31,
    139,
    20,
    v3);
  memset(s, 0, sizeof(s));
  s[2] = 4456449;
  s[0] = 3;
  v5 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  free(ptr);
  return v5;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00086FE8) --------------------------------------------------------
int __fastcall chip_setting_software_bridge_or_core_reset_ltc(int a1, int a2, int a3)
{
  char v7[24]; // [sp+24h] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+1024h] [bp-18h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "software_reset %s %02x", "chip_setting_software_bridge_or_core_reset_ltc", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_software_bridge_or_core_reset_ltc",
    46,
    158,
    20,
    v7);
  memset(s, 0, sizeof(s));
  s[2] = 4456449;
  s[0] = (2 * a2) | a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00087130) --------------------------------------------------------
int __fastcall chip_setting_misc_ltc(int a1, int a2, int a3, int a4, int a5)
{
  char v10[28]; // [sp+20h] [bp-101Ch] BYREF
  _DWORD s[4]; // [sp+1020h] [bp-1Ch] BYREF
  unsigned int v12; // [sp+1030h] [bp-Ch]

  memset(s, 0, sizeof(s));
  s[2] = 1835009;
  v12 = (a2 << 22) | (a3 << 21) | (a4 << 20) | (4 * a5) | 0xC1021F10;
  s[0] = v12;
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "set_misc value %08x", s[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_misc_ltc",
    21,
    184,
    20,
    v10);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000872BC) --------------------------------------------------------
int __fastcall chip_setting_core_command_ltc(int a1, int a2)
{
  int v4; // [sp+10h] [bp-1024h]
  char v6[24]; // [sp+1Ch] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+101Ch] [bp-18h] BYREF

  v4 = a2;
  if ( a2 >= *(_DWORD *)(a1 + 340) )
    v4 = *(_DWORD *)(a1 + 340);
  if ( v4 <= 0 )
    return 1;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "core_command %s %02x", "chip_setting_core_command_ltc", 148);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_core_command_ltc",
    29,
    200,
    20,
    v6);
  memset(s, 0, sizeof(s));
  s[2] = 9699329;
  s[0] = (unsigned __int8)v4 | 0x80000000;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008744C) --------------------------------------------------------
unsigned int *__fastcall sub_8744C(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int *v4; // [sp+2Ch] [bp-1030h]
  char v5[40]; // [sp+34h] [bp-1028h] BYREF
  float v6; // [sp+1034h] [bp-28h]
  int v7; // [sp+1038h] [bp-24h]
  float v8; // [sp+103Ch] [bp-20h]
  float v9; // [sp+1040h] [bp-1Ch]
  int k; // [sp+1044h] [bp-18h]
  int j; // [sp+1048h] [bp-14h]
  int v12; // [sp+104Ch] [bp-10h]
  signed int i; // [sp+1050h] [bp-Ch]
  float v14; // [sp+1054h] [bp-8h]

  v4 = result;
  v9 = 0.0;
  v14 = 0.0;
  v12 = 108;
  j = 0;
  k = 0;
  *result = -1069022960;
  for ( i = 2; i > 0; --i )
  {
    for ( j = 0; j <= 7; ++j )
    {
      for ( k = j; k >= 0; --k )
      {
        v8 = (float)((float)((float)((float)((float)(j + 1) * v1) * (float)(k + 1)) * (float)i) / 25.0) * 100.0;
        if ( (int)v8 % 100 <= 50 )
          v12 = (int)v8 / 100;
        else
          v12 = (int)v8 / 100 + 1;
        v9 = (float)((float)v12 * 25.0) / (float)i;
        if ( v12 <= 1066 && v12 > 7 && (i != 1 || v9 <= 13325.0) && v9 <= 3200.0 && v9 >= 1600.0 )
        {
          v7 = v9 > 2400.0;
          v2 = sub_CC518(25 * v12, i);
          v3 = sub_CC518(v2, j + 1);
          result = (unsigned int *)sub_CC518(v3, k + 1);
          v14 = (float)(int)result;
          *v4 = (v7 << 28)
              | (v12 << 16) & 0xFFF0000
              | ((_WORD)i << 8) & 0x3F00
              | (16 * (_BYTE)j) & 0x70
              | k & 7
              | 0xC0000000;
          v6 = fabsf(v14 - v1);
          if ( v6 < 3.0 )
          {
            V_LOCK();
            logfmt_raw(
              v5,
              0x1000u,
              0,
              "target_freq:%.2f actual_freq:%.2f,vco:%.2f fbdiv:%d refdiv:%d postdiv1:%d, postdiv2:%d",
              v1,
              v14,
              v9,
              v12,
              i,
              j,
              k);
            V_UNLOCK();
            return (unsigned int *)zlog(
                                     g_zc,
                                     "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildr"
                                     "oot/tmp/release/build/godminer-origin_godminer-branch1/backend/backend_ltc_1491/chi"
                                     "p_setting_ltc_1491.c",
                                     186,
                                     "inferred_plldivider_ltc",
                                     23,
                                     248,
                                     20,
                                     v5);
          }
          v14 = 0.0;
        }
      }
    }
  }
  return result;
}
// 874FC: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000878C0) --------------------------------------------------------
int __fastcall chip_setting_freq_ltc(int a1, char a2, int a3, int a4)
{
  float v4; // s0
  char v5; // r3
  float v6; // s15
  int v8; // [sp+4h] [bp-10A0h]
  int v9; // [sp+24h] [bp-1080h]
  char v14[24]; // [sp+4Ch] [bp-1058h] BYREF
  int v15; // [sp+104Ch] [bp-58h] BYREF
  int v16; // [sp+1050h] [bp-54h] BYREF
  _DWORD s[4]; // [sp+1054h] [bp-50h] BYREF
  unsigned int v18; // [sp+1064h] [bp-40h] BYREF
  _QWORD v19[2]; // [sp+1068h] [bp-3Ch] BYREF
  int v20; // [sp+1078h] [bp-2Ch]
  int v21; // [sp+107Ch] [bp-28h]
  int v22; // [sp+1080h] [bp-24h]
  int v23; // [sp+1084h] [bp-20h]
  void *v24; // [sp+1088h] [bp-1Ch]
  int v25; // [sp+108Ch] [bp-18h]
  float v26; // [sp+1090h] [bp-14h]
  float v27; // [sp+1094h] [bp-10h]

  v18 = 0;
  v16 = 0;
  v27 = 0.0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = a2;
  if ( a2 )
    v5 = 0;
  else
    v5 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a3);
  BYTE1(s[2]) = v5;
  if ( a4 )
  {
    if ( a4 == 1 )
      HIWORD(s[2]) = 12;
  }
  else
  {
    HIWORD(s[2]) = 8;
  }
  sub_8744C(&v18);
  v26 = v4;
  s[0] = v18;
  if ( a2 )
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v26, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
      186,
      "chip_setting_freq_ltc",
      21,
      280,
      20,
      v14);
  }
  v25 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = *(_BYTE *)(*(_DWORD *)(a1 + 492) + 109);
  HIWORD(s[2]) = 72;
  v24 = malloc(0xCu);
  memset(v24, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *, int, int, _DWORD))(a1 + 288))(
    a1,
    s,
    1,
    v24,
    &v16,
    v8,
    200,
    0);
  if ( (*(_DWORD *)v24 & 0x10000) != 0 )
  {
    v15 = 0;
    sub_86BA0(&v15, *(_DWORD *)v24);
    v6 = (double)(25 * (unsigned int)(unsigned __int16)v15) / 256.0;
    v27 = v6;
    V_LOCK();
    sub_86850((int)v19, *(int *)(a1 + 252));
    logfmt_raw(v14, 0x1000u, 0, v23, v19[0], v19[1], v20, v21, v22, v23, "get_cnt freq:%f", v9, v27);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
      186,
      "chip_setting_freq_ltc",
      21,
      300,
      20,
      v14);
  }
  return v25;
}
// 879EC: variable 'v4' is possibly undefined
// 87B5C: variable 'v8' is possibly undefined
// 87C2C: variable 'v9' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00087C98) --------------------------------------------------------
int __fastcall sweep_chip_setting_freq_ltc(int a1, char a2, int a3)
{
  float v3; // s0
  char v4; // r3
  char v9[32]; // [sp+24h] [bp-1020h] BYREF
  _DWORD s[4]; // [sp+1024h] [bp-20h] BYREF
  unsigned int v11; // [sp+1034h] [bp-10h] BYREF
  int v12; // [sp+1038h] [bp-Ch]
  float v13; // [sp+103Ch] [bp-8h]

  v11 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = a2;
  if ( a2 )
    v4 = 0;
  else
    v4 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a3);
  BYTE1(s[2]) = v4;
  HIWORD(s[2]) = 8;
  sub_8744C(&v11);
  v13 = v3;
  s[0] = v11;
  if ( a2 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v13, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
      186,
      "sweep_chip_setting_freq_ltc",
      27,
      320,
      20,
      v9);
  }
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x2710u);
  return v12;
}
// 87D6C: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00087E64) --------------------------------------------------------
int __fastcall chip_setting_ticket_mask_ltc(int a1, unsigned int a2)
{
  char v5[32]; // [sp+1Ch] [bp-1020h] BYREF
  _DWORD s[4]; // [sp+101Ch] [bp-20h] BYREF
  int v7; // [sp+102Ch] [bp-10h]
  unsigned int v8; // [sp+1030h] [bp-Ch]
  int v9; // [sp+1034h] [bp-8h]

  v9 = 0;
  v8 = a2;
  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %08x", "chip_setting_ticket_mask_ltc", 2, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_ticket_mask_ltc",
    28,
    337,
    20,
    v5);
  s[2] = 131073;
  s[0] = (unsigned __int16)a2;
  BYTE2(s[3]) = 1;
  LOBYTE(s[3]) = -1;
  BYTE1(s[3]) = *(_DWORD *)(a1 + 340);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  usleep(0x3E8u);
  s[2] = 262145;
  s[0] = HIWORD(a2);
  BYTE2(s[3]) = 1;
  LOBYTE(s[3]) = -1;
  BYTE1(s[3]) = *(_DWORD *)(a1 + 340);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  while ( (v8 & 1) != 0 )
  {
    ++v9;
    v8 >>= 1;
  }
  v9 += 16;
  *(_DWORD *)(a1 + 432) = v9;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "cal mask %d", v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_ticket_mask_ltc",
    28,
    366,
    20,
    v5);
  return v7;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00088130) --------------------------------------------------------
int __fastcall chip_setting_gen_nonce_cnt_ltc(int a1, int a2)
{
  char v5[24]; // [sp+1Ch] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+101Ch] [bp-18h] BYREF

  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "gen_nonce_cnt %s reg %02x value %08x", "chip_setting_gen_nonce_cnt_ltc", 3, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_gen_nonce_cnt_ltc",
    30,
    388,
    60,
    v5);
  s[2] = 196609;
  s[0] = (unsigned __int16)a2;
  BYTE2(s[3]) = 1;
  LOBYTE(s[3]) = -1;
  BYTE1(s[3]) = *(_DWORD *)(a1 + 340);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00088294) --------------------------------------------------------
bool __fastcall chip_setting_check_bist_ltc(int a1, unsigned __int8 a2, int a3, int a4)
{
  int v4; // r3
  char v5; // r3
  int v7; // [sp+4h] [bp-1098h]
  char v12[24]; // [sp+44h] [bp-1058h] BYREF
  int v13; // [sp+1044h] [bp-58h] BYREF
  _WORD v14[8]; // [sp+1048h] [bp-54h] BYREF
  _DWORD v15[7]; // [sp+1058h] [bp-44h] BYREF
  int v16; // [sp+1074h] [bp-28h]
  unsigned int v17; // [sp+1078h] [bp-24h]
  void *s; // [sp+107Ch] [bp-20h]
  int v19; // [sp+1080h] [bp-1Ch]
  int v20; // [sp+1084h] [bp-18h]
  _BOOL4 v21; // [sp+1088h] [bp-14h]
  int i; // [sp+108Ch] [bp-10h]

  v13 = 0;
  if ( a2 )
    v4 = *(_DWORD *)(a1 + 336);
  else
    v4 = 1;
  v20 = v4;
  v19 = 0;
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "check bist result, chip_all %d chip_no %d core %d ", a2, a3, a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_check_bist_ltc",
    27,
    408,
    20,
    v12);
  s = malloc(12 * v20);
  memset(s, 0, 12 * v20);
  memset(v14, 0, sizeof(v14));
  LOBYTE(v14[4]) = a2;
  if ( a2 )
    v5 = 0;
  else
    v5 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a3);
  HIBYTE(v14[4]) = v5;
  LOBYTE(v14[7]) = 0;
  HIBYTE(v14[6]) = 1;
  LOBYTE(v14[6]) = a4;
  v14[5] = 6;
  (*(void (__fastcall **)(int, _WORD *, int, void *, int *, int, int, _DWORD))(a1 + 300))(
    a1,
    v14,
    v20,
    s,
    &v13,
    v7,
    2000,
    0);
  for ( i = 0; i < v13; ++i )
  {
    v17 = (unsigned int)*((unsigned __int8 *)s + 12 * i + 4) / *(_DWORD *)(a1 + 428);
    v21 = *((_WORD *)s + 6 * i + 3) == 6 && (*((_DWORD *)s + 3 * i) & 0x1000000) != 0;
  }
  if ( v20 > v13 )
  {
    V_LOCK();
    sub_86850((int)v15, *(int *)(a1 + 252));
    logfmt_raw(
      v12,
      0x1000u,
      0,
      v16,
      v15[0],
      v15[1],
      v15[2],
      v15[3],
      v15[4],
      v15[5],
      v15[6],
      v16,
      "detected core %d get check bist results less than expect num(%d < %d)",
      a4,
      v13,
      v20);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
      186,
      "chip_setting_check_bist_ltc",
      27,
      441,
      80,
      v12);
  }
  free(s);
  return v21;
}
// 884CC: variable 'v7' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00088690) --------------------------------------------------------
int __fastcall chip_setting_reset_bist_ltc(int a1, char a2, int a3, char a4, int a5)
{
  char v5; // r3
  char v7; // r3
  char v13[44]; // [sp+20h] [bp-102Ch] BYREF
  _DWORD s[4]; // [sp+1020h] [bp-2Ch] BYREF
  int v15; // [sp+1030h] [bp-1Ch]
  int v16; // [sp+1034h] [bp-18h]
  int v17; // [sp+1038h] [bp-14h]
  int v18; // [sp+103Ch] [bp-10h]
  int i; // [sp+1040h] [bp-Ch]
  int j; // [sp+1044h] [bp-8h]

  V_LOCK();
  logfmt_raw(v13, 0x1000u, 0, "%s", "chip_setting_reset_bist_ltc");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_reset_bist_ltc",
    27,
    460,
    40,
    v13);
  if ( a4 )
  {
    v17 = 0;
    v18 = *(_DWORD *)(a1 + 340) - 1;
  }
  else
  {
    v18 = a5;
    v17 = a5;
  }
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = a2;
  if ( a2 )
    v5 = 0;
  else
    v5 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a3);
  BYTE1(s[2]) = v5;
  BYTE1(s[3]) = *(_DWORD *)(a1 + 340);
  for ( i = v17; i <= v18; ++i )
  {
    s[0] = 1024;
    HIWORD(s[2]) = 0;
    LOBYTE(s[3]) = i;
    BYTE2(s[3]) = 0;
    v15 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
    if ( v15 )
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "%s failed, reg:%02x, core_id:%d", "chip_setting_reset_bist_ltc", HIWORD(s[2]), i);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        186,
        "chip_setting_reset_bist_ltc",
        27,
        482,
        100,
        v13);
      return v15;
    }
    usleep(0x3E8u);
  }
  usleep(0x2710u);
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = a2;
  if ( a2 )
    v7 = 0;
  else
    v7 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a3);
  BYTE1(s[2]) = v7;
  BYTE1(s[3]) = *(_DWORD *)(a1 + 340);
  for ( j = v17; j <= v18; ++j )
  {
    s[0] = 4199424;
    HIWORD(s[2]) = 0;
    LOBYTE(s[3]) = j;
    BYTE2(s[3]) = 0;
    v16 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
    if ( v16 )
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "%s failed, reg:%02x, core_id:%d", "chip_setting_reset_bist_ltc", HIWORD(s[2]), j);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
        186,
        "chip_setting_reset_bist_ltc",
        27,
        503,
        100,
        v13);
      return v16;
    }
    usleep(0x3E8u);
  }
  usleep(0x2710u);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00088B1C) --------------------------------------------------------
int __fastcall chip_setting_core_error_ctrl_ltc(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp-18h] BYREF
  int v4; // [sp+1Ch] [bp-8h]

  memset(s, 0, sizeof(s));
  puts("chip_setting_core_error_ctrl_ltc");
  s[2] = 11010049;
  s[0] = -2140927048;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x3E8u);
  return v4;
}

//----- (00088BA8) --------------------------------------------------------
int __fastcall chip_setting_working_mode_ltc(int a1, char a2, int a3, char a4, int a5, unsigned __int8 a6)
{
  char v6; // r3
  char v13[24]; // [sp+24h] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+1024h] [bp-18h] BYREF
  int v15; // [sp+1034h] [bp-8h]

  V_LOCK();
  logfmt_raw(v13, 0x1000u, 0, "%s", "chip_setting_working_mode_ltc");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_working_mode_ltc",
    29,
    532,
    20,
    v13);
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = a2;
  if ( a2 )
    v6 = 0;
  else
    v6 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a3);
  BYTE1(s[2]) = v6;
  BYTE1(s[3]) = a4;
  s[0] = a6 | 0x400;
  HIWORD(s[2]) = 0;
  LOBYTE(s[3]) = -1;
  v15 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  if ( v15 )
  {
    V_LOCK();
    logfmt_raw(
      v13,
      0x1000u,
      0,
      "%s failed, chip_all %d chip_addr %02x reg:%02x, all core",
      "chip_setting_working_mode_ltc",
      LOBYTE(s[2]),
      BYTE1(s[2]),
      HIWORD(s[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
      186,
      "chip_setting_working_mode_ltc",
      29,
      546,
      100,
      v13);
    return v15;
  }
  else
  {
    usleep(0x3E8u);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00088DFC) --------------------------------------------------------
int __fastcall chip_setting_gen_nonce_count_ltc(int a1, char a2, int a3, char a4, char a5, __int16 a6)
{
  char v6; // r3
  char v13[24]; // [sp+24h] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+1024h] [bp-18h] BYREF
  int v15; // [sp+1034h] [bp-8h]

  V_LOCK();
  logfmt_raw(v13, 0x1000u, 0, "%s", "chip_setting_gen_nonce_count_ltc");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_gen_nonce_count_ltc",
    32,
    568,
    20,
    v13);
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = a2;
  if ( a2 )
    v6 = 0;
  else
    v6 = *(_BYTE *)(*(_DWORD *)(a1 + 492) + a3);
  BYTE1(s[2]) = v6;
  BYTE1(s[3]) = a4;
  s[0] = (a6 << 10) & 0x400;
  HIWORD(s[2]) = 3;
  LOBYTE(s[3]) = a5;
  v15 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  if ( v15 )
  {
    V_LOCK();
    logfmt_raw(
      v13,
      0x1000u,
      0,
      "%s failed, chip_all %d chip_addr %02x reg:%02x, all core",
      "chip_setting_gen_nonce_count_ltc",
      LOBYTE(s[2]),
      BYTE1(s[2]),
      HIWORD(s[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
      186,
      "chip_setting_gen_nonce_count_ltc",
      32,
      581,
      100,
      v13);
    return v15;
  }
  else
  {
    usleep(0x3E8u);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00089054) --------------------------------------------------------
int __fastcall chip_setting_share_mode_ltc(int a1)
{
  _DWORD s[5]; // [sp+Ch] [bp-18h] BYREF

  memset(s, 0, 0x10u);
  s[2] = 257;
  s[0] = 1279;
  LOBYTE(s[3]) = -1;
  BYTE2(s[3]) = 1;
  s[4] = (*(int (__fastcall **)(int, _DWORD *))(a1 + 272))(a1, s);
  usleep(0x3E8u);
  return 0;
}

//----- (000890E0) --------------------------------------------------------
int __fastcall chip_setting_io_drive_ltc(int a1)
{
  char v3[24]; // [sp+1Ch] [bp-1018h] BYREF
  _DWORD s[4]; // [sp+101Ch] [bp-18h] BYREF
  int v5; // [sp+102Ch] [bp-8h]

  memset(s, 0, sizeof(s));
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "io_drive_strenth %s reg %02x value %08x", "chip_setting_io_drive_ltc", 48, 489335);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_ltc_1491/chip_setting_ltc_1491.c",
    186,
    "chip_setting_io_drive_ltc",
    25,
    618,
    60,
    v3);
  s[2] = 3145729;
  s[0] = 489335;
  v5 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 268))(a1, s);
  usleep(0x3E8u);
  return v5;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00089210) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_89210(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (00089244) --------------------------------------------------------
int __fastcall sub_89244(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 892B0: variable 'v3' is possibly undefined

//----- (0008935C) --------------------------------------------------------
int __fastcall sub_8935C(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (000893D0) --------------------------------------------------------
int __fastcall sub_893D0(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000894F4) --------------------------------------------------------
_BYTE *__fastcall sub_894F4(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (00089560) --------------------------------------------------------
int __fastcall global_idx_init_x7(int a1)
{
  _BYTE *s; // [sp+Ch] [bp-8h]

  s = malloc(0xBF88u);
  memset(s, 0, 0xBF88u);
  s[49024] = 1;
  *(_DWORD *)(a1 + 824) = s;
  printf("__custom_data init %p\n", s);
  return 0;
}

//----- (000895CC) --------------------------------------------------------
int __fastcall global_idx_free_x7(int a1)
{
  free(*(void **)(a1 + 824));
  return 0;
}

//----- (000895FC) --------------------------------------------------------
__int64 __fastcall sub_895FC(int a1, unsigned __int8 a2)
{
  int v2; // r0
  char v6[12]; // [sp+18h] [bp-200Ch] BYREF
  _BYTE v7[12]; // [sp+1018h] [bp-100Ch] BYREF
  int v8; // [sp+2018h] [bp-Ch]
  unsigned int i; // [sp+201Ch] [bp-8h]

  v8 = 0;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 382); ++i )
  {
    v2 = snprintf(&v7[v8], 4096 - v8, "%02x ", *(unsigned __int8 *)(a1 + i + 184));
    v8 += v2;
  }
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "x7 dump work jobid %s, work count %02x", a1 + 120, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "dump_work_x7",
    12,
    107,
    40,
    v6);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "dump work: %s", v7);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
           179,
           "dump_work_x7",
           12,
           108,
           40,
           v6);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000897E8) --------------------------------------------------------
int __fastcall sub_897E8(int a1)
{
  int i; // [sp+8h] [bp-Ch]
  int v3; // [sp+Ch] [bp-8h]

  v3 = 0;
  for ( i = 31; i >= 0; --i )
  {
    if ( *(_BYTE *)(a1 + i) )
    {
      if ( *(unsigned __int8 *)(a1 + i) > 1u )
      {
        if ( *(unsigned __int8 *)(a1 + i) > 3u )
        {
          if ( *(unsigned __int8 *)(a1 + i) > 7u )
          {
            if ( *(unsigned __int8 *)(a1 + i) > 0xFu )
            {
              if ( *(unsigned __int8 *)(a1 + i) > 0x1Fu )
              {
                if ( *(unsigned __int8 *)(a1 + i) > 0x3Fu )
                {
                  if ( *(char *)(a1 + i) >= 0 )
                    ++v3;
                }
                else
                {
                  v3 += 2;
                }
              }
              else
              {
                v3 += 3;
              }
            }
            else
            {
              v3 += 4;
            }
          }
          else
          {
            v3 += 5;
          }
        }
        else
        {
          v3 += 6;
        }
      }
      else
      {
        v3 += 7;
      }
      return v3;
    }
    v3 += 8;
  }
  return v3;
}

//----- (00089984) --------------------------------------------------------
int __fastcall sub_89984(__int64 a1)
{
  __int64 src; // [sp+0h] [bp-34h] BYREF
  _BYTE v3[24]; // [sp+Ch] [bp-28h] BYREF
  _BYTE v4[8]; // [sp+24h] [bp-10h] BYREF

  src = a1;
  memset(v3, 0, sizeof(v3));
  memcpy(v4, &src, sizeof(v4));
  return (unsigned __int8)sub_897E8((int)v3);
}

//----- (000899E8) --------------------------------------------------------
int __fastcall work_2_packet_x7(int a1, int a2, void *a3, _DWORD *a4)
{
  char v4; // r3
  _BYTE *v5; // r3
  __int16 v6; // r0
  int v10; // [sp+20h] [bp-122Ch] BYREF
  char v11[36]; // [sp+228h] [bp-1024h] BYREF
  int v12; // [sp+1228h] [bp-24h]
  int v13; // [sp+122Ch] [bp-20h]
  int v14; // [sp+1230h] [bp-1Ch]
  int v15; // [sp+1234h] [bp-18h]
  void *src; // [sp+1238h] [bp-14h]
  int k; // [sp+123Ch] [bp-10h]
  int j; // [sp+1240h] [bp-Ch]
  int i; // [sp+1244h] [bp-8h]

  src = a3;
  v15 = a2;
  v14 = 0;
  wait_x7_chip_setting_not_pending(a1);
  v13 = *(_DWORD *)(a1 + 824);
  *(_BYTE *)src = 85;
  *((_BYTE *)src + 1) = -86;
  *((_BYTE *)src + 2) = 3;
  *((_BYTE *)src + 3) = -1;
  *((_BYTE *)src + 4) = -1;
  *((_BYTE *)src + 5) = *(_BYTE *)(v15 + 382) + 8;
  *((_BYTE *)src + 9) = *(_DWORD *)(a1 + 432);
  *((_BYTE *)src + 10) = 4;
  v12 = *(_DWORD *)(v15 + 383);
  if ( v12 == -1 )
  {
    v12 = 432 * *(_DWORD *)(a1 + 248);
    *(_DWORD *)(v15 + 383) = v12;
  }
  memset((void *)(v15 + 223), 0, 4u);
  *(_DWORD *)((char *)src + 11) = *(_DWORD *)(v15 + 383);
  *((_BYTE *)src + 15) = *(_BYTE *)(v15 + 382);
  memcpy((char *)src + 16, (const void *)(v15 + 184), *(unsigned __int8 *)(v15 + 382));
  *(_QWORD *)(v13 + 8 * *(unsigned __int8 *)(v13 + 49024)) = *(_QWORD *)v15;
  memcpy((void *)(v13 + ((*(unsigned __int8 *)(v13 + 49024) + 16) << 6)), (const void *)(v15 + 8), 0x40u);
  memcpy((void *)(v13 + 32 * (*(unsigned __int8 *)(v13 + 49024) + 288)), (const void *)(v15 + 72), 0x20u);
  *(_QWORD *)(v13 + 8 * (*(unsigned __int8 *)(v13 + 49024) + 1664)) = *(_QWORD *)(v15 + 104);
  *(_QWORD *)(v13 + 8 * (*(unsigned __int8 *)(v13 + 49024) + 1792)) = *(_QWORD *)(v15 + 112);
  strcpy((char *)(v13 + ((*(unsigned __int8 *)(v13 + 49024) + 240) << 6)), (const char *)(v15 + 120));
  memcpy(
    (void *)(v13 + 198 * *(unsigned __int8 *)(v13 + 49024) + 23552),
    (const void *)(v15 + 184),
    *(unsigned __int8 *)(v15 + 382));
  *(_BYTE *)(v13 + *(unsigned __int8 *)(v13 + 49024) + 48896) = *(_BYTE *)(v15 + 382);
  pthread_mutex_lock(&msg_ack_lock[*(_DWORD *)(a1 + 248)]);
  pthread_cond_broadcast(&msg_check_process_wakeup_cond[*(_DWORD *)(a1 + 248)]);
  v4 = *(_BYTE *)(v13 + 49024);
  *(_BYTE *)(v13 + 49024) = v4 + 1;
  *((_BYTE *)src + 8) = v4;
  pthread_mutex_unlock(&msg_ack_lock[*(_DWORD *)(a1 + 248)]);
  *(_BYTE *)(v13 + 49024) &= ~0x80u;
  if ( *(unsigned __int8 *)(v15 + 382) == (unsigned __int8)last_blob_len
    && !memcmp(&last_start_nonce_x7, (const void *)(v15 + 383), 4u)
    && !memcmp(&last_blob_x7, (const void *)(v15 + 184), (unsigned __int8)last_blob_len) )
  {
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "work_2_packet_x7",
      16,
      214,
      80,
      v11);
    sub_895FC(v15, *((_BYTE *)src + 8));
  }
  last_blob_len = *(_BYTE *)(v15 + 382);
  memcpy(&last_blob_x7, (const void *)(v15 + 184), *(unsigned __int8 *)(v15 + 382));
  last_start_nonce_x7 = *(_DWORD *)(v15 + 383);
  v5 = src;
  *((_BYTE *)src + 6) = 0;
  v5[7] = 0;
  v6 = BM_CRC16((char *)src, *(unsigned __int8 *)(v15 + 382) + 16);
  *((_WORD *)src + 3) = v6;
  *a4 = *(unsigned __int8 *)(v15 + 382) + 16;
  pthread_mutex_lock(&last_work_lock[*(_DWORD *)(a1 + 248)]);
  memcpy((char *)&last_work_packet + 214 * *(_DWORD *)(a1 + 248), src, 0xD6u);
  last_work_len[*(_DWORD *)(a1 + 248)] = *a4;
  pthread_mutex_unlock(&last_work_lock[*(_DWORD *)(a1 + 248)]);
  if ( *(_BYTE *)(a1 + 257) && *(_BYTE *)(a1 + 258) )
  {
    memset(*(void **)(a1 + 456), 0, 48 * *(_DWORD *)(a1 + 336));
    *(_BYTE *)(a1 + 257) = 0;
  }
  if ( memcmp((char *)&last_seed_hash_x7 + 32 * *(_DWORD *)(a1 + 248), (const void *)(v15 + 72), 0x20u) )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 336); ++i )
      pthread_mutex_lock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * i + 52));
    chip_setting_seed_x7(a1, (const void *)(v15 + 72), 0x20u, &v10, 0xFFu);
    memcpy((char *)&last_seed_hash_x7 + 32 * *(_DWORD *)(a1 + 248), (const void *)(v15 + 72), 0x20u);
    for ( j = 0; j < *(_DWORD *)(a1 + 336); ++j )
      pthread_mutex_unlock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * j + 52));
    for ( k = 0; k < *(_DWORD *)(a1 + 336); ++k )
      chip_seed_status_set_calculating(a1, k);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "new seed has come");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "work_2_packet_x7",
      16,
      267,
      40,
      v11);
    set_x7_chip_setting_pending(a1, 50);
    *a4 = 0;
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 16165C: using guessed type pthread_mutex_t msg_ack_lock[3];
// 1616A4: using guessed type _DWORD last_work_len[3];
// 1616B0: using guessed type pthread_cond_t msg_check_process_wakeup_cond[3];
// 161740: using guessed type _DWORD x7_chip_seed_status[3];
// 16174C: using guessed type char last_blob_len;
// 161750: using guessed type pthread_mutex_t last_work_lock[3];
// 161798: using guessed type int last_start_nonce_x7;

//----- (0008A348) --------------------------------------------------------
__int64 __fastcall sub_8A348(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  char v9[20]; // [sp+40h] [bp-2054h] BYREF
  char v10[20]; // [sp+1040h] [bp-1054h] BYREF
  _DWORD v11[7]; // [sp+2040h] [bp-54h] BYREF
  int v12; // [sp+205Ch] [bp-38h]
  _DWORD v13[7]; // [sp+2060h] [bp-34h] BYREF
  int v14; // [sp+207Ch] [bp-18h]
  unsigned int v15; // [sp+2080h] [bp-14h]
  int v16; // [sp+2084h] [bp-10h]

  v16 = 0;
  v3 = snprintf(v10, 0x1000u, "%08x ", *(_DWORD *)(a2 + 16));
  v16 += v3;
  V_LOCK();
  sub_89210((int)v11, *(int *)(a1 + 252));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "work_id: %02x",
    *(unsigned __int8 *)(a2 + 12));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "dump_nonce_x7",
    13,
    281,
    40,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "back nonce: %s", v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "dump_nonce_x7",
    13,
    282,
    40,
    v9);
  v15 = 0;
  v16 = 0;
  while ( v15 <= 3 )
  {
    v4 = snprintf(&v10[v16], 4096 - v16, "%02x ", *(unsigned __int8 *)(a3 + v15 + 192));
    v16 += v4;
    ++v15;
  }
  V_LOCK();
  sub_89210((int)v13, *(int *)(a1 + 252));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v14,
    v13[0],
    v13[1],
    v13[2],
    v13[3],
    v13[4],
    v13[5],
    v13[6],
    v14,
    "asic %d core %d addr_interval %d",
    *(_DWORD *)(a3 + 8),
    *(_DWORD *)(a3 + 12),
    *(_DWORD *)(a1 + 428));
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "dump_nonce_x7",
    13,
    288,
    40,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "nonce: %s", v10);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
           179,
           "dump_nonce_x7",
           13,
           289,
           40,
           v9);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008A728) --------------------------------------------------------
int __fastcall packet_2_nonce_x7(unsigned int *a1, char *a2, int a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  int v8; // r0
  int v9; // r1
  _DWORD *v10; // r3
  unsigned int v15; // [sp+14h] [bp-18h]
  unsigned __int16 v16; // [sp+1Ah] [bp-12h]
  unsigned __int16 v17; // [sp+1Ch] [bp-10h]

  if ( a2[2] != 4 )
    return 100;
  v17 = ((unsigned __int8)a2[9] << 8) | (unsigned __int8)a2[8];
  a2[8] = 0;
  a2[9] = 0;
  v16 = BM_CRC16(a2, 52);
  if ( v16 == v17 )
  {
    v15 = a1[206];
    *(_BYTE *)(a3 + 228) = a2[12];
    *(_QWORD *)a3 = *(_QWORD *)(v15 + 8 * (unsigned __int8)a2[12]);
    *a7 = *(_DWORD *)(v15 + 8 * (unsigned __int8)a2[12]);
    *(_DWORD *)(a3 + 8) = (unsigned __int8)a2[3];
    strcpy((char *)(a3 + 16), (const char *)(v15 + (((unsigned __int8)a2[12] + 16) << 6)));
    memcpy((void *)(a3 + 80), (const void *)(v15 + 32 * ((unsigned __int8)a2[12] + 288)), 0x20u);
    *(_QWORD *)(a3 + 112) = *(_QWORD *)(v15 + 8 * ((unsigned __int8)a2[12] + 1664));
    *(_QWORD *)(a3 + 120) = *(_QWORD *)(v15 + 8 * ((unsigned __int8)a2[12] + 1792));
    strcpy((char *)(a3 + 128), (const char *)(v15 + (((unsigned __int8)a2[12] + 240) << 6)));
    memcpy((void *)(a3 + 192), a2 + 16, 0x20u);
    memcpy((void *)(a3 + 196), a2 + 20, 0x20u);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)a2 + 4) % 0x1B0u % 0x48;
    if ( (unsigned __int8)a2[3] >= (int)a1[84] )
    {
      v8 = rand();
      sub_CC7AC(v8, a1[84]);
      *a6 = v9;
    }
    else
    {
      *a6 = (unsigned __int8)a2[3];
    }
    *a5 = *(_DWORD *)(a3 + 192);
    *a4 = 1;
    v10 = (_DWORD *)(a1[121] + 4 * (a1[86] * *a6 + *(_DWORD *)(a3 + 12)));
    ++*v10;
    return 0;
  }
  else
  {
    printf("chain[%d] get nonce crc error calc value %04x expected value %04x\n", v16, v17, v16);
    return 101;
  }
}
// 8A9F8: variable 'v9' is possibly undefined

//----- (0008AA6C) --------------------------------------------------------
int __fastcall sub_8AA6C(int *a1)
{
  int (**v1)(); // r0
  int (**v2)(); // r0
  char v6[56]; // [sp+34h] [bp-1038h] BYREF
  int v7; // [sp+1034h] [bp-38h] BYREF
  _DWORD v8[7]; // [sp+1038h] [bp-34h] BYREF
  int v9; // [sp+1054h] [bp-18h]
  unsigned int v10; // [sp+1058h] [bp-14h]
  int v11; // [sp+105Ch] [bp-10h]

  v10 = a1[84];
  v11 = 0;
  v7 = 0;
  do
  {
    chip_setting_get_restart_reg_x7((int)a1, 0xFFu, &v7);
    a1[106] = v7;
    chip_setting_get_addr_x7(a1, v10);
    if ( a1[106] != v10 )
    {
      V_LOCK();
      sub_89210((int)v8, a1[63]);
      logfmt_raw(
        v6,
        0x1000u,
        0,
        v9,
        v8[0],
        v8[1],
        v8[2],
        v8[3],
        v8[4],
        v8[5],
        v8[6],
        v9,
        "some chip not found ,restart chain");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
        179,
        "check_asic_num_x7",
        17,
        352,
        80,
        v6);
      v1 = dev_ctrl();
      ((void (__fastcall *)(int))v1[7])(a1[62]);
      sleep(0xAu);
      v2 = dev_ctrl();
      ((void (__fastcall *)(int, int, int))v2[6])(a1[62], a1[277], a1[282]);
      sleep(5u);
    }
    if ( a1[106] == v10 )
      break;
    ++v11;
  }
  while ( v11 <= 2 );
  if ( a1[106] == v10 )
    return 0;
  else
    return 102;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008ACA4) --------------------------------------------------------
int __fastcall sub_8ACA4(int a1, int a2)
{
  int v2; // r1
  size_t v3; // r2
  int v4; // r3
  int v5; // r1
  int v6; // r2
  char v10[36]; // [sp+38h] [bp-1064h] BYREF
  int v11; // [sp+1038h] [bp-64h]
  int v12; // [sp+103Ch] [bp-60h]
  size_t size; // [sp+1040h] [bp-5Ch]
  int v14; // [sp+1044h] [bp-58h]
  int v15; // [sp+1048h] [bp-54h]
  int v16; // [sp+104Ch] [bp-50h]
  int v17; // [sp+1050h] [bp-4Ch]
  int v18; // [sp+1054h] [bp-48h] BYREF
  _DWORD v19[7]; // [sp+1058h] [bp-44h] BYREF
  int v20; // [sp+1074h] [bp-28h]
  _DWORD *v21; // [sp+1078h] [bp-24h]
  void *ptr; // [sp+107Ch] [bp-20h]
  int v23; // [sp+1080h] [bp-1Ch]
  char *v24; // [sp+1084h] [bp-18h]
  signed int i; // [sp+1088h] [bp-14h]
  int j; // [sp+108Ch] [bp-10h]

  v23 = -64;
  v2 = *(_DWORD *)(a1 + 392);
  v3 = *(_DWORD *)(a1 + 396);
  v4 = *(_DWORD *)(a1 + 400);
  v11 = *(_DWORD *)(a1 + 388);
  v12 = v2;
  size = v3;
  v14 = v4;
  v5 = *(_DWORD *)(a1 + 408);
  v6 = *(_DWORD *)(a1 + 412);
  v15 = *(_DWORD *)(a1 + 404);
  v16 = v5;
  v17 = v6;
  ptr = calloc(0xCu, size);
  if ( ptr )
    chip_setting_read_all_sensor_temp(a1, ptr, size, &v18);
  else
    v18 = 0;
  for ( i = 0; i < (int)size; ++i )
  {
    v21 = (_DWORD *)(v11 + 24 * i);
    v24 = 0;
    for ( j = 0; j < v18; ++j )
    {
      if ( v21[5] == *((_DWORD *)ptr + 3 * j) )
      {
        v24 = (char *)ptr + 12 * j;
        break;
      }
    }
    if ( v24 && *((_DWORD *)v24 + 2) )
    {
      v23 = (*((_DWORD *)v24 + 1) + 500) / 1000;
    }
    else
    {
      v23 = -64;
      if ( *(_BYTE *)(a1 + 1096) != 1 )
      {
        V_LOCK();
        sub_89210((int)v19, *(int *)(a1 + 252));
        logfmt_raw(
          v10,
          0x1000u,
          0,
          v20,
          v19[0],
          v19[1],
          v19[2],
          v19[3],
          v19[4],
          v19[5],
          v19[6],
          v20,
          "read sensor failed, sensor[%d], addr:%02x",
          *v21,
          v21[5]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
          179,
          "read_temperature_x7",
          19,
          400,
          100,
          v10);
      }
    }
    if ( v21[5] < *(_DWORD *)(a1 + 336) )
    {
      pthread_mutex_lock((pthread_mutex_t *)(*(_DWORD *)(a1 + 528) + 44 * v21[5] + 20));
      *(_DWORD *)(*(_DWORD *)(a1 + 528) + 44 * v21[5]) = v23;
      pthread_mutex_unlock((pthread_mutex_t *)(*(_DWORD *)(a1 + 528) + 44 * v21[5] + 20));
    }
    *(_DWORD *)(a2 + 12 * i) = v23;
    *(_DWORD *)(a2 + 12 * i + 4) = v23;
    if ( v23 != dword_1503AC )
      dword_1503AC = v23;
  }
  if ( ptr )
    free(ptr);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1503AC: using guessed type int dword_1503AC;
// 1608F0: using guessed type int g_zc;

//----- (0008B088) --------------------------------------------------------
int __fastcall read_rxu_status_x7(int a1, void *a2, _DWORD *a3)
{
  char v6[52]; // [sp+38h] [bp-1034h] BYREF
  _DWORD v7[7]; // [sp+1038h] [bp-34h] BYREF
  int v8; // [sp+1054h] [bp-18h]
  int all_rxu_status; // [sp+105Ch] [bp-10h]

  all_rxu_status = chip_setting_get_all_rxu_status(a1, a2, *(_DWORD *)(a1 + 336), a3);
  if ( !all_rxu_status )
    return 0;
  V_LOCK();
  sub_89210((int)v7, *(int *)(a1 + 252));
  logfmt_raw(
    v6,
    0x1000u,
    0,
    v8,
    v7[0],
    v7[1],
    v7[2],
    v7[3],
    v7[4],
    v7[5],
    v7[6],
    v8,
    "chip_setting_get_all_rxu_status failed ,err code %d",
    all_rxu_status);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "read_rxu_status_x7",
    18,
    429,
    100,
    v6);
  return all_rxu_status;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008B1E0) --------------------------------------------------------
int __fastcall restart_one_chip_x7(int a1, int a2)
{
  char v6[24]; // [sp+34h] [bp-1058h] BYREF
  int v7; // [sp+1034h] [bp-58h] BYREF
  _DWORD v8[7]; // [sp+1038h] [bp-54h] BYREF
  int v9; // [sp+1054h] [bp-38h]
  _DWORD v10[7]; // [sp+1058h] [bp-34h] BYREF
  int v11; // [sp+1074h] [bp-18h]
  int restarted; // [sp+107Ch] [bp-10h]

  restarted = chip_setting_restart_one_chip_x7(a1, a2, &v7);
  if ( restarted )
  {
    V_LOCK();
    sub_89210((int)v8, *(int *)(a1 + 252));
    logfmt_raw(
      v6,
      0x1000u,
      0,
      v9,
      v8[0],
      v8[1],
      v8[2],
      v8[3],
      v8[4],
      v8[5],
      v8[6],
      v9,
      "restart_one_chip failed ,err code %d",
      restarted,
      a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "restart_one_chip_x7",
      19,
      443,
      100,
      v6);
    return 109;
  }
  else if ( v7 == 1 )
  {
    return 0;
  }
  else
  {
    V_LOCK();
    sub_89210((int)v10, *(int *)(a1 + 252));
    logfmt_raw(
      v6,
      0x1000u,
      0,
      v11,
      v10[0],
      v10[1],
      v10[2],
      v10[3],
      v10[4],
      v10[5],
      v10[6],
      v11,
      "restart_one_chip response count err, count:%d, should be 1",
      v7,
      a2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "restart_one_chip_x7",
      19,
      448,
      100,
      v6);
    return 109;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008B3EC) --------------------------------------------------------
int sub_8B3EC()
{
  return 0;
}

//----- (0008B414) --------------------------------------------------------
int sub_8B414()
{
  return 0;
}

//----- (0008B43C) --------------------------------------------------------
int sub_8B43C()
{
  return 0;
}

//----- (0008B468) --------------------------------------------------------
int sub_8B468()
{
  return 0;
}

//----- (0008B490) --------------------------------------------------------
int sub_8B490()
{
  return 0;
}

//----- (0008B4C0) --------------------------------------------------------
int sub_8B4C0()
{
  return 0;
}

//----- (0008B4E4) --------------------------------------------------------
int sub_8B4E4()
{
  return 0;
}

//----- (0008B508) --------------------------------------------------------
int sub_8B508()
{
  return 0;
}

//----- (0008B530) --------------------------------------------------------
int top_init_x7()
{
  return 0;
}

//----- (0008B560) --------------------------------------------------------
int __fastcall dhash_start_x7(int a1)
{
  char v3[44]; // [sp+30h] [bp-102Ch] BYREF
  _DWORD v4[7]; // [sp+1030h] [bp-2Ch] BYREF
  int v5; // [sp+104Ch] [bp-10h]

  V_LOCK();
  sub_89210((int)v4, *(int *)(a1 + 252));
  logfmt_raw(v3, 0x1000u, 0, v5, v4[0], v4[1], v4[2], v4[3], v4[4], v4[5], v4[6], v5, "dhash_start_x7");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "dhash_start_x7",
    14,
    496,
    40,
    v3);
  *(_BYTE *)(a1 + 257) = 1;
  if ( *(_BYTE *)(a1 + 460) != 1 )
    *(_DWORD *)(a1 + 464) = (int)*(float *)(a1 + 1104);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008B6A4) --------------------------------------------------------
int sub_8B6A4()
{
  return 0;
}

//----- (0008B6D0) --------------------------------------------------------
int sub_8B6D0()
{
  return 0;
}

//----- (0008B6FC) --------------------------------------------------------
int __fastcall setup_all_chip_x7(int *a1)
{
  char v4[8]; // [sp+1Ch] [bp-1008h] BYREF
  int v5; // [sp+101Ch] [bp-8h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "setup_all_chip_x7() in");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "setup_all_chip_x7",
    17,
    517,
    40,
    v4);
  v5 = a1[84];
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "%s", "setup_all_chip_x7");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "setup_all_chip_x7",
    17,
    520,
    60,
    v4);
  if ( !sub_8AA6C(a1) )
    return 102;
  a1[116] = 0;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get addr after open cores and set frequency.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "setup_all_chip_x7",
    17,
    528,
    60,
    v4);
  if ( !sub_8AA6C(a1) )
    return 102;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "setup_all_chip_x7() in");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "setup_all_chip_x7",
    17,
    532,
    40,
    v4);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008B974) --------------------------------------------------------
int set_baud_x7()
{
  return 0;
}

//----- (0008B99C) --------------------------------------------------------
int __fastcall sub_8B99C(int a1)
{
  int i; // [sp+8h] [bp-Ch]
  int v3; // [sp+Ch] [bp-8h]

  v3 = 0;
  for ( i = 31; i >= 0; --i )
  {
    if ( *(_BYTE *)(a1 + i) )
    {
      if ( *(unsigned __int8 *)(a1 + i) > 1u )
      {
        if ( *(unsigned __int8 *)(a1 + i) > 3u )
        {
          if ( *(unsigned __int8 *)(a1 + i) > 7u )
          {
            if ( *(unsigned __int8 *)(a1 + i) > 0xFu )
            {
              if ( *(unsigned __int8 *)(a1 + i) > 0x1Fu )
              {
                if ( *(unsigned __int8 *)(a1 + i) > 0x3Fu )
                {
                  if ( *(char *)(a1 + i) >= 0 )
                    ++v3;
                }
                else
                {
                  v3 += 2;
                }
              }
              else
              {
                v3 += 3;
              }
            }
            else
            {
              v3 += 4;
            }
          }
          else
          {
            v3 += 5;
          }
        }
        else
        {
          v3 += 6;
        }
      }
      else
      {
        v3 += 7;
      }
      return v3;
    }
    v3 += 8;
  }
  return v3;
}

//----- (0008BB38) --------------------------------------------------------
int __fastcall check_nonce_x7(int a1, _DWORD *a2)
{
  double *v2; // lr
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  double v8; // r2
  char v13[64]; // [sp+1Ch] [bp-1040h] BYREF
  int v14; // [sp+101Ch] [bp-40h]
  int v15; // [sp+1020h] [bp-3Ch]
  int v16; // [sp+1024h] [bp-38h]
  int v17; // [sp+1028h] [bp-34h]
  int v18; // [sp+102Ch] [bp-30h]
  int v19; // [sp+1030h] [bp-2Ch]
  double v20; // [sp+1034h] [bp-28h]
  int v21; // [sp+103Ch] [bp-20h]
  double v22; // [sp+1040h] [bp-1Ch]
  _DWORD *v23; // [sp+104Ch] [bp-10h]

  v23 = a2;
  v21 = a2[48];
  v2 = (double *)(a2 + 49);
  v3 = a2[49];
  v4 = a2[50];
  v5 = *((_DWORD *)v2 + 2);
  v6 = *((_DWORD *)v2 + 3);
  v14 = v3;
  v15 = v4;
  v16 = v5;
  v17 = v6;
  v7 = *((_DWORD *)v2 + 5);
  v8 = v2[3];
  v18 = *((_DWORD *)v2 + 4);
  v19 = v7;
  v20 = v8;
  v22 = v8;
  if ( *(_QWORD *)&v8 < *((_QWORD *)v23 + 15) )
    return 0;
  V_LOCK();
  logfmt_raw(v13, 0x1000u, 0, "hw diff (%llu<%llu) not reach pool", v23[30], v23[31], v22, a2, a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "check_nonce_x7",
    14,
    601,
    20,
    v13);
  return 1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008BC7C) --------------------------------------------------------
int get_chip_status_x7()
{
  return 0;
}

//----- (0008BCA4) --------------------------------------------------------
int softreset_all_chip_x7()
{
  return 0;
}

//----- (0008BCC8) --------------------------------------------------------
int __fastcall get_theory_hashrate_x7(int a1, _QWORD *a2)
{
  *a2 = 0x40F1904000000000LL;
  return 0;
}

//----- (0008BD04) --------------------------------------------------------
void sub_8BD04()
{
  ;
}

//----- (0008BD2C) --------------------------------------------------------
int __fastcall get_sale_hashrate_x7(int a1, double *a2, _DWORD *a3)
{
  double v7; // [sp+10h] [bp-14h] BYREF
  int v8; // [sp+1Ch] [bp-8h]

  v8 = 0;
  v7 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 136))(a1, &v7);
  if ( strcmp((const char *)(a1 + 304), "X5") )
    return 205;
  *a2 = v7 * 0.985;
  *a3 = 1;
  return v8;
}
// 8BD2C: too many cbuild loops

//----- (0008BDD8) --------------------------------------------------------
int get_qualify_hashrate_x7()
{
  return 0;
}

//----- (0008BE00) --------------------------------------------------------
int __fastcall get_qualify_nonce_num_x7(int a1, float *a2)
{
  unsigned __int64 v2; // d17
  double v3; // d8
  double v4; // r0
  float v5; // s15
  double v9; // [sp+8h] [bp-1Ch] BYREF
  int v10; // [sp+14h] [bp-10h]

  v10 = 0;
  v9 = 0.0;
  (*(void (__fastcall **)(int, double *))(a1 + 136))(a1, &v9);
  v3 = v9;
  LODWORD(v2) = *(_DWORD *)(a1 + 432);
  LODWORD(v4) = sub_CCAD4(vshld_u64(1u, v2));
  v5 = v3 / v4 / 6.0 * 0.75;
  *a2 = v5;
  return 0;
}
// 8BE00: too many cbuild loops
// 8BE58: variable 'v2' is possibly undefined
// 8BE68: variable 'v4' is possibly undefined

//----- (0008BEA8) --------------------------------------------------------
int set_sensor_extern_mode_x7()
{
  return 0;
}

//----- (0008BECC) --------------------------------------------------------
int __fastcall read_sensor_temp_local_x7(
        int a1,
        _DWORD *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        char a9)
{
  chip_setting_read_one_sensor_temp_x7(a1, a2, a3, a9);
  if ( *a3 == 1 )
    return 0;
  else
    return 4;
}

//----- (0008BF34) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_x7(
        int a1,
        _DWORD *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        char a9)
{
  chip_setting_read_one_sensor_temp_x7(a1, a2, a3, a9);
  if ( *a3 == 1 )
    return 0;
  else
    return 4;
}

//----- (0008BF9C) --------------------------------------------------------
int __fastcall parameter_update_x7(int a1)
{
  *(_DWORD *)(a1 + 1104) = 1157234688;
  return 0;
}

//----- (0008BFEC) --------------------------------------------------------
int overclock_update_x7()
{
  return 0;
}

//----- (0008C014) --------------------------------------------------------
int get_pcba_test_level_x7()
{
  return 0;
}

//----- (0008C03C) --------------------------------------------------------
int __fastcall get_packet_remain_len_x7(int a1)
{
  return *(unsigned __int8 *)(a1 + 6);
}

//----- (0008C06C) --------------------------------------------------------
int adjust_working_freq_x7()
{
  return 0;
}

//----- (0008C094) --------------------------------------------------------
int __fastcall send_fake_work_x7(int a1)
{
  int (**v1)(); // r0
  unsigned int v2; // r0
  int (**v3)(); // r0
  _BYTE dest[92]; // [sp+Ch] [bp-68h] BYREF
  unsigned int v8; // [sp+68h] [bp-Ch]
  int v9; // [sp+6Ch] [bp-8h]

  v9 = 3;
  memcpy(dest, &unk_12DDA8, sizeof(dest));
  v8 = 92;
  printf("send %d triger work\n", 3);
  while ( v9-- )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1072));
    do
    {
      v1 = dev_ctrl();
      v2 = ((int (__fastcall *)(_DWORD))v1[17])(*(_DWORD *)(a1 + 248));
    }
    while ( v8 > v2 );
    v3 = dev_ctrl();
    ((void (__fastcall *)(_DWORD, _BYTE *, unsigned int))v3[13])(*(_DWORD *)(a1 + 248), dest, v8);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1072));
    usleep(0x2710u);
  }
  return 0;
}

//----- (0008C180) --------------------------------------------------------
int __fastcall dhash_mining_reset_x7(int a1)
{
  __int64 v1; // r0
  int (**v2)(); // r0
  int (**v3)(); // r0
  int (**v4)(); // r0
  int (**v5)(); // r0
  int v6; // r3
  char v9[28]; // [sp+30h] [bp-125Ch] BYREF
  _BYTE v10[520]; // [sp+1030h] [bp-25Ch] BYREF
  _DWORD v11[7]; // [sp+1238h] [bp-54h] BYREF
  int v12; // [sp+1254h] [bp-38h]
  _DWORD v13[7]; // [sp+1258h] [bp-34h] BYREF
  int v14; // [sp+1274h] [bp-18h]
  int i; // [sp+1278h] [bp-14h]
  int v16; // [sp+127Ch] [bp-10h]

  v16 = 0;
  pthread_mutex_lock(&stru_15F7C0[*(_DWORD *)(a1 + 248)]);
  V_LOCK();
  sub_89210((int)v11, *(int *)(a1 + 252));
  logfmt_raw(v9, 0x1000u, 0, v12, v11[0], v11[1], v11[2], v11[3], v11[4], v11[5], v11[6], v12, "dhash mining reset!");
  V_UNLOCK();
  v1 = zlog(
         g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmin"
         "er-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
         179,
         "dhash_mining_reset_x7",
         21,
         838,
         80,
         v9);
  (*(void (__fastcall **)(int, _DWORD))(a1 + 4))(a1, HIDWORD(v1));
  *(_BYTE *)(a1 + 257) = 0;
  *(_BYTE *)(a1 + 258) = 0;
  v2 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v2[7])(*(_DWORD *)(a1 + 248));
  sleep(0xAu);
  v3 = dev_ctrl();
  ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v3[6])(
    *(_DWORD *)(a1 + 248),
    *(_DWORD *)(a1 + 1108),
    *(_DWORD *)(a1 + 1128));
  sleep(0xAu);
  if ( (*(int (__fastcall **)(int))(a1 + 220))(a1) )
  {
    V_LOCK();
    sub_89210((int)v13, *(int *)(a1 + 252));
    logfmt_raw(
      v9,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "finding chip failed after restart");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "dhash_mining_reset_x7",
      21,
      847,
      120,
      v9);
    exit(-1);
  }
  memset((char *)&last_seed_hash_x7 + 32 * *(_DWORD *)(a1 + 248), 0, 0x20u);
  v4 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v4[11])(*(_DWORD *)(a1 + 248));
  v5 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v5[1])(*(_DWORD *)(a1 + 248));
  (*(void (__fastcall **)(int))(a1 + 16))(a1);
  chip_setting_seed_x7(a1, (char *)&last_seed_hash_x7 + 32 * *(_DWORD *)(a1 + 248), 0x20u, v10, 0xFFu);
  for ( i = 0; i < *(_DWORD *)(a1 + 336); ++i )
  {
    reset_chip_seed_status(a1, i);
    chip_seed_status_set_calculating(a1, i);
  }
  pthread_mutex_unlock(&stru_15F7C0[*(_DWORD *)(a1 + 248)]);
  return v6;
}
// 8C5AC: variable 'v6' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F7C0: using guessed type pthread_mutex_t stru_15F7C0[3];
// 1608F0: using guessed type int g_zc;

//----- (0008C5B8) --------------------------------------------------------
void *runtime_ctrl_x7_2044()
{
  char v1[4]; // [sp+10h] [bp-1604h] BYREF
  _QWORD v2[162]; // [sp+1010h] [bp-604h] BYREF
  void *dest; // [sp+160Ch] [bp-8h]

  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "runtime_ctrl_x7() in");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "runtime_ctrl_x7_2044",
    20,
    897,
    40,
    v1);
  memset(v2, 0, sizeof(v2));
  LODWORD(v2[0]) = backend_init_base;
  HIDWORD(v2[0]) = reset_base;
  LODWORD(v2[2]) = dhash_mining_start_base;
  HIDWORD(v2[2]) = dhash_mining_stop_base;
  LODWORD(v2[3]) = dhash_mining_reset_x7;
  HIDWORD(v2[3]) = backend_exit_base;
  LODWORD(v2[4]) = push_work_base;
  HIDWORD(v2[4]) = send_fake_work_x7;
  LODWORD(v2[5]) = async_push_work_base;
  HIDWORD(v2[5]) = pop_ans_base;
  LODWORD(v2[6]) = try_pop_ans_base;
  HIDWORD(v2[7]) = softreset_all_chip_x7;
  LODWORD(v2[8]) = setup_all_chip_x7;
  HIDWORD(v2[8]) = work_2_packet_x7;
  LODWORD(v2[9]) = packet_2_nonce_x7;
  HIDWORD(v2[9]) = check_nonce_x7;
  LODWORD(v2[10]) = global_idx_init_x7;
  HIDWORD(v2[10]) = global_idx_free_x7;
  LODWORD(v2[11]) = set_baud_x7;
  HIDWORD(v2[11]) = 570348;
  v2[12] = 0x8B4680008B414LL;
  v2[13] = 0x8B4C00008B490LL;
  v2[14] = 0x8B6D00008B4E4LL;
  v2[15] = 0x8B5080008B6A4LL;
  HIDWORD(v2[16]) = get_chip_status_x7;
  LODWORD(v2[17]) = get_theory_hashrate_x7;
  HIDWORD(v2[17]) = get_sale_hashrate_x7;
  LODWORD(v2[18]) = get_qualify_hashrate_x7;
  HIDWORD(v2[18]) = get_qualify_nonce_num_x7;
  LODWORD(v2[19]) = set_sensor_extern_mode_x7;
  HIDWORD(v2[19]) = read_sensor_temp_local_x7;
  LODWORD(v2[20]) = read_sensor_temp_remote_x7;
  HIDWORD(v2[20]) = parameter_update_x7;
  LODWORD(v2[21]) = overclock_update_x7;
  HIDWORD(v2[21]) = get_pcba_test_level_x7;
  LODWORD(v2[22]) = get_packet_remain_len_x7;
  HIDWORD(v2[23]) = adjust_working_freq_x7;
  LODWORD(v2[24]) = 570428;
  HIDWORD(v2[24]) = set_frequency_by_temp_single_base;
  LODWORD(v2[26]) = get_chip_temperature_str_base;
  HIDWORD(v2[27]) = sub_8AA6C;
  HIDWORD(v2[28]) = 568484;
  LODWORD(v2[29]) = top_init_x7;
  LODWORD(v2[30]) = dhash_start_x7;
  v2[38] = 14168;
  v2[39] = 0;
  v2[40] = 7499128;
  v2[41] = 0x100002044LL;
  v2[42] = 0x100000006LL;
  v2[43] = 0x100000020LL;
  HIDWORD(v2[44]) = 1;
  HIDWORD(v2[46]) = unk_15F7B8;
  LODWORD(v2[47]) = unk_15F7BC;
  HIDWORD(v2[48]) = sensor_info_x7_2044;
  v2[49] = qword_150394;
  v2[50] = qword_15039C;
  v2[51] = qword_1503A4;
  HIDWORD(v2[53]) = 1;
  LODWORD(v2[54]) = 14;
  HIDWORD(v2[103]) = 392;
  v2[104] = 0x4000000E8LL;
  v2[105] = 0x34000000D6LL;
  HIDWORD(v2[106]) = 8;
  LODWORD(v2[125]) = 4;
  HIDWORD(v2[138]) = 1200;
  v2[140] = 0x20000000;
  LODWORD(v2[141]) = 1;
  dest = calloc(1u, 0x510u);
  memcpy(dest, v2, 0x510u);
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "runtime_ctrl_x7() out");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
    179,
    "runtime_ctrl_x7_2044",
    20,
    1007,
    40,
    v1);
  return dest;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150390: using guessed type _UNKNOWN *sensor_info_x7_2044;
// 150394: using guessed type __int64;
// 15039C: using guessed type __int64;
// 1503A4: using guessed type __int64;
// 1608F0: using guessed type int g_zc;

//----- (0008CA58) --------------------------------------------------------
int __fastcall try_get_seed_status(int a1, int a2, int a3, _DWORD *a4)
{
  int seed_status_x7; // [sp+1Ch] [bp-8h]

  seed_status_x7 = sync_unblocked_get_seed_status_x7(a1, 2, a2, a3, a4);
  if ( seed_status_x7 )
    return seed_status_x7;
  else
    return 0;
}

//----- (0008CABC) --------------------------------------------------------
int __fastcall try_get_msg_ack(int a1, int a2, int a3, _DWORD *a4)
{
  int msg_x7; // [sp+1Ch] [bp-8h]

  msg_x7 = sync_unblocked_get_msg_x7(a1, 3, a2, a3, 13, a4);
  if ( msg_x7 )
    return msg_x7;
  else
    return 0;
}

//----- (0008CB28) --------------------------------------------------------
int __fastcall check_chip_msg_ack_thread(char *a1)
{
  pthread_t v1; // r0
  int (**v2)(); // r0
  unsigned int v3; // r0
  int (**v4)(); // r0
  char v7[60]; // [sp+30h] [bp-11BCh] BYREF
  pthread_condattr_t attr; // [sp+1030h] [bp-1BCh] BYREF
  int v9; // [sp+1034h] [bp-1B8h] BYREF
  struct timespec tp; // [sp+1038h] [bp-1B4h] BYREF
  _BYTE dest[216]; // [sp+1040h] [bp-1ACh] BYREF
  _DWORD v12[7]; // [sp+1118h] [bp-D4h] BYREF
  int v13; // [sp+1134h] [bp-B8h]
  _DWORD v14[7]; // [sp+1138h] [bp-B4h] BYREF
  int v15; // [sp+1154h] [bp-98h]
  _DWORD v16[7]; // [sp+1158h] [bp-94h] BYREF
  int v17; // [sp+1174h] [bp-78h]
  _DWORD v18[7]; // [sp+1178h] [bp-74h] BYREF
  int v19; // [sp+1194h] [bp-58h]
  _DWORD v20[7]; // [sp+1198h] [bp-54h] BYREF
  int v21; // [sp+11B4h] [bp-38h]
  int msg_ack; // [sp+11B8h] [bp-34h]
  int v23; // [sp+11BCh] [bp-30h]
  int v24; // [sp+11C0h] [bp-2Ch]
  int i; // [sp+11C4h] [bp-28h]
  int j; // [sp+11C8h] [bp-24h]
  char *v27; // [sp+11CCh] [bp-20h]
  unsigned int v28; // [sp+11D0h] [bp-1Ch]
  unsigned __int8 v29; // [sp+11D7h] [bp-15h]
  int v30; // [sp+11D8h] [bp-14h]
  int v31; // [sp+11DCh] [bp-10h]

  v27 = a1;
  v30 = *(_DWORD *)a1;
  v29 = a1[4];
  memcpy(dest, a1 + 5, 0xD6u);
  v28 = *((_DWORD *)v27 + 55);
  free(a1);
  v31 = *(_DWORD *)(v30 + 824);
  v1 = pthread_self();
  pthread_detach(v1);
  pthread_mutex_lock(&stru_15F808[*(_DWORD *)(v30 + 248)]);
  if ( byte_15F850[*(_DWORD *)(v30 + 248)] != 1 )
  {
    pthread_condattr_init(&attr);
    pthread_condattr_setclock(&attr, 1);
    pthread_cond_init(&msg_check_process_wakeup_cond[*(_DWORD *)(v30 + 248)], &attr);
    byte_15F850[*(_DWORD *)(v30 + 248)] = 1;
    dword_15F854 = (int)malloc(524 * *(_DWORD *)(v30 + 336));
    if ( !dword_15F854 )
    {
      V_LOCK();
      sub_89210((int)v12, *(int *)(v30 + 252));
      logfmt_raw(v7, 0x1000u, 0, v13, v12[0], v12[1], v12[2], v12[3], v12[4], v12[5], v12[6], v13, "malloc failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
        179,
        "check_chip_msg_ack_thread",
        25,
        1085,
        120,
        v7);
      exit(1);
    }
  }
  if ( *(unsigned __int8 *)(v31 + 49024) == v29 + 1 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      clock_gettime(1, &tp);
      ++tp.tv_sec;
      v23 = *(_DWORD *)(v30 + 336);
      v24 = 0;
      do
      {
        pthread_mutex_lock(&msg_ack_lock[*(_DWORD *)(v30 + 248)]);
        v24 = pthread_cond_timedwait(
                &msg_check_process_wakeup_cond[*(_DWORD *)(v30 + 248)],
                &msg_ack_lock[*(_DWORD *)(v30 + 248)],
                &tp);
        if ( *(unsigned __int8 *)(v31 + 49024) != v29 + 1 )
        {
          pthread_mutex_unlock(&msg_ack_lock[*(_DWORD *)(v30 + 248)]);
          V_LOCK();
          sub_89210((int)v14, *(int *)(v30 + 252));
          logfmt_raw(
            v7,
            0x1000u,
            0,
            v15,
            v14[0],
            v14[1],
            v14[2],
            v14[3],
            v14[4],
            v14[5],
            v14[6],
            v15,
            "msg debug: new msg come");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
            179,
            "check_chip_msg_ack_thread",
            25,
            1108,
            20,
            v7);
          goto LABEL_25;
        }
        pthread_mutex_unlock(&msg_ack_lock[*(_DWORD *)(v30 + 248)]);
        msg_ack = try_get_msg_ack(v30, v23, dword_15F854, &v9);
        if ( msg_ack )
        {
          V_LOCK();
          sub_89210((int)v16, *(int *)(v30 + 252));
          logfmt_raw(
            v7,
            0x1000u,
            0,
            v17,
            v16[0],
            v16[1],
            v16[2],
            v16[3],
            v16[4],
            v16[5],
            v16[6],
            v17,
            "err while try_get_msg_ack, code %d",
            msg_ack);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
            179,
            "check_chip_msg_ack_thread",
            25,
            1116,
            100,
            v7);
          goto LABEL_23;
        }
        for ( j = 0; j < v9; ++j )
        {
          if ( v29 == *(unsigned __int8 *)(dword_15F854 + 524 * j + 12) )
            --v23;
        }
        if ( v23 <= 0 )
        {
          V_LOCK();
          sub_89210((int)v18, *(int *)(v30 + 252));
          logfmt_raw(
            v7,
            0x1000u,
            0,
            v19,
            v18[0],
            v18[1],
            v18[2],
            v18[3],
            v18[4],
            v18[5],
            v18[6],
            v19,
            "msg debug: msg ack success");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
            179,
            "check_chip_msg_ack_thread",
            25,
            1130,
            20,
            v7);
          goto LABEL_25;
        }
      }
      while ( v24 != 110 );
      V_LOCK();
      sub_89210((int)v20, *(int *)(v30 + 252));
      logfmt_raw(
        v7,
        0x1000u,
        0,
        v21,
        v20[0],
        v20[1],
        v20[2],
        v20[3],
        v20[4],
        v20[5],
        v20[6],
        v21,
        "msg ack expired, resend msg remain_packet_num:%d",
        v23);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
        179,
        "check_chip_msg_ack_thread",
        25,
        1136,
        40,
        v7);
      pthread_mutex_lock((pthread_mutex_t *)(v30 + 1072));
      do
      {
        v2 = dev_ctrl();
        v3 = ((int (__fastcall *)(_DWORD))v2[17])(*(_DWORD *)(v30 + 248));
      }
      while ( v3 < v28 );
      v4 = dev_ctrl();
      ((void (__fastcall *)(_DWORD, _BYTE *, unsigned int))v4[13])(*(_DWORD *)(v30 + 248), dest, v28);
      pthread_mutex_unlock((pthread_mutex_t *)(v30 + 1072));
LABEL_23:
      ;
    }
  }
LABEL_25:
  pthread_mutex_unlock(&stru_15F808[*(_DWORD *)(v30 + 248)]);
  return 0;
}
// 8D294: conditional instruction was optimized away because %var_24.4!=6E
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F808: using guessed type pthread_mutex_t stru_15F808[3];
// 15F850: using guessed type _BYTE byte_15F850[4];
// 15F854: using guessed type int dword_15F854;
// 1608F0: using guessed type int g_zc;
// 16165C: using guessed type pthread_mutex_t msg_ack_lock[3];
// 1616B0: using guessed type pthread_cond_t msg_check_process_wakeup_cond[3];

//----- (0008D2EC) --------------------------------------------------------
int __fastcall check_chip_msg_ack_x7(int a1, _BYTE *a2, int a3)
{
  char v7[56]; // [sp+3Ch] [bp-1038h] BYREF
  pthread_t newthread; // [sp+103Ch] [bp-38h] BYREF
  _DWORD v9[7]; // [sp+1040h] [bp-34h] BYREF
  int v10; // [sp+105Ch] [bp-18h]
  void *arg; // [sp+1064h] [bp-10h]

  arg = malloc(0xE0u);
  if ( !arg )
  {
    V_LOCK();
    sub_89210((int)v9, *(int *)(a1 + 252));
    logfmt_raw(v7, 0x1000u, 0, v10, v9[0], v9[1], v9[2], v9[3], v9[4], v9[5], v9[6], v10, "malloc failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "check_chip_msg_ack_x7",
      21,
      1163,
      120,
      v7);
    exit(1);
  }
  *(_DWORD *)arg = a1;
  *((_BYTE *)arg + 4) = a2[8];
  memcpy((char *)arg + 5, a2, 0xD6u);
  *((_DWORD *)arg + 55) = a3;
  pthread_create(&newthread, 0, (void *(*)(void *))check_chip_msg_ack_thread, arg);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008D488) --------------------------------------------------------
int __fastcall x7_chip_seed_status_init(_DWORD *a1)
{
  int v2; // r4
  char v5[16]; // [sp+1Ch] [bp-1010h] BYREF
  int i; // [sp+101Ch] [bp-10h]

  if ( byte_15F7B4[a1[63]] )
    return 201;
  v2 = a1[62];
  x7_chip_seed_status[v2] = calloc(1u, 76 * a1[84]);
  if ( !x7_chip_seed_status[a1[62]] )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s malloc failed", "x7_chip_seed_status_init");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "x7_chip_seed_status_init",
      24,
      1189,
      120,
      v5);
    exit(-1);
  }
  for ( i = 0; i < a1[84]; ++i )
    pthread_mutex_init((pthread_mutex_t *)(x7_chip_seed_status[a1[62]] + 76 * i + 52), 0);
  byte_15F7B4[a1[63]] = 1;
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F7B4: using guessed type _BYTE byte_15F7B4[4];
// 1608F0: using guessed type int g_zc;
// 161740: using guessed type _DWORD x7_chip_seed_status[3];

//----- (0008D668) --------------------------------------------------------
int __fastcall sub_8D668(int a1, int a2, int a3, int a4)
{
  return a4;
}

//----- (0008D684) --------------------------------------------------------
int __fastcall reset_chip_seed_status(int a1, unsigned __int8 a2)
{
  char v6[8]; // [sp+1Ch] [bp-1008h] BYREF
  struct timespec *tp; // [sp+101Ch] [bp-8h]

  if ( byte_15F7B4[*(_DWORD *)(a1 + 252)] != 1 )
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "%s chip_seed_status used before init", "reset_chip_seed_status");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "reset_chip_seed_status",
      22,
      1221,
      100,
      v6);
    return 110;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2) = 0;
    *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 33) = 0;
    memset((void *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 1), 0, 0x20u);
    tp = (struct timespec *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 36);
    clock_gettime(1, tp);
    pthread_mutex_unlock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F7B4: using guessed type _BYTE byte_15F7B4[4];
// 1608F0: using guessed type int g_zc;
// 161740: using guessed type _DWORD x7_chip_seed_status[3];

//----- (0008D900) --------------------------------------------------------
int __fastcall chip_seed_status_set_calculating(int a1, unsigned __int8 a2)
{
  char v6[8]; // [sp+1Ch] [bp-1008h] BYREF
  struct timespec *tp; // [sp+101Ch] [bp-8h]

  if ( byte_15F7B4[*(_DWORD *)(a1 + 252)] != 1 )
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "%s chip_seed_status used before init", "chip_seed_status_set_calculating");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "chip_seed_status_set_calculating",
      32,
      1241,
      100,
      v6);
    return 110;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 34) = 1;
    *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 33) = 1;
    tp = (struct timespec *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 36);
    clock_gettime(1, tp);
    pthread_mutex_unlock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F7B4: using guessed type _BYTE byte_15F7B4[4];
// 1608F0: using guessed type int g_zc;
// 161740: using guessed type _DWORD x7_chip_seed_status[3];

//----- (0008DB34) --------------------------------------------------------
int __fastcall update_seed_status_receive_ack(int a1, unsigned __int8 a2, const void *a3)
{
  char v8[4]; // [sp+20h] [bp-1004h] BYREF

  if ( byte_15F7B4[*(_DWORD *)(a1 + 252)] != 1 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "%s chip_seed_status used before init", "update_seed_status_receive_ack");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "update_seed_status_receive_ack",
      30,
      1259,
      100,
      v8);
    return 110;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 35) = 1;
    *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 34) = 1;
    *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2) = 1;
    *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 33) = 0;
    memcpy((void *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 1), a3, 0x20u);
    pthread_mutex_unlock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F7B4: using guessed type _BYTE byte_15F7B4[4];
// 1608F0: using guessed type int g_zc;
// 161740: using guessed type _DWORD x7_chip_seed_status[3];

//----- (0008DDD4) --------------------------------------------------------
int __fastcall update_seed_status_expired(int a1, unsigned __int8 a2)
{
  int v3; // r2
  char v7[52]; // [sp+30h] [bp-1034h] BYREF
  _DWORD v8[7]; // [sp+1030h] [bp-34h] BYREF
  int v9; // [sp+104Ch] [bp-18h]
  _DWORD *v10; // [sp+1054h] [bp-10h]

  if ( byte_15F7B4[*(_DWORD *)(a1 + 252)] != 1 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "%s chip_seed_status used before init", "update_seed_status_expired");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "update_seed_status_expired",
      26,
      1280,
      100,
      v7);
    return 110;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    if ( *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 33) )
    {
      v3 = x7_chip_seed_status[*(_DWORD *)(a1 + 248)];
      v10 = (_DWORD *)(v3 + 76 * a2 + 36);
      clock_gettime(1, (struct timespec *)(v3 + 76 * a2 + 44));
      if ( (unsigned int)"time" < (v10[3] - v10[1]) / 1000000
                                + vshld_n_s64(
                                    4 * (vshld_n_s64(v10[2] - *v10, 5u) - (v10[2] - *v10)) + v10[2] - *v10,
                                    3u) )
      {
        V_LOCK();
        sub_89210((int)v8, *(int *)(a1 + 252));
        logfmt_raw(
          v7,
          0x1000u,
          0,
          v9,
          v8[0],
          v8[1],
          v8[2],
          v8[3],
          v8[4],
          v8[5],
          v8[6],
          v9,
          "seed calculating response expired");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
          179,
          "update_seed_status_expired",
          26,
          1289,
          80,
          v7);
        *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 33) = 0;
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F7B4: using guessed type _BYTE byte_15F7B4[4];
// 1608F0: using guessed type int g_zc;
// 161740: using guessed type _DWORD x7_chip_seed_status[3];

//----- (0008E16C) --------------------------------------------------------
int __fastcall update_outdated_chip_seed(int a1, unsigned __int8 a2)
{
  char v6[4]; // [sp+18h] [bp-1004h] BYREF

  if ( byte_15F7B4[*(_DWORD *)(a1 + 252)] != 1 )
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "%s chip_seed_status used before init", "update_outdated_chip_seed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
      179,
      "update_outdated_chip_seed",
      25,
      1302,
      100,
      v6);
    return 110;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    if ( *(_BYTE *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 33) == 1
      || !memcmp(
            (const void *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 1),
            (char *)&last_seed_hash_x7 + 32 * *(_DWORD *)(a1 + 248),
            0x20u) )
    {
      pthread_mutex_unlock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
    }
    else
    {
      chip_setting_seed_x7(a1, (char *)&last_seed_hash_x7 + 32 * *(_DWORD *)(a1 + 248), 0x20u, v6, a2);
      pthread_mutex_unlock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(a1 + 248)] + 76 * a2 + 52));
      chip_seed_status_set_calculating(a1, a2);
    }
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F7B4: using guessed type _BYTE byte_15F7B4[4];
// 1608F0: using guessed type int g_zc;
// 161740: using guessed type _DWORD x7_chip_seed_status[3];

//----- (0008E444) --------------------------------------------------------
int __fastcall scanseed(int a1)
{
  char v2[48]; // [sp+34h] [bp-1270h] BYREF
  int v3; // [sp+1034h] [bp-270h] BYREF
  _BYTE s[512]; // [sp+1038h] [bp-26Ch] BYREF
  _DWORD v5[7]; // [sp+1238h] [bp-6Ch] BYREF
  int v6; // [sp+1254h] [bp-50h]
  _DWORD v7[7]; // [sp+1258h] [bp-4Ch] BYREF
  int v8; // [sp+1274h] [bp-30h]
  unsigned __int8 v9; // [sp+127Fh] [bp-25h]
  int seed_status; // [sp+1280h] [bp-24h]
  _BYTE *v11; // [sp+1284h] [bp-20h]
  int v12; // [sp+1288h] [bp-1Ch]
  int v13; // [sp+128Ch] [bp-18h]
  int i; // [sp+1290h] [bp-14h]
  int j; // [sp+1294h] [bp-10h]

  v13 = a1;
  v12 = *(_DWORD *)(a1 + 1288);
  v11 = 0;
  memset(s, 0, sizeof(s));
LABEL_2:
  if ( *(_BYTE *)(v12 + 8) )
  {
    *(_BYTE *)(v12 + 8) = 0;
  }
  else
  {
    for ( i = 0; ; ++i )
    {
      if ( i > 9 )
      {
        if ( *(_BYTE *)(v13 + 258) )
        {
          for ( j = 0; j < *(_DWORD *)(v13 + 336); ++j )
          {
            if ( *(_BYTE *)(v12 + 8) )
            {
              *(_BYTE *)(v12 + 8) = 0;
              return 0;
            }
            update_seed_status_expired(v13, j);
            update_outdated_chip_seed(v13, j);
          }
        }
        goto LABEL_2;
      }
      if ( *(_BYTE *)(v13 + 258) )
        break;
LABEL_15:
      usleep(0x7A120u);
    }
    while ( !*(_BYTE *)(v12 + 8) )
    {
      v3 = 0;
      seed_status = try_get_seed_status(v13, 1, (int)s, &v3);
      if ( seed_status )
      {
        V_LOCK();
        sub_89210((int)v5, *(int *)(v13 + 252));
        logfmt_raw(
          v2,
          0x1000u,
          0,
          v6,
          v5[0],
          v5[1],
          v5[2],
          v5[3],
          v5[4],
          v5[5],
          v5[6],
          v6,
          "get seed err, code %d",
          seed_status);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
          179,
          "scanseed",
          8,
          1350,
          100,
          v2);
      }
      if ( v3 )
      {
        v11 = s;
        v9 = s[3];
        if ( s[3] < *(int *)(v13 + 336) )
        {
          update_seed_status_receive_ack(v13, v9, v11 + 12);
          pthread_mutex_lock(&last_work_lock[*(_DWORD *)(v13 + 248)]);
          chip_setting_msg_x7(
            v13,
            (char *)&last_work_packet + 214 * *(_DWORD *)(v13 + 248),
            last_work_len[*(_DWORD *)(v13 + 248)],
            v9);
          pthread_mutex_unlock(&last_work_lock[*(_DWORD *)(v13 + 248)]);
        }
        else
        {
          V_LOCK();
          sub_89210((int)v7, *(int *)(v13 + 252));
          logfmt_raw(
            v2,
            0x1000u,
            0,
            v8,
            v7[0],
            v7[1],
            v7[2],
            v7[3],
            v7[4],
            v7[5],
            v7[6],
            v8,
            "chip_id %d is invalid",
            v9);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
            179,
            "scanseed",
            8,
            1359,
            100,
            v2);
        }
      }
      if ( !v3 )
        goto LABEL_15;
    }
    *(_BYTE *)(v12 + 8) = 0;
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 1616A4: using guessed type _DWORD last_work_len[3];
// 161750: using guessed type pthread_mutex_t last_work_lock[3];

//----- (0008E834) --------------------------------------------------------
int __fastcall scan_rxu_hang(int a1)
{
  float v1; // s15
  float v2; // s15
  int v3; // r3
  char v5[16]; // [sp+34h] [bp-1290h] BYREF
  _DWORD v6[133]; // [sp+1034h] [bp-290h] BYREF
  _DWORD v7[7]; // [sp+1248h] [bp-7Ch] BYREF
  int v8; // [sp+1264h] [bp-60h]
  _DWORD v9[7]; // [sp+1268h] [bp-5Ch] BYREF
  int v10; // [sp+1284h] [bp-40h]
  int rxu_status_x7; // [sp+1288h] [bp-3Ch]
  void *v12; // [sp+128Ch] [bp-38h]
  void *ptr; // [sp+1290h] [bp-34h]
  int v14; // [sp+1294h] [bp-30h]
  int v15; // [sp+1298h] [bp-2Ch]
  int v16; // [sp+129Ch] [bp-28h]
  int j; // [sp+12A0h] [bp-24h]
  int i; // [sp+12A4h] [bp-20h]
  int v19; // [sp+12A8h] [bp-1Ch]
  int v20; // [sp+12ACh] [bp-18h]
  int v21; // [sp+12B0h] [bp-14h]
  int v22; // [sp+12B4h] [bp-10h]

  v16 = a1;
  v15 = *(_DWORD *)(a1 + 1288);
  v14 = 0;
  memset(&v6[5], 0, 0x200u);
  v21 = 0;
  v22 = 1;
  ptr = calloc(1u, 8 * *(_DWORD *)(v16 + 336));
  v12 = calloc(1u, 12 * *(_DWORD *)(v16 + 336));
  while ( !*(_BYTE *)(v15 + 9) )
  {
    if ( !*(_BYTE *)(v16 + 258) )
      goto LABEL_30;
    if ( v21 == 1 )
    {
      rxu_status_x7 = read_rxu_status_x7(v16, v12, v6);
      if ( rxu_status_x7 )
      {
        V_LOCK();
        sub_89210((int)v7, *(int *)(v16 + 252));
        logfmt_raw(
          v5,
          0x1000u,
          0,
          v8,
          v7[0],
          v7[1],
          v7[2],
          v7[3],
          v7[4],
          v7[5],
          v7[6],
          v8,
          "read_rxu_status_x7 err, code %d",
          rxu_status_x7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
          179,
          "scan_rxu_hang",
          13,
          1432,
          100,
          v5);
      }
      v20 = 0;
      v19 = 0;
      for ( i = 0; i < v6[0]; ++i )
      {
        if ( *((_DWORD *)v12 + 3 * i) < *(_DWORD *)(v16 + 336) )
        {
          v20 += *((_DWORD *)v12 + 3 * i + 1);
          *((_DWORD *)ptr + 2 * *((_DWORD *)v12 + 3 * i)) += *((_DWORD *)v12 + 3 * i + 1);
          v1 = *((float *)ptr + 2 * *((_DWORD *)v12 + 3 * i) + 1) + (float)*((int *)v12 + 3 * i + 1) * 0.4;
          *((float *)ptr + 2 * *((_DWORD *)v12 + 3 * i) + 1) = v1;
          if ( *((float *)ptr + 2 * *((_DWORD *)v12 + 3 * i) + 1) <= (float)*((int *)ptr + 2 * *((_DWORD *)v12 + 3 * i))
                                                                   + 0.001 )
            v2 = *((float *)ptr + 2 * *((_DWORD *)v12 + 3 * i) + 1);
          else
            v2 = (float)*((int *)ptr + 2 * *((_DWORD *)v12 + 3 * i)) + 0.001;
          *((float *)ptr + 2 * *((_DWORD *)v12 + 3 * i) + 1) = v2;
          v19 += (int)*((float *)ptr + 2 * *((_DWORD *)v12 + 3 * i) + 1);
        }
      }
      if ( v20 - v19 <= 0 )
      {
        usleep(0x1C9C3800u);
      }
      else
      {
        v22 = 2;
        V_LOCK();
        sub_89210((int)v9, *(int *)(v16 + 252));
        logfmt_raw(
          v5,
          0x1000u,
          0,
          v10,
          v9[0],
          v9[1],
          v9[2],
          v9[3],
          v9[4],
          v9[5],
          v9[6],
          v10,
          "%d rxu hang, prepare to restart chip",
          v20);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_x7_2044/backend_x7_2044.c",
          179,
          "scan_rxu_hang",
          13,
          1468,
          40,
          v5);
      }
      goto LABEL_29;
    }
    if ( v21 )
    {
      if ( v21 != 2 )
        goto LABEL_29;
      for ( j = 0; j < *(_DWORD *)(v16 + 336); ++j )
      {
        if ( (float)*((int *)ptr + 2 * *((_DWORD *)v12 + 3 * j)) > *((float *)ptr + 2 * *((_DWORD *)v12 + 3 * j) + 1) )
        {
          *(_BYTE *)(v16 + 1096) = 1;
          *((_DWORD *)ptr + 2 * *((_DWORD *)v12 + 3 * j)) = 0;
          rxu_status_x7 = restart_one_chip_x7(v16, *((_DWORD *)v12 + 3 * j));
          *(_BYTE *)(v16 + 1096) = 0;
          pthread_mutex_lock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(v16 + 248)]
                                               + 76 * *((_DWORD *)v12 + 3 * j)
                                               + 52));
          chip_setting_seed_x7(
            v16,
            (char *)&last_seed_hash_x7 + 32 * *(_DWORD *)(v16 + 248),
            0x20u,
            v5,
            *((_DWORD *)v12 + 3 * j));
          pthread_mutex_unlock((pthread_mutex_t *)(x7_chip_seed_status[*(_DWORD *)(v16 + 248)]
                                                 + 76 * *((_DWORD *)v12 + 3 * j)
                                                 + 52));
          reset_chip_seed_status(v16, *((_DWORD *)v12 + 3 * j));
          chip_seed_status_set_calculating(v16, *((_DWORD *)v12 + 3 * j));
          sleep(0xFu);
        }
      }
    }
    usleep(0x1C9C3800u);
    v22 = 1;
LABEL_29:
    v21 = v22;
LABEL_30:
    usleep(0x7A120u);
  }
  *(_BYTE *)(v15 + 9) = 0;
  free(ptr);
  free(v12);
  return v3;
}
// 8F058: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161740: using guessed type _DWORD x7_chip_seed_status[3];

//----- (0008F064) --------------------------------------------------------
int __fastcall backend_init_x7(int a1)
{
  int (**v1)(); // r0
  int (**v2)(); // r0
  int (**v3)(); // r0
  pthread_t *newthread; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  *(_DWORD *)(a1 + 1288) = calloc(1u, 0xCu);
  newthread = *(pthread_t **)(a1 + 1288);
  v1 = dev_ctrl();
  *(_DWORD *)(a1 + 252) = ((int (__fastcall *)(_DWORD))v1[12])(*(_DWORD *)(a1 + 248));
  v2 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v2[11])(*(_DWORD *)(a1 + 248));
  v3 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v3[1])(*(_DWORD *)(a1 + 248));
  *(_DWORD *)(a1 + 860) = queue_new(1, 0);
  *(_DWORD *)(a1 + 864) = queue_new(*(_DWORD *)(a1 + 832), 0);
  *(_DWORD *)(a1 + 868) = queue_new(1, 0);
  for ( i = 0; i < *(_DWORD *)(a1 + 1000); ++i )
    *(_DWORD *)(a1 + 4 * (i + 218)) = queue_new(1, 0);
  *(_DWORD *)(a1 + 856) = queue_new(*(_DWORD *)(a1 + 828), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 1024), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 1048), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 1072), 0);
  *(_DWORD *)(a1 + 492) = calloc(*(_DWORD *)(a1 + 336), 1u);
  *(_DWORD *)(a1 + 480) = calloc(*(_DWORD *)(a1 + 336), 4u);
  *(_DWORD *)(a1 + 484) = calloc(*(_DWORD *)(a1 + 336) * *(_DWORD *)(a1 + 344), 4u);
  *(_DWORD *)(a1 + 488) = calloc(*(_DWORD *)(a1 + 336), 2 * *(_DWORD *)(a1 + 836));
  *(_DWORD *)(a1 + 456) = calloc(*(_DWORD *)(a1 + 336), 0x30u);
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 428) = -1;
  *(_BYTE *)(a1 + 460) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 472) = 0;
  *(_DWORD *)(a1 + 476) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  *(_DWORD *)(a1 + 512) = 0;
  if ( *(_DWORD *)(a1 + 848) )
    *(_DWORD *)(a1 + 516) = calloc(*(_DWORD *)(a1 + 336), *(_DWORD *)(a1 + 848));
  *(_DWORD *)(a1 + 520) = 0;
  memset((void *)(a1 + 568), 0, 0x100u);
  *(_BYTE *)(a1 + 1020) = 0;
  *(_BYTE *)(a1 + 1021) = 0;
  *(_BYTE *)(a1 + 1022) = 0;
  *((_BYTE *)newthread + 8) = 0;
  *((_BYTE *)newthread + 9) = 0;
  if ( !*(_DWORD *)(a1 + 1004) )
    *(_DWORD *)(a1 + 1004) = a1;
  if ( *(_DWORD *)(a1 + 80) )
    (*(void (__fastcall **)(int))(a1 + 80))(a1);
  x7_chip_seed_status_init((_DWORD *)a1);
  pthread_create((pthread_t *)(a1 + 1012), 0, (void *(*)(void *))get_response, (void *)a1);
  pthread_create((pthread_t *)(a1 + 1008), 0, (void *(*)(void *))scanhash, (void *)a1);
  if ( *((_BYTE *)newthread + 10) )
  {
    pthread_create(newthread, 0, (void *(*)(void *))scanseed, (void *)a1);
    pthread_create(newthread + 1, 0, (void *(*)(void *))scan_rxu_hang, (void *)a1);
  }
  pthread_create((pthread_t *)(a1 + 1016), 0, (void *(*)(void *))send_work, (void *)a1);
  *(_BYTE *)(a1 + 256) = 1;
  return 0;
}

//----- (0008F4C8) --------------------------------------------------------
int __fastcall backend_exit_x7(int a1)
{
  int (**v1)(); // r0
  void *thread_return; // [sp+8h] [bp-14h] BYREF
  void *ptr; // [sp+Ch] [bp-10h]
  int j; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  ptr = *(void **)(a1 + 1288);
  *(_BYTE *)(a1 + 257) = 0;
  *(_BYTE *)(a1 + 258) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  (*(void (__fastcall **)(int))(a1 + 60))(a1);
  if ( *(_DWORD *)(a1 + 84) )
    (*(void (__fastcall **)(int))(a1 + 84))(a1);
  *(_BYTE *)(a1 + 1020) = 1;
  *((_BYTE *)ptr + 8) = 1;
  *((_BYTE *)ptr + 9) = 1;
  *(_BYTE *)(a1 + 1021) = 1;
  *(_BYTE *)(a1 + 1022) = 1;
  queue_force_wakeup(*(_DWORD *)(a1 + 860));
  queue_force_wakeup(*(_DWORD *)(a1 + 864));
  queue_force_wakeup(*(_DWORD *)(a1 + 868));
  for ( i = 0; i < *(_DWORD *)(a1 + 1000); ++i )
    queue_force_wakeup(*(_DWORD *)(a1 + 4 * (i + 218)));
  queue_force_wakeup(*(_DWORD *)(a1 + 856));
  pthread_join(*(_DWORD *)(a1 + 1012), &thread_return);
  pthread_join(*(_DWORD *)(a1 + 1008), &thread_return);
  if ( *((_BYTE *)ptr + 10) )
  {
    pthread_join(*(_DWORD *)ptr, &thread_return);
    pthread_join(*((_DWORD *)ptr + 1), &thread_return);
  }
  pthread_join(*(_DWORD *)(a1 + 1016), &thread_return);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1024));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1048));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1072));
  queue_free(*(_DWORD *)(a1 + 860));
  queue_free(*(_DWORD *)(a1 + 864));
  queue_free(*(_DWORD *)(a1 + 868));
  for ( j = 0; j < *(_DWORD *)(a1 + 1000); ++j )
    queue_free(*(_DWORD *)(a1 + 4 * (j + 218)));
  queue_free(*(_DWORD *)(a1 + 856));
  free(*(void **)(a1 + 492));
  free(*(void **)(a1 + 480));
  free(*(void **)(a1 + 488));
  free(*(void **)(a1 + 456));
  free(*(void **)(a1 + 484));
  if ( *(_DWORD *)(a1 + 848) )
    free(*(void **)(a1 + 516));
  *(_DWORD *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 428) = -1;
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 1004) = 0;
  free(ptr);
  v1 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v1[7])(*(_DWORD *)(a1 + 248));
  return 0;
}

//----- (0008F818) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_8F818(int a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (0008F850) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_8F850(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0008F884) --------------------------------------------------------
int __fastcall sub_8F884(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+14h] [bp-30h]
  __int64 v8; // [sp+18h] [bp-2Ch]
  __int16 v9; // [sp+20h] [bp-24h]
  __int64 v10; // [sp+22h] [bp-22h]
  __int64 v11; // [sp+2Ah] [bp-1Ah]
  int v12; // [sp+34h] [bp-10h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+3Ch] [bp-8h]

  v6 = result;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  while ( a2 && v14 <= 29 )
  {
    sub_CC7AC(a2, a3);
    *((_BYTE *)&v7 + v14++) = v3 + 48;
    result = sub_CC518(a2, a3);
    a2 = result;
  }
  v13 = 0;
  v12 = v14 - 1;
  while ( v13 < v14 )
    *(_BYTE *)(v6 + v13++) = *((_BYTE *)&v7 + v12--);
  return result;
}
// 8F8F0: variable 'v3' is possibly undefined

//----- (0008F99C) --------------------------------------------------------
int __fastcall sub_8F99C(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp-5h]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (0008FA10) --------------------------------------------------------
int __fastcall sub_8FA10(unsigned __int8 a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/./util.h",
    146,
    "get_value_from_lower_hex",
    24,
    50,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0008FB34) --------------------------------------------------------
_BYTE *__fastcall sub_8FB34(_BYTE *result)
{
  _BYTE *v1; // r3
  _BYTE *v2; // [sp+4h] [bp-8h]

  v2 = result;
  if ( *result )
  {
    v2 = result + 1;
    *result = 120;
  }
  while ( *v2 )
  {
    v1 = v2++;
    *v1 = 0;
  }
  return result;
}

//----- (0008FBA0) --------------------------------------------------------
int __fastcall wait_x7_chip_setting_not_pending(int a1)
{
  int v1; // r2
  _DWORD *v4; // [sp+Ch] [bp-10h]

  if ( *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248) + 56) != 1 )
  {
    pthread_mutex_init((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32), 0);
    *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248) + 56) = 1;
  }
  while ( 1 )
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32));
    if ( *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248)) != 1 )
      break;
    v1 = *(_DWORD *)(a1 + 248) << 6;
    v4 = (_DWORD *)((char *)&pending + v1 + 4);
    clock_gettime(1, (struct timespec *)((char *)&pending + v1 + 12));
    if ( vshld_n_s64(4 * (vshld_n_s64(v4[2] - *v4, 5u) - (v4[2] - *v4)) + v4[2] - *v4, 3u) + (v4[3] - v4[1]) / 1000000 >= *((_QWORD *)&pending + 8 * *(_DWORD *)(a1 + 248) + 3) )
      break;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32));
    usleep(0x3E8u);
  }
  clock_gettime(1, (struct timespec *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 4));
  *((_QWORD *)&pending + 8 * *(_DWORD *)(a1 + 248) + 3) = 0;
  *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248)) = 0;
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32));
}

//----- (0008FE28) --------------------------------------------------------
int __fastcall set_x7_chip_setting_pending(int a1, int a2)
{
  if ( *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248) + 56) != 1 )
  {
    pthread_mutex_init((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32), 0);
    *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248) + 56) = 1;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32));
  clock_gettime(1, (struct timespec *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 4));
  *((_QWORD *)&pending + 8 * *(_DWORD *)(a1 + 248) + 3) = 1000 * a2;
  if ( *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248)) != 1 )
    *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248)) = 1;
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32));
}

//----- (0008FFA4) --------------------------------------------------------
int __fastcall x7_chip_finish_pending(int a1)
{
  if ( *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248) + 56) != 1 )
  {
    pthread_mutex_init((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32), 0);
    *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248) + 56) = 1;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32));
  *((_QWORD *)&pending + 8 * *(_DWORD *)(a1 + 248) + 3) = 0;
  *((_BYTE *)&pending + 64 * *(_DWORD *)(a1 + 248)) = 0;
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)&pending + 64 * *(_DWORD *)(a1 + 248) + 32));
}

//----- (000900B8) --------------------------------------------------------
int __fastcall set_chip_reg_x7(int a1, unsigned __int8 *a2)
{
  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  send_command_packet(a1, a2, a2[5] + 8);
  return 0;
}

//----- (00090120) --------------------------------------------------------
int __fastcall sync_get_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, unsigned __int64 a7, char a8)
{
  int v9; // r2
  int v10; // r3
  char v16[36]; // [sp+20h] [bp-1224h] BYREF
  _DWORD v17[2]; // [sp+1020h] [bp-224h] BYREF
  _WORD src[262]; // [sp+1028h] [bp-21Ch] BYREF
  __int16 v19; // [sp+1234h] [bp-10h]
  __int16 v20; // [sp+1236h] [bp-Eh]
  int v21; // [sp+1238h] [bp-Ch]
  int v22; // [sp+123Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  if ( a8 )
    queue_clear(*(_DWORD *)(a1 + 868));
  v22 = 0;
  v21 = 0;
  sub_CCDFC(a7, 0x3E8u);
  v17[1] = (_DWORD)&unk_F4240 * v9;
  v17[0] = sub_CCDFC(a7, 0x3E8u);
  while ( v22 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), (char *)src, 0xCu, v17) == 110 )
    {
      v21 = 3;
      break;
    }
    if ( LOBYTE(src[0]) != 170 || HIBYTE(src[0]) != 85 )
    {
      v21 = 1;
      break;
    }
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), (char *)&src[6], LOBYTE(src[3]), v17) == 110 )
    {
      v21 = 3;
      break;
    }
    if ( a2 == LOBYTE(src[1]) )
    {
      if ( LOBYTE(src[3]) != a5 - 12 )
      {
        v21 = 1;
        break;
      }
      v20 = src[4];
      src[4] = 0;
      v19 = BM_CRC16((char *)src, a5);
      if ( v20 != v19 )
      {
        v21 = 2;
        break;
      }
      v10 = v22++;
      memcpy((void *)(a4 + 524 * v10), src, 0x20Cu);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v16, 0x1000u, 0, "received unexpected response package, cmd %d", LOBYTE(src[1]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "sync_get_status_x7",
        18,
        126,
        20,
        v16);
    }
  }
  *a6 = v22;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v21;
}
// 901FC: variable 'v9' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00090464) --------------------------------------------------------
int __fastcall sync_get_rxu_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, unsigned __int64 a7)
{
  int v8; // r2
  int v9; // r3
  char v15[36]; // [sp+20h] [bp-1224h] BYREF
  _DWORD v16[2]; // [sp+1020h] [bp-224h] BYREF
  _WORD src[262]; // [sp+1028h] [bp-21Ch] BYREF
  __int16 v18; // [sp+1234h] [bp-10h]
  __int16 v19; // [sp+1236h] [bp-Eh]
  int v20; // [sp+1238h] [bp-Ch]
  int v21; // [sp+123Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  queue_clear(*(_DWORD *)(a1 + 884));
  v21 = 0;
  v20 = 0;
  sub_CCDFC(a7, 0x3E8u);
  v16[1] = (_DWORD)&unk_F4240 * v8;
  v16[0] = sub_CCDFC(a7, 0x3E8u);
  while ( v21 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 884), (char *)src, 0xCu, v16) == 110 )
    {
      v20 = 3;
      break;
    }
    if ( LOBYTE(src[0]) != 170 || HIBYTE(src[0]) != 85 )
    {
      v20 = 1;
      break;
    }
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 884), (char *)&src[6], LOBYTE(src[3]), v16) == 110 )
    {
      v20 = 3;
      break;
    }
    if ( a2 == LOBYTE(src[1]) )
    {
      if ( LOBYTE(src[3]) != a5 - 12 )
      {
        v20 = 1;
        break;
      }
      v19 = src[4];
      src[4] = 0;
      v18 = BM_CRC16((char *)src, a5);
      if ( v19 != v18 )
      {
        v20 = 2;
        break;
      }
      v9 = v21++;
      memcpy((void *)(a4 + 524 * v9), src, 0x20Cu);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, "received unexpected response package, cmd %d", LOBYTE(src[1]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "sync_get_rxu_status_x7",
        22,
        190,
        20,
        v15);
    }
  }
  *a6 = v21;
  return v20;
}
// 9051C: variable 'v8' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009076C) --------------------------------------------------------
int __fastcall sync_get_temperature_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, unsigned __int64 a7)
{
  int v8; // r2
  int v9; // r3
  char v15[36]; // [sp+20h] [bp-1224h] BYREF
  _DWORD v16[2]; // [sp+1020h] [bp-224h] BYREF
  _WORD src[262]; // [sp+1028h] [bp-21Ch] BYREF
  __int16 v18; // [sp+1234h] [bp-10h]
  __int16 v19; // [sp+1236h] [bp-Eh]
  int v20; // [sp+1238h] [bp-Ch]
  int v21; // [sp+123Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v21 = 0;
  v20 = 0;
  sub_CCDFC(a7, 0x3E8u);
  v16[1] = (_DWORD)&unk_F4240 * v8;
  v16[0] = sub_CCDFC(a7, 0x3E8u);
  while ( v21 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 872), (char *)src, 0xCu, v16) == 110 )
    {
      v20 = 3;
      break;
    }
    if ( LOBYTE(src[0]) != 170 || HIBYTE(src[0]) != 85 )
    {
      v20 = 1;
      break;
    }
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 872), (char *)&src[6], LOBYTE(src[3]), v16) == 110 )
    {
      v20 = 3;
      break;
    }
    if ( a2 == LOBYTE(src[1]) )
    {
      if ( LOBYTE(src[3]) != a5 - 12 )
      {
        v20 = 1;
        break;
      }
      v19 = src[4];
      src[4] = 0;
      v18 = BM_CRC16((char *)src, a5);
      if ( v19 != v18 )
      {
        v20 = 2;
        break;
      }
      v9 = v21++;
      memcpy((void *)(a4 + 524 * v9), src, 0x20Cu);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, "received unexpected response package, cmd %d", LOBYTE(src[1]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "sync_get_temperature_status_x7",
        30,
        254,
        20,
        v15);
    }
  }
  *a6 = v21;
  return v20;
}
// 907FC: variable 'v8' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00090A4C) --------------------------------------------------------
int __fastcall sync_unblocked_get_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v7; // r3
  char v13[36]; // [sp+20h] [bp-1224h] BYREF
  _DWORD v14[2]; // [sp+1020h] [bp-224h] BYREF
  _WORD src[262]; // [sp+1028h] [bp-21Ch] BYREF
  __int16 v16; // [sp+1234h] [bp-10h]
  __int16 v17; // [sp+1236h] [bp-Eh]
  int v18; // [sp+1238h] [bp-Ch]
  int v19; // [sp+123Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  v19 = 0;
  v18 = 0;
  v14[1] = 100000000;
  while ( v19 < a3 )
  {
    if ( !queue_try_dequeue(*(_DWORD *)(a1 + 868), (char *)src, 0xCu) )
    {
      v18 = 0;
      break;
    }
    if ( LOBYTE(src[0]) != 170 || HIBYTE(src[0]) != 85 )
    {
      v18 = 1;
      break;
    }
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), (char *)&src[6], LOBYTE(src[3]), v14) == 110 )
    {
      v18 = 3;
      break;
    }
    if ( a2 == LOBYTE(src[1]) )
    {
      if ( LOBYTE(src[3]) != a5 - 12 )
      {
        v18 = 1;
        break;
      }
      v17 = src[4];
      src[4] = 0;
      v16 = BM_CRC16((char *)src, a5);
      if ( v17 != v16 )
      {
        v18 = 2;
        break;
      }
      v7 = v19++;
      memcpy((void *)(a4 + 524 * v7), src, 0x20Cu);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "received unexpected response package, cmd %d", LOBYTE(src[1]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "sync_unblocked_get_status_x7",
        28,
        315,
        20,
        v13);
    }
  }
  *a6 = v19;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v18;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00090D38) --------------------------------------------------------
int __fastcall sync_unblocked_get_msg_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v7; // r3
  char v13[36]; // [sp+20h] [bp-1224h] BYREF
  _DWORD v14[2]; // [sp+1020h] [bp-224h] BYREF
  _WORD src[262]; // [sp+1028h] [bp-21Ch] BYREF
  __int16 v16; // [sp+1234h] [bp-10h]
  __int16 v17; // [sp+1236h] [bp-Eh]
  int v18; // [sp+1238h] [bp-Ch]
  int v19; // [sp+123Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  v19 = 0;
  v18 = 0;
  v14[1] = 100000000;
  while ( v19 < a3 )
  {
    if ( !queue_try_dequeue(*(_DWORD *)(a1 + 876), (char *)src, 0xCu) )
    {
      v18 = 0;
      break;
    }
    if ( LOBYTE(src[0]) != 170 || HIBYTE(src[0]) != 85 )
    {
      v18 = 1;
      break;
    }
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 876), (char *)&src[6], LOBYTE(src[3]), v14) == 110 )
    {
      v18 = 3;
      break;
    }
    if ( a2 == LOBYTE(src[1]) )
    {
      if ( LOBYTE(src[3]) != a5 - 12 )
      {
        v18 = 1;
        break;
      }
      v17 = src[4];
      src[4] = 0;
      v16 = BM_CRC16((char *)src, a5);
      if ( v17 != v16 )
      {
        v18 = 2;
        break;
      }
      v7 = v19++;
      memcpy((void *)(a4 + 524 * v7), src, 0x20Cu);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "received unexpected response package, cmd %d", LOBYTE(src[1]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "sync_unblocked_get_msg_x7",
        25,
        377,
        20,
        v13);
    }
  }
  *a6 = v19;
  return v18;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00090FF4) --------------------------------------------------------
int __fastcall sync_get_seed_status_x7(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, unsigned __int64 a7)
{
  int v8; // r2
  int v9; // r3
  char v15[36]; // [sp+20h] [bp-1224h] BYREF
  _DWORD v16[2]; // [sp+1020h] [bp-224h] BYREF
  _WORD src[262]; // [sp+1028h] [bp-21Ch] BYREF
  __int16 v18; // [sp+1234h] [bp-10h]
  __int16 v19; // [sp+1236h] [bp-Eh]
  int v20; // [sp+1238h] [bp-Ch]
  int v21; // [sp+123Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  queue_clear(*(_DWORD *)(a1 + 880));
  v21 = 0;
  v20 = 0;
  sub_CCDFC(a7, 0x3E8u);
  v16[1] = (_DWORD)&unk_F4240 * v8;
  v16[0] = sub_CCDFC(a7, 0x3E8u);
  while ( v21 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 880), (char *)src, 0xCu, v16) == 110 )
    {
      v20 = 3;
      break;
    }
    if ( LOBYTE(src[0]) != 170 || HIBYTE(src[0]) != 85 )
    {
      v20 = 1;
      break;
    }
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 880), (char *)&src[6], LOBYTE(src[3]), v16) == 110 )
    {
      v20 = 3;
      break;
    }
    if ( a2 == LOBYTE(src[1]) )
    {
      if ( LOBYTE(src[3]) != a5 - 12 )
      {
        v20 = 1;
        break;
      }
      v19 = src[4];
      src[4] = 0;
      v18 = BM_CRC16((char *)src, a5);
      if ( v19 != v18 )
      {
        v20 = 2;
        break;
      }
      v9 = v21++;
      memcpy((void *)(a4 + 524 * v9), src, 0x20Cu);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, "received unexpected response package, cmd %d", LOBYTE(src[1]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "sync_get_seed_status_x7",
        23,
        441,
        20,
        v15);
    }
  }
  *a6 = v21;
  return v20;
}
// 910AC: variable 'v8' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000912FC) --------------------------------------------------------
int __fastcall sync_unblocked_get_seed_status_x7(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v6; // r3
  char v12[40]; // [sp+24h] [bp-1228h] BYREF
  _DWORD v13[2]; // [sp+1024h] [bp-228h] BYREF
  _WORD src[262]; // [sp+102Ch] [bp-220h] BYREF
  __int16 v15; // [sp+1238h] [bp-14h]
  __int16 v16; // [sp+123Ah] [bp-12h]
  int v17; // [sp+123Ch] [bp-10h]
  int v18; // [sp+1240h] [bp-Ch]
  int v19; // [sp+1244h] [bp-8h]

  v17 = 44;
  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  v19 = 0;
  v18 = 0;
  v13[1] = 100000000;
  while ( v19 < a3 )
  {
    if ( !queue_try_dequeue(*(_DWORD *)(a1 + 880), (char *)src, 0xCu) )
    {
      v18 = 0;
      break;
    }
    if ( LOBYTE(src[0]) != 170 || HIBYTE(src[0]) != 85 )
    {
      v18 = 1;
      break;
    }
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 880), (char *)&src[6], LOBYTE(src[3]), v13) == 110 )
    {
      v18 = 3;
      break;
    }
    if ( a2 == LOBYTE(src[1]) )
    {
      if ( LOBYTE(src[3]) != v17 - 12 )
      {
        v18 = 1;
        break;
      }
      v16 = src[4];
      src[4] = 0;
      v15 = BM_CRC16((char *)src, v17);
      if ( v16 != v15 )
      {
        v18 = 2;
        break;
      }
      v6 = v19++;
      memcpy((void *)(a4 + 524 * v6), src, 0x20Cu);
    }
    else
    {
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "received unexpected response package, cmd %d", LOBYTE(src[1]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "sync_unblocked_get_seed_status_x7",
        33,
        503,
        20,
        v12);
    }
  }
  *a5 = v19;
  return v18;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000915C4) --------------------------------------------------------
int __fastcall sync_get_chip_reg_x7(int a1, int a2, unsigned __int8 *a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  int v12; // [sp+28h] [bp-Ch]
  int v13; // [sp+2Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  if ( a3[2] )
  {
    switch ( a3[2] )
    {
      case 0x12u:
        v13 = 16;
        break;
      case 0x14u:
        v13 = 16;
        break;
      case 0x10u:
      case 7u:
        v13 = 16;
        break;
      default:
        return 1;
    }
  }
  else
  {
    v13 = 20;
  }
  v12 = set_chip_reg_x7(a1, a3);
  if ( v12 )
    return v12;
  else
    return sync_get_status_x7(a1, a3[2], a2, a4, v13, a5, a6, 1);
}

//----- (00091708) --------------------------------------------------------
int __fastcall sync_get_chip_rxu_status_reg_x7(
        int a1,
        int a2,
        unsigned __int8 *a3,
        int a4,
        _DWORD *a5,
        unsigned __int64 a6)
{
  int v12; // [sp+24h] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  if ( a3[2] != 19 )
    return 1;
  v12 = set_chip_reg_x7(a1, a3);
  if ( v12 )
    return v12;
  else
    return sync_get_rxu_status_x7(a1, a3[2], a2, a4, 16, a5, a6);
}

//----- (000917E0) --------------------------------------------------------
int __fastcall sync_get_chip_temperature_reg_x7(
        int a1,
        int a2,
        unsigned __int8 *a3,
        int a4,
        _DWORD *a5,
        unsigned __int64 a6)
{
  int v12; // [sp+24h] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  wait_x7_chip_setting_not_pending(a1);
  if ( a3[2] != 9 )
    return 1;
  queue_clear(*(_DWORD *)(a1 + 872));
  v12 = set_chip_reg_x7(a1, a3);
  if ( v12 )
    return v12;
  else
    return sync_get_temperature_status_x7(a1, a3[2], a2, a4, 16, a5, a6);
}

//----- (000918C8) --------------------------------------------------------
int __fastcall chip_setting_get_addr_x7(int *a1, unsigned int a2)
{
  int v2; // r3
  char v6[24]; // [sp+5Ch] [bp-1798h] BYREF
  _BYTE v7[1024]; // [sp+105Ch] [bp-798h] BYREF
  _BYTE s[256]; // [sp+145Ch] [bp-398h] BYREF
  int v9; // [sp+155Ch] [bp-298h] BYREF
  unsigned __int8 v10[6]; // [sp+1560h] [bp-294h] BYREF
  __int16 v11; // [sp+1566h] [bp-28Eh]
  _DWORD v12[7]; // [sp+1768h] [bp-8Ch] BYREF
  int v13; // [sp+1784h] [bp-70h]
  _DWORD v14[7]; // [sp+1788h] [bp-6Ch] BYREF
  int v15; // [sp+17A4h] [bp-50h]
  _DWORD v16[9]; // [sp+17A8h] [bp-4Ch] BYREF
  int i; // [sp+17CCh] [bp-28h]
  int v18; // [sp+17D0h] [bp-24h]
  char *v19; // [sp+17D4h] [bp-20h]
  unsigned int j; // [sp+17D8h] [bp-1Ch]
  int chip_reg_x7; // [sp+17DCh] [bp-18h]
  int v22; // [sp+17E0h] [bp-14h]
  void *ptr; // [sp+17E4h] [bp-10h]

  v9 = 0;
  v22 = 0;
  chip_reg_x7 = 0;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "%s chip_no %d", "chip_setting_get_addr_x7", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
    184,
    "chip_setting_get_addr_x7",
    24,
    629,
    20,
    v6);
  memset(s, 0, sizeof(s));
  ptr = malloc(524 * a2);
  memset(ptr, 0, 524 * a2);
  v10[0] = 85;
  v10[1] = -86;
  v10[2] = 0;
  v10[3] = -1;
  v10[4] = -1;
  v10[5] = 0;
  v11 = 0;
  v11 = BM_CRC16((char *)v10, 8);
  chip_reg_x7 = sync_get_chip_reg_x7((int)a1, a2, v10, (int)ptr, &v9, 0xBB8u);
  V_LOCK();
  sub_8F850((int)v12, a1[63]);
  logfmt_raw(
    v6,
    0x1000u,
    0,
    v13,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v13,
    "%s detect %d chips",
    "chip_setting_get_addr_x7",
    v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
    184,
    "chip_setting_get_addr_x7",
    24,
    649,
    60,
    v6);
  for ( i = 0; i < v9; ++i )
  {
    if ( !*((_BYTE *)ptr + 524 * i + 2) )
    {
      V_LOCK();
      logfmt_raw(
        v6,
        0x1000u,
        0,
        "[GET ADDR] fw version %c%c%c%c chip %d",
        *((unsigned __int8 *)ptr + 524 * i + 12),
        *((unsigned __int8 *)ptr + 524 * i + 13),
        *((unsigned __int8 *)ptr + 524 * i + 14),
        *((unsigned __int8 *)ptr + 524 * i + 15),
        *((unsigned __int8 *)ptr + 524 * i + 3));
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "chip_setting_get_addr_x7",
        24,
        653,
        60,
        v6);
      if ( !s[*((unsigned __int8 *)ptr + 524 * i + 3)] )
      {
        v2 = *((unsigned __int8 *)ptr + 524 * i + 3);
        ++s[v2];
        ++v22;
      }
    }
  }
  v18 = 0;
  memset(v7, 0, sizeof(v7));
  v7[0] = 10;
  v19 = v7;
  for ( j = 0; a2 > j; ++j )
  {
    if ( !s[j] )
    {
      sprintf(v19, "%03d ", j);
      v19 += 4;
      ++v18;
    }
  }
  if ( v22 < a1[84] )
  {
    V_LOCK();
    sub_8F850((int)v14, a1[63]);
    sub_8F818((int)v16, "asic num error");
    logfmt_raw(
      v6,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      v16[0],
      v16[1],
      v16[2],
      v16[3],
      v16[4],
      v16[5],
      v16[6],
      v16[7],
      "detected asic num less than design(%d<%d)",
      v22,
      a1[84]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
      184,
      "chip_setting_get_addr_x7",
      24,
      683,
      100,
      v6);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "Sweep error string = J%d:2.", a1[63]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
      184,
      "chip_setting_get_addr_x7",
      24,
      684,
      100,
      v6);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "bad asic: %s", v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
      184,
      "chip_setting_get_addr_x7",
      24,
      685,
      40,
      v6);
  }
  free(ptr);
  a1[106] = v22;
  return chip_reg_x7;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00092040) --------------------------------------------------------
int __fastcall chip_setting_seed_x7(int a1, const void *a2, unsigned __int8 a3, void *a4, unsigned __int8 a5)
{
  unsigned __int8 src[5]; // [sp+10h] [bp-20Ch] BYREF
  unsigned __int8 v9; // [sp+15h] [bp-207h]
  __int16 v10; // [sp+16h] [bp-206h]
  int v11; // [sp+18h] [bp-204h] BYREF

  src[0] = 85;
  src[1] = -86;
  src[2] = 2;
  src[3] = a5;
  src[4] = -1;
  v9 = a3;
  v10 = 0;
  memcpy(&v11, a2, a3);
  v10 = BM_CRC16((char *)src, v9 + 8);
  memcpy(a4, src, v9 + 8);
  return set_chip_reg_x7(a1, src);
}

//----- (00092120) --------------------------------------------------------
int __fastcall chip_setting_msg_x7(int a1, const void *a2, unsigned __int8 a3, char a4)
{
  char v9[52]; // [sp+38h] [bp-1234h] BYREF
  _WORD dest[260]; // [sp+1038h] [bp-234h] BYREF
  _DWORD v11[7]; // [sp+1240h] [bp-2Ch] BYREF
  int v12; // [sp+125Ch] [bp-10h]

  memcpy(dest, a2, 0xD6u);
  dest[0] = -21931;
  LOBYTE(dest[1]) = 3;
  HIBYTE(dest[1]) = a4;
  LOBYTE(dest[2]) = -1;
  HIBYTE(dest[2]) = a3 - 8;
  dest[3] = 0;
  dest[3] = BM_CRC16((char *)dest, (unsigned __int8)(a3 - 8) + 8);
  if ( a3 && a3 > 8u )
    return set_chip_reg_x7(a1, (unsigned __int8 *)dest);
  V_LOCK();
  sub_8F850((int)v11, *(int *)(a1 + 252));
  logfmt_raw(v9, 0x1000u, 0, v12, v11[0], v11[1], v11[2], v11[3], v11[4], v11[5], v11[6], v12, "packet_len is zero");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
    184,
    "chip_setting_msg_x7",
    19,
    737,
    40,
    v9);
  return 4;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00092320) --------------------------------------------------------
int __fastcall chip_setting_baud_x7(int a1, int a2)
{
  char v5[12]; // [sp+18h] [bp-120Ch] BYREF
  unsigned __int8 v6[6]; // [sp+1018h] [bp-20Ch] BYREF
  __int16 v7; // [sp+101Eh] [bp-206h]
  int v8; // [sp+1020h] [bp-204h]

  v6[0] = 85;
  v6[1] = -86;
  v6[2] = 14;
  v6[3] = -1;
  v6[4] = -1;
  v6[5] = 4;
  v7 = 0;
  v8 = a2;
  v7 = BM_CRC16((char *)v6, 12);
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set baud value %d", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
    184,
    "chip_setting_baud_x7",
    20,
    768,
    60,
    v5);
  set_chip_reg_x7(a1, v6);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00092474) --------------------------------------------------------
int __fastcall chip_setting_get_md5sum_x7(int a1, int a2, unsigned __int8 a3, const void *a4, size_t n, _BYTE *a6)
{
  char v12[48]; // [sp+44h] [bp-1270h] BYREF
  int v14; // [sp+1048h] [bp-26Ch]
  int v15; // [sp+104Ch] [bp-268h] BYREF
  unsigned __int8 v16[5]; // [sp+1050h] [bp-264h] BYREF
  unsigned __int8 v17; // [sp+1055h] [bp-25Fh]
  __int16 v18; // [sp+1056h] [bp-25Eh]
  int v19; // [sp+1058h] [bp-25Ch]
  int v20; // [sp+105Ch] [bp-258h] BYREF
  _DWORD v21[7]; // [sp+1258h] [bp-5Ch] BYREF
  int v22; // [sp+1274h] [bp-40h]
  _DWORD v23[7]; // [sp+1278h] [bp-3Ch] BYREF
  int v24; // [sp+1294h] [bp-20h]
  void *s; // [sp+129Ch] [bp-18h]
  int i; // [sp+12A0h] [bp-14h]
  int chip_reg_x7; // [sp+12A4h] [bp-10h]

  v15 = 0;
  chip_reg_x7 = 0;
  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "%s chip_no %d", "chip_setting_get_md5sum_x7", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
    184,
    "chip_setting_get_md5sum_x7",
    26,
    783,
    20,
    v12);
  s = malloc(524 * a2);
  memset(s, 0, 524 * a2);
  v16[0] = 85;
  v16[1] = -86;
  v16[2] = 18;
  v16[3] = -1;
  v16[4] = -1;
  v17 = n + 4;
  v14 = a3;
  v19 = a3;
  memcpy(&v20, a4, n);
  v18 = 0;
  v18 = BM_CRC16((char *)v16, v17 + 8);
  chip_reg_x7 = sync_get_chip_reg_x7(a1, a2, v16, (int)s, &v15, 0xEA60u);
  if ( a2 == v15 )
  {
    if ( !chip_reg_x7 )
    {
      *a6 = 0;
      for ( i = 0; i < v15; ++i )
      {
        if ( *((_BYTE *)s + 524 * i + 2) == 18 )
        {
          if ( *((_DWORD *)s + 131 * i + 3) )
          {
            ++*a6;
          }
          else
          {
            V_LOCK();
            sub_8F850((int)v23, *(int *)(a1 + 252));
            logfmt_raw(
              v12,
              0x1000u,
              0,
              v24,
              v23[0],
              v23[1],
              v23[2],
              v23[3],
              v23[4],
              v23[5],
              v23[6],
              v24,
              "%s : chip %d md5sum check failed",
              "chip_setting_get_md5sum_x7",
              *((unsigned __int8 *)s + 524 * i + 3));
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
              184,
              "chip_setting_get_md5sum_x7",
              26,
              821,
              100,
              v12);
          }
        }
      }
    }
    free(s);
    return chip_reg_x7;
  }
  else
  {
    V_LOCK();
    sub_8F850((int)v21, *(int *)(a1 + 252));
    logfmt_raw(
      v12,
      0x1000u,
      0,
      v22,
      v21[0],
      v21[1],
      v21[2],
      v21[3],
      v21[4],
      v21[5],
      v21[6],
      v22,
      "%s get only %d response",
      "chip_setting_get_md5sum_x7",
      v15);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
      184,
      "chip_setting_get_md5sum_x7",
      26,
      803,
      100,
      v12);
    free(s);
    return chip_reg_x7;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00092948) --------------------------------------------------------
int __fastcall chip_setting_get_restart_reg_x7(int a1, unsigned __int8 a2, _DWORD *a3)
{
  char v7[36]; // [sp+28h] [bp-1024h] BYREF
  int v8; // [sp+1028h] [bp-24h] BYREF
  void *ptr; // [sp+102Ch] [bp-20h]
  void *s; // [sp+1030h] [bp-1Ch]
  int i; // [sp+1034h] [bp-18h]
  int j; // [sp+1038h] [bp-14h]
  int status_x7; // [sp+103Ch] [bp-10h]
  size_t size; // [sp+1040h] [bp-Ch]
  int v15; // [sp+1044h] [bp-8h]

  status_x7 = 0;
  size = 1;
  v15 = 16;
  if ( a2 == 255 )
    size = *(_DWORD *)(a1 + 336);
  s = malloc(size);
  memset(s, 0, size);
  ptr = malloc(524 * size);
  memset(ptr, 0, 524 * size);
  *a3 = 0;
  status_x7 = sync_get_status_x7(a1, 20, size, (int)ptr, v15, &v8, 0x7530u, 0);
  for ( i = 0; i < v8; ++i )
  {
    if ( *((_BYTE *)ptr + 524 * i + 2) == 20 && (a2 == 255 || a2 == *((unsigned __int8 *)ptr + 524 * i + 3)) )
    {
      *((_BYTE *)s + i) = 1;
      ++*a3;
    }
  }
  if ( size != *a3 )
  {
    V_LOCK();
    if ( a2 == 255 )
    {
      logfmt_raw(v7, 0x1000u, 0, "some chip not found");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "chip_setting_get_restart_reg_x7",
        31,
        863,
        100,
        v7);
    }
    else
    {
      logfmt_raw(v7, 0x1000u, 0, "some chip not found, chip_id %d", a2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
        184,
        "chip_setting_get_restart_reg_x7",
        31,
        865,
        100,
        v7);
    }
    for ( j = 0; j < v8; ++j )
    {
      if ( *((_BYTE *)ptr + 524 * j + 2) == 20 )
      {
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "responsed chip:%d", *((unsigned __int8 *)ptr + 524 * j + 3));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
          184,
          "chip_setting_get_restart_reg_x7",
          31,
          870,
          100,
          v7);
      }
    }
  }
  free(ptr);
  free(s);
  return status_x7;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00092D60) --------------------------------------------------------
int __fastcall chip_setting_send_update_cmd_x7(int a1, int a2, unsigned __int8 a3, _BYTE *a4)
{
  char v10[52]; // [sp+40h] [bp-1274h] BYREF
  int v12; // [sp+1044h] [bp-270h] BYREF
  unsigned __int8 v13[2]; // [sp+1048h] [bp-26Ch] BYREF
  char v14; // [sp+104Ah] [bp-26Ah]
  char v15; // [sp+104Bh] [bp-269h]
  char v16; // [sp+104Ch] [bp-268h]
  char v17; // [sp+104Dh] [bp-267h]
  __int16 v18; // [sp+104Eh] [bp-266h]
  _DWORD v19[2]; // [sp+1250h] [bp-64h] BYREF
  __int64 v20; // [sp+1258h] [bp-5Ch]
  int v21; // [sp+1260h] [bp-54h]
  int v22; // [sp+1264h] [bp-50h]
  int v23; // [sp+1268h] [bp-4Ch]
  int v24; // [sp+126Ch] [bp-48h]
  _DWORD v25[2]; // [sp+1270h] [bp-44h] BYREF
  __int64 v26; // [sp+1278h] [bp-3Ch]
  int v27; // [sp+1280h] [bp-34h]
  int v28; // [sp+1284h] [bp-30h]
  int v29; // [sp+1288h] [bp-2Ch]
  int v30; // [sp+128Ch] [bp-28h]
  int v31; // [sp+1294h] [bp-20h]
  void *s; // [sp+1298h] [bp-1Ch]
  int i; // [sp+129Ch] [bp-18h]
  int chip_reg_x7; // [sp+12A0h] [bp-14h]
  char *v35; // [sp+12A4h] [bp-10h]

  v12 = 0;
  chip_reg_x7 = 0;
  v35 = (char *)&unk_F4240;
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s chip_no %d", "chip_setting_send_update_cmd_x7", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
    184,
    "chip_setting_send_update_cmd_x7",
    31,
    889,
    20,
    v10);
  s = malloc(524 * a2);
  memset(s, 0, 524 * a2);
  v13[0] = 85;
  v13[1] = -86;
  if ( a3 )
    v14 = 16;
  else
    v14 = 7;
  v15 = -1;
  v16 = -1;
  v17 = 0;
  v31 = a3;
  v18 = 0;
  v18 = BM_CRC16((char *)v13, 8);
  if ( a3 )
    v35 = (_BYTE *)(&loc_7A11C + 4);
  else
    v35 = "ce/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-origin_godminer-branch1/backend/backend_ltc_1491/chip_reg_io_ltc_1491.c";
  chip_reg_x7 = sync_get_chip_reg_x7(a1, a2, v13, (int)s, &v12, (int)v35);
  if ( a2 == v12 )
  {
    if ( !chip_reg_x7 )
    {
      *a4 = 0;
      for ( i = 0; i < v12; ++i )
      {
        if ( *((_DWORD *)s + 131 * i + 3) )
        {
          ++*a4;
        }
        else
        {
          V_LOCK();
          sub_8F850((int)v25, *(int *)(a1 + 252));
          logfmt_raw(
            v10,
            0x1000u,
            0,
            v30,
            v25[0],
            v25[1],
            v26,
            v27,
            v28,
            v29,
            v30,
            "chip %d update failed",
            "chip_setting_send_update_cmd_x7",
            *((unsigned __int8 *)s + 524 * i + 3));
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
            184,
            "chip_setting_send_update_cmd_x7",
            31,
            933,
            100,
            v10);
        }
      }
    }
    free(s);
    return chip_reg_x7;
  }
  else
  {
    V_LOCK();
    sub_8F850((int)v19, *(int *)(a1 + 252));
    logfmt_raw(
      v10,
      0x1000u,
      0,
      v24,
      v19[0],
      v19[1],
      v20,
      v21,
      v22,
      v23,
      v24,
      "%s get only %d response",
      "chip_setting_send_update_cmd_x7",
      v12);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
      184,
      "chip_setting_send_update_cmd_x7",
      31,
      914,
      100,
      v10);
    free(s);
    return chip_reg_x7;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00093250) --------------------------------------------------------
int __fastcall chip_setting_restart_one_chip_x7(int a1, unsigned __int8 a2, _DWORD *a3)
{
  unsigned __int8 v6[6]; // [sp+20h] [bp-214h] BYREF
  __int16 v7; // [sp+26h] [bp-20Eh]
  int chip_reg_x7; // [sp+228h] [bp-Ch]
  void *s; // [sp+22Ch] [bp-8h]

  s = 0;
  chip_reg_x7 = 0;
  v6[0] = 85;
  v6[1] = -86;
  v6[2] = 20;
  v6[3] = a2;
  v6[4] = -1;
  v6[5] = 0;
  v7 = 0;
  v7 = BM_CRC16((char *)v6, 8);
  s = malloc(0x20Cu);
  memset(s, 0, 0x20Cu);
  chip_reg_x7 = sync_get_chip_reg_x7(a1, 1, v6, (int)s, a3, 0x9C40u);
  if ( s )
  {
    free(s);
    s = 0;
  }
  return chip_reg_x7;
}

//----- (00093368) --------------------------------------------------------
int __fastcall chip_setting_read_one_sensor_temp_x7(int a1, _DWORD *a2, _DWORD *a3, char a4)
{
  int v9; // [sp+24h] [bp-220h] BYREF
  unsigned __int8 v10[6]; // [sp+28h] [bp-21Ch] BYREF
  __int16 v11; // [sp+2Eh] [bp-216h]
  int chip_temperature_reg_x7; // [sp+230h] [bp-14h]
  int v13; // [sp+234h] [bp-10h]
  void *s; // [sp+238h] [bp-Ch]
  int i; // [sp+23Ch] [bp-8h]

  s = 0;
  v13 = 6;
  chip_temperature_reg_x7 = 0;
  v10[0] = 85;
  v10[1] = -86;
  v10[2] = 9;
  v10[3] = -1;
  v10[4] = -1;
  v10[5] = 0;
  v11 = 0;
  v11 = BM_CRC16((char *)v10, 8);
  s = malloc(524 * v13);
  memset(s, 0, 524 * v13);
  *a3 = 0;
  *a2 = -64;
  chip_temperature_reg_x7 = sync_get_chip_temperature_reg_x7(a1, v13, v10, (int)s, &v9, 0x3E8u);
  for ( i = 0; i < v9; ++i )
  {
    if ( *((_BYTE *)s + 524 * i + 2) == 9 && a4 == *((_BYTE *)s + 524 * i + 3) )
    {
      *a2 = *((_DWORD *)s + 131 * i + 3);
      *a2 /= 1000;
      *a3 = 1;
      break;
    }
  }
  if ( s )
  {
    free(s);
    s = 0;
  }
  return chip_temperature_reg_x7;
}

//----- (00093584) --------------------------------------------------------
int __fastcall chip_setting_read_all_sensor_temp(int a1, void *a2, int a3, _DWORD *a4)
{
  int v9; // [sp+20h] [bp-21Ch] BYREF
  unsigned __int8 v10[6]; // [sp+24h] [bp-218h] BYREF
  __int16 v11; // [sp+2Ah] [bp-212h]
  void *s; // [sp+22Ch] [bp-10h]
  int chip_temperature_reg_x7; // [sp+230h] [bp-Ch]
  int i; // [sp+234h] [bp-8h]

  chip_temperature_reg_x7 = 0;
  v10[0] = 85;
  v10[1] = -86;
  v10[2] = 9;
  v10[3] = -1;
  v10[4] = -1;
  v10[5] = 0;
  v11 = 0;
  v11 = BM_CRC16((char *)v10, 8);
  s = malloc(524 * a3);
  memset(s, 0, 524 * a3);
  memset(a2, 0, 12 * a3);
  *a4 = 0;
  chip_temperature_reg_x7 = sync_get_chip_temperature_reg_x7(a1, a3, v10, (int)s, &v9, 0x3E8u);
  for ( i = 0; i < v9; ++i )
  {
    if ( *((_BYTE *)s + 524 * i + 2) == 9 )
    {
      *((_DWORD *)a2 + 3 * *a4) = *((unsigned __int8 *)s + 524 * i + 3);
      *((_DWORD *)a2 + 3 * *a4 + 1) = *((_DWORD *)s + 131 * i + 3);
      *((_DWORD *)a2 + 3 * (*a4)++ + 2) = 1;
    }
  }
  free(s);
  return chip_temperature_reg_x7;
}

//----- (000937BC) --------------------------------------------------------
int __fastcall chip_setting_get_all_rxu_status(int a1, void *a2, int a3, _DWORD *a4)
{
  char v9[72]; // [sp+3Ch] [bp-1248h] BYREF
  int v10; // [sp+103Ch] [bp-248h] BYREF
  unsigned __int8 v11[6]; // [sp+1040h] [bp-244h] BYREF
  __int16 v12; // [sp+1046h] [bp-23Eh]
  _DWORD v13[7]; // [sp+1248h] [bp-3Ch] BYREF
  int v14; // [sp+1264h] [bp-20h]
  void *s; // [sp+126Ch] [bp-18h]
  int i; // [sp+1270h] [bp-14h]
  int chip_rxu_status_reg_x7; // [sp+1274h] [bp-10h]

  chip_rxu_status_reg_x7 = 0;
  v11[0] = 85;
  v11[1] = -86;
  v11[2] = 19;
  v11[3] = -1;
  v11[4] = -1;
  v11[5] = 0;
  v12 = 0;
  v12 = BM_CRC16((char *)v11, 8);
  s = malloc(524 * a3);
  memset(s, 0, 524 * a3);
  memset(a2, 0, 12 * a3);
  *a4 = 0;
  chip_rxu_status_reg_x7 = sync_get_chip_rxu_status_reg_x7(a1, a3, v11, (int)s, &v10, 0x249F0u);
  for ( i = 0; i < v10; ++i )
  {
    if ( *((_BYTE *)s + 524 * i + 2) == 19 )
    {
      *((_DWORD *)a2 + 3 * *a4) = *((unsigned __int8 *)s + 524 * i + 3);
      *((_DWORD *)a2 + 3 * *a4 + 1) = *((_DWORD *)s + 131 * i + 3);
      *((_DWORD *)a2 + 3 * (*a4)++ + 2) = 1;
    }
  }
  if ( *a4 != *(_DWORD *)(a1 + 336) )
  {
    V_LOCK();
    sub_8F850((int)v13, *(int *)(a1 + 252));
    logfmt_raw(
      v9,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "response rxu hang status packet not enough:%d",
      *a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_x7_2044/chip_setting_x7_2044.c",
      184,
      "chip_setting_get_all_rxu_status",
      31,
      1108,
      80,
      v9);
  }
  free(s);
  return chip_rxu_status_reg_x7;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00093B8C) --------------------------------------------------------
int __fastcall chip_setting_send_update_single_packet(int a1, const void *a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v7[2]; // [sp+14h] [bp-210h] BYREF
  char v8; // [sp+16h] [bp-20Eh]
  char v9; // [sp+17h] [bp-20Dh]
  char v10; // [sp+18h] [bp-20Ch]
  unsigned __int8 v11; // [sp+19h] [bp-20Bh]
  __int16 v12; // [sp+1Ah] [bp-20Ah]
  _DWORD v13[129]; // [sp+1Ch] [bp-208h] BYREF

  v13[128] = 0;
  v7[0] = 85;
  v7[1] = -86;
  if ( a4 )
    v8 = 15;
  else
    v8 = 6;
  v9 = -1;
  v10 = -1;
  v11 = a3;
  memcpy(v13, a2, a3);
  v12 = 0;
  v12 = BM_CRC16((char *)v7, a3 + 8);
  return set_chip_reg_x7(a1, v7);
}

//----- (00093C84) --------------------------------------------------------
int __fastcall sub_93C84(char a1)
{
  int v1; // r3

  switch ( a1 )
  {
    case 1:
      v1 = 34;
      break;
    case 2:
      v1 = 39;
      break;
    case 3:
      v1 = 43;
      break;
    case 4:
      v1 = 45;
      break;
    default:
      v1 = 114;
      break;
  }
  return v1;
}
// 93CA8: control flows out of bounds to 93CAC

//----- (00093CF0) --------------------------------------------------------
__int64 __fastcall sub_93CF0(int a1, int a2, unsigned int a3)
{
  char v4; // [sp+10h] [bp-102Ch] BYREF
  unsigned int v5; // [sp+14h] [bp-1028h]
  int v6; // [sp+18h] [bp-1024h]
  int v7; // [sp+1Ch] [bp-1020h]
  char v8[24]; // [sp+24h] [bp-1018h] BYREF
  char *v9; // [sp+1024h] [bp-18h]
  unsigned int i; // [sp+1028h] [bp-14h]
  int v11; // [sp+102Ch] [bp-10h]

  v7 = a1;
  v6 = a2;
  v5 = a3;
  v11 = 2 * a3;
  v9 = &v4;
  for ( i = 0; i < v5; ++i )
    sprintf(&v9[2 * i], "%02x", *(unsigned __int8 *)(v6 + i));
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "%s[%d]=%s", v7, v5, v9);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
           174,
           "hex_dump",
           8,
           78,
           20,
           v8);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00093E7C) --------------------------------------------------------
int __fastcall sub_93E7C(int a1, int a2)
{
  unsigned int i; // [sp+8h] [bp-Ch]
  unsigned __int16 v4; // [sp+Eh] [bp-6h]

  v4 = 0;
  for ( i = 2; i < a2 - 2; ++i )
    v4 += *(unsigned __int8 *)(a1 + i);
  *(_BYTE *)(a1 + a2 - 2) = HIBYTE(v4);
  *(_BYTE *)(a1 + a2 - 1) = v4;
  return v4;
}

//----- (00093F38) --------------------------------------------------------
bool __fastcall sub_93F38(int a1, int a2)
{
  unsigned int i; // [sp+8h] [bp-Ch]
  __int16 v4; // [sp+Eh] [bp-6h]

  v4 = 0;
  for ( i = 0; i < a2 - 2; ++i )
    v4 += *(unsigned __int8 *)(a1 + i);
  return ((v4 == 0) | *(unsigned __int8 *)(a1 + a2 - 1)) != 0;
}

//----- (00093FF4) --------------------------------------------------------
int __fastcall sub_93FF4(
        int a1,
        unsigned __int8 a2,
        const void *a3,
        unsigned int a4,
        unsigned __int8 a5,
        void *dest,
        size_t n)
{
  int v7; // r0
  int v8; // r0
  size_t v10; // [sp+10h] [bp-102Ch]
  char v14[24]; // [sp+24h] [bp-1018h] BYREF
  _BYTE s[17]; // [sp+1024h] [bp-18h] BYREF
  unsigned __int8 v16; // [sp+1035h] [bp-7h]
  unsigned __int8 v17; // [sp+1036h] [bp-6h]
  unsigned __int8 v18; // [sp+1037h] [bp-5h]

  if ( a4 > 7 )
  {
    a4 = 8;
  }
  else if ( !a4 )
  {
    a4 = 1;
  }
  v10 = a4;
  if ( !g_bitmain_pic_state[2 * a1 + 1] )
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "%s this chain not inited", "pic_1704_cmd");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
      174,
      "pic_1704_cmd",
      12,
      108,
      100,
      v14);
    v18 = 1;
  }
  s[0] = 85;
  s[1] = -86;
  s[2] = v10 + 4;
  s[3] = a2;
  memcpy(&s[4], a3, v10);
  v17 = v10 + 6;
  sub_93E7C((int)s, (unsigned __int8)(v10 + 6));
  sub_93CF0((int)"pic tx", (int)s, v17);
  pthread_mutex_lock(&i2c_mutex_all);
  v7 = iic_write(g_bitmain_pic_state[2 * a1], (int)s, v17);
  if ( v7 == v17 )
  {
    usleep(0x2710u);
    memset(s, 0, 0x10u);
    v16 = n + 5;
    v8 = iic_read(g_bitmain_pic_state[2 * a1], s, (unsigned __int8)(n + 5));
    if ( v8 == v16 )
    {
      sub_93CF0((int)"pic rx", (int)s, v16);
      if ( v16 == s[0] && a2 == s[1] && a5 == s[2] && sub_93F38((int)s, v16) )
      {
        if ( n && dest )
          memcpy(dest, &s[3], n);
        v18 = 0;
      }
      else
      {
        V_LOCK();
        logfmt_raw(v14, 0x1000u, 0, "%s recv data format err", "pic_1704_cmd");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
          174,
          "pic_1704_cmd",
          12,
          140,
          100,
          v14);
        v18 = 3;
      }
    }
    else
    {
      v18 = 2;
      V_LOCK();
      logfmt_raw(v14, 0x1000u, 0, "%s read iic err", "pic_1704_cmd");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
        174,
        "pic_1704_cmd",
        12,
        134,
        100,
        v14);
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "%s write iic err", "pic_1704_cmd");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
      174,
      "pic_1704_cmd",
      12,
      124,
      100,
      v14);
    v18 = 1;
  }
  pthread_mutex_unlock(&i2c_mutex_all);
  return v18;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F918: using guessed type pthread_mutex_t i2c_mutex_all;
// 1608F0: using guessed type int g_zc;
// 1617FC: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (000944F0) --------------------------------------------------------
bool __fastcall sub_944F0(int a1, char a2, char a3, const void *a4, size_t n)
{
  _BYTE v7[2]; // [sp+20h] [bp-14h] BYREF
  __int16 v8; // [sp+22h] [bp-12h] BYREF

  v7[0] = a2;
  v7[1] = a3;
  memcpy(&v8, a4, n);
  return sub_93FF4(a1, 0x3Bu, v7, n + 2, 0, 0, 0) == 0;
}

//----- (00094594) --------------------------------------------------------
bool __fastcall sub_94594(int a1, char a2, char a3, void *dest, size_t n)
{
  _BYTE v6[4]; // [sp+24h] [bp-8h] BYREF

  v6[0] = a2;
  v6[1] = a3;
  v6[2] = n;
  return sub_93FF4(a1, 0x3Cu, v6, 3u, 0, dest, n) == 0;
}

//----- (00094624) --------------------------------------------------------
bool __fastcall sub_94624(int a1, char a2, unsigned __int8 a3)
{
  char v3; // r0
  char v5; // r0
  _BYTE v10[8]; // [sp+10h] [bp-Ch] BYREF

  v10[0] = a3;
  v3 = sub_93C84(a2);
  if ( !sub_944F0(a1, v3, 0, v10, 1u) )
    return 0;
  v5 = sub_93C84(a2);
  return sub_94594(a1, v5, 0, v10, 1u) && a3 == v10[0];
}

//----- (0009470C) --------------------------------------------------------
int __fastcall get_chain_mps_voltage1(int a1, char a2, unsigned __int16 *a3)
{
  char v3; // r0
  char v8[20]; // [sp+20h] [bp-1014h] BYREF
  _BYTE v9[8]; // [sp+1020h] [bp-14h] BYREF
  unsigned __int16 v10; // [sp+1028h] [bp-Ch]
  unsigned __int16 v11; // [sp+102Ah] [bp-Ah]
  int v12; // [sp+102Ch] [bp-8h]

  v12 = 0;
  *a3 = -1;
  if ( !sub_94624(a1, a2, 0) )
  {
    ++v12;
  }
  else
  {
    v3 = sub_93C84(a2);
    if ( !sub_94594(a1, v3, 33, v9, 2u) )
    {
      ++v12;
    }
    else
    {
      v11 = v9[0] | (v9[1] << 8);
      v10 = 10 * (v11 & 0x1FF) + 490;
      *a3 = v10;
      printf("chain-%d raw data: %u get_chain_mps_voltage1: %u\n", a1, v11, v10);
    }
  }
  if ( v12 > 0 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "get_chain_mps_voltage2 error, fd %d", a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
      174,
      "get_chain_mps_voltage1",
      22,
      219,
      100,
      v8);
  }
  return v12;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009492C) --------------------------------------------------------
int __fastcall get_chain_mps_voltage2(int a1, char a2, unsigned __int16 *a3)
{
  char v3; // r0
  char v8[20]; // [sp+20h] [bp-1014h] BYREF
  _BYTE v9[8]; // [sp+1020h] [bp-14h] BYREF
  unsigned __int16 v10; // [sp+1028h] [bp-Ch]
  unsigned __int16 v11; // [sp+102Ah] [bp-Ah]
  int v12; // [sp+102Ch] [bp-8h]

  v12 = 0;
  *a3 = -1;
  if ( !sub_94624(a1, a2, 2u) )
  {
    ++v12;
  }
  else
  {
    v3 = sub_93C84(a2);
    if ( !sub_94594(a1, v3, 13, v9, 2u) )
    {
      ++v12;
    }
    else
    {
      v11 = v9[0] | (v9[1] << 8);
      v10 = 10 * ((v11 >> 5) & 0x1FF) + 490;
      *a3 = v10;
      printf("chain-%d graw data: %u get_chain_mps_voltage2: %u\n", a1, v11, v10);
    }
  }
  if ( v12 > 0 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "get_chain_mps_voltage2 error, fd %d", a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
      174,
      "get_chain_mps_voltage2",
      22,
      250,
      100,
      v8);
  }
  return v12;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00094B54) --------------------------------------------------------
int __fastcall set_chain_mps_voltage(int a1, char a2, unsigned __int16 a3, unsigned __int16 a4)
{
  __int16 v4; // r3
  __int16 v5; // r3
  char v7; // r0
  int v8; // r3
  char v9; // r0
  unsigned __int16 v12; // [sp+18h] [bp-1024h]
  char v15[24]; // [sp+24h] [bp-1018h] BYREF
  unsigned __int16 v16; // [sp+1024h] [bp-18h] BYREF
  unsigned __int16 v17; // [sp+1026h] [bp-16h] BYREF
  _BYTE v18[10]; // [sp+1028h] [bp-14h] BYREF
  __int16 v19; // [sp+1032h] [bp-Ah]
  int v20; // [sp+1034h] [bp-8h]

  v12 = a3;
  v20 = 0;
  if ( a3 > 0xA5Au || a3 <= 0x92Du )
  {
    if ( a3 > 0xA59u )
    {
      v4 = 2650;
    }
    else
    {
      v4 = a3;
      if ( a3 < 0x92Eu )
        v4 = 2350;
    }
    v12 = v4;
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, "the mps_voltage_1 value-%d is out of the allowed range(%d-%d)", v12, 2350, 2650);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
      174,
      "set_chain_mps_voltage",
      21,
      264,
      40,
      v15);
  }
  if ( a4 > 0xA5Au || a4 <= 0x92Du )
  {
    if ( a4 > 0xA59u )
    {
      v5 = 2650;
    }
    else
    {
      v5 = a4;
      if ( a4 < 0x92Eu )
        v5 = 2350;
    }
    a4 = v5;
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, "the mps_voltage_2 value-%d is out of the allowed range(%d-%d)", a4, 2350, 2650);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
      174,
      "set_chain_mps_voltage",
      21,
      270,
      40,
      v15);
  }
  get_chain_mps_voltage1(a1, a2, &v17);
  if ( v12 == v17 )
  {
    V_LOCK();
    logfmt_raw(v15, 0x1000u, 0, "voltage1 is already set to %d", v12);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
      174,
      "set_chain_mps_voltage",
      21,
      276,
      20,
      v15);
    return 0;
  }
  else
  {
    get_chain_mps_voltage2(a1, a2, &v16);
    if ( a4 == v16 )
    {
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, "voltage2 is already set to %d", a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
        174,
        "set_chain_mps_voltage",
        21,
        283,
        20,
        v15);
      return 0;
    }
    else
    {
      if ( !sub_94624(a1, a2, 0) )
      {
        ++v20;
      }
      else
      {
        v19 = ((__int16)(v12 - 490) / 10) & 0x1FF;
        v18[0] = (__int16)(v12 - 490) / 10;
        v18[1] = HIBYTE(v19);
        v7 = sub_93C84(a2);
        if ( !sub_944F0(a1, v7, 33, v18, 2u) )
        {
          ++v20;
        }
        else if ( !sub_94624(a1, a2, 2u) )
        {
          ++v20;
        }
        else
        {
          v8 = a4 - 490;
          v19 = (32 * (v8 / 10)) & 0x3FE0;
          v18[0] = 32 * (v8 / 10);
          v9 = sub_93C84(a2);
          if ( !sub_944F0(a1, v9, 13, v18, 2u) )
          {
            ++v20;
          }
          else
          {
            get_chain_mps_voltage1(a1, a2, &v17);
            if ( v12 == v17 )
            {
              get_chain_mps_voltage2(a1, a2, &v16);
              if ( a4 != v16 )
              {
                V_LOCK();
                logfmt_raw(v15, 0x1000u, 0, "voltage2 set failed!", a4);
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
                  174,
                  "set_chain_mps_voltage",
                  21,
                  329,
                  100,
                  v15);
                ++v20;
              }
            }
            else
            {
              V_LOCK();
              logfmt_raw(v15, 0x1000u, 0, "voltage1 set failed!", v12);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
                174,
                "set_chain_mps_voltage",
                21,
                321,
                100,
                v15);
              ++v20;
            }
          }
        }
      }
      if ( v20 > 0 )
      {
        V_LOCK();
        logfmt_raw(v15, 0x1000u, 0, "set_chain_mps_voltage error, fd %d", a1);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/drv_pic/mps2973.c",
          174,
          "set_chain_mps_voltage",
          21,
          336,
          100,
          v15);
      }
      return v20;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000953B0) --------------------------------------------------------
char __fastcall set_pic_device_high(char result)
{
  byte_15F930 = result;
  return result;
}
// 15F930: using guessed type char byte_15F930;

//----- (000953E4) --------------------------------------------------------
_BYTE *__fastcall sub_953E4(_BYTE *result, char a2, int a3, unsigned __int8 a4)
{
  unsigned __int8 i; // [sp+15h] [bp-7h]
  __int16 v5; // [sp+16h] [bp-6h]

  *result = 85;
  result[1] = -86;
  result[2] = a4 + 4;
  result[3] = a2;
  v5 = (unsigned __int8)result[2] + (unsigned __int8)result[3];
  if ( a3 )
  {
    for ( i = 0; i < (unsigned int)a4; ++i )
    {
      result[i + 4] = *(_BYTE *)(a3 + i);
      v5 += *(unsigned __int8 *)(a3 + i);
    }
    result[i + 4] = HIBYTE(v5);
    result[i + 5] = v5;
  }
  else
  {
    result[4] = HIBYTE(v5);
    result[5] = v5;
  }
  return result;
}

//----- (00095588) --------------------------------------------------------
int __fastcall sub_95588(unsigned __int8 a1, int a2, unsigned __int8 a3, void *a4, unsigned __int8 a5)
{
  pthread_mutex_lock(&i2c_mutex_all);
  iic_write(g_bitmain_pic_state[2 * a1], a2, a3);
  usleep(0x2710u);
  iic_read(g_bitmain_pic_state[2 * a1], a4, a5);
  return pthread_mutex_unlock(&i2c_mutex_all);
}
// 15F918: using guessed type pthread_mutex_t i2c_mutex_all;
// 1617FC: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (00095620) --------------------------------------------------------
int __fastcall sub_95620(int a1, int a2, _BYTE *a3, unsigned __int8 *a4)
{
  unsigned int v5; // r3
  char v10[8]; // [sp+24h] [bp-1808h] BYREF
  char v11[8]; // [sp+824h] [bp-1008h] BYREF
  unsigned __int8 v12; // [sp+1827h] [bp-5h]

  v12 = 0;
  sub_953E4(a3, a1, a2, BYTE1(a1));
  do
  {
    sub_95588(HIBYTE(a1), (int)a3, BYTE1(a1) + 6, a4, BYTE2(a1));
    if ( BYTE2(a1) == 2 )
    {
      if ( *a4 == (unsigned __int8)a1 && a4[1] == 1 )
      {
        snprintf(v10, 0x800u, "PICCMD %d passed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
          175,
          "pic_process_cmd",
          15,
          99,
          20,
          v11);
        return 1;
      }
      snprintf(v10, 0x800u, "PICCMD %d failed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
        175,
        "pic_process_cmd",
        15,
        104,
        20,
        v11);
      sleep(1u);
    }
    else if ( BYTE2(a1) <= 2u )
    {
      snprintf(v10, 0x800u, "ret_len = %d should never happen!!", BYTE2(a1));
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
        175,
        "pic_process_cmd",
        15,
        122,
        20,
        v11);
    }
    else
    {
      if ( __PAIR64__(a4[1], *a4) == __PAIR64__((unsigned __int8)a1, BYTE2(a1)) )
      {
        snprintf(v10, 0x800u, "PICCMD %d passed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
          175,
          "pic_process_cmd",
          15,
          112,
          20,
          v11);
        return 1;
      }
      snprintf(v10, 0x800u, "PICCMD %d failed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
        175,
        "pic_process_cmd",
        15,
        117,
        20,
        v11);
      sleep(1u);
    }
    v5 = v12++;
  }
  while ( v5 <= 2 );
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00095B64) --------------------------------------------------------
int __fastcall pic1704_get_sw_version(char a1, _BYTE *a2)
{
  int v4; // [sp+Ch] [bp-20h] BYREF
  char v5; // [sp+10h] [bp-1Ch]
  int v6; // [sp+14h] [bp-18h] BYREF
  __int16 v7; // [sp+18h] [bp-14h]
  int v8; // [sp+1Ch] [bp-10h]
  int v9; // [sp+20h] [bp-Ch]
  unsigned __int8 v10; // [sp+27h] [bp-5h]

  v6 = 0;
  v7 = 0;
  v4 = 255;
  v5 = 0;
  *a2 = -1;
  LOWORD(v8) = 23;
  v9 = 0;
  HIBYTE(v8) = a1;
  BYTE2(v8) = 5;
  v10 = sub_95620(v8, 0, &v6, (unsigned __int8 *)&v4);
  if ( v10 )
    *a2 = BYTE2(v4);
  return v10;
}

//----- (00095C1C) --------------------------------------------------------
int __fastcall pic1704_jump_to_app(char a1)
{
  __int16 v2; // [sp+8h] [bp-1Ch] BYREF
  int v3; // [sp+Ch] [bp-18h] BYREF
  __int16 v4; // [sp+10h] [bp-14h]
  int v5; // [sp+14h] [bp-10h]
  int v6; // [sp+18h] [bp-Ch]

  v3 = 0;
  v4 = 0;
  v2 = 255;
  LOWORD(v5) = 6;
  v6 = 0;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  return (unsigned __int8)sub_95620(v5, 0, &v3, (unsigned __int8 *)&v2);
}

//----- (00095CA4) --------------------------------------------------------
int __fastcall pic1704_reset(char a1)
{
  __int16 v2; // [sp+8h] [bp-1Ch] BYREF
  int v3; // [sp+Ch] [bp-18h] BYREF
  __int16 v4; // [sp+10h] [bp-14h]
  int v5; // [sp+14h] [bp-10h]
  int v6; // [sp+18h] [bp-Ch]

  v3 = 0;
  v4 = 0;
  v2 = 255;
  LOWORD(v5) = 7;
  v6 = 0;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  return (unsigned __int8)sub_95620(v5, 0, &v3, (unsigned __int8 *)&v2);
}

//----- (00095D2C) --------------------------------------------------------
int __fastcall pic1704_enable_disable_dc_dc(char a1, char a2)
{
  _BYTE v3[2]; // [sp+6h] [bp-1Eh] BYREF
  __int16 v4; // [sp+8h] [bp-1Ch] BYREF
  _DWORD v5[2]; // [sp+Ch] [bp-18h] BYREF
  int v6; // [sp+14h] [bp-10h]
  _BYTE *v7; // [sp+18h] [bp-Ch]

  v3[1] = a1;
  v3[0] = a2;
  v5[0] = 0;
  *(_DWORD *)((char *)v5 + 3) = 0;
  v4 = 255;
  LOWORD(v6) = 277;
  v7 = v3;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 2;
  return (unsigned __int8)sub_95620(v6, (int)v3, v5, (unsigned __int8 *)&v4);
}

//----- (00095DC0) --------------------------------------------------------
int __fastcall pic1704_erase_program(char a1)
{
  __int16 v2; // [sp+8h] [bp-1Ch] BYREF
  int v3; // [sp+Ch] [bp-18h] BYREF
  __int16 v4; // [sp+10h] [bp-14h]
  int v5; // [sp+14h] [bp-10h]
  int v6; // [sp+18h] [bp-Ch]

  v3 = 0;
  v4 = 0;
  v2 = 255;
  LOWORD(v5) = 9;
  v6 = 0;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  return (unsigned __int8)sub_95620(v5, 0, &v3, (unsigned __int8 *)&v2);
}

//----- (00095E48) --------------------------------------------------------
int __fastcall pic1704_heart_beat(char a1)
{
  int v2; // [sp+Ch] [bp-20h] BYREF
  __int16 v3; // [sp+10h] [bp-1Ch]
  int v4; // [sp+14h] [bp-18h] BYREF
  __int16 v5; // [sp+18h] [bp-14h]
  int v6; // [sp+1Ch] [bp-10h]
  int v7; // [sp+20h] [bp-Ch]

  v4 = 0;
  v5 = 0;
  v2 = 255;
  v3 = 0;
  LOWORD(v6) = 22;
  v7 = 0;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 6;
  return (unsigned __int8)sub_95620(v6, 0, &v4, (unsigned __int8 *)&v2);
}

//----- (00095ED8) --------------------------------------------------------
int __fastcall sub_95ED8(char a1, int a2)
{
  __int16 v3; // [sp+8h] [bp-2Ch] BYREF
  _QWORD v4[3]; // [sp+Ch] [bp-28h] BYREF
  int v5; // [sp+24h] [bp-10h]
  int v6; // [sp+28h] [bp-Ch]

  memset(v4, 0, 22);
  v3 = 255;
  LOWORD(v5) = 4098;
  v6 = a2;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  return (unsigned __int8)sub_95620(v5, a2, v4, (unsigned __int8 *)&v3);
}

//----- (00095F68) --------------------------------------------------------
int __fastcall pic1704_update_app_program(unsigned __int8 a1)
{
  __int64 *v2; // r3
  __int64 v3; // r0
  __int64 v4; // r2
  char v7[56]; // [sp+1Ch] [bp-1838h] BYREF
  char v8[56]; // [sp+81Ch] [bp-1038h] BYREF
  __int64 v9; // [sp+181Ch] [bp-38h] BYREF
  __int64 v10; // [sp+1824h] [bp-30h]
  char nptr[8]; // [sp+182Ch] [bp-28h] BYREF
  unsigned int v12; // [sp+1834h] [bp-20h]
  unsigned int v13; // [sp+1838h] [bp-1Ch]
  unsigned int v14; // [sp+183Ch] [bp-18h]
  void *s; // [sp+1840h] [bp-14h]
  FILE *stream; // [sp+1844h] [bp-10h]
  unsigned int i; // [sp+1848h] [bp-Ch]
  int v18; // [sp+184Ch] [bp-8h]

  i = 0;
  *(_DWORD *)nptr = 0;
  *(_DWORD *)&nptr[3] = 0;
  v9 = 0;
  v10 = 0;
  v14 = 0;
  v13 = 3520;
  v12 = 880;
  v18 = 0;
  stream = fopen("/etc/config/dsPIC33EP16GS202_app.txt", "r");
  if ( stream )
  {
    s = malloc(0x3700u);
    if ( s )
    {
      fseek(stream, 0, 0);
      memset(s, 0, 0x3700u);
      for ( i = 0; i < v13; ++i )
      {
        fgets(nptr, 7, stream);
        v14 = strtoul(nptr, 0, 16);
        *((_BYTE *)s + 4 * i) = HIBYTE(v14);
        *((_BYTE *)s + 4 * i + 1) = BYTE2(v14);
        *((_BYTE *)s + 4 * i + 2) = BYTE1(v14);
        *((_BYTE *)s + 4 * i + 3) = v14;
      }
      fclose(stream);
      v18 = pic1704_reset(a1);
      if ( v18 )
      {
        v18 = pic1704_erase_program(a1);
        if ( v18 )
        {
          for ( i = 0; i < v12; ++i )
          {
            v2 = (__int64 *)((char *)s + 16 * i);
            v3 = *v2;
            v4 = v2[1];
            v9 = v3;
            v10 = v4;
            v18 = sub_95ED8(a1, (int)&v9);
            if ( !v18 )
            {
              snprintf(v7, 0x800u, "%s send data to pic error chain[%d]!", "pic1704_update_app_program", a1);
              V_LOCK();
              logfmt_raw(v8, 0x1000u, 0, v7);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
                175,
                "pic1704_update_app_program",
                26,
                338,
                20,
                v8);
              free(s);
              return 0;
            }
          }
          v18 = pic1704_reset(a1);
          if ( v18 )
          {
            free(s);
            return 1;
          }
          else
          {
            snprintf(v7, 0x800u, "%s reset error after program chain[%d]!", "pic1704_update_app_program", a1);
            V_LOCK();
            logfmt_raw(v8, 0x1000u, 0, v7);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
              175,
              "pic1704_update_app_program",
              26,
              348,
              20,
              v8);
            V_LOCK();
            logfmt_raw(v8, 0x1000u, 0, "Sweep error string = J%d:5.", a1);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
              175,
              "pic1704_update_app_program",
              26,
              349,
              100,
              v8);
            free(s);
            return 0;
          }
        }
        else
        {
          snprintf(v7, 0x800u, "%s erase pic error chain[%d]!", "pic1704_update_app_program", a1);
          V_LOCK();
          logfmt_raw(v8, 0x1000u, 0, v7);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
            175,
            "pic1704_update_app_program",
            26,
            318,
            20,
            v8);
          free(s);
          return 0;
        }
      }
      else
      {
        snprintf(v7, 0x800u, "%s reset pic error chain[%d]!", "pic1704_update_app_program", a1);
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
          175,
          "pic1704_update_app_program",
          26,
          308,
          20,
          v8);
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, "Sweep error string = J%d:5.", a1);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
          175,
          "pic1704_update_app_program",
          26,
          309,
          100,
          v8);
        free(s);
        return 0;
      }
    }
    else
    {
      snprintf(v7, 0x800u, "%s malloc failed chain[%d]!", "pic1704_update_app_program", a1);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
        175,
        "pic1704_update_app_program",
        26,
        282,
        20,
        v8);
      set_miner_6060info_malloc_failed_err(1);
      return -1;
    }
  }
  else
  {
    snprintf(v7, 0x800u, "%s open DSPIC33EP16GS202_PIC_PROGRAM failed chain[%d]!", "pic1704_update_app_program", a1);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
      175,
      "pic1704_update_app_program",
      26,
      275,
      20,
      v8);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00096778) --------------------------------------------------------
int __fastcall pic1704_set_voltage(char a1, unsigned __int8 a2)
{
  __int16 v3; // [sp+8h] [bp-24h] BYREF
  char v4; // [sp+Ah] [bp-22h]
  __int16 v5; // [sp+Ch] [bp-20h] BYREF
  char v6; // [sp+10h] [bp-1Ch] BYREF
  __int64 v7; // [sp+11h] [bp-1Bh]
  int v8; // [sp+1Ch] [bp-10h]
  __int16 *v9; // [sp+20h] [bp-Ch]

  v6 = 0;
  v7 = 0;
  v5 = 255;
  v4 = 0;
  v3 = a2;
  LOWORD(v8) = 784;
  v9 = &v3;
  HIBYTE(v8) = a1;
  BYTE2(v8) = 2;
  return (unsigned __int8)sub_95620(v8, (int)&v3, &v6, (unsigned __int8 *)&v5);
}

//----- (00096828) --------------------------------------------------------
bool __fastcall sub_96828(unsigned __int8 *a1)
{
  unsigned __int8 *v2; // r3
  unsigned __int8 *v4; // [sp+14h] [bp-1818h]
  char v5[20]; // [sp+18h] [bp-1814h] BYREF
  char v6[20]; // [sp+818h] [bp-1014h] BYREF
  int v7; // [sp+1818h] [bp-14h]
  unsigned __int16 v8; // [sp+181Eh] [bp-Eh]
  unsigned int i; // [sp+1820h] [bp-Ch]
  unsigned __int16 v10; // [sp+1826h] [bp-6h]

  v4 = a1;
  v10 = 0;
  v8 = 0;
  v7 = 0;
  i = 0;
  if ( !a1 || *a1 <= 3u )
    return 0;
  v7 = *a1;
  for ( i = 0; v7 - 2 > i; ++i )
  {
    v2 = v4++;
    v10 += *v2;
  }
  v8 = *v4 << 8;
  v8 |= v4[1];
  snprintf(v5, 0x800u, "sum1,sum2 = %d,%d", v10, v8);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, v5);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
    175,
    "check_pic_crc",
    13,
    400,
    20,
    v6);
  return v10 == v8;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00096A24) --------------------------------------------------------
__int64 __fastcall sub_96A24(unsigned int a1)
{
  float v1; // s0
  char v3[20]; // [sp+18h] [bp-1814h] BYREF
  char v4[20]; // [sp+818h] [bp-1014h] BYREF
  double v5; // [sp+1818h] [bp-14h]
  double v6; // [sp+1820h] [bp-Ch]

  v6 = (double)a1 * 3.3 / (float)(v1 * 1024.0);
  snprintf(v3, 0x800u, "v_an2 = %f", v6);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
    175,
    "decode_an_voltage_buf",
    21,
    410,
    20,
    v4);
  v5 = v6 * 7.5999999;
  snprintf(v3, 0x800u, "v_10 = %f", v6 * 7.5999999);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
           175,
           "decode_an_voltage_buf",
           21,
           413,
           20,
           v4);
}
// 96A94: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00096C1C) --------------------------------------------------------
int __fastcall pic1704_get_an_voltage1(char a1)
{
  int result; // r0
  unsigned int v2; // [sp+8h] [bp-14h] BYREF
  char v3; // [sp+Fh] [bp-Dh]
  double v4; // [sp+10h] [bp-Ch]

  v2 = 0;
  v4 = 0.0;
  result = pic1704_get_single_voltage(a1, (int *)&v2);
  v3 = result;
  if ( (_BYTE)result )
    return sub_96A24(v2);
  return result;
}

//----- (00096C94) --------------------------------------------------------
int __fastcall pic1704_get_an_voltage2(char a1, char a2)
{
  float v2; // s0
  float v3; // s1
  int result; // r0
  int v5; // s15
  char v7[36]; // [sp+28h] [bp-1824h] BYREF
  char v8[36]; // [sp+828h] [bp-1024h] BYREF
  unsigned int v9; // [sp+1828h] [bp-24h] BYREF
  unsigned int v10; // [sp+182Ch] [bp-20h] BYREF
  int v11[2]; // [sp+1830h] [bp-1Ch] BYREF
  double v12; // [sp+1838h] [bp-14h]
  char v13; // [sp+1847h] [bp-5h]

  v11[0] = 0;
  v10 = 0;
  v9 = 0;
  result = pic1704_get_all_voltage(a1, v11, (int *)&v10, (int *)&v9);
  v13 = result;
  if ( (_BYTE)result )
  {
    strcpy(v7, "Received an voltage response.");
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
      175,
      "pic1704_get_an_voltage2",
      23,
      445,
      20,
      v8);
    snprintf(
      v7,
      0x800u,
      "an0 = %f, an2 %f, an6 %f.",
      (double)(unsigned int)v11[0] * 3.3 / 1024.0,
      (double)v10 * 3.3 / 1024.0,
      (double)v9 * 3.3 / 1024.0);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
      175,
      "pic1704_get_an_voltage2",
      23,
      446,
      20,
      v8);
    if ( a2 )
    {
      v12 = (double)v9 * 3.3 / 1024.0;
      if ( v12 >= v2 && v12 <= v3 )
      {
        *(float *)&v5 = v12 / 2.5;
        v11[1] = v5;
        return sub_96A24(v10);
      }
      else
      {
        strcpy(v7, "Ref an vol too high or too low.");
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, v7);
        V_UNLOCK();
        return zlog(
                 g_zc,
                 "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/buil"
                 "d/godminer-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
                 175,
                 "pic1704_get_an_voltage2",
                 23,
                 452,
                 20,
                 v8);
      }
    }
    else
    {
      return sub_96A24(v10);
    }
  }
  return result;
}
// 96F1C: variable 'v2' is possibly undefined
// 96F44: variable 'v3' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00097068) --------------------------------------------------------
int __fastcall pic1704_get_single_voltage(char a1, int *a2)
{
  char v5[32]; // [sp+1Ch] [bp-1820h] BYREF
  char v6[32]; // [sp+81Ch] [bp-1020h] BYREF
  _BYTE v7[7]; // [sp+181Ch] [bp-20h] BYREF
  int v8; // [sp+1824h] [bp-18h] BYREF
  __int16 v9; // [sp+1828h] [bp-14h]
  int v10; // [sp+182Ch] [bp-10h]
  int v11; // [sp+1830h] [bp-Ch]

  v8 = 0;
  v9 = 0;
  *(_DWORD *)v7 = 255;
  *(_DWORD *)&v7[3] = 0;
  LOWORD(v10) = 58;
  v11 = 0;
  HIBYTE(v10) = a1;
  BYTE2(v10) = 7;
  if ( !(unsigned __int8)sub_95620(v10, 0, &v8, v7) )
    return 0;
  if ( v7[2] == 1 && sub_96828(v7) )
  {
    *a2 = (v7[3] << 8) | v7[4];
    snprintf(v5, 0x800u, "Received one voltage response: vol = %d.", *a2);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
      175,
      "pic1704_get_single_voltage",
      26,
      487,
      20,
      v6);
    return 1;
  }
  else
  {
    snprintf(v5, 0x800u, "ret_buff error: buff0 = %d, buff1 = %d, buff2 = %d.", v7[0], v7[1], v7[2]);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
      175,
      "pic1704_get_single_voltage",
      26,
      483,
      20,
      v6);
    return 1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000972D8) --------------------------------------------------------
int __fastcall pic1704_get_all_voltage(char a1, int *a2, int *a3, int *a4)
{
  char v9[32]; // [sp+24h] [bp-1820h] BYREF
  char v10[32]; // [sp+824h] [bp-1020h] BYREF
  _BYTE v11[11]; // [sp+1824h] [bp-20h] BYREF
  int v12; // [sp+1830h] [bp-14h] BYREF
  int v13; // [sp+1834h] [bp-10h]
  int v14; // [sp+1838h] [bp-Ch]

  v12 = 0;
  *(_DWORD *)v11 = 255;
  *(_QWORD *)&v11[3] = 0;
  LOWORD(v13) = 55;
  v14 = 0;
  HIBYTE(v13) = a1;
  BYTE2(v13) = 11;
  if ( !(unsigned __int8)sub_95620(v13, 0, &v12, v11) )
    return 0;
  *a2 = (v11[3] << 8) | v11[4];
  *a3 = (v11[5] << 8) | v11[6];
  *a4 = (v11[7] << 8) | v11[8];
  snprintf(v9, 0x800u, "Received all voltage response: vol0 = %d, vol1 = %d, vol2 = %d.", *a2, *a3, *a4);
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
    175,
    "pic1704_get_all_voltage",
    23,
    514,
    20,
    v10);
  return 1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000974EC) --------------------------------------------------------
int __fastcall pic1704_voltage_clamp_ctrl(char a1, char a2)
{
  _BYTE v3[2]; // [sp+6h] [bp-1Eh] BYREF
  __int16 v4; // [sp+8h] [bp-1Ch] BYREF
  _DWORD v5[2]; // [sp+Ch] [bp-18h] BYREF
  int v6; // [sp+14h] [bp-10h]
  _BYTE *v7; // [sp+18h] [bp-Ch]

  v3[1] = a1;
  v3[0] = a2;
  v5[0] = 0;
  *(_DWORD *)((char *)v5 + 3) = 0;
  v4 = 255;
  LOWORD(v6) = 305;
  v7 = v3;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 2;
  return (unsigned __int8)sub_95620(v6, (int)v3, v5, (unsigned __int8 *)&v4);
}

//----- (00097580) --------------------------------------------------------
int __fastcall pic1704_get_PDCx(char a1, int *a2, int *a3, int *a4)
{
  unsigned __int8 v9; // [sp+14h] [bp-28h] BYREF
  __int64 v10; // [sp+15h] [bp-27h]
  int v11; // [sp+20h] [bp-1Ch] BYREF
  __int16 v12; // [sp+24h] [bp-18h]
  int v13; // [sp+28h] [bp-14h]
  int v14; // [sp+2Ch] [bp-10h]
  int v15; // [sp+30h] [bp-Ch]

  v11 = 0;
  v12 = 0;
  v10 = 0;
  v9 = -1;
  LOWORD(v13) = 43;
  v14 = 0;
  HIBYTE(v13) = a1;
  BYTE2(v13) = 9;
  if ( !(unsigned __int8)sub_95620(v13, 0, &v11, &v9) )
    return 0;
  *a2 = BYTE3(v10) | (BYTE2(v10) << 8);
  *a3 = BYTE5(v10) | (BYTE4(v10) << 8);
  v15 = BYTE6(v10) << 8;
  *a4 = HIBYTE(v10) | v15;
  return 1;
}

//----- (000976A0) --------------------------------------------------------
int __fastcall pic1704_get_raw_crab_voltage(char a1, int *a2, int *a3, int *a4, int *a5)
{
  _BYTE v10[13]; // [sp+10h] [bp-2Ch] BYREF
  int v11; // [sp+20h] [bp-1Ch] BYREF
  __int16 v12; // [sp+24h] [bp-18h]
  int v13; // [sp+28h] [bp-14h]
  int v14; // [sp+2Ch] [bp-10h]
  int v15; // [sp+30h] [bp-Ch]

  v11 = 0;
  v12 = 0;
  *(_QWORD *)v10 = 255;
  *(_QWORD *)&v10[5] = 0;
  LOWORD(v13) = 40;
  v14 = 0;
  HIBYTE(v13) = a1;
  BYTE2(v13) = 13;
  if ( !(unsigned __int8)sub_95620(v13, 0, &v11, v10) )
    return 0;
  *a2 = (v10[3] << 8) | v10[4];
  *a3 = (v10[5] << 8) | v10[6];
  *a4 = (v10[7] << 8) | v10[8];
  v15 = (v10[9] << 8) | v10[10];
  *a5 = v15;
  return 1;
}

//----- (00097804) --------------------------------------------------------
int __fastcall pic1704_write_iic(char a1, char a2)
{
  _BYTE v3[4]; // [sp+Ch] [bp-20h] BYREF
  __int16 v4; // [sp+10h] [bp-1Ch] BYREF
  __int64 v5; // [sp+14h] [bp-18h] BYREF
  int v6; // [sp+1Ch] [bp-10h]
  _BYTE *v7; // [sp+20h] [bp-Ch]

  v5 = 0;
  v4 = 255;
  v3[0] = a2;
  v3[1] = 0;
  LOWORD(v6) = 571;
  v7 = v3;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 2;
  return (unsigned __int8)sub_95620(v6, (int)v3, &v5, (unsigned __int8 *)&v4);
}

//----- (000978A4) --------------------------------------------------------
int __fastcall pic1704_read_iic(char a1, char a2, _BYTE *a3)
{
  _BYTE v6[4]; // [sp+8h] [bp-2Ch] BYREF
  _BYTE v7[7]; // [sp+Ch] [bp-28h] BYREF
  _DWORD v8[2]; // [sp+14h] [bp-20h] BYREF
  int v9; // [sp+1Ch] [bp-18h]
  _BYTE *v10; // [sp+20h] [bp-14h]
  int i; // [sp+28h] [bp-Ch]
  __int16 v13; // [sp+2Eh] [bp-6h]

  v8[0] = 0;
  *(_DWORD *)((char *)v8 + 3) = 0;
  *(_DWORD *)v7 = 255;
  *(_DWORD *)&v7[3] = 0;
  v6[0] = a2;
  v6[1] = 2;
  LOWORD(v9) = 572;
  v10 = v6;
  HIBYTE(v9) = a1;
  BYTE2(v9) = 7;
  if ( !(unsigned __int8)sub_95620(v9, (int)v6, v8, v7) )
    return 0;
  v13 = 0;
  for ( i = 0; i < BYTE2(v9) - 2; ++i )
    v13 += (unsigned __int8)v7[i];
  if ( HIBYTE(v13) != (unsigned __int8)v7[BYTE2(v9) - 2] || (unsigned __int8)v13 != (unsigned __int8)v7[BYTE2(v9) - 1] )
    return 0;
  if ( v7[2] != 1 )
    return 0;
  *a3 = v7[3];
  return 1;
}

//----- (00097A34) --------------------------------------------------------
int __fastcall pic1704_write_flash(char a1, const void *a2, char a3, size_t a4)
{
  int v9; // [sp+14h] [bp-20h] BYREF
  char v10; // [sp+18h] [bp-1Ch]
  int v11; // [sp+1Ch] [bp-18h]
  void *v12; // [sp+20h] [bp-14h]
  unsigned __int8 v13; // [sp+27h] [bp-Dh]
  void *ptr; // [sp+28h] [bp-Ch]
  void *v15; // [sp+2Ch] [bp-8h]

  v9 = 255;
  v10 = 0;
  v15 = malloc(a4 + 8);
  ptr = malloc(a4 + 2);
  *(_BYTE *)ptr = a3;
  *((_BYTE *)ptr + 1) = a4;
  memcpy((char *)ptr + 2, a2, a4);
  LOBYTE(v11) = 51;
  v12 = ptr;
  BYTE1(v11) = a4 + 2;
  HIBYTE(v11) = a1;
  BYTE2(v11) = 5;
  v13 = sub_95620(v11, (int)ptr, v15, (unsigned __int8 *)&v9);
  free(ptr);
  free(v15);
  return v13;
}

//----- (00097B48) --------------------------------------------------------
int __fastcall pic1704_read_flash(char a1, void *a2, char a3, size_t a4)
{
  _BYTE v9[4]; // [sp+10h] [bp-24h] BYREF
  __int64 v10; // [sp+14h] [bp-20h] BYREF
  int v11; // [sp+1Ch] [bp-18h]
  _BYTE *v12; // [sp+20h] [bp-14h]
  void *ptr; // [sp+24h] [bp-10h]
  unsigned int i; // [sp+28h] [bp-Ch]
  __int16 v15; // [sp+2Ch] [bp-8h]
  unsigned __int8 v16; // [sp+2Fh] [bp-5h]

  v10 = 0;
  ptr = malloc(a4 + 5);
  v9[0] = a3;
  v9[1] = a4;
  LOWORD(v11) = 564;
  v12 = v9;
  HIBYTE(v11) = a1;
  BYTE2(v11) = a4 + 5;
  v16 = sub_95620(v11, (int)v9, &v10, (unsigned __int8 *)ptr);
  if ( v16 )
  {
    v15 = 0;
    for ( i = 0; a4 + 3 > i; ++i )
      v15 += *((unsigned __int8 *)ptr + i);
    if ( HIBYTE(v15) == *((unsigned __int8 *)ptr + a4 + 3) && (unsigned __int8)v15 == *((unsigned __int8 *)ptr + a4 + 4) )
      memcpy(a2, (char *)ptr + 3, a4);
    else
      v16 = 0;
  }
  free(ptr);
  return v16;
}

//----- (00097CE0) --------------------------------------------------------
int __fastcall open_pic(unsigned __int8 a1)
{
  int v4; // [sp+Ch] [bp-10h] BYREF
  __int16 v5; // [sp+10h] [bp-Ch]
  char v6; // [sp+12h] [bp-Ah]
  unsigned __int8 v7; // [sp+13h] [bp-9h]
  int v8; // [sp+14h] [bp-8h]

  if ( g_bitmain_pic_state[2 * a1] && g_bitmain_pic_state[2 * a1 + 1] )
    return g_bitmain_pic_state[2 * a1];
  v4 = a1;
  v5 = 0;
  v6 = byte_15F930;
  v7 = a1;
  pthread_mutex_lock(&i2c_mutex_all);
  v8 = iic_init((int)&v4);
  pthread_mutex_unlock(&i2c_mutex_all);
  if ( v8 >= 0 )
  {
    g_bitmain_pic_state[2 * a1] = v8;
    g_bitmain_pic_state[2 * a1 + 1] = 1;
  }
  return v8;
}
// 15F918: using guessed type pthread_mutex_t i2c_mutex_all;
// 15F930: using guessed type char byte_15F930;
// 1617FC: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (00097DE4) --------------------------------------------------------
int __fastcall close_pic(int result)
{
  unsigned __int8 v1; // [sp+17h] [bp-1805h]
  char v2[4]; // [sp+18h] [bp-1804h] BYREF
  char v3[4]; // [sp+818h] [bp-1004h] BYREF

  v1 = result;
  if ( (unsigned __int8)result <= 0xFu )
  {
    if ( g_bitmain_pic_state[2 * (unsigned __int8)result] || g_bitmain_pic_state[2 * (unsigned __int8)result + 1] )
    {
      pthread_mutex_lock(&i2c_mutex_all);
      iic_uninit(g_bitmain_pic_state[2 * v1]);
      g_bitmain_pic_state[2 * v1 + 1] = 0;
      return pthread_mutex_unlock(&i2c_mutex_all);
    }
  }
  else
  {
    snprintf(v2, 0x800u, "%s: Bad pic param, input chain is %d", "close_pic", (unsigned __int8)result);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/drv_pic/pic_1704.c",
             175,
             "close_pic",
             9,
             765,
             100,
             v3);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F918: using guessed type pthread_mutex_t i2c_mutex_all;
// 1608F0: using guessed type int g_zc;
// 1617FC: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (00097F6C) --------------------------------------------------------
int __fastcall sub_97F6C(int a1)
{
  if ( hal_fan_addr(a1) < 0 )
    return 0;
  else
    return hal_fan_addr(a1);
}

//----- (00097FB0) --------------------------------------------------------
unsigned int __fastcall sub_97FB0(unsigned __int8 a1, const char *a2)
{
  const char *v6; // [sp+14h] [bp-8h]

  v6 = a2;
  do
    ++v6;
  while ( *v6 != 32 );
  *v6 = 0;
  if ( !atoi(a2) )
    return 0;
  if ( atoi(a2) > 4000000 )
    dword_15F93C[a1] = atoi(a2);
  return 10 * ((unsigned int)(float)(6.0e10 / (float)(unsigned int)(2 * dword_15F93C[a1])) / 0xA);
}
// 15F93C: using guessed type _DWORD dword_15F93C[8];

//----- (000980C4) --------------------------------------------------------
int sub_980C4()
{
  int v0; // r0
  int v1; // r4
  int v2; // r4
  int v3; // r4
  int v4; // r4
  int v5; // r4
  int v6; // r4
  int v7; // r4
  int v8; // r3
  char v10[48]; // [sp+1Ch] [bp-1870h] BYREF
  char v11[48]; // [sp+81Ch] [bp-1070h] BYREF
  _QWORD v12[4]; // [sp+181Ch] [bp-70h] BYREF
  _DWORD s[16]; // [sp+183Ch] [bp-50h] BYREF
  unsigned __int8 i; // [sp+187Fh] [bp-Dh]

  memset(s, 0, sizeof(s));
  memset(v12, 0, sizeof(v12));
  for ( i = 0; ; ++i )
  {
    v2 = i;
    if ( v2 >= hal_fan_number() )
      break;
    do
    {
      memset(s, 0, sizeof(s));
      v0 = hal_fan_addr(i);
      snprintf((char *)s, 0x40u, "/sys/class/pwm/pwmchip12/pwm%d/capture", v0);
      v1 = i;
      *((_DWORD *)v12 + v1) = fopen((const char *)s, "r");
      if ( !*((_DWORD *)v12 + i) )
      {
        snprintf(v10, 0x800u, "fail to open %s", (const char *)s);
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_fan.c",
          185,
          "fan_thread_function",
          19,
          62,
          100,
          v11);
        usleep(0x2DC6C0u);
      }
    }
    while ( !*((_DWORD *)v12 + i) && dword_15F938 == 1 );
    snprintf(v10, 0x800u, "%s open successfully", (const char *)s);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_fan.c",
      185,
      "fan_thread_function",
      19,
      67,
      20,
      v11);
  }
  while ( dword_15F938 )
  {
    for ( i = 0; ; ++i )
    {
      v6 = i;
      if ( v6 >= hal_fan_number() )
        break;
      fflush(*((FILE **)v12 + i));
      fseek(*((FILE **)v12 + i), 0, 0);
      memset(s, 0, sizeof(s));
      fread(s, 1u, 0x40u, *((FILE **)v12 + i));
      v3 = i;
      dword_15F95C[v3] = sub_97FB0(i, (const char *)s);
      dword_1505A8[i] = dword_15F95C[i];
      v4 = dword_1505A8[i];
      if ( v4 > QMap<tagE_LEVEL,MFaultLabel::FaultType>::empty(i) )
      {
        v5 = i;
        dword_1505A8[v5] = QMap<tagE_LEVEL,MFaultLabel::FaultType>::empty(i);
      }
    }
    usleep(0x64u);
  }
  for ( i = 0; ; ++i )
  {
    v7 = i;
    if ( v7 >= hal_fan_number() )
      break;
    fclose(*((FILE **)v12 + i));
  }
  strcpy(v10, "fan thread exit\n");
  V_LOCK();
  logfmt_raw(v11, 0x1000u, 0, v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_fan.c",
    185,
    "fan_thread_function",
    19,
    94,
    20,
    v11);
  return v8;
}
// 98598: variable 'v8' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1505A8: using guessed type _DWORD dword_1505A8[8];
// 15F938: using guessed type int dword_15F938;
// 15F95C: using guessed type _DWORD dword_15F95C[8];
// 1608F0: using guessed type int g_zc;

//----- (000985A4) --------------------------------------------------------
int fan_init()
{
  _DWORD v2[512]; // [sp+10h] [bp-1804h] BYREF
  char v3[4]; // [sp+810h] [bp-1004h] BYREF

  if ( platform_inited )
  {
    dword_15F938 = 1;
    pthread_create((pthread_t *)&dword_15F934, 0, (void *(*)(void *))sub_980C4, 0);
    return 0;
  }
  else
  {
    strcpy((char *)v2, "please init platform first!!\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_fan.c",
      185,
      "fan_init",
      8,
      101,
      100,
      v3,
      v2[0],
      v2[1],
      v2[2],
      v2[3],
      v2[4],
      v2[5],
      v2[6],
      v2[7]);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F934: using guessed type int dword_15F934;
// 15F938: using guessed type int dword_15F938;
// 1603F4: using guessed type int platform_inited;
// 1608F0: using guessed type int g_zc;

//----- (000986A4) --------------------------------------------------------
int fan_uninit()
{
  dword_15F938 = 0;
  return pthread_join(dword_15F934, 0);
}
// 15F934: using guessed type int dword_15F934;
// 15F938: using guessed type int dword_15F938;

//----- (000986DC) --------------------------------------------------------
int __fastcall fan_get_realtime_speed(unsigned int a1)
{
  char v3[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v4[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v5; // [sp+181Ch] [bp-8h]

  v5 = 0;
  if ( a1 > 7 )
  {
    snprintf(v3, 0x800u, "bad fan id = %d\n", a1);
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_fan.c",
      185,
      "fan_get_realtime_speed",
      22,
      128,
      100,
      v4);
  }
  return dword_1505A8[a1];
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1505A8: using guessed type _DWORD dword_1505A8[8];
// 1608F0: using guessed type int g_zc;

//----- (000987D8) --------------------------------------------------------
int fan_get_max_num()
{
  return hal_fan_number();
}

//----- (000987F0) --------------------------------------------------------
int __fastcall QMap<tagE_LEVEL,MFaultLabel::FaultType>::empty(int a1)
{
  return hal_fan_max_speed(a1);
}

//----- (00098818) --------------------------------------------------------
int fan_turn_on()
{
  return -1;
}

//----- (0009883C) --------------------------------------------------------
int fan_turn_off()
{
  return -1;
}

//----- (00098860) --------------------------------------------------------
void sub_98860()
{
  ;
}

//----- (00098878) --------------------------------------------------------
int fpga_init()
{
  return 0;
}

//----- (00098894) --------------------------------------------------------
void fpga_uninit()
{
  ;
}

//----- (000988AC) --------------------------------------------------------
int fpga_read()
{
  return -1;
}

//----- (000988D4) --------------------------------------------------------
int fpga_write()
{
  return -1;
}

//----- (000988FC) --------------------------------------------------------
int get_fpga_map_mem_addr()
{
  return 0;
}

//----- (00098918) --------------------------------------------------------
int get_hardware_version()
{
  return 0;
}

//----- (00098934) --------------------------------------------------------
void fpga_reset()
{
  ;
}

//----- (0009894C) --------------------------------------------------------
int __fastcall iic_init(int a1)
{
  char v4[2048]; // [sp+18h] [bp-180Ch] BYREF
  char v5[12]; // [sp+818h] [bp-100Ch] BYREF
  int v6; // [sp+1818h] [bp-Ch]
  int v7; // [sp+181Ch] [bp-8h]

  v7 = 0;
  v6 = 0;
  if ( pthread_mutex_lock(&stru_15F97C) )
  {
    strcpy(v4, "failed to iic lock\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
      185,
      "iic_init",
      8,
      32,
      100,
      v5);
    return -4;
  }
  else if ( a1 )
  {
    if ( *(_DWORD *)a1 || *(_WORD *)(a1 + 4) != 1 || *(_BYTE *)(a1 + 6) != 2 || *(_BYTE *)(a1 + 7) )
    {
      v6 = i2c_init("/dev/i2c-0");
      if ( v6 >= 0 )
      {
        if ( i2c_ioctl(v6, 1795, (16 * *(unsigned __int8 *)(a1 + 6)) | (2 * *(unsigned __int8 *)(a1 + 7))) )
        {
          strcpy(v4, "failed to i2c_ioctl\n");
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
            185,
            "iic_init",
            8,
            68,
            100,
            v5);
          v7 = -1;
        }
        else
        {
          v7 = v6;
          snprintf(
            v4,
            0x800u,
            "i2c chain = %d, master = 0x%x, slave = 0x%x\n",
            *(_DWORD *)a1,
            *(unsigned __int16 *)(a1 + 4),
            (8 * *(unsigned __int8 *)(a1 + 6)) | *(unsigned __int8 *)(a1 + 7));
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
            185,
            "iic_init",
            8,
            74,
            20,
            v5);
        }
      }
      else
      {
        strcpy(v4, "failed to i2c_init\n");
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
          185,
          "iic_init",
          8,
          61,
          100,
          v5);
        v7 = -1;
      }
    }
    else
    {
      v6 = i2c_sim_init();
      if ( v6 < 0 )
      {
        strcpy(v4, "failed to i2c_sim_init\n");
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
          185,
          "iic_init",
          8,
          51,
          100,
          v5);
        v7 = -1;
      }
      v7 = v6;
    }
    pthread_mutex_unlock(&stru_15F97C);
    return v7;
  }
  else
  {
    pthread_mutex_unlock(&stru_15F97C);
    strcpy(v4, "bad param\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
      185,
      "iic_init",
      8,
      39,
      100,
      v5);
    v7 = -3;
    return -3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F97C: using guessed type pthread_mutex_t stru_15F97C;
// 1608F0: using guessed type int g_zc;

//----- (00098F18) --------------------------------------------------------
int __fastcall iic_uninit(int a1)
{
  char v3[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v4[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v5; // [sp+181Ch] [bp-8h]

  v5 = 0;
  if ( pthread_mutex_lock(&stru_15F97C) )
  {
    strcpy(v3, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
             185,
             "iic_uninit",
             10,
             92,
             100,
             v4);
  }
  else
  {
    if ( a1 == 255 )
      i2c_sim_uninit();
    else
      i2c_uninit(a1);
    return pthread_mutex_unlock(&stru_15F97C);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F97C: using guessed type pthread_mutex_t stru_15F97C;
// 1608F0: using guessed type int g_zc;

//----- (00099040) --------------------------------------------------------
int __fastcall iic_read(int a1, void *a2, size_t a3)
{
  int v6; // [sp+14h] [bp-1810h]
  char v9[2048]; // [sp+20h] [bp-1804h] BYREF
  char v10[4]; // [sp+820h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_15F97C) )
  {
    strcpy(v9, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
      185,
      "iic_read",
      8,
      121,
      100,
      v10);
    return -4;
  }
  else
  {
    v6 = i2c_read(a1, a2, a3);
    pthread_mutex_unlock(&stru_15F97C);
    return v6;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F97C: using guessed type pthread_mutex_t stru_15F97C;
// 1608F0: using guessed type int g_zc;

//----- (0009918C) --------------------------------------------------------
int __fastcall iic_write(int a1, int a2, unsigned int a3)
{
  int v6; // [sp+14h] [bp-1810h]
  char v9[2048]; // [sp+20h] [bp-1804h] BYREF
  char v10[4]; // [sp+820h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_15F97C) )
  {
    strcpy(v9, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
      185,
      "iic_write",
      9,
      142,
      100,
      v10);
    return -4;
  }
  else
  {
    v6 = i2c_write(a1, a2, a3);
    pthread_mutex_unlock(&stru_15F97C);
    return v6;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F97C: using guessed type pthread_mutex_t stru_15F97C;
// 1608F0: using guessed type int g_zc;

//----- (000992D8) --------------------------------------------------------
int __fastcall iic_read_reg(int a1, _BYTE *a2, unsigned int a3, int a4, unsigned int a5)
{
  char v11[2048]; // [sp+24h] [bp-1810h] BYREF
  char v12[16]; // [sp+824h] [bp-1010h] BYREF
  char v13; // [sp+1827h] [bp-Dh] BYREF
  int v14; // [sp+1828h] [bp-Ch]
  unsigned int i; // [sp+182Ch] [bp-8h]

  if ( pthread_mutex_lock(&stru_15F97C) )
  {
    strcpy(v11, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
      185,
      "iic_read_reg",
      12,
      164,
      100,
      v12,
      a4);
    return -4;
  }
  else
  {
    v14 = 0;
    for ( i = 0; i < a5; ++i )
    {
      v13 = *a2 + i;
      v14 = i2c_write(a1, (int)&v13, a3);
      if ( a3 == v14 )
      {
        v14 = i2c_read(a1, (void *)(a4 + i), a3);
      }
      else
      {
        strcpy(v11, "failed to write i2c reg\n");
        V_LOCK();
        logfmt_raw(v12, 0x1000u, 0, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
          185,
          "iic_read_reg",
          12,
          175,
          100,
          v12);
      }
    }
    pthread_mutex_unlock(&stru_15F97C);
    return a5;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F97C: using guessed type pthread_mutex_t stru_15F97C;
// 1608F0: using guessed type int g_zc;

//----- (00099570) --------------------------------------------------------
size_t __fastcall iic_write_reg(int a1, _BYTE *a2, int a3, const void *a4, size_t n)
{
  char v11[2048]; // [sp+24h] [bp-1810h] BYREF
  char v12[16]; // [sp+824h] [bp-1010h] BYREF
  void *ptr; // [sp+1824h] [bp-10h]

  ptr = 0;
  if ( pthread_mutex_lock(&stru_15F97C) )
  {
    strcpy(v11, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
      185,
      "iic_write_reg",
      13,
      201,
      100,
      v12);
    return -4;
  }
  else if ( a3 == 1 )
  {
    if ( a4 && n )
    {
      ptr = malloc(n + 1);
      *(_BYTE *)ptr = *a2;
      memcpy((char *)ptr + 1, a4, n);
      if ( n + 1 != i2c_write(a1, (int)ptr, n + 1) )
      {
        strcpy(v11, "failed to write i2c reg\n");
        V_LOCK();
        logfmt_raw(v12, 0x1000u, 0, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
          185,
          "iic_write_reg",
          13,
          221,
          100,
          v12);
      }
      if ( ptr )
        free(ptr);
      pthread_mutex_unlock(&stru_15F97C);
      return n;
    }
    else
    {
      strcpy(v11, "bad register data size\n");
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
        185,
        "iic_write_reg",
        13,
        212,
        80,
        v12);
      return -1;
    }
  }
  else
  {
    strcpy(v11, "bad register bytes\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_iic.c",
      185,
      "iic_write_reg",
      13,
      207,
      80,
      v12);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F97C: using guessed type pthread_mutex_t stru_15F97C;
// 1608F0: using guessed type int g_zc;

//----- (00099988) --------------------------------------------------------
int bitmain_power_on()
{
  if ( !is_gpio_exist(dword_1505E8) )
  {
    gpio_export(dword_1505E8);
    gpio_direction(dword_1505E8, 1);
  }
  return gpio_write(dword_1505E8, 1);
}
// 1505E8: using guessed type int dword_1505E8;

//----- (00099A00) --------------------------------------------------------
int bitmain_power_off()
{
  if ( !is_gpio_exist(dword_1505E8) )
  {
    gpio_export(dword_1505E8);
    gpio_direction(dword_1505E8, 1);
  }
  return gpio_write(dword_1505E8, 0);
}
// 1505E8: using guessed type int dword_1505E8;

//----- (00099A78) --------------------------------------------------------
int __fastcall set_status(int result)
{
  dword_1505E8 = result;
  return result;
}
// 99A78: invalid function type 'void __cdecl set_status(STATUS_CODE err)' has been ignored
// 1505E8: using guessed type int dword_1505E8;

//----- (00099AA8) --------------------------------------------------------
int __fastcall pwm_init(unsigned int a1, int a2)
{
  char v4[2048]; // [sp+18h] [bp-1804h] BYREF
  char v5[4]; // [sp+818h] [bp-1004h] BYREF

  if ( platform_inited )
  {
    if ( a1 <= 1 )
    {
      *((_DWORD *)&unk_15F994 + 3 * a1) = a2;
      *((_BYTE *)&unk_15F994 + 12 * a1 + 8) = 1;
      return a1 + 1;
    }
    else
    {
      strcpy(v4, "bad param\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_pwm.c",
        185,
        "pwm_init",
        8,
        28,
        100,
        v5);
      return -3;
    }
  }
  else
  {
    strcpy(v4, "please init platform first!!\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_pwm.c",
      185,
      "pwm_init",
      8,
      23,
      100,
      v5);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1603F4: using guessed type int platform_inited;
// 1608F0: using guessed type int g_zc;

//----- (00099CAC) --------------------------------------------------------
int __fastcall pwm_uninit(int a1)
{
  int result; // r0
  char v3[2048]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( a1 - 1 <= 1 )
  {
    *((_DWORD *)&unk_15F994 + 3 * a1 - 2) = 0;
    *((_DWORD *)&unk_15F994 + 3 * a1 - 3) = *((_DWORD *)&unk_15F994 + 3 * a1 - 2);
    result = (unsigned __int8)*((_DWORD *)&unk_15F994 + 3 * a1 - 3);
    *((_BYTE *)&unk_15F994 + 12 * a1 - 4) = result;
  }
  else
  {
    strcpy(v3, "bad param\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_pwm.c",
             185,
             "pwm_uninit",
             10,
             40,
             100,
             v4);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (00099E40) --------------------------------------------------------
int __fastcall pwm_set(int a1, unsigned int a2)
{
  int v3; // r3
  unsigned int v5; // [sp+10h] [bp-1894h]
  char v6[2048]; // [sp+1Ch] [bp-1888h] BYREF
  char v7[8]; // [sp+81Ch] [bp-1088h] BYREF
  char s[128]; // [sp+181Ch] [bp-88h] BYREF
  int v9; // [sp+189Ch] [bp-8h]

  v9 = -5;
  if ( a1 - 1 <= 1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      if ( a2 >= 0x64 )
        v3 = 100;
      dword_15F998 = v3;
      v5 = (int)"time" * v3 / 0x64u;
      sprintf(s, "echo 0 > %s/enable", "/sys/class/pwm/pwmchip8/pwm0");
      system(s);
      sprintf(s, "echo %u > %s/period", "time", "/sys/class/pwm/pwmchip8/pwm0");
      system(s);
      sprintf(s, "echo %u > %s/duty_cycle", v5, "/sys/class/pwm/pwmchip8/pwm0");
      system(s);
      sprintf(s, "echo 1 > %s/enable", "/sys/class/pwm/pwmchip8/pwm0");
      system(s);
      sprintf(s, "echo 0 > %s/enable", "/sys/class/pwm/pwmchip8/pwm1");
      system(s);
      sprintf(s, "echo %u > %s/period", "time", "/sys/class/pwm/pwmchip8/pwm1");
      system(s);
      sprintf(s, "echo %u > %s/duty_cycle", v5, "/sys/class/pwm/pwmchip8/pwm1");
      system(s);
      sprintf(s, "echo 1 > %s/enable", "/sys/class/pwm/pwmchip8/pwm1");
      system(s);
      return 0;
    }
    else
    {
      snprintf(v6, 0x800u, "pwm type %d not supported\n", a1 - 1);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_pwm.c",
        185,
        "pwm_set",
        7,
        88,
        100,
        v7);
    }
    return v9;
  }
  else
  {
    strcpy(v6, "bad param\n");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_pwm.c",
      185,
      "pwm_set",
      7,
      59,
      100,
      v7);
    return -3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F998: using guessed type int dword_15F998;
// 1608F0: using guessed type int g_zc;

//----- (0009A208) --------------------------------------------------------
int __fastcall pwm_get(int a1, _DWORD *a2)
{
  char v4[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v6; // [sp+181Ch] [bp-8h]

  v6 = -5;
  if ( a1 - 1 <= 1 )
  {
    if ( a1 == 1 )
    {
      *a2 = dword_15F998;
      snprintf(v4, 0x800u, "val of fpga = 0x%x\n", *a2);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_pwm.c",
        185,
        "pwm_get",
        7,
        113,
        20,
        v5);
    }
    return v6;
  }
  else
  {
    strcpy(v4, "bad param\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_pwm.c",
      185,
      "pwm_get",
      7,
      106,
      100,
      v5);
    return -3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F998: using guessed type int dword_15F998;
// 1608F0: using guessed type int g_zc;

//----- (0009A3EC) --------------------------------------------------------
int sub_9A3EC()
{
  _DWORD v1[3]; // [sp+Ch] [bp-20h] BYREF
  int v2; // [sp+18h] [bp-14h]
  void *ptr; // [sp+1Ch] [bp-10h]
  _DWORD *v4; // [sp+20h] [bp-Ch]
  int i; // [sp+24h] [bp-8h]

  prctl(15, &unk_13775C);
  while ( dword_15F9CC )
  {
    if ( !pthread_mutex_lock(&stru_15F9AC) )
    {
      v4 = new_iterator_c_map(dword_15F9C4);
      for ( i = ((int (__fastcall *)(_DWORD *))*v4)(v4); i; i = ((int (__fastcall *)(_DWORD *))*v4)(v4) )
      {
        ptr = (void *)((int (__fastcall *)(int))v4[2])(i);
        v2 = v4[5];
        if ( !*((_DWORD *)ptr + 1) )
        {
          gpio_write(***(_DWORD ***)(v2 + 16), *((_DWORD *)ptr + 2));
          *((_DWORD *)ptr + 2) = *((_DWORD *)ptr + 2) != 1;
          *((_DWORD *)ptr + 1) = *(_DWORD *)ptr;
        }
        *((_DWORD *)ptr + 1) -= 200;
        *((_DWORD *)ptr + 1) = *((_DWORD *)ptr + 1);
        v1[0] = *(_DWORD *)ptr;
        v1[1] = *((_DWORD *)ptr + 1);
        v1[2] = *((_DWORD *)ptr + 2);
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v4[1])(v4, v1, 12);
        free(ptr);
      }
      delete_iterator_c_map(v4);
      pthread_mutex_unlock(&stru_15F9AC);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 15F9AC: using guessed type pthread_mutex_t stru_15F9AC;
// 15F9C4: using guessed type int dword_15F9C4;
// 15F9CC: using guessed type int dword_15F9CC;

//----- (0009A5C4) --------------------------------------------------------
int __fastcall sub_9A5C4(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0009A5FC) --------------------------------------------------------
int __fastcall sub_9A5FC(unsigned int a1)
{
  int v6; // [sp+Ch] [bp-8h]

  v6 = 0;
  if ( a1 == 2 )
  {
    if ( hal_led_green_addr() < 0 )
      return 0;
    else
      return hal_led_green_addr();
  }
  else if ( a1 > 2 )
  {
    if ( a1 == 256 )
    {
      if ( hal_key_reset_addr() < 0 )
        return 0;
      else
        return hal_key_reset_addr();
    }
    else if ( a1 == 257 )
    {
      if ( hal_key_ipreport_addr() < 0 )
        return 0;
      else
        return hal_key_ipreport_addr();
    }
  }
  else if ( a1 == 1 )
  {
    if ( hal_led_red_addr() < 0 )
      return 0;
    else
      return hal_led_red_addr();
  }
  return v6;
}

//----- (0009A6FC) --------------------------------------------------------
int __fastcall sub_9A6FC(int a1)
{
  char v3[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v4[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v5; // [sp+181Ch] [bp-8h]

  v5 = 259;
  if ( a1 == hal_key_reset_addr() )
    return 256;
  if ( a1 == hal_key_ipreport_addr() )
    return 257;
  snprintf(v3, 0x800u, "unmaped port = %d\n", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
    184,
    "convert_port_to_ui_type",
    23,
    124,
    100,
    v4);
  return v5;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009A828) --------------------------------------------------------
int __fastcall sub_9A828(int a1, char a2)
{
  int result; // r0
  char v5[12]; // [sp+18h] [bp-180Ch] BYREF
  char v6[12]; // [sp+818h] [bp-100Ch] BYREF
  int v7; // [sp+1818h] [bp-Ch]
  int i; // [sp+181Ch] [bp-8h]

  result = sub_9A6FC(a1);
  v7 = result;
  if ( result == 259 )
  {
    snprintf(v5, 0x800u, "gpio port %d is not a supported key\n", a1);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, v5);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
             184,
             "gpio_key_callback",
             17,
             134,
             80,
             v6);
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( dword_15F9D4[i] )
        result = dword_15F9D4[i](v7, a2 != 0);
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F9D4: using guessed type int (__fastcall *dword_15F9D4[5])(int, bool);
// 1608F0: using guessed type int g_zc;

//----- (0009A998) --------------------------------------------------------
int ui_init()
{
  int v0; // r0
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int i; // [sp+4h] [bp-8h]

  if ( !dword_15F9C8 )
  {
    v0 = sub_9A5FC(1u);
    gpio_export(v0);
    v1 = sub_9A5FC(1u);
    gpio_direction(v1, 1);
    v2 = sub_9A5FC(2u);
    gpio_export(v2);
    v3 = sub_9A5FC(2u);
    gpio_direction(v3, 1);
    v4 = sub_9A5FC(0x100u);
    gpio_export(v4);
    v5 = sub_9A5FC(0x101u);
    gpio_export(v5);
    v6 = sub_9A5FC(0x100u);
    gpio_reg_callback(v6, 632872);
    v7 = sub_9A5FC(0x101u);
    gpio_reg_callback(v7, 632872);
    pthread_mutex_init(&stru_15F9AC, 0);
    for ( i = 0; i <= 4; ++i )
      dword_15F9D4[i] = 0;
    dword_15F9C4 = (int)new_c_map(632260, 0, 0);
    dword_15F9CC = 1;
    pthread_create((pthread_t *)&dword_15F9D0, 0, (void *(*)(void *))sub_9A3EC, 0);
    dword_15F9C8 = 1;
  }
  return 0;
}
// 15F9AC: using guessed type pthread_mutex_t stru_15F9AC;
// 15F9C4: using guessed type int dword_15F9C4;
// 15F9C8: using guessed type int dword_15F9C8;
// 15F9CC: using guessed type int dword_15F9CC;
// 15F9D0: using guessed type int dword_15F9D0;
// 15F9D4: using guessed type int (__fastcall *dword_15F9D4[5])(int, bool);

//----- (0009AB38) --------------------------------------------------------
void ui_uninit()
{
  int v0; // r0
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0

  if ( dword_15F9C8 )
  {
    dword_15F9CC = 0;
    pthread_join(dword_15F9D0, 0);
    delete_c_map((void ***)dword_15F9C4);
    pthread_mutex_destroy(&stru_15F9AC);
    v0 = sub_9A5FC(0x100u);
    gpio_unreg_callback(v0, 632872);
    v1 = sub_9A5FC(0x101u);
    gpio_unreg_callback(v1, 632872);
    v2 = sub_9A5FC(1u);
    gpio_unexport(v2);
    v3 = sub_9A5FC(2u);
    gpio_unexport(v3);
    v4 = sub_9A5FC(0x100u);
    gpio_unexport(v4);
    v5 = sub_9A5FC(0x101u);
    gpio_unexport(v5);
    dword_15F9C8 = 0;
  }
}
// 15F9AC: using guessed type pthread_mutex_t stru_15F9AC;
// 15F9C4: using guessed type int dword_15F9C4;
// 15F9C8: using guessed type int dword_15F9C8;
// 15F9CC: using guessed type int dword_15F9CC;
// 15F9D0: using guessed type int dword_15F9D0;

//----- (0009AC3C) --------------------------------------------------------
int __fastcall sub_9AC3C(int result, int *a2)
{
  int v3; // [sp+14h] [bp-1808h] BYREF
  char v4[4]; // [sp+18h] [bp-1804h] BYREF
  char v5[4]; // [sp+818h] [bp-1004h] BYREF

  v3 = result;
  if ( a2 )
  {
    result = exists_c_map(a2, (int)&v3);
    if ( result == 1 )
    {
      snprintf(v4, 0x800u, "remove %d from flicker list\n", v3);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
        184,
        "remove_port_form_gpio_map",
        25,
        199,
        20,
        v5);
      return remove_c_map(a2, (int)&v3);
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009AD70) --------------------------------------------------------
int __fastcall sub_9AD70(int result, int a2, int *a3)
{
  _DWORD v5[2]; // [sp+1Ch] [bp-1818h] BYREF
  char v6[16]; // [sp+24h] [bp-1810h] BYREF
  char v7[16]; // [sp+824h] [bp-1010h] BYREF
  _DWORD v8[3]; // [sp+1824h] [bp-10h] BYREF

  v5[0] = result;
  if ( a3 )
  {
    if ( exists_c_map(a3, (int)v5) )
    {
      snprintf(v6, 0x800u, "port %d already exist in map\n", v5[0]);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
               184,
               "add_port_to_gpio_map",
               20,
               224,
               20,
               v7);
    }
    else
    {
      snprintf(v6, 0x800u, "add %d to flicker map with interval %d\n", v5[0], a2);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
        184,
        "add_port_to_gpio_map",
        20,
        218,
        20,
        v7);
      v8[0] = a2;
      v8[1] = 0;
      v8[2] = 1;
      return insert_c_map(a3, v5, 4u, v8, 0xCu);
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009AFA4) --------------------------------------------------------
void __fastcall sub_9AFA4(int a1, int a2, int a3)
{
  char v5[32]; // [sp+24h] [bp-1820h] BYREF
  char v6[32]; // [sp+824h] [bp-1020h] BYREF
  _DWORD v7[3]; // [sp+1824h] [bp-20h] BYREF
  void *ptr; // [sp+1830h] [bp-14h]
  int v9; // [sp+1834h] [bp-10h]
  _DWORD *v10; // [sp+1838h] [bp-Ch]
  int i; // [sp+183Ch] [bp-8h]

  if ( a3 )
  {
    v10 = new_iterator_c_map(a3);
    for ( i = ((int (__fastcall *)(_DWORD *))*v10)(v10); i; i = ((int (__fastcall *)(_DWORD *))*v10)(v10) )
    {
      v9 = v10[5];
      if ( a1 == ***(_DWORD ***)(v9 + 16) )
      {
        ptr = (void *)((int (__fastcall *)(int))v10[2])(i);
        v7[0] = a2;
        v7[1] = 0;
        v7[2] = 1;
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v10[1])(v10, v7, 12);
        snprintf(v5, 0x800u, "update the freq interval of port[%d] from %d to %d\n", a1, *(_DWORD *)ptr, a2);
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, v5);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
          184,
          "update_filcker_freq",
          19,
          245,
          20,
          v6);
        free(ptr);
        break;
      }
    }
    delete_iterator_c_map(v10);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009B198) --------------------------------------------------------
int __fastcall sub_9B198(unsigned int a1, int a2)
{
  char v6[2048]; // [sp+18h] [bp-180Ch] BYREF
  char v7[12]; // [sp+818h] [bp-100Ch] BYREF
  int v8; // [sp+1818h] [bp-Ch]
  int v9; // [sp+181Ch] [bp-8h]

  v8 = -1;
  v9 = sub_9A5FC(a1);
  if ( v9 )
  {
    snprintf(v6, 0x800u, "ui type = %d, port = %d, status = %d\n", a1, v9, a2);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
      184,
      "gpio_ctrl_ui",
      12,
      271,
      20,
      v7);
    if ( pthread_mutex_lock(&stru_15F9AC) )
    {
      strcpy(v6, "failed to api lock\n");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
        184,
        "gpio_ctrl_ui",
        12,
        274,
        100,
        v7);
      return -1;
    }
    else
    {
      if ( a2 == 1 )
      {
        sub_9AC3C(v9, (int *)dword_15F9C4);
        v8 = gpio_write(v9, 0);
      }
      else if ( a2 )
      {
        if ( a2 == 2 )
        {
          sub_9AD70(v9, 200, (int *)dword_15F9C4);
        }
        else
        {
          strcpy(v6, "unsuported led status\n");
          V_LOCK();
          logfmt_raw(v7, 0x1000u, 0, v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
            184,
            "gpio_ctrl_ui",
            12,
            291,
            100,
            v7);
          v8 = -2;
        }
      }
      else
      {
        sub_9AC3C(v9, (int *)dword_15F9C4);
        v8 = gpio_write(v9, 1);
      }
      pthread_mutex_unlock(&stru_15F9AC);
      return v8;
    }
  }
  else
  {
    strcpy(v6, "unsuported gpio port\n");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
      184,
      "gpio_ctrl_ui",
      12,
      268,
      100,
      v7);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F9AC: using guessed type pthread_mutex_t stru_15F9AC;
// 15F9C4: using guessed type int dword_15F9C4;
// 1608F0: using guessed type int g_zc;

//----- (0009B59C) --------------------------------------------------------
int __fastcall sub_9B59C(unsigned int a1, int a2)
{
  char v5[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v6[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v7; // [sp+181Ch] [bp-8h]

  v7 = sub_9A5FC(a1);
  if ( v7 )
  {
    if ( a2 == 200 )
    {
      strcpy(v5, "interval is same with default\n");
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
        184,
        "gpio_set_led_filker_freq",
        24,
        317,
        80,
        v6);
    }
    else
    {
      sub_9AFA4(v7, a2, dword_15F9C4);
    }
    return 0;
  }
  else
  {
    strcpy(v5, "unsuported led port\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
      184,
      "gpio_set_led_filker_freq",
      24,
      312,
      100,
      v6);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F9C4: using guessed type int dword_15F9C4;
// 1608F0: using guessed type int g_zc;

//----- (0009B79C) --------------------------------------------------------
int red_led_on()
{
  return sub_9B198(1u, 0);
}

//----- (0009B7BC) --------------------------------------------------------
int red_led_off()
{
  return sub_9B198(1u, 1);
}

//----- (0009B7DC) --------------------------------------------------------
int red_led_flicker()
{
  return sub_9B198(1u, 2);
}

//----- (0009B7FC) --------------------------------------------------------
int green_led_on()
{
  return sub_9B198(2u, 0);
}

//----- (0009B81C) --------------------------------------------------------
int green_led_off()
{
  return sub_9B198(2u, 1);
}

//----- (0009B83C) --------------------------------------------------------
int green_led_flicker()
{
  return sub_9B198(2u, 2);
}

//----- (0009B85C) --------------------------------------------------------
int beeper_on()
{
  return sub_9B198(0x10u, 0);
}

//----- (0009B87C) --------------------------------------------------------
int beeper_off()
{
  return sub_9B198(0x10u, 1);
}

//----- (0009B89C) --------------------------------------------------------
int beeper_flicker()
{
  return sub_9B198(0x10u, 2);
}

//----- (0009B8BC) --------------------------------------------------------
int __fastcall reg_key_callback(int (__fastcall *a1)(int, bool))
{
  char v4[2048]; // [sp+18h] [bp-180Ch] BYREF
  char v5[12]; // [sp+818h] [bp-100Ch] BYREF
  int i; // [sp+1818h] [bp-Ch]
  int v7; // [sp+181Ch] [bp-8h]

  i = 0;
  v7 = 0;
  if ( pthread_mutex_lock(&stru_15F9AC) )
  {
    strcpy(v4, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
      184,
      "reg_key_callback",
      16,
      390,
      100,
      v5);
    return -1;
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( !dword_15F9D4[i] )
      {
        dword_15F9D4[i] = a1;
        break;
      }
    }
    if ( i > 4 )
    {
      v7 = -2;
      strcpy(v4, "no more listener available\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
        184,
        "reg_key_callback",
        16,
        404,
        100,
        v5);
    }
    pthread_mutex_unlock(&stru_15F9AC);
    return v7;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F9AC: using guessed type pthread_mutex_t stru_15F9AC;
// 15F9D4: using guessed type int (__fastcall *dword_15F9D4[5])(int, bool);
// 1608F0: using guessed type int g_zc;

//----- (0009BADC) --------------------------------------------------------
int __fastcall unreg_key_callback(int (__fastcall *a1)(int, bool))
{
  char v4[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  int i; // [sp+181Ch] [bp-8h]

  i = 0;
  if ( pthread_mutex_lock(&stru_15F9AC) )
  {
    strcpy(v4, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
      184,
      "unreg_key_callback",
      18,
      423,
      100,
      v5);
    return -1;
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( a1 == dword_15F9D4[i] )
      {
        dword_15F9D4[i] = 0;
        break;
      }
    }
    if ( i > 4 )
    {
      strcpy(v4, "listener not registered before\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
        184,
        "unreg_key_callback",
        18,
        436,
        80,
        v5);
    }
    pthread_mutex_unlock(&stru_15F9AC);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F9AC: using guessed type pthread_mutex_t stru_15F9AC;
// 15F9D4: using guessed type int (__fastcall *dword_15F9D4[5])(int, bool);
// 1608F0: using guessed type int g_zc;

//----- (0009BCF0) --------------------------------------------------------
int __fastcall lcd_show_result(unsigned __int8 a1, int a2, unsigned int a3)
{
  char v8[2048]; // [sp+24h] [bp-1808h] BYREF
  char v9[8]; // [sp+824h] [bp-1008h] BYREF
  int v10; // [sp+1824h] [bp-8h]

  v10 = -1;
  if ( pthread_mutex_lock(&stru_15F9AC) )
  {
    strcpy(v8, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
      184,
      "lcd_show_result",
      15,
      456,
      100,
      v9);
    return -4;
  }
  else
  {
    if ( dword_1505EC < 0 )
    {
      dword_1505EC = lcd_init(lcd_path);
      lcd_clear(dword_1505EC);
    }
    if ( dword_1505EC <= 0 )
    {
      snprintf(v8, 0x800u, "failed to init %s\n", lcd_path);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
        184,
        "lcd_show_result",
        15,
        470,
        100,
        v9);
      v10 = -1;
    }
    else
    {
      v10 = lcd_write(dword_1505EC, a1, a2, a3);
    }
    pthread_mutex_unlock(&stru_15F9AC);
    return v10;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1505EC: using guessed type int dword_1505EC;
// 1505F0: using guessed type char *lcd_path;
// 15F9AC: using guessed type pthread_mutex_t stru_15F9AC;
// 1608F0: using guessed type int g_zc;

//----- (0009BF54) --------------------------------------------------------
int lcd_clear_result()
{
  _DWORD v1[512]; // [sp+10h] [bp-1804h] BYREF
  char v2[4]; // [sp+810h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_15F9AC) )
  {
    strcpy((char *)v1, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_ui.c",
      184,
      "lcd_clear_result",
      16,
      484,
      100,
      v2,
      v1[0],
      v1[1],
      v1[2],
      v1[3],
      v1[4]);
  }
  if ( dword_1505EC > 0 )
    lcd_clear(dword_1505EC);
  return pthread_mutex_unlock(&stru_15F9AC);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1505EC: using guessed type int dword_1505EC;
// 15F9AC: using guessed type pthread_mutex_t stru_15F9AC;
// 1608F0: using guessed type int g_zc;

//----- (0009C050) --------------------------------------------------------
int hal_led_red_addr()
{
  if ( dword_1505F4 )
    return dword_150758;
  else
    return -1;
}
// 1505F4: using guessed type int dword_1505F4;
// 150758: using guessed type int dword_150758;

//----- (0009C090) --------------------------------------------------------
int hal_led_green_addr()
{
  if ( dword_1505F4 )
    return dword_15075C;
  else
    return -1;
}
// 1505F4: using guessed type int dword_1505F4;
// 15075C: using guessed type int dword_15075C;

//----- (0009C0D0) --------------------------------------------------------
int hal_key_reset_addr()
{
  if ( dword_1505F4 )
    return dword_150760;
  else
    return -1;
}
// 1505F4: using guessed type int dword_1505F4;
// 150760: using guessed type int dword_150760;

//----- (0009C110) --------------------------------------------------------
int hal_key_ipreport_addr()
{
  if ( dword_1505F4 )
    return dword_150764;
  else
    return -1;
}
// 1505F4: using guessed type int dword_1505F4;
// 150764: using guessed type int dword_150764;

//----- (0009C150) --------------------------------------------------------
int __fastcall hal_chain_uart_addr(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_1505F4 )
    return -1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( a1 == dword_1505F8[4 * i] )
      return dword_1505F8[4 * i + 1];
  }
  return -2;
}
// 1505F4: using guessed type int dword_1505F4;
// 1505F8: using guessed type _DWORD dword_1505F8[64];

//----- (0009C1EC) --------------------------------------------------------
int __fastcall hal_chain_plug_addr(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_1505F4 )
    return -1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( a1 == dword_1505F8[4 * i] )
      return dword_1505F8[4 * i + 2];
  }
  return -2;
}
// 1505F4: using guessed type int dword_1505F4;
// 1505F8: using guessed type _DWORD dword_1505F8[64];

//----- (0009C288) --------------------------------------------------------
int __fastcall hal_chain_reset_addr(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_1505F4 )
    return -1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( a1 == dword_1505F8[4 * i] )
      return dword_1505F8[4 * i + 3];
  }
  return -2;
}
// 1505F4: using guessed type int dword_1505F4;
// 1505F8: using guessed type _DWORD dword_1505F8[64];

//----- (0009C324) --------------------------------------------------------
int hal_chain_max_num()
{
  int i; // [sp+4h] [bp-8h]

  if ( !dword_1505F4 )
    return -1;
  for ( i = 0;
        i <= 15
     && (dword_1505F8[4 * i] != -1
      || dword_1505F8[4 * i + 1] != -1
      || dword_1505F8[4 * i + 2] != -1
      || dword_1505F8[4 * i + 3] != -1);
        ++i )
  {
    ;
  }
  return i;
}
// 1505F4: using guessed type int dword_1505F4;
// 1505F8: using guessed type _DWORD dword_1505F8[64];

//----- (0009C40C) --------------------------------------------------------
int __fastcall hal_fan_addr(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_1505F4 )
    return -1;
  for ( i = 0; i <= 7; ++i )
  {
    if ( a1 == dword_1506F8[3 * i] )
      return dword_1506F8[3 * i + 1];
  }
  return -2;
}
// 1505F4: using guessed type int dword_1505F4;
// 1506F8: using guessed type _DWORD dword_1506F8[24];

//----- (0009C4BC) --------------------------------------------------------
int __fastcall hal_fan_max_speed(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_1505F4 )
    return -1;
  for ( i = 0; i <= 7; ++i )
  {
    if ( a1 == dword_1506F8[3 * i] )
      return dword_1506F8[3 * i + 2];
  }
  return -1;
}
// 1505F4: using guessed type int dword_1505F4;
// 1506F8: using guessed type _DWORD dword_1506F8[24];

//----- (0009C56C) --------------------------------------------------------
int hal_fan_number()
{
  int i; // [sp+0h] [bp-Ch]
  int v3; // [sp+4h] [bp-8h]

  v3 = 0;
  if ( !dword_1505F4 )
    return -1;
  for ( i = 0; i <= 7; ++i )
  {
    if ( dword_1506F8[3 * i] != -1 )
      ++v3;
  }
  return v3;
}
// 1505F4: using guessed type int dword_1505F4;
// 1506F8: using guessed type _DWORD dword_1506F8[24];

//----- (0009C608) --------------------------------------------------------
int __fastcall eeprom_open(unsigned int a1)
{
  char v4[16]; // [sp+1Ch] [bp-1810h] BYREF
  char v5[16]; // [sp+81Ch] [bp-1010h] BYREF
  unsigned int v6; // [sp+181Ch] [bp-10h] BYREF
  __int16 v7; // [sp+1820h] [bp-Ch]
  char v8; // [sp+1822h] [bp-Ah]
  char v9; // [sp+1823h] [bp-9h]
  int v10; // [sp+1824h] [bp-8h]

  v10 = 0;
  if ( a1 <= 0xF )
  {
    if ( dword_15F9E8[2 * a1] && dword_15F9E8[2 * a1 + 1] )
    {
      return dword_15F9E8[2 * a1];
    }
    else
    {
      v6 = a1;
      v7 = 0;
      v8 = 10;
      v9 = a1;
      v10 = iic_init((int)&v6);
      if ( v10 >= 0 )
      {
        dword_15F9E8[2 * a1] = v10;
        dword_15F9E8[2 * a1 + 1] = 1;
      }
      return v10;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad eeprom param, input chain is %d", "eeprom_open", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_open",
      11,
      50,
      100,
      v5);
    return -2147483391;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F9E8: using guessed type _DWORD dword_15F9E8[32];
// 1608F0: using guessed type int g_zc;

//----- (0009C804) --------------------------------------------------------
unsigned int __fastcall eeprom_close(unsigned int result)
{
  unsigned int v1; // [sp+14h] [bp-1808h]
  char v2[4]; // [sp+18h] [bp-1804h] BYREF
  char v3[4]; // [sp+818h] [bp-1004h] BYREF

  v1 = result;
  if ( result <= 0xF )
  {
    if ( dword_15F9E8[2 * result] || dword_15F9E8[2 * result + 1] )
    {
      result = iic_uninit(dword_15F9E8[2 * result]);
      dword_15F9E8[2 * v1] = 0;
      dword_15F9E8[2 * v1 + 1] = 0;
    }
  }
  else
  {
    snprintf(v2, 0x800u, "%s: Bad eeprom param, input chain is %d", "eeprom_close", result);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
             180,
             "eeprom_close",
             12,
             74,
             100,
             v3);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F9E8: using guessed type _DWORD dword_15F9E8[32];
// 1608F0: using guessed type int g_zc;

//----- (0009C98C) --------------------------------------------------------
int __fastcall eeprom_write(unsigned int a1, char a2, int a3, unsigned int a4)
{
  char v10[16]; // [sp+24h] [bp-1810h] BYREF
  char v11[16]; // [sp+824h] [bp-1010h] BYREF
  unsigned __int8 v12; // [sp+1827h] [bp-Dh] BYREF
  unsigned int i; // [sp+1828h] [bp-Ch]
  int v14; // [sp+182Ch] [bp-8h]

  v14 = 0;
  i = 0;
  if ( a1 <= 0xF )
  {
    if ( dword_15F9E8[2 * a1 + 1] || (v14 = eeprom_open(a1), v14 >= 0) )
    {
      for ( i = 0; a4 > i; ++i )
      {
        v12 = i + a2;
        v14 = iic_write_reg(dword_15F9E8[2 * a1], &v12, 1, (const void *)(a3 + i), 1u);
        if ( v14 != 1 )
        {
          snprintf(v10, 0x800u, "fail to write eeprom by iic, chain:%d, addr: %d", a1, v12);
          V_LOCK();
          logfmt_raw(v11, 0x1000u, 0, v10);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
            180,
            "eeprom_write",
            12,
            116,
            100,
            v11);
          return -2147483392;
        }
      }
      sleep(1u);
      return 0;
    }
    else
    {
      snprintf(v10, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed", "eeprom_write", a1);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_write",
        12,
        96,
        100,
        v11);
      return v14;
    }
  }
  else
  {
    snprintf(v10, 0x800u, "%s: Bad eeprom param, input chain is %d", "eeprom_write", a1);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_write",
      12,
      91,
      100,
      v11);
    return -2147483391;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F9E8: using guessed type _DWORD dword_15F9E8[32];
// 1608F0: using guessed type int g_zc;

//----- (0009CD24) --------------------------------------------------------
int __fastcall eeprom_read(unsigned int a1, char a2, int a3, unsigned int a4)
{
  char v10[2048]; // [sp+24h] [bp-1810h] BYREF
  char v11[16]; // [sp+824h] [bp-1010h] BYREF
  unsigned __int8 v12; // [sp+1827h] [bp-Dh] BYREF
  unsigned int i; // [sp+1828h] [bp-Ch]
  int v14; // [sp+182Ch] [bp-8h]

  v14 = 0;
  i = 0;
  if ( a1 <= 0xF )
  {
    if ( dword_15F9E8[2 * a1 + 1] || (v14 = eeprom_open(a1), v14 >= 0) )
    {
      strcpy(v10, "no use at24c512c!");
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_read",
        11,
        152,
        20,
        v11);
      for ( i = 0; a4 > i; ++i )
      {
        v12 = i + a2;
        v14 = iic_read_reg(dword_15F9E8[2 * a1], &v12, 1u, a3 + i, 1u);
        if ( v14 != 1 )
        {
          snprintf(v10, 0x800u, "fail to read eeprom by iic, chain: %d, addr: %d", a1, v12);
          V_LOCK();
          logfmt_raw(v11, 0x1000u, 0, v10);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
            180,
            "eeprom_read",
            11,
            158,
            100,
            v11);
          return -2147483392;
        }
      }
      usleep(0x7A120u);
      return 0;
    }
    else
    {
      snprintf(v10, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed", "eeprom_read", a1);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_read",
        11,
        136,
        100,
        v11);
      return v14;
    }
  }
  else
  {
    snprintf(v10, 0x800u, "%s: Bad eeprom param, input chain is %d", "eeprom_read", a1);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_read",
      11,
      131,
      100,
      v11);
    return -2147483391;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F9E8: using guessed type _DWORD dword_15F9E8[32];
// 1608F0: using guessed type int g_zc;

//----- (0009D164) --------------------------------------------------------
void sub_9D164()
{
  int v0; // [sp+0h] [bp-Ch]
  unsigned __int8 i; // [sp+7h] [bp-5h]

  if ( dword_15FA68 )
  {
    for ( i = 0; i < dword_15FAAC; ++i )
    {
      v0 = dword_15FA6C[i];
      if ( *(_DWORD *)(dword_15FA68 + 4 * v0) )
      {
        free(*(void **)(dword_15FA68 + 4 * v0));
        *(_DWORD *)(dword_15FA68 + 4 * v0) = 0;
      }
    }
    free((void *)dword_15FA68);
    dword_15FA68 = 0;
  }
}
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 15FAAC: using guessed type int dword_15FAAC;

//----- (0009D24C) --------------------------------------------------------
int sub_9D24C()
{
  int v0; // r4
  _DWORD v3[512]; // [sp+10h] [bp-1814h] BYREF
  char v4[20]; // [sp+810h] [bp-1014h] BYREF
  int v5; // [sp+1810h] [bp-14h]
  unsigned __int8 i; // [sp+1817h] [bp-Dh]

  if ( dword_15FA68 || (dword_15FA68 = (int)calloc(1u, 0x54u)) != 0 )
  {
    for ( i = 0; i < dword_15FAAC; ++i )
    {
      v5 = dword_15FA6C[i];
      if ( !*(_DWORD *)(dword_15FA68 + 4 * v5) )
      {
        v0 = dword_15FA68;
        *(_DWORD *)(v0 + 4 * v5) = calloc(1u, 0xCCu);
        if ( !*(_DWORD *)(dword_15FA68 + 4 * v5) )
        {
          snprintf((char *)v3, 0x800u, "No memory for configuraion for chain %d.", v5);
          V_LOCK();
          logfmt_raw(v4, 0x1000u, 0, v3);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
            180,
            "_alloc_memory",
            13,
            215,
            100,
            v4);
          goto LABEL_11;
        }
      }
    }
    return 0;
  }
  else
  {
    strcpy((char *)v3, "No memory for configuraion.");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "_alloc_memory",
      13,
      202,
      100,
      v4,
      v3[0],
      v3[1],
      v3[2],
      v3[3],
      v3[4],
      v3[5],
      v3[6]);
LABEL_11:
    sub_9D164();
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 15FAAC: using guessed type int dword_15FAAC;
// 1608F0: using guessed type int g_zc;

//----- (0009D4A8) --------------------------------------------------------
int __fastcall sub_9D4A8(_BYTE *a1, unsigned __int8 *a2)
{
  char v4[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  unsigned __int8 v6; // [sp+181Dh] [bp-7h]
  unsigned __int8 v7; // [sp+181Eh] [bp-6h]
  unsigned __int8 v8; // [sp+181Fh] [bp-5h]

  v7 = 0;
  v8 = 0;
  v6 = 0;
  v7 = BM_CRC5(a1, 8 * (a2[1] - 1));
  if ( a2[2] == 3 )
  {
    v8 = a2[60];
  }
  else if ( a2[2] == 4 )
  {
    v8 = a2[196];
  }
  if ( v7 == v8 )
  {
    return 1;
  }
  else
  {
    snprintf(v4, 0x800u, "Fixture CRC check fail. store_crc = 0x%x, len = 0x%x, crc = 0x%x\n", v8, a2[1], v7);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "_is_fixture_crc_pass",
      20,
      246,
      100,
      v5);
  }
  return v6;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009D664) --------------------------------------------------------
int __fastcall eeprom_verify_fixture_crc(_BYTE *a1, unsigned __int8 *a2)
{
  if ( sub_9D4A8(a1, a2) )
    return 0;
  else
    return -1;
}

//----- (0009D6A8) --------------------------------------------------------
int __fastcall sub_9D6A8(_BYTE *a1, char *a2)
{
  char v6[24]; // [sp+1Ch] [bp-1918h] BYREF
  char v7[24]; // [sp+81Ch] [bp-1118h] BYREF
  unsigned int s[64]; // [sp+181Ch] [bp-118h] BYREF
  int v9; // [sp+191Ch] [bp-18h]
  size_t v10; // [sp+1920h] [bp-14h]
  size_t n; // [sp+1924h] [bp-10h]
  int v12; // [sp+1928h] [bp-Ch]
  unsigned __int8 v13; // [sp+192Eh] [bp-6h]
  unsigned __int8 v14; // [sp+192Fh] [bp-5h]

  memset(s, 0, sizeof(s));
  v9 = 0;
  v10 = 0;
  n = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v14 = *a1 & 0xF;
  v13 = *a1 >> 4;
  v9 = (unsigned __int8)a1[1];
  v10 = 2;
  n = v9 - 2;
  v12 = v9;
  if ( v9 && (n & 0x80000000) == 0 )
  {
    if ( v14 == 1 && v13 == 1 )
    {
      memcpy(s, &a1[v10], n);
      data_dec(s, n, v13, v14);
      memcpy(a2, a1, v10);
      memcpy(&a2[v10], s, n);
      return 0;
    }
    else
    {
      snprintf(
        v6,
        0x800u,
        "EEPROM eeprom_key_version or eeprom_encryption_algorithm error! eeprom_key_version:%d, eeprom_encryption_algorithm:%d",
        v14,
        v13);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "decode_eeprom_fixture_info",
        26,
        285,
        100,
        v7,
        a2);
      return -1;
    }
  }
  else
  {
    snprintf(
      v6,
      0x800u,
      "EEPROM info error! fixture_len:%d, fixture_without_header_len:%d, fixture_actual_len:%d",
      v9,
      n,
      v12);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "decode_eeprom_fixture_info",
      26,
      279,
      100,
      v7,
      a2);
    return -1;
  }
}
// 9D7A4: conditional instruction was optimized away because %var_8.4<100u
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009D9AC) --------------------------------------------------------
int __fastcall sub_9D9AC(_BYTE *a1, char *a2)
{
  char v6[24]; // [sp+1Ch] [bp-1918h] BYREF
  char v7[24]; // [sp+81Ch] [bp-1118h] BYREF
  unsigned int s[64]; // [sp+181Ch] [bp-118h] BYREF
  int v9; // [sp+191Ch] [bp-18h]
  size_t v10; // [sp+1920h] [bp-14h]
  size_t n; // [sp+1924h] [bp-10h]
  int v12; // [sp+1928h] [bp-Ch]
  unsigned __int8 v13; // [sp+192Eh] [bp-6h]
  unsigned __int8 v14; // [sp+192Fh] [bp-5h]

  memset(s, 0, sizeof(s));
  v9 = 0;
  v10 = 0;
  n = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v14 = *a1 & 0xF;
  v13 = *a1 >> 4;
  v9 = (unsigned __int8)a1[1];
  v10 = 2;
  n = v9 - 2;
  v12 = v9;
  if ( v9 && (n & 0x80000000) == 0 )
  {
    if ( v14 == 1 && v13 == 1 )
    {
      memcpy(s, &a1[v10], n);
      data_enc(s, n, v13, v14);
      memcpy(a2, a1, v10);
      memcpy(&a2[v10], s, n);
      return 0;
    }
    else
    {
      snprintf(
        v6,
        0x800u,
        "EEPROM eeprom_key_version or eeprom_encryption_algorithm error! eeprom_key_version:%d, eeprom_encryption_algorithm:%d",
        v14,
        v13);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "encode_eeprom_fixture_info",
        26,
        326,
        100,
        v7,
        a2);
      return -1;
    }
  }
  else
  {
    snprintf(
      v6,
      0x800u,
      "EEPROM info error! fixture_len:%d, fixture_without_header_len:%d, fixture_actual_len:%d",
      v9,
      n,
      v12);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "encode_eeprom_fixture_info",
      26,
      320,
      100,
      v7,
      a2);
    return -1;
  }
}
// 9DAA8: conditional instruction was optimized away because %var_8.4<100u
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009DCB0) --------------------------------------------------------
int __fastcall eeprom_decode_fixture_info(_BYTE *a1, char *a2)
{
  return sub_9D6A8(a1, a2);
}

//----- (0009DCE0) --------------------------------------------------------
int __fastcall init_eeprom_fmt_info(_BYTE *a1, char a2)
{
  char v3[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v4[8]; // [sp+81Ch] [bp-1008h] BYREF
  unsigned __int8 v5; // [sp+181Fh] [bp-5h]

  v5 = 1;
  *a1 = 0;
  a1[1] = 1;
  a1[2] = 2;
  a1[3] = 3;
  a1[4] = 20;
  a1[5] = 22;
  a1[6] = 35;
  a1[7] = 36;
  a1[8] = 45;
  if ( a2 == 3 || a2 == 4 )
  {
    qmemcpy(a1 + 9, "MNRSTUVWXZ\\^`abcd", 17);
    a1[28] = 113;
    a1[29] = 114;
    a1[30] = 116;
    a1[31] = -12;
    a1[32] = -10;
    a1[33] = -7;
  }
  else
  {
    v5 = 0;
  }
  a1[34] = 1;
  a1[35] = 1;
  a1[36] = 1;
  a1[37] = 17;
  a1[38] = 2;
  a1[39] = 13;
  a1[40] = 1;
  a1[42] = 32;
  if ( a2 == 3 || a2 == 4 )
    a1[41] = 9;
  else
    v5 = 0;
  a1[43] = 1;
  a1[44] = 4;
  a1[45] = 1;
  a1[46] = 1;
  a1[47] = 1;
  a1[48] = 1;
  a1[49] = 1;
  a1[50] = 1;
  a1[51] = 2;
  a1[52] = 2;
  a1[53] = 2;
  a1[54] = 2;
  a1[55] = 1;
  a1[56] = 1;
  a1[57] = 1;
  a1[58] = 1;
  a1[59] = 8;
  a1[60] = 1;
  a1[61] = 2;
  a1[62] = 0x80;
  a1[63] = 2;
  a1[64] = 3;
  a1[65] = 1;
  if ( v5 != 1 )
  {
    strcpy(v3, "This FMT is not supported");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "init_eeprom_fmt_info",
      20,
      462,
      100,
      v4);
  }
  return v5;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009E348) --------------------------------------------------------
__int64 __fastcall eeprom_dump_fixture(int a1)
{
  char v3[4]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  snprintf(v3, 0x800u, "%-30s : 0x%04x", "key_version", *(_BYTE *)a1 & 0xF);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    469,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%04x", "algorithm_code", *(_BYTE *)a1 >> 4);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    470,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%04x", "fixture_info_len", *(unsigned __int8 *)(a1 + 1));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    471,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%04x", "fixture_standard", *(unsigned __int8 *)(a1 + 49));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    472,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%04x", "test_standard", *(unsigned __int8 *)(a1 + 50));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    473,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %s", "chip_technology", *(const char **)(a1 + 35));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    474,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%02x", "fixture_fmt_version", *(unsigned __int8 *)(a1 + 2));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    475,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %s", "SN", *(const char **)(a1 + 3));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    477,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%02x-%02x", "pcb", *(unsigned __int8 *)(a1 + 31), *(unsigned __int8 *)(a1 + 32));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    478,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%02x-%02x", "bom", *(unsigned __int8 *)(a1 + 33), *(unsigned __int8 *)(a1 + 34));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    479,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %u", "hash_board_voltage", *(unsigned __int16 *)(a1 + 39));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    480,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %u", "hash_board_freq", *(unsigned __int16 *)(a1 + 41));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    481,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %.2f", "nonce_response_rate", *(float *)(a1 + 43));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    482,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %u", "inlet_temperature", *(unsigned __int8 *)(a1 + 47));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    483,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %u", "outlet_temperature", *(unsigned __int8 *)(a1 + 48));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    484,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%02x-%02x", "asic sensor", *(_BYTE *)(a1 + 24) >> 7, *(_BYTE *)(a1 + 24) & 0x7F);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    485,
    100,
    v4);
  snprintf(
    v3,
    0x800u,
    "%-30s : 0x%02x-%02x-%02x-%02x",
    "asic sensor addr",
    **(unsigned __int8 **)(a1 + 25),
    *(unsigned __int8 *)(*(_DWORD *)(a1 + 25) + 1),
    *(unsigned __int8 *)(*(_DWORD *)(a1 + 25) + 2),
    *(unsigned __int8 *)(*(_DWORD *)(a1 + 25) + 3));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    486,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%02x-%02x", "pic sensor", *(_BYTE *)(a1 + 29) >> 7, *(_BYTE *)(a1 + 29) & 0x7F);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    487,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : 0x%02x", "pic sensor addr", *(unsigned __int8 *)(a1 + 30));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    488,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : bin%d", "chip_bin", *(unsigned __int8 *)(a1 + 15));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    489,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %s", "FT", *(const char **)(a1 + 16));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    490,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %s", "chip_die", *(const char **)(a1 + 7));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    491,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : %s", "chip_marking", *(const char **)(a1 + 11));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_dump_fixture",
    19,
    492,
    100,
    v4);
  snprintf(v3, 0x800u, "%-30s : P%d", "phy_seq_level", *(unsigned __int8 *)(a1 + 55));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
           180,
           "eeprom_dump_fixture",
           19,
           493,
           100,
           v4);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (0009F374) --------------------------------------------------------
int __fastcall sub_9F374(_BYTE *a1, int a2)
{
  float v3; // s15
  char v7[2048]; // [sp+1Ch] [bp-1860h] BYREF
  char v8[32]; // [sp+81Ch] [bp-1060h] BYREF
  _BYTE dest[18]; // [sp+181Ch] [bp-60h] BYREF
  unsigned __int16 v10; // [sp+182Eh] [bp-4Eh] BYREF
  unsigned __int16 v11; // [sp+1830h] [bp-4Ch] BYREF
  unsigned __int16 v12; // [sp+1832h] [bp-4Ah] BYREF
  _BYTE v13[7]; // [sp+1834h] [bp-48h] BYREF
  unsigned __int8 v14; // [sp+183Bh] [bp-41h]
  unsigned __int8 v15; // [sp+183Dh] [bp-3Fh]
  unsigned __int8 v16; // [sp+183Eh] [bp-3Eh]
  unsigned __int8 v17; // [sp+183Fh] [bp-3Dh]
  unsigned __int8 v18; // [sp+1840h] [bp-3Ch]
  unsigned __int8 v19; // [sp+1841h] [bp-3Bh]
  unsigned __int8 v20; // [sp+1842h] [bp-3Ah]
  unsigned __int8 v21; // [sp+1843h] [bp-39h]
  unsigned __int8 v22; // [sp+1844h] [bp-38h]
  unsigned __int8 v23; // [sp+1845h] [bp-37h]
  unsigned __int8 v24; // [sp+1846h] [bp-36h]
  unsigned __int8 v25; // [sp+1847h] [bp-35h]
  unsigned __int8 v26; // [sp+1848h] [bp-34h]
  unsigned __int8 v27; // [sp+1849h] [bp-33h]
  unsigned __int8 v28; // [sp+184Ah] [bp-32h]
  unsigned __int8 v29; // [sp+184Bh] [bp-31h]
  unsigned __int8 v30; // [sp+184Ch] [bp-30h]
  unsigned __int8 v31; // [sp+184Dh] [bp-2Fh]
  unsigned __int8 v32; // [sp+184Eh] [bp-2Eh]
  unsigned __int8 v33; // [sp+1850h] [bp-2Ch]
  unsigned __int8 v34; // [sp+1851h] [bp-2Bh]
  unsigned __int8 v35; // [sp+1852h] [bp-2Ah]
  unsigned __int8 v36; // [sp+1853h] [bp-29h]
  unsigned __int8 v37; // [sp+1855h] [bp-27h]
  unsigned __int8 n; // [sp+1859h] [bp-23h]
  unsigned __int8 n_1; // [sp+185Ah] [bp-22h]
  unsigned __int8 n_2; // [sp+185Bh] [bp-21h]
  unsigned __int8 v41; // [sp+185Dh] [bp-1Fh]
  unsigned __int8 v42; // [sp+1860h] [bp-1Ch]
  unsigned __int8 v43; // [sp+1867h] [bp-15h]
  unsigned __int8 v44; // [sp+1868h] [bp-14h]
  unsigned __int8 v45; // [sp+1869h] [bp-13h]
  unsigned __int8 v46; // [sp+186Ah] [bp-12h]
  unsigned __int8 v47; // [sp+186Fh] [bp-Dh]
  unsigned __int8 v48; // [sp+1871h] [bp-Bh]
  unsigned __int8 v49; // [sp+1872h] [bp-Ah]
  size_t v50; // [sp+1873h] [bp-9h]
  unsigned __int8 v51; // [sp+1877h] [bp-5h]

  v51 = 1;
  *(_BYTE *)a2 = *(_BYTE *)a2 & 0xF | (16 * ((*a1 >> 4) & 0xF));
  *(_BYTE *)a2 = *(_BYTE *)a2 & 0xF0 | *a1 & 0xF;
  *(_BYTE *)(a2 + 1) = a1[1];
  *(_BYTE *)(a2 + 2) = a1[2];
  if ( (unsigned __int8)init_eeprom_fmt_info(v13, *(_BYTE *)(a2 + 2)) != 1 )
  {
    v51 = 0;
    return 0;
  }
  else
  {
    *(_DWORD *)(a2 + 3) = calloc(n + 1, 1u);
    if ( !*(_DWORD *)(a2 + 3) )
    {
      strcpy(v7, "Decode SN OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_buf_to_layout",
        20,
        523,
        100,
        v8);
      v51 = 0;
    }
    memcpy(*(void **)(a2 + 3), &a1[v13[3]], n);
    *(_DWORD *)(a2 + 7) = calloc(n_1 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 7) )
    {
      strcpy(v7, "Decode Chip Die OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_buf_to_layout",
        20,
        532,
        100,
        v8);
      v51 = 0;
    }
    memcpy(*(void **)(a2 + 7), &a1[v13[4]], n_1);
    *(_DWORD *)(a2 + 11) = calloc(n_2 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 11) )
    {
      strcpy(v7, "Decode Chip Marking OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_buf_to_layout",
        20,
        541,
        100,
        v8);
      v51 = 0;
    }
    memcpy(*(void **)(a2 + 11), &a1[v13[5]], n_2);
    *(_BYTE *)(a2 + 15) = a1[v13[6]];
    if ( *(_BYTE *)(a2 + 2) == 1 || *(_BYTE *)(a2 + 2) == 2 )
    {
      memset(dest, 0, 16);
      *(_DWORD *)(a2 + 16) = calloc(v41 + 6, 1u);
      if ( !*(_DWORD *)(a2 + 16) )
      {
        strcpy(v7, "Decode Chip FT Program Version OOM");
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
          180,
          "eeprom_buf_to_layout",
          20,
          556,
          100,
          v8);
        v51 = 0;
      }
      memcpy(dest, &a1[v14], v41);
      snprintf(*(char **)(a2 + 16), v41 + 6, "F%dV%02dB%dC%d", dest[0], dest[1], dest[2], dest[3]);
    }
    else
    {
      *(_DWORD *)(a2 + 16) = calloc(v41 + 1, 1u);
      if ( !*(_DWORD *)(a2 + 16) )
      {
        strcpy(v7, "Decode Chip FT Program Version OOM");
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
          180,
          "eeprom_buf_to_layout",
          20,
          567,
          100,
          v8);
        v51 = 0;
      }
      memcpy(*(void **)(a2 + 16), &a1[v14], v41);
    }
    *(_BYTE *)(a2 + 24) = *(_BYTE *)(a2 + 24) & 0x80 | a1[v15] & 0x7F;
    *(_BYTE *)(a2 + 24) = *(_BYTE *)(a2 + 24) & 0x7F | (a1[v15] >> 7 << 7);
    *(_DWORD *)(a2 + 25) = calloc(v42 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 25) )
    {
      strcpy(v7, "Decode Chip FT Program Version OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_buf_to_layout",
        20,
        581,
        100,
        v8);
      v51 = 0;
    }
    memcpy(*(void **)(a2 + 25), &a1[v16], v42);
    *(_BYTE *)(a2 + 29) = *(_BYTE *)(a2 + 29) & 0x80 | a1[v17] & 0x7F;
    *(_BYTE *)(a2 + 29) = *(_BYTE *)(a2 + 29) & 0x7F | (a1[v17] >> 7 << 7);
    *(_BYTE *)(a2 + 30) = a1[v18];
    *(_BYTE *)(a2 + 31) = a1[v19];
    *(_BYTE *)(a2 + 32) = a1[v20];
    *(_BYTE *)(a2 + 33) = a1[v21];
    *(_BYTE *)(a2 + 34) = a1[v22];
    *(_DWORD *)(a2 + 35) = calloc(v43 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 35) )
    {
      strcpy(v7, "Decode Chip Technology OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_buf_to_layout",
        20,
        605,
        100,
        v8);
      v51 = 0;
    }
    memcpy(*(void **)(a2 + 35), &a1[v23], v43);
    memcpy(&v12, &a1[v24], v44);
    *(_WORD *)(a2 + 39) = (v12 << 8) | HIBYTE(v12);
    memcpy(&v11, &a1[v25], v45);
    *(_WORD *)(a2 + 41) = (v11 << 8) | HIBYTE(v11);
    memcpy(&v10, &a1[v26], v46);
    v3 = (double)((unsigned __int16)(v10 << 8) | (unsigned int)HIBYTE(v10)) / 100.0;
    *(float *)(a2 + 43) = v3;
    *(_BYTE *)(a2 + 47) = a1[v27];
    *(_BYTE *)(a2 + 48) = a1[v28];
    *(_BYTE *)(a2 + 49) = a1[v29];
    *(_BYTE *)(a2 + 50) = a1[v30];
    *(_DWORD *)(a2 + 51) = calloc(v47 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 51) )
    {
      strcpy(v7, "Decode miner_type OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_buf_to_layout",
        20,
        641,
        100,
        v8);
      v51 = 0;
    }
    memcpy(*(void **)(a2 + 51), &a1[v31], v47);
    *(_BYTE *)(a2 + 55) = a1[v32];
    *(_BYTE *)(a2 + 60) = a1[v33];
    if ( *(_BYTE *)(a2 + 2) == 4 )
    {
      memcpy((void *)(a2 + 61), &a1[v34], v48);
      memcpy((void *)(a2 + 63), &a1[v35], v49);
      memcpy((void *)(a2 + 191), &a1[v36], (unsigned __int8)v50);
      *(_BYTE *)(a2 + 196) = a1[v37];
    }
    return v51;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A03D0) --------------------------------------------------------
int __fastcall eeprom_trans_raw2layout(_BYTE *a1, int a2)
{
  if ( sub_9F374(a1, a2) )
    return 0;
  else
    return -1;
}

//----- (000A0414) --------------------------------------------------------
int __fastcall sub_A0414(_BYTE *a1, int a2)
{
  _BYTE *v3; // r4
  char v7[40]; // [sp+1Ch] [bp-1868h] BYREF
  char v8[40]; // [sp+81Ch] [bp-1068h] BYREF
  _BYTE src[18]; // [sp+181Ch] [bp-68h] BYREF
  __int16 v10; // [sp+182Eh] [bp-56h] BYREF
  __int16 v11; // [sp+1830h] [bp-54h] BYREF
  __int16 v12; // [sp+1832h] [bp-52h] BYREF
  _BYTE v13[7]; // [sp+1834h] [bp-50h] BYREF
  unsigned __int8 v14; // [sp+183Bh] [bp-49h]
  unsigned __int8 v15; // [sp+183Dh] [bp-47h]
  unsigned __int8 v16; // [sp+183Eh] [bp-46h]
  unsigned __int8 v17; // [sp+183Fh] [bp-45h]
  unsigned __int8 v18; // [sp+1840h] [bp-44h]
  unsigned __int8 v19; // [sp+1841h] [bp-43h]
  unsigned __int8 v20; // [sp+1842h] [bp-42h]
  unsigned __int8 v21; // [sp+1843h] [bp-41h]
  unsigned __int8 v22; // [sp+1844h] [bp-40h]
  unsigned __int8 v23; // [sp+1845h] [bp-3Fh]
  unsigned __int8 v24; // [sp+1846h] [bp-3Eh]
  unsigned __int8 v25; // [sp+1847h] [bp-3Dh]
  unsigned __int8 v26; // [sp+1848h] [bp-3Ch]
  unsigned __int8 v27; // [sp+1849h] [bp-3Bh]
  unsigned __int8 v28; // [sp+184Ah] [bp-3Ah]
  unsigned __int8 v29; // [sp+184Bh] [bp-39h]
  unsigned __int8 v30; // [sp+184Ch] [bp-38h]
  unsigned __int8 v31; // [sp+184Dh] [bp-37h]
  unsigned __int8 v32; // [sp+184Eh] [bp-36h]
  unsigned __int8 v33; // [sp+1850h] [bp-34h]
  unsigned __int8 n; // [sp+1859h] [bp-2Bh]
  unsigned __int8 n_1; // [sp+185Ah] [bp-2Ah]
  unsigned __int8 n_2; // [sp+185Bh] [bp-29h]
  unsigned __int8 v37; // [sp+185Dh] [bp-27h]
  unsigned __int8 v38; // [sp+1860h] [bp-24h]
  unsigned __int8 v39; // [sp+1867h] [bp-1Dh]
  unsigned __int8 v40; // [sp+1868h] [bp-1Ch]
  unsigned __int8 v41; // [sp+1869h] [bp-1Bh]
  unsigned __int8 v42; // [sp+186Ah] [bp-1Ah]
  size_t v43; // [sp+186Fh] [bp-15h]
  unsigned __int8 v44; // [sp+1877h] [bp-Dh]

  v44 = 1;
  *a1 = (16 * (*(_BYTE *)a2 >> 4)) | *(_BYTE *)a2 & 0xF;
  a1[1] = *(_BYTE *)(a2 + 1);
  a1[2] = *(_BYTE *)(a2 + 2);
  if ( (unsigned __int8)init_eeprom_fmt_info(v13, *(_BYTE *)(a2 + 2)) != 1 )
  {
    v44 = 0;
    return 0;
  }
  else
  {
    if ( !*(_DWORD *)(a2 + 3) )
    {
      strcpy(v7, "encode serial_number OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_layout_to_buf",
        20,
        693,
        100,
        v8);
      v44 = 0;
    }
    memcpy(&a1[v13[3]], *(const void **)(a2 + 3), n);
    if ( !*(_DWORD *)(a2 + 7) )
    {
      strcpy(v7, "encode chip_die OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_layout_to_buf",
        20,
        700,
        100,
        v8);
      v44 = 0;
    }
    memcpy(&a1[v13[4]], *(const void **)(a2 + 7), n_1);
    if ( !*(_DWORD *)(a2 + 11) )
    {
      strcpy(v7, "encode chip_marking OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_layout_to_buf",
        20,
        707,
        100,
        v8);
      v44 = 0;
    }
    memcpy(&a1[v13[5]], *(const void **)(a2 + 11), n_2);
    a1[v13[6]] = *(_BYTE *)(a2 + 15);
    if ( !*(_DWORD *)(a2 + 16) )
    {
      strcpy(v7, "encode Chip FT Program Version OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_layout_to_buf",
        20,
        717,
        100,
        v8);
      v44 = 0;
    }
    if ( *(_BYTE *)(a2 + 2) == 1 || *(_BYTE *)(a2 + 2) == 2 )
    {
      memset(src, 0, 16);
      _isoc99_sscanf(*(_DWORD *)(a2 + 16), "F%dV%02dB%dC%d", src, &src[1], &src[2], &src[3]);
      memcpy(&a1[v14], src, v37);
    }
    else
    {
      memcpy(&a1[v14], *(const void **)(a2 + 16), v37);
    }
    a1[v15] = (*(_BYTE *)(a2 + 24) >> 7 << 7) | *(_BYTE *)(a2 + 24) & 0x7F;
    if ( !*(_DWORD *)(a2 + 25) )
    {
      strcpy(v7, "Decode asic_sensor_addr OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_layout_to_buf",
        20,
        737,
        100,
        v8);
      v44 = 0;
    }
    memcpy(&a1[v16], *(const void **)(a2 + 25), v38);
    a1[v17] = (*(_BYTE *)(a2 + 29) >> 7 << 7) | *(_BYTE *)(a2 + 29) & 0x7F;
    a1[v18] = *(_BYTE *)(a2 + 30);
    a1[v19] = *(_BYTE *)(a2 + 31);
    a1[v20] = *(_BYTE *)(a2 + 32);
    a1[v21] = *(_BYTE *)(a2 + 33);
    a1[v22] = *(_BYTE *)(a2 + 34);
    if ( !*(_DWORD *)(a2 + 35) )
    {
      strcpy(v7, "Decode Chip Technology OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_layout_to_buf",
        20,
        759,
        100,
        v8);
      v44 = 0;
    }
    memcpy(&a1[v23], *(const void **)(a2 + 35), v39);
    v12 = (*(_WORD *)(a2 + 39) << 8) | HIBYTE(*(_WORD *)(a2 + 39));
    memcpy(&a1[v24], &v12, v40);
    v11 = (*(_WORD *)(a2 + 41) << 8) | HIBYTE(*(_WORD *)(a2 + 41));
    memcpy(&a1[v25], &v11, v41);
    v10 = (unsigned int)(float)(*(float *)(a2 + 43) * 100.0);
    memcpy(&a1[v26], &v10, v42);
    a1[v27] = *(_BYTE *)(a2 + 47);
    a1[v28] = *(_BYTE *)(a2 + 48);
    a1[v29] = *(_BYTE *)(a2 + 49);
    a1[v30] = *(_BYTE *)(a2 + 50);
    if ( !*(_DWORD *)(a2 + 51) )
    {
      strcpy(v7, "Decode miner_type OOM");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_layout_to_buf",
        20,
        791,
        100,
        v8);
      v44 = 0;
    }
    memcpy(&a1[v31], *(const void **)(a2 + 51), (unsigned __int8)v43);
    a1[v32] = *(_BYTE *)(a2 + 55);
    v3 = &a1[v33];
    *v3 = BM_CRC5(a1, 8 * (*(unsigned __int8 *)(a2 + 1) - 1));
    return v44;
  }
}
// 1D24C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A1114) --------------------------------------------------------
_DWORD *__fastcall add_eeprom_device(int a1)
{
  int v1; // r2

  v1 = dword_15FAAC++;
  dword_15FA6C[v1] = a1;
  return dword_15FA6C;
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 15FAAC: using guessed type int dword_15FAAC;

//----- (000A1164) --------------------------------------------------------
int __fastcall eeprom_load_one_chain(unsigned int a1, int a2)
{
  char v6[16]; // [sp+1Ch] [bp-1A10h] BYREF
  char v7[16]; // [sp+81Ch] [bp-1210h] BYREF
  char v8[256]; // [sp+181Ch] [bp-210h] BYREF
  _BYTE s[256]; // [sp+191Ch] [bp-110h] BYREF
  unsigned __int8 *v10; // [sp+1A1Ch] [bp-10h]
  int v11; // [sp+1A20h] [bp-Ch]
  int v12; // [sp+1A24h] [bp-8h]

  v11 = 0;
  v12 = 3;
  memset(s, 0, sizeof(s));
  memset(v8, 0, sizeof(v8));
  v10 = *(unsigned __int8 **)(a2 + 4 * a1);
  do
  {
    v11 = eeprom_read(a1, 0, (int)s, 0x100u);
    if ( v11 )
    {
      snprintf(v6, 0x800u, "Read configuration fail for chain %d.", a1);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_load_one_chain",
        21,
        822,
        100,
        v7);
      return v11;
    }
    if ( !sub_9D6A8(s, v8) )
      break;
    snprintf(v6, 0x800u, "Data decode fail for chain %d.", a1);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_load_one_chain",
      21,
      836,
      100,
      v7);
    usleep(0x7A120u);
    --v12;
  }
  while ( v12 );
  if ( v12 && sub_9F374(v8, (int)v10) && sub_9D4A8(v8, v10) )
  {
    *(_BYTE *)(a2 + a1 + 64) = 1;
  }
  else
  {
    *(_BYTE *)(a2 + a1 + 64) = 0;
    snprintf(v6, 0x800u, "Data load fail for chain %d.", a1);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_load_one_chain",
      21,
      853,
      100,
      v7);
    return -1;
  }
  return v11;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A14F8) --------------------------------------------------------
int __fastcall eeprom_rewrite_one_chain(unsigned int a1, int a2, int a3, int a4)
{
  char v10[16]; // [sp+24h] [bp-1B10h] BYREF
  char v11[16]; // [sp+824h] [bp-1310h] BYREF
  char v12[256]; // [sp+1824h] [bp-310h] BYREF
  char v13[256]; // [sp+1924h] [bp-210h] BYREF
  _BYTE s[256]; // [sp+1A24h] [bp-110h] BYREF
  unsigned __int8 *v15; // [sp+1B24h] [bp-10h]
  int v16; // [sp+1B28h] [bp-Ch]
  int v17; // [sp+1B2Ch] [bp-8h]

  v16 = 0;
  v17 = 3;
  memset(s, 0, sizeof(s));
  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  v15 = *(unsigned __int8 **)(a2 + 4 * a1);
  do
  {
    v16 = eeprom_read(a1, 0, (int)s, 0x100u);
    if ( v16 )
    {
      snprintf(v10, 0x800u, "Read configuration fail for chain %d.", a1);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_rewrite_one_chain",
        24,
        874,
        100,
        v11);
      return v16;
    }
    if ( !sub_9D6A8(s, v13) )
      break;
    snprintf(v10, 0x800u, "Data decode fail for chain %d.", a1);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_rewrite_one_chain",
      24,
      888,
      100,
      v11);
    usleep(0x7A120u);
    --v17;
  }
  while ( v17 );
  if ( !v17 || !sub_9F374(v13, (int)v15) || !sub_9D4A8(v13, v15) )
  {
    *(_BYTE *)(a2 + a1 + 64) = 0;
    snprintf(v10, 0x800u, "Data load fail for chain %d.", a1);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_rewrite_one_chain",
      24,
      905,
      100,
      v11);
    return -1;
  }
  *(_BYTE *)(a2 + a1 + 64) = 1;
  snprintf(
    v10,
    0x800u,
    "chain[%d], modify voltage from %d to %d, freq from %d to %d",
    a1,
    *(unsigned __int16 *)(v15 + 39),
    *(unsigned __int16 *)(v15 + 39) + a3,
    *(unsigned __int16 *)(v15 + 41),
    *(unsigned __int16 *)(v15 + 41) + a4);
  V_LOCK();
  logfmt_raw(v11, 0x1000u, 0, v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "eeprom_rewrite_one_chain",
    24,
    911,
    100,
    v11);
  *(_WORD *)(v15 + 39) += a3;
  *(_WORD *)(v15 + 41) += a4;
  sub_A0414(v13, (int)v15);
  if ( sub_9D9AC(v13, v12) )
    return -1;
  v17 = 3;
  while ( 1 )
  {
    eeprom_write(a1, 0, (int)v12, v15[1]);
    memset(s, 0, sizeof(s));
    v16 = eeprom_read(a1, 0, (int)s, 0x100u);
    if ( !v16 )
      break;
    snprintf(v10, 0x800u, "Read configuration fail for chain %d.", a1);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_rewrite_one_chain",
      24,
      929,
      100,
      v11);
LABEL_21:
    if ( !--v17 )
      return v16;
  }
  if ( sub_9D6A8(s, v13) )
  {
    snprintf(v10, 0x800u, "Data decode fail for chain %d.", a1);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_rewrite_one_chain",
      24,
      943,
      100,
      v11);
    usleep(0x7A120u);
    goto LABEL_21;
  }
  if ( !sub_9F374(v13, (int)v15) || !sub_9D4A8(v13, v15) )
  {
    *(_BYTE *)(a2 + a1 + 64) = 0;
    v16 = -1;
    snprintf(v10, 0x800u, "Data load fail for chain %d.", a1);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_rewrite_one_chain",
      24,
      958,
      100,
      v11);
    goto LABEL_21;
  }
  *(_BYTE *)(a2 + a1 + 64) = 1;
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A1D98) --------------------------------------------------------
int __fastcall eeprom_vol_freq_override(int a1, int a2)
{
  int v6; // [sp+1008h] [bp-Ch]
  unsigned __int8 i; // [sp+100Fh] [bp-5h]

  v6 = 0;
  if ( !dword_15FA68 && sub_9D24C() )
    return -1;
  for ( i = 0; i < dword_15FAAC; ++i )
    v6 |= eeprom_rewrite_one_chain(dword_15FA6C[i], dword_15FA68, a1, a2);
  if ( !v6 )
    *(_BYTE *)(dword_15FA68 + 80) = 1;
  return v6;
}
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 15FAAC: using guessed type int dword_15FAAC;

//----- (000A1EA0) --------------------------------------------------------
int eeprom_load()
{
  int v2; // [sp+1000h] [bp-Ch]
  unsigned __int8 i; // [sp+1007h] [bp-5h]

  v2 = 0;
  if ( dword_15FA68 )
  {
    if ( *(_BYTE *)(dword_15FA68 + 80) )
      return 0;
  }
  else if ( sub_9D24C() )
  {
    return -1;
  }
  for ( i = 0; i < dword_15FAAC; ++i )
    v2 |= eeprom_load_one_chain(dword_15FA6C[i], dword_15FA68);
  if ( !v2 )
    *(_BYTE *)(dword_15FA68 + 80) = 1;
  return v2;
}
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 15FAAC: using guessed type int dword_15FAAC;

//----- (000A1FA0) --------------------------------------------------------
int __fastcall eeprom_get_voltage(int a1, _DWORD *a2)
{
  char v4[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v6; // [sp+181Ch] [bp-8h]

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    v6 = *(unsigned __int16 *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 39);
    if ( a2 )
    {
      *a2 = v6;
      return 0;
    }
    else
    {
      strcpy(v4, "voltage level not match");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_get_voltage",
        18,
        1044,
        100,
        v5);
      return -2;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "No work mode voltage, chain = %d.", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_get_voltage",
      18,
      1033,
      100,
      v5);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A21A8) --------------------------------------------------------
int eeprom_get_max_voltage()
{
  char v2[12]; // [sp+10h] [bp-180Ch] BYREF
  char v3[12]; // [sp+810h] [bp-100Ch] BYREF
  int v4; // [sp+1810h] [bp-Ch]
  int i; // [sp+1814h] [bp-8h]

  v4 = 0;
  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    for ( i = 0; i < dword_15FAAC; ++i )
    {
      if ( v4 < *(unsigned __int16 *)(*(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[i]) + 39) )
        v4 = *(unsigned __int16 *)(*(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[i]) + 39);
    }
    return v4;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: eeprom is not ready", "eeprom_get_max_voltage");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_get_max_voltage",
      22,
      1054,
      100,
      v3);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 15FAAC: using guessed type int dword_15FAAC;
// 1608F0: using guessed type int g_zc;

//----- (000A2334) --------------------------------------------------------
int __fastcall eeprom_get_PT2_freq(int a1, _DWORD *a2)
{
  char v4[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v6; // [sp+181Ch] [bp-8h]

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    v6 = *(unsigned __int16 *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 41);
    if ( a2 )
    {
      *a2 = v6;
      return 0;
    }
    else
    {
      strcpy(v4, "freq level not match");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "eeprom_get_PT2_freq",
        19,
        1083,
        100,
        v5);
      return -2;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "No work mode freq, chain = %d.", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_get_PT2_freq",
      19,
      1072,
      100,
      v5);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A2544) --------------------------------------------------------
int eeprom_get_min_freq()
{
  char v2[12]; // [sp+10h] [bp-180Ch] BYREF
  char v3[12]; // [sp+810h] [bp-100Ch] BYREF
  int v4; // [sp+1810h] [bp-Ch]
  int i; // [sp+1814h] [bp-8h]

  v4 = 0xFFFF;
  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    for ( i = 0; i < dword_15FAAC; ++i )
    {
      if ( v4 > *(unsigned __int16 *)(*(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[i]) + 41) )
        v4 = *(unsigned __int16 *)(*(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[i]) + 41);
    }
    return v4;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: g_eeprom_data is not ready", "eeprom_get_min_freq");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_get_min_freq",
      19,
      1093,
      100,
      v3);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 15FAAC: using guessed type int dword_15FAAC;
// 1608F0: using guessed type int g_zc;

//----- (000A26D0) --------------------------------------------------------
int __fastcall eeprom_get_fmt_version(int a1, _BYTE *a2)
{
  char v4[4]; // [sp+18h] [bp-1804h] BYREF
  char v5[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    *a2 = *(_BYTE *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 2);
    return 0;
  }
  else
  {
    snprintf(v4, 0x800u, "%s: g_eeprom_data is not ready", "eeprom_get_fmt_version");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "eeprom_get_fmt_version",
      22,
      1109,
      100,
      v5);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A27F8) --------------------------------------------------------
int is_eeprom_loaded()
{
  char v2[4]; // [sp+10h] [bp-1804h] BYREF
  char v3[4]; // [sp+810h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
    return *(unsigned __int8 *)(dword_15FA68 + 80);
  snprintf(v2, 0x800u, "%s: g_eeprom_data is not ready", "is_eeprom_loaded");
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "is_eeprom_loaded",
    16,
    1121,
    20,
    v3);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A28E4) --------------------------------------------------------
int __fastcall sub_A28E4(int a1)
{
  char v3[4]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
    return *(_DWORD *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 11);
  snprintf(v3, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.", "get_chip_marking", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "get_chip_marking",
    16,
    1145,
    100,
    v4);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A29FC) --------------------------------------------------------
int __fastcall sub_A29FC(int a1)
{
  char v3[4]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 15);
  snprintf(v3, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.", "get_chip_bin", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "get_chip_bin",
    12,
    1155,
    100,
    v4);
  return 255;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A2B14) --------------------------------------------------------
int __fastcall sub_A2B14(int a1)
{
  char v3[4]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
    return *(_DWORD *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 16);
  snprintf(v3, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.", "get_chip_ft", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "get_chip_ft",
    11,
    1165,
    100,
    v4);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A2C2C) --------------------------------------------------------
int __fastcall sub_A2C2C(int a1)
{
  char v3[4]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 50);
  snprintf(v3, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.", "get_test_standard_code", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "get_test_standard_code",
    22,
    1175,
    100,
    v4);
  return 255;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A2D44) --------------------------------------------------------
int __fastcall sub_A2D44(int a1)
{
  char v3[4]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
    return *(_DWORD *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 3);
  snprintf(v3, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.", "get_chip_sn", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "get_chip_sn",
    11,
    1185,
    100,
    v4);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A2E5C) --------------------------------------------------------
int __fastcall sub_A2E5C(int a1, char *a2)
{
  char v4[4]; // [sp+18h] [bp-1804h] BYREF
  char v5[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    sprintf(
      a2,
      "%x%02x",
      *(unsigned __int8 *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 31),
      *(unsigned __int8 *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 32));
    return 0;
  }
  else
  {
    snprintf(v4, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.", "get_pcb_version", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "get_pcb_version",
      15,
      1195,
      100,
      v5);
    return 255;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A2FD0) --------------------------------------------------------
int __fastcall sub_A2FD0(int a1, char *a2)
{
  char v4[4]; // [sp+18h] [bp-1804h] BYREF
  char v5[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    sprintf(
      a2,
      "%x%x",
      *(unsigned __int8 *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 33),
      *(unsigned __int8 *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 34));
    return 0;
  }
  else
  {
    snprintf(v4, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.", "get_bom_version", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "get_bom_version",
      15,
      1206,
      100,
      v5);
    return 255;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A3144) --------------------------------------------------------
int __fastcall sub_A3144(int a1, void *a2)
{
  size_t v2; // r0
  char v6[12]; // [sp+18h] [bp-180Ch] BYREF
  char v7[12]; // [sp+818h] [bp-100Ch] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    v2 = strlen(*(const char **)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 51));
    memcpy(a2, *(const void **)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 51), v2);
  }
  else
  {
    snprintf(v6, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.", "get_miner_type", a1);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "get_miner_type",
      14,
      1218,
      100,
      v7,
      a2);
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A32AC) --------------------------------------------------------
int __fastcall sub_A32AC(int a1)
{
  char v3[4]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_15FA68 + 4 * a1) + 55);
  snprintf(v3, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.", "get_phy_seq_level", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "get_phy_seq_level",
    17,
    1230,
    100,
    v4);
  return 255;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 1608F0: using guessed type int g_zc;

//----- (000A33C4) --------------------------------------------------------
int __fastcall api_get_eeprom_nonce_response_rate(int a1, _DWORD *a2)
{
  char v4[4]; // [sp+18h] [bp-1804h] BYREF
  char v5[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    if ( a2 )
    {
      *a2 = *(_DWORD *)(*(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[a1]) + 43);
      return 0;
    }
    else
    {
      snprintf(
        v4,
        0x800u,
        "%s: chain = %d nonce response rate in eeprom is invalid",
        "api_get_eeprom_nonce_response_rate",
        dword_15FA6C[a1]);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "api_get_eeprom_nonce_response_rate",
        34,
        1249,
        100,
        v5);
      return -2;
    }
  }
  else
  {
    snprintf(
      v4,
      0x800u,
      "%s: g_eeprom_data is not ready, chain = %d.",
      "api_get_eeprom_nonce_response_rate",
      dword_15FA6C[a1]);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "api_get_eeprom_nonce_response_rate",
      34,
      1240,
      100,
      v5);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 1608F0: using guessed type int g_zc;

//----- (000A35D8) --------------------------------------------------------
int __fastcall api_get_eeprom_PT2_freq(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  v2 = 0;
  eeprom_get_PT2_freq(dword_15FA6C[a1], &v2);
  return v2;
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A3624) --------------------------------------------------------
int __fastcall api_get_eeprom_sweep_freq(int a1)
{
  char v4[4]; // [sp+18h] [bp-1804h] BYREF
  char v5[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    V_LOCK();
    logfmt_raw(
      v5,
      0x1000u,
      0,
      "get eeprom sweep freq: %hu",
      *(unsigned __int16 *)(*(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[a1]) + 191));
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "api_get_eeprom_sweep_freq",
      25,
      1270,
      20,
      v5);
    return *(__int16 *)(*(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[a1]) + 191);
  }
  else
  {
    snprintf(v4, 0x800u, "%s: g_eeprom_data is not ready", "api_get_eeprom_sweep_freq");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "api_get_eeprom_sweep_freq",
      25,
      1265,
      20,
      v5);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "get eeprom sweep freq fail");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "api_get_eeprom_sweep_freq",
      25,
      1266,
      60,
      v5);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 1608F0: using guessed type int g_zc;

//----- (000A384C) --------------------------------------------------------
int __fastcall api_get_eeprom_voltage(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  v2 = 0;
  eeprom_get_voltage(dword_15FA6C[a1], &v2);
  return v2;
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A3898) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_marking(int a1)
{
  return sub_A28E4(dword_15FA6C[a1]);
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A38D0) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_bin(int a1)
{
  return sub_A29FC(dword_15FA6C[a1]);
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A3908) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_ft(int a1)
{
  return sub_A2B14(dword_15FA6C[a1]);
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A3940) --------------------------------------------------------
int __fastcall api_get_eeprom_test_standard_code(int a1)
{
  return sub_A2C2C(dword_15FA6C[a1]);
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A3978) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_sn(int a1)
{
  return sub_A2D44(dword_15FA6C[a1]);
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A39B0) --------------------------------------------------------
int __fastcall api_get_eeprom_miner_type(int a1, void *a2)
{
  return sub_A3144(dword_15FA6C[a1], a2);
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A39F0) --------------------------------------------------------
int __fastcall api_get_eeprom_chain_load_state(int a1)
{
  char v3[4]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_15FA68 )
    return *(unsigned __int8 *)(dword_15FA68 + dword_15FA6C[a1] + 64);
  snprintf(
    v3,
    0x800u,
    "%s: g_eeprom_data is not ready, chain = %d.",
    "api_get_eeprom_chain_load_state",
    dword_15FA6C[a1]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
    180,
    "api_get_eeprom_chain_load_state",
    31,
    1329,
    100,
    v4);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 1608F0: using guessed type int g_zc;

//----- (000A3B08) --------------------------------------------------------
int __fastcall api_get_eeprom_pcb_version(int a1, char *a2)
{
  return sub_A2E5C(dword_15FA6C[a1], a2);
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A3B48) --------------------------------------------------------
int __fastcall api_get_eeprom_bom_version(int a1, char *a2)
{
  return sub_A2FD0(dword_15FA6C[a1], a2);
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A3B88) --------------------------------------------------------
int __fastcall api_get_eeprom_phy_seq_level(int a1)
{
  return sub_A32AC(dword_15FA6C[a1]);
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A3BC0) --------------------------------------------------------
int __fastcall api_get_eeprom_fmt_version(int a1)
{
  unsigned __int8 v3; // [sp+Fh] [bp-5h] BYREF

  v3 = 0;
  if ( eeprom_get_fmt_version(dword_15FA6C[a1], &v3) )
    return 0;
  else
    return v3;
}
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];

//----- (000A3C20) --------------------------------------------------------
int __fastcall api_get_eeprom_asic_freqs(int a1, void *a2, float *a3)
{
  int v4; // r3
  float v5; // s15
  char v7[16]; // [sp+24h] [bp-1A10h] BYREF
  char v8[16]; // [sp+824h] [bp-1210h] BYREF
  float src[128]; // [sp+1824h] [bp-210h] BYREF
  unsigned __int16 v10; // [sp+1A26h] [bp-Eh]
  float v11; // [sp+1A28h] [bp-Ch]
  unsigned int i; // [sp+1A2Ch] [bp-8h]

  if ( dword_15FA68 && *(_BYTE *)(dword_15FA68 + 80) )
  {
    v4 = *(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[a1]);
    v10 = (*(unsigned __int8 *)(v4 + 42) << 8) | *(unsigned __int8 *)(v4 + 41);
    v5 = (double)*(unsigned __int16 *)(*(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[a1]) + 61) * 0.01;
    v11 = v5;
    for ( i = 0; i <= 0x7F; ++i )
      src[i] = (float)v10
             + (float)((float)*(unsigned __int8 *)(*(_DWORD *)(dword_15FA68 + 4 * dword_15FA6C[a1]) + i + 63) * v11);
    if ( a2 && a3 )
    {
      *a3 = v11;
      memcpy(a2, src, 0x200u);
      return 0;
    }
    else
    {
      snprintf(v7, 0x800u, "%s: sweep_freqs is NULL %d\n", "api_get_eeprom_asic_freqs", dword_15FA6C[a1]);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
        180,
        "api_get_eeprom_asic_freqs",
        25,
        1390,
        100,
        v8);
      return -2;
    }
  }
  else
  {
    snprintf(v7, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "api_get_eeprom_asic_freqs", dword_15FA6C[a1]);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/eeprom/bitmain_eeprom.c",
      180,
      "api_get_eeprom_asic_freqs",
      25,
      1371,
      100,
      v8);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FA68: using guessed type int dword_15FA68;
// 15FA6C: using guessed type _DWORD dword_15FA6C[16];
// 1608F0: using guessed type int g_zc;

//----- (000A3F88) --------------------------------------------------------
unsigned int __fastcall sub_A3F88(unsigned int a1)
{
  return bswap32(a1);
}

//----- (000A3FB0) --------------------------------------------------------
unsigned int __fastcall sub_A3FB0(int a1, unsigned int a2)
{
  return bswap32(a2);
}

//----- (000A3FF4) --------------------------------------------------------
int __fastcall sub_A3FF4(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  char v7[2048]; // [sp+24h] [bp-1810h] BYREF
  char v8[16]; // [sp+824h] [bp-1010h] BYREF
  unsigned int i; // [sp+1824h] [bp-10h]
  unsigned __int16 v10; // [sp+1828h] [bp-Ch]
  unsigned __int16 v11; // [sp+182Ah] [bp-Ah]
  int v12; // [sp+182Ch] [bp-8h]

  i = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  if ( !a1 || !a2 || !a3 )
    return -2147482879;
  i = 2;
  v11 = 0;
  while ( a3 - 2 > i )
    v11 += a2[i++];
  v10 = (a2[a3 - 1] << 8) + a2[a3 - 2];
  if ( v11 == v10 )
  {
    if ( *a1 != *a2 || a1[1] != a2[1] || a1[3] != a2[3] || a3 != a2[2] + 2 )
    {
      strcpy(v7, "power reply the bad data");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "check_read_back_data",
        20,
        132,
        20,
        v8);
      v12 = -2147482880;
    }
  }
  else
  {
    snprintf(v7, 0x800u, "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x", v11, v10);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "check_read_back_data",
      20,
      126,
      20,
      v8);
    v12 = -2147482880;
  }
  if ( v12 )
  {
    for ( i = 0; a3 > i; ++i )
    {
      snprintf(v7, 0x800u, "read_back_data[%d] = 0x%02x", i, a2[i]);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "check_read_back_data",
        20,
        138,
        20,
        v8);
    }
  }
  return v12;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A4484) --------------------------------------------------------
int __fastcall sub_A4484(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  char v9[20]; // [sp+20h] [bp-1814h] BYREF
  char v10[20]; // [sp+820h] [bp-1014h] BYREF
  char v11; // [sp+1822h] [bp-12h]
  unsigned __int8 v12; // [sp+1823h] [bp-11h]
  unsigned __int8 *v13; // [sp+1824h] [bp-10h]
  int v14; // [sp+1828h] [bp-Ch]
  unsigned __int8 i; // [sp+182Eh] [bp-6h]
  unsigned __int8 j; // [sp+182Fh] [bp-5h]

  j = 0;
  i = 0;
  v14 = 0;
  v12 = 17;
  v11 = 16;
  pthread_mutex_lock(&power_mutex);
  if ( byte_15FBA8 != 1 )
  {
    i2c_sim_send_cmd(v11, 0, 1, v12, 4u);
    byte_15FBA8 = 1;
  }
  for ( i = 0; i <= 2u; ++i )
  {
    for ( j = 0; a2 > j; i2c_sim_send_cmd(v11, 0, 1, v12, a1[j++]) )
      ;
    usleep(0x61A80u);
    v13 = a3;
    for ( j = 0; a4 > j; ++j )
      *v13++ = i2c_sim_send_cmd(v11, 1, 0, v12, 0);
    usleep((__useconds_t)"time");
    v14 = sub_A3FF4(a1, a3, a4);
    if ( !v14 )
      break;
    snprintf(v9, 0x800u, "Send power cmd(0x%02x) failed, retry %d\n", a1[3], i);
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "exec_i2c_sim_cmd",
      16,
      185,
      20,
      v10);
  }
  pthread_mutex_unlock(&power_mutex);
  return v14;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAB0: using guessed type pthread_mutex_t power_mutex;
// 15FBA8: using guessed type char byte_15FBA8;
// 1608F0: using guessed type int g_zc;

//----- (000A477C) --------------------------------------------------------
bool is_power_status_with_64bits()
{
  return dword_15FAD8 == 193 || dword_15FAD8 == 194;
}
// 15FAD8: using guessed type int dword_15FAD8;

//----- (000A47D0) --------------------------------------------------------
int __fastcall sub_A47D0(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5)
{
  char v10[16]; // [sp+24h] [bp-1810h] BYREF
  char v11[16]; // [sp+824h] [bp-1010h] BYREF
  char v12; // [sp+1827h] [bp-Dh] BYREF
  int v13; // [sp+1828h] [bp-Ch]
  unsigned __int8 i; // [sp+182Eh] [bp-6h]
  unsigned __int8 j; // [sp+182Fh] [bp-5h]

  j = 0;
  v13 = 0;
  v12 = 0;
  pthread_mutex_lock(&power_mutex);
  for ( i = 0; i <= 2u; ++i )
  {
    for ( j = 0; a3 > j; iic_write_reg(a1, &v12, 1, &a2[j++], 1u) )
      ;
    usleep(0x61A80u);
    for ( j = 0; a5 > j; iic_read_reg(a1, &v12, 1u, (int)&a4[j++], 1u) )
      ;
    usleep((__useconds_t)"time");
    v13 = sub_A3FF4(a2, a4, a5);
    if ( !v13 )
      break;
    snprintf(v10, 0x800u, "Send power cmd(0x%02x) failed, retry %d", a2[3], i);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "exec_power_cmd",
      14,
      246,
      20,
      v11);
  }
  pthread_mutex_unlock(&power_mutex);
  return v13;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAB0: using guessed type pthread_mutex_t power_mutex;
// 1608F0: using guessed type int g_zc;

//----- (000A4A58) --------------------------------------------------------
int __fastcall sub_A4A58(int a1)
{
  char v3[36]; // [sp+18h] [bp-1824h] BYREF
  char v4[36]; // [sp+818h] [bp-1024h] BYREF
  int v5; // [sp+1818h] [bp-24h] BYREF
  __int16 v6; // [sp+181Ch] [bp-20h]
  __int64 v7; // [sp+1820h] [bp-1Ch] BYREF
  int v8; // [sp+1828h] [bp-14h]
  __int16 v9; // [sp+182Eh] [bp-Eh]
  int v10; // [sp+1830h] [bp-Ch]
  char v11; // [sp+1835h] [bp-7h]
  char v12; // [sp+1836h] [bp-6h]
  char v13; // [sp+1837h] [bp-5h]

  v10 = -2147482880;
  v11 = 4;
  v12 = 1;
  v7 = 0;
  v5 = 17082965;
  v8 = -1;
  v9 = 5;
  v6 = 5;
  v13 = 6;
  if ( a1 != 255 )
  {
    if ( sub_A47D0(a1, (unsigned __int8 *)&v5, 6u, (unsigned __int8 *)&v7, 8u) )
    {
      strcpy(v3, "get power version failed");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "_bitmain_get_power_fw_version",
        29,
        277,
        100,
        v4);
      return -2147482880;
    }
    return (BYTE5(v7) << 8) | BYTE4(v7);
  }
  if ( !sub_A4484((unsigned __int8 *)&v5, 6u, (unsigned __int8 *)&v7, 8u) )
    return (BYTE5(v7) << 8) | BYTE4(v7);
  strcpy(v3, "get power version failed");
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "_bitmain_get_power_fw_version",
    29,
    271,
    100,
    v4);
  return -2147482880;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A4D8C) --------------------------------------------------------
int __fastcall sub_A4D8C(int a1)
{
  char v3[36]; // [sp+18h] [bp-1824h] BYREF
  char v4[36]; // [sp+818h] [bp-1024h] BYREF
  int v5; // [sp+1818h] [bp-24h] BYREF
  __int16 v6; // [sp+181Ch] [bp-20h]
  __int64 v7; // [sp+1820h] [bp-1Ch] BYREF
  int v8; // [sp+1828h] [bp-14h]
  __int16 v9; // [sp+182Eh] [bp-Eh]
  int v10; // [sp+1830h] [bp-Ch]
  char v11; // [sp+1835h] [bp-7h]
  char v12; // [sp+1836h] [bp-6h]
  char v13; // [sp+1837h] [bp-5h]

  v10 = -2147482880;
  v11 = 4;
  v12 = 2;
  v7 = 0;
  v5 = 33860181;
  v8 = -1;
  v9 = 6;
  v6 = 6;
  v13 = 6;
  if ( a1 != 255 )
  {
    if ( sub_A47D0(a1, (unsigned __int8 *)&v5, 6u, (unsigned __int8 *)&v7, 8u) )
    {
      strcpy(v3, "get power version failed");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "_bitmain_get_power_version",
        26,
        322,
        100,
        v4);
      return -2147482880;
    }
    return (BYTE5(v7) << 8) | BYTE4(v7);
  }
  if ( !sub_A4484((unsigned __int8 *)&v5, 6u, (unsigned __int8 *)&v7, 8u) )
    return (BYTE5(v7) << 8) | BYTE4(v7);
  strcpy(v3, "get power version failed");
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "_bitmain_get_power_version",
    26,
    316,
    100,
    v4);
  return -2147482880;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A50C0) --------------------------------------------------------
int __fastcall sub_A50C0(int a1)
{
  char v3[28]; // [sp+18h] [bp-181Ch] BYREF
  char v4[28]; // [sp+818h] [bp-101Ch] BYREF
  __int64 v5; // [sp+1818h] [bp-1Ch] BYREF
  int v6; // [sp+1820h] [bp-14h] BYREF
  __int16 v7; // [sp+1824h] [bp-10h]
  __int16 v8; // [sp+1826h] [bp-Eh]
  char v9; // [sp+1829h] [bp-Bh]
  char v10; // [sp+182Ah] [bp-Ah]
  char v11; // [sp+182Bh] [bp-9h]
  int v12; // [sp+182Ch] [bp-8h]

  v9 = 4;
  v10 = 3;
  v6 = 50637397;
  v5 = 0;
  v12 = -2147482880;
  v8 = 7;
  v7 = 7;
  v11 = 6;
  if ( a1 != 255 )
  {
    if ( sub_A47D0(a1, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v5, 8u) )
    {
      strcpy(v3, "get AD conversion N failed");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "_bitmain_get_AD_conversion_N",
        28,
        382,
        100,
        v4);
      return -2147482880;
    }
    return (BYTE5(v5) << 8) | BYTE4(v5);
  }
  if ( !sub_A4484((unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v5, 8u) )
    return (BYTE5(v5) << 8) | BYTE4(v5);
  strcpy(v3, "get AD conversion N failed");
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "_bitmain_get_AD_conversion_N",
    28,
    376,
    100,
    v4);
  return -2147482880;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A53FC) --------------------------------------------------------
int __fastcall sub_A53FC(int a1, unsigned __int8 a2)
{
  char v4[32]; // [sp+1Ch] [bp-1820h] BYREF
  char v5[32]; // [sp+81Ch] [bp-1020h] BYREF
  __int64 v6; // [sp+181Ch] [bp-20h] BYREF
  __int64 v7; // [sp+1824h] [bp-18h] BYREF
  __int16 v8; // [sp+182Eh] [bp-Eh]
  char v9; // [sp+1831h] [bp-Bh]
  char v10; // [sp+1832h] [bp-Ah]
  char v11; // [sp+1833h] [bp-9h]
  int v12; // [sp+1834h] [bp-8h]

  v9 = 6;
  v10 = -125;
  v7 = 2198252117LL;
  v6 = 0;
  v12 = -2147482880;
  v8 = a2 + 137;
  BYTE4(v7) = a2;
  HIWORD(v7) = v8;
  v11 = 8;
  if ( a1 != 255 )
  {
    if ( sub_A47D0(a1, (unsigned __int8 *)&v7, 8u, (unsigned __int8 *)&v6, 8u) )
    {
      strcpy(v4, "set DA conversion N failed");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "_bitmain_set_DA_conversion_N",
        28,
        426,
        100,
        v5);
      return -2147482880;
    }
    return (BYTE5(v6) << 8) | BYTE4(v6);
  }
  if ( !sub_A4484((unsigned __int8 *)&v7, 8u, (unsigned __int8 *)&v6, 8u) )
    return (BYTE5(v6) << 8) | BYTE4(v6);
  strcpy(v4, "set DA conversion N failed");
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "_bitmain_set_DA_conversion_N",
    28,
    420,
    100,
    v5);
  return -2147482880;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A579C) --------------------------------------------------------
int __fastcall sub_A579C(int a1)
{
  return sub_A4D8C(a1);
}

//----- (000A57D4) --------------------------------------------------------
int __fastcall sub_A57D4(int a1)
{
  char v3[28]; // [sp+18h] [bp-181Ch] BYREF
  char v4[28]; // [sp+818h] [bp-101Ch] BYREF
  __int64 v5; // [sp+1818h] [bp-1Ch] BYREF
  int v6; // [sp+1820h] [bp-14h] BYREF
  __int16 v7; // [sp+1824h] [bp-10h]
  __int16 v8; // [sp+1826h] [bp-Eh]
  char v9; // [sp+1829h] [bp-Bh]
  char v10; // [sp+182Ah] [bp-Ah]
  char v11; // [sp+182Bh] [bp-9h]
  int v12; // [sp+182Ch] [bp-8h]

  v9 = 4;
  v10 = 4;
  v6 = 67414613;
  v5 = 0;
  v12 = -2147482880;
  v8 = 8;
  v7 = 8;
  v11 = 6;
  if ( a1 != 255 )
  {
    if ( sub_A47D0(a1, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v5, 8u) )
    {
      strcpy(v3, "get sample N failed");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "_bitmain_get_sample_N",
        21,
        481,
        100,
        v4);
      return -2147482880;
    }
    return (BYTE5(v5) << 8) | BYTE4(v5);
  }
  if ( !sub_A4484((unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v5, 8u) )
    return (BYTE5(v5) << 8) | BYTE4(v5);
  strcpy(v3, "get sample N failed");
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "_bitmain_get_sample_N",
    21,
    475,
    100,
    v4);
  return -2147482880;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A5AF0) --------------------------------------------------------
int __fastcall sub_A5AF0(int a1, unsigned __int8 a2)
{
  char v4[32]; // [sp+1Ch] [bp-1820h] BYREF
  char v5[32]; // [sp+81Ch] [bp-1020h] BYREF
  __int64 v6; // [sp+181Ch] [bp-20h] BYREF
  __int64 v7; // [sp+1824h] [bp-18h] BYREF
  __int16 v8; // [sp+182Eh] [bp-Eh]
  char v9; // [sp+1831h] [bp-Bh]
  char v10; // [sp+1832h] [bp-Ah]
  char v11; // [sp+1833h] [bp-9h]
  int v12; // [sp+1834h] [bp-8h]

  v9 = 6;
  v10 = -127;
  v7 = 2164697685LL;
  v6 = 0;
  v12 = -2147482880;
  v8 = a2 + 135;
  BYTE4(v7) = a2;
  HIWORD(v7) = v8;
  v11 = 8;
  if ( a1 != 255 )
  {
    if ( sub_A47D0(a1, (unsigned __int8 *)&v7, 8u, (unsigned __int8 *)&v6, 8u) )
    {
      strcpy(v4, "set watchdog failed");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "_bitmain_set_watchdog",
        21,
        518,
        100,
        v5);
      return -2147482880;
    }
    return (BYTE5(v6) << 8) | BYTE4(v6);
  }
  if ( !sub_A4484((unsigned __int8 *)&v7, 8u, (unsigned __int8 *)&v6, 8u) )
    return (BYTE5(v6) << 8) | BYTE4(v6);
  strcpy(v4, "set watchdog failed");
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "_bitmain_set_watchdog",
    21,
    512,
    100,
    v5);
  return -2147482880;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A5E70) --------------------------------------------------------
int __fastcall sub_A5E70(int a1)
{
  char v3[28]; // [sp+18h] [bp-181Ch] BYREF
  char v4[28]; // [sp+818h] [bp-101Ch] BYREF
  __int64 v5; // [sp+1818h] [bp-1Ch] BYREF
  int v6; // [sp+1820h] [bp-14h] BYREF
  __int16 v7; // [sp+1824h] [bp-10h]
  __int16 v8; // [sp+1826h] [bp-Eh]
  char v9; // [sp+1829h] [bp-Bh]
  char v10; // [sp+182Ah] [bp-Ah]
  char v11; // [sp+182Bh] [bp-9h]
  int v12; // [sp+182Ch] [bp-8h]

  v9 = 4;
  v10 = 10;
  v6 = 168077909;
  v5 = 0;
  v12 = -2147482880;
  v8 = 14;
  v7 = 14;
  v11 = 6;
  if ( a1 != 255 )
  {
    if ( sub_A47D0(a1, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v5, 8u) )
    {
      strcpy(v3, "get power status failed");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "_bitmain_get_power_status",
        25,
        553,
        100,
        v4);
      return -2147482880;
    }
    return (BYTE5(v5) << 8) | BYTE4(v5);
  }
  if ( !sub_A4484((unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v5, 8u) )
    return (BYTE5(v5) << 8) | BYTE4(v5);
  strcpy(v3, "get power status failed");
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "_bitmain_get_power_status",
    25,
    547,
    100,
    v4);
  return -2147482880;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A618C) --------------------------------------------------------
void sub_A618C()
{
  ;
}
// 15FAD8: using guessed type int dword_15FAD8;

//----- (000A6288) --------------------------------------------------------
void bitmain_get_sample_voltage()
{
  char v0[2048]; // [sp+14h] [bp-1808h] BYREF
  char v1[8]; // [sp+814h] [bp-1008h] BYREF
  int v2; // [sp+1814h] [bp-8h]

  v2 = 0;
  if ( dword_15FAD4 || (v2 = bitmain_power_open(), v2 >= 0) )
  {
    v2 = sub_A57D4(dword_15FAD0);
    if ( v2 >= 0 )
    {
      sub_A618C();
    }
    else
    {
      strcpy(v0, "can not get sample voltage");
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "bitmain_get_sample_voltage",
        26,
        596,
        100,
        v1);
    }
  }
  else
  {
    snprintf(v0, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_get_sample_voltage");
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, v0);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_get_sample_voltage",
      26,
      592,
      100,
      v1);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 1608F0: using guessed type int g_zc;

//----- (000A6474) --------------------------------------------------------
int __fastcall sub_A6474(int a1)
{
  char v3[36]; // [sp+18h] [bp-1824h] BYREF
  char v4[36]; // [sp+818h] [bp-1024h] BYREF
  unsigned __int8 v5[16]; // [sp+1818h] [bp-24h] BYREF
  int v6; // [sp+1828h] [bp-14h] BYREF
  __int16 v7; // [sp+182Ch] [bp-10h]
  __int16 v8; // [sp+182Eh] [bp-Eh]
  char v9; // [sp+1831h] [bp-Bh]
  char v10; // [sp+1832h] [bp-Ah]
  char v11; // [sp+1833h] [bp-9h]
  int v12; // [sp+1834h] [bp-8h]

  v9 = 4;
  v10 = 10;
  v6 = 168077909;
  memset(v5, 0, 14);
  v12 = -2147482880;
  v8 = 14;
  v7 = 14;
  v11 = 6;
  if ( a1 != 255 )
  {
    if ( sub_A47D0(a1, (unsigned __int8 *)&v6, 6u, v5, 0xEu) )
    {
      strcpy(v3, "get power status failed\n");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "_bitmain_get_power_status_32bits",
        32,
        628,
        100,
        v4);
      return -2147482880;
    }
    return (v5[7] << 24) | (v5[6] << 16) & 0xFF0000 | (unsigned __int16)(v5[5] << 8) | v5[4];
  }
  if ( !sub_A4484((unsigned __int8 *)&v6, 6u, v5, 0xEu) )
    return (v5[7] << 24) | (v5[6] << 16) & 0xFF0000 | (unsigned __int16)(v5[5] << 8) | v5[4];
  strcpy(v3, "get power status failed\n");
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "_bitmain_get_power_status_32bits",
    32,
    622,
    100,
    v4);
  return -2147482880;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A67C4) --------------------------------------------------------
int bitmain_get_power_status()
{
  char v2[2048]; // [sp+14h] [bp-1808h] BYREF
  char v3[8]; // [sp+814h] [bp-1008h] BYREF
  int v4; // [sp+1814h] [bp-8h]

  v4 = 0;
  if ( dword_15FAD4 || (v4 = bitmain_power_open(), v4 >= 0) )
  {
    if ( is_power_status_with_64bits() )
      v4 = sub_A6474(dword_15FAD0);
    else
      v4 = sub_A5E70(dword_15FAD0);
    if ( v4 == -2147482880 )
    {
      strcpy(v2, "can nont get power status\n");
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "bitmain_get_power_status",
        24,
        653,
        100,
        v3);
    }
    return v4;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_get_power_status");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_get_power_status",
      24,
      642,
      100,
      v3);
    return v4;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 1608F0: using guessed type int g_zc;

//----- (000A69C4) --------------------------------------------------------
int __fastcall bitmain_set_watchdog(char a1)
{
  char v4[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v6; // [sp+181Ch] [bp-8h]

  v6 = 0;
  if ( dword_15FAD4 || (v6 = bitmain_power_open(), v6 >= 0) )
  {
    if ( a1 == 1 )
      v6 = sub_A5AF0(dword_15FAD0, 1u);
    else
      v6 = sub_A5AF0(dword_15FAD0, 0);
    if ( v6 < 0 )
    {
      strcpy(v4, "can nont set power watchdog");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "bitmain_set_watchdog",
        20,
        673,
        100,
        v5);
    }
    return v6;
  }
  else
  {
    snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_set_watchdog");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_set_watchdog",
      20,
      661,
      100,
      v5);
    return v6;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 1608F0: using guessed type int g_zc;

//----- (000A6BD0) --------------------------------------------------------
int bitmain_power_open()
{
  _DWORD v2[512]; // [sp+10h] [bp-1814h] BYREF
  char v3[20]; // [sp+810h] [bp-1014h] BYREF
  int v4; // [sp+1810h] [bp-14h] BYREF
  __int16 v5; // [sp+1814h] [bp-10h]
  char v6; // [sp+1816h] [bp-Eh]
  char v7; // [sp+1817h] [bp-Dh]
  int v8; // [sp+1818h] [bp-Ch]
  int v9; // [sp+181Ch] [bp-8h]

  v9 = 0;
  v8 = 0;
  if ( dword_15FAD0 && dword_15FAD4 )
    return dword_15FAD0;
  v4 = 0;
  v5 = 1;
  v6 = 2;
  v7 = 0;
  pthread_mutex_lock(&power_mutex);
  v9 = iic_init((int)&v4);
  pthread_mutex_unlock(&power_mutex);
  if ( v9 < 0 )
    return v9;
  dword_15FAD0 = v9;
  dword_15FAD4 = 1;
  memset(&unk_15FAE8, 0, 0xC0u);
  sleep(2u);
  v9 = bitmain_power_version();
  if ( v9 >= 0 )
  {
    dword_15FAD8 = v9;
    snprintf((char *)v2, 0x800u, "power open power_version = 0x%x", v9);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_power_open",
      18,
      711,
      40,
      v3);
    if ( dword_15FAD8 == 193 || dword_15FAD8 == 194 )
    {
      v8 = sub_A4A58(dword_15FAD0);
      snprintf((char *)v2, 0x800u, "power fw_version = 0x%x", v8);
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "bitmain_power_open",
        18,
        715,
        40,
        v3);
      dword_15FADC = v8;
    }
    return 0;
  }
  else
  {
    strcpy((char *)v2, "power open power_version < 0 will close power");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_power_open",
      18,
      706,
      40,
      v3,
      v2[0],
      v2[1],
      v2[2],
      v2[3],
      v2[4],
      v2[5],
      v2[6],
      v2[7],
      v2[8],
      v2[9],
      v2[10],
      v2[11]);
    bitmain_power_close();
    return v9;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAB0: using guessed type pthread_mutex_t power_mutex;
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 15FAD8: using guessed type int dword_15FAD8;
// 15FADC: using guessed type int dword_15FADC;
// 1608F0: using guessed type int g_zc;

//----- (000A6F38) --------------------------------------------------------
int bitmain_power_close()
{
  _DWORD v1[512]; // [sp+10h] [bp-1804h] BYREF
  char v2[4]; // [sp+810h] [bp-1004h] BYREF

  if ( !dword_15FAD0 || !dword_15FAD4 )
  {
    pthread_mutex_lock(&power_mutex);
    strcpy((char *)v1, "bitmain power close ===========");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_power_close",
      19,
      728,
      40,
      v2,
      v1[0],
      v1[1],
      v1[2],
      v1[3],
      v1[4],
      v1[5],
      v1[6],
      v1[7]);
    iic_uninit(dword_15FAD0);
    dword_15FAD4 = 0;
    dword_15FAD8 = 0;
    memset(&unk_15FAE8, 0, 0xC0u);
    pthread_mutex_unlock(&power_mutex);
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAB0: using guessed type pthread_mutex_t power_mutex;
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 15FAD8: using guessed type int dword_15FAD8;
// 1608F0: using guessed type int g_zc;

//----- (000A707C) --------------------------------------------------------
int bitmain_power_fw_version()
{
  char v2[8]; // [sp+14h] [bp-1808h] BYREF
  char v3[8]; // [sp+814h] [bp-1008h] BYREF
  int v4; // [sp+1814h] [bp-8h]

  v4 = 0;
  if ( dword_15FAD4 || (v4 = bitmain_power_open(), v4 >= 0) )
  {
    dword_15FADC = sub_A4A58(dword_15FAD0);
    return dword_15FADC;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_power_fw_version");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_power_fw_version",
      24,
      742,
      100,
      v3);
    return v4;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 15FADC: using guessed type int dword_15FADC;
// 1608F0: using guessed type int g_zc;

//----- (000A7198) --------------------------------------------------------
int bitmain_power_version()
{
  char v2[8]; // [sp+14h] [bp-1808h] BYREF
  char v3[8]; // [sp+814h] [bp-1008h] BYREF
  int v4; // [sp+1814h] [bp-8h]

  v4 = 0;
  if ( dword_15FAD4 || (v4 = bitmain_power_open(), v4 >= 0) )
  {
    v4 = sub_A579C(dword_15FAD0);
    if ( v4 > 0 )
      dword_15FAD8 = v4;
    return v4;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_power_version");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_power_version",
      21,
      753,
      100,
      v3);
    return v4;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// A6BD0: using guessed type int bitmain_power_open(void);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 15FAD8: using guessed type int dword_15FAD8;
// 1608F0: using guessed type int g_zc;

//----- (000A72C0) --------------------------------------------------------
void bitmain_get_voltage()
{
  char v0[2048]; // [sp+14h] [bp-1808h] BYREF
  char v1[8]; // [sp+814h] [bp-1008h] BYREF
  int v2; // [sp+1814h] [bp-8h]

  v2 = 0;
  if ( dword_15FAD4 || (v2 = bitmain_power_open(), v2 >= 0) )
  {
    v2 = sub_A50C0(dword_15FAD0);
    if ( v2 >= 0 )
    {
      bitmain_convert_N_to_V();
    }
    else
    {
      strcpy(v0, "can nont get voltage");
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "bitmain_get_voltage",
        19,
        768,
        100,
        v1);
    }
  }
  else
  {
    snprintf(v0, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_get_voltage");
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, v0);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_get_voltage",
      19,
      764,
      100,
      v1);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 1608F0: using guessed type int g_zc;

//----- (000A74A4) --------------------------------------------------------
int bitmain_set_voltage()
{
  int v0; // s0
  int v1; // s1
  char v4[12]; // [sp+18h] [bp-180Ch] BYREF
  char v5[12]; // [sp+818h] [bp-100Ch] BYREF
  int v6; // [sp+1818h] [bp-Ch]
  unsigned int v7; // [sp+181Ch] [bp-8h]

  v6 = 0;
  v7 = 0;
  if ( dword_15FAD4 || (v6 = bitmain_power_open(), v6 >= 0) )
  {
    v7 = bitmain_convert_V_to_N();
    if ( v7 < 0x100 )
      return sub_A53FC(dword_15FAD0, v7);
    else
      return -2147482879;
  }
  else
  {
    snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_set_voltage");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_set_voltage",
      19,
      780,
      100,
      v5,
      v0,
      v1);
    return v6;
  }
}
// A7594: variable 'v0' is possibly undefined
// A7594: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 1608F0: using guessed type int g_zc;

//----- (000A7614) --------------------------------------------------------
int __fastcall bitmain_set_voltage_by_n(unsigned __int8 a1)
{
  char v4[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v6; // [sp+181Ch] [bp-8h]

  v6 = 0;
  if ( dword_15FAD4 )
    return sub_A53FC(dword_15FAD0, a1);
  v6 = bitmain_power_open();
  if ( v6 >= 0 )
    return sub_A53FC(dword_15FAD0, a1);
  snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_set_voltage_by_n");
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "bitmain_set_voltage_by_n",
    24,
    793,
    100,
    v5);
  return v6;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 1608F0: using guessed type int g_zc;

//----- (000A7744) --------------------------------------------------------
void bitmain_convert_N_to_V_calibration()
{
  int i; // [sp+14h] [bp-10h]

  if ( dword_15FAFC > 1 )
  {
    for ( i = 0; i < dword_15FAFC - 1; ++i )
      ;
  }
}
// 15FAFC: using guessed type int dword_15FAFC;

//----- (000A7928) --------------------------------------------------------
int sub_A7928()
{
  double v0; // d0
  double v2; // d0
  int i; // [sp+1Ch] [bp-8h]

  if ( dword_15FAFC <= 1 )
    return -1;
  for ( i = 0; ; ++i )
  {
    if ( i >= dword_15FAFC - 1 )
      return -1;
    if ( v0 > *((double *)&unk_15FAE8 + i + 13) - 0.001 && v0 < *((double *)&unk_15FAE8 + i + 14) + 0.001
      || v0 < *((double *)&unk_15FAE8 + i + 13) + 0.001 && v0 > *((double *)&unk_15FAE8 + i + 14) - 0.001 )
    {
      break;
    }
  }
  v2 = (v0 - *((double *)&unk_15FAE8 + i + 13))
     * ((double)(*((unsigned __int8 *)&unk_15FAE8 + i + 25) - *((unsigned __int8 *)&unk_15FAE8 + i + 24))
      / (*((double *)&unk_15FAE8 + i + 14) - *((double *)&unk_15FAE8 + i + 13)))
     + (double)*((unsigned __int8 *)&unk_15FAE8 + i + 24);
  round();
  if ( (unsigned int)(int)v2 >= 0x100 )
    return -1;
  else
    return (int)v2;
}
// A7998: variable 'v0' is possibly undefined
// 1D1B0: using guessed type int round(void);
// 15FAFC: using guessed type int dword_15FAFC;

//----- (000A7B74) --------------------------------------------------------
int bitmain_convert_V_to_N()
{
  double v0; // d0
  int v2; // [sp+Ch] [bp-8h]

  switch ( dword_15FAD8 )
  {
    case 34:
      v2 = (int)(1215.89444 - v0 * 59.931507);
      break;
    case 65:
      v2 = (int)(765.411764 - v0 * 35.833333);
      break;
    case 66:
      v2 = (int)(765.411764 - v0 * 35.833333);
      break;
    case 67:
      v2 = (int)(933.240365 - v0 * 59.806034);
      break;
    case 97:
      v2 = (int)(1144.50226 - v0 * 52.243589);
      break;
    case 98:
    case 100:
    case 101:
    case 102:
      v2 = (int)(0.0 - v0);
      break;
    case 106:
      v2 = (int)(1133.0 - v0 * 70.83);
      break;
    case 113:
    case 117:
      v2 = (int)(1190.93534 - v0 * 78.742588);
      break;
    case 114:
    case 119:
      v2 = (int)(1190.93534 - v0 * 78.742588);
      break;
    case 115:
    case 120:
      v2 = (int)(1280.57782 - v0 * 73.979365);
      break;
    case 116:
    case 118:
      v2 = (int)(1156.10758 - v0 * 76.090494);
      break;
    case 193:
    case 194:
      if ( dword_15FADC == -2147482880 || (unsigned __int8)dword_15FADC <= 3u )
        v2 = (int)(1275.0 - v0 * 85.0);
      else
        v2 = (int)(1083.75 - v0 * 70.8333333);
      break;
    default:
      v2 = -1;
      break;
  }
  return v2;
}
// A7BAC: control flows out of bounds to A7BB0
// A7E3C: variable 'v0' is possibly undefined
// 15FAD8: using guessed type int dword_15FAD8;
// 15FADC: using guessed type int dword_15FADC;

//----- (000A80F0) --------------------------------------------------------
void bitmain_convert_N_to_V()
{
  bitmain_convert_N_to_V_calibration();
}
// A8154: control flows out of bounds to A8158
// 15FAD8: using guessed type int dword_15FAD8;

//----- (000A83E0) --------------------------------------------------------
int __fastcall bitmain_power_read(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  int v4; // r3
  char v8[2048]; // [sp+1Ch] [bp-1850h] BYREF
  char v9[16]; // [sp+81Ch] [bp-1050h] BYREF
  unsigned __int8 v10[40]; // [sp+181Ch] [bp-50h] BYREF
  __int16 v11; // [sp+1844h] [bp-28h]
  __int64 v12; // [sp+1846h] [bp-26h]
  int v13; // [sp+1850h] [bp-1Ch] BYREF
  unsigned __int8 v14; // [sp+1854h] [bp-18h]
  unsigned __int8 v15; // [sp+1855h] [bp-17h]
  _BYTE v16[6]; // [sp+1856h] [bp-16h]
  char v17; // [sp+185Eh] [bp-Eh]
  char v18; // [sp+185Fh] [bp-Dh]
  int v19; // [sp+1860h] [bp-Ch]
  __int16 v20; // [sp+1864h] [bp-8h]
  unsigned __int8 i; // [sp+1867h] [bp-5h]

  *(_WORD *)&v16[4] = 0;
  v17 = 6;
  v18 = 6;
  v13 = 101100117;
  memset(v10, 0, sizeof(v10));
  v11 = 0;
  v12 = 0;
  v19 = 5;
  v20 = a1 + 12 + a3;
  v14 = a1;
  v15 = a3;
  *(_DWORD *)v16 = (unsigned __int8)(a1 + 12 + a3);
  i = 8;
  v16[1] = HIBYTE(v20);
  if ( dword_15FAD4 || (*(_DWORD *)&v16[2] = bitmain_power_open(), *(int *)&v16[2] >= 0) )
  {
    if ( dword_15FAD0 == 255 )
    {
      if ( sub_A4484((unsigned __int8 *)&v13, 8u, v10, 0x32u) )
      {
        strcpy(v8, "get power version failed");
        V_LOCK();
        logfmt_raw(v9, 0x1000u, 0, v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
          183,
          "bitmain_power_read",
          18,
          980,
          100,
          v9);
        return -2147482880;
      }
    }
    else if ( sub_A47D0(dword_15FAD0, (unsigned __int8 *)&v13, 8u, v10, a3 + 7) )
    {
      strcpy(v8, "set DA conversion N failed");
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "bitmain_power_read",
        18,
        986,
        100,
        v9);
      return -2147482880;
    }
    for ( i = 0; i < a3 + 7; ++i )
    {
      snprintf(v8, 0x800u, "read_back_data[%d]: %02X", i, v10[i]);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "bitmain_power_read",
        18,
        994,
        100,
        v9);
    }
    for ( i = 0; i < (unsigned int)a3; ++i )
    {
      v4 = v19++;
      *(_BYTE *)(a2 + i) = v10[v4];
      snprintf(v8, 0x800u, "buf[%d]: %02X", i, *(unsigned __int8 *)(a2 + i));
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "bitmain_power_read",
        18,
        999,
        100,
        v9);
    }
    return *(_DWORD *)&v16[2];
  }
  else
  {
    snprintf(v8, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_power_read");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_power_read",
      18,
      976,
      100,
      v9);
    return *(_DWORD *)&v16[2];
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 1608F0: using guessed type int g_zc;

//----- (000A8A94) --------------------------------------------------------
bool is_power_protocal_v2()
{
  return dword_15FAD8 == 98 || dword_15FAD8 == 100 || dword_15FAD8 == 101 || dword_15FAD8 == 102;
}
// 15FAD8: using guessed type int dword_15FAD8;

//----- (000A8B08) --------------------------------------------------------
int __fastcall sub_A8B08(int a1, unsigned int a2, unsigned __int64 a3, int a4)
{
  int v5; // r2
  unsigned __int64 v6; // r0
  int v9; // [sp+8h] [bp-5Ch]
  int v11; // [sp+14h] [bp-50h]
  __int64 v12; // [sp+18h] [bp-4Ch]
  __int64 v13; // [sp+20h] [bp-44h]
  __int64 v14; // [sp+28h] [bp-3Ch]
  __int64 v15; // [sp+30h] [bp-34h]
  __int64 v16; // [sp+38h] [bp-2Ch]
  __int64 v17; // [sp+40h] [bp-24h]
  _BYTE v18[13]; // [sp+48h] [bp-1Ch] BYREF
  unsigned int j; // [sp+58h] [bp-Ch]
  unsigned int i; // [sp+5Ch] [bp-8h]

  v9 = a2;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  memset(v18, 0, sizeof(v18));
  if ( a4 <= 1 || (unsigned int)a4 > 0x24 || !a2 )
    return 0;
  if ( a2 > 0x41 )
    v9 = 65;
  for ( i = 0; i < v9 - 1; ++i )
  {
    sub_CCDFC(a3, a4);
    *((_BYTE *)&v11 + i) = a0123456789abcd[v5];
    LODWORD(v6) = sub_CCDFC(a3, a4);
    a3 = v6;
  }
  if ( a3 )
    return 0;
  for ( j = 0; j < v9 - 1; ++j )
    *(_BYTE *)(a1 + j) = *((_BYTE *)&v11 + v9 - j - 2);
  *(_BYTE *)(a1 + v9 - 1) = 0;
  return 1;
}
// A8BD4: variable 'v5' is possibly undefined
// A8C0C: variable 'v6' is possibly undefined

//----- (000A8CC4) --------------------------------------------------------
int __fastcall sub_A8CC4(int a1)
{
  char v3[28]; // [sp+18h] [bp-181Ch] BYREF
  char v4[28]; // [sp+818h] [bp-101Ch] BYREF
  __int64 v5; // [sp+1818h] [bp-1Ch] BYREF
  int v6; // [sp+1820h] [bp-14h] BYREF
  __int16 v7; // [sp+1824h] [bp-10h]
  __int16 v8; // [sp+1826h] [bp-Eh]
  char v9; // [sp+1829h] [bp-Bh]
  char v10; // [sp+182Ah] [bp-Ah]
  char v11; // [sp+182Bh] [bp-9h]
  int v12; // [sp+182Ch] [bp-8h]

  v9 = 4;
  v10 = 8;
  v6 = 134523477;
  v5 = 0;
  v12 = -2147482880;
  v8 = 12;
  v7 = 12;
  v11 = 6;
  if ( a1 != 255 )
  {
    if ( sub_A47D0(a1, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v5, 8u) )
    {
      strcpy(v3, "get power status failed\n");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "_bitmain_get_miner_power",
        24,
        1068,
        100,
        v4);
      return -2147482880;
    }
    return (BYTE5(v5) << 8) | BYTE4(v5);
  }
  if ( !sub_A4484((unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v5, 8u) )
    return (BYTE5(v5) << 8) | BYTE4(v5);
  strcpy(v3, "get power status failed\n");
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
    183,
    "_bitmain_get_miner_power",
    24,
    1062,
    100,
    v4);
  return -2147482880;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000A8FE8) --------------------------------------------------------
bool sub_A8FE8()
{
  return dword_15FAD8 == 193 || dword_15FAD8 == 194;
}
// 15FAD8: using guessed type int dword_15FAD8;

//----- (000A9034) --------------------------------------------------------
int __fastcall sub_A9034(int a1, int a2)
{
  int i; // [sp+1Ch] [bp-8h]

  if ( a2 <= 1 || a2 > 256 )
    return 0;
  for ( i = 0; i < a2; ++i )
  {
    round();
    *(_BYTE *)(a1 + i) = (unsigned int)((double)i * (255.0 / (double)(a2 - 1)));
  }
  return 1;
}
// 1D1B0: using guessed type int round(void);

//----- (000A9108) --------------------------------------------------------
void sub_A9108()
{
  ;
}
// A9148: control flows out of bounds to A914C
// 15FAD8: using guessed type int dword_15FAD8;
// 15FADC: using guessed type int dword_15FADC;

//----- (000A9658) --------------------------------------------------------
int __fastcall sub_A9658(unsigned __int16 a1)
{
  if ( a1 == 106 )
    return 0;
  if ( a1 <= 0x6Au )
  {
    if ( a1 == 98 )
      return 0;
    if ( a1 <= 0x62u )
    {
      if ( a1 != 26 )
      {
        if ( a1 != 65 )
          return (unsigned __int8)-1;
        return 64;
      }
      return 0;
    }
    if ( (unsigned int)a1 - 100 <= 2 )
      return 0;
    return (unsigned __int8)-1;
  }
  if ( a1 <= 0x78u )
  {
    if ( a1 < 0x75u && a1 != 113 && a1 != 115 )
      return (unsigned __int8)-1;
    return 64;
  }
  if ( (unsigned int)a1 - 193 > 1 )
    return (unsigned __int8)-1;
  return 0;
}

//----- (000A9724) --------------------------------------------------------
int get_power_voltage_calibration_data()
{
  double v0; // d0
  __int64 v2; // r0
  _DWORD v4[9]; // [sp+10h] [bp-18A4h] BYREF
  char v5[36]; // [sp+810h] [bp-10A4h] BYREF
  _DWORD v6[5]; // [sp+1810h] [bp-A4h] BYREF
  unsigned int v7; // [sp+1824h] [bp-90h]
  __int64 dest; // [sp+1828h] [bp-8Ch] BYREF
  uint8_t src[8]; // [sp+1844h] [bp-70h] BYREF
  unsigned int v10; // [sp+184Ch] [bp-68h]
  unsigned __int8 v11; // [sp+1850h] [bp-64h]
  unsigned __int8 v12; // [sp+1851h] [bp-63h]
  _BYTE v13[18]; // [sp+1852h] [bp-62h] BYREF
  double *v14; // [sp+1864h] [bp-50h]
  _BYTE *v15; // [sp+1868h] [bp-4Ch]
  unsigned int v16; // [sp+186Ch] [bp-48h]
  unsigned int v17; // [sp+1870h] [bp-44h]
  unsigned int v18; // [sp+1874h] [bp-40h]
  unsigned __int16 v19; // [sp+187Ah] [bp-3Ah]
  unsigned int v20; // [sp+187Ch] [bp-38h]
  __int64 v21; // [sp+1880h] [bp-34h]
  uint8_t v22; // [sp+188Fh] [bp-25h]
  uint16_t v23; // [sp+1890h] [bp-24h]
  unsigned __int16 v24; // [sp+1892h] [bp-22h]
  int i; // [sp+1894h] [bp-20h]
  int v26; // [sp+1898h] [bp-1Ch]
  unsigned int j; // [sp+189Ch] [bp-18h]
  unsigned int k; // [sp+18A0h] [bp-14h]
  unsigned __int8 v29; // [sp+18A7h] [bp-Dh]

  v29 = sub_A9658(dword_15FAD8);
  if ( v29 == 255 )
    return -1;
  if ( is_power_protocal_v2() )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s power protocal not support!", "get_power_voltage_calibration_data");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "get_power_voltage_calibration_data",
      34,
      1210,
      100,
      v5);
    return -1;
  }
  else if ( bitmain_power_read(v29, (int)src, 0x20u) )
  {
    return -1;
  }
  else
  {
    strcpy((char *)v4, "power calibration data:");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "get_power_voltage_calibration_data",
      34,
      1221,
      100,
      v5,
      v4[0],
      v4[1],
      v4[2],
      v4[3],
      v4[4],
      v4[5]);
    for ( i = 0; i <= 31; i += 4 )
    {
      snprintf((char *)v4, 0x800u, "%2X %2X %2X %2X  ", src[i], src[i + 1], src[i + 2], src[i + 3]);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "get_power_voltage_calibration_data",
        34,
        1223,
        100,
        v5);
    }
    v24 = (v13[16] << 8) + v13[17];
    v23 = CRC16(src, 0x1Eu);
    if ( v24 == v23 )
    {
      v22 = src[0];
      memcpy(&dest, src, sizeof(dest));
      v7 = v10;
      LODWORD(v2) = sub_A3FB0(dest, HIDWORD(dest));
      dest = v2;
      v7 = sub_A3F88(v7);
      v21 = dest & 0x1FFFFFFFFFFFFFFLL;
      v20 = v7;
      memset(v6, 0, 18);
      sub_A8B08((int)v6, 0xCu, dest & 0x1FFFFFFFFFFFFFFLL, 36);
      sub_A8B08((int)&v6[2] + 3, 7u, v20, 36);
      dword_15FAE8[0] = v6[0];
      dword_15FAE8[1] = v6[1];
      dword_15FAE8[2] = v6[2];
      dword_15FAE8[3] = v6[3];
      word_15FAF8 = v6[4];
      v19 = (v13[14] << 8) + v13[15];
      v18 = v19 / 0x174u;
      v17 = v19 / 0x1Fu % 0xC + 1;
      v16 = v19 % 0x1Fu + 1;
      dword_15FBA0 = 10000 * v18 + 100 * v17 + v16;
      v15 = v13;
      v26 = (__int16)((v11 << 8) + v12);
      for ( j = 0; j <= 0xD && (char)v15[j] != -128; ++j )
        ;
      v14 = (double *)dword_15FAE8;
      dword_15FAFC = j + 1;
      if ( (unsigned __int8)sub_A9034((int)&byte_15FB00, j + 1) != 1 )
      {
        return -1;
      }
      else
      {
        sub_A9108();
        v14[13] = v0 + (double)v26 / 1000.0;
        for ( k = 0; k < j; ++k )
        {
          v26 += (char)v15[k];
          sub_A9108();
          v14[k + 14] = v0 + (double)v26 / 1000.0;
        }
        return 0;
      }
    }
    else
    {
      strcpy((char *)v4, "calibration data crc err");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "get_power_voltage_calibration_data",
        34,
        1232,
        100,
        v5);
      return -1;
    }
  }
}
// A9B28: variable 'v2' is possibly undefined
// A9DBC: variable 'v0' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD8: using guessed type int dword_15FAD8;
// 15FAE8: using guessed type _DWORD dword_15FAE8[4];
// 15FAF8: using guessed type __int16 word_15FAF8;
// 15FAFC: using guessed type int dword_15FAFC;
// 15FB00: using guessed type char byte_15FB00;
// 15FBA0: using guessed type int dword_15FBA0;
// 1608F0: using guessed type int g_zc;

//----- (000A9E84) --------------------------------------------------------
int bitmain_get_miner_power()
{
  char v2[8]; // [sp+14h] [bp-1808h] BYREF
  char v3[8]; // [sp+814h] [bp-1008h] BYREF
  int v4; // [sp+1814h] [bp-8h]

  v4 = 0;
  if ( dword_15FAD4 || (v4 = bitmain_power_open(), v4 >= 0) )
  {
    if ( is_power_protocal_v2() )
    {
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "%s power protocal not support!", "bitmain_get_miner_power");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
        183,
        "bitmain_get_miner_power",
        23,
        1291,
        100,
        v3);
      return -1;
    }
    else if ( !sub_A8FE8() )
    {
      return -1;
    }
    else
    {
      v4 = sub_A8CC4(dword_15FAD0);
      if ( v4 == -2147482880 )
      {
        snprintf(v2, 0x800u, "can nont get power ret = 0x%x\n", -2147482880);
        V_LOCK();
        logfmt_raw(v3, 0x1000u, 0, v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
          183,
          "bitmain_get_miner_power",
          23,
          1300,
          100,
          v3);
        return -1;
      }
      else
      {
        return v4;
      }
    }
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed", "bitmain_get_miner_power");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/power/bitmain_power_APW9.c",
      183,
      "bitmain_get_miner_power",
      23,
      1289,
      100,
      v3);
    return v4;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FAD0: using guessed type int dword_15FAD0;
// 15FAD4: using guessed type int dword_15FAD4;
// 1608F0: using guessed type int g_zc;

//----- (000AA0FC) --------------------------------------------------------
int __fastcall tsensor_open(unsigned int a1, int a2, unsigned __int8 a3)
{
  int v4; // r2
  char v9[24]; // [sp+24h] [bp-1818h] BYREF
  char v10[24]; // [sp+824h] [bp-1018h] BYREF
  unsigned int v11; // [sp+1824h] [bp-18h] BYREF
  __int16 v12; // [sp+1828h] [bp-14h]
  char v13; // [sp+182Ah] [bp-12h]
  char v14; // [sp+182Bh] [bp-11h]
  int v15; // [sp+182Ch] [bp-10h]
  unsigned __int8 i; // [sp+1833h] [bp-9h]
  int v17; // [sp+1834h] [bp-8h]

  v15 = -2147482111;
  if ( a1 <= 0xF )
  {
    if ( a3 <= 7u )
    {
      for ( i = 0; i < (unsigned int)a3; ++i )
      {
        v17 = sub_AB0EC(a1, *(_BYTE *)(a2 + i));
        if ( v17 == -2147482112 )
        {
          v11 = a1;
          v12 = 0;
          v13 = ((*(unsigned __int8 *)(a2 + i) + a1) >> 3) & 0xF;
          v14 = (*(_BYTE *)(a2 + i) + a1) & 7;
          v15 = iic_init((int)&v11);
          if ( v15 < 0 )
          {
            snprintf(v9, 0x800u, " open T-sensor error, chain is %d,slave addr is %d", a1, *(unsigned __int8 *)(a2 + i));
            V_LOCK();
            logfmt_raw(v10, 0x1000u, 0, v9);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
              182,
              "tsensor_open",
              12,
              75,
              100,
              v10);
            return v15;
          }
          v4 = byte_15FBAC[68 * a1];
          byte_15FBAC[68 * a1] = v4 + 1;
          v17 = v4;
          byte_15FBAC[68 * a1 + 4 + 8 * v4] = *(_BYTE *)(a2 + i);
          *(_DWORD *)&byte_15FBAC[68 * a1 + 8 + 8 * v17] = v15;
        }
      }
      return 0;
    }
    else
    {
      snprintf(v9, 0x800u, " Bad T-sensor param, input num is %d", a3);
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
        182,
        "tsensor_open",
        12,
        56,
        100,
        v10);
      return -2147482111;
    }
  }
  else
  {
    snprintf(v9, 0x800u, " Bad T-sensor param, input chain is %d", a1);
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
      182,
      "tsensor_open",
      12,
      55,
      100,
      v10);
    return -2147482111;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FBAC: using guessed type unsigned __int8 byte_15FBAC[1088];
// 1608F0: using guessed type int g_zc;

//----- (000AA598) --------------------------------------------------------
int __fastcall tsensor_close(unsigned int a1)
{
  int v1; // r3
  char v4[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  unsigned __int8 i; // [sp+181Fh] [bp-5h]

  if ( a1 <= 0xF )
  {
    for ( i = 0; i < (unsigned int)byte_15FBAC[68 * a1]; ++i )
    {
      if ( *(_DWORD *)&byte_15FBAC[68 * a1 + 8 + 8 * i] )
        iic_uninit(*(_DWORD *)&byte_15FBAC[68 * a1 + 8 + 8 * i]);
    }
    memset(&byte_15FBAC[68 * a1], 0, 0x44u);
  }
  else
  {
    snprintf(v4, 0x800u, " Bad T-sensor param, input chain is %d", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
      182,
      "tsensor_close",
      13,
      91,
      100,
      v5);
    return -2147482111;
  }
  return v1;
}
// AA764: variable 'v1' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FBAC: using guessed type unsigned __int8 byte_15FBAC[1088];
// 1608F0: using guessed type int g_zc;

//----- (000AA770) --------------------------------------------------------
int __fastcall tsensor_write(unsigned int a1, unsigned __int8 a2, char a3, int a4, unsigned int a5)
{
  unsigned __int8 v9; // [sp+1Bh] [bp-1821h] BYREF
  unsigned int v10; // [sp+1Ch] [bp-1820h]
  char v11[24]; // [sp+24h] [bp-1818h] BYREF
  char v12[24]; // [sp+824h] [bp-1018h] BYREF
  unsigned __int8 v13; // [sp+1827h] [bp-15h] BYREF
  unsigned int i; // [sp+1828h] [bp-14h]
  int v15; // [sp+182Ch] [bp-10h]
  int v16; // [sp+1830h] [bp-Ch]
  int v17; // [sp+1834h] [bp-8h]

  v10 = a1;
  v9 = a2;
  v16 = 0;
  i = 0;
  v15 = 0;
  if ( a1 <= 0xF )
  {
    v17 = sub_AB0EC(v10, v9);
    if ( v17 == -2147482112 )
    {
      v16 = tsensor_open(v10, (int)&v9, 1u);
      if ( v16 < 0 )
      {
        snprintf(v11, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed", v10, v9);
        V_LOCK();
        logfmt_raw(v12, 0x1000u, 0, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
          182,
          "tsensor_write",
          13,
          121,
          100,
          v12);
        return v16;
      }
      v17 = sub_AB0EC(v10, v9);
      if ( v17 == -2147482112 )
      {
        snprintf(v11, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed", v10, v9);
        V_LOCK();
        logfmt_raw(v12, 0x1000u, 0, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
          182,
          "tsensor_write",
          13,
          128,
          100,
          v12);
        return v16;
      }
    }
    for ( i = 0; a5 > i; ++i )
    {
      v13 = i + a3;
      v16 = iic_write_reg(*(_DWORD *)&byte_15FBAC[68 * v10 + 8 + 8 * v17], &v13, 1, (const void *)(a4 + i), 1u);
      if ( v16 != 1 )
      {
        snprintf(v11, 0x800u, "fail to write tsensor by iic, chain:%d, slave: %d, addr: %d", v10, v9, v13);
        V_LOCK();
        logfmt_raw(v12, 0x1000u, 0, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
          182,
          "tsensor_write",
          13,
          140,
          100,
          v12);
        return -2147482112;
      }
    }
    return a5;
  }
  else
  {
    snprintf(v11, 0x800u, " Bad T-sensor param, input chain is %d", v10);
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
      182,
      "tsensor_write",
      13,
      112,
      100,
      v12);
    return -2147482111;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FBAC: using guessed type unsigned __int8 byte_15FBAC[1088];
// 1608F0: using guessed type int g_zc;

//----- (000AAC50) --------------------------------------------------------
int __fastcall tsensor_read(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, unsigned int a5)
{
  unsigned __int8 v8; // [sp+1Ah] [bp-181Ah] BYREF
  unsigned __int8 v9; // [sp+1Bh] [bp-1819h] BYREF
  unsigned int v10; // [sp+1Ch] [bp-1818h]
  char v11[16]; // [sp+24h] [bp-1810h] BYREF
  char v12[16]; // [sp+824h] [bp-1010h] BYREF
  int v13; // [sp+1824h] [bp-10h]
  int v14; // [sp+1828h] [bp-Ch]
  int v15; // [sp+182Ch] [bp-8h]

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v14 = 0;
  v13 = 0;
  if ( a1 <= 0xF )
  {
    v15 = sub_AB0EC(v10, v9);
    if ( v15 == -2147482112 )
    {
      v14 = tsensor_open(v10, (int)&v9, 1u);
      if ( v14 < 0 )
      {
        snprintf(v11, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed", v10, v9);
        V_LOCK();
        logfmt_raw(v12, 0x1000u, 0, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
          182,
          "tsensor_read",
          12,
          164,
          100,
          v12);
        return v14;
      }
      v15 = sub_AB0EC(v10, v9);
      if ( v15 == -2147482112 )
      {
        snprintf(v11, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed", v10, v9);
        V_LOCK();
        logfmt_raw(v12, 0x1000u, 0, v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
          182,
          "tsensor_read",
          12,
          171,
          100,
          v12);
        return v14;
      }
    }
    v14 = iic_read_reg(*(_DWORD *)&byte_15FBAC[68 * v10 + 8 + 8 * v15], &v8, 2u, a4, a5);
    if ( a5 == v14 )
    {
      return v14;
    }
    else
    {
      snprintf(v11, 0x800u, "fail to read tsensor by iic, chain: %d, slave: %d, addr: %d", v10, v9, v8);
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
        182,
        "tsensor_read",
        12,
        196,
        100,
        v12);
      return -2147482112;
    }
  }
  else
  {
    snprintf(v11, 0x800u, " Bad T-sensor param, input chain is %d", v10);
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
      182,
      "tsensor_read",
      12,
      155,
      100,
      v12);
    return -2147482111;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FBAC: using guessed type unsigned __int8 byte_15FBAC[1088];
// 1608F0: using guessed type int g_zc;

//----- (000AB0EC) --------------------------------------------------------
int __fastcall sub_AB0EC(unsigned int a1, unsigned __int8 a2)
{
  char v4[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  unsigned __int8 i; // [sp+181Fh] [bp-5h]

  if ( a1 <= 0xF )
  {
    if ( byte_15FBAC[68 * a1] )
    {
      for ( i = 0; i < (unsigned int)byte_15FBAC[68 * a1]; ++i )
      {
        if ( a2 == byte_15FBAC[68 * a1 + 4 + 8 * i] )
          return i;
      }
      return -2147482112;
    }
    else
    {
      return -2147482112;
    }
  }
  else
  {
    snprintf(v4, 0x800u, " Bad T-sensor param, input chain is %d", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/tsensor/bitmain_tsensor.c",
      182,
      "find_index",
      10,
      208,
      100,
      v5);
    return -2147482111;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15FBAC: using guessed type unsigned __int8 byte_15FBAC[1088];
// 1608F0: using guessed type int g_zc;

//----- (000AB2BC) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_AB2BC(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (000AB2F0) --------------------------------------------------------
unsigned int __fastcall sub_AB2F0(int a1, int a2, unsigned __int8 *a3, int a4)
{
  return check_and_print_uart_debug_log(a1, a2, a3, a4, 1);
}

//----- (000AB334) --------------------------------------------------------
unsigned int __fastcall sub_AB334(int a1, int a2, unsigned __int8 *a3, int a4)
{
  return check_and_print_uart_debug_log(a1, a2, a3, a4, 0);
}

//----- (000AB378) --------------------------------------------------------
int __fastcall send_work(int a1)
{
  int v1; // r0
  char v3[16]; // [sp+1Ch] [bp-1010h] BYREF
  void *ptr; // [sp+101Ch] [bp-10h]
  char *s; // [sp+1020h] [bp-Ch]
  int v6; // [sp+1024h] [bp-8h]

  v6 = a1;
  s = (char *)calloc(1u, 0x40u);
  snprintf(s, 0x40u, "%.10s_%d", "send_work", *(_DWORD *)(v6 + 248));
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v3, 0x1000u, 0, "%s on pid %ld", s, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_base.c",
    160,
    "send_work",
    9,
    58,
    40,
    v3);
  prctl(15, s);
  for ( ptr = calloc(1u, *(_DWORD *)(v6 + 828)); ; push_work_base(v6, (int)ptr) )
  {
    memset(ptr, 0, *(_DWORD *)(v6 + 828));
    queue_dequeue(*(_DWORD *)(v6 + 856), (char *)ptr, 1u);
    if ( *(_BYTE *)(v6 + 1022) )
      break;
  }
  *(_BYTE *)(v6 + 1022) = 0;
  free(ptr);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000AB50C) --------------------------------------------------------
int __fastcall platform_check_repeat_nonce(_DWORD *a1, int a2, unsigned __int8 *a3)
{
  char v8[12]; // [sp+48h] [bp-104Ch] BYREF
  _DWORD v9[7]; // [sp+1048h] [bp-4Ch] BYREF
  int v10; // [sp+1064h] [bp-30h]
  void *ptr; // [sp+106Ch] [bp-28h]
  void *v12; // [sp+1070h] [bp-24h]
  void *v13; // [sp+1074h] [bp-20h]
  size_t v14; // [sp+1078h] [bp-1Ch]
  size_t v15; // [sp+107Ch] [bp-18h]
  size_t n; // [sp+1080h] [bp-14h]
  size_t i; // [sp+1084h] [bp-10h]

  n = a1[209];
  v15 = 2 * n * a2;
  v14 = v15 + n;
  if ( !memcmp((const void *)(a1[122] + v15), a3, n) || !memcmp((const void *)(a1[122] + v14), a3, n) )
  {
    v13 = calloc(2 * n + 1, 1u);
    v12 = calloc(2 * n + 1, 1u);
    ptr = calloc(2 * n + 1, 1u);
    if ( v13 && v12 && ptr )
    {
      for ( i = 0; i < n; ++i )
      {
        sprintf((char *)v13 + 2 * i, "%02x", a3[i]);
        sprintf((char *)v12 + 2 * i, "%02x", *(unsigned __int8 *)(a1[122] + v15 + i));
        sprintf((char *)ptr + 2 * i, "%02x", *(unsigned __int8 *)(a1[122] + v14 + i));
      }
      V_LOCK();
      sub_AB2BC((int)v9, (int)a1[63]);
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v10,
        v9[0],
        v9[1],
        v9[2],
        v9[3],
        v9[4],
        v9[5],
        v9[6],
        v10,
        "asic %d repeat nonce %s %s %s",
        a2,
        v13,
        v12,
        ptr);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/backend_base.c",
        160,
        "platform_check_repeat_nonce",
        27,
        93,
        20,
        v8);
    }
    if ( ptr )
      free(ptr);
    if ( v12 )
      free(v12);
    if ( v13 )
      free(v13);
    return 4;
  }
  else
  {
    memcpy((void *)(a1[122] + v14), (const void *)(a1[122] + v15), n);
    memcpy((void *)(a1[122] + v15), a3, n);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000AB908) --------------------------------------------------------
int __fastcall scanhash(_DWORD *a1)
{
  int v1; // r0
  unsigned int v2; // r0
  int v3; // r3
  int v4; // r3
  char v6[72]; // [sp+1Ch] [bp-1248h] BYREF
  char v7; // [sp+101Fh] [bp-245h] BYREF
  int v8; // [sp+1020h] [bp-244h] BYREF
  int v9; // [sp+1024h] [bp-240h] BYREF
  char v10[512]; // [sp+1028h] [bp-23Ch] BYREF
  unsigned int v11; // [sp+1228h] [bp-3Ch]
  unsigned int v12; // [sp+122Ch] [bp-38h]
  unsigned int v13; // [sp+1230h] [bp-34h]
  void *v14; // [sp+1234h] [bp-30h]
  void *ptr; // [sp+1238h] [bp-2Ch]
  int v16; // [sp+123Ch] [bp-28h]
  char *s; // [sp+1240h] [bp-24h]
  _DWORD *v18; // [sp+1244h] [bp-20h]
  int v19; // [sp+1248h] [bp-1Ch]
  unsigned int v20; // [sp+124Ch] [bp-18h]
  int v21; // [sp+1250h] [bp-14h]
  unsigned int v22; // [sp+1254h] [bp-10h]

  v18 = a1;
  s = (char *)calloc(1u, 0x40u);
  snprintf(s, 0x40u, "%.10s_%d", "scanhash", v18[62]);
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v6, 0x1000u, 0, "%s on pid %ld", s, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_base.c",
    160,
    "scanhash",
    8,
    110,
    40,
    v6);
  prctl(15, s);
  v16 = v18[215];
  memset(v10, 0, sizeof(v10));
  ptr = calloc(1u, v18[208]);
  v14 = calloc(1u, v18[209]);
  v19 = 0;
  v20 = 1;
  v21 = 0;
  v22 = 1;
  while ( 1 )
  {
    memset(v10, 0, sizeof(v10));
    queue_dequeue(v16, v10, 1u);
    if ( *((_BYTE *)v18 + 1020) )
    {
      *((_BYTE *)v18 + 1020) = 0;
      goto LABEL_43;
    }
    while ( 1 )
    {
      while ( (unsigned __int8)v10[0] != 170 )
      {
        queue_dequeue(v16, v10, 1u);
        sub_AB334((int)(v18 + 286), 1, (unsigned __int8 *)v10, v18[63]);
        if ( *((_BYTE *)v18 + 1020) )
        {
          *((_BYTE *)v18 + 1020) = 0;
          goto LABEL_43;
        }
      }
      queue_dequeue(v16, &v10[1], 1u);
      if ( *((_BYTE *)v18 + 1020) )
      {
        *((_BYTE *)v18 + 1020) = 0;
        goto LABEL_43;
      }
      if ( v10[1] == 85 )
        break;
      v10[0] = v10[1];
      sub_AB334((int)(v18 + 286), 2, (unsigned __int8 *)v10, v18[63]);
    }
    queue_dequeue(v16, &v10[2], v18[213] - 2);
    v13 = ((int (__fastcall *)(char *))v18[44])(v10);
    queue_dequeue(v16, &v10[v18[213]], v13);
    sub_AB334((int)(v18 + 286), v18[213] + v13, (unsigned __int8 *)v10, v18[63]);
    if ( *((_BYTE *)v18 + 1020) )
      break;
    memset(ptr, 0, v18[208]);
    v9 = 0;
    v8 = 0;
    v7 = 0;
    v2 = ((int (__fastcall *)(_DWORD *, char *, void *, char *, void *, int *, int *))v18[18])(
           v18,
           v10,
           ptr,
           &v7,
           v14,
           &v9,
           &v8);
    v12 = v2;
    if ( v2 == 100 )
    {
      if ( (unsigned __int8)queue_enqueue(v18[217], v10, v13 + 3) != 1 && ++v19 >= v20 )
      {
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, "chain[%d], queue_enqueue of __low_priority_resp_packet_queue is false", v18[63]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_base.c",
          160,
          "scanhash",
          8,
          220,
          40,
          v6);
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, "low_priority_enqueue_fail_cnt = %d, low_priority_enqueue_fail_limit = %d", v19, v20);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/backend_base.c",
          160,
          "scanhash",
          8,
          221,
          40,
          v6);
        v4 = 10000000;
        if ( 10 * v20 < 0x989680 )
          v4 = 10 * v20;
        v20 = v4;
        v19 = 0;
      }
    }
    else if ( v2 > 0x64 )
    {
      if ( v2 == 101 )
        ++*(_QWORD *)(v18[114] + 40);
    }
    else if ( !v2 && *((_BYTE *)v18 + 258) == 1 )
    {
      if ( *((_BYTE *)v18 + v8 + 536) != 1 && v7 && platform_check_repeat_nonce(v18, v9, (unsigned __int8 *)v14) )
      {
        ++*(_QWORD *)(v18[114] + 48 * v9 + 32);
      }
      else
      {
        v11 = ((int (__fastcall *)(_DWORD *, void *))v18[19])(v18, ptr);
        if ( v11 <= 5 )
        {
          ++*(_QWORD *)(v18[114] + 48 * v9 + 8 * v11);
          if ( v11 <= 1 )
          {
            ++*(_DWORD *)(v18[120] + 4 * v9);
            ++*((_QWORD *)v18 + 56);
            ++*(_QWORD *)&v18[2 * v8 + 142];
            if ( !v11
              && *((_BYTE *)v18 + v8 + 536) != 1
              && (unsigned __int8)queue_enqueue(*(_DWORD *)(v18[251] + 864), (char *)ptr, 1) != 1
              && ++v21 >= v22 )
            {
              V_LOCK();
              logfmt_raw(v6, 0x1000u, 0, "chain[%d], queue_enqueue of __nonce_retrieve_queue is false", v18[63]);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/backend_base.c",
                160,
                "scanhash",
                8,
                195,
                40,
                v6);
              V_LOCK();
              logfmt_raw(v6, 0x1000u, 0, "nonce_enqueue_fail_cnt = %d, nonce_enqueue_fail_limit = %d", v21, v22);
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/backend/backend_base.c",
                160,
                "scanhash",
                8,
                196,
                40,
                v6);
              v3 = 10000000;
              if ( 10 * v22 < 0x989680 )
                v3 = 10 * v22;
              v22 = v3;
              v21 = 0;
            }
          }
        }
      }
    }
  }
  *((_BYTE *)v18 + 1020) = 0;
LABEL_43:
  free(ptr);
  free(v14);
  return 0;
}
// 2B: found interdependent unknown calls
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000AC1E8) --------------------------------------------------------
int __fastcall get_response(int a1)
{
  int v1; // r0
  int (**v2)(); // r0
  int v3; // r3
  __useconds_t v4; // r3
  char v6[40]; // [sp+1Ch] [bp-1128h] BYREF
  char v7[256]; // [sp+101Ch] [bp-128h] BYREF
  size_t n; // [sp+111Ch] [bp-28h]
  int v9; // [sp+1120h] [bp-24h]
  __useconds_t useconds; // [sp+1124h] [bp-20h]
  __useconds_t v11; // [sp+1128h] [bp-1Ch]
  int v12; // [sp+112Ch] [bp-18h]
  int v13; // [sp+1130h] [bp-14h]
  unsigned int v14; // [sp+1134h] [bp-10h]
  int v15; // [sp+1138h] [bp-Ch]
  char *s; // [sp+113Ch] [bp-8h]

  v15 = a1;
  s = (char *)calloc(1u, 0x40u);
  snprintf(s, 0x40u, "%.10s_%d", "get_response", *(_DWORD *)(v15 + 248));
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v6, 0x1000u, 0, "%s on pid %ld", s, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/backend_base.c",
    160,
    "get_response",
    12,
    248,
    40,
    v6);
  prctl(15, s);
  memset(v7, 0, sizeof(v7));
  useconds = 64;
  v11 = 64;
  v9 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 1;
  while ( 1 )
  {
    v2 = dev_ctrl();
    n = ((int (__fastcall *)(_DWORD, char *, int))v2[15])(*(_DWORD *)(v15 + 248), v7, 256);
    if ( *(_BYTE *)(v15 + 1021) )
      break;
    if ( (int)n <= 0 )
    {
      usleep(v11);
      v11 *= 2;
      v4 = v11;
      if ( v11 >= 0x3E8 )
        v4 = 1000;
      v11 = v4;
    }
    else
    {
      v9 = queue_element_num(*(_DWORD *)(v15 + 860));
      if ( v9 <= 0x4000 )
      {
        if ( (unsigned __int8)queue_enqueue(*(_DWORD *)(v15 + 860), v7, n) != 1 && ++v13 >= v14 )
        {
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, "chain[%d], queue_enqueue of __resp_packet_queue is false", *(_DWORD *)(v15 + 252));
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/backend_base.c",
            160,
            "get_response",
            12,
            281,
            40,
            v6);
          V_LOCK();
          logfmt_raw(v6, 0x1000u, 0, "enqueue_fail_cnt = %d, enqueue_fail_limit = %d", v13, v14);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/backend_base.c",
            160,
            "get_response",
            12,
            282,
            40,
            v6);
          v3 = 10000000;
          if ( 10 * v14 < 0x989680 )
            v3 = 10 * v14;
          v14 = v3;
          v13 = 0;
        }
        v11 = useconds;
        memset(v7, 0, n);
      }
      else
      {
        if ( !v12 )
        {
          V_LOCK();
          logfmt_raw(
            v6,
            0x1000u,
            0,
            "chain[%d], queue_element_num reach limit, pls check runtime->__resp_packet_queue",
            *(_DWORD *)(v15 + 252));
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/backend_base.c",
            160,
            "get_response",
            12,
            267,
            40,
            v6);
          v12 = 1;
        }
        usleep(useconds);
      }
    }
  }
  *(_BYTE *)(v15 + 1021) = 0;
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000AC60C) --------------------------------------------------------
int __fastcall backend_exit_base(int a1)
{
  int (**v1)(); // r0
  void *thread_return; // [sp+8h] [bp-14h] BYREF
  int k; // [sp+Ch] [bp-10h]
  int j; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  *(_BYTE *)(a1 + 257) = 0;
  *(_BYTE *)(a1 + 258) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  (*(void (__fastcall **)(int))(a1 + 60))(a1);
  if ( *(_DWORD *)(a1 + 84) )
    (*(void (__fastcall **)(int))(a1 + 84))(a1);
  *(_BYTE *)(a1 + 1020) = 1;
  *(_BYTE *)(a1 + 1021) = 1;
  *(_BYTE *)(a1 + 1022) = 1;
  queue_force_wakeup(*(_DWORD *)(a1 + 860));
  queue_force_wakeup(*(_DWORD *)(a1 + 864));
  queue_force_wakeup(*(_DWORD *)(a1 + 868));
  queue_force_wakeup(*(_DWORD *)(a1 + 856));
  for ( i = 0; i < *(_DWORD *)(a1 + 1000); ++i )
    queue_force_wakeup(*(_DWORD *)(a1 + 4 * (i + 218)));
  pthread_join(*(_DWORD *)(a1 + 1012), &thread_return);
  pthread_join(*(_DWORD *)(a1 + 1008), &thread_return);
  pthread_join(*(_DWORD *)(a1 + 1016), &thread_return);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1024));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1048));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1072));
  queue_free(*(_DWORD *)(a1 + 860));
  queue_free(*(_DWORD *)(a1 + 864));
  queue_free(*(_DWORD *)(a1 + 868));
  queue_free(*(_DWORD *)(a1 + 856));
  for ( j = 0; j < *(_DWORD *)(a1 + 1000); ++j )
    queue_free(*(_DWORD *)(a1 + 4 * (j + 218)));
  free(*(void **)(a1 + 492));
  free(*(void **)(a1 + 480));
  free(*(void **)(a1 + 488));
  free(*(void **)(a1 + 456));
  for ( k = 0; k < *(_DWORD *)(a1 + 336); ++k )
    pthread_mutex_destroy((pthread_mutex_t *)(*(_DWORD *)(a1 + 528) + 44 * k + 20));
  free(*(void **)(a1 + 528));
  if ( *(_DWORD *)(a1 + 848) )
    free(*(void **)(a1 + 516));
  *(_DWORD *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 428) = -1;
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 1004) = 0;
  v1 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v1[7])(*(_DWORD *)(a1 + 248));
  return 0;
}

//----- (000AC940) --------------------------------------------------------
int __fastcall async_push_work_base(int a1, char *a2)
{
  queue_enqueue(*(_DWORD *)(a1 + 856), a2, 1);
  return 0;
}

//----- (000AC97C) --------------------------------------------------------
int set_frequency_by_temp_single_base()
{
  return 106;
}

//----- (000AC9B0) --------------------------------------------------------
int update_temp_bias_freq_base()
{
  return 106;
}

//----- (000AC9D8) --------------------------------------------------------
int set_frequency_automatic_single_base()
{
  return 1;
}

//----- (000ACA08) --------------------------------------------------------
int __fastcall get_chip_temperature_str_base(int a1, _BYTE *a2, unsigned int a3)
{
  int v3; // r3
  int v5; // [sp+4h] [bp-18h]
  int i; // [sp+10h] [bp-Ch]
  int v9; // [sp+14h] [bp-8h]

  *a2 = 0;
  v9 = 0;
  v3 = a3;
  if ( a3 >= 0xFA0 )
    v3 = 4000;
  v5 = v3;
  for ( i = 0; i < *(_DWORD *)(a1 + 336); ++i )
    v9 += snprintf(&a2[v9], v5 - v9, "%d ", *(_DWORD *)(*(_DWORD *)(a1 + 528) + 44 * i));
  return 0;
}

//----- (000ACAD8) --------------------------------------------------------
int set_frequency_single_base()
{
  return 106;
}

//----- (000ACB0C) --------------------------------------------------------
int __fastcall push_work_base(int a1, int a2)
{
  int (**v3)(); // r0
  unsigned int v4; // r0
  int (**v5)(); // r0
  char v9[24]; // [sp+1Ch] [bp-1018h] BYREF
  unsigned int v10; // [sp+101Ch] [bp-18h] BYREF
  int v11; // [sp+1020h] [bp-14h]
  void *ptr; // [sp+1024h] [bp-10h]

  if ( *(_BYTE *)(a1 + 258) != 1 && *(_BYTE *)(a1 + 257) != 1 )
    return 103;
  ptr = calloc(1u, *(_DWORD *)(a1 + 840));
  v10 = 0;
  (*(void (__fastcall **)(int, int, void *, unsigned int *))(a1 + 68))(a1, a2, ptr, &v10);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1072));
  do
  {
    v3 = dev_ctrl();
    v4 = ((int (__fastcall *)(_DWORD))v3[17])(*(_DWORD *)(a1 + 248));
  }
  while ( v4 < v10 );
  v5 = dev_ctrl();
  v11 = ((int (__fastcall *)(_DWORD, void *, unsigned int))v5[13])(*(_DWORD *)(a1 + 248), ptr, v10);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1072));
  sub_AB2F0(a1 + 1216, v10, (unsigned __int8 *)ptr, *(_DWORD *)(a1 + 252));
  if ( v11 > 0 )
  {
    ++*(_QWORD *)(a1 + 440);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "device %d push work failed,errcode %d", *(_DWORD *)(a1 + 248), v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/backend_base.c",
      160,
      "push_work_base",
      14,
      432,
      100,
      v9);
  }
  free(ptr);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000ACD8C) --------------------------------------------------------
int __fastcall pop_ans_base(int a1, char *a2)
{
  queue_dequeue(*(_DWORD *)(*(_DWORD *)(a1 + 1004) + 864), a2, 1u);
  return 0;
}

//----- (000ACDCC) --------------------------------------------------------
int __fastcall try_pop_ans_base(int a1, char *a2)
{
  return queue_try_dequeue(*(_DWORD *)(*(_DWORD *)(a1 + 1004) + 864), a2, 1u);
}

//----- (000ACE0C) --------------------------------------------------------
int __fastcall backend_init_base(int a1)
{
  int (**v1)(); // r0
  int (**v2)(); // r0
  int (**v3)(); // r0
  int j; // [sp+8h] [bp-Ch]
  int i; // [sp+Ch] [bp-8h]

  v1 = dev_ctrl();
  *(_DWORD *)(a1 + 252) = ((int (__fastcall *)(_DWORD))v1[12])(*(_DWORD *)(a1 + 248));
  v2 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v2[11])(*(_DWORD *)(a1 + 248));
  v3 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v3[1])(*(_DWORD *)(a1 + 248));
  *(_DWORD *)(a1 + 860) = queue_new(1, 0);
  *(_DWORD *)(a1 + 864) = queue_new(*(_DWORD *)(a1 + 832), 0);
  *(_DWORD *)(a1 + 868) = queue_new(1, 0);
  for ( i = 0; i < *(_DWORD *)(a1 + 1000); ++i )
    *(_DWORD *)(a1 + 4 * (i + 218)) = queue_new(1, 0);
  *(_DWORD *)(a1 + 856) = queue_new(*(_DWORD *)(a1 + 828), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 1024), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 1048), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 1072), 0);
  *(_DWORD *)(a1 + 492) = calloc(*(_DWORD *)(a1 + 336), 1u);
  *(_DWORD *)(a1 + 480) = calloc(*(_DWORD *)(a1 + 336), 4u);
  *(_DWORD *)(a1 + 488) = calloc(*(_DWORD *)(a1 + 336), 2 * *(_DWORD *)(a1 + 836));
  *(_DWORD *)(a1 + 456) = calloc(*(_DWORD *)(a1 + 336), 0x30u);
  *(_DWORD *)(a1 + 528) = calloc(*(_DWORD *)(a1 + 336), 0x2Cu);
  for ( j = 0; j < *(_DWORD *)(a1 + 336); ++j )
    pthread_mutex_init((pthread_mutex_t *)(*(_DWORD *)(a1 + 528) + 44 * j + 20), 0);
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 428) = -1;
  *(_BYTE *)(a1 + 460) = 0;
  *(_DWORD *)(a1 + 472) = 0;
  *(_DWORD *)(a1 + 476) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  *(_DWORD *)(a1 + 512) = 0;
  if ( *(_DWORD *)(a1 + 848) )
    *(_DWORD *)(a1 + 516) = calloc(*(_DWORD *)(a1 + 336), *(_DWORD *)(a1 + 848));
  *(_DWORD *)(a1 + 520) = 0;
  memset((void *)(a1 + 568), 0, 0x100u);
  *(_BYTE *)(a1 + 1020) = 0;
  *(_BYTE *)(a1 + 1021) = 0;
  *(_BYTE *)(a1 + 1022) = 0;
  if ( !*(_DWORD *)(a1 + 1004) )
    *(_DWORD *)(a1 + 1004) = a1;
  if ( *(_DWORD *)(a1 + 80) )
    (*(void (__fastcall **)(int))(a1 + 80))(a1);
  pthread_create((pthread_t *)(a1 + 1012), 0, (void *(*)(void *))get_response, (void *)a1);
  pthread_create((pthread_t *)(a1 + 1008), 0, (void *(*)(void *))scanhash, (void *)a1);
  pthread_create((pthread_t *)(a1 + 1016), 0, (void *(*)(void *))send_work, (void *)a1);
  *(_BYTE *)(a1 + 256) = 1;
  return 0;
}

//----- (000AD220) --------------------------------------------------------
int __fastcall reset_base(int a1)
{
  int (**v1)(); // r0

  (*(void (__fastcall **)(int))(a1 + 60))(a1);
  v1 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v1[11])(*(_DWORD *)(a1 + 248));
  queue_clear(*(_DWORD *)(a1 + 860));
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 520) = 0;
  memset(*(void **)(a1 + 516), 0, *(_DWORD *)(a1 + 848) * *(_DWORD *)(a1 + 336));
  return 0;
}

//----- (000AD2CC) --------------------------------------------------------
int __fastcall dhash_mining_start_base(int a1)
{
  *(_BYTE *)(a1 + 258) = 1;
  return 0;
}

//----- (000AD2FC) --------------------------------------------------------
int __fastcall dhash_mining_stop_base(int a1)
{
  (*(void (__fastcall **)(int))(a1 + 4))(a1);
  *(_BYTE *)(a1 + 257) = 0;
  *(_BYTE *)(a1 + 258) = 0;
  return 0;
}

//----- (000AD344) --------------------------------------------------------
int __fastcall dhash_mining_reset_base(int a1)
{
  __int64 v1; // r0
  int (**v2)(); // r0
  int (**v3)(); // r0
  int (**v4)(); // r0
  int (**v5)(); // r0
  char v8[44]; // [sp+30h] [bp-102Ch] BYREF
  _DWORD v9[7]; // [sp+1030h] [bp-2Ch] BYREF
  int v10; // [sp+104Ch] [bp-10h]

  V_LOCK();
  sub_AB2BC((int)v9, *(int *)(a1 + 252));
  logfmt_raw(v8, 0x1000u, 0, v10, v9[0], v9[1], v9[2], v9[3], v9[4], v9[5], v9[6], v10, "dhash mining reset!");
  V_UNLOCK();
  v1 = zlog(
         g_zc,
         "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmin"
         "er-origin_godminer-branch1/backend/backend_base.c",
         160,
         "dhash_mining_reset_base",
         23,
         568,
         80,
         v8);
  (*(void (__fastcall **)(int, _DWORD))(a1 + 4))(a1, HIDWORD(v1));
  *(_BYTE *)(a1 + 257) = 0;
  *(_BYTE *)(a1 + 258) = 0;
  v2 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v2[7])(*(_DWORD *)(a1 + 248));
  sleep(0xAu);
  v3 = dev_ctrl();
  ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v3[6])(
    *(_DWORD *)(a1 + 248),
    *(_DWORD *)(a1 + 1108),
    *(_DWORD *)(a1 + 1128));
  sleep(1u);
  v4 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v4[11])(*(_DWORD *)(a1 + 248));
  v5 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v5[1])(*(_DWORD *)(a1 + 248));
  (*(void (__fastcall **)(int))(a1 + 16))(a1);
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000AD54C) --------------------------------------------------------
int __fastcall set_chipaddr_base(int a1, int a2, int a3)
{
  char v4; // r0
  _BYTE v9[7]; // [sp+14h] [bp-10h] BYREF
  int i; // [sp+1Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  (*(void (__fastcall **)(int))(a1 + 264))(a1);
  usleep(0x4E20u);
  *(_DWORD *)v9 = 4237909;
  *(_DWORD *)&v9[3] = 5;
  for ( i = 0; i < a3; ++i )
  {
    v9[4] = *(_BYTE *)(a2 + i);
    v4 = BM_CRC5(&v9[2], 8 * (v9[3] - 1));
    v9[6] = v9[6] & 0xE0 | v4 & 0x1F;
    send_command_packet(a1, v9, 7u);
    usleep(0x4E20u);
  }
  return 0;
}

//----- (000AD674) --------------------------------------------------------
int __fastcall set_inactive_base(int a1)
{
  char v2; // r0
  _BYTE v5[7]; // [sp+8h] [bp-Ch] BYREF

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  *(_DWORD *)v5 = 5483093;
  *(_DWORD *)&v5[3] = 5;
  v2 = BM_CRC5(&v5[2], 0x20u);
  v5[6] = v5[6] & 0xE0 | v2 & 0x1F;
  send_command_packet(a1, v5, 7u);
  return 0;
}

//----- (000AD754) --------------------------------------------------------
int __fastcall set_chip_reg_base(int a1, int a2)
{
  char v3; // r0
  unsigned __int8 v6[2]; // [sp+Ch] [bp-10h] BYREF
  char v7; // [sp+Eh] [bp-Eh] BYREF
  __int64 v8; // [sp+Fh] [bp-Dh]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v8 = 0;
  v6[0] = 85;
  v6[1] = -86;
  v7 = 1;
  v7 = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1E | 0x41;
  LOBYTE(v8) = 9;
  BYTE1(v8) = *(_BYTE *)(a2 + 9);
  BYTE2(v8) = *(_WORD *)(a2 + 10);
  *(_DWORD *)((char *)&v8 + 3) = reverse_byte_order_32(*(_DWORD *)a2);
  v3 = BM_CRC5(&v7, 0x40u);
  HIBYTE(v8) = HIBYTE(v8) & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, v6, 0xBu);
  return 0;
}

//----- (000AD878) --------------------------------------------------------
int __fastcall sync_get_status_unclear_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _DWORD v13[2]; // [sp+14h] [bp-28h] BYREF
  char v14[2]; // [sp+1Ch] [bp-20h] BYREF
  int v15; // [sp+1Eh] [bp-1Eh] BYREF
  char v16; // [sp+22h] [bp-1Ah]
  unsigned __int8 v17; // [sp+23h] [bp-19h]
  char v18; // [sp+25h] [bp-17h]
  int v19; // [sp+28h] [bp-14h]
  int v20; // [sp+2Ch] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  v20 = 0;
  v19 = 0;
  sub_CCDFC(a5, 0x3E8u);
  v13[1] = (_DWORD)&unk_F4240 * v6;
  v13[0] = sub_CCDFC(a5, 0x3E8u);
  while ( v20 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v14, 0xAu, v13) == 110 )
    {
      v19 = 3;
      break;
    }
    if ( (unsigned __int8)v14[0] != 170 || v14[1] != 85 )
    {
      v19 = 1;
      break;
    }
    v7 = v18 & 0x1F;
    if ( v7 == BM_CRC5(&v15, 0x3Bu) )
    {
      *(_BYTE *)(a3 + 12 * v20 + 4) = v16;
      *(_WORD *)(a3 + 12 * v20 + 6) = v17;
      *(_DWORD *)(a3 + 12 * v20++) = v15;
    }
    else
    {
      v19 = 2;
    }
  }
  *a4 = v20;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v19;
}
// AD8F0: variable 'v6' is possibly undefined

//----- (000ADA50) --------------------------------------------------------
int __fastcall sync_get_dag_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  unsigned __int16 v7; // r0
  unsigned int *v8; // r4
  __int16 *v9; // r12
  _DWORD *v10; // r5
  int v11; // r1
  int v12; // r2
  int v13; // r3
  char v19[48]; // [sp+24h] [bp-1070h] BYREF
  _DWORD v20[2]; // [sp+1024h] [bp-70h] BYREF
  unsigned __int8 v21; // [sp+102Ch] [bp-68h] BYREF
  unsigned __int8 v22; // [sp+102Dh] [bp-67h]
  char v23; // [sp+102Eh] [bp-66h] BYREF
  unsigned __int8 v24; // [sp+102Fh] [bp-65h]
  unsigned int v25; // [sp+1030h] [bp-64h]
  char v26; // [sp+1034h] [bp-60h] BYREF
  __int16 v27; // [sp+1074h] [bp-20h] BYREF
  __int16 v28; // [sp+1076h] [bp-1Eh]
  int v29; // [sp+1078h] [bp-1Ch]
  int v30; // [sp+107Ch] [bp-18h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  v30 = 0;
  v29 = 0;
  sub_CCDFC(a5, 0x3E8u);
  v20[1] = (_DWORD)&unk_F4240 * v6;
  v20[0] = sub_CCDFC(a5, 0x3E8u);
  while ( v30 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), (char *)&v21, 0x4Au, v20) == 110 )
    {
      v29 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(v19, 0x1000u, 0, "[DAG] header:%02x%02x chip_addr:%02x", v21, v22, v24);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/chip_reg_io_base.c",
      164,
      "sync_get_dag_base",
      17,
      241,
      20,
      v19);
    if ( v21 != 170 || v22 != 85 )
    {
      v29 = 1;
      break;
    }
    v7 = BM_CRC16(&v23, 70);
    v28 = HIBYTE(v7) | (v7 << 8);
    if ( v28 == v27 )
    {
      *(_BYTE *)(a3 + 76 * v30 + 4) = v24;
      v8 = (unsigned int *)(a3 + 76 * v30);
      *v8 = reverse_byte_order_32(v25);
      v9 = (__int16 *)&v26;
      v10 = (_DWORD *)(a3 + 76 * v30 + 10);
      do
      {
        v11 = *((_DWORD *)v9 + 1);
        v12 = *((_DWORD *)v9 + 2);
        v13 = *((_DWORD *)v9 + 3);
        *v10 = *(_DWORD *)v9;
        v10[1] = v11;
        v10[2] = v12;
        v10[3] = v13;
        v9 += 8;
        v10 += 4;
      }
      while ( v9 != &v27 );
      ++v30;
    }
    else
    {
      v29 = 2;
    }
  }
  *a4 = v30;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v29;
}
// ADB14: variable 'v6' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000ADD98) --------------------------------------------------------
int __fastcall sync_get_dag_node_rvn(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  unsigned __int16 v7; // r0
  int v8; // r4
  char v14[44]; // [sp+20h] [bp-112Ch] BYREF
  _DWORD v15[2]; // [sp+1020h] [bp-12Ch] BYREF
  unsigned __int8 v16; // [sp+1028h] [bp-124h] BYREF
  unsigned __int8 v17; // [sp+1029h] [bp-123h]
  char v18[2]; // [sp+102Ah] [bp-122h] BYREF
  unsigned __int8 v19; // [sp+102Ch] [bp-120h]
  unsigned int v20; // [sp+102Dh] [bp-11Fh]
  _BYTE v21[64]; // [sp+1031h] [bp-11Bh] BYREF
  __int16 v22; // [sp+1131h] [bp-1Bh]
  __int16 v23; // [sp+1136h] [bp-16h]
  int v24; // [sp+1138h] [bp-14h]
  int v25; // [sp+113Ch] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  v25 = 0;
  v24 = 0;
  sub_CCDFC(a5, 0x3E8u);
  v15[1] = (_DWORD)&unk_F4240 * v6;
  v15[0] = sub_CCDFC(a5, 0x3E8u);
  while ( v25 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), (char *)&v16, 0x10Bu, v15) == 110 )
    {
      v24 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "[DAG] header:%02x%02x chip_addr:%02x", v16, v17, v19);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/chip_reg_io_base.c",
      164,
      "sync_get_dag_node_rvn",
      21,
      299,
      20,
      v14);
    if ( v16 != 170 || v17 != 85 )
    {
      v24 = 1;
      break;
    }
    v7 = BM_CRC16(v18, 263);
    v23 = HIBYTE(v7) | (v7 << 8);
    if ( v23 == v22 )
    {
      *(_BYTE *)(a3 + 268 * v25 + 2) = v19;
      v8 = a3 + 268 * v25;
      *(_DWORD *)(v8 + 4) = reverse_byte_order_32(v20);
      memcpy((void *)(a3 + 268 * v25++ + 8), v21, 0x40u);
    }
    else
    {
      v24 = 2;
    }
  }
  *a4 = v25;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v24;
}
// ADE5C: variable 'v6' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000AE0D0) --------------------------------------------------------
int __fastcall sync_get_chip_reg_base(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // r0
  _BYTE v15[7]; // [sp+18h] [bp-14h] BYREF

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  *(_DWORD *)v15 = 174677;
  *(_DWORD *)&v15[3] = 0;
  v15[2] = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 2;
  v15[2] = v15[2] & 0x1F | 0x40;
  v15[3] = 5;
  v15[4] = *(_BYTE *)(a2 + 9);
  v15[5] = *(_WORD *)(a2 + 10);
  v9 = BM_CRC5(&v15[2], 0x20u);
  v15[6] = v15[6] & 0xE0 | v9 & 0x1F;
  send_command_packet(a1, v15, 7u);
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  return (*(int (__fastcall **)(int, int, int, int, int, int))(a1 + 284))(a1, a3, a4, a5, a7, a8);
}

//----- (000AE224) --------------------------------------------------------
int __fastcall sync_get_dag_node_base(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  char v7; // r0
  unsigned __int8 v13[2]; // [sp+1Ch] [bp-18h] BYREF
  __int64 v14; // [sp+1Eh] [bp-16h] BYREF
  void *s; // [sp+28h] [bp-Ch]
  size_t nmemb; // [sp+2Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v14 = 6;
  v13[0] = 85;
  v13[1] = -86;
  LOBYTE(v14) = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x19 | 0x46;
  BYTE1(v14) = 8;
  BYTE2(v14) = *(_BYTE *)(a2 + 9);
  *(_DWORD *)((char *)&v14 + 3) = reverse_byte_order_32(*(_DWORD *)(a2 + 4));
  nmemb = 8;
  s = calloc(8u, 1u);
  memset(s, 0, 8u);
  memcpy(s, &v14, 7u);
  v7 = BM_CRC5(s, 8 * nmemb);
  HIBYTE(v14) = HIBYTE(v14) & 0xE0 | v7 & 0x1F;
  free(s);
  send_command_packet(a1, v13, 0xAu);
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  return sync_get_dag_base(a1, a3, a4, a5, a6);
}

//----- (000AE3F0) --------------------------------------------------------
int __fastcall set_core_reg_base(int a1, int a2)
{
  char v3; // r0
  unsigned __int8 v6[2]; // [sp+Ch] [bp-10h] BYREF
  char v7; // [sp+Eh] [bp-Eh] BYREF
  char v8; // [sp+Fh] [bp-Dh]
  __int64 v9; // [sp+10h] [bp-Ch]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v8 = 0;
  v9 = 0;
  v6[0] = 85;
  v6[1] = -86;
  v7 = 4;
  v7 = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1B | 0x44;
  v8 = 10;
  LOBYTE(v9) = *(_BYTE *)(a2 + 9);
  BYTE1(v9) = *(_WORD *)(a2 + 10);
  BYTE2(v9) = *(_BYTE *)(a2 + 12);
  *(_DWORD *)((char *)&v9 + 3) = reverse_byte_order_32(*(_DWORD *)a2);
  v3 = BM_CRC5(&v7, 0x48u);
  HIBYTE(v9) = HIBYTE(v9) & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, v6, 0xCu);
  return 0;
}

//----- (000AE51C) --------------------------------------------------------
int __fastcall set_core_reg_rvn(int a1, int a2)
{
  char v3; // r0
  _BYTE v7[14]; // [sp+8h] [bp-14h] BYREF

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  *(_QWORD *)v7 = 305749;
  *(_QWORD *)&v7[6] = 0;
  v7[2] = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1B | 0x44;
  v7[3] = 12;
  v7[4] = *(_BYTE *)(a2 + 9);
  *(_WORD *)&v7[5] = reverse_byte_order_16(*(_WORD *)(a2 + 10) & 0xFFF);
  v7[7] = *(_BYTE *)(a2 + 12);
  v7[8] = *(_BYTE *)(a2 + 13);
  *(_DWORD *)&v7[9] = reverse_byte_order_32(*(_DWORD *)a2);
  v3 = BM_CRC5(&v7[2], 0x58u);
  v7[13] = v7[13] & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, v7, 0xEu);
  return 0;
}

//----- (000AE668) --------------------------------------------------------
int __fastcall set_core_reg_base_9(int a1, int a2)
{
  char v3; // r0
  unsigned __int8 v6[2]; // [sp+Ch] [bp-10h] BYREF
  char v7; // [sp+Eh] [bp-Eh] BYREF
  __int64 v8; // [sp+Fh] [bp-Dh]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v8 = 0;
  v6[0] = 85;
  v6[1] = -86;
  v7 = 4;
  v7 = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 4;
  v7 = v7 & 0x1F | 0x40;
  LOBYTE(v8) = 9;
  BYTE1(v8) = *(_BYTE *)(a2 + 9);
  BYTE2(v8) = *(_WORD *)(a2 + 10);
  BYTE3(v8) = *(_BYTE *)(a2 + 12);
  BYTE4(v8) = BYTE2(*(_DWORD *)a2);
  BYTE5(v8) = BYTE1(*(_DWORD *)a2);
  BYTE6(v8) = *(_DWORD *)a2;
  v3 = BM_CRC5(&v7, 0x40u);
  HIBYTE(v8) = HIBYTE(v8) & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, v6, 0xBu);
  return 0;
}

//----- (000AE7B8) --------------------------------------------------------
int __fastcall sync_get_core_reg_base_3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  char v15[48]; // [sp+34h] [bp-1030h] BYREF
  _DWORD v16[2]; // [sp+1034h] [bp-30h] BYREF
  unsigned __int8 v17; // [sp+103Ch] [bp-28h] BYREF
  unsigned __int8 v18; // [sp+103Dh] [bp-27h]
  char v19; // [sp+103Eh] [bp-26h] BYREF
  unsigned __int8 v20; // [sp+103Fh] [bp-25h]
  unsigned __int8 v21; // [sp+1040h] [bp-24h]
  unsigned __int8 v22; // [sp+1041h] [bp-23h]
  unsigned __int8 v23; // [sp+1042h] [bp-22h]
  unsigned __int8 v24; // [sp+1043h] [bp-21h]
  char v25; // [sp+1044h] [bp-20h]
  __int64 v26; // [sp+1048h] [bp-1Ch] BYREF
  int v27; // [sp+1050h] [bp-14h]
  int v28; // [sp+1054h] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v26 = 371285;
  BYTE2(v26) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 5;
  BYTE2(v26) = BYTE2(v26) & 0x1F | 0x40;
  BYTE3(v26) = 6;
  BYTE4(v26) = *(_BYTE *)(a2 + 9);
  BYTE5(v26) = *(_WORD *)(a2 + 10);
  BYTE6(v26) = *(_BYTE *)(a2 + 12);
  v7 = BM_CRC5((_BYTE *)&v26 + 2, 0x28u);
  HIBYTE(v26) = HIBYTE(v26) & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  send_command_packet(a1, (unsigned __int8 *)&v26, 8u);
  v28 = 0;
  v27 = 0;
  sub_CCDFC(a6, 0x3E8u);
  v16[1] = (_DWORD)&unk_F4240 * v8;
  v16[0] = sub_CCDFC(a6, 0x3E8u);
  while ( v28 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), (char *)&v17, 9u, v16) == 110 )
    {
      v27 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(
      v15,
      0x1000u,
      0,
      "core reg: %02x %02x chip addr %02x reg addr %02x reg value %02x%02x%02x",
      v17,
      v18,
      v23,
      v24,
      v20,
      v21,
      v22);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/chip_reg_io_base.c",
      164,
      "sync_get_core_reg_base_3",
      24,
      602,
      20,
      v15);
    if ( v17 != 170 || v18 != 85 || (v25 & 0x40) == 0 )
    {
      v27 = 1;
      break;
    }
    v9 = v25 & 0x1F;
    if ( v9 == BM_CRC5(&v19, 0x33u) )
    {
      *(_BYTE *)(a4 + 12 * v28 + 4) = v23;
      *(_WORD *)(a4 + 12 * v28 + 6) = v24;
      *(_BYTE *)(a4 + 12 * v28 + 8) = v19;
      *(_DWORD *)(a4 + 12 * v28++) = (v22 << 24) | (v21 << 16) | v20;
    }
    else
    {
      v27 = 2;
    }
  }
  *a5 = v28;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v27;
}
// AE9B8: variable 'v8' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000AEC58) --------------------------------------------------------
int __fastcall sync_get_core_reg_rvn(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _DWORD v15[2]; // [sp+10h] [bp-34h] BYREF
  char v16[2]; // [sp+18h] [bp-2Ch] BYREF
  _BYTE v17[2]; // [sp+1Ah] [bp-2Ah] BYREF
  int v18; // [sp+1Ch] [bp-28h]
  char v19; // [sp+20h] [bp-24h]
  __int16 v20; // [sp+21h] [bp-23h]
  char v21; // [sp+23h] [bp-21h]
  unsigned __int8 v22[2]; // [sp+24h] [bp-20h] BYREF
  __int64 v23; // [sp+26h] [bp-1Eh] BYREF
  int v24; // [sp+30h] [bp-14h]
  int v25; // [sp+34h] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v23 = 5;
  v22[0] = 85;
  v22[1] = -86;
  LOBYTE(v23) = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1A | 0x45;
  BYTE1(v23) = 8;
  BYTE2(v23) = *(_BYTE *)(a2 + 9);
  *(_WORD *)((char *)&v23 + 3) = reverse_byte_order_16(*(_WORD *)(a2 + 10) & 0xFFF);
  BYTE5(v23) = *(_BYTE *)(a2 + 12);
  BYTE6(v23) = 63;
  v7 = BM_CRC5(&v23, 0x38u);
  HIBYTE(v23) = HIBYTE(v23) & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  send_command_packet(a1, v22, 0xAu);
  v25 = 0;
  v24 = 0;
  sub_CCDFC(a6, 0x3E8u);
  v15[1] = (_DWORD)&unk_F4240 * v8;
  v15[0] = sub_CCDFC(a6, 0x3E8u);
  while ( v25 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v16, 0xCu, v15) == 110 )
    {
      v24 = 3;
      break;
    }
    if ( (unsigned __int8)v16[0] != 170 || v16[1] != 85 || v17[0] != 10 || (v21 & 0x40) != 0 )
    {
      v24 = 1;
      break;
    }
    v9 = v21 & 0x1F;
    if ( v9 == BM_CRC5(v17, 0x4Bu) )
    {
      *(_BYTE *)(a4 + 12 * v25 + 4) = v19;
      *(_WORD *)(a4 + 12 * v25 + 6) = v20;
      *(_BYTE *)(a4 + 12 * v25 + 8) = v17[1];
      *(_DWORD *)(a4 + 12 * v25++) = v18;
    }
    else
    {
      v24 = 2;
    }
  }
  *a5 = v25;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v24;
}
// AEDFC: variable 'v8' is possibly undefined

//----- (000AEF98) --------------------------------------------------------
int __fastcall sync_get_core_reg_base(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _DWORD v15[2]; // [sp+14h] [bp-30h] BYREF
  char v16[2]; // [sp+1Ch] [bp-28h] BYREF
  _BYTE v17[2]; // [sp+1Eh] [bp-26h] BYREF
  int v18; // [sp+20h] [bp-24h]
  char v19; // [sp+24h] [bp-20h]
  unsigned __int8 v20; // [sp+25h] [bp-1Fh]
  char v21; // [sp+26h] [bp-1Eh]
  __int64 v22; // [sp+28h] [bp-1Ch] BYREF
  int v23; // [sp+30h] [bp-14h]
  int v24; // [sp+34h] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v22 = 371285;
  BYTE2(v22) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 5;
  BYTE2(v22) = BYTE2(v22) & 0x1F | 0x40;
  BYTE3(v22) = 6;
  BYTE4(v22) = *(_BYTE *)(a2 + 9);
  BYTE5(v22) = *(_WORD *)(a2 + 10);
  BYTE6(v22) = *(_BYTE *)(a2 + 12);
  v7 = BM_CRC5((_BYTE *)&v22 + 2, 0x28u);
  HIBYTE(v22) = HIBYTE(v22) & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  send_command_packet(a1, (unsigned __int8 *)&v22, 8u);
  v24 = 0;
  v23 = 0;
  sub_CCDFC(a6, 0x3E8u);
  v15[1] = (_DWORD)&unk_F4240 * v8;
  v15[0] = sub_CCDFC(a6, 0x3E8u);
  while ( v24 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v16, 0xBu, v15) == 110 )
    {
      v23 = 3;
      break;
    }
    if ( (unsigned __int8)v16[0] != 170 || v16[1] != 85 || v17[0] != 9 || (v21 & 0x40) == 0 )
    {
      v23 = 1;
      break;
    }
    v9 = v21 & 0x1F;
    if ( v9 == BM_CRC5(v17, 0x43u) )
    {
      *(_BYTE *)(a4 + 12 * v24 + 4) = v19;
      *(_WORD *)(a4 + 12 * v24 + 6) = v20;
      *(_BYTE *)(a4 + 12 * v24 + 8) = v17[1];
      *(_DWORD *)(a4 + 12 * v24++) = v18;
    }
    else
    {
      v23 = 2;
    }
  }
  *a5 = v24;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v23;
}
// AF11C: variable 'v8' is possibly undefined

//----- (000AF2B8) --------------------------------------------------------
int __fastcall sync_get_status_base2(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _DWORD v13[2]; // [sp+14h] [bp-28h] BYREF
  char v14[2]; // [sp+1Ch] [bp-20h] BYREF
  _BYTE v15[3]; // [sp+1Eh] [bp-1Eh] BYREF
  int v16; // [sp+21h] [bp-1Bh]
  char v17; // [sp+25h] [bp-17h]
  int v18; // [sp+28h] [bp-14h]
  int v19; // [sp+2Ch] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  v19 = 0;
  v18 = 0;
  sub_CCDFC(a5, 0x3E8u);
  v13[1] = (_DWORD)&unk_F4240 * v6;
  v13[0] = sub_CCDFC(a5, 0x3E8u);
  while ( v19 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v14, 0xAu, v13) == 110 )
    {
      v18 = 3;
      break;
    }
    if ( (unsigned __int8)v14[0] != 170 || v14[1] != 85 || (v15[0] & 0xF) != 0 || (v15[0] & 0xE0) != 0 )
    {
      v18 = 1;
      break;
    }
    v7 = v17 & 0x1F;
    if ( v7 == BM_CRC5(v15, 0x38u) )
    {
      *(_BYTE *)(a3 + 12 * v19 + 4) = v15[1];
      *(_WORD *)(a3 + 12 * v19 + 6) = v15[2];
      *(_DWORD *)(a3 + 12 * v19++) = v16;
    }
    else
    {
      v18 = 2;
    }
  }
  *a4 = v19;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v18;
}
// AF340: variable 'v6' is possibly undefined

//----- (000AF4CC) --------------------------------------------------------
int __fastcall sync_get_chip_reg_rvn(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  char v7; // r0
  _BYTE v13[7]; // [sp+18h] [bp-Ch] BYREF

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  *(_DWORD *)v13 = 174677;
  *(_DWORD *)&v13[3] = 0;
  v13[2] = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 2;
  v13[2] = v13[2] & 0x1F | 0x40;
  v13[3] = 5;
  v13[4] = *(_BYTE *)(a2 + 9);
  v13[5] = *(_WORD *)(a2 + 10);
  v7 = BM_CRC5(&v13[2], 0x20u);
  v13[6] = v13[6] & 0xE0 | v7 & 0x1F;
  send_command_packet(a1, v13, 7u);
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  return sync_get_status_base4(a1, a3, a4, a5, a6);
}

//----- (000AF618) --------------------------------------------------------
int __fastcall sync_get_chip_reg_base2(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  char v7; // r0
  _BYTE v13[7]; // [sp+18h] [bp-Ch] BYREF

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  *(_DWORD *)v13 = 174677;
  *(_DWORD *)&v13[3] = 0;
  v13[2] = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 2;
  v13[2] = v13[2] & 0x1F | 0x40;
  v13[3] = 5;
  v13[4] = *(_BYTE *)(a2 + 9);
  v13[5] = *(_WORD *)(a2 + 10);
  v7 = BM_CRC5(&v13[2], 0x20u);
  v13[6] = v13[6] & 0xE0 | v7 & 0x1F;
  send_command_packet(a1, v13, 7u);
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  return sync_get_status_base2(a1, a3, a4, a5, a6);
}

//----- (000AF764) --------------------------------------------------------
int __fastcall sync_get_chip_reg_base3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _DWORD v15[2]; // [sp+14h] [bp-30h] BYREF
  char v16[2]; // [sp+1Ch] [bp-28h] BYREF
  char v17; // [sp+1Eh] [bp-26h] BYREF
  int v18; // [sp+1Fh] [bp-25h]
  char v19; // [sp+23h] [bp-21h]
  unsigned __int8 v20; // [sp+24h] [bp-20h]
  char v21; // [sp+25h] [bp-1Fh]
  _BYTE v22[7]; // [sp+28h] [bp-1Ch] BYREF
  int v23; // [sp+30h] [bp-14h]
  int v24; // [sp+34h] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  *(_DWORD *)v22 = 174677;
  *(_DWORD *)&v22[3] = 0;
  v22[2] = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 2;
  v22[2] = v22[2] & 0x1F | 0x40;
  v22[3] = 5;
  v22[4] = *(_BYTE *)(a2 + 9);
  v22[5] = *(_WORD *)(a2 + 10);
  v7 = BM_CRC5(&v22[2], 0x20u);
  v22[6] = v22[6] & 0xE0 | v7 & 0x1F;
  queue_clear(*(_DWORD *)(a1 + 868));
  send_command_packet(a1, v22, 7u);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  v24 = 0;
  v23 = 0;
  sub_CCDFC(a6, 0x3E8u);
  v15[1] = (_DWORD)&unk_F4240 * v8;
  v15[0] = sub_CCDFC(a6, 0x3E8u);
  while ( v24 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v16, 0xAu, v15) == 110 )
    {
      v23 = 3;
      break;
    }
    if ( (unsigned __int8)v16[0] != 170 || v16[1] != 85 || v17 != 8 )
    {
      v23 = 1;
      break;
    }
    v9 = v21 & 0x1F;
    if ( v9 == BM_CRC5(&v17, 0x3Bu) )
    {
      *(_BYTE *)(a4 + 12 * v24 + 4) = v19;
      *(_WORD *)(a4 + 12 * v24 + 6) = v20;
      *(_DWORD *)(a4 + 12 * v24++) = v18;
    }
    else
    {
      v23 = 2;
    }
  }
  *a5 = v24;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v23;
}
// AF8D0: variable 'v8' is possibly undefined

//----- (000AFA40) --------------------------------------------------------
int __fastcall sync_get_status_base4(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _DWORD v13[2]; // [sp+14h] [bp-28h] BYREF
  char v14[2]; // [sp+1Ch] [bp-20h] BYREF
  char v15; // [sp+1Eh] [bp-1Eh] BYREF
  int v16; // [sp+1Fh] [bp-1Dh]
  char v17; // [sp+23h] [bp-19h]
  unsigned __int8 v18; // [sp+24h] [bp-18h]
  char v19; // [sp+25h] [bp-17h]
  int v20; // [sp+28h] [bp-14h]
  int v21; // [sp+2Ch] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  v21 = 0;
  v20 = 0;
  sub_CCDFC(a5, 0x3E8u);
  v13[1] = (_DWORD)&unk_F4240 * v6;
  v13[0] = sub_CCDFC(a5, 0x3E8u);
  while ( v21 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v14, 0xAu, v13) == 110 )
    {
      v20 = 3;
      break;
    }
    if ( (unsigned __int8)v14[0] != 170 || v14[1] != 85 || v15 != 8 )
    {
      v20 = 1;
      break;
    }
    v7 = v19 & 0x1F;
    if ( v7 == BM_CRC5(&v15, 0x3Bu) )
    {
      *(_BYTE *)(a3 + 12 * v21 + 4) = v17;
      *(_WORD *)(a3 + 12 * v21 + 6) = v18;
      *(_DWORD *)(a3 + 12 * v21++) = v16;
    }
    else
    {
      v20 = 2;
    }
  }
  *a4 = v21;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v20;
}
// AFAC8: variable 'v6' is possibly undefined

//----- (000AFC38) --------------------------------------------------------
int __fastcall set_core_reg_base2(int a1, int a2)
{
  char v3; // r0
  _BYTE v7[13]; // [sp+8h] [bp-1Ch] BYREF
  void *s; // [sp+18h] [bp-Ch]
  size_t nmemb; // [sp+1Ch] [bp-8h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  *(_QWORD *)v7 = 305749;
  *(_QWORD *)&v7[5] = 0;
  v7[2] = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1B | 0x44;
  v7[3] = 11;
  v7[4] = *(_BYTE *)(a2 + 9);
  v7[5] = *(_BYTE *)(a2 + 12);
  *(_WORD *)&v7[6] = reverse_byte_order_16(*(_WORD *)(a2 + 10));
  *(_DWORD *)&v7[8] = reverse_byte_order_32(*(_DWORD *)a2);
  nmemb = 12;
  s = calloc(0xCu, 1u);
  memset(s, 0, 0xCu);
  memcpy(s, &v7[2], 0xAu);
  v3 = BM_CRC5(s, 8 * nmemb);
  v7[12] = v7[12] & 0xE0 | v3 & 0x1F;
  free(s);
  send_command_packet(a1, v7, 0xDu);
  return 0;
}

//----- (000AFDE0) --------------------------------------------------------
int __fastcall sync_get_core_reg_base2(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _DWORD v15[2]; // [sp+10h] [bp-3Ch] BYREF
  char v16[2]; // [sp+18h] [bp-34h] BYREF
  _BYTE v17[3]; // [sp+1Ah] [bp-32h] BYREF
  __int16 v18; // [sp+1Dh] [bp-2Fh]
  int v19; // [sp+1Fh] [bp-2Dh]
  char v20; // [sp+23h] [bp-29h]
  unsigned __int8 v21; // [sp+24h] [bp-28h] BYREF
  __int64 v22; // [sp+25h] [bp-27h] BYREF
  void *s; // [sp+30h] [bp-1Ch]
  size_t nmemb; // [sp+34h] [bp-18h]
  int v25; // [sp+38h] [bp-14h]
  int v26; // [sp+3Ch] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v22 = 1450;
  v21 = 85;
  BYTE1(v22) = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1A | 0x45;
  BYTE2(v22) = 7;
  BYTE3(v22) = *(_BYTE *)(a2 + 9);
  BYTE4(v22) = *(_BYTE *)(a2 + 12);
  *(_WORD *)((char *)&v22 + 5) = reverse_byte_order_16(*(_WORD *)(a2 + 10));
  nmemb = 8;
  s = calloc(8u, 1u);
  memset(s, 0, 8u);
  memcpy(s, (char *)&v22 + 1, 6u);
  v7 = BM_CRC5(s, 8 * nmemb);
  HIBYTE(v22) = HIBYTE(v22) & 0xE0 | v7 & 0x1F;
  free(s);
  if ( *(_BYTE *)(a2 + 8) != 1 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  send_command_packet(a1, &v21, 9u);
  v26 = 0;
  v25 = 0;
  sub_CCDFC(a6, 0x3E8u);
  v15[1] = (_DWORD)&unk_F4240 * v8;
  v15[0] = sub_CCDFC(a6, 0x3E8u);
  while ( v26 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v16, 0xCu, v15) == 110 )
    {
      v25 = 3;
      break;
    }
    if ( (unsigned __int8)v16[0] != 170 || v16[1] != 85 || (v17[0] & 0xF) != 1 || (v17[0] & 0xE0) != 0 )
    {
      v25 = 1;
      break;
    }
    v9 = v20 & 0x1F;
    if ( v9 == BM_CRC5(v17, 0x48u) )
    {
      *(_BYTE *)(a4 + 12 * v26 + 4) = v17[1];
      *(_WORD *)(a4 + 12 * v26 + 6) = v18;
      *(_BYTE *)(a4 + 12 * v26 + 8) = v17[2];
      *(_DWORD *)(a4 + 12 * v26++) = v19;
    }
    else
    {
      v25 = 2;
    }
  }
  *a5 = v26;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v25;
}
// AFFE4: variable 'v8' is possibly undefined

//----- (000B0188) --------------------------------------------------------
int __fastcall set_core_enable_base(int a1, int *a2, __useconds_t a3)
{
  int v3; // r3
  int v4; // r3
  char v9[16]; // [sp+24h] [bp-1010h] BYREF
  int v10; // [sp+1024h] [bp-10h]
  int v11; // [sp+1028h] [bp-Ch]
  int i; // [sp+102Ch] [bp-8h]

  v11 = *a2;
  for ( i = 0; ; ++i )
  {
    v4 = i;
    if ( i >= *((unsigned __int8 *)a2 + 13) )
      break;
    if ( (i & 0x1F) == 0 )
    {
      *a2 = -1;
      if ( v11 )
        *a2 = 0;
      *((_WORD *)a2 + 5) += 4 * (i / 32);
    }
    *((_BYTE *)a2 + 12) = i;
    if ( v11 )
    {
      LOBYTE(v3) = i & 0x1F;
      if ( i <= 0 )
        v3 = -(-i & 0x1F);
      *a2 |= 1 << v3;
    }
    else
    {
      *a2 *= 2;
    }
    v10 = (*(int (__fastcall **)(int, int *))(a1 + 276))(a1, a2);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "%s failed, reg:%02x, core_id:%d",
        "set_core_enable_base",
        *((unsigned __int16 *)a2 + 5),
        i);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/chip_reg_io_base.c",
        164,
        "set_core_enable_base",
        20,
        1284,
        100,
        v9);
      return -1;
    }
    usleep(a3);
  }
  return v4;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B0438) --------------------------------------------------------
int __fastcall set_core_enable_base2(int a1, int a2, __useconds_t a3)
{
  int v5; // [sp+4h] [bp-1040h]
  char v9[36]; // [sp+20h] [bp-1024h] BYREF
  _BYTE v10[12]; // [sp+1020h] [bp-24h] BYREF
  int v11; // [sp+102Ch] [bp-18h] BYREF
  int v12; // [sp+1030h] [bp-14h]
  int i; // [sp+1034h] [bp-10h]

  puts("set_core_enable_base2");
  for ( i = 0; i < *(unsigned __int8 *)(a2 + 13); ++i )
  {
    if ( (i & 0x1F) == 0 )
      *(_WORD *)(a2 + 10) += i / 32;
    if ( *(unsigned __int8 *)(a2 + 13) > 1u )
      *(_BYTE *)(a2 + 12) = i;
    v12 = (*(int (__fastcall **)(int, int))(a1 + 276))(a1, a2);
    if ( v12 < 0 )
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "%s failed, reg:%02x, core_id:%d",
        "set_core_enable_base2",
        *(unsigned __int16 *)(a2 + 10),
        i);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/chip_reg_io_base.c",
        164,
        "set_core_enable_base2",
        21,
        1303,
        100,
        v9);
      return 3;
    }
    usleep(a3);
    v11 = 0;
    (*(void (__fastcall **)(int, int, int, _BYTE *, int *, int, int, _DWORD))(a1 + 300))(
      a1,
      a2,
      1,
      v10,
      &v11,
      v5,
      2000,
      0);
  }
  return 0;
}
// B0668: variable 'v5' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B06A8) --------------------------------------------------------
int __fastcall sync_get_status_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  char v13[40]; // [sp+2Ch] [bp-1028h] BYREF
  _DWORD v14[2]; // [sp+102Ch] [bp-28h] BYREF
  unsigned __int8 v15; // [sp+1034h] [bp-20h] BYREF
  unsigned __int8 v16; // [sp+1035h] [bp-1Fh]
  char v17; // [sp+1036h] [bp-1Eh] BYREF
  int v18; // [sp+1037h] [bp-1Dh]
  unsigned __int8 v19; // [sp+103Bh] [bp-19h]
  unsigned __int8 v20; // [sp+103Ch] [bp-18h]
  char v21; // [sp+103Dh] [bp-17h]
  int v22; // [sp+1040h] [bp-14h]
  int v23; // [sp+1044h] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  v23 = 0;
  v22 = 0;
  sub_CCDFC(a5, 0x3E8u);
  v14[1] = (_DWORD)&unk_F4240 * v6;
  v14[0] = sub_CCDFC(a5, 0x3E8u);
  while ( v23 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), (char *)&v15, 0xAu, v14) == 110 )
    {
      v22 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(
      v13,
      0x1000u,
      0,
      "header:%02x%02x chip_addr:%02x, reg value:%08x, reg addr:%02x",
      v15,
      v16,
      v19,
      v18,
      v20);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/chip_reg_io_base.c",
      164,
      "sync_get_status_base",
      20,
      1351,
      20,
      v13);
    if ( v15 != 170 || v16 != 85 || v17 != 8 || (v21 & 0x40) != 0 )
    {
      v22 = 1;
      break;
    }
    v7 = v21 & 0x1F;
    if ( v7 == BM_CRC5(&v17, 0x3Bu) )
    {
      *(_BYTE *)(a3 + 12 * v23 + 4) = v19;
      *(_WORD *)(a3 + 12 * v23 + 6) = v20;
      *(_DWORD *)(a3 + 12 * v23++) = v18;
    }
    else
    {
      v22 = 2;
    }
  }
  *a4 = v23;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v22;
}
// B076C: variable 'v6' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B09E4) --------------------------------------------------------
int __fastcall sync_get_status_base3(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  char v13[40]; // [sp+2Ch] [bp-1028h] BYREF
  _DWORD v14[2]; // [sp+102Ch] [bp-28h] BYREF
  unsigned __int8 v15; // [sp+1034h] [bp-20h] BYREF
  unsigned __int8 v16; // [sp+1035h] [bp-1Fh]
  unsigned __int8 v17; // [sp+1036h] [bp-1Eh] BYREF
  int v18; // [sp+1037h] [bp-1Dh]
  unsigned __int8 v19; // [sp+103Bh] [bp-19h]
  char v20; // [sp+103Ch] [bp-18h]
  int v21; // [sp+1040h] [bp-14h]
  int v22; // [sp+1044h] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  v22 = 0;
  v21 = 0;
  sub_CCDFC(a5, 0x3E8u);
  v14[1] = (_DWORD)&unk_F4240 * v6;
  v14[0] = sub_CCDFC(a5, 0x3E8u);
  while ( v22 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), (char *)&v15, 9u, v14) == 110 )
    {
      v21 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(
      v13,
      0x1000u,
      0,
      "header:%02x%02x chip_addr:%02x, reg value:%08x, reg addr:%02x",
      v15,
      v16,
      v19,
      v18,
      v17);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/chip_reg_io_base.c",
      164,
      "sync_get_status_base3",
      21,
      1419,
      20,
      v13);
    if ( v15 != 170 || v16 != 85 )
    {
      v21 = 1;
      break;
    }
    v7 = v20 & 0x1F;
    if ( v7 == BM_CRC5(&v17, 0x33u) )
    {
      *(_BYTE *)(a3 + 12 * v22 + 4) = v19;
      *(_WORD *)(a3 + 12 * v22 + 6) = v17;
      *(_DWORD *)(a3 + 12 * v22++) = v18;
    }
    else
    {
      v21 = 2;
    }
  }
  *a4 = v22;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v21;
}
// B0AA8: variable 'v6' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B0CEC) --------------------------------------------------------
int __fastcall sync_get_core_reg_base3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _DWORD v15[2]; // [sp+14h] [bp-30h] BYREF
  char v16[2]; // [sp+1Ch] [bp-28h] BYREF
  _BYTE v17[7]; // [sp+1Eh] [bp-26h] BYREF
  char v18; // [sp+25h] [bp-1Fh]
  __int64 v19; // [sp+28h] [bp-1Ch] BYREF
  int v20; // [sp+30h] [bp-14h]
  int v21; // [sp+34h] [bp-10h]

  if ( *(_BYTE *)(a1 + 256) != 1 )
    return 4;
  v19 = 371285;
  BYTE2(v19) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 5;
  BYTE2(v19) = BYTE2(v19) & 0x1F | 0x40;
  BYTE3(v19) = 6;
  BYTE4(v19) = *(_BYTE *)(a2 + 9);
  BYTE5(v19) = *(_WORD *)(a2 + 10);
  BYTE6(v19) = *(_BYTE *)(a2 + 12);
  v7 = BM_CRC5((_BYTE *)&v19 + 2, 0x28u);
  HIBYTE(v19) = HIBYTE(v19) & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1024));
  queue_clear(*(_DWORD *)(a1 + 868));
  send_command_packet(a1, (unsigned __int8 *)&v19, 8u);
  v21 = 0;
  v20 = 0;
  sub_CCDFC(a6, 0x3E8u);
  v15[1] = (_DWORD)&unk_F4240 * v8;
  v15[0] = sub_CCDFC(a6, 0x3E8u);
  while ( v21 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 868), v16, 0xAu, v15) == 110 )
    {
      v20 = 3;
      break;
    }
    if ( (unsigned __int8)v16[0] != 170 || v16[1] != 85 || v17[0] != 8 || (v18 & 0x40) == 0 || v18 < 0 )
    {
      v20 = 1;
      break;
    }
    v9 = v18 & 0x1F;
    if ( v9 == BM_CRC5(v17, 0x3Bu) )
    {
      *(_BYTE *)(a4 + 12 * v21 + 4) = v17[5];
      *(_WORD *)(a4 + 12 * v21 + 6) = v17[6];
      *(_BYTE *)(a4 + 12 * v21 + 8) = v17[1];
      *(_DWORD *)(a4 + 12 * v21++) = (v17[2] << 16) | (v17[3] << 8) | v17[4];
    }
    else
    {
      v20 = 2;
    }
  }
  *a5 = v21;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1024));
  return v20;
}
// B0E70: variable 'v8' is possibly undefined

//----- (000B103C) --------------------------------------------------------
int __fastcall get_fake_regio_runtime(int a1)
{
  int (**v1)(); // r0
  int v2; // r4

  if ( !dword_15FFF0[a1] )
  {
    dword_15FFF0[a1] = calloc(1u, 0x510u);
    *(_DWORD *)(dword_15FFF0[a1] + 248) = a1;
    v1 = dev_ctrl();
    ((void (__fastcall *)(int))v1[1])(a1);
    pthread_mutex_init((pthread_mutex_t *)(dword_15FFF0[a1] + 1024), 0);
    pthread_mutex_init((pthread_mutex_t *)(dword_15FFF0[a1] + 1048), 0);
    v2 = dword_15FFF0[a1];
    *(_DWORD *)(v2 + 868) = queue_new(1, 0);
    *(_DWORD *)(dword_15FFF0[a1] + 860) = *(_DWORD *)(dword_15FFF0[a1] + 868);
    *(_DWORD *)(dword_15FFF0[a1] + 260) = set_chipaddr_base;
    *(_DWORD *)(dword_15FFF0[a1] + 264) = set_inactive_base;
    *(_DWORD *)(dword_15FFF0[a1] + 268) = set_chip_reg_base;
    *(_DWORD *)(dword_15FFF0[a1] + 272) = set_core_reg_base;
    *(_DWORD *)(dword_15FFF0[a1] + 288) = sync_get_chip_reg_base;
    *(_DWORD *)(dword_15FFF0[a1] + 300) = sync_get_core_reg_base;
    *(_BYTE *)(dword_15FFF0[a1] + 256) = 1;
  }
  return dword_15FFF0[a1];
}
// 15FFF0: using guessed type _DWORD dword_15FFF0[256];

//----- (000B1220) --------------------------------------------------------
int __fastcall set_chipaddr_by_id(int a1, int a2, int a3)
{
  int v3; // r3
  int v7; // [sp+14h] [bp-20h] BYREF
  int fake_regio_runtime; // [sp+18h] [bp-1Ch]
  int i; // [sp+1Ch] [bp-18h]
  _DWORD *all_created_runtime; // [sp+20h] [bp-14h]
  int v11; // [sp+24h] [bp-10h]
  int v12; // [sp+28h] [bp-Ch]
  int v13; // [sp+2Ch] [bp-8h]

  v12 = a1;
  v11 = a1;
  v7 = 0;
  all_created_runtime = get_all_created_runtime(&v7);
  for ( i = 0; i < v7; ++i )
  {
    if ( v11 == *(_DWORD *)(all_created_runtime[i] + 248) )
    {
      v3 = all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v3 = 0;
LABEL_7:
  fake_regio_runtime = v3;
  if ( !v3 )
    fake_regio_runtime = get_fake_regio_runtime(v12);
  v13 = fake_regio_runtime;
  return (*(int (__fastcall **)(int, int, int))(fake_regio_runtime + 260))(fake_regio_runtime, a2, a3);
}

//----- (000B1314) --------------------------------------------------------
int __fastcall set_inactive_by_id(int a1)
{
  int v1; // r3
  int v3; // [sp+Ch] [bp-20h] BYREF
  int fake_regio_runtime; // [sp+10h] [bp-1Ch]
  int i; // [sp+14h] [bp-18h]
  _DWORD *all_created_runtime; // [sp+18h] [bp-14h]
  int v7; // [sp+1Ch] [bp-10h]
  int v8; // [sp+20h] [bp-Ch]
  int v9; // [sp+24h] [bp-8h]

  v8 = a1;
  v7 = a1;
  v3 = 0;
  all_created_runtime = get_all_created_runtime(&v3);
  for ( i = 0; i < v3; ++i )
  {
    if ( v7 == *(_DWORD *)(all_created_runtime[i] + 248) )
    {
      v1 = all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v1 = 0;
LABEL_7:
  fake_regio_runtime = v1;
  if ( !v1 )
    fake_regio_runtime = get_fake_regio_runtime(v8);
  v9 = fake_regio_runtime;
  return (*(int (__fastcall **)(int))(fake_regio_runtime + 264))(fake_regio_runtime);
}

//----- (000B13F8) --------------------------------------------------------
int __fastcall set_chip_reg_by_id(int a1, int a2)
{
  int v2; // r3
  int v5; // [sp+Ch] [bp-20h] BYREF
  int fake_regio_runtime; // [sp+10h] [bp-1Ch]
  int i; // [sp+14h] [bp-18h]
  _DWORD *all_created_runtime; // [sp+18h] [bp-14h]
  int v9; // [sp+1Ch] [bp-10h]
  int v10; // [sp+20h] [bp-Ch]
  int v11; // [sp+24h] [bp-8h]

  v10 = a1;
  v9 = a1;
  v5 = 0;
  all_created_runtime = get_all_created_runtime(&v5);
  for ( i = 0; i < v5; ++i )
  {
    if ( v9 == *(_DWORD *)(all_created_runtime[i] + 248) )
    {
      v2 = all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v2 = 0;
LABEL_7:
  fake_regio_runtime = v2;
  if ( !v2 )
    fake_regio_runtime = get_fake_regio_runtime(v10);
  v11 = fake_regio_runtime;
  return (*(int (__fastcall **)(int, int))(fake_regio_runtime + 268))(fake_regio_runtime, a2);
}

//----- (000B14E4) --------------------------------------------------------
int __fastcall set_core_reg_by_id(int a1, int a2)
{
  int v2; // r3
  int v5; // [sp+Ch] [bp-20h] BYREF
  int fake_regio_runtime; // [sp+10h] [bp-1Ch]
  int i; // [sp+14h] [bp-18h]
  _DWORD *all_created_runtime; // [sp+18h] [bp-14h]
  int v9; // [sp+1Ch] [bp-10h]
  int v10; // [sp+20h] [bp-Ch]
  int v11; // [sp+24h] [bp-8h]

  v10 = a1;
  v9 = a1;
  v5 = 0;
  all_created_runtime = get_all_created_runtime(&v5);
  for ( i = 0; i < v5; ++i )
  {
    if ( v9 == *(_DWORD *)(all_created_runtime[i] + 248) )
    {
      v2 = all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v2 = 0;
LABEL_7:
  fake_regio_runtime = v2;
  if ( !v2 )
    fake_regio_runtime = get_fake_regio_runtime(v10);
  v11 = fake_regio_runtime;
  return (*(int (__fastcall **)(int, int))(fake_regio_runtime + 272))(fake_regio_runtime, a2);
}

//----- (000B15D0) --------------------------------------------------------
int __fastcall sync_get_chip_reg_by_id(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // r3
  int v10; // [sp+20h] [bp-2Ch] BYREF
  _DWORD *fake_regio_runtime; // [sp+24h] [bp-28h]
  int i; // [sp+28h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+2Ch] [bp-20h]
  int v14; // [sp+30h] [bp-1Ch]
  int v15; // [sp+34h] [bp-18h]
  int v16; // [sp+38h] [bp-14h]
  void *arg; // [sp+3Ch] [bp-10h]

  v15 = a1;
  v14 = a1;
  v10 = 0;
  all_created_runtime = get_all_created_runtime(&v10);
  for ( i = 0; i < v10; ++i )
  {
    if ( v14 == *(_DWORD *)(all_created_runtime[i] + 248) )
    {
      v5 = (_DWORD *)all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v5 = 0;
LABEL_7:
  fake_regio_runtime = v5;
  if ( !v5 )
    fake_regio_runtime = (_DWORD *)get_fake_regio_runtime(v15);
  arg = fake_regio_runtime;
  if ( fake_regio_runtime[215] == fake_regio_runtime[217] )
    pthread_create((pthread_t *)arg + 253, 0, (void *(*)(void *))get_response, arg);
  v16 = (*((int (__fastcall **)(void *, int, int, int, int))arg + 72))(arg, a2, a3, a4, a5);
  if ( *((_DWORD *)arg + 215) == *((_DWORD *)arg + 217) )
  {
    *((_BYTE *)arg + 1021) = 1;
    pthread_join(*((_DWORD *)arg + 253), 0);
  }
  return v16;
}

//----- (000B174C) --------------------------------------------------------
int __fastcall sync_get_core_reg_by_id(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // r3
  int v10; // [sp+20h] [bp-2Ch] BYREF
  _DWORD *fake_regio_runtime; // [sp+24h] [bp-28h]
  int i; // [sp+28h] [bp-24h]
  _DWORD *all_created_runtime; // [sp+2Ch] [bp-20h]
  int v14; // [sp+30h] [bp-1Ch]
  int v15; // [sp+34h] [bp-18h]
  int v16; // [sp+38h] [bp-14h]
  void *arg; // [sp+3Ch] [bp-10h]

  v15 = a1;
  v14 = a1;
  v10 = 0;
  all_created_runtime = get_all_created_runtime(&v10);
  for ( i = 0; i < v10; ++i )
  {
    if ( v14 == *(_DWORD *)(all_created_runtime[i] + 248) )
    {
      v5 = (_DWORD *)all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v5 = 0;
LABEL_7:
  fake_regio_runtime = v5;
  if ( !v5 )
    fake_regio_runtime = (_DWORD *)get_fake_regio_runtime(v15);
  arg = fake_regio_runtime;
  if ( fake_regio_runtime[215] == fake_regio_runtime[217] )
    pthread_create((pthread_t *)arg + 253, 0, (void *(*)(void *))get_response, arg);
  v16 = (*((int (__fastcall **)(void *, int, int, int, int))arg + 75))(arg, a2, a3, a4, a5);
  if ( *((_DWORD *)arg + 215) == *((_DWORD *)arg + 217) )
  {
    *((_BYTE *)arg + 1021) = 1;
    pthread_join(*((_DWORD *)arg + 253), 0);
  }
  return v16;
}

//----- (000B18C8) --------------------------------------------------------
unsigned int __fastcall sub_B18C8(unsigned int a1)
{
  return bswap32(a1);
}

//----- (000B18F0) --------------------------------------------------------
unsigned int __fastcall sub_B18F0(int a1, int a2, unsigned __int8 *a3, int a4)
{
  return check_and_print_uart_debug_log(a1, a2, a3, a4, 1);
}

//----- (000B1934) --------------------------------------------------------
int __fastcall reverse_byte_order_16(unsigned __int16 a1)
{
  return (unsigned __int16)__rev16(a1);
}

//----- (000B196C) --------------------------------------------------------
unsigned int __fastcall reverse_byte_order_32(unsigned int a1)
{
  return sub_B18C8(a1);
}

//----- (000B1994) --------------------------------------------------------
int __fastcall send_command_packet(int a1, unsigned __int8 *a2, unsigned int a3)
{
  int (**v3)(); // r0
  int (**v4)(); // r0
  char v9[8]; // [sp+24h] [bp-1008h] BYREF
  int v10; // [sp+1024h] [bp-8h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1048));
  v10 = 0;
  while ( 1 )
  {
    v3 = dev_ctrl();
    if ( ((int (__fastcall *)(_DWORD))v3[16])(*(_DWORD *)(a1 + 248)) >= a3 )
      break;
    usleep(0x2710u);
  }
  v4 = dev_ctrl();
  v10 = ((int (__fastcall *)(_DWORD, unsigned __int8 *, unsigned int))v4[14])(*(_DWORD *)(a1 + 248), a2, a3);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1048));
  sub_B18F0(a1 + 1216, a3, a2, *(_DWORD *)(a1 + 252));
  if ( v10 <= 0 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "device %d send cmd failed, errcode %d ", *(_DWORD *)(a1 + 248), v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/chip_reg_io_interface.c",
      169,
      "send_command_packet",
      19,
      46,
      100,
      v9);
  }
  return v10;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B1B74) --------------------------------------------------------
int __fastcall convert_offset_to_chain_id(int a1)
{
  return g_chain_info[2 * a1];
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B1BA4) --------------------------------------------------------
int scan_miner_device_hal()
{
  return total_chain;
}
// 1603F0: using guessed type int total_chain;

//----- (000B1BC8) --------------------------------------------------------
int __fastcall dev_init_hal(int a1)
{
  char v4[20]; // [sp+18h] [bp-1014h] BYREF
  unsigned __int8 v5; // [sp+101Bh] [bp-11h] BYREF
  unsigned int i; // [sp+1020h] [bp-Ch]
  unsigned int hash_on_plug; // [sp+1024h] [bp-8h]

  if ( platform_init() )
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "platform init failed!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/platform_device_hal.c",
      174,
      "dev_init_hal",
      12,
      59,
      100,
      v4);
    return -1;
  }
  else
  {
    total_chain = 0;
    hash_on_plug = get_hash_on_plug();
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( ((hash_on_plug >> i) & 1) != 0 )
      {
        g_chain_info[2 * total_chain] = i;
        LOBYTE(g_chain_info[2 * total_chain + 1]) = 1;
        V_LOCK();
        logfmt_raw(v4, 0x1000u, 0, "chain_offset %d, chain %d", total_chain, g_chain_info[2 * total_chain]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/platform_device_hal.c",
          174,
          "dev_init_hal",
          12,
          69,
          60,
          v4);
        if ( platform_is_pic_mcu_en() )
        {
          if ( open_pic(i) < 0 )
          {
            V_LOCK();
            logfmt_raw(
              v4,
              0x1000u,
              0,
              "chain_offset %d, chain %d, open pic error!",
              total_chain,
              g_chain_info[2 * total_chain]);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/platform_device_hal.c",
              174,
              "dev_init_hal",
              12,
              73,
              100,
              v4);
            return -1;
          }
          pic1704_reset(i);
          usleep(0x493E0u);
          pic1704_jump_to_app(i);
          usleep(0x493E0u);
          if ( !pic1704_get_sw_version(g_chain_info[2 * total_chain], &v5) )
          {
            V_LOCK();
            logfmt_raw(
              v4,
              0x1000u,
              0,
              "chain_offset %d, chain %d, get_sw_version error!",
              total_chain,
              g_chain_info[2 * total_chain]);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/platform_device_hal.c",
              174,
              "dev_init_hal",
              12,
              84,
              100,
              v4);
            return -1;
          }
          V_LOCK();
          logfmt_raw(
            v4,
            0x1000u,
            0,
            "chain_offset %d, chain %d, pic firmware verion = 0x%02x",
            total_chain,
            g_chain_info[2 * total_chain],
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/platform_device_hal.c",
            174,
            "dev_init_hal",
            12,
            90,
            60,
            v4);
        }
        ++total_chain;
      }
    }
    if ( a1 != total_chain )
    {
      set_miner_6060info_board_num_less_than_design_err(1);
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "phyiscal chain num = %d, total chain num = %d", a1, total_chain);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/platform_device_hal.c",
        174,
        "dev_init_hal",
        12,
        99,
        100,
        v4);
    }
    fpga_reset();
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "reset fpga");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/platform_device_hal.c",
      174,
      "dev_init_hal",
      12,
      103,
      20,
      v4);
    enable_bypass_mode();
    dev_config_hal(&word_1C200);
    return 0;
  }
}
// 1C200: using guessed type __int16 word_1C200;
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1603F0: using guessed type int total_chain;
// 1608F0: using guessed type int g_zc;
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B21B0) --------------------------------------------------------
int dev_init_hal_pcba()
{
  char v2[12]; // [sp+10h] [bp-100Ch] BYREF
  unsigned int hash_on_plug; // [sp+1010h] [bp-Ch]
  unsigned int i; // [sp+1014h] [bp-8h]

  if ( platform_init() )
  {
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "platform init failed!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/platform_device_hal.c",
      174,
      "dev_init_hal_pcba",
      17,
      116,
      100,
      v2);
    return -1;
  }
  else
  {
    total_chain = 0;
    hash_on_plug = get_hash_on_plug();
    printf("plug_on_status: %x\n", hash_on_plug);
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( ((hash_on_plug >> i) & 1) != 0 )
      {
        g_chain_info[2 * total_chain] = i;
        LOBYTE(g_chain_info[2 * total_chain + 1]) = 1;
        printf("chain_offset %d, chain %d\n", total_chain, g_chain_info[2 * total_chain]);
        ++total_chain;
      }
    }
    enable_bypass_mode();
    dev_config_hal(&word_1C200);
    return 0;
  }
}
// 1C200: using guessed type __int16 word_1C200;
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1603F0: using guessed type int total_chain;
// 1608F0: using guessed type int g_zc;
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B2360) --------------------------------------------------------
int __fastcall dev_init_pic_for_one_chain(int a1)
{
  char v4[4]; // [sp+18h] [bp-1004h] BYREF

  if ( !platform_is_pic_mcu_en() )
    return 0;
  if ( LOBYTE(g_chain_info[2 * a1 + 1]) == 1 )
  {
    if ( open_pic(g_chain_info[2 * a1]) < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "chain offset %d, id %d, open pic error!\n", a1, g_chain_info[2 * a1]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/platform_device_hal.c",
        174,
        "dev_init_pic_for_one_chain",
        26,
        147,
        100,
        v4);
      return -1;
    }
    if ( !pic1704_reset(g_chain_info[2 * a1]) )
    {
      printf("chain offset %d, id %d, reset pic error!\n", a1, g_chain_info[2 * a1]);
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "Sweep error string = J%d:5.", g_chain_info[2 * a1]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/platform_device_hal.c",
        174,
        "dev_init_pic_for_one_chain",
        26,
        153,
        100,
        v4);
      return -1;
    }
    usleep(0x493E0u);
    if ( !pic1704_jump_to_app(g_chain_info[2 * a1]) )
    {
      printf("chain offset %d, id %d, pic jump to app error!\n", a1, g_chain_info[2 * a1]);
      return -1;
    }
    usleep(0x493E0u);
    return 0;
  }
  printf("Chain offset %d is invalid\n", a1);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B262C) --------------------------------------------------------
int __fastcall sub_dev_init_hal(unsigned int a1)
{
  if ( a1 >= total_chain )
    puts("warning: get pcie fd error");
  return g_chain_info[2 * a1];
}
// 1603F0: using guessed type int total_chain;
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B267C) --------------------------------------------------------
int __fastcall dev_is_valid_hal(int a1)
{
  return LOBYTE(g_chain_info[2 * a1 + 1]);
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B26B4) --------------------------------------------------------
int __fastcall set_dev_invalid_hal(int result)
{
  LOBYTE(g_chain_info[2 * result + 1]) = 0;
  --total_chain;
  return result;
}
// 1603F0: using guessed type int total_chain;
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B270C) --------------------------------------------------------
int __fastcall dev_config_hal(__int16 *a1)
{
  int v3; // [sp+Ch] [bp-18h] BYREF
  int v4; // [sp+10h] [bp-14h] BYREF
  _DWORD *all_created_runtime; // [sp+14h] [bp-10h]
  int i; // [sp+18h] [bp-Ch]
  int v7; // [sp+1Ch] [bp-8h]

  all_created_runtime = get_all_created_runtime(&v3);
  if ( a1 == (__int16 *)1562500 )
    goto LABEL_21;
  if ( (int)a1 <= 1562500 )
  {
    if ( a1 == (__int16 *)&loc_70800 )
    {
      v7 = 6;
      goto LABEL_26;
    }
    if ( (int)a1 <= 460800 )
    {
      if ( a1 != &word_1C200 )
        goto LABEL_25;
      v7 = 26;
      goto LABEL_26;
    }
    if ( a1 == word_E1000 )
    {
      v7 = 2;
      goto LABEL_26;
    }
    if ( a1 != (__int16 *)1500000 )
      goto LABEL_25;
LABEL_21:
    v7 = 1;
    goto LABEL_26;
  }
  if ( a1 == (__int16 *)6250000 )
  {
    v7 = 3;
  }
  else if ( (int)a1 > 6250000 )
  {
    if ( a1 == (__int16 *)12500000 )
    {
      v7 = 4;
    }
    else
    {
      if ( a1 != (__int16 *)25000000 )
      {
LABEL_25:
        v7 = 26;
        goto LABEL_26;
      }
      v7 = 5;
    }
  }
  else
  {
    if ( a1 != (__int16 *)3000000 && a1 != (__int16 *)3125000 )
      goto LABEL_25;
    v7 = 0;
  }
LABEL_26:
  printf("%s: set zynq bt8d %d\n", "dev_config_hal", v7);
  v4 = v7;
  for ( i = 0; i < v3; ++i )
    uart_set_config(*(_DWORD *)(all_created_runtime[i] + 252), 0, &v4, 4u);
  usleep((__useconds_t)"time");
  return 0;
}
// 1C200: using guessed type __int16 word_1C200;
// E1000: using guessed type _WORD[4292];

//----- (000B2900) --------------------------------------------------------
int __fastcall dev_config_one_chain_baud(int a1, __int16 *a2)
{
  int v5; // [sp+Ch] [bp-10h] BYREF
  int v6; // [sp+10h] [bp-Ch] BYREF
  int v7; // [sp+14h] [bp-8h]

  uart_get_config(0, 0, (speed_t *)&v6, &v5);
  printf("%s: get zynq bt8d %08x\n", "dev_config_one_chain_baud", v6);
  if ( a2 == (__int16 *)1562500 )
    goto LABEL_21;
  if ( (int)a2 <= 1562500 )
  {
    if ( a2 == (__int16 *)&loc_70800 )
    {
      v7 = 6;
      goto LABEL_26;
    }
    if ( (int)a2 <= 460800 )
    {
      if ( a2 != &word_1C200 )
        goto LABEL_25;
      v7 = 26;
      goto LABEL_26;
    }
    if ( a2 == word_E1000 )
    {
      v7 = 2;
      goto LABEL_26;
    }
    if ( a2 != (__int16 *)1500000 )
      goto LABEL_25;
LABEL_21:
    v7 = 1;
    goto LABEL_26;
  }
  if ( a2 == (__int16 *)6250000 )
  {
    v7 = 3;
  }
  else if ( (int)a2 > 6250000 )
  {
    if ( a2 == (__int16 *)12500000 )
    {
      v7 = 4;
    }
    else
    {
      if ( a2 != (__int16 *)25000000 )
      {
LABEL_25:
        v7 = 26;
        goto LABEL_26;
      }
      v7 = 5;
    }
  }
  else
  {
    if ( a2 != (__int16 *)3000000 && a2 != (__int16 *)3125000 )
      goto LABEL_25;
    v7 = 0;
  }
LABEL_26:
  printf("%s: set zynq bt8d %d\n", "dev_config_one_chain_baud", v7);
  v6 = (v7 << (8 * a1)) | v6 & ~(63 << (8 * a1));
  uart_set_config(a1, 0, &v6, 4u);
  usleep((__useconds_t)"time");
  uart_get_config(0, 0, (speed_t *)&v6, &v5);
  printf("%s: after set baud, get zynq bt8d %08x\n", "dev_config_one_chain_baud", v6);
  return 0;
}
// 1C200: using guessed type __int16 word_1C200;
// E1000: using guessed type _WORD word_E1000[4292];

//----- (000B2B40) --------------------------------------------------------
int __fastcall dump_log_hal(const char *a1, int a2, int a3, int a4)
{
  int i; // [sp+14h] [bp-8h]

  printf("%s[%d] ", a1, a2);
  for ( i = 0; i < a4; ++i )
    printf("%02x ", *(unsigned __int8 *)(a3 + i));
  return putchar(10);
}

//----- (000B2BCC) --------------------------------------------------------
int __fastcall dev_send_work_cmd_hal(int a1, int a2, unsigned int a3)
{
  int v7; // [sp+10h] [bp-Ch]
  unsigned int i; // [sp+14h] [bp-8h]

  v7 = 0;
  for ( i = 0; a3 >> 7 > i; ++i )
    v7 += uart_send(g_chain_info[2 * a1], a2 + (i << 7), 0x80u);
  return v7 + uart_send(g_chain_info[2 * a1], a2 + (i << 7), a3 & 0x7F);
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B2CB4) --------------------------------------------------------
int __fastcall dev_send_reg_cmd_hal(int a1, int a2, unsigned int a3)
{
  return uart_send(g_chain_info[2 * a1], a2, a3);
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B2CFC) --------------------------------------------------------
int __fastcall dev_read_nonce_reg_data_hal(int a1, void *a2, size_t a3)
{
  return uart_receive(g_chain_info[2 * a1], a2, a3, 0);
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B2D4C) --------------------------------------------------------
int dev_get_nonce_reg_fifo_size_hal()
{
  return 0;
}

//----- (000B2D70) --------------------------------------------------------
int dev_get_reg_fifo_capacity_hal()
{
  return 0x10000;
}

//----- (000B2D94) --------------------------------------------------------
int dev_get_work_fifo_capacity_hal()
{
  return 0x10000;
}

//----- (000B2DB8) --------------------------------------------------------
int dev_dma_rw_dispatcher_hal()
{
  return 0;
}

//----- (000B2DDC) --------------------------------------------------------
int cli_ssh_init()
{
  uart_uninit();
  fpga_uninit();
  platform_uninit();
  return 0;
}

//----- (000B2DFC) --------------------------------------------------------
int __fastcall power_on_hal(int a1, unsigned __int16 a2, int a3)
{
  char v8[16]; // [sp+24h] [bp-1010h] BYREF
  int v9; // [sp+1024h] [bp-10h]
  int v10; // [sp+1028h] [bp-Ch]
  int v11; // [sp+102Ch] [bp-8h]

  v11 = 0;
  v10 = 0;
  v9 = 2;
  if ( platform_is_pic_mcu_en() )
  {
    v11 += pic1704_reset(g_chain_info[2 * a1]);
    usleep(0x493E0u);
    v11 += pic1704_jump_to_app(g_chain_info[2 * a1]);
    usleep(0x493E0u);
  }
  if ( !a3 && platform_is_pic_mcu_en() )
    set_chain_isl_voltage(g_chain_info[2 * a1], a2);
  if ( !platform_is_pic_mcu_en() || (v11 += pic1704_enable_disable_dc_dc(g_chain_info[2 * a1], 1), v11 == 3) )
  {
    sleep(1u);
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "chain %d, pic init failed, err:%d!!!", g_chain_info[2 * a1], v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/platform_device_hal.c",
      174,
      "power_on_hal",
      12,
      460,
      100,
      v8);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B303C) --------------------------------------------------------
int __fastcall power_off_hal(int a1)
{
  if ( platform_is_pic_mcu_en() )
  {
    pic1704_enable_disable_dc_dc(g_chain_info[2 * a1], 0);
    usleep(0x493E0u);
  }
  return 0;
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B3098) --------------------------------------------------------
int __fastcall hardreset_hal(int a1)
{
  usleep(0x493E0u);
  chain_reset_low(g_chain_info[2 * a1]);
  usleep(0x493E0u);
  chain_reset_high(g_chain_info[2 * a1]);
  sleep(1u);
  chain_reset_low(g_chain_info[2 * a1]);
  usleep(0x493E0u);
  chain_reset_high(g_chain_info[2 * a1]);
  return 0;
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B3144) --------------------------------------------------------
int __fastcall chain_reset_high_hal(int a1)
{
  chain_reset_high(g_chain_info[2 * a1]);
  return 0;
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B317C) --------------------------------------------------------
int __fastcall chain_reset_low_hal(int a1)
{
  chain_reset_low(g_chain_info[2 * a1]);
  return 0;
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B31B4) --------------------------------------------------------
int __fastcall softreset_hal(int a1)
{
  _BYTE v3[16]; // [sp+8h] [bp-14h] BYREF

  while ( dev_read_nonce_reg_data_hal(a1, v3, 0x10u) != -1 )
    ;
  sleep(1u);
  while ( dev_read_nonce_reg_data_hal(a1, v3, 0x10u) != -1 )
    ;
  return 0;
}

//----- (000B3224) --------------------------------------------------------
int __fastcall heartbeat_to_hal(int a1)
{
  int is_pic_mcu_en; // r3

  is_pic_mcu_en = platform_is_pic_mcu_en();
  if ( is_pic_mcu_en )
    return pic1704_heart_beat(g_chain_info[2 * a1]);
  return is_pic_mcu_en;
}
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B3274) --------------------------------------------------------
int __fastcall pic_operation_to_hal(int a1, int a2, unsigned int a3, void *a4)
{
  int is_pic_mcu_en; // r3
  char v10[8]; // [sp+24h] [bp-1008h] BYREF
  int flash; // [sp+1024h] [bp-8h]

  is_pic_mcu_en = platform_is_pic_mcu_en();
  if ( is_pic_mcu_en )
  {
    flash = -1;
    if ( a2 == 51 )
    {
      flash = pic1704_write_flash(g_chain_info[2 * a1], a4, a3, HIWORD(a3));
      if ( flash != 1 )
      {
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, "chain %d, pic1704_write_flash failed!!!", g_chain_info[2 * a1]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/platform_device_hal.c",
          174,
          "pic_operation_to_hal",
          20,
          554,
          100,
          v10);
      }
    }
    else if ( a2 == 52 )
    {
      flash = pic1704_read_flash(g_chain_info[2 * a1], a4, a3, HIWORD(a3));
      if ( flash != 1 )
      {
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, "chain %d, pic1704_read_flash failed!!!", g_chain_info[2 * a1]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/platform_device_hal.c",
          174,
          "pic_operation_to_hal",
          20,
          562,
          100,
          v10);
      }
    }
    return flash;
  }
  return is_pic_mcu_en;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 161898: using guessed type _DWORD g_chain_info[32];

//----- (000B34EC) --------------------------------------------------------
int (**dev_ctrl_hal())()
{
  return off_150BB8;
}
// 150BB8: using guessed type int (*off_150BB8[26])();

//----- (000B350C) --------------------------------------------------------
_DWORD *__fastcall new_c_map(int a1, int a2, int a3)
{
  _DWORD *v8; // [sp+14h] [bp-8h]

  v8 = malloc(4u);
  if ( !v8 )
    return 0;
  *v8 = new_c_rb(a1, a2, a3);
  if ( *v8 )
    return v8;
  else
    return 0;
}

//----- (000B358C) --------------------------------------------------------
int __fastcall insert_c_map(int *a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  if ( a1 )
    return insert_c_rb(*a1, a2, a3, a4, a5);
  else
    return 501;
}

//----- (000B35EC) --------------------------------------------------------
bool __fastcall exists_c_map(int *a1, int a2)
{
  return a1 && find_c_rb(*a1, a2) != 0;
}

//----- (000B3658) --------------------------------------------------------
int __fastcall remove_c_map(int *a1, int a2)
{
  void *ptr; // [sp+Ch] [bp-10h] BYREF
  void *v5; // [sp+10h] [bp-Ch]
  int v6; // [sp+14h] [bp-8h]

  v6 = 0;
  if ( !a1 )
    return 501;
  v5 = remove_c_rb(*a1, a2);
  if ( v5 )
  {
    get_raw_clib_object(*((_DWORD *)v5 + 4), &ptr);
    free(ptr);
    delete_clib_object(*((void ***)v5 + 4));
    get_raw_clib_object(*((_DWORD *)v5 + 5), &ptr);
    free(ptr);
    delete_clib_object(*((void ***)v5 + 5));
    free(v5);
  }
  return v6;
}

//----- (000B372C) --------------------------------------------------------
int __fastcall find_c_map(int *a1, int a2, void **a3)
{
  _DWORD *c_rb; // [sp+14h] [bp-8h]

  if ( !a1 )
    return 0;
  c_rb = find_c_rb(*a1, a2);
  if ( !c_rb )
    return 0;
  get_raw_clib_object(c_rb[5], a3);
  return 1;
}

//----- (000B37A8) --------------------------------------------------------
int __fastcall delete_c_map(void ***a1)
{
  int v3; // [sp+Ch] [bp-8h]

  v3 = 0;
  if ( a1 )
  {
    v3 = delete_c_rb(*a1);
    free(a1);
  }
  return v3;
}

//----- (000B37F8) --------------------------------------------------------
_DWORD *__fastcall sub_B37F8(int *a1)
{
  return minimum_c_rb(*a1, *(_DWORD **)*a1);
}

//----- (000B3838) --------------------------------------------------------
int __fastcall sub_B3838(int a1)
{
  int *v1; // r0

  if ( *(_DWORD *)(a1 + 20) )
    v1 = tree_successor(**(int ***)(a1 + 12), *(_DWORD *)(a1 + 20));
  else
    v1 = sub_B37F8(*(int **)(a1 + 12));
  *(_DWORD *)(a1 + 20) = v1;
  if ( *(_DWORD *)(a1 + 20) )
    return *(_DWORD *)(*(_DWORD *)(a1 + 20) + 20);
  else
    return 0;
}

//----- (000B38DC) --------------------------------------------------------
void *__fastcall sub_B38DC(int a1)
{
  void *v2; // [sp+Ch] [bp-8h] BYREF

  get_raw_clib_object(a1, &v2);
  return v2;
}

//----- (000B390C) --------------------------------------------------------
void *__fastcall sub_B390C(int a1, const void *a2, size_t a3)
{
  void *v7; // [sp+10h] [bp-Ch] BYREF
  int v8; // [sp+14h] [bp-8h]

  v8 = *(_DWORD *)(a1 + 12);
  if ( *(_DWORD *)(*(_DWORD *)v8 + 32) )
  {
    get_raw_clib_object(*(_DWORD *)(a1 + 20), &v7);
    (*(void (__fastcall **)(void *))(*(_DWORD *)v8 + 32))(v7);
  }
  return replace_raw_clib_object(*(void ***)(*(_DWORD *)(a1 + 20) + 20), a2, a3);
}

//----- (000B399C) --------------------------------------------------------
_DWORD *__fastcall new_iterator_c_map(int a1)
{
  _DWORD *result; // r0

  result = malloc(0x18u);
  *result = 735288;
  result[2] = 735452;
  result[1] = 735500;
  result[3] = a1;
  result[4] = 0;
  result[5] = 0;
  return result;
}

//----- (000B3A20) --------------------------------------------------------
void __fastcall delete_iterator_c_map(void *a1)
{
  free(a1);
}

//----- (000B3A44) --------------------------------------------------------
_DWORD *__fastcall sub_B3A44(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // [sp+Ch] [bp-8h]

  v2 = (_DWORD *)a2[1];
  a2[1] = *v2;
  if ( (_DWORD *)*v2 != result + 1 )
    *(_DWORD *)(*v2 + 8) = a2;
  if ( v2 != result + 1 )
    v2[2] = a2[2];
  if ( a2[2] )
  {
    if ( a2 == *(_DWORD **)a2[2] )
      *(_DWORD *)a2[2] = v2;
    else
      *(_DWORD *)(a2[2] + 4) = v2;
  }
  else
  {
    *result = v2;
  }
  *v2 = a2;
  if ( a2 != result + 1 )
    a2[2] = v2;
  return result;
}

//----- (000B3B58) --------------------------------------------------------
_DWORD *__fastcall sub_B3B58(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // [sp+Ch] [bp-8h]

  v2 = (_DWORD *)*a2;
  *a2 = *(_DWORD *)(*a2 + 4);
  if ( (_DWORD *)v2[1] != result + 1 )
    *(_DWORD *)(v2[1] + 8) = a2;
  if ( v2 != result + 1 )
    v2[2] = a2[2];
  if ( a2[2] )
  {
    if ( a2 == *(_DWORD **)(a2[2] + 4) )
      *(_DWORD *)(a2[2] + 4) = v2;
    else
      *(_DWORD *)a2[2] = v2;
  }
  else
  {
    *result = v2;
  }
  v2[1] = a2;
  if ( a2 != result + 1 )
    a2[2] = v2;
  return result;
}

//----- (000B3C6C) --------------------------------------------------------
_DWORD *__fastcall new_c_rb(int a1, int a2, int a3)
{
  _DWORD *s; // [sp+14h] [bp-8h]

  s = malloc(0x28u);
  if ( !s )
    return 0;
  memset(s, 0, 0x28u);
  s[9] = a1;
  s[7] = a2;
  s[8] = a3;
  *s = s + 1;
  s[1] = s + 1;
  s[2] = s + 1;
  s[3] = 0;
  s[4] = 0;
  return s;
}

//----- (000B3D34) --------------------------------------------------------
_DWORD *__fastcall sub_B3D34(_DWORD *result, _DWORD *a2)
{
  _DWORD *v3; // [sp+4h] [bp-10h]
  int v4; // [sp+8h] [bp-Ch]
  int v5; // [sp+Ch] [bp-8h]

  v3 = result;
  while ( a2 != (_DWORD *)*v3 && *(_DWORD *)(a2[2] + 12) == 1 )
  {
    if ( a2[2] == **(_DWORD **)(a2[2] + 8) )
    {
      v4 = *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 4);
      if ( *(_DWORD *)(v4 + 12) == 1 )
      {
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(v4 + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        a2 = *(_DWORD **)(a2[2] + 8);
      }
      else
      {
        if ( a2 == *(_DWORD **)(a2[2] + 4) )
        {
          a2 = (_DWORD *)a2[2];
          sub_B3A44(v3, a2);
        }
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        result = sub_B3B58(v3, *(_DWORD **)(a2[2] + 8));
      }
    }
    else
    {
      v5 = **(_DWORD **)(a2[2] + 8);
      if ( *(_DWORD *)(v5 + 12) == 1 )
      {
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(v5 + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        a2 = *(_DWORD **)(a2[2] + 8);
      }
      else
      {
        if ( a2 == *(_DWORD **)a2[2] )
        {
          a2 = (_DWORD *)a2[2];
          sub_B3B58(v3, a2);
        }
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        result = sub_B3A44(v3, *(_DWORD **)(a2[2] + 8));
      }
    }
  }
  *(_DWORD *)(*v3 + 12) = 0;
  return result;
}

//----- (000B3F5C) --------------------------------------------------------
_DWORD *__fastcall find_c_rb(int a1, int a2)
{
  _DWORD *v2; // r3
  void *ptr; // [sp+Ch] [bp-10h] BYREF
  int v8; // [sp+10h] [bp-Ch]
  _DWORD *i; // [sp+14h] [bp-8h]

  for ( i = *(_DWORD **)a1; i != (_DWORD *)(a1 + 4); i = v2 )
  {
    v8 = 0;
    get_raw_clib_object(i[4], &ptr);
    v8 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v8 )
      break;
    if ( v8 >= 0 )
      v2 = (_DWORD *)i[1];
    else
      v2 = (_DWORD *)*i;
  }
  if ( i == (_DWORD *)(a1 + 4) )
    return 0;
  else
    return i;
}

//----- (000B4040) --------------------------------------------------------
int __fastcall insert_c_rb(int a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  void *v11; // [sp+10h] [bp-2Ch] BYREF
  void *v12; // [sp+14h] [bp-28h] BYREF
  void *v13; // [sp+18h] [bp-24h] BYREF
  void *ptr; // [sp+1Ch] [bp-20h] BYREF
  int v15; // [sp+20h] [bp-1Ch]
  int v16; // [sp+24h] [bp-18h]
  _DWORD *v17; // [sp+28h] [bp-14h]
  int v18; // [sp+2Ch] [bp-10h]
  _DWORD *v19; // [sp+30h] [bp-Ch]
  _DWORD *v20; // [sp+34h] [bp-8h]

  v18 = 0;
  v17 = malloc(0x18u);
  if ( !v17 )
    return 2;
  *v17 = a1 + 4;
  v17[1] = a1 + 4;
  v17[3] = 1;
  v17[4] = new_clib_object(a2, a3);
  if ( a4 )
    v17[5] = new_clib_object(a4, a5);
  else
    v17[5] = 0;
  v20 = *(_DWORD **)a1;
  v19 = 0;
  while ( v20 != (_DWORD *)(a1 + 4) )
  {
    v15 = 0;
    get_raw_clib_object(v20[4], &ptr);
    get_raw_clib_object(v17[4], &v13);
    v15 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v13, ptr);
    free(ptr);
    free(v13);
    if ( !v15 )
      return 401;
    v19 = v20;
    if ( v15 >= 0 )
      v20 = (_DWORD *)v20[1];
    else
      v20 = (_DWORD *)*v20;
  }
  v17[2] = v19;
  if ( v19 )
  {
    v16 = 0;
    get_raw_clib_object(v19[4], &v12);
    get_raw_clib_object(v17[4], &v11);
    v16 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v11, v12);
    free(v12);
    free(v11);
    if ( v16 >= 0 )
      v19[1] = v17;
    else
      *v19 = v17;
  }
  else
  {
    *(_DWORD *)a1 = v17;
  }
  sub_B3D34((_DWORD *)a1, v17);
  sub_B4C50((_DWORD **)a1);
  return v18;
}

//----- (000B42BC) --------------------------------------------------------
int *__fastcall sub_B42BC(int *result, int a2)
{
  int *v3; // [sp+4h] [bp-10h]
  _DWORD *v4; // [sp+8h] [bp-Ch]
  _DWORD *v5; // [sp+Ch] [bp-8h]

  v3 = result;
  while ( a2 != *v3 && !*(_DWORD *)(a2 + 12) )
  {
    if ( a2 == **(_DWORD **)(a2 + 8) )
    {
      v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
      if ( v5[3] == 1 )
      {
        v5[3] = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 1;
        result = sub_B3A44(v3, *(_DWORD **)(a2 + 8));
        v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
      }
      if ( *(_DWORD *)(*v5 + 12) || *(_DWORD *)(v5[1] + 12) )
      {
        if ( !*(_DWORD *)(v5[1] + 12) )
        {
          *(_DWORD *)(*v5 + 12) = 0;
          v5[3] = 1;
          sub_B3B58(v3, v5);
          v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
        }
        v5[3] = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 0;
        *(_DWORD *)(v5[1] + 12) = 0;
        result = sub_B3A44(v3, *(_DWORD **)(a2 + 8));
        a2 = *v3;
      }
      else
      {
        v5[3] = 1;
        a2 = *(_DWORD *)(a2 + 8);
      }
    }
    else
    {
      v4 = **(_DWORD ***)(a2 + 8);
      if ( v4[3] == 1 )
      {
        v4[3] = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 1;
        result = sub_B3B58(v3, *(_DWORD **)(a2 + 8));
        v4 = **(_DWORD ***)(a2 + 8);
      }
      if ( *(_DWORD *)(v4[1] + 12) || *(_DWORD *)(*v4 + 12) )
      {
        if ( !*(_DWORD *)(*v4 + 12) )
        {
          *(_DWORD *)(v4[1] + 12) = 0;
          v4[3] = 1;
          sub_B3A44(v3, v4);
          v4 = **(_DWORD ***)(a2 + 8);
        }
        v4[3] = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 0;
        *(_DWORD *)(*v4 + 12) = 0;
        result = sub_B3B58(v3, *(_DWORD **)(a2 + 8));
        a2 = *v3;
      }
      else
      {
        v4[3] = 1;
        a2 = *(_DWORD *)(a2 + 8);
      }
    }
  }
  *(_DWORD *)(a2 + 12) = 0;
  return result;
}

//----- (000B45B4) --------------------------------------------------------
int *__fastcall sub_B45B4(int *a1, int *a2)
{
  int v4; // [sp+Ch] [bp-10h]
  int v5; // [sp+Ch] [bp-10h]
  int *i; // [sp+10h] [bp-Ch]
  int v7; // [sp+14h] [bp-8h]

  if ( (int *)*a2 == a1 + 1 || (int *)a2[1] == a1 + 1 )
  {
    i = a2;
  }
  else
  {
    for ( i = (int *)a2[1]; (int *)*i != a1 + 1; i = (int *)*i )
      ;
  }
  if ( (int *)*i == a1 + 1 )
    v7 = i[1];
  else
    v7 = *i;
  *(_DWORD *)(v7 + 8) = i[2];
  if ( i[2] )
  {
    if ( i == *(int **)i[2] )
      *(_DWORD *)i[2] = v7;
    else
      *(_DWORD *)(i[2] + 4) = v7;
  }
  else
  {
    *a1 = v7;
  }
  if ( i != a2 )
  {
    v4 = a2[4];
    a2[4] = i[4];
    i[4] = v4;
    v5 = a2[5];
    a2[5] = i[5];
    i[5] = v5;
  }
  if ( !i[3] )
    sub_B42BC(a1, v7);
  sub_B4C50((_DWORD **)a1);
  return i;
}

//----- (000B477C) --------------------------------------------------------
int *__fastcall remove_c_rb(int a1, int a2)
{
  int *v2; // r3
  void *ptr; // [sp+Ch] [bp-10h] BYREF
  int v8; // [sp+10h] [bp-Ch]
  int *i; // [sp+14h] [bp-8h]

  i = 0;
  for ( i = *(int **)a1; i != (int *)(a1 + 4); i = v2 )
  {
    v8 = 0;
    get_raw_clib_object(i[4], &ptr);
    v8 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v8 )
      break;
    if ( v8 >= 0 )
      v2 = (int *)i[1];
    else
      v2 = (int *)*i;
  }
  if ( i == (int *)(a1 + 4) )
    return 0;
  else
    return sub_B45B4((int *)a1, i);
}

//----- (000B4874) --------------------------------------------------------
void __fastcall sub_B4874(int a1, int a2)
{
  void *v4; // [sp+8h] [bp-Ch] BYREF
  void *v5; // [sp+Ch] [bp-8h] BYREF

  if ( *(_DWORD *)(a1 + 28) )
  {
    get_raw_clib_object(*(_DWORD *)(a2 + 16), &v5);
    (*(void (__fastcall **)(void *))(a1 + 28))(v5);
  }
  delete_clib_object(*(void ***)(a2 + 16));
  if ( *(_DWORD *)(a2 + 20) )
  {
    if ( *(_DWORD *)(a1 + 32) )
    {
      get_raw_clib_object(*(_DWORD *)(a2 + 20), &v4);
      (*(void (__fastcall **)(void *))(a1 + 32))(v4);
    }
    delete_clib_object(*(void ***)(a2 + 20));
  }
}

//----- (000B493C) --------------------------------------------------------
int __fastcall delete_c_rb(void **a1)
{
  void **ptr; // [sp+Ch] [bp-8h]

  ptr = (void **)*a1;
  while ( ptr != a1 + 1 )
  {
    if ( *ptr == a1 + 1 )
    {
      if ( ptr[1] == a1 + 1 )
      {
        sub_B4874((int)a1, (int)ptr);
        if ( ptr[2] )
        {
          ptr = (void **)ptr[2];
          if ( *ptr == a1 + 1 )
          {
            if ( ptr[1] != a1 + 1 )
            {
              free(ptr[1]);
              ptr[1] = a1 + 1;
            }
          }
          else
          {
            free(*ptr);
            *ptr = a1 + 1;
          }
        }
        else
        {
          free(ptr);
          ptr = a1 + 1;
        }
      }
      else
      {
        ptr = (void **)ptr[1];
      }
    }
    else
    {
      ptr = (void **)*ptr;
    }
  }
  free(a1);
  return 0;
}

//----- (000B4A94) --------------------------------------------------------
_DWORD *__fastcall minimum_c_rb(int a1, _DWORD *a2)
{
  while ( *a2 != a1 + 4 )
    a2 = (_DWORD *)*a2;
  return a2;
}

//----- (000B4AE4) --------------------------------------------------------
int __fastcall maximum_c_rb(int a1, int a2)
{
  while ( *(_DWORD *)(a2 + 4) != a1 + 4 )
    a2 = *(_DWORD *)(a2 + 4);
  return a2;
}

//----- (000B4B34) --------------------------------------------------------
bool __fastcall empty_c_rb(_DWORD *a1)
{
  return *a1 != (_DWORD)(a1 + 1);
}

//----- (000B4B78) --------------------------------------------------------
int *__fastcall tree_successor(int *a1, int a2)
{
  int *v4; // [sp+0h] [bp-14h]
  int *i; // [sp+Ch] [bp-8h]

  v4 = (int *)a2;
  if ( *(int **)(a2 + 4) != a1 + 1 )
    return minimum_c_rb((int)a1, *(_DWORD **)(a2 + 4));
  if ( a2 == maximum_c_rb((int)a1, *a1) )
    return 0;
  for ( i = (int *)v4[2]; i != a1 + 1 && v4 == (int *)i[1]; i = (int *)i[2] )
    v4 = i;
  return i;
}

//----- (000B4C50) --------------------------------------------------------
int __fastcall sub_B4C50(_DWORD **a1)
{
  sub_B4CBC((int)a1, *a1);
  endian_flip32(a1, *a1);
  sub_B4D88((int)a1, *a1);
  return sub_B4DF4((int)a1, *a1);
}

//----- (000B4CBC) --------------------------------------------------------
int __fastcall sub_B4CBC(int result, _DWORD *a2)
{
  int v3; // [sp+4h] [bp-8h]

  v3 = result;
  if ( a2 != (_DWORD *)(result + 4) )
  {
    sub_B4CBC(result, *a2);
    return sub_B4CBC(v3, a2[1]);
  }
  return result;
}

//----- (000B4D1C) --------------------------------------------------------
void __cdecl endian_flip32(void *dest_p, const void *src_p)
{
  ;
}

//----- (000B4D40) --------------------------------------------------------
int __fastcall sub_B4D40(int a1, int a2)
{
  if ( a2 == a1 + 4 )
    return 0;
  else
    return *(_DWORD *)(a2 + 12);
}

//----- (000B4D88) --------------------------------------------------------
int __fastcall sub_B4D88(int a1, _DWORD *a2)
{
  int result; // r0

  result = sub_B4D40(a1, (int)a2);
  if ( a2 != (_DWORD *)(a1 + 4) )
  {
    sub_B4D88(a1, *a2);
    return sub_B4D88(a1, a2[1]);
  }
  return result;
}

//----- (000B4DF4) --------------------------------------------------------
int __fastcall sub_B4DF4(int a1, _DWORD *a2)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  v3 = -1;
  return sub_B4E30(a1, a2, 0, &v3);
}

//----- (000B4E30) --------------------------------------------------------
int __fastcall sub_B4E30(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int result; // r0

  result = sub_B4D40(a1, (int)a2);
  if ( !result )
    ++a3;
  if ( a2 == (_DWORD *)(a1 + 4) )
  {
    if ( *a4 == -1 )
      *a4 = a3;
  }
  else
  {
    sub_B4E30(a1, *a2, a3, a4);
    return sub_B4E30(a1, a2[1], a3, a4);
  }
  return result;
}

//----- (000B4EE4) --------------------------------------------------------
void *__fastcall clib_copy(void *a1, const void *a2, size_t a3)
{
  return memcpy(a1, a2, a3);
}

//----- (000B4F18) --------------------------------------------------------
void *__fastcall clib_get(void *a1, const void *a2, size_t a3)
{
  return memcpy(a1, a2, a3);
}

//----- (000B4F4C) --------------------------------------------------------
void **__fastcall new_clib_object(const void *a1, size_t a2)
{
  void **ptr; // [sp+Ch] [bp-8h]

  ptr = (void **)malloc(8u);
  if ( !ptr )
    return 0;
  ptr[1] = (void *)a2;
  *ptr = malloc(a2);
  if ( *ptr )
  {
    memcpy(*ptr, a1, a2);
    return ptr;
  }
  else
  {
    free(ptr);
    return 0;
  }
}

//----- (000B4FF0) --------------------------------------------------------
int __fastcall get_raw_clib_object(int a1, void **a2)
{
  *a2 = malloc(*(_DWORD *)(a1 + 4));
  if ( !*a2 )
    return 3;
  memcpy(*a2, *(const void **)a1, *(_DWORD *)(a1 + 4));
  return 0;
}

//----- (000B506C) --------------------------------------------------------
void *__fastcall replace_raw_clib_object(void **a1, const void *a2, size_t a3)
{
  free(*a1);
  *a1 = malloc(a3);
  return memcpy(*a1, a2, a3);
}

//----- (000B50D0) --------------------------------------------------------
void __fastcall delete_clib_object(void **a1)
{
  if ( a1 )
  {
    free(*a1);
    free(a1);
  }
}

//----- (000B5110) --------------------------------------------------------
char *__fastcall clib_strdup(const char *a1)
{
  return strdup(a1);
}

//----- (000B5138) --------------------------------------------------------
int __fastcall sub_B5138(unsigned __int8 a1, int a2, unsigned int a3)
{
  return iic_write(g_bitmain_pic_state[2 * a1], a2, a3);
}
// 1617FC: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (000B5184) --------------------------------------------------------
int __fastcall sub_B5184(unsigned __int8 a1, void *a2, size_t a3)
{
  return iic_read(g_bitmain_pic_state[2 * a1], a2, a3);
}
// 1617FC: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (000B51D0) --------------------------------------------------------
int __fastcall sub_B51D0(unsigned __int8 a1, char a2, char a3, int a4, int a5)
{
  unsigned int v5; // r3
  unsigned int v6; // r3
  unsigned int v7; // r3
  int v8; // r0
  char v14[56]; // [sp+2Ch] [bp-1038h] BYREF
  _QWORD v15[2]; // [sp+102Ch] [bp-38h] BYREF
  _QWORD s[2]; // [sp+103Ch] [bp-28h] BYREF
  __int16 v17; // [sp+104Ch] [bp-18h]
  unsigned __int8 i; // [sp+104Fh] [bp-15h]
  int j; // [sp+1050h] [bp-14h]
  unsigned int v20; // [sp+1054h] [bp-10h]
  int v21; // [sp+1058h] [bp-Ch]
  _BYTE v22[3]; // [sp+105Dh] [bp-7h]

  v17 = 255;
  s[0] = 255;
  s[1] = 0;
  v22[2] = 0;
  v15[0] = 838904405;
  v15[1] = 0;
  j = 0;
  *(_WORD *)v22 = (unsigned __int8)(a5 + 6);
  v21 = 1;
  pthread_mutex_lock(&i2c_mutex_all);
  BYTE2(v15[0]) = a5 + 6;
  BYTE4(v15[0]) = 2 * a2;
  v20 = 6;
  BYTE5(v15[0]) = a3;
  for ( i = 0; a5 > i; ++i )
  {
    v5 = v20++;
    *((_BYTE *)v15 + v5) = *(_BYTE *)(a4 + i);
  }
  for ( j = 2; j < a5 + 6; ++j )
    *(_WORD *)&v22[1] += *((unsigned __int8 *)v15 + j);
  LOBYTE(v17) = v22[2];
  HIBYTE(v17) = v22[1];
  v6 = v20++;
  *((_BYTE *)v15 + v6) = v22[2];
  v7 = v20++;
  *((_BYTE *)v15 + v7) = HIBYTE(v17);
  v8 = sub_B5138(a1, (int)v15, v20);
  if ( v20 == v8 )
  {
    usleep((__useconds_t)sub_30D40);
    memset(s, 0, sizeof(s));
    if ( sub_B5184(a1, s, 5u) == 5 )
    {
      if ( BYTE1(s[0]) != 50 || BYTE2(s[0]) != 1 )
      {
        V_LOCK();
        logfmt_raw(
          v14,
          0x1000u,
          0,
          "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x",
          "write_dc_dc",
          LOBYTE(s[0]),
          BYTE1(s[0]),
          BYTE2(s[0]),
          BYTE3(s[0]));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
          175,
          "write_dc_dc",
          11,
          75,
          100,
          v14);
        v21 = 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v14, 0x1000u, 0, "%s read iic err", "write_dc_dc");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
        175,
        "write_dc_dc",
        11,
        68,
        100,
        v14);
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "%s write iic err", "write_dc_dc");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
      175,
      "write_dc_dc",
      11,
      61,
      100,
      v14);
  }
  pthread_mutex_unlock(&i2c_mutex_all);
  return v21;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F918: using guessed type pthread_mutex_t i2c_mutex_all;
// 1608F0: using guessed type int g_zc;

//----- (000B56B8) --------------------------------------------------------
int __fastcall sub_B56B8(unsigned __int8 a1, char a2, char a3, int a4, int a5)
{
  unsigned int v5; // r3
  unsigned int v6; // r3
  int v7; // r0
  char v13[48]; // [sp+2Ch] [bp-1030h] BYREF
  char v14; // [sp+102Ch] [bp-30h] BYREF
  __int64 v15; // [sp+102Dh] [bp-2Fh]
  _QWORD s[2]; // [sp+1038h] [bp-24h] BYREF
  __int16 v17; // [sp+1048h] [bp-14h]
  unsigned __int8 i; // [sp+104Bh] [bp-11h]
  int v19; // [sp+104Ch] [bp-10h]
  unsigned __int8 v20; // [sp+1051h] [bp-Bh]
  __int16 v21; // [sp+1052h] [bp-Ah]
  unsigned int v22; // [sp+1054h] [bp-8h]

  v20 = 7;
  v17 = 255;
  s[0] = 255;
  s[1] = 0;
  v21 = 0;
  v15 = 3278762;
  v19 = 1;
  pthread_mutex_lock(&i2c_mutex_all);
  v14 = 85;
  BYTE3(v15) = (2 * a2) | 1;
  BYTE4(v15) = a3;
  v22 = 7;
  BYTE5(v15) = a5;
  for ( i = 2; i < (unsigned int)v20; ++i )
    v21 += (unsigned __int8)*(&v14 + i);
  LOBYTE(v17) = HIBYTE(v21);
  HIBYTE(v17) = v21;
  v5 = v22++;
  *(&v14 + v5) = HIBYTE(v21);
  v6 = v22++;
  *(&v14 + v6) = HIBYTE(v17);
  v7 = sub_B5138(a1, (int)&v14, v22);
  if ( v22 == v7 )
  {
    usleep((__useconds_t)sub_30D40);
    memset(s, 0, sizeof(s));
    if ( sub_B5184(a1, s, 5u) == 5 )
    {
      if ( BYTE1(s[0]) == 50 && BYTE2(s[0]) == 1 )
      {
        for ( i = 0; a5 > i; ++i )
          *(_BYTE *)(a4 + i) = *((_BYTE *)s + i + 3);
        v19 = 1;
      }
      else
      {
        V_LOCK();
        logfmt_raw(
          v13,
          0x1000u,
          0,
          "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x",
          "read_dc_dc",
          LOBYTE(s[0]),
          BYTE1(s[0]),
          BYTE2(s[0]),
          BYTE3(s[0]));
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
          175,
          "read_dc_dc",
          10,
          125,
          100,
          v13);
        v19 = 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "%s read iic err", "read_dc_dc");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
        175,
        "read_dc_dc",
        10,
        118,
        100,
        v13);
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "%s write iic err", "read_dc_dc");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
      175,
      "read_dc_dc",
      10,
      110,
      100,
      v13);
  }
  pthread_mutex_unlock(&i2c_mutex_all);
  return v19;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15F918: using guessed type pthread_mutex_t i2c_mutex_all;
// 1608F0: using guessed type int g_zc;

//----- (000B5BBC) --------------------------------------------------------
int __fastcall sub_B5BBC(unsigned __int8 a1, char a2, _WORD *a3)
{
  __int16 s; // [sp+1Ch] [bp-8h] BYREF

  memset(&s, 0, sizeof(s));
  sub_B56B8(a1, a2, 33, (int)&s, 2);
  *a3 = (unsigned __int8)s | (HIBYTE(s) << 8);
  return 1;
}

//----- (000B5C4C) --------------------------------------------------------
int __fastcall sub_B5C4C(int a1, char a2, unsigned __int16 a3)
{
  int v4; // [sp+Ch] [bp-1020h]
  char v6; // [sp+13h] [bp-1019h]
  int v7; // [sp+14h] [bp-1018h]
  char v8[16]; // [sp+1Ch] [bp-1010h] BYREF
  __int16 v9; // [sp+101Ch] [bp-10h] BYREF
  char v10; // [sp+101Fh] [bp-Dh] BYREF
  unsigned __int16 v11; // [sp+1020h] [bp-Ch] BYREF
  unsigned __int8 v12; // [sp+1022h] [bp-Ah]
  unsigned __int8 v13; // [sp+1023h] [bp-9h]
  int v14; // [sp+1024h] [bp-8h]

  v7 = a1;
  v6 = a2;
  v14 = a3;
  if ( a3 > 0x3DEu || v14 <= 809 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "illegal voltage [%d, %d], set default voltage %d", 810, 990, 900, v4, a3, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
      175,
      "ISL_set_voltage_dynamic",
      23,
      154,
      60,
      v8);
    v14 = 900;
  }
  v13 = 0;
  v12 = 3;
  v11 = 0;
  do
  {
    v10 = -1;
    sub_B51D0(v7, v6, 0, (int)&v10, 1);
    usleep((__useconds_t)"time");
    v9 = v14;
    sub_B51D0(v7, v6, 33, (int)&v9, 2);
    usleep((__useconds_t)sub_30D40);
    sub_B5BBC(v7, v6, &v11);
    if ( v11 > v14 - 10 && v11 < v14 + 10 )
      break;
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "set vol %d,  %d, set again!", v14, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
      175,
      "ISL_set_voltage_dynamic",
      23,
      181,
      60,
      v8);
    usleep((__useconds_t)sub_30D40);
    ++v13;
  }
  while ( v13 <= (unsigned int)v12 );
  return v11;
}
// B5CF8: variable 'v4' is possibly undefined
// B5DA4: variable 'v7' is possibly undefined
// B5DA4: variable 'v6' is possibly undefined
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B5F1C) --------------------------------------------------------
int __fastcall get_chain_isl_voltage(unsigned __int8 a1, int a2, int a3)
{
  char v7[12]; // [sp+20h] [bp-100Ch] BYREF
  unsigned __int16 v8; // [sp+1022h] [bp-Ah] BYREF
  unsigned int i; // [sp+1024h] [bp-8h]

  if ( a3 <= 2 )
    return 0;
  for ( i = 0; i <= 2; ++i )
  {
    v8 = 0;
    sub_B5BBC(a1, aPqt[i], &v8);
    *(_WORD *)(a2 + 2 * i) = v8;
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "Get one chain ISL: domain addr = %x vol=%u", (unsigned __int8)aPqt[i], v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
      175,
      "get_chain_isl_voltage",
      21,
      202,
      60,
      v7);
  }
  return 1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B6084) --------------------------------------------------------
int __fastcall set_chain_isl_voltage(int a1, unsigned __int16 a2)
{
  char v5[12]; // [sp+18h] [bp-100Ch] BYREF
  unsigned __int16 v6; // [sp+101Ah] [bp-Ah]
  unsigned int i; // [sp+101Ch] [bp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    v6 = sub_B5C4C(a1, aPqt[i], a2);
    V_LOCK();
    logfmt_raw(
      v5,
      0x1000u,
      0,
      "Set one chain ISL: domain addr = %x set vol %d, get vol %d",
      (unsigned __int8)aPqt[i],
      a2,
      v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/drv_pic/isl68127.c",
      175,
      "set_chain_isl_voltage",
      21,
      215,
      60,
      v5);
  }
  return 1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B61C4) --------------------------------------------------------
unsigned int *__fastcall sub_B61C4(unsigned int *result)
{
  unsigned int *v1; // [sp+14h] [bp-1810h]
  char v2[2048]; // [sp+18h] [bp-180Ch] BYREF
  char v3[12]; // [sp+818h] [bp-100Ch] BYREF
  unsigned int j; // [sp+1818h] [bp-Ch]
  unsigned int i; // [sp+181Ch] [bp-8h]

  v1 = result;
  if ( result )
  {
    strcpy(v2, "==========================capability start==========================\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
      188,
      "platform_dump_capability",
      24,
      26,
      20,
      v3);
    snprintf(v2, 0x800u, "board num = %d\n", *v1);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
      188,
      "platform_dump_capability",
      24,
      27,
      20,
      v3);
    for ( i = 0; *v1 > i; ++i )
    {
      snprintf(v2, 0x800u, "board id = %d, chain num = %d\n", v1[18 * i + 1], v1[18 * i + 2]);
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
        188,
        "platform_dump_capability",
        24,
        30,
        20,
        v3);
      for ( j = 0; v1[18 * i + 2] > j; ++j )
      {
        snprintf(v2, 0x800u, "\tchain id = %d\n", v1[18 * i + 3 + j]);
        V_LOCK();
        logfmt_raw(v3, 0x1000u, 0, v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
          188,
          "platform_dump_capability",
          24,
          33,
          20,
          v3);
      }
    }
    strcpy(v2, "==========================capability end============================\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    return (unsigned int *)zlog(
                             g_zc,
                             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                             "release/build/godminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
                             188,
                             "platform_dump_capability",
                             24,
                             36,
                             20,
                             v3);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B6608) --------------------------------------------------------
int platform_init()
{
  char v2[24]; // [sp+14h] [bp-1818h] BYREF
  char v3[24]; // [sp+814h] [bp-1018h] BYREF
  char v4; // [sp+1817h] [bp-15h] BYREF
  int v5; // [sp+1818h] [bp-14h]
  int i; // [sp+181Ch] [bp-10h]
  int v7; // [sp+1820h] [bp-Ch]
  int v8; // [sp+1824h] [bp-8h]

  if ( platform_inited )
    return 0;
  if ( fpga_init() )
  {
    strcpy(v2, "fpga init failed\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
      188,
      "platform_init",
      13,
      45,
      100,
      v3);
    return -1;
  }
  else if ( gpio_init() )
  {
    strcpy(v2, "gpio init failed\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
      188,
      "platform_init",
      13,
      50,
      100,
      v3);
    return -2;
  }
  else
  {
    memset(dword_1603F8, 0, sizeof(dword_1603F8));
    v5 = hal_chain_max_num();
    for ( i = 0; i < v5; ++i )
    {
      v7 = hal_chain_plug_addr(i);
      if ( v7 >= 0 )
      {
        gpio_export(v7);
        gpio_direction(v7, 0);
        v8 = hal_chain_reset_addr(i);
        if ( v8 >= 0 )
        {
          gpio_export(v8);
          gpio_direction(v8, 1);
          v4 = 0;
          gpio_read(v7, &v4);
          if ( v4 == 1 )
          {
            dword_1603F8[18 * dword_1603F8[0] + 1] = i;
            dword_1603F8[18 * dword_1603F8[0] + 3 + dword_1603F8[18 * dword_1603F8[0] + 2]++] = i;
            ++dword_1603F8[0];
          }
          else
          {
            snprintf(v2, 0x800u, "no board pluged in socket %d", v7);
            V_LOCK();
            logfmt_raw(v3, 0x1000u, 0, v2);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
              188,
              "platform_init",
              13,
              89,
              80,
              v3);
          }
        }
        else
        {
          snprintf(v2, 0x800u, "fail to get reset for chain %d\n", i);
          V_LOCK();
          logfmt_raw(v3, 0x1000u, 0, v2);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
            188,
            "platform_init",
            13,
            72,
            80,
            v3);
        }
      }
      else
      {
        snprintf(v2, 0x800u, "fail to get socket for chain %d\n", i);
        V_LOCK();
        logfmt_raw(v3, 0x1000u, 0, v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
          188,
          "platform_init",
          13,
          63,
          80,
          v3);
      }
    }
    sub_B61C4(dword_1603F8);
    platform_inited = 1;
    fan_init();
    uart_init();
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1603F4: using guessed type int platform_inited;
// 1603F8: using guessed type unsigned int dword_1603F8[73];
// 1608F0: using guessed type int g_zc;

//----- (000B6B7C) --------------------------------------------------------
void platform_uninit()
{
  char v0[20]; // [sp+10h] [bp-1814h] BYREF
  char v1[20]; // [sp+810h] [bp-1014h] BYREF
  int v2; // [sp+1810h] [bp-14h]
  int v3; // [sp+1814h] [bp-10h]
  int v4; // [sp+1818h] [bp-Ch]
  int i; // [sp+181Ch] [bp-8h]

  if ( platform_inited )
  {
    v4 = hal_chain_max_num();
    fpga_uninit();
    for ( i = 0; i < v4; ++i )
    {
      v3 = hal_chain_plug_addr(i);
      if ( v3 >= 0 )
      {
        gpio_unexport(v3);
        v2 = hal_chain_reset_addr(i);
        if ( v2 >= 0 )
        {
          gpio_unexport(v2);
        }
        else
        {
          snprintf(v0, 0x800u, "fail to get reset for chain %d\n", i);
          V_LOCK();
          logfmt_raw(v1, 0x1000u, 0, v0);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
            188,
            "platform_uninit",
            15,
            120,
            80,
            v1);
        }
      }
      else
      {
        snprintf(v0, 0x800u, "fail to get socket for chain %d\n", i);
        V_LOCK();
        logfmt_raw(v1, 0x1000u, 0, v0);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
          188,
          "platform_uninit",
          15,
          112,
          80,
          v1);
      }
    }
    uart_uninit();
    fan_uninit();
    ui_uninit();
    gpio_uninit();
    platform_inited = 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1603F4: using guessed type int platform_inited;
// 1608F0: using guessed type int g_zc;

//----- (000B6D88) --------------------------------------------------------
void *__fastcall get_system_capability(void *result)
{
  if ( result )
    return memcpy(result, &dword_1603F8, 0x124u);
  return result;
}
// 1603F8: using guessed type int dword_1603F8;

//----- (000B6DC4) --------------------------------------------------------
int __fastcall sub_B6DC4(const char *a1, int a2)
{
  char v6[44]; // [sp+18h] [bp-182Ch] BYREF
  char v7[44]; // [sp+818h] [bp-102Ch] BYREF
  char dest[32]; // [sp+1818h] [bp-2Ch] BYREF
  int i; // [sp+1838h] [bp-Ch]
  int fd; // [sp+183Ch] [bp-8h]

  fd = socket(2, 1, 0);
  if ( fd >= 0 )
  {
    strcpy(dest, a1);
    if ( ioctl(fd, 0x8927u, dest) >= 0 )
    {
      for ( i = 0; i <= 5; ++i )
        *(_BYTE *)(a2 + i) = dest[i + 18];
      close(fd);
      return 0;
    }
    else
    {
      strcpy(v6, "error ioctl");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
        188,
        "get_eth_mac",
        11,
        156,
        100,
        v7);
      close(fd);
      return -2;
    }
  }
  else
  {
    strcpy(v6, "error sock");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
      188,
      "get_eth_mac",
      11,
      150,
      100,
      v7);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B7000) --------------------------------------------------------
int __fastcall get_uuid(void *a1)
{
  if ( !a1 )
    return -1;
  memset(a1, 0, 0x10u);
  return sub_B6DC4("eth0", (int)a1);
}

//----- (000B705C) --------------------------------------------------------
int __fastcall get_mac(int a1)
{
  if ( a1 )
    return sub_B6DC4("eth0", a1);
  else
    return -1;
}

//----- (000B70A4) --------------------------------------------------------
int __fastcall chain_reset_low(int a1)
{
  char v3[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v4[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v5; // [sp+181Ch] [bp-8h]

  v5 = hal_chain_reset_addr(a1);
  if ( v5 >= 0 )
    return gpio_write(v5, 0);
  snprintf(v3, 0x800u, "bad chain id = %d\n", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
           188,
           "chain_reset_low",
           15,
           200,
           100,
           v4);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B71A8) --------------------------------------------------------
int __fastcall chain_reset_high(int a1)
{
  char v3[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v4[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v5; // [sp+181Ch] [bp-8h]

  v5 = hal_chain_reset_addr(a1);
  if ( v5 >= 0 )
    return gpio_write(v5, 1);
  snprintf(v3, 0x800u, "bad chain id = %d\n", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
           188,
           "chain_reset_high",
           16,
           214,
           100,
           v4);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000B72AC) --------------------------------------------------------
int __fastcall chain_reset(int a1)
{
  chain_reset_low(a1);
  usleep((__useconds_t)"time");
  return chain_reset_high(a1);
}

//----- (000B72E4) --------------------------------------------------------
int get_hash_on_plug()
{
  char v2[24]; // [sp+14h] [bp-1818h] BYREF
  char v3[24]; // [sp+814h] [bp-1018h] BYREF
  int v4; // [sp+1814h] [bp-18h] BYREF
  int i; // [sp+1818h] [bp-14h]
  int v6; // [sp+181Ch] [bp-10h]
  int v7; // [sp+1820h] [bp-Ch]
  int v8; // [sp+1824h] [bp-8h]

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v4 = 0;
  if ( platform_inited )
  {
    v6 = hal_chain_max_num();
    for ( i = 0; i < v6; ++i )
    {
      v4 = 0;
      v8 = hal_chain_plug_addr(i);
      if ( v8 >= 0 )
      {
        gpio_export(v8);
        gpio_direction(v8, 0);
        gpio_read(v8, &v4);
        v7 |= v4 << i;
      }
      else
      {
        snprintf(v2, 0x800u, "fail to get slot for chain %d", i);
        V_LOCK();
        logfmt_raw(v3, 0x1000u, 0, v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
          188,
          "get_hash_on_plug",
          16,
          249,
          80,
          v3);
      }
    }
    return v7;
  }
  else
  {
    strcpy(v2, "platform not inited");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_common.c",
      188,
      "get_hash_on_plug",
      16,
      238,
      100,
      v3);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1603F4: using guessed type int platform_inited;
// 1608F0: using guessed type int g_zc;

//----- (000B751C) --------------------------------------------------------
int enable_bypass_mode()
{
  return 0;
}

//----- (000B7538) --------------------------------------------------------
int __fastcall sub_B7538(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (000B7570) --------------------------------------------------------
int sub_B7570()
{
  char v1[40]; // [sp+1Ch] [bp-1828h] BYREF
  char v2[40]; // [sp+81Ch] [bp-1028h] BYREF
  _DWORD v3[2]; // [sp+181Ch] [bp-28h] BYREF
  unsigned __int8 v4; // [sp+1827h] [bp-1Dh] BYREF
  int v5; // [sp+1828h] [bp-1Ch]
  void *ptr; // [sp+182Ch] [bp-18h]
  int v7; // [sp+1830h] [bp-14h]
  _DWORD *v8; // [sp+1834h] [bp-10h]
  int i; // [sp+1838h] [bp-Ch]
  int v10; // [sp+183Ch] [bp-8h]

  v10 = 0;
  prctl(15, "gpio");
  while ( dword_160520 )
  {
    if ( !pthread_mutex_lock(&stru_160540) )
    {
      v8 = new_iterator_c_map(dword_160558);
      for ( i = ((int (__fastcall *)(_DWORD *))*v8)(v8); i; i = ((int (__fastcall *)(_DWORD *))*v8)(v8) )
      {
        v7 = v8[5];
        ptr = (void *)((int (__fastcall *)(int))v8[2])(i);
        v5 = ***(_DWORD ***)(v7 + 16);
        v4 = 0;
        v10 = gpio_read(v5, &v4);
        if ( v10 )
        {
          snprintf(v1, 0x800u, "failed to read gpio port %d", v5);
          V_LOCK();
          logfmt_raw(v2, 0x1000u, 0, v1);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
            186,
            "gpio_thread_function",
            20,
            60,
            20,
            v2);
          free(ptr);
          break;
        }
        if ( *((_DWORD *)ptr + 1) != v4 )
        {
          snprintf(
            v1,
            0x800u,
            "gpio port %d, last val = %d, new val = %d",
            ***(_DWORD ***)(v7 + 16),
            *((_DWORD *)ptr + 1),
            v4);
          V_LOCK();
          logfmt_raw(v2, 0x1000u, 0, v1);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
            186,
            "gpio_thread_function",
            20,
            66,
            20,
            v2);
          (*(void (__fastcall **)(int, _DWORD))ptr)(v5, v4);
          v3[0] = *(_DWORD *)ptr;
          v3[1] = v4;
          ((void (__fastcall *)(_DWORD *, _DWORD *, int))v8[1])(v8, v3, 8);
        }
        free(ptr);
      }
      delete_iterator_c_map(v8);
      pthread_mutex_unlock(&stru_160540);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160520: using guessed type int dword_160520;
// 160540: using guessed type pthread_mutex_t stru_160540;
// 160558: using guessed type int dword_160558;
// 1608F0: using guessed type int g_zc;

//----- (000B787C) --------------------------------------------------------
int gpio_init()
{
  _DWORD v1[512]; // [sp+10h] [bp-1804h] BYREF
  char v2[4]; // [sp+810h] [bp-1004h] BYREF

  if ( dword_16051C )
  {
    strcpy((char *)v1, "gpio re init");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
      186,
      "gpio_init",
      9,
      92,
      80,
      v2,
      v1[0],
      v1[1],
      v1[2],
      v1[3]);
  }
  else
  {
    pthread_mutex_init(&stru_160540, 0);
    dword_160558 = (int)new_c_map(750904, 0, 0);
    pthread_mutex_init(&stru_160528, 0);
    dword_160520 = 1;
    pthread_create((pthread_t *)&dword_160524, 0, (void *(*)(void *))sub_B7570, 0);
    dword_16051C = 1;
  }
  return 0;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 16051C: using guessed type int dword_16051C;
// 160520: using guessed type int dword_160520;
// 160524: using guessed type int dword_160524;
// 160528: using guessed type pthread_mutex_t stru_160528;
// 160540: using guessed type pthread_mutex_t stru_160540;
// 160558: using guessed type int dword_160558;
// 1608F0: using guessed type int g_zc;

//----- (000B79C4) --------------------------------------------------------
int gpio_uninit()
{
  int result; // r0

  if ( dword_16051C )
  {
    dword_160520 = 0;
    pthread_join(dword_160524, 0);
    pthread_mutex_destroy(&stru_160540);
    delete_c_map((void ***)dword_160558);
    dword_16051C = 0;
    return pthread_mutex_destroy(&stru_160528);
  }
  return result;
}
// 16051C: using guessed type int dword_16051C;
// 160520: using guessed type int dword_160520;
// 160524: using guessed type int dword_160524;
// 160528: using guessed type pthread_mutex_t stru_160528;
// 160540: using guessed type pthread_mutex_t stru_160540;
// 160558: using guessed type int dword_160558;

//----- (000B7A50) --------------------------------------------------------
int __fastcall gpio_reg_callback(int a1, int a2)
{
  int v5; // [sp+14h] [bp-1810h] BYREF
  char v6[2048]; // [sp+18h] [bp-180Ch] BYREF
  char v7[12]; // [sp+818h] [bp-100Ch] BYREF
  _DWORD v8[2]; // [sp+1818h] [bp-Ch] BYREF

  v5 = a1;
  if ( a2 )
  {
    if ( pthread_mutex_lock(&stru_160540) )
    {
      strcpy(v6, "fail to lock gpio ctrl mutex");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
        186,
        "gpio_reg_callback",
        17,
        143,
        100,
        v7);
      return -1;
    }
    else
    {
      if ( exists_c_map((int *)dword_160558, (int)&v5) )
      {
        snprintf(v6, 0x800u, "port %d already exist in callback map ", v5);
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_reg_callback",
          17,
          155,
          20,
          v7);
      }
      else
      {
        snprintf(v6, 0x800u, "add %d to callback map", v5);
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_reg_callback",
          17,
          149,
          20,
          v7);
        v8[0] = a2;
        v8[1] = -1;
        insert_c_map((int *)dword_160558, &v5, 4u, v8, 8u);
      }
      pthread_mutex_unlock(&stru_160540);
      return 0;
    }
  }
  else
  {
    strcpy(v6, "bad param");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
      186,
      "gpio_reg_callback",
      17,
      138,
      100,
      v7);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160540: using guessed type pthread_mutex_t stru_160540;
// 160558: using guessed type int dword_160558;
// 1608F0: using guessed type int g_zc;

//----- (000B7DCC) --------------------------------------------------------
int __fastcall gpio_unreg_callback(int a1, int a2)
{
  int v5; // [sp+14h] [bp-1808h] BYREF
  char v6[2048]; // [sp+18h] [bp-1804h] BYREF
  char v7[4]; // [sp+818h] [bp-1004h] BYREF

  v5 = a1;
  if ( a2 )
  {
    if ( pthread_mutex_lock(&stru_160540) )
    {
      strcpy(v6, "fail to lock gpio ctrl mutex");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
        186,
        "gpio_unreg_callback",
        19,
        178,
        100,
        v7,
        a2);
      return -1;
    }
    else
    {
      if ( exists_c_map((int *)dword_160558, (int)&v5) )
      {
        snprintf(v6, 0x800u, "remove %d from callback list", v5);
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_unreg_callback",
          19,
          184,
          20,
          v7,
          a2);
        remove_c_map((int *)dword_160558, (int)&v5);
      }
      else
      {
        strcpy(v6, "callback function not registered before");
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_unreg_callback",
          19,
          189,
          80,
          v7,
          a2);
      }
      pthread_mutex_unlock(&stru_160540);
      return 0;
    }
  }
  else
  {
    strcpy(v6, "bad param");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
      186,
      "gpio_unreg_callback",
      19,
      173,
      100,
      v7,
      0);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160540: using guessed type pthread_mutex_t stru_160540;
// 160558: using guessed type int dword_160558;
// 1608F0: using guessed type int g_zc;

//----- (000B80F0) --------------------------------------------------------
int __fastcall gpio_export(int a1)
{
  char v4[2048]; // [sp+18h] [bp-184Ch] BYREF
  char v5[12]; // [sp+818h] [bp-104Ch] BYREF
  char s[64]; // [sp+1818h] [bp-4Ch] BYREF
  int fd; // [sp+1858h] [bp-Ch]
  size_t n; // [sp+185Ch] [bp-8h]

  if ( pthread_mutex_lock(&stru_160528) )
  {
    strcpy(v4, "failed to api lock");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
      186,
      "gpio_export",
      11,
      209,
      100,
      v5);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(s, 0) )
    {
      fd = open("/sys/class/gpio/export", 1);
      if ( fd >= 0 )
      {
        n = snprintf(s, 0x40u, "%d", a1);
        if ( write(fd, s, n) >= 0 )
        {
          snprintf(v4, 0x800u, "export gpio %d success", a1);
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
            186,
            "gpio_export",
            11,
            236,
            20,
            v5);
          close(fd);
          pthread_mutex_unlock(&stru_160528);
          return 0;
        }
        else
        {
          snprintf(v4, 0x800u, "Failed to export gpio %d!", a1);
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
            186,
            "gpio_export",
            11,
            231,
            100,
            v5);
          close(fd);
          pthread_mutex_unlock(&stru_160528);
          return -3;
        }
      }
      else
      {
        strcpy(v4, "Failed to open export for writing!");
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_export",
          11,
          224,
          100,
          v5);
        pthread_mutex_unlock(&stru_160528);
        return -2;
      }
    }
    else
    {
      snprintf(v4, 0x800u, "port %d already exported", a1);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
        186,
        "gpio_export",
        11,
        216,
        40,
        v5);
      pthread_mutex_unlock(&stru_160528);
      return 0;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160528: using guessed type pthread_mutex_t stru_160528;
// 1608F0: using guessed type int g_zc;

//----- (000B857C) --------------------------------------------------------
int __fastcall gpio_unexport(int a1)
{
  char v4[2048]; // [sp+18h] [bp-184Ch] BYREF
  char v5[12]; // [sp+818h] [bp-104Ch] BYREF
  char s[64]; // [sp+1818h] [bp-4Ch] BYREF
  int fd; // [sp+1858h] [bp-Ch]
  size_t n; // [sp+185Ch] [bp-8h]

  if ( pthread_mutex_lock(&stru_160528) )
  {
    strcpy(v4, "failed to api lock");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
      186,
      "gpio_unexport",
      13,
      256,
      100,
      v5);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    fd = access(s, 0);
    if ( fd )
    {
      snprintf(v4, 0x800u, "port %d already unexported, ret = %d", a1, fd);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
        186,
        "gpio_unexport",
        13,
        263,
        80,
        v5);
      pthread_mutex_unlock(&stru_160528);
      return 0;
    }
    else
    {
      fd = open("/sys/class/gpio/unexport", 1);
      if ( fd >= 0 )
      {
        n = snprintf(s, 0x40u, "%d", a1);
        if ( write(fd, s, n) >= 0 )
        {
          snprintf(v4, 0x800u, "unexport gpio %d success", a1);
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
            186,
            "gpio_unexport",
            13,
            283,
            20,
            v5);
          close(fd);
          pthread_mutex_unlock(&stru_160528);
          return 0;
        }
        else
        {
          snprintf(v4, 0x800u, "Failed to unexport gpio %d!", a1);
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
            186,
            "gpio_unexport",
            13,
            278,
            100,
            v5);
          close(fd);
          pthread_mutex_unlock(&stru_160528);
          return -2;
        }
      }
      else
      {
        strcpy(v4, "Failed to open unexport for writing!");
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_unexport",
          13,
          271,
          100,
          v5);
        pthread_mutex_unlock(&stru_160528);
        return -2;
      }
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160528: using guessed type pthread_mutex_t stru_160528;
// 1608F0: using guessed type int g_zc;

//----- (000B8A14) --------------------------------------------------------
int __fastcall gpio_direction(int a1, int a2)
{
  int v3; // r2
  size_t v4; // r3
  int v5; // r2
  int v6; // r2
  char v10[2048]; // [sp+1Ch] [bp-1848h] BYREF
  char v11[8]; // [sp+81Ch] [bp-1048h] BYREF
  char s[64]; // [sp+181Ch] [bp-48h] BYREF
  int fd; // [sp+185Ch] [bp-8h]

  if ( pthread_mutex_lock(&stru_160528) )
  {
    strcpy(v10, "failed to api lock");
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
      186,
      "gpio_direction",
      14,
      304,
      100,
      v11);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/direction", a1);
    fd = open(s, 1);
    if ( fd >= 0 )
    {
      if ( a2 )
        v3 = 3;
      else
        v3 = 0;
      if ( a2 )
        v4 = 3;
      else
        v4 = 2;
      if ( write(fd, &aIn[v3], v4) >= 0 )
      {
        if ( a2 )
          v6 = 3;
        else
          v6 = 0;
        snprintf(v10, 0x800u, "set gpio %d direction %s success!", a1, &aIn[v6]);
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_direction",
          14,
          322,
          20,
          v11);
        close(fd);
        pthread_mutex_unlock(&stru_160528);
        return 0;
      }
      else
      {
        if ( a2 )
          v5 = 3;
        else
          v5 = 0;
        snprintf(v10, 0x800u, "Failed to set gpio %d direction %s !", a1, &aIn[v5]);
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_direction",
          14,
          317,
          100,
          v11);
        close(fd);
        pthread_mutex_unlock(&stru_160528);
        return -3;
      }
    }
    else
    {
      snprintf(v10, 0x800u, "Failed to open gpio %d direction for writing!", a1);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
        186,
        "gpio_direction",
        14,
        311,
        100,
        v11);
      pthread_mutex_unlock(&stru_160528);
      return -2;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160528: using guessed type pthread_mutex_t stru_160528;
// 1608F0: using guessed type int g_zc;

//----- (000B8E44) --------------------------------------------------------
int __fastcall gpio_read(int a1, _BYTE *a2)
{
  char v6[2048]; // [sp+18h] [bp-184Ch] BYREF
  char v7[12]; // [sp+818h] [bp-104Ch] BYREF
  int buf; // [sp+1818h] [bp-4Ch] BYREF
  char s[64]; // [sp+181Ch] [bp-48h] BYREF
  int fd; // [sp+185Ch] [bp-8h]

  buf = 0;
  if ( pthread_mutex_lock(&stru_160528) )
  {
    strcpy(v6, "failed to api lock");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
      186,
      "gpio_read",
      9,
      343,
      100,
      v7);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    fd = open(s, 0);
    if ( fd >= 0 )
    {
      if ( read(fd, &buf, 4u) >= 0 )
      {
        close(fd);
        pthread_mutex_unlock(&stru_160528);
        *a2 = atoi((const char *)&buf);
        return 0;
      }
      else
      {
        strcpy(v6, "Failed to read value!");
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_read",
          9,
          356,
          100,
          v7);
        close(fd);
        pthread_mutex_unlock(&stru_160528);
        return -3;
      }
    }
    else
    {
      snprintf(v6, 0x800u, "Failed to open gpio %d value for reading!", a1);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
        186,
        "gpio_read",
        9,
        350,
        100,
        v7);
      pthread_mutex_unlock(&stru_160528);
      return -2;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160528: using guessed type pthread_mutex_t stru_160528;
// 1608F0: using guessed type int g_zc;

//----- (000B9168) --------------------------------------------------------
int __fastcall gpio_write(int a1, char a2)
{
  char v6[2048]; // [sp+1Ch] [bp-1848h] BYREF
  char v7[8]; // [sp+81Ch] [bp-1048h] BYREF
  char s[64]; // [sp+181Ch] [bp-48h] BYREF
  int fd; // [sp+185Ch] [bp-8h]

  if ( pthread_mutex_lock(&stru_160528) )
  {
    strcpy(v6, "failed to api lock");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
      186,
      "gpio_write",
      10,
      383,
      100,
      v7);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    fd = open(s, 1);
    if ( fd >= 0 )
    {
      if ( write(fd, &a01[a2 != 0], 1u) >= 0 )
      {
        close(fd);
        pthread_mutex_unlock(&stru_160528);
        return 0;
      }
      else
      {
        snprintf(v6, 0x800u, "Failed to write gpio[%d] value!", a1);
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
          186,
          "gpio_write",
          10,
          396,
          100,
          v7);
        close(fd);
        pthread_mutex_unlock(&stru_160528);
        return -3;
      }
    }
    else
    {
      snprintf(v6, 0x800u, "Failed to open gpio[%d] value for writing!", a1);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
        186,
        "gpio_write",
        10,
        390,
        100,
        v7);
      pthread_mutex_unlock(&stru_160528);
      return -2;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160528: using guessed type pthread_mutex_t stru_160528;
// 1608F0: using guessed type int g_zc;

//----- (000B9480) --------------------------------------------------------
int __fastcall is_gpio_exist(int a1)
{
  char v4[2048]; // [sp+18h] [bp-1844h] BYREF
  char v5[4]; // [sp+818h] [bp-1044h] BYREF
  char s[64]; // [sp+1818h] [bp-44h] BYREF

  if ( pthread_mutex_lock(&stru_160528) )
  {
    strcpy(v4, "failed to api lock");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
      186,
      "is_gpio_exist",
      13,
      411,
      100,
      v5);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(s, 0) )
    {
      pthread_mutex_unlock(&stru_160528);
      return 0;
    }
    else
    {
      snprintf(v4, 0x800u, "port %d already exported", a1);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_gpio.c",
        186,
        "is_gpio_exist",
        13,
        418,
        20,
        v5);
      pthread_mutex_unlock(&stru_160528);
      return 1;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160528: using guessed type pthread_mutex_t stru_160528;
// 1608F0: using guessed type int g_zc;

//----- (000B9658) --------------------------------------------------------
int __fastcall sub_B9658(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (000B9690) --------------------------------------------------------
int __fastcall i2c_init(const char *a1)
{
  char v4[28]; // [sp+18h] [bp-181Ch] BYREF
  _DWORD v5[1024]; // [sp+818h] [bp-101Ch] BYREF
  int v6; // [sp+1818h] [bp-1Ch]
  void *ptr; // [sp+181Ch] [bp-18h]
  _DWORD *v8; // [sp+1820h] [bp-14h]
  int i; // [sp+1824h] [bp-10h]
  int v10; // [sp+1828h] [bp-Ch]
  int v11; // [sp+182Ch] [bp-8h]

  v11 = -1;
  v10 = 1;
  if ( !pthread_mutex_lock(&stru_16055C) )
  {
    if ( !dword_160578 )
    {
      strcpy(v4, "init i2c map\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
        185,
        "i2c_init",
        8,
        51,
        20,
        (const char *)v5);
      dword_160574 = (int)new_c_map(759384, 0, 0);
    }
    v8 = new_iterator_c_map(dword_160574);
    for ( i = ((int (__fastcall *)(_DWORD *))*v8)(v8); i; i = ((int (__fastcall *)(_DWORD *))*v8)(v8) )
    {
      ptr = (void *)((int (__fastcall *)(int))v8[2])(i);
      if ( !strncmp(a1, (const char *)ptr + 12, 0x100u) )
      {
        snprintf(v4, 0x800u, "%s has already opened\n", a1);
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
          185,
          "i2c_init",
          8,
          62,
          20,
          (const char *)v5);
        memset(v5, 0, 0x10Cu);
        v5[0] = ++dword_160578;
        v5[1] = *((_DWORD *)ptr + 1);
        strncpy((char *)&v5[3], a1, 0x100u);
        insert_c_map((int *)dword_160574, &dword_160578, 4u, v5, 0x10Cu);
        v10 = 0;
        free(ptr);
        break;
      }
      free(ptr);
    }
    delete_iterator_c_map(v8);
    if ( v10 )
    {
      v6 = open(a1, 2050);
      if ( v6 < 0 )
      {
        snprintf(v4, 0x800u, "failed to open %s\n", a1);
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
          185,
          "i2c_init",
          8,
          80,
          100,
          (const char *)v5);
        pthread_mutex_unlock(&stru_16055C);
        return -1;
      }
      memset(v5, 0, 0x10Cu);
      v5[0] = ++dword_160578;
      v5[1] = v6;
      strncpy((char *)&v5[3], a1, 0x100u);
      insert_c_map((int *)dword_160574, &dword_160578, 4u, v5, 0x10Cu);
    }
    pthread_mutex_unlock(&stru_16055C);
    return dword_160578;
  }
  strcpy(v4, "failed to i2c lock\n");
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
    185,
    "i2c_init",
    8,
    45,
    100,
    (const char *)v5);
  return -4;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 16055C: using guessed type pthread_mutex_t stru_16055C;
// 160574: using guessed type int dword_160574;
// 160578: using guessed type int dword_160578;
// 1608F0: using guessed type int g_zc;

//----- (000B9C38) --------------------------------------------------------
int __fastcall i2c_uninit(int a1)
{
  _DWORD v2[2]; // [sp+14h] [bp-1828h] BYREF
  char v3[32]; // [sp+1Ch] [bp-1820h] BYREF
  char v4[32]; // [sp+81Ch] [bp-1020h] BYREF
  void *v5; // [sp+181Ch] [bp-20h] BYREF
  void *ptr; // [sp+1820h] [bp-1Ch]
  _DWORD *v7; // [sp+1824h] [bp-18h]
  const char *v8; // [sp+1828h] [bp-14h]
  int i; // [sp+182Ch] [bp-10h]
  int v10; // [sp+1830h] [bp-Ch]
  int v11; // [sp+1834h] [bp-8h]

  v2[0] = a1;
  v10 = 0;
  v11 = 1;
  v5 = 0;
  if ( pthread_mutex_lock(&stru_16055C) )
  {
    strcpy(v3, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
             185,
             "i2c_uninit",
             10,
             102,
             100,
             v4);
  }
  else
  {
    if ( find_c_map((int *)dword_160574, (int)v2, &v5) == 1 )
    {
      v8 = (const char *)v5;
      remove_c_map((int *)dword_160574, (int)v2);
      v7 = new_iterator_c_map(dword_160574);
      for ( i = ((int (__fastcall *)(_DWORD *))*v7)(v7); i; i = ((int (__fastcall *)(_DWORD *))*v7)(v7) )
      {
        ptr = (void *)((int (__fastcall *)(int))v7[2])(i);
        if ( !strncmp(v8 + 12, (const char *)ptr + 12, 0x100u) )
        {
          snprintf(v3, 0x800u, "%s still open for %d\n", v8 + 12, *(_DWORD *)ptr);
          V_LOCK();
          logfmt_raw(v4, 0x1000u, 0, v3);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
            185,
            "i2c_uninit",
            10,
            119,
            20,
            v4);
          v11 = 0;
          free(ptr);
          break;
        }
        free(ptr);
      }
      delete_iterator_c_map(v7);
    }
    else
    {
      v11 = 0;
      snprintf(v3, 0x800u, "ctx(%d) not inited\n", v2[0]);
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
        185,
        "i2c_uninit",
        10,
        132,
        80,
        v4);
    }
    if ( v11 )
      close(*((_DWORD *)v5 + 1));
    if ( v5 )
      free(v5);
    return pthread_mutex_unlock(&stru_16055C);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 16055C: using guessed type pthread_mutex_t stru_16055C;
// 160574: using guessed type int dword_160574;
// 1608F0: using guessed type int g_zc;

//----- (000B9FDC) --------------------------------------------------------
int __fastcall i2c_read(int a1, void *a2, size_t a3)
{
  int v7; // [sp+1Ch] [bp-1818h] BYREF
  char v8[20]; // [sp+20h] [bp-1814h] BYREF
  char v9[20]; // [sp+820h] [bp-1014h] BYREF
  void *ptr; // [sp+1820h] [bp-14h] BYREF
  int v11; // [sp+1824h] [bp-10h]
  int v12; // [sp+1828h] [bp-Ch]
  const char *v13; // [sp+182Ch] [bp-8h]

  v7 = a1;
  v11 = 0;
  if ( pthread_mutex_lock(&stru_16055C) )
  {
    strcpy(v8, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
      185,
      "i2c_read",
      8,
      159,
      100,
      v9);
    return -1;
  }
  else
  {
    v12 = 0;
    if ( find_c_map((int *)dword_160574, (int)&v7, &ptr) == 1 )
    {
      v13 = (const char *)ptr;
      snprintf(v8, 0x800u, "i2c read path = %s, addr = %d\n", (const char *)ptr + 12, *((_DWORD *)ptr + 2) >> 1);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
        185,
        "i2c_read",
        8,
        167,
        20,
        v9);
      if ( ioctl(*((_DWORD *)v13 + 1), 0x703u, *((_DWORD *)v13 + 2) >> 1) >= 0 )
      {
        if ( a3 != read(*((_DWORD *)v13 + 1), a2, a3) )
        {
          snprintf(v8, 0x800u, "fail to read %d\n", a3);
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, v8);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
            185,
            "i2c_read",
            8,
            181,
            100,
            v9);
        }
        free(ptr);
        pthread_mutex_unlock(&stru_16055C);
        return v11;
      }
      else
      {
        snprintf(v8, 0x800u, "read io ctrl for path = %s, addr = %d failed\n", v13 + 12, *((_DWORD *)v13 + 2));
        V_LOCK();
        logfmt_raw(v9, 0x1000u, 0, v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
          185,
          "i2c_read",
          8,
          170,
          100,
          v9);
        free(ptr);
        pthread_mutex_unlock(&stru_16055C);
        return -3;
      }
    }
    else
    {
      snprintf(v8, 0x800u, "ctx %d not inited\n", v7);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
        185,
        "i2c_read",
        8,
        188,
        100,
        v9);
      pthread_mutex_unlock(&stru_16055C);
      return -4;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 16055C: using guessed type pthread_mutex_t stru_16055C;
// 160574: using guessed type int dword_160574;
// 1608F0: using guessed type int g_zc;

//----- (000BA48C) --------------------------------------------------------
int __fastcall i2c_write(int a1, int a2, unsigned int a3)
{
  int v7; // [sp+1Ch] [bp-1818h] BYREF
  char v8[20]; // [sp+20h] [bp-1814h] BYREF
  char v9[20]; // [sp+820h] [bp-1014h] BYREF
  void *ptr; // [sp+1820h] [bp-14h] BYREF
  unsigned int i; // [sp+1824h] [bp-10h]
  int v12; // [sp+1828h] [bp-Ch]
  const char *v13; // [sp+182Ch] [bp-8h]

  v7 = a1;
  i = 0;
  if ( pthread_mutex_lock(&stru_16055C) )
  {
    strcpy(v8, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
      185,
      "i2c_write",
      9,
      211,
      100,
      v9);
    return -1;
  }
  else
  {
    v12 = 0;
    if ( find_c_map((int *)dword_160574, (int)&v7, &ptr) == 1 )
    {
      v13 = (const char *)ptr;
      snprintf(v8, 0x800u, "i2c write path = %s, addr = %d\n", (const char *)ptr + 12, *((_DWORD *)ptr + 2));
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
        185,
        "i2c_write",
        9,
        219,
        20,
        v9);
      if ( ioctl(*((_DWORD *)v13 + 1), 0x703u, *((_DWORD *)v13 + 2) >> 1) >= 0 )
      {
        for ( i = 0; i < a3; ++i )
        {
          if ( write(*((_DWORD *)v13 + 1), (const void *)(a2 + i), 1u) != 1 )
          {
            snprintf(v8, 0x800u, "fail to write %d:%d\n", i, a3);
            V_LOCK();
            logfmt_raw(v9, 0x1000u, 0, v8);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
              185,
              "i2c_write",
              9,
              232,
              100,
              v9);
          }
        }
        free(ptr);
        usleep(0x2710u);
        pthread_mutex_unlock(&stru_16055C);
        return a3;
      }
      else
      {
        snprintf(v8, 0x800u, "write io ctrl for path = %s, addr = %d failed\n", v13 + 12, *((_DWORD *)v13 + 2));
        V_LOCK();
        logfmt_raw(v9, 0x1000u, 0, v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
          185,
          "i2c_write",
          9,
          222,
          100,
          v9);
        free(ptr);
        pthread_mutex_unlock(&stru_16055C);
        return -3;
      }
    }
    else
    {
      snprintf(v8, 0x800u, "ctx %d not inited\n", v7);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
        185,
        "i2c_write",
        9,
        239,
        100,
        v9);
      pthread_mutex_unlock(&stru_16055C);
      return -4;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 16055C: using guessed type pthread_mutex_t stru_16055C;
// 160574: using guessed type int dword_160574;
// 1608F0: using guessed type int g_zc;

//----- (000BA970) --------------------------------------------------------
int __fastcall i2c_ioctl(int a1, __int16 a2, int a3)
{
  char v8[20]; // [sp+20h] [bp-1814h] BYREF
  char v9[20]; // [sp+820h] [bp-1014h] BYREF
  void *ptr; // [sp+1820h] [bp-14h]
  int v11; // [sp+1824h] [bp-10h]
  int i; // [sp+1828h] [bp-Ch]
  _DWORD *v13; // [sp+182Ch] [bp-8h]

  if ( pthread_mutex_lock(&stru_16055C) )
  {
    strcpy(v8, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
      185,
      "i2c_ioctl",
      9,
      261,
      100,
      v9);
    return -4;
  }
  else
  {
    v13 = new_iterator_c_map(dword_160574);
    for ( i = ((int (__fastcall *)(_DWORD *))*v13)(v13); i; i = ((int (__fastcall *)(_DWORD *))*v13)(v13) )
    {
      v11 = v13[5];
      if ( ***(_DWORD ***)(v11 + 16) == a1 )
      {
        ptr = (void *)((int (__fastcall *)(int))v13[2])(i);
        if ( a2 == 1795 )
        {
          *((_DWORD *)ptr + 2) = a3;
          ((void (__fastcall *)(_DWORD *, void *, int))v13[1])(v13, ptr, 268);
          snprintf(v8, 0x800u, "update the slave address to %d\n", a3);
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, v8);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
            185,
            "i2c_ioctl",
            9,
            277,
            20,
            v9);
          free(ptr);
        }
        break;
      }
    }
    delete_iterator_c_map(v13);
    pthread_mutex_unlock(&stru_16055C);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 16055C: using guessed type pthread_mutex_t stru_16055C;
// 160574: using guessed type int dword_160574;
// 1608F0: using guessed type int g_zc;

//----- (000BAC2C) --------------------------------------------------------
int __fastcall i2c_get_fd_from_ctx(int a1)
{
  int v3; // [sp+14h] [bp-1810h] BYREF
  char v4[2048]; // [sp+18h] [bp-180Ch] BYREF
  char v5[12]; // [sp+818h] [bp-100Ch] BYREF
  void *ptr; // [sp+1818h] [bp-Ch] BYREF
  int v7; // [sp+181Ch] [bp-8h]

  v3 = a1;
  v7 = -1;
  if ( pthread_mutex_lock(&stru_16055C) )
  {
    strcpy(v4, "failed to get i2c lock");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
      185,
      "i2c_get_fd_from_ctx",
      19,
      299,
      100,
      v5);
    return -4;
  }
  else if ( find_c_map((int *)dword_160574, (int)&v3, &ptr) )
  {
    snprintf(
      v4,
      0x800u,
      "i2c dev = %s, addr = 0x%x, fd = %d",
      (const char *)ptr + 12,
      *((_DWORD *)ptr + 2),
      *((_DWORD *)ptr + 1));
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c.c",
      185,
      "i2c_get_fd_from_ctx",
      19,
      310,
      20,
      v5);
    pthread_mutex_unlock(&stru_16055C);
    v7 = *((_DWORD *)ptr + 1);
    free(ptr);
    return v7;
  }
  else
  {
    pthread_mutex_unlock(&stru_16055C);
    return -2;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 16055C: using guessed type pthread_mutex_t stru_16055C;
// 160574: using guessed type int dword_160574;
// 1608F0: using guessed type int g_zc;

//----- (000BAE58) --------------------------------------------------------
int __fastcall cgsleep_ms(int a1)
{
  return usleep(1000 * a1);
}

//----- (000BAE88) --------------------------------------------------------
int sub_BAE88()
{
  return cgsleep_ms(1);
}

//----- (000BAEA0) --------------------------------------------------------
ssize_t sub_BAEA0()
{
  ssize_t result; // r0
  _DWORD v1[512]; // [sp+10h] [bp-180Ch] BYREF
  char v2[12]; // [sp+810h] [bp-100Ch] BYREF
  char buf; // [sp+1813h] [bp-9h] BYREF
  ssize_t v4; // [sp+1814h] [bp-8h]

  buf = 49;
  result = write(dword_150C24, &buf, 1u);
  v4 = result;
  if ( result != 1 )
  {
    strcpy((char *)v1, "error! write SDA high");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
             189,
             "sda_high",
             8,
             45,
             40,
             v2,
             v1[0],
             v1[1],
             v1[2],
             v1[3],
             v1[4],
             v1[5]);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150C24: using guessed type int dword_150C24;
// 1608F0: using guessed type int g_zc;

//----- (000BAF9C) --------------------------------------------------------
ssize_t sub_BAF9C()
{
  ssize_t result; // r0
  _DWORD v1[512]; // [sp+10h] [bp-180Ch] BYREF
  char v2[12]; // [sp+810h] [bp-100Ch] BYREF
  char buf; // [sp+1813h] [bp-9h] BYREF
  ssize_t v4; // [sp+1814h] [bp-8h]

  buf = 48;
  result = write(dword_150C24, &buf, 1u);
  v4 = result;
  if ( result != 1 )
  {
    strcpy((char *)v1, "error! write SDA low");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
             189,
             "sda_low",
             7,
             56,
             40,
             v2,
             v1[0],
             v1[1],
             v1[2],
             v1[3],
             v1[4],
             v1[5]);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150C24: using guessed type int dword_150C24;
// 1608F0: using guessed type int g_zc;

//----- (000BB098) --------------------------------------------------------
ssize_t sub_BB098()
{
  ssize_t result; // r0
  _DWORD v1[512]; // [sp+10h] [bp-180Ch] BYREF
  char v2[12]; // [sp+810h] [bp-100Ch] BYREF
  char buf; // [sp+1813h] [bp-9h] BYREF
  ssize_t v4; // [sp+1814h] [bp-8h]

  buf = 49;
  result = write(dword_150C20, &buf, 1u);
  v4 = result;
  if ( result != 1 )
  {
    strcpy((char *)v1, "error! write SCL high");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
             189,
             "scl_high",
             8,
             66,
             40,
             v2,
             v1[0],
             v1[1],
             v1[2],
             v1[3],
             v1[4],
             v1[5]);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150C20: using guessed type int dword_150C20;
// 1608F0: using guessed type int g_zc;

//----- (000BB194) --------------------------------------------------------
ssize_t sub_BB194()
{
  ssize_t result; // r0
  _DWORD v1[512]; // [sp+10h] [bp-180Ch] BYREF
  char v2[12]; // [sp+810h] [bp-100Ch] BYREF
  char buf; // [sp+1813h] [bp-9h] BYREF
  ssize_t v4; // [sp+1814h] [bp-8h]

  buf = 48;
  result = write(dword_150C20, &buf, 1u);
  v4 = result;
  if ( result != 1 )
  {
    strcpy((char *)v1, "error! write SCL low");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
             189,
             "scl_low",
             7,
             75,
             40,
             v2,
             v1[0],
             v1[1],
             v1[2],
             v1[3],
             v1[4],
             v1[5]);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150C20: using guessed type int dword_150C20;
// 1608F0: using guessed type int g_zc;

//----- (000BB290) --------------------------------------------------------
int sub_BB290()
{
  char v2[12]; // [sp+10h] [bp-180Ch] BYREF
  char v3[12]; // [sp+810h] [bp-100Ch] BYREF
  char buf; // [sp+1813h] [bp-9h] BYREF
  ssize_t v5; // [sp+1814h] [bp-8h]

  v5 = read(dword_150C24, &buf, 1u);
  if ( v5 == 1 )
    return buf != 48;
  snprintf(v2, 0x800u, "error! read SDA return %d", v5);
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
    189,
    "sda_status",
    10,
    85,
    40,
    v3);
  return -1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150C24: using guessed type int dword_150C24;
// 1608F0: using guessed type int g_zc;

//----- (000BB390) --------------------------------------------------------
int i2c_sim_init()
{
  char v2[2048]; // [sp+14h] [bp-1808h] BYREF
  char v3[8]; // [sp+814h] [bp-1008h] BYREF
  int v4; // [sp+1814h] [bp-8h]

  v4 = 0;
  strcpy(v2, "i2c_sim_init start");
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
    189,
    "i2c_sim_init",
    12,
    98,
    40,
    v3);
  if ( access("/sys/class/gpio/gpio461/", 0) == -1 )
  {
    v4 = system("echo 461 > /sys/class/gpio/export");
    if ( v4 )
    {
      snprintf(v2, 0x800u, "[i2c_sim] echo %s > %s failed", "461", "/sys/class/gpio/export");
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "i2c_sim_init",
        12,
        104,
        100,
        v3);
      return v4;
    }
    strcpy(v2, "init gpio461");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
      189,
      "i2c_sim_init",
      12,
      108,
      40,
      v3);
  }
  if ( access("/sys/class/gpio/gpio459/", 0) == -1 )
  {
    v4 = system("echo 459 > /sys/class/gpio/export");
    if ( v4 )
    {
      snprintf(v2, 0x800u, "[i2c_sim] echo %s > %s failed", "459", "/sys/class/gpio/export");
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "i2c_sim_init",
        12,
        115,
        100,
        v3);
      return v4;
    }
    strcpy(v2, "init gpio459");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
      189,
      "i2c_sim_init",
      12,
      119,
      40,
      v3);
  }
  v4 = system("echo high > /sys/class/gpio/gpio461/direction");
  if ( v4 )
  {
    snprintf(v2, 0x800u, "[i2c_sim] echo high > %s failed", "/sys/class/gpio/gpio461/direction");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
      189,
      "i2c_sim_init",
      12,
      125,
      100,
      v3);
    return v4;
  }
  else
  {
    v4 = system("echo high > /sys/class/gpio/gpio459/direction");
    if ( v4 )
    {
      snprintf(v2, 0x800u, "[i2c_sim] echo high > %s failed", "/sys/class/gpio/gpio459/direction");
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "i2c_sim_init",
        12,
        132,
        100,
        v3);
      return v4;
    }
    else
    {
      dword_16057C = 1;
      if ( dword_150C20 > 0 )
        close(dword_150C20);
      dword_150C20 = open("/sys/class/gpio/gpio459/value", 1);
      if ( dword_150C20 >= 0 )
      {
        if ( dword_150C24 > 0 )
          close(dword_150C24);
        dword_150C24 = open("/sys/class/gpio/gpio461/value", 1);
        if ( dword_150C24 >= 0 )
        {
          if ( dword_150C28 > 0 )
            close(dword_150C28);
          dword_150C28 = open("/sys/class/gpio/gpio461/direction", 1);
          if ( dword_150C28 >= 0 )
          {
            snprintf(v2, 0x800u, "power i2c device:%s addr:0x%02x fd:%d", "sim_dev", 16, 255);
            V_LOCK();
            logfmt_raw(v3, 0x1000u, 0, v2);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
              189,
              "i2c_sim_init",
              12,
              172,
              40,
              v3);
            strcpy(v2, "i2c_sim_init end");
            V_LOCK();
            logfmt_raw(v3, 0x1000u, 0, v2);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
              189,
              "i2c_sim_init",
              12,
              173,
              40,
              v3);
            return 255;
          }
          else
          {
            strcpy(v2, "open gpio461 direction failed");
            V_LOCK();
            logfmt_raw(v3, 0x1000u, 0, v2);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
              189,
              "i2c_sim_init",
              12,
              167,
              40,
              v3);
            strcpy(v2, "open gpio461 direction failed");
            V_LOCK();
            logfmt_raw(v3, 0x1000u, 0, v2);
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
              189,
              "i2c_sim_init",
              12,
              168,
              100,
              v3);
            return dword_150C28;
          }
        }
        else
        {
          strcpy(v2, "open gpio461 failed");
          V_LOCK();
          logfmt_raw(v3, 0x1000u, 0, v2);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
            189,
            "i2c_sim_init",
            12,
            155,
            100,
            v3);
          return dword_150C24;
        }
      }
      else
      {
        strcpy(v2, "open gpio459 failed");
        V_LOCK();
        logfmt_raw(v3, 0x1000u, 0, v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
          189,
          "i2c_sim_init",
          12,
          144,
          100,
          v3);
        return dword_150C20;
      }
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150C20: using guessed type int dword_150C20;
// 150C24: using guessed type int dword_150C24;
// 150C28: using guessed type int dword_150C28;
// 16057C: using guessed type int dword_16057C;
// 1608F0: using guessed type int g_zc;

//----- (000BBE34) --------------------------------------------------------
int i2c_sim_uninit()
{
  int result; // r0

  if ( dword_150C20 > 0 )
    result = close(dword_150C20);
  if ( dword_150C24 > 0 )
    result = close(dword_150C24);
  if ( dword_150C28 > 0 )
    return close(dword_150C28);
  return result;
}
// 150C20: using guessed type int dword_150C20;
// 150C24: using guessed type int dword_150C24;
// 150C28: using guessed type int dword_150C28;

//----- (000BBEBC) --------------------------------------------------------
void sub_BBEBC()
{
  char v0[2048]; // [sp+14h] [bp-1810h] BYREF
  char v1[16]; // [sp+814h] [bp-1010h] BYREF
  int buf; // [sp+1814h] [bp-10h] BYREF
  char v3; // [sp+1818h] [bp-Ch]
  ssize_t v4; // [sp+181Ch] [bp-8h]

  if ( dword_16057C )
  {
    buf = 28265;
    v3 = 0;
    v4 = write(dword_150C28, &buf, 2u);
    if ( v4 != 2 )
    {
      strcpy(v0, "write in");
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "set_sda_in",
        10,
        207,
        40,
        v1);
    }
    close(dword_150C24);
    dword_150C24 = -1;
    dword_150C24 = open("/sys/class/gpio/gpio461/value", 0);
    if ( dword_150C24 < 0 )
    {
      strcpy(v0, "open gpio461 failed");
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "set_sda_in",
        10,
        215,
        40,
        v1);
    }
    dword_16057C = 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150C24: using guessed type int dword_150C24;
// 150C28: using guessed type int dword_150C28;
// 16057C: using guessed type int dword_16057C;
// 1608F0: using guessed type int g_zc;

//----- (000BC0D4) --------------------------------------------------------
void sub_BC0D4()
{
  char v0[2048]; // [sp+14h] [bp-1810h] BYREF
  char v1[16]; // [sp+814h] [bp-1010h] BYREF
  int buf; // [sp+1814h] [bp-10h] BYREF
  char v3; // [sp+1818h] [bp-Ch]
  ssize_t v4; // [sp+181Ch] [bp-8h]

  if ( dword_16057C != 1 )
  {
    buf = 7632239;
    v3 = 0;
    v4 = write(dword_150C28, &buf, 3u);
    if ( v4 != 3 )
    {
      strcpy(v0, "write out");
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "set_sda_out",
        11,
        233,
        40,
        v1);
    }
    close(dword_150C24);
    dword_150C24 = -1;
    dword_150C24 = open("/sys/class/gpio/gpio461/value", 1);
    if ( dword_150C24 < 0 )
    {
      strcpy(v0, "open gpio461 failed");
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "set_sda_out",
        11,
        241,
        40,
        v1);
    }
    dword_16057C = 1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150C24: using guessed type int dword_150C24;
// 150C28: using guessed type int dword_150C28;
// 16057C: using guessed type int dword_16057C;
// 1608F0: using guessed type int g_zc;

//----- (000BC2F0) --------------------------------------------------------
int sub_BC2F0()
{
  sub_BC0D4();
  sub_BAEA0();
  sub_BB098();
  sub_BAE88();
  sub_BAF9C();
  return sub_BAE88();
}

//----- (000BC318) --------------------------------------------------------
int sub_BC318()
{
  sub_BC0D4();
  sub_BB194();
  sub_BAE88();
  sub_BAF9C();
  sub_BB098();
  sub_BAE88();
  sub_BAEA0();
  return sub_BAE88();
}

//----- (000BC348) --------------------------------------------------------
int sub_BC348()
{
  char v2[8]; // [sp+14h] [bp-1808h] BYREF
  char v3[8]; // [sp+814h] [bp-1008h] BYREF
  char v4; // [sp+1816h] [bp-6h]
  char v5; // [sp+1817h] [bp-5h]

  v4 = 0;
  sub_BB194();
  sub_BAE88();
  sub_BBEBC();
  while ( 1 )
  {
    v5 = sub_BB290();
    if ( !v5 )
      break;
    if ( v5 == -1 )
    {
      snprintf(v2, 0x800u, "%s:%d ack error", "i2c_check_ack", 293);
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "i2c_check_ack",
        13,
        293,
        40,
        v3);
      sub_BB098();
      sub_BAE88();
      return 0;
    }
    ++v4;
    sub_BB098();
    sub_BAE88();
    sub_BB194();
    sub_BAE88();
  }
  sub_BB098();
  sub_BAE88();
  return 1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000BC480) --------------------------------------------------------
int __fastcall sub_BC480(char a1)
{
  sub_BB194();
  sub_BAE88();
  sub_BC0D4();
  if ( a1 == 1 )
  {
    sub_BAF9C();
  }
  else if ( !a1 )
  {
    sub_BAEA0();
  }
  sub_BB098();
  return sub_BAE88();
}

//----- (000BC4D8) --------------------------------------------------------
int __fastcall sub_BC4D8(unsigned __int8 a1)
{
  int result; // r0
  char v3[2048]; // [sp+18h] [bp-180Ch] BYREF
  char v4[12]; // [sp+818h] [bp-100Ch] BYREF
  unsigned __int8 i; // [sp+181Bh] [bp-9h]
  int v6; // [sp+181Ch] [bp-8h]

  v6 = 0;
  sub_BC0D4();
  for ( i = 0x80; i; i >>= 1 )
  {
    sub_BB194();
    sub_BAE88();
    if ( (i & a1) != 0 )
      sub_BAEA0();
    else
      sub_BAF9C();
    sub_BB098();
    sub_BAE88();
  }
  while ( 1 )
  {
    result = sub_BC348();
    if ( result )
      break;
    if ( ++v6 > 3 )
    {
      strcpy(v3, "IIC_SendData checkack 3 times,send data checkack error");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/"
               "godminer-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
               189,
               "i2c_send_data",
               13,
               359,
               100,
               v4);
    }
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000BC668) --------------------------------------------------------
int __fastcall sub_BC668(char a1)
{
  char v4[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  char v6; // [sp+181Dh] [bp-7h]
  unsigned __int8 v7; // [sp+181Eh] [bp-6h]
  unsigned __int8 i; // [sp+181Fh] [bp-5h]

  v7 = 0;
  sub_BBEBC();
  for ( i = 0x80; i; i >>= 1 )
  {
    sub_BB194();
    sub_BAE88();
    close(dword_150C24);
    dword_150C24 = open("/sys/class/gpio/gpio461/value", 0);
    if ( dword_150C24 < 0 )
    {
      strcpy(v4, "open gpio461 failed");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "i2c_recv_data",
        13,
        380,
        40,
        v5);
      sub_BB098();
      sub_BAE88();
      return 255;
    }
    v6 = sub_BB290();
    if ( v6 == 1 )
    {
      v7 |= i;
    }
    else if ( v6 == -1 )
    {
      sub_BB098();
      sub_BAE88();
      strcpy(v4, "read GPIO461 error");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_i2c_sim.c",
        189,
        "i2c_recv_data",
        13,
        395,
        40,
        v5);
      return 255;
    }
    sub_BB098();
    sub_BAE88();
  }
  sub_BC480(a1);
  return v7;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150C24: using guessed type int dword_150C24;
// 1608F0: using guessed type int g_zc;

//----- (000BC8E0) --------------------------------------------------------
int __fastcall i2c_sim_send_cmd(char a1, char a2, char a3, unsigned __int8 a4, unsigned __int8 a5)
{
  unsigned __int8 v10; // [sp+7h] [bp-Dh]
  unsigned __int8 v11; // [sp+Fh] [bp-5h]

  v10 = 2 * a1;
  if ( a3 )
  {
    sub_BC2F0();
    sub_BC4D8(v10);
    sub_BC4D8(a4);
  }
  if ( a2 )
  {
    sub_BC2F0();
    sub_BC4D8(v10 | 1);
    v11 = sub_BC668(0);
    sub_BC318();
    return v11;
  }
  else
  {
    if ( a3 != 1 )
    {
      sub_BC2F0();
      sub_BC4D8(v10);
    }
    sub_BC4D8(a5);
    sub_BC318();
    return 0;
  }
}

//----- (000BC9D4) --------------------------------------------------------
int __fastcall lcd_init(const char *a1)
{
  char v3[2048]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( dword_160584 )
    return 0;
  if ( a1 )
  {
    dword_160580 = open(a1, 2050);
    if ( dword_160580 >= 0 )
    {
      dword_160584 = 1;
      return dword_160580;
    }
    else
    {
      strcpy(v3, "open lcd failed!!!\n");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_lcd.c",
        185,
        "lcd_init",
        8,
        32,
        100,
        v4);
      return -1;
    }
  }
  else
  {
    strcpy(v3, "bad param\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_lcd.c",
      185,
      "lcd_init",
      8,
      26,
      100,
      v4);
    return -3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160580: using guessed type int dword_160580;
// 160584: using guessed type int dword_160584;
// 1608F0: using guessed type int g_zc;

//----- (000BCBB8) --------------------------------------------------------
int __fastcall lcd_write(int a1, unsigned __int8 a2, int a3, unsigned int a4)
{
  size_t v5; // r3
  int v6; // r2
  unsigned int v8; // [sp+10h] [bp-181Ch]
  unsigned __int8 v10; // [sp+1Bh] [bp-1811h]
  char v11[2048]; // [sp+20h] [bp-180Ch] BYREF
  char v12[12]; // [sp+820h] [bp-100Ch] BYREF
  size_t n; // [sp+1820h] [bp-Ch]
  int v14; // [sp+1824h] [bp-8h]

  v8 = a4;
  v10 = a2;
  v14 = 0;
  if ( !dword_160584 )
    return -2;
  if ( a1 == dword_160580 && a2 <= 3u && a4 <= 0x40 )
  {
    if ( pthread_mutex_lock(&stru_160588) )
    {
      strcpy(v11, "failed to lcd lock\n");
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_lcd.c",
        185,
        "lcd_write",
        9,
        66,
        100,
        v12);
      return -4;
    }
    else
    {
      do
      {
        v5 = v8;
        if ( v8 >= 0x10 )
          v5 = 16;
        n = v5;
        v6 = (char)v10++;
        memcpy((char *)&unk_1605A0 + 16 * v6, (const void *)(a3 + v14), v5);
        v14 += n;
        v8 -= n;
      }
      while ( v8 && v10 <= 3u );
      write(dword_160580, &unk_1605A0, 0x40u);
      pthread_mutex_unlock(&stru_160588);
      return 0;
    }
  }
  else
  {
    strcpy(v11, "bad param\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_lcd.c",
      185,
      "lcd_write",
      9,
      60,
      80,
      v12);
    return -3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160580: using guessed type int dword_160580;
// 160584: using guessed type int dword_160584;
// 160588: using guessed type pthread_mutex_t stru_160588;
// 1608F0: using guessed type int g_zc;

//----- (000BCEF0) --------------------------------------------------------
int lcd_flush()
{
  return 0;
}

//----- (000BCF14) --------------------------------------------------------
int __fastcall lcd_clear(int a1)
{
  char v3[2048]; // [sp+18h] [bp-1804h] BYREF
  char v4[4]; // [sp+818h] [bp-1004h] BYREF

  if ( !dword_160584 )
    return -2;
  if ( a1 == dword_160580 )
  {
    if ( pthread_mutex_lock(&stru_160588) )
    {
      strcpy(v3, "failed to lcd lock\n");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_lcd.c",
        185,
        "lcd_clear",
        9,
        112,
        100,
        v4);
      return -4;
    }
    else
    {
      memset(&unk_1605A0, 32, 0x40u);
      lseek(dword_160580, 0, 0);
      write(dword_160580, &unk_1605A0, 0x40u);
      pthread_mutex_unlock(&stru_160588);
      return 0;
    }
  }
  else
  {
    strcpy(v3, "bad param\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_lcd.c",
      185,
      "lcd_clear",
      9,
      107,
      80,
      v4);
    return -3;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160580: using guessed type int dword_160580;
// 160584: using guessed type int dword_160584;
// 160588: using guessed type pthread_mutex_t stru_160588;
// 1608F0: using guessed type int g_zc;

//----- (000BD128) --------------------------------------------------------
int __fastcall lcd_uninit(int a1)
{
  char v2[2048]; // [sp+1Ch] [bp-1808h] BYREF
  char v3[8]; // [sp+81Ch] [bp-1008h] BYREF
  int v4; // [sp+181Ch] [bp-8h]

  v4 = 0;
  if ( dword_160584 )
  {
    if ( close(a1) )
    {
      strcpy(v2, "lcd close failed!!!\n");
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_lcd.c",
        185,
        "lcd_uninit",
        10,
        135,
        100,
        v3);
      v4 = -1;
    }
    dword_160584 = 0;
  }
  return v4;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160584: using guessed type int dword_160584;
// 1608F0: using guessed type int g_zc;

//----- (000BD250) --------------------------------------------------------
int __fastcall sub_BD250(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (000BD288) --------------------------------------------------------
int uart_init()
{
  _DWORD v2[512]; // [sp+10h] [bp-1804h] BYREF
  char v3[4]; // [sp+810h] [bp-1004h] BYREF

  if ( platform_inited )
  {
    if ( !dword_1608E0 )
      dword_1608E0 = (int)new_c_map(774736, 0, 0);
    return 0;
  }
  else
  {
    strcpy((char *)v2, "please init platform first!!\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "uart_init",
      9,
      40,
      100,
      v3,
      v2[0],
      v2[1],
      v2[2],
      v2[3],
      v2[4],
      v2[5],
      v2[6],
      v2[7]);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1603F4: using guessed type int platform_inited;
// 1608E0: using guessed type int dword_1608E0;
// 1608F0: using guessed type int g_zc;

//----- (000BD394) --------------------------------------------------------
int uart_uninit()
{
  int result; // r0

  if ( dword_1608E0 )
  {
    result = delete_c_map((void ***)dword_1608E0);
    dword_1608E0 = 0;
  }
  return result;
}
// 1608E0: using guessed type int dword_1608E0;

//----- (000BD3DC) --------------------------------------------------------
int __fastcall sub_BD3DC(const char *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v4; // r3
  int v5; // [sp+4h] [bp-18h]
  unsigned int i; // [sp+10h] [bp-Ch]
  unsigned int j; // [sp+10h] [bp-Ch]
  unsigned __int8 *v8; // [sp+14h] [bp-8h]

  v5 = a3;
  v8 = a2;
  result = printf("Dumping %u %s bytes from %p:\n", a3, a1, a2);
  while ( v5 > 0 )
  {
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( i >= v5 )
        printf("   ");
      else
        printf("%02x ", v8[i]);
    }
    for ( j = 0; j <= 0xF; ++j )
    {
      if ( j >= v5 )
      {
        putchar(32);
      }
      else
      {
        if ( v8[j] <= 0x1Fu || v8[j] > 0x7Eu )
          v4 = 46;
        else
          v4 = v8[j];
        putchar(v4);
      }
    }
    result = putchar(10);
    v8 += 16;
    if ( v5 <= 16 )
      break;
    v5 -= 16;
  }
  return result;
}

//----- (000BD558) --------------------------------------------------------
int __fastcall sub_BD558(int a1)
{
  return hal_chain_uart_addr(a1);
}

//----- (000BD580) --------------------------------------------------------
int __fastcall sub_BD580(int a1)
{
  int v1; // r0
  int v3[2]; // [sp+Ch] [bp-220h] BYREF
  char s[512]; // [sp+14h] [bp-218h] BYREF
  int v5; // [sp+214h] [bp-18h] BYREF
  int v6; // [sp+218h] [bp-14h]
  void *ptr[2]; // [sp+21Ch] [bp-10h] BYREF
  int v8; // [sp+224h] [bp-8h]

  v3[0] = a1;
  v8 = 0;
  if ( find_c_map((int *)dword_1608E0, (int)v3, ptr) == 1 )
  {
    ptr[1] = ptr[0];
    v8 = *((_DWORD *)ptr[0] + 1);
    free(ptr[0]);
  }
  else
  {
    v1 = sub_BD558(v3[0]);
    snprintf(s, 0x200u, "/dev/ttyS%d", v1);
    v6 = open(s, 2306);
    v8 = v6;
    v5 = v3[0];
    sub_BD674(v6);
    insert_c_map((int *)dword_1608E0, v3, 4u, &v5, 8u);
  }
  return v8;
}
// 1608E0: using guessed type int dword_1608E0;

//----- (000BD674) --------------------------------------------------------
int __fastcall sub_BD674(int a1)
{
  struct termios termios_p; // [sp+8h] [bp-44h] BYREF
  speed_t speed; // [sp+44h] [bp-8h]

  speed = 4098;
  tcgetattr(a1, &termios_p);
  cfsetispeed(&termios_p, speed);
  cfsetospeed(&termios_p, speed);
  termios_p.c_cflag &= 0xFFFFFECF;
  termios_p.c_cflag |= 0x30u;
  termios_p.c_cflag |= 0x80u;
  termios_p.c_cflag |= 0x800u;
  termios_p.c_iflag &= 0xFFFFFA14;
  termios_p.c_oflag &= ~1u;
  termios_p.c_lflag &= 0xFFFF7FB4;
  termios_p.c_cc[5] = 0;
  termios_p.c_cc[6] = 9;
  tcsetattr(a1, 0, &termios_p);
  return tcflush(a1, 2);
}

//----- (000BD75C) --------------------------------------------------------
int __fastcall uart_send(int a1, int a2, unsigned int a3)
{
  char v8[20]; // [sp+20h] [bp-1814h] BYREF
  char v9[20]; // [sp+820h] [bp-1014h] BYREF
  ssize_t v10; // [sp+1820h] [bp-14h]
  int fd; // [sp+1824h] [bp-10h]
  unsigned int v12; // [sp+1828h] [bp-Ch]
  int v13; // [sp+182Ch] [bp-8h]

  v10 = 0;
  v12 = 0;
  v13 = 0;
  pthread_mutex_lock(&stru_1605E0[a1]);
  fd = sub_BD580(a1);
  if ( fd >= 0 )
  {
    v13 = 0;
    flock(fd, 2);
    while ( a3 > v12 && v13 <= 29 )
    {
      v10 = write(fd, (const void *)(a2 + v12), a3 - v12);
      if ( v10 < 0 )
      {
        snprintf(v8, 0x800u, "write %d bytes failed, ret = %d on chain %d\n", a3, v10, a1);
        V_LOCK();
        logfmt_raw(v9, 0x1000u, 0, v8);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
          186,
          "uart_send",
          9,
          192,
          100,
          v9);
        pthread_mutex_unlock(&stru_1605E0[a1]);
        return v10;
      }
      v12 += v10;
      if ( a3 == v12 )
        break;
      usleep((__useconds_t)"time");
      ++v13;
    }
    flock(fd, 8);
    pthread_mutex_unlock(&stru_1605E0[a1]);
    if ( a3 != v12 )
    {
      snprintf(v8, 0x800u, "write %d bytes failed, ret = %d on chain %d\n", a3, v12, a1);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
        186,
        "uart_send",
        9,
        208,
        100,
        v9);
    }
    return v12;
  }
  else
  {
    snprintf(v8, 0x800u, "failed to get fd of chain %d, ret = %d\n", a1, fd);
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "uart_send",
      9,
      175,
      100,
      v9);
    pthread_mutex_unlock(&stru_1605E0[a1]);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1605E0: using guessed type pthread_mutex_t stru_1605E0[16];
// 1608F0: using guessed type int g_zc;

//----- (000BDB9C) --------------------------------------------------------
int __fastcall uart_receive(int a1, void *a2, size_t a3, int a4)
{
  char v10[12]; // [sp+20h] [bp-180Ch] BYREF
  char v11[12]; // [sp+820h] [bp-100Ch] BYREF
  ssize_t v12; // [sp+1820h] [bp-Ch]
  int fd; // [sp+1824h] [bp-8h]

  v12 = 0;
  pthread_mutex_lock(&stru_160760[a1]);
  fd = sub_BD580(a1);
  if ( fd >= 0 )
  {
    v12 = read(fd, a2, a3);
    pthread_mutex_unlock(&stru_160760[a1]);
    return v12;
  }
  else
  {
    snprintf(v10, 0x800u, "failed to get fd of chain %d, ret = %d\n", a1, fd);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "uart_receive",
      12,
      235,
      100,
      v11,
      a4,
      a3,
      a2);
    pthread_mutex_unlock(&stru_160760[a1]);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160760: using guessed type pthread_mutex_t stru_160760[16];
// 1608F0: using guessed type int g_zc;

//----- (000BDD70) --------------------------------------------------------
int __fastcall sub_BDD70(int a1, speed_t *a2, _DWORD *a3)
{
  char v7[2048]; // [sp+24h] [bp-1848h] BYREF
  char v8[8]; // [sp+824h] [bp-1048h] BYREF
  struct termios termios_p; // [sp+1824h] [bp-48h] BYREF
  speed_t v10; // [sp+1860h] [bp-Ch]
  speed_t v11; // [sp+1864h] [bp-8h]

  tcgetattr(a1, &termios_p);
  v10 = cfgetispeed(&termios_p);
  v11 = cfgetospeed(&termios_p);
  if ( v10 == v11 )
  {
    if ( *a3 > 3u )
    {
      *a2 = v10;
      *a3 = 4;
      return 0;
    }
    else
    {
      strcpy(v7, "bad param to get baud, size too small\n");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
        186,
        "get_baud",
        8,
        266,
        100,
        v8);
      return -2;
    }
  }
  else
  {
    strcpy(v7, "input and output speed not match\n");
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "get_baud",
      8,
      261,
      100,
      v8);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000BDFBC) --------------------------------------------------------
int __fastcall sub_BDFBC(int a1)
{
  int v1; // r3

  switch ( a1 )
  {
    case 0:
      v1 = 4109;
      break;
    case 1:
      v1 = 4106;
      break;
    case 2:
      v1 = 4103;
      break;
    case 6:
      v1 = 4100;
      break;
    case 7:
      v1 = 4099;
      break;
    case 8:
      v1 = 4097;
      break;
    case 9:
      v1 = 15;
      break;
    case 10:
      v1 = 14;
      break;
    case 11:
      v1 = 13;
      break;
    case 26:
      v1 = 4098;
      break;
    default:
      v1 = 4098;
      break;
  }
  return v1;
}
// BDFD8: control flows out of bounds to BDFDC

//----- (000BE0AC) --------------------------------------------------------
int __fastcall sub_BE0AC(int a1, int a2, int *a3)
{
  int v3; // r0
  char file[512]; // [sp+14h] [bp-2C8h] BYREF
  char s[188]; // [sp+214h] [bp-C8h] BYREF
  int v11; // [sp+2D0h] [bp-Ch]
  int v12; // [sp+2D4h] [bp-8h]

  memset(s, 0, 0x80u);
  v12 = (int)&word_1C200;
  v11 = sub_BDFBC(*a3);
  switch ( v11 )
  {
    case 4098:
      v12 = (int)&word_1C200;
      break;
    case 4104:
      v12 = (int)&unk_F4240;
      break;
    case 4106:
      v12 = 1500000;
      break;
    case 4109:
      v12 = 3125000;
      break;
  }
  close(a2);
  v3 = sub_BD558(a1);
  snprintf(file, 0x200u, "/dev/ttyS%d", v3);
  sprintf(s, "echo %d > /proc/tty/driver/serial && echo 5555555555 > %s", v12, file);
  if ( !system(s) )
    return open(file, 2306, 0);
  puts("UART_BAUD CMD ERROR");
  return -2;
}
// 1C200: using guessed type __int16 word_1C200;

//----- (000BE20C) --------------------------------------------------------
int __fastcall sub_BE20C(int a1, int *a2, unsigned int a3)
{
  char v8[2048]; // [sp+20h] [bp-1844h] BYREF
  char v9[4]; // [sp+820h] [bp-1044h] BYREF
  struct termios termios_p; // [sp+1820h] [bp-44h] BYREF
  speed_t speed; // [sp+185Ch] [bp-8h]

  tcgetattr(a1, &termios_p);
  if ( a3 > 3 )
  {
    speed = sub_BDFBC(*a2);
    cfsetispeed(&termios_p, speed);
    cfsetospeed(&termios_p, speed);
    tcsetattr(a1, 1, &termios_p);
    tcflush(a1, 2);
    return 0;
  }
  else
  {
    strcpy(v8, "bad param to set baud, size too small\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "set_baud",
      8,
      348,
      100,
      v9);
    return -2;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000BE3A8) --------------------------------------------------------
int __fastcall sub_BE3A8(int a1, _DWORD *a2, _DWORD *a3)
{
  char v7[64]; // [sp+24h] [bp-1840h] BYREF
  char v8[64]; // [sp+824h] [bp-1040h] BYREF
  struct termios termios_p; // [sp+1824h] [bp-40h] BYREF

  tcgetattr(a1, &termios_p);
  if ( *a3 > 3u )
  {
    *a2 = termios_p.c_cc[6];
    *a3 = 4;
    return 0;
  }
  else
  {
    strcpy(v7, "bad param to get vmin, size too small\n");
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "get_vmin",
      8,
      372,
      100,
      v8);
    return -2;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000BE514) --------------------------------------------------------
int __fastcall sub_BE514(int a1, int *a2, unsigned int a3)
{
  char v8[2048]; // [sp+20h] [bp-1844h] BYREF
  char v9[4]; // [sp+820h] [bp-1044h] BYREF
  struct termios termios_p; // [sp+1820h] [bp-44h] BYREF
  int v11; // [sp+185Ch] [bp-8h]

  tcgetattr(a1, &termios_p);
  if ( a3 > 3 )
  {
    v11 = *a2;
    termios_p.c_cc[6] = v11;
    tcsetattr(a1, 0, &termios_p);
    tcflush(a1, 2);
    return 0;
  }
  else
  {
    strcpy(v8, "bad param to set baud, size too small\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "set_vmin",
      8,
      389,
      100,
      v9);
    return -2;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000BE694) --------------------------------------------------------
int __fastcall uart_set_config(int a1, int a2, int *a3, unsigned int a4)
{
  char v9[12]; // [sp+20h] [bp-180Ch] BYREF
  char v10[12]; // [sp+820h] [bp-100Ch] BYREF
  int v11; // [sp+1820h] [bp-Ch]
  int v12; // [sp+1824h] [bp-8h]

  v11 = -1;
  pthread_mutex_lock(&stru_1605E0[a1]);
  v12 = sub_BD580(a1);
  if ( a2 )
  {
    if ( a2 == 1 )
    {
      v11 = sub_BE514(v12, a3, a4);
    }
    else
    {
      snprintf(v9, 0x800u, "unknown set config type = %d\n", a2);
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
        186,
        "uart_set_config",
        15,
        425,
        80,
        v10,
        a4,
        a3);
    }
  }
  else
  {
    v11 = sub_BE20C(v12, a3, a4);
  }
  pthread_mutex_unlock(&stru_1605E0[a1]);
  return v11;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1605E0: using guessed type pthread_mutex_t stru_1605E0[16];
// 1608F0: using guessed type int g_zc;

//----- (000BE878) --------------------------------------------------------
int __fastcall uart_get_config(int a1, int a2, speed_t *a3, _DWORD *a4)
{
  char v9[12]; // [sp+20h] [bp-180Ch] BYREF
  char v10[12]; // [sp+820h] [bp-100Ch] BYREF
  int v11; // [sp+1820h] [bp-Ch]
  int v12; // [sp+1824h] [bp-8h]

  v11 = -1;
  pthread_mutex_lock(&stru_1605E0[a1]);
  v12 = sub_BD580(a1);
  snprintf(v9, 0x800u, "get config of chain %d\n", a1);
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
    186,
    "uart_get_config",
    15,
    445,
    20,
    v10);
  if ( a2 )
  {
    if ( a2 == 1 )
    {
      v11 = sub_BE3A8(v12, a3, a4);
    }
    else
    {
      snprintf(v9, 0x800u, "unknown get config type = %d\n", a2);
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
        186,
        "uart_get_config",
        15,
        455,
        80,
        v10,
        a4,
        a3);
    }
  }
  else
  {
    v11 = sub_BDD70(v12, a3, a4);
  }
  pthread_mutex_unlock(&stru_1605E0[a1]);
  return v11;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1605E0: using guessed type pthread_mutex_t stru_1605E0[16];
// 1608F0: using guessed type int g_zc;

//----- (000BEAFC) --------------------------------------------------------
int high_speed_uart_set_config()
{
  return -5;
}

//----- (000BEB2C) --------------------------------------------------------
int high_speed_uart_get_config()
{
  return -5;
}

//----- (000BEB5C) --------------------------------------------------------
int __fastcall uart_flush(int a1)
{
  char v4[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  int fd; // [sp+181Ch] [bp-8h]

  pthread_mutex_lock(&stru_1605E0[a1]);
  fd = sub_BD580(a1);
  if ( fd >= 0 )
  {
    tcflush(fd, 2);
    pthread_mutex_unlock(&stru_1605E0[a1]);
    return 0;
  }
  else
  {
    snprintf(v4, 0x800u, "failed to get fd of chain %d, ret = %d\n", a1, fd);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "uart_flush",
      10,
      491,
      100,
      v5);
    pthread_mutex_unlock(&stru_1605E0[a1]);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1605E0: using guessed type pthread_mutex_t stru_1605E0[16];
// 1608F0: using guessed type int g_zc;

//----- (000BECE8) --------------------------------------------------------
int __fastcall uart_flush_tx(int a1)
{
  char v4[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  int fd; // [sp+181Ch] [bp-8h]

  pthread_mutex_lock(&stru_1605E0[a1]);
  fd = sub_BD580(a1);
  if ( fd >= 0 )
  {
    tcflush(fd, 0);
    pthread_mutex_unlock(&stru_1605E0[a1]);
    return 0;
  }
  else
  {
    snprintf(v4, 0x800u, "failed to get fd of chain %d, ret = %d\n", a1, fd);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "uart_flush_tx",
      13,
      508,
      100,
      v5);
    pthread_mutex_unlock(&stru_1605E0[a1]);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1605E0: using guessed type pthread_mutex_t stru_1605E0[16];
// 1608F0: using guessed type int g_zc;

//----- (000BEE74) --------------------------------------------------------
int __fastcall uart_flush_rx(int a1)
{
  char v4[8]; // [sp+1Ch] [bp-1808h] BYREF
  char v5[8]; // [sp+81Ch] [bp-1008h] BYREF
  int fd; // [sp+181Ch] [bp-8h]

  pthread_mutex_lock(&stru_1605E0[a1]);
  fd = sub_BD580(a1);
  if ( fd >= 0 )
  {
    tcflush(fd, 1);
    pthread_mutex_unlock(&stru_1605E0[a1]);
    return 0;
  }
  else
  {
    snprintf(v4, 0x800u, "failed to get fd of chain %d, ret = %d\n", a1, fd);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "uart_flush_rx",
      13,
      525,
      100,
      v5);
    pthread_mutex_unlock(&stru_1605E0[a1]);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1605E0: using guessed type pthread_mutex_t stru_1605E0[16];
// 1608F0: using guessed type int g_zc;

//----- (000BF000) --------------------------------------------------------
int __fastcall uart_get_readable_byte_num(int a1)
{
  char v4[2048]; // [sp+18h] [bp-180Ch] BYREF
  char v5[12]; // [sp+818h] [bp-100Ch] BYREF
  int v6; // [sp+1818h] [bp-Ch] BYREF
  int fd; // [sp+181Ch] [bp-8h]

  v6 = 0;
  pthread_mutex_lock(&stru_160760[a1]);
  fd = sub_BD580(a1);
  if ( fd >= 0 )
  {
    if ( ioctl(fd, 0x541Bu, &v6) )
    {
      strcpy(v4, "ioctl to FIONREAD failed\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
        186,
        "uart_get_readable_byte_num",
        26,
        547,
        80,
        v5);
      v6 = 0;
    }
    pthread_mutex_unlock(&stru_160760[a1]);
    return v6;
  }
  else
  {
    snprintf(v4, 0x800u, "failed to get fd of chain %d, ret = %d\n", a1, fd);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/backend/device/hal/platform/cv183x/cv183x_uart.c",
      186,
      "uart_get_readable_byte_num",
      26,
      541,
      100,
      v5);
    pthread_mutex_unlock(&stru_160760[a1]);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 160760: using guessed type pthread_mutex_t stru_160760[16];
// 1608F0: using guessed type int g_zc;

//----- (000BF258) --------------------------------------------------------
unsigned int __fastcall sub_BF258(unsigned int a1)
{
  return bswap32(a1);
}

//----- (000BF280) --------------------------------------------------------
int __cdecl convirt_total_rate(int totalRate)
{
  return totalRate;
}

//----- (000BF2A4) --------------------------------------------------------
unsigned int __fastcall sub_BF2A4(unsigned int result, int a2, unsigned int a3)
{
  unsigned int v5; // [sp+Ch] [bp-18h]
  unsigned int i; // [sp+14h] [bp-10h]

  v5 = result;
  for ( i = 0; i < a3; ++i )
  {
    result = sub_BF258(*(_DWORD *)(a2 + 4 * i));
    *(_DWORD *)(v5 + 4 * i) = result;
  }
  return result;
}

//----- (000BF324) --------------------------------------------------------
const void *__fastcall sub_BF324(const void *a1, _DWORD *a2, int a3)
{
  unsigned int v3; // r0
  const void *result; // r0
  _DWORD v7[8]; // [sp+14h] [bp-130h] BYREF
  _DWORD dest[64]; // [sp+34h] [bp-110h] BYREF
  int v9; // [sp+134h] [bp-10h]
  int v10; // [sp+138h] [bp-Ch]
  int i; // [sp+13Ch] [bp-8h]

  if ( a3 )
  {
    for ( i = 0; i <= 15; ++i )
    {
      v3 = sub_BF258(a2[i]);
      dest[i] = v3;
    }
  }
  else
  {
    memcpy(dest, a2, 0x40u);
  }
  for ( i = 16; i <= 63; i += 2 )
  {
    dest[i] = (__ROR4__(dest[i - 2], 17) ^ __ROR4__(dest[i - 2], 19) ^ (dest[i - 2] >> 10))
            + dest[i - 7]
            + ((dest[i - 15] >> 3) ^ __ROR4__(dest[i - 15], 7) ^ __ROR4__(dest[i - 15], 18))
            + dest[i - 16];
    dest[i + 1] = (__ROR4__(dest[i - 1], 17) ^ __ROR4__(dest[i - 1], 19) ^ (dest[i - 1] >> 10))
                + dest[i - 6]
                + ((dest[i - 14] >> 3) ^ __ROR4__(dest[i - 14], 7) ^ __ROR4__(dest[i - 14], 18))
                + dest[i - 15];
  }
  memcpy(v7, a1, sizeof(v7));
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[0]
      + 1116352408;
  v9 = (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22)) + (v7[0] & (v7[1] | v7[2]) | v7[2] & v7[1]);
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[1]
      + 1899447441;
  v9 = (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22)) + (v7[7] & (v7[0] | v7[1]) | v7[1] & v7[0]);
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[2]
      - 1245643825;
  v9 = (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22)) + (v7[6] & (v7[7] | v7[0]) | v7[0] & v7[7]);
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[3]
      - 373957723;
  v9 = (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22)) + (v7[5] & (v7[6] | v7[7]) | v7[7] & v7[6]);
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[4]
      + 961987163;
  v9 = (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22)) + (v7[4] & (v7[5] | v7[6]) | v7[6] & v7[5]);
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[5]
      + 1508970993;
  v9 = (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22)) + (v7[3] & (v7[4] | v7[5]) | v7[5] & v7[4]);
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[6]
      - 1841331548;
  v9 = (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22)) + (v7[2] & (v7[3] | v7[4]) | v7[4] & v7[3]);
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[7]
      - 1424204075;
  v9 = (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22)) + (v7[1] & (v7[2] | v7[3]) | v7[3] & v7[2]);
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[8]
      - 670586216;
  v9 = (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22)) + (v7[0] & (v7[1] | v7[2]) | v7[2] & v7[1]);
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[9]
      + 310598401;
  v9 = (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22)) + (v7[7] & (v7[0] | v7[1]) | v7[1] & v7[0]);
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[10]
      + 607225278;
  v9 = (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22)) + (v7[6] & (v7[7] | v7[0]) | v7[0] & v7[7]);
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[11]
      + 1426881987;
  v9 = (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22)) + (v7[5] & (v7[6] | v7[7]) | v7[7] & v7[6]);
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[12]
      + 1925078388;
  v9 = (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22)) + (v7[4] & (v7[5] | v7[6]) | v7[6] & v7[5]);
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[13]
      - 2132889090;
  v9 = (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22)) + (v7[3] & (v7[4] | v7[5]) | v7[5] & v7[4]);
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[14]
      - 1680079193;
  v9 = (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22)) + (v7[2] & (v7[3] | v7[4]) | v7[4] & v7[3]);
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[15]
      - 1046744716;
  v9 = (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22)) + (v7[1] & (v7[2] | v7[3]) | v7[3] & v7[2]);
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[16]
      - 459576895;
  v9 = (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22)) + (v7[0] & (v7[1] | v7[2]) | v7[2] & v7[1]);
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[17]
      - 272742522;
  v9 = (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22)) + (v7[7] & (v7[0] | v7[1]) | v7[1] & v7[0]);
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[18]
      + 264347078;
  v9 = (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22)) + (v7[6] & (v7[7] | v7[0]) | v7[0] & v7[7]);
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[19]
      + 604807628;
  v9 = (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22)) + (v7[5] & (v7[6] | v7[7]) | v7[7] & v7[6]);
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[20]
      + 770255983;
  v9 = (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22)) + (v7[4] & (v7[5] | v7[6]) | v7[6] & v7[5]);
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[21]
      + 1249150122;
  v9 = (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22)) + (v7[3] & (v7[4] | v7[5]) | v7[5] & v7[4]);
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[22]
      + 1555081692;
  v9 = (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22)) + (v7[2] & (v7[3] | v7[4]) | v7[4] & v7[3]);
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[23]
      + 1996064986;
  v9 = (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22)) + (v7[1] & (v7[2] | v7[3]) | v7[3] & v7[2]);
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[24]
      - 1740746414;
  v9 = (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22)) + (v7[0] & (v7[1] | v7[2]) | v7[2] & v7[1]);
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[25]
      - 1473132947;
  v9 = (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22)) + (v7[7] & (v7[0] | v7[1]) | v7[1] & v7[0]);
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[26]
      - 1341970488;
  v9 = (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22)) + (v7[6] & (v7[7] | v7[0]) | v7[0] & v7[7]);
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[27]
      - 1084653625;
  v9 = (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22)) + (v7[5] & (v7[6] | v7[7]) | v7[7] & v7[6]);
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[28]
      - 958395405;
  v9 = (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22)) + (v7[4] & (v7[5] | v7[6]) | v7[6] & v7[5]);
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[29]
      - 710438585;
  v9 = (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22)) + (v7[3] & (v7[4] | v7[5]) | v7[5] & v7[4]);
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[30]
      + 113926993;
  v9 = (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22)) + (v7[2] & (v7[3] | v7[4]) | v7[4] & v7[3]);
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[31]
      + 338241895;
  v9 = (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22)) + (v7[1] & (v7[2] | v7[3]) | v7[3] & v7[2]);
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[32]
      + 666307205;
  v9 = (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22)) + (v7[0] & (v7[1] | v7[2]) | v7[2] & v7[1]);
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[33]
      + 773529912;
  v9 = (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22)) + (v7[7] & (v7[0] | v7[1]) | v7[1] & v7[0]);
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[34]
      + 1294757372;
  v9 = (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22)) + (v7[6] & (v7[7] | v7[0]) | v7[0] & v7[7]);
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[35]
      + 1396182291;
  v9 = (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22)) + (v7[5] & (v7[6] | v7[7]) | v7[7] & v7[6]);
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[36]
      + 1695183700;
  v9 = (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22)) + (v7[4] & (v7[5] | v7[6]) | v7[6] & v7[5]);
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[37]
      + 1986661051;
  v9 = (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22)) + (v7[3] & (v7[4] | v7[5]) | v7[5] & v7[4]);
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[38]
      - 2117940946;
  v9 = (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22)) + (v7[2] & (v7[3] | v7[4]) | v7[4] & v7[3]);
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[39]
      - 1838011259;
  v9 = (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22)) + (v7[1] & (v7[2] | v7[3]) | v7[3] & v7[2]);
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[40]
      - 1564481375;
  v9 = (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22)) + (v7[0] & (v7[1] | v7[2]) | v7[2] & v7[1]);
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[41]
      - 1474664885;
  v9 = (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22)) + (v7[7] & (v7[0] | v7[1]) | v7[1] & v7[0]);
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[42]
      - 1035236496;
  v9 = (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22)) + (v7[6] & (v7[7] | v7[0]) | v7[0] & v7[7]);
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[43]
      - 949202525;
  v9 = (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22)) + (v7[5] & (v7[6] | v7[7]) | v7[7] & v7[6]);
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[44]
      - 778901479;
  v9 = (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22)) + (v7[4] & (v7[5] | v7[6]) | v7[6] & v7[5]);
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[45]
      - 694614492;
  v9 = (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22)) + (v7[3] & (v7[4] | v7[5]) | v7[5] & v7[4]);
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[46]
      - 200395387;
  v9 = (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22)) + (v7[2] & (v7[3] | v7[4]) | v7[4] & v7[3]);
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[47]
      + 275423344;
  v9 = (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22)) + (v7[1] & (v7[2] | v7[3]) | v7[3] & v7[2]);
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[48]
      + 430227734;
  v9 = (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22)) + (v7[0] & (v7[1] | v7[2]) | v7[2] & v7[1]);
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[49]
      + 506948616;
  v9 = (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22)) + (v7[7] & (v7[0] | v7[1]) | v7[1] & v7[0]);
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[50]
      + 659060556;
  v9 = (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22)) + (v7[6] & (v7[7] | v7[0]) | v7[0] & v7[7]);
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[51]
      + 883997877;
  v9 = (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22)) + (v7[5] & (v7[6] | v7[7]) | v7[7] & v7[6]);
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[52]
      + 958139571;
  v9 = (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22)) + (v7[4] & (v7[5] | v7[6]) | v7[6] & v7[5]);
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[53]
      + 1322822218;
  v9 = (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22)) + (v7[3] & (v7[4] | v7[5]) | v7[5] & v7[4]);
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[54]
      + 1537002063;
  v9 = (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22)) + (v7[2] & (v7[3] | v7[4]) | v7[4] & v7[3]);
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[55]
      + 1747873779;
  v9 = (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22)) + (v7[1] & (v7[2] | v7[3]) | v7[3] & v7[2]);
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[56]
      + 1955562222;
  v9 = (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22)) + (v7[0] & (v7[1] | v7[2]) | v7[2] & v7[1]);
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[57]
      + 2024104815;
  v9 = (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22)) + (v7[7] & (v7[0] | v7[1]) | v7[1] & v7[0]);
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[58]
      - 2067236844;
  v9 = (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22)) + (v7[6] & (v7[7] | v7[0]) | v7[0] & v7[7]);
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[59]
      - 1933114872;
  v9 = (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22)) + (v7[5] & (v7[6] | v7[7]) | v7[7] & v7[6]);
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[60]
      - 1866530822;
  v9 = (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22)) + (v7[4] & (v7[5] | v7[6]) | v7[6] & v7[5]);
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[61]
      - 1538233109;
  v9 = (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22)) + (v7[3] & (v7[4] | v7[5]) | v7[5] & v7[4]);
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[62]
      - 1090935817;
  v9 = (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22)) + (v7[2] & (v7[3] | v7[4]) | v7[4] & v7[3]);
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[63]
      - 965641998;
  result = (const void *)v7[2];
  v9 = (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22)) + (v7[1] & (v7[2] | v7[3]) | v7[3] & v7[2]);
  v7[4] += v10;
  v7[0] = v10 + v9;
  for ( i = 0; i <= 7; ++i )
  {
    result = a1;
    *((_DWORD *)a1 + i) += v7[i];
  }
  return result;
}

//----- (000C2974) --------------------------------------------------------
_DWORD *__fastcall sub_C2974(_DWORD *result)
{
  *result = 1779033703;
  result[1] = -1150833019;
  result[2] = 1013904242;
  result[3] = -1521486534;
  result[4] = 1359893119;
  result[5] = -1694144372;
  result[6] = 528734635;
  result[7] = 1541459225;
  return result;
}

//----- (000C2A30) --------------------------------------------------------
void *__fastcall sub_C2A30(_DWORD *a1, int a2)
{
  void *result; // r0
  int v5; // [sp+Ch] [bp-188h] BYREF
  int v6; // [sp+10h] [bp-184h]
  int v7; // [sp+14h] [bp-180h]
  int v8; // [sp+18h] [bp-17Ch]
  int v9; // [sp+1Ch] [bp-178h]
  int v10; // [sp+20h] [bp-174h]
  int v11; // [sp+24h] [bp-170h]
  int v12; // [sp+28h] [bp-16Ch]
  _DWORD v13[8]; // [sp+2Ch] [bp-168h] BYREF
  _DWORD dest[4]; // [sp+4Ch] [bp-148h] BYREF
  _BYTE v15[48]; // [sp+5Ch] [bp-138h] BYREF
  _DWORD v16[8]; // [sp+8Ch] [bp-108h]
  _DWORD v17[8]; // [sp+ACh] [bp-E8h] BYREF
  _DWORD v18[8]; // [sp+CCh] [bp-C8h] BYREF
  _DWORD v19[8]; // [sp+ECh] [bp-A8h] BYREF
  _BYTE v20[32]; // [sp+10Ch] [bp-88h] BYREF
  _DWORD v21[8]; // [sp+12Ch] [bp-68h] BYREF
  _DWORD v22[5]; // [sp+14Ch] [bp-48h] BYREF
  int v23; // [sp+160h] [bp-34h] BYREF
  unsigned int i; // [sp+18Ch] [bp-8h]

  sub_C2974(v17);
  sub_BF324(v17, a1, 1);
  memcpy(dest, a1 + 16, sizeof(dest));
  memcpy(v15, &unk_13B65C, sizeof(v15));
  sub_BF324(v17, dest, 1);
  v16[0] = v17[0];
  v16[1] = v17[1];
  v16[2] = v17[2];
  v16[3] = v17[3];
  v16[4] = v17[4];
  v16[5] = v17[5];
  v16[6] = v17[6];
  v16[7] = v17[7];
  sub_C2974(v21);
  for ( i = 0; i <= 7; ++i )
    dest[i] = v16[i] ^ 0x36363636;
  while ( i <= 0xF )
    dest[i++] = 909522486;
  sub_BF324(v21, dest, 0);
  sub_BF324(v21, a1, 1);
  sub_BF2A4((unsigned int)v22, (int)(a1 + 16), 4u);
  sub_BF2A4((unsigned int)&v23, (int)&unk_13B6B0, 0xBu);
  sub_C2974(v18);
  for ( i = 0; i <= 7; ++i )
    dest[i] = v16[i] ^ 0x5C5C5C5C;
  while ( i <= 0xF )
    dest[i++] = 1549556828;
  sub_BF324(v18, dest, 0);
  result = memcpy(v20, &unk_13B68C, sizeof(v20));
  for ( i = 0; i <= 3; ++i )
  {
    v5 = v21[0];
    v6 = v21[1];
    v7 = v21[2];
    v8 = v21[3];
    v9 = v21[4];
    v10 = v21[5];
    v11 = v21[6];
    v12 = v21[7];
    v22[4] = i + 1;
    sub_BF324(&v5, v22, 0);
    v19[0] = v5;
    v19[1] = v6;
    v19[2] = v7;
    v19[3] = v8;
    v19[4] = v9;
    v19[5] = v10;
    v19[6] = v11;
    v19[7] = v12;
    v13[0] = v18[0];
    v13[1] = v18[1];
    v13[2] = v18[2];
    v13[3] = v18[3];
    v13[4] = v18[4];
    v13[5] = v18[5];
    v13[6] = v18[6];
    v13[7] = v18[7];
    sub_BF324(v13, v19, 0);
    result = (void *)sub_BF2A4(a2 + 32 * i, (int)v13, 8u);
  }
  return result;
}

//----- (000C2D68) --------------------------------------------------------
const void *__fastcall sub_C2D68(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD dest[4]; // [sp+14h] [bp-88h] BYREF
  _DWORD v8[12]; // [sp+24h] [bp-78h] BYREF
  _DWORD v9[8]; // [sp+54h] [bp-48h]
  int v10; // [sp+74h] [bp-28h] BYREF
  int v11; // [sp+78h] [bp-24h]
  int v12; // [sp+7Ch] [bp-20h]
  int v13; // [sp+80h] [bp-1Ch]
  int v14; // [sp+84h] [bp-18h]
  int v15; // [sp+88h] [bp-14h]
  int v16; // [sp+8Ch] [bp-10h]
  int v17; // [sp+90h] [bp-Ch]
  unsigned int i; // [sp+94h] [bp-8h]

  sub_C2974(&v10);
  sub_BF324(&v10, a1, 1);
  memcpy(dest, a1 + 16, sizeof(dest));
  memcpy(v8, &unk_13B65C, sizeof(v8));
  sub_BF324(&v10, dest, 1);
  v9[0] = v10;
  v9[1] = v11;
  v9[2] = v12;
  v9[3] = v13;
  v9[4] = v14;
  v9[5] = v15;
  v9[6] = v16;
  v9[7] = v17;
  sub_C2974(a3);
  for ( i = 0; i <= 7; ++i )
    dest[i] = v9[i] ^ 0x5C5C5C5C;
  while ( i <= 0xF )
    dest[i++] = 1549556828;
  sub_BF324(a3, dest, 0);
  sub_C2974(&v10);
  for ( i = 0; i <= 7; ++i )
    dest[i] = v9[i] ^ 0x36363636;
  while ( i <= 0xF )
    dest[i++] = 909522486;
  sub_BF324(&v10, dest, 0);
  sub_BF324(&v10, a2, 1);
  sub_BF324(&v10, a2 + 16, 1);
  sub_BF324(&v10, dword_13B6DC, 0);
  dest[0] = v10;
  dest[1] = v11;
  dest[2] = v12;
  dest[3] = v13;
  v8[0] = v14;
  v8[1] = v15;
  v8[2] = v16;
  v8[3] = v17;
  memcpy(&v8[4], &unk_13B68C, 0x20u);
  return sub_BF324(a3, dest, 0);
}
// 13B6DC: using guessed type _DWORD dword_13B6DC[16];

//----- (000C2FF4) --------------------------------------------------------
int *__fastcall sub_C2FF4(int *result, _DWORD *a2)
{
  unsigned int i; // [sp+Ch] [bp-48h]
  int v3; // [sp+10h] [bp-44h]
  int v4; // [sp+10h] [bp-44h]
  int v5; // [sp+14h] [bp-40h]
  int v6; // [sp+14h] [bp-40h]
  int v7; // [sp+18h] [bp-3Ch]
  int v8; // [sp+18h] [bp-3Ch]
  int v9; // [sp+1Ch] [bp-38h]
  int v10; // [sp+1Ch] [bp-38h]
  int v11; // [sp+20h] [bp-34h]
  int v12; // [sp+20h] [bp-34h]
  int v13; // [sp+24h] [bp-30h]
  int v14; // [sp+24h] [bp-30h]
  int v15; // [sp+28h] [bp-2Ch]
  int v16; // [sp+28h] [bp-2Ch]
  int v17; // [sp+2Ch] [bp-28h]
  int v18; // [sp+2Ch] [bp-28h]
  int v19; // [sp+30h] [bp-24h]
  int v20; // [sp+30h] [bp-24h]
  int v21; // [sp+34h] [bp-20h]
  int v22; // [sp+34h] [bp-20h]
  int v23; // [sp+38h] [bp-1Ch]
  int v24; // [sp+38h] [bp-1Ch]
  int v25; // [sp+3Ch] [bp-18h]
  int v26; // [sp+3Ch] [bp-18h]
  int v27; // [sp+40h] [bp-14h]
  int v28; // [sp+40h] [bp-14h]
  int v29; // [sp+44h] [bp-10h]
  int v30; // [sp+44h] [bp-10h]
  int v31; // [sp+48h] [bp-Ch]
  int v32; // [sp+48h] [bp-Ch]
  int v33; // [sp+4Ch] [bp-8h]
  int v34; // [sp+4Ch] [bp-8h]

  *result ^= *a2;
  v33 = *result;
  result[1] ^= a2[1];
  v31 = result[1];
  result[2] ^= a2[2];
  v29 = result[2];
  result[3] ^= a2[3];
  v27 = result[3];
  result[4] ^= a2[4];
  v25 = result[4];
  result[5] ^= a2[5];
  v23 = result[5];
  result[6] ^= a2[6];
  v21 = result[6];
  result[7] ^= a2[7];
  v19 = result[7];
  result[8] ^= a2[8];
  v17 = result[8];
  result[9] ^= a2[9];
  v15 = result[9];
  result[10] ^= a2[10];
  v13 = result[10];
  result[11] ^= a2[11];
  v11 = result[11];
  result[12] ^= a2[12];
  v9 = result[12];
  result[13] ^= a2[13];
  v7 = result[13];
  result[14] ^= a2[14];
  v5 = result[14];
  result[15] ^= a2[15];
  v3 = result[15];
  for ( i = 0; i <= 7; i += 2 )
  {
    v26 = __ROR4__(v33 + v9, 25) ^ v25;
    v16 = __ROR4__(v23 + v31, 25) ^ v15;
    v6 = __ROR4__(v13 + v21, 25) ^ v5;
    v28 = __ROR4__(v3 + v11, 25) ^ v27;
    v18 = __ROR4__(v26 + v33, 23) ^ v17;
    v8 = __ROR4__(v16 + v23, 23) ^ v7;
    v30 = __ROR4__(v6 + v13, 23) ^ v29;
    v20 = __ROR4__(v28 + v3, 23) ^ v19;
    v10 = __ROR4__(v18 + v26, 19) ^ v9;
    v32 = __ROR4__(v8 + v16, 19) ^ v31;
    v22 = __ROR4__(v30 + v6, 19) ^ v21;
    v12 = __ROR4__(v20 + v28, 19) ^ v11;
    v34 = __ROR4__(v10 + v18, 14) ^ v33;
    v24 = __ROR4__(v32 + v8, 14) ^ v23;
    v14 = __ROR4__(v22 + v30, 14) ^ v13;
    v4 = __ROR4__(v12 + v20, 14) ^ v3;
    v31 = __ROR4__(v34 + v28, 25) ^ v32;
    v21 = __ROR4__(v24 + v26, 25) ^ v22;
    v11 = __ROR4__(v14 + v16, 25) ^ v12;
    v9 = __ROR4__(v4 + v6, 25) ^ v10;
    v29 = __ROR4__(v31 + v34, 23) ^ v30;
    v19 = __ROR4__(v21 + v24, 23) ^ v20;
    v17 = __ROR4__(v11 + v14, 23) ^ v18;
    v7 = __ROR4__(v9 + v4, 23) ^ v8;
    v27 = __ROR4__(v29 + v31, 19) ^ v28;
    v25 = __ROR4__(v19 + v21, 19) ^ v26;
    v15 = __ROR4__(v17 + v11, 19) ^ v16;
    v5 = __ROR4__(v7 + v9, 19) ^ v6;
    v33 = __ROR4__(v27 + v29, 14) ^ v34;
    v23 = __ROR4__(v25 + v19, 14) ^ v24;
    v13 = __ROR4__(v15 + v17, 14) ^ v14;
    v3 = __ROR4__(v5 + v7, 14) ^ v4;
  }
  *result += v33;
  result[1] += v31;
  result[2] += v29;
  result[3] += v27;
  result[4] += v25;
  result[5] += v23;
  result[6] += v21;
  result[7] += v19;
  result[8] += v17;
  result[9] += v15;
  result[10] += v13;
  result[11] += v11;
  result[12] += v9;
  result[13] += v7;
  result[14] += v5;
  result[15] += v3;
  return result;
}

//----- (000C38AC) --------------------------------------------------------
const void *__fastcall sub_C38AC(_DWORD *a1, int a2, _DWORD *a3)
{
  int src[32]; // [sp+10h] [bp-A4h] BYREF
  unsigned int v7; // [sp+90h] [bp-24h]
  int v8; // [sp+94h] [bp-20h]
  unsigned int v9; // [sp+98h] [bp-1Ch]
  int *v10; // [sp+9Ch] [bp-18h]
  unsigned int j; // [sp+A0h] [bp-14h]
  unsigned int i; // [sp+A4h] [bp-10h]

  v10 = src;
  v9 = (a2 + 63) & 0xFFFFFFC0;
  sub_C2A30(a1, (int)src);
  for ( i = 0; i < 0x400; i += 2 )
  {
    memcpy((void *)(v9 + (i << 7)), src, 0x80u);
    sub_C2FF4(src, &src[16]);
    sub_C2FF4(&src[16], src);
    memcpy((void *)(v9 + ((i + 1) << 7)), src, 0x80u);
    sub_C2FF4(src, &src[16]);
    sub_C2FF4(&src[16], src);
  }
  for ( i = 0; i < 0x400; i += 2 )
  {
    v8 = src[16] & 0x3FF;
    v7 = v9 + (v8 << 7);
    for ( j = 0; j <= 0xF; ++j )
      *(_QWORD *)&v10[2 * j] ^= *(_QWORD *)(v7 + 8 * j);
    sub_C2FF4(src, &src[16]);
    sub_C2FF4(&src[16], src);
    v8 = src[16] & 0x3FF;
    v7 = v9 + (v8 << 7);
    for ( j = 0; j <= 0xF; ++j )
      *(_QWORD *)&v10[2 * j] ^= *(_QWORD *)(v7 + 8 * j);
    sub_C2FF4(src, &src[16]);
    sub_C2FF4(&src[16], src);
  }
  return sub_C2D68(a1, src, a3);
}

//----- (000C3B68) --------------------------------------------------------
int __fastcall sub_C3B68(int result, int a2)
{
  int v2; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  v2 = result;
  for ( i = 0; i <= 7; ++i )
  {
    result = v2;
    *(_DWORD *)(v2 + 4 * i) = (*(_DWORD *)(a2 + 4 * i) << 24)
                            | (*(_DWORD *)(a2 + 4 * i) << 8) & 0xFF0000
                            | (*(_DWORD *)(a2 + 4 * i) >> 8) & 0xFF00
                            | HIBYTE(*(_DWORD *)(a2 + 4 * i));
  }
  return result;
}

//----- (000C3C48) --------------------------------------------------------
int __fastcall scrypt_regenhash(_DWORD *a1, int a2)
{
  _BYTE v3[131584]; // [sp+10h] [bp-2025Ch] BYREF
  _DWORD v4[20]; // [sp+20210h] [bp-5Ch] BYREF
  _DWORD *v5; // [sp+20260h] [bp-Ch]
  unsigned int *v6; // [sp+20264h] [bp-8h]

  memset(v3, 0, sizeof(v3));
  v6 = (unsigned int *)(a2 + 76);
  v5 = a1;
  sub_BF2A4((unsigned int)v4, a2, 0x13u);
  v4[19] = sub_BF258(*v6);
  sub_C38AC(v4, (int)v3, v5);
  return sub_C3B68((int)v5, (int)v5);
}

//----- (000C3D34) --------------------------------------------------------
int __fastcall scrypt_test(int a1, int a2, unsigned int a3)
{
  _BYTE v5[131596]; // [sp-20208h] [bp-2029Ch] BYREF
  unsigned int v6; // [sp+4h] [bp-90h]
  int v7; // [sp+8h] [bp-8Ch]
  int v8; // [sp+Ch] [bp-88h]
  _DWORD v9[8]; // [sp+14h] [bp-80h] BYREF
  _DWORD v10[20]; // [sp+34h] [bp-60h] BYREF
  unsigned int v11; // [sp+84h] [bp-10h]
  _BYTE *v12; // [sp+88h] [bp-Ch]
  unsigned int v13; // [sp+8Ch] [bp-8h]

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v13 = convirt_total_rate(*(_DWORD *)(a2 + 28));
  sub_BF2A4((unsigned int)v10, v8, 0x13u);
  v10[19] = sub_BF258(v6);
  v12 = v5;
  sub_C38AC(v10, (int)v5, v9);
  v11 = sub_BF258(v9[7]);
  if ( v11 <= 0xFFFF )
    return v11 <= v13;
  else
    return -1;
}

//----- (000C3E0C) --------------------------------------------------------
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  uint32_t v3; // [sp+14h] [bp-138h]
  uint32_t v4; // [sp+18h] [bp-134h]
  uint32_t v5; // [sp+1Ch] [bp-130h]
  int v6; // [sp+20h] [bp-12Ch]
  uint32_t v7; // [sp+24h] [bp-128h]
  uint32_t v8; // [sp+28h] [bp-124h]
  uint32_t v9; // [sp+2Ch] [bp-120h]
  uint32_t v10; // [sp+30h] [bp-11Ch]
  uint32_t w[64]; // [sp+34h] [bp-118h]
  int v12; // [sp+134h] [bp-18h]
  uint32_t v13; // [sp+138h] [bp-14h]
  const unsigned __int8 *v14; // [sp+13Ch] [bp-10h]
  int j; // [sp+140h] [bp-Ch]
  signed int i; // [sp+144h] [bp-8h]

  for ( i = 0; i < (int)block_nb; ++i )
  {
    v14 = &message[64 * i];
    for ( j = 0; j <= 15; ++j )
      w[j] = v14[4 * j + 3] | (v14[4 * j + 2] << 8) | (v14[4 * j + 1] << 16) | (v14[4 * j] << 24);
    for ( j = 16; j <= 63; ++j )
      w[j] = (__ROR4__(w[j - 2], 17) ^ __ROR4__(w[j - 2], 19) ^ (w[j - 2] >> 10))
           + w[j - 7]
           + ((w[j - 15] >> 3) ^ __ROR4__(w[j - 15], 7) ^ __ROR4__(w[j - 15], 18))
           + w[j - 16];
    for ( j = 0; j <= 7; ++j )
      *(&v3 + j) = *((_DWORD *)ctx + j + 34);
    for ( j = 0; j <= 63; ++j )
    {
      v13 = v10 + (__ROR4__(v7, 25) ^ __ROR4__(v7, 6) ^ __ROR4__(v7, 11)) + (v9 & ~v7 ^ v7 & v8) + sha256_k[j] + w[j];
      v12 = (__ROR4__(v3, 2) ^ __ROR4__(v3, 13) ^ __ROR4__(v3, 22)) + (v5 & v4 ^ v3 & (v5 ^ v4));
      v10 = v9;
      v9 = v8;
      v8 = v7;
      v7 = v6 + v13;
      v6 = v5;
      v5 = v4;
      v4 = v3;
      v3 = v13 + v12;
    }
    for ( j = 0; j <= 7; ++j )
      *((_DWORD *)ctx + j + 34) += *(&v3 + j);
  }
}
// 150D48: using guessed type _DWORD sha256_k[64];

//----- (000C4234) --------------------------------------------------------
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  _BYTE v6[168]; // [sp+10h] [bp-ACh] BYREF

  sha256_init((sha256_ctx *)v6);
  sha256_update((sha256_ctx *)v6, message, len);
  sha256_final((sha256_ctx *)v6, digest);
}

//----- (000C4288) --------------------------------------------------------
void __cdecl sha256_init(sha256_ctx *ctx)
{
  int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)ctx + i + 34) = sha256_h0[i];
  *((_DWORD *)ctx + 1) = 0;
  *(_DWORD *)ctx = 0;
}
// 150D28: using guessed type _DWORD sha256_h0[8];

//----- (000C4304) --------------------------------------------------------
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  size_t v3; // r3
  const unsigned __int8 *v7; // [sp+14h] [bp-18h]
  unsigned int v8; // [sp+18h] [bp-14h]
  size_t n; // [sp+20h] [bp-Ch]
  int na; // [sp+20h] [bp-Ch]

  v3 = len;
  if ( 64 - *((_DWORD *)ctx + 1) < len )
    v3 = 64 - *((_DWORD *)ctx + 1);
  n = v3;
  memcpy((char *)ctx + *((_DWORD *)ctx + 1) + 8, message, v3);
  if ( *((_DWORD *)ctx + 1) + len > 0x3F )
  {
    v8 = (len - n) >> 6;
    v7 = &message[n];
    sha256_transf(ctx, (const unsigned __int8 *)ctx + 8, 1u);
    sha256_transf(ctx, &message[n], v8);
    na = ((_BYTE)len - (_BYTE)n) & 0x3F;
    memcpy((char *)ctx + 8, &v7[64 * v8], na);
    *((_DWORD *)ctx + 1) = na;
    *(_DWORD *)ctx += (v8 + 1) << 6;
  }
  else
  {
    *((_DWORD *)ctx + 1) += len;
  }
}

//----- (000C4454) --------------------------------------------------------
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  int v2; // r3
  int v5; // [sp+8h] [bp-14h]
  int v6; // [sp+Ch] [bp-10h]
  unsigned int v7; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  if ( (*((_DWORD *)ctx + 1) & 0x3Fu) <= 0x37 )
    v2 = 1;
  else
    v2 = 2;
  v7 = v2;
  v6 = 8 * (*(_DWORD *)ctx + *((_DWORD *)ctx + 1));
  v5 = v2 << 6;
  memset((char *)ctx + *((_DWORD *)ctx + 1) + 8, 0, (v2 << 6) - *((_DWORD *)ctx + 1));
  *((_BYTE *)ctx + *((_DWORD *)ctx + 1) + 8) = 0x80;
  *((_BYTE *)ctx + v5 + 7) = v6;
  *((_BYTE *)ctx + v5 + 6) = BYTE1(v6);
  *((_BYTE *)ctx + v5 + 5) = BYTE2(v6);
  *((_BYTE *)ctx + v5 + 4) = HIBYTE(v6);
  sha256_transf(ctx, (const unsigned __int8 *)ctx + 8, v7);
  for ( i = 0; i <= 7; ++i )
  {
    digest[4 * i + 3] = *((_DWORD *)ctx + i + 34);
    digest[4 * i + 2] = BYTE1(*((_DWORD *)ctx + i + 34));
    digest[4 * i + 1] = BYTE2(*((_DWORD *)ctx + i + 34));
    digest[4 * i] = HIBYTE(*((_DWORD *)ctx + i + 34));
  }
}

//----- (000C468C) --------------------------------------------------------
int __fastcall sub_C468C(__int16 a1, char a2)
{
  return crc_itu_t_table[(unsigned __int8)(a2 ^ HIBYTE(a1))] ^ (unsigned __int16)(a1 << 8);
}
// 13B814: using guessed type _WORD crc_itu_t_table[256];

//----- (000C4708) --------------------------------------------------------
int __fastcall BM_CRC16(char *a1, int a2)
{
  char *v2; // r3
  unsigned __int16 i; // [sp+Eh] [bp-6h]

  for ( i = -1; a2--; i = sub_C468C(i, *v2) )
    v2 = a1++;
  return i;
}

//----- (000C4774) --------------------------------------------------------
int __fastcall BM_CRC16_WITH_KEY(char *a1, int a2, unsigned __int16 a3)
{
  char *v3; // r3

  while ( a2-- )
  {
    v3 = a1++;
    a3 = sub_C468C(a3, *v3);
  }
  return a3;
}

//----- (000C47E8) --------------------------------------------------------
int BM_CRC8()
{
  return 0;
}

//----- (000C4814) --------------------------------------------------------
int __fastcall BM_CRC5(_BYTE *a1, unsigned int a2)
{
  _BYTE v4[5]; // [sp+Ch] [bp-20h]
  int v5; // [sp+14h] [bp-18h]
  char v6; // [sp+18h] [bp-14h]
  bool v7; // [sp+1Ah] [bp-12h]
  unsigned __int8 v8; // [sp+1Bh] [bp-11h]
  int v9; // [sp+1Ch] [bp-10h]
  unsigned int v10; // [sp+20h] [bp-Ch]
  unsigned int i; // [sp+24h] [bp-8h]

  v5 = 16843009;
  v6 = 1;
  v10 = 128;
  v9 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v7 = (v10 & *a1) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 128;
      v9 = 0;
      ++a1;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (000C4A10) --------------------------------------------------------
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len)
{
  const uint8_t *v2; // r3
  unsigned __int16 v7; // [sp+Ch] [bp-8h]
  unsigned __int8 v8; // [sp+Eh] [bp-6h]
  unsigned __int8 v9; // [sp+Fh] [bp-5h]

  v9 = -1;
  v8 = -1;
  while ( w_len-- )
  {
    v2 = p_data++;
    v7 = (unsigned __int8)(v8 ^ *v2);
    v8 = v9 ^ chCRCHTalbe[v8 ^ *v2];
    v9 = chCRCLTalbe[v7];
  }
  return (v9 << 8) | v8;
}
// 13BA1C: using guessed type _BYTE chCRCHTalbe[256];
// 13BB1C: using guessed type _BYTE chCRCLTalbe[256];

//----- (000C4AD8) --------------------------------------------------------
int __fastcall sub_C4AD8(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r3
  int v4; // [sp+Ch] [bp-8h]

  v4 = 5381;
  while ( *a1 )
  {
    v1 = a1++;
    v4 = *v1 ^ (33 * v4);
  }
  return v4;
}

//----- (000C4B40) --------------------------------------------------------
char *__fastcall sub_C4B40(char *a1, const void *a2, size_t a3)
{
  char *v8; // [sp+14h] [bp-10h]
  size_t n; // [sp+1Ch] [bp-8h]

  n = strlen(a1) + 1;
  v8 = (char *)malloc((-n & 3) + n + a3 + 12);
  if ( !v8 )
    return 0;
  memcpy(v8 + 12, a1, n);
  *(_DWORD *)v8 = sub_C4AD8((unsigned __int8 *)a1);
  *((_DWORD *)v8 + 1) = &v8[(-n & 3) + 12 + n];
  memcpy(*((void **)v8 + 1), a2, a3);
  return v8;
}

//----- (000C4C24) --------------------------------------------------------
int __fastcall sub_C4C24(int a1, int a2)
{
  return a2 & (*(_DWORD *)(a1 + 4) - 1);
}

//----- (000C4C5C) --------------------------------------------------------
int __fastcall sub_C4C5C(_DWORD *a1, int *a2)
{
  int result; // r0

  result = sub_C4C24((int)a1, *a2);
  a2[2] = *(_DWORD *)(*a1 + 4 * result);
  *(_DWORD *)(*a1 + 4 * result) = a2;
  return result;
}

//----- (000C4CD0) --------------------------------------------------------
int __fastcall sub_C4CD0(int a1, int a2)
{
  int *v7; // [sp+Ch] [bp-18h]
  int *v8; // [sp+Ch] [bp-18h]
  void *v9; // [sp+10h] [bp-14h]
  int v10; // [sp+14h] [bp-10h]
  int *i; // [sp+18h] [bp-Ch]
  int *j; // [sp+18h] [bp-Ch]
  int *v13; // [sp+1Ch] [bp-8h]

  v13 = 0;
  v10 = *(_DWORD *)(a1 + 4);
  while ( v10-- )
  {
    for ( i = *(int **)(*(_DWORD *)a1 + 4 * v10); i; i = v7 )
    {
      v7 = (int *)i[2];
      i[2] = (int)v13;
      v13 = i;
    }
  }
  v9 = realloc(*(void **)a1, 4 * a2);
  if ( v9 )
  {
    *(_DWORD *)a1 = v9;
    *(_DWORD *)(a1 + 4) = a2;
  }
  if ( *(_DWORD *)a1 )
  {
    memset(*(void **)a1, 0, 4 * *(_DWORD *)(a1 + 4));
    for ( j = v13; j; j = v8 )
    {
      v8 = (int *)j[2];
      sub_C4C5C((_DWORD *)a1, j);
    }
  }
  if ( v9 )
    return 0;
  else
    return -1;
}

//----- (000C4E34) --------------------------------------------------------
int __fastcall sub_C4E34(int *a1, unsigned __int8 *a2)
{
  int v2; // r4
  int v7; // [sp+8h] [bp-14h]
  int i; // [sp+Ch] [bp-10h]

  v7 = sub_C4AD8(a2);
  if ( a1[1] )
  {
    v2 = *a1;
    for ( i = v2 + 4 * sub_C4C24((int)a1, v7); *(_DWORD *)i; i = *(_DWORD *)i + 8 )
    {
      if ( v7 == **(_DWORD **)i && !strcmp((const char *)(*(_DWORD *)i + 12), (const char *)a2) )
        return i;
    }
  }
  return 0;
}

//----- (000C4F00) --------------------------------------------------------
void __fastcall map_deinit_(int a1)
{
  _DWORD *v3; // [sp+Ch] [bp-10h]
  int v4; // [sp+10h] [bp-Ch]
  _DWORD *ptr; // [sp+14h] [bp-8h]

  v4 = *(_DWORD *)(a1 + 4);
  while ( v4-- )
  {
    for ( ptr = *(_DWORD **)(*(_DWORD *)a1 + 4 * v4); ptr; ptr = v3 )
    {
      v3 = (_DWORD *)ptr[2];
      free(ptr);
    }
  }
  free(*(void **)a1);
}

//----- (000C4F98) --------------------------------------------------------
int __fastcall map_get_(int *a1, unsigned __int8 *a2)
{
  int v4; // [sp+Ch] [bp-8h]

  v4 = sub_C4E34(a1, a2);
  if ( v4 )
    return *(_DWORD *)(*(_DWORD *)v4 + 4);
  else
    return 0;
}

//----- (000C4FE8) --------------------------------------------------------
int __fastcall map_set_(int *a1, unsigned __int8 *a2, const void *a3, size_t a4)
{
  int v5; // r3
  char *ptr; // [sp+18h] [bp-Ch]
  int v12; // [sp+1Ch] [bp-8h]

  v12 = sub_C4E34(a1, a2);
  if ( v12 )
  {
    memcpy(*(void **)(*(_DWORD *)v12 + 4), a3, a4);
    return 0;
  }
  else
  {
    ptr = sub_C4B40((char *)a2, a3, a4);
    if ( !ptr || a1[2] >= (unsigned int)a1[1] && (!a1[1] ? (v5 = 1) : (v5 = 2 * a1[1]), sub_C4CD0((int)a1, v5)) )
    {
      if ( ptr )
        free(ptr);
      return -1;
    }
    else
    {
      sub_C4C5C(a1, (int *)ptr);
      ++a1[2];
      return 0;
    }
  }
}

//----- (000C5118) --------------------------------------------------------
void __fastcall map_remove_(int *a1, unsigned __int8 *a2)
{
  void *ptr; // [sp+8h] [bp-Ch]
  int v4; // [sp+Ch] [bp-8h]

  v4 = sub_C4E34(a1, a2);
  if ( v4 )
  {
    ptr = *(void **)v4;
    *(_DWORD *)v4 = *(_DWORD *)(*(_DWORD *)v4 + 8);
    free(ptr);
    --a1[2];
  }
}

//----- (000C5190) --------------------------------------------------------
_DWORD *__fastcall map_iter_(_DWORD *result)
{
  *result = -1;
  result[1] = 0;
  return result;
}

//----- (000C51D4) --------------------------------------------------------
int __fastcall map_next_(_DWORD *a1, _DWORD *a2)
{
  if ( a2[1] )
  {
    a2[1] = *(_DWORD *)(a2[1] + 8);
    if ( a2[1] )
      return a2[1] + 12;
  }
  while ( ++*a2 < a1[1] )
  {
    a2[1] = *(_DWORD *)(*a1 + 4 * *a2);
    if ( a2[1] )
      return a2[1] + 12;
  }
  return 0;
}

//----- (000C52B0) --------------------------------------------------------
size_t __fastcall statusServiceThread(int a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  size_t v9; // r0
  char v11[80]; // [sp+1Ch] [bp-7050h] BYREF
  char v12[8]; // [sp+101Ch] [bp-6050h] BYREF
  char v13[4]; // [sp+1024h] [bp-6048h] BYREF
  socklen_t addr_len; // [sp+1028h] [bp-6044h] BYREF
  char v15[64]; // [sp+102Ch] [bp-6040h] BYREF
  char v16[4096]; // [sp+382Ch] [bp-3840h] BYREF
  struct sockaddr addr; // [sp+482Ch] [bp-2840h] BYREF
  char v18[10240]; // [sp+483Ch] [bp-2830h] BYREF
  _DWORD optval[2]; // [sp+703Ch] [bp-30h] BYREF
  int fd; // [sp+7044h] [bp-28h]
  int v21; // [sp+7048h] [bp-24h]
  signed int v22; // [sp+704Ch] [bp-20h]
  size_t v23; // [sp+7050h] [bp-1Ch]
  void *buf; // [sp+7054h] [bp-18h]
  int v25; // [sp+7058h] [bp-14h]
  ssize_t v26; // [sp+705Ch] [bp-10h]

  fd = a1;
  optval[0] = 3;
  optval[1] = 0;
  buf = v18;
  v26 = -1;
  memset(v16, 0, sizeof(v16));
  v22 = 0;
  v21 = 0;
  v25 = 0;
  addr_len = 0;
  v23 = 0;
  strcpy(v13, "\r\n");
  strcpy(v12, "\r\n\r\n");
  memset(v18, 0, sizeof(v18));
  while ( ExitServer != 1 )
  {
    v26 = recvfrom(fd, buf, 10239 - v25, 0, &addr, &addr_len);
    if ( v26 <= 0 )
    {
      close(fd);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, ":statusServiceThread recvfrom<=0");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/http.c",
        159,
        "statusServiceThread",
        19,
        52,
        20,
        v11);
      return 0;
    }
    v25 += v26;
    if ( v25 > 10238 )
    {
      close(fd);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "BUFSIZE is too small!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/http.c",
        159,
        "statusServiceThread",
        19,
        60,
        20,
        v11);
      return 0;
    }
    buf = &v18[v25];
    if ( strstr(v18, v12) )
    {
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "find http request end flag!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/http.c",
        159,
        "statusServiceThread",
        19,
        67,
        20,
        v11);
      break;
    }
  }
  V_LOCK();
  logfmt_raw(v11, 0x1000u, 0, "get http=%s", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/common/general/http.c",
    159,
    "statusServiceThread",
    19,
    72,
    20,
    v11);
  if ( v18[0] == 71 && v18[1] == 69 && v18[2] == 84 && v18[3] == 32 )
  {
    v26 = setsockopt(fd, 1, 21, optval, 8u);
    if ( v26 )
    {
      close(fd);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, "setsockopt SO_SNDTIMEO failed");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/http.c",
        159,
        "statusServiceThread",
        19,
        87,
        20,
        v11);
      return 0;
    }
    else
    {
      v26 = setsockopt(fd, 1, 20, optval, 8u);
      if ( v26 )
      {
        close(fd);
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, "setsockopt SO_RCVTIMEO failed");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/http.c",
          159,
          "statusServiceThread",
          19,
          95,
          20,
          v11);
        return 0;
      }
      else
      {
        if ( http_test_case )
        {
          if ( http_test_case(v18, v16, 4096) )
          {
            close(fd);
            V_LOCK();
            logfmt_raw(v11, 0x1000u, 0, "statusServiceThread exit for Error cmd!");
            V_UNLOCK();
            zlog(
              g_zc,
              "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/g"
              "odminer-origin_godminer-branch1/common/general/http.c",
              159,
              "statusServiceThread",
              19,
              108,
              20,
              v11);
            return 0;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v11, 0x1000u, 0, "No 6060 test case found.");
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/common/general/http.c",
            159,
            "statusServiceThread",
            19,
            103,
            20,
            v11);
        }
        v22 = strlen(v16);
        v26 = 0;
        v2 = sprintf(v15, "HTTP/1.0  200  OK%s", v13);
        v26 += v2;
        v3 = sprintf(&v15[v26], "Server: SearchFreqServer%s", v13);
        v26 += v3;
        v4 = sprintf(&v15[v26], "Cache-Control: no-cache%s", v13);
        v26 += v4;
        v5 = sprintf(&v15[v26], "Pragma: no-cache%s", v13);
        v26 += v5;
        v6 = sprintf(&v15[v26], "Content-Type: text/plain%s", v13);
        v26 += v6;
        v7 = sprintf(&v15[v26], "Content-Length: %d%s", v22, v13);
        v26 += v7;
        v8 = sprintf(&v15[v26], "Connection: Keep-Alive%s", v12);
        v26 += v8;
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, "send http response...");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/http.c",
          159,
          "statusServiceThread",
          19,
          123,
          20,
          v11);
        do
        {
          if ( ExitServer == 1 )
            break;
          v23 = 0;
          do
          {
            v9 = strlen(v15);
            v26 = send(fd, &v15[v23], v9 - v23, 0x4000);
            if ( v26 == -1 && *_errno_location() == 11 )
            {
              V_LOCK();
              logfmt_raw(v11, 0x1000u, 0, "statusServiceThread send http timeout, try again...");
              V_UNLOCK();
              zlog(
                g_zc,
                "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build"
                "/godminer-origin_godminer-branch1/common/general/http.c",
                159,
                "statusServiceThread",
                19,
                132,
                20,
                v11);
              usleep((__useconds_t)"time");
            }
            else
            {
              if ( v26 <= 0 )
              {
                close(fd);
                V_LOCK();
                logfmt_raw(v11, 0x1000u, 0, "statusServiceThread send http response error");
                V_UNLOCK();
                zlog(
                  g_zc,
                  "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/bui"
                  "ld/godminer-origin_godminer-branch1/common/general/http.c",
                  159,
                  "statusServiceThread",
                  19,
                  139,
                  20,
                  v11);
                return 0;
              }
              v23 += v26;
            }
          }
          while ( strlen(v15) > v23 && ExitServer != 1 );
        }
        while ( strlen(v15) > v23 && !ExitServer );
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, "send http data...");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/http.c",
          159,
          "statusServiceThread",
          19,
          153,
          20,
          v11);
        v23 = 0;
        while ( 1 )
        {
          v26 = send(fd, &v16[v23], v22 - v23, 0);
          V_LOCK();
          logfmt_raw(v11, 0x1000u, 0, "send http data ret=%d", v26);
          V_UNLOCK();
          zlog(
            g_zc,
            "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/god"
            "miner-origin_godminer-branch1/common/general/http.c",
            159,
            "statusServiceThread",
            19,
            159,
            20,
            v11);
          if ( v26 <= 0 )
            break;
          v23 += v26;
          if ( (int)v23 >= v22 || v21 || ExitServer == 1 )
            goto LABEL_41;
        }
        v21 = 1;
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, "statusServiceThread send http data error");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/http.c",
          159,
          "statusServiceThread",
          19,
          163,
          20,
          v11);
LABEL_41:
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, "one client disconnected!");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/http.c",
          159,
          "statusServiceThread",
          19,
          173,
          20,
          v11);
        close(fd);
        return v23;
      }
    }
  }
  else
  {
    close(fd);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "statusServiceThread not support http command");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/http.c",
      159,
      "statusServiceThread",
      19,
      79,
      20,
      v11);
    return 0;
  }
}
// 1608E8: invalid function type '?' has been ignored
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608E4: using guessed type char ExitServer;
// 1608E8: using guessed type int (__fastcall *http_test_case)(_DWORD, _DWORD, _DWORD);
// 1608F0: using guessed type int g_zc;

//----- (000C6198) --------------------------------------------------------
int httpListenThread()
{
  char v1[48]; // [sp+1Ch] [bp-1030h] BYREF
  socklen_t addr_len; // [sp+101Ch] [bp-30h] BYREF
  struct sockaddr addr; // [sp+1020h] [bp-2Ch] BYREF
  struct sockaddr s; // [sp+1030h] [bp-1Ch] BYREF
  int v5; // [sp+1040h] [bp-Ch]
  int fd; // [sp+1044h] [bp-8h]

  v5 = 0;
  fd = -1;
  do
  {
    listen_sockfd = socket(2, 1, 6);
    if ( listen_sockfd >= 0 )
    {
      memset(&s, 0, sizeof(s));
      s.sa_family = 2;
      *(_DWORD *)&s.sa_data[2] = htonl(0);
      *(_WORD *)s.sa_data = htons(0x17ACu);
      if ( bind(listen_sockfd, &s, 0x10u) >= 0 )
      {
        if ( listen(listen_sockfd, 100) >= 0 )
          break;
        V_LOCK();
        logfmt_raw(v1, 0x1000u, 0, "http listen failed! try again after 10s...");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/http.c",
          159,
          "httpListenThread",
          16,
          222,
          80,
          v1);
        close(listen_sockfd);
        listen_sockfd = -1;
        sleep(0xAu);
      }
      else
      {
        V_LOCK();
        logfmt_raw(v1, 0x1000u, 0, "http port bind failed! try again after 10s...");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/http.c",
          159,
          "httpListenThread",
          16,
          211,
          80,
          v1);
        close(listen_sockfd);
        listen_sockfd = -1;
        sleep(0xAu);
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, "socket creating failed, try again after 10s...");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/http.c",
        159,
        "httpListenThread",
        16,
        198,
        80,
        v1);
      sleep(0xAu);
    }
  }
  while ( ExitServer != 1 );
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "start listen on 6060 ...");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/common/general/http.c",
    159,
    "httpListenThread",
    16,
    235,
    60,
    v1);
  while ( ExitServer != 1 )
  {
    for ( fd = -1; fd == -1 && ExitServer != 1; fd = accept(listen_sockfd, &addr, &addr_len) )
    {
      usleep(0x2710u);
      addr_len = 16;
    }
    if ( ExitServer )
    {
      if ( fd != -1 )
      {
        close(fd);
        fd = -1;
      }
      break;
    }
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, "one client connected sock=%d", fd);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/http.c",
      159,
      "httpListenThread",
      16,
      257,
      20,
      v1);
    statusServiceThread(fd);
  }
  close(listen_sockfd);
  listen_sockfd = -1;
  return v5;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 150F48: using guessed type int listen_sockfd;
// 1608E4: using guessed type char ExitServer;
// 1608F0: using guessed type int g_zc;

//----- (000C665C) --------------------------------------------------------
__int64 start_http_thread()
{
  char v1[52]; // [sp+10h] [bp-1034h] BYREF
  pthread_attr_t attr; // [sp+1010h] [bp-34h] BYREF
  pthread_t newthread; // [sp+1034h] [bp-10h] BYREF
  int v4; // [sp+1038h] [bp-Ch]
  size_t stacksize; // [sp+103Ch] [bp-8h]

  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "start the http thread.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/common/general/http.c",
    159,
    "start_http_thread",
    17,
    273,
    60,
    v1);
  v4 = pthread_attr_init(&attr);
  stacksize = 0x200000;
  v4 = pthread_attr_setstacksize(&attr, 0x200000u);
  v4 = pthread_create(&newthread, &attr, (void *(*)(void *))httpListenThread, 0);
  pthread_detach(newthread);
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "httpListenThread start ret=%d", v4);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/common/general/http.c",
           159,
           "start_http_thread",
           17,
           280,
           60,
           v1);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C67BC) --------------------------------------------------------
int log_init()
{
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0

  if ( !opt_zlog_conf_file )
    opt_zlog_conf_file = (int)strdup("/etc/zlog.conf");
  if ( zlog_init(opt_zlog_conf_file) )
  {
    puts("zlog init failed");
    return -1;
  }
  else
  {
    g_zc = zlog_get_category("miner_zc");
    if ( g_zc )
    {
      g_temp_zc = zlog_get_category("miner_temp_zc");
      if ( g_temp_zc )
      {
        g_fan_zc = zlog_get_category("miner_fan_zc");
        if ( g_fan_zc )
        {
          g_hash_zc = zlog_get_category("miner_hash_zc");
          if ( g_hash_zc )
          {
            g_droa_zc = zlog_get_category("miner_droa");
            if ( g_droa_zc )
            {
              puts("zlog init OK!");
              return 0;
            }
            else
            {
              v5 = puts("zlog get miner_droa category fail");
              zlog_fini(v5);
              return -5;
            }
          }
          else
          {
            v4 = puts("zlog get miner_hash_zc category fail");
            zlog_fini(v4);
            return -4;
          }
        }
        else
        {
          v3 = puts("zlog get miner_fan_zc category fail");
          zlog_fini(v3);
          return -3;
        }
      }
      else
      {
        v2 = puts("zlog get miner_temp_zc category fail");
        zlog_fini(v2);
        return -3;
      }
    }
    else
    {
      v1 = puts("zlog get miner_zc category fail");
      zlog_fini(v1);
      return -2;
    }
  }
}
// 1CDD4: using guessed type int __fastcall zlog_init(_DWORD);
// 1CDEC: using guessed type int __fastcall zlog_get_category(_DWORD);
// 1D348: using guessed type int __fastcall zlog_fini(_DWORD);
// 1608EC: using guessed type int opt_zlog_conf_file;
// 1608F0: using guessed type int g_zc;
// 1608F4: using guessed type int g_temp_zc;
// 1608F8: using guessed type int g_fan_zc;
// 1608FC: using guessed type int g_hash_zc;
// 160900: using guessed type int g_droa_zc;

//----- (000C69B8) --------------------------------------------------------
int __fastcall log_uninit(int a1)
{
  if ( g_zc || g_temp_zc || g_fan_zc || g_hash_zc || g_droa_zc )
  {
    zlog_fini(a1);
    g_droa_zc = 0;
    g_hash_zc = 0;
    g_temp_zc = 0;
    g_zc = 0;
  }
  puts("zlog uninit!");
  return 0;
}
// 1D348: using guessed type int __fastcall zlog_fini(_DWORD);
// 1608F0: using guessed type int g_zc;
// 1608F4: using guessed type int g_temp_zc;
// 1608F8: using guessed type int g_fan_zc;
// 1608FC: using guessed type int g_hash_zc;
// 160900: using guessed type int g_droa_zc;

//----- (000C6A98) --------------------------------------------------------
int log_reload()
{
  if ( g_zc && g_temp_zc && g_fan_zc && g_hash_zc && g_droa_zc )
  {
    zlog_reload(opt_zlog_conf_file);
    puts("zlog reload!");
  }
  return 0;
}
// 1D3B4: using guessed type int __fastcall zlog_reload(_DWORD);
// 1608EC: using guessed type int opt_zlog_conf_file;
// 1608F0: using guessed type int g_zc;
// 1608F4: using guessed type int g_temp_zc;
// 1608F8: using guessed type int g_fan_zc;
// 1608FC: using guessed type int g_hash_zc;
// 160900: using guessed type int g_droa_zc;

//----- (000C6B30) --------------------------------------------------------
int __fastcall log_droa(const char *a1)
{
  if ( !dword_16096C )
    dword_16096C = zlog_get_category(off_15104C[0]);
  return zlog(
           dword_16096C,
           "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godm"
           "iner-origin_godminer-branch1/common/general/log/log.c",
           162,
           "log_droa",
           8,
           110,
           40,
           "%s",
           a1);
}
// 1CDEC: using guessed type int __fastcall zlog_get_category(_DWORD);
// 1D474: using guessed type int zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 15104C: using guessed type char *off_15104C[19];
// 16096C: using guessed type int dword_16096C;

//----- (000C6BDC) --------------------------------------------------------
int __fastcall my_system(const char *a1)
{
  int *v2; // r0
  char *v3; // r0
  char v5[12]; // [sp+18h] [bp-140Ch] BYREF
  char v6[12]; // [sp+1018h] [bp-40Ch] BYREF
  FILE *stream; // [sp+1418h] [bp-Ch]
  int v8; // [sp+141Ch] [bp-8h]

  if ( a1 )
  {
    stream = popen(a1, "r");
    if ( stream )
    {
      while ( fgets(v6, 1024, stream) )
        ;
      v8 = pclose(stream);
      if ( v8 == -1 )
      {
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, "close popen file pointer fp error!");
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/log/log.c",
          162,
          "my_system",
          9,
          169,
          40,
          v5);
        return v8;
      }
      else if ( v8 )
      {
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, "pclose res is :%d", (v8 & 0x7F) == 0);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/log/log.c",
          162,
          "my_system",
          9,
          178,
          40,
          v5);
        return BYTE1(v8);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      V_LOCK();
      v2 = _errno_location();
      v3 = strerror(*v2);
      logfmt_raw(v5, 0x1000u, 0, "popen error: %s", v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/log/log.c",
        162,
        "my_system",
        9,
        158,
        40,
        v5);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "cmd is NULL!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/log/log.c",
      162,
      "my_system",
      9,
      153,
      40,
      v5);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C6EC4) --------------------------------------------------------
int __fastcall sub_C6EC4(int a1, const char *a2, const char *a3, const char *a4)
{
  char v6[8]; // [sp+2Ch] [bp-2008h] BYREF
  char v7[8]; // [sp+102Ch] [bp-1008h] BYREF
  unsigned int v8; // [sp+202Ch] [bp-8h]

  v8 = snprintf(
         v7,
         0x1000u,
         "/usr/bin/updatename.sh %s %s %s %s %s %s",
         *(const char **)(a1 + 8),
         (const char *)(a1 + 42),
         (const char *)(a1 + 72),
         a2,
         a3,
         a4);
  if ( v8 < 0x1000 )
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "_log_update_name");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/log/log.c",
      162,
      "_log_update_name",
      16,
      195,
      20,
      v6);
    v8 = my_system(v7);
    if ( v8 )
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "my_system returned failed %d on LOGUPDATENAME", v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/log/log.c",
        162,
        "_log_update_name",
        16,
        199,
        40,
        v6);
    }
    return v8;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "too large command LOGUPDATENAME");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/log/log.c",
      162,
      "_log_update_name",
      16,
      192,
      40,
      v6);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C7148) --------------------------------------------------------
int __fastcall sub_C7148(int a1)
{
  char v4[20]; // [sp+20h] [bp-2014h] BYREF
  char v5[20]; // [sp+1020h] [bp-1014h] BYREF
  int v6; // [sp+2020h] [bp-14h]
  unsigned int v7; // [sp+2024h] [bp-10h]

  v6 = 0;
  v7 = snprintf(v5, 0x1000u, "/usr/bin/checksize.sh %d %s", 0, *(const char **)(a1 + 8));
  if ( v7 < 0x1000 )
  {
    v7 = my_system(v5);
    if ( v7 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "my_system returned failed %d on LOGCHECKSIZE", v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/log/log.c",
        162,
        "log_rotate",
        10,
        220,
        40,
        v4);
    }
    v7 = snprintf(
           v5,
           0x1000u,
           "/usr/bin/rotate.sh %d %d %s %s %s %s %s",
           v6,
           *(_DWORD *)a1,
           *(const char **)(a1 + 8),
           *(const char **)(a1 + 4),
           (const char *)(a1 + 42),
           (const char *)(a1 + 72),
           *(const char **)(a1 + 92));
    if ( v7 < 0x1000 )
    {
      v7 = my_system(v5);
      if ( v7 )
      {
        V_LOCK();
        logfmt_raw(v4, 0x1000u, 0, "my_system returned failed %d on LOGROTATE", v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmi"
          "ner-origin_godminer-branch1/common/general/log/log.c",
          162,
          "log_rotate",
          10,
          232,
          40,
          v4);
      }
      return v7;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "too large command LOGROTATE");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/log/log.c",
        162,
        "log_rotate",
        10,
        226,
        40,
        v4);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "too large command LOGCHECKSIZE");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/log/log.c",
      162,
      "log_rotate",
      10,
      214,
      40,
      v4);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C74B8) --------------------------------------------------------
int __fastcall sub_C74B8(int a1, const char *a2, const char *a3)
{
  char v5[8]; // [sp+24h] [bp-2008h] BYREF
  char v6[8]; // [sp+1024h] [bp-1008h] BYREF
  unsigned int v7; // [sp+2024h] [bp-8h]

  v7 = snprintf(
         v6,
         0x1000u,
         "/usr/bin/symbollink.sh %s %s %s %s %s",
         *(const char **)(a1 + 8),
         (const char *)(a1 + 42),
         (const char *)(a1 + 72),
         a2,
         a3);
  if ( v7 < 0x1000 )
  {
    v7 = my_system(v6);
    if ( v7 )
    {
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "my_system returned failed %d on LOG_SYMBOL_LINK", v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/log/log.c",
        162,
        "_log_generate_symbol_link",
        25,
        253,
        40,
        v5);
    }
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "too large command LOG_SYMBOL_LINK");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/log/log.c",
      162,
      "_log_generate_symbol_link",
      25,
      246,
      40,
      v5);
    return -1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C76AC) --------------------------------------------------------
void __fastcall __noreturn sub_C76AC(int a1)
{
  int v1; // r0
  size_t v2; // r0
  char v3[20]; // [sp+18h] [bp-2054h] BYREF
  char v4[20]; // [sp+1018h] [bp-1054h] BYREF
  char src[20]; // [sp+2018h] [bp-54h] BYREF
  char s[32]; // [sp+202Ch] [bp-40h] BYREF
  time_t timer; // [sp+204Ch] [bp-20h] BYREF
  int v8; // [sp+2050h] [bp-1Ch]
  struct tm *tp; // [sp+2054h] [bp-18h]
  int v10; // [sp+2058h] [bp-14h]
  int v11; // [sp+205Ch] [bp-10h]

  v10 = a1;
  v11 = 0;
  if ( !a1 )
  {
    strcpy(v3, "input arg wrong\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3, 0);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/log/log.c",
      162,
      "log_thread_routine",
      18,
      272,
      120,
      v4);
  }
  *(_DWORD *)v10 = 0;
  *(_DWORD *)(v10 + 92) = "cglog_sync";
  while ( 1 )
  {
    if ( !(++v11 % 0x1Eu) )
    {
      time(&timer);
      tp = localtime(&timer);
      strftime(s, 0xFu, "%Y-%m/%d", tp);
      strftime(src, 0xAu, "%H-%M-%S", tp);
      if ( !strncmp((const char *)(v10 + 42), "1970", 4u) && timer > 31536000 )
      {
        v8 = sub_C6EC4(v10, "cglog_init", s, src);
        v1 = sub_C6EC4(v10, "cglog_sync", s, src);
        v8 |= v1;
        if ( !v8 )
        {
          strncpy((char *)(v10 + 42), s, 0x1Eu);
          strncpy((char *)(v10 + 72), src, 0x14u);
          strcpy((char *)(v10 + 12), (const char *)(v10 + 42));
        }
      }
      if ( *(_BYTE *)(v10 + 12) )
      {
        v2 = strlen(s);
        if ( strncmp((const char *)(v10 + 12), s, v2) )
        {
          v8 = sub_C74B8(v10, "cglog_sync", s);
          if ( !v8 )
            strncpy((char *)(v10 + 12), s, 0x1Eu);
        }
      }
      else
      {
        strcpy((char *)(v10 + 12), (const char *)(v10 + 42));
      }
      sub_C7148(v10);
    }
    sleep(1u);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C79CC) --------------------------------------------------------
void cal_log_init()
{
  _DWORD v0[1024]; // [sp+10h] [bp-2014h] BYREF
  char v1[20]; // [sp+1010h] [bp-1014h] BYREF
  pthread_t newthread; // [sp+2010h] [bp-14h] BYREF
  time_t timer; // [sp+2014h] [bp-10h] BYREF
  struct tm *tp; // [sp+2018h] [bp-Ch]
  void *arg; // [sp+201Ch] [bp-8h]

  arg = &dword_16090C;
  if ( !byte_160936 )
  {
    time(&timer);
    tp = localtime(&timer);
    strftime((char *)arg + 42, 0xFu, "%Y-%m/%d", tp);
    strftime((char *)arg + 72, 0xAu, "%H-%M-%S", tp);
    *(_DWORD *)arg = 1;
    *((_DWORD *)arg + 1) = "/var/log";
    *((_DWORD *)arg + 2) = "nvdata";
    *((_DWORD *)arg + 23) = "cglog_init";
    sub_C7148((int)arg);
    if ( pthread_create(&newthread, 0, (void *(*)(void *))sub_C76AC, arg) )
    {
      strcpy((char *)v0, "Failed to create log thread");
      V_LOCK();
      logfmt_raw(v1, 0x1000u, 0, v0, 0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/log/log.c",
        162,
        "cal_log_init",
        12,
        351,
        120,
        v1,
        v0[0],
        v0[1],
        v0[2],
        v0[3],
        v0[4],
        v0[5],
        v0[6]);
    }
    pthread_detach(newthread);
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;
// 16090C: using guessed type int dword_16090C;
// 160936: using guessed type char byte_160936;

//----- (000C7B7C) --------------------------------------------------------
int logfmt_raw(void *a1, size_t a2, int a3, ...)
{
  unsigned int v3; // r3
  int result; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  const char *v8; // r3
  int v9; // r0
  int v10; // r0
  const char *v12; // [sp+10h] [bp-1034h]
  double v13; // [sp+20h] [bp-1024h]
  char **v14; // [sp+30h] [bp-1014h]
  char v15[4096]; // [sp+34h] [bp-1010h] BYREF
  char *format; // [sp+1034h] [bp-10h]
  int v17; // [sp+1038h] [bp-Ch]
  int v18; // [sp+103Ch] [bp-8h]
  va_list varg_r3; // [sp+104Ch] [bp+8h] BYREF

  va_start(varg_r3, a3);
  v18 = 0;
  memset(a1, 0, a2);
  memset(v15, 0, sizeof(v15));
  va_copy(v14, varg_r3);
  v17 = 0;
  while ( 2 )
  {
    if ( v17 < dword_160988 )
    {
      v3 = ((unsigned int)v14 + 7) & 0xFFFFFFF8;
      v14 = (char **)(v3 + 32);
      v12 = *(const char **)v3;
      result = *(_DWORD *)(v3 + 16);
      v13 = *(double *)(v3 + 16);
      switch ( *(_DWORD *)(v3 + 8) )
      {
        case 0:
          if ( strchr((const char *)LODWORD(v13), 32)
            || !strcmp((const char *)LODWORD(v13), "true") && strlen((const char *)LODWORD(v13)) == 4 )
          {
            v5 = sprintf((char *)a1 + v18, "%s=\"%s\" ", v12, (const char *)LODWORD(v13));
            v18 += v5;
          }
          else
          {
            v6 = sprintf((char *)a1 + v18, "%s=%s ", v12, (const char *)LODWORD(v13));
            v18 += v6;
          }
          goto LABEL_14;
        case 1:
          v7 = sprintf((char *)a1 + v18, "%s=%lf ", v12, v13);
          v18 += v7;
          goto LABEL_14;
        case 2:
          if ( LOBYTE(v13) )
            v8 = "true";
          else
            v8 = "false";
          v9 = sprintf((char *)a1 + v18, "%s=%s ", v12, v8);
          v18 += v9;
          goto LABEL_14;
        case 3:
          v10 = sprintf((char *)a1 + v18, "%s=%lld ", v12, v13);
          v18 += v10;
LABEL_14:
          ++v17;
          continue;
        default:
          return result;
      }
    }
    break;
  }
  format = *v14;
  vsprintf(v15, format, v14 + 1);
  if ( strchr(v15, 32) )
    result = sprintf((char *)a1 + v18, "msg=\"%s\"", v15);
  else
    result = sprintf((char *)a1 + v18, "msg=%s", v15);
  dword_160988 = 0;
  return result;
}
// C7C5C: control flows out of bounds to C7C60
// 160988: using guessed type int dword_160988;

//----- (000C7FA0) --------------------------------------------------------
int V_LOCK()
{
  return pthread_mutex_lock(&stru_160970);
}
// 160970: using guessed type pthread_mutex_t stru_160970;

//----- (000C7FBC) --------------------------------------------------------
int V_UNLOCK()
{
  return pthread_mutex_unlock(&stru_160970);
}
// 160970: using guessed type pthread_mutex_t stru_160970;

//----- (000C7FD8) --------------------------------------------------------
int __fastcall V_STR(int a1, const char *a2, const char *a3)
{
  size_t v3; // r4
  size_t v4; // r1

  ++dword_160988;
  v3 = strlen(a2);
  v4 = strlen(a3);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = v3;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = v4;
  return a1;
}
// 160988: using guessed type int dword_160988;

//----- (000C8070) --------------------------------------------------------
int __fastcall V_FLOAT(int a1, const char *a2)
{
  __int64 v2; // d0
  size_t v3; // r0

  ++dword_160988;
  v3 = strlen(a2);
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = v3;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = v2;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}
// C80D8: variable 'v2' is possibly undefined
// 160988: using guessed type int dword_160988;

//----- (000C80F4) --------------------------------------------------------
int __fastcall V_BOOL(int a1, const char *a2, char a3)
{
  size_t v3; // r1

  ++dword_160988;
  v3 = strlen(a2);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = v3;
  *(_DWORD *)(a1 + 8) = 2;
  *(_BYTE *)(a1 + 16) = a3;
  return a1;
}
// 160988: using guessed type int dword_160988;

//----- (000C8188) --------------------------------------------------------
int __fastcall V_INT(int a1, const char *a2, __int64 a3)
{
  size_t v3; // r0

  ++dword_160988;
  v3 = strlen(a2);
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = v3;
  *(_DWORD *)(a1 + 8) = 3;
  *(_QWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}
// 160988: using guessed type int dword_160988;

//----- (000C820C) --------------------------------------------------------
void *new_observable_subject()
{
  return calloc(1u, 0x404u);
}

//----- (000C822C) --------------------------------------------------------
void __fastcall destroy_observable_subject(void *a1)
{
  free(a1);
}

//----- (000C8250) --------------------------------------------------------
int __fastcall subject_observe(int result, int a2)
{
  *(_DWORD *)(result + 4 * (*(_DWORD *)(result + 1024))++) = a2;
  return result;
}

//----- (000C829C) --------------------------------------------------------
int __fastcall subject_notify_all(int result, int a2)
{
  int v3; // [sp+4h] [bp-10h]
  int i; // [sp+Ch] [bp-8h]

  v3 = result;
  for ( i = 0; i < *(_DWORD *)(v3 + 1024); ++i )
    result = (*(int (__fastcall **)(int))(v3 + 4 * i))(a2);
  return result;
}

//----- (000C82FC) --------------------------------------------------------
int sub_C82FC()
{
  return *_errno_location() == 11 || *_errno_location() == 11;
}

//----- (000C8348) --------------------------------------------------------
int __fastcall send_line(int a1, const char *a2)
{
  size_t v3; // r3
  int v4; // r3
  fd_set v8[32]; // [sp+1Ch] [bp-1020h] BYREF
  struct timeval timeout; // [sp+101Ch] [bp-20h] BYREF
  fd_set *v10; // [sp+1024h] [bp-18h]
  unsigned int i; // [sp+1028h] [bp-14h]
  ssize_t v12; // [sp+102Ch] [bp-10h]
  size_t n; // [sp+1030h] [bp-Ch]
  int v14; // [sp+1034h] [bp-8h]

  v14 = 0;
  if ( a1 == -1 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "socket invalid!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/socket.c",
      161,
      "send_line",
      9,
      12,
      20,
      (const char *)v8);
    return 0;
  }
  else
  {
    n = strlen(a2);
    if ( a2[n - 1] != 10 )
    {
      v3 = n++;
      a2[v3] = 10;
      a2[n] = 0;
    }
    while ( (int)n > 0 )
    {
      timeout.tv_sec = 0;
      timeout.tv_usec = 0;
      v10 = v8;
      for ( i = 0; i <= 0x1F; ++i )
        v10->__fds_bits[i] = 0;
      LOBYTE(v4) = a1 & 0x1F;
      if ( a1 <= 0 )
        v4 = -(-a1 & 0x1F);
      v8[0].__fds_bits[a1 / 32] |= 1 << v4;
      if ( select(a1 + 1, 0, v8, 0, &timeout) <= 0 )
        return 0;
      v12 = send(a1, &a2[v14], n, 0x4000);
      if ( v12 < 0 )
      {
        if ( (unsigned __int8)sub_C82FC() != 1 )
          return 0;
        v12 = 0;
      }
      v14 += v12;
      n -= v12;
    }
    return 1;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C8644) --------------------------------------------------------
int __fastcall socket_full(int a1, __time_t a2)
{
  int v3; // r3
  char v6[20]; // [sp+18h] [bp-1094h] BYREF
  fd_set readfds; // [sp+1018h] [bp-94h] BYREF
  struct timeval timeout; // [sp+1098h] [bp-14h] BYREF
  unsigned int i; // [sp+10A0h] [bp-Ch]
  fd_set *p_readfds; // [sp+10A4h] [bp-8h]

  if ( a1 == -1 )
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "socket invalid!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/socket.c",
      161,
      "socket_full",
      11,
      53,
      20,
      v6);
    return 0;
  }
  else
  {
    p_readfds = &readfds;
    for ( i = 0; i <= 0x1F; ++i )
      p_readfds->__fds_bits[i] = 0;
    LOBYTE(v3) = a1 & 0x1F;
    if ( a1 <= 0 )
      v3 = -(-a1 & 0x1F);
    readfds.__fds_bits[a1 / 32] |= 1 << v3;
    timeout.tv_sec = a2;
    timeout.tv_usec = 0;
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "socket_full before select");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/socket.c",
      161,
      "socket_full",
      11,
      61,
      20,
      v6);
    if ( select(a1 + 1, &readfds, 0, 0, &timeout) <= 0 )
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "socket_full select false");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/socket.c",
        161,
        "socket_full",
        11,
        66,
        20,
        v6);
      return 0;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, "socket_full select true");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/socket.c",
        161,
        "socket_full",
        11,
        63,
        20,
        v6);
      return 1;
    }
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C8964) --------------------------------------------------------
int __fastcall keep_sockalive(int a1)
{
  int v3; // [sp+10h] [bp-14h] BYREF
  int v4; // [sp+14h] [bp-10h] BYREF
  int optval; // [sp+18h] [bp-Ch] BYREF
  char v6; // [sp+1Fh] [bp-5h]

  optval = 1;
  v4 = 45;
  v3 = 30;
  v6 = 0;
  setsockopt(a1, 1, 9, &optval, 4u);
  if ( v6 != 1 )
    fcntl(a1, 2, 1);
  setsockopt(a1, 6, 1, &optval, 4u);
  setsockopt(a1, 6, 6, &optval, 4u);
  setsockopt(a1, 6, 4, &v4, 4u);
  return setsockopt(a1, 6, 5, &v3, 4u);
}

//----- (000C8A64) --------------------------------------------------------
void *new_task_timer()
{
  return calloc(1u, 0x180Cu);
}

//----- (000C8A94) --------------------------------------------------------
int __fastcall add_new_task(int a1, int a2, int a3)
{
  int result; // r0
  int v5; // [sp+14h] [bp-8h]

  v5 = *(_DWORD *)(a1 + 6144);
  *(_DWORD *)(a1 + 4 * v5) = a2;
  *(_DWORD *)(a1 + 4 * (v5 + 256)) = a3;
  result = clock_gettime(1, (struct timespec *)(a1 + 16 * (v5 + 128)));
  ++*(_DWORD *)(a1 + 6144);
  return result;
}

//----- (000C8B30) --------------------------------------------------------
int __fastcall task_timer_thread(int a1)
{
  int v1; // r0
  int v2; // r6
  char v5[64]; // [sp+1Ch] [bp-1040h] BYREF
  struct timespec *v6; // [sp+101Ch] [bp-40h]
  struct timespec *tp; // [sp+1020h] [bp-3Ch]
  struct timespec *v8; // [sp+1024h] [bp-38h]
  int v9; // [sp+1028h] [bp-34h]
  int v10; // [sp+102Ch] [bp-30h]
  int v11; // [sp+1030h] [bp-2Ch]
  int v12; // [sp+1034h] [bp-28h]
  char *s; // [sp+1038h] [bp-24h]
  int j; // [sp+103Ch] [bp-20h]
  int i; // [sp+1040h] [bp-1Ch]
  int v16; // [sp+1044h] [bp-18h]

  s = (char *)calloc(1u, 0x40u);
  snprintf(s, 0x40u, "%.10s_%d", "task_timer_thread", 0);
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v5, 0x1000u, 0, "%s on pid %ld", s, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-or"
    "igin_godminer-branch1/common/general/task_timer.c",
    165,
    "task_timer_thread",
    17,
    44,
    40,
    v5);
  prctl(15, s);
  v12 = a1;
  v11 = 0;
  v16 = 0;
  v10 = 0;
  while ( 1 )
  {
    v9 = *(_DWORD *)(v12 + 6144);
    for ( i = 0; i < v9; ++i )
    {
      v8 = (struct timespec *)(v12 + 16 * (i + 128));
      clock_gettime(1, v8 + 1);
      v11 = (v8[1].tv_nsec - v8->tv_nsec) / 1000000
          + vshld_n_s64(
              4 * (vshld_n_s64(v8[1].tv_sec - v8->tv_sec, 5u) - (v8[1].tv_sec - v8->tv_sec)) + v8[1].tv_sec - v8->tv_sec,
              3u);
      if ( v11 >= *(_DWORD *)(v12 + 4 * (i + 256)) )
      {
        tp = (struct timespec *)(v12 + 16 * (i + 128));
        clock_gettime(1, tp);
        (*(void (__fastcall **)(int))(v12 + 4 * i))(v11);
      }
    }
    v16 = 0x7FFFFFFF;
    for ( j = 0; j < v9; ++j )
    {
      v2 = *(_DWORD *)(v12 + 4 * (j + 256));
      v6 = (struct timespec *)(v12 + 16 * (j + 128));
      clock_gettime(1, v6 + 1);
      v10 = v2
          - ((v6[1].tv_nsec - v6->tv_nsec) / 1000000
           + vshld_n_s64(
               4 * (vshld_n_s64(v6[1].tv_sec - v6->tv_sec, 5u) - (v6[1].tv_sec - v6->tv_sec))
             + v6[1].tv_sec
             - v6->tv_sec,
               3u));
      if ( v10 < v16 )
        v16 = v10;
    }
    v16 &= ~(v16 >> 31);
    if ( *(_BYTE *)(v12 + 6148) != 1 )
      break;
    usleep(1000 * v16);
  }
  return *(_BYTE *)(v12 + 6148) ^ 1;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C8F08) --------------------------------------------------------
int __fastcall _exec_all_task(int result)
{
  int v1; // [sp+4h] [bp-28h]
  struct timespec *v2; // [sp+Ch] [bp-20h]
  int v3; // [sp+14h] [bp-18h]
  int v4; // [sp+18h] [bp-14h]
  int i; // [sp+1Ch] [bp-10h]

  v1 = result;
  v4 = *(_DWORD *)(result + 6144);
  for ( i = 0; i < v4; ++i )
  {
    v2 = (struct timespec *)(v1 + 16 * (i + 128));
    clock_gettime(1, v2 + 1);
    v3 = (v2[1].tv_nsec - v2->tv_nsec) / 1000000
       + vshld_n_s64(
           4 * (vshld_n_s64(v2[1].tv_sec - v2->tv_sec, 5u) - (v2[1].tv_sec - v2->tv_sec)) + v2[1].tv_sec - v2->tv_sec,
           3u);
    clock_gettime(1, v2);
    result = (*(int (__fastcall **)(int))(v1 + 4 * i))(v3);
  }
  return result;
}

//----- (000C9058) --------------------------------------------------------
int __fastcall start_task_timer(int a1)
{
  int v3; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  *(_BYTE *)(a1 + 6148) = 1;
  v3 = *(_DWORD *)(a1 + 6144);
  for ( i = 0; i < v3; ++i )
    clock_gettime(1, (struct timespec *)(a1 + 16 * (i + 128)));
  return pthread_create((pthread_t *)(a1 + 6152), 0, (void *(*)(void *))task_timer_thread, (void *)a1);
}

//----- (000C9104) --------------------------------------------------------
int __fastcall stop_task_timer(int result)
{
  void *thread_return; // [sp+Ch] [bp-8h] BYREF

  if ( *(_BYTE *)(result + 6148) )
  {
    *(_BYTE *)(result + 6148) = 0;
    return pthread_join(*(_DWORD *)(result + 6152), &thread_return);
  }
  return result;
}

//----- (000C9160) --------------------------------------------------------
void __fastcall destroy_task_timer(_BYTE *a1)
{
  if ( a1[6148] )
    stop_task_timer((int)a1);
  free(a1);
}

//----- (000C91A0) --------------------------------------------------------
int __fastcall force_exec_all_task(int a1)
{
  if ( !*(_BYTE *)(a1 + 6148) )
    return _exec_all_task(a1);
  stop_task_timer(a1);
  _exec_all_task(a1);
  return start_task_timer(a1);
}

//----- (000C91F4) --------------------------------------------------------
int __fastcall _init_pipe_of_queue(int *a1, int a2, int a3)
{
  int result; // r0

  *a1 = (int)pipe_new(a2, a3);
  a1[2] = pipe_consumer_new(*a1);
  result = pipe_producer_new(*a1);
  a1[1] = result;
  return result;
}

//----- (000C926C) --------------------------------------------------------
void __fastcall _deinit_pipe_of_queue(int *a1)
{
  pipe_free(*a1);
  pipe_consumer_free(a1[2]);
  pipe_producer_free(a1[1]);
}

//----- (000C92B8) --------------------------------------------------------
char *__fastcall queue_new(int a1, int a2)
{
  char *v6; // [sp+Ch] [bp-8h]

  v6 = (char *)calloc(1u, 0x60u);
  if ( v6 )
  {
    _init_pipe_of_queue((int *)v6, a1, a2);
    pthread_mutex_init((pthread_mutex_t *)(v6 + 16), 0);
    pthread_condattr_init((pthread_condattr_t *)v6 + 22);
    pthread_condattr_setclock((pthread_condattr_t *)v6 + 22, 1);
    pthread_cond_init((pthread_cond_t *)(v6 + 40), (const pthread_condattr_t *)v6 + 22);
    *((_DWORD *)v6 + 3) = 0;
    v6[92] = 0;
    return v6;
  }
  else
  {
    printf("calloc failed in queue_new");
    return 0;
  }
}

//----- (000C938C) --------------------------------------------------------
void __fastcall queue_free(int a1)
{
  pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  _deinit_pipe_of_queue((int *)a1);
  free((void *)a1);
}

//----- (000C93D8) --------------------------------------------------------
int __fastcall queue_enqueue(int a1, char *a2, int a3)
{
  unsigned __int8 v7; // [sp+17h] [bp-5h] BYREF

  v7 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pipe_push(*(_DWORD **)(a1 + 4), a2, a3, &v7);
  *(_DWORD *)(a1 + 12) += a3;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return v7;
}

//----- (000C9470) --------------------------------------------------------
int __fastcall clean_up(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1);
}

//----- (000C949C) --------------------------------------------------------
void __fastcall queue_dequeue(int a1, char *a2, unsigned int a3)
{
  struct __jmp_buf_tag v6; // [sp+20h] [bp-112Ch] BYREF
  char v7[16]; // [sp+13Ch] [bp-1010h] BYREF
  pthread_mutex_t *v9; // [sp+1140h] [bp-Ch]
  void (__fastcall *v10)(pthread_mutex_t *); // [sp+1144h] [bp-8h]

  v10 = (void (__fastcall *)(pthread_mutex_t *))clean_up;
  v9 = (pthread_mutex_t *)(a1 + 16);
  if ( _sigsetjmp(&v6, 0) )
  {
    v10(v9);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&v6);
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&v6);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  while ( a3 > *(_DWORD *)(a1 + 12) )
  {
    if ( *(_BYTE *)(a1 + 92) )
    {
      *(_BYTE *)(a1 + 92) = 0;
      goto LABEL_11;
    }
    pthread_cond_wait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 16));
  }
  if ( a3 != pipe_pop(*(_DWORD **)(a1 + 8), a2, a3) )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "%s, unkown error", "queue_dequeue");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/thread_safe_queue.c",
      172,
      "queue_dequeue",
      13,
      89,
      100,
      v7);
    exit(-1);
  }
  *(_DWORD *)(a1 + 12) -= a3;
LABEL_11:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  _pthread_unregister_cancel((__pthread_unwind_buf_t *)&v6);
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C9730) --------------------------------------------------------
int __fastcall queue_dequeue_for(int a1, char *a2, unsigned int a3, _DWORD *a4)
{
  char v9[20]; // [sp+20h] [bp-1014h] BYREF
  struct timespec tp; // [sp+1020h] [bp-14h] BYREF
  int v11; // [sp+1028h] [bp-Ch]
  int v12; // [sp+102Ch] [bp-8h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  clock_gettime(1, &tp);
  v11 = a4[1] + tp.tv_nsec;
  tp.tv_sec += v11 / 1000000000 + *a4;
  tp.tv_nsec = v11 % 1000000000;
  v12 = 0;
  while ( a3 > *(_DWORD *)(a1 + 12) )
  {
    v12 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 16), &tp);
    if ( v12 == 110 )
      goto LABEL_7;
  }
  if ( a3 != pipe_pop(*(_DWORD **)(a1 + 8), a2, a3) )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "%s, unkown error", "queue_dequeue_for");
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/thread_safe_queue.c",
      172,
      "queue_dequeue_for",
      17,
      114,
      100,
      v9);
    exit(-1);
  }
  *(_DWORD *)(a1 + 12) -= a3;
LABEL_7:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return v12;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C99C8) --------------------------------------------------------
int __fastcall queue_clear(int a1)
{
  size_t v1; // r0
  char v4[8]; // [sp+1Ch] [bp-1008h] BYREF
  void *ptr; // [sp+101Ch] [bp-8h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v1 = pipe_elem_size(*(_DWORD *)a1);
  ptr = calloc(1u, v1);
  while ( *(int *)(a1 + 12) > 0 )
  {
    if ( pipe_pop(*(_DWORD **)(a1 + 8), (char *)ptr, 1) != 1 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s, unkown error", "queue_clear");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/thread_safe_queue.c",
        172,
        "queue_clear",
        11,
        129,
        100,
        v4);
      exit(-1);
    }
    --*(_DWORD *)(a1 + 12);
  }
  free(ptr);
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C9B4C) --------------------------------------------------------
int __fastcall queue_try_dequeue(int a1, char *a2, unsigned int a3)
{
  char v7[8]; // [sp+24h] [bp-1008h] BYREF
  unsigned __int8 v8; // [sp+1027h] [bp-5h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v8 = 0;
  if ( a3 <= *(_DWORD *)(a1 + 12) )
  {
    if ( a3 != pipe_pop(*(_DWORD **)(a1 + 8), a2, a3) )
    {
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, "%s, unkown error", "queue_try_dequeue");
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/thread_safe_queue.c",
        172,
        "queue_try_dequeue",
        17,
        148,
        100,
        v7);
      exit(-1);
    }
    *(_DWORD *)(a1 + 12) -= a3;
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return v8;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000C9D0C) --------------------------------------------------------
int __fastcall queue_element_num(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (000C9D34) --------------------------------------------------------
int __fastcall queue_force_wakeup(int a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  *(_BYTE *)(a1 + 92) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
}

//----- (000C9D8C) --------------------------------------------------------
unsigned int *__fastcall xxtea_encode(unsigned int *a1, unsigned int a2, int a3)
{
  unsigned int *result; // r0
  unsigned int *v4; // r3
  unsigned int *v5; // r3
  char v7[28]; // [sp+20h] [bp-101Ch] BYREF
  unsigned int v8; // [sp+1020h] [bp-1Ch]
  int v9; // [sp+1024h] [bp-18h]
  unsigned int v10; // [sp+1028h] [bp-14h]
  unsigned int v11; // [sp+102Ch] [bp-10h]
  unsigned int i; // [sp+1030h] [bp-Ch]
  unsigned int v13; // [sp+1034h] [bp-8h]

  if ( a2 > 1 )
  {
    v13 = 0x34 / a2 + 6;
    v11 = 0;
    v10 = a1[a2 - 1];
    do
    {
      v11 -= 1640531527;
      v9 = (v11 >> 2) & 3;
      for ( i = 0; i < a2 - 1; ++i )
      {
        v8 = a1[i + 1];
        v4 = &a1[i];
        *v4 += (((v10 >> 5) ^ (4 * v8)) + ((16 * v10) ^ (v8 >> 3)))
             ^ ((v11 ^ v8) + (v10 ^ *(_DWORD *)(a3 + 4 * (v9 ^ i & 3))));
        v10 = *v4;
      }
      v8 = *a1;
      result = a1;
      v5 = &a1[a2 - 1];
      *v5 += (((v10 >> 5) ^ (4 * v8)) + ((16 * v10) ^ (v8 >> 3)))
           ^ ((v11 ^ v8) + (v10 ^ *(_DWORD *)(a3 + 4 * (v9 ^ i & 3))));
      v10 = *v5;
      --v13;
    }
    while ( v13 );
  }
  else
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, " xxtea encode input data length <= 1");
    V_UNLOCK();
    return (unsigned int *)zlog(
                             g_zc,
                             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/"
                             "release/build/godminer-origin_godminer-branch1/common/general/xxtea.c",
                             160,
                             "xxtea_encode",
                             12,
                             24,
                             100,
                             v7);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000CA0D0) --------------------------------------------------------
int __fastcall xxtea_decode(unsigned int *a1, unsigned int a2, int a3)
{
  int result; // r0
  unsigned int *v4; // r3
  char v6[28]; // [sp+20h] [bp-101Ch] BYREF
  unsigned int v7; // [sp+1020h] [bp-1Ch]
  int v8; // [sp+1024h] [bp-18h]
  unsigned int v9; // [sp+1028h] [bp-14h]
  unsigned int v10; // [sp+102Ch] [bp-10h]
  unsigned int i; // [sp+1030h] [bp-Ch]
  unsigned int v12; // [sp+1034h] [bp-8h]

  if ( a2 > 1 )
  {
    v12 = 0x34 / a2 + 6;
    v10 = -1640531527 * v12;
    v9 = *a1;
    do
    {
      v8 = (v10 >> 2) & 3;
      for ( i = a2 - 1; i; --i )
      {
        v7 = a1[i - 1];
        v4 = &a1[i];
        *v4 -= (((v7 >> 5) ^ (4 * v9)) + ((16 * v7) ^ (v9 >> 3)))
             ^ ((v10 ^ v9) + (v7 ^ *(_DWORD *)(a3 + 4 * (v8 ^ i & 3))));
        v9 = *v4;
      }
      v7 = a1[a2 - 1];
      result = v10 ^ v9;
      *a1 -= ((v10 ^ v9) + (v7 ^ *(_DWORD *)(a3 + 4 * v8))) ^ (((v7 >> 5) ^ (4 * v9)) + ((16 * v7) ^ (v9 >> 3)));
      v9 = *a1;
      v10 += 1640531527;
      --v12;
    }
    while ( v12 );
  }
  else
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, " xxtea decode input data length <= 1");
    V_UNLOCK();
    return zlog(
             g_zc,
             "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/go"
             "dminer-origin_godminer-branch1/common/general/xxtea.c",
             160,
             "xxtea_decode",
             12,
             53,
             100,
             v6);
  }
  return result;
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000CA3FC) --------------------------------------------------------
int __fastcall data_enc(unsigned int *a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  char v7; // [sp+18h] [bp-100Ch]
  char v8[4]; // [sp+20h] [bp-1004h] BYREF

  v7 = a2;
  if ( a3 == 1 )
  {
    if ( (a2 & 7) != 0 )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, " xxtea input data length %% 8 must be 0, but now is %d", v7 & 7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/xxtea.c",
        160,
        "data_enc",
        8,
        93,
        100,
        v8);
      return 0;
    }
    else
    {
      xxtea_encode(a1, a2 >> 2, (int)&xxtea_key + 16 * a4);
      return 1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "algorithm_type is %d, but not support it", a3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/xxtea.c",
      160,
      "data_enc",
      8,
      100,
      100,
      v8);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000CA5C8) --------------------------------------------------------
int __fastcall data_dec(unsigned int *a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  char v7; // [sp+18h] [bp-100Ch]
  char v8[4]; // [sp+20h] [bp-1004h] BYREF

  v7 = a2;
  if ( a3 == 1 )
  {
    if ( (a2 & 7) != 0 )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, " xxtea input data length %% 8 must be 0, but now is %d", v7 & 7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godmine"
        "r-origin_godminer-branch1/common/general/xxtea.c",
        160,
        "data_dec",
        8,
        112,
        100,
        v8);
      return 0;
    }
    else
    {
      xxtea_decode(a1, a2 >> 2, (int)&xxtea_key + 16 * a4);
      return 1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "algorithm_type is %d, but not support it", a3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/workspace/jenkins/jenkins/workspace/Antminer_L9_CVCtrl_release/build/rootfs/buildroot/tmp/release/build/godminer-"
      "origin_godminer-branch1/common/general/xxtea.c",
      160,
      "data_dec",
      8,
      119,
      100,
      v8);
    return 0;
  }
}
// 1D474: using guessed type __int64 zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1608F0: using guessed type int g_zc;

//----- (000CA794) --------------------------------------------------------
int __fastcall sub_CA794(int a1)
{
  return *(_DWORD *)a1;
}

//----- (000CA7BC) --------------------------------------------------------
int __fastcall pipe_elem_size(int a1)
{
  return sub_CA794(a1);
}

//----- (000CA7E4) --------------------------------------------------------
_DWORD *__fastcall sub_CA7E4(_DWORD *a1, _DWORD *a2)
{
  int v2; // r7
  int v3; // r6
  int v4; // r5
  int v5; // r4
  int v6; // r0

  v2 = a2[3];
  v3 = a2[4];
  v4 = a2[5];
  v5 = a2[6];
  v6 = sub_CA794((int)a2);
  *a1 = v2;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  a1[4] = v6;
  return a1;
}

//----- (000CA858) --------------------------------------------------------
int __fastcall sub_CA858(int a1, int a2, int a3, int a4, int a5)
{
  return a2 - a1 - a5;
}

//----- (000CA89C) --------------------------------------------------------
bool __fastcall sub_CA89C(int a1, int a2, unsigned int a3, unsigned int a4)
{
  return a3 >= a4;
}

//----- (000CA8EC) --------------------------------------------------------
int __fastcall sub_CA8EC(int a1, int a2, unsigned int a3, unsigned int a4, int a5)
{
  int v5; // r2

  if ( sub_CA89C(a1, a2, a3, a4) )
    v5 = a4 - a1 + a2 - a3;
  else
    v5 = a4 - a3;
  return v5 - a5;
}

//----- (000CA980) --------------------------------------------------------
unsigned int __fastcall sub_CA980(int a1, unsigned int a2, unsigned int a3)
{
  if ( a2 < a3 )
    return a2;
  else
    return a1 + a2 - a3;
}

//----- (000CA9DC) --------------------------------------------------------
unsigned int __fastcall sub_CA9DC(unsigned int a1, unsigned int a2, int a3)
{
  if ( a2 >= a1 )
    return a2;
  else
    return a3 + a2 - a1;
}

//----- (000CAA3C) --------------------------------------------------------
char *__fastcall sub_CAA3C(char *a1, const void *a2, size_t a3)
{
  memcpy(a1, a2, a3);
  return &a1[a3];
}

//----- (000CAA7C) --------------------------------------------------------
unsigned int __fastcall sub_CAA7C(unsigned int a1)
{
  unsigned int v3; // [sp+4h] [bp-10h]
  unsigned int i; // [sp+Ch] [bp-8h]

  if ( a1 >= 0x80000000 )
    return a1;
  v3 = a1 - 1;
  for ( i = 1; i <= 0x1F; i *= 2 )
    v3 |= v3 >> i;
  return v3 + 1;
}

//----- (000CAB24) --------------------------------------------------------
_DWORD *__fastcall sub_CAB24(_DWORD *result)
{
  _DWORD v1[5]; // [sp+Ch] [bp-18h] BYREF

  if ( result )
  {
    if ( result[3] )
      return sub_CA7E4(v1, result);
  }
  return result;
}

//----- (000CAB78) --------------------------------------------------------
_DWORD *__fastcall sub_CAB78(int a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  return sub_CAB24((_DWORD *)a1);
}

//----- (000CABBC) --------------------------------------------------------
int __fastcall sub_CABBC(int a1)
{
  sub_CAB24((_DWORD *)a1);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
}

//----- (000CAC00) --------------------------------------------------------
_DWORD *__fastcall pipe_new(int a1, int a2)
{
  unsigned int v3; // r3
  unsigned int v4; // r6
  char *v8; // [sp+Ch] [bp-20h]
  size_t size; // [sp+10h] [bp-1Ch]
  _DWORD *ptr; // [sp+14h] [bp-18h]

  if ( !a1 )
    return 0;
  ptr = malloc(0xB8u);
  size = 32 * a1;
  v8 = (char *)malloc(32 * a1);
  if ( ptr && v8 )
  {
    if ( a2 )
    {
      v3 = 32 * a1;
      if ( (a2 + 1) * a1 >= size )
        v3 = (a2 + 1) * a1;
      v4 = sub_CAA7C(v3);
    }
    else
    {
      v4 = -1;
    }
    memset(ptr, 0, 0xB8u);
    *ptr = a1;
    ptr[1] = size;
    ptr[2] = v4;
    ptr[3] = v8;
    ptr[4] = &v8[size];
    ptr[5] = v8;
    ptr[6] = &v8[a1];
    ptr[7] = 1;
    ptr[8] = 1;
    pthread_mutex_init((pthread_mutex_t *)(ptr + 9), 0);
    pthread_mutex_init((pthread_mutex_t *)(ptr + 15), 0);
    pthread_cond_init((pthread_cond_t *)(ptr + 22), 0);
    pthread_cond_init((pthread_cond_t *)(ptr + 34), 0);
    sub_CAB24(ptr);
    return ptr;
  }
  else
  {
    free(ptr);
    free(v8);
    return 0;
  }
}

//----- (000CADE4) --------------------------------------------------------
int __fastcall pipe_producer_new(int a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  ++*(_DWORD *)(a1 + 28);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
  return a1;
}

//----- (000CAE38) --------------------------------------------------------
int __fastcall pipe_consumer_new(int a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  ++*(_DWORD *)(a1 + 32);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
  return a1;
}

//----- (000CAE8C) --------------------------------------------------------
void __fastcall sub_CAE8C(int a1)
{
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 36));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 60));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 88));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 136));
  free(*(void **)(a1 + 12));
  free((void *)a1);
}

//----- (000CAF00) --------------------------------------------------------
void __fastcall pipe_free(int a1)
{
  int v2; // [sp+8h] [bp-Ch]
  int v3; // [sp+Ch] [bp-8h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  v3 = --*(_DWORD *)(a1 + 28);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  v2 = --*(_DWORD *)(a1 + 32);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
  if ( v2 )
  {
    if ( !v3 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 88));
  }
  else
  {
    free(*(void **)(a1 + 12));
    *(_DWORD *)(a1 + 12) = 0;
    if ( v3 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 136));
    else
      sub_CAE8C(a1);
  }
}

//----- (000CB03C) --------------------------------------------------------
void __fastcall pipe_producer_free(int a1)
{
  int v1; // [sp+Ch] [bp-10h]
  int v2; // [sp+10h] [bp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  v2 = --*(_DWORD *)(a1 + 28);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
  if ( !v2 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
    v1 = *(_DWORD *)(a1 + 32);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
    if ( v1 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 88));
    else
      sub_CAE8C(a1);
  }
}

//----- (000CB120) --------------------------------------------------------
void __fastcall pipe_consumer_free(int a1)
{
  int v1; // [sp+Ch] [bp-10h]
  int v2; // [sp+10h] [bp-Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  v2 = --*(_DWORD *)(a1 + 32);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
  if ( !v2 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
    v1 = *(_DWORD *)(a1 + 28);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
    if ( v1 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 136));
    else
      sub_CAE8C(a1);
  }
}

//----- (000CB204) --------------------------------------------------------
char *__fastcall sub_CB204(const void *a1, int a2, const void *a3, unsigned int a4, int a5, char *a6)
{
  char *v6; // r0

  if ( !sub_CA89C((int)a1, a2, (unsigned int)a3, a4) )
    return sub_CAA3C(a6, a3, a4 - (_DWORD)a3);
  v6 = sub_CAA3C(a6, a3, a2 - (_DWORD)a3);
  return sub_CAA3C(v6, a1, a4 - (_DWORD)a1);
}

//----- (000CB2C4) --------------------------------------------------------
_DWORD *__fastcall sub_CB2C4(_DWORD *a1, int a2, unsigned int a3, _BYTE *a4)
{
  const void *v9[5]; // [sp+1Ch] [bp-28h] BYREF
  char *v10; // [sp+30h] [bp-14h]
  int v11; // [sp+34h] [bp-10h]
  unsigned int v12; // [sp+38h] [bp-Ch]
  unsigned int v13; // [sp+3Ch] [bp-8h]

  sub_CAB24((_DWORD *)a2);
  v13 = *(_DWORD *)(a2 + 8);
  v12 = *(_DWORD *)(a2 + 4);
  v11 = sub_CA794(a2);
  if ( a3 >= v13 )
    a3 = v13;
  if ( a3 > v12 )
  {
    if ( a3 + v11 <= 0x100000 && (v10 = (char *)malloc(a3 + v11)) != 0 )
    {
      sub_CA7E4(v9, (_DWORD *)a2);
      *(_DWORD *)(a2 + 24) = sub_CB204(v9[0], (int)v9[1], v9[2], (unsigned int)v9[3], (int)v9[4], v10);
      free(*(void **)(a2 + 12));
      *(_DWORD *)(a2 + 12) = v10;
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 16) = &v10[a3 + v11];
      sub_CAB24((_DWORD *)a2);
      sub_CA7E4(a1, (_DWORD *)a2);
    }
    else
    {
      *a4 = 0;
      sub_CA7E4(a1, (_DWORD *)a2);
    }
  }
  else
  {
    sub_CA7E4(a1, (_DWORD *)a2);
  }
  return a1;
}

//----- (000CB478) --------------------------------------------------------
_DWORD *sub_CB478(_DWORD *a1, _DWORD *a2, ...)
{
  unsigned int v2; // r0
  _DWORD *v3; // lr
  int v4; // r1
  _DWORD v6[6]; // [sp+8h] [bp-34h] BYREF
  _DWORD *v7; // [sp+20h] [bp-1Ch]
  _DWORD *v8; // [sp+24h] [bp-18h]
  int v9; // [sp+28h] [bp-14h]
  unsigned int v10; // [sp+2Ch] [bp-10h]
  unsigned int v11; // [sp+30h] [bp-Ch]
  unsigned int v12; // [sp+34h] [bp-8h]
  int varg_r2; // [sp+40h] [bp+4h] BYREF
  va_list varg_r2a; // [sp+40h] [bp+4h]
  int varg_r3; // [sp+44h] [bp+8h]
  unsigned int v16; // [sp+48h] [bp+Ch]
  unsigned int v17; // [sp+4Ch] [bp+10h]
  int v18; // [sp+50h] [bp+14h]
  int v19; // [sp+54h] [bp+18h]
  _BYTE *v20; // [sp+58h] [bp+1Ch]
  va_list va1; // [sp+5Ch] [bp+20h] BYREF

  va_start(va1, a2);
  va_start(varg_r2a, a2);
  varg_r2 = va_arg(va1, _DWORD);
  varg_r3 = va_arg(va1, _DWORD);
  v16 = va_arg(va1, _DWORD);
  v17 = va_arg(va1, _DWORD);
  v18 = va_arg(va1, _DWORD);
  v19 = va_arg(va1, _DWORD);
  v20 = va_arg(va1, _BYTE *);
  v8 = a1;
  v7 = a2;
  v12 = sub_CA794((int)a2);
  v11 = sub_CA858(varg_r2, varg_r3, v16, v17, v18);
  if ( v19 + sub_CA8EC(varg_r2, varg_r3, v16, v17, v18) > v11 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 9));
    sub_CA7E4((int *)varg_r2a, v7);
    v10 = v19 + sub_CA8EC(varg_r2, varg_r3, v16, v17, v18);
    v9 = v10 / v12;
    if ( v10 > v11 )
    {
      v2 = sub_CAA7C(v9 + 1);
      sub_CB2C4(v6, (int)v7, v12 * v2, v20);
      varg_r2 = v6[0];
      varg_r3 = v6[1];
      v16 = v6[2];
      v17 = v6[3];
      v18 = v6[4];
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 9));
  }
  v3 = v8;
  v4 = varg_r3;
  *v8 = varg_r2;
  v3[1] = v4;
  v3[2] = v16;
  v3[3] = v17;
  v3[4] = v18;
  return v8;
}

//----- (000CB5FC) --------------------------------------------------------
unsigned int __fastcall sub_CB5FC(
        int a1,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        int a5,
        char *a6,
        size_t a7)
{
  size_t v7; // r3
  char *v8; // r0
  unsigned int result; // r0
  size_t v10; // [sp+Ch] [bp-8h]
  char *varg_r3; // [sp+24h] [bp+10h]
  unsigned int varg_r3a; // [sp+24h] [bp+10h]

  varg_r3 = (char *)a4;
  if ( !sub_CA89C(a1, a2, a3, a4) )
  {
    v7 = a7;
    if ( a7 >= a2 - (unsigned int)varg_r3 )
      v7 = a2 - (_DWORD)varg_r3;
    v10 = v7;
    varg_r3 = sub_CAA3C(varg_r3, a6, v7);
    a6 += v10;
    a7 -= v10;
  }
  if ( a7 )
  {
    v8 = (char *)sub_CA980(a1, (unsigned int)varg_r3, a2);
    varg_r3 = sub_CAA3C(v8, a6, a7);
  }
  result = sub_CA980(a1, (unsigned int)varg_r3, a2);
  varg_r3a = result;
  return result;
}

//----- (000CB718) --------------------------------------------------------
_DWORD *__fastcall sub_CB718(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // lr
  int v4; // r1
  unsigned int v5; // r2
  unsigned int v6; // r3
  int v8; // [sp+8h] [bp-4Ch] BYREF
  int v9; // [sp+Ch] [bp-48h]
  unsigned int v10; // [sp+10h] [bp-44h]
  unsigned int v11; // [sp+14h] [bp-40h]
  int v12; // [sp+18h] [bp-3Ch]
  _DWORD *v13; // [sp+24h] [bp-30h]
  _DWORD *v14; // [sp+28h] [bp-2Ch]
  _DWORD *v15; // [sp+2Ch] [bp-28h]
  int v16; // [sp+34h] [bp-20h] BYREF
  int v17; // [sp+38h] [bp-1Ch]
  unsigned int v18; // [sp+3Ch] [bp-18h]
  unsigned int v19; // [sp+40h] [bp-14h]
  int v20; // [sp+44h] [bp-10h]
  int v21; // [sp+48h] [bp-Ch]
  int v22; // [sp+4Ch] [bp-8h]

  v15 = a1;
  v14 = a2;
  v13 = a3;
  sub_CA7E4(&v16, a2);
  v22 = sub_CA8EC(v16, v17, v18, v19, v20);
  v21 = v14[8];
  for ( *v13 = v14[2]; v22 == *v13 && v21; *v13 = v14[2] )
  {
    pthread_cond_wait((pthread_cond_t *)(v14 + 34), (pthread_mutex_t *)(v14 + 15));
    sub_CA7E4(&v8, v14);
    v16 = v8;
    v17 = v9;
    v18 = v10;
    v19 = v11;
    v20 = v12;
    v22 = sub_CA8EC(v8, v9, v10, v11, v12);
    v21 = v14[8];
  }
  v3 = v15;
  v4 = v17;
  v5 = v18;
  v6 = v19;
  *v15 = v16;
  v3[1] = v4;
  v3[2] = v5;
  v3[3] = v6;
  v3[4] = v20;
  return v15;
}

//----- (000CB858) --------------------------------------------------------
int __fastcall _pipe_push(_DWORD *a1, char *a2, unsigned int a3, _BYTE *a4)
{
  int result; // r0
  int v5; // r4
  int v6; // r0
  int v7; // r4
  size_t v8; // r3
  unsigned int v9; // r0
  _DWORD v10[6]; // [sp+18h] [bp-5Ch] BYREF
  _BYTE *v11; // [sp+30h] [bp-44h]
  unsigned int v12; // [sp+34h] [bp-40h]
  char *v13; // [sp+38h] [bp-3Ch]
  _DWORD *v14; // [sp+3Ch] [bp-38h]
  int v15; // [sp+44h] [bp-30h] BYREF
  int v16; // [sp+48h] [bp-2Ch]
  unsigned int v17; // [sp+4Ch] [bp-28h]
  unsigned int v18; // [sp+50h] [bp-24h]
  int v19; // [sp+54h] [bp-20h]
  int v20; // [sp+58h] [bp-1Ch] BYREF
  unsigned int v21; // [sp+5Ch] [bp-18h]
  size_t v22; // [sp+60h] [bp-14h]
  int v23; // [sp+64h] [bp-10h]

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = a4;
  result = sub_CA794((int)a1);
  v23 = result;
  if ( v12 )
  {
    v22 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(v14 + 15));
    sub_CB718(&v15, v14, &v20);
    if ( v14[8] )
    {
      sub_CB478(v10, v14, v15, v16, v17, v18, v19, v12, v11);
      v15 = v10[0];
      v16 = v10[1];
      v17 = v10[2];
      v18 = v10[3];
      v19 = v10[4];
      if ( *v11 )
      {
        v5 = v20;
        v6 = sub_CA8EC(v15, v16, v17, v18, v19);
        if ( v12 <= v5 - v6 )
        {
          v8 = v12;
        }
        else
        {
          v7 = v20;
          v8 = v7 - sub_CA8EC(v15, v16, v17, v18, v19);
        }
        v22 = v8;
        v9 = sub_CB5FC(v15, v16, v17, v18, v19, v13, v8);
        v14[6] = v9;
        pthread_mutex_unlock((pthread_mutex_t *)(v14 + 15));
        if ( v22 == v23 )
          result = pthread_cond_signal((pthread_cond_t *)(v14 + 22));
        else
          result = pthread_cond_broadcast((pthread_cond_t *)(v14 + 22));
        v21 = v12 - v22;
        if ( v12 != v22 )
          return _pipe_push(v14, &v13[v22], v21, v11);
      }
      else
      {
        return pthread_mutex_unlock((pthread_mutex_t *)(v14 + 15));
      }
    }
    else
    {
      return pthread_mutex_unlock((pthread_mutex_t *)(v14 + 15));
    }
  }
  return result;
}

//----- (000CBA9C) --------------------------------------------------------
int __fastcall pipe_push(_DWORD *a1, char *a2, int a3, _BYTE *a4)
{
  int v4; // r0

  v4 = sub_CA794((int)a1);
  return _pipe_push(a1, a2, v4 * a3, a4);
}

//----- (000CBAF8) --------------------------------------------------------
_DWORD *__fastcall sub_CBAF8(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // lr
  int v3; // r1
  unsigned int v4; // r2
  unsigned int v5; // r3
  int v7; // [sp+8h] [bp-3Ch] BYREF
  int v8; // [sp+Ch] [bp-38h]
  unsigned int v9; // [sp+10h] [bp-34h]
  unsigned int v10; // [sp+14h] [bp-30h]
  int v11; // [sp+18h] [bp-2Ch]
  _DWORD *v12; // [sp+20h] [bp-24h]
  _DWORD *v13; // [sp+24h] [bp-20h]
  int v14; // [sp+28h] [bp-1Ch] BYREF
  int v15; // [sp+2Ch] [bp-18h]
  unsigned int v16; // [sp+30h] [bp-14h]
  unsigned int v17; // [sp+34h] [bp-10h]
  int v18; // [sp+38h] [bp-Ch]
  int i; // [sp+3Ch] [bp-8h]

  v13 = a1;
  v12 = a2;
  sub_CA7E4(&v14, a2);
  for ( i = sub_CA8EC(v14, v15, v16, v17, v18); !i && v12[7]; i = sub_CA8EC(v7, v8, v9, v10, v11) )
  {
    pthread_cond_wait((pthread_cond_t *)(v12 + 22), (pthread_mutex_t *)(v12 + 9));
    sub_CA7E4(&v7, v12);
    v14 = v7;
    v15 = v8;
    v16 = v9;
    v17 = v10;
    v18 = v11;
  }
  v2 = v13;
  v3 = v15;
  v4 = v16;
  v5 = v17;
  *v13 = v14;
  v2[1] = v3;
  v2[2] = v4;
  v2[3] = v5;
  v2[4] = v18;
  return v13;
}

//----- (000CBBF8) --------------------------------------------------------
unsigned int *__fastcall sub_CBBF8(
        unsigned int *a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        unsigned int a5,
        int a6,
        char *dest,
        size_t n,
        unsigned int *a9)
{
  size_t v9; // r3
  unsigned int v10; // r0
  size_t v13; // [sp+8h] [bp-Ch]
  unsigned int varg_r3a; // [sp+24h] [bp+10h]
  const void *varg_r3b; // [sp+24h] [bp+10h]
  char *desta; // [sp+30h] [bp+1Ch]
  size_t na; // [sp+34h] [bp+20h]

  v9 = a3 - a4 - a6;
  if ( n < v9 )
    v9 = n;
  v13 = v9;
  desta = sub_CAA3C(dest, (const void *)(a4 + a6), v9);
  na = n - v13;
  varg_r3a = sub_CA980(a2, a4 + v13, a3);
  if ( na )
  {
    varg_r3b = (const void *)sub_CA980(a2, varg_r3a + a6, a3);
    memcpy(desta, varg_r3b, na);
    v10 = sub_CA980(a2, (unsigned int)varg_r3b + na, a3);
    varg_r3a = sub_CA9DC(a2, v10 - a6, a3);
  }
  *a9 = varg_r3a;
  *a1 = a2;
  a1[1] = a3;
  a1[2] = varg_r3a;
  a1[3] = a5;
  a1[4] = a6;
  return a1;
}

//----- (000CBD9C) --------------------------------------------------------
int sub_CBD9C(_DWORD *a1, ...)
{
  _DWORD v2[7]; // [sp+8h] [bp-2Ch] BYREF
  _DWORD *v3; // [sp+24h] [bp-10h]
  char v4; // [sp+2Bh] [bp-9h] BYREF
  unsigned int v5; // [sp+2Ch] [bp-8h]
  int varg_r1; // [sp+3Ch] [bp+8h] BYREF
  va_list varg_r1a; // [sp+3Ch] [bp+8h]
  int varg_r2; // [sp+40h] [bp+Ch]
  unsigned int varg_r3; // [sp+44h] [bp+10h]
  unsigned int v10; // [sp+48h] [bp+14h]
  int v11; // [sp+4Ch] [bp+18h]
  va_list va1; // [sp+50h] [bp+1Ch] BYREF

  va_start(va1, a1);
  va_start(varg_r1a, a1);
  varg_r1 = va_arg(va1, _DWORD);
  varg_r2 = va_arg(va1, _DWORD);
  varg_r3 = va_arg(va1, _DWORD);
  v10 = va_arg(va1, _DWORD);
  v11 = va_arg(va1, _DWORD);
  v3 = a1;
  v5 = sub_CA858(varg_r1, varg_r2, varg_r3, v10, v11);
  v4 = 1;
  if ( sub_CA8EC(varg_r1, varg_r2, varg_r3, v10, v11) > v5 >> 2 )
    return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 9));
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 9));
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 15));
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 9));
  sub_CA7E4((int *)varg_r1a, v3);
  v5 = sub_CA858(varg_r1, varg_r2, varg_r3, v10, v11);
  if ( sub_CA8EC(varg_r1, varg_r2, varg_r3, v10, v11) <= v5 >> 2 )
    sub_CB2C4(v2, (int)v3, v5 >> 1, &v4);
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 9));
  return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 15));
}

//----- (000CBEFC) --------------------------------------------------------
size_t __fastcall sub_CBEFC(_DWORD *a1, void *a2, size_t a3)
{
  size_t n; // r3
  int v5; // r0
  unsigned int v7[7]; // [sp+18h] [bp-4Ch] BYREF
  size_t v8; // [sp+34h] [bp-30h]
  void *dest; // [sp+38h] [bp-2Ch]
  _DWORD *v10; // [sp+3Ch] [bp-28h]
  unsigned int v11; // [sp+44h] [bp-20h] BYREF
  unsigned int v12; // [sp+48h] [bp-1Ch]
  unsigned int v13; // [sp+4Ch] [bp-18h]
  unsigned int v14; // [sp+50h] [bp-14h]
  int v15; // [sp+54h] [bp-10h]
  unsigned int v16; // [sp+58h] [bp-Ch]
  size_t v17; // [sp+5Ch] [bp-8h]

  v10 = a1;
  dest = a2;
  v8 = a3;
  if ( !a3 )
    return 0;
  v17 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 9));
  sub_CBAF8(&v11, v10);
  v16 = sub_CA8EC(v11, v12, v13, v14, v15);
  if ( v16 )
  {
    sub_CAB24(v10);
    n = v16;
    if ( v8 < v16 )
      n = v8;
    v17 = n;
    sub_CBBF8(v7, v11, v12, v13, v14, v15, (char *)dest, n, v10 + 5);
    v11 = v7[0];
    v12 = v7[1];
    v13 = v7[2];
    v14 = v7[3];
    v15 = v7[4];
    sub_CAB24(v10);
    sub_CBD9C(v10, v11, v12, v13, v14, v15);
    v5 = sub_CA794((int)v10);
    if ( v17 == v5 )
      pthread_cond_signal((pthread_cond_t *)(v10 + 34));
    else
      pthread_cond_broadcast((pthread_cond_t *)(v10 + 34));
    return v17;
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 9));
    return 0;
  }
}

//----- (000CC0A8) --------------------------------------------------------
int __fastcall pipe_pop(_DWORD *a1, char *a2, int a3)
{
  size_t v7; // [sp+10h] [bp-14h]
  unsigned int v8; // [sp+14h] [bp-10h]
  unsigned int v9; // [sp+18h] [bp-Ch]
  size_t v10; // [sp+1Ch] [bp-8h]

  v8 = sub_CA794((int)a1);
  v10 = v8 * a3;
  v9 = 0;
  do
  {
    v7 = sub_CBEFC(a1, a2, v10);
    a2 += v7;
    v9 += v7;
    v10 -= v7;
  }
  while ( v7 && v10 );
  return v9 / v8;
}

//----- (000CC164) --------------------------------------------------------
size_t __fastcall pipe_pop_eager(_DWORD *a1, void *a2, int a3)
{
  unsigned int v7; // [sp+14h] [bp-8h]

  v7 = sub_CA794((int)a1);
  return sub_CBEFC(a1, a2, v7 * a3) / v7;
}

//----- (000CC1C4) --------------------------------------------------------
int __fastcall pipe_reserve(_DWORD *a1, int a2)
{
  _DWORD v3[6]; // [sp+8h] [bp-44h] BYREF
  unsigned int v4; // [sp+20h] [bp-2Ch]
  _DWORD *v5; // [sp+24h] [bp-28h]
  char v6; // [sp+2Bh] [bp-21h] BYREF
  int v7[6]; // [sp+2Ch] [bp-20h] BYREF
  _DWORD *v8; // [sp+44h] [bp-8h]

  v5 = a1;
  v8 = a1;
  v6 = 1;
  v4 = sub_CA794((int)a1) * a2;
  if ( !v4 )
    v4 = 32;
  v7[5] = v8[2];
  sub_CAB78((int)v8);
  sub_CA7E4(v7, v8);
  if ( v4 > sub_CA8EC(v7[0], v7[1], v7[2], v7[3], v7[4]) )
    sub_CB2C4(v3, (int)v8, v4, &v6);
  return sub_CABBC((int)v8);
}

//----- (000CC4FC) --------------------------------------------------------
int __fastcall sub_CC4FC(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0xCC4F2);
  return a1 / a2;
}
// CC4FE: control flows out of bounds to CC4F2

//----- (000CC518) --------------------------------------------------------
int __fastcall sub_CC518(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0xCCE2C);
  return divsi3_skip_div0_test(a1, a2);
}
// CC7A8: control flows out of bounds to CCE2C

//----- (000CC51E) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_CC560 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// CC522: variable 'v2' is possibly undefined

//----- (000CC7AC) --------------------------------------------------------
int __fastcall sub_CC7AC(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0xCCE2C);
  return divsi3_skip_div0_test(a1, a2);
}
// CC7A8: control flows out of bounds to CCE2C

//----- (000CCAD4) --------------------------------------------------------
int __fastcall sub_CCAD4(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0xCCAFA);
  return a1;
}
// CCAE2: control flows out of bounds to CCAFA

//----- (000CCAE4) --------------------------------------------------------
int __fastcall sub_CCAE4(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (000CCCD0) --------------------------------------------------------
int __fastcall sub_CCCD0(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0xCCCF4);
  return a1;
}
// CCCDC: control flows out of bounds to CCCF4

//----- (000CCDFC) --------------------------------------------------------
int __fastcall sub_CCDFC(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return _udivmoddi4(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (000CCEA0) --------------------------------------------------------
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}
// CCEA0: invalid function type 'UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp)' has been ignored

//----- (000CCFB8) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_14CEF0;
  v8 = &off_14CEF4 - &off_14CEF0;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 14CEF0: using guessed type _UNKNOWN *off_14CEF0;
// 14CEF4: using guessed type _UNKNOWN *off_14CEF4;

//----- (000CCFF8) --------------------------------------------------------
int __fastcall sub_CCFF8(char *filename, struct stat *stat_buf)
{
  return sub_1D020(3, filename, stat_buf);
}

//----- (000CD004) --------------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=1930 queued=1617 decompiled=1617 lumina nreq=0 worse=0 better=0
// ALL OK, 1617 function(s) have been successfully decompiled
