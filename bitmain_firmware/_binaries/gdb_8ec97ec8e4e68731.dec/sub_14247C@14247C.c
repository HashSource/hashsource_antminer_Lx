// write access to const memory has been detected, the output may be wrong!
int __fastcall sub_14247C(int a1, int *a2)
{
  char *v2; // r8
  int v3; // r4
  int v4; // r5
  int v5; // r9
  int v6; // r3
  unsigned __int16 *v7; // r6
  int v8; // r2
  bool v9; // zf
  int v10; // r3
  int result; // r0
  __int64 v12; // r0
  unsigned __int16 *v13; // r6
  int v14; // r3
  bool v15; // zf
  char v16; // r11
  int v17; // r12
  void *v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // r8
  int v22; // r6
  unsigned int v23; // r7
  int v24; // r0
  int v25; // r3
  int v26; // lr
  int v27; // r7
  int v28; // r3
  __int16 *v29; // r3
  void *v30; // r0
  int v31; // r6
  int v32; // r7
  int v33; // r2
  unsigned int v34; // r8
  int v35; // r6
  int v36; // r2
  int v37; // r3
  char v38; // r1
  void *v39; // r0
  void *v40; // r3
  int v41; // r12
  bool v42; // zf
  int v43; // r3
  int v44; // r2
  int v45; // r3
  bool v46; // zf
  __int16 *v47; // r3
  int v48; // r6
  int v49; // r7
  int *v50; // r3
  int v51; // lr
  int v52; // r0
  int v53; // r1
  int v54; // r2
  _DWORD *v55; // r12
  int v56; // r7
  int v57; // r2
  unsigned int v58; // r8
  int v59; // r6
  int v60; // r2
  int v61; // r3
  char v62; // r1
  void *v63; // r0
  void *v64; // r3
  int v65; // r12
  bool v66; // zf
  int v67; // r3
  int v68; // r2
  int v69; // r3
  bool v70; // zf
  __int16 *v71; // r3
  int v72; // r6
  int v73; // r7
  int *v74; // r3
  int v75; // lr
  int v76; // r0
  int v77; // r1
  int v78; // r2
  _DWORD *v79; // r12
  _DWORD *v80; // r6
  const char *v81; // r0
  const char *v82; // r0
  int v83; // r3
  int v84; // r3
  int v85; // r6
  int v86; // r3
  int v87; // r3
  int v88; // r8
  int v89; // r7
  _DWORD *v90; // r7
  int v91; // r3
  unsigned int v92; // r8
  char v93; // r2
  int v94; // r7
  int v95; // r1
  int v96; // r3
  char v97; // r2
  void *v98; // r12
  void *v99; // r3
  int v100; // r0
  bool v101; // zf
  int v102; // r3
  int v103; // r3
  unsigned int v104; // r7
  int v105; // r10
  int v106; // r2
  int v107; // r3
  char v108; // r1
  void *v109; // r0
  void *v110; // r3
  int v111; // r12
  bool v112; // zf
  int v113; // r3
  int v114; // r2
  __int16 *v115; // r3
  int v116; // r3
  int v117; // r10
  int v118; // r1
  int v119; // r3
  char v120; // r2
  void *v121; // r0
  void *v122; // r3
  int v123; // r12
  bool v124; // zf
  int v125; // r3
  int v126; // r2
  __int16 *v127; // r3
  int v128; // r3
  int v129; // r10
  int v130; // r1
  int v131; // r3
  char v132; // r2
  void *v133; // r0
  void *v134; // r3
  int v135; // r12
  bool v136; // zf
  int v137; // r3
  int v138; // r2
  __int16 *v139; // r3
  unsigned int j; // r8
  int v141; // r1
  __int16 *v142; // r2
  int v143; // r2
  int v144; // r3
  int *v145; // r7
  int v146; // r11
  bool v147; // zf
  int v148; // r12
  int v149; // r10
  _DWORD *v150; // r12
  int v151; // r1
  int v152; // r2
  int v153; // r3
  _DWORD *v154; // r12
  int v155; // r2
  char v156; // r3
  char v157; // r3
  int v158; // r3
  int v159; // r1
  unsigned int v160; // r7
  int v161; // r6
  int v162; // r2
  int v163; // r3
  void *v164; // r0
  void *v165; // r7
  int v166; // r12
  int v167; // r3
  int v168; // r2
  int v169; // r7
  int v170; // r3
  __int16 *v171; // r12
  int v172; // r1
  int v173; // r7
  _DWORD *v174; // r6
  int v175; // r1
  _DWORD *v176; // r3
  _DWORD *v177; // r10
  char v178; // r3
  int v179; // r1
  unsigned int v180; // r11
  int v181; // r8
  int v182; // r1
  int v183; // r3
  char v184; // r2
  char *v185; // r0
  char *v186; // r3
  int v187; // r12
  bool v188; // zf
  int v189; // r3
  char *v190; // lr
  int v191; // r0
  int v192; // r1
  int v193; // r2
  int v194; // r3
  int v195; // r0
  int v196; // r10
  int v197; // r0
  int v198; // r2
  int v199; // r2
  int v200; // r3
  int v201; // r3
  char *v202; // r10
  const char **v203; // r8
  int v204; // r4
  int v205; // r7
  int v206; // r7
  const char **v207; // r10
  int v208; // r2
  char *v209; // r0
  int v210; // r0
  int v211; // r2
  int v212; // r0
  int v213; // r0
  int v214; // r0
  int v215; // r0
  unsigned __int16 *v216; // r3
  int v217; // r2
  bool v218; // zf
  char *v219; // r0
  _BOOL4 v220; // r7
  const char *v221; // r10
  size_t v222; // r11
  int v223; // r0
  unsigned int v224; // r3
  bool v225; // cc
  int v226; // r2
  unsigned int *v227; // r0
  int v228; // r12
  _BOOL4 v229; // r3
  int v230; // r3
  int v231; // r3
  bool v232; // cc
  char v233; // r3
  const char *v234; // r0
  int v235; // r5
  int v236; // r11
  int v237; // r7
  int v238; // r10
  int v239; // r3
  __int16 *v240; // r3
  unsigned int v241; // r7
  int v242; // r3
  int v243; // r10
  int v244; // r2
  int v245; // r3
  void *v246; // r0
  void *v247; // r7
  int v248; // r1
  int v249; // r3
  int v250; // r2
  int v251; // r3
  bool v252; // zf
  int v253; // r3
  int v254; // r2
  int v255; // r2
  __int16 *v256; // r3
  const char *v257; // r0
  unsigned int *v258; // r0
  unsigned int v259; // r2
  unsigned int v260; // r3
  int *v261; // r2
  int v262; // r2
  int v263; // r3
  int v264; // r2
  __int16 *v265; // r3
  int v266; // r8
  int v267; // r6
  int i; // r7
  int v269; // r3
  __int16 *v270; // r2
  int v271; // r11
  __int16 *v272; // r3
  char *v273; // r2
  int v274; // r7
  unsigned __int16 v275; // r7
  int v276; // r1
  int v277; // [sp+Ch] [bp-70h]
  int v278; // [sp+Ch] [bp-70h]
  unsigned __int16 v279; // [sp+Ch] [bp-70h]
  int v280; // [sp+10h] [bp-6Ch]
  int v281; // [sp+14h] [bp-68h]
  void *v282; // [sp+18h] [bp-64h]
  char *v283; // [sp+20h] [bp-5Ch]
  int s1; // [sp+24h] [bp-58h]
  char *s1a; // [sp+24h] [bp-58h]
  const char *s1b; // [sp+24h] [bp-58h]
  int v287; // [sp+28h] [bp-54h]
  char *v288; // [sp+2Ch] [bp-50h]
  int v289; // [sp+34h] [bp-48h]
  void *src; // [sp+40h] [bp-3Ch] BYREF
  char *v291; // [sp+44h] [bp-38h]
  char *v292; // [sp+48h] [bp-34h]
  int s[12]; // [sp+4Ch] [bp-30h] BYREF

  v3 = (int)a2;
  v4 = a1;
  v280 = *a2;
  v5 = sub_11D4EC(*(_DWORD *)(a1 + 8), a2[34]);
  if ( !v5 )
    v5 = sub_138200((unsigned __int16 *)v4, (_DWORD *)v3);
  if ( *(_DWORD *)(v4 + 12) )
  {
    v277 = sub_12FF48(v4, v3);
    if ( v277 )
      goto LABEL_5;
    src = 0;
    v291 = 0;
    v292 = 0;
    v282 = sub_9253C((int)nullsub_39, 0);
    memset(s, 0, 0x2Cu);
    v13 = *(unsigned __int16 **)(v4 + 12);
    if ( v13 )
    {
      v14 = *v13;
      if ( *v13 )
      {
        HIDWORD(v12) = &dword_47AC88;
        while ( 1 )
        {
          v15 = v14 == 13;
          if ( v14 != 13 )
            v15 = v14 == 52;
          v16 = v15;
          if ( v15 )
            goto LABEL_239;
          if ( v14 != 46 )
            break;
          v201 = *(_DWORD *)(v3 + 64);
          if ( v201 == 12 )
          {
            ((void (__fastcall *)(unsigned __int16 *, int))loc_141E40)(v13, v3);
          }
          else
          {
            v287 = *(_DWORD *)v3;
            if ( v201 == 14 )
              sub_946E0("unexpected member function in Ada type");
            v202 = sub_12FAF0(v13, (_DWORD *)v3);
            v283 = v202;
            if ( v202 )
            {
              v203 = (const char **)s[5];
              s1 = s[6];
              v288 = (char *)s[5];
              if ( s[6] <= 0 )
              {
LABEL_311:
                if ( (s1 & 3) == 0 )
                {
                  v288 = (char *)sub_93050(v288, 12 * (s1 + 4));
                  s[5] = (int)v288;
                  s1 = s[6];
                  if ( !s[6] )
                  {
                    sub_9253C((int)sub_2589B8, (int)&s[5]);
                    v288 = (char *)s[5];
                    s1 = s[6];
                  }
                }
                v206 = s1;
                *(_DWORD *)&v288[12 * s1] = v283;
                v207 = (const char **)&v288[12 * s1];
                v207[1] = 0;
                v207[2] = 0;
                s[6] = s1 + 1;
              }
              else
              {
                v289 = v3;
                v204 = 0;
                v205 = s[6];
                while ( strcmp(*v203, v202) )
                {
                  ++v204;
                  v203 += 3;
                  if ( v204 == v205 )
                  {
                    v3 = v289;
                    goto LABEL_311;
                  }
                }
                v206 = v204;
                v207 = v203;
                v3 = v289;
                if ( v206 >= s1 )
                  goto LABEL_311;
              }
              v2 = (char *)sub_93028(0x14u);
              sub_9253C((int)&loc_11C838, (int)v2);
              v208 = *(_DWORD *)(v3 + 64);
              *(_DWORD *)v2 = 0;
              *((_DWORD *)v2 + 1) = 0;
              *((_DWORD *)v2 + 2) = 0;
              *((_DWORD *)v2 + 3) = 0;
              *((_DWORD *)v2 + 4) = 0;
              s1a = (char *)v207[1];
              *(_DWORD *)v2 = v207[2];
              v207[1] = s1a + 1;
              v207[2] = v2;
              if ( v208 == 4 )
              {
                v258 = *(unsigned int **)(v3 + 164);
                if ( !v258 || (v259 = v258[1], v260 = *v258, v259 == *v258) )
                {
                  v258 = sub_99EB8(v258, 1, 8, 20);
                  v260 = *v258;
                  v259 = v258[1];
                  *(_DWORD *)(v3 + 164) = v258;
                }
                if ( v260 >= v259 )
                {
                  v12 = sub_94700(
                          (int)"dwarf2read.c",
                          10067,
                          "%s: Assertion `%s' failed.",
                          "delayed_method_info* VEC_delayed_method_info_quick_push(VEC_delayed_method_info*, const delaye"
                          "d_method_info*, const char*, unsigned int)",
                          "quick_push");
LABEL_417:
                  sub_946E0("unexpected member functions in Ada type", HIDWORD(v12));
                }
                *v258 = v260 + 1;
                v261 = (int *)&v258[5 * v260 + 2];
                *v261 = v5;
                v261[1] = v206;
                v261[4] = (int)v13;
                v261[2] = (int)s1a;
                v261[3] = (int)v283;
              }
              else
              {
                v209 = (char *)sub_135FD8(v283, (int)v13, (int *)v3);
                if ( !v209 )
                  v209 = "";
                *((_DWORD *)v2 + 1) = v209;
              }
              *((_DWORD *)v2 + 2) = ((int (__fastcall *)(int))loc_16FD44)(v287);
              v210 = sub_132D94(v13, (int *)v3);
              v287 = v210;
              if ( v210 && (v211 = *(_DWORD *)(v210 + 24), *(_BYTE *)v211 == 7) )
              {
                v274 = *(__int16 *)(v211 + 4);
                sub_170C60(
                  *((_DWORD *)v2 + 2),
                  v5,
                  *(_DWORD *)(v211 + 20),
                  *(_DWORD *)(v211 + 24),
                  v274,
                  *(unsigned __int8 *)(v211 + 1) >> 7);
                if ( !v274 || (*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v287 + 24) + 24) + 8) & 1) == 0 )
                  *((_WORD *)v2 + 9) = 1;
              }
              else if ( dword_47AC88 > 0 )
              {
                v257 = (const char *)sub_1359DC(v283, (int)v13, (int *)v3, 0);
                sub_F43B4(&off_46D334, "member function type missing for '%s'", v257);
              }
              if ( sub_12E694((int)v13, 29, v3) )
              {
                sub_134A64((int)v13, (_DWORD *)v3);
                *((_DWORD *)v2 + 3) = v212;
              }
              v213 = sub_12E694((int)v13, 50, v3);
              if ( v213 )
                v214 = *(_DWORD *)(v213 + 8);
              else
                v214 = sub_122128((int)v13, v3);
              if ( v214 == 2 )
              {
                v2[16] |= 8u;
              }
              else if ( v214 == 3 )
              {
LABEL_321:
                v2[16] |= 4u;
              }
              v215 = sub_12E694((int)v13, 52, v3);
              if ( v215 && *(_QWORD *)(v215 + 8) )
                v2[16] |= 0x10u;
              v216 = (unsigned __int16 *)*((_DWORD *)v13 + 5);
              if ( v216 )
              {
                v217 = *v216;
                v218 = (v217 & 0xFFFB) == 19;
                if ( (v217 & 0xFFFB) != 0x13 )
                  v218 = v217 == 2;
                if ( v218 )
                {
                  s1b = sub_12FAF0(v13, (_DWORD *)v3);
                  v219 = sub_12FAF0(*((_WORD **)v13 + 5), (_DWORD *)v3);
                  v220 = v219 == 0;
                  v221 = v219;
                  if ( !s1b )
                    v220 = 1;
                  if ( !v220 )
                  {
                    v222 = strlen(s1b);
                    if ( !strncmp(s1b, v221, v222) )
                    {
                      LOBYTE(v220) = v221[v222] == 60;
                      if ( !v221[v222] )
                        LOBYTE(v220) = 1;
                    }
                    v16 = v220;
                  }
                }
              }
              v2[16] = v2[16] & 0xBF | ((v16 & 1) << 6);
              v223 = sub_12E694((int)v13, 77, v3);
              if ( v223 )
              {
                v224 = *(_WORD *)(v223 + 2) & 0x7FFF;
                HIDWORD(v12) = v224 - 3;
                v225 = v224 - 3 > 1;
                if ( v224 - 3 > 1 )
                  v225 = v224 - 9 > 1;
                v226 = !v225;
                if ( v224 == 24 )
                  v226 |= 1u;
                if ( v226 && (v227 = *(unsigned int **)(v223 + 8), *v227) )
                {
                  HIDWORD(v12) = v227[1];
                  v228 = (unsigned __int8)*(_BYTE *)HIDWORD(v12);
                  if ( v228 == 16 )
                  {
                    *((_WORD *)v2 + 9) = sub_122F44(v227, v3) + 2;
                  }
                  else
                  {
                    if ( v228 == 6 )
                      goto LABEL_406;
                    v229 = v228 == 148;
                    if ( *v227 <= 1 )
                      v229 = 0;
                    if ( v229 && *(unsigned __int8 *)(HIDWORD(v12) + 1) == *(unsigned __int8 *)(v3 + 14) )
                    {
LABEL_406:
                      v275 = sub_122F44(v227, v3);
                      v276 = *(unsigned __int8 *)(v3 + 14);
                      *((_WORD *)v2 + 9) = v275;
                      LOWORD(v12) = sub_347924(v275, v276);
                      if ( HIDWORD(v12) )
                      {
                        if ( dword_47AC88 > 0 )
                        {
                          sub_121FE4();
                          v275 = *((_WORD *)v2 + 9);
                        }
                      }
                      else
                      {
                        v275 = v12;
                      }
                      *((_WORD *)v2 + 9) = v275 + 2;
                    }
                    else if ( dword_47AC88 > 0 )
                    {
                      sub_121FE4();
                    }
                  }
                  if ( !*((_DWORD *)v2 + 3) )
                  {
                    v230 = *(_DWORD *)(v287 + 24);
                    if ( *(_WORD *)(v230 + 4) && (v231 = *(_DWORD *)(v230 + 24), (*(_BYTE *)(v231 + 8) & 1) != 0) )
                    {
                      *((_DWORD *)v2 + 3) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v231 + 12) + 24) + 20);
                    }
                    else if ( dword_47AC88 > 0 )
                    {
                      sub_F43B4(
                        &off_46D334,
                        "cannot determine context for virtual member function \"%s\" (offset %d)",
                        v283,
                        *((_DWORD *)v13 + 2));
                    }
                  }
                }
                else
                {
                  v232 = v224 > 0x17;
                  if ( v224 != 23 )
                    v232 = v224 - 6 > 1;
                  if ( v232 )
                  {
                    if ( dword_47AC88 > 0 )
                      sub_121FC8("DW_AT_vtable_elem_location", v283);
                  }
                  else if ( dword_47AC88 > 0 )
                  {
                    sub_121FE4();
                  }
                }
              }
              else
              {
                LODWORD(v12) = sub_12E694((int)v13, 76, v3);
                if ( (_DWORD)v12 && *(_QWORD *)(v12 + 8) )
                {
                  if ( dword_47AC88 > 0 )
                    sub_F43B4(
                      &off_46D334,
                      "Member function \"%s\" (offset %d) is virtual but the vtable offset is not specified",
                      v283,
                      *((_DWORD *)v13 + 2));
                  sub_173008(v5);
                  v264 = *(_DWORD *)(v5 + 24);
                  HIDWORD(v12) = 1;
                  if ( (*(_WORD *)(v264 + 2) & 0x380) == 0x80 )
                    v265 = *(__int16 **)(v264 + 28);
                  else
                    v265 = &word_3B4A2C;
                  *((_BYTE *)v265 + 8) = v265[4] & 0xFC | 1;
                }
              }
            }
          }
LABEL_38:
          v13 = (unsigned __int16 *)*((_DWORD *)v13 + 4);
          if ( v13 )
          {
            v14 = *v13;
            if ( *v13 )
              continue;
          }
          goto LABEL_40;
        }
        if ( v14 != 28 )
        {
          switch ( v14 )
          {
            case 2:
            case 4:
            case 19:
            case 22:
            case 23:
              v90 = sub_93094(1u, 0x10u);
              sub_9253C((int)&loc_11C838, (int)v90);
              switch ( *v13 )
              {
                case 2u:
                case 4u:
                case 0x13u:
                case 0x16u:
                case 0x17u:
                  *v90 = sub_12FAF0(v13, (_DWORD *)v3);
                  v90[1] = sub_132D94(v13, (int *)v3);
                  LODWORD(v12) = sub_12E694((int)v13, 50, v3);
                  if ( (_DWORD)v12 )
                    v198 = *(_DWORD *)(v12 + 8);
                  else
                    v198 = sub_122128((int)v13, v3);
                  if ( v198 == 2 )
                  {
                    *((_BYTE *)v90 + 8) |= 1u;
                  }
                  else if ( v198 == 3 )
                  {
                    *((_BYTE *)v90 + 8) |= 2u;
                  }
                  else if ( v198 != 1 && dword_47AC88 > 0 )
                  {
                    sub_F43B4(&off_46D334, "Unhandled DW_AT_accessibility value (%x)");
                  }
                  if ( *v13 == 22 )
                  {
                    v262 = s[7];
                    s[7] = (int)v90;
                    v263 = s[8] + 1;
                    v90[3] = v262;
                    s[8] = v263;
                  }
                  else
                  {
                    v199 = s[9];
                    s[9] = (int)v90;
                    v200 = s[10] + 1;
                    v90[3] = v199;
                    s[10] = v200;
                  }
                  break;
                default:
                  sub_94700(
                    (int)"dwarf2read.c",
                    15219,
                    "%s: Assertion `%s' failed.",
                    "void dwarf2_add_type_defn(field_info*, die_info*, dwarf2_cu*)",
                    "type_can_define_types (die)");
                  goto LABEL_321;
              }
              break;
            default:
              if ( (unsigned int)(v14 - 47) <= 1 )
              {
                LODWORD(v12) = ((int (__fastcall *)(unsigned __int16 *, _DWORD, int))loc_1363E4)(v13, 0, v3);
                if ( (_DWORD)v12 )
                {
                  if ( v291 == v292 )
                  {
                    sub_148AC4(&src);
                  }
                  else
                  {
                    HIDWORD(v12) = v291 + 4;
                    if ( v291 )
                      *(_DWORD *)v291 = v12;
                    v291 = (char *)HIDWORD(v12);
                  }
                }
              }
              break;
          }
          goto LABEL_38;
        }
LABEL_239:
        sub_136DD8(s, v13, (int *)v3);
        goto LABEL_38;
      }
    }
LABEL_40:
    if ( src != v291 )
    {
      sub_173008(v5);
      v17 = *(_DWORD *)(v5 + 24);
      v18 = src;
      v19 = *(_WORD *)(v17 + 2) & 0x380;
      v20 = (v291 - (_BYTE *)src) >> 2;
      v21 = *(_DWORD *)(v280 + 60);
      if ( v19 == 128 )
      {
        v22 = *(_DWORD *)(v17 + 28);
      }
      else
      {
        v22 = 3885612;
        word_3B4A32 = (v291 - (_BYTE *)src) >> 2;
      }
      v23 = 4 * (unsigned __int16)v20;
      if ( v19 == 128 )
        *(_WORD *)(v22 + 6) = v20;
      v24 = *(_DWORD *)(v280 + 64);
      if ( v23 > v24 - v21 )
      {
        obstack_newchunk((struct obstack *)(v280 + 48), v23);
        v17 = *(_DWORD *)(v5 + 24);
        v24 = *(_DWORD *)(v280 + 64);
        v21 = *(_DWORD *)(v280 + 60);
        v18 = src;
        v19 = *(_WORD *)(v17 + 2) & 0x380;
      }
      v25 = v21 + v23;
      v26 = *(_DWORD *)(v280 + 56);
      *(_DWORD *)(v280 + 60) = v21 + v23;
      if ( v21 + v23 == v26 )
        *(_BYTE *)(v280 + 88) |= 2u;
      v27 = *(_DWORD *)(v280 + 52);
      v28 = (v25 + *(_DWORD *)(v280 + 72)) & ~*(_DWORD *)(v280 + 72);
      *(_DWORD *)(v280 + 60) = v28;
      if ( v28 - v27 > (unsigned int)(v24 - v27) )
      {
        *(_DWORD *)(v280 + 60) = v24;
        v28 = v24;
      }
      *(_DWORD *)(v280 + 56) = v28;
      *(_DWORD *)(v22 + 52) = v26;
      if ( v19 == 128 )
      {
        v29 = *(__int16 **)(v17 + 28);
        v30 = (void *)*((_DWORD *)v29 + 13);
      }
      else
      {
        v29 = &word_3B4A2C;
        v30 = 0;
      }
      memcpy(v30, v18, 4 * (unsigned __int16)v29[3]);
    }
    v31 = s[2];
    if ( !s[2] )
    {
LABEL_56:
      if ( !s[6] )
        goto LABEL_57;
      if ( *(_DWORD *)(v3 + 64) == 14 )
        goto LABEL_417;
      sub_173008(v5);
      v158 = *(_DWORD *)(v5 + 24);
      v159 = s[6];
      v160 = 12 * s[6];
      if ( (*(_BYTE *)(v158 + 2) & 0x10) != 0 )
      {
        v161 = *(_DWORD *)(v158 + 16);
        v162 = *(_DWORD *)(v161 + 64);
        v163 = *(_DWORD *)(v161 + 60);
        if ( v160 > v162 - v163 )
        {
          obstack_newchunk((struct obstack *)(v161 + 48), 12 * s[6]);
          v163 = *(_DWORD *)(v161 + 60);
          v162 = *(_DWORD *)(v161 + 64);
          v159 = s[6];
        }
        v164 = *(void **)(v161 + 56);
        v165 = (void *)(v163 + v160);
        v166 = *(_DWORD *)(v161 + 52);
        *(_DWORD *)(v161 + 60) = v165;
        if ( v165 == v164 )
          *(_BYTE *)(v161 + 88) |= 2u;
        v167 = ((unsigned int)v165 + *(_DWORD *)(v161 + 72)) & ~*(_DWORD *)(v161 + 72);
        *(_DWORD *)(v161 + 60) = v167;
        if ( v167 - v166 > (unsigned int)(v162 - v166) )
        {
          v167 = v162;
          *(_DWORD *)(v161 + 60) = v162;
        }
        *(_DWORD *)(v161 + 56) = v167;
      }
      else
      {
        v164 = sub_93028(12 * s[6]);
        v159 = s[6];
      }
      v168 = *(_DWORD *)(v5 + 24);
      v169 = s[5];
      v170 = *(_WORD *)(v168 + 2) & 0x380;
      if ( v170 == 128 )
      {
        v171 = *(__int16 **)(v168 + 28);
        *((_DWORD *)v171 + 8) = v164;
        if ( v159 <= 0 )
          goto LABEL_226;
      }
      else
      {
        v171 = &word_3B4A2C;
        dword_3B4A4C = (int)v164;
        if ( v159 <= 0 )
          goto LABEL_226;
      }
      v172 = -12 - v169;
      v173 = v169 + 12;
      v281 = v172;
      do
      {
        v9 = v170 == 128;
        v174 = *(_DWORD **)(v173 - 4);
        v175 = *(_DWORD *)(v173 - 12);
        v176 = (_DWORD *)(v281 + v173);
        if ( v9 )
        {
          v177 = (_DWORD *)((char *)v176 + *(_DWORD *)(*(_DWORD *)(v168 + 28) + 32));
          *v177 = v175;
        }
        else
        {
          *v176 = v175;
          v177 = (_DWORD *)(v281 + v173);
        }
        v178 = *(_BYTE *)(v168 + 2);
        v179 = *(_DWORD *)(v173 - 8);
        v177[1] = v179;
        v180 = 16 * v179;
        if ( (v178 & 0x10) != 0 )
        {
          v181 = *(_DWORD *)(v168 + 16);
          v182 = *(_DWORD *)(v181 + 64);
          v183 = *(_DWORD *)(v181 + 60);
          v184 = v182 - v183;
          if ( v182 - v183 < v180 )
          {
            obstack_newchunk((struct obstack *)(v181 + 48), v180);
            v183 = *(_DWORD *)(v181 + 60);
            v182 = *(_DWORD *)(v181 + 64);
          }
          v185 = *(char **)(v181 + 56);
          v186 = (char *)(v183 + v180);
          v187 = *(_DWORD *)(v181 + 72);
          *(_DWORD *)(v181 + 60) = v186;
          v188 = v186 == v185;
          if ( v186 == v185 )
            v184 = *(_BYTE *)(v181 + 88);
          v189 = (unsigned int)&v186[v187] & ~v187;
          *(_DWORD *)(v181 + 60) = v189;
          if ( v188 )
            *(_BYTE *)(v181 + 88) = v184 | 2;
          if ( v189 - *(_DWORD *)(v181 + 52) > (unsigned int)(v182 - *(_DWORD *)(v181 + 52)) )
          {
            v189 = v182;
            *(_DWORD *)(v181 + 60) = v182;
          }
          *(_DWORD *)(v181 + 56) = v189;
        }
        else
        {
          v185 = (char *)sub_93028(16 * v179);
        }
        v177[2] = v185;
        if ( v174 )
        {
          v190 = &v185[16 * *(_DWORD *)(v173 - 8)];
          do
          {
            v191 = v174[1];
            v192 = v174[2];
            v193 = v174[3];
            v194 = v174[4];
            v190 -= 16;
            v174 = (_DWORD *)*v174;
            *(_DWORD *)v190 = v191;
            *((_DWORD *)v190 + 1) = v192;
            *((_DWORD *)v190 + 2) = v193;
            *((_DWORD *)v190 + 3) = v194;
          }
          while ( v174 );
        }
        v173 += 12;
        LOWORD(v159) = s[6];
        v168 = *(_DWORD *)(v5 + 24);
        ++v277;
        v170 = *(_WORD *)(v168 + 2) & 0x380;
      }
      while ( s[6] > v277 );
      if ( v170 == 128 )
        v171 = *(__int16 **)(v168 + 28);
      else
        v171 = &word_3B4A2C;
LABEL_226:
      v171[2] = v159;
      if ( sub_12E694(v4, 29, v3) )
      {
        sub_134A64(v4, (_DWORD *)v3);
        v196 = v195;
        ((void (__fastcall *)(int, int))loc_1731A4)(v5, v195);
        if ( v196 == v5 )
        {
          v266 = *(_DWORD *)(v196 + 24);
          v267 = *(__int16 *)(v266 + 4) - 1;
          v279 = *(_WORD *)(v266 + 2) & 0x380;
          for ( i = 24 * v267; ; i -= 24 )
          {
            v269 = v279;
            v270 = v279 == 128 ? *(__int16 **)(v266 + 28) : &word_3B4A2C;
            if ( *v270 > v267 )
              break;
            v271 = *(_DWORD *)(*(_DWORD *)(v266 + 24) + i + 16);
            if ( !strncmp((const char *)v271, "_vptr", 5u) )
            {
              if ( sub_10A844(*(unsigned __int8 *)(v271 + 5)) )
              {
                ((void (__fastcall *)(int, int))loc_173104)(v5, v267);
                v266 = *(_DWORD *)(v196 + 24);
                v269 = *(_WORD *)(v266 + 2) & 0x380;
                break;
              }
              v266 = *(_DWORD *)(v196 + 24);
              v279 = *(_WORD *)(v266 + 2) & 0x380;
            }
            --v267;
          }
          if ( v269 == 128 )
            v272 = *(__int16 **)(v266 + 28);
          else
            v272 = &word_3B4A2C;
          if ( *v272 > v267 && dword_47AC88 > 0 )
          {
            v273 = *(char **)(*(_DWORD *)(v5 + 24) + 12);
            if ( !v273 )
              v273 = "";
            sub_F43B4(&off_46D334, "virtual function table pointer not found when defining class '%s'", v273);
          }
        }
        else
        {
          v197 = ((int (__fastcall *)(int))loc_1724A0)(v196);
          ((void (__fastcall *)(int, int))loc_173104)(v5, v197);
        }
      }
      else
      {
        v234 = *(const char **)(v3 + 72);
        if ( v234 && !strncmp(v234, "IBM(R) XL C/C++ Advanced Edition", 0x20u) )
        {
          v278 = v4;
          v235 = *(_DWORD *)(v5 + 24);
          v236 = *(__int16 *)(v235 + 4) - 1;
          v237 = *(_WORD *)(v235 + 2) & 0x380;
          v238 = 24 * v236;
          while ( 1 )
          {
            if ( v237 == 128 )
              v240 = *(__int16 **)(v235 + 28);
            else
              v240 = &word_3B4A2C;
            if ( *v240 > v236 )
            {
              v4 = v278;
              goto LABEL_57;
            }
            v239 = *(_DWORD *)(v235 + 24) + v238;
            v238 -= 24;
            if ( !strcmp(*(const char **)(v239 + 16), "__vfp") )
              break;
            --v236;
          }
          v4 = v278;
          ((void (__fastcall *)(int, int))loc_173104)(v5, v236);
          ((void (__fastcall *)(int, int))loc_1731A4)(v5, v5);
        }
      }
LABEL_57:
      if ( s[7] )
      {
        v32 = s[8];
        sub_173008(v5);
        v33 = *(_DWORD *)(v5 + 24);
        v34 = 12 * v32;
        if ( (*(_BYTE *)(v33 + 2) & 0x10) != 0 )
        {
          v35 = *(_DWORD *)(v33 + 16);
          v36 = *(_DWORD *)(v35 + 64);
          v37 = *(_DWORD *)(v35 + 60);
          v38 = v36 - v37;
          if ( v36 - v37 < v34 )
          {
            obstack_newchunk((struct obstack *)(v35 + 48), 12 * v32);
            v37 = *(_DWORD *)(v35 + 60);
            v36 = *(_DWORD *)(v35 + 64);
          }
          v39 = *(void **)(v35 + 56);
          v40 = (void *)(v37 + v34);
          v41 = *(_DWORD *)(v35 + 72);
          *(_DWORD *)(v35 + 60) = v40;
          v42 = v40 == v39;
          if ( v40 == v39 )
            v38 = *(_BYTE *)(v35 + 88);
          v43 = ((unsigned int)v40 + v41) & ~v41;
          *(_DWORD *)(v35 + 60) = v43;
          if ( v42 )
            *(_BYTE *)(v35 + 88) = v38 | 2;
          if ( v43 - *(_DWORD *)(v35 + 52) > (unsigned int)(v36 - *(_DWORD *)(v35 + 52)) )
          {
            v43 = v36;
            *(_DWORD *)(v35 + 60) = v36;
          }
          *(_DWORD *)(v35 + 56) = v43;
        }
        else
        {
          v39 = sub_93028(12 * v32);
        }
        v44 = *(_DWORD *)(v5 + 24);
        v45 = *(_WORD *)(v44 + 2) & 0x380;
        v46 = v45 == 128;
        if ( v45 == 128 )
        {
          v47 = *(__int16 **)(v44 + 28);
        }
        else
        {
          v47 = &word_3B4A2C;
          dword_3B4A50 = (int)v39;
        }
        if ( v46 )
          *((_DWORD *)v47 + 9) = v39;
        v48 = v32 - 1;
        *((_DWORD *)v47 + 10) = v32;
        if ( v32 - 1 >= 0 )
        {
          v49 = *((_DWORD *)v47 + 9);
          v50 = (int *)s[7];
          v51 = 12 * v48;
          do
          {
            v52 = *v50;
            v53 = v50[1];
            v54 = v50[2];
            --v48;
            v55 = (_DWORD *)(v49 + v51);
            v50 = (int *)v50[3];
            v51 -= 12;
            s[7] = (int)v50;
            *v55 = v52;
            v55[1] = v53;
            v55[2] = v54;
          }
          while ( v48 != -1 );
        }
      }
      if ( s[9] && *(_DWORD *)(v3 + 64) != 14 )
      {
        v56 = s[10];
        sub_173008(v5);
        v57 = *(_DWORD *)(v5 + 24);
        v58 = 12 * v56;
        if ( (*(_BYTE *)(v57 + 2) & 0x10) != 0 )
        {
          v59 = *(_DWORD *)(v57 + 16);
          v60 = *(_DWORD *)(v59 + 64);
          v61 = *(_DWORD *)(v59 + 60);
          v62 = v60 - v61;
          if ( v58 > v60 - v61 )
          {
            obstack_newchunk((struct obstack *)(v59 + 48), 12 * v56);
            v61 = *(_DWORD *)(v59 + 60);
            v60 = *(_DWORD *)(v59 + 64);
          }
          v63 = *(void **)(v59 + 56);
          v64 = (void *)(v61 + v58);
          v65 = *(_DWORD *)(v59 + 72);
          *(_DWORD *)(v59 + 60) = v64;
          v66 = v64 == v63;
          if ( v64 == v63 )
            v62 = *(_BYTE *)(v59 + 88);
          v67 = ((unsigned int)v64 + v65) & ~v65;
          *(_DWORD *)(v59 + 60) = v67;
          if ( v66 )
            *(_BYTE *)(v59 + 88) = v62 | 2;
          if ( v67 - *(_DWORD *)(v59 + 52) > (unsigned int)(v60 - *(_DWORD *)(v59 + 52)) )
          {
            v67 = v60;
            *(_DWORD *)(v59 + 60) = v60;
          }
          *(_DWORD *)(v59 + 56) = v67;
        }
        else
        {
          v63 = sub_93028(12 * v56);
        }
        v68 = *(_DWORD *)(v5 + 24);
        v69 = *(_WORD *)(v68 + 2) & 0x380;
        v70 = v69 == 128;
        if ( v69 == 128 )
        {
          v71 = *(__int16 **)(v68 + 28);
        }
        else
        {
          v71 = &word_3B4A2C;
          dword_3B4A58 = (int)v63;
        }
        if ( v70 )
          *((_DWORD *)v71 + 11) = v63;
        v72 = v56 - 1;
        *((_DWORD *)v71 + 12) = v56;
        if ( v56 - 1 >= 0 )
        {
          v73 = *((_DWORD *)v71 + 11);
          v74 = (int *)s[9];
          v75 = 12 * v72;
          do
          {
            v76 = *v74;
            v77 = v74[1];
            v78 = v74[2];
            --v72;
            v79 = (_DWORD *)(v73 + v75);
            v74 = (int *)v74[3];
            v75 -= 12;
            s[9] = (int)v74;
            *v79 = v76;
            v79[1] = v77;
            v79[2] = v78;
          }
          while ( v72 != -1 );
        }
      }
      sub_92620(v282);
      if ( src )
      {
        sub_339E64(src);
        v6 = *(_DWORD *)(v5 + 24);
        if ( *(_BYTE *)v6 != 3 )
          goto LABEL_6;
LABEL_98:
        if ( *(_WORD *)(v6 + 4) != 2 )
          goto LABEL_6;
        goto LABEL_99;
      }
LABEL_5:
      v6 = *(_DWORD *)(v5 + 24);
      if ( *(_BYTE *)v6 != 3 )
        goto LABEL_6;
      goto LABEL_98;
    }
    v91 = *(_DWORD *)(v5 + 24);
    v92 = 24 * s[2];
    v93 = *(_BYTE *)(v91 + 2);
    *(_WORD *)(v91 + 4) = s[2];
    if ( (v93 & 0x10) != 0 )
    {
      v94 = *(_DWORD *)(v91 + 16);
      v95 = *(_DWORD *)(v94 + 64);
      v96 = *(_DWORD *)(v94 + 60);
      v97 = v95 - v96;
      if ( v95 - v96 < v92 )
      {
        obstack_newchunk((struct obstack *)(v94 + 48), 24 * v31);
        v96 = *(_DWORD *)(v94 + 60);
        v95 = *(_DWORD *)(v94 + 64);
      }
      v98 = *(void **)(v94 + 56);
      v99 = (void *)(v96 + v92);
      v100 = *(_DWORD *)(v94 + 72);
      *(_DWORD *)(v94 + 60) = v99;
      v101 = v99 == v98;
      if ( v99 == v98 )
        v97 = *(_BYTE *)(v94 + 88);
      v102 = ((unsigned int)v99 + v100) & ~v100;
      *(_DWORD *)(v94 + 60) = v102;
      if ( v101 )
        *(_BYTE *)(v94 + 88) = v97 | 2;
      if ( v102 - *(_DWORD *)(v94 + 52) > (unsigned int)(v95 - *(_DWORD *)(v94 + 52)) )
      {
        v102 = v95;
        *(_DWORD *)(v94 + 60) = v95;
      }
      *(_DWORD *)(v94 + 56) = v102;
    }
    else
    {
      v98 = sub_93028(24 * v31);
    }
    *(_DWORD *)(*(_DWORD *)(v5 + 24) + 24) = v98;
    memset(v98, 0, 24 * v31);
    if ( s[4] )
    {
      if ( *(_DWORD *)(v3 + 64) == 14 )
      {
LABEL_168:
        HIDWORD(v12) = "unsupported accessibility %d";
        for ( j = v92 - 24; ; j -= 24 )
        {
          v144 = v31--;
          if ( v31 + 1 <= 0 )
            goto LABEL_56;
          v145 = (int *)s[0];
          v146 = *(_DWORD *)(v5 + 24);
          v147 = s[0] == 0;
          if ( s[0] )
            v144 = *(_DWORD *)s[0];
          else
            v145 = (int *)s[1];
          v148 = *(_DWORD *)(v146 + 24);
          if ( s[0] )
            s[0] = v144;
          else
            v144 = *v145;
          v149 = v145[1];
          v150 = (_DWORD *)(v148 + j);
          if ( v147 )
            s[1] = v144;
          v151 = v145[5];
          v152 = v145[6];
          v153 = v145[7];
          *v150 = v145[4];
          v150[1] = v151;
          v150[2] = v152;
          v150[3] = v153;
          v154 = v150 + 4;
          HIDWORD(v12) = v145[9];
          *v154 = v145[8];
          v154[1] = HIDWORD(v12);
          if ( v149 == 2 )
          {
            if ( *(_DWORD *)(v3 + 64) != 14 )
            {
              v155 = v31 >> 3;
              v156 = 1 << (v31 & 7);
              if ( (*(_WORD *)(v146 + 2) & 0x380) == 0x80 )
              {
                LODWORD(v12) = *(_DWORD *)(*(_DWORD *)(v146 + 28) + 24);
                HIDWORD(v12) = *(unsigned __int8 *)(v12 + (v31 >> 3));
                v155 += v12;
                v157 = v156 | BYTE4(v12);
              }
              else
              {
                HIDWORD(v12) = 0;
                v157 = v156 | *(_BYTE *)(v31 >> 3);
              }
LABEL_194:
              *(_BYTE *)v155 = v157;
            }
          }
          else
          {
            if ( v149 == 3 )
            {
              if ( *(_DWORD *)(v3 + 64) == 14 )
                goto LABEL_173;
              v155 = v31 >> 3;
              v233 = 1 << (v31 & 7);
              if ( (*(_WORD *)(v146 + 2) & 0x380) == 0x80 )
              {
                LODWORD(v12) = *(_DWORD *)(*(_DWORD *)(v146 + 28) + 20);
                HIDWORD(v12) = *(unsigned __int8 *)(v12 + (v31 >> 3));
                v155 += v12;
                v157 = v233 | BYTE4(v12);
              }
              else
              {
                HIDWORD(v12) = 0;
                v157 = v233 | *(_BYTE *)(v31 >> 3);
              }
              goto LABEL_194;
            }
            if ( v149 != 1 && dword_47AC88 > 0 )
              sub_F43B4(&off_46D334, "unsupported accessibility %d", v149);
          }
LABEL_173:
          if ( v31 < s[3] && (unsigned int)(v145[2] - 1) <= 1 )
          {
            if ( *(_DWORD *)(v3 + 64) == 14 )
              sub_946E0("unexpected virtuality in component of Ada type");
            v141 = *(_DWORD *)(v5 + 24);
            if ( (*(_WORD *)(v141 + 2) & 0x380) == 0x80 )
              v142 = *(__int16 **)(v141 + 28);
            else
              v142 = &word_3B4A2C;
            v143 = *((_DWORD *)v142 + 4);
            HIDWORD(v12) = *(unsigned __int8 *)(v143 + (v31 >> 3));
            *(_BYTE *)(v143 + (v31 >> 3)) = (1 << (v31 & 7)) | BYTE4(v12);
          }
        }
      }
      sub_173008(v5);
      v103 = *(_DWORD *)(v5 + 24);
      v104 = (v31 >> 3) + 1;
      if ( (*(_BYTE *)(v103 + 2) & 0x10) != 0 )
      {
        v105 = *(_DWORD *)(v103 + 16);
        v106 = *(_DWORD *)(v105 + 64);
        v107 = *(_DWORD *)(v105 + 60);
        v108 = v106 - v107;
        if ( v104 > v106 - v107 )
        {
          obstack_newchunk((struct obstack *)(v105 + 48), (v31 >> 3) + 1);
          v107 = *(_DWORD *)(v105 + 60);
          v106 = *(_DWORD *)(v105 + 64);
        }
        v109 = *(void **)(v105 + 56);
        v110 = (void *)(v107 + v104);
        v111 = *(_DWORD *)(v105 + 72);
        *(_DWORD *)(v105 + 60) = v110;
        v112 = v110 == v109;
        if ( v110 == v109 )
          v108 = *(_BYTE *)(v105 + 88);
        v113 = ((unsigned int)v110 + v111) & ~v111;
        *(_DWORD *)(v105 + 60) = v113;
        if ( v112 )
          *(_BYTE *)(v105 + 88) = v108 | 2;
        if ( v113 - *(_DWORD *)(v105 + 52) > (unsigned int)(v106 - *(_DWORD *)(v105 + 52)) )
        {
          v113 = v106;
          *(_DWORD *)(v105 + 60) = v106;
        }
        *(_DWORD *)(v105 + 56) = v113;
      }
      else
      {
        v109 = sub_93028((v31 >> 3) + 1);
      }
      v114 = *(_DWORD *)(v5 + 24);
      if ( (*(_WORD *)(v114 + 2) & 0x380) == 0x80 )
        v115 = *(__int16 **)(v114 + 28);
      else
        v115 = &word_3B4A2C;
      *((_DWORD *)v115 + 5) = v109;
      memset(v109, 0, (v31 >> 3) + 1);
      v116 = *(_DWORD *)(v5 + 24);
      if ( (*(_BYTE *)(v116 + 2) & 0x10) != 0 )
      {
        v117 = *(_DWORD *)(v116 + 16);
        v118 = *(_DWORD *)(v117 + 64);
        v119 = *(_DWORD *)(v117 + 60);
        v120 = v118 - v119;
        if ( v104 > v118 - v119 )
        {
          obstack_newchunk((struct obstack *)(v117 + 48), (v31 >> 3) + 1);
          v119 = *(_DWORD *)(v117 + 60);
          v118 = *(_DWORD *)(v117 + 64);
        }
        v121 = *(void **)(v117 + 56);
        v122 = (void *)(v119 + v104);
        v123 = *(_DWORD *)(v117 + 72);
        *(_DWORD *)(v117 + 60) = v122;
        v124 = v122 == v121;
        if ( v122 == v121 )
          v120 = *(_BYTE *)(v117 + 88);
        v125 = ((unsigned int)v122 + v123) & ~v123;
        *(_DWORD *)(v117 + 60) = v125;
        if ( v124 )
          *(_BYTE *)(v117 + 88) = v120 | 2;
        if ( v125 - *(_DWORD *)(v117 + 52) > (unsigned int)(v118 - *(_DWORD *)(v117 + 52)) )
        {
          v125 = v118;
          *(_DWORD *)(v117 + 60) = v118;
        }
        *(_DWORD *)(v117 + 56) = v125;
      }
      else
      {
        v121 = sub_93028((v31 >> 3) + 1);
      }
      v126 = *(_DWORD *)(v5 + 24);
      if ( (*(_WORD *)(v126 + 2) & 0x380) == 0x80 )
        v127 = *(__int16 **)(v126 + 28);
      else
        v127 = &word_3B4A2C;
      *((_DWORD *)v127 + 6) = v121;
      memset(v121, 0, (v31 >> 3) + 1);
      v128 = *(_DWORD *)(v5 + 24);
      if ( (*(_BYTE *)(v128 + 2) & 0x10) != 0 )
      {
        v129 = *(_DWORD *)(v128 + 16);
        v130 = *(_DWORD *)(v129 + 64);
        v131 = *(_DWORD *)(v129 + 60);
        v132 = v130 - v131;
        if ( v104 > v130 - v131 )
        {
          obstack_newchunk((struct obstack *)(v129 + 48), (v31 >> 3) + 1);
          v131 = *(_DWORD *)(v129 + 60);
          v130 = *(_DWORD *)(v129 + 64);
        }
        v133 = *(void **)(v129 + 56);
        v134 = (void *)(v131 + v104);
        v135 = *(_DWORD *)(v129 + 72);
        *(_DWORD *)(v129 + 60) = v134;
        v136 = v134 == v133;
        if ( v134 == v133 )
          v132 = *(_BYTE *)(v129 + 88);
        v137 = ((unsigned int)v134 + v135) & ~v135;
        *(_DWORD *)(v129 + 60) = v137;
        if ( v136 )
          *(_BYTE *)(v129 + 88) = v132 | 2;
        if ( v137 - *(_DWORD *)(v129 + 52) > (unsigned int)(v130 - *(_DWORD *)(v129 + 52)) )
        {
          v137 = v130;
          *(_DWORD *)(v129 + 60) = v130;
        }
        *(_DWORD *)(v129 + 56) = v137;
      }
      else
      {
        v133 = sub_93028((v31 >> 3) + 1);
      }
      v138 = *(_DWORD *)(v5 + 24);
      if ( (*(_WORD *)(v138 + 2) & 0x380) == 0x80 )
        v139 = *(__int16 **)(v138 + 28);
      else
        v139 = &word_3B4A2C;
      *((_DWORD *)v139 + 7) = v133;
      memset(v133, 0, (v31 >> 3) + 1);
    }
    if ( s[3] && *(_DWORD *)(v3 + 64) != 14 )
    {
      v241 = (s[3] >> 3) + 1;
      sub_173008(v5);
      v242 = *(_DWORD *)(v5 + 24);
      if ( (*(_BYTE *)(v242 + 2) & 0x10) != 0 )
      {
        v243 = *(_DWORD *)(v242 + 16);
        v244 = *(_DWORD *)(v243 + 64);
        v245 = *(_DWORD *)(v243 + 60);
        if ( v244 - v245 < v241 )
        {
          obstack_newchunk((struct obstack *)(v243 + 48), v241);
          v245 = *(_DWORD *)(v243 + 60);
          v244 = *(_DWORD *)(v243 + 64);
        }
        v246 = *(void **)(v243 + 56);
        v247 = (void *)(v245 + v241);
        v248 = *(_DWORD *)(v243 + 52);
        *(_DWORD *)(v243 + 60) = v247;
        if ( v247 == v246 )
          *(_BYTE *)(v243 + 88) |= 2u;
        v249 = ((unsigned int)v247 + *(_DWORD *)(v243 + 72)) & ~*(_DWORD *)(v243 + 72);
        *(_DWORD *)(v243 + 60) = v249;
        if ( v249 - v248 > (unsigned int)(v244 - v248) )
        {
          v249 = v244;
          *(_DWORD *)(v243 + 60) = v244;
        }
        *(_DWORD *)(v243 + 56) = v249;
      }
      else
      {
        v246 = sub_93028(v241);
      }
      v250 = *(_DWORD *)(v5 + 24);
      v251 = *(_WORD *)(v250 + 2) & 0x380;
      v252 = v251 == 128;
      if ( v251 == 128 )
        v253 = *(_DWORD *)(v250 + 28);
      else
        v253 = 18988;
      v254 = s[3];
      if ( !v252 )
        HIWORD(v253) = 59;
      *(_DWORD *)(v253 + 16) = v246;
      memset(v246, 0, (v254 >> 3) + 1);
      v255 = *(_DWORD *)(v5 + 24);
      if ( (*(_WORD *)(v255 + 2) & 0x380) == 0x80 )
        v256 = *(__int16 **)(v255 + 28);
      else
        v256 = &word_3B4A2C;
      *v256 = s[3];
    }
    goto LABEL_168;
  }
  v6 = *(_DWORD *)(v5 + 24);
  if ( *(_BYTE *)v6 != 3 )
    goto LABEL_23;
  if ( *(_WORD *)(v6 + 4) == 2 )
  {
LABEL_99:
    v80 = *(_DWORD **)(v6 + 24);
    v81 = (const char *)v80[4];
    if ( v81 )
    {
      if ( !strcmp(v81, "__pfn") )
      {
        v82 = (const char *)v80[10];
        if ( v82 )
        {
          if ( !strcmp(v82, "__delta") )
          {
            v83 = v80[3];
            if ( v83 )
            {
              v84 = *(_DWORD *)(v83 + 24);
              if ( *(_BYTE *)v84 == 1 )
              {
                v85 = *(_DWORD *)(v84 + 20);
                v86 = *(_DWORD *)(v85 + 24);
                if ( *(_BYTE *)v86 == 7 )
                {
                  if ( *(_WORD *)(v86 + 4) )
                  {
                    v87 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v86 + 24) + 12) + 24);
                    if ( *(_BYTE *)v87 == 1 )
                    {
                      v88 = *(_DWORD *)(v87 + 20);
                      v89 = ((int (__fastcall *)(int))loc_16FD44)(v280);
                      sub_170C60(
                        v89,
                        v88,
                        *(_DWORD *)(*(_DWORD *)(v85 + 24) + 20),
                        *(_DWORD *)(*(_DWORD *)(v85 + 24) + 24),
                        *(__int16 *)(*(_DWORD *)(v85 + 24) + 4),
                        *(unsigned __int8 *)(*(_DWORD *)(v85 + 24) + 1) >> 7);
                      sub_170BFC(v5, v89);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_6:
  v7 = *(unsigned __int16 **)(v4 + 12);
  if ( v7 && *v7 )
  {
    v8 = *v7;
    do
    {
      v9 = v8 == 52;
      if ( v8 != 52 )
        v9 = v8 == 13;
      v10 = v9;
      if ( v8 == 28 )
        v10 |= 1u;
      if ( (unsigned int)(v8 - 47) <= 1 )
        v10 |= 1u;
      if ( v10 )
      {
        v7 = (unsigned __int16 *)*((_DWORD *)v7 + 4);
        if ( !v7 )
          break;
      }
      else
      {
        ((void (__fastcall *)(unsigned __int16 *, int))loc_143F88)(v7, v3);
        v7 = (unsigned __int16 *)*((_DWORD *)v7 + 4);
        if ( !v7 )
          break;
      }
      v8 = *v7;
    }
    while ( *v7 );
  }
LABEL_23:
  if ( sub_12E694(v4, 11, v3) )
    return ((int (__fastcall *)(int, int, int, _DWORD))loc_1363E4)(v4, v5, v3, 0);
  result = sub_12FF48(v4, v3);
  if ( !result )
    return ((int (__fastcall *)(int, int, int, _DWORD))loc_1363E4)(v4, v5, v3, 0);
  return result;
}
