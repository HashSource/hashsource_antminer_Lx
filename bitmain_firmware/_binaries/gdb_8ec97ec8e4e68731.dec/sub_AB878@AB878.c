int __fastcall sub_AB878(int a1, _DWORD *a2, int *a3, int a4)
{
  int v6; // r4
  _DWORD *v9; // r9
  int v10; // r7
  __int64 v11; // r0
  int v12; // r4
  int v13; // r3
  __int64 v14; // r0
  int v15; // r3
  int v16; // r4
  int v17; // r1
  int v18; // r2
  int j; // r4
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24; // r4
  int v25; // r0
  int v26; // r0
  int v27; // r0
  int v28; // r0
  int v29; // r0
  int v30; // r0
  int v31; // r4
  int v32; // r0
  int v33; // r2
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r0
  unsigned int v38; // r12
  int v39; // r0
  char *v40; // r4
  int v41; // r0
  int v42; // r4
  int v43; // r0
  int v44; // r0
  int v45; // r4
  int v46; // r0
  int v47; // r0
  int v48; // r4
  int v49; // r5
  int v50; // r4
  __int64 v51; // r0
  int v52; // r0
  int v53; // r3
  int v54; // r4
  int v55; // r0
  __int64 v56; // r0
  int v57; // r7
  int v58; // r0
  int v59; // r4
  int v60; // r0
  int v61; // r6
  int v62; // r0
  int v63; // r1
  int v64; // r0
  int v65; // r1
  _DWORD *v66; // r3
  int v67; // r8
  char *v68; // r1
  int v69; // r2
  int v70; // r4
  int v71; // r1
  int v72; // r2
  int v73; // r0
  __int64 v74; // r2
  int v75; // r0
  __int64 v76; // r0
  int v77; // r4
  int v78; // r4
  int v79; // r6
  int v80; // r0
  int v81; // r8
  int v82; // r4
  int v83; // r8
  int v84; // r6
  int v85; // r0
  int v86; // r4
  int v87; // r0
  int v88; // r0
  __int64 v89; // r0
  int v90; // r0
  int v91; // r4
  int v92; // r7
  int v93; // r6
  int v94; // r7
  int v95; // r6
  __int64 v96; // r8
  __int64 v97; // r6
  int v98; // r0
  int v99; // r0
  int v100; // r0
  int v101; // r0
  int v102; // r0
  int v103; // r2
  __int64 *v104; // r4
  int *v105; // r8
  int v106; // r4
  int v107; // r0
  int v108; // r3
  int v109; // r0
  int v110; // r0
  int v111; // r0
  int v112; // r0
  int v113; // r0
  char *v114; // r2
  int v115; // r4
  int k; // r3
  int v117; // r0
  int v118; // r0
  int v119; // r4
  int v120; // r0
  int v121; // r3
  int i; // r4
  int v123; // r2
  int v124; // r0
  int v125; // r4
  int v126; // r0
  int v127; // r0
  int v128; // r5
  int v129; // r4
  int v130; // r6
  int v131; // r0
  int v132; // r0
  int v133; // r3
  int v134; // r5
  bool v135; // zf
  int v136; // r3
  int v137; // r3
  bool v138; // zf
  int v139; // r0
  int v140; // r0
  int v141; // r3
  int v142; // r3
  bool v143; // zf
  int v144; // r2
  bool v145; // zf
  unsigned int v146; // r7
  int v147; // r0
  int v148; // r3
  int v149; // r4
  int v150; // r0
  int v151; // r0
  int v152; // r4
  int v153; // r5
  int v154; // r0
  int v155; // r0
  int v156; // r4
  int v157; // r0
  int v158; // r3
  int v159; // r0
  int v160; // r4
  int v161; // r0
  int v162; // r0
  _BOOL4 v163; // r7
  int v164; // r0
  int v165; // r6
  int v166; // r5
  unsigned int v167; // r1
  unsigned int v168; // r7
  __int64 v169; // r0
  int v170; // r0
  __int64 v171; // r0
  int v172; // r5
  int v173; // r0
  int v174; // r0
  int v175; // r0
  int v176; // r0
  int v177; // r6
  int v178; // r4
  int v179; // r0
  int v180; // r0
  int v181; // r3
  int v182; // r5
  int v183; // r1
  int v184; // r0
  int v185; // r0
  int v186; // r6
  int v187; // r6
  int v188; // r0
  int v189; // r3
  const char *v190; // r1
  int v191; // r0
  int v192; // r0
  bool v193; // cc
  int v194; // r4
  int v195; // r0
  __int64 v196; // r0
  int v197; // r0
  int v198; // r6
  __int64 v199; // r4
  __int64 v200; // r0
  int v201; // r6
  __int64 v202; // r4
  __int64 v203; // r0
  int v204; // r0
  _BYTE *v205; // r3
  int v206; // r0
  int v207; // r0
  _BYTE *v208; // r3
  int v209; // r3
  __int64 v210; // r8
  char v211; // r3
  __int64 v212; // r0
  __int64 v213; // kr00_8
  __int64 v214; // r2
  __int64 v215; // r6
  __int64 v216; // r0
  int v217; // r8
  int v218; // r9
  int v219; // r0
  int v220; // r0
  int v221; // r3
  int v222; // r0
  int v223; // r0
  int v224; // r1
  int v225; // r0
  int v226; // r0
  char *v227; // r0
  int v228; // r3
  char v229; // r2
  int v230; // r0
  int v231; // r0
  int v232; // r0
  char *v233; // r2
  int v234; // r3
  __int64 v235; // r0
  int v236; // r0
  int v237; // r0
  int v238; // r3
  __int64 v239; // r0
  int v240; // r2
  __int64 v241; // r2
  int v242; // r10
  __int64 v243; // r8
  int v244; // r6
  int v245; // r0
  int v246; // r5
  int v247; // r1
  int v248; // r0
  int v249; // r3
  int v250; // r0
  int v251; // r5
  int v252; // r1
  int v253; // r0
  int v254; // r0
  int v255; // r0
  int v256; // r5
  int v257; // r3
  int v258; // r0
  const char *v259; // r1
  int v260; // r3
  int v261; // r0
  int v262; // r5
  int v263; // r0
  int v264; // r6
  int v265; // r0
  int v266; // r5
  int v267; // r3
  __int64 v268; // r8
  __int64 v269; // r0
  int v270; // r2
  int v271; // r3
  int v272; // r0
  int v273; // r3
  _BOOL4 v274; // r5
  int v275; // r0
  int v276; // r0
  int v277; // r0
  int v278; // r0
  int v279; // r0
  int v280; // r4
  int v281; // r0
  int v282; // r10
  int v283; // r9
  int v284; // r8
  int v285; // r6
  int v286; // r1
  int v287; // r7
  int v288; // r8
  int v289; // r9
  int v290; // r0
  int v291; // r5
  int v292; // r8
  int v293; // r0
  int v294; // r0
  const void *v295; // r8
  const void *v296; // r0
  int v297; // r0
  int v298; // r0
  int v299; // r0
  int v300; // r0
  int v301; // r0
  int v302; // r4
  __int64 v303; // r0
  int v304; // r9
  int v305; // r0
  int v306; // r10
  __int64 v307; // r0
  __int64 v308; // kr10_8
  __int64 v309; // r0
  int v310; // r0
  int v311; // r0
  int v312; // r8
  int v313; // r0
  unsigned int v314; // r6
  __int64 v315; // r6
  int v316; // r9
  int v317; // r10
  int v318; // r0
  int v319; // r5
  void *v320; // r4
  const void *v321; // r0
  const char *v322; // r0
  int v323; // [sp+4h] [bp-80h] BYREF
  __int64 v324; // [sp+8h] [bp-7Ch] BYREF
  __int64 v325; // [sp+10h] [bp-74h]
  __int64 v326; // [sp+18h] [bp-6Ch]
  __int64 v327; // [sp+20h] [bp-64h]
  int v328; // [sp+28h] [bp-5Ch] BYREF
  int v329; // [sp+2Ch] [bp-58h] BYREF
  __int64 v330; // [sp+30h] [bp-54h] BYREF
  __int64 v331; // [sp+38h] [bp-4Ch] BYREF
  __int64 v332; // [sp+40h] [bp-44h] BYREF
  __int64 v333; // [sp+48h] [bp-3Ch] BYREF
  __int64 v334; // [sp+50h] [bp-34h] BYREF
  __int64 v335; // [sp+58h] [bp-2Ch] BYREF

  v6 = *a3;
  v328 = 0;
  v329 = 0;
  v9 = &a2[4 * v6];
  *a3 = v6 + 1;
  v10 = v9[4];
  switch ( v10 )
  {
    case 1:
      v328 = sub_14DB3C(a2, a3, a4);
      v329 = sub_14DB3C(a2, a3, a4);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( **(_BYTE **)(sub_26BC70(v328) + 24) == 1 )
      {
        v154 = v328;
LABEL_270:
        v201 = sub_26BC70(v154);
        v202 = sub_26EB1C(v328);
        v203 = sub_26EB1C(v329);
        return sub_26DAF4(v201, HIDWORD(v203), (int)v202 + (int)v203, (unsigned __int64)(v202 + v203) >> 32);
      }
      if ( **(_BYTE **)(sub_26BC70(v329) + 24) == 1 )
      {
        v154 = v329;
        goto LABEL_270;
      }
      v155 = sub_26BC70(v328);
      if ( sub_9AAB0(v155) || (v278 = sub_26BC70(v329), sub_9AAB0(v278)) )
      {
        v156 = sub_26BC70(v328);
        if ( v156 != (int)sub_26BC70(v329) )
          sub_946E0("Operands of fixed-point addition must have the same type");
      }
      v157 = sub_26BC70(v328);
      v158 = *(_DWORD *)(v157 + 24);
      for ( i = v157; *(_BYTE *)v158 == 18; v158 = *(_DWORD *)(i + 24) )
        i = *(_DWORD *)(v158 + 20);
      sub_14CFF4(*a2, a2[1], &v328, &v329);
      v123 = 1;
      goto LABEL_148;
    case 2:
      v328 = sub_14DB3C(a2, a3, a4);
      v329 = sub_14DB3C(a2, a3, a4);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( **(_BYTE **)(sub_26BC70(v328) + 24) == 1 )
      {
        v117 = v328;
LABEL_268:
        v198 = sub_26BC70(v117);
        v199 = sub_26EB1C(v328);
        v200 = sub_26EB1C(v329);
        return sub_26DAF4(v198, HIDWORD(v200), (int)v199 - (int)v200, (unsigned __int64)(v199 - v200) >> 32);
      }
      if ( **(_BYTE **)(sub_26BC70(v329) + 24) == 1 )
      {
        v117 = v329;
        goto LABEL_268;
      }
      v118 = sub_26BC70(v328);
      if ( sub_9AAB0(v118) || (v277 = sub_26BC70(v329), sub_9AAB0(v277)) )
      {
        v119 = sub_26BC70(v328);
        if ( v119 != (int)sub_26BC70(v329) )
          sub_946E0("Operands of fixed-point subtraction must have the same type");
      }
      v120 = sub_26BC70(v328);
      v121 = *(_DWORD *)(v120 + 24);
      for ( i = v120; *(_BYTE *)v121 == 18; v121 = *(_DWORD *)(i + 24) )
        i = *(_DWORD *)(v121 + 20);
      sub_14CFF4(*a2, a2[1], &v328, &v329);
      v123 = 2;
LABEL_148:
      v124 = sub_25E4EC(v328, v329, v123);
      return sub_2647C8(i, v124);
    case 3:
    case 4:
    case 5:
    case 6:
      v328 = sub_14C9EC(0, a2, a3, a4);
      v329 = sub_14C9EC(0, a2, a3, a4);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( a4 == 2 )
      {
        sub_14CFF4(*a2, a2[1], &v328, &v329);
LABEL_244:
        v185 = sub_26BC70(v328);
        return sub_260DBC(v185);
      }
      v125 = *(_DWORD *)(sub_1780B4(a2[1]) + 44);
      v126 = sub_26BC70(v328);
      if ( sub_9AAB0(v126) )
        v328 = sub_A32C8(v125, v328);
      v127 = sub_26BC70(v329);
      if ( sub_9AAB0(v127) )
        v329 = sub_A32C8(v125, v329);
      sub_14CFF4(*a2, a2[1], &v328, &v329);
      v128 = v329;
      v129 = sub_26EA24(v328);
      v130 = sub_26EA24(v128);
      v131 = sub_26BC70(v129);
      v132 = sub_A0870(v131);
      if ( !v132 )
        goto LABEL_393;
      v133 = *(_DWORD *)(v132 + 24);
      if ( *(_BYTE *)v133 != 12 )
        goto LABEL_393;
      v134 = *(_DWORD *)(v133 + 20);
      v135 = v134 == 0;
      if ( v134 )
        v135 = v132 == v134;
      if ( !v135 )
      {
        do
        {
          v136 = *(_DWORD *)(v134 + 24);
          if ( *(_BYTE *)v136 != 12 )
            break;
          v137 = *(_DWORD *)(v136 + 20);
          v138 = v137 == v134;
          if ( v137 != v134 )
            v138 = v137 == 0;
          if ( v138 )
            break;
          v134 = v137;
        }
        while ( v137 );
      }
      else
      {
LABEL_393:
        v134 = v132;
      }
      v139 = sub_26BC70(v130);
      v140 = sub_A0870(v139);
      if ( !v140 )
        goto LABEL_282;
      v141 = *(_DWORD *)(v140 + 24);
      if ( *(_BYTE *)v141 != 12 )
        goto LABEL_282;
      v142 = *(_DWORD *)(v141 + 20);
      v143 = v140 == v142;
      if ( v140 != v142 )
        v143 = v142 == 0;
      if ( v143 )
        return sub_25E4EC(v129, v130, v10);
      while ( 1 )
      {
        v144 = *(_DWORD *)(v142 + 24);
        if ( *(_BYTE *)v144 != 12 )
          break;
        v140 = *(_DWORD *)(v144 + 20);
        v145 = v140 == v142;
        if ( v140 != v142 )
          v145 = v140 == 0;
        if ( v145 )
          return sub_25E4EC(v129, v130, v10);
        if ( !v140 )
          goto LABEL_282;
        v142 = *(_DWORD *)(v144 + 20);
      }
      v140 = v142;
LABEL_282:
      if ( **(_BYTE **)(v134 + 24) != 8 || **(_BYTE **)(v140 + 24) != 8 )
        return sub_25E4EC(v129, v130, v10);
      if ( (unsigned int)(v10 - 4) > 2 )
        return sub_25E4EC(v129, v130, 3);
      v210 = sub_26EB1C(v130);
      if ( !v210 )
      {
        v322 = (const char *)sub_1562F4(v10);
        sub_946E0("second operand of %s must not be zero.", v322);
      }
      v211 = *(_BYTE *)(*(_DWORD *)(v134 + 24) + 1);
      if ( v10 == 6 )
        v211 |= 1u;
      if ( (v211 & 1) != 0 )
        return sub_25E4EC(v129, v130, v10);
      v212 = sub_26EB1C(v129);
      v213 = v212;
      if ( v10 == 5 )
      {
        sub_347ED4(v212, HIDWORD(v212), v210, HIDWORD(v210));
        v215 = v214;
        if ( (((unsigned __int64)(v213 * v214) >> 32) & 0x80000000) != 0LL )
          v215 = v214 - v210;
      }
      else
      {
        v215 = sub_347ED4(v212, HIDWORD(v212), v210, HIDWORD(v210));
      }
      v216 = sub_26BB80(v134);
      j = v216;
      v217 = sub_26BCB8(v216, HIDWORD(v216));
      v218 = *(_DWORD *)(sub_26BC70(j) + 20);
      v219 = sub_170040(v134);
      v220 = ((int (__fastcall *)(int))loc_165BB8)(v219);
      sub_15C34C(v217, v218, v220, v221, v215, HIDWORD(v215));
      return j;
    case 9:
    case 10:
    case 59:
      *a3 = v6;
      v45 = sub_14E83C(a1, a2, a3, a4);
      v46 = sub_19462C(*a2, a2[1]);
      return sub_2647C8(v46, v45);
    case 11:
    case 12:
    case 13:
      v159 = sub_14C9EC(0, a2, a3, 2);
      *a3 = v6;
      v328 = v159;
      v160 = sub_14E83C(a1, a2, a3, a4);
      v161 = sub_26BC70(v328);
      return sub_2647C8(v161, v160);
    case 14:
    case 15:
      v328 = sub_14C9EC(0, a2, a3, a4);
      v75 = sub_26BC70(v328);
      v329 = sub_14C9EC(v75, a2, a3, a4);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      v76 = *(_QWORD *)a2;
      if ( a4 == 2 )
      {
        v77 = 0;
      }
      else
      {
        sub_14CFF4(v76, HIDWORD(v76), &v328, &v329);
        v78 = v328;
        v79 = v329;
        v80 = sub_26BC70(v328);
        if ( v80 && sub_A1D84(v80) || (v225 = sub_26BC70(v79)) != 0 && sub_A1D84(v225) )
        {
          v81 = sub_AB07C(v78);
          v82 = sub_AB07C(v79);
          v83 = sub_A8AAC(v81);
          v84 = sub_A8AAC(v82);
          v85 = sub_26BC70(v83);
          v86 = sub_A0870(v85);
          v87 = sub_26BC70(v84);
          v88 = sub_A0870(v87);
          if ( **(_BYTE **)(v86 + 24) != 2 || **(_BYTE **)(v88 + 24) != 2 )
            sub_946E0("Attempt to compare array with non-array");
          if ( *(_DWORD *)(v86 + 20) == *(_DWORD *)(v88 + 20) )
          {
            v295 = (const void *)sub_26E978(v83);
            v296 = (const void *)sub_26E978(v84);
            v77 = memcmp(v295, v296, *(_DWORD *)(v86 + 20)) == 0;
          }
          else
          {
            v77 = 0;
          }
          v76 = *(_QWORD *)a2;
        }
        else
        {
          v77 = sub_25E07C(v78, v79);
          v76 = *(_QWORD *)a2;
        }
      }
      if ( v10 == 15 )
        v77 = v77 == 0;
      v89 = sub_19462C(v76, HIDWORD(v76));
      return sub_26DAF4(v89, HIDWORD(v89), v77, v77 >> 31);
    case 21:
      v146 = a4 - 1;
      v147 = sub_14C9EC(0, a2, a3, a4);
      v148 = *a3;
      v328 = v147;
      if ( a2[4 * v148 + 4] == 113 )
      {
        v191 = sub_AE428(v147);
        j = v191;
        v328 = v191;
        if ( v146 > 1 )
          return sub_AB0DC(v191, v191);
        return j;
      }
      v149 = sub_26BC70(v147);
      if ( *(_DWORD *)nullsub_31(v328) == 3 )
        v150 = 0;
      else
        v150 = v149;
      v329 = sub_14C9EC(v150, a2, a3, a4);
      if ( v146 > 1 )
      {
        v151 = sub_26BC70(v328);
        if ( sub_9AAB0(v151) )
        {
          v152 = v329;
          v153 = sub_26BC70(v328);
          if ( v153 != (int)sub_26BC70(v329) )
            v152 = sub_A330C(v153, v329);
          goto LABEL_191;
        }
        v261 = sub_26BC70(v329);
        if ( sub_9AAB0(v261) )
          sub_946E0("Fixed-point values must be assigned to fixed-point variables");
        v152 = v329;
        v262 = sub_26BC70(v328);
        v263 = sub_26BC70(v329);
        if ( v262 == v263 )
          goto LABEL_191;
        v264 = sub_A0870(v263);
        v265 = sub_A0870(v262);
        v266 = v265;
        v267 = **(char **)(v264 + 24);
        if ( v267 == 1 )
        {
          if ( **(_BYTE **)(v265 + 24) != 2 )
          {
LABEL_191:
            v329 = v152;
            return sub_AB0DC(v328, v152);
          }
          v152 = sub_AB378(v329);
          v264 = sub_26BC70(v152);
          v267 = **(char **)(v264 + 24);
        }
        if ( v267 != 2 || **(_BYTE **)(v266 + 24) != 2 )
          goto LABEL_191;
        if ( !sub_171B30(v266, &v330, &v331) || !sub_171B30(v264, &v332, &v333) )
LABEL_459:
          sub_946E0("unable to determine array bounds");
        v268 = v331;
        v327 = v330;
        if ( v331 < v330 )
        {
          v268 = v330 - 1;
          v331 = v330 - 1;
        }
        v269 = v333;
        if ( v333 < v332 )
        {
          v269 = v332 - 1;
          v333 = v332 - 1;
        }
        v326 = v268 - v327;
        v325 = v269 - v332;
        if ( v268 - v327 != v269 - v332 )
          sub_946E0("cannot assign arrays of different length");
        if ( !sub_1736DC(*(_DWORD *)(*(_DWORD *)(v266 + 24) + 20)) )
        {
          v270 = *(_DWORD *)(v264 + 24);
          v271 = *(_DWORD *)(v266 + 24);
LABEL_367:
          if ( *(_DWORD *)(*(_DWORD *)(v270 + 20) + 20) != *(_DWORD *)(*(_DWORD *)(v271 + 20) + 20) )
            sub_946E0("Incompatible types in assignment");
          sub_26BC78(v152, v266);
          goto LABEL_191;
        }
        v311 = sub_1736DC(*(_DWORD *)(*(_DWORD *)(v264 + 24) + 20));
        v270 = *(_DWORD *)(v264 + 24);
        v271 = *(_DWORD *)(v266 + 24);
        if ( !v311 )
          goto LABEL_367;
        v312 = *(_DWORD *)(v271 + 20);
        if ( *(_DWORD *)(*(_DWORD *)(v270 + 20) + 20) >= *(_DWORD *)(v312 + 20) )
          goto LABEL_367;
        if ( *(_BYTE *)v271 == 2 )
        {
          if ( sub_1736DC(v312) )
          {
            if ( **(_BYTE **)(sub_26BC70(v152) + 24) == 2 )
            {
              v313 = sub_26BC70(v152);
              if ( sub_1736DC(*(_DWORD *)(*(_DWORD *)(v313 + 24) + 20)) )
              {
                v314 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v266 + 24) + 20) + 20);
                if ( v314 > *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(sub_26BC70(v152) + 24) + 20) + 20) )
                {
                  if ( sub_171B30(v266, &v334, &v335) )
                  {
                    v315 = 0;
                    v316 = v152;
                    v317 = sub_26BB80(v266);
                    while ( 1 )
                    {
                      v324 = v335 - v334;
                      if ( v335 - v334 < v315 )
                        break;
                      v318 = sub_25CE0C(
                               v316,
                               (unsigned __int64)(v335 - v334 - v315) >> 32,
                               v334 + v315,
                               (unsigned __int64)(v334 + v315) >> 32);
                      v319 = sub_2647C8(v312, v318);
                      v320 = (void *)(sub_26E954(v317) + *(_DWORD *)(v312 + 20) * v315);
                      v321 = (const void *)sub_26E738(v319);
                      memcpy(v320, v321, *(_DWORD *)(v312 + 20));
                      ++v315;
                    }
                    v152 = v317;
                    goto LABEL_191;
                  }
                  goto LABEL_459;
                }
                sub_94700(
                  (int)"ada-lang.c",
                  9801,
                  "%s: Assertion `%s' failed.",
                  "value* ada_promote_array_of_integrals(type*, value*)",
                  "TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > TYPE_LENGTH (TYPE_TARGET_TYPE (value_type (val)))");
              }
              sub_94700(
                (int)"ada-lang.c",
                9799,
                "%s: Assertion `%s' failed.",
                "value* ada_promote_array_of_integrals(type*, value*)",
                "is_integral_type (TYPE_TARGET_TYPE (value_type (val)))");
            }
            sub_94700(
              (int)"ada-lang.c",
              9798,
              "%s: Assertion `%s' failed.",
              "value* ada_promote_array_of_integrals(type*, value*)",
              "TYPE_CODE (value_type (val)) == TYPE_CODE_ARRAY");
          }
          sub_94700(
            (int)"ada-lang.c",
            9797,
            "%s: Assertion `%s' failed.",
            "value* ada_promote_array_of_integrals(type*, value*)",
            "is_integral_type (TYPE_TARGET_TYPE (type))");
        }
        v235 = sub_94700(
                 (int)"ada-lang.c",
                 9796,
                 "%s: Assertion `%s' failed.",
                 "value* ada_promote_array_of_integrals(type*, value*)",
                 "TYPE_CODE (type) == TYPE_CODE_ARRAY");
LABEL_454:
        sub_946E0("Attempt to take contents of a non-pointer value.", HIDWORD(v235));
      }
      return v328;
    case 24:
      v328 = sub_14C9EC(0, a2, a3, a4);
      v34 = sub_14C9EC(0, a2, a3, a4);
      v329 = v34;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( a4 == 2 )
        goto LABEL_244;
      v35 = sub_26BC70(v34);
      if ( sub_1736DC(v35) )
        sub_14CF98(*a2, a2[1], &v328);
      else
        sub_14CFF4(*a2, a2[1], &v328, &v329);
      return sub_25E4EC(v328, v329, 24);
    case 36:
      v91 = sub_14C9EC(0, a2, a3, a4);
      v92 = sub_14C9EC(0, a2, a3, a4);
      v93 = sub_14C9EC(0, a2, a3, a4);
      v94 = sub_26EA24(v92);
      v95 = sub_26EA24(v93);
      v96 = sub_26EB1C(v94);
      v97 = sub_26EB1C(v95);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( **(_BYTE **)(sub_26BC70(v91) + 24) == 18 )
      {
        v255 = sub_26BC70(v91);
        if ( sub_A2514(*(_DWORD *)(*(_DWORD *)(v255 + 24) + 20)) )
        {
          LODWORD(v327) = *(_DWORD *)(*(_DWORD *)(sub_26BC70(v91) + 24) + 20);
          v256 = *(_DWORD *)(sub_26BC70(v91) + 24);
          *(_DWORD *)(v256 + 20) = sub_A2E80(v327);
        }
      }
      v98 = sub_26BC70(v91);
      if ( sub_A0CFC(v98) )
        sub_946E0("cannot slice a packed array");
      if ( **(_BYTE **)(sub_26BC70(v91) + 24) == 18
        || **(_BYTE **)(sub_26BC70(v91) + 24) == 2 && *(_DWORD *)nullsub_31(v91) == 1 )
      {
        v91 = sub_2616BC(v91);
      }
      if ( a4 == 2 && (v230 = sub_26BC70(v91), v231 = sub_A0870(v230), sub_A0C94(v231)) )
      {
        v232 = sub_A83C4(v91, 0);
        return sub_A2354(v232, v96);
      }
      else
      {
        for ( j = sub_A8A3C(v91);
              **(_BYTE **)(sub_26BC70(j) + 24) == 1
           && **(_BYTE **)(*(_DWORD *)(*(_DWORD *)(sub_26BC70(j) + 24) + 20) + 24) == 1;
              j = sub_26210C(j) )
        {
          ;
        }
        v99 = sub_26BC70(j);
        if ( !v99 || !sub_A0A04(v99) )
          sub_946E0("cannot take slice of non-array");
        v100 = sub_26BC70(j);
        if ( **(_BYTE **)(sub_A0870(v100) + 24) == 1 )
        {
          v272 = sub_26BC70(j);
          v273 = *(_DWORD *)(sub_A0870(v272) + 24);
          v274 = v97 < v96;
          if ( a4 == 2 )
            v274 = 1;
          if ( v274 )
          {
            return sub_A2354(*(_DWORD *)(v273 + 20), v96);
          }
          else
          {
            v282 = sub_AA974(*(_DWORD *)(v273 + 20), 0);
            v283 = sub_26725C(v96, HIDWORD(v96));
            v284 = sub_26725C(v97, HIDWORD(v97));
            v285 = sub_A0870(v282);
            v286 = *(_DWORD *)(v285 + 24);
            v327 = v283;
            v287 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v286 + 24) + 12) + 24) + 20);
            v288 = sub_171928(0, v287, v327, HIDWORD(v327), v284, v284 >> 31);
            v289 = *(_DWORD *)(*(_DWORD *)(v285 + 24) + 20);
            v290 = sub_1710BC(3, v285);
            v291 = sub_171DD4(0, v289, v288, v290, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v285 + 24) + 24) + 8) >> 4);
            v292 = sub_9E8E8(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v285 + 24) + 24) + 12));
            if ( !sub_1707CC(v287, &v335, v327, HIDWORD(v327), &v335)
              || !sub_1707CC(v287, &v334, v292, v292 >> 31, &v334) )
            {
              sub_946B0("unable to get positions in slice, use bounds instead");
              v334 = v292;
              v335 = v327;
            }
            v293 = sub_26EBA8(j);
            return sub_260F84(v291, v293 + *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v285 + 24) + 20) + 20) * (v335 - v334));
          }
        }
        else if ( a4 != 2 )
        {
          if ( v97 >= v96 )
          {
            v242 = sub_26725C(v96, HIDWORD(v96));
            v243 = v242;
            v244 = sub_26725C(v97, HIDWORD(v97));
            v245 = sub_26BC70(j);
            v246 = sub_A0870(v245);
            v247 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v246 + 24) + 24) + 12);
            LODWORD(v327) = *(_DWORD *)(*(_DWORD *)(v247 + 24) + 20);
            v248 = sub_171928(0, v247, v242, v242 >> 31, v244, v244 >> 31);
            v249 = *(_DWORD *)(v246 + 24);
            LODWORD(v325) = v248;
            LODWORD(v326) = *(_DWORD *)(v249 + 20);
            v250 = sub_1710BC(3, v246);
            v251 = sub_171DD4(0, v326, v325, v250, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v246 + 24) + 24) + 8) >> 4);
            if ( sub_1707CC(v327, &v334, v242, v242 >> 31, &v334) && sub_1707CC(v327, v252, v244, v244 >> 31, &v335) )
            {
              v244 = v335;
              LODWORD(v243) = v334;
            }
            else
            {
              sub_946B0("unable to get positions in slice, use bounds instead");
              v334 = v242;
              v335 = v244;
            }
            v253 = sub_264570(j, v242, v244 + 1 - v243);
            return sub_2647C8(v251, v253);
          }
          else
          {
            v101 = sub_26BC70(j);
            return sub_A2354(v101, v96);
          }
        }
      }
      return j;
    case 40:
      *a3 = v6;
      if ( a4 != 1 )
      {
        v90 = v9[12];
        if ( (*(_BYTE *)(v90 + 32) & 7) != 0 )
        {
          if ( a4 != 2 )
          {
LABEL_110:
            v328 = sub_14E83C(a1, a2, a3, a4);
            return sub_AAF94(v328);
          }
          v50 = sub_A263C(*(_DWORD *)(v90 + 24));
          if ( sub_A2974(v50, "_tag", 0, 1) )
          {
LABEL_272:
            v204 = sub_14C9EC(0, a2, a3, 0);
            v205 = *(_BYTE **)(v50 + 24);
            v328 = v204;
            if ( *v205 == 18 )
            {
              v328 = sub_AB07C(v204);
              return ((int (__fastcall *)(int, int))loc_2618D4)(v328, 18);
            }
            else
            {
              v206 = sub_A93B4(v204, "_tag", 0);
              v207 = sub_A988C(v206);
              if ( !v207 )
                v207 = v50;
              return sub_260DBC(v207);
            }
          }
          v227 = *(char **)(v50 + 24);
          v228 = *v227;
          if ( v228 == 18 )
          {
            if ( sub_A2974(*((_DWORD *)v227 + 5), "_tag", 0, 1) )
              goto LABEL_272;
            v228 = **(char **)(v50 + 24);
          }
          if ( v228 == 3 )
          {
            if ( sub_A0ED8(v50) )
              goto LABEL_310;
            v228 = **(char **)(v50 + 24);
          }
          if ( v228 != 4 || !sub_A0E38(v50, "___XVU") )
            goto LABEL_110;
LABEL_310:
          v229 = *(_BYTE *)(*(_DWORD *)(v50 + 24) + 2);
          *a3 += 4;
          if ( (v229 & 8) == 0 )
            v50 = sub_A28F8(v50);
          return sub_260DBC(v50);
        }
        if ( !dword_46D448 )
        {
          v190 = *(const char **)v90;
          goto LABEL_254;
        }
LABEL_470:
        v190 = (const char *)sub_21B3C4(v90);
LABEL_254:
        sub_946E0("Unexpected unresolved symbol, %s, during evaluation", v190);
      }
      *a3 = v6 + 4;
      return sub_14DA0C(a2);
    case 46:
      *a3 = v6 + 3;
      v102 = sub_26725C(v9[8], v9[9]);
      v103 = *a3;
      LODWORD(v333) = v102;
      if ( a2[4 * v103 + 4] == 40 )
      {
        v189 = v9[24];
        if ( (*(_BYTE *)(v189 + 32) & 7) == 0 )
        {
          if ( !dword_46D448 )
          {
            v190 = *(const char **)v189;
            goto LABEL_254;
          }
          v90 = v9[24];
          goto LABEL_470;
        }
      }
      if ( v102 >= 0 )
      {
        v105 = &v323;
        v106 = 0;
        do
        {
          v107 = sub_14C9EC(0, a2, a3, a4);
          v108 = v333;
          ++v106;
          v105[1] = v107;
          ++v105;
        }
        while ( v108 >= v106 );
        v104 = (__int64 *)((char *)&v324 + 4 * v106);
      }
      else
      {
        v104 = &v324;
      }
      *(_DWORD *)v104 = 0;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      v109 = sub_26BC70(v324);
      v110 = sub_A0A60(v109);
      if ( sub_A0CFC(v110) )
      {
        v111 = sub_A8AAC(v324);
        LODWORD(v324) = v111;
      }
      else if ( **(_BYTE **)(sub_26BC70(v324) + 24) == 2
             && (*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(sub_26BC70(v324) + 24) + 24) + 8) & 0xFFFFFFF0) != 0 )
      {
        v111 = v324;
      }
      else if ( **(_BYTE **)(sub_26BC70(v324) + 24) == 18 )
      {
        v276 = sub_26EA24(v324);
        v111 = sub_AAF94(v276);
        LODWORD(v324) = v111;
      }
      else
      {
        v208 = *(_BYTE **)(sub_26BC70(v324) + 24);
        v111 = v324;
        if ( *v208 == 2 )
        {
          v209 = *(_DWORD *)nullsub_31(v324);
          v111 = v324;
          if ( v209 == 1 )
          {
            v111 = sub_2616BC(v324);
            LODWORD(v324) = v111;
          }
        }
      }
      v112 = sub_26BC70(v111);
      v113 = sub_A0870(v112);
      v114 = *(char **)(v113 + 24);
      v115 = v113;
      for ( k = *v114; k == 23; k = *v114 )
      {
        v115 = *((_DWORD *)v114 + 5);
        v114 = *(char **)(v115 + 24);
      }
      if ( k != 1 )
        goto LABEL_138;
      v257 = **(char **)(sub_A0870(*((_DWORD *)v114 + 5)) + 24);
      switch ( v257 )
      {
        case 3:
          if ( a4 != 2 )
            LODWORD(v324) = sub_AB378(v324);
          break;
        case 7:
          break;
        case 2:
          goto LABEL_372;
        default:
          v258 = sub_26BC70(v324);
          v259 = (const char *)v258;
          if ( v258 )
          {
            v260 = *(_DWORD *)(v258 + 24);
            v259 = *(const char **)(v260 + 8);
            if ( !v259 )
              v259 = *(const char **)(v260 + 12);
          }
          sub_946E0("cannot subscript or call something of type `%s'", v259);
      }
      v115 = sub_A0870(*(_DWORD *)(*(_DWORD *)(v115 + 24) + 20));
LABEL_372:
      v114 = *(char **)(v115 + 24);
      k = *v114;
LABEL_138:
      switch ( k )
      {
        case 1:
          if ( a4 == 2 )
          {
            v294 = sub_AA974(*((_DWORD *)v114 + 5), 0);
            v173 = sub_A1770(v294, v333);
            if ( !v173 )
LABEL_406:
              sub_946E0("element type of array unknown");
LABEL_249:
            v188 = sub_A2E80(v173);
            return sub_260DBC(v188);
          }
          v177 = v324;
          LODWORD(v327) = v333;
          v178 = sub_AB378(v324);
          v179 = sub_26BD30(v178);
          v180 = sub_171258(v179);
          v181 = *(_DWORD *)(v180 + 24);
          v182 = v180;
          if ( *(_BYTE *)v181 == 2 )
          {
            if ( (*(_DWORD *)(*(_DWORD *)(v181 + 24) + 8) & 0xFFFFFFF0) != 0 )
            {
              v184 = sub_A916C(v178, v327, (int)&v324 + 4);
              return sub_AAE94(v184);
            }
            if ( (int)v327 > 0 )
            {
              v302 = 1;
              while ( 1 )
              {
                v303 = sub_1700C0(*(_DWORD *)(v181 + 20));
                v304 = v303;
                v305 = sub_26C4E0(v177, HIDWORD(v303));
                v306 = sub_2647C8(v304, v305);
                sub_17195C(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v182 + 24) + 24) + 12), &v334, &v335);
                v307 = sub_26BC70(*((_DWORD *)&v324 + v302));
                sub_26DAF4(v307, HIDWORD(v307), v334, HIDWORD(v334));
                v308 = sub_9B510();
                v309 = sub_9B510();
                v177 = ((int (__fastcall *)(int, _DWORD, _DWORD, _DWORD))loc_25CA94)(
                         v306,
                         HIDWORD(v309),
                         v308 - v309,
                         (unsigned __int64)(v308 - v309) >> 32);
                v183 = v302;
                v182 = *(_DWORD *)(*(_DWORD *)(v182 + 24) + 20);
                if ( v302 == (_DWORD)v327 )
                  break;
                v181 = *(_DWORD *)(v182 + 24);
                ++v302;
                if ( *(_BYTE *)v181 != 2 )
                  goto LABEL_430;
              }
            }
          }
          else if ( (int)v327 > 0 )
          {
            v183 = 0;
LABEL_430:
            sub_946E0("too many subscripts (%d expected)", v183);
          }
          v184 = sub_26210C(v177);
          return sub_AAE94(v184);
        case 2:
          if ( a4 != 2 )
          {
            v175 = sub_A8AAC(v324);
            v176 = sub_A92F8(v175, v333, (int)&v324 + 4);
            return sub_AAE94(v176);
          }
          v173 = sub_A1770(v115, v333);
          if ( !v173 )
            goto LABEL_406;
          goto LABEL_249;
        case 3:
          v172 = sub_A15F8(v115);
          v173 = sub_A1770(v115, v333);
          if ( !v173 )
            sub_946E0("cannot subscript or call a record");
          if ( (_DWORD)v333 != v172 )
            sub_946E0("wrong number of subscripts; expecting %d", v172);
          if ( a4 == 2 )
            goto LABEL_249;
          v174 = sub_A92F8(v324, v333, (int)&v324 + 4);
          return sub_AAE94(v174);
        case 7:
          if ( a4 != 2 )
            return sub_17E6EC(v324, 0, v333, (char *)&v324 + 4);
          v37 = *((_DWORD *)v114 + 5);
          if ( !v37 )
            sub_17D5CC();
          return sub_26BB80(v37);
        case 27:
          v55 = a2[1];
          if ( a4 == 2 )
            goto LABEL_266;
          return ((int (__fastcall *)(int, _DWORD, _DWORD, _DWORD, char *))loc_26CD64)(
                   v55,
                   *a2,
                   v324,
                   v333,
                   (char *)&v324 + 4);
        default:
          sub_946E0("Attempt to index or call something other than an array or function");
      }
    case 50:
      *a3 = v6;
      j = sub_14E83C(a1, a2, a3, a4);
      if ( **(_BYTE **)(sub_26BC70(j) + 24) == 13 )
        **(_BYTE **)(sub_26BC70(j) + 24) = 2;
      return j;
    case 52:
      *a3 = v6 + 3;
      v57 = v9[8];
      if ( (v9[16] & 0xFFFFFFFD) == 0x28 )
      {
        *a3 = v6 + 7;
        if ( v9[16] == 42 )
        {
          if ( a4 == 2 )
            return sub_260DBC(v57);
          v58 = sub_14D68C(a4, v9[20], v9[24]);
        }
        else
        {
          v58 = sub_14D5E0(a4, v9[20], v9[24]);
        }
        if ( a4 == 1 )
          return sub_14DA0C(a2);
        j = sub_A3370(v57, v58);
        if ( *(_DWORD *)nullsub_31(j) == 1 )
        {
          if ( sub_26BF4C(j) )
            ((void (__fastcall *)(int))loc_26E00C)(j);
          *(_DWORD *)nullsub_31(j) = 0;
        }
      }
      else
      {
        v195 = sub_14C9EC(v9[8], a2, a3, a4);
        if ( a4 == 1 )
          return sub_14DA0C(a2);
        return sub_A3370(v57, v195);
      }
      return j;
    case 58:
      v29 = sub_14C9EC(0, a2, a3, a4);
      v328 = v29;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      v30 = sub_26BC70(v29);
      if ( sub_9AAB0(v30) )
      {
        v31 = sub_26BC70(v328);
        v32 = sub_25F2C0(v328);
        return sub_2647C8(v31, v32);
      }
      else
      {
        sub_14CF98(*a2, a2[1], &v328);
        return sub_25F2C0(v328);
      }
    case 61:
      LODWORD(v332) = v6 + 1;
      v21 = sub_14C9EC(0, a2, a3, a4);
      v328 = v21;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      v22 = sub_26BC70(v21);
      v23 = sub_A0870(v22);
      v24 = v23;
      if ( a4 != 2 )
      {
        v328 = sub_AB07C(v328);
        v25 = sub_26BC70(v328);
        v26 = sub_A0870(v25);
        if ( **(_BYTE **)(v26 + 24) == 8 )
        {
          if ( a1 )
          {
            v27 = sub_1700C0(a1);
            v28 = sub_2647C8(v27, v328);
            return sub_AB378(v28);
          }
          else
          {
            v280 = *(_DWORD *)(sub_1780B4(a2[1]) + 12);
            v281 = sub_26EBA8(v328);
            return sub_260F84(v280, v281);
          }
        }
        else if ( sub_A0C94(v26) )
        {
          return sub_A8AAC(v328);
        }
        else
        {
          return sub_AB378(v328);
        }
      }
      if ( sub_A0C94(v23) )
      {
        v279 = sub_A83C4(v328, 0);
        if ( !v279 )
          sub_946E0("Attempt to dereference null array pointer.");
        return sub_260F84(v279, 0);
      }
      v233 = *(char **)(v24 + 24);
      v234 = *v233;
      if ( v234 == 1 )
        goto LABEL_409;
      HIDWORD(v235) = v234 & 0xFFFFFFEF;
      if ( (v234 & 0xFFFFFFEF) != 2 )
      {
        if ( v234 != 8 )
          goto LABEL_454;
        if ( !a1 )
        {
          v310 = sub_1780B4(a2[1]);
          return sub_260DBC(*(_DWORD *)(v310 + 12));
        }
        v301 = sub_A2E80(a1);
        v238 = v301;
        if ( v301 && (*(_BYTE *)(*(_DWORD *)(v301 + 24) + 2) & 8) == 0 )
          v238 = sub_A28F8(v301);
        return sub_260DBC(v238);
      }
      if ( v234 != 18 )
        goto LABEL_321;
LABEL_409:
      if ( sub_A2974(*((_DWORD *)v233 + 5), "_tag", 0, 1) )
      {
        v328 = sub_14C9EC(0, a2, &v332, 0);
        v297 = sub_AB378(v328);
        v238 = sub_26BC70(v297);
      }
      else
      {
        v233 = *(char **)(v24 + 24);
LABEL_321:
        v236 = sub_A0870(*((_DWORD *)v233 + 5));
        v237 = sub_A2E80(v236);
        v238 = v237;
        if ( !v237 )
          __und(0);
        if ( (*(_BYTE *)(*(_DWORD *)(v237 + 24) + 2) & 8) == 0 )
          v238 = sub_A28F8(v237);
      }
      if ( *(_DWORD *)(v238 + 20) > (unsigned int)dword_477C84 )
        sub_946E0("object size is larger than varsize-limit");
      return sub_260DBC(v238);
    case 68:
      j = sub_14C9EC(0, a2, a3, a4);
      v328 = j;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      return j;
    case 72:
      v328 = sub_14C9EC(0, a2, a3, a4);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      sub_14CF98(*a2, a2[1], &v328);
      v42 = v328;
      v43 = sub_26BC70(v328);
      v44 = sub_260DBC(v43);
      if ( !sub_25F43C(v42, v44) )
        return v328;
      return sub_25F2C0(v328);
    case 81:
      v38 = *a3 + 3 + ((unsigned int)(sub_26725C(v9[8], v9[9]) + 16) >> 4);
      *a3 = v38;
      LODWORD(v332) = v38;
      v39 = sub_14C9EC(0, a2, a3, a4);
      v328 = v39;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      v40 = (char *)&a2[4 * v6 + 12];
      if ( a4 != 2 )
      {
        v41 = sub_A93B4(v39, v40, 0);
        v328 = sub_AAE94(v41);
        return sub_AAF94(v328);
      }
      v186 = sub_26BC70(v39);
      if ( sub_A2974(v186, "_tag", 1, 1) )
      {
        v187 = sub_A2974(v186, v40, 1, 1);
        if ( !v187 )
        {
          v298 = sub_14C9EC(0, a2, &v332, 0);
          v299 = sub_A93B4(v298, v40, 0);
          v328 = sub_AAE94(v299);
          v300 = sub_AAF94(v328);
          v187 = sub_26BC70(v300);
        }
      }
      else
      {
        v187 = sub_A2974(v186, v40, 1, 0);
      }
      v173 = v187;
      goto LABEL_249;
    case 88:
      *a3 = v6 + 3;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( a4 != 2 )
        sub_946E0("Attempt to use a type name as an expression");
      v37 = v9[8];
      return sub_26BB80(v37);
    case 89:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
      if ( !a4 )
      {
        if ( v10 != 89 )
        {
          if ( v10 == 113 )
            sub_946E0("Aggregates only allowed on the right of an assignment");
          sub_94700((int)"ada-lang.c", 11626, "aggregate apparently mangled");
        }
        sub_946E0(
          "Undefined name, ambiguous name, or renaming used in component association: %s.",
          (const char *)&a2[4 * v6 + 12]);
      }
      sub_9B138((int)a2, v6, &v335, (int *)&v333);
      v193 = (int)v333 <= 0;
      *a3 += v335 - 1;
      if ( !v193 )
      {
        v194 = 0;
        do
        {
          sub_AB878(0, a2, a3, a4);
          ++v194;
        }
        while ( (int)v333 > v194 );
      }
      return sub_14DA0C(a2);
    case 98:
      *a3 = v6 + 3;
      v328 = sub_14C9EC(0, a2, a3, a4);
      v329 = sub_14C9EC(0, a2, a3, a4);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( a4 == 2 )
      {
        v226 = sub_19462C(*a2, a2[1]);
        return sub_260DBC(v226);
      }
      v59 = sub_26725C(v9[8], v9[9]);
      v60 = sub_26BC70(v329);
      v61 = sub_A1680(v60, v59, "range");
      if ( !v61 )
        v61 = sub_26BC70(v328);
      v62 = sub_A8EE8(v329, v59, 1);
      LODWORD(v334) = sub_26DAF4(v61, v63, v62, v63);
      v64 = sub_A8EE8(v329, v59, 0);
      v329 = sub_26DAF4(v61, v65, v64, v65);
      goto LABEL_5;
    case 99:
      v328 = sub_14C9EC(0, a2, a3, a4);
      v329 = sub_14C9EC(0, a2, a3, a4);
      LODWORD(v334) = sub_14C9EC(0, a2, a3, a4);
      if ( a4 != 1 )
        goto LABEL_5;
      return sub_14DA0C(a2);
    case 100:
    case 101:
    case 102:
      if ( v9[8] == 88 )
      {
        sub_14C9EC(0, a2, a3, 1);
        v192 = v9[12];
        v328 = 0;
        v50 = sub_171258(v192);
      }
      else
      {
        v50 = 0;
        v328 = sub_14C9EC(0, a2, a3, a4);
      }
      v66 = &a2[4 * *a3];
      if ( v66[4] != 38 )
        sub_946E0("Invalid operand to '%s", *(const char **)&asc_373FF8[4 * v10 - 332]);
      v67 = sub_26725C(v66[12], v66[13]);
      *a3 += 4;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( v50 )
      {
        v68 = *(char **)(v50 + 24);
        v69 = *v68;
        switch ( *v68 )
        {
          case 5:
          case 8:
          case 12:
          case 21:
            if ( (*((_DWORD *)v68 + 2) || *((_DWORD *)v68 + 3)) && v69 != 5 )
            {
              v164 = ((int (__fastcall *)(int, _DWORD))loc_A7D90)(v50, 0);
              if ( v164 )
                v50 = v164;
            }
            if ( v10 == 101 )
            {
              LODWORD(v51) = sub_9E7EC(v50);
            }
            else
            {
              if ( v10 == 102 )
                sub_946E0("the 'length attribute applies only to array types");
              LODWORD(v51) = sub_9E8E8(v50);
            }
            return sub_26DAF4(v50, HIDWORD(v51), v51, HIDWORD(v51));
          default:
            if ( v69 == 9 )
              sub_946E0("unimplemented type attribute");
            if ( sub_A0CFC(v50) )
              v50 = sub_A8280(v50);
            if ( v10 == 102 )
            {
              v165 = *(_DWORD *)(sub_1780B4(a2[1]) + 12);
              if ( a4 != 2 )
              {
                v166 = sub_A86F8(v50, v67, 0);
                v168 = v167;
                LODWORD(v169) = sub_A86F8(v50, v67, 1);
                return sub_26DAF4(v165, HIDWORD(v169), (int)v169 - v166 + 1, (v169 - __PAIR64__(v168, v166) + 1) >> 32);
              }
            }
            else
            {
              v165 = sub_A1680(v50, v67, *(const char **)&asc_373FF8[4 * v10 - 332]);
              if ( !v165 )
                v165 = *(_DWORD *)(sub_1780B4(a2[1]) + 12);
              if ( a4 != 2 )
              {
                v223 = sub_A86F8(v50, v67, v10 == 101);
                return sub_26DAF4(v165, v224, v223, v224);
              }
            }
            j = sub_26BB80(v165);
            break;
        }
        return j;
      }
      v328 = sub_AB07C(v328);
      v254 = sub_26BC70(v328);
      if ( sub_A0CFC(v254) )
        v328 = sub_A8AAC(v328);
      if ( v10 == 102 )
      {
        v50 = *(_DWORD *)(sub_1780B4(a2[1]) + 12);
        if ( a4 != 2 )
        {
          LODWORD(v51) = sub_A8FD4(v328, v67);
          return sub_26DAF4(v50, HIDWORD(v51), v51, HIDWORD(v51));
        }
      }
      else
      {
        v275 = sub_26BC70(v328);
        v50 = sub_A1680(v275, v67, *(const char **)&asc_373FF8[4 * v10 - 332]);
        if ( !v50 )
          v50 = *(_DWORD *)(sub_1780B4(a2[1]) + 12);
        if ( a4 != 2 )
        {
          LODWORD(v51) = sub_A8EE8(v328, v67, v10 == 101);
          return sub_26DAF4(v50, HIDWORD(v51), v51, HIDWORD(v51));
        }
      }
      return sub_26BB80(v50);
    case 104:
    case 105:
      sub_14C9EC(0, a2, a3, 1);
      v328 = sub_14C9EC(0, a2, a3, a4);
      v329 = sub_14C9EC(0, a2, a3, a4);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( a4 == 2 )
        goto LABEL_244;
      sub_14CFF4(*a2, a2[1], &v328, &v329);
      if ( v10 == 105 )
        v33 = 25;
      else
        v33 = 26;
      return sub_25E4EC(v328, v329, v33);
    case 106:
      v70 = sub_171258(v9[12]);
      sub_14C9EC(0, a2, a3, 1);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( !sub_A341C(v70) )
        sub_946E0("'modulus must be applied to modular type");
      v72 = *(_DWORD *)(v70 + 24);
      v73 = *(_DWORD *)(v72 + 20);
      v74 = *(_QWORD *)(*(_DWORD *)(v72 + 24) + 24) + 1LL;
      return sub_26DAF4(v73, v71, v74, HIDWORD(v74));
    case 107:
      sub_14C9EC(0, a2, a3, 1);
      v328 = sub_14C9EC(0, a2, a3, a4);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      v50 = *(_DWORD *)(sub_1780B4(a2[1]) + 12);
      if ( a4 == 2 )
        return sub_260DBC(v50);
      v51 = sub_9B510();
      return sub_26DAF4(v50, HIDWORD(v51), v51, HIDWORD(v51));
    case 108:
      v328 = sub_14C9EC(0, a2, a3, a4);
      v52 = sub_26BC70(v328);
      v53 = *(_DWORD *)(v52 + 24);
      v54 = v52;
      if ( *(_BYTE *)v53 == 18 )
        v54 = *(_DWORD *)(v53 + 20);
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      v55 = a2[1];
      if ( a4 == 2 )
      {
LABEL_266:
        v197 = sub_1780B4(v55);
        return sub_260DBC(*(_DWORD *)(v197 + 12));
      }
      else
      {
        v56 = sub_1780B4(v55);
        return sub_26DAF4(*(_DWORD *)(v56 + 12), HIDWORD(v56), 8 * *(_DWORD *)(v54 + 20), 0);
      }
    case 109:
      v36 = sub_14C9EC(0, a2, a3, a4);
      v328 = v36;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      if ( a4 != 2 )
        return sub_A93B4(v36, "_tag", 0);
      v222 = sub_A2DAC(v36);
      return sub_260DBC(v222);
    case 110:
      sub_14C9EC(0, a2, a3, 1);
      v47 = sub_14C9EC(0, a2, a3, a4);
      v48 = v47;
      v328 = v47;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      v49 = v9[12];
      if ( a4 != 2 )
      {
        if ( v49 )
        {
          switch ( **(_BYTE **)(v49 + 24) )
          {
            case 5:
            case 8:
            case 0xC:
            case 0x15:
              v170 = sub_26BC70(v47);
              if ( !sub_9A3D8(v170) )
                sub_946E0("'VAL requires integral argument");
              if ( **(_BYTE **)(v49 + 24) == 5 )
              {
                v239 = sub_26EB1C(v48);
                if ( (int)v239 < 0 || (v240 = *(_DWORD *)(v49 + 24), (int)v239 >= *(__int16 *)(v240 + 4)) )
                  sub_946E0("argument to 'VAL out of range", HIDWORD(v239));
                v241 = *(_QWORD *)(*(_DWORD *)(v240 + 24) + 24 * v239);
                return sub_26DAF4(v49, HIDWORD(v239), v241, HIDWORD(v241));
              }
              else
              {
                v171 = sub_26EB1C(v48);
                return sub_26DAF4(v49, HIDWORD(v171), v171, HIDWORD(v171));
              }
            default:
              break;
          }
        }
        sub_946E0("'VAL only defined on discrete types");
      }
      return sub_260DBC(v9[12]);
    case 111:
      *a3 = v6 + 3;
      return sub_AB878(v9[8], a2, a3, a4);
    case 112:
      *a3 = v6 + 3;
      v328 = sub_14C9EC(0, a2, a3, a4);
      v11 = sub_171258(v9[8]);
      v12 = v11;
      if ( a4 == 1 )
        return sub_14DA0C(a2);
      v13 = *(_DWORD *)(v11 + 24);
      if ( *(_BYTE *)v13 == 12 )
      {
        v14 = sub_26DAF4(
                v11,
                HIDWORD(v11),
                *(_DWORD *)(*(_DWORD *)(v13 + 24) + 8),
                *(_DWORD *)(*(_DWORD *)(v13 + 24) + 12));
        v15 = *(_DWORD *)(v12 + 24);
        v329 = v14;
        LODWORD(v334) = sub_26DAF4(
                          v12,
                          HIDWORD(v14),
                          *(_DWORD *)(*(_DWORD *)(v15 + 24) + 24),
                          *(_DWORD *)(*(_DWORD *)(v15 + 24) + 28));
LABEL_5:
        sub_14CFF4(*a2, a2[1], &v328, &v329);
        sub_14CFF4(*a2, a2[1], &v328, &v334);
        v16 = sub_19462C(*a2, a2[1]);
        if ( sub_25F43C(v328, v334) || (v18 = sub_25E07C(v328, v334)) != 0 )
        {
          if ( sub_25F43C(v329, v328) )
            v18 = 1;
          else
            v18 = sub_25E07C(v329, v328) != 0;
        }
        return sub_26DAF4(v16, v17, v18, 0);
      }
      else
      {
        sub_9B398((int)"Membership test incompletely implemented; always returns true", HIDWORD(v11));
        v196 = sub_19462C(*a2, a2[1]);
        return sub_26DAF4(v196, HIDWORD(v196), 1, 0);
      }
    default:
      *a3 = v6;
      v162 = sub_14E83C(a1, a2, a3, a4);
      j = v162;
      v328 = v162;
      if ( !a4 )
      {
        j = sub_AAE94(v162);
        v328 = j;
      }
      v163 = (unsigned int)(v10 - 38) <= 1;
      if ( !a1 )
        v163 = 0;
      if ( v163 )
        return sub_A3370(a1, j);
      return j;
  }
}
