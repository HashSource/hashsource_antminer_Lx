void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  const char *v3; // r8
  FILE *v4; // r9
  size_t v5; // r0
  FILE *v6; // r0
  size_t v7; // r6
  int v8; // r9
  char *v9; // r7
  size_t i; // r5
  const unsigned __int16 **v11; // r0
  int v12; // t1
  int v13; // r3
  int v14; // r6
  int v15; // r0
  int (*v16)(void); // r2
  int (**v17)(); // r3
  bool v18; // zf
  int v19; // r0
  char *v20; // r0
  int v21; // r3
  char *v22; // r5
  char *v23; // r7
  int v24; // r6
  const char **v25; // r8
  const char *v26; // t1
  char *v27; // r0
  int v28; // r6
  const char *v29; // r0
  char *v30; // r0
  char *v31; // r8
  char *v32; // r7
  char *v33; // r0
  size_t v34; // r0
  unsigned __int8 *v35; // r12
  char *v36; // r5
  size_t v37; // r0
  unsigned int v38; // r6
  unsigned int v39; // r7
  int v40; // r12
  int v41; // r3
  unsigned __int8 *v42; // r10
  unsigned int v43; // r2
  unsigned __int8 *v44; // r0
  int v45; // r1
  unsigned int v46; // r8
  unsigned int v47; // r12
  int v48; // r3
  unsigned int v49; // r2
  unsigned int v50; // r12
  int v51; // r3
  unsigned int v52; // r7
  unsigned int v53; // r12
  char *v54; // r2
  unsigned int v55; // r12
  int v56; // r3
  unsigned int v57; // r7
  unsigned int v58; // r2
  int v59; // r3
  unsigned int v60; // r1
  unsigned int v61; // r2
  unsigned int v62; // r3
  unsigned int v63; // r6
  size_t v64; // r0
  unsigned __int8 *v65; // r3
  int v66; // r7
  int v67; // r3
  char *v68; // r8
  int v69; // r3
  int v70; // r6
  int v71; // r2
  _DWORD *v72; // r2
  int v73; // r1
  int v74; // r3
  _DWORD *v75; // r8
  int v76; // r1
  char *v77; // r9
  __int64 *v78; // r3
  __int64 v79; // r0
  _DWORD *v80; // r7
  _DWORD *v81; // r6
  int v82; // r5
  char *v83; // r2
  unsigned int v84; // r3
  int v85; // r1
  int v86; // r3
  int v87; // r3
  _DWORD *v88; // r3
  unsigned int v89; // r2
  unsigned int v90; // r1
  bool v91; // cc
  int v92; // r2
  int v93; // r3
  _BYTE *v94; // r6
  _DWORD *v95; // r0
  char *v96; // r3
  _DWORD *v97; // r2
  int *v98; // r3
  int v99; // r0
  int v100; // r1
  __int16 v101; // r3
  int v102; // r3
  int v103; // r3
  char *v104; // r9
  int v105; // r5
  _BYTE *v106; // r6
  _BYTE *v107; // r0
  unsigned __int8 *v108; // r1
  int v109; // r5
  const char *v110; // r1
  const char *v111; // r1
  const char *v112; // r5
  const char *v113; // r3
  int v114; // r3
  int v115; // r4
  int v116; // r2
  int v117; // r6
  int v118; // r5
  pthread_rwlock_t *v119; // r0
  char *v120; // r0
  int v121; // r9
  unsigned int v122; // r7
  char *j; // r0
  char v124; // r3
  char *v125; // r12
  const char *v126; // r0
  int v127; // r0
  bool v128; // zf
  int v129; // r0
  int v130; // r3
  int v131; // r3
  int v132; // r5
  unsigned __int8 *v133; // r7
  int v134; // r0
  int v135; // r3
  int v136; // r3
  char *v137; // r7
  int v138; // r5
  int v139; // r0
  int v140; // r3
  void *v141; // r0
  void **v142; // r9
  void *v143; // r0
  char *v144; // r12
  int *v145; // lr
  int v146; // r0
  int v147; // r1
  int v148; // r2
  int v149; // r3
  _DWORD *v150; // r12
  _DWORD *v151; // lr
  int v152; // r1
  const char *v153; // r1
  int v154; // r0
  int v155; // r3
  int v156; // r0
  int v157; // r1
  int v158; // r12
  int v159; // r3
  int v160; // r1
  int v161; // r12
  int k; // r3
  int v163; // r2
  int m; // r6
  _DWORD *v165; // r3
  int v166; // r4
  int v167; // r3
  const char *v168; // r0
  size_t v169; // r5
  size_t v170; // r5
  char *v171; // r0
  const char *v172; // r3
  char *v173; // r6
  __sighandler_t v174; // r4
  __sighandler_t v175; // r0
  bool v176; // zf
  __pid_t v177; // r0
  __pid_t v178; // r4
  size_t v179; // r0
  int n; // r5
  int v181; // r8
  const char *v182; // r8
  const char *v183; // r4
  const char *v184; // r10
  char *v185; // r8
  const char *v186; // r5
  _DWORD *v187; // r0
  int v188; // r2
  const char **v189; // r0
  sem_t *v190; // r7
  const char *v191; // r6
  char *v192; // r3
  int *v193; // r10
  int *v194; // r9
  char *v195; // r4
  int *v196; // r0
  int v197; // r12
  char *v198; // r1
  int v199; // r0
  int v200; // lr
  int v201; // r5
  int v202; // r5
  int v203; // r3
  int v204; // r3
  int v205; // r5
  int *v206; // r0
  int v207; // r2
  int v208; // r3
  int v209; // r1
  char *v210; // r5
  unsigned __int8 *v211; // r4
  pthread_mutex_t *v212; // r0
  int v213; // r3
  int v214; // r1
  int v215; // r3
  void **v216; // r0
  int v217; // r0
  unsigned __int8 *v218; // r8
  int v219; // r3
  int v220; // r1
  int v221; // r3
  void **v222; // r0
  int v223; // r0
  unsigned __int8 *v224; // r8
  int v225; // r3
  int ii; // r3
  _DWORD *v227; // r12
  int v228; // r3
  int v229; // r3
  char *v230; // r10
  int v231; // r1
  int v232; // r3
  int v233; // r12
  int v234; // r0
  int v235; // r3
  int v236; // r5
  int jj; // r10
  int v238; // r0
  unsigned __int8 *v239; // r1
  void **v240; // r8
  char *v241; // r1
  void **v242; // r3
  int v243; // r3
  const char *v244; // lr
  char *v245; // r12
  int v246; // r0
  int v247; // r1
  int v248; // r2
  int v249; // r3
  _DWORD *v250; // lr
  _DWORD *v251; // r12
  int v252; // r1
  int v253; // r2
  int kk; // r3
  _DWORD *v255; // r12
  int v256; // r3
  int mm; // r3
  int v258; // r3
  int v259; // r10
  int v260; // r1
  int v261; // r3
  int v262; // r0
  int v263; // r0
  int nn; // r10
  int v265; // r0
  unsigned __int8 *v266; // r1
  unsigned __int8 *v267; // r1
  int *v268; // r0
  void **v269; // r10
  struct timeval *v270; // r8
  void **v271; // r3
  int *v272; // r0
  int v273; // r0
  int v274; // r1
  int v275; // r3
  int v276; // r12
  int v277; // r4
  int v278; // r3
  const char **v279; // r8
  int v280; // r7
  int v281; // r3
  pthread_mutex_t *v282; // r0
  int v283; // r7
  int *v284; // r0
  int *v285; // r0
  int i1; // r4
  char v287; // [sp+10h] [bp-2A34h] BYREF
  char v288[4088]; // [sp+1018h] [bp-1A2Ch] BYREF
  const char *v289; // [sp+2010h] [bp-A34h]
  int *v290; // [sp+2020h] [bp-A24h]
  char *v291; // [sp+2024h] [bp-A20h]
  char *v292; // [sp+2028h] [bp-A1Ch]
  int *v293; // [sp+202Ch] [bp-A18h]
  int v294; // [sp+2030h] [bp-A14h]
  __int16 *v295; // [sp+2034h] [bp-A10h]
  const char *v296; // [sp+2038h] [bp-A0Ch]
  char *v297; // [sp+203Ch] [bp-A08h]
  char *v298; // [sp+2040h] [bp-A04h]
  int *v299; // [sp+2044h] [bp-A00h]
  char *v300; // [sp+2048h] [bp-9FCh]
  unsigned __int8 *v301; // [sp+204Ch] [bp-9F8h]
  char *format; // [sp+2050h] [bp-9F4h]
  const char **v303; // [sp+2054h] [bp-9F0h]
  int v304; // [sp+2058h] [bp-9ECh]
  int v305; // [sp+205Ch] [bp-9E8h] BYREF
  void **v306; // [sp+2060h] [bp-9E4h] BYREF
  char dest[32]; // [sp+2064h] [bp-9E0h] BYREF
  struct sigaction s; // [sp+2084h] [bp-9C0h] BYREF
  char v309[256]; // [sp+2110h] [bp-934h] BYREF
  int v310[513]; // [sp+2210h] [bp-834h] BYREF

  byte_68AAC = 0;
  v305 = a1;
  v3 = *a2;
  v303 = a2;
  v299 = (int *)&byte_68AAC;
  v306 = 0;
  memset(v309, 0, sizeof(v309));
  memset(&s, 0, 0x40u);
  snprintf((char *)&s, 0x40u, "pidof %s", v3);
  v4 = popen((const char *)&s, "r");
  if ( v4 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          if ( !fgets(v309, 256, v4) )
          {
            v6 = v4;
            v7 = 0;
            v8 = 0;
            pclose(v6);
            v9 = v309;
            for ( i = 1; strlen(v309) >= i; ++i )
            {
              memset(dest, 0, sizeof(dest));
              v11 = _ctype_b_loc();
              v12 = (unsigned __int8)*v9++;
              if ( ((*v11)[v12] & 0x2000) != 0 )
              {
                strncpy(dest, &v309[v7], i - v7 - 1);
                v13 = strtol(dest, 0, 10);
                if ( v13 > 0 && (++v8, byte_68BD5) && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                {
                  snprintf((char *)v310, 0x800u, "Parsed proc id is: %d\n", v13);
                  v7 = i;
                  sub_20F58(7, (const char *)v310, 0);
                }
                else
                {
                  v7 = i;
                }
              }
            }
            if ( v8 )
            {
              if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
              {
                snprintf((char *)v310, 0x800u, " %d instance of %s is  already Running on this machine", v8, v3);
                sub_20F58(3, (const char *)v310, 0);
              }
              if ( v8 != 1 )
              {
                snprintf((char *)v310, 0x800u, "%s is forbidden to start twice, will exit immediately!", *v303);
                sub_20F58(3, (const char *)v310, 1);
                sub_2E6B0(-1, 0);
              }
            }
            goto LABEL_34;
          }
        }
        while ( !byte_68BD5 );
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
          break;
LABEL_9:
        if ( byte_68BD4 || dword_67DB4 > 6 )
        {
LABEL_11:
          v5 = strlen(v309);
          snprintf((char *)v310, 0x800u, "strlen is: %d\n", v5);
          sub_20F58(7, (const char *)v310, 0);
        }
      }
      snprintf((char *)v310, 0x800u, "pidof %s command result is: %s\n", v3, v309);
      sub_20F58(7, (const char *)v310, 0);
      if ( byte_68BD5 )
      {
        if ( byte_74500 )
          goto LABEL_11;
        goto LABEL_9;
      }
    }
  }
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf((char *)v310, 0x800u, " app-service:%s Not Found!!!", v3);
    sub_20F58(7, (const char *)v310, 0);
  }
LABEL_34:
  strcpy((char *)&dword_68AD4, "bmminer.log");
  strcpy((char *)&word_68AB4, "a+");
  v297 = (char *)&word_68AB4;
  LOWORD(v14) = (unsigned __int16)byte_68BD8;
  v15 = sysconf(84);
  v18 = v15 == 1;
  if ( v15 == 1 )
  {
    v17 = &off_67ED8;
    v16 = sched_yield;
  }
  v19 = v305 + 1;
  if ( v18 )
    *v17 = v16;
  HIWORD(v14) = (unsigned int)byte_68BD8 >> 16;
  v304 = v14;
  v20 = (char *)sub_229BC(4 * v19, "cgminer.c", "main", 11819);
  v21 = v305;
  v22 = v20;
  *(_DWORD *)(v14 + 0x47C) = v20;
  if ( v21 > 0 )
  {
    v23 = v20 - 4;
    v24 = 0;
    v25 = v303 - 1;
    do
    {
      v26 = v25[1];
      ++v25;
      ++v24;
      *((_DWORD *)v23 + 1) = _strdup(v26);
      v23 += 4;
      v21 = v305;
    }
    while ( v305 > v24 );
  }
  *(_DWORD *)&v22[4 * v21] = 0;
  sub_2EE90(&stru_76838, "main", 11828);
  sub_2EE90(&stru_767C8, "main", 11829);
  sub_2EE90(&stru_766E4, "main", 11830);
  sub_2EF3C((int)&stru_7453C, "main", 11831);
  sub_2EE90(&stru_766C4, "main", 11832);
  v301 = byte_6ABD0;
  sub_2EE90(&stru_6918C, "main", 11833);
  sub_2EF3C((int)&stru_74504, "main", 11834);
  sub_2EE90(&stru_690F0, "main", 11835);
  sub_2EF14(&stru_6A6C0, "main", 11836);
  sub_2EF14(&stru_755A0, "main", 11837);
  sub_2EF14(&stru_744A8, "main", 11838);
  sub_2EF14(&stru_7680C, "main", 11839);
  sub_2EE90(&stru_6910C, "main", 11841);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v310, "Failed to pthread_cond_init lp_cond");
    sub_20F58(3, (const char *)v310, 1);
    sub_2E6B0(1, 0);
  }
  sub_2EE90(&stru_767F4, "main", 11848);
  if ( pthread_cond_init(&stru_76700, 0) )
  {
    strcpy((char *)v310, "Failed to pthread_cond_init restart_cond");
    sub_20F58(3, (const char *)v310, 1);
    sub_2E6B0(1, 0);
  }
  v298 = (char *)pthread_cond_init(&stru_744D0, 0);
  if ( v298 )
  {
    strcpy((char *)v310, "Failed to pthread_cond_init gws_cond");
    sub_20F58(3, (const char *)v310, 1);
    sub_2E6B0(1, 0);
  }
  v27 = sub_23300();
  dword_755E0 = (int)v27;
  if ( !v27 )
  {
    strcpy((char *)v310, "Failed to create getq");
    sub_20F58(3, (const char *)v310, 1);
    sub_2E6B0(1, 0);
  }
  v289 = a10;
  *(_DWORD *)(v304 + 0x438) = v27 + 12;
  snprintf(::s, 0x100u, "%s %s", "cgminer", v289);
  s.sa_handler = (__sighandler_t)sub_2E78C;
  s.sa_flags = (int)v298;
  v296 = (const char *)&dword_755C4;
  sigemptyset(&s.sa_mask);
  sigaction(15, &s, &stru_755F8);
  sigaction(2, &s, &stru_76730);
  sigaction(6, &s, &stru_733D0);
  dword_755C4 = (int)v288;
  strcpy(v288, "/usr/bin");
  v28 = 36;
  dword_7557C = (int)&v287;
  v29 = *v303;
  v295 = &word_51DD8;
  v30 = _strdup(v29);
  v31 = (char *)dword_7557C;
  v32 = v30;
  v33 = dirname(v30);
  strcpy(v31, v33);
  free(v32);
  v34 = strlen((const char *)dword_7557C);
  v35 = v301;
  *(_WORD *)(dword_7557C + v34) = 47;
  *(_DWORD *)&v35[-644] = 9;
  v36 = (char *)sub_22A44(0x68u, 1u, "cgminer.c", "main", 11895);
  do
  {
    v37 = strlen(v36);
    --v28;
    *(_WORD *)&v36[v37] = 48;
  }
  while ( v28 );
  v38 = v37 + 1;
  v39 = -1640531527;
  v40 = -17973521;
  format = (char *)(v37 + 1);
  v41 = -1640531527;
  if ( v37 + 1 <= 0xB )
  {
    v44 = (unsigned __int8 *)v36;
    v54 = format;
  }
  else
  {
    v42 = (unsigned __int8 *)(v36 + 12);
    v300 = v36;
    do
    {
      v38 -= 12;
      v43 = (*(v42 - 6) << 16) + (*(v42 - 7) << 8) + *(v42 - 8) + (*(v42 - 5) << 24) + v39;
      v44 = v42;
      v45 = (*(v42 - 2) << 16) + (*(v42 - 3) << 8) + *(v42 - 4) + (*(v42 - 1) << 24);
      v46 = (*(v42 - 10) << 16) + (*(v42 - 11) << 8) + *(v42 - 12) + (*(v42 - 9) << 24) - v43;
      v42 += 12;
      v47 = v45 + v40;
      v48 = (v46 - v47 + v41) ^ (v47 >> 13);
      v49 = (v43 - v47 - v48) ^ (v48 << 8);
      v50 = (v47 - v48 - v49) ^ (v49 >> 13);
      v51 = (v48 - v49 - v50) ^ (v50 >> 12);
      v52 = (v49 - v50 - v51) ^ (v51 << 16);
      v53 = (v50 - v51 - v52) ^ (v52 >> 5);
      v41 = (v51 - v52 - v53) ^ (v53 >> 3);
      v39 = (v52 - v53 - v41) ^ (v41 << 10);
      v40 = (v53 - v41 - v39) ^ (v39 >> 15);
    }
    while ( v38 > 0xB );
    v36 = v300;
    v54 = (char *)v38;
  }
  v55 = (unsigned int)&format[v40];
  switch ( (unsigned int)v54 )
  {
    case 1u:
      goto LABEL_62;
    case 2u:
      goto LABEL_61;
    case 3u:
      goto LABEL_60;
    case 4u:
      goto LABEL_59;
    case 5u:
      goto LABEL_58;
    case 6u:
      goto LABEL_57;
    case 7u:
      goto LABEL_56;
    case 8u:
      goto LABEL_55;
    case 9u:
      goto LABEL_54;
    case 0xAu:
      goto LABEL_53;
    case 0xBu:
      v55 += v44[10] << 24;
LABEL_53:
      v55 += v44[9] << 16;
LABEL_54:
      v55 += v44[8] << 8;
LABEL_55:
      v39 += v44[7] << 24;
LABEL_56:
      v39 += v44[6] << 16;
LABEL_57:
      v39 += v44[5] << 8;
LABEL_58:
      v39 += v44[4];
LABEL_59:
      v41 += v44[3] << 24;
LABEL_60:
      v41 += v44[2] << 16;
LABEL_61:
      v41 += v44[1] << 8;
LABEL_62:
      v41 += *v44;
      break;
    default:
      break;
  }
  *((_DWORD *)v36 + 22) = v36;
  v56 = (v41 - v39 - v55) ^ (v55 >> 13);
  v57 = (v39 - v55 - v56) ^ (v56 << 8);
  v58 = (v55 - v56 - v57) ^ (v57 >> 13);
  v59 = (v56 - v57 - v58) ^ (v58 >> 12);
  v60 = (v57 - v58 - v59) ^ (v59 << 16);
  v61 = (v58 - v59 - v60) ^ (v60 >> 5);
  v62 = v59 - v60 - v61;
  v63 = (v61 - (v62 ^ (v61 >> 3)) - ((v60 - v61 - (v62 ^ (v61 >> 3))) ^ ((v62 ^ (v61 >> 3)) << 10)))
      ^ (((v60 - v61 - (v62 ^ (v61 >> 3))) ^ ((v62 ^ (v61 >> 3)) << 10)) >> 15);
  *((_DWORD *)v36 + 24) = v63;
  v64 = strlen(v36);
  v65 = v301;
  *((_DWORD *)v36 + 23) = v64;
  v66 = *(_DWORD *)&v65[-1264];
  if ( v66 )
  {
    v67 = *(_DWORD *)(v66 + 68);
    *((_DWORD *)v36 + 19) = 0;
    v68 = v36 + 68;
    *((_DWORD *)v36 + 17) = v67;
    *((_DWORD *)v36 + 18) = *(_DWORD *)(*(_DWORD *)(v66 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v66 + 68) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v66 + 68) + 16) + 8) = v36;
    *(_DWORD *)(*(_DWORD *)(v66 + 68) + 16) = v36 + 68;
  }
  else
  {
    *((_DWORD *)v36 + 19) = 0;
    *((_DWORD *)v36 + 18) = 0;
    *(_DWORD *)&v65[-1264] = v36;
    v141 = malloc(0x2Cu);
    *((_DWORD *)v36 + 17) = v141;
    if ( !v141 )
      goto LABEL_184;
    memset(v141, 0, 0x2Cu);
    v68 = v36 + 68;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 16) = v36 + 68;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 4) = 32;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 8) = 5;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 20) = 68;
    v142 = (void **)*((_DWORD *)v36 + 17);
    *v142 = malloc(0x180u);
    v143 = (void *)**((_DWORD **)v36 + 17);
    if ( !v143 )
      goto LABEL_184;
    memset(v143, 0, 0x180u);
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 40) = -1609490463;
  }
  v69 = *(_DWORD *)&v301[-1264];
  ++*(_DWORD *)(*(_DWORD *)(v69 + 68) + 12);
  v70 = 12 * (v63 & (*(_DWORD *)(*(_DWORD *)(v69 + 68) + 4) - 1));
  ++*(_DWORD *)(**(_DWORD **)(v69 + 68) + v70 + 4);
  v71 = *(_DWORD *)(**(_DWORD **)(v69 + 68) + v70);
  *((_DWORD *)v36 + 20) = 0;
  *((_DWORD *)v36 + 21) = v71;
  v72 = *(_DWORD **)(v69 + 68);
  v73 = *(_DWORD *)(*v72 + v70);
  if ( v73 )
  {
    *(_DWORD *)(v73 + 12) = v68;
    v72 = *(_DWORD **)(v69 + 68);
  }
  *(_DWORD *)(*v72 + v70) = v68;
  if ( *(_DWORD *)(**(_DWORD **)(v69 + 68) + v70 + 4) < (unsigned int)(10
                                                                     * *(_DWORD *)(**(_DWORD **)(v69 + 68) + v70 + 8)
                                                                     + 10)
    || (v74 = *((_DWORD *)v36 + 17), *(_DWORD *)(v74 + 36) == 1) )
  {
LABEL_86:
    strcpy(byte_73324, v36);
    dword_767C0 = (int)&dword_767C0;
    dword_767C4 = (int)&dword_767C0;
    sub_409F8((int)&off_67FE0, (int)"Options for both config file and command line");
    sub_409F8((int)&off_68760, (int)"Options for command line only");
    sub_40ACC(&v305, v303, (void (*)(const char *, ...))sub_2AA90);
    if ( v305 != 1 )
    {
      qmemcpy(v310, "Unexpected extra commandline arguments", 38);
      v124 = aUnexpectedExtr[38];
      v125 = (char *)&v310[9] + 2;
      goto LABEL_142;
    }
    if ( !*(_BYTE *)(v304 + 0x324) )
      sub_2D8F0();
    v18 = *(_BYTE *)(v304 + 0x5A4) == 0;
    v300 = (char *)&dword_766C0;
    if ( !v18 || dword_766C0 )
    {
      v94 = sub_324B8();
      v95 = sub_229BC(0xFFu, "cgminer.c", "main", 11931);
      v96 = v300;
      v97 = v95;
      *((_DWORD *)v94 + 41) = v95;
      if ( *(_DWORD *)v96 )
        LOWORD(v98) = 16788;
      else
        LOWORD(v98) = 16800;
      HIWORD(v98) = 5;
      v99 = *v98;
      v100 = v98[1];
      v101 = *((_WORD *)v98 + 4);
      *v97 = v99;
      v97[1] = v100;
      *((_WORD *)v97 + 4) = v101;
      v102 = *((_DWORD *)v94 + 41);
      *((_DWORD *)v94 + 43) = v102;
      *((_DWORD *)v94 + 44) = v102;
      *((_DWORD *)v94 + 42) = v102;
      *((_DWORD *)v94 + 150) = v102;
      strncpy(v94 + 48, "?", 7u);
      v103 = *((_DWORD *)v94 + 25);
      v94[55] = 0;
      if ( v103 != 1 )
        sub_2B664((_DWORD *)v94 + 25);
      v104 = (char *)&unk_691B0;
      v105 = 0;
      v94[97] = 0;
      v106 = &unk_69BB0;
      byte_68BD6 = 1;
      do
      {
        v107 = v104;
        v104 += 160;
        sub_22CD8(v107, (unsigned __int8 *)&a000000029c6bf4[v105], 160);
        v108 = (unsigned __int8 *)&a00000002c01f50[v105];
        v105 += 324;
        sub_22CD8(v106, v108, 160);
        v106 += 160;
      }
      while ( v105 != 5184 );
      sub_2D950(&unk_6A950);
    }
    if ( *(_DWORD *)(v304 + 0x210) )
      sub_3FB54();
    v109 = v304;
    v110 = *(const char **)(v304 + 0x200);
    if ( v110 )
    {
      *(_BYTE *)v299 = 1;
      strcpy((char *)&dword_68AD4, v110);
      v111 = *(const char **)(v109 + 0x20C);
      if ( v111 )
        strcpy((char *)&word_68AB4, v111);
      if ( !byte_74500 )
      {
        v303 = (const char **)&byte_68BD4;
        if ( !byte_68BD4 && dword_67DB4 <= 2 )
        {
          v112 = *(const char **)(v304 + 0x208);
          if ( !v112 )
          {
LABEL_109:
            if ( dword_67DB4 <= 3 )
            {
              v113 = *(const char **)(v304 + 0x31C);
              if ( !v113 )
                goto LABEL_120;
LABEL_111:
              if ( dword_67DB4 <= 4 )
              {
                v114 = *(_DWORD *)(v304 + 0x3F0);
                if ( v114 != -1 )
                  goto LABEL_113;
LABEL_205:
                if ( !*(_BYTE *)v303 && dword_67DB4 <= 3 )
                {
                  if ( !byte_74488 )
                    goto LABEL_119;
                  goto LABEL_208;
                }
LABEL_210:
                strcpy((char *)v310, "Error in configuration file, partially loaded.");
                sub_20F58(4, (const char *)v310, 0);
                if ( !byte_74488 )
                  goto LABEL_119;
                if ( byte_74500 || *(_BYTE *)v303 )
                  goto LABEL_209;
LABEL_208:
                if ( dword_67DB4 > 3 )
                {
LABEL_209:
                  strcpy((char *)v310, "Start cgminer with -T to see what failed to load.");
                  sub_20F58(4, (const char *)v310, 0);
                }
LABEL_119:
                v115 = v304;
                free(*(void **)(v304 + 0x31C));
                *(_DWORD *)(v115 + 0x31C) = 0;
                goto LABEL_120;
              }
LABEL_112:
              snprintf((char *)v310, 0x800u, "Loaded configuration file %s", v113);
              sub_20F58(5, (const char *)v310, 0);
              v114 = *(_DWORD *)(v304 + 0x3F0);
              if ( v114 != -1 )
              {
LABEL_113:
                if ( !v114 )
                {
                  if ( (byte_74500 || *(_BYTE *)v303 || dword_67DB4 > 3)
                    && ((strcpy((char *)v310, "Fatal JSON error in configuration file."),
                         sub_20F58(4, (const char *)v310, 0),
                         byte_74500)
                     || *(_BYTE *)v303)
                    || dword_67DB4 > 3 )
                  {
                    strcpy((char *)v310, "Configuration file could not be used.");
                    sub_20F58(4, (const char *)v310, 0);
                  }
                }
                goto LABEL_119;
              }
              if ( byte_74500 )
                goto LABEL_210;
              goto LABEL_205;
            }
LABEL_178:
            snprintf((char *)v310, 0x800u, "Started %s", ::s);
            sub_20F58(4, (const char *)v310, 0);
            v113 = *(const char **)(v304 + 0x31C);
            if ( !v113 )
            {
LABEL_120:
              *(_WORD *)(*(_DWORD *)v296 + strlen(*(const char **)v296)) = *v295;
              if ( byte_73388 )
              {
                *(_BYTE *)v303 = 1;
              }
              else if ( !*(_BYTE *)v303 )
              {
                setlogmask(63);
                goto LABEL_123;
              }
              setlogmask(255);
LABEL_123:
              v116 = dword_68754;
              if ( dword_68754 < 0 )
                v116 = 60;
              LOWORD(v117) = (unsigned __int16)&unk_731F0;
              if ( dword_68754 < 0 )
                dword_68754 = v116;
              *(_DWORD *)&v301[-76] = 8;
              HIWORD(v117) = (unsigned int)&unk_731F0 >> 16;
              v299 = &dword_75598;
              dword_75598 = (int)sub_22A44(8u, 0x40u, "cgminer.c", "main", 12093);
              sub_3ECA0((int)&unk_73268);
              sub_3ECA0(v117);
              sub_3ECA0((int)&unk_73110);
              format = (char *)&dword_75588;
              sub_3ECA0((int)&unk_689C8);
              off_73274(0);
              (*(void (__fastcall **)(_DWORD))(v117 + 0xC))(0);
              ((void (__fastcall *)(_DWORD))off_7311C)(0);
              v118 = 0;
              off_689D4();
              dword_75588 = 0;
              while ( dword_755C0 > v118 )
              {
                v119 = *(pthread_rwlock_t **)(dword_7346C + 4 * v118++);
                sub_3EEE8(v119);
              }
              if ( dword_755C0 )
              {
                v120 = *(char **)(v304 + 0x3FC);
                *(_DWORD *)&v301[-1160] = dword_755C0;
                if ( v120 )
                {
                  v121 = 0;
                  v122 = 0;
                  for ( j = strtok(v120, ","); j; j = strtok(v297, ",") )
                  {
                    if ( dword_755C0 <= v121 )
                    {
                      strcpy((char *)v310, "Too many values passed to set temp cutoff");
                      sub_20F58(3, (const char *)v310, 1);
                      sub_2E6B0(1, 1);
                    }
                    v122 = strtol(j, 0, 10);
                    if ( v122 > 0xC8 )
                    {
                      v144 = "ssed to set temp cutoff";
                      qmemcpy(v310, "Invalid value pa", 16);
                      v145 = &v310[4];
                      goto LABEL_188;
                    }
                    if ( pthread_rwlock_rdlock(&stru_7680C) )
                      sub_30138("load_temp_cutoffs", 1336);
                    *(_DWORD *)(*(_DWORD *)(dword_7346C + 4 * v121) + 184) = v122;
                    if ( pthread_rwlock_unlock(&stru_7680C) )
                    {
                      v206 = _errno_location();
                      snprintf(
                        (char *)v310,
                        0x800u,
                        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                        *v206,
                        "cgminer.c",
                        "load_temp_cutoffs",
                        1338);
                      v153 = (const char *)v310;
                      goto LABEL_189;
                    }
                    ++v121;
                    v297 = 0;
                    off_67ED8();
                  }
                  if ( v121 <= 1 )
                  {
                    if ( pthread_rwlock_rdlock(&stru_7680C) )
                      sub_30138("load_temp_cutoffs", 1359);
                    v207 = dword_755C0;
                    v295 = (__int16 *)&dword_7346C;
                    v208 = dword_7346C;
                    while ( v121 < v207 )
                    {
                      v209 = *(_DWORD *)(v208 + 4 * v121++);
                      *(_DWORD *)(v209 + 184) = v122;
                    }
                    sub_2FB80(&stru_7680C, "load_temp_cutoffs", 1365);
                  }
                  else
                  {
                    v295 = (__int16 *)&dword_7346C;
                  }
                }
                else
                {
                  v156 = pthread_rwlock_rdlock(&stru_7680C);
                  if ( v156 )
                    sub_30138("load_temp_cutoffs", 1343);
                  v157 = dword_755C0;
                  v295 = (__int16 *)&dword_7346C;
                  v158 = dword_7346C;
                  while ( v156 < v157 )
                  {
                    v159 = *(_DWORD *)(v158 + 4 * v156++);
                    if ( !*(_DWORD *)(v159 + 184) )
                      *(_DWORD *)(v159 + 184) = 95;
                  }
                  sub_2FB80(&stru_7680C, "load_temp_cutoffs", 1352);
                }
                v160 = dword_755C0;
                v161 = *(_DWORD *)v295;
                for ( k = 0; v160 > k; ++k )
                {
                  v163 = *(_DWORD *)(v161 + 4 * k);
                  *(_DWORD *)(v163 + 312) = 99999999;
                }
                if ( !byte_756B0 )
                  *(_DWORD *)&v301[-644] += *(_DWORD *)&v301[-1160];
                if ( !dword_733CC )
                {
                  if ( byte_74500 || *(_BYTE *)v303 || dword_67DB4 > 3 )
                  {
                    strcpy((char *)v310, "Need to specify at least one pool server.");
                    sub_20F58(4, (const char *)v310, 0);
                  }
                  strcpy((char *)v310, "Pool setup failed");
                  sub_20F58(3, (const char *)v310, 1);
                  sub_2E6B0(1, 0);
                }
                v297 = (char *)&dword_744C8;
                v296 = "cgminer.c";
                for ( m = 0; ; ++m )
                {
                  v165 = *(_DWORD **)v297;
                  if ( dword_733CC <= m )
                    break;
                  v166 = v165[m];
                  v167 = *(_DWORD *)(v166 + 168);
                  *(_DWORD *)(v166 + 404) = 99999999;
                  *(_DWORD *)(v166 + 440) = 99999999;
                  if ( !v167 )
                  {
                    if ( !*(_DWORD *)(v166 + 176) )
                      *(_DWORD *)(v166 + 176) = calloc(1u, 1u);
                    v168 = *(const char **)(v166 + 172);
                    if ( !v168 )
                    {
                      snprintf(
                        (char *)v310,
                        0x800u,
                        "No login credentials supplied for pool %u %s",
                        m,
                        *(const char **)(v166 + 164));
                      sub_20F58(3, (const char *)v310, 1);
                      sub_2E6B0(1, 0);
                    }
                    v169 = strlen(v168);
                    v170 = v169 + strlen(*(const char **)(v166 + 176)) + 2;
                    v171 = (char *)sub_229BC(v170, v296, "main", 12203);
                    v172 = *(const char **)(v166 + 176);
                    *(_DWORD *)(v166 + 168) = v171;
                    snprintf(v171, v170, "%s:%s", *(const char **)(v166 + 172), v172);
                  }
                }
                v18 = byte_74500 == 0;
                *(_DWORD *)(v304 + 0x488) = *v165;
                if ( !v18 )
                  openlog("cgminer", 1, 8);
                v173 = (char *)v310;
                if ( *(_DWORD *)&v301[-72] )
                {
                  if ( pipe(v310) < 0 )
                  {
                    perror("pipe - failed to create pipe for --monitor");
                    exit(1);
                  }
                  fflush((FILE *)stderr);
                  if ( dup2(v310[1], 2) < 0 )
                  {
                    perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                    exit(1);
                  }
                  if ( close(v310[1]) < 0 )
                  {
                    perror("close - failed to close write end of pipe for --monitor");
                    exit(1);
                  }
                  v174 = signal(13, (__sighandler_t)1);
                  v175 = signal(13, (__sighandler_t)1);
                  v176 = (__sighandler_t)((char *)v174 + 1) == 0;
                  if ( v174 != (__sighandler_t)-1 )
                    v176 = (__sighandler_t)((char *)v175 + 1) == 0;
                  if ( v176 )
                  {
                    perror("signal - failed to edit signal mask for --monitor");
                    exit(1);
                  }
                  v177 = fork();
                  v178 = v177;
                  *(_DWORD *)(v304 + 0x424) = v177;
                  if ( v177 < 0 )
                  {
                    perror("fork - failed to fork child process for --monitor");
                    exit(1);
                  }
                  if ( !v177 )
                  {
                    if ( dup2(v310[0], v177) >= 0 )
                    {
                      close(v310[0]);
                      execl("/bin/bash", "/bin/bash", "-c", *(_DWORD *)&v301[-72], v178);
                      perror("execl - in child failed to exec user specified command for --monitor");
                      exit(1);
                    }
                    perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                    exit(1);
                  }
                  if ( close(v310[0]) < 0 )
                  {
                    perror("close - failed to close read end of pipe for --monitor");
                    exit(1);
                  }
                }
                v179 = *(_DWORD *)format;
                v293 = &dword_744A4;
                dword_744A4 = (int)sub_22A44(v179, 4u, "cgminer.c", "main", 12220);
                v296 = (const char *)&dword_755C0;
                for ( n = 0; *(_DWORD *)format > n; ++n )
                {
                  v181 = *v293;
                  *(_DWORD *)(v181 + 4 * n) = sub_22A44(1u, 0x40u, "cgminer.c", "main", 12224);
                }
                v182 = v296;
                v294 = 0;
                v296 = 0;
                v291 = &byte_68BD5;
                v292 = &byte_74500;
                v290 = &dword_733CC;
                while ( *(_DWORD *)v182 > v294 )
                {
                  v183 = 0;
                  v184 = v182;
                  v185 = v173;
                  v186 = *(const char **)(*(_DWORD *)v295 + 4 * v294);
                  v187 = sub_229BC(4 * (*((_DWORD *)v186 + 37) + 1), "cgminer.c", "main", 12233);
                  v188 = *((_DWORD *)v186 + 37);
                  *((_DWORD *)v186 + 38) = v187;
                  v187[v188] = 0;
                  *((_DWORD *)v186 + 24) = 4;
                  while ( 1 )
                  {
                    v191 = &v183[(_DWORD)v296];
                    if ( *((_DWORD *)v186 + 37) <= (int)v183 )
                      break;
                    v189 = (const char **)sub_31B04((int)&v183[(_DWORD)v296]);
                    *v189 = v191;
                    v190 = (sem_t *)v189;
                    v189[9] = v186;
                    v189[1] = v183;
                    if ( (*(int (**)(void))(*((_DWORD *)v186 + 1) + 44))() )
                    {
                      if ( sub_25164((int)v190, 0, (void *(*)(void *))sub_2B500, v190) )
                      {
                        snprintf(v185, 0x800u, "thread %d create failed", v190->__align);
                        sub_20F58(3, v185, 1);
                        sub_2E6B0(1, 0);
                      }
                      *(_DWORD *)(*((_DWORD *)v186 + 38) + 4 * (_DWORD)v183) = v190;
                      if ( *((_DWORD *)v186 + 8) != 1 )
                      {
                        if ( *v291 && (*v292 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                        {
                          snprintf(v185, 0x800u, "Pushing sem post to thread %d", v190->__align);
                          sub_20F58(7, v185, 0);
                        }
                        sub_251AC(v190 + 1, "cgminer.c", "main", 12261);
                      }
                    }
                    ++v183;
                  }
                  v192 = v185;
                  v182 = v184;
                  v173 = v192;
                  v296 = &v183[(_DWORD)v296];
                  ++v294;
                }
                v193 = (int *)v292;
                v194 = v290;
                if ( *(_BYTE *)(v304 + 0x5A4) || (v195 = *(char **)v300) != 0 )
                {
LABEL_284:
                  v196 = (int *)dbl_69088;
                  dbl_756A8 = 0.0;
                  do
                  {
                    *(_QWORD *)v196 = 0;
                    v196 += 2;
                  }
                  while ( &dword_690E8 != v196 );
                  v197 = *(_DWORD *)v182;
                  v198 = v298;
                  v199 = *(_DWORD *)v295;
                  *(_DWORD *)(v304 + 0x510) = 0;
                  while ( v197 > (int)v198 )
                  {
                    v200 = *(_DWORD *)(v199 + 4 * (_DWORD)v198++);
                    *(_QWORD *)(v200 + 80) = 0;
                    *(_QWORD *)(v200 + 48) = 0;
                  }
                  sub_239A4((struct timeval *)&dword_69020);
                  sub_239A4((struct timeval *)&dword_69018);
                  sub_239A4(&stru_6907C);
                  sub_2C610(byte_69028, 0x28u, &dword_69020);
                  v201 = *v299;
                  *(_DWORD *)(v304 + 0x480) = 2;
                  if ( sub_25164(v201 + 128, 0, (void *(*)(void *))sub_34DF4, 0) )
                  {
                    strcpy(v173, "watchpool thread create failed");
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(1, 0);
                  }
                  pthread_detach(*(_DWORD *)(v201 + 140));
                  v202 = *v299;
                  *(_DWORD *)(v304 + 0x484) = 3;
                  if ( sub_25164(v202 + 192, 0, (void *(*)(void *))sub_38D3C, 0) )
                  {
                    strcpy(v173, "watchdog thread create failed");
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(1, 0);
                  }
                  pthread_detach(*(_DWORD *)(v202 + 204));
                  v203 = *v299;
                  *(_DWORD *)(v304 + 0x3F4) = 5;
                  if ( sub_25164(v203 + 320, 0, (void *(*)(void *))sub_2C1A4, (void *)(v203 + 320)) )
                  {
                    strcpy(v173, "API thread create failed");
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(1, 0);
                  }
                  v204 = *(_DWORD *)&v301[-76];
                  if ( v204 != 8 )
                  {
                    snprintf(v173, 0x800u, "incorrect total_control_threads (%d) should be 8", v204);
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(1, 0);
                  }
                  if ( !nice(-10) && byte_68BD5 && (*(_BYTE *)v193 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                  {
                    strcpy(v173, "Unable to set thread to high priority");
                    sub_20F58(7, v173, 0);
                  }
                  v210 = v297;
                  v211 = v301;
                  v298 = &byte_767F0;
                  v299 = v193;
                  v301 = (unsigned __int8 *)&byte_755D4;
                  while ( 1 )
                  {
                    if ( *v298 )
                    {
                      if ( *(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 5 )
                      {
                        strcpy(v173, "Work update message received");
                        sub_20F58(6, v173, 0);
                      }
                      sub_239A4(&stru_68FE0);
                      v273 = pthread_rwlock_rdlock(&stru_744A8);
                      if ( v273 )
                      {
                        v284 = _errno_location();
                        snprintf(
                          v173,
                          0x800u,
                          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                          *v284,
                          "cgminer.c",
                          "signal_work_update",
                          5507);
                        goto LABEL_423;
                      }
                      v274 = *(_DWORD *)format;
                      v275 = *v293;
                      while ( v273 < v274 )
                      {
                        v276 = *(_DWORD *)(v275 + 4 * v273++);
                        *(_BYTE *)(v276 + 63) = 1;
                      }
                      if ( pthread_rwlock_unlock(&stru_744A8) )
                      {
                        v285 = _errno_location();
                        snprintf(
                          v173,
                          0x800u,
                          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                          *v285,
                          "cgminer.c",
                          "signal_work_update",
                          5514);
LABEL_423:
                        v153 = v173;
LABEL_189:
                        sub_20F58(3, v153, 1);
                        sub_2E6B0(1, 1);
                      }
                      off_67ED8();
                    }
                    v212 = *(pthread_mutex_t **)(v304 + 0x438);
                    *v298 = 0;
                    if ( pthread_mutex_lock(v212) )
                    {
                      v272 = _errno_location();
                      snprintf(
                        v173,
                        0x800u,
                        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                        *v272,
                        "cgminer.c",
                        "main",
                        12427);
                      goto LABEL_423;
                    }
                    v213 = *(_DWORD *)(v304 + 0x514);
                    if ( v213
                      && *(int *)(*(_DWORD *)(v213 + 344) + 12) > 1
                      && (v280 = v304,
                          pthread_cond_wait(&stru_744D0, *(pthread_mutex_t **)(v304 + 0x438)),
                          (v281 = *(_DWORD *)(v280 + 0x514)) != 0) )
                    {
                      v282 = *(pthread_mutex_t **)(v280 + 0x438);
                      v283 = *(_DWORD *)(*(_DWORD *)(v281 + 344) + 12);
                      if ( pthread_mutex_unlock(v282) )
                      {
LABEL_422:
                        v268 = _errno_location();
                        snprintf(
                          v173,
                          0x800u,
                          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                          *v268,
                          "cgminer.c",
                          "main",
                          12438);
                        goto LABEL_423;
                      }
                      off_67ED8();
                      if ( v283 > 1 )
                      {
                        v306 = (void **)sub_355FC(0);
                        if ( v306 )
                          sub_2CEA0(&v306, "cgminer.c", "main", 12450);
                        continue;
                      }
                    }
                    else
                    {
                      if ( pthread_mutex_unlock(*(pthread_mutex_t **)(v304 + 0x438)) )
                        goto LABEL_422;
                      off_67ED8();
                    }
                    if ( v306 )
                      sub_2CEA0(&v306, "cgminer.c", "main", 12458);
                    v297 = "Selecting pool %d for work";
                    v306 = (void **)sub_2FD8C();
                    pthread_mutex_lock(&mutex);
LABEL_349:
                    v223 = sub_31FF4();
                    v224 = (unsigned __int8 *)v223;
                    v225 = *(_DWORD *)(v304 + 0x3F8);
                    if ( v225 == 4 )
                      break;
                    if ( v225 != 3 )
                      goto LABEL_331;
                    v214 = *v194;
                    v215 = 0;
                    v216 = *(void ***)v210;
                    while ( v215 < v214 )
                    {
                      if ( *((_DWORD *)v216[v215] + 16) < *((_DWORD *)v216[v215] + 15) )
                        goto LABEL_360;
                      ++v215;
                    }
                    for ( ii = 0; v214 > ii; ++ii )
                    {
                      v227 = v216[ii];
                      v227[16] = 0;
                    }
                    v228 = *(_DWORD *)&v211[-68] + 1;
                    if ( v214 <= v228 )
                      v228 = 0;
                    *(_DWORD *)&v211[-68] = v228;
LABEL_360:
                    v229 = 0;
                    v230 = v210;
                    while ( 1 )
                    {
                      v236 = v229 + 1;
                      if ( v229 >= *v194 )
                        break;
                      v231 = *(_DWORD *)(*(_DWORD *)v230 + 4 * *(_DWORD *)&v211[-68]);
                      v232 = *(_DWORD *)(v231 + 64);
                      v233 = *(_DWORD *)(v231 + 60);
                      *(_DWORD *)(v231 + 64) = v232 + 1;
                      if ( v232 < v233 )
                      {
                        if ( !*(_BYTE *)(v231 + 97)
                          && *(_DWORD *)(v231 + 100) == 1
                          && !sub_2B684((unsigned __int8 *)v231) )
                        {
                          v210 = v230;
                          v224 = v267;
                          goto LABEL_377;
                        }
                        if ( *v301 )
                        {
                          v234 = sub_2B7BC(0);
                          --*(_DWORD *)(v234 + 64);
                        }
                      }
                      v235 = *(_DWORD *)&v211[-68] + 1;
                      v91 = v235 < *v194;
                      *(_DWORD *)&v211[-68] = v235;
                      if ( !v91 )
                        *(_DWORD *)&v211[-68] = 0;
                      v229 = v236;
                    }
                    v210 = v230;
                    for ( jj = 0; ; ++jj )
                    {
                      if ( jj >= *v194 )
                        goto LABEL_331;
                      v238 = sub_2B7BC(jj);
                      if ( !*(_BYTE *)(v238 + 97) && *(_DWORD *)(v238 + 100) == 1 && !sub_2B684((unsigned __int8 *)v238) )
                        break;
                    }
                    v224 = v239;
LABEL_377:
                    if ( !byte_68BD5 )
                      goto LABEL_378;
LABEL_332:
                    if ( *(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6 )
                    {
                      snprintf(v173, 0x800u, v297, *(_DWORD *)v224);
                      sub_20F58(7, v173, 0);
                    }
LABEL_336:
                    if ( v224[97] || *((_DWORD *)v224 + 25) != 1 )
                    {
LABEL_338:
                      sub_34178(0);
                      v217 = sub_31FF4();
                      v218 = (unsigned __int8 *)v217;
                      v219 = *(_DWORD *)(v304 + 0x3F8);
                      if ( v219 == 4 )
                      {
                        v218 = (unsigned __int8 *)sub_2B6A8(v217);
                        goto LABEL_341;
                      }
                      if ( v219 != 3 )
                        goto LABEL_341;
                      v220 = *v194;
                      v221 = 0;
                      v222 = *(void ***)v210;
                      while ( v221 < v220 )
                      {
                        if ( *((_DWORD *)v222[v221] + 16) < *((_DWORD *)v222[v221] + 15) )
                          goto LABEL_398;
                        ++v221;
                      }
                      for ( kk = 0; v220 > kk; ++kk )
                      {
                        v255 = v222[kk];
                        v255[16] = 0;
                      }
                      v256 = *(_DWORD *)&v211[-68] + 1;
                      if ( v220 <= v256 )
                        v256 = 0;
                      *(_DWORD *)&v211[-68] = v256;
LABEL_398:
                      for ( mm = 0; ; mm = v259 )
                      {
                        v259 = mm + 1;
                        if ( mm >= *v194 )
                        {
                          for ( nn = 0; nn < *v194; ++nn )
                          {
                            v265 = sub_2B7BC(nn);
                            if ( !*(_BYTE *)(v265 + 97)
                              && *(_DWORD *)(v265 + 100) == 1
                              && !sub_2B684((unsigned __int8 *)v265) )
                            {
                              goto LABEL_414;
                            }
                          }
LABEL_341:
                          if ( byte_68BD5 )
                            goto LABEL_342;
                          goto LABEL_346;
                        }
                        v260 = *(_DWORD *)(*(_DWORD *)v210 + 4 * *(_DWORD *)&v211[-68]);
                        v261 = *(_DWORD *)(v260 + 64);
                        v262 = *(_DWORD *)(v260 + 60);
                        *(_DWORD *)(v260 + 64) = v261 + 1;
                        if ( v261 < v262 )
                        {
                          if ( !*(_BYTE *)(v260 + 97)
                            && *(_DWORD *)(v260 + 100) == 1
                            && !sub_2B684((unsigned __int8 *)v260) )
                          {
LABEL_414:
                            v218 = v266;
                            if ( !byte_68BD5 )
                              goto LABEL_415;
LABEL_342:
                            if ( *(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6 )
                            {
                              snprintf(v173, 0x800u, v297, *(_DWORD *)v218);
                              sub_20F58(7, v173, 0);
                            }
LABEL_346:
                            if ( !v218[97] && *((_DWORD *)v218 + 25) == 1 )
                            {
LABEL_415:
                              if ( sub_2B684(v218) )
                                goto LABEL_348;
                            }
                            else
                            {
LABEL_348:
                              sub_23B9C();
                            }
                            goto LABEL_349;
                          }
                          if ( *v301 )
                          {
                            v263 = sub_2B7BC(0);
                            --*(_DWORD *)(v263 + 64);
                          }
                        }
                        v258 = *(_DWORD *)&v211[-68] + 1;
                        v91 = v258 < *v194;
                        *(_DWORD *)&v211[-68] = v258;
                        if ( !v91 )
                          *(_DWORD *)&v211[-68] = 0;
                      }
                    }
LABEL_378:
                    if ( sub_2B684(v224) )
                      goto LABEL_338;
                    pthread_mutex_unlock(&mutex);
                    if ( v224[640] )
                    {
                      sub_360B0((int)v224, (int)v306);
                      if ( byte_68BD5 && (*(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                      {
                        strcpy(v173, "Generated stratum work");
                        sub_20F58(7, v173, 0);
                      }
                      sub_3D93C((int)v306);
                      v306 = 0;
                      pthread_mutex_unlock(&mutex);
                    }
                    else
                    {
                      pthread_mutex_unlock(&mutex);
                      v297 = *(char **)v300;
                      if ( v297 )
                      {
                        v269 = v306;
                        v270 = (struct timeval *)(v306 + 100);
                        sub_2EA28(v306);
                        v271 = *(void ***)v210;
                        *((_BYTE *)v269 + 282) = 1;
                        v269[65] = *v271;
                        sub_239A4(v270);
                        sub_257F8(v269 + 102, v270);
                        *((_BYTE *)v269 + 440) = 66;
                        sub_2B1B0((int)v269);
                        if ( byte_68BD5 && (*(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                        {
                          v244 = "Generated benchfile work";
                          v245 = v173;
LABEL_387:
                          v246 = *(_DWORD *)v244;
                          v247 = *((_DWORD *)v244 + 1);
                          v248 = *((_DWORD *)v244 + 2);
                          v249 = *((_DWORD *)v244 + 3);
                          v250 = v244 + 16;
                          *(_DWORD *)v245 = v246;
                          *((_DWORD *)v245 + 1) = v247;
                          *((_DWORD *)v245 + 2) = v248;
                          *((_DWORD *)v245 + 3) = v249;
                          v251 = v245 + 16;
                          v252 = v250[1];
                          v253 = v250[2];
                          *v251 = *v250;
                          v251[1] = v252;
                          *((_BYTE *)v251 + 8) = v253;
                          sub_20F58(7, v173, 0);
                        }
LABEL_388:
                        sub_3D93C((int)v306);
                        v306 = 0;
                      }
                      else if ( *(_BYTE *)(v304 + 0x5A4) )
                      {
                        v240 = v306;
                        *((_QWORD *)v306 + 47) = 0x4040000000000000LL;
                        sub_254E8(v240 + 40, &unk_6A950, 0x20u, (int)"cgminer.c", (int)"get_benchmark_work", 4265);
                        v241 = v297;
                        v242 = *(void ***)v210;
                        *((_BYTE *)v240 + 282) = 1;
                        v240[61] = v241;
                        v240[65] = *v242;
                        sub_239A4((struct timeval *)v240 + 50);
                        sub_257F8(v240 + 102, v240 + 100);
                        v243 = (unsigned __int8)byte_68BD5;
                        *((_BYTE *)v240 + 440) = 66;
                        if ( v243 && (*(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                        {
                          v244 = "Generated benchmark work";
                          v245 = v173;
                          goto LABEL_387;
                        }
                        goto LABEL_388;
                      }
                    }
                  }
                  v224 = (unsigned __int8 *)sub_2B6A8(v223);
LABEL_331:
                  if ( !byte_68BD5 )
                    goto LABEL_336;
                  goto LABEL_332;
                }
                while ( *v194 > (int)v195 )
                {
                  v205 = *(_DWORD *)(*(_DWORD *)v297 + 4 * (_DWORD)v195);
                  if ( *(_DWORD *)(v205 + 100) != 1 )
                    sub_2B664((_DWORD *)(v205 + 100));
                  ++v195;
                  *(_BYTE *)(v205 + 97) = 1;
                }
                if ( *(_BYTE *)v193 || *(_BYTE *)v303 || dword_67DB4 > 4 )
                {
                  strcpy(v173, "Probing for an alive pool");
                  sub_20F58(5, v173, 0);
                }
                v277 = 0;
                sub_2B41C();
                do
                {
                  ++v277;
                  sleep(1u);
                  if ( v277 == 180 )
                    v278 = 0;
                  else
                    v278 = (*(_BYTE *)(v304 + 0x598) ^ 1) & 1;
                }
                while ( v278 );
                v296 = v182;
                v279 = v303;
                while ( 1 )
                {
                  if ( *(_BYTE *)(v304 + 0x598) )
                  {
                    v182 = v296;
                    goto LABEL_284;
                  }
                  if ( v278 )
                    goto LABEL_456;
                  if ( ((*(_BYTE *)v193 || *(_BYTE *)v279 || dword_67DB4 > 2)
                     && ((strcpy(v173, "No servers were found that could be used to get work from."),
                          sub_20F58(3, v173, 0),
                          *(_BYTE *)v193)
                      || *(_BYTE *)v279)
                     || dword_67DB4 > 2)
                    && ((strcpy(v173, "Please check the details from the list below of the servers you have input"),
                         sub_20F58(3, v173, 0),
                         *(_BYTE *)v193)
                     || *(_BYTE *)v279)
                    || dword_67DB4 > 2 )
                  {
                    strcpy(
                      v173,
                      "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                    sub_20F58(3, v173, 0);
                  }
                  for ( i1 = 0; *v194 > i1; ++i1 )
                  {
                    if ( *(_BYTE *)v193 || *(_BYTE *)v279 || dword_67DB4 > 3 )
                    {
                      snprintf(
                        v173,
                        0x800u,
                        "Pool: %d  URL: %s  User: %s  Password: %s",
                        i1,
                        *(const char **)(*(_DWORD *)(*(_DWORD *)v297 + 4 * i1) + 164),
                        *(const char **)(*(_DWORD *)(*(_DWORD *)v297 + 4 * i1) + 172),
                        *(const char **)(*(_DWORD *)(*(_DWORD *)v297 + 4 * i1) + 176));
                      sub_20F58(4, v173, 0);
                    }
                  }
                  if ( !byte_74488 )
                  {
LABEL_473:
                    strcpy(v173, "No servers could be used! Exiting.");
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(0, 0);
                  }
                  if ( *(_BYTE *)v193 || *(_BYTE *)v279 || dword_67DB4 > 2 )
                    break;
LABEL_457:
                  v278 = 1;
                }
                strcpy(v173, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
                sub_20F58(3, v173, 0);
LABEL_456:
                if ( !byte_74488 )
                  goto LABEL_473;
                goto LABEL_457;
              }
              qmemcpy(v310, "All devices disabled, cannot mint!", 34);
              v124 = aAllDevicesDisa[34];
              v125 = (char *)&v310[8] + 2;
LABEL_142:
              *v125 = v124;
              sub_20F58(3, (const char *)v310, 1);
              sub_2E6B0(1, 0);
            }
            if ( byte_74500 || *(_BYTE *)v303 )
              goto LABEL_112;
            goto LABEL_111;
          }
          goto LABEL_146;
        }
      }
      snprintf((char *)v310, 0x800u, "Log file path: %s Open flag: %s", (const char *)&dword_68AD4, v297);
      sub_20F58(3, (const char *)v310, 0);
    }
    v112 = *(const char **)(v304 + 0x208);
    if ( !v112 )
    {
      v303 = (const char **)&byte_68BD4;
      goto LABEL_176;
    }
LABEL_146:
    memset(v309, 0, sizeof(v309));
    v126 = *(const char **)(v304 + 0x204);
    if ( v126 )
    {
      if ( !*v126 )
      {
        v144 = "Log work asic num empty";
        v145 = v310;
LABEL_188:
        v146 = *(_DWORD *)v144;
        v147 = *((_DWORD *)v144 + 1);
        v148 = *((_DWORD *)v144 + 2);
        v149 = *((_DWORD *)v144 + 3);
        v150 = v144 + 16;
        *v145 = v146;
        v145[1] = v147;
        v145[2] = v148;
        v145[3] = v149;
        v151 = v145 + 4;
        v152 = v150[1];
        *v151 = *v150;
        v151[1] = v152;
        v153 = (const char *)v310;
        goto LABEL_189;
      }
      v127 = strtol(v126, 0, 10);
      v128 = v127 == 1;
      if ( v127 != 1 )
        v128 = ((v127 - 32) & 0xFFFFFFDF) == 0;
      *(_DWORD *)&v301[-608] = v127;
      if ( !v128 )
      {
        strcpy((char *)v310, "Log work asic num must be 1, 32, 64");
        sub_20F58(3, (const char *)v310, 1);
        sub_2E6B0(1, 1);
      }
      v303 = (const char **)&byte_68BD4;
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf(
          (char *)v310,
          0x800u,
          "Log work path: %s Asic num: %s",
          *(const char **)(v304 + 0x208),
          *(const char **)(v304 + 0x204));
        sub_20F58(3, (const char *)v310, 0);
      }
    }
    else
    {
      v303 = (const char **)&byte_68BD4;
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf((char *)v310, 0x800u, "Log work path: %s", v112);
        sub_20F58(3, (const char *)v310, 0);
      }
    }
    sprintf(v309, "%s.txt", *(const char **)(v304 + 0x208));
    v129 = fopen64(v309, &word_5406C);
    v130 = (unsigned __int8)byte_74500;
    *(_DWORD *)&v301[-604] = v129;
    if ( v130 || *(_BYTE *)v303 || dword_67DB4 > 2 )
    {
      snprintf((char *)v310, 0x800u, "Log work open file %s", v309);
      sub_20F58(3, (const char *)v310, 0);
    }
    v131 = *(_DWORD *)&v301[-608];
    if ( v131 == 1 )
    {
      sprintf(v309, "%s%02d.txt", *(const char **)(v304 + 0x208), 1);
      v154 = fopen64(v309, &word_5406C);
      v155 = (unsigned __int8)byte_74500;
      *(_DWORD *)&v301[-600] = v154;
      if ( v155 || *(_BYTE *)v303 || dword_67DB4 > 2 )
      {
        snprintf((char *)v310, 0x800u, "Log work open asic %d file %s", *(_DWORD *)&v301[-608], v309);
        sub_20F58(3, (const char *)v310, 0);
      }
    }
    else if ( ((v131 - 32) & 0xFFFFFFDF) == 0 )
    {
      format = (char *)&word_5406C;
      v132 = 0;
      v133 = v301;
      while ( 1 )
      {
        v136 = *(_DWORD *)&v133[-608];
        if ( v136 < v132 )
          break;
        sprintf(v309, "%s%02d_%02d.txt", *(const char **)(v304 + 0x208), v136, v132);
        v134 = fopen64(v309, format);
        v135 = (unsigned __int8)byte_74500;
        dword_6A978[v132] = v134;
        if ( v135 || *(_BYTE *)v303 || dword_67DB4 > 2 )
        {
          snprintf((char *)v310, 0x800u, "Log work open asic %d file %s", *(_DWORD *)&v133[-608], v309);
          sub_20F58(3, (const char *)v310, 0);
        }
        ++v132;
      }
    }
    if ( v301[-340] )
    {
      v137 = &byte_6AA7C;
      v138 = 0;
      format = "Log work open diff file %s";
      do
      {
        sprintf(v309, "%s_diff_%02d.txt", *(const char **)(v304 + 0x208), v138);
        v139 = fopen64(v309, &word_5406C);
        v140 = (unsigned __int8)byte_74500;
        *((_DWORD *)v137 + 1) = v139;
        v137 += 4;
        if ( v140 || *(_BYTE *)v303 || dword_67DB4 > 2 )
        {
          snprintf((char *)v310, 0x800u, format, v309);
          sub_20F58(3, (const char *)v310, 0);
        }
        ++v138;
      }
      while ( v138 != 65 );
    }
LABEL_176:
    if ( byte_74500 || *(_BYTE *)v303 )
      goto LABEL_178;
    goto LABEL_109;
  }
  v75 = calloc(24 * *(_DWORD *)(v74 + 4), 1u);
  if ( v75 )
  {
    v76 = *((_DWORD *)v36 + 17);
    v77 = v36;
    v300 = 0;
    *(_DWORD *)(v76 + 24) = (((2 * *(_DWORD *)(v76 + 4) - 1) & *(_DWORD *)(v76 + 12)) != 0)
                          + (*(_DWORD *)(v76 + 12) >> (*(_BYTE *)(v76 + 8) + 1));
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 28) = 0;
    v78 = (__int64 *)*((_DWORD *)v36 + 17);
    while ( 1 )
    {
      v79 = *v78;
      if ( *((_DWORD *)v78 + 1) <= (unsigned int)v300 )
        break;
      v80 = *(_DWORD **)(v79 + 12 * (_DWORD)v300);
      if ( v80 )
      {
        do
        {
          v81 = (_DWORD *)v80[4];
          v82 = 3 * ((2 * *((_DWORD *)v78 + 1) - 1) & v80[7]);
          v83 = (char *)&v75[3 * ((2 * *((_DWORD *)v78 + 1) - 1) & v80[7])];
          v84 = *((_DWORD *)v83 + 1) + 1;
          *((_DWORD *)v83 + 1) = v84;
          v85 = *((_DWORD *)v77 + 17);
          if ( v84 > *(_DWORD *)(v85 + 24) )
          {
            v86 = *(_DWORD *)(v85 + 28);
            format = v83;
            *(_DWORD *)(v85 + 28) = v86 + 1;
            *((_DWORD *)format + 2) = *((_DWORD *)v83 + 1) / *(_DWORD *)(*((_DWORD *)v77 + 17) + 24);
          }
          v80[3] = 0;
          v80[4] = v75[v82];
          v87 = v75[v82];
          if ( v87 )
            *(_DWORD *)(v87 + 12) = v80;
          v75[v82] = v80;
          v80 = v81;
          v78 = (__int64 *)*((_DWORD *)v77 + 17);
        }
        while ( v81 );
      }
      ++v300;
    }
    free((void *)v79);
    v36 = v77;
    *(_DWORD *)(*((_DWORD *)v77 + 17) + 4) *= 2;
    ++*(_DWORD *)(*((_DWORD *)v77 + 17) + 8);
    **((_DWORD **)v77 + 17) = v75;
    v88 = (_DWORD *)*((_DWORD *)v77 + 17);
    v89 = v88[7];
    v90 = v88[3];
    v91 = v89 > v90 >> 1;
    if ( v89 <= v90 >> 1 )
      v92 = 0;
    else
      v92 = v88[8];
    if ( v91 )
      ++v92;
    v88[8] = v92;
    v93 = *((_DWORD *)v77 + 17);
    if ( *(_DWORD *)(v93 + 32) > 1u )
      *(_DWORD *)(v93 + 36) = 1;
    goto LABEL_86;
  }
LABEL_184:
  exit(-1);
}
