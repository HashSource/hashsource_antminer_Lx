//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct hostent {
    char *e0;
    char **e1;
    int32_t e2;
    int32_t e3;
    char **e4;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int32_t __libc_csu_fini(void);
int32_t __libc_csu_init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t _fini(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t _init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t _start(int32_t i_a1, int32_t i_a2);
int32_t callapi(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t display(int32_t i_a1);
int32_t function_1091c(char *s1, char *s2);
int32_t function_10928(int32_t fd, int32_t level, int32_t optname,
                       int32_t *optval, int32_t optlen);
int32_t function_10934(char *format, ...);
void function_10940(int32_t *ptr);
int16_t function_1094c(int16_t hostshort);
int32_t *function_10958(int32_t *ptr, int32_t size);
int32_t function_10964(char *s);
int32_t *function_10970(int32_t size);
int32_t function_1097c(int32_t main2, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
char *function_10988(int32_t errnum);
void function_10994(void);
int16_t **function_109a0(void);
int32_t function_109ac(char *s);
char *function_109b8(char *s, int32_t c);
int32_t function_109c4(struct _IO_FILE *stream, char *format, ...);
int32_t *function_109d0(void);
int32_t *function_109dc(int32_t *s, int32_t c, int32_t n);
int32_t function_109e8(char *nptr);
int32_t function_109f4(int32_t domain, int32_t type, int32_t protocol);
struct hostent *function_10a00(char *name);
void function_10a0c(void);
int32_t function_10a18(int32_t fd, int32_t *buf, int32_t n, int32_t flags);
int32_t function_10a24(int32_t fd);
int32_t function_10a30(int32_t fd, int32_t *buf, int32_t n, int32_t flags);
int32_t function_10a3c(int32_t fd, struct sockaddr *addr, int32_t len);
int32_t function_10a6c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10a78(void);
int32_t function_10a9c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10af8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5);
int32_t function_10b04(void);
int32_t function_111c4(int32_t i_a1);
int32_t unknown_240(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = -0x1cae0000;   // 0x10a88
char *p_g2;                   // 0x1152c
int32_t i_g3 = 0x10b05;       // 0x21f10
struct _IO_FILE *p_g4 = NULL; // 0x22080
int32_t i_g5 = 0;             // 0x22088
int32_t i_g6;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());

// ------------------------ Functions -------------------------

// Address range: 0x108fc - 0x10908
int32_t _init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x108fc
    return function_10a78();
}

// Address range: 0x1091c - 0x10928
int32_t function_1091c(char *s1, char *s2) {
    // 0x1091c
    return strcmp(s1, s2);
}

// Address range: 0x10928 - 0x10934
int32_t function_10928(int32_t fd, int32_t level, int32_t optname,
                       int32_t *optval, int32_t optlen) {
    // 0x10928
    return setsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x10934 - 0x10940
int32_t function_10934(char *format, ...) {
    // 0x10934
    return printf(format);
}

// Address range: 0x10940 - 0x1094c
void function_10940(int32_t *ptr) {
    // 0x10940
    free(ptr);
}

// Address range: 0x1094c - 0x10958
int16_t function_1094c(int16_t hostshort) {
    // 0x1094c
    return htons(hostshort);
}

// Address range: 0x10958 - 0x10964
int32_t *function_10958(int32_t *ptr, int32_t size) {
    // 0x10958
    return realloc(ptr, size);
}

// Address range: 0x10964 - 0x10970
int32_t function_10964(char *s) {
    // 0x10964
    return puts(s);
}

// Address range: 0x10970 - 0x1097c
int32_t *function_10970(int32_t size) {
    // 0x10970
    return malloc(size);
}

// Address range: 0x1097c - 0x10988
int32_t function_1097c(int32_t main2, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x1097c
    return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10988 - 0x10994
char *function_10988(int32_t errnum) {
    // 0x10988
    return strerror(errnum);
}

// Address range: 0x10994 - 0x109a0
void function_10994(void) {
    // 0x10994
    __gmon_start__();
}

// Address range: 0x109a0 - 0x109ac
int16_t **function_109a0(void) {
    // 0x109a0
    return __ctype_b_loc();
}

// Address range: 0x109ac - 0x109b8
int32_t function_109ac(char *s) {
    // 0x109ac
    return strlen(s);
}

// Address range: 0x109b8 - 0x109c4
char *function_109b8(char *s, int32_t c) {
    // 0x109b8
    return strchr(s, c);
}

// Address range: 0x109c4 - 0x109d0
int32_t function_109c4(struct _IO_FILE *stream, char *format, ...) {
    // 0x109c4
    return fprintf(stream, format);
}

// Address range: 0x109d0 - 0x109dc
int32_t *function_109d0(void) {
    // 0x109d0
    return __errno_location();
}

// Address range: 0x109dc - 0x109e8
int32_t *function_109dc(int32_t *s, int32_t c, int32_t n) {
    // 0x109dc
    return memset(s, c, n);
}

// Address range: 0x109e8 - 0x109f4
int32_t function_109e8(char *nptr) {
    // 0x109e8
    return atoi(nptr);
}

// Address range: 0x109f4 - 0x10a00
int32_t function_109f4(int32_t domain, int32_t type, int32_t protocol) {
    // 0x109f4
    return socket(domain, type, protocol);
}

// Address range: 0x10a00 - 0x10a0c
struct hostent *function_10a00(char *name) {
    // 0x10a00
    return gethostbyname(name);
}

// Address range: 0x10a0c - 0x10a18
void function_10a0c(void) {
    // 0x10a0c
    abort();
}

// Address range: 0x10a18 - 0x10a24
int32_t function_10a18(int32_t fd, int32_t *buf, int32_t n, int32_t flags) {
    // 0x10a18
    return recv(fd, buf, n, flags);
}

// Address range: 0x10a24 - 0x10a30
int32_t function_10a24(int32_t fd) {
    // 0x10a24
    return close(fd);
}

// Address range: 0x10a30 - 0x10a3c
int32_t function_10a30(int32_t fd, int32_t *buf, int32_t n, int32_t flags) {
    // 0x10a30
    return send(fd, buf, n, flags);
}

// Address range: 0x10a3c - 0x10a48
int32_t function_10a3c(int32_t fd, struct sockaddr *addr, int32_t len) {
    // 0x10a3c
    return connect(fd, addr, len);
}

// Address range: 0x10a48 - 0x10a6c
int32_t _start(int32_t i_a1, int32_t i_a2) {
    // 0x10a48
    int32_t i_v1; // 0x10a48
    __libc_start_main(0x11290, i_a2, (char **)&i_v1, (void (*)())0x114dd,
                      (void (*)())0x11290, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x10a6c - 0x10a70
int32_t function_10a6c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10a6c
    return i_a1;
}

// Address range: 0x10a78 - 0x10a94
int32_t function_10a78(void) {
    int32_t i_v1 =
        *(int32_t *)((int32_t)&i_g1 + (int32_t) "e: '%s'\n" + 112); // 0x10a84
    if (i_v1 == 0) {
        int32_t i_v2; // 0x10a78
        return i_v2;
    }
    // 0x10a90
    __gmon_start__();
    return &i_g6;
}

// Address range: 0x10a9c - 0x10af8
int32_t function_10a9c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10a9c
    bool i_v1; // 0x10a9c
    if (i_v1) {
        return i_a1;
    }
    // 0x10acc
    int32_t i_v2;                   // 0x10a9c
    int32_t i_v3 = 0x100001 * i_v2; // 0x10ad0
    bool i_v4;                      // 0x10a9c
    int32_t i_v5;                   // 0x10a9c
    if (i_v1) {
        // .thread
        i_v5 = i_v1 ? i_v3 : 0;
    } else {
        int32_t i_v6 = i_v3 & -1 - 0x400000 * i_v2; // 0x10ad4
        i_v5 = i_v6 < 1 ? 0 : i_v3;
        i_v4 = i_v6 < 0;
        if (i_v6 == 0) {
            return unknown_240();
        }
    }
    // 0x10ae4
    if (i_v4 != i_v1) {
        __asm_svclt(0x4770);
    }
    float64_t f_v7; // 0x10a9c
    __asm_vqrshl_s8(f_v7, f_v7);
    float128_t f_v8; // 0x10a9c
    __asm_vaddhn_i16(f_v8, f_v8);
    if (!i_v1) {
        *(int32_t *)i_a4 = i_v5;
    }
    return i_a1;
}

// Address range: 0x10af8 - 0x10b04
int32_t function_10af8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5) {
    int32_t i_v1 = i_a1; // 0x10af8
    if (i_a4 == 0) {
        // 0x10afa
        i_v1 = function_10a9c(i_a1, i_a2, i_a3, 0);
        int32_t i_v2; // 0x10af8
        *(char *)i_v2 = 1;
    }
    // 0x10b02
    return i_v1;
}

// Address range: 0x10b04 - 0x10b06
int32_t function_10b04(void) {
    // 0x10b04
    int32_t i_v1; // 0x10b04
    return i_v1;
}

// Address range: 0x10b08 - 0x10ce4
int32_t display(int32_t i_a1) {
    // 0x10b08
    if (i_a1 == 0) {
        // 0x10cd8
        return __asm_nop();
    }
    char *p_v1 = (char *)i_a1;      // 0x10b28
    char *p_v2 = strchr(p_v1, 124); // 0x10b28
    char *p_v3 = NULL;              // 0x10b38
    if (p_v2 != NULL) {
        // 0x10b3c
        *p_v2 = 0;
        p_v3 = (char *)((int32_t)p_v2 + 1);
    }
    char *p_v4 = p_v1;   // 0x10b5c
    char *p_v5;          // 0x10b08
    char *p_v6;          // 0x10b08
    char *p_v7;          // 0x10b08
    char *p_v8;          // 0x10b08
    int32_t i_v9;        // 0x10b08
    int32_t i_v10;       // 0x10b08
    unsigned char i_v11; // 0x10c14
    char *p_v12;         // 0x10b80
    int32_t i_v13;       // 0x10c98
    char *p_v14;         // 0x10bc4
    int16_t **p_v15;     // 0x10c04
    if (!((i_a1 == 0 | *p_v1 == 0))) {
        p_v5 = p_v4;
        i_v9 = 0;
        p_v12 = strchr(p_v5, 44);
        p_v6 = NULL;
        if (p_v12 != NULL) {
            // 0x10b94
            *p_v12 = 0;
            p_v6 = (char *)((int32_t)p_v12 + 1);
        }
        // 0x10ba8
        if (*p_v5 != 0) {
            // 0x10bb8
            p_v14 = strchr(p_v5, 61);
            p_v7 = NULL;
            if (p_v14 != NULL) {
                // 0x10bd8
                *p_v14 = 0;
                p_v7 = (char *)((int32_t)p_v14 + 1);
            }
            // 0x10bec
            p_v8 = p_v7;
            if (i_v9 == 0) {
                // 0x10bf8
                i_v10 = (int32_t)&p_g2;
                if (p_v8 != NULL) {
                    // 0x10c04
                    p_v15 = __ctype_b_loc();
                    i_v11 = *p_v8;
                    i_v10 = (int32_t)&p_g2;
                    if ((*(int16_t *)(2 * (int32_t)i_v11 + (int32_t)*p_v15) &
                         2048) != 0) {
                        // 0x10c30
                        i_v10 = (int32_t)p_v8;
                    }
                }
                // 0x10c40
                printf("[%s%s] =>\n(\n", p_v5, (char *)i_v10);
            }
            if (p_v8 == NULL) {
                // 0x10c78
                printf("   [%d] => %s\n", i_v9, p_v5);
            } else {
                // 0x10c60
                printf("   [%s] => %s\n", p_v5, p_v8);
            }
        }
        // 0x10c8c
        i_v13 = i_v9 + 1;
        while (p_v6 != NULL) {
            // 0x10b74
            p_v5 = p_v6;
            i_v9 = i_v13;
            p_v12 = strchr(p_v5, 44);
            p_v6 = NULL;
            if (p_v12 != NULL) {
                // 0x10b94
                *p_v12 = 0;
                p_v6 = (char *)((int32_t)p_v12 + 1);
            }
            // 0x10ba8
            if (*p_v5 != 0) {
                // 0x10bb8
                p_v14 = strchr(p_v5, 61);
                p_v7 = NULL;
                if (p_v14 != NULL) {
                    // 0x10bd8
                    *p_v14 = 0;
                    p_v7 = (char *)((int32_t)p_v14 + 1);
                }
                // 0x10bec
                p_v8 = p_v7;
                if (i_v9 == 0) {
                    // 0x10bf8
                    i_v10 = (int32_t)&p_g2;
                    if (p_v8 != NULL) {
                        // 0x10c04
                        p_v15 = __ctype_b_loc();
                        i_v11 = *p_v8;
                        i_v10 = (int32_t)&p_g2;
                        if ((*(int16_t *)(2 * (int32_t)i_v11 +
                                          (int32_t)*p_v15) &
                             2048) != 0) {
                            // 0x10c30
                            i_v10 = (int32_t)p_v8;
                        }
                    }
                    // 0x10c40
                    printf("[%s%s] =>\n(\n", p_v5, (char *)i_v10);
                }
                if (p_v8 == NULL) {
                    // 0x10c78
                    printf("   [%d] => %s\n", i_v9, p_v5);
                } else {
                    // 0x10c60
                    printf("   [%s] => %s\n", p_v5, p_v8);
                }
            }
            // 0x10c8c
            i_v13 = i_v9 + 1;
        }
        if (i_v13 >= 1) {
            // 0x10cb8
            puts(")");
        }
    }
    int32_t i_v16 = (int32_t)p_v3; // 0x10cd4
    while (p_v3 != NULL) {
        // 0x10b1c
        p_v1 = (char *)i_v16;
        p_v2 = strchr(p_v1, 124);
        p_v3 = NULL;
        if (p_v2 != NULL) {
            // 0x10b3c
            *p_v2 = 0;
            p_v3 = (char *)((int32_t)p_v2 + 1);
        }
        // 0x10b50
        p_v4 = p_v1;
        if (!((i_v16 == 0 | *p_v1 == 0))) {
            p_v5 = p_v4;
            i_v9 = 0;
            p_v12 = strchr(p_v5, 44);
            p_v6 = NULL;
            if (p_v12 != NULL) {
                // 0x10b94
                *p_v12 = 0;
                p_v6 = (char *)((int32_t)p_v12 + 1);
            }
            // 0x10ba8
            if (*p_v5 != 0) {
                // 0x10bb8
                p_v14 = strchr(p_v5, 61);
                p_v7 = NULL;
                if (p_v14 != NULL) {
                    // 0x10bd8
                    *p_v14 = 0;
                    p_v7 = (char *)((int32_t)p_v14 + 1);
                }
                // 0x10bec
                p_v8 = p_v7;
                if (i_v9 == 0) {
                    // 0x10bf8
                    i_v10 = (int32_t)&p_g2;
                    if (p_v8 != NULL) {
                        // 0x10c04
                        p_v15 = __ctype_b_loc();
                        i_v11 = *p_v8;
                        i_v10 = (int32_t)&p_g2;
                        if ((*(int16_t *)(2 * (int32_t)i_v11 +
                                          (int32_t)*p_v15) &
                             2048) != 0) {
                            // 0x10c30
                            i_v10 = (int32_t)p_v8;
                        }
                    }
                    // 0x10c40
                    printf("[%s%s] =>\n(\n", p_v5, (char *)i_v10);
                }
                if (p_v8 == NULL) {
                    // 0x10c78
                    printf("   [%d] => %s\n", i_v9, p_v5);
                } else {
                    // 0x10c60
                    printf("   [%s] => %s\n", p_v5, p_v8);
                }
            }
            // 0x10c8c
            i_v13 = i_v9 + 1;
            while (p_v6 != NULL) {
                // 0x10b74
                p_v5 = p_v6;
                i_v9 = i_v13;
                p_v12 = strchr(p_v5, 44);
                p_v6 = NULL;
                if (p_v12 != NULL) {
                    // 0x10b94
                    *p_v12 = 0;
                    p_v6 = (char *)((int32_t)p_v12 + 1);
                }
                // 0x10ba8
                if (*p_v5 != 0) {
                    // 0x10bb8
                    p_v14 = strchr(p_v5, 61);
                    p_v7 = NULL;
                    if (p_v14 != NULL) {
                        // 0x10bd8
                        *p_v14 = 0;
                        p_v7 = (char *)((int32_t)p_v14 + 1);
                    }
                    // 0x10bec
                    p_v8 = p_v7;
                    if (i_v9 == 0) {
                        // 0x10bf8
                        i_v10 = (int32_t)&p_g2;
                        if (p_v8 != NULL) {
                            // 0x10c04
                            p_v15 = __ctype_b_loc();
                            i_v11 = *p_v8;
                            i_v10 = (int32_t)&p_g2;
                            if ((*(int16_t *)(2 * (int32_t)i_v11 +
                                              (int32_t)*p_v15) &
                                 2048) != 0) {
                                // 0x10c30
                                i_v10 = (int32_t)p_v8;
                            }
                        }
                        // 0x10c40
                        printf("[%s%s] =>\n(\n", p_v5, (char *)i_v10);
                    }
                    if (p_v8 == NULL) {
                        // 0x10c78
                        printf("   [%d] => %s\n", i_v9, p_v5);
                    } else {
                        // 0x10c60
                        printf("   [%s] => %s\n", p_v5, p_v8);
                    }
                }
                // 0x10c8c
                i_v13 = i_v9 + 1;
            }
            if (i_v13 >= 1) {
                // 0x10cb8
                puts(")");
            }
        }
        // 0x10cc4
        i_v16 = (int32_t)p_v3;
    }
    // 0x10cd8
    return __asm_nop();
}

// Address range: 0x10ce4 - 0x111c4
int32_t callapi(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    char *p_v1 = (char *)i_a2; // 0x10d14
    if (gethostbyname(p_v1) == NULL) {
        // 0x10d28
        printf("Couldn't get hostname: '%s'\n", p_v1);
        // 0x111b8
        return 1;
    }
    int32_t i_v2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x10d4c
    if (i_v2 == -1) {
        // 0x10d60
        printf("Socket initialisation failed: %s\n",
               strerror(*__errno_location()));
        // 0x111b8
        return 1;
    }
    // 0x10d90
    int32_t i_v3; // bp-56, 0x10ce4
    memset(&i_v3, 0, 16);
    i_v3 = 2;
    htons((int16_t)i_a3);
    if (connect(i_v2, (struct sockaddr *)&i_v3, 16) < 0) {
        // 0x10df4
        printf("Socket connect failed: %s\n", strerror(*__errno_location()));
        // 0x111b8
        return 1;
    }
    int32_t i_v4 = 1; // bp-64, 0x10e34
    if (setsockopt(i_v2, SO_DEBUG, 13, &i_v4, 8) != 0) {
        // 0x10e68
        printf("cgminer-api, setsocket SO_LINGER failed (%s)\n",
               strerror(*__errno_location()));
        close(i_v2);
    }
    int32_t i_v5 = 10; // bp-72, 0x10e9c
    if (setsockopt(i_v2, SO_DEBUG, 21, &i_v5, 8) != 0) {
        // 0x10ed8
        printf("cgminer-api, setsocket SO_SNDTIMEO failed (%s)\n",
               strerror(*__errno_location()));
        close(i_v2);
    }
    int32_t i_v6 = setsockopt(i_v2, SO_DEBUG, 20, &i_v5, 8); // 0x10f24
    if (i_v6 != 0) {
        // 0x10f38
        printf("cgminer-api, setsocket SO_RCVTIMEO failed (%s)\n",
               strerror(*__errno_location()));
        close(i_v2);
    }
    char *p_v7 = (char *)i_a1;                                    // 0x10f6c
    uint32_t i_v8 = send(i_v2, (int32_t *)i_a1, strlen(p_v7), 0); // 0x10f80
    int32_t i_v9;                                                 // 0x10ce4
    if (i_v8 <= 0) {
        // 0x10f94
        printf("cgminer api send failed: %s\n", strerror(*__errno_location()));
        i_v9 = 1;
    lab_0x111ac:
        // 0x111ac
        close(i_v2);
        // 0x111b8
        return i_v9;
    }
    // 0x10fc8
    if (strlen(p_v7) != i_v8) {
        // 0x111ac
        close(i_v2);
        // 0x111b8
        return i_v6;
    }
    int32_t *p_v10 = malloc(0x10000); // 0x10ff4
    if (p_v10 == NULL) {
        // 0x1100c
        printf("cgminer api: OOM (%d)\n", 0x10000);
        // 0x111b8
        return 1;
    }
    char *p_v11 = (char *)p_v10; // 0x11038
    int32_t i_v12 = 0;           // 0x11038
    int32_t i_v13 = 0;           // 0x11038
    int32_t i_v14;               // 0x10ce4
    int32_t i_v15;               // 0x10ce4
    int32_t i_v16;               // 0x11060
    int32_t i_v17;               // 0x110a0
    while (true) {
        uint32_t i_v18 = i_v13;
        int32_t i_v19 = i_v12;
        int32_t i_v20 = i_v12;
        char *p_v21 = p_v11;
        char *p_v22 = p_v21;   // 0x11048
        int32_t i_v23 = i_v20; // 0x11048
        if (i_v20 == i_v19) {
            // 0x1104c
            i_v16 = i_v20 + 0x10000;
            int32_t *p_v24 = realloc((int32_t *)p_v21, i_v16); // 0x1106c
            p_v22 = (char *)p_v24;
            i_v23 = i_v20 + 0xffff;
            if (p_v24 == NULL) {
                // break -> 0x11080
                break;
            }
        }
        // 0x110a0
        i_v12 = i_v23;
        p_v11 = p_v22;
        i_v17 = (int32_t)p_v11;
        int32_t i_v25 =
            recv(i_v2, (int32_t *)(i_v19 + i_v17), i_v12 - i_v19, 0); // 0x110c0
        if (i_v25 < 0) {
            // 0x110d4
            printf("Recv failed: %s\n", strerror(*__errno_location()));
            i_v14 = 1;
            i_v15 = i_v19;
            goto lab_0x11168;
        }
        if (i_v25 == 0) {
            // 0x11114
            puts("Recv failed: api server close the socket");
            i_v14 = 1;
            i_v15 = i_v19;
            goto lab_0x11168;
        }
        int32_t i_v26 = i_v25 + i_v19; // 0x11134
        if (i_v12 != i_v26) {
            // 0x11164
            __asm_nop();
            i_v14 = i_v6;
            i_v15 = i_v26;
            goto lab_0x11168;
        }
        // 0x1114c
        i_v13 = i_v18 + 1;
        i_v14 = i_v6;
        i_v15 = i_v12;
        if (i_v18 >= 2) {
            goto lab_0x11168;
        }
    }
    // 0x11080
    printf("cgminer realloc: OOM (%d)\n", i_v16);
    // 0x111b8
    return 1;
lab_0x11168:
    // 0x11168
    *(char *)(i_v15 + i_v17) = 0;
    if (i_g5 == 0) {
        // 0x1119c
        display(i_v17);
        // 0x111a4
        free((int32_t *)p_v11);
        i_v9 = i_v14;
        goto lab_0x111ac;
    } else {
        // 0x11190
        puts(p_v11);
        // 0x111a4
        free((int32_t *)p_v11);
        i_v9 = i_v14;
        goto lab_0x111ac;
    }
}

// Address range: 0x111c4 - 0x11290
int32_t function_111c4(int32_t i_a1) {
    uint32_t i_v1 = i_a1;
    int16_t *p_v2 = *__ctype_b_loc(); // 0x111ec
    char *p_v3 = (char *)i_v1;        // 0x111f4
    int32_t i_v4 = i_v1 + 1;          // 0x1120c
    while ((*(int16_t *)(2 * (int32_t)*p_v3 + (int32_t)p_v2) & 0x2000) != 0) {
        // 0x111e4
        i_v1 = i_v4;
        p_v2 = *__ctype_b_loc();
        p_v3 = (char *)i_v1;
        i_v4 = i_v1 + 1;
    }
    int32_t i_v5 = strlen(p_v3) + i_v1; // 0x11224
    if (i_v1 >= i_v5) {
        // 0x11280
        return i_v1;
    }
    int32_t i_v6 = i_v5; // 0x1127c
    i_v6--;
    char *p_v7 = (char *)i_v6;
    int16_t **p_v8 = __ctype_b_loc(); // 0x11230
    if ((*(int16_t *)(2 * (int32_t)*p_v7 + (int32_t)*p_v8) & 0x2000) != 0) {
        // 0x1125c
        *p_v7 = 0;
    }
    while (i_v1 < i_v6) {
        // 0x11230
        i_v6--;
        p_v7 = (char *)i_v6;
        p_v8 = __ctype_b_loc();
        if ((*(int16_t *)(2 * (int32_t)*p_v7 + (int32_t)*p_v8) & 0x2000) != 0) {
            // 0x1125c
            *p_v7 = 0;
        }
    }
    // 0x11280
    return i_v1;
}

// Address range: 0x11290 - 0x114dc
int main(int argc, char **argv) {
    int32_t i_v1 = 1; // 0x112d4
    int32_t i_v2;     // 0x11290
    if (argc < 2) {
        goto lab_0x113c8;
    } else {
        int32_t *p_v3 = (int32_t *)((int32_t)argv + 4);
        i_v2 = (int32_t) "-?";
        if (strcmp((char *)*p_v3, "-?") == 0) {
            goto lab_0x11350;
        } else {
            // 0x11300
            i_v2 = (int32_t) "-h";
            if (strcmp((char *)*p_v3, "-h") == 0) {
                goto lab_0x11350;
            } else {
                // 0x11328
                i_v2 = (int32_t) "--help";
                if (strcmp((char *)*p_v3, "--help") == 0) {
                    goto lab_0x11350;
                } else {
                    // 0x11388
                    i_v1 = 1;
                    if (strcmp((char *)*p_v3, "-o") == 0) {
                        // 0x113b0
                        i_g5 = 1;
                        i_v1 = 2;
                    }
                    goto lab_0x113c8;
                }
            }
        }
    }
lab_0x113c8:;
    char *p_v4 = "summary"; // 0x113d4
    int32_t i_v5 = i_v1;    // 0x113d4
    if (i_v1 < argc) {
        int32_t i_v6 = *(int32_t *)(4 * i_v1 + (int32_t)argv); // 0x113f0
        char *p_v7 = (char *)function_111c4(i_v6);             // 0x113fc
        p_v4 = *p_v7 == 0 ? "summary" : p_v7;
        i_v5 = i_v1 + 1;
    }
    char *p_v8 = "127.0.0.1"; // 0x11424
    int32_t i_v9 = i_v5;      // 0x11424
    if (i_v5 < argc) {
        int32_t i_v10 = *(int32_t *)(4 * i_v5 + (int32_t)argv); // 0x11440
        char *p_v11 = (char *)function_111c4(i_v10);            // 0x1144c
        p_v8 = *p_v11 == 0 ? "127.0.0.1" : p_v11;
        i_v9 = i_v5 + 1;
    }
    int32_t i_v12 = 4028; // 0x11474
    if (i_v9 < argc) {
        int32_t i_v13 = *(int32_t *)(4 * i_v9 + (int32_t)argv); // 0x11488
        char *p_v14 = (char *)function_111c4(i_v13);            // 0x11494
        i_v12 = 4028;
        if (*p_v14 != 0) {
            // 0x114a8
            i_v12 = 0x10000 * atoi(p_v14) >> 16;
        }
    }
    // 0x114d0
    return callapi((int32_t)p_v4, (int32_t)p_v8, i_v12);
lab_0x11350:
    // 0x11350
    fprintf(p_g4, "usAge: %s [command [ip/host [port]]]\n", (char *)i_v2);
    // 0x114d0
    return 1;
}

// Address range: 0x114dc - 0x11510
int32_t __libc_csu_init(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                        int32_t i_a4) {
    int32_t i_v1 = _init(i_a1, i_a2, i_a3, i_a4); // 0x114ec
    return 0x21f12 - (int32_t)&i_g3 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x11518 - 0x1151a
int32_t __libc_csu_fini(void) {
    // 0x11518
    int32_t i_v1; // 0x11518
    return i_v1;
}

// Address range: 0x1151c - 0x11524
int32_t _fini(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x1151c
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 39
