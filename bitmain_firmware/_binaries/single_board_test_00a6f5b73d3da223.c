/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_205A0();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// int __fastcall zlog_init(_DWORD); weak
// char *strstr(const char *haystack, const char *needle);
// int __fastcall zlog_get_category(_DWORD); weak
// int raise(int sig);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int printf(const char *format, ...);
// int _isoc99_fscanf(_DWORD, const char *, ...); weak
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int getchar(void);
// int tolower(int c);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// time_t time(time_t *timer);
// __off_t lseek(int fd, __off_t offset, int whence);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *inet_ntoa(struct in_addr in);
// unsigned int sleep(unsigned int seconds);
// char *strdup(const char *s);
// uint16_t htons(uint16_t hostshort);
// int pthread_condattr_init(pthread_condattr_t *attr);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int _isinf(double value);
// void *realloc(void *ptr, size_t size);
// int pthread_condattr_setclock(pthread_condattr_t *attr, __clockid_t clock_id);
// int pthread_cond_destroy(pthread_cond_t *cond);
// void perror(const char *s);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int ioctl(int fd, unsigned int request, ...);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int sched_yield(void);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// char *getenv(const char *name);
// int puts(const char *s);
// void *malloc(size_t size);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
// int system(const char *command);
// struct tm *localtime(const time_t *timer);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// __pid_t getpid(void);
// void exit(int status);
// int syscall(int sysno, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// char *strchr(const char *s, int c);
// int fprintf(FILE *stream, const char *format, ...);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// void *memset(void *s, int c, size_t n);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int putchar(int c);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// int fgetc(FILE *stream);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// ssize_t write(int fd, const void *buf, size_t n);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int _isnan(double value);
// void *memchr(const void *s, int c, size_t n);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// int access(const char *name, int type);
// int rand(void);
// int fclose(FILE *stream);
// int __fastcall zlog_fini(_DWORD); weak
// int munmap(void *addr, size_t len);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// int putenv(char *string);
// int __fastcall zlog_reload(_DWORD); weak
// int pthread_join(pthread_t th, void **thread_return);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int atoi(const char *nptr);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int socket(int domain, int type, int protocol);
// double atof(const char *nptr);
// in_addr_t inet_addr(const char *cp);
// struct hostent *gethostbyname(const char *name);
// int fseek(FILE *stream, int off, int whence);
// __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_20B30();
int *sub_20B54();
int register_tm_clones();
int *sub_20BA4();
int frame_dummy();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_20BE0(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_20C04(int a1, __int64 a2);
int __fastcall sub_20C2C(int result, int a2, unsigned int a3);
int __fastcall sub_20D0C(unsigned __int8 a1);
_BYTE *__fastcall sub_20E10(_BYTE *result, int a2);
int __fastcall sub_20E58(int a1, int a2);
int __fastcall sub_21440(int a1);
int __fastcall sub_21534(int a1, char a2);
int __fastcall sub_21644(int a1, char *a2);
int __fastcall sub_218D8(int a1, char *a2);
unsigned int *__fastcall sub_21AFC(unsigned int *result);
int __fastcall sub_21C0C(int a1);
int __fastcall sub_21D60(int a1, char a2);
int __fastcall sub_21EE0(int a1);
int __fastcall sub_222CC(int a1, int a2);
int __fastcall sub_223E8(int a1, char a2, char a3, int a4);
int __fastcall sub_22434(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_22554(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_225C8(int a1, int a2, int a3, size_t a4);
int __fastcall sub_2266C(int a1, int a2, int a3, size_t a4);
int __fastcall sub_22710(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_22774(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_227D8(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_229B0(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_22B8C(int a1);
int __fastcall sub_22BC4(int a1);
int __fastcall sub_22C18(int a1, void *a2, unsigned int a3);
int __fastcall sub_22EE4(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_22F70(int a1, int a2, void *a3);
int __fastcall sub_23220(int a1, __int16 a2, int a3);
int __fastcall sub_23268(int a1, __int16 a2, int a3);
int __fastcall sub_232C0(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_23320(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_23384(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_233E0(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_23764(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall sub_23ADC(int result, int a2);
int __fastcall sub_23B38(int a1, unsigned __int8 a2, int a3);
int __fastcall sub_23B80(int a1, unsigned __int8 a2, signed int a3, int a4);
int __fastcall pcba_ltc_reg_init(int result);
int pcba_is_ltc_asic_valid();
int pcba_calc_ltc_core_num();
bool __fastcall sub_23D10(_DWORD *a1, char a2);
int __fastcall sub_23DD8(int a1, unsigned __int8 a2);
int __fastcall pcba_setup_all_chip_ltc(int a1);
int __fastcall pcba_ltc_recv(int a1);
int __fastcall pcba_ltc_send(int a1, int a2);
int __fastcall pcba_read_ltc_temperature(int a1, int *a2, int *a3, int *a4, int *a5, _DWORD *a6, _DWORD *a7);
void pcba_statistic_ltc_pattern_test_results();
int pcba_check_nonce_ltc();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_243A8(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_243CC(int a1, __int64 a2);
int __fastcall sub_243F4(int result, int a2, unsigned int a3);
int __fastcall sub_244D4(unsigned __int8 a1);
_BYTE *__fastcall sub_245D8(_BYTE *result, int a2);
int __fastcall sub_24620(int a1, int a2);
int __fastcall sub_24C08(int a1);
int __fastcall sub_24CFC(int a1, char a2);
int __fastcall sub_24E0C(int a1, unsigned __int8 a2);
int __fastcall sub_24F30(int a1, char *a2);
int __fastcall sub_251C4(int a1, char *a2);
unsigned int *__fastcall sub_253E8(unsigned int *result);
int __fastcall sub_254F8(int a1);
int __fastcall sub_2564C(int a1, char a2);
int __fastcall sub_257CC(int a1, char a2, int a3);
int __fastcall sub_258F8(int a1, char a2);
int __fastcall sub_25A08(int a1);
int __fastcall sub_25CF8(int a1);
int __fastcall sub_2615C(int a1);
int __fastcall sub_26548(int a1, int a2);
int __fastcall sub_26664(int a1, char a2, char a3, int a4);
int __fastcall sub_266B0(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_267D0(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_26844(int a1, int a2, int a3, size_t a4);
int __fastcall sub_268E8(int a1, int a2, int a3, size_t a4);
int __fastcall sub_2698C(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_269F0(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_26A54(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_26C2C(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_26E08(int a1);
int __fastcall sub_26E40(int a1);
int __fastcall sub_26E94(int a1, void *a2, unsigned int a3);
int __fastcall sub_27160(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_271EC(int a1, int a2, void *a3);
int __fastcall sub_2749C(int a1, __int16 a2, int a3);
int __fastcall sub_274E4(int a1, __int16 a2, int a3);
int __fastcall sub_2753C(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_2759C(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_27600(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_2765C(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_279E0(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall pcba_dash_reg_init(int result);
int pcba_is_dash_asic_valid();
int pcba_calc_dash_core_num();
int __fastcall pcba_dash_recv(int a1);
int __fastcall pcba_dash_send(int a1, int a2);
int __fastcall pcba_read_dash_temperature(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
void pcba_statistic_dash_pattern_test_results();
int pcba_check_nonce_dash();
int __fastcall pcba_setup_all_chip_dash(int a1);
int __fastcall pcba_set_baud_dash(int a1, char *a2);
int __fastcall dump_pt2_result(int a1, int a2);
int __fastcall init_history_result(int a1);
int __fastcall sub_2874C(int a1);
int sub_28C58();
int sub_28CE8();
int sub_28DAC();
int __fastcall check_whether_board_changed(int a1);
int __fastcall pcba_set_fan_pwm(int a1);
int __fastcall pcba_save_config_to_pic(int a1);
int sub_29190();
int sub_2925C();
int __fastcall sub_293BC(int a1);
int __fastcall sub_29414(int a1);
int __fastcall sub_2A080(int a1);
int __fastcall sub_2A240(int a1);
int pcba_boot_area_test();
int pcba_basic_area_test();
int pcba_miner_area_test();
int singleBoardTest_fpgaminer();
int __fastcall singleBoardTest_asicminer(int a1);
void __noreturn restart_single_board_test();
int __fastcall main(int argc, const char **argv, const char **envp);
size_t __fastcall pcba_fill_lcd_result(const char *a1);
int pcba_lcd_dump();
int pcba_display_result_on_lcd();
int __fastcall lcd_show(unsigned __int8 a1, const char *a2);
int lcd_clear_result_pcba();
int __fastcall lcd_show_one(unsigned __int8 a1, const char *a2);
void __cdecl json_decref(json_t_0 *json);
int __fastcall get_key_value_string(const json_t *a1, const char *a2, void **a3);
int __fastcall get_key_value_interger(const json_t *a1, const char *a2, int *a3);
int __fastcall get_key_value_real(const json_t *a1, const char *a2, _QWORD *a3);
int __fastcall get_key_value_boolean(const json_t *a1, const char *a2, bool *a3);
int __fastcall get_key_value_array_interger(const json_t *a1, const char *a2, void **a3, size_t *a4);
int __fastcall get_key_value_array_real(const json_t *a1, const char *a2, void **a3, size_t *a4);
bool __fastcall parse_config(const json_t *a1, int a2);
bool __fastcall read_config_json(_DWORD *a1);
int __cdecl parse_config_ini_array(const char *str, void **pointer);
int __fastcall read_config_ini(void **a1);
void __fastcall config_free(int a1);
int __fastcall get_algo_type(const char *a1, int *a2);
bool __fastcall proofread_config(_DWORD *a1);
void *app_config_init();
int __fastcall load_patterns(int a1);
int get_app_config_handle();
void app_config_exit();
int __fastcall print_app_config(int a1);
int __fastcall sub_2E338(int result, int a2, unsigned int a3);
int __fastcall sub_2E418(unsigned __int8 a1);
int pcba_is_vbk_asic_valid();
int __fastcall pcba_calc_vbk_core_num(_DWORD *a1);
int __fastcall pcba_vbk_recv(int a1);
int __fastcall pcba_vbk_send(int a1, int *a2);
int pcba_statistic_vbk_pattern_test_results(); // weak
json_t_0 *__cdecl json_incref(json_t_0 *json);
void __fastcall sub_2E8A8(int a1);
int __cdecl json_object_set(json_t_0 *object, const char *key, json_t_0 *value);
int __cdecl json_array_append(json_t_0 *array, json_t_0 *value);
int __fastcall substr(const char *a1, int a2, unsigned int a3, int a4);
int __fastcall set_socket_feature(int a1);
int32_t __cdecl get_local_ip(char *ifname, char *ip);
bool create_connection_to_MES_system_by_ip();
int __fastcall create_connection_to_MES_system_by_name(int a1);
int __fastcall prepare_MES_system_handshake_information(int a1);
int __fastcall send_message_to_bitmain_MES_system(const void *a1, size_t a2);
char *__fastcall receive_message_from_bitmain_MES_system(unsigned int *a1);
int download_MES_system_Config_file();
int check_whether_MES_system_response_is_correct();
int __fastcall save_MES_system_config_information(int a1);
int init_MES_system_config_information();
int __fastcall parse_MES_system_config_information(int a1);
int parse_all_MES_system_config_information();
int print_MES_system_information();
int __fastcall find_test_standard_position(int a1, const char *a2, const char *a3, const char *a4, const char *a5, const char *a6, const char *a7, char *a8, int a9);
int __fastcall prepare_test_standard(int a1);
int __fastcall check_whether_MES_system_submit_result_is_correct(const json_t *a1);
int __fastcall prepare_MES_system_submit_information(int a1);
int submit_result_to_MES_system();
int save_MES_system_submit_result();
int __fastcall sub_34948(int a1);
unsigned __int64 __fastcall sub_34A64(unsigned __int64 *a1);
int __fastcall pcba_eth_recv(int a1);
int __fastcall pcba_eth_send(int a1, int a2);
int __fastcall pcba_eth_stage_send_work(int a1);
int __fastcall pcba_read_eth_temperature(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
int __fastcall pcba_eth_reg_init(int a1, int a2);
int __fastcall pcba_eth_stop_mining(int a1);
int pcba_is_eth_asic_valid();
int pcba_calc_eth_core_num();
int __fastcall pcba_calc_eth_pe_num(int result, int *a2, int *a3);
int pcba_calc_eth_jig_level();
void pcba_statistic_eth_pattern_test_results();
int pcba_check_nonce_eth();
int32_t detect_scan_code_gun(); // idb
int __fastcall sub_3516C(const char *a1, _BYTE *a2, _BYTE *a3, const char *a4, _BYTE *a5);
int32_t __cdecl recv_scan_data(char *recv_buffer, int32_t length);
int flush_scanner_data();
int __fastcall scan_hashboard_info(char a1, _BYTE *a2, const char *a3, _BYTE *a4, _BYTE *a5, int a6);
int __fastcall get_chip_bin(int a1);
int __fastcall get_chip_ft_program_version(_BYTE *a1, unsigned __int8 *a2);
int __fastcall get_chip_ft_program_version_ex(int a1, int a2);
int __fastcall get_hardware_infor(char *a1);
void __cdecl get_chip_technology(hashboard_qr_code *qr_code);
int __fastcall sub_35BB8(int a1, unsigned __int8 a2, int a3);
int __fastcall sub_35C00(int a1, unsigned __int8 a2, signed int a3, int a4);
bool __fastcall sub_35D38(unsigned int a1);
int __fastcall sub_35D80(int a1, const char *a2, int a3, int a4, int a5);
int __fastcall sub_3612C(int a1, const char *a2);
int __fastcall sub_3633C(int a1, const char *a2, int a3, int a4);
int __fastcall sub_365F8(int a1, const char *a2);
int __fastcall sub_36840(int a1, int a2, int a3, int a4, const char *a5);
int __fastcall sub_36C5C(int a1, int a2);
int __fastcall sub_36F08(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_374F0(int a1, int a2);
int __fastcall sub_37780(int a1);
int __fastcall pcba_fpga_ip_test(int a1);
int __fastcall pcba_match_fpga_baud(int a1, int a2);
int __fastcall sub_379DC(int a1, unsigned __int8 a2);
int __fastcall pcba_set_address(int a1);
int __fastcall pcba_get_chip_num(int a1);
unsigned int __fastcall sub_37AE8(char *a1);
int __fastcall pcba_set_chips_baud(int a1, int a2, char *a3);
int __fastcall pcba_set_baud(int a1, int a2, int a3);
int __fastcall pcba_set_ticket_mask(int a1, int a2);
int __fastcall pcba_read_fpga_temperature(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
bool __fastcall sub_37D70(unsigned int a1);
int __fastcall sub_37DB0(unsigned int a1);
int pcba_start_boot();
int __fastcall pcba_start_basic(int a1, int a2);
int __fastcall pcba_start_fpgaminer(int a1, int a2);
int __fastcall find_APW_power_version(int a1);
int __fastcall pcba_power_on(unsigned int a1, int a2);
int __fastcall pcba_set_working_voltage(int a1, int a2);
int __fastcall pcba_power_off(int a1);
int8_t __cdecl get_max_value(int8_t *data, uint8_t data_length);
int8_t __cdecl get_min_value(int8_t *data, uint8_t data_length);
uint8_t __cdecl CRC5_long(const uint8_t *pdata, uint32_t length);
int __fastcall print_eeprom_data_in_hex(int a1, unsigned int a2);
int display_main_page();
int malloc_for_mes_config_information();
void *__fastcall copy_app_config(int a1);
int __fastcall prepare_mes_config_test_process(int a1);
int __fastcall check_scan_code_gun(int a1);
int __fastcall check_sn_qr_code_legality(int a1, const char *a2);
int __fastcall scan_code_from_hashboard(int a1);
int print_local_config_after_parse_MES_system_information();
int __fastcall get_sensor_type(int a1);
int print_eeprom_data();
int __fastcall prepare_eeprom_data(int a1);
int __fastcall PT2_display_result_on_LCD(int a1);
int __fastcall do_PT2_summary_work(unsigned __int8 a1);
int __fastcall find_submit_history_result_index(unsigned __int8 *a1);
int __fastcall copy_eeprom(unsigned int a1, unsigned int a2);
int __fastcall check_eeprom(unsigned int a1);
int dump_eeprom_data();
int write_EEPROM_PT1_marker();
int check_PT1_EEPROM_marker();
int __fastcall sub_3BB90(int a1, unsigned __int8 a2, int a3);
int __fastcall sub_3BBD8(int a1, unsigned __int8 a2, signed int a3, int a4);
int __fastcall pcba_ckb_reg_init(int result);
int pcba_is_ckb_asic_valid();
int pcba_calc_ckb_core_num();
int __fastcall pcba_ckb_recv(int a1);
int __fastcall pcba_ckb_send(int a1, int a2);
int __fastcall pcba_read_ckb_temperature(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
void pcba_statistic_ckb_pattern_test_results();
int pcba_chain_check();
int __fastcall is_asic_pass(int a1);
void __cdecl _list_add(list_head *new, list_head *prev, list_head *next);
void __cdecl list_add_tail(list_head *new, list_head *head);
unsigned __int8 __cdecl c2hex_0(unsigned __int8 value);
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low);
int __cdecl s2hex(unsigned __int8 *dst, const char *src, int inlen);
int __fastcall get_work_by_key(const json_t *a1, const char *a2, unsigned __int8 *a3, int a4);
int __fastcall get_work_element_len(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __fastcall get_work(int a1, const json_t *a2, int a3, int a4);
unsigned int __fastcall get_core_works(int a1, const char *a2, int a3, size_t a4);
int __fastcall get_core_works_from_txt(int a1, const char *a2, int a3, int a4);
int __fastcall eth_get_works_from_txt(const char *a1, list_head *a2, int a3, unsigned int a4);
int __fastcall get_all_works(int a1);
int __fastcall print_works(int a1);
int __fastcall sub_3CE08(int result, int a2, unsigned int a3);
int __fastcall sub_3CEE8(unsigned __int8 a1);
__int64 __fastcall sub_3CFEC(unsigned __int8 *a1);
_BYTE *__fastcall sub_3D0F4(_BYTE *result, int a2, int a3, int a4);
bool __fastcall pcba_is_grin29_asic_valid(_DWORD *a1);
int pcba_calc_grin29_core_num();
int __fastcall pcba_grin29_recv(int a1);
int __fastcall pcba_grin29_send(int a1, int *a2);
int pcba_statistic_grin29_pattern_test_results(); // weak
__int64 __fastcall sub_3D648(int a1);
__int64 sub_3D718();
int sub_3D8B8();
int __fastcall sub_3DA88(int a1);
int __fastcall sub_3DAAC(unsigned int a1, unsigned int a2);
int __fastcall sub_3DD40(int a1, int a2);
int __fastcall sub_3DE48(int a1, int a2);
unsigned int power_on();
unsigned int power_off();
int __fastcall power_info_init(int a1, int a2, int a3, int a4, int a5);
int __fastcall set_power_init_status(char a1);
int is_power_init();
int is_power_on();
int power_init();
int __fastcall set_voltage(int a1, char a2);
int __fastcall set_voltage_by_steps(int a1, char a2);
int get_current_voltage();
int get_working_voltage();
int get_max_voltage();
int __fastcall set_working_voltage(char a1);
int is_check_asic_voltage_enable();
int __fastcall set_check_asic_voltage(char a1);
int __fastcall fan_info_init(int a1, int a2);
int fan_get_max_num();
int fan_get_max_speed();
int fan_get_check_fan_speed();
int fan_pwm_get();
int __fastcall fan_pwm_set(unsigned int a1);
int fan_pwm_set_max();
int __fastcall sub_3F02C(int a1);
int __fastcall sub_3F068(int *a1);
int __fastcall sub_3F0D4(int *a1);
int sub_3F110();
int __fastcall json_object_seed(int result);
int __fastcall sub_3F1D0(int result);
void __fastcall sub_3F210(int a1);
void *__fastcall sub_3F254(_DWORD *a1, int a2, int a3, int a4);
int __fastcall sub_3F2C8(_DWORD *a1);
int __fastcall sub_3F3D0(_DWORD *a1);
char *__fastcall sub_3F404(int *a1, const char *a2, char a3, char *format);
char *__fastcall sub_3F454(int a1, char ***a2, int a3, size_t *a4, _DWORD *a5, int a6);
json_t *__fastcall sub_3F6D0(int a1, char ***a2);
json_t *__fastcall sub_3F840(int a1, int a2);
_DWORD *__fastcall sub_3F924(int a1, char ***a2);
void *__fastcall sub_3F9D4(int a1, int **a2, int a3);
_QWORD *__fastcall sub_3FA68(int *a1, __int64 a2);
_QWORD *__fastcall sub_3FAAC(double a1);
void *__fastcall sub_3FB38(double a1);
int __fastcall sub_3FD24(int a1, const json_t *a2, char ***a3);
int __fastcall sub_40088(int a1, const json_t *a2, int a3);
int __fastcall sub_40294(int a1, const json_t *a2, char ***a3);
void *__fastcall json_vpack_ex(json_error_t *a1, int a2, _BYTE *a3, int a4);
void *g_dbus_create_error(json_error_t *a1, int a2, _BYTE *a3, ...);
void *json_pack(_BYTE *a1, ...);
int __fastcall json_vunpack_ex(const json_t *a1, json_error_t *a2, int a3, _BYTE *a4, char **a5);
int g_dbus_send_error(const json_t *a1, json_error_t *a2, int a3, _BYTE *a4, ...);
int json_unpack(const json_t *a1, _BYTE *a2, ...);
int __cdecl dump_to_strbuffer(const char *buffer, size_t size, void *data);
int __fastcall sub_40A88(const void *a1, size_t a2, _DWORD *a3);
int __fastcall sub_40AD4(const void *a1, size_t a2, FILE *a3);
int __fastcall sub_40B08(const void *a1, size_t a2, int *a3);
int __fastcall sub_40B40(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5);
int __fastcall sub_40BEC(const char *a1, int a2, int (__fastcall *a3)(const char *, int, int), int a4, __int16 a5);
int __cdecl compare_keys(const void *key1, const void *key2);
int __fastcall sub_40E24(hashtable_t *a1, const void *a2, char *a3, size_t a4);
int __fastcall sub_40E74(_DWORD *a1, int a2, int a3, hashtable_t *a4, int (__fastcall *a5)(const char *, int, int), int a6);
char *__fastcall json_dumps(_DWORD *a1, int a2);
int __fastcall json_dumpb(_DWORD *a1, int a2, int a3, int a4);
int __fastcall json_dumpf(_DWORD *a1, int a2, int a3);
int __fastcall json_dumpfd(_DWORD *a1, int a2, int a3);
int __fastcall json_dump_file(_DWORD *a1, const char *a2, int a3);
int __fastcall json_dump_callback(_DWORD *a1, int (__fastcall *a2)(const char *, int, int), int a3, int a4);
void __cdecl jsonp_error_init(json_error_t *error, const char *source);
char *__fastcall jsonp_error_set_source(char *result, const char *a2);
int jsonp_error_set(int a1, int a2, int a3, int a4, char a5, char *format, ...);
int __fastcall jsonp_error_vset(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg);
void __fastcall sub_41848(int a1);
int sub_4188C(int result, _DWORD *a2, int a3, const char *a4, ...);
int __fastcall stream_init(int result, int a2, int a3);
int __fastcall sub_41A54(int a1, int a2);
_DWORD *__fastcall sub_41BAC(_DWORD *result, int a2);
int __fastcall sub_41C18(int a1, int a2);
void __cdecl lex_save(lex_t *lex, int c);
int __cdecl lex_get_save(lex_t *lex, json_error_t *error);
_DWORD *__fastcall sub_41C94(_DWORD *a1, int a2);
_DWORD *__fastcall sub_41CB0(_DWORD *result, int a2);
void __cdecl lex_save_cached(lex_t *lex);
void __cdecl lex_free_string(lex_t *lex);
int __fastcall sub_41D58(int a1);
void __fastcall sub_41DE4(int a1, json_error_t *a2);
int __fastcall sub_42174(int a1, int a2, json_error_t *a3);
int __cdecl lex_scan(lex_t *lex, json_error_t *error);
char *__cdecl lex_steal_string(lex_t *lex, size_t *out_len);
int __fastcall lex_init(int a1, int a2, int a3, int a4);
void __cdecl lex_close(lex_t *lex);
json_t *__fastcall sub_425D4(int a1, int a2, json_error_t *a3);
json_t *__fastcall sub_42750(int a1, int a2, json_error_t *a3);
void *__fastcall sub_427FC(double a1, json_error_t *a2);
void *__fastcall sub_42974(unsigned int a1, unsigned int a2, int a3);
void *__fastcall json_loads(int a1, unsigned int a2, json_error_t *a3);
void *__fastcall json_loadb(int a1, int a2, unsigned int a3, json_error_t *a4);
void *__fastcall json_loadf(int a1, unsigned int a2, json_error_t *a3);
int __fastcall sub_42C4C(int *a1);
void *__fastcall json_loadfd(int a1, unsigned int a2, json_error_t *a3);
void *__fastcall json_load_file(const char *a1, unsigned int a2, json_error_t *a3);
int __fastcall sub_42D9C(int a1);
void *__fastcall json_load_callback(int a1, int a2, unsigned int a3, json_error_t *a4);
int __fastcall sub_42EE4(int result);
void __fastcall sub_42F24(int a1);
int __fastcall sub_42F68(json_t *a1, const char *a2, int a3);
int __fastcall sub_42F90(json_t *a1, int a2);
_DWORD *__fastcall json_init(_DWORD *result, int a2);
_DWORD *json_object();
void __cdecl json_delete_object(json_object_t *object);
size_t __cdecl json_object_size(const json_t *json);
json_t *__cdecl json_object_get(const json_t *json, const char *key);
int __cdecl json_object_set_new_nocheck(json_t *json, const char *key, json_t *value);
int __fastcall json_object_set_new(json_t *a1, const char *a2, json_t *a3);
int __fastcall json_object_del(_DWORD *a1, char *a2);
int __fastcall json_object_clear(_DWORD *a1);
int __fastcall json_object_update(json_t *a1, json_t *a2);
int __fastcall json_object_update_existing(json_t *a1, json_t *a2);
int __fastcall json_object_update_missing(json_t *a1, json_t *a2);
void *__cdecl json_object_iter(json_t *json);
int __fastcall json_object_iter_at(_DWORD *a1, char *a2);
void *__cdecl json_object_iter_next(json_t *json, void *iter);
const char *__cdecl json_object_iter_key(void *iter);
int __fastcall json_object_iter_value(int a1);
int __fastcall json_object_iter_set_new(_DWORD *a1, int a2, int a3);
void *__cdecl json_object_key_to_iter(const char *key);
int __fastcall sub_4350C(const json_t *a1, const json_t *a2);
json_t *__fastcall sub_4359C(json_t *a1);
json_t *__fastcall sub_43610(json_t *a1);
_DWORD *json_array();
void __fastcall sub_436CC(int a1);
size_t __cdecl json_array_size(const json_t *json);
int __fastcall json_array_get(_DWORD *a1, unsigned int a2);
int __fastcall json_array_set_new(_DWORD *a1, unsigned int a2, int a3);
void *__fastcall sub_43808(int a1, int a2, int a3, int a4);
void __cdecl array_copy(json_t **dest, size_t dpos, json_t **src, size_t spos, size_t count);
json_t **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy);
int __cdecl json_array_append_new(json_t *json, json_t *value);
int __fastcall json_array_insert_new(int a1, size_t a2, int a3);
int __fastcall json_array_remove(_DWORD *a1, unsigned int a2);
int __fastcall json_array_clear(_DWORD *a1);
int __fastcall json_array_extend(int a1, int a2);
int __fastcall sub_43BDC(const json_t *a1, const json_t *a2);
json_t *__fastcall sub_43C44(const json_t *a1);
json_t *__fastcall sub_43C94(const json_t *a1);
_DWORD *__fastcall sub_43CEC(const char *a1, size_t a2, int a3);
_DWORD *__fastcall json_string_nocheck(const char *a1);
_DWORD *__fastcall json_stringn_nocheck(const char *a1, size_t a2);
_DWORD *__fastcall jsonp_stringn_nocheck_own(const char *a1, size_t a2);
_DWORD *__fastcall json_string(const char *a1);
_DWORD *__fastcall json_stringn(const char *a1, size_t a2);
const char *__cdecl json_string_value(const json_t *json);
size_t __cdecl json_string_length(const json_t *json);
int __fastcall json_string_set_nocheck(int a1, const char *a2);
int __fastcall json_string_setn_nocheck(int a1, const char *a2, size_t a3);
int __fastcall json_string_set(int a1, const char *a2);
int __fastcall json_string_setn(int a1, const char *a2, size_t a3);
void __cdecl json_delete_string(json_string_t *string);
bool __fastcall sub_43FA8(int a1, int a2);
_DWORD *__fastcall sub_43FEC(int a1);
_DWORD *__fastcall json_vsprintf(const char *a1, void *a2);
_DWORD *json_sprintf(const char *a1, ...);
_QWORD *__fastcall json_integer(__int64 a1);
int __fastcall json_integer_value(_DWORD *a1);
int __fastcall json_integer_set(int a1, __int64 a2);
void __fastcall sub_44170(void *a1);
bool __fastcall sub_44188(_DWORD *a1, _DWORD *a2);
_QWORD *__fastcall sub_441BC(_DWORD *a1);
_QWORD *__fastcall json_real(double a1);
double __cdecl json_real_value(const json_t *json);
int __fastcall json_real_set(double a1);
void __fastcall sub_442C4(void *a1);
int __fastcall sub_442DC(const json_t *a1, const json_t *a2);
_QWORD *__fastcall sub_4431C(const json_t *a1);
double __cdecl json_number_value(const json_t *json);
void *json_true();
void *json_false();
void *json_null();
void __cdecl json_delete(json_t *json);
int __fastcall json_equal(const json_t *a1, const json_t *a2);
void *__fastcall json_copy(json_t *a1);
void *__fastcall json_deep_copy(const json_t *a1);
int __fastcall utf8_encode(int a1, _BYTE *a2, _DWORD *a3);
size_t __cdecl utf8_check_first(char byte);
size_t __cdecl utf8_check_full(const char *buffer, size_t size, int32_t *codepoint);
const char *__cdecl utf8_iterate(const char *buffer, size_t bufsize, int32_t *codepoint);
int __fastcall utf8_check_string(int a1, unsigned int a2);
void *__cdecl jsonp_malloc(size_t size);
void __cdecl jsonp_free(void *ptr);
char *__cdecl jsonp_strdup(const char *str);
char *__cdecl jsonp_strndup(const char *str, size_t len);
void *(*__fastcall json_set_alloc_funcs(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size);
_DWORD *__fastcall json_get_alloc_funcs(_DWORD *result, _DWORD *a2);
void __fastcall sub_44A90(int a1);
int __fastcall sub_44AD4(unsigned __int8 *a1, unsigned int a2, int a3);
void __cdecl list_init(list_t *list);
void __cdecl list_insert(list_t *list, list_t *node);
_DWORD *__fastcall sub_45368(_DWORD *result);
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket);
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list);
int __fastcall sub_45414(hashtable_t *a1, bucket_t *a2, const char *a3, int a4);
int __fastcall sub_4547C(int a1, const char *a2, int a3);
void __fastcall sub_45544(int a1);
int __fastcall sub_45588(int a1);
int __fastcall hashtable_init(int a1);
void __cdecl hashtable_close(hashtable_t *hashtable);
int __fastcall hashtable_set(int a1, char *a2, int a3);
void *__cdecl hashtable_get(hashtable_t *hashtable, const char *key);
int __fastcall hashtable_del(int a1, char *a2);
void __fastcall hashtable_clear(int a1);
void *__fastcall hashtable_iter(int a1);
int __fastcall hashtable_iter_at(int a1, char *a2);
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter);
int __fastcall hashtable_iter_key(int a1);
int __fastcall hashtable_iter_value(int a1);
void __fastcall hashtable_iter_set(int a1, int a2);
int __cdecl strbuffer_init(strbuffer_t *strbuff);
void __cdecl strbuffer_close(strbuffer_t *strbuff);
void __cdecl strbuffer_clear(strbuffer_t *strbuff);
int __fastcall strbuffer_value(int a1);
int __fastcall strbuffer_steal_value(int *a1);
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, char byte);
int __fastcall strbuffer_append_bytes(int a1, const void *a2, size_t a3);
char __cdecl strbuffer_pop(strbuffer_t *strbuff);
void __cdecl to_locale(strbuffer_t *strbuffer);
void __cdecl from_locale(char *buffer);
int __fastcall jsonp_strtod(strbuffer_t *a1, double *a2);
int __fastcall jsonp_dtostr(char *a1, size_t a2, int a3);
int __fastcall eeprom_open(unsigned int a1);
unsigned int __fastcall eeprom_close(unsigned int result);
int __fastcall eeprom_write(unsigned int a1, char a2, int a3, unsigned int a4);
int __fastcall eeprom_read(unsigned int a1, char a2, int a3, unsigned int a4);
void sub_46740();
int sub_467E4();
int __fastcall sub_469C4(_BYTE *a1, int a2);
int __fastcall sub_46AF0(_BYTE *a1, char *a2);
int __fastcall sub_46DFC(_BYTE *a1, char a2);
__int64 __fastcall eeprom_dump_fixture(int a1);
int __fastcall sub_47D60(_BYTE *a1, int a2);
_DWORD *__fastcall add_eeprom_device(int a1);
int __fastcall eeprom_load_one_chain(unsigned int a1, int a2);
int eeprom_load();
int __fastcall eeprom_get_voltage(int a1, _DWORD *a2);
int eeprom_get_max_voltage();
int __fastcall eeprom_get_freq(int a1, _DWORD *a2);
int eeprom_get_min_freq();
int is_eeprom_loaded();
int __fastcall sub_493E8(int a1);
int __fastcall sub_494B8(int a1);
int __fastcall sub_49588(int a1);
int __fastcall sub_49658(int a1);
int __fastcall sub_49728(int a1, char *a2);
int __fastcall sub_49830(int a1, char *a2);
int __fastcall sub_49938(int a1, void *a2);
int __fastcall api_get_eeprom_nonce_response_rate(int a1, _DWORD *a2);
int __fastcall api_get_eeprom_freq(int a1);
int __fastcall api_get_eeprom_voltage(int a1);
int __fastcall api_get_eeprom_chip_bin(int a1);
int __fastcall api_get_eeprom_chip_ft(int a1);
int __fastcall api_get_eeprom_test_standard_code(int a1);
int __fastcall api_get_eeprom_chip_sn(int a1);
int __fastcall api_get_eeprom_miner_type(int a1, void *a2);
int __fastcall api_get_eeprom_chain_load_state(int a1);
int __fastcall api_get_eeprom_pcb_version(int a1, char *a2);
int __fastcall api_get_eeprom_bom_version(int a1, char *a2);
int __fastcall sub_49E40(int a1, char a2, char a3, int a4, int a5);
int __fastcall sub_49E90(int a1, char *a2);
int __fastcall sub_49EC0(int a1, int a2);
int __fastcall at24c512_eeprom_read_byte(int a1, unsigned __int8 a2, __int16 a3, _BYTE *a4);
int __fastcall at24c512_eeprom_write_byte(int a1, unsigned __int8 a2, __int16 a3, char a4);
int __fastcall at24c512_eeprom_open(const char *a1, int a2);
int __fastcall at24c512_eeprom_close(int a1);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4A094(int a1, __int64 a2);
int __fastcall send_work(int a1);
int __fastcall platform_check_repeat_nonce(int *a1, int a2, unsigned __int8 *a3);
int __fastcall scanhash(int *a1);
int __fastcall get_response(int a1);
int __fastcall backend_exit_base(int a1);
int __fastcall async_push_work_base(int a1, char *a2);
int __fastcall push_work_base(int a1, int a2);
int __fastcall pop_ans_base(int a1, char *a2);
int __fastcall try_pop_ans_base(int a1, char *a2);
int __fastcall backend_init_base(int a1);
int __fastcall start_mining_base(int a1);
int __fastcall stop_mining_base(int a1);
int __fastcall reset_mining_base(int a1);
_DWORD *__fastcall runtime_ctrl(int a1);
int query_device_num();
int __fastcall redirect_nonce_output(int result, int a2);
void *__fastcall get_all_created_runtime(_DWORD *a1);
int check_and_destroy_abnormal_runtime();
_UNKNOWN **dev_ctrl();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4BC18(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4BC3C(int a1, __int64 a2);
int __fastcall sub_4BC64(int result, int a2, unsigned int a3);
int __fastcall sub_4BD44(unsigned __int8 a1);
int __fastcall sub_4BE48(unsigned __int8 *a1);
_BYTE *__fastcall sub_4BE84(_BYTE *result, int a2, int a3, int a4);
_BYTE *__fastcall sub_4BF44(_BYTE *result, int a2);
int __fastcall sub_4BF8C(int a1, int a2);
int __fastcall sub_4C574(int a1);
int __fastcall sub_4C668(int a1, char a2);
int __fastcall sub_4C778(int a1, unsigned __int8 a2);
int __fastcall sub_4C89C(int a1, char *a2);
int __fastcall sub_4CB30(int a1, char *a2);
unsigned int *__fastcall sub_4CD54(unsigned int *result);
int __fastcall sub_4CE64(int a1);
int __fastcall sub_4CFB8(int a1, char a2);
int __fastcall sub_4D138(int a1, char a2, int a3);
int __fastcall sub_4D264(int a1, char a2);
int __fastcall sub_4D374(int a1);
int __fastcall sub_4D664(int a1);
int __fastcall sub_4DAC8(int a1);
int __fastcall sub_4DEB4(int a1, int a2);
int __fastcall sub_4DFD0(int a1, char a2, char a3, int a4);
int __fastcall sub_4E01C(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_4E13C(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_4E1B0(int a1, int a2, int a3, size_t a4);
int __fastcall sub_4E254(int a1, int a2, int a3, size_t a4);
int __fastcall sub_4E2F8(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_4E35C(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_4E3C0(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_4E598(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_4E774(int a1);
int __fastcall sub_4E7AC(int a1);
int __fastcall sub_4E800(int a1, void *a2, unsigned int a3);
int __fastcall sub_4EACC(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_4EB58(int a1, int a2, void *a3);
int __fastcall sub_4EE04(int a1, __int16 a2, int a3);
int __fastcall sub_4EE4C(int a1, __int16 a2, int a3);
int __fastcall sub_4EEA4(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_4EF04(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_4EF68(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_4EFC4(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_4F340(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall sub_4F6B8(_DWORD *a1);
int __fastcall sub_4F7BC(int a1);
int __fastcall work_2_packet_grin32(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __fastcall sub_4F9A4(int a1, int a2);
int __fastcall packet_2_nonce_grin32(int a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7);
int __fastcall sub_4FF2C(int a1, unsigned __int8 a2);
int __fastcall sub_4FF7C(int a1, unsigned __int8 a2);
int __fastcall sub_50108(int a1, unsigned __int8 a2);
int __fastcall sub_50158(int a1, unsigned __int8 a2);
int __fastcall sub_502EC(int a1, unsigned __int8 a2);
int __fastcall enable_core_clk(int a1);
int __fastcall setup_all_chip_grin32(int a1);
int __fastcall global_idx_init_grin32(int a1);
int __fastcall global_idx_free_grin32(int a1);
int __fastcall set_baud_grin32(int a1, char *a2);
int __fastcall sub_50490(_DWORD *a1, _DWORD *a2);
int __fastcall sub_504B0(int a1, int a2, _DWORD *a3, int a4, int a5, int a6);
int __fastcall check_nonce_grin32(int a1, int a2);
int get_chip_status_grin32();
int get_algo_type_grin32();
int softreset_all_chip_grin32();
int __fastcall get_theory_hashrate_grin32(int a1, double *a2);
int set_boot_config_grin32();
int __fastcall set_sensor_extern_mode_grin32(int a1);
int __fastcall read_sensor_temp_local_grin32(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_grin32(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int parameter_update_grin32();
int overclock_update_grin32();
int __fastcall get_pcba_test_level_grin32(int a1, _DWORD *a2);
int __fastcall get_packet_remain_len_grin32(unsigned __int8 a1);
void *runtime_ctrl_grin32();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_51000(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_51024(int a1, __int64 a2);
int __fastcall sub_5104C(int result, int a2, unsigned int a3);
int __fastcall sub_5112C(unsigned __int8 a1);
_BYTE *__fastcall sub_51230(_BYTE *result, int a2);
int __fastcall sub_51278(int a1, int a2);
int __fastcall sub_51860(int a1);
int __fastcall sub_51954(int a1, char a2);
int __fastcall sub_51A64(int a1, unsigned __int8 a2);
int __fastcall sub_51B88(int a1, char *a2);
int __fastcall sub_51E1C(int a1, char *a2);
unsigned int *__fastcall sub_52040(unsigned int *result);
int __fastcall sub_52150(int a1);
int __fastcall sub_522A4(int a1, char a2);
int __fastcall sub_52424(int a1, char a2, int a3);
int __fastcall sub_52550(int a1, char a2);
int __fastcall sub_52660(int a1);
int __fastcall sub_52950(int a1);
int __fastcall sub_52DB4(int a1);
int __fastcall sub_531A0(int a1, int a2);
int __fastcall sub_532BC(int a1, char a2, char a3, int a4);
int __fastcall sub_53308(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_53428(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_5349C(int a1, int a2, int a3, size_t a4);
int __fastcall sub_53540(int a1, int a2, int a3, size_t a4);
int __fastcall sub_535E4(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_53648(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_536AC(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_53884(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_53A60(int a1);
int __fastcall sub_53A98(int a1);
int __fastcall sub_53AEC(int a1, void *a2, unsigned int a3);
int __fastcall sub_53DB8(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_53E44(int a1, int a2, void *a3);
int __fastcall sub_540F4(int a1, __int16 a2, int a3);
int __fastcall sub_5413C(int a1, __int16 a2, int a3);
int __fastcall sub_54194(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_541F4(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_54258(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_542B4(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_54638(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall global_idx_init_ckb(int a1);
int __fastcall global_idx_free_ckb(int a1);
__int64 __fastcall sub_54A10(int a1, unsigned __int8 a2);
int __fastcall work_2_packet_ckb(int a1, int a2, _BYTE *a3, _DWORD *a4);
__int64 __fastcall sub_54EF0(int a1, int a2, int a3);
int __fastcall packet_2_nonce_ckb(unsigned int *a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7);
int __fastcall makeup_chip_addr_ckb(int a1, unsigned __int8 a2);
int __fastcall setup_all_chip_ckb(int a1);
int __fastcall set_baud_ckb(int a1, char *a2);
int __fastcall sub_556D0(int a1, int a2);
int __fastcall check_nonce_ckb(int a1, unsigned __int8 *a2);
int get_chip_status_ckb();
int get_algo_type_ckb();
int __fastcall softreset_all_chip_ckb(int a1);
int __fastcall get_theory_hashrate_ckb(int a1, double *a2);
int set_boot_config_ckb();
int __fastcall set_sensor_extern_mode_ckb(int a1);
int __fastcall read_sensor_temp_local_ckb(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_ckb(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall parameter_update_ckb(int a1, char a2, int a3, char a4, int a5);
int __fastcall overclock_update_ckb(int a1, int a2);
int __fastcall get_pcba_test_level_ckb(_DWORD *a1, _DWORD *a2);
int get_packet_remain_len_ckb();
void *runtime_ctrl_ckb();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_563B0(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_563D4(int a1, __int64 a2);
int __fastcall sub_563FC(int result, int a2, unsigned int a3);
int __fastcall sub_564DC(unsigned __int8 a1);
_BYTE *__fastcall sub_565E0(_BYTE *result, int a2);
int __fastcall sub_56628(int a1, int a2);
int __fastcall sub_56C10(int a1);
int __fastcall sub_56D04(int a1, char a2);
int __fastcall sub_56E14(int a1, unsigned __int8 a2);
int __fastcall sub_56F38(int a1, char *a2);
int __fastcall sub_571CC(int a1, char *a2);
unsigned int *__fastcall sub_573F0(unsigned int *result);
int __fastcall sub_57500(int a1);
int __fastcall sub_57654(int a1, char a2);
int __fastcall sub_577D4(int a1, char a2, int a3);
int __fastcall sub_57900(int a1, char a2);
int __fastcall sub_57A10(int a1);
int __fastcall sub_57D00(int a1);
int __fastcall sub_58164(int a1);
int __fastcall sub_58550(int a1, int a2);
int __fastcall sub_5866C(int a1, char a2, char a3, int a4);
int __fastcall sub_586B8(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_587D8(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_5884C(int a1, int a2, int a3, size_t a4);
int __fastcall sub_588F0(int a1, int a2, int a3, size_t a4);
int __fastcall sub_58994(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_589F8(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_58A5C(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_58C34(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_58E10(int a1);
int __fastcall sub_58E48(int a1);
int __fastcall sub_58E9C(int a1, void *a2, unsigned int a3);
int __fastcall sub_59168(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_591F4(int a1, int a2, void *a3);
int __fastcall sub_594A4(int a1, __int16 a2, int a3);
int __fastcall sub_594EC(int a1, __int16 a2, int a3);
int __fastcall sub_59544(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_595A4(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_59608(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_59664(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_599E8(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall global_idx_init_dash(int a1);
int __fastcall global_idx_free_dash(int a1);
__int64 __fastcall sub_59E3C(int a1, unsigned __int8 a2);
int __fastcall work_2_packet_dash(int a1, int a2, _BYTE *a3, _DWORD *a4);
__int64 __fastcall sub_5A4DC(int a1, int a2, int a3);
int __fastcall packet_2_nonce_dash(int *a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7);
int __fastcall makeup_chip_addr_dash(int a1, unsigned __int8 a2);
void __fastcall get_chip_regdata(int a1, unsigned __int8 a2);
void __fastcall get_core_regdata(int a1, unsigned __int8 a2);
int __fastcall set_ticket_mask_dash(int a1, unsigned __int8 a2);
int __fastcall sub_5AF50(int a1, int a2);
int __fastcall setup_all_chip_dash(int a1);
int __fastcall set_baud_dash(int a1, char *a2);
int __fastcall sub_5B854(int a1, int a2);
int __fastcall check_nonce_dash(int a1, unsigned __int8 *a2);
void check_asic_status_dash();
int __fastcall save_avg_hashrate_dash(int a1);
int get_chip_status_dash();
int get_algo_type_dash();
int __fastcall softreset_all_chip_dash(int a1);
int __fastcall get_theory_hashrate_dash(int a1, double *a2);
int set_boot_config_dash();
int __fastcall set_sensor_extern_mode_dash(int a1);
int __fastcall read_sensor_temp_local_dash(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_dash(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall parameter_update_dash(int a1, char a2, int a3);
int __fastcall overclock_update_dash(int a1, int a2);
int __fastcall get_pcba_test_level_dash(_DWORD *a1, _DWORD *a2);
int get_packet_remain_len_dash();
void *runtime_ctrl_dash();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5CC70(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5CC94(int a1, __int64 a2);
int __fastcall sub_5CCBC(int result, int a2, unsigned int a3);
int __fastcall sub_5CD9C(unsigned __int8 a1);
_BYTE *__fastcall sub_5CEA0(_BYTE *result, int a2);
int __fastcall sub_5CEE8(int a1, int a2);
int __fastcall sub_5D4D0(int a1);
int __fastcall sub_5D5C4(int a1, char a2);
int __fastcall sub_5D6D4(int a1, unsigned __int8 a2);
int __fastcall sub_5D7F8(int a1, char *a2);
int __fastcall sub_5DA8C(int a1, char *a2);
unsigned int *__fastcall sub_5DCB0(unsigned int *result);
int __fastcall sub_5DDC0(int a1);
int __fastcall sub_5DF14(int a1, char a2);
int __fastcall sub_5E094(int a1, char a2, int a3);
int __fastcall sub_5E1C4(int a1, char a2);
int __fastcall sub_5E2D4(int a1);
int __fastcall sub_5E5C4(int a1);
int __fastcall sub_5EA28(int a1);
int __fastcall sub_5EE14(int a1, int a2);
int __fastcall sub_5EF30(int a1, char a2, char a3, int a4);
int __fastcall sub_5EF7C(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_5F09C(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_5F110(int a1, int a2, int a3, size_t a4);
int __fastcall sub_5F1B4(int a1, int a2, int a3, size_t a4);
int __fastcall sub_5F258(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_5F2BC(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_5F320(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_5F4F8(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_5F6D4(int a1);
int __fastcall sub_5F70C(int a1);
int __fastcall sub_5F760(int a1, void *a2, unsigned int a3);
int __fastcall sub_5FA2C(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_5FAB8(int a1, int a2, void *a3);
int __fastcall sub_5FD64(int a1, __int16 a2, int a3);
int __fastcall sub_5FDAC(int a1, __int16 a2, int a3);
int __fastcall sub_5FE04(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_5FE64(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_5FEC8(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_5FF24(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_602A4(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall global_idx_init_dcr(int a1);
int __fastcall global_idx_free_dcr(int a1);
__int64 __fastcall sub_6067C(int a1, unsigned __int8 a2);
int __fastcall work_2_packet_dcr(int a1, int a2, _BYTE *a3, _DWORD *a4);
__int64 __fastcall sub_60BB0(int a1, int a2, int a3);
int __fastcall packet_2_nonce_dcr(unsigned int *a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7);
bool __fastcall sub_610B4(int a1);
int __fastcall makeup_chip_addr_dcr(_BYTE *a1, unsigned __int8 a2);
int __fastcall setup_all_chip_dcr(int a1);
int __fastcall set_baud_dcr(int a1, char *a2);
int __fastcall sub_61424(int a1, int a2);
int __fastcall sub_61570(const char *a1, int a2, int a3);
int __fastcall check_nonce_dcr(int a1, unsigned __int8 *a2);
int __fastcall get_chip_status_dcr(int a1);
int get_algo_type_dcr();
int __fastcall softreset_all_chip_dcr(int a1);
int __fastcall get_theory_hashrate_dcr(int a1, double *a2);
int set_boot_config_dcr();
int __fastcall set_sensor_extern_mode_dcr(int a1);
int __fastcall read_sensor_temp_local_dcr(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_dcr(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int parameter_update_dcr();
int overclock_update_dcr();
int get_pcba_test_level_dcr();
int __fastcall get_packet_remain_len_dcr(unsigned __int8 a1);
void *runtime_ctrl_dcr();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_61B70(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_61B94(int a1, __int64 a2);
int __fastcall sub_61BBC(int result, int a2, unsigned int a3);
int __fastcall sub_61C9C(unsigned __int8 a1);
_BYTE *__fastcall sub_61DA0(_BYTE *result, int a2);
int __fastcall sub_61DE8(int a1, int a2);
int __fastcall sub_623D0(int a1);
int __fastcall sub_624C4(int a1, char a2);
int __fastcall sub_625D4(int a1, unsigned __int8 a2);
int __fastcall sub_626F8(int a1, char *a2);
int __fastcall sub_6298C(int a1, char *a2);
unsigned int *__fastcall sub_62BB0(unsigned int *result);
int __fastcall sub_62CC0(int a1);
int __fastcall sub_62E14(int a1, char a2);
int __fastcall sub_62F94(int a1, char a2, int a3);
int __fastcall sub_630C4(int a1, char a2);
int __fastcall sub_631D4(int a1);
int __fastcall sub_634C4(int a1);
int __fastcall sub_63928(int a1);
int __fastcall sub_63D14(int a1, int a2);
int __fastcall sub_63E30(int a1, char a2, char a3, int a4);
int __fastcall sub_63E7C(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_63F9C(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_64010(int a1, int a2, int a3, size_t a4);
int __fastcall sub_640B4(int a1, int a2, int a3, size_t a4);
int __fastcall sub_64158(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_641BC(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_64220(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_643F8(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_645D4(int a1);
int __fastcall sub_6460C(int a1);
int __fastcall sub_64660(int a1, void *a2, unsigned int a3);
int __fastcall sub_6492C(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_649B8(int a1, int a2, void *a3);
int __fastcall sub_64C64(int a1, __int16 a2, int a3);
int __fastcall sub_64CAC(int a1, __int16 a2, int a3);
int __fastcall sub_64D04(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_64D64(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_64DC8(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_64E24(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_651A4(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall global_idx_init_ckb2(int a1);
int __fastcall global_idx_free_ckb2(int a1);
__int64 __fastcall sub_6557C(int a1, unsigned __int8 a2);
int __fastcall work_2_packet_ckb2(int a1, int a2, _BYTE *a3, _DWORD *a4);
__int64 __fastcall sub_65AC8(int a1, int a2, int a3);
int __fastcall packet_2_nonce_ckb2(unsigned int *a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7);
bool __fastcall sub_65FC0(int a1);
int __fastcall makeup_chip_addr_ckb2(int a1, unsigned __int8 a2);
int __fastcall setup_all_chip_ckb2(int a1);
int __fastcall set_baud_ckb2(int a1, char *a2);
int __fastcall sub_662C8(int a1, int a2);
int __fastcall check_nonce_ckb2(int a1, unsigned __int8 *a2);
int get_chip_status_ckb2();
int get_algo_type_ckb2();
int __fastcall softreset_all_chip_ckb2(int a1);
int __fastcall get_theory_hashrate_ckb2(int a1, double *a2);
int set_boot_config_ckb2();
int __fastcall set_sensor_extern_mode_ckb2(int a1);
int __fastcall read_sensor_temp_local_ckb2(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_ckb2(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int parameter_update_ckb2();
int overclock_update_ckb2();
int get_pcba_test_level_ckb2();
int __fastcall get_packet_remain_len_ckb2(unsigned __int8 a1);
void *runtime_ctrl_ckb2();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_66868(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6688C(int a1, __int64 a2);
int __fastcall sub_668B4(int result, int a2, unsigned int a3);
int __fastcall sub_66994(unsigned __int8 a1);
_BYTE *__fastcall sub_66A98(_BYTE *result, int a2);
int __fastcall sub_66AE0(int a1, int a2);
int __fastcall sub_670C8(int a1);
int __fastcall sub_671BC(int a1, char a2);
int __fastcall sub_672CC(int a1, unsigned __int8 a2);
int __fastcall sub_673F0(int a1, char *a2);
int __fastcall sub_67684(int a1, char *a2);
unsigned int *__fastcall sub_678A8(unsigned int *result);
int __fastcall sub_679B8(int a1);
int __fastcall sub_67B0C(int a1, char a2);
int __fastcall sub_67C8C(int a1, char a2, int a3);
int __fastcall sub_67DB8(int a1, char a2);
int __fastcall sub_67EC8(int a1);
int __fastcall sub_681B8(int a1);
int __fastcall sub_6861C(int a1);
int __fastcall sub_68A08(int a1, int a2);
int __fastcall sub_68B24(int a1, char a2, char a3, int a4);
int __fastcall sub_68B70(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_68C90(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_68D04(int a1, int a2, int a3, size_t a4);
int __fastcall sub_68DA8(int a1, int a2, int a3, size_t a4);
int __fastcall sub_68E4C(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_68EB0(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_68F14(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_690EC(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_692C8(int a1);
int __fastcall sub_69300(int a1);
int __fastcall sub_69354(int a1, void *a2, unsigned int a3);
int __fastcall sub_69620(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_696AC(int a1, int a2, void *a3);
int __fastcall sub_69958(int a1, __int16 a2, int a3);
int __fastcall sub_699A0(int a1, __int16 a2, int a3);
int __fastcall sub_699F8(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_69A58(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_69ABC(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_69B18(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_69E9C(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall global_idx_init_vbk(int a1);
int __fastcall global_idx_free_vbk(int a1);
int __fastcall dump_work_vbk(int a1, unsigned __int8 a2);
int __fastcall work_2_packet_vbk(int a1, int a2, _BYTE *a3, _DWORD *a4);
int __fastcall pakcet_2_nonce_vbk(int a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7);
int __fastcall makeup_chip_addr_vbk(int a1, unsigned __int8 a2);
int __fastcall setup_all_chip_vbk(int a1);
int __fastcall set_baud_vbk(int a1, char *a2);
int __fastcall sub_6A98C(int a1, int a2);
int __fastcall check_nonce_vbk(int a1, int a2);
int get_chip_status_vbk();
int get_algo_type_vbk();
int __fastcall softreset_all_chip_vbk(int a1);
int __fastcall get_theory_hashrate_vbk(int a1, double *a2);
int set_boot_config_vbk();
int __fastcall set_sensor_extern_mode_vbk(int a1);
int __fastcall read_sensor_temp_local_vbk(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_vbk(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int parameter_update_vbk();
int overclock_update_vbk();
int __fastcall get_pcba_test_level_vbk(int a1, _DWORD *a2);
int __fastcall get_packet_remain_len_vbk(unsigned __int8 a1);
void *runtime_ctrl_vbk();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6AFB0(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6AFD4(int a1, __int64 a2);
int __fastcall sub_6AFFC(int result, int a2, unsigned int a3);
int __fastcall sub_6B0DC(unsigned __int8 a1);
int __fastcall sub_6B1E0(unsigned __int8 *a1);
_BYTE *__fastcall sub_6B21C(_BYTE *result, int a2, int a3, int a4);
_BYTE *__fastcall sub_6B2DC(_BYTE *result, int a2);
int __fastcall sub_6B324(int a1, int a2);
int __fastcall sub_6B90C(int a1);
int __fastcall sub_6BA00(int a1, char a2);
int __fastcall sub_6BB10(int a1, unsigned __int8 a2);
int __fastcall sub_6BC34(int a1, char *a2);
int __fastcall sub_6BEC8(int a1, char *a2);
unsigned int *__fastcall sub_6C0EC(unsigned int *result);
int __fastcall sub_6C1FC(int a1);
int __fastcall sub_6C350(int a1, char a2);
int __fastcall sub_6C4D0(int a1, char a2, int a3);
int __fastcall sub_6C5FC(int a1, char a2);
int __fastcall sub_6C70C(int a1);
int __fastcall sub_6C9FC(int a1);
int __fastcall sub_6CE60(int a1);
int __fastcall sub_6D24C(int a1, int a2);
int __fastcall sub_6D368(int a1, char a2, char a3, int a4);
int __fastcall sub_6D3B4(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_6D4D4(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_6D548(int a1, int a2, int a3, size_t a4);
int __fastcall sub_6D5EC(int a1, int a2, int a3, size_t a4);
int __fastcall sub_6D690(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_6D6F4(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_6D758(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_6D930(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_6DB0C(int a1);
int __fastcall sub_6DB44(int a1);
int __fastcall sub_6DB98(int a1, void *a2, unsigned int a3);
int __fastcall sub_6DE64(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_6DEF0(int a1, int a2, void *a3);
int __fastcall sub_6E19C(int a1, __int16 a2, int a3);
int __fastcall sub_6E1E4(int a1, __int16 a2, int a3);
int __fastcall sub_6E23C(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_6E29C(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_6E300(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_6E35C(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_6E6D8(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall dump_work(_DWORD *a1);
int __fastcall dump_work_packet(int a1);
int __fastcall work_2_packet_grin29(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __fastcall sub_6ED48(int a1, int a2);
int __fastcall packet_2_nonce_grin29(int a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7);
int __fastcall makeup_chip_addr(int a1, unsigned __int8 a2);
int __fastcall sub_6F4F4(int a1, unsigned __int8 a2);
int __fastcall sub_6F680(int a1, unsigned __int8 a2);
int __fastcall sub_6F6D0(int a1, unsigned __int8 a2);
int __fastcall sub_6F864(int a1, unsigned __int8 a2);
int __fastcall setup_all_chip_grin29(int a1);
int __fastcall global_idx_init_grin29(int a1);
int __fastcall global_idx_free_grin29(int a1);
int __fastcall set_baud_grin29(int a1, char *a2);
int __fastcall sub_6F9D0(_DWORD *a1, _DWORD *a2);
int __fastcall sub_6F9F0(int a1, int a2, _DWORD *a3, int a4, int a5, int a6);
int __fastcall check_nonce_grin29(int a1, int a2);
int get_chip_status_grin29();
int get_algo_type_grin29();
int __fastcall softreset_all_chip_grin29(int a1);
int __fastcall get_theory_hashrate_grin29(int a1, double *a2);
int set_boot_config_grin29();
int __fastcall set_sensor_extern_mode_grin29(int a1);
int __fastcall read_sensor_temp_local_grin29(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_grin29(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int parameter_update_grin29();
int overclock_update_grin29();
int __fastcall get_pcba_test_level_grin29(int a1, _DWORD *a2);
int __fastcall get_packet_remain_len_grin29(unsigned __int8 a1);
void *runtime_ctrl_grin29();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_70550(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_70574(int a1, __int64 a2);
int __fastcall sub_7059C(int result, int a2, unsigned int a3);
int __fastcall sub_7067C(unsigned __int8 a1);
int __fastcall sub_70780(unsigned __int8 *a1);
_BYTE *__fastcall sub_707BC(_BYTE *result, int a2, int a3, int a4);
_BYTE *__fastcall sub_7087C(_BYTE *result, int a2);
_DWORD *__fastcall LZ4F_writeLE32(_DWORD *result, int a2);
int __fastcall sub_7090C(int a1, int a2);
int __fastcall sub_70EF4(int a1);
int __fastcall sub_70FE8(int a1, char a2);
int __fastcall sub_710F8(int a1, unsigned __int8 a2);
int __fastcall sub_7121C(int a1, char *a2);
int __fastcall sub_714B0(int a1, char *a2);
unsigned int *__fastcall sub_716D4(unsigned int *result);
int __fastcall sub_717E4(int a1);
int __fastcall sub_71938(int a1, char a2);
int __fastcall sub_71AB8(int a1, char a2, int a3);
int __fastcall sub_71BE4(int a1, char a2);
int __fastcall sub_71CF4(int a1);
int __fastcall sub_71FE4(int a1);
int __fastcall sub_72448(int a1);
int __fastcall sub_72834(int a1, int a2);
int __fastcall sub_72950(int a1, char a2, char a3, int a4);
int __fastcall sub_7299C(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_72ABC(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_72B30(int a1, int a2, int a3, size_t a4);
int __fastcall sub_72BD4(int a1, int a2, int a3, size_t a4);
int __fastcall sub_72C78(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_72CDC(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_72D40(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_72F18(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_730F4(int a1);
int __fastcall sub_7312C(int a1);
int __fastcall sub_73180(int a1, void *a2, unsigned int a3);
int __fastcall sub_7344C(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_734D8(int a1, int a2, void *a3);
int __fastcall sub_73784(int a1, __int16 a2, int a3);
int __fastcall sub_737CC(int a1, __int16 a2, int a3);
int __fastcall sub_73824(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_73884(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_738E8(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_73944(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_73CC0(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall global_idx_init_ae(int a1);
int __fastcall global_idx_free_ae(int a1);
int __fastcall dump_work_ae(_DWORD *a1);
int __fastcall dump_work_packet_ae(int a1);
int __fastcall work_2_packet_ae(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_743AC(int a1, int a2);
int __fastcall packet_2_nonce_ae(int a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7);
int __fastcall makeup_chip_addr_ae(int a1, unsigned __int8 a2);
int __fastcall setup_all_chip_ae(int a1);
int __fastcall set_baud_ae(int a1, char *a2);
int sub_74BD0(); // weak
int __fastcall sub_74BF0(int a1, unsigned int a2, int a3, int a4, unsigned int a5);
int __fastcall check_nonce_ae(_DWORD *a1, int a2);
int get_chip_status_ae();
int get_algo_type_ae();
int __fastcall softreset_all_chip_ae(int a1);
int __fastcall get_theory_hashrate_ae(int a1, double *a2);
int set_boot_config_ae();
int __fastcall set_sensor_extern_mode_ae(int a1);
int __fastcall read_sensor_temp_local_ae(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_ae(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int parameter_update_ae();
int overclock_update_ae();
int __fastcall get_pcba_test_level_ae(int a1, _DWORD *a2);
int __fastcall get_packet_remain_len_ae(unsigned __int8 a1);
void *runtime_ctrl_ae();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_755D0(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_755F4(int a1, __int64 a2);
int __fastcall sub_7561C(int a1, int a2, unsigned int a3);
int __fastcall sub_7563C(int a1, int a2, unsigned int a3);
int __fastcall sub_7565C(const void *a1, const void *a2, const void *a3, int a4);
int __fastcall sub_756C0(int result, int a2, unsigned int a3);
int __fastcall sub_757A0(unsigned __int8 a1);
int __fastcall sub_758A4(unsigned __int8 *a1);
_BYTE *__fastcall sub_758E0(_BYTE *result, int a2, int a3, int a4);
_BYTE *__fastcall sub_759A0(_BYTE *result, int a2);
int __fastcall sub_759E8(int a1, int a2);
int __fastcall sub_75FD0(int a1);
int __fastcall sub_760C4(int a1, char a2);
int __fastcall sub_761D4(int a1, unsigned __int8 a2);
int __fastcall sub_762F8(int a1, char *a2);
int __fastcall sub_7658C(int a1, char *a2);
unsigned int *__fastcall sub_767B0(unsigned int *result);
int __fastcall sub_768C0(int a1);
int __fastcall sub_76A14(int a1, char a2);
int __fastcall sub_76B94(int a1, char a2, int a3);
int __fastcall sub_76CC0(int a1, char a2);
int __fastcall sub_76DD0(int a1);
int __fastcall sub_770C0(int a1);
int __fastcall sub_77524(int a1);
int __fastcall sub_77910(int a1, int a2);
int __fastcall sub_77A2C(int a1, char a2, char a3, int a4);
int __fastcall sub_77A78(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_77B98(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_77C0C(int a1, int a2, int a3, size_t a4);
int __fastcall sub_77CB0(int a1, int a2, int a3, size_t a4);
int __fastcall sub_77D54(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_77DB8(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_77E1C(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_77FF4(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_781D0(int a1);
int __fastcall sub_78208(int a1);
int __fastcall sub_7825C(int a1, void *a2, unsigned int a3);
int __fastcall sub_78528(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_785B4(int a1, int a2, void *a3);
int __fastcall sub_78860(int a1, __int16 a2, int a3);
int __fastcall sub_788A8(int a1, __int16 a2, int a3);
int __fastcall sub_78900(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_78960(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_789C4(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_78A20(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_78DA0(int a1, char a2, __int16 a3, __int16 a4, void *a5);
char *__fastcall sub_79118(const char *a1, signed int a2);
__int64 sub_791EC();
unsigned int __fastcall sub_79338(unsigned int a1);
int __fastcall sub_7936C(void *a1);
__int64 __fastcall sub_79398(_DWORD *a1);
int __fastcall sub_794A4(int a1);
int __fastcall sub_794F4(int a1);
int __fastcall set_ticketmask(int a1, int a2);
int __fastcall open_core_clk_tops(int a1);
int __fastcall open_serdes_clk_close_core_clk(int a1);
int __fastcall set_pll_div(int a1);
int __fastcall set_debug_ctrl(int a1, int a2);
int __fastcall set_core_reset(int a1);
int __fastcall set_start_delay(int a1, int a2);
int __fastcall set_initial_interval_time(int a1, int a2);
int __fastcall set_reset_to_normal(int a1, int a2);
int __fastcall get_timeout_count(int a1);
int __fastcall reverse_start_nonce(int a1, int a2);
int __fastcall close_core9(int a1);
int __fastcall get_count_sync(int a1, unsigned __int8 a2);
int __fastcall get_work_mode(int a1);
int __fastcall setup_count_sync(int a1, char a2);
int __fastcall set_dag_node_num(int a1, int a2);
int __fastcall clear_dag_mode(int a1);
int __fastcall set_mac_stats(int a1);
int __fastcall get_mac_stats(int a1);
int __fastcall check_mac_done(int a1, int a2, unsigned __int8 a3, int a4);
int __fastcall enable_one_lane(int a1, unsigned __int8 a2);
int __fastcall setup_clk(int a1);
int __fastcall sub_7B344(int a1, char a2, char a3);
int __fastcall sub_7B47C(int a1, int a2);
int __fastcall phy_power_reset(int a1);
int __fastcall sub_7BB48(_DWORD *a1, signed int a2);
int __fastcall serdes_apb_write(int a1, int a2, char a3, unsigned __int16 a4, int a5);
int __fastcall serdes_apb_write_1_chip(int a1, char a2, char a3, unsigned __int16 a4, int a5);
int __fastcall serdes_apb_read(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4);
int __fastcall serdes_apb_read_back(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4, int a5);
int __fastcall serdes_apb_read_back_1_chip(int a1, char a2, unsigned __int8 a3, unsigned __int16 a4, int a5);
int __fastcall phy_reg_read(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4);
int __fastcall check_phy_reg_0917(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall phy_reg_read_0922(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall phy_reg_read_0927_old_28G(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall phy_reg_read_0928_28G(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall phy_reg_read_0826(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall phy_reg_read_0805(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall serdes_initial_seq_1_by_vendor(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4);
int __fastcall serdes_initial_seq_2_by_vendor(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall check_d54(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5);
int __fastcall check_d54_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5);
int __fastcall enable_rx_equalizer_tuning(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4);
int __fastcall enable_rx_equalizer_tuning_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall clear_rxeqcal_ext(int a1, unsigned __int8 a2, int a3);
int __fastcall enable_rx_equalizer_tuning_ext(int a1, unsigned __int8 a2, int a3);
int __fastcall BM_debug_seq_16G_update_20210819_500M(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall BM_debug_seq_update_20210805_500M(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_16G_20210819_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_24G_20210817_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_24G_20210915_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_24G_20210916_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_24G_20210917_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_24G_seq1_20210922_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_24G_seq2_20210922_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_28G_20210927_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_32G_20210826_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_32G_20210817_update(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall SOC_32G_static_config_20210911(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall SOC_28G_20210929_update(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall SOC_28G_20210928_update(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall SOC_28G_static_config_20210914(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall SOC_28G_static_axlk_txdata_en(int a1, unsigned __int8 a2, char a3);
int __fastcall SOC_32G_static_config_20210912(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall overwrite_to_24G(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall cmnadj_20210813_500M_test(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __fastcall atp_test(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall get_special_core_reg(int a1);
int __fastcall read_dag(int a1);
int __fastcall get_core_clk(int a1);
int __fastcall check_ref_clock_ready(int a1, int a2, unsigned __int8 a3);
int __fastcall check_tx_rx_status(int a1, int a2, unsigned __int8 a3);
int __fastcall check_cmn_calibration_status_1_phy(int a1, char a2, unsigned __int8 a3);
int __fastcall check_cmn_calibration_status(int a1, int a2, int a3);
int __fastcall do_32G_stop_seq_all_phy(int a1, unsigned __int8 a2, char a3);
int __fastcall do_32G_retry_seq_all_phy(int a1, unsigned __int8 a2, char a3);
int __fastcall do_32G_retry_seq_by_worse_phy(int a1, int a2, int a3, int a4, int a5);
int __fastcall load_32G_advance(int a1, unsigned __int8 a2, char a3);
int __fastcall ajust_retry_param(int a1, char a2, char a3);
int __fastcall check_cmn_lock_status(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5);
int __fastcall check_ref_clock_ready_ext(int a1, int a2, unsigned __int8 a3, int a4, int a5);
int __fastcall check_bist_tx_running(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall check_bist_tx_running_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall check_bist_rx_running(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall check_bist_rx_running_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall check_bist_done(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall check_bist_done_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall sub_C9C74(int a1, int a2, unsigned __int8 a3, _DWORD *a4);
int __fastcall check_bist_error(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall check_bist_error_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall config_rxifrx_sigdet_ovr(int a1, unsigned __int8 a2, char a3, char a4);
int __fastcall config_rxifrx_sigdet_ovr_one_lane(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4);
int __fastcall enable_rxbist_autostop(int a1, unsigned __int8 a2, char a3, char a4, char a5);
int __fastcall enable_rxbist_autostop_one_lane(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4, char a5);
int __fastcall read_rx_debug_reg2(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4);
int __fastcall read_rx_debug_reg2_one_lane(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4);
int __fastcall serdes_phy_bist_internal_serial(int a1, unsigned __int8 a2, char a3, char a4, char a5);
int __fastcall serdes_phy_bist_internal_digital(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4, char a5);
int __fastcall serdes_phy_bist_external(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4, char a5, int a6);
int __fastcall div2_seq(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall div4_seq(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall div8_seq(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall div32_20210813_500M(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall div2_seq_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall div4_seq_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall div8_seq_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall div32_20210813_500M_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall sub_D0584(unsigned int a1, unsigned int a2);
int __fastcall serdes_phy_bist_external_0811(int a1, unsigned __int8 a2, char a3, char a4, char a5, unsigned int a6, int a7);
int __fastcall serdes_phy_bist_external_0811_all_lane(int a1, unsigned __int8 a2, char a3, char a4, char a5, unsigned int a6);
int __fastcall serdes_phy_bist_external_phy1tx_phy2rx(int a1, unsigned __int8 a2, char a3, char a4, unsigned int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, unsigned __int8 a9);
int __fastcall serdes_phy_bist_external_all_phy(int a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __fastcall serdes_phy_bist(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
int __fastcall setup_serdes_phy_x_y(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, char a6);
int __fastcall set_logic_core_id(int a1);
int __fastcall setup_mac_lane_cross(int a1);
int __fastcall setup_mac(int a1);
int __fastcall disable_mac(int a1);
int __fastcall membist0(int a1);
int __fastcall membist1(int a1);
int __fastcall enable_work(int a1, int a2);
int __fastcall open_core_clk(int a1);
int __fastcall close_core_clk(int a1);
int __fastcall open_cores_by_work_num(int a1);
int __fastcall set_work_mode(int a1, int a2);
int __fastcall set_work_num(int a1, int a2);
int __fastcall set_nonce_num(int a1, int a2);
int __fastcall set_work_timeout(int a1, int a2);
int __fastcall set_work_debug(int a1, int a2);
int __fastcall set_safe_mode(int a1, int a2);
int __fastcall set_data_preemptive(int a1, int a2);
int __fastcall set_core_bus_reset(int a1);
int __fastcall open_core_by_steps(int a1);
int __fastcall set_chip0_1_work_1_pe(int a1);
int __fastcall work_2_packet_eth(int a1, int a2, int a3, _DWORD *a4);
__int64 __fastcall sub_D9754(int a1, int a2);
int __fastcall packet_2_nonce_eth(int a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7);
int __fastcall sub_D9ED8(int a1, unsigned __int8 a2);
int __fastcall setup_ref_clk_termination(int a1);
int __fastcall setup_serdes_phy(int a1);
int __fastcall setup_all_chip_eth(int a1);
int __fastcall global_idx_init_eth(int a1);
int __fastcall global_idx_free_eth(int a1);
int __fastcall set_baud_eth(int a1, char *a2);
int __fastcall check_nonce_eth(int a1, int a2);
int get_chip_status_eth();
int get_algo_type_eth();
int softreset_all_chip_eth();
int __fastcall get_theory_hashrate_eth(int a1, double *a2);
int set_boot_config_eth();
int __fastcall set_sensor_extern_mode_eth(int a1);
int __fastcall read_sensor_temp_local_eth(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_eth(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int parameter_update_eth();
int overclock_update_eth();
int __fastcall get_pcba_test_level_eth(int a1, _DWORD *a2);
int __fastcall get_packet_remain_len_eth(unsigned __int8 a1);
int __fastcall stop_mining_eth(int a1);
int __fastcall recover_mining_eth(int a1);
int __fastcall update_mbist_cnt_for_pcba_test_base(int a1, void *a2);
int __fastcall prepare_for_pcba_test_base(int a1, int *a2);
void *runtime_ctrl_eth();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_DAC10(const char **a1, const char *a2);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_DAC34(int a1, __int64 a2);
int __fastcall sub_DAC5C(int result, int a2, unsigned int a3);
int __fastcall sub_DAD3C(unsigned __int8 a1);
_BYTE *__fastcall sub_DAE40(_BYTE *result, int a2);
int __fastcall sub_DAE88(int a1, int a2);
int __fastcall sub_DB470(int a1);
int __fastcall sub_DB564(int a1, char a2);
int __fastcall sub_DB674(int a1, char *a2);
int __fastcall sub_DB908(int a1, char *a2);
unsigned int *__fastcall sub_DBB2C(unsigned int *result);
int __fastcall sub_DBC3C(int a1);
int __fastcall sub_DBD90(int a1, char a2);
int __fastcall sub_DBF10(int a1);
int __fastcall sub_DC2FC(int a1, int a2);
int __fastcall sub_DC418(int a1, char a2, char a3, int a4);
int __fastcall sub_DC464(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6);
int __fastcall sub_DC584(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n);
int __fastcall sub_DC5F8(int a1, int a2, int a3, size_t a4);
int __fastcall sub_DC69C(int a1, int a2, int a3, size_t a4);
int __fastcall sub_DC740(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_DC7A4(int a1, unsigned int *a2, _DWORD *a3, int a4);
int __fastcall sub_DC808(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_DC9E0(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_DCBBC(int a1);
int __fastcall sub_DCBF4(int a1);
int __fastcall sub_DCC48(int a1, void *a2, unsigned int a3);
int __fastcall sub_DCF14(int a1, char a2, int a3, void *a4);
unsigned int __fastcall sub_DCFA0(int a1, int a2, void *a3);
int __fastcall sub_DD250(int a1, __int16 a2, int a3);
int __fastcall sub_DD298(int a1, __int16 a2, int a3);
int __fastcall sub_DD2F0(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_DD350(int a1, char a2, char a3, __int16 a4, int a5);
int __fastcall sub_DD3B4(int a1, char a2, __int16 a3, int a4);
int __fastcall sub_DD410(int a1, __int16 a2, __int16 a3, void *a4);
int __fastcall sub_DD794(int a1, char a2, __int16 a3, __int16 a4, void *a5);
int __fastcall global_idx_init_ltc(int a1);
int __fastcall global_idx_free_ltc(int a1);
__int64 __fastcall sub_DDB6C(int a1, unsigned __int8 a2);
int __fastcall sub_DDD00(int a1, int a2, int a3);
int __fastcall sub_DDDB0(int result, int a2);
int __fastcall work_2_packet_ltc(int a1, int a2, _BYTE *a3, _DWORD *a4);
__int64 __fastcall sub_DE278(int a1, int a2, int a3);
int __fastcall packet_2_nonce_ltc(_DWORD *a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7);
bool __fastcall sub_DE798(_DWORD *a1, char a2);
int __fastcall sub_DE860(int a1, unsigned __int8 a2);
int __fastcall sub_DE8B0(int a1, unsigned int a2);
int __fastcall setup_all_chip_ltc(_DWORD *a1);
int __fastcall set_baud_ltc(int a1, char *a2);
int __fastcall sub_DEE20(int a1, int a2);
int __fastcall check_nonce_ltc(int a1, int a2);
int __fastcall get_chip_status_ltc(_DWORD *a1, int a2);
int get_algo_type_ltc();
int __fastcall softreset_all_chip_ltc(int a1);
int __fastcall get_theory_hashrate_ltc(int a1, double *a2);
int set_boot_config_ltc();
int __fastcall set_sensor_extern_mode_ltc(int a1);
int __fastcall read_sensor_temp_local_ltc(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall read_sensor_temp_remote_ltc(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall parameter_update_ltc(int a1, char a2, int a3, char a4, int a5);
int overclock_update_ltc();
int get_pcba_test_level_ltc();
int get_packet_remain_len_ltc();
int __fastcall adjust_working_freq_ltc(int a1, int a2);
void *runtime_ctrl_ltc();
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_DF6A0(int a1, __int64 a2);
int __fastcall sub_DF6C8(int result, int a2, unsigned int a3);
int __fastcall sub_DF7A8(unsigned __int8 a1);
int __fastcall chip_setting_software_reset_ltc(int a1);
int __fastcall chip_setting_misc_ltc(int a1, char *a2);
unsigned int *__fastcall sub_DFBFC(unsigned int *result);
int __fastcall chip_setting_freq_ltc(int a1, char a2, int a3);
int __fastcall chip_setting_ticket_mask_ltc(int a1, unsigned int a2);
int __fastcall chip_setting_check_bist_ltc(int a1, unsigned __int8 a2, int a3, int a4, _BOOL4 *a5);
int __fastcall chip_setting_reset_bist_ltc(int a1, char a2, int a3, char a4, int a5);
int __fastcall chip_setting_working_mode_ltc(int a1, char a2, int a3, char a4, int a5, unsigned __int8 a6);
_DWORD *__fastcall sub_E0F50(_DWORD *result, _DWORD *a2, int a3);
_DWORD *__fastcall sub_E0F80(_DWORD *a1, int a2);
void __cdecl _list_del(list_head *prev, list_head *next);
void __cdecl list_del(list_head *entry);
bool __fastcall sub_E0FF0(_DWORD *a1);
int __fastcall sub_E1014(int result, int a2, unsigned int a3);
int __fastcall sub_E10B4(unsigned __int8 a1);
int __fastcall sub_E10F4(unsigned __int8 a1);
int __fastcall extract_byte_from_hex(const char *a1, int a2);
int __fastcall format_hashrate_string(const char *a1, char *a2);
int __fastcall format_hashrate_double(const char *a1, double *a2, char *a3);
int __fastcall bin2hex(int result, int a2, unsigned int a3);
void *__fastcall abin2hex(int a1, unsigned int a2);
bool __fastcall hex2bin(_BYTE *a1, char *a2, int a3);
int __fastcall sub_E1BE0(unsigned __int8 a1);
int __fastcall str2hex(int a1, int a2, int a3);
int __fastcall valid_hex(const char *a1);
int __fastcall valid_ascii(const char *a1);
char *tq_new();
void __fastcall tq_free(char *a1);
int __fastcall sub_E2100(int a1, char a2);
int __fastcall tq_freeze(int a1);
int __fastcall tq_thaw(int a1);
int __fastcall tq_push(int a1, int a2);
int __fastcall tq_pop(int a1, const struct timespec *a2);
int __fastcall sub_E229C(int a1, int a2);
int __fastcall cgtime(struct timeval *a1);
_DWORD *__fastcall cgtimer_sub(_DWORD *result, _DWORD *a2, _DWORD *a3);
int __fastcall sub_E2384(const char *a1, int *a2, int a3, int a4);
int __fastcall get_server_port_from_url(const char *a1, char *a2, _WORD *a3);
int __fastcall find_min_and_max_float(int result, int a2, float *a3, float *a4);
int *__fastcall find_min_and_max_int(int *result, int a2, _DWORD *a3, _DWORD *a4);
void __cdecl set_flag_to_bad_asic_cfg_freq(uint8_t flag);
_BYTE *__fastcall sub_E2754(_BYTE *result, char a2, int a3, unsigned __int8 a4);
int __fastcall sub_E282C(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4, unsigned __int8 a5);
int __fastcall sub_E289C(int a1, int a2, _BYTE *a3, unsigned __int8 *a4);
int __fastcall pic1704_get_sw_version(char a1, _BYTE *a2);
int __fastcall pic1704_jump_to_app(char a1);
int __fastcall pic1704_reset(char a1);
int __fastcall pic1704_enable_disable_dc_dc(char a1, char a2);
int __fastcall pic1704_erase_program(char a1);
int __fastcall pic1704_heart_beat(char a1);
int __fastcall sub_E2E54(char a1, int a2);
int __fastcall pic1704_update_app_program(unsigned __int8 a1);
int __fastcall pic1704_set_voltage(char a1, unsigned __int8 a2);
bool __fastcall sub_E35A0(unsigned __int8 *a1);
__int64 __fastcall sub_E3770(unsigned int a1);
int __fastcall pic1704_get_an_voltage1(char a1);
int __fastcall pic1704_get_an_voltage2(char a1, char a2);
int __fastcall pic1704_get_single_voltage(char a1, int *a2);
int __fastcall pic1704_get_all_voltage(char a1, int *a2, int *a3, int *a4);
int __fastcall pic1704_voltage_clamp_ctrl(char a1, char a2);
int __fastcall pic1704_get_PDCx(char a1, int *a2, int *a3, int *a4);
int __fastcall pic1704_get_raw_crab_voltage(char a1, int *a2, int *a3, int *a4, int *a5);
int __fastcall pic1704_write_iic(char a1, char a2);
int __fastcall pic1704_read_iic(char a1, char a2, _BYTE *a3);
int __fastcall pic1704_write_flash(char a1, const void *a2, char a3, size_t a4);
int __fastcall pic1704_read_flash(char a1, void *a2, char a3, size_t a4);
int __fastcall open_pic(unsigned __int8 a1);
int __fastcall close_pic(int result);
int fpga_init();
void fpga_uninit();
int __fastcall fpga_read(unsigned int a1, _DWORD *a2);
int __fastcall fpga_write(unsigned int a1, int a2);
int get_fpga_map_mem_addr();
int sub_E4CC8();
int __fastcall sub_E4DF4(unsigned int a1);
int __fastcall sub_E4E50(int a1);
int __fastcall sub_E4E90(int a1, char a2);
int ui_init();
void ui_uninit();
int __fastcall sub_E5260(int result, int *a2);
int __fastcall sub_E5330(int result, int a2, int *a3);
int __fastcall sub_E54C4(unsigned int a1, int a2);
int red_led_on();
int red_led_off();
int red_led_flicker();
int green_led_on();
int green_led_off();
int green_led_flicker();
int beeper_on();
int beeper_off();
int beeper_flicker();
int __fastcall reg_key_callback(int (__fastcall *a1)(int, bool));
int __fastcall unreg_key_callback(int (__fastcall *a1)(int, bool));
int __fastcall lcd_show_result(unsigned __int8 a1, int a2, unsigned int a3);
int lcd_clear_result();
int bitmain_power_on();
int bitmain_power_off();
int __fastcall iic_init(int a1);
int __fastcall iic_uninit(int a1);
int __fastcall iic_read(int a1, int a2, unsigned int a3);
int __fastcall iic_write(int a1, int a2, unsigned int a3);
int __fastcall iic_read_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5);
int __fastcall iic_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5);
unsigned int *__fastcall sub_E6798(unsigned int *result);
int platform_init();
int platform_uninit();
void *__fastcall get_system_capability(void *result);
int __fastcall sub_E6DC4(const char *a1, int a2);
int __fastcall get_uuid(void *a1);
int __fastcall get_mac_hal(int a1);
int __fastcall chain_reset(char a1);
int __fastcall chain_reset_low(char a1);
int __fastcall chain_reset_high(char a1);
unsigned int all_chain_reset_high();
unsigned int all_chain_reset_low();
void board_reset();
void board_reset_low();
void board_reset_high();
int get_hardware_type();
int __fastcall set_hardware_type(int a1);
int enable_bypass_mode();
int disable_bypass_mode();
bool is_bypass_mode_enable();
int get_hardware_version();
int get_dhash_acc_control();
__int64 __fastcall set_dhash_acc_control(int a1);
__int64 disable_dhash_chip_work();
__int64 fpga_chain_reset_all();
__int64 __fastcall read_fpga_id(char *a1);
int __fastcall set_hardware_version(int a1);
int get_job_start_address();
int __fastcall set_job_start_address(int a1);
int get_nonce2_and_job_id_store_address();
int __fastcall set_nonce2_and_job_id_store_address(int a1);
int __fastcall get_fan_speed(_BYTE *a1, _DWORD *a2);
int __fastcall set_time_out_control(int a1);
int get_hash_counting_number();
int __fastcall set_hash_counting_number(int a1);
int enable_mid_auto_gen_rx();
int disable_mid_auto_gen_rx();
int get_crc_count();
int __fastcall reset_crc_count(char a1);
int get_hash_on_plug();
int get_nonce_number_in_fifo();
int __fastcall get_return_nonce(_DWORD *a1);
int __fastcall get_return_nonce_128bit(_DWORD *a1);
int get_ticket_mask();
int __fastcall set_ticket_mask(int a1);
int get_job_id();
int __fastcall set_job_id(int a1);
int get_job_length();
int __fastcall set_job_length(int a1);
int get_work_fifo_state();
int get_block_header_version();
int __fastcall set_block_header_version(int a1);
int get_block_header_version_1();
int get_block_header_version_2();
int get_block_header_version_3();
int __fastcall set_block_header_version_1(int a1);
int __fastcall set_block_header_version_2(int a1);
int __fastcall set_block_header_version_3(int a1);
int __fastcall set_block_header_version_4(int a1);
int __fastcall set_block_header_version_5(int a1);
int __fastcall set_block_header_version_6(int a1);
int __fastcall set_block_header_version_7(int a1);
int get_time_stamp();
int __fastcall set_time_stamp(int a1);
int get_target_bits();
int __fastcall set_target_bits(int a1);
int __fastcall set_pre_header_hash(int result);
int __fastcall set_coinbase_length_and_nonce2_length(int a1);
int __fastcall set_work_nonce2(int *a1);
int __fastcall set_merkle_bin_number(unsigned __int16 a1);
int get_nonce_fifo_interrupt();
int __fastcall set_nonce_fifo_interrupt(int a1);
int __fastcall sub_E803C(int *a1);
int sub_E8098();
int __fastcall sub_E80B4(int a1);
int set_BC_nullen_all_chain();
int __fastcall set_BC_baud(char a1);
int __fastcall set_BC_nullen(int a1, char a2);
int __fastcall send_BC_command(int *a1, int a2);
int __fastcall set_TW_write_command(int result);
int __fastcall set_TW_write_command_vil(int *a1);
int __fastcall set_TW_write_command_chunk0(int *a1);
int __fastcall set_TW_write_command_x_midstate(int *a1, int a2);
int get_QN_write_data_command();
int __fastcall set_QN_write_data_command(int a1);
int get_temperature_0_3();
int get_temperature_4_7();
int get_temperature_8_11();
int get_temperature_12_15();
int __fastcall set_fan_control(int a1);
int __fastcall set_fan_control_1(int a1);
int get_bt8d_control();
int __fastcall set_bt8d_control(int a1);
int __fastcall lcd_init(const char *a1);
int __fastcall lcd_write(int a1, unsigned __int8 a2, int a3, unsigned int a4);
int lcd_flush();
int __fastcall lcd_clear(int a1);
int __fastcall lcd_uninit(int a1);
int __fastcall pwm_init(unsigned int a1, int a2);
int __fastcall pwm_uninit(int result);
int __fastcall pwm_set(int a1, unsigned int a2);
int __fastcall pwm_get(int a1, _DWORD *a2);
int i2c_init();
int __fastcall i2c_uninit(int a1);
int sub_E9B58();
int __fastcall sub_E9B9C(_BYTE *a1);
int __fastcall i2c_read(int a1, int a2, unsigned int a3);
int __fastcall i2c_write(int a1, int a2, unsigned int a3);
int __fastcall i2c_read_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5);
int __fastcall i2c_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5);
int __fastcall i2c_ioctl(int a1, __int16 a2, int a3);
int __fastcall i2c_select(int a1, int a2);
int sub_EB14C(); // weak
int gpio_init();
int gpio_uninit();
int __fastcall gpio_reg_callback(int a1, int a2);
int __fastcall gpio_unreg_callback(int a1, int a2);
int __fastcall gpio_export(int a1);
int __fastcall gpio_unexport(int a1);
int __fastcall gpio_direction(int a1, int a2);
int __fastcall gpio_read(int a1, _BYTE *a2);
int __fastcall gpio_write(int a1, char a2);
int __fastcall is_gpio_exist(int a1);
int fan_init();
void fan_uninit();
int __fastcall fan_get_realtime_speed(int a1);
int __fastcall sub_ECC78(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
int __fastcall sub_ED0C8(int a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_ED388(unsigned __int8 a1);
int __fastcall sub_ED668(int a1, int a2, unsigned int a3);
int uart_init();
void uart_uninit();
int __fastcall sub_EDB68(const char *a1, unsigned __int8 *a2, int a3);
size_t __fastcall uart_send(int a1, const void *a2, size_t a3);
int __fastcall uart_receive(int a1, int a2, unsigned int a3);
int __fastcall uart_set_config(int a1, int a2, int *a3);
int __fastcall uart_get_config(int a1, int a2, _DWORD *a3, int a4);
int __fastcall high_speed_uart_set_config(int a1, int a2, _DWORD *a3);
int __fastcall high_speed_uart_get_config(int a1, int a2, unsigned int *a3, int a4);
int __fastcall sub_EE814(int a1);
int __fastcall clear_uart_rx_fifo(int a1);
int __fastcall uart_flush(int a1);
int __fastcall uart_flush_tx(int a1);
int __fastcall uart_flush_rx(int a1);
int __fastcall uart_get_readable_byte_num(int a1);
int __fastcall sub_EEEF8(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall sub_EF2B0(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5);
int __fastcall sub_EF50C(int a1);
int __fastcall sub_EF790(int a1);
int __fastcall sub_EFA14(int a1);
int __fastcall sub_EFC70(int a1, unsigned __int8 a2);
int __fastcall sub_EFF44(int a1);
int bitmain_power_open();
int bitmain_power_close();
int bitmain_power_fw_version();
int bitmain_power_version();
void bitmain_get_voltage();
int bitmain_set_voltage();
int __fastcall bitmain_set_voltage_by_n(unsigned __int8 a1);
void bitmain_convert_N_to_V_calibration();
int bitmain_convert_V_to_N_calibration();
int bitmain_convert_V_to_N();
void bitmain_convert_N_to_V();
int __fastcall bitmain_power_read(unsigned __int8 a1, int a2, unsigned __int8 a3);
int get_power_voltage_calibration_data();
int __fastcall set_chipaddr_base(int a1, int a2, int a3);
int __fastcall set_inactive_base(int a1);
int __fastcall set_chip_reg_base(int a1, int a2);
int __fastcall sync_get_status_unclear_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_status_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_dag_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_chip_reg_base(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall sync_get_dag_node_base(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall set_core_reg_base(int a1, int a2);
int __fastcall set_core_reg_base_9(int a1, int a2);
int __fastcall sync_get_core_reg_base_3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall sync_get_core_reg_base(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall sync_get_status_base2(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_chip_reg_base2(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall set_core_reg_base2(int a1, int a2);
int __fastcall sync_get_core_reg_base2(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall set_core_enable_base(int a1, int *a2, __useconds_t a3);
int __fastcall set_core_enable_base2(int a1, int a2, __useconds_t a3);
int __fastcall sync_get_status_base3(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_core_reg_base3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall get_fake_regio_runtime(int a1);
int __fastcall set_chipaddr_by_id(int a1, int a2, int a3);
int __fastcall set_inactive_by_id(int a1);
int __fastcall set_chip_reg_by_id(int a1, int a2);
int __fastcall set_core_reg_by_id(int a1, int a2);
int __fastcall sync_get_chip_reg_by_id(int a1, int a2, int a3, int a4, int a5);
int __fastcall sync_get_core_reg_by_id(int a1, int a2, int a3, int a4, int a5);
unsigned int __fastcall sub_F4034(unsigned int a1);
int __fastcall reverse_byte_order_16(unsigned __int16 a1);
unsigned int __fastcall reverse_byte_order_32(unsigned int a1);
int __fastcall send_command_packet(int a1, int a2, unsigned int a3);
int __fastcall convert_offset_to_chain_id(int a1);
int scan_miner_device_hal();
int __fastcall dev_init_hal(int a1);
int dev_init_hal_pcba();
int __fastcall dev_init_pic_for_one_chain(int a1);
int __fastcall sub_dev_init_hal(unsigned int a1);
int __fastcall dev_is_valid_hal(int a1);
int __fastcall set_dev_invalid_hal(int result);
int __fastcall dev_config_hal(int a1);
int __fastcall dev_config_one_chain_baud(int a1, int a2);
int __fastcall dump_log_hal(const char *a1, int a2, int a3, int a4);
size_t __fastcall dev_send_work_cmd_hal(int a1, int a2, unsigned int a3);
size_t __fastcall dev_send_reg_cmd_hal(int a1, const void *a2, size_t a3);
int __fastcall dev_read_nonce_reg_data_hal(int a1, int a2, unsigned int a3);
int dev_get_nonce_reg_fifo_size_hal();
int dev_get_reg_fifo_capacity_hal();
int dev_get_work_fifo_capacity_hal();
int dev_dma_rw_dispatcher_hal();
int dev_exit_hal();
int __fastcall power_on_hal(int a1, unsigned __int16 a2, int a3);
int __fastcall power_off_hal(int a1);
int hardreset_hal();
int __fastcall softreset_hal(int a1);
int __fastcall heartbeat_to_hal(int a1);
int __fastcall pic_operation_to_hal(int a1, int a2, unsigned int a3, void *a4);
_UNKNOWN **dev_ctrl_hal();
int __fastcall sub_F5378(int result, int a2, unsigned int a3);
int __fastcall sub_F5458(unsigned __int8 a1);
int __fastcall chip_setting_fuart_cfg_dcr(int a1, char *a2);
int __fastcall chip_setting_misc_dcr(int a1);
int __fastcall chip_setting_ticket_value_dcr(int a1, int a2);
int __fastcall sub_F5AA0(int result, int a2, unsigned int a3);
int __fastcall sub_F5B80(unsigned __int8 a1);
int __fastcall chip_setting_fuart_cfg_ckb2(int a1, char *a2);
int __fastcall chip_setting_misc_ckb2(int a1);
int __fastcall chip_setting_ticket_value_ckb2(int a1, int a2);
int __fastcall set_chip_reg_ltc(int a1, int a2);
int __fastcall sync_get_status_unclear_ltc(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_status_ltc(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5);
int __fastcall sync_get_chip_reg_ltc(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6);
int __fastcall set_core_reg_ltc(int a1, int a2);
int __fastcall sync_get_core_reg_ltc(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6);
int __fastcall set_core_enable_ltc(int a1, int a2, __useconds_t a3);
_DWORD *__fastcall new_c_map(int a1, int a2, int a3);
int __fastcall insert_c_map(int *a1, const void *a2, size_t a3, const void *a4, size_t a5);
bool __fastcall exists_c_map(int *a1, int a2);
int __fastcall remove_c_map(int *a1, int a2);
int __fastcall find_c_map(int *a1, int a2, void **a3);
int __fastcall delete_c_map(void ***a1);
_DWORD *__fastcall sub_F704C(int *a1);
int __fastcall sub_F7070(int a1);
void *__fastcall sub_F70C8(int a1);
void *__fastcall sub_F70E8(int a1, const void *a2, size_t a3);
_DWORD *__fastcall new_iterator_c_map(int a1);
void __fastcall delete_iterator_c_map(void *a1);
int __fastcall sub_F71A4(unsigned __int8 a1, int a2, unsigned int a3);
int __fastcall sub_F71D4(unsigned __int8 a1, int a2, unsigned int a3);
int __fastcall sub_F7204(unsigned __int8 a1, char a2, char a3, int a4, int a5);
int __fastcall sub_F7748(unsigned __int8 a1, char a2, char a3, int a4, int a5);
int __fastcall sub_F7C84(unsigned __int8 a1, char a2, _WORD *a3);
int __fastcall sub_F7CD8(int a1, char a2, unsigned __int16 a3);
int __fastcall get_chain_isl_voltage(unsigned __int8 a1, int a2, int a3);
int __fastcall set_chain_isl_voltage(int a1, unsigned __int16 a2);
void *__fastcall clib_copy(void *a1, const void *a2, size_t a3);
void *__fastcall clib_get(void *a1, const void *a2, size_t a3);
void **__fastcall new_clib_object(const void *a1, size_t a2);
int __fastcall get_raw_clib_object(int a1, void **a2);
void *__fastcall replace_raw_clib_object(void **a1, const void *a2, size_t a3);
void __fastcall delete_clib_object(void **a1);
char *__fastcall clib_strdup(const char *a1);
_DWORD *__fastcall sub_F8330(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_F83C0(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall new_c_rb(int a1, int a2, int a3);
_DWORD *__fastcall sub_F84BC(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall find_c_rb(int a1, int a2);
int __fastcall insert_c_rb(int a1, const void *a2, size_t a3, const void *a4, size_t a5);
int *__fastcall sub_F87BC(int *result, int a2);
int *__fastcall sub_F8948(int *a1, int *a2);
int *__fastcall remove_c_rb(int a1, int a2);
void __fastcall sub_F8ABC(int a1, int a2);
int __fastcall delete_c_rb(void **a1);
_DWORD *__fastcall minimum_c_rb(int a1, _DWORD *a2);
int __fastcall maximum_c_rb(int a1, int a2);
bool __fastcall empty_c_rb(_DWORD *a1);
int *__fastcall tree_successor(int *a1, int a2);
int __fastcall sub_F8CDC(_DWORD **a1);
int __fastcall sub_F8D1C(int result, _DWORD *a2);
void sub_F8D54();
int __fastcall sub_F8D6C(int a1, int a2);
int __fastcall sub_F8D94(int a1, _DWORD *a2);
int __fastcall sub_F8DD4(int a1, _DWORD *a2);
int __fastcall sub_F8DFC(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __fastcall sub_F8E60(__int64 *a1);
double __cdecl diff_from_target(void *target);
void *__fastcall diff_to_target_dash(void *a1);
int __fastcall target_to_diff_dash(int a1);
int __fastcall target_to_diff_vbk(int a1);
void target_to_double_diff_vbk();
void diff_to_target_vbk();
__int64 __fastcall sub_F9438(unsigned __int8 *a1);
__int64 *__fastcall sub_F953C(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
int __fastcall sub_F99A4(int a1, int a2);
int __fastcall sub_FA148(int result, int a2);
int __fastcall vblake_hash(int a1, int a2);
int __fastcall sub_FA3A8(int a1, int a2, unsigned int a3);
int __fastcall sub_FA3C8(int result, int a2, unsigned int a3);
int __fastcall sub_FA4A8(unsigned __int8 a1);
void *__fastcall diff_to_target_eth(void *a1);
int __fastcall target_to_diff_eth(int a1);
int __fastcall target_to_double_diff_eth(int a1);
int __fastcall get_epoch_num(unsigned __int64 a1);
__int64 __fastcall get_cache_size(int a1);
__int64 __fastcall get_dag_size(int a1);
int __fastcall get_epoch_number_eth(const void *a1);
_DWORD *__fastcall get_seedhash_by_block_num(_DWORD *a1, unsigned __int64 a2);
int __fastcall set_cur_seed(_DWORD *a1);
int __fastcall get_cur_seed(_DWORD *a1);
int __fastcall sub_FA828(__int64 *a1);
int __fastcall target_to_double_diff_dcr(__int64 *a1);
void *__fastcall diff_to_target_dcr(void *a1);
int __fastcall target_to_diff_dcr(int a1);
void *__fastcall graph_init_ae(int a1);
void __fastcall graph_exit_ae(int a1);
int __fastcall sub_FAAD4(int a1, int a2, unsigned int a3, unsigned int a4);
int __fastcall sub_FAB28(int a1, unsigned int *a2, int a3, unsigned int *a4, int a5);
unsigned int __fastcall sub_FABE4(int a1, unsigned int a2, int a3);
unsigned int __fastcall graph_add_edge_ae(unsigned int result, int a2, int a3);
int __fastcall get_sols_ae(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, int a8);
void *__fastcall cuckoo_hash_init(int a1);
void __fastcall cuckoo_hash_exit(int a1);
int __fastcall cuckoo_hash_set(int result, unsigned int a2, int a3);
int __fastcall cuckoo_hash_operator(int a1, unsigned int a2);
int __fastcall sub_FB0E4(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
unsigned __int64 __fastcall sub_FB15C(unsigned __int64 a1, char a2);
unsigned __int64 __fastcall sub_FB1E4(int a1);
int __fastcall sub_FB268(int result);
int __fastcall sub_FB2E4(int a1);
int __fastcall sub_FB614(int a1, __int64 a2);
_QWORD *__fastcall sub_FB6D8(_QWORD *result, _QWORD *a2);
int __fastcall sip_node_ae(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, unsigned int a7);
_QWORD *__fastcall generate_sipkeys_ae(int a1, unsigned int a2, _QWORD *a3);
int __fastcall siphash_verify_ae(int a1, int a2, int a3, int a4);
void *__fastcall diff_to_target_ltc(void *a1);
int __fastcall target_to_diff_ltc(int a1);
int __fastcall sub_FBA34(__int64 *a1);
int __fastcall target_to_double_diff_ltc(__int64 *a1);
void *__fastcall sub_FBB68(int *a1, int a2, int a3);
void __fastcall sub_FBD18(int a1);
__int64 __fastcall sub_FBD88(int a1, int a2);
void *__fastcall sub_FBEA4(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_FBFD4(_DWORD *result, int a2, int a3, int a4);
_DWORD *__fastcall sub_FC080(_DWORD *a1, int a2, int a3);
size_t *__fastcall sub_FC0CC(int a1);
_DWORD *__fastcall new_graph29(int a1, int a2);
void __fastcall free_graph29(void (__fastcall **a1)(_DWORD));
void *__fastcall diff_to_target_ckb(void *a1);
int __fastcall target_to_diff_ckb(int a1);
int __fastcall target_to_double_diff_ckb(int a1);
void *__fastcall sub_FC280(int *a1, int a2, int a3);
void __fastcall sub_FC428(int a1);
__int64 __fastcall sub_FC498(int a1, int a2, int a3);
void *__fastcall sub_FC50C(_DWORD *a1, int a2, unsigned int a3, int a4);
_DWORD *__fastcall sub_FC64C(_DWORD *result, unsigned int a2, int a3);
_DWORD *__fastcall sub_FC740(_DWORD *a1, int a2, int a3);
size_t *__fastcall sub_FC784(int a1);
_DWORD *__fastcall new_graph32(int a1, int a2);
void __fastcall free_graph32(void (__fastcall **a1)(_DWORD));
int logfmt_raw(void *a1, size_t a2, int a3, ...);
int V_LOCK();
int V_UNLOCK();
const char **__fastcall V_STR(const char **a1, const char *a2, const char *a3);
int __fastcall V_FLOAT(int a1, const char *a2);
const char **__fastcall V_BOOL(const char **a1, const char *a2, char a3);
int __fastcall V_INT(int a1, const char *a2, __int64 a3);
int log_init();
int __fastcall log_uninit(int a1);
int log_reload();
int __fastcall _init_pipe_of_queue(int *a1, int a2, int a3);
void __fastcall _deinit_pipe_of_queue(int *a1);
char *__fastcall queue_new(int a1, int a2);
void __fastcall queue_free(int a1);
int __fastcall queue_enqueue(int a1, char *a2, int a3);
int __fastcall clean_up(pthread_mutex_t *a1);
void __fastcall queue_dequeue(int a1, char *a2, unsigned int a3);
int __fastcall queue_dequeue_for(int a1, char *a2, unsigned int a3, _DWORD *a4);
int __fastcall queue_clear(int a1);
int __fastcall queue_try_dequeue(int a1, char *a2, unsigned int a3);
int __fastcall queue_element_num(int a1);
int __fastcall queue_force_wakeup(int a1);
unsigned __int16 __cdecl crc_itu_t_byte(unsigned __int16 crc, const unsigned __int8 data);
unsigned __int16 __cdecl CRC16_v1(const unsigned __int8 *buffer, int len);
int __fastcall BM_CRC16_WITH_KEY(const unsigned __int8 *a1, int a2, unsigned __int16 a3);
int BM_CRC8();
int __fastcall BM_CRC5(_BYTE *a1, unsigned int a2);
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len);
int __fastcall xxtea_encode(unsigned int *a1, unsigned int a2, int a3);
int __fastcall xxtea_decode(unsigned int *a1, unsigned int a2, int a3);
int __fastcall data_enc(unsigned int *a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall data_dec(unsigned int *a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall sub_FE384(int a1);
int __fastcall pipe_elem_size(int a1);
_DWORD *__fastcall sub_FE3B4(_DWORD *a1, _DWORD *a2);
int __fastcall sub_FE3F8(int a1, int a2, int a3, int a4, int a5);
bool __fastcall sub_FE420(int a1, int a2, unsigned int a3, unsigned int a4);
int __fastcall sub_FE450(int a1, int a2, unsigned int a3, unsigned int a4, int a5);
unsigned int __fastcall sub_FE4A4(int a1, unsigned int a2, unsigned int a3);
unsigned int __fastcall sub_FE4D8(unsigned int a1, unsigned int a2, int a3);
char *__fastcall sub_FE50C(char *a1, const void *a2, size_t a3);
unsigned int __fastcall sub_FE530(unsigned int a1);
_DWORD *__fastcall sub_FE590(_DWORD *result);
_DWORD *__fastcall sub_FE5C0(int a1);
int __fastcall sub_FE5EC(int a1);
_DWORD *__fastcall pipe_new(int a1, int a2);
int __fastcall pipe_producer_new(int a1);
int __fastcall pipe_consumer_new(int a1);
void __fastcall sub_FE78C(int a1);
void __fastcall pipe_free(int a1);
void __fastcall pipe_producer_free(int a1);
void __fastcall pipe_consumer_free(int a1);
char *__fastcall sub_FE994(const void *a1, int a2, const void *a3, unsigned int a4, int a5, char *a6);
_DWORD *__fastcall sub_FEA04(_DWORD *a1, int a2, unsigned int a3);
_DWORD *sub_FEAC8(_DWORD *a1, _DWORD *a2, ...);
unsigned int __fastcall sub_FEBB8(int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5, char *a6, size_t a7);
_DWORD *__fastcall sub_FEC5C(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __fastcall _pipe_push(_DWORD *a1, char *a2, unsigned int a3);
int __fastcall pipe_push(_DWORD *a1, char *a2, int a3);
_DWORD *__fastcall sub_FEE88(_DWORD *a1, _DWORD *a2);
unsigned int *__fastcall sub_FEF24(unsigned int *a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5, int a6, char *dest, size_t n, unsigned int *a9);
int sub_FF010(_DWORD *a1, ...);
size_t __fastcall sub_FF0EC(_DWORD *a1, void *a2, size_t a3);
int __fastcall pipe_pop(_DWORD *a1, char *a2, int a3);
size_t __fastcall pipe_pop_eager(_DWORD *a1, void *a2, int a3);
int __fastcall pipe_reserve(_DWORD *a1, int a2);
void *__fastcall compressor_init(int a1, int a2, int a3);
void __fastcall compressor_exit(int a1);
void **__fastcall compressor_reset(void **result);
int __fastcall compressor_stats(_DWORD *a1);
int __fastcall compress(_DWORD *a1, unsigned int a2);
_DWORD *__fastcall new_compressor(int a1, int a2);
int __fastcall free_compressor(int a1);
unsigned int __fastcall sub_FF61C(unsigned int a1);
unsigned int __fastcall sub_FF634(unsigned int result, int a2, unsigned int a3);
int __fastcall sub_FF678(const void *a1, _DWORD *a2, int a3);
_DWORD *__fastcall sub_102CF4(_DWORD *result);
void *__fastcall sub_102D84(_DWORD *a1, int a2);
int __fastcall sub_102FE8(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int *__fastcall sub_1031C8(int *result, _DWORD *a2);
int __fastcall sub_10366C(_DWORD *a1, int a2, _DWORD *a3);
int __fastcall sub_10388C(int result, int a2);
int __fastcall scrypt_regenhash(_DWORD *a1, int a2);
int __fastcall scrypt_test(int a1, int a2, unsigned int a3);
int __fastcall PrintState(int a1);
int __fastcall EaglesongPermutation(int result);
unsigned int __fastcall EaglesongSponge(int a1, unsigned int a2, int a3, unsigned int a4, unsigned __int8 a5);
unsigned int __fastcall EaglesongHash(int a1, int a2, unsigned int a3);
unsigned int __fastcall _bswap_64(int a1, unsigned int a2);
_QWORD *__fastcall sub_103FEC(_QWORD *result);
int __fastcall sub_10403C(int a1, int a2, unsigned int a3, int a4, int a5, unsigned int a6, __int64 a7);
int __fastcall sub_104090(_DWORD *a1);
_DWORD *__fastcall sub_1040D4(_DWORD *result);
unsigned __int64 __fastcall sub_104120(unsigned __int64 a1, char a2);
unsigned __int64 __fastcall sub_1041A8(int a1);
unsigned __int64 __fastcall sub_10432C(int a1, __int64 a2);
_DWORD *new_siphash();
void __fastcall free_siphash(void *a1);
int __fastcall sub_104420(unsigned __int8 a1);
int __fastcall base64_encode_nonce(unsigned __int64 a1, int a2);
int __fastcall base64_encode(int result, int a2, int a3);
int __fastcall base64_decode(int result, int a2, int a3);
void *__fastcall sub_104824(int a1);
int __fastcall sub_104C24(int result, int a2, unsigned int a3);
int __fastcall sub_104C6C(int result, int a2, unsigned int a3);
int __fastcall sub_104CA8(int a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5, char a6);
int __fastcall eth_sha3_256(int a1, unsigned int a2, int a3, unsigned int a4);
int __fastcall eth_sha3_512(int a1, unsigned int a2, int a3, unsigned int a4);
unsigned int __fastcall sub_104E50(int a1);
__int64 __fastcall sub_104E84(int a1, int a2);
_BYTE *__fastcall sub_104F58(_BYTE *result, int a2);
unsigned int __fastcall sub_104F9C(unsigned int *a1, int a2);
unsigned int __fastcall sub_104FBC(int *a1);
_BYTE *__fastcall sub_104FD8(_BYTE *result, int a2, int a3, int a4);
__int64 __fastcall sub_105094(__int64 *a1, int a2, int a3, int a4);
__int64 __fastcall sub_1050BC(int *a1);
void *__fastcall sub_1050E0(_DWORD *a1, const void *a2, const void *a3);
unsigned int __fastcall sub_105124(unsigned int result, char *a2, size_t a3);
unsigned int __fastcall sub_10917C(_DWORD *a1, char a2, int a3, int a4, unsigned int a5);
void *__fastcall sub_109350(int a1, const void *a2, const void *a3);
int __fastcall sub_1093A4(__int64 a1, size_t a2);
_BYTE *__fastcall sub_10AB88(unsigned int a1, char a2, int a3, int a4, unsigned int a5);
void *__fastcall sph_blake224_init(_DWORD *a1);
unsigned int __fastcall sph_blake224(unsigned int a1, char *a2, size_t a3);
void *__fastcall sph_blake224_close(_DWORD *a1, int a2);
void *__fastcall sph_blake224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
void *__fastcall sph_blake256_init(_DWORD *a1);
unsigned int __fastcall sph_blake256(unsigned int a1, char *a2, size_t a3);
void *__fastcall sph_blake256_close(_DWORD *a1, int a2);
void *__fastcall sph_blake256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
int __fastcall set_total_hash_rate(int result);
void *__fastcall sph_blake384_init(int a1);
int __fastcall sph_blake384(__int64 a1, size_t a2);
void *__fastcall sph_blake384_close(unsigned int a1, int a2);
void *__fastcall sph_blake384_addbits_and_close(unsigned int a1, char a2, int a3, int a4);
void *__fastcall sph_blake512_init(int a1);
int __fastcall sph_blake512(__int64 a1, size_t a2);
void *__fastcall sph_blake512_close(unsigned int a1, int a2);
void *__fastcall sph_blake512_addbits_and_close(unsigned int a1, char a2, int a3, int a4);
void *__fastcall decred_hash(int a1, char *a2);
__int64 __fastcall sub_10B0A8(int a1, int a2);
_BYTE *__fastcall sub_10B180(_BYTE *result, int a2, int a3, int a4);
__int64 __fastcall sub_10B23C(__int64 *a1, int a2, int a3, int a4);
__int64 __fastcall sub_10B264(int *a1);
int __fastcall sub_10B288(int result, int a2, unsigned int a3, int a4);
_QWORD *__fastcall sub_10B344(_QWORD *result, __int64 a2);
__int64 __fastcall sub_10B364(int a1);
_QWORD *__fastcall sub_10B380(int a1, int a2, int a3);
_DWORD *__fastcall sub_115578(char *a1, void *a2);
void *__fastcall sub_1155B8(char *a1, void *a2);
void *__fastcall sub_1155F0(char *a1, _BYTE *a2);
_DWORD *__fastcall sub_115628(char *a1, void *a2);
void *__fastcall sub_115668(char *a1, int a2);
void *__fastcall sub_1156A0(char *a1, int a2);
int __fastcall Xhash(_DWORD, _DWORD); // weak
FILE *__fastcall x11_log_work(int a1, int a2, int a3);
void doOneTestData();
void doOneGoldenData();
int __fastcall dohash_X11(int a1, int a2, int a3, int a4);
int __fastcall sub_140E58(int result, unsigned int a2);
int __fastcall sub_140E9C(int a1);
unsigned __int8 *__fastcall sub_140EB4(unsigned __int8 *result, int a2, int *a3);
int __fastcall sub_142CC0(unsigned __int8 *a1, int a2);
int __fastcall sub_14C4AC(unsigned __int8 *a1, int a2);
void *__fastcall sub_156808(_DWORD *a1, const void *a2);
void *__fastcall sub_156848(_DWORD *a1, const void *a2);
unsigned __int8 *__fastcall sub_156888(unsigned __int8 *result, char *a2, unsigned int a3);
unsigned __int8 *__fastcall sub_156928(unsigned __int8 *result, char *a2, unsigned int a3);
int __fastcall sub_1569D4(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_156A20(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_156A6C(int a1, char a2, int a3, int a4, unsigned int a5);
int __fastcall sub_156B38(int a1, char a2, int a3, int a4, unsigned int a5);
void *__fastcall sph_simd224_init(_DWORD *a1);
unsigned __int8 *__fastcall sph_simd224(unsigned __int8 *a1, char *a2, unsigned int a3);
void *__fastcall sph_simd224_close(_DWORD *a1, int a2);
void *__fastcall sph_simd224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
void *__fastcall sph_simd256_init(_DWORD *a1);
unsigned __int8 *__fastcall sph_simd256(unsigned __int8 *a1, char *a2, unsigned int a3);
void *__fastcall sph_simd256_close(_DWORD *a1, int a2);
void *__fastcall sph_simd256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
void *__fastcall sph_simd384_init(_DWORD *a1);
unsigned __int8 *__fastcall sph_simd384(unsigned __int8 *a1, char *a2, unsigned int a3);
void *__fastcall sph_simd384_close(_DWORD *a1, int a2);
void *__fastcall sph_simd384_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
void *__fastcall sph_simd512_init(_DWORD *a1);
unsigned __int8 *__fastcall sph_simd512(unsigned __int8 *a1, char *a2, unsigned int a3);
void *__fastcall sph_simd512_close(_DWORD *a1, int a2);
void *__fastcall sph_simd512_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
int __fastcall sub_156E40(int result, unsigned int a2);
int __fastcall sub_156E84(int a1);
_BYTE *__fastcall sub_156E9C(_BYTE *result, int a2, int a3, int a4);
void *__fastcall sub_156F58(_DWORD *a1, const void *a2);
int __fastcall sub_156F8C(int result, char *a2, size_t a3);
void *__fastcall sub_15C5E8(int a1, char a2, unsigned int a3, void *a4, size_t a5, const void *a6);
void *__fastcall sph_jh224_init(_DWORD *a1);
int __fastcall sph_jh224(int a1, char *a2, size_t a3);
void *__fastcall sph_jh224_close(int a1, void *a2);
void *__fastcall sph_jh224_addbits_and_close(int a1, char a2, unsigned int a3, void *a4);
void *__fastcall sph_jh256_init(_DWORD *a1);
int __fastcall sph_jh256(int a1, char *a2, size_t a3);
void *__fastcall sph_jh256_close(int a1, void *a2);
void *__fastcall sph_jh256_addbits_and_close(int a1, char a2, unsigned int a3, void *a4);
void *__fastcall sph_jh384_init(_DWORD *a1);
int __fastcall sph_jh384(int a1, char *a2, size_t a3);
void *__fastcall sph_jh384_close(int a1, void *a2);
void *__fastcall sph_jh384_addbits_and_close(int a1, char a2, unsigned int a3, void *a4);
void *__fastcall sph_jh512_init(_DWORD *a1);
int __fastcall sph_jh512(int a1, char *a2, size_t a3);
void *__fastcall sph_jh512_close(int a1, void *a2);
void *__fastcall sph_jh512_addbits_and_close(int a1, char a2, unsigned int a3, void *a4);
unsigned int __fastcall sub_15C9BC(int a1);
_BYTE *__fastcall sub_15C9F0(_BYTE *result, int a2);
unsigned int __fastcall sub_15CA34(int *a1);
unsigned int __fastcall sub_15CA50(unsigned int result, char *a2, size_t a3);
_BYTE *__fastcall sub_15DA48(int *a1, char a2, char a3, _BYTE *a4, unsigned int a5);
unsigned int __fastcall sub_15EA68(unsigned int result, char *a2, size_t a3);
unsigned int __fastcall sub_1605D0(int *a1, char a2, char a3, _BYTE *a4);
unsigned int __fastcall sub_16214C(unsigned int result, char *a2, size_t a3);
unsigned int __fastcall sub_1648F0(int *a1, char a2, char a3, _BYTE *a4);
void *__fastcall sph_luffa224_init(int a1);
unsigned int __fastcall sph_luffa224(unsigned int a1, char *a2, size_t a3);
void *__fastcall sph_luffa224_close(int *a1, _BYTE *a2);
void *__fastcall sph_luffa224_addbits_and_close(int *a1, char a2, char a3, _BYTE *a4);
void *__fastcall sph_luffa256_init(int a1);
unsigned int __fastcall sph_luffa256(unsigned int a1, char *a2, size_t a3);
void *__fastcall sph_luffa256_close(int *a1, _BYTE *a2);
void *__fastcall sph_luffa256_addbits_and_close(int *a1, char a2, char a3, _BYTE *a4);
void *__fastcall sph_luffa384_init(int a1);
unsigned int __fastcall sph_luffa384(unsigned int a1, char *a2, size_t a3);
void *__fastcall sph_luffa384_close(int *a1, _BYTE *a2);
void *__fastcall sph_luffa384_addbits_and_close(int *a1, char a2, char a3, _BYTE *a4);
void *__fastcall sph_luffa512_init(int a1);
unsigned int __fastcall sph_luffa512(unsigned int a1, char *a2, size_t a3);
void *__fastcall sph_luffa512_close(int *a1, _BYTE *a2);
void *__fastcall sph_luffa512_addbits_and_close(int *a1, char a2, char a3, _BYTE *a4);
_WORD *__fastcall sub_167388(_WORD *result, __int16 a2);
_DWORD *__fastcall sub_1673B4(_DWORD *result, int a2);
int __fastcall sub_1673D0(int a1);
_DWORD *__fastcall sub_1673E8(_DWORD *result, int a2);
_DWORD *__fastcall sub_1674D4(_DWORD *result, int a2);
void *__fastcall sub_167660(_DWORD *a1);
void *__fastcall sub_16C794(_DWORD *a1);
_DWORD *__fastcall sub_171878(_DWORD *result, char *a2, size_t a3);
_DWORD *__fastcall sub_171978(_DWORD *result, char *a2, size_t a3);
_DWORD *__fastcall sub_171A78(_DWORD *a1, char a2, int a3, void *a4, unsigned int a5);
_DWORD *__fastcall sub_171C7C(_DWORD *a1, char a2, int a3, void *a4, unsigned int a5);
_DWORD *__fastcall sph_echo224_init(_DWORD *a1);
_DWORD *__fastcall sph_echo224(_DWORD *a1, char *a2, size_t a3);
_DWORD *__fastcall sph_echo224_close(_DWORD *a1, void *a2);
_DWORD *__fastcall sph_echo224_addbits_and_close(_DWORD *a1, char a2, int a3, void *a4);
_DWORD *__fastcall sph_echo256_init(_DWORD *a1);
_DWORD *__fastcall sph_echo256(_DWORD *a1, char *a2, size_t a3);
_DWORD *__fastcall sph_echo256_close(_DWORD *a1, void *a2);
_DWORD *__fastcall sph_echo256_addbits_and_close(_DWORD *a1, char a2, int a3, void *a4);
_DWORD *__fastcall sph_echo384_init(_DWORD *a1);
_DWORD *__fastcall sph_echo384(_DWORD *a1, char *a2, size_t a3);
_DWORD *__fastcall sph_echo384_close(_DWORD *a1, void *a2);
_DWORD *__fastcall sph_echo384_addbits_and_close(_DWORD *a1, char a2, int a3, void *a4);
_DWORD *__fastcall sph_echo512_init(_DWORD *a1);
_DWORD *__fastcall sph_echo512(_DWORD *a1, char *a2, size_t a3);
_DWORD *__fastcall sph_echo512_close(_DWORD *a1, void *a2);
_DWORD *__fastcall sph_echo512_addbits_and_close(_DWORD *a1, char a2, int a3, void *a4);
_BYTE *__fastcall sub_17209C(_BYTE *result, int a2, int a3, int a4);
int __fastcall sub_172158(int result, int a2, unsigned int a3, int a4);
__int64 __fastcall sub_172214(int a1);
_DWORD *__fastcall sub_172230(_DWORD *result, int a2);
void *__fastcall sub_1722BC(int a1, char *a2, size_t a3);
_DWORD *__fastcall sub_17738C(int a1, char a2, char a3, void *a4, size_t n);
_DWORD *__fastcall sub_179B38(_DWORD *result, int a2);
void *__fastcall sub_179BCC(int a1, char *a2, size_t a3);
_DWORD *__fastcall sub_183F74(int a1, char a2, char a3, void *a4, size_t n);
_DWORD *__fastcall sph_groestl224_init(_DWORD *a1);
void *__fastcall sph_groestl224(int a1, char *a2, size_t a3);
_DWORD *__fastcall sph_groestl224_close(int a1, void *a2);
_DWORD *__fastcall sph_groestl224_addbits_and_close(int a1, char a2, char a3, void *a4);
_DWORD *__fastcall sph_groestl256_init(_DWORD *a1);
void *__fastcall sph_groestl256(int a1, char *a2, size_t a3);
_DWORD *__fastcall sph_groestl256_close(int a1, void *a2);
_DWORD *__fastcall sph_groestl256_addbits_and_close(int a1, char a2, char a3, void *a4);
_DWORD *__fastcall sph_groestl384_init(_DWORD *a1);
void *__fastcall sph_groestl384(int a1, char *a2, size_t a3);
_DWORD *__fastcall sph_groestl384_close(int a1, void *a2);
_DWORD *__fastcall sph_groestl384_addbits_and_close(int a1, char a2, char a3, void *a4);
_DWORD *__fastcall sph_groestl512_init(_DWORD *a1);
void *__fastcall sph_groestl512(int a1, char *a2, size_t a3);
_DWORD *__fastcall sph_groestl512_close(int a1, void *a2);
_DWORD *__fastcall sph_groestl512_addbits_and_close(int a1, char a2, char a3, void *a4);
int __fastcall sub_18920C(int result, unsigned int a2);
int __fastcall sub_189250(int a1);
unsigned int __fastcall sub_189268(_DWORD *a1, int a2);
int __fastcall sub_18FC14(_DWORD *a1, int a2);
void *__fastcall sub_199024(_DWORD *a1, const void *a2);
_DWORD *__fastcall sub_199058(_DWORD *result, char *a2, unsigned int a3);
unsigned int __fastcall sub_1990F0(int a1, char a2, int a3, int a4, unsigned int a5);
void *__fastcall sub_199250(_DWORD *a1, const void *a2);
_DWORD *__fastcall sub_199298(_DWORD *result, char *a2, unsigned int a3);
int __fastcall sub_199370(int a1, char a2, int a3, int a4, unsigned int a5);
void *__fastcall sph_shavite224_init(_DWORD *a1);
_DWORD *__fastcall sph_shavite224(_DWORD *a1, char *a2, unsigned int a3);
void *__fastcall sph_shavite224_close(_DWORD *a1, int a2);
void *__fastcall sph_shavite224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
void *__fastcall sph_shavite256_init(_DWORD *a1);
_DWORD *__fastcall sph_shavite256(_DWORD *a1, char *a2, unsigned int a3);
void *__fastcall sph_shavite256_close(_DWORD *a1, int a2);
void *__fastcall sph_shavite256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
void *__fastcall sph_shavite384_init(_DWORD *a1);
_DWORD *__fastcall sph_shavite384(_DWORD *a1, char *a2, unsigned int a3);
void *__fastcall sph_shavite384_close(_DWORD *a1, int a2);
void *__fastcall sph_shavite384_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
void *__fastcall sph_shavite512_init(_DWORD *a1);
_DWORD *__fastcall sph_shavite512(_DWORD *a1, char *a2, unsigned int a3);
void *__fastcall sph_shavite512_close(_DWORD *a1, int a2);
void *__fastcall sph_shavite512_addbits_and_close(_DWORD *a1, char a2, int a3, int a4);
__int64 *__fastcall sub_1997D0(int a1, int a2);
int __fastcall blake2b_init(int a1, unsigned int a2, int a3, unsigned int a4);
__int64 *__fastcall blake2b_update(__int64 *result, int a2, unsigned int a3);
__int64 *__fastcall blake2b_final(int a1, int a2);
int __fastcall blake2b(_DWORD *a1, int a2, unsigned int a3);
void *__fastcall visited_init(_DWORD *a1, unsigned int a2);
void __fastcall visited_exit(void **a1);
void **__fastcall visited_clear(void **result);
int __fastcall visited_set(_DWORD *a1, unsigned int a2);
int __fastcall visited_reset(_DWORD *a1, unsigned int a2);
int __fastcall visited_test(_DWORD *a1, unsigned int a2);
int __fastcall visited_block(_DWORD *a1, unsigned int a2);
_DWORD *__fastcall new_bitmap(int a1);
void __fastcall free_bitmap(void (__fastcall **a1)(_DWORD));
unsigned int __fastcall sub_19AD10(int a1, unsigned int a2);
int __fastcall sub_19AD38(__int64 *a1);
int __fastcall le256_target_to_double_diff_base(__int64 *a1);
void *__fastcall diff_to_le256_target_base(void *a1);
int __fastcall le256_target_to_diff_base(int a1);
int __fastcall sub_19B26C(int a1);
int __fastcall be256_target_to_double_diff_base(int a1);
void *__fastcall diff_to_be256_target_base(void *a1);
int __fastcall be256_target_to_diff_base(int a1);
int __fastcall sub_19B7F8(int result, unsigned int a2);
int __fastcall sub_19B83C(int a1);
void *__fastcall sub_19B854(int a1, const void *a2);
int __fastcall sub_19B87C(int result, char *a2, size_t a3);
int __fastcall sub_19F464(_DWORD *a1, char a2, char a3, int a4, unsigned int a5);
void *__fastcall sph_cubehash224_init(int a1);
int __fastcall sph_cubehash224(int a1, char *a2, size_t a3);
void *__fastcall sph_cubehash224_close(_DWORD *a1, int a2);
void *__fastcall sph_cubehash224_addbits_and_close(_DWORD *a1, char a2, char a3, int a4);
void *__fastcall sph_cubehash256_init(int a1);
int __fastcall sph_cubehash256(int a1, char *a2, size_t a3);
void *__fastcall sph_cubehash256_close(_DWORD *a1, int a2);
void *__fastcall sph_cubehash256_addbits_and_close(_DWORD *a1, char a2, char a3, int a4);
void *__fastcall sph_cubehash384_init(int a1);
int __fastcall sph_cubehash384(int a1, char *a2, size_t a3);
void *__fastcall sph_cubehash384_close(_DWORD *a1, int a2);
void *__fastcall sph_cubehash384_addbits_and_close(_DWORD *a1, char a2, char a3, int a4);
void *__fastcall sph_cubehash512_init(int a1);
int __fastcall sph_cubehash512(int a1, char *a2, size_t a3);
void *__fastcall sph_cubehash512_close(_DWORD *a1, int a2);
void *__fastcall sph_cubehash512_addbits_and_close(_DWORD *a1, char a2, char a3, int a4);
int __fastcall sub_1A363C(unsigned int a1, unsigned int a2);
int __fastcall sub_1A3658(int a1, unsigned int a2);
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2); // idb
int __fastcall sub_1A38EC(int a1, unsigned int a2);
int __fastcall sub_1A3C0C(__int64 a1);
int __fastcall sub_1A3C1C(__int64 a1);
int __fastcall sub_1A3E08(__int64 a1);
int __fastcall sub_1A3E94(unsigned __int64 a1, unsigned __int64 a2);
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
void __fastcall init(int argc, char **argv, char **envp);
int _libc_csu_fini(); // weak
int __fastcall sub_1A4070(_DWORD, _DWORD); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

Elf32_Sym stru_1869C = { 27149u, 1002989u, 22u, 18u, 0u, 13u }; // weak
__int16 word_1FF00 = 3; // weak
__int16 word_1FFFE = 2; // weak
Elf32_Rel stru_201FC = { 2016560u, 188693u }; // weak
_UNKNOWN loc_70800; // weak
_UNKNOWN loc_E1000; // weak
_UNKNOWN loc_FE502; // weak
_UNKNOWN loc_1098E0; // weak
_UNKNOWN loc_1098E4; // weak
_UNKNOWN loc_1098E8; // weak
_UNKNOWN loc_1098EC; // weak
_UNKNOWN loc_1098F0; // weak
_UNKNOWN loc_1098F4; // weak
_UNKNOWN loc_1098F8; // weak
_UNKNOWN loc_1098FA; // weak
_UNKNOWN loc_109900; // weak
_UNKNOWN loc_109904; // weak
_UNKNOWN loc_109908; // weak
_UNKNOWN loc_10990C; // weak
_UNKNOWN loc_109910; // weak
_UNKNOWN loc_109914; // weak
_UNKNOWN loc_109918; // weak
_UNKNOWN loc_10991C; // weak
_UNKNOWN loc_112928; // weak
_UNKNOWN loc_112930; // weak
_UNKNOWN loc_112938; // weak
_UNKNOWN loc_113968; // weak
_UNKNOWN loc_113970; // weak
_UNKNOWN loc_113978; // weak
_UNKNOWN loc_114688; // weak
_UNKNOWN loc_114690; // weak
_UNKNOWN loc_114698; // weak
_UNKNOWN loc_16E360; // weak
_UNKNOWN loc_17D780; // weak
_UNKNOWN loc_1A36A0; // weak
_UNKNOWN unk_1ACFFF; // weak
unsigned __int8 all_algo_system_info[612] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  112u,
  23u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  40u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  80u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  112u,
  23u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  40u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  80u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  112u,
  23u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  20u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  85u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  72u,
  0u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  3u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  112u,
  23u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  40u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  80u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  112u,
  23u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  40u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  80u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  16u,
  39u,
  0u,
  0u,
  5u,
  0u,
  0u,
  0u,
  1u,
  0u,
  113u,
  0u,
  1u,
  0u,
  0u,
  0u,
  176u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  176u,
  4u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  112u,
  23u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  20u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  80u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  55u,
  0u,
  0u,
  0u,
  136u,
  19u,
  0u,
  0u,
  152u,
  58u,
  0u,
  0u,
  6u,
  0u,
  0u,
  0u,
  1u,
  0u,
  115u,
  0u,
  1u,
  0u,
  0u,
  0u,
  220u,
  5u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  64u,
  6u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  112u,
  23u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  20u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  75u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  60u,
  0u,
  0u,
  0u,
  136u,
  19u,
  0u,
  0u,
  152u,
  58u,
  0u,
  0u,
  7u,
  0u,
  0u,
  0u,
  1u,
  0u,
  113u,
  0u,
  1u,
  0u,
  0u,
  0u,
  236u,
  4u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  155u,
  5u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  112u,
  23u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  20u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  75u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  60u,
  0u,
  0u,
  0u,
  136u,
  19u,
  0u,
  0u,
  152u,
  58u,
  0u,
  0u,
  10u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  255u,
  255u,
  255u,
  127u,
  255u,
  255u,
  255u,
  127u,
  3u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
char byte_1B4D34[4] = { '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_1B721C[4] = { 700, 820, 750, 830 }; // weak
_UNKNOWN unk_1B725C; // weak
_DWORD dword_1B80C4[4] = { 700, 820, 750, 830 }; // weak
_UNKNOWN unk_1B8108; // weak
_UNKNOWN unk_1C3D88; // weak
int dword_1C7E68[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char aIn[3] = "in"; // weak
char a01[3] = "01"; // weak
char aPqt[4] = "PQT"; // weak
_QWORD qword_1CB328[2048] =
{
  1073739904LL,
  1082130304LL,
  1090514816LL,
  1098906752LL,
  1107293056LL,
  1115684224LL,
  1124070016LL,
  1132461952LL,
  1140849536LL,
  1149232768LL,
  1157627776LL,
  1166013824LL,
  1174404736LL,
  1182786944LL,
  1191180416LL,
  1199568512LL,
  1207958912LL,
  1216345216LL,
  1224732032LL,
  1233124736LL,
  1241513344LL,
  1249902464LL,
  1258290304LL,
  1266673792LL,
  1275067264LL,
  1283453312LL,
  1291844992LL,
  1300234112LL,
  1308619904LL,
  1317010048LL,
  1325397376LL,
  1333787776LL,
  1342176128LL,
  1350561664LL,
  1358954368LL,
  1367339392LL,
  1375731584LL,
  1384118144LL,
  1392507008LL,
  1400897408LL,
  1409284736LL,
  1417673344LL,
  1426062464LL,
  1434451072LL,
  1442839168LL,
  1451229056LL,
  1459615616LL,
  1468006016LL,
  1476394112LL,
  1484782976LL,
  1493171584LL,
  1501559168LL,
  1509948032LL,
  1518337664LL,
  1526726528LL,
  1535114624LL,
  1543503488LL,
  1551892096LL,
  1560278656LL,
  1568669056LL,
  1577056384LL,
  1585446272LL,
  1593831296LL,
  1602219392LL,
  1610610304LL,
  1619000192LL,
  1627386752LL,
  1635773824LL,
  1644164224LL,
  1652555648LL,
  1660943488LL,
  1669332608LL,
  1677721216LL,
  1686109312LL,
  1694497664LL,
  1702886272LL,
  1711274624LL,
  1719661184LL,
  1728047744LL,
  1736434816LL,
  1744829056LL,
  1753218944LL,
  1761606272LL,
  1769995904LL,
  1778382464LL,
  1786772864LL,
  1795157888LL,
  1803550592LL,
  1811937664LL,
  1820327552LL,
  1828711552LL,
  1837102976LL,
  1845488768LL,
  1853879936LL,
  1862269312LL,
  1870656896LL,
  1879048064LL,
  1887431552LL,
  1895825024LL,
  1904212096LL,
  1912601216LL,
  1920988544LL,
  1929379456LL,
  1937765504LL,
  1946156672LL,
  1954543232LL,
  1962932096LL,
  1971321728LL,
  1979707264LL,
  1988093056LL,
  1996487552LL,
  2004874624LL,
  2013262208LL,
  2021653888LL,
  2030039936LL,
  2038430848LL,
  2046819968LL,
  2055208576LL,
  2063596672LL,
  2071981952LL,
  2080373632LL,
  2088762752LL,
  2097149056LL,
  2105539712LL,
  2113928576LL,
  2122315136LL,
  2130700672LL,
  2139092608LL,
  2147483264LL,
  2155872128LL,
  2164257664LL,
  2172642176LL,
  2181035392LL,
  2189426048LL,
  2197814912LL,
  2206203008LL,
  2214587264LL,
  2222979712LL,
  2231367808LL,
  2239758208LL,
  2248145024LL,
  2256527744LL,
  2264922752LL,
  2273312128LL,
  2281701248LL,
  2290086272LL,
  2298476672LL,
  2306867072LL,
  2315251072LL,
  2323639168LL,
  2332032128LL,
  2340420224LL,
  2348808064LL,
  2357196416LL,
  2365580416LL,
  2373966976LL,
  2382363008LL,
  2390748544LL,
  2399139968LL,
  2407530368LL,
  2415918976LL,
  2424307328LL,
  2432695424LL,
  2441084288LL,
  2449472384LL,
  2457861248LL,
  2466247808LL,
  2474637184LL,
  2483026816LL,
  2491414144LL,
  2499803776LL,
  2508191872LL,
  2516582272LL,
  2524970368LL,
  2533359232LL,
  2541743488LL,
  2550134144LL,
  2558525056LL,
  2566913408LL,
  2575301504LL,
  2583686528LL,
  2592073856LL,
  2600467328LL,
  2608856192LL,
  2617240448LL,
  2625631616LL,
  2634022016LL,
  2642407552LL,
  2650796416LL,
  2659188352LL,
  2667574912LL,
  2675965312LL,
  2684352896LL,
  2692738688LL,
  2701130624LL,
  2709518464LL,
  2717907328LL,
  2726293376LL,
  2734685056LL,
  2743073152LL,
  2751462016LL,
  2759851648LL,
  2768232832LL,
  2776625536LL,
  2785017728LL,
  2793401984LL,
  2801794432LL,
  2810182016LL,
  2818571648LL,
  2826959488LL,
  2835349376LL,
  2843734144LL,
  2852121472LL,
  2860514432LL,
  2868900992LL,
  2877286784LL,
  2885676928LL,
  2894069632LL,
  2902451584LL,
  2910843008LL,
  2919234688LL,
  2927622784LL,
  2936011648LL,
  2944400768LL,
  2952789376LL,
  2961177728LL,
  2969565568LL,
  2977951616LL,
  2986338944LL,
  2994731392LL,
  3003120256LL,
  3011508352LL,
  3019895936LL,
  3028287104LL,
  3036675968LL,
  3045063808LL,
  3053452928LL,
  3061837696LL,
  3070228352LL,
  3078615424LL,
  3087003776LL,
  3095394944LL,
  3103782272LL,
  3112173184LL,
  3120562048LL,
  3128944768LL,
  3137339264LL,
  3145725056LL,
  3154109312LL,
  3162505088LL,
  3170893184LL,
  3179280256LL,
  3187669376LL,
  3196056704LL,
  3204445568LL,
  3212836736LL,
  3221224064LL,
  3229612928LL,
  3238002304LL,
  3246391168LL,
  3254778496LL,
  3263165824LL,
  3271556224LL,
  3279944576LL,
  3288332416LL,
  3296719232LL,
  3305110912LL,
  3313500032LL,
  3321887104LL,
  3330273152LL,
  3338658944LL,
  3347053184LL,
  3355440512LL,
  3363827072LL,
  3372220288LL,
  3380608384LL,
  3388997504LL,
  3397384576LL,
  3405774208LL,
  3414163072LL,
  3422551936LL,
  3430937984LL,
  3439328384LL,
  3447714176LL,
  3456104576LL,
  3464493952LL,
  3472883584LL,
  3481268864LL,
  3489655168LL,
  3498048896LL,
  3506434432LL,
  3514826368LL,
  3523213952LL,
  3531603584LL,
  3539987072LL,
  3548380288LL,
  3556763264LL,
  3565157248LL,
  3573545344LL,
  3581934464LL,
  3590324096LL,
  3598712704LL,
  3607098752LL,
  3615488384LL,
  3623877248LL,
  3632265856LL,
  3640646528LL,
  3649043584LL,
  3657430144LL,
  3665821568LL,
  3674207872LL,
  3682597504LL,
  3690984832LL,
  3699367808LL,
  3707764352LL,
  3716152448LL,
  3724541056LL,
  3732925568LL,
  3741318016LL,
  3749706368LL,
  3758091136LL,
  3766481536LL,
  3774872704LL,
  3783260032LL,
  3791650432LL,
  3800036224LL,
  3808427648LL,
  3816815488LL,
  3825204608LL,
  3833592704LL,
  3841981568LL,
  3850370432LL,
  3858755968LL,
  3867147904LL,
  3875536256LL,
  3883920512LL,
  3892313728LL,
  3900702592LL,
  3909087872LL,
  3917478784LL,
  3925868416LL,
  3934256512LL,
  3942645376LL,
  3951032192LL,
  3959422336LL,
  3967809152LL,
  3976200064LL,
  3984588416LL,
  3992974976LL,
  4001363584LL,
  4009751168LL,
  4018141312LL,
  4026530432LL,
  4034911616LL,
  4043308928LL,
  4051695488LL,
  4060084352LL,
  4068472448LL,
  4076862848LL,
  4085249408LL,
  4093640576LL,
  4102028416LL,
  4110413696LL,
  4118805632LL,
  4127194496LL,
  4135583104LL,
  4143971968LL,
  4152360832LL,
  4160746112LL,
  4169135744LL,
  4177525888LL,
  4185912704LL,
  4194303616LL,
  4202691968LL,
  4211076736LL,
  4219463552LL,
  4227855488LL,
  4236246656LL,
  4244633728LL,
  4253022848LL,
  4261412224LL,
  4269799808LL,
  4278184832LL,
  4286578048LL,
  4294962304LL,
  4303349632LL,
  4311743104LL,
  4320130432LL,
  4328521088LL,
  4336909184LL,
  4345295488LL,
  4353687424LL,
  4362073472LL,
  4370458496LL,
  4378852736LL,
  4387238528LL,
  4395630208LL,
  4404019072LL,
  4412407424LL,
  4420790656LL,
  4429182848LL,
  4437571456LL,
  4445962112LL,
  4454344064LL,
  4462738048LL,
  4471119232LL,
  4479516544LL,
  4487904128LL,
  4496289664LL,
  4504682368LL,
  4513068416LL,
  4521459584LL,
  4529846144LL,
  4538232704LL,
  4546619776LL,
  4555010176LL,
  4563402112LL,
  4571790208LL,
  4580174464LL,
  4588567936LL,
  4596957056LL,
  4605344896LL,
  4613734016LL,
  4622119808LL,
  4630511488LL,
  4638898816LL,
  4647287936LL,
  4655675264LL,
  4664065664LL,
  4672451968LL,
  4680842624LL,
  4689231488LL,
  4697620352LL,
  4706007424LL,
  4714397056LL,
  4722786176LL,
  4731173248LL,
  4739562368LL,
  4747951744LL,
  4756340608LL,
  4764727936LL,
  4773114496LL,
  4781504384LL,
  4789894784LL,
  4798283648LL,
  4806667648LL,
  4815059584LL,
  4823449472LL,
  4831835776LL,
  4840226176LL,
  4848612224LL,
  4857003392LL,
  4865391488LL,
  4873780096LL,
  4882169728LL,
  4890557312LL,
  4898946944LL,
  4907333248LL,
  4915722368LL,
  4924110976LL,
  4932499328LL,
  4940889728LL,
  4949276032LL,
  4957666432LL,
  4966054784LL,
  4974438016LL,
  4982831488LL,
  4991221376LL,
  4999607168LL,
  5007998848LL,
  5016386432LL,
  5024763776LL,
  5033164672LL,
  5041544576LL,
  5049941888LL,
  5058329728LL,
  5066717056LL,
  5075107456LL,
  5083494272LL,
  5091883904LL,
  5100273536LL,
  5108662144LL,
  5117048192LL,
  5125436032LL,
  5133827456LL,
  5142215296LL,
  5150605184LL,
  5158993024LL,
  5167382144LL,
  5175769472LL,
  5184157568LL,
  5192543872LL,
  5200936064LL,
  5209324928LL,
  5217711232LL,
  5226102656LL,
  5234490496LL,
  5242877312LL,
  5251263872LL,
  5259654016LL,
  5268040832LL,
  5276434304LL,
  5284819328LL,
  5293209728LL,
  5301598592LL,
  5309986688LL,
  5318374784LL,
  5326764416LL,
  5335151488LL,
  5343542144LL,
  5351929472LL,
  5360319872LL,
  5368706944LL,
  5377096576LL,
  5385484928LL,
  5393871232LL,
  5402263424LL,
  5410650496LL,
  5419040384LL,
  5427426944LL,
  5435816576LL,
  5444205952LL,
  5452594816LL,
  5460981376LL,
  5469367936LL,
  5477760896LL,
  5486148736LL,
  5494536832LL,
  5502925952LL,
  5511315328LL,
  5519703424LL,
  5528089984LL,
  5536481152LL,
  5544869504LL,
  5553256064LL,
  5561645696LL,
  5570032768LL,
  5578423936LL,
  5586811264LL,
  5595193216LL,
  5603585408LL,
  5611972736LL,
  5620366208LL,
  5628750464LL,
  5637143936LL,
  5645528192LL,
  5653921408LL,
  5662310272LL,
  5670694784LL,
  5679082624LL,
  5687474048LL,
  5695864448LL,
  5704251008LL,
  5712641408LL,
  5721030272LL,
  5729416832LL,
  5737806208LL,
  5746194304LL,
  5754583936LL,
  5762969984LL,
  5771358592LL,
  5779748224LL,
  5788137856LL,
  5796527488LL,
  5804911232LL,
  5813300608LL,
  5821692544LL,
  5830082176LL,
  5838468992LL,
  5846855552LL,
  5855247488LL,
  5863636096LL,
  5872024448LL,
  5880411008LL,
  5888799872LL,
  5897186432LL,
  5905576832LL,
  5913966976LL,
  5922352768LL,
  5930744704LL,
  5939132288LL,
  5947522432LL,
  5955911296LL,
  5964299392LL,
  5972688256LL,
  5981074304LL,
  5989465472LL,
  5997851008LL,
  6006241408LL,
  6014627968LL,
  6023015552LL,
  6031408256LL,
  6039796096LL,
  6048185216LL,
  6056574848LL,
  6064963456LL,
  6073351808LL,
  6081736064LL,
  6090128768LL,
  6098517632LL,
  6106906496LL,
  6115289216LL,
  6123680896LL,
  6132070016LL,
  6140459648LL,
  6148849024LL,
  6157237376LL,
  6165624704LL,
  6174009728LL,
  6182403712LL,
  6190792064LL,
  6199176064LL,
  6207569792LL,
  6215952256LL,
  6224345216LL,
  6232732544LL,
  6241124224LL,
  6249510272LL,
  6257899136LL,
  6266287744LL,
  6274676864LL,
  6283065728LL,
  6291454336LL,
  6299843456LL,
  6308232064LL,
  6316620928LL,
  6325006208LL,
  6333395584LL,
  6341784704LL,
  6350174848LL,
  6358562176LL,
  6366951296LL,
  6375337856LL,
  6383729536LL,
  6392119168LL,
  6400504192LL,
  6408895616LL,
  6417283456LL,
  6425673344LL,
  6434059136LL,
  6442444672LL,
  6450837376LL,
  6459223424LL,
  6467613056LL,
  6476004224LL,
  6484393088LL,
  6492781952LL,
  6501170048LL,
  6509555072LL,
  6517947008LL,
  6526336384LL,
  6534725504LL,
  6543112832LL,
  6551500672LL,
  6559888768LL,
  6568278656LL,
  6576662912LL,
  6585055616LL,
  6593443456LL,
  6601834112LL,
  6610219648LL,
  6618610304LL,
  6626999168LL,
  6635385472LL,
  6643777408LL,
  6652164224LL,
  6660552832LL,
  6668941952LL,
  6677330048LL,
  6685719424LL,
  6694107776LL,
  6702493568LL,
  6710882176LL,
  6719274112LL,
  6727662976LL,
  6736052096LL,
  6744437632LL,
  6752825984LL,
  6761213824LL,
  6769604224LL,
  6777993856LL,
  6786383488LL,
  6794770816LL,
  6803158144LL,
  6811549312LL,
  6819937664LL,
  6828326528LL,
  6836706176LL,
  6845101696LL,
  6853491328LL,
  6861880448LL,
  6870269312LL,
  6878655104LL,
  6887046272LL,
  6895433344LL,
  6903822208LL,
  6912212864LL,
  6920596864LL,
  6928988288LL,
  6937377152LL,
  6945764992LL,
  6954149248LL,
  6962544256LL,
  6970928768LL,
  6979317376LL,
  6987709312LL,
  6996093824LL,
  7004487296LL,
  7012875392LL,
  7021258624LL,
  7029652352LL,
  7038038912LL,
  7046427776LL,
  7054818944LL,
  7063207808LL,
  7071595136LL,
  7079980928LL,
  7088372608LL,
  7096759424LL,
  7105149824LL,
  7113536896LL,
  7121928064LL,
  7130315392LL,
  7138699648LL,
  7147092352LL,
  7155479168LL,
  7163865728LL,
  7172249984LL,
  7180648064LL,
  7189036672LL,
  7197424768LL,
  7205810816LL,
  7214196608LL,
  7222589824LL,
  7230975104LL,
  7239367552LL,
  7247755904LL,
  7256145536LL,
  7264533376LL,
  7272921472LL,
  7281308032LL,
  7289694848LL,
  7298088832LL,
  7306471808LL,
  7314864512LL,
  7323253888LL,
  7331643008LL,
  7340029568LL,
  7348419712LL,
  7356808832LL,
  7365196672LL,
  7373585792LL,
  7381973888LL,
  7390362752LL,
  7398750592LL,
  7407138944LL,
  7415528576LL,
  7423915648LL,
  7432302208LL,
  7440690304LL,
  7449080192LL,
  7457472128LL,
  7465860992LL,
  7474249088LL,
  7482635648LL,
  7491023744LL,
  7499412608LL,
  7507803008LL,
  7516192384LL,
  7524579968LL,
  7532967296LL,
  7541358464LL,
  7549745792LL,
  7558134656LL,
  7566524032LL,
  7574912896LL,
  7583300992LL,
  7591690112LL,
  7600075136LL,
  7608466816LL,
  7616854912LL,
  7625244544LL,
  7633629824LL,
  7642020992LL,
  7650410368LL,
  7658794112LL,
  7667187328LL,
  7675574912LL,
  7683961984LL,
  7692349568LL,
  7700739712LL,
  7709130368LL,
  7717519232LL,
  7725905536LL,
  7734295424LL,
  7742683264LL,
  7751069056LL,
  7759457408LL,
  7767849088LL,
  7776238208LL,
  7784626816LL,
  7793014912LL,
  7801405312LL,
  7809792128LL,
  7818179968LL,
  7826571136LL,
  7834957184LL,
  7843347328LL,
  7851732352LL,
  7860124544LL,
  7868512384LL,
  7876902016LL,
  7885287808LL,
  7893679744LL,
  7902067072LL,
  7910455936LL,
  7918844288LL,
  7927230848LL,
  7935622784LL,
  7944009344LL,
  7952400256LL,
  7960786048LL,
  7969176704LL,
  7977565312LL,
  7985953408LL,
  7994339968LL,
  8002730368LL,
  8011119488LL,
  8019508096LL,
  8027896192LL,
  8036285056LL,
  8044674688LL,
  8053062272LL,
  8061448832LL,
  8069838464LL,
  8078227328LL,
  8086616704LL,
  8095006592LL,
  8103393664LL,
  8111783552LL,
  8120171392LL,
  8128560256LL,
  8136949376LL,
  8145336704LL,
  8153726848LL,
  8162114944LL,
  8170503296LL,
  8178891904LL,
  8187280768LL,
  8195669632LL,
  8204058496LL,
  8212444544LL,
  8220834176LL,
  8229222272LL,
  8237612672LL,
  8246000768LL,
  8254389376LL,
  8262775168LL,
  8271167104LL,
  8279553664LL,
  8287944064LL,
  8296333184LL,
  8304715136LL,
  8313108352LL,
  8321497984LL,
  8329885568LL,
  8338274432LL,
  8346663296LL,
  8355052928LL,
  8363441536LL,
  8371828352LL,
  8380217984LL,
  8388606592LL,
  8396996224LL,
  8405384576LL,
  8413772672LL,
  8422161536LL,
  8430549376LL,
  8438939008LL,
  8447326592LL,
  8455715456LL,
  8464104832LL,
  8472492928LL,
  8480882048LL,
  8489270656LL,
  8497659776LL,
  8506045312LL,
  8514434944LL,
  8522823808LL,
  8531208832LL,
  8539602304LL,
  8547990656LL,
  8556378752LL,
  8564768384LL,
  8573154176LL,
  8581542784LL,
  8589933952LL,
  8598322816LL,
  8606705024LL,
  8615099264LL,
  8623487872LL,
  8631876992LL,
  8640264064LL,
  8648653952LL,
  8657040256LL,
  8665430656LL,
  8673820544LL,
  8682209152LL,
  8690592128LL,
  8698977152LL,
  8707374464LL,
  8715763328LL,
  8724151424LL,
  8732540032LL,
  8740928384LL,
  8749315712LL,
  8757704576LL,
  8766089344LL,
  8774480768LL,
  8782871936LL,
  8791260032LL,
  8799645824LL,
  8808034432LL,
  8816426368LL,
  8824812928LL,
  8833199488LL,
  8841591424LL,
  8849976448LL,
  8858366336LL,
  8866757248LL,
  8875147136LL,
  8883532928LL,
  8891923328LL,
  8900306816LL,
  8908700288LL,
  8917088384LL,
  8925478784LL,
  8933867392LL,
  8942250368LL,
  8950644608LL,
  8959032704LL,
  8967420544LL,
  8975809664LL,
  8984197504LL,
  8992584064LL,
  9000976256LL,
  9009362048LL,
  9017752448LL,
  9026141312LL,
  9034530688LL,
  9042917504LL,
  9051307904LL,
  9059694208LL,
  9068084864LL,
  9076471424LL,
  9084861824LL,
  9093250688LL,
  9101638528LL,
  9110027648LL,
  9118416512LL,
  9126803584LL,
  9135188096LL,
  9143581312LL,
  9151969664LL,
  9160356224LL,
  9168747136LL,
  9177134464LL,
  9185525632LL,
  9193910144LL,
  9202302848LL,
  9210690688LL,
  9219079552LL,
  9227465344LL,
  9235854464LL,
  9244244864LL,
  9252633472LL,
  9261021824LL,
  9269411456LL,
  9277799296LL,
  9286188928LL,
  9294574208LL,
  9302965888LL,
  9311351936LL,
  9319740032LL,
  9328131968LL,
  9336516736LL,
  9344907392LL,
  9353296768LL,
  9361685888LL,
  9370074752LL,
  9378463616LL,
  9386849408LL,
  9395239808LL,
  9403629184LL,
  9412016512LL,
  9420405376LL,
  9428795008LL,
  9437181568LL,
  9445570688LL,
  9453960832LL,
  9462346624LL,
  9470738048LL,
  9479121536LL,
  9487515008LL,
  9495903616LL,
  9504289664LL,
  9512678528LL,
  9521067904LL,
  9529456256LL,
  9537843584LL,
  9546233728LL,
  9554621312LL,
  9563011456LL,
  9571398784LL,
  9579788672LL,
  9588178304LL,
  9596567168LL,
  9604954496LL,
  9613343104LL,
  9621732992LL,
  9630121856LL,
  9638508416LL,
  9646898816LL,
  9655283584LL,
  9663675776LL,
  9672061312LL,
  9680449664LL,
  9688840064LL,
  9697230464LL,
  9705617536LL,
  9714003584LL,
  9722393984LL,
  9730772608LL,
  9739172224LL,
  9747561088LL,
  9755945344LL,
  9764338816LL,
  9772726144LL,
  9781116544LL,
  9789503872LL,
  9797892992LL,
  9806282624LL,
  9814670464LL,
  9823056512LL,
  9831439232LL,
  9839833984LL,
  9848224384LL,
  9856613504LL,
  9865000576LL,
  9873391232LL,
  9881772416LL,
  9890162816LL,
  9898556288LL,
  9906940544LL,
  9915333248LL,
  9923721088LL,
  9932108672LL,
  9940496512LL,
  9948888448LL,
  9957276544LL,
  9965666176LL,
  9974048384LL,
  9982441088LL,
  9990830464LL,
  9999219584LL,
  10007602816LL,
  10015996544LL,
  10024385152LL,
  10032774016LL,
  10041163648LL,
  10049548928LL,
  10057940096LL,
  10066329472LL,
  10074717824LL,
  10083105152LL,
  10091495296LL,
  10099878784LL,
  10108272256LL,
  10116660608LL,
  10125049216LL,
  10133437312LL,
  10141825664LL,
  10150213504LL,
  10158601088LL,
  10166991232LL,
  10175378816LL,
  10183766144LL,
  10192157312LL,
  10200545408LL,
  10208935552LL,
  10217322112LL,
  10225712768LL,
  10234099328LL,
  10242489472LL,
  10250876032LL,
  10259264896LL,
  10267656064LL,
  10276042624LL,
  10284429184LL,
  10292820352LL,
  10301209472LL,
  10309598848LL,
  10317987712LL,
  10326375296LL,
  10334763392LL,
  10343153536LL,
  10351541632LL,
  10359930752LL,
  10368318592LL,
  10376707456LL,
  10385096576LL,
  10393484672LL,
  10401867136LL,
  10410262144LL,
  10418647424LL,
  10427039104LL,
  10435425664LL,
  10443810176LL,
  10452203648LL,
  10460589952LL,
  10468982144LL,
  10477369472LL,
  10485759104LL,
  10494147712LL,
  10502533504LL,
  10510923392LL,
  10519313536LL,
  10527702656LL,
  10536091264LL,
  10544478592LL,
  10552867712LL,
  10561255808LL,
  10569642368LL,
  10578032768LL,
  10586423168LL,
  10594805632LL,
  10603200128LL,
  10611588992LL,
  10619976064LL,
  10628361344LL,
  10636754048LL,
  10645143424LL,
  10653531776LL,
  10661920384LL,
  10670307968LL,
  10678696832LL,
  10687086464LL,
  10695475072LL,
  10703863168LL,
  10712246144LL,
  10720639616LL,
  10729026688LL,
  10737414784LL,
  10745806208LL,
  10754190976LL,
  10762581376LL,
  10770971264LL,
  10779356288LL,
  10787747456LL,
  10796135552LL,
  10804525184LL,
  10812915584LL,
  10821301888LL,
  10829692288LL,
  10838078336LL,
  10846469248LL,
  10854858368LL,
  10863247232LL,
  10871631488LL,
  10880023424LL,
  10888412032LL,
  10896799616LL,
  10905188992LL,
  10913574016LL,
  10921964672LL,
  10930352768LL,
  10938742912LL,
  10947132544LL,
  10955518592LL,
  10963909504LL,
  10972298368LL,
  10980687488LL,
  10989074816LL,
  10997462912LL,
  11005851776LL,
  11014241152LL,
  11022627712LL,
  11031017344LL,
  11039403904LL,
  11047793024LL,
  11056184704LL,
  11064570752LL,
  11072960896LL,
  11081343872LL,
  11089737856LL,
  11098128256LL,
  11106514816LL,
  11114904448LL,
  11123293568LL,
  11131680128LL,
  11140065152LL,
  11148458368LL,
  11156845696LL,
  11165236864LL,
  11173624192LL,
  11182013824LL,
  11190402688LL,
  11198790784LL,
  11207179136LL,
  11215568768LL,
  11223957376LL,
  11232345728LL,
  11240734592LL,
  11249122688LL,
  11257511296LL,
  11265899648LL,
  11274285952LL,
  11282675584LL,
  11291065472LL,
  11299452544LL,
  11307842432LL,
  11316231296LL,
  11324616832LL,
  11333009024LL,
  11341395584LL,
  11349782656LL,
  11358172288LL,
  11366560384LL,
  11374950016LL,
  11383339648LL,
  11391721856LL,
  11400117376LL,
  11408504192LL,
  11416893568LL,
  11425283456LL,
  11433671552LL,
  11442061184LL,
  11450444672LL,
  11458837888LL,
  11467226752LL,
  11475611776LL,
  11484003968LL,
  11492392064LL,
  11500780672LL,
  11509169024LL,
  11517550976LL,
  11525944448LL,
  11534335616LL,
  11542724224LL,
  11551111808LL,
  11559500672LL,
  11567890304LL,
  11576277376LL,
  11584667008LL,
  11593056128LL,
  11601443456LL,
  11609830016LL,
  11618221952LL,
  11626607488LL,
  11634995072LL,
  11643387776LL,
  11651775104LL,
  11660161664LL,
  11668552576LL,
  11676940928LL,
  11685330304LL,
  11693718656LL,
  11702106496LL,
  11710496128LL,
  11718882688LL,
  11727273088LL,
  11735660416LL,
  11744050048LL,
  11752437376LL,
  11760824704LL,
  11769216128LL,
  11777604736LL,
  11785991296LL,
  11794381952LL,
  11802770048LL,
  11811157888LL,
  11819548544LL,
  11827932544LL,
  11836324736LL,
  11844713344LL,
  11853100928LL,
  11861486464LL,
  11869879936LL,
  11878268032LL,
  11886656896LL,
  11895044992LL,
  11903433088LL,
  11911822976LL,
  11920210816LL,
  11928600448LL,
  11936987264LL,
  11945375872LL,
  11953761152LL,
  11962151296LL,
  11970543488LL,
  11978928512LL,
  11987320448LL,
  11995708288LL,
  12004095104LL,
  12012486272LL,
  12020875136LL,
  12029255552LL,
  12037652096LL,
  12046039168LL,
  12054429568LL,
  12062813824LL,
  12071206528LL,
  12079594624LL,
  12087983744LL,
  12096371072LL,
  12104759936LL,
  12113147264LL,
  12121534592LL,
  12129924992LL,
  12138314624LL,
  12146703232LL,
  12155091584LL,
  12163481216LL,
  12171864704LL,
  12180255872LL,
  12188643968LL,
  12197034112LL,
  12205424512LL,
  12213811328LL,
  12222199424LL,
  12230590336LL,
  12238977664LL,
  12247365248LL,
  12255755392LL,
  12264143488LL,
  12272531584LL,
  12280920448LL,
  12289309568LL,
  12297694592LL,
  12306086528LL,
  12314475392LL,
  12322865024LL,
  12331253632LL,
  12339640448LL,
  12348029312LL,
  12356418944LL,
  12364805248LL,
  12373196672LL,
  12381580928LL,
  12389969024LL,
  12398357632LL,
  12406750592LL,
  12415138432LL,
  12423527552LL,
  12431916416LL,
  12440304512LL,
  12448692352LL,
  12457081216LL,
  12465467776LL,
  12473859968LL,
  12482245504LL,
  12490636672LL,
  12499025536LL,
  12507411584LL,
  12515801728LL,
  12524190592LL,
  12532577152LL,
  12540966272LL,
  12549354368LL,
  12557743232LL,
  12566129536LL,
  12574523264LL,
  12582911872LL,
  12591299456LL,
  12599688064LL,
  12608074624LL,
  12616463488LL,
  12624845696LL,
  12633239936LL,
  12641631616LL,
  12650019968LL,
  12658407296LL,
  12666795136LL,
  12675183232LL,
  12683574656LL,
  12691960192LL,
  12700350592LL,
  12708740224LL,
  12717128576LL,
  12725515904LL,
  12733906816LL,
  12742295168LL,
  12750680192LL,
  12759071872LL,
  12767460736LL,
  12775848832LL,
  12784236928LL,
  12792626816LL,
  12801014656LL,
  12809404288LL,
  12817789312LL,
  12826181504LL,
  12834568832LL,
  12842954624LL,
  12851345792LL,
  12859732352LL,
  12868122496LL,
  12876512128LL,
  12884901248LL,
  12893289088LL,
  12901672832LL,
  12910067584LL,
  12918455168LL,
  12926842496LL,
  12935232896LL,
  12943620736LL,
  12952009856LL,
  12960396928LL,
  12968786816LL,
  12977176192LL,
  12985563776LL,
  12993951104LL,
  13002341504LL,
  13010730368LL,
  13019115392LL,
  13027506304LL,
  13035895168LL,
  13044272512LL,
  13052673152LL,
  13061062528LL,
  13069446272LL,
  13077838976LL,
  13086227072LL,
  13094613632LL,
  13103000192LL,
  13111393664LL,
  13119782528LL,
  13128157568LL,
  13136559232LL,
  13144945024LL,
  13153329536LL,
  13161724288LL,
  13170111872LL,
  13178502784LL,
  13186884736LL,
  13195279744LL,
  13203667072LL,
  13212057472LL,
  13220445824LL,
  13228832128LL,
  13237221248LL,
  13245610624LL,
  13254000512LL,
  13262388352LL,
  13270777472LL,
  13279166336LL,
  13287553408LL,
  13295943296LL,
  13304331904LL,
  13312719488LL,
  13321108096LL,
  13329494656LL,
  13337885824LL,
  13346274944LL,
  13354663808LL,
  13363051136LL,
  13371439232LL,
  13379825024LL,
  13388210816LL,
  13396605056LL,
  13404995456LL,
  13413380224LL,
  13421771392LL,
  13430159744LL,
  13438546048LL,
  13446937216LL,
  13455326848LL,
  13463708288LL,
  13472103808LL,
  13480492672LL,
  13488875648LL,
  13497269888LL,
  13505657728LL,
  13514045312LL,
  13522435712LL,
  13530824576LL,
  13539210112LL,
  13547599232LL,
  13555989376LL,
  13564379008LL,
  13572766336LL,
  13581154432LL,
  13589544832LL,
  13597932928LL,
  13606320512LL,
  13614710656LL,
  13623097472LL,
  13631477632LL,
  13639874944LL,
  13648264064LL,
  13656652928LL,
  13665041792LL,
  13673430656LL,
  13681818496LL,
  13690207616LL,
  13698595712LL,
  13706982272LL,
  13715373184LL,
  13723762048LL,
  13732150144LL,
  13740536704LL,
  13748926592LL,
  13757316224LL,
  13765700992LL,
  13774090112LL,
  13782477952LL,
  13790869376LL,
  13799259008LL,
  13807647872LL,
  13816036736LL,
  13824425344LL,
  13832814208LL,
  13841202304LL,
  13849591424LL,
  13857978752LL,
  13866368896LL,
  13874754688LL,
  13883145344LL,
  13891533184LL,
  13899919232LL,
  13908311168LL,
  13916692096LL,
  13925085056LL,
  13933473152LL,
  13941866368LL,
  13950253696LL,
  13958643584LL,
  13967032192LL,
  13975417216LL,
  13983807616LL,
  13992197504LL,
  14000582272LL,
  14008973696LL,
  14017363072LL,
  14025752192LL,
  14034137984LL,
  14042528384LL,
  14050918016LL,
  14059301504LL,
  14067691648LL,
  14076083584LL,
  14084470144LL,
  14092852352LL,
  14101249664LL,
  14109635968LL,
  14118024832LL,
  14126407552LL,
  14134804352LL,
  14143188608LL,
  14151577984LL,
  14159968384LL,
  14168357248LL,
  14176741504LL,
  14185127296LL,
  14193521024LL,
  14201911424LL,
  14210301824LL,
  14218685056LL,
  14227067264LL,
  14235467392LL,
  14243855488LL,
  14252243072LL,
  14260630144LL,
  14269021568LL,
  14277409408LL,
  14285799296LL,
  14294187904LL,
  14302571392LL,
  14310961792LL,
  14319353728LL,
  14327738752LL,
  14336130944LL,
  14344518784LL,
  14352906368LL,
  14361296512LL,
  14369685376LL,
  14378071424LL,
  14386462592LL,
  14394848128LL,
  14403230848LL,
  14411627392LL,
  14420013952LL,
  14428402304LL,
  14436793472LL,
  14445181568LL,
  14453569664LL,
  14461959808LL,
  14470347904LL,
  14478737024LL,
  14487122816LL,
  14495511424LL,
  14503901824LL,
  14512291712LL,
  14520677504LL,
  14529064832LL,
  14537456768LL,
  14545845632LL,
  14554234496LL,
  14562618496LL,
  14571011456LL,
  14579398784LL,
  14587789184LL,
  14596172672LL,
  14604564608LL,
  14612953984LL,
  14621341312LL,
  14629724288LL,
  14638120832LL,
  14646503296LL,
  14654897536LL,
  14663284864LL,
  14671675264LL,
  14680061056LL,
  14688447616LL,
  14696835968LL,
  14705228416LL,
  14713616768LL,
  14722003328LL,
  14730392192LL,
  14738784128LL,
  14747172736LL,
  14755561088LL,
  14763947648LL,
  14772336512LL,
  14780725376LL,
  14789110144LL,
  14797499776LL,
  14805892736LL,
  14814276992LL,
  14822670208LL,
  14831056256LL,
  14839444352LL,
  14847836032LL,
  14856222848LL,
  14864612992LL,
  14872997504LL,
  14881388672LL,
  14889775744LL,
  14898165376LL,
  14906553472LL,
  14914944896LL,
  14923329664LL,
  14931721856LL,
  14940109696LL,
  14948497024LL,
  14956887424LL,
  14965276544LL,
  14973663616LL,
  14982053248LL,
  14990439808LL,
  14998830976LL,
  15007216768LL,
  15015605888LL,
  15023995264LL,
  15032385152LL,
  15040768384LL,
  15049154944LL,
  15057549184LL,
  15065939072LL,
  15074328448LL,
  15082715008LL,
  15091104128LL,
  15099493504LL,
  15107879296LL,
  15116269184LL,
  15124659584LL,
  15133042304LL,
  15141431936LL,
  15149824384LL,
  15158214272LL,
  15166602368LL,
  15174991232LL,
  15183378304LL,
  15191760512LL,
  15200154496LL,
  15208542592LL,
  15216931712LL,
  15225323392LL,
  15233708416LL,
  15242098048LL,
  15250489216LL,
  15258875264LL,
  15267265408LL,
  15275654528LL,
  15284043136LL,
  15292431488LL,
  15300819584LL,
  15309208192LL,
  15317596544LL,
  15325986176LL,
  15334374784LL,
  15342763648LL,
  15351151744LL,
  15359540608LL,
  15367929728LL,
  15376318336LL,
  15384706432LL,
  15393092992LL,
  15401481856LL,
  15409869952LL,
  15418258816LL,
  15426649984LL,
  15435037568LL,
  15443425664LL,
  15451815296LL,
  15460203392LL,
  15468589184LL,
  15476979328LL,
  15485369216LL,
  15493755776LL,
  15502146944LL,
  15510534272LL,
  15518924416LL,
  15527311232LL,
  15535699072LL,
  15544089472LL,
  15552478336LL,
  15560866688LL,
  15569254528LL,
  15577642624LL,
  15586031488LL,
  15594419072LL,
  15602809472LL,
  15611199104LL,
  15619586432LL,
  15627975296LL,
  15636364928LL,
  15644753792LL,
  15653141888LL,
  15661529216LL,
  15669918848LL,
  15678305152LL,
  15686696576LL,
  15695083136LL,
  15703474048LL,
  15711861632LL,
  15720251264LL,
  15728636288LL,
  15737027456LL,
  15745417088LL,
  15753804928LL,
  15762194048LL,
  15770582656LL,
  15778971008LL,
  15787358336LL,
  15795747712LL,
  15804132224LL,
  15812523392LL,
  15820909696LL,
  15829300096LL,
  15837691264LL,
  15846071936LL,
  15854466944LL,
  15862855808LL,
  15871244672LL,
  15879634816LL,
  15888020608LL,
  15896409728LL,
  15904799104LL,
  15913185152LL,
  15921577088LL,
  15929966464LL,
  15938354816LL,
  15946743424LL,
  15955129472LL,
  15963519872LL,
  15971907968LL,
  15980296064LL,
  15988684928LL,
  15997073024LL,
  16005460864LL,
  16013851264LL,
  16022241152LL,
  16030629248LL,
  16039012736LL,
  16047406976LL,
  16055794816LL,
  16064181376LL,
  16072571264LL,
  16080957824LL,
  16089346688LL,
  16097737856LL,
  16106125184LL,
  16114514816LL,
  16122904192LL,
  16131292544LL,
  16139678848LL,
  16148066944LL,
  16156453504LL,
  16164839552LL,
  16173236096LL,
  16181623424LL,
  16190012032LL,
  16198401152LL,
  16206790528LL,
  16215177344LL,
  16223567744LL,
  16231956352LL,
  16240344704LL,
  16248731008LL,
  16257117824LL,
  16265504384LL,
  16273898624LL,
  16282281856LL,
  16290668672LL,
  16299064192LL,
  16307449216LL,
  16315842176LL,
  16324230016LL,
  16332613504LL,
  16341006464LL,
  16349394304LL,
  16357783168LL,
  16366172288LL,
  16374561664LL,
  16382951296LL,
  16391337856LL,
  16399726208LL,
  16408116352LL,
  16416505472LL,
  16424892032LL,
  16433282176LL,
  16441668224LL,
  16450058624LL,
  16458448768LL,
  16466836864LL,
  16475224448LL,
  16483613056LL,
  16492001408LL,
  16500391808LL,
  16508779648LL,
  16517166976LL,
  16525555328LL,
  16533944192LL,
  16542330752LL,
  16550719616LL,
  16559110528LL,
  16567497088LL,
  16575888512LL,
  16584274816LL,
  16592665472LL,
  16601051008LL,
  16609442944LL,
  16617832064LL,
  16626218624LL,
  16634607488LL,
  16642996096LL,
  16651385728LL,
  16659773824LL,
  16668163712LL,
  16676552576LL,
  16684938112LL,
  16693328768LL,
  16701718144LL,
  16710095488LL,
  16718492288LL,
  16726883968LL,
  16735272832LL,
  16743661184LL,
  16752049792LL,
  16760436608LL,
  16768827008LL,
  16777214336LL,
  16785599104LL,
  16793992832LL,
  16802381696LL,
  16810768768LL,
  16819151744LL,
  16827542656LL,
  16835934848LL,
  16844323712LL,
  16852711552LL,
  16861101952LL,
  16869489536LL,
  16877876864LL,
  16886265728LL,
  16894653056LL,
  16903044736LL,
  16911431296LL,
  16919821696LL,
  16928207488LL,
  16936592768LL,
  16944987776LL,
  16953375616LL,
  16961763968LL,
  16970152832LL,
  16978540928LL,
  16986929536LL,
  16995319168LL,
  17003704448LL,
  17012096896LL,
  17020481152LL,
  17028870784LL,
  17037262208LL,
  17045649536LL,
  17054039936LL,
  17062426496LL,
  17070814336LL,
  17079205504LL,
  17087592064LL,
  17095978112LL,
  17104369024LL,
  17112759424LL,
  17121147776LL,
  17129536384LL,
  17137926016LL,
  17146314368LL,
  17154700928LL,
  17163089792LL,
  17171480192LL,
  17179864192LL,
  17188256896LL,
  17196644992LL,
  17205033856LL,
  17213423488LL,
  17221811072LL,
  17230198912LL,
  17238588032LL,
  17246976896LL,
  17255360384LL,
  17263754624LL,
  17272143232LL,
  17280530048LL,
  17288918912LL,
  17297309312LL,
  17305696384LL,
  17314085504LL,
  17322475136LL,
  17330863744LL,
  17339252096LL,
  17347640192LL,
  17356026496LL,
  17364413824LL,
  17372796544LL,
  17381190016LL,
  17389583488LL,
  17397972608LL,
  17406360704LL,
  17414748544LL,
  17423135872LL,
  17431527296LL,
  17439915904LL,
  17448303232LL,
  17456691584LL,
  17465081728LL,
  17473468288LL,
  17481857408LL,
  17490247552LL,
  17498635904LL,
  17507022464LL,
  17515409024LL,
  17523801728LL,
  17532189824LL,
  17540577664LL,
  17548966016LL,
  17557353344LL,
  17565741184LL,
  17574131584LL,
  17582519168LL,
  17590907008LL,
  17599296128LL,
  17607687808LL,
  17616076672LL,
  17624455808LL,
  17632852352LL,
  17641238656LL,
  17649630848LL,
  17658018944LL,
  17666403968LL,
  17674794112LL,
  17683178368LL,
  17691573376LL,
  17699962496LL,
  17708350592LL,
  17716739968LL,
  17725126528LL,
  17733517184LL,
  17741898112LL,
  17750293888LL,
  17758673024LL,
  17767070336LL,
  17775458432LL,
  17783848832LL,
  17792236928LL,
  17800625536LL,
  17809012352LL,
  17817402752LL,
  17825785984LL,
  17834178944LL,
  17842563968LL,
  17850955648LL,
  17859344512LL,
  17867732864LL,
  17876119424LL,
  17884511872LL,
  17892900224LL,
  17901287296LL,
  17909677696LL,
  17918058112LL,
  17926451072LL,
  17934843776LL,
  17943230848LL,
  17951609216LL,
  17960008576LL,
  17968397696LL,
  17976784256LL,
  17985175424LL,
  17993564032LL,
  18001952128LL,
  18010339712LL,
  18018728576LL,
  18027116672LL,
  18035503232LL,
  18043894144LL,
  18052283264LL,
  18060672128LL,
  18069056384LL,
  18077449856LL,
  18085837184LL,
  18094225792LL,
  18102613376LL,
  18111004544LL,
  18119388544LL,
  18127781248LL,
  18136170368LL,
  18144558976LL,
  18152947328LL,
  18161336192LL,
  18169724288LL,
  18178108544LL,
  18186498944LL,
  18194886784LL,
  18203275648LL,
  18211666048LL,
  18220048768LL,
  18228444544LL,
  18236833408LL,
  18245220736LL
}; // weak
_QWORD qword_1CF328[2048] =
{
  16776896LL,
  16907456LL,
  17039296LL,
  17170112LL,
  17301056LL,
  17432512LL,
  17563072LL,
  17693888LL,
  17824192LL,
  17955904LL,
  18087488LL,
  18218176LL,
  18349504LL,
  18481088LL,
  18611392LL,
  18742336LL,
  18874304LL,
  19004224LL,
  19135936LL,
  19267264LL,
  19398208LL,
  19529408LL,
  19660096LL,
  19791424LL,
  19922752LL,
  20053952LL,
  20184896LL,
  20315968LL,
  20446912LL,
  20576576LL,
  20709184LL,
  20840384LL,
  20971072LL,
  21102272LL,
  21233216LL,
  21364544LL,
  21494848LL,
  21626816LL,
  21757376LL,
  21887552LL,
  22019392LL,
  22151104LL,
  22281536LL,
  22412224LL,
  22543936LL,
  22675264LL,
  22806464LL,
  22935872LL,
  23068096LL,
  23198272LL,
  23330752LL,
  23459008LL,
  23592512LL,
  23723968LL,
  23854912LL,
  23986112LL,
  24116672LL,
  24247616LL,
  24378688LL,
  24509504LL,
  24640832LL,
  24772544LL,
  24903488LL,
  25034432LL,
  25165376LL,
  25296704LL,
  25427392LL,
  25558592LL,
  25690048LL,
  25820096LL,
  25951936LL,
  26081728LL,
  26214208LL,
  26345024LL,
  26476096LL,
  26606656LL,
  26737472LL,
  26869184LL,
  26998208LL,
  27131584LL,
  27262528LL,
  27393728LL,
  27523904LL,
  27655744LL,
  27786688LL,
  27917888LL,
  28049344LL,
  28179904LL,
  28311488LL,
  28441792LL,
  28573504LL,
  28700864LL,
  28835648LL,
  28966208LL,
  29096768LL,
  29228608LL,
  29359808LL,
  29490752LL,
  29621824LL,
  29752256LL,
  29882816LL,
  30014912LL,
  30144448LL,
  30273728LL,
  30406976LL,
  30538432LL,
  30670784LL,
  30799936LL,
  30932672LL,
  31063744LL,
  31195072LL,
  31325248LL,
  31456192LL,
  31588288LL,
  31719232LL,
  31850432LL,
  31981504LL,
  32110784LL,
  32243392LL,
  32372672LL,
  32505664LL,
  32636608LL,
  32767808LL,
  32897344LL,
  33029824LL,
  33160768LL,
  33289664LL,
  33423296LL,
  33554368LL,
  33683648LL,
  33816512LL,
  33947456LL,
  34076992LL,
  34208704LL,
  34340032LL,
  34471744LL,
  34600256LL,
  34734016LL,
  34864576LL,
  34993984LL,
  35127104LL,
  35258176LL,
  35386688LL,
  35518528LL,
  35650624LL,
  35782336LL,
  35910976LL,
  36044608LL,
  36175808LL,
  36305728LL,
  36436672LL,
  36568384LL,
  36699968LL,
  36830656LL,
  36961984LL,
  37093312LL,
  37223488LL,
  37355072LL,
  37486528LL,
  37617472LL,
  37747904LL,
  37879232LL,
  38009792LL,
  38141888LL,
  38272448LL,
  38403392LL,
  38535104LL,
  38660672LL,
  38795584LL,
  38925632LL,
  39059264LL,
  39190336LL,
  39320768LL,
  39452096LL,
  39581632LL,
  39713984LL,
  39844928LL,
  39974848LL,
  40107968LL,
  40238144LL,
  40367168LL,
  40500032LL,
  40631744LL,
  40762816LL,
  40894144LL,
  41023552LL,
  41155904LL,
  41286208LL,
  41418304LL,
  41547712LL,
  41680448LL,
  41811904LL,
  41942848LL,
  42073792LL,
  42204992LL,
  42334912LL,
  42467008LL,
  42597824LL,
  42729152LL,
  42860096LL,
  42991552LL,
  43122368LL,
  43253696LL,
  43382848LL,
  43515712LL,
  43646912LL,
  43777088LL,
  43907648LL,
  44039104LL,
  44170432LL,
  44302144LL,
  44433344LL,
  44564288LL,
  44694976LL,
  44825152LL,
  44956864LL,
  45088448LL,
  45219008LL,
  45350464LL,
  45481024LL,
  45612608LL,
  45744064LL,
  45874496LL,
  46006208LL,
  46136768LL,
  46267712LL,
  46399424LL,
  46529344LL,
  46660672LL,
  46791488LL,
  46923328LL,
  47053504LL,
  47185856LL,
  47316928LL,
  47447872LL,
  47579072LL,
  47710144LL,
  47839936LL,
  47971648LL,
  48103232LL,
  48234176LL,
  48365248LL,
  48496192LL,
  48627136LL,
  48757312LL,
  48889664LL,
  49020736LL,
  49149248LL,
  49283008LL,
  49413824LL,
  49545152LL,
  49675712LL,
  49807168LL,
  49938368LL,
  50069056LL,
  50200256LL,
  50331584LL,
  50462656LL,
  50593472LL,
  50724032LL,
  50853952LL,
  50986048LL,
  51117632LL,
  51248576LL,
  51379904LL,
  51510848LL,
  51641792LL,
  51773248LL,
  51903296LL,
  52035136LL,
  52164032LL,
  52297664LL,
  52427968LL,
  52557376LL,
  52690112LL,
  52821952LL,
  52952896LL,
  53081536LL,
  53213504LL,
  53344576LL,
  53475776LL,
  53608384LL,
  53738816LL,
  53870528LL,
  54000832LL,
  54131776LL,
  54263744LL,
  54394688LL,
  54525248LL,
  54655936LL,
  54787904LL,
  54918592LL,
  55049152LL,
  55181248LL,
  55312064LL,
  55442752LL,
  55574336LL,
  55705024LL,
  55836224LL,
  55967168LL,
  56097856LL,
  56228672LL,
  56358592LL,
  56490176LL,
  56621888LL,
  56753728LL,
  56884928LL,
  57015488LL,
  57146816LL,
  57278272LL,
  57409216LL,
  57540416LL,
  57671104LL,
  57802432LL,
  57933632LL,
  58064576LL,
  58195264LL,
  58326976LL,
  58457408LL,
  58588864LL,
  58720192LL,
  58849984LL,
  58981696LL,
  59113024LL,
  59243456LL,
  59375552LL,
  59506624LL,
  59637568LL,
  59768512LL,
  59897792LL,
  60030016LL,
  60161984LL,
  60293056LL,
  60423872LL,
  60554432LL,
  60683968LL,
  60817216LL,
  60948032LL,
  61079488LL,
  61209664LL,
  61341376LL,
  61471936LL,
  61602752LL,
  61733696LL,
  61865792LL,
  61996736LL,
  62127808LL,
  62259136LL,
  62389568LL,
  62520512LL,
  62651584LL,
  62781632LL,
  62910784LL,
  63045056LL,
  63176128LL,
  63307072LL,
  63438656LL,
  63569216LL,
  63700928LL,
  63831616LL,
  63960896LL,
  64093888LL,
  64225088LL,
  64355392LL,
  64486976LL,
  64617664LL,
  64748608LL,
  64879424LL,
  65009216LL,
  65142464LL,
  65273792LL,
  65402816LL,
  65535424LL,
  65666752LL,
  65797696LL,
  65927744LL,
  66060224LL,
  66191296LL,
  66321344LL,
  66453056LL,
  66584384LL,
  66715328LL,
  66846656LL,
  66977728LL,
  67108672LL,
  67239104LL,
  67370432LL,
  67501888LL,
  67631296LL,
  67763776LL,
  67895104LL,
  68026304LL,
  68157248LL,
  68287936LL,
  68419264LL,
  68548288LL,
  68681408LL,
  68811968LL,
  68942912LL,
  69074624LL,
  69205568LL,
  69337024LL,
  69467584LL,
  69599168LL,
  69729472LL,
  69861184LL,
  69989824LL,
  70122944LL,
  70253888LL,
  70385344LL,
  70515904LL,
  70647232LL,
  70778816LL,
  70907968LL,
  71040832LL,
  71171648LL,
  71303104LL,
  71432512LL,
  71564992LL,
  71695168LL,
  71826368LL,
  71958464LL,
  72089536LL,
  72219712LL,
  72350144LL,
  72482624LL,
  72613568LL,
  72744512LL,
  72875584LL,
  73006144LL,
  73138112LL,
  73268672LL,
  73400128LL,
  73530944LL,
  73662272LL,
  73793344LL,
  73924544LL,
  74055104LL,
  74185792LL,
  74316992LL,
  74448832LL,
  74579392LL,
  74710976LL,
  74841664LL,
  74972864LL,
  75102784LL,
  75233344LL,
  75364544LL,
  75497024LL,
  75627584LL,
  75759296LL,
  75890624LL,
  76021696LL,
  76152256LL,
  76283072LL,
  76414144LL,
  76545856LL,
  76676672LL,
  76806976LL,
  76937792LL,
  77070016LL,
  77200832LL,
  77331392LL,
  77462464LL,
  77593664LL,
  77725376LL,
  77856448LL,
  77987776LL,
  78118336LL,
  78249664LL,
  78380992LL,
  78511424LL,
  78642496LL,
  78773056LL,
  78905152LL,
  79033664LL,
  79166656LL,
  79297472LL,
  79429568LL,
  79560512LL,
  79690816LL,
  79822784LL,
  79953472LL,
  80084672LL,
  80214208LL,
  80346944LL,
  80477632LL,
  80608576LL,
  80740288LL,
  80870848LL,
  81002048LL,
  81133504LL,
  81264448LL,
  81395648LL,
  81525952LL,
  81657536LL,
  81786304LL,
  81919808LL,
  82050112LL,
  82181312LL,
  82311616LL,
  82443968LL,
  82573376LL,
  82705984LL,
  82835776LL,
  82967744LL,
  83096768LL,
  83230528LL,
  83359552LL,
  83491264LL,
  83622464LL,
  83753536LL,
  83886016LL,
  84015296LL,
  84147776LL,
  84277184LL,
  84409792LL,
  84540608LL,
  84672064LL,
  84803008LL,
  84934336LL,
  85065152LL,
  85193792LL,
  85326784LL,
  85458496LL,
  85589312LL,
  85721024LL,
  85851968LL,
  85982656LL,
  86112448LL,
  86244416LL,
  86370112LL,
  86506688LL,
  86637632LL,
  86769344LL,
  86900672LL,
  87031744LL,
  87162304LL,
  87293632LL,
  87424576LL,
  87555392LL,
  87687104LL,
  87816896LL,
  87947968LL,
  88079168LL,
  88211264LL,
  88341824LL,
  88473152LL,
  88603712LL,
  88735424LL,
  88862912LL,
  88996672LL,
  89128384LL,
  89259712LL,
  89390272LL,
  89521984LL,
  89652544LL,
  89783872LL,
  89914816LL,
  90045376LL,
  90177088LL,
  90307904LL,
  90438848LL,
  90569152LL,
  90700096LL,
  90832832LL,
  90963776LL,
  91093696LL,
  91223744LL,
  91356992LL,
  91486784LL,
  91618496LL,
  91749824LL,
  91880384LL,
  92012224LL,
  92143552LL,
  92273344LL,
  92405696LL,
  92536768LL,
  92666432LL,
  92798912LL,
  92926016LL,
  93060544LL,
  93192128LL,
  93322816LL,
  93453632LL,
  93583936LL,
  93715136LL,
  93845056LL,
  93977792LL,
  94109504LL,
  94240448LL,
  94371776LL,
  94501184LL,
  94632896LL,
  94764224LL,
  94895552LL,
  95023424LL,
  95158208LL,
  95287744LL,
  95420224LL,
  95550016LL,
  95681216LL,
  95811904LL,
  95943872LL,
  96075328LL,
  96203584LL,
  96337856LL,
  96468544LL,
  96599744LL,
  96731072LL,
  96860992LL,
  96992576LL,
  97124288LL,
  97254848LL,
  97385536LL,
  97517248LL,
  97647808LL,
  97779392LL,
  97910464LL,
  98041408LL,
  98172608LL,
  98303168LL,
  98434496LL,
  98565568LL,
  98696768LL,
  98827328LL,
  98958784LL,
  99089728LL,
  99220928LL,
  99352384LL,
  99482816LL,
  99614272LL,
  99745472LL,
  99876416LL,
  100007104LL,
  100138048LL,
  100267072LL,
  100401088LL,
  100529984LL,
  100662592LL,
  100791872LL,
  100925248LL,
  101056064LL,
  101187392LL,
  101317952LL,
  101449408LL,
  101580608LL,
  101711296LL,
  101841728LL,
  101973824LL,
  102104896LL,
  102235712LL,
  102366016LL,
  102498112LL,
  102628672LL,
  102760384LL,
  102890432LL,
  103021888LL,
  103153472LL,
  103284032LL,
  103415744LL,
  103545152LL,
  103677248LL,
  103808576LL,
  103939648LL,
  104070976LL,
  104201792LL,
  104332736LL,
  104462528LL,
  104594752LL,
  104725952LL,
  104854592LL,
  104988608LL,
  105118912LL,
  105247808LL,
  105381184LL,
  105511232LL,
  105643072LL,
  105774784LL,
  105903296LL,
  106037056LL,
  106167872LL,
  106298944LL,
  106429504LL,
  106561472LL,
  106691392LL,
  106822592LL,
  106954304LL,
  107085376LL,
  107216576LL,
  107346368LL,
  107478464LL,
  107609792LL,
  107739712LL,
  107872192LL,
  108003136LL,
  108131392LL,
  108265408LL,
  108396224LL,
  108527168LL,
  108657344LL,
  108789568LL,
  108920384LL,
  109049792LL,
  109182272LL,
  109312576LL,
  109444928LL,
  109572928LL,
  109706944LL,
  109837888LL,
  109969088LL,
  110099648LL,
  110230976LL,
  110362432LL,
  110492992LL,
  110624704LL,
  110755264LL,
  110886208LL,
  111017408LL,
  111148864LL,
  111279296LL,
  111410752LL,
  111541952LL,
  111673024LL,
  111803456LL,
  111933632LL,
  112066496LL,
  112196416LL,
  112328512LL,
  112457792LL,
  112590784LL,
  112715968LL,
  112852672LL,
  112983616LL,
  113114944LL,
  113244224LL,
  113376448LL,
  113505472LL,
  113639104LL,
  113770304LL,
  113901376LL,
  114031552LL,
  114163264LL,
  114294592LL,
  114425536LL,
  114556864LL,
  114687424LL,
  114818624LL,
  114948544LL,
  115080512LL,
  115212224LL,
  115343296LL,
  115473472LL,
  115605184LL,
  115736128LL,
  115867072LL,
  115997248LL,
  116128576LL,
  116260288LL,
  116391488LL,
  116522944LL,
  116652992LL,
  116784704LL,
  116915648LL,
  117046208LL,
  117178304LL,
  117308608LL,
  117440192LL,
  117569728LL,
  117701824LL,
  117833024LL,
  117964096LL,
  118094656LL,
  118225984LL,
  118357312LL,
  118489024LL,
  118617536LL,
  118749632LL,
  118882112LL,
  119012416LL,
  119144384LL,
  119275328LL,
  119406016LL,
  119537344LL,
  119668672LL,
  119798464LL,
  119928896LL,
  120061376LL,
  120192832LL,
  120321728LL,
  120454336LL,
  120584512LL,
  120716608LL,
  120848192LL,
  120979136LL,
  121109056LL,
  121241408LL,
  121372352LL,
  121502912LL,
  121634752LL,
  121764416LL,
  121895744LL,
  122027072LL,
  122157632LL,
  122289088LL,
  122421184LL,
  122550592LL,
  122682944LL,
  122813888LL,
  122945344LL,
  123075776LL,
  123207488LL,
  123338048LL,
  123468736LL,
  123600704LL,
  123731264LL,
  123861952LL,
  123993664LL,
  124124608LL,
  124256192LL,
  124386368LL,
  124518208LL,
  124649024LL,
  124778048LL,
  124911296LL,
  125041088LL,
  125173696LL,
  125303744LL,
  125432896LL,
  125566912LL,
  125696576LL,
  125829056LL,
  125958592LL,
  126090304LL,
  126221248LL,
  126352832LL,
  126483776LL,
  126615232LL,
  126746432LL,
  126876608LL,
  127008704LL,
  127139392LL,
  127270336LL,
  127401152LL,
  127532224LL,
  127663552LL,
  127794752LL,
  127925696LL,
  128055232LL,
  128188096LL,
  128319424LL,
  128449856LL,
  128581312LL,
  128712256LL,
  128843584LL,
  128973632LL,
  129103808LL,
  129236288LL,
  129365696LL,
  129498944LL,
  129629888LL,
  129760832LL,
  129892288LL,
  130023104LL,
  130154048LL,
  130283968LL,
  130416448LL,
  130547008LL,
  130678336LL,
  130807616LL,
  130939456LL,
  131071552LL,
  131202112LL,
  131331776LL,
  131464384LL,
  131594048LL,
  131727296LL,
  131858368LL,
  131987392LL,
  132120256LL,
  132250816LL,
  132382528LL,
  132513728LL,
  132644672LL,
  132774976LL,
  132905792LL,
  133038016LL,
  133168832LL,
  133299392LL,
  133429312LL,
  133562048LL,
  133692992LL,
  133823296LL,
  133954624LL,
  134086336LL,
  134217152LL,
  134348608LL,
  134479808LL,
  134607296LL,
  134741056LL,
  134872384LL,
  135002944LL,
  135134144LL,
  135265472LL,
  135396544LL,
  135527872LL,
  135659072LL,
  135787712LL,
  135921472LL,
  136052416LL,
  136182848LL,
  136313792LL,
  136444864LL,
  136576448LL,
  136707904LL,
  136837952LL,
  136970048LL,
  137099584LL,
  137232064LL,
  137363392LL,
  137494208LL,
  137625536LL,
  137755712LL,
  137887424LL,
  138018368LL,
  138149824LL,
  138280256LL,
  138411584LL,
  138539584LL,
  138672832LL,
  138804928LL,
  138936128LL,
  139066688LL,
  139196864LL,
  139328704LL,
  139460032LL,
  139590208LL,
  139721024LL,
  139852864LL,
  139984576LL,
  140115776LL,
  140245696LL,
  140376512LL,
  140508352LL,
  140640064LL,
  140769856LL,
  140902336LL,
  141032768LL,
  141162688LL,
  141294016LL,
  141426496LL,
  141556544LL,
  141687488LL,
  141819584LL,
  141949888LL,
  142080448LL,
  142212544LL,
  142342336LL,
  142474432LL,
  142606144LL,
  142736192LL,
  142868288LL,
  142997824LL,
  143129408LL,
  143258944LL,
  143392448LL,
  143523136LL,
  143653696LL,
  143785024LL,
  143916992LL,
  144045632LL,
  144177856LL,
  144309184LL,
  144440768LL,
  144570688LL,
  144701888LL,
  144832448LL,
  144965056LL,
  145096384LL,
  145227584LL,
  145358656LL,
  145489856LL,
  145620928LL,
  145751488LL,
  145883072LL,
  146011456LL,
  146144704LL,
  146275264LL,
  146407232LL,
  146538176LL,
  146668736LL,
  146800448LL,
  146931392LL,
  147062336LL,
  147193664LL,
  147324224LL,
  147455936LL,
  147586624LL,
  147717056LL,
  147848768LL,
  147979456LL,
  148110784LL,
  148242368LL,
  148373312LL,
  148503232LL,
  148635584LL,
  148766144LL,
  148897088LL,
  149028416LL,
  149159488LL,
  149290688LL,
  149420224LL,
  149551552LL,
  149683136LL,
  149814976LL,
  149943616LL,
  150076352LL,
  150208064LL,
  150338624LL,
  150470464LL,
  150600256LL,
  150732224LL,
  150862784LL,
  150993088LL,
  151125952LL,
  151254976LL,
  151388096LL,
  151519168LL,
  151649728LL,
  151778752LL,
  151911104LL,
  152042944LL,
  152174144LL,
  152304704LL,
  152435648LL,
  152567488LL,
  152698816LL,
  152828992LL,
  152960576LL,
  153091648LL,
  153222976LL,
  153353792LL,
  153484096LL,
  153616192LL,
  153747008LL,
  153878336LL,
  154008256LL,
  154139968LL,
  154270912LL,
  154402624LL,
  154533824LL,
  154663616LL,
  154795712LL,
  154926272LL,
  155057984LL,
  155188928LL,
  155319872LL,
  155450816LL,
  155580608LL,
  155712064LL,
  155843392LL,
  155971136LL,
  156106688LL,
  156237376LL,
  156367424LL,
  156499264LL,
  156630976LL,
  156761536LL,
  156892352LL,
  157024064LL,
  157155008LL,
  157284416LL,
  157415872LL,
  157545536LL,
  157677248LL,
  157810496LL,
  157938112LL,
  158071744LL,
  158203328LL,
  158334656LL,
  158464832LL,
  158596288LL,
  158727616LL,
  158858048LL,
  158988992LL,
  159121216LL,
  159252416LL,
  159381568LL,
  159513152LL,
  159645632LL,
  159776192LL,
  159906496LL,
  160038464LL,
  160169536LL,
  160300352LL,
  160430656LL,
  160563008LL,
  160693952LL,
  160822208LL,
  160956352LL,
  161086784LL,
  161217344LL,
  161349184LL,
  161480512LL,
  161611456LL,
  161742272LL,
  161873216LL,
  162002752LL,
  162135872LL,
  162266432LL,
  162397888LL,
  162529216LL,
  162660032LL,
  162790976LL,
  162922048LL,
  163052096LL,
  163184576LL,
  163314752LL,
  163446592LL,
  163577408LL,
  163707968LL,
  163839296LL,
  163969984LL,
  164100928LL,
  164233024LL,
  164364224LL,
  164494912LL,
  164625856LL,
  164756672LL,
  164887616LL,
  165019072LL,
  165150016LL,
  165280064LL,
  165412672LL,
  165543104LL,
  165674944LL,
  165805888LL,
  165936832LL,
  166067648LL,
  166198336LL,
  166330048LL,
  166461248LL,
  166591552LL,
  166722496LL,
  166854208LL,
  166985408LL,
  167116736LL,
  167246656LL,
  167378368LL,
  167508416LL,
  167641024LL,
  167771584LL,
  167903168LL,
  168034112LL,
  168164032LL,
  168295744LL,
  168427456LL,
  168557632LL,
  168688448LL,
  168819136LL,
  168951616LL,
  169082176LL,
  169213504LL,
  169344832LL,
  169475648LL,
  169605952LL,
  169738048LL,
  169866304LL,
  169999552LL,
  170131264LL,
  170262464LL,
  170393536LL,
  170524352LL,
  170655424LL,
  170782016LL,
  170917696LL,
  171048896LL,
  171179072LL,
  171310784LL,
  171439936LL,
  171573184LL,
  171702976LL,
  171835072LL,
  171966272LL,
  172097216LL,
  172228288LL,
  172359232LL,
  172489664LL,
  172621376LL,
  172747712LL,
  172883264LL,
  173014208LL,
  173144512LL,
  173275072LL,
  173407424LL,
  173539136LL,
  173669696LL,
  173800768LL,
  173931712LL,
  174063424LL,
  174193472LL,
  174325696LL,
  174455744LL,
  174586816LL,
  174718912LL,
  174849728LL,
  174977728LL,
  175109696LL,
  175242688LL,
  175374272LL,
  175504832LL,
  175636288LL,
  175765696LL,
  175898432LL,
  176028992LL,
  176159936LL,
  176291264LL,
  176422592LL,
  176552512LL,
  176684864LL,
  176815424LL,
  176946496LL,
  177076544LL,
  177209152LL,
  177340096LL,
  177470528LL,
  177600704LL,
  177731648LL,
  177864256LL,
  177994816LL,
  178126528LL,
  178257472LL,
  178387648LL,
  178518464LL,
  178650176LL,
  178781888LL,
  178912064LL,
  179044288LL,
  179174848LL,
  179305024LL,
  179436736LL,
  179568448LL,
  179698496LL,
  179830208LL,
  179960512LL,
  180092608LL,
  180223808LL,
  180354752LL,
  180485696LL,
  180617152LL,
  180748096LL,
  180877504LL,
  181009984LL,
  181139264LL,
  181272512LL,
  181402688LL,
  181532608LL,
  181663168LL,
  181795136LL,
  181926592LL,
  182057536LL,
  182190016LL,
  182320192LL,
  182451904LL,
  182582336LL,
  182713792LL,
  182843072LL,
  182976064LL,
  183107264LL,
  183237056LL,
  183368384LL,
  183494848LL,
  183631424LL,
  183762752LL,
  183893824LL,
  184024768LL,
  184154816LL,
  184286656LL,
  184417984LL,
  184548928LL,
  184680128LL,
  184810816LL,
  184941248LL,
  185072704LL,
  185203904LL,
  185335616LL,
  185465408LL,
  185596352LL,
  185727296LL,
  185859904LL,
  185989696LL,
  186121664LL,
  186252992LL,
  186383552LL,
  186514112LL,
  186645952LL,
  186777152LL,
  186907328LL,
  187037504LL,
  187170112LL,
  187301824LL,
  187429184LL,
  187562048LL,
  187693504LL,
  187825472LL,
  187957184LL,
  188087104LL,
  188218304LL,
  188349376LL,
  188481344LL,
  188609728LL,
  188743616LL,
  188874304LL,
  189005248LL,
  189136448LL,
  189265088LL,
  189396544LL,
  189528128LL,
  189660992LL,
  189791936LL,
  189923264LL,
  190054208LL,
  190182848LL,
  190315072LL,
  190447424LL,
  190577984LL,
  190709312LL,
  190840768LL,
  190971328LL,
  191102656LL,
  191233472LL,
  191364032LL,
  191495872LL,
  191626816LL,
  191758016LL,
  191888192LL,
  192020288LL,
  192148928LL,
  192282176LL,
  192413504LL,
  192542528LL,
  192674752LL,
  192805952LL,
  192937792LL,
  193068608LL,
  193198912LL,
  193330496LL,
  193462208LL,
  193592384LL,
  193723456LL,
  193854272LL,
  193985984LL,
  194116672LL,
  194247232LL,
  194379712LL,
  194508352LL,
  194641856LL,
  194772544LL,
  194900672LL,
  195035072LL,
  195166016LL,
  195296704LL,
  195428032LL,
  195558592LL,
  195690304LL,
  195818176LL,
  195952576LL,
  196083392LL,
  196214336LL,
  196345792LL,
  196476736LL,
  196607552LL,
  196739008LL,
  196869952LL,
  197000768LL,
  197130688LL,
  197262784LL,
  197394368LL,
  197523904LL,
  197656384LL,
  197787584LL,
  197916608LL,
  198049472LL,
  198180544LL,
  198310208LL,
  198442432LL,
  198573632LL,
  198705088LL,
  198834368LL,
  198967232LL,
  199097792LL,
  199228352LL,
  199360192LL,
  199491392LL,
  199621696LL,
  199751744LL,
  199883968LL,
  200014016LL,
  200146624LL,
  200276672LL,
  200408128LL,
  200540096LL,
  200671168LL,
  200801984LL,
  200933312LL,
  201062464LL,
  201194944LL,
  201326144LL,
  201457472LL,
  201588544LL,
  201719744LL,
  201850816LL,
  201981632LL,
  202111552LL,
  202244032LL,
  202374464LL,
  202505152LL,
  202636352LL,
  202767808LL,
  202898368LL,
  203030336LL,
  203159872LL,
  203292608LL,
  203423296LL,
  203553472LL,
  203685824LL,
  203816896LL,
  203947712LL,
  204078272LL,
  204208192LL,
  204341056LL,
  204472256LL,
  204603328LL,
  204733888LL,
  204864448LL,
  204996544LL,
  205125568LL,
  205258304LL,
  205388864LL,
  205517632LL,
  205650112LL,
  205782208LL,
  205913536LL,
  206044736LL,
  206176192LL,
  206307008LL,
  206434496LL,
  206569024LL,
  206700224LL,
  206831168LL,
  206961856LL,
  207093056LL,
  207223616LL,
  207355328LL,
  207486784LL,
  207616832LL,
  207749056LL,
  207879104LL,
  208010048LL,
  208141888LL,
  208273216LL,
  208404032LL,
  208534336LL,
  208666048LL,
  208796864LL,
  208927424LL,
  209059264LL,
  209189824LL,
  209321792LL,
  209451584LL,
  209582656LL,
  209715136LL,
  209845568LL,
  209976896LL,
  210106432LL,
  210239296LL,
  210370112LL,
  210501568LL,
  210630976LL,
  210763712LL,
  210894272LL,
  211024832LL,
  211156672LL,
  211287616LL,
  211418176LL,
  211549376LL,
  211679296LL,
  211812032LL,
  211942592LL,
  212074432LL,
  212204864LL,
  212334016LL,
  212467648LL,
  212597824LL,
  212727616LL,
  212860352LL,
  212991424LL,
  213120832LL,
  213253952LL,
  213385024LL,
  213515584LL,
  213645632LL,
  213777728LL,
  213909184LL,
  214040128LL,
  214170688LL,
  214302656LL,
  214433728LL,
  214564544LL,
  214695232LL,
  214826048LL,
  214956992LL,
  215089088LL,
  215219776LL,
  215350592LL,
  215482304LL,
  215613248LL,
  215743552LL,
  215874752LL,
  216005312LL,
  216137024LL,
  216267328LL,
  216399296LL,
  216530752LL,
  216661696LL,
  216790592LL,
  216923968LL,
  217054528LL,
  217183168LL,
  217316672LL,
  217448128LL,
  217579072LL,
  217709504LL,
  217838912LL,
  217972672LL,
  218102848LL,
  218233024LL,
  218364736LL,
  218496832LL,
  218627776LL,
  218759104LL,
  218888896LL,
  219021248LL,
  219151936LL,
  219281728LL,
  219413056LL,
  219545024LL,
  219675968LL,
  219807296LL,
  219938624LL,
  220069312LL,
  220200128LL,
  220331456LL,
  220461632LL,
  220592704LL,
  220725184LL,
  220855744LL,
  220987072LL,
  221117888LL,
  221249216LL,
  221378368LL,
  221510336LL,
  221642048LL,
  221772736LL,
  221904832LL,
  222031808LL,
  222166976LL,
  222297536LL,
  222428992LL,
  222559936LL,
  222690368LL,
  222820672LL,
  222953152LL,
  223083968LL,
  223213376LL,
  223345984LL,
  223476928LL,
  223608512LL,
  223738688LL,
  223869376LL,
  224001472LL,
  224132672LL,
  224262848LL,
  224394944LL,
  224524864LL,
  224657344LL,
  224788288LL,
  224919488LL,
  225050432LL,
  225181504LL,
  225312704LL,
  225443776LL,
  225574592LL,
  225704768LL,
  225834176LL,
  225966784LL,
  226097216LL,
  226229824LL,
  226360384LL,
  226491712LL,
  226623424LL,
  226754368LL,
  226885312LL,
  227015104LL,
  227147456LL,
  227278528LL,
  227409472LL,
  227539904LL,
  227669696LL,
  227802944LL,
  227932352LL,
  228065216LL,
  228196288LL,
  228326464LL,
  228457792LL,
  228588736LL,
  228720064LL,
  228850112LL,
  228981056LL,
  229113152LL,
  229243328LL,
  229375936LL,
  229505344LL,
  229636928LL,
  229769152LL,
  229894976LL,
  230030272LL,
  230162368LL,
  230292416LL,
  230424512LL,
  230553152LL,
  230684864LL,
  230816704LL,
  230948416LL,
  231079616LL,
  231210944LL,
  231342016LL,
  231472448LL,
  231603776LL,
  231733952LL,
  231866176LL,
  231996736LL,
  232127296LL,
  232259392LL,
  232388672LL,
  232521664LL,
  232652608LL,
  232782272LL,
  232914496LL,
  233043904LL,
  233175616LL,
  233306816LL,
  233438528LL,
  233569984LL,
  233699776LL,
  233830592LL,
  233962688LL,
  234092224LL,
  234221888LL,
  234353984LL,
  234485312LL,
  234618304LL,
  234749888LL,
  234880832LL,
  235011776LL,
  235142464LL,
  235274048LL,
  235403456LL,
  235535936LL,
  235667392LL,
  235797568LL,
  235928768LL,
  236057152LL,
  236190272LL,
  236322752LL,
  236453312LL,
  236583616LL,
  236715712LL,
  236846528LL,
  236976448LL,
  237108544LL,
  237239104LL,
  237371072LL,
  237501632LL,
  237630784LL,
  237764416LL,
  237895232LL,
  238026688LL,
  238157632LL,
  238286912LL,
  238419392LL,
  238548032LL,
  238681024LL,
  238812608LL,
  238941632LL,
  239075008LL,
  239206336LL,
  239335232LL,
  239466944LL,
  239599168LL,
  239730496LL,
  239861312LL,
  239992384LL,
  240122816LL,
  240254656LL,
  240385856LL,
  240516928LL,
  240647872LL,
  240779072LL,
  240909632LL,
  241040704LL,
  241171904LL,
  241302848LL,
  241433408LL,
  241565248LL,
  241696192LL,
  241825984LL,
  241958848LL,
  242088256LL,
  242220224LL,
  242352064LL,
  242481856LL,
  242611648LL,
  242744896LL,
  242876224LL,
  243005632LL,
  243138496LL,
  243268672LL,
  243400384LL,
  243531712LL,
  243662656LL,
  243793856LL,
  243924544LL,
  244054592LL,
  244187072LL,
  244316608LL,
  244448704LL,
  244580032LL,
  244710976LL,
  244841536LL,
  244972864LL,
  245104448LL,
  245233984LL,
  245365312LL,
  245497792LL,
  245628736LL,
  245759936LL,
  245889856LL,
  246021056LL,
  246152512LL,
  246284224LL,
  246415168LL,
  246545344LL,
  246675904LL,
  246808384LL,
  246939584LL,
  247070144LL,
  247199552LL,
  247331648LL,
  247463872LL,
  247593536LL,
  247726016LL,
  247857088LL,
  247987648LL,
  248116928LL,
  248249536LL,
  248380736LL,
  248512064LL,
  248643008LL,
  248773312LL,
  248901056LL,
  249036608LL,
  249167552LL,
  249298624LL,
  249429184LL,
  249560512LL,
  249692096LL,
  249822784LL,
  249954112LL,
  250085312LL,
  250215488LL,
  250345792LL,
  250478528LL,
  250608704LL,
  250739264LL,
  250870976LL,
  251002816LL,
  251133632LL,
  251263552LL,
  251395136LL,
  251523904LL,
  251657792LL,
  251789248LL,
  251919424LL,
  252051392LL,
  252182464LL,
  252313408LL,
  252444224LL,
  252575552LL,
  252706624LL,
  252836032LL,
  252968512LL,
  253099712LL,
  253227584LL,
  253361728LL,
  253493056LL,
  253623488LL,
  253754432LL,
  253885504LL,
  254017216LL,
  254148032LL,
  254279488LL,
  254410432LL,
  254541376LL,
  254672576LL,
  254803264LL,
  254933824LL,
  255065792LL,
  255196736LL,
  255326528LL,
  255458752LL,
  255589952LL,
  255721408LL,
  255851072LL,
  255983296LL,
  256114624LL,
  256244416LL,
  256374208LL,
  256507712LL,
  256636096LL,
  256768832LL,
  256900544LL,
  257031616LL,
  257162176LL,
  257294272LL,
  257424448LL,
  257555776LL,
  257686976LL,
  257818432LL,
  257949632LL,
  258079552LL,
  258211136LL,
  258342464LL,
  258473408LL,
  258603712LL,
  258734656LL,
  258867008LL,
  258996544LL,
  259127744LL,
  259260224LL,
  259391296LL,
  259522112LL,
  259651904LL,
  259784384LL,
  259915328LL,
  260045888LL,
  260175424LL,
  260308544LL,
  260438336LL,
  260570944LL,
  260700992LL,
  260832448LL,
  260963776LL,
  261092672LL,
  261226304LL,
  261356864LL,
  261487936LL,
  261619648LL,
  261750592LL,
  261879872LL,
  262011968LL,
  262143424LL,
  262274752LL,
  262404416LL,
  262537024LL,
  262667968LL,
  262799296LL,
  262928704LL,
  263061184LL,
  263191744LL,
  263322944LL,
  263454656LL,
  263585216LL,
  263716672LL,
  263847872LL,
  263978944LL,
  264108608LL,
  264241088LL,
  264371648LL,
  264501184LL,
  264632768LL,
  264764096LL,
  264895936LL,
  265024576LL,
  265158464LL,
  265287488LL,
  265418432LL,
  265550528LL,
  265681216LL,
  265813312LL,
  265943488LL,
  266075968LL,
  266206144LL,
  266337728LL,
  266468032LL,
  266600384LL,
  266731072LL,
  266862272LL,
  266993344LL,
  267124288LL,
  267255616LL,
  267386432LL,
  267516992LL,
  267648704LL,
  267777728LL,
  267910592LL,
  268040512LL,
  268172096LL,
  268302784LL,
  268435264LL,
  268566208LL,
  268696256LL,
  268828096LL,
  268959296LL,
  269090368LL,
  269221312LL,
  269352256LL,
  269482688LL,
  269614784LL,
  269745856LL,
  269876416LL,
  270007616LL,
  270139328LL,
  270270272LL,
  270401216LL,
  270531904LL,
  270663616LL,
  270791744LL,
  270924736LL,
  271056832LL,
  271186112LL,
  271317184LL,
  271449536LL,
  271580992LL,
  271711936LL,
  271843136LL,
  271973056LL,
  272105408LL,
  272236352LL,
  272367296LL,
  272498368LL,
  272629568LL,
  272759488LL,
  272891456LL,
  273022784LL,
  273153856LL,
  273284672LL,
  273415616LL,
  273547072LL,
  273677632LL,
  273808448LL,
  273937088LL,
  274071488LL,
  274200896LL,
  274332992LL,
  274463296LL,
  274595392LL,
  274726208LL,
  274857536LL,
  274988992LL,
  275118656LL,
  275250496LL,
  275382208LL,
  275513024LL,
  275643968LL,
  275775296LL,
  275906368LL,
  276037184LL,
  276167872LL,
  276297664LL,
  276429376LL,
  276560576LL,
  276692672LL,
  276822976LL,
  276955072LL,
  277085632LL,
  277216832LL,
  277347008LL,
  277478848LL,
  277609664LL,
  277740992LL,
  277868608LL,
  278002624LL,
  278134336LL,
  278265536LL,
  278395328LL,
  278526784LL,
  278657728LL,
  278789824LL,
  278921152LL,
  279052096LL,
  279182912LL,
  279313088LL,
  279443776LL,
  279576256LL,
  279706048LL,
  279838528LL,
  279969728LL,
  280099648LL,
  280230976LL,
  280361408LL,
  280493632LL,
  280622528LL,
  280755392LL,
  280887104LL,
  281018176LL,
  281147968LL,
  281278912LL,
  281411392LL,
  281542592LL,
  281673152LL,
  281803712LL,
  281935552LL,
  282066496LL,
  282197312LL,
  282329024LL,
  282458816LL,
  282590272LL,
  282720832LL,
  282853184LL,
  282983744LL,
  283115072LL,
  283246144LL,
  283377344LL,
  283508416LL,
  283639744LL,
  283770304LL,
  283901504LL,
  284032576LL,
  284163136LL,
  284294848LL,
  284426176LL,
  284556992LL,
  284687296LL,
  284819264LL,
  284950208LL,
  285081536LL
}; // weak
_WORD crc_itu_t_table[256] =
{
  0,
  4129,
  8258,
  12387,
  16516,
  20645,
  24774,
  28903,
  -32504,
  -28375,
  -24246,
  -20117,
  -15988,
  -11859,
  -7730,
  -3601,
  4657,
  528,
  12915,
  8786,
  21173,
  17044,
  29431,
  25302,
  -27847,
  -31976,
  -19589,
  -23718,
  -11331,
  -15460,
  -3073,
  -7202,
  9314,
  13379,
  1056,
  5121,
  25830,
  29895,
  17572,
  21637,
  -23190,
  -19125,
  -31448,
  -27383,
  -6674,
  -2609,
  -14932,
  -10867,
  13907,
  9842,
  5649,
  1584,
  30423,
  26358,
  22165,
  18100,
  -18597,
  -22662,
  -26855,
  -30920,
  -2081,
  -6146,
  -10339,
  -14404,
  18628,
  22757,
  26758,
  30887,
  2112,
  6241,
  10242,
  14371,
  -13876,
  -9747,
  -5746,
  -1617,
  -30392,
  -26263,
  -22262,
  -18133,
  23285,
  19156,
  31415,
  27286,
  6769,
  2640,
  14899,
  10770,
  -9219,
  -13348,
  -1089,
  -5218,
  -25735,
  -29864,
  -17605,
  -21734,
  27814,
  31879,
  19684,
  23749,
  11298,
  15363,
  3168,
  7233,
  -4690,
  -625,
  -12820,
  -8755,
  -21206,
  -17141,
  -29336,
  -25271,
  32407,
  28342,
  24277,
  20212,
  15891,
  11826,
  7761,
  3696,
  -97,
  -4162,
  -8227,
  -12292,
  -16613,
  -20678,
  -24743,
  -28808,
  -28280,
  -32343,
  -20022,
  -24085,
  -12020,
  -16083,
  -3762,
  -7825,
  4224,
  161,
  12482,
  8419,
  20484,
  16421,
  28742,
  24679,
  -31815,
  -27752,
  -23557,
  -19494,
  -15555,
  -11492,
  -7297,
  -3234,
  689,
  4752,
  8947,
  13010,
  16949,
  21012,
  25207,
  29270,
  -18966,
  -23093,
  -27224,
  -31351,
  -2706,
  -6833,
  -10964,
  -15091,
  13538,
  9411,
  5280,
  1153,
  29798,
  25671,
  21540,
  17413,
  -22565,
  -18438,
  -30823,
  -26696,
  -6305,
  -2178,
  -14563,
  -10436,
  9939,
  14066,
  1681,
  5808,
  26199,
  30326,
  17941,
  22068,
  -9908,
  -13971,
  -1778,
  -5841,
  -26168,
  -30231,
  -18038,
  -22101,
  22596,
  18533,
  30726,
  26663,
  6336,
  2273,
  14466,
  10403,
  -13443,
  -9380,
  -5313,
  -1250,
  -29703,
  -25640,
  -21573,
  -17510,
  19061,
  23124,
  27191,
  31254,
  2801,
  6864,
  10931,
  14994,
  -722,
  -4849,
  -8852,
  -12979,
  -16982,
  -21109,
  -25112,
  -29239,
  31782,
  27655,
  23652,
  19525,
  15522,
  11395,
  7392,
  3265,
  -4321,
  -194,
  -12451,
  -8324,
  -20581,
  -16454,
  -28711,
  -24584,
  28183,
  32310,
  20053,
  24180,
  11923,
  16050,
  3793,
  7920
}; // weak
_BYTE chCRCHTalbe[256] =
{
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64
}; // weak
_BYTE chCRCLTalbe[256] =
{
  0,
  -64,
  -63,
  1,
  -61,
  3,
  2,
  -62,
  -58,
  6,
  7,
  -57,
  5,
  -59,
  -60,
  4,
  -52,
  12,
  13,
  -51,
  15,
  -49,
  -50,
  14,
  10,
  -54,
  -53,
  11,
  -55,
  9,
  8,
  -56,
  -40,
  24,
  25,
  -39,
  27,
  -37,
  -38,
  26,
  30,
  -34,
  -33,
  31,
  -35,
  29,
  28,
  -36,
  20,
  -44,
  -43,
  21,
  -41,
  23,
  22,
  -42,
  -46,
  18,
  19,
  -45,
  17,
  -47,
  -48,
  16,
  -16,
  48,
  49,
  -15,
  51,
  -13,
  -14,
  50,
  54,
  -10,
  -9,
  55,
  -11,
  53,
  52,
  -12,
  60,
  -4,
  -3,
  61,
  -1,
  63,
  62,
  -2,
  -6,
  58,
  59,
  -5,
  57,
  -7,
  -8,
  56,
  40,
  -24,
  -23,
  41,
  -21,
  43,
  42,
  -22,
  -18,
  46,
  47,
  -17,
  45,
  -19,
  -20,
  44,
  -28,
  36,
  37,
  -27,
  39,
  -25,
  -26,
  38,
  34,
  -30,
  -29,
  35,
  -31,
  33,
  32,
  -32,
  -96,
  96,
  97,
  -95,
  99,
  -93,
  -94,
  98,
  102,
  -90,
  -89,
  103,
  -91,
  101,
  100,
  -92,
  108,
  -84,
  -83,
  109,
  -81,
  111,
  110,
  -82,
  -86,
  106,
  107,
  -85,
  105,
  -87,
  -88,
  104,
  120,
  -72,
  -71,
  121,
  -69,
  123,
  122,
  -70,
  -66,
  126,
  127,
  -65,
  125,
  -67,
  -68,
  124,
  -76,
  116,
  117,
  -75,
  119,
  -73,
  -74,
  118,
  114,
  -78,
  -77,
  115,
  -79,
  113,
  112,
  -80,
  80,
  -112,
  -111,
  81,
  -109,
  83,
  82,
  -110,
  -106,
  86,
  87,
  -105,
  85,
  -107,
  -108,
  84,
  -100,
  92,
  93,
  -99,
  95,
  -97,
  -98,
  94,
  90,
  -102,
  -101,
  91,
  -103,
  89,
  88,
  -104,
  -120,
  72,
  73,
  -119,
  75,
  -117,
  -118,
  74,
  78,
  -114,
  -113,
  79,
  -115,
  77,
  76,
  -116,
  68,
  -124,
  -123,
  69,
  -121,
  71,
  70,
  -122,
  -126,
  66,
  67,
  -125,
  65,
  -127,
  128,
  64
}; // weak
_UNKNOWN unk_1D3ED8; // weak
_UNKNOWN unk_1D3F08; // weak
_UNKNOWN unk_1D3F2C; // weak
_DWORD dword_1D3F58[16] = { 1, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1568 }; // weak
unsigned __int8 byte_1D3FF0[24] =
{
  1u,
  3u,
  6u,
  10u,
  15u,
  21u,
  28u,
  36u,
  45u,
  55u,
  2u,
  14u,
  27u,
  41u,
  56u,
  8u,
  25u,
  43u,
  62u,
  18u,
  39u,
  61u,
  20u,
  44u
}; // weak
unsigned __int8 byte_1D4008[24] =
{
  10u,
  7u,
  11u,
  17u,
  18u,
  3u,
  5u,
  16u,
  8u,
  21u,
  24u,
  4u,
  15u,
  23u,
  19u,
  13u,
  12u,
  2u,
  20u,
  14u,
  22u,
  9u,
  6u,
  1u
}; // weak
_QWORD qword_1D4020[24] =
{
  1LL,
  32898LL,
  -9223372036854742902LL,
  -9223372034707259392LL,
  32907LL,
  2147483649LL,
  -9223372034707259263LL,
  -9223372036854743031LL,
  138LL,
  136LL,
  2147516425LL,
  2147483658LL,
  2147516555LL,
  -9223372036854775669LL,
  -9223372036854742903LL,
  -9223372036854743037LL,
  -9223372036854743038LL,
  -9223372036854775680LL,
  32778LL,
  -9223372034707292150LL,
  -9223372034707259263LL,
  -9223372036854742912LL,
  2147483649LL,
  -9223372034707259384LL
}; // weak
_UNKNOWN unk_1D40E0; // weak
_UNKNOWN unk_1D4100; // weak
_UNKNOWN unk_1D4120; // weak
_UNKNOWN unk_1D4160; // weak
_DWORD dword_1D41A0[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
}; // weak
_QWORD qword_1D45A0[16] =
{
  2611923443488327891LL,
  1376283091369227076LL,
  -6626703657320631856LL,
  589684135938649225LL,
  4983270260364809079LL,
  -4732044268327596948LL,
  -4563226453097033507LL,
  4577018097722394903LL,
  -7919907764393346277LL,
  -3372901835766516308LL,
  3458046377305235383LL,
  -5124621466747896170LL,
  -5008970055469465703LL,
  2639559389850201335LL,
  577009281997405206LL,
  7163292796296056425LL
}; // weak
_UNKNOWN unk_1D4620; // weak
_UNKNOWN unk_1D4630; // weak
_DWORD dword_1D48C8[256] =
{
  1,
  41,
  139,
  45,
  46,
  87,
  226,
  14,
  60,
  147,
  116,
  130,
  190,
  80,
  196,
  69,
  2,
  82,
  21,
  90,
  92,
  174,
  195,
  28,
  120,
  37,
  232,
  3,
  123,
  160,
  135,
  138,
  4,
  164,
  42,
  180,
  184,
  91,
  133,
  56,
  240,
  74,
  207,
  6,
  246,
  63,
  13,
  19,
  8,
  71,
  84,
  103,
  111,
  182,
  9,
  112,
  223,
  148,
  157,
  12,
  235,
  126,
  26,
  38,
  16,
  142,
  168,
  206,
  222,
  107,
  18,
  224,
  189,
  39,
  57,
  24,
  213,
  252,
  52,
  76,
  32,
  27,
  79,
  155,
  187,
  214,
  36,
  191,
  121,
  78,
  114,
  48,
  169,
  247,
  104,
  152,
  64,
  54,
  158,
  53,
  117,
  171,
  72,
  125,
  242,
  156,
  228,
  96,
  81,
  237,
  208,
  47,
  128,
  108,
  59,
  106,
  234,
  85,
  144,
  250,
  227,
  55,
  199,
  192,
  162,
  217,
  159,
  94,
  256,
  216,
  118,
  212,
  211,
  170,
  31,
  243,
  197,
  110,
  141,
  127,
  67,
  177,
  61,
  188,
  255,
  175,
  236,
  167,
  165,
  83,
  62,
  229,
  137,
  220,
  25,
  254,
  134,
  97,
  122,
  119,
  253,
  93,
  215,
  77,
  73,
  166,
  124,
  201,
  17,
  183,
  50,
  251,
  11,
  194,
  244,
  238,
  249,
  186,
  173,
  154,
  146,
  75,
  248,
  145,
  34,
  109,
  100,
  245,
  22,
  131,
  231,
  219,
  241,
  115,
  89,
  51,
  35,
  150,
  239,
  33,
  68,
  218,
  200,
  233,
  44,
  5,
  205,
  181,
  225,
  230,
  178,
  102,
  70,
  43,
  221,
  66,
  136,
  179,
  143,
  209,
  88,
  10,
  153,
  105,
  193,
  203,
  99,
  204,
  140,
  86,
  185,
  132,
  15,
  101,
  29,
  161,
  176,
  20,
  49,
  210,
  129,
  149,
  198,
  151,
  23,
  172,
  113,
  7,
  30,
  202,
  58,
  65,
  95,
  40,
  98,
  163
}; // weak
unsigned __int16 word_1D4CC8[128] =
{
  1u,
  98u,
  95u,
  58u,
  30u,
  113u,
  23u,
  198u,
  129u,
  49u,
  176u,
  29u,
  15u,
  185u,
  140u,
  99u,
  193u,
  153u,
  88u,
  143u,
  136u,
  221u,
  70u,
  178u,
  225u,
  205u,
  44u,
  200u,
  68u,
  239u,
  35u,
  89u,
  241u,
  231u,
  22u,
  100u,
  34u,
  248u,
  146u,
  173u,
  249u,
  244u,
  11u,
  50u,
  17u,
  124u,
  73u,
  215u,
  253u,
  122u,
  134u,
  25u,
  137u,
  62u,
  165u,
  236u,
  255u,
  61u,
  67u,
  141u,
  197u,
  31u,
  211u,
  118u,
  256u,
  159u,
  162u,
  199u,
  227u,
  144u,
  234u,
  59u,
  128u,
  208u,
  81u,
  228u,
  242u,
  72u,
  117u,
  158u,
  64u,
  104u,
  169u,
  114u,
  121u,
  36u,
  187u,
  79u,
  32u,
  52u,
  213u,
  57u,
  189u,
  18u,
  222u,
  168u,
  16u,
  26u,
  235u,
  157u,
  223u,
  9u,
  111u,
  84u,
  8u,
  13u,
  246u,
  207u,
  240u,
  133u,
  184u,
  42u,
  4u,
  135u,
  123u,
  232u,
  120u,
  195u,
  92u,
  21u,
  2u,
  196u,
  190u,
  116u,
  60u,
  226u,
  46u,
  139u
}; // weak
unsigned __int16 word_1D4DC8[128] =
{
  2u,
  156u,
  118u,
  107u,
  45u,
  212u,
  111u,
  162u,
  97u,
  249u,
  211u,
  3u,
  49u,
  101u,
  151u,
  223u,
  189u,
  178u,
  253u,
  204u,
  76u,
  82u,
  232u,
  65u,
  96u,
  176u,
  161u,
  47u,
  189u,
  61u,
  248u,
  107u,
  0u,
  131u,
  133u,
  113u,
  17u,
  33u,
  12u,
  111u,
  251u,
  103u,
  57u,
  148u,
  47u,
  65u,
  249u,
  143u,
  189u,
  8u,
  204u,
  230u,
  205u,
  151u,
  187u,
  227u,
  247u,
  111u,
  140u,
  6u,
  77u,
  10u,
  21u,
  149u,
  255u,
  101u,
  139u,
  150u,
  212u,
  45u,
  146u,
  95u,
  160u,
  8u,
  46u,
  254u,
  208u,
  156u,
  106u,
  34u,
  68u,
  79u,
  4u,
  53u,
  181u,
  175u,
  25u,
  192u,
  161u,
  81u,
  96u,
  210u,
  68u,
  196u,
  9u,
  150u,
  0u,
  126u,
  124u,
  144u,
  240u,
  224u,
  245u,
  146u,
  6u,
  154u,
  200u,
  109u,
  210u,
  192u,
  8u,
  114u,
  68u,
  249u,
  53u,
  27u,
  52u,
  106u,
  70u,
  30u,
  10u,
  146u,
  117u,
  251u,
  180u,
  247u,
  236u,
  108u
}; // weak
unsigned __int16 word_1D4EC8[256] =
{
  1u,
  163u,
  98u,
  40u,
  95u,
  65u,
  58u,
  202u,
  30u,
  7u,
  113u,
  172u,
  23u,
  151u,
  198u,
  149u,
  129u,
  210u,
  49u,
  20u,
  176u,
  161u,
  29u,
  101u,
  15u,
  132u,
  185u,
  86u,
  140u,
  204u,
  99u,
  203u,
  193u,
  105u,
  153u,
  10u,
  88u,
  209u,
  143u,
  179u,
  136u,
  66u,
  221u,
  43u,
  70u,
  102u,
  178u,
  230u,
  225u,
  181u,
  205u,
  5u,
  44u,
  233u,
  200u,
  218u,
  68u,
  33u,
  239u,
  150u,
  35u,
  51u,
  89u,
  115u,
  241u,
  219u,
  231u,
  131u,
  22u,
  245u,
  100u,
  109u,
  34u,
  145u,
  248u,
  75u,
  146u,
  154u,
  173u,
  186u,
  249u,
  238u,
  244u,
  194u,
  11u,
  251u,
  50u,
  183u,
  17u,
  201u,
  124u,
  166u,
  73u,
  77u,
  215u,
  93u,
  253u,
  119u,
  122u,
  97u,
  134u,
  254u,
  25u,
  220u,
  137u,
  229u,
  62u,
  83u,
  165u,
  167u,
  236u,
  175u,
  255u,
  188u,
  61u,
  177u,
  67u,
  127u,
  141u,
  110u,
  197u,
  243u,
  31u,
  170u,
  211u,
  212u,
  118u,
  216u,
  256u,
  94u,
  159u,
  217u,
  162u,
  192u,
  199u,
  55u,
  227u,
  250u,
  144u,
  85u,
  234u,
  106u,
  59u,
  108u,
  128u,
  47u,
  208u,
  237u,
  81u,
  96u,
  228u,
  156u,
  242u,
  125u,
  72u,
  171u,
  117u,
  53u,
  158u,
  54u,
  64u,
  152u,
  104u,
  247u,
  169u,
  48u,
  114u,
  78u,
  121u,
  191u,
  36u,
  214u,
  187u,
  155u,
  79u,
  27u,
  32u,
  76u,
  52u,
  252u,
  213u,
  24u,
  57u,
  39u,
  189u,
  224u,
  18u,
  107u,
  222u,
  206u,
  168u,
  142u,
  16u,
  38u,
  26u,
  126u,
  235u,
  12u,
  157u,
  148u,
  223u,
  112u,
  9u,
  182u,
  111u,
  103u,
  84u,
  71u,
  8u,
  19u,
  13u,
  63u,
  246u,
  6u,
  207u,
  74u,
  240u,
  56u,
  133u,
  91u,
  184u,
  180u,
  42u,
  164u,
  4u,
  138u,
  135u,
  160u,
  123u,
  3u,
  232u,
  37u,
  120u,
  28u,
  195u,
  174u,
  92u,
  90u,
  21u,
  82u,
  2u,
  69u,
  196u,
  80u,
  190u,
  130u,
  116u,
  147u,
  60u,
  14u,
  226u,
  87u,
  46u,
  45u,
  139u,
  41u
}; // weak
unsigned __int16 word_1D50C8[256] =
{
  2u,
  203u,
  156u,
  47u,
  118u,
  214u,
  107u,
  106u,
  45u,
  93u,
  212u,
  20u,
  111u,
  73u,
  162u,
  251u,
  97u,
  215u,
  249u,
  53u,
  211u,
  19u,
  3u,
  89u,
  49u,
  207u,
  101u,
  67u,
  151u,
  130u,
  223u,
  23u,
  189u,
  202u,
  178u,
  239u,
  253u,
  127u,
  204u,
  49u,
  76u,
  236u,
  82u,
  137u,
  232u,
  157u,
  65u,
  79u,
  96u,
  161u,
  176u,
  130u,
  161u,
  30u,
  47u,
  9u,
  189u,
  247u,
  61u,
  226u,
  248u,
  90u,
  107u,
  64u,
  0u,
  88u,
  131u,
  243u,
  133u,
  59u,
  113u,
  115u,
  17u,
  236u,
  33u,
  213u,
  12u,
  191u,
  111u,
  19u,
  251u,
  61u,
  103u,
  208u,
  57u,
  35u,
  148u,
  248u,
  47u,
  116u,
  65u,
  119u,
  249u,
  178u,
  143u,
  40u,
  189u,
  129u,
  8u,
  163u,
  204u,
  227u,
  230u,
  196u,
  205u,
  122u,
  151u,
  45u,
  187u,
  19u,
  227u,
  72u,
  247u,
  125u,
  111u,
  121u,
  140u,
  220u,
  6u,
  107u,
  77u,
  69u,
  10u,
  101u,
  21u,
  65u,
  149u,
  171u,
  255u,
  54u,
  101u,
  210u,
  139u,
  43u,
  150u,
  151u,
  212u,
  164u,
  45u,
  237u,
  146u,
  184u,
  95u,
  6u,
  160u,
  42u,
  8u,
  204u,
  46u,
  238u,
  254u,
  168u,
  208u,
  50u,
  156u,
  190u,
  106u,
  127u,
  34u,
  234u,
  68u,
  55u,
  79u,
  18u,
  4u,
  130u,
  53u,
  208u,
  181u,
  21u,
  175u,
  120u,
  25u,
  100u,
  192u,
  178u,
  161u,
  96u,
  81u,
  127u,
  96u,
  227u,
  210u,
  248u,
  68u,
  10u,
  196u,
  31u,
  9u,
  167u,
  150u,
  193u,
  0u,
  169u,
  126u,
  14u,
  124u,
  198u,
  144u,
  142u,
  240u,
  21u,
  224u,
  44u,
  245u,
  66u,
  146u,
  238u,
  6u,
  196u,
  154u,
  49u,
  200u,
  222u,
  109u,
  9u,
  210u,
  141u,
  192u,
  138u,
  8u,
  79u,
  114u,
  217u,
  68u,
  128u,
  249u,
  94u,
  53u,
  30u,
  27u,
  61u,
  52u,
  135u,
  106u,
  212u,
  70u,
  238u,
  30u,
  185u,
  10u,
  132u,
  146u,
  136u,
  117u,
  37u,
  251u,
  150u,
  180u,
  188u,
  247u,
  156u,
  236u,
  192u,
  108u,
  86u
}; // weak
_UNKNOWN unk_1D52C8; // weak
_UNKNOWN unk_1D5308; // weak
_UNKNOWN unk_1D5348; // weak
_UNKNOWN unk_1D53C8; // weak
_DWORD dword_1D5448[336] =
{
  -1562454670,
  1744311775,
  169182331,
  1461003191,
  -1864979583,
  -158901683,
  -984637618,
  1076613571,
  -533030678,
  -1661319844,
  -1714240253,
  -1701203354,
  -1265237402,
  -1974223886,
  437540533,
  832756616,
  1549443843,
  -619832934,
  179453760,
  272941447,
  -2145843940,
  496344708,
  -1377094801,
  -590485666,
  -1844200944,
  1097580290,
  358971612,
  -802702345,
  964766730,
  1350085175,
  -759227841,
  -745471935,
  224013634,
  -1870738186,
  -1667276067,
  -828915566,
  195517464,
  -1404818489,
  -697966639,
  603768419,
  57437847,
  448323742,
  2118452513,
  -1460900796,
  -1157369362,
  -94269859,
  -1298688259,
  -1753119852,
  931499594,
  791675867,
  764241706,
  -1788174341,
  -2123104630,
  1818867960,
  1181927306,
  339902400,
  -1894386491,
  -1000421443,
  -1485880203,
  -2135223921,
  -1217012142,
  -1131879250,
  503363714,
  -190601576,
  865072270,
  358851497,
  609640362,
  -1980123179,
  552464822,
  -35628420,
  1525271094,
  908870150,
  1127557582,
  1033436750,
  1962490451,
  -1488217485,
  1495266768,
  -2038346129,
  -2119328498,
  -1621436241,
  1728447911,
  1784820974,
  -1104671861,
  655866222,
  638022727,
  1058046150,
  1870569696,
  2068348614,
  -1526049523,
  -1062930358,
  -1612192879,
  -1628336489,
  -2123204986,
  -728932272,
  1096457854,
  1655760371,
  -333471748,
  2048939072,
  1762531,
  -2067139378,
  -174794929,
  -661259619,
  293482069,
  -1521171676,
  678616923,
  678362813,
  -494930568,
  -1295735537,
  -277051131,
  785598958,
  -2053931452,
  2136549611,
  929652592,
  1244734643,
  -249002402,
  1709495837,
  74914759,
  -417285807,
  -398197132,
  -1970809821,
  -1545066115,
  -225151342,
  159042525,
  -1042730853,
  -80733411,
  -535045029,
  1330193626,
  -1081959182,
  834332580,
  -4230988,
  88355341,
  1220344030,
  855420475,
  970177363,
  -1044144315,
  -1601492512,
  -49952283,
  252292855,
  305426580,
  888246338,
  28799394,
  -1779612445,
  915291113,
  1251487567,
  1662861448,
  368471200,
  1262797127,
  -5287289,
  -246760578,
  818285282,
  -977899450,
  -427004212,
  1453643172,
  13258685,
  1266982362,
  -1374142776,
  1171150707,
  -1378786256,
  1758373608,
  1730501652,
  -225650013,
  383848139,
  1476847923,
  -1701210982,
  548560927,
  2072276930,
  2142031569,
  411423136,
  -1587848910,
  -753279603,
  -1071867312,
  1186244010,
  1734557087,
  -1167391516,
  -1424373002,
  2129548811,
  -361123553,
  1948330153,
  905428457,
  -296667589,
  1521243933,
  1993560181,
  -20822470,
  24149411,
  -1346292233,
  1121494168,
  552398200,
  2036820894,
  358843201,
  -1462027542,
  1295762426,
  -2094234830,
  523976871,
  -213440740,
  888160345,
  -1703531081,
  1817067239,
  -45145646,
  965606840,
  -279357476,
  1225563021,
  -622114517,
  1238868571,
  225506152,
  -793887875,
  -2074768006,
  -253123083,
  1703868644,
  -190662496,
  1396379702,
  -1643665396,
  1525431925,
  -1835767663,
  1334372438,
  1432137819,
  1287437048,
  -1724138525,
  2073331699,
  -688596363,
  1562143602,
  682405476,
  1840461020,
  1353004140,
  1910188216,
  -220044808,
  709987600,
  862247907,
  -59384487,
  -239293412,
  -1572876733,
  1020377959,
  -1337726974,
  -900003277,
  1973496200,
  1293497471,
  1548949172,
  -1013695598,
  508393742,
  -680168327,
  1068494518,
  -137058070,
  557390526,
  159315036,
  1361519436,
  1394909990,
  -767806790,
  1243063108,
  -1378507155,
  -1505878603,
  147452591,
  -1740809853,
  1446800273,
  -1585645492,
  1298171506,
  -868294074,
  -154702328,
  -1288464337,
  1584839857,
  -1519987157,
  719766767,
  -390663162,
  919912894,
  360902260,
  1663168444,
  223265277,
  1774801908,
  -1000702553,
  643323910,
  370459006,
  385540102,
  1034915966,
  1067279144,
  -470627886,
  215128832,
  818850399,
  806147255,
  374418036,
  -1741496078,
  -667882739,
  -1694970141,
  2074002763,
  -1837502027,
  1860588031,
  -748124668,
  1464673179,
  828872422,
  -207165748,
  91556375,
  -645826895,
  -831770093,
  -2074994884,
  1654785528,
  -1278530572,
  1192576888,
  -2108406017,
  1214944035,
  123264824,
  1701142094,
  -1988297486,
  -1907325188,
  1143894065,
  -2033579056,
  -1576451856,
  1313306672,
  971939941,
  -2093418543,
  938041079,
  -1120260892,
  649238305,
  1878528769,
  -772979549,
  -404840465,
  366977163,
  -644733578,
  -151550660,
  -1102914542,
  2095884248,
  2125473707,
  -629306029,
  -559399254,
  -1815206486,
  -664206659,
  -45877670,
  -116886758,
  -621846592,
  -1525069289,
  862342551,
  1780612428,
  832091189,
  1880441307,
  -1156636950,
  -1688941075,
  -1587294054,
  1916835665,
  -1080199690,
  -496023663
}; // weak
_UNKNOWN unk_1D5988; // weak
_UNKNOWN unk_1D5A08; // weak
_UNKNOWN unk_1D5A88; // weak
_UNKNOWN unk_1D5B08; // weak
_UNKNOWN unk_1D5B88; // weak
_DWORD dword_1D5C28[8] =
{
  809079974,
  -1058647399,
  1824733714,
  -598304706,
  503320719,
  2013282877,
  -1889830782,
  -1763583214
}; // weak
_DWORD dword_1D5C48[8] =
{
  -533497832,
  1142663437,
  2134168642,
  -1819729537,
  -441926426,
  1383381748,
  646486951,
  -1709019491
}; // weak
_DWORD dword_1D5C68[8] =
{
  -1226960659,
  1895070382,
  117941204,
  471764817,
  1887059269,
  -1364032158,
  -1161161335,
  1084518206
}; // weak
_DWORD dword_1D5C88[8] =
{
  23617341,
  94469364,
  -1123431734,
  -198759640,
  340452812,
  -89674197,
  776532417,
  -1188837628
}; // weak
_DWORD dword_1D5CA8[8] =
{
  -64955950,
  877997605,
  2061009295,
  -2076674486,
  -1150427086,
  -306741048,
  -645631146,
  -1563982796
}; // weak
_DWORD dword_1D5CC8[8] =
{
  -497126719,
  -433865870,
  1549313188,
  507044583,
  2028178333,
  660104985,
  921544063,
  1882893543
}; // weak
_DWORD dword_1D5CE8[8] =
{
  -1307332699,
  -934363499,
  1314949666,
  1457019134,
  876286863,
  -789819843,
  753617026,
  -1280499192
}; // weak
_DWORD dword_1D5D08[8] =
{
  -534197825,
  1148546961,
  2123353650,
  -1788524354,
  -31908894,
  1018308325,
  1497670286,
  -1580940459
}; // weak
_DWORD dword_1D5D28[8] =
{
  -254613021,
  -1408116742,
  466314994,
  1865259977,
  2019567177,
  -1898256046,
  996910408,
  -307325664
}; // weak
_DWORD dword_1D5D48[8] =
{
  1351669111,
  756622763,
  -1268476244,
  -778937680,
  689117878,
  264262595,
  1057050380,
  -66765775
}; // weak
_DWORD dword_1D5D68[256] =
{
  -1520213050,
  -2072216328,
  -1720223762,
  -1921287178,
  234025727,
  -1117033514,
  -1318096930,
  1422247313,
  1345335392,
  50397442,
  -1452841010,
  2099981142,
  436141799,
  1658312629,
  -424957107,
  -1703512340,
  1170918031,
  -1652391393,
  1086966153,
  -2021818886,
  368769775,
  -346465870,
  -918075506,
  200339707,
  -324162239,
  1742001331,
  -39673249,
  -357585083,
  -1080255453,
  -140204973,
  -1770884380,
  1539358875,
  -1028147339,
  486407649,
  -1366060227,
  1780885068,
  1513502316,
  1094664062,
  49805301,
  1338821763,
  1546925160,
  -190470831,
  887481809,
  150073849,
  -1821281822,
  1943591083,
  1395732834,
  1058346282,
  201589768,
  1388824469,
  1696801606,
  1589887901,
  672667696,
  -1583966665,
  251987210,
  -1248159185,
  151455502,
  907153956,
  -1686077413,
  1038279391,
  652995533,
  1764173646,
  -843926913,
  -1619692054,
  453576978,
  -1635548387,
  1949051992,
  773462580,
  756751158,
  -1301385508,
  -296068428,
  -73359269,
  -162377052,
  1295727478,
  1641469623,
  -827083907,
  2066295122,
  1055122397,
  1898917726,
  -1752923117,
  -179088474,
  1758581177,
  0,
  753790401,
  1612718144,
  536673507,
  -927878791,
  -312779850,
  -1100322092,
  1187761037,
  -641810841,
  1262041458,
  -565556588,
  -733197160,
  -396863312,
  1255133061,
  1808847035,
  720367557,
  -441800113,
  385612781,
  -985447546,
  -682799718,
  1429418854,
  -1803188975,
  -817543798,
  284817897,
  100794884,
  -2122350594,
  -263171936,
  1144798328,
  -1163944155,
  -475486133,
  -212774494,
  -22830243,
  -1069531008,
  -1970303227,
  -1382903233,
  -1130521311,
  1211644016,
  83228145,
  -541279133,
  -1044990345,
  1977277103,
  1663115586,
  806359072,
  452984805,
  250868733,
  1842533055,
  1288555905,
  336333848,
  890442534,
  804056259,
  -513843266,
  -1567123659,
  -867941240,
  957814574,
  1472513171,
  -223893675,
  -2105639172,
  1195195770,
  -1402706744,
  -413311558,
  723065138,
  -1787595802,
  -1604296512,
  -1736343271,
  -783331426,
  2145180835,
  1713513028,
  2116692564,
  -1416589253,
  -2088204277,
  -901364084,
  703524551,
  -742868885,
  1007948840,
  2044649127,
  -497131844,
  487262998,
  1994120109,
  1004593371,
  1446130276,
  1312438900,
  503974420,
  -615954030,
  168166924,
  1814307912,
  -463709000,
  1573044895,
  1859376061,
  -273896381,
  -1503501628,
  -1466855111,
  -1533700815,
  937747667,
  -1954973198,
  854058965,
  1137232011,
  1496790894,
  -1217565222,
  -1936880383,
  1691735473,
  -766620004,
  -525751991,
  -1267962664,
  -95005012,
  133494003,
  636152527,
  -1352309302,
  -1904575756,
  -374428089,
  403179536,
  -709182865,
  -2005370640,
  1864705354,
  1915629148,
  605822008,
  -240736681,
  -944458637,
  1371981463,
  602466507,
  2094914977,
  -1670089496,
  555687742,
  -582268010,
  -591544991,
  -2037675251,
  -2054518257,
  -1871679264,
  1111375484,
  -994724495,
  -1436129588,
  -666351472,
  84083462,
  32962295,
  302911004,
  -1553899070,
  1597322602,
  -111716434,
  -793134743,
  -1853454825,
  1489093017,
  656219450,
  -1180787161,
  954327513,
  335083755,
  -1281845205,
  856756514,
  -1150719534,
  1893325225,
  -1987146233,
  -1483434957,
  -1231316179,
  572399164,
  -1836611819,
  552200649,
  1238290055,
  -11184726,
  2015897680,
  2061492133,
  -1886614525,
  -123625127,
  -2138470135,
  386731290,
  -624967835,
  837215959,
  -968736124,
  -1201116976,
  -1019133566,
  -1332111063,
  1999449434,
  286199582,
  -877612933,
  -61582168,
  -692339859,
  974525996
}; // weak
_DWORD dword_1D6168[256] =
{
  1667483301,
  2088564868,
  2004348569,
  2071721613,
  -218956019,
  1802229437,
  1869602481,
  -976907948,
  808476752,
  16843267,
  1734856361,
  724260477,
  -16849127,
  -673729182,
  -1414836762,
  1987505306,
  -892694715,
  -2105401443,
  -909539008,
  2105408135,
  -84218091,
  1499050731,
  1195871945,
  -252642549,
  -1381154324,
  -724257945,
  -1566416899,
  -1347467798,
  -1667488833,
  -1532734473,
  1920132246,
  -1061119141,
  -1212713534,
  -33693412,
  -1819066962,
  640044138,
  909536346,
  1061125697,
  -134744830,
  -859012273,
  875849820,
  -1515892236,
  -437923532,
  -235800312,
  1903288979,
  -656888973,
  825320019,
  353708607,
  67373068,
  -943221422,
  589514341,
  -1010590370,
  404238376,
  -1768540255,
  84216335,
  -1701171275,
  117902857,
  303178806,
  -2139087973,
  -488448195,
  -336868058,
  656887401,
  -1296924723,
  1970662047,
  151589403,
  -2088559202,
  741103732,
  437924910,
  454768173,
  1852759218,
  1515893998,
  -1600103429,
  1381147894,
  993752653,
  -690571423,
  -1280082482,
  690573947,
  -471605954,
  791633521,
  -2071719017,
  1397991157,
  -774784664,
  0,
  -303185620,
  538984544,
  -50535649,
  -1313769016,
  1532737261,
  1785386174,
  -875852474,
  -1094817831,
  960066123,
  1246401758,
  1280088276,
  1482207464,
  -808483510,
  -791626901,
  -269499094,
  -1431679003,
  -67375850,
  1128498885,
  1296931543,
  859006549,
  -2054876780,
  1162185423,
  -101062384,
  33686534,
  2139094657,
  1347461360,
  1010595908,
  -1616960070,
  -1465365533,
  1364304627,
  -1549574658,
  1077969088,
  -1886452342,
  -1835909203,
  -1650646596,
  943222856,
  -168431356,
  -1128504353,
  -1229555775,
  -623202443,
  555827811,
  269492272,
  -6886,
  -202113778,
  -757940371,
  -842170036,
  202119188,
  320022069,
  -320027857,
  1600110305,
  -1751698014,
  1145342156,
  387395129,
  -993750185,
  -1482205710,
  2122251394,
  1027439175,
  1684326572,
  1566423783,
  421081643,
  1936975509,
  1616953504,
  -2122245736,
  1330618065,
  -589520001,
  572671078,
  707417214,
  -1869595733,
  -2004350077,
  1179028682,
  -286341335,
  -1195873325,
  336865340,
  -555833479,
  1583267042,
  185275933,
  -606360202,
  -522134725,
  842163286,
  976909390,
  168432670,
  1229558491,
  101059594,
  606357612,
  1549580516,
  -1027432611,
  -741098130,
  -1397996561,
  1650640038,
  -1852753496,
  -1785384540,
  -454765769,
  2038035083,
  -404237006,
  -926381245,
  926379609,
  1835915959,
  -1920138868,
  -707415708,
  1313774802,
  -1448523296,
  1819072692,
  1448520954,
  -185273593,
  -353710299,
  1701169839,
  2054878350,
  -1364310039,
  134746136,
  -1162186795,
  2021191816,
  623200879,
  774790258,
  471611428,
  -1499047951,
  -1263242297,
  -960063663,
  -387396829,
  -572677764,
  1953818780,
  522141217,
  1263245021,
  -1111662116,
  -1953821306,
  -1970663547,
  1886445712,
  1044282434,
  -1246400060,
  1718013098,
  1212715224,
  50529797,
  -151587071,
  235805714,
  1633796771,
  892693087,
  1465364217,
  -1179031088,
  -2038032495,
  -1044276904,
  488454695,
  -1633802311,
  -505292488,
  -117904621,
  -1734857805,
  286335539,
  1768542907,
  -640046736,
  -1903294583,
  -1802226777,
  -1684329034,
  505297954,
  -2021190254,
  -370554592,
  -825325751,
  1431677695,
  673730680,
  -538991238,
  -1936981105,
  -1583261192,
  -1987507840,
  218962455,
  -1077975590,
  -421079247,
  1111655622,
  1751699640,
  1094812355,
  -1718015568,
  757946999,
  252648977,
  -1330611253,
  1414834428,
  -1145344554,
  370551866
}; // weak
_DWORD dword_1D6568[256] =
{
  1673962851,
  2096661628,
  2012125559,
  2079755643,
  -218165774,
  1809235307,
  1876865391,
  -980331323,
  811618352,
  16909057,
  1741597031,
  727088427,
  -18408962,
  -675978537,
  -1420958037,
  1995217526,
  -896580150,
  -2111857278,
  -913751863,
  2113570685,
  -84994566,
  1504897881,
  1200539975,
  -251982864,
  -1388188499,
  -726439980,
  -1570767454,
  -1354372433,
  -1675378788,
  -1538000988,
  1927583346,
  -1063560256,
  -1217019209,
  -35578627,
  -1824674157,
  642542118,
  913070646,
  1065238847,
  -134937865,
  -863809588,
  879254580,
  -1521355611,
  -439274267,
  -235337487,
  1910674289,
  -659852328,
  828527409,
  355090197,
  67636228,
  -946515257,
  591815971,
  -1013096765,
  405809176,
  -1774739050,
  84545285,
  -1708149350,
  118360327,
  304363026,
  -2145674368,
  -488686110,
  -338876693,
  659450151,
  -1300247118,
  1978310517,
  152181513,
  -2095210877,
  743994412,
  439627290,
  456535323,
  1859957358,
  1521806938,
  -1604584544,
  1386542674,
  997608763,
  -692624938,
  -1283600717,
  693271337,
  -472039709,
  794718511,
  -2079090812,
  1403450707,
  -776378159,
  0,
  -306107155,
  541089824,
  -52224004,
  -1317418831,
  1538714971,
  1792327274,
  -879933749,
  -1100490306,
  963791673,
  1251270218,
  1285084236,
  1487988824,
  -813348145,
  -793023536,
  -272291089,
  -1437604438,
  -68348165,
  1132905795,
  1301993293,
  862344499,
  -2062445435,
  1166724933,
  -102166279,
  33818114,
  2147385727,
  1352724560,
  1014514748,
  -1624917345,
  -1471421528,
  1369633617,
  -1554121053,
  1082179648,
  -1895462257,
  -1841320558,
  -1658733411,
  946882616,
  -168753931,
  -1134305348,
  -1233665610,
  -626035238,
  557998881,
  270544912,
  -1762561,
  -201519373,
  -759206446,
  -847164211,
  202904588,
  321271059,
  -322752532,
  1606345055,
  -1758092649,
  1149815876,
  388905239,
  -996976700,
  -1487539545,
  2130477694,
  1031423805,
  1690872932,
  1572530013,
  422718233,
  1944491379,
  1623236704,
  -2129028991,
  1335808335,
  -593264676,
  574907938,
  710180394,
  -1875137648,
  -2012511352,
  1183631942,
  -288937490,
  -1200893000,
  338181140,
  -559449634,
  1589437022,
  185998603,
  -609388837,
  -522503200,
  845436466,
  980700730,
  169090570,
  1234361161,
  101452294,
  608726052,
  1555620956,
  -1029743166,
  -742560045,
  -1404833876,
  1657054818,
  -1858492271,
  -1791908715,
  -455919644,
  2045938553,
  -405458201,
  -930397240,
  929978679,
  1843050349,
  -1929278323,
  -709794603,
  1318900302,
  -1454776151,
  1826141292,
  1454176854,
  -185399308,
  -355523094,
  1707781989,
  2062847610,
  -1371018834,
  135272456,
  -1167075910,
  2029029496,
  625635109,
  777810478,
  473441308,
  -1504185946,
  -1267480652,
  -963161658,
  -389340184,
  -576619299,
  1961401460,
  524165407,
  1268178251,
  -1117659971,
  -1962047861,
  -1978694262,
  1893765232,
  1048330814,
  -1250835275,
  1724688998,
  1217452104,
  50726147,
  -151584266,
  236720654,
  1640145761,
  896163637,
  1471084887,
  -1184247623,
  -2045275770,
  -1046914879,
  490350365,
  -1641563746,
  -505857823,
  -118811656,
  -1741966440,
  287453969,
  1775418217,
  -643206951,
  -1912108658,
  -1808554092,
  -1691502949,
  507257374,
  -2028629369,
  -372694807,
  -829994546,
  1437269845,
  676362280,
  -542803233,
  -1945923700,
  -1587939167,
  -1995865975,
  219813645,
  -1083843905,
  -422104602,
  1115997762,
  1758509160,
  1099088705,
  -1725321063,
  760903469,
  253628687,
  -1334064208,
  1420360788,
  -1150429509,
  371997206
}; // weak
_DWORD dword_1D6968[256] =
{
  -962239645,
  -125535108,
  -291932297,
  -158499973,
  -15863054,
  -692229269,
  -558796945,
  -1856715323,
  1615867952,
  33751297,
  -827758745,
  1451043627,
  -417726722,
  -1251813417,
  1306962859,
  -325421450,
  -1891251510,
  530416258,
  -1992242743,
  -91783811,
  -283772166,
  -1293199015,
  -1899411641,
  -83103504,
  1106029997,
  -1285040940,
  1610457762,
  1173008303,
  599760028,
  1408738468,
  -459902350,
  -1688485696,
  1975695287,
  -518193667,
  1034851219,
  1282024998,
  1817851446,
  2118205247,
  -184354825,
  -2091922228,
  1750873140,
  1374987685,
  -785062427,
  -116854287,
  -493653647,
  -1418471208,
  1649619249,
  708777237,
  135005188,
  -1789737017,
  1181033251,
  -1654733885,
  807933976,
  933336726,
  168756485,
  800430746,
  235472647,
  607523346,
  463175808,
  -549592350,
  -853087253,
  1315514151,
  2144187058,
  -358648459,
  303761673,
  496927619,
  1484008492,
  875436570,
  908925723,
  -592286098,
  -1259447718,
  1543217312,
  -1527360942,
  1984772923,
  -1218324778,
  2110698419,
  1383803177,
  -583080989,
  1584475951,
  328696964,
  -1493871789,
  -1184312879,
  0,
  -1054020115,
  1080041504,
  -484442884,
  2043195825,
  -1225958565,
  -725718422,
  -1924740149,
  1742323390,
  1917532473,
  -1797371318,
  -1730917300,
  -1326950312,
  -2058694705,
  -1150562096,
  -987041809,
  1340451498,
  -317260805,
  -2033892541,
  -1697166003,
  1716859699,
  294946181,
  -1966127803,
  -384763399,
  67502594,
  -25067649,
  -1594863536,
  2017737788,
  632987551,
  1273211048,
  -1561112239,
  1576969123,
  -2134884288,
  92966799,
  1068339858,
  566009245,
  1883781176,
  -251333131,
  1675607228,
  2009183926,
  -1351230758,
  1113792801,
  540020752,
  -451215361,
  -49351693,
  -1083321646,
  -2125673011,
  403966988,
  641012499,
  -1020269332,
  -1092526241,
  899848087,
  -1999879100,
  775493399,
  -1822964540,
  1441965991,
  -58556802,
  2051489085,
  -928226204,
  -1159242403,
  841685273,
  -426413197,
  -1063231392,
  429425025,
  -1630449841,
  -1551901476,
  1147544098,
  1417554474,
  1001099408,
  193169544,
  -1932900794,
  -953553170,
  1809037496,
  675025940,
  -1485185314,
  -1126015394,
  371002123,
  -1384719397,
  -616832800,
  1683370546,
  1951283770,
  337512970,
  -1831122615,
  201983494,
  1215046692,
  -1192993700,
  -1621245246,
  -1116810285,
  1139780780,
  -995728798,
  967348625,
  832869781,
  -751311644,
  -225740423,
  -718084121,
  -1958491960,
  1851340599,
  -625513107,
  25988493,
  -1318791723,
  -1663938994,
  1239460265,
  -659264404,
  -1392880042,
  -217582348,
  -819598614,
  -894474907,
  -191989126,
  1206496942,
  270010376,
  1876277946,
  -259491720,
  1248797989,
  1550986798,
  941890588,
  1475454630,
  1942467764,
  -1756248378,
  -886839064,
  -1585652259,
  -392399756,
  1042358047,
  -1763882165,
  1641856445,
  226921355,
  260409994,
  -527404944,
  2084716094,
  1908716981,
  -861247898,
  -1864873912,
  100991747,
  -150866186,
  470945294,
  -1029480095,
  1784624437,
  -1359390889,
  1775286713,
  395413126,
  -1722236479,
  975641885,
  666476190,
  -650583583,
  -351012616,
  733190296,
  573772049,
  -759469719,
  -1452221991,
  126455438,
  866620564,
  766942107,
  1008868894,
  361924487,
  -920589847,
  -2025206066,
  -1426107051,
  1350051880,
  -1518673953,
  59739276,
  1509466529,
  159418761,
  437718285,
  1708834751,
  -684595482,
  -2067381694,
  -793221016,
  -2101132991,
  699439513,
  1517759789,
  504434447,
  2076946608,
  -1459858348,
  1842789307,
  742004246
}; // weak
_QWORD qword_1D6D68[256] =
{
  -4132730006030503226LL,
  -539047019380510728LL,
  -1253751459939328274LL,
  -680615785620800778LL,
  -68146532174010113LL,
  -2973018020288656682LL,
  -2399952645993785634LL,
  -7974685284245934703LL,
  6940259164160561248LL,
  144964032577996546LL,
  -3555161031839830322LL,
  6232327157277249878LL,
  -1794168595447821081LL,
  -5376610045693389899LL,
  5613343524669979725LL,
  -1397589549593044500LL,
  -8123079965105241969LL,
  2278045966340498207LL,
  -8556828570679228023LL,
  -394083029752846086LL,
  -1218851249403735825LL,
  -5554205910300715854LL,
  -8157981275169173874LL,
  -356931036449478917LL,
  4750314849306635841LL,
  -5519304651777172813LL,
  6916893634425799519LL,
  5037991028614062149LL,
  2575855417214826787LL,
  6050487156059820371LL,
  -1975158695585036828LL,
  -7252152277477263717LL,
  8485602336333178997LL,
  -2225665366713645599LL,
  4444625026341786685LL,
  5506381438015959628LL,
  7807791422239572588LL,
  9097830637817281918LL,
  -791805576357678091LL,
  -8984929946756361597LL,
  7520115157031488616LL,
  5905523166432155217LL,
  -3371866415327048239LL,
  -501895069027474951LL,
  -2120105058666394398LL,
  -6092440566617522517LL,
  7085223196738557794LL,
  3044244512336603946LL,
  579856130311986184LL,
  -7687026679944420459LL,
  5072615240255924550LL,
  -7107205905805836387LL,
  3470129582080280624LL,
  4008607157484834615LL,
  724820128529718026LL,
  3437758089523424047LL,
  1011370493763851534LL,
  2609352586403937828LL,
  1989243818338594075LL,
  -2360548904282908449LL,
  -3664098953908279347LL,
  5650219536259741006LL,
  9209296418857825151LL,
  -1540284147086765846LL,
  1304676293201968914LL,
  2134207842326520861LL,
  6373913558653912152LL,
  3760057578515744308LL,
  3903895711119786294LL,
  -2543790735647501860LL,
  -5409259478498828876LL,
  6628091486423895387LL,
  -6559964539331172956LL,
  8524730079150317942LL,
  -5232771947449609033LL,
  9065458294843847805LL,
  5943525060815740754LL,
  -2504387036886949923LL,
  6805427853385256286LL,
  1411639487974519059LL,
  -6416126415317196122LL,
  -5086699538363186759LL,
  0LL,
  -4527074801173088831LL,
  4638849042495889472LL,
  -2080701368495914269LL,
  8775530246867991161LL,
  -5265421354484852042LL,
  -3116856144302633516LL,
  -8266918097709283443LL,
  7483239239932450663LL,
  8235927982688808818LL,
  -7719676112749859436LL,
  -7434269359936634984LL,
  -5699169934288645200LL,
  -8842235271952049275LL,
  -4941735505785190725LL,
  -4239416128151045179LL,
  5757181648683957071LL,
  -1362689382007777299LL,
  -8735550249359846778LL,
  -7289305370308970342LL,
  7374025361920596326LL,
  1266675498346853905LL,
  -8444513962316611446LL,
  -1652599854977721879LL,
  289928065155993092LL,
  -107550273884887298LL,
  -6849874926400459872LL,
  8666316343085937784LL,
  2718567606894587941LL,
  5468379569402574155LL,
  -6704910902412530526LL,
  6773055510411822173LL,
  -9169298760443110528LL,
  399143085646643205LL,
  4588463150355764031LL,
  2430891427587161633LL,
  8090963950110812272LL,
  -1079464180659192335LL,
  7196688960598972771LL,
  8629440425986895735LL,
  -5803655993621532497LL,
  4783813075073886018LL,
  2319424521247944736LL,
  -1938006693691601947LL,
  -211984664778051587LL,
  -4652951001509721921LL,
  -9129893944974092927LL,
  1735064791040140312LL,
  2753190719007979814LL,
  -4382110802955357501LL,
  -4692355842748938562LL,
  3864769067831117877LL,
  -8589477951944276088LL,
  3330794877570737454LL,
  -7829721286028203373LL,
  6193199414460110933LL,
  -251388363538603524LL,
  8811280341303669626LL,
  -3986657708614932536LL,
  -4978888598616897350LL,
  3615093614658277170LL,
  -1831320571571059994LL,
  -4566478517113766976LL,
  1844279794350664217LL,
  -7002772614441011554LL,
  -6665506112713710941LL,
  4928777107651882564LL,
  6088489024673207892LL,
  4299661002353859899LL,
  829531626435155211LL,
  -8301819364822890100LL,
  -4095578029907264313LL,
  7769789553626187115LL,
  2899280514118872104LL,
  -6378973339665617753LL,
  -4836193932402654788LL,
  1593478389663478038LL,
  -5947494126225573971LL,
  -2649333408558377253LL,
  7230187229316554340LL,
  8380891946546275956LL,
  1449640257059436052LL,
  -7864622544551746414LL,
  867532395520070156LL,
  5218705172807875656LL,
  -5123852588244561992LL,
  -6963367773201794913LL,
  -4796789134113763395LL,
  4895278838934300995LL,
  -4276568130044480060LL,
  4154696978365930041LL,
  3577092819803162161LL,
  -3226902417109316909LL,
  -969400341436664590LL,
  -3084207811025533995LL,
  -8411864538101231989LL,
  7951629520483353966LL,
  -2686485401861744422LL,
  111466906339216897LL,
  -5664268649994904143LL,
  -7146610704094727780LL,
  5323415545414644297LL,
  -2831449391489409064LL,
  -5982395393339180628LL,
  -934500182441461005LL,
  -3520260821304237873LL,
  -3841693718987267894LL,
  -824453909634777612LL,
  5181829118267778887LL,
  1159712260623972368LL,
  8058591632907570031LL,
  -1114364365424593936LL,
  5363669171025607498LL,
  6661589755141474908LL,
  4045481975055406136LL,
  6337037504113827671LL,
  8342890077932888435LL,
  -7543188581700639593LL,
  -3809045394300227893LL,
  -6810470110931442271LL,
  -1685248136714430488LL,
  4476996269786750270LL,
  -7575837988735882602LL,
  7051724970971307617LL,
  974495581702560781LL,
  1118333705716538127LL,
  -2265069082654323744LL,
  8953992539573500540LL,
  8197926088305223281LL,
  -3698999121493546548LL,
  -8009586568539675760LL,
  433766197760035078LL,
  -647967478113897225LL,
  2022740987527703068LL,
  -4421514493125837630LL,
  7665079155249220458LL,
  -5838557303685464402LL,
  7624825529638257257LL,
  1698189836028526359LL,
  -7397116310055259751LL,
  4190445973273137978LL,
  2862405696548304679LL,
  -2794297441136373287LL,
  -1507635822399725845LL,
  3148956010242041131LL,
  2464388553825941282LL,
  -3261802576104520494LL,
  -6237404599195518551LL,
  542981175300359943LL,
  3722056809430827315LL,
  3293919965509446701LL,
  4333158171542968892LL,
  1554351746374809621LL,
  -3954009426878223927LL,
  -8698397173708268409LL,
  -6125089990832901974LL,
  5798561028237744208LL,
  -6522811437909398619LL,
  256430895966882051LL,
  6483127462435965529LL,
  684567602447225353LL,
  1880028789257872154LL,
  7339401150278733925LL,
  -2940369712781753129LL,
  -8879388373373823612LL,
  -3406766600092449840LL,
  -9024334736455181182LL,
  3003991986254111273LL,
  6518877556871643994LL,
  2166579085771484446LL,
  8920494270855921019LL,
  -6270053980460566616LL,
  7914753508893592685LL,
  3186956779326956076LL
}; // weak
_QWORD qword_1D7568[256] =
{
  -6514469342364383546LL,
  -8868828445443884808LL,
  -7365724491405660434LL,
  -8216944455539034378LL,
  1001231837162962943LL,
  -4776106171804494122LL,
  -5645322941993918754LL,
  6069159414800945553LL,
  5818914948986724448LL,
  217304192548012546LL,
  -6230764539228533042LL,
  9055761923954529878LL,
  1861441408096593895LL,
  7093633830708557237LL,
  -1830095433830216371LL,
  -7294787295337911060LL,
  4973609262237388687LL,
  -7116042975538110689LL,
  4614430677554268553LL,
  -8651535248180839686LL,
  1568729405706006511LL,
  -1477419361347784014LL,
  -3961126114129178994LL,
  859375037481155579LL,
  -1404507442331631295LL,
  7457302820679234483LL,
  -162660663112278177LL,
  -1546381834468702907LL,
  -4663799846548200669LL,
  -601790240288320685LL,
  -7578536079611534108LL,
  6570168410485201819LL,
  -4401602596433267339LL,
  2078732406302826977LL,
  -5874125826494808771LL,
  7681098530159742028LL,
  6546244132699008108LL,
  4754889993820667518LL,
  211957263239476725LL,
  5700942844065383299LL,
  6688096534267717736LL,
  -819083437551496879LL,
  3799169140624576977LL,
  642070844933274105LL,
  -7791316881019968798LL,
  8308461211226123179LL,
  6036219141534736994LL,
  4563344062369442346LL,
  869216770192050184LL,
  5922785821150385557LL,
  7317416345848071750LL,
  6782951410951495069LL,
  2909457474493362224LL,
  -6814235811617229001LL,
  1086512166512298506LL,
  -5377644620061921489LL,
  656429371612270094LL,
  3911475465864225828LL,
  -7262416569187362021LL,
  4442034935990640607LL,
  2774615558667619789LL,
  7610163533148671566LL,
  -3603358207219368065LL,
  -6931116106311472406LL,
  1955737732932112914LL,
  -7045114575697208035LL,
  8408392528960968792LL,
  3344048267133858868LL,
  3273122066349504054LL,
  -5574385745926169380LL,
  -1264620967483820876LL,
  -309034256761529509LL,
  -697211361211079516LL,
  5615099564754302582LL,
  7022698833697355703LL,
  -3532429807378465411LL,
  8909401524646400594LL,
  4512961136775126493LL,
  8195587537927757406LL,
  -7555172552714153197LL,
  -768139761052113242LL,
  7523747412402354617LL,
  0LL,
  3213727543391011265LL,
  6953734161536401472LL,
  2296027802622944227LL,
  -3967033794359559815LL,
  -1335549367324854602LL,
  -4705177771963460396LL,
  5044535463021874573LL,
  -2752138243085998233LL,
  5468739165446173298LL,
  -2435468977041992556LL,
  -3158316551694739304LL,
  -1694721354838593360LL,
  5337291446550234501LL,
  7741051604950236091LL,
  3067371542195979717LL,
  -1901023833671119025LL,
  1639655606490492397LL,
  -4244830917265029498LL,
  -2941023354431694182LL,
  6182597133298394726LL,
  -7772465749977329391LL,
  -3526517729034990966LL,
  1209550821022886377LL,
  434608385096025092LL,
  -9086126040821596418LL,
  -1127294156110323552LL,
  4967694984853878904LL,
  -5022967435948448475LL,
  -2047379834866939061LL,
  -909992162619514206LL,
  -91732263271375523LL,
  -4603985312323239808LL,
  -8499834516716649211LL,
  -5945054226335711425LL,
  -4881093043811376863LL,
  5251434972898160752LL,
  358330856890036721LL,
  -2322033457618132125LL,
  -4472539792500885641LL,
  8450335603361361839LL,
  7171038354084414018LL,
  3476867080768200736LL,
  1932376405107795429LL,
  1072158037947448829LL,
  7882908404632043455LL,
  5483647447745266049LL,
  1454728737246681112LL,
  3840549265079871014LL,
  3431022939711128515LL,
  -2204730952607416642LL,
  -6743298615549610699LL,
  -3743810926298036088LL,
  4133261267469413934LL,
  6286454811121062803LL,
  -960940237233040043LL,
  -9015188844753847044LL,
  5184990381174127226LL,
  -6013449351397390136LL,
  -1770140159966659910LL,
  3126761667041374770LL,
  -7649464479452567834LL,
  -6873623737422593856LL,
  -7479718562678302439LL,
  -3375614147072450914LL,
  9177634000278299555LL,
  7388342546632426564LL,
  9126688124738884692LL,
  -6091427819984962757LL,
  -9000832517114885365LL,
  -3890188918061429620LL,
  2996436545184778183LL,
  -3182234232327672981LL,
  4346048666049194024LL,
  8743047605751949223LL,
  -2133793756539667268LL,
  2102098132240242198LL,
  8521261804145847725LL,
  4300178136308833243LL,
  6253523334082749540LL,
  5686025765538657396LL,
  2173024333024597012LL,
  -2648267370905955694LL,
  727364368623340556LL,
  7822950931728451656LL,
  -1987433357229705032LL,
  6712025210167009183LL,
  7953834605416529341LL,
  -1187214245068455101LL,
  -6443540942523349820LL,
  -6308729813475903175LL,
  -6601441815868067535LL,
  4016464536944694227LL,
  -8358814449561963790LL,
  3652795546974016981LL,
  4831734870102150027LL,
  6475309135687937646LL,
  -5210732149353162022LL,
  -8357960124579577599LL,
  7240007424359117233LL,
  -3304676951004701540LL,
  -2264681828357879479LL,
  -5428025346616207144LL,
  -413462576937456468LL,
  575626253210153971LL,
  2703689357883133903LL,
  -5796156154134345014LL,
  -8146016055698000652LL,
  -1617319030536321209LL,
  1738433540384100368LL,
  -3035878231131852945LL,
  -8576116443052773136LL,
  8040246328048699978LL,
  8266522534938827868LL,
  2625717486449080376LL,
  -1031877433300658345LL,
  -4042452599488547981LL,
  5851850824139184023LL,
  2561814965747895243LL,
  8960338603958182305LL,
  -7148409303574517528LL,
  2412912495415868990LL,
  -2506397376883026282LL,
  -2539326654881308319LL,
  -8783548116078162675LL,
  -8854476515919065329LL,
  -8008618874510778144LL,
  4825824990831737980LL,
  -4259745796751724175LL,
  -6159827343160783668LL,
  -2865569364396765040LL,
  363682184311670278LL,
  141022266228275191LL,
  1312858743224540188LL,
  -6656321743931784510LL,
  6905391930587966058LL,
  -484399773005205842LL,
  -3399536225818613399LL,
  -7985259745726490857LL,
  6352864217937320345LL,
  2843012882769328698LL,
  -5093904632016066777LL,
  4082873943760951769LL,
  1426855013570767851LL,
  -5524000621257741525LL,
  3694171273316213282LL,
  -4917976165827423534LL,
  8091157018678241705LL,
  -8570771712784267513LL,
  -6384148618604891341LL,
  -5306716220221018835LL,
  2483847492426939452LL,
  -7914322549658872555LL,
  2344510773200013769LL,
  5266356449539032967LL,
  -49791387911017814LL,
  8692097332098388048LL,
  8813982602763150757LL,
  -8140666927316401405LL,
  -526336250252469927LL,
  -9218134510605825783LL,
  1672024133566929434LL,
  -2681201047018379931LL,
  3581860549962815447LL,
  -4173902517423995772LL,
  -5135278159318232880LL,
  -4386683318832430462LL,
  -5741302614748681943LL,
  8625687925281217114LL,
  1241923746213469726LL,
  -3749731800868619397LL,
  -267084585174062936LL,
  -2964949831290950291LL,
  4204196264480484396LL
}; // weak
_QWORD qword_1D7D68[256] =
{
  -7497185011422542171LL,
  -1470560967359661948LL,
  -4057574281474806119LL,
  -608956215103916403LL,
  -1939066718215209203LL,
  -5198071117120088387LL,
  -6356635401098174799LL,
  4178307997439725908LL,
  -4544043029872222128LL,
  289641071162556931LL,
  -8655731703483019607LL,
  -6014700755043854723LL,
  -3086345443720304871LL,
  8189341437854594402LL,
  -7335829217796600346LL,
  -4344396161840517990LL,
  418630046812442437LL,
  4520661559489273757LL,
  702632736481446208LL,
  -1183734689148765561LL,
  -4233641760872468715LL,
  9162269042867876587LL,
  522638836955516617LL,
  -1360919289338791157LL,
  -9065767836416130580LL,
  9054882501800211303LL,
  -4747641609324109827LL,
  -8492124076087360022LL,
  5105604074781483967LL,
  -6484348924133682185LL,
  -3197108641049811818LL,
  3309402376642468699LL,
  -1558876190633790014LL,
  -2800082124053290724LL,
  8856802461512187310LL,
  -7440392166028063638LL,
  -2815212736623121318LL,
  -233270446739521983LL,
  -1079172831822613246LL,
  2148586257683546959LL,
  -3394486082452559780LL,
  -6771175202378133004LL,
  -5090135906714529484LL,
  -1650560360467793656LL,
  -2328761580480437613LL,
  5590501597289098099LL,
  -4254401958709665197LL,
  6071203322875488831LL,
  1158564284650227724LL,
  3600156170315470162LL,
  -8309310981267896731LL,
  2441618274884885854LL,
  6951350521918664744LL,
  7996319228396779425LL,
  1445953521505143311LL,
  6828782792364470197LL,
  2025222469355179529LL,
  5213539280926024758LL,
  3942509732700035995LL,
  -6537188956388204739LL,
  -9121435855761847002LL,
  -7153007327152550295LL,
  -122497362680643635LL,
  -3478292139619980641LL,
  2606769640463012379LL,
  4231587845050801566LL,
  -5720569210009528204LL,
  7526128995628495918LL,
  7815765668543215149LL,
  -6643457281463886670LL,
  8298425650913785070LL,
  -5325793436113347589LL,
  5981332267059160310LL,
  -1380549172243564979LL,
  8476726276696553313LL,
  -411571077119115826LL,
  -6589474830505848197LL,
  -6826825629269369538LL,
  -4858414693382988175LL,
  2783954244679701399LL,
  6270405981464078069LL,
  7617953909209413992LL,
  0LL,
  -7389232208830938836LL,
  -9178229796507729824LL,
  -2512692887231929569LL,
  -989727302021973560LL,
  8587499365318702829LL,
  -5487144831525006146LL,
  128993373931277638LL,
  -3571115429052586023LL,
  -1955323247705558453LL,
  3709240383374660830LL,
  3127702009367009492LL,
  8873190930349338856LL,
  1287548862353212746LL,
  7907594980338416491LL,
  -7962880367339911894LL,
  -7046755503358128155LL,
  -4523278433753633514LL,
  1681185529015994053LL,
  3414528287577905879LL,
  -3675124214632389035LL,
  2497127966435250580LL,
  1101920978810342095LL,
  -3949639071203464944LL,
  579282142325113862LL,
  -1758513162925179263LL,
  6560601215109996784LL,
  -1095424963366062012LL,
  5392421556865803706LL,
  -7620403662068954141LL,
  6849679327628534515LL,
  -5036715323762582018LL,
  1971380762661912768LL,
  758164418264892810LL,
  9145876175950659501LL,
  4818777796537033148LL,
  -2244964318868115384LL,
  -501021004698357500LL,
  -4144754791536172065LL,
  -1272054310234523711LL,
  5016857836491091829LL,
  -8888588725345172893LL,
  4634257138600910896LL,
  -3373730282562263782LL,
  -2228703391096374002LL,
  7329447551461998445LL,
  1861197020862185804LL,
  3475675260959332372LL,
  5503175953840743989LL,
  -7101842972009577681LL,
  7437942417497439969LL,
  7709497347997513122LL,
  815094700599445708LL,
  6650472270725525049LL,
  4465697234261087063LL,
  -6193027773434079758LL,
  -2045335043290891134LL,
  -808035726511146425LL,
  -8363275839839090516LL,
  8012720891273853671LL,
  7240991593081221675LL,
  -2908034926644894059LL,
  -7206989777776623456LL,
  3653431620147943832LL,
  2839749813801492177LL,
  6737806710131630975LL,
  -8598947654182615962LL,
  -6304337427958573954LL,
  8567724349161421739LL,
  1629884832283298691LL,
  235816956589804746LL,
  -7675495528497952983LL,
  -2995224232664011821LL,
  5783814086020573244LL,
  6164154153643255673LL,
  7151120537131728098LL,
  3181543715925005853LL,
  4727221163609927030LL,
  -5959041527511786693LL,
  -3964760887547108266LL,
  -1670185845158284210LL,
  2891907043010286622LL,
  4573083775328752347LL,
  1737837630479666186LL,
  -8019665511857502100LL,
  7725894613062957284LL,
  2731254947766050653LL,
  7039810878580833646LL,
  -8778941558171679761LL,
  -7786258725827459930LL,
  8278646236609329576LL,
  7131349919053459876LL,
  -4802746669893168329LL,
  -34186537554742645LL,
  -5668287733838785230LL,
  992273807610448707LL,
  -2527827897747607975LL,
  -5781856927321761097LL,
  184520657936122252LL,
  8767493264978850148LL,
  2552927933435780306LL,
  -7909481774621046304LL,
  -6068683205532657484LL,
  4834044746268454138LL,
  -213631767876996345LL,
  -8831799182880682203LL,
  -8076449561628194129LL,
  -898029929508834162LL,
  -8205302195688093719LL,
  2317128569300455448LL,
  -2421576073953185835LL,
  -323264650073280376LL,
  -7732276275002586513LL,
  -5145799532258501518LL,
  8100889877420718116LL,
  -5906205893034813455LL,
  -1850197341333392441LL,
  3887541009157429073LL,
  -8258155422082675933LL,
  6450417473310269820LL,
  -3765118417830877028LL,
  8963044394047258145LL,
  3998314097779578589LL,
  -4431581069780622884LL,
  1914459276555652486LL,
  2203532990994124677LL,
  -2617839692998975344LL,
  -520655285615035326LL,
  -2137023619577843260LL,
  -8942553583848731478LL,
  4284005662810214616LL,
  868918815239833093LL,
  -791787992980654335LL,
  4050444938710359058LL,
  -6917911665258085725LL,
  -3107096845597644193LL,
  5120866626634166009LL,
  -3284302345216103984LL,
  3362097275778570129LL,
  3019761305513466200LL,
  8388279114275633703LL,
  5679243437265070009LL,
  -6248682598640789192LL,
  -3659998000074462445LL,
  6255134633653644211LL,
  4923898209763467827LL,
  -4623301439570914629LL,
  5300860526160095600LL,
  1044986298664159113LL,
  7418176197297910695LL,
  6539709077925998006LL,
  8675659555171744802LL,
  3075275395379303826LL,
  -8547796493211678432LL,
  1574933701195171657LL,
  5700148768488991487LL,
  -6879115901668405128LL,
  5876769314801296762LL,
  471346936180573071LL,
  -5614871548665439752LL,
  1340806719731206528LL,
  3763064497814247959LL,
  -3857937309451852326LL,
  -5380902894996826319LL,
  1392111814611076294LL,
  -4912379552089452360LL,
  2260458875180450499LL,
  5966056521101552048LL,
  -5433179973154612617LL,
  4337829777585872401LL,
  -700649189469881397LL,
  5413322490278095100LL,
  -2710649788391658026LL,
  6363087431850011706LL
}; // weak
_QWORD qword_1D8568[256] =
{
  -817979258377427561LL,
  -7528726169882426133LL,
  -5721347929815475769LL,
  -8318838476926185993LL,
  1661010127064337893LL,
  -2540632675654910537LL,
  -3985184194692206169LL,
  -264308930584161223LL,
  -1130139003587112768LL,
  361137922776367876LL,
  -2258027246506825337LL,
  -8683635173334024788LL,
  3105561577112672725LL,
  -6457416312112717199LL,
  3595615762444576410LL,
  -5360773008599508285LL,
  -3511172458272045819LL,
  -4855517414447669954LL,
  -4593460197845286903LL,
  -7888175242731157521LL,
  4545609565511554501LL,
  2804377613063351167LL,
  4668333744645392647LL,
  2092799329750944749LL,
  3453187164874075266LL,
  -6239832826549409923LL,
  2088856877858291134LL,
  2732037219362925194LL,
  -2684186089318269114LL,
  213642055637006246LL,
  -6803072865531554093LL,
  -1343218970167387347LL,
  6756064819359892202LL,
  2601995117030087897LL,
  -1608090919154897286LL,
  -4725754911100474728LL,
  -1271441700846544168LL,
  -4377002144188972548LL,
  432916159054283505LL,
  -3364240244298526947LL,
  -1991465643506377520LL,
  573091119895803042LL,
  6644037114458617017LL,
  1731661415564511465LL,
  -5867154244286376993LL,
  -7677628843335912627LL,
  -769001080810744892LL,
  4701548464522805076LL,
  1444551691105471504LL,
  -697224084717219279LL,
  -5808042727983127156LL,
  -2135020135593976287LL,
  8658302535061219424LL,
  -530869712184696466LL,
  1229220031125655316LL,
  -4272292157103032994LL,
  1948118091058514204LL,
  6500482609974621768LL,
  -5288432482816124106LL,
  5133337872188784037LL,
  7648918286080222849LL,
  -4942212453807265380LL,
  5534163301174332926LL,
  -4999072204656566321LL,
  3250241304987310884LL,
  -5071412015858344390LL,
  -7172935939384642384LL,
  8227639215101587048LL,
  8587651186431503724LL,
  -3624609273476238685LL,
  3021398157330542195LL,
  1655941809489836982LL,
  141302249252255315LL,
  -2932450693871153684LL,
  -6673873863409442443LL,
  5318268699763658490LL,
  -8251845901927941212LL,
  4773325909448801953LL,
  -7822308567505014340LL,
  -6730732236668954842LL,
  357196842072995159LL,
  -5158671055602489239LL,
  0LL,
  8371194131363474585LL,
  -6890330544865779584LL,
  2386663448460337117LL,
  4884227714308491506LL,
  3237292750151282039LL,
  -2756527268475650381LL,
  -3871184421012027903LL,
  8131653848015559118LL,
  -2500661422465070108LL,
  8781590384726040115LL,
  7481719228443710507LL,
  2587357103155898491LL,
  -2428884564349466095LL,
  -4797533141416055955LL,
  9091218142742784657LL,
  3811510363855250846LL,
  4185597602771572417LL,
  6108381732774790423LL,
  7122270155594979119LL,
  -47851186704460340LL,
  -6371283172410158046LL,
  5390609469804302095LL,
  3463321825938313417LL,
  722275845552735752LL,
  -7457511939816652313LL,
  860200360589979739LL,
  -3727629516068600592LL,
  -3045886970570622390LL,
  4531534323560211350LL,
  1077220870497432415LL,
  1872962276447616698LL,
  6611385251291775003LL,
  -8824093734992508406LL,
  -1392196317744222850LL,
  -2324737025059472318LL,
  -2861799345241437984LL,
  865831313187341561LL,
  8853929641893945286LL,
  6395489906733859310LL,
  -6956479017949104827LL,
  -6529192622089411708LL,
  5778206764421886016LL,
  3322019128409397969LL,
  1300998164324355809LL,
  -5229322344102662811LL,
  -3148908575728776167LL,
  4329151267530609712LL,
  6860494581304538444LL,
  8155862462793723805LL,
  4098619287260815719LL,
  -170294799558663574LL,
  5750058542653033483LL,
  5420446524455663964LL,
  -479640599153912003LL,
  1004880339897021098LL,
  -7096937018600684829LL,
  -3942961176048416780LL,
  -1176302448499184501LL,
  3667955984346310511LL,
  9019440457837587300LL,
  -6587178272710814249LL,
  -314975739860442981LL,
  -5505453001313511374LL,
  7552933458509484327LL,
  -9115425135000322211LL,
  -6168054699313043832LL,
  -9043647144663941464LL,
  -1825111386112677002LL,
  -7024596630795222250LL,
  5028908665861360131LL,
  8874760591446059413LL,
  7985847533814141910LL,
  4916880124502621264LL,
  -8396527006347986603LL,
  4459194208476783203LL,
  2818452033581227308LL,
  -7316490980689086911LL,
  5565127074875390893LL,
  -407863158034377016LL,
  -3292462665201070360LL,
  2458440062251310632LL,
  8564569840458849087LL,
  2164575633765304856LL,
  -5445778853760308080LL,
  4027405057195041899LL,
  -1775008172853994203LL,
  -5589334306842644895LL,
  3093738100615278470LL,
  -1033873851198167405LL,
  -2042131904610064270LL,
  -602084019559881630LL,
  6428705445888866237LL,
  -8751753614014116865LL,
  6211121960325558961LL,
  -4232322283658853619LL,
  -1487899243553334820LL,
  -4415847497606711377LL,
  -8102943789481358334LL,
  -6024501157979659143LL,
  7913508379725451811LL,
  4314513805062824082LL,
  -4056398424757979989LL,
  1583602106184301123LL,
  650499644617590781LL,
  8008930248820204933LL,
  -1535751521347915889LL,
  -8534733069746925837LL,
  2371462306736892302LL,
  2889103382210943008LL,
  7265823574109181406LL,
  -8968774123921569541LL,
  -5661110513740124268LL,
  -7605851024798223688LL,
  7792472364234056816LL,
  644305427270988206LL,
  5964826535099877350LL,
  -913681636013944523LL,
  7287780423433397133LL,
  -8900093466430571431LL,
  -4639623131807834933LL,
  7143099736113684860LL,
  8997484977546779959LL,
  9213378706152742082LL,
  -7960515191910857190LL,
  -7744620590500182754LL,
  -6084174754193829669LL,
  -4160544601482181896LL,
  6324275599358674146LL,
  -1897452325290857853LL,
  8347549330551396411LL,
  1082287816882652428LL,
  216458607757558261LL,
  3896236182117028408LL,
  -97955229952990305LL,
  -2206797303486193708LL,
  1223027184968333639LL,
  7768827015316754642LL,
  -6300068865034972882LL,
  -1704356884353820631LL,
  7577140704254240628LL,
  -3406461883196655282LL,
  5203989160688957609LL,
  3824459740124746701LL,
  -3552268197398072490LL,
  6139344687198253892LL,
  -2973547812742841409LL,
  -8038766757522345911LL,
  -9184668647618541298LL,
  -961533083818678426LL,
  -4488186758513707430LL,
  7359557278820475512LL,
  -5939493952408939990LL,
  6926642509246963849LL,
  -2645342115646191339LL,
  1945302910127243087LL,
  -8612983824704309088LL,
  -8180069455051261359LL,
  -8462392853740155130LL,
  1438921290992449714LL,
  -7241617149292609518LL,
  4113819607550793524LL,
  8492228760641592010LL,
  5994664409028833717LL,
  5892487139954050579LL,
  -3190568322650294085LL,
  6828405761199227679LL,
  -3769288715895459758LL,
  -7388267599364458572LL,
  3679778639410237756LL,
  5101248232805878774LL,
  2304751982975974475LL,
  7049928972698506970LL,
  5636904067162454616LL
}; // weak
_QWORD qword_1D8D68[256] =
{
  -6488505333816387596LL,
  -8892515824107721833LL,
  -7372288209707219024LL,
  -8247081616505178228LL,
  943478833150813463LL,
  -4765922387822790692LL,
  -5636229787179440184LL,
  6123890065292933628LL,
  5832320261051957488LL,
  217587862202418181LL,
  -6205908820751185952LL,
  9045428545345399943LL,
  1813768571333498155LL,
  7108390733004042662LL,
  -1859568499666019791LL,
  -7298828746967301195LL,
  5030310294124299727LL,
  -7080605160063549764LL,
  4665810069017856448LL,
  -8677758104835199086LL,
  1531172127256200511LL,
  -1502349930454614234LL,
  -3944926161900337344LL,
  801050278664858909LL,
  -1427801330295209425LL,
  7469530816082050473LL,
  -208217405854466532LL,
  -1574746644054111707LL,
  -4622108138223483174LL,
  -647865978055055870LL,
  -7592710647379995743LL,
  6624081037630320109LL,
  -4441349172565448099LL,
  2027963306158643492LL,
  -5842905682043569431LL,
  7691851623108876478LL,
  6552317910056622318LL,
  4738839583905676483LL,
  146072275639267590LL,
  5751468923926027729LL,
  6693629326234800356LL,
  -862625896350834169LL,
  3773046520127207772LL,
  583464615485696280LL,
  -7805216566838829138LL,
  8328631992928390549LL,
  6049908123254375669LL,
  4558042126717244481LL,
  870351448809672724LL,
  5978075049487380982LL,
  7327331606793129135LL,
  6837167499228619234LL,
  2916160130525978744LL,
  -6775437803315433736LL,
  1085678715105383441LL,
  -5348891869512900924LL,
  656141320821742619LL,
  3916581519643527258LL,
  -7226398220130502986LL,
  4415666046950548807LL,
  2768209423324578154LL,
  7618952911299124411LL,
  -3653488575006245300LL,
  -6937143306121916486LL,
  1958290759821763629LL,
  -7009390900067550535LL,
  8402806888486711452LL,
  3346814663117400178LL,
  3276158955028311159LL,
  -5562770324439522355LL,
  -1285322819182365911LL,
  -354010465921419754LL,
  -720112338841742591LL,
  5609129391076273367LL,
  7035489822171035043LL,
  -3582274315010246071LL,
  8903017583045485709LL,
  4486323954062893378LL,
  8184110753057455251LL,
  -7520253732264139102LL,
  -791328797860997372LL,
  7545783072850471352LL,
  0LL,
  3203385078741506420LL,
  6962811590477381792LL,
  2243288373431098657LL,
  -4016302149275684285LL,
  -1356539278201620692LL,
  -4694705928803535911LL,
  5100968201236644298LL,
  -2778695237196198288LL,
  5466718428776359133LL,
  -2415638502699027591LL,
  -3141261184203478169LL,
  -1719368245633844445LL,
  5394850032661434846LL,
  7763368736029633981LL,
  3062091254749368702LL,
  -1930782759662019020LL,
  1601830034368545082LL,
  -4227522674965538988LL,
  -2926503464930955422LL,
  6196840277367704831LL,
  -7735013650559917401LL,
  -3509781258315034806LL,
  1166671902149757232LL,
  435175724404836362LL,
  -9108417000979175528LL,
  -1149636573479806197LL,
  4957535719334932684LL,
  -4983813370278163755LL,
  -2072089812287646146LL,
  -932618258300575986LL,
  -137003145858467303LL,
  -4585830450584347813LL,
  -8465219165516854651LL,
  -5914119942039568660LL,
  -4836868056519261473LL,
  5249130566573940952LL,
  291887291444820236LL,
  -2343532741424855430LL,
  -4514806436282110376LL,
  8475546554855671199LL,
  7180399452679799973LL,
  3481405795238690896LL,
  1886669482166505774LL,
  1014136740263158034LL,
  7905797290515588535LL,
  5536143856653572564LL,
  1458080065262989372LL,
  3845925811554438239LL,
  3418710146013961585LL,
  -2217874662675617992LL,
  -6701980539598771459LL,
  -3724538977587557553LL,
  4128504732433603659LL,
  6339215132565388793LL,
  -1005050018296321523LL,
  -9034957538239257699LL,
  5172862985630643401LL,
  -5985521636438406161LL,
  -1787215766531641550LL,
  3133747992728396925LL,
  -7663927106399250524LL,
  -6846813109435196421LL,
  -7443418734332988749LL,
  -3357162361074931864LL,
  9187662801030569345LL,
  7397987314882218154LL,
  9116084253434488962LL,
  -6059913002106521882LL,
  -8962562333750389090LL,
  -3871466699160419515LL,
  2989190343916361083LL,
  -3211623525339900306LL,
  4342714860421533764LL,
  8758142998932968843LL,
  -2144415199935700163LL,
  2100701722121677863LL,
  8546204461968015770LL,
  4273237492464594253LL,
  6267495985456793850LL,
  5679785099165362386LL,
  2171357430210766882LL,
  -2632665613971275914LL,
  729040032631494686LL,
  7833163039287054516LL,
  -2001973485804164297LL,
  6766509592116274663LL,
  7976455197627933106LL,
  -1213041411999431126LL,
  -6417288874797132815LL,
  -6276933516309007645LL,
  -6559556417653284105LL,
  3988371587399662937LL,
  -8392892268758171770LL,
  3627231504321655126LL,
  4883395732197019077LL,
  6479419198246870251LL,
  -5205570891035463742LL,
  -8318273851757952369LL,
  7254205748809595308LL,
  -3283702898335014035LL,
  -2289110326490131909LL,
  -5420328610307986489LL,
  -426230438429048043LL,
  507212358717275401LL,
  2697551516212233583LL,
  -5770763917165883414LL,
  -8175865157485923447LL,
  -1648203907770773984LL,
  1740702897619345448LL,
  -3070316472714273180LL,
  -8609910583937401981LL,
  8048490305582765233LL,
  8257009464867207318LL,
  2624565283286970476LL,
  -1078507282012983800LL,
  -4084165132324182446LL,
  5905174138654373363LL,
  2550636954284952933LL,
  8972337733758114180LL,
  -7151901025394439233LL,
  2405869147857714275LL,
  -2486854961718282372LL,
  -2558292659720633729LL,
  -8750041021128762735LL,
  -8821255281124761964LL,
  -8022234882018059349LL,
  4811738295715428550LL,
  -4298925050619960745LL,
  -6132449358011268123LL,
  -2849683929150506125LL,
  364520016315747343LL,
  73171364806259971LL,
  1312282641643485238LL,
  -6629794794255966210LL,
  6908956592530511073LL,
  -499689901168965872LL,
  -3428644039542386069LL,
  -7950895036222067032LL,
  6406495374451157480LL,
  2839892549582681193LL,
  -5057270633994826032LL,
  4055651829285431624LL,
  1384257565328919861LL,
  -5490198922138528050LL,
  3698993657441109077LL,
  -4911733040075784234LL,
  8111046329749227920LL,
  -8538676429233516928LL,
  -6344796499357505806LL,
  -5277677609516901695LL,
  2478767859667466342LL,
  -7877437772505404755LL,
  2333051291105790304LL,
  5321949121828427227LL,
  -64544997583663334LL,
  8685429720843067528LL,
  8831043909765976462LL,
  -8103513933462174070LL,
  -571030980123905517LL,
  -9179582847952874853LL,
  1673407331558700089LL,
  -2705237973479536011LL,
  3554330593488647507LL,
  -4156306215946284207LL,
  -5128751355255014445LL,
  -4368812135405117602LL,
  -5707219436341013813LL,
  8618134154782422169LL,
  1239383929833733171LL,
  -3799281635073198522LL,
  -279302716856186081LL,
  -2999102212718273951LL,
  4201403444243355726LL
}; // weak
_QWORD qword_1D9568[256] =
{
  -850398823135578971LL,
  -7534529905301940348LL,
  -5737886166673805159LL,
  -8324069422436742003LL,
  1722908328384075533LL,
  -2591022417804010307LL,
  -4028787768591660879LL,
  -257389550320878508LL,
  -1112283141172563888LL,
  362260502690399491LL,
  -2292667773282164567LL,
  -8660045678981118083LL,
  3156152418636737305LL,
  -6479635648210688414LL,
  3565810001947275750LL,
  -5379007778964392550LL,
  -3512649863847882939LL,
  -4854001752732681059LL,
  -4590987122549604288LL,
  -7896785992664771961LL,
  4598439029686746901LL,
  2780043351519340267LL,
  4669826607538979017LL,
  2154686527398812939LL,
  3417740918617419756LL,
  -6261494748788446873LL,
  2036576322385222909LL,
  2693228743757538794LL,
  -2668062667800388929LL,
  167006281291662071LL,
  -6825797989775990378LL,
  -1335709147916800677LL,
  6712744393237487042LL,
  2649772312745288732LL,
  -1597584632680093266LL,
  -4687600371049644438LL,
  -1260325733073883558LL,
  -4342175384977226943LL,
  501014416233399810LL,
  -3363481371701030577LL,
  -1978091338879409060LL,
  528699418701072372LL,
  6669217319668505652LL,
  1792988974661834760LL,
  -5887081150108684653LL,
  -7692522360640006797LL,
  -750022638482164397LL,
  4713907795912835391LL,
  1449042010761597964LL,
  -692545449123252654LL,
  -5771004179333206171LL,
  -2125807199880879522LL,
  8667230466268493864LL,
  -518134720053184351LL,
  1232589961334886671LL,
  -4257257140795816779LL,
  1951481466980145929LL,
  6520689048427190838LL,
  -5283536982453602661LL,
  5159119523057846077LL,
  7685337570129046054LL,
  -4902926520636621975LL,
  5490872557588335821LL,
  -5021255291093665121LL,
  3260344524213595419LL,
  -5069895267466430050LL,
  -7150493171419407244LL,
  8234326367415071278LL,
  8593209170317834029LL,
  -3669909380882248270LL,
  2998751616086256110LL,
  1607041092664301307LL,
  118681993609413110LL,
  -2908913633819044019LL,
  -6695524747751087263LL,
  5274979042854586830LL,
  -8223763880340058757LL,
  4800799670108504638LL,
  -7796471620180339855LL,
  -6723571793826241897LL,
  334012558389740789LL,
  -5187661089782253464LL,
  0LL,
  8409840914605372460LL,
  -6854407987616767904LL,
  2432757313365156127LL,
  4844317913159713736LL,
  3214082180866583789LL,
  -2806352982584337986LL,
  -3870969716797224378LL,
  8077038152445751513LL,
  -2472631835177984693LL,
  8785841815173691870LL,
  7493876087129860052LL,
  2563586886765061096LL,
  -2424197166889050550LL,
  -4825963537045275285LL,
  9132110120037219882LL,
  3781703516681024741LL,
  4240119176737405462LL,
  6112095557685564613LL,
  7131619999767028439LL,
  -28879332889002155LL,
  -6361878656416831596LL,
  5386457483119119055LL,
  3520101770985025552LL,
  724521005380798982LL,
  -7464998963265431423LL,
  840942368522439664LL,
  -3696196936216294332LL,
  -3030881705250859590LL,
  4500586191939583715LL,
  1057398833276718835LL,
  1820682807651473918LL,
  6619025367818263488LL,
  -8827049748297251446LL,
  -1381691117946344275LL,
  -2306369530390978628LL,
  -2834892337868384184LL,
  936170315035773956LL,
  8798172627652213471LL,
  6354428955481495745LL,
  -6975882654675263627LL,
  -6492147484926368413LL,
  5796168043046391856LL,
  3372041518177136154LL,
  1364588475434734094LL,
  -5257741736060012691LL,
  -3146466372320897972LL,
  4333615233134246932LL,
  6879571851329953589LL,
  8192825915225239855LL,
  4073152640037894369LL,
  -159819282297193054LL,
  5748713570481950668LL,
  5432799301558094649LL,
  -474404549701011113LL,
  961612348075412978LL,
  -7106120575556018814LL,
  -3912648985643005625LL,
  -1213780810339192916LL,
  3641365610638553831LL,
  9029490968958893355LL,
  -6610467424995662699LL,
  -343469013002880096LL,
  -5500556397161303144LL,
  7563407029166368977LL,
  -9141564370996854401LL,
  -6129886982235968922LL,
  -9018928481883880834LL,
  -1811226347667265877LL,
  -7019692300115206525LL,
  5028704995248391626LL,
  8916221020496821033LL,
  7927860829915344595LL,
  4930359845339546684LL,
  -8418169265725273223LL,
  4432031027747306978LL,
  2824062725572536093LL,
  -7334202507624605066LL,
  5590897722072583483LL,
  -387762135791764906LL,
  -3267796436721806770LL,
  2465179922669773342LL,
  8567133550606776027LL,
  2166807616567123466LL,
  -5405365976855169940LL,
  4003621698001385444LL,
  -1767487346931538083LL,
  -5616061589009354130LL,
  3056047781208009455LL,
  -1065729387915906650LL,
  -2028245762374966360LL,
  -592732211671533660LL,
  6452202320288373047LL,
  -8758108251783985525LL,
  6234061420866131506LL,
  -4229289569812626109LL,
  -1475651882660861095LL,
  -4460574797991001417LL,
  -8102537573437370484LL,
  -6044479749408314268LL,
  7922285416875781586LL,
  4283566777231883232LL,
  -4098318710628169804LL,
  1565472204421010938LL,
  719155315655641351LL,
  8043657423078387493LL,
  -1576036897702024529LL,
  -8539399987217069682LL,
  2334913306001547497LL,
  2898084021523195928LL,
  7208978154656785621LL,
  -8974564716538264696LL,
  -5621818026281881233LL,
  -7581145470593362318LL,
  7805925867920583716LL,
  603296910319421681LL,
  5918138326453736135LL,
  -908434548663651503LL,
  7327017717113644323LL,
  -8924549371616721796LL,
  -4658999203730833508LL,
  7159947419159651105LL,
  9001172379954019549LL,
  9159865765061623772LL,
  -7954468490107514490LL,
  -7738574975373765499LL,
  -6103537614862963824LL,
  -4126849235390249406LL,
  6279831463863146436LL,
  -1933789385572751958LL,
  8350677085852496856LL,
  1083403808283561733LL,
  285125316693000961LL,
  3902962933960291858LL,
  -127012548248600925LL,
  -2194543388306120353LL,
  1206593816711598329LL,
  7710841415207644112LL,
  -6287281164798482287LL,
  -1697406700653778856LL,
  7589473818493872423LL,
  -3389197143006850887LL,
  5229200169335605304LL,
  3881799323722003731LL,
  -3538374465537257805LL,
  6158428545736791347LL,
  -3025061247151253829LL,
  -8054219913376984976LL,
  -9185365186053242743LL,
  -954425349080943961LL,
  -4473150655529565770LL,
  7375273568746628642LL,
  -5928965727042490990LL,
  6965320164376666144LL,
  -2640086266429449399LL,
  1923224692291738367LL,
  -8586024383030458248LL,
  -8202280166184874374LL,
  -8464230710846780785LL,
  1390021677956600824LL,
  -7236711714822907008LL,
  4117163183707535639LL,
  8435353590201742810LL,
  6018172321325732657LL,
  5896764992905236934LL,
  -3241517711905533000LL,
  6835481832572542659LL,
  -3755393880244958288LL,
  -7366945220846118537LL,
  3687636784373314321LL,
  5061337327867414219LL,
  2285480779654569980LL,
  6993084639923036630LL,
  5648125451145072186LL
}; // weak
_QWORD qword_1D9D68[256] =
{
  3658830161806403060LL,
  8068471982206190743LL,
  6840667228270008752LL,
  8860540406502034828LL,
  -1657325702705902313LL,
  781047695717219804LL,
  1647999368269705672LL,
  7895251412693308668LL,
  -8043323034533080848LL,
  504968320194511621LL,
  3372860398471522784LL,
  -3362404974020035193LL,
  -3681720072215520981LL,
  1420240691923411622LL,
  8956900886734562865LL,
  6479814113331878581LL,
  4652094466709997007LL,
  -6692595761026392644LL,
  5298917344712605888LL,
  7564633985869055890LL,
  -3391229117604096705LL,
  -7731920885721404634LL,
  -3562753261142226624LL,
  -1802571197190436067LL,
  7944703701710531631LL,
  1924078722888591273LL,
  4854704466749619484LL,
  6937027674676521509LL,
  -494512229646155814LL,
  5860119863246386946LL,
  5036401619753866913LL,
  8546595533780507629LL,
  2915365813808382557LL,
  -4187818664459494364LL,
  -3153296344493740311LL,
  -987330197588120898LL,
  -9048738413851813138LL,
  -4792254131597000253LL,
  -867517960216509946LL,
  5945740308885098449LL,
  -8329292762970825500LL,
  6219842671507665927LL,
  -8227565019850853284LL,
  -2163424329309091816LL,
  5540239616359961518LL,
  4515891563080283029LL,
  -7538354714338569227LL,
  7722030962565005121LL,
  2019873280778046484LL,
  7175805761542836982LL,
  -1637544012536650321LL,
  9195679041781391074LL,
  5201710519588235384LL,
  -3515279817648332296LL,
  1948380848668610321LL,
  -1499927694865549884LL,
  1517165556759464219LL,
  9089429763501209178LL,
  -5973150127325013066LL,
  -7430975404279120569LL,
  -6355197933886232982LL,
  -770592270725715525LL,
  3710825140688047436LL,
  5830730639690342330LL,
  4544714881750604589LL,
  -6621103311737479495LL,
  -4298588586122644324LL,
  5058725655369363058LL,
  4699002829928869239LL,
  1287146253331575501LL,
  -7082837377719603671LL,
  5574150100450999062LL,
  -6510897783409347071LL,
  -6812127309293204009LL,
  1492863430709961123LL,
  3782317589976960585LL,
  -2354728964166157427LL,
  -6927137390762770878LL,
  -3648374805535428205LL,
  -5687180364529625182LL,
  -6726505420774116092LL,
  124334322830829752LL,
  0LL,
  -5349782485042189196LL,
  -2287757827485179744LL,
  -4403426284644786399LL,
  4213532830346758211LL,
  -7298445015084372692LL,
  996655333081988825LL,
  5155932480226346698LL,
  1686430770642606448LL,
  -5804451299439326243LL,
  -1327272308100178311LL,
  -29105360549194649LL,
  -7804543641688217565LL,
  6594823782527814366LL,
  485187454949485501LL,
  -4916306631584765314LL,
  8885408437445649716LL,
  -2887391104087747014LL,
  -3276783497807346348LL,
  -532943356886329502LL,
  -7393109219584551425LL,
  -5327457556268346201LL,
  -4572689849721893046LL,
  -2744406239601487824LL,
  1009936640389023242LL,
  7421649069842923928LL,
  -6079682542770065397LL,
  -5442467912184216372LL,
  -1142465448418886955LL,
  8451932566541230910LL,
  -6007059786803252466LL,
  4926196916038532633LL,
  -2629960619803295653LL,
  -9221958571531072891LL,
  -3224788793782653460LL,
  -134789421384876833LL,
  -6309419619633837864LL,
  -148072309066038260LL,
  1829415686401351546LL,
  3420334116822368600LL,
  3508215552959018399LL,
  -1782789507290668123LL,
  8079493123112185936LL,
  -3754342811002070482LL,
  -1153487689189552622LL,
  630432949434019255LL,
  6161347929070390484LL,
  2600855259794117692LL,
  8729706938060715359LL,
  -5565390105227481231LL,
  -8737336351743483592LL,
  -4020248120662318339LL,
  -4068851853384758193LL,
  7290815670655859019LL,
  7679643792508016633LL,
  6365088149081551373LL,
  7060795954904793757LL,
  -5513960344293652535LL,
  2866761806228991215LL,
  -8594351435717351630LL,
  5706678839782747005LL,
  4820793982389097892LL,
  4305653039810453755LL,
  -6189888071367681869LL,
  -675928272912461464LL,
  2496018385918328705LL,
  -1277821187096156502LL,
  -3002682148579541374LL,
  -2505343160081273882LL,
  -7707053679666363490LL,
  -3923606376080356795LL,
  -4843683892798215813LL,
  390524350277538670LL,
  7793523394674441284LL,
  3217724598347594123LL,
  -9098189466681613763LL,
  3537038871896726823LL,
  4012053566475368090LL,
  -7576220898763654323LL,
  -7033386394144057606LL,
  -6452404483852710190LL,
  3896761697337220642LL,
  -1976355816101979274LL,
  1300427629897058846LL,
  -267884546707133260LL,
  -8090513439380216777LL,
  8691841028265041383LL,
  1134270962950368946LL,
  7584980893449252650LL,
  3874437799171172081LL,
  -2722081104123942685LL,
  -4165493598236203785LL,
  -8443172640036145319LL,
  8427064535865002886LL,
  -8947010671001324970LL,
  5659770476831261637LL,
  -8832000486989407765LL,
  1790984284295837634LL,
  -8214282544497062769LL,
  2139686343073883308LL,
  -1036781387850591635LL,
  8235194622498562107LL,
  2294822280632972487LL,
  -5067485289831335403LL,
  -363679929251330295LL,
  -6859035947402582673LL,
  2362923809891856362LL,
  9076148043866803849LL,
  7441995977690507552LL,
  4039746561556092968LL,
  824000221181957476LL,
  8354441779898189955LL,
  -339376978816569423LL,
  -3865112732397833578LL,
  6068662227037856876LL,
  6870056452095537416LL,
  2410397527973218130LL,
  7248428500329386483LL,
  -5851359937281318043LL,
  2711626006103620740LL,
  6334568636027477183LL,
  6718876007625072995LL,
  -1542879945464947332LL,
  2189138494662630527LL,
  -7202085359473031535LL,
  -7273577808761944684LL,
  5467616860393148587LL,
  -5008992058459405626LL,
  2770120336234497111LL,
  3012007283533392613LL,
  -2048978572068792205LL,
  650213814948529423LL,
  -794895221429960445LL,
  3034331113518928438LL,
  4378275795777266686LL,
  -8400785195080261663LL,
  -4706632174893205232LL,
  173786406234869867LL,
  -4677243775680474712LL,
  8185742401661851880LL,
  5997169794928420713LL,
  -637497145404900912LL,
  -7937074030882310072LL,
  -2383553107482832075LL,
  -1933403565769968690LL,
  8584461443306697557LL,
  347571825080187862LL,
  4155038430961627280LL,
  -8716990268517086848LL,
  -4525216406497482766LL,
  -1428435245576636735LL,
  6502138080762667622LL,
  -5182212078694460755LL,
  -6212213069399973792LL,
  6667446521314363867LL,
  -5716568763472871654LL,
  -2859697284360669048LL,
  3145101859561044622LL,
  -8574005352758341750LL,
  5357412156408330259LL,
  -7923791623709032293LL,
  2529362827684681529LL,
  1181462467628620405LL,
  -8874387932214775469LL,
  -3061175860442577327LL,
  274949069113374931LL,
  -2557337863836482722LL,
  -2150141509812637493LL,
  -4370081018232080487LL,
  3251069040381333811LL,
  4430270774389427014LL,
  -5212730767135736801LL,
  895492670470870625LL,
  7074077743793453646LL
}; // weak
_QWORD qword_1DA568[256] =
{
  -4123426336747949006LL,
  -506508810684950673LL,
  -1229876565285162914LL,
  -651177001753932678LL,
  -266197391304728LL,
  -2965974707196797942LL,
  -2387275418275035114LL,
  -7957486458563658643LL,
  6944639415001084048LL,
  144681453828113671LL,
  -3544709455639093202LL,
  6221298115219916753LL,
  -1736390727986238516LL,
  -5353264341797657069LL,
  5570361864063693180LL,
  -1374553620898728615LL,
  -8102181313361621184LL,
  2242684032231783587LL,
  -8536221208079712183LL,
  -361827357024611736LL,
  -1157682642299830320LL,
  -5570130857757563244LL,
  -8174375240641986354LL,
  -289624638012842522LL,
  4702299529845419886LL,
  -5497936930678527718LL,
  6872490549362629699LL,
  4991653641072551264LL,
  2532077726550973177LL,
  6004415020601377361LL,
  -1953270502678683323LL,
  -7234088123626689162LL,
  8463885386563869992LL,
  -2170421826476563259LL,
  4412875052822751700LL,
  5497886449374772978LL,
  7812719341339340418LL,
  9114795249707893693LL,
  -723668930911926541LL,
  -8970239043307581102LL,
  7523365229776659596LL,
  5859733566941038422LL,
  -3327820678929556339LL,
  -434306091840956191LL,
  -2097951887485325748LL,
  -6076636495149296322LL,
  7089320868829197719LL,
  3038310529719288171LL,
  578725815312454684LL,
  -7668132415988894109LL,
  5063846485937205225LL,
  -7089406738786491777LL,
  3472319707500542024LL,
  3978826293794961615LL,
  723407269006348571LL,
  3400135662319813867LL,
  1012756982522256149LL,
  2604266168906046078LL,
  1953325522689439405LL,
  -2315063903371049064LL,
  -3617192588435101017LL,
  5642563505021893621LL,
  9187288256953011251LL,
  -1519226209746044336LL,
  1302133084453023039LL,
  2098006976483998116LL,
  6365966375176150212LL,
  3761682614888329798LL,
  3906359670669670209LL,
  -2531952473888600815LL,
  -5425449472682481251LL,
  6583132039820285517LL,
  -6582865918933204571LL,
  8536095823347177377LL,
  -5208587286150536428LL,
  9042611201205225780LL,
  5931939605878902239LL,
  -2459740959152389473LL,
  6799997542117512141LL,
  1374608503470531249LL,
  -6438188863185419102LL,
  -5063901502726686719LL,
  0LL,
  -4485254716293614411LL,
  4629806522499637472LL,
  -2025740372782669374LL,
  8753248293616108346LL,
  -5280772416934695782LL,
  -3110651762944583411LL,
  -8246858369142961593LL,
  7451163589187563543LL,
  8246737314006162863LL,
  -7740317546873718291LL,
  -7450972300593829889LL,
  -5714812311552121965LL,
  -8825566454158270885LL,
  -4919220048898573050LL,
  -4195900673450410309LL,
  5715038919811478651LL,
  -1302359698081170729LL,
  -8753092121750842158LL,
  -7306290846933490952LL,
  7378679378438651801LL,
  1229927049810192310LL,
  -8463724885102867776LL,
  -1591722537017921319LL,
  289362907656227342LL,
  -72477712295290778LL,
  -6872228757534405717LL,
  8680764082766531764LL,
  2676750384117765616LL,
  5425680410537574005LL,
  -6727547303739846996LL,
  6727813493614844228LL,
  -9187132016099828773LL,
  361847122867946880LL,
  4557552108570537171LL,
  2387396272890634238LL,
  8102055860178049192LL,
  -1013022973486691075LL,
  7161813876007205401LL,
  8608562442177435695LL,
  -5787278054259318992LL,
  4774487976327751143LL,
  2314903261249818736LL,
  -1881067783633359157LL,
  -144943253172645137LL,
  -4629861608277035256LL,
  -9114920497001474987LL,
  1736159853750271012LL,
  2748943224687386489LL,
  -4340573262599720526LL,
  -4702073127476053882LL,
  3834149238181395912LL,
  -8608406338763206713LL,
  3327660243235195749LL,
  -7812805004869764758LL,
  6149087678436609368LL,
  -217154767908856479LL,
  8825445536460425651LL,
  -3978740553760313561LL,
  -4991422772205374840LL,
  3617001161328655695LL,
  -1808593446930897854LL,
  -4557466231096935621LL,
  1808644068894880682LL,
  -7016941202204169994LL,
  -6655335784742158046LL,
  4919169430155864814LL,
  6076621059438576342LL,
  4268193599028192989LL,
  795873892332969621LL,
  -8319052296255552055LL,
  -4051223617803289668LL,
  7740513302502141445LL,
  2893629076025394284LL,
  -6365986139945727188LL,
  -4846750183089619583LL,
  1591491593794037553LL,
  -5931955110040659401LL,
  -2604422343992586858LL,
  7234002322657311390LL,
  8391418767565836966LL,
  1446814538012697142LL,
  -7884998931948800284LL,
  868079926875135506LL,
  5208532337812092156LL,
  -5136104225865713777LL,
  -6944729683005151368LL,
  -4774538664058375665LL,
  4846980983505758825LL,
  -4268103392495734475LL,
  4123512145233634266LL,
  3544795126685824966LL,
  -3183139225235662454LL,
  -940535442576800140LL,
  -3038466636354791805LL,
  -8391539754251598514LL,
  7957396396986461061LL,
  -2676625063004356072LL,
  72493011640815502LL,
  -5642618384372421603LL,
  -7161618257817735695LL,
  5280998956743015282LL,
  -2821306516664695009LL,
  -6004149037153249863LL,
  -868341519792797190LL,
  -3472515532653760608LL,
  -3834059100099974624LL,
  -795854057501718147LL,
  5136330696686116967LL,
  1157451630624909368LL,
  8029871811776046091LL,
  -1085216896371358861LL,
  5353213791505986043LL,
  6655320486470391498LL,
  4051027930089024596LL,
  6293764734050175071LL,
  8319212728728637985LL,
  -7523455360341773468LL,
  -3761873973543737938LL,
  -6800017238436051931LL,
  -1663907663406383273LL,
  4485059097030386525LL,
  -7595640491125932822LL,
  7017132422346866462LL,
  940555345859088796LL,
  1085232401606874267LL,
  -2242633341279884469LL,
  8970118194060773050LL,
  8174531275068299046LL,
  -3689386511252658903LL,
  -8029680385743359005LL,
  434039963437567753LL,
  -578991875264805900LL,
  2025513965044512298LL,
  -4412784777302376900LL,
  7668046683470553483LL,
  -5859471981539684162LL,
  7595831848707582722LL,
  1663958216919328959LL,
  -7378769577454802831LL,
  4195709383782918483LL,
  2821427439731331319LL,
  -2749103797820700527LL,
  -1447041083189807650LL,
  3110777153045909221LL,
  2459584715077932407LL,
  -3255333148019665404LL,
  -6221317948977409991LL,
  506524178481512583LL,
  3689476580346163905LL,
  3255458606572028396LL,
  4340382041383265882LL,
  1519281161305763256LL,
  -3906555427371851607LL,
  -8680889398511150244LL,
  -6148821626000565584LL,
  5787258152050788568LL,
  -6510663195592847829LL,
  217174465301154441LL,
  6438450586025726794LL,
  651192438538410898LL,
  1880841307444164899LL,
  7306486533573997840LL,
  -2893789580707671164LL,
  -8897769177498627627LL,
  -3400014601814224125LL,
  -9042450562305270052LL,
  2966095699251350498LL,
  6510647828870044099LL,
  2170191020691632941LL,
  8897929747410667069LL,
  -6293503079660904521LL,
  7885194756028260620LL,
  3182983187588075106LL
}; // weak
_DWORD dword_1DAD68[256] =
{
  -1520213050,
  -2072216328,
  -1720223762,
  -1921287178,
  234025727,
  -1117033514,
  -1318096930,
  1422247313,
  1345335392,
  50397442,
  -1452841010,
  2099981142,
  436141799,
  1658312629,
  -424957107,
  -1703512340,
  1170918031,
  -1652391393,
  1086966153,
  -2021818886,
  368769775,
  -346465870,
  -918075506,
  200339707,
  -324162239,
  1742001331,
  -39673249,
  -357585083,
  -1080255453,
  -140204973,
  -1770884380,
  1539358875,
  -1028147339,
  486407649,
  -1366060227,
  1780885068,
  1513502316,
  1094664062,
  49805301,
  1338821763,
  1546925160,
  -190470831,
  887481809,
  150073849,
  -1821281822,
  1943591083,
  1395732834,
  1058346282,
  201589768,
  1388824469,
  1696801606,
  1589887901,
  672667696,
  -1583966665,
  251987210,
  -1248159185,
  151455502,
  907153956,
  -1686077413,
  1038279391,
  652995533,
  1764173646,
  -843926913,
  -1619692054,
  453576978,
  -1635548387,
  1949051992,
  773462580,
  756751158,
  -1301385508,
  -296068428,
  -73359269,
  -162377052,
  1295727478,
  1641469623,
  -827083907,
  2066295122,
  1055122397,
  1898917726,
  -1752923117,
  -179088474,
  1758581177,
  0,
  753790401,
  1612718144,
  536673507,
  -927878791,
  -312779850,
  -1100322092,
  1187761037,
  -641810841,
  1262041458,
  -565556588,
  -733197160,
  -396863312,
  1255133061,
  1808847035,
  720367557,
  -441800113,
  385612781,
  -985447546,
  -682799718,
  1429418854,
  -1803188975,
  -817543798,
  284817897,
  100794884,
  -2122350594,
  -263171936,
  1144798328,
  -1163944155,
  -475486133,
  -212774494,
  -22830243,
  -1069531008,
  -1970303227,
  -1382903233,
  -1130521311,
  1211644016,
  83228145,
  -541279133,
  -1044990345,
  1977277103,
  1663115586,
  806359072,
  452984805,
  250868733,
  1842533055,
  1288555905,
  336333848,
  890442534,
  804056259,
  -513843266,
  -1567123659,
  -867941240,
  957814574,
  1472513171,
  -223893675,
  -2105639172,
  1195195770,
  -1402706744,
  -413311558,
  723065138,
  -1787595802,
  -1604296512,
  -1736343271,
  -783331426,
  2145180835,
  1713513028,
  2116692564,
  -1416589253,
  -2088204277,
  -901364084,
  703524551,
  -742868885,
  1007948840,
  2044649127,
  -497131844,
  487262998,
  1994120109,
  1004593371,
  1446130276,
  1312438900,
  503974420,
  -615954030,
  168166924,
  1814307912,
  -463709000,
  1573044895,
  1859376061,
  -273896381,
  -1503501628,
  -1466855111,
  -1533700815,
  937747667,
  -1954973198,
  854058965,
  1137232011,
  1496790894,
  -1217565222,
  -1936880383,
  1691735473,
  -766620004,
  -525751991,
  -1267962664,
  -95005012,
  133494003,
  636152527,
  -1352309302,
  -1904575756,
  -374428089,
  403179536,
  -709182865,
  -2005370640,
  1864705354,
  1915629148,
  605822008,
  -240736681,
  -944458637,
  1371981463,
  602466507,
  2094914977,
  -1670089496,
  555687742,
  -582268010,
  -591544991,
  -2037675251,
  -2054518257,
  -1871679264,
  1111375484,
  -994724495,
  -1436129588,
  -666351472,
  84083462,
  32962295,
  302911004,
  -1553899070,
  1597322602,
  -111716434,
  -793134743,
  -1853454825,
  1489093017,
  656219450,
  -1180787161,
  954327513,
  335083755,
  -1281845205,
  856756514,
  -1150719534,
  1893325225,
  -1987146233,
  -1483434957,
  -1231316179,
  572399164,
  -1836611819,
  552200649,
  1238290055,
  -11184726,
  2015897680,
  2061492133,
  -1886614525,
  -123625127,
  -2138470135,
  386731290,
  -624967835,
  837215959,
  -968736124,
  -1201116976,
  -1019133566,
  -1332111063,
  1999449434,
  286199582,
  -877612933,
  -61582168,
  -692339859,
  974525996
}; // weak
_DWORD dword_1DB168[256] =
{
  1667483301,
  2088564868,
  2004348569,
  2071721613,
  -218956019,
  1802229437,
  1869602481,
  -976907948,
  808476752,
  16843267,
  1734856361,
  724260477,
  -16849127,
  -673729182,
  -1414836762,
  1987505306,
  -892694715,
  -2105401443,
  -909539008,
  2105408135,
  -84218091,
  1499050731,
  1195871945,
  -252642549,
  -1381154324,
  -724257945,
  -1566416899,
  -1347467798,
  -1667488833,
  -1532734473,
  1920132246,
  -1061119141,
  -1212713534,
  -33693412,
  -1819066962,
  640044138,
  909536346,
  1061125697,
  -134744830,
  -859012273,
  875849820,
  -1515892236,
  -437923532,
  -235800312,
  1903288979,
  -656888973,
  825320019,
  353708607,
  67373068,
  -943221422,
  589514341,
  -1010590370,
  404238376,
  -1768540255,
  84216335,
  -1701171275,
  117902857,
  303178806,
  -2139087973,
  -488448195,
  -336868058,
  656887401,
  -1296924723,
  1970662047,
  151589403,
  -2088559202,
  741103732,
  437924910,
  454768173,
  1852759218,
  1515893998,
  -1600103429,
  1381147894,
  993752653,
  -690571423,
  -1280082482,
  690573947,
  -471605954,
  791633521,
  -2071719017,
  1397991157,
  -774784664,
  0,
  -303185620,
  538984544,
  -50535649,
  -1313769016,
  1532737261,
  1785386174,
  -875852474,
  -1094817831,
  960066123,
  1246401758,
  1280088276,
  1482207464,
  -808483510,
  -791626901,
  -269499094,
  -1431679003,
  -67375850,
  1128498885,
  1296931543,
  859006549,
  -2054876780,
  1162185423,
  -101062384,
  33686534,
  2139094657,
  1347461360,
  1010595908,
  -1616960070,
  -1465365533,
  1364304627,
  -1549574658,
  1077969088,
  -1886452342,
  -1835909203,
  -1650646596,
  943222856,
  -168431356,
  -1128504353,
  -1229555775,
  -623202443,
  555827811,
  269492272,
  -6886,
  -202113778,
  -757940371,
  -842170036,
  202119188,
  320022069,
  -320027857,
  1600110305,
  -1751698014,
  1145342156,
  387395129,
  -993750185,
  -1482205710,
  2122251394,
  1027439175,
  1684326572,
  1566423783,
  421081643,
  1936975509,
  1616953504,
  -2122245736,
  1330618065,
  -589520001,
  572671078,
  707417214,
  -1869595733,
  -2004350077,
  1179028682,
  -286341335,
  -1195873325,
  336865340,
  -555833479,
  1583267042,
  185275933,
  -606360202,
  -522134725,
  842163286,
  976909390,
  168432670,
  1229558491,
  101059594,
  606357612,
  1549580516,
  -1027432611,
  -741098130,
  -1397996561,
  1650640038,
  -1852753496,
  -1785384540,
  -454765769,
  2038035083,
  -404237006,
  -926381245,
  926379609,
  1835915959,
  -1920138868,
  -707415708,
  1313774802,
  -1448523296,
  1819072692,
  1448520954,
  -185273593,
  -353710299,
  1701169839,
  2054878350,
  -1364310039,
  134746136,
  -1162186795,
  2021191816,
  623200879,
  774790258,
  471611428,
  -1499047951,
  -1263242297,
  -960063663,
  -387396829,
  -572677764,
  1953818780,
  522141217,
  1263245021,
  -1111662116,
  -1953821306,
  -1970663547,
  1886445712,
  1044282434,
  -1246400060,
  1718013098,
  1212715224,
  50529797,
  -151587071,
  235805714,
  1633796771,
  892693087,
  1465364217,
  -1179031088,
  -2038032495,
  -1044276904,
  488454695,
  -1633802311,
  -505292488,
  -117904621,
  -1734857805,
  286335539,
  1768542907,
  -640046736,
  -1903294583,
  -1802226777,
  -1684329034,
  505297954,
  -2021190254,
  -370554592,
  -825325751,
  1431677695,
  673730680,
  -538991238,
  -1936981105,
  -1583261192,
  -1987507840,
  218962455,
  -1077975590,
  -421079247,
  1111655622,
  1751699640,
  1094812355,
  -1718015568,
  757946999,
  252648977,
  -1330611253,
  1414834428,
  -1145344554,
  370551866
}; // weak
_DWORD dword_1DB568[256] =
{
  1673962851,
  2096661628,
  2012125559,
  2079755643,
  -218165774,
  1809235307,
  1876865391,
  -980331323,
  811618352,
  16909057,
  1741597031,
  727088427,
  -18408962,
  -675978537,
  -1420958037,
  1995217526,
  -896580150,
  -2111857278,
  -913751863,
  2113570685,
  -84994566,
  1504897881,
  1200539975,
  -251982864,
  -1388188499,
  -726439980,
  -1570767454,
  -1354372433,
  -1675378788,
  -1538000988,
  1927583346,
  -1063560256,
  -1217019209,
  -35578627,
  -1824674157,
  642542118,
  913070646,
  1065238847,
  -134937865,
  -863809588,
  879254580,
  -1521355611,
  -439274267,
  -235337487,
  1910674289,
  -659852328,
  828527409,
  355090197,
  67636228,
  -946515257,
  591815971,
  -1013096765,
  405809176,
  -1774739050,
  84545285,
  -1708149350,
  118360327,
  304363026,
  -2145674368,
  -488686110,
  -338876693,
  659450151,
  -1300247118,
  1978310517,
  152181513,
  -2095210877,
  743994412,
  439627290,
  456535323,
  1859957358,
  1521806938,
  -1604584544,
  1386542674,
  997608763,
  -692624938,
  -1283600717,
  693271337,
  -472039709,
  794718511,
  -2079090812,
  1403450707,
  -776378159,
  0,
  -306107155,
  541089824,
  -52224004,
  -1317418831,
  1538714971,
  1792327274,
  -879933749,
  -1100490306,
  963791673,
  1251270218,
  1285084236,
  1487988824,
  -813348145,
  -793023536,
  -272291089,
  -1437604438,
  -68348165,
  1132905795,
  1301993293,
  862344499,
  -2062445435,
  1166724933,
  -102166279,
  33818114,
  2147385727,
  1352724560,
  1014514748,
  -1624917345,
  -1471421528,
  1369633617,
  -1554121053,
  1082179648,
  -1895462257,
  -1841320558,
  -1658733411,
  946882616,
  -168753931,
  -1134305348,
  -1233665610,
  -626035238,
  557998881,
  270544912,
  -1762561,
  -201519373,
  -759206446,
  -847164211,
  202904588,
  321271059,
  -322752532,
  1606345055,
  -1758092649,
  1149815876,
  388905239,
  -996976700,
  -1487539545,
  2130477694,
  1031423805,
  1690872932,
  1572530013,
  422718233,
  1944491379,
  1623236704,
  -2129028991,
  1335808335,
  -593264676,
  574907938,
  710180394,
  -1875137648,
  -2012511352,
  1183631942,
  -288937490,
  -1200893000,
  338181140,
  -559449634,
  1589437022,
  185998603,
  -609388837,
  -522503200,
  845436466,
  980700730,
  169090570,
  1234361161,
  101452294,
  608726052,
  1555620956,
  -1029743166,
  -742560045,
  -1404833876,
  1657054818,
  -1858492271,
  -1791908715,
  -455919644,
  2045938553,
  -405458201,
  -930397240,
  929978679,
  1843050349,
  -1929278323,
  -709794603,
  1318900302,
  -1454776151,
  1826141292,
  1454176854,
  -185399308,
  -355523094,
  1707781989,
  2062847610,
  -1371018834,
  135272456,
  -1167075910,
  2029029496,
  625635109,
  777810478,
  473441308,
  -1504185946,
  -1267480652,
  -963161658,
  -389340184,
  -576619299,
  1961401460,
  524165407,
  1268178251,
  -1117659971,
  -1962047861,
  -1978694262,
  1893765232,
  1048330814,
  -1250835275,
  1724688998,
  1217452104,
  50726147,
  -151584266,
  236720654,
  1640145761,
  896163637,
  1471084887,
  -1184247623,
  -2045275770,
  -1046914879,
  490350365,
  -1641563746,
  -505857823,
  -118811656,
  -1741966440,
  287453969,
  1775418217,
  -643206951,
  -1912108658,
  -1808554092,
  -1691502949,
  507257374,
  -2028629369,
  -372694807,
  -829994546,
  1437269845,
  676362280,
  -542803233,
  -1945923700,
  -1587939167,
  -1995865975,
  219813645,
  -1083843905,
  -422104602,
  1115997762,
  1758509160,
  1099088705,
  -1725321063,
  760903469,
  253628687,
  -1334064208,
  1420360788,
  -1150429509,
  371997206
}; // weak
_DWORD dword_1DB968[256] =
{
  -962239645,
  -125535108,
  -291932297,
  -158499973,
  -15863054,
  -692229269,
  -558796945,
  -1856715323,
  1615867952,
  33751297,
  -827758745,
  1451043627,
  -417726722,
  -1251813417,
  1306962859,
  -325421450,
  -1891251510,
  530416258,
  -1992242743,
  -91783811,
  -283772166,
  -1293199015,
  -1899411641,
  -83103504,
  1106029997,
  -1285040940,
  1610457762,
  1173008303,
  599760028,
  1408738468,
  -459902350,
  -1688485696,
  1975695287,
  -518193667,
  1034851219,
  1282024998,
  1817851446,
  2118205247,
  -184354825,
  -2091922228,
  1750873140,
  1374987685,
  -785062427,
  -116854287,
  -493653647,
  -1418471208,
  1649619249,
  708777237,
  135005188,
  -1789737017,
  1181033251,
  -1654733885,
  807933976,
  933336726,
  168756485,
  800430746,
  235472647,
  607523346,
  463175808,
  -549592350,
  -853087253,
  1315514151,
  2144187058,
  -358648459,
  303761673,
  496927619,
  1484008492,
  875436570,
  908925723,
  -592286098,
  -1259447718,
  1543217312,
  -1527360942,
  1984772923,
  -1218324778,
  2110698419,
  1383803177,
  -583080989,
  1584475951,
  328696964,
  -1493871789,
  -1184312879,
  0,
  -1054020115,
  1080041504,
  -484442884,
  2043195825,
  -1225958565,
  -725718422,
  -1924740149,
  1742323390,
  1917532473,
  -1797371318,
  -1730917300,
  -1326950312,
  -2058694705,
  -1150562096,
  -987041809,
  1340451498,
  -317260805,
  -2033892541,
  -1697166003,
  1716859699,
  294946181,
  -1966127803,
  -384763399,
  67502594,
  -25067649,
  -1594863536,
  2017737788,
  632987551,
  1273211048,
  -1561112239,
  1576969123,
  -2134884288,
  92966799,
  1068339858,
  566009245,
  1883781176,
  -251333131,
  1675607228,
  2009183926,
  -1351230758,
  1113792801,
  540020752,
  -451215361,
  -49351693,
  -1083321646,
  -2125673011,
  403966988,
  641012499,
  -1020269332,
  -1092526241,
  899848087,
  -1999879100,
  775493399,
  -1822964540,
  1441965991,
  -58556802,
  2051489085,
  -928226204,
  -1159242403,
  841685273,
  -426413197,
  -1063231392,
  429425025,
  -1630449841,
  -1551901476,
  1147544098,
  1417554474,
  1001099408,
  193169544,
  -1932900794,
  -953553170,
  1809037496,
  675025940,
  -1485185314,
  -1126015394,
  371002123,
  -1384719397,
  -616832800,
  1683370546,
  1951283770,
  337512970,
  -1831122615,
  201983494,
  1215046692,
  -1192993700,
  -1621245246,
  -1116810285,
  1139780780,
  -995728798,
  967348625,
  832869781,
  -751311644,
  -225740423,
  -718084121,
  -1958491960,
  1851340599,
  -625513107,
  25988493,
  -1318791723,
  -1663938994,
  1239460265,
  -659264404,
  -1392880042,
  -217582348,
  -819598614,
  -894474907,
  -191989126,
  1206496942,
  270010376,
  1876277946,
  -259491720,
  1248797989,
  1550986798,
  941890588,
  1475454630,
  1942467764,
  -1756248378,
  -886839064,
  -1585652259,
  -392399756,
  1042358047,
  -1763882165,
  1641856445,
  226921355,
  260409994,
  -527404944,
  2084716094,
  1908716981,
  -861247898,
  -1864873912,
  100991747,
  -150866186,
  470945294,
  -1029480095,
  1784624437,
  -1359390889,
  1775286713,
  395413126,
  -1722236479,
  975641885,
  666476190,
  -650583583,
  -351012616,
  733190296,
  573772049,
  -759469719,
  -1452221991,
  126455438,
  866620564,
  766942107,
  1008868894,
  361924487,
  -920589847,
  -2025206066,
  -1426107051,
  1350051880,
  -1518673953,
  59739276,
  1509466529,
  159418761,
  437718285,
  1708834751,
  -684595482,
  -2067381694,
  -793221016,
  -2101132991,
  699439513,
  1517759789,
  504434447,
  2076946608,
  -1459858348,
  1842789307,
  742004246
}; // weak
_UNKNOWN unk_1DBD68; // weak
_UNKNOWN unk_1DBD88; // weak
_UNKNOWN unk_1DBDA8; // weak
_UNKNOWN unk_1DBDE8; // weak
_QWORD qword_1DBE28[8] =
{
  7640891576956012808LL,
  -4942790177534073029LL,
  4354685564936845355LL,
  -6534734903238641935LL,
  5840696475078001361LL,
  -7276294671716946913LL,
  2270897969802886507LL,
  6620516959819538809LL
}; // weak
_UNKNOWN unk_1DBE68; // weak
_UNKNOWN unk_1DC048; // weak
_UNKNOWN unk_1DC0C8; // weak
_UNKNOWN unk_1DC148; // weak
_UNKNOWN unk_1DC1C8; // weak
_UNKNOWN *off_1EC254 = (_UNKNOWN *)0x20BBD; // weak
_UNKNOWN *off_1EC258 = (_UNKNOWN *)0x20BA5; // weak
char need_pattern = '\x01'; // weak
int gChain = -1; // weak
char *off_1EC5CC[33] =
{
  "grin29",
  "vbk",
  "ckb",
  "ae",
  "grin32",
  "eth",
  "ltc",
  "dash",
  "ckb2",
  "dcr",
  "unknow",
  "grin29",
  "vbk",
  "ckb",
  "ae",
  "grin32",
  "eth",
  "ltc",
  "dash",
  "ckb2",
  "dcr",
  "unknow",
  "grin29",
  "vbk",
  "ckb",
  "ae",
  "grin32",
  "eth",
  "ltc",
  "dash",
  "ckb2",
  "dcr",
  "unknow"
}; // weak
int bitmain_MES_system_clientSocket = -1; // weak
const char submit_result_handshake_information[] = " "; // idb
char base_factory_config_file[40] = "/mnt/card/Config/MES_system/Config.ini-"; // weak
char factory_config_file[40] = "/mnt/card/Config/MES_system/Config.ini-"; // weak
char base_submit_result_file[32] = "/mnt/card/Result/submit.result-"; // weak
char submit_result_file[32] = "/mnt/card/Result/submit.result-"; // weak
int dword_1ED16C = 255; // weak
char *off_1ED170[11] =
{
  "grin29",
  "vbk",
  "ckb",
  "ae",
  "grin32",
  "eth",
  "ltc",
  "dash",
  "ckb2",
  "dcr",
  "unknow"
}; // weak
char eeprom_data_buf[] = { '\xFF' }; // weak
char byte_1ED19D = '\0'; // weak
unsigned int dword_1ED19E[23] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
char gCode_gun_chain = '\xFF'; // weak
_UNKNOWN unk_1ED200; // weak
char byte_1ED204 = '\x80'; // weak
int dword_1ED208 = 1; // weak
char byte_1ED228 = '\x98'; // weak
int dword_1ED22C = 1; // weak
char byte_1ED24C = '\xA0'; // weak
int dword_1ED250 = 1; // weak
char byte_1ED270 = '\x90'; // weak
int dword_1ED274 = 1; // weak
char byte_1ED294 = '\x88'; // weak
int dword_1ED298 = 1; // weak
char byte_1ED2B4 = '\x01'; // weak
int fan_pwm = 100; // weak
int dword_1ED3C4 = 2147483647; // weak
int dword_1ED3C8 = 2147483647; // weak
_UNKNOWN unk_1ED3CC; // weak
_UNKNOWN unk_1ED3D4; // weak
_UNKNOWN unk_1ED3DC; // weak
void *(*off_1ED3E4)(size_t size) = &malloc; // weak
void (*off_1ED3E8)(void *ptr) = &free; // weak
_UNKNOWN *off_1ED4A0 = (_UNKNOWN *)0x4B2C5; // weak
_UNKNOWN *off_1ED7E0 = (_UNKNOWN *)0x4B2C5; // weak
_UNKNOWN *off_1EDB70 = (_UNKNOWN *)0x4B2C5; // weak
_UNKNOWN *off_1EDEB0 = (_UNKNOWN *)0x4B2C5; // weak
_UNKNOWN *off_1EE1F0 = (_UNKNOWN *)0x4B2C5; // weak
int dword_1EE4F4 = 0; // weak
_UNKNOWN *off_1EE530 = (_UNKNOWN *)0x4B2C5; // weak
_UNKNOWN *off_1EE870 = (_UNKNOWN *)0x4B2C5; // weak
_UNKNOWN *off_1EEBB0 = (_UNKNOWN *)0x4B2C5; // weak
char byte_1EEF8C = '\x01'; // weak
int dword_1EEF90 = 287453952; // weak
int dword_1EEF98 = 1146447360; // weak
_UNKNOWN *off_1EEFA0 = (_UNKNOWN *)0x4B2C5; // weak
_UNKNOWN *off_1EF330 = (_UNKNOWN *)0x4B2C5; // weak
int dword_1EF698 = -1; // weak
char *lcd_path[34] =
{
  "/dev/bitmain-lcd",
  "grin29",
  "vbk",
  "ckb",
  "ae",
  "grin32",
  "eth",
  "ltc",
  "dash",
  "ckb2",
  "dcr",
  "unknow",
  "grin29",
  "vbk",
  "ckb",
  "ae",
  "grin32",
  "eth",
  "ltc",
  "dash",
  "ckb2",
  "dcr",
  "unknow",
  "grin29",
  "vbk",
  "ckb",
  "ae",
  "grin32",
  "eth",
  "ltc",
  "dash",
  "ckb2",
  "dcr",
  "unknow"
}; // weak
_UNKNOWN *off_1EF724 = (_UNKNOWN *)0xF41ED; // weak
int dword_1EF838[] = { -267997795 }; // weak
int dword_1EF840 = -1246842578; // weak
int dword_1EF848 = -1032370606; // weak
int dword_1EF850 = 1180234323; // weak
int dword_1EF858 = -880206250; // weak
int dword_1EF860 = 704332193; // weak
int dword_1EF868 = 1012972200; // weak
int dword_1EF870 = 529878509; // weak
unsigned __int8 byte_1EF878[256] =
{
  0u,
  1u,
  2u,
  3u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  14u,
  10u,
  4u,
  8u,
  9u,
  15u,
  13u,
  6u,
  1u,
  12u,
  0u,
  2u,
  11u,
  7u,
  5u,
  3u,
  11u,
  8u,
  12u,
  0u,
  5u,
  2u,
  15u,
  13u,
  10u,
  14u,
  3u,
  6u,
  7u,
  1u,
  9u,
  4u,
  7u,
  9u,
  3u,
  1u,
  13u,
  12u,
  11u,
  14u,
  2u,
  6u,
  5u,
  10u,
  4u,
  0u,
  15u,
  8u,
  9u,
  0u,
  5u,
  7u,
  2u,
  4u,
  10u,
  15u,
  14u,
  1u,
  11u,
  12u,
  6u,
  8u,
  3u,
  13u,
  2u,
  12u,
  6u,
  10u,
  0u,
  11u,
  8u,
  3u,
  4u,
  13u,
  7u,
  5u,
  15u,
  14u,
  1u,
  9u,
  12u,
  5u,
  1u,
  15u,
  14u,
  13u,
  4u,
  10u,
  0u,
  7u,
  6u,
  3u,
  9u,
  2u,
  8u,
  11u,
  13u,
  11u,
  7u,
  14u,
  12u,
  1u,
  3u,
  9u,
  5u,
  0u,
  15u,
  4u,
  8u,
  6u,
  2u,
  10u,
  6u,
  15u,
  14u,
  9u,
  11u,
  3u,
  0u,
  8u,
  12u,
  2u,
  13u,
  7u,
  1u,
  4u,
  10u,
  5u,
  10u,
  2u,
  8u,
  4u,
  7u,
  6u,
  1u,
  5u,
  15u,
  11u,
  9u,
  14u,
  3u,
  12u,
  13u,
  0u,
  0u,
  1u,
  2u,
  3u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  14u,
  10u,
  4u,
  8u,
  9u,
  15u,
  13u,
  6u,
  1u,
  12u,
  0u,
  2u,
  11u,
  7u,
  5u,
  3u,
  11u,
  8u,
  12u,
  0u,
  5u,
  2u,
  15u,
  13u,
  10u,
  14u,
  3u,
  6u,
  7u,
  1u,
  9u,
  4u,
  7u,
  9u,
  3u,
  1u,
  13u,
  12u,
  11u,
  14u,
  2u,
  6u,
  5u,
  10u,
  4u,
  0u,
  15u,
  8u,
  9u,
  0u,
  5u,
  7u,
  2u,
  4u,
  10u,
  15u,
  14u,
  1u,
  11u,
  12u,
  6u,
  8u,
  3u,
  13u,
  2u,
  12u,
  6u,
  10u,
  0u,
  11u,
  8u,
  3u,
  4u,
  13u,
  7u,
  5u,
  15u,
  14u,
  1u,
  9u
}; // weak
_QWORD qword_1EF978[33] =
{
  -6549524092871383040LL,
  -3216926870969632768LL,
  -6594613858476781568LL,
  868906878963180680LL,
  5712024393863467499LL,
  4394605518411334188LL,
  5045910881260042717LL,
  -4926843755437766656LL,
  5987067145339136795LL,
  -3341658112243943424LL,
  3450974313248867902LL,
  -7446784132049864704LL,
  -4972871168744972288LL,
  7251808426145424871LL,
  -2856998567947870208LL,
  7194923001510760043LL,
  8078043211674344LL,
  8078077571412724LL,
  8078129111020284LL,
  8078163470758664LL,
  8078232190235412LL,
  -4293086432LL,
  8220258168812608LL,
  8220292528550988LL,
  8220344068158548LL,
  8220378427896928LL,
  8220447147373676LL,
  8223591063434360LL,
  8223642603042648LL,
  8223676962781024LL,
  8223728502388588LL,
  8223780041996148LL,
  8223831581603716LL
}; // weak
_UNKNOWN xxtea_key; // weak
_DWORD bit_matrix[256] =
{
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1
}; // weak
_DWORD coefficients[48] =
{
  0,
  2,
  4,
  0,
  13,
  22,
  0,
  4,
  19,
  0,
  3,
  14,
  0,
  27,
  31,
  0,
  3,
  8,
  0,
  17,
  26,
  0,
  3,
  12,
  0,
  18,
  22,
  0,
  12,
  18,
  0,
  4,
  7,
  0,
  4,
  31,
  0,
  12,
  27,
  0,
  7,
  17,
  0,
  7,
  8,
  0,
  1,
  13
}; // weak
_DWORD injection_constants[688] =
{
  1855865006,
  1905425410,
  -1709976655,
  -622054739,
  1032409551,
  -506855782,
  -1207519924,
  -1396968425,
  -748541125,
  -1602062806,
  -1629687360,
  -1447372169,
  2140267628,
  -888181169,
  643666497,
  -1212290384,
  1650510310,
  -11477718,
  -1875465615,
  -837412743,
  -785351457,
  -1981524257,
  -130993182,
  1710578749,
  -1803085055,
  -1244527411,
  1480208996,
  1578522967,
  1287498084,
  1734330951,
  -190643394,
  708932386,
  996229935,
  2136290034,
  -1240885445,
  444158521,
  833910729,
  -762012376,
  2023134994,
  246971246,
  2115097133,
  -856782659,
  -288325960,
  -447333759,
  -406098993,
  635344190,
  1292199226,
  193140055,
  -1799762569,
  334501241,
  2034977354,
  1743243228,
  -1000941356,
  1500028059,
  1719949015,
  584229601,
  951298088,
  51751996,
  1133340702,
  -1418655291,
  -1746003544,
  -570021074,
  745981051,
  8668527,
  -1869672493,
  -1505340129,
  1048733477,
  -719226738,
  -1627274576,
  -1827140388,
  -1830150664,
  1125817006,
  2083431254,
  -634147581,
  1184000147,
  1723721687,
  -1258173323,
  527338049,
  1750225140,
  1001517848,
  -1356624892,
  -1756441876,
  1528143433,
  -718866241,
  302536230,
  1042559657,
  1808927816,
  522017242,
  413864040,
  -2131215112,
  747377088,
  2102689845,
  267810243,
  -19832641,
  1958460196,
  -645005205,
  -559265813,
  99751838,
  1132137329,
  -1479975025,
  11115835,
  1069794372,
  1919446926,
  16581033,
  -556005497,
  -961579482,
  1880292982,
  -224004146,
  -1703203110,
  1582824690,
  1302385837,
  1550037333,
  873558901,
  -736932847,
  782726197,
  1383642846,
  -1420678068,
  -1131428094,
  -917894684,
  -340182370,
  -1846757794,
  1280502982,
  -2029798574,
  -886218582,
  815813514,
  353693963,
  360669993,
  875158589,
  1572290226,
  -1482577559,
  1921432868,
  234260510,
  931510879,
  -855350726,
  41255280,
  -668469930,
  -1713811055,
  -2075820367,
  1487403810,
  -761889697,
  1326199798,
  1241647514,
  -527415263,
  -1810743242,
  1231684379,
  2014013892,
  -820360921,
  -2019485256,
  -839191304,
  1291439375,
  667511428,
  1829835134,
  2139945031,
  1959718373,
  -930544154,
  1612798017,
  1903331162,
  1936628026,
  17474876,
  1138048043,
  -254207341,
  228080470,
  -132749764,
  -439274653,
  174158716,
  164958544,
  -2086294481,
  1049118981,
  2063707829,
  1611296423,
  -1217949829,
  1924368759,
  109058290,
  -831855525,
  689474216,
  -442453527,
  -1068749946,
  -1949217419,
  1686602227,
  -609346038,
  -573712210,
  -1420983901,
  1147906746,
  482394525,
  398348176,
  -2101287331,
  1735367829,
  1550880178,
  1876215911,
  -1525649680,
  433972381,
  2014850965,
  -796275327,
  -1557227266,
  -1104122750,
  1826110860,
  58661854,
  185954861,
  -304341470,
  -1815648935,
  -1976608997,
  -1832091212,
  35353719,
  1733441796,
  -916603700,
  -1407717731,
  -1806809412,
  125929086,
  -933962339,
  652395276,
  -2054421482,
  1832482568,
  -337470376,
  -938676858,
  -728320853,
  -1102715147,
  282216198,
  -1393026950,
  -1762319413,
  573038915,
  2026071396,
  1178840514,
  1193924986,
  -805749235,
  625494973,
  -1849263730,
  -1778945036,
  1142965877,
  786061242,
  114496495,
  -290831258,
  771388720,
  -1464922981,
  972116830,
  214087613,
  950496270,
  1329661725,
  -844159883,
  1235677176,
  23205704,
  921414827,
  -1116890583,
  1154600293,
  1082220029,
  1442470426,
  -2016613911,
  -1370121403,
  -680834010,
  1669161133,
  -567675399,
  -1756816197,
  -80412608,
  -1574505,
  538746317,
  -434954007,
  -1458993245,
  -498402685,
  1640097532,
  -863502494,
  -238429958,
  1339049286,
  -1863530642,
  1189369529,
  811454136,
  -165157236,
  757622805,
  -955925507,
  270233075,
  -1993494942,
  -709362876,
  -367174508,
  1395844043,
  -128518006,
  -1287540503,
  675319197,
  1411496983,
  -342165060,
  1612935621,
  1738037905,
  -680226689,
  2085448061,
  -1821331272,
  1878380219,
  2101761860,
  1733094080,
  -359595268,
  233392004,
  -946610583,
  -27681871,
  -961702609,
  1835837891,
  -1836302447,
  -117297403,
  614556892,
  -437678893,
  1984557019,
  1844690139,
  1562288113,
  401985552,
  -496472415,
  1856796670,
  2075510149,
  -1999041349,
  409506147,
  1741287333,
  -1061720677,
  -1777402965,
  -1115215865,
  1895089268,
  1455594784,
  -783016683,
  -2011992013,
  -470799554,
  -1227246963,
  1403025338,
  -287518050,
  -1526043619,
  314736670,
  1387934555,
  899171860,
  -497444184,
  -1349194467,
  -653441177,
  539786503,
  2008990964,
  -93209472,
  -61043850,
  -1928348676,
  -633967162,
  -1959616313,
  456587260,
  1715657916,
  1877468964,
  -1956665470,
  -1004375036,
  981278119,
  1367266904,
  -1978081427,
  1046256419,
  532500975,
  342908957,
  872429724,
  1735067229,
  -2006667904,
  -361817444,
  766805217,
  1619494384,
  -1915517777,
  1775396505,
  1083985430,
  2012846186,
  2135495270,
  -2009159985,
  -358588302,
  -97624651,
  891655348,
  -1856586871,
  -1560560645,
  -1405515321,
  1847861937,
  1478440288,
  269068725,
  2119883213,
  -1443100050,
  1139120526,
  2139584761,
  -264701727,
  1410712296,
  1687795505,
  -1205630546,
  97835033,
  252068878,
  -244098400,
  -1738264338,
  1206687020,
  -1089168187,
  -1278530378,
  1061284034,
  656065819,
  1219255789,
  -144046999,
  1903934029,
  1331466454,
  997521238,
  405016842,
  -1526905885,
  514871420,
  -1455989752,
  360470951,
  212701009,
  -698338912,
  -1414187969,
  -449578429,
  429318843,
  -678086031,
  -766338156,
  1492187655,
  1285232759,
  92182797,
  -1946281532,
  -1461534519,
  -1711494438,
  1775413962,
  -602126782,
  -187555065,
  2145549964,
  325495303,
  362079799,
  -837785921,
  -611179182,
  -1724861142,
  -1364551106,
  838827700,
  1579127898,
  353027228,
  214805549,
  -660037097,
  -1204902171,
  -693680551,
  1740104678,
  -2089881782,
  -1225195404,
  2141448779,
  -888962781,
  -1090085035,
  531120068,
  -689186013,
  384868663,
  430379277,
  1609807199,
  -77383576,
  -1268320187,
  -1126121064,
  -2009054570,
  -574760821,
  2143626566,
  1671779320,
  -1490534310,
  931802062,
  1751311728,
  -273187203,
  -971939234,
  844192789,
  1770305381,
  -398435978,
  -1683781891,
  -722545447,
  -117570807,
  216352257,
  -1158121022,
  -665698217,
  495721850,
  1925227433,
  1512045534,
  -2097989051,
  1363407942,
  700965250,
  -449395921,
  1517233243,
  1143417563,
  -881844836,
  -144623636,
  138539333,
  -419156276,
  -249070121,
  1952250156,
  -1459722754,
  -740108337,
  1422201839,
  1618590765,
  -1235011920,
  270415931,
  -1126738093,
  633217930,
  1453781182,
  -285225961,
  1587748669,
  182940405,
  -143793186,
  465489325,
  -921666237,
  -136081970,
  1635997901,
  1552105220,
  -157853434,
  -566134811,
  1741886684,
  -1267331266,
  1456363656,
  243484072,
  -1074351681,
  2027925778,
  -244278242,
  2075717003,
  -1876688199,
  -626636064,
  1186405769,
  2129527647,
  -1103665911,
  -1721462982,
  140765727,
  1236109447,
  2042490053,
  1007727976,
  1596869550,
  82780331,
  1928908411,
  1377705662,
  340940085,
  780859739,
  -1869296387,
  -1124899053,
  -952544273,
  -726068108,
  1700064301,
  -477602666,
  64779191,
  -1827239767,
  -876678782,
  729272265,
  1663709885,
  -770613812,
  451236669,
  845696531,
  1288019972,
  322051038,
  1657525133,
  2016950843,
  -804878607,
  -1621090585,
  2125407198,
  823182482,
  -1674243575,
  2126028114,
  1834380972,
  -1024470490,
  854194885,
  1377989236,
  167266085,
  -1194281467,
  1915297538,
  1907737419,
  1035979704,
  77603427,
  1438275967,
  -723254403,
  -938221122,
  -2232582,
  -1010804493,
  -2029973714,
  503117151,
  -963318037,
  -1447028108,
  -1732051861,
  -444722136,
  -584689039,
  -2090101395,
  2118560538,
  1479923009,
  1353917701,
  -431976132,
  -1152884615,
  -28745117,
  289168233,
  -1815255520,
  1593737787,
  761625408,
  -1267860372,
  1467026537,
  -23089685,
  -1242008950,
  -484294288,
  -903301295,
  -39080362,
  1521560636,
  -1500003241,
  -762338633,
  90536434,
  -1613113328,
  -480938888,
  -661812821,
  -1490381790,
  1833413584,
  1079757785,
  1870916527,
  332065910,
  -51667230,
  781331959,
  -828877089,
  -1067543774,
  661833812,
  -1233180110,
  1830482573,
  980995959,
  -537652764,
  1640451241,
  -309623762,
  1921517637,
  1854238853,
  -968865486,
  -298322244,
  655454024,
  1587463258,
  -1901943521,
  -1521009225,
  -1488531402,
  1214990184,
  1531154235,
  415582812,
  1694298254,
  -376189503,
  901901011,
  -1646232089,
  840664092,
  -2025702306,
  119185654,
  -1775323301,
  -1157186094,
  -589606045,
  949441266,
  -2082878328,
  -803951162,
  -955178565,
  594737464,
  -889248176,
  1656654161,
  1457310463,
  -1405057856,
  158412437,
  490481807,
  453531460,
  -506212369,
  1553629486,
  1712455001,
  -2048630716,
  427939973,
  1514967103,
  1140002123,
  2099077147,
  -583257199,
  51299934,
  -1054312243,
  1927779838,
  -792237379,
  515933659,
  2092655098,
  -1813455586,
  -2055017722,
  1935028548,
  77418110,
  1607839486,
  2072259072,
  1976489573,
  -1154296744,
  1317256103,
  -1894443745,
  2006294821,
  -259775403,
  1234893213,
  1448921082,
  -1548671091,
  1059573364,
  -1765145202,
  -1974897597,
  -1493463890,
  -1055544799,
  391137571,
  -460119038,
  -1364687166,
  -1900569867,
  -338302357,
  -946336453,
  1899402005,
  2037279334,
  981387016,
  -1336838712,
  -534022937,
  -348685613,
  1821122388,
  -1182743692,
  1504633473,
  1151121305,
  -534817275,
  -317847458,
  -912153676,
  -1429962319,
  -919223396,
  -1210528129
}; // weak
int num_rounds = 43; // weak
int rate = 256; // weak
char aAbcdefghijklmn[66] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; // weak
int blake256_rounds = 14; // weak
int stdin; // weak
char byte_1F0C7C; // weak
int g_patten_offset; // weak
char gScanCodeGun_data_ready; // weak
int pcba_total_device_no; // weak
int dword_1F0C8C; // weak
int dword_1F0C90; // weak
int dword_1F0C94; // weak
int g_config_info; // weak
_UNKNOWN unk_1F0C9C; // weak
int mes_system_handshake_file_length; // weak
int MES_system_Config_information; // weak
int mes_system_config_file_length; // weak
int MES_system_config_File; // weak
int mes_system_submit_result_file_length; // weak
int Mes_System_Config_File_Information; // weak
int gConfigs_array_size; // weak
int gHw_info_array_size; // weak
int gPower_version_array_size; // weak
int gPattern_array_size; // weak
int gAsic_reg_array_size; // weak
int gTest_method_array_size; // weak
int gTest_config_array_size; // weak
int gData_array_size; // weak
int gTest_loop_array_size; // weak
int gTest_loop_id_array_size; // weak
char gFind_test_standard; // weak
int dword_1F0D68; // weak
pthread_mutex_t stru_1F0D6C; // weak
int dword_1F0D84; // weak
char byte_1F0D88[256]; // weak
_UNKNOWN gHistory_Result; // weak
_UNKNOWN unk_20314C; // weak
_UNKNOWN unk_20324C; // weak
_UNKNOWN unk_20334C; // weak
_UNKNOWN unk_20344C; // weak
_UNKNOWN unk_20354C; // weak
_UNKNOWN unk_288ED0; // weak
_UNKNOWN unk_2DC6C0; // weak
char byte_2FAF08[1061112]; // weak
_UNKNOWN unk_3FE000; // weak
int gTest_loop; // weak
int ret_str; // weak
int MES2Local_Config_Information; // weak
char byte_479DB0; // weak
char byte_479DB4; // weak
__int16 word_479DB6; // weak
_UNKNOWN unk_479DB8; // weak
int dword_479DBC; // weak
char byte_479DC0; // weak
int dword_479DC4; // weak
char byte_479DC8; // weak
char byte_479DC9; // weak
int dword_479DCC; // weak
int dword_479DD0; // weak
char fan_pwm_fixed; // weak
char byte_479DD5; // weak
int dword_479DD8; // weak
int hashtable_seed; // weak
unsigned __int8 byte_479DE0[4]; // weak
_DWORD dword_479DE4[32]; // weak
int dword_479E64; // weak
_DWORD dword_479E68[16]; // weak
int dword_479EA8; // weak
_DWORD dword_479EAC[256]; // weak
int dword_47A2AC; // weak
pthread_mutex_t stru_47A2B0; // weak
int dword_47A2D0[1025]; // weak
_UNKNOWN unk_47B2D4; // weak
_UNKNOWN unk_47B2D8; // weak
_UNKNOWN unk_47B2DC; // weak
_UNKNOWN unk_47B2E0; // weak
_UNKNOWN unk_47B2E4; // weak
_UNKNOWN unk_47B2E8; // weak
_UNKNOWN unk_47B2EC; // weak
_UNKNOWN unk_47B2F0; // weak
int dword_47B2F4; // weak
pthread_mutex_t i2c_mutex_all; // weak
char byte_47B310; // weak
int dword_47B314; // weak
int dword_47B318; // weak
int dword_47B31C; // weak
int dword_47B320; // weak
int dword_47B324; // weak
pthread_mutex_t stru_47B328; // weak
int dword_47B340; // weak
int dword_47B344; // weak
int dword_47B348; // weak
int dword_47B34C; // weak
int (__fastcall *dword_47B350[5])(int, bool); // weak
pthread_mutex_t stru_47B364; // weak
int platform_inited; // weak
pthread_mutex_t tw_cmd_acc_mutex; // weak
pthread_mutex_t bc_cmd_acc_mutex; // weak
_UNKNOWN unk_47B3B0; // weak
int dword_47B4D4; // weak
int dword_47B4D8; // weak
pthread_mutex_t stru_47B4DC; // weak
_UNKNOWN unk_47B4F4; // weak
_DWORD dword_47B534[4]; // weak
pthread_mutex_t stru_47B544; // weak
int dword_47B55C; // weak
int dword_47B560; // weak
int dword_47B564; // weak
int dword_47B568; // weak
int dword_47B56C; // weak
pthread_mutex_t stru_47B570; // weak
pthread_mutex_t stru_47B588; // weak
int dword_47B5A0; // weak
pthread_mutex_t stru_47B5A4[16]; // weak
pthread_mutex_t stru_47B724[16]; // weak
pthread_mutex_t power_mutex; // weak
int dword_47B8C0; // weak
int dword_47B8C4; // weak
int dword_47B8C8; // weak
_UNKNOWN unk_47B8D0; // weak
int dword_47B930; // weak
_DWORD dword_47B938[256]; // weak
int total_chain; // weak
_DWORD dword_47BD3C[4]; // weak
_UNKNOWN unk_47BD4C; // weak
_UNKNOWN unk_47BD50; // weak
_UNKNOWN unk_47BD54; // weak
_UNKNOWN unk_47BD58; // weak
pthread_mutex_t stru_47BD5C; // weak
_QWORD qword_47BD78[4]; // weak
_QWORD qword_47BD98[4]; // weak
_QWORD qword_47BDB8[4]; // weak
_QWORD qword_47BDD8[4]; // weak
pthread_mutex_t stru_47BDF8; // weak
int dword_47BE10; // weak
int opt_zlog_conf_file; // weak
int g_zc; // weak
int g_temp_zc; // weak
int g_fan_zc; // weak
int g_hash_zc; // weak
int g_logwork_file; // weak
char g_pcba_info; // weak
pthread_t dword_47BE30; // idb
pthread_t newthread; // idb
pthread_t dword_47BE38; // idb
pthread_t dword_47BE3C; // idb
pthread_t dword_47BE40; // idb
int dword_47BE54; // weak
int dword_47BE58; // weak
int dword_47BE5C; // weak
int dword_47BE60; // weak
int dword_47BE64; // weak
int dword_47BE68; // weak
float flt_47BE70; // weak
int dword_47BE74; // weak
int dword_47BE78; // weak
int dword_47BE7C; // weak
char byte_47BE80; // weak
char byte_47BE81; // weak
char byte_47BE82; // weak
int (__fastcall *off_47BE88)(_DWORD); // weak
int (__fastcall *off_47BE8C)(_DWORD, _DWORD); // weak
int (__fastcall *off_47BE90)(_DWORD); // weak
int (__fastcall *off_47BE94)(_DWORD); // weak
int dword_47BE98; // weak
int (__fastcall *off_47BE9C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_47BEA0; // weak
int g_lcd_result_with_data; // weak
char dest[16]; // idb
char byte_47BEB9[34]; // idb
char dword_47BEDB[]; // idb
int dword_47BEDF; // weak
unsigned __int8 APW_power_version[8]; // weak
char qr_code[32]; // weak
char word_47BF14[16]; // weak
char dword_47BF24[]; // idb
int dword_47BF28; // weak
int dword_47BF2C; // weak
char byte_47BF30; // weak
char byte_47BF34[16]; // idb
char src[]; // idb
int dword_47BF48; // weak
char byte_47BF4C; // weak
char byte_47BF54[16]; // weak
char byte_47BF64[16]; // idb
char byte_47BF74[16]; // weak
_UNKNOWN sn; // weak
char s[]; // idb
int dword_47BF89; // weak
int dword_47BF8D; // weak
int dword_47BF91; // weak
char byte_47BF95; // weak
int gAsic_sensor_num; // weak
_DWORD fpga_type[4]; // weak
char opt_custom_voltage_swith; // weak
int gPic_sensor_num; // weak
char zhiju_eeprom_data; // weak
char byte_47BFC5; // weak
char byte_47BFC6; // weak
int dword_47BFC7; // weak
int dword_47BFCB; // weak
int dword_47BFCF; // weak
int dword_47BFD3; // weak
char byte_47BFD7; // weak
__int16 word_47BFD8; // weak
int dword_47BFDA; // weak
int dword_47BFDE; // weak
int dword_47BFE2; // weak
char byte_47BFE6; // weak
char byte_47BFE7; // weak
int dword_47BFE8; // weak
int dword_47BFEC; // weak
char byte_47BFF0; // weak
char byte_47BFF1; // weak
char byte_47BFF2; // weak
char byte_47BFF3; // weak
char byte_47BFF4; // weak
char byte_47BFF5; // weak
char byte_47BFF6; // weak
char byte_47BFF7; // weak
char byte_47BFF8; // weak
char byte_47BFF9; // weak
char byte_47BFFA; // weak
char byte_47BFFB; // weak
char byte_47BFFC; // weak
char byte_47BFFD; // weak
char byte_47BFFE; // weak
char byte_47BFFF; // weak
char byte_47C000; // weak
char byte_47C001; // weak
char byte_47C002; // weak
char byte_47C003; // weak
char byte_47C004; // weak
char byte_47C005; // weak
char byte_47C006; // weak
char byte_47C007; // weak
char byte_47C008[13]; // weak
char byte_47C015; // weak
int opt_custom_voltage; // weak
_DWORD pcba_chain_info[4]; // weak
int opt_algo; // weak
_UNKNOWN last_header_ckb; // weak
_UNKNOWN last_header_dash; // weak
_UNKNOWN last_header_dcr; // weak
_UNKNOWN last_header_ckb2; // weak
_UNKNOWN last_header; // weak
_UNKNOWN last_work_ltc; // weak
_DWORD g_bitmain_pic_state[32]; // weak
_DWORD g_chain_info[32]; // weak
unsigned int vs[2048]; // weak
_DWORD gEdges[336]; // weak
_BYTE gSols[688]; // weak
unsigned int us[2048]; // weak
_DWORD cuckoo[4]; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00020594) --------------------------------------------------------
// Alternative name is '_init'
int init_proc()
{
  return sub_20B30();
}

//----- (000205A0) --------------------------------------------------------
void sub_205A0()
{
  JUMPOUT(0);
}
// 205AC: control flows out of bounds to 0

//----- (00020B00) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())_libc_csu_init,
    (void (*)())_libc_csu_fini,
    a1,
    va);
  abort();
}
// 20B0A: positive sp value 4 has been found
// 20B1C: variable 'v4' is possibly undefined
// 1A406C: using guessed type int _libc_csu_fini();

//----- (00020B30) --------------------------------------------------------
int sub_20B30()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 2086C: using guessed type int _gmon_start__(void);

//----- (00020B54) --------------------------------------------------------
int *sub_20B54()
{
  return &stdin;
}
// 1F0C78: using guessed type int stdin;

//----- (00020B78) --------------------------------------------------------
int register_tm_clones()
{
  return 2034808;
}

//----- (00020BA4) --------------------------------------------------------
int *sub_20BA4()
{
  int *result; // r0

  if ( !byte_1F0C7C )
  {
    result = sub_20B54();
    byte_1F0C7C = 1;
  }
  return result;
}
// 1F0C7C: using guessed type char byte_1F0C7C;

//----- (00020BBC) --------------------------------------------------------
int frame_dummy()
{
  return register_tm_clones();
}

//----- (00020BE0) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_20BE0(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (00020C04) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_20C04(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (00020C2C) --------------------------------------------------------
int __fastcall sub_20C2C(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 20C70: variable 'v3' is possibly undefined

//----- (00020D0C) --------------------------------------------------------
int __fastcall sub_20D0C(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00020E10) --------------------------------------------------------
_BYTE *__fastcall sub_20E10(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (00020E58) --------------------------------------------------------
int __fastcall sub_20E58(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_LTC", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_get_addr_LTC",
    24,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_20C04((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_LTC",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_get_addr_LTC",
    24,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_get_addr_LTC",
      24,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
          74,
          "ChipSetting_get_addr_LTC",
          24,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_20C04((int)v12, *(int *)(a1 + 140));
    sub_20BE0(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_get_addr_LTC",
      24,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 20FB0: variable 'v4' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00021440) --------------------------------------------------------
int __fastcall sub_21440(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_LTC", 52);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_software_reset_LTC",
    30,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 3407873;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00021534) --------------------------------------------------------
int __fastcall sub_21534(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_LTC", 52);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_software_reset_one_asic_LTC",
    39,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 52;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00021644) --------------------------------------------------------
int __fastcall sub_21644(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1572865;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_misc_LTC",
    20,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000218D8) --------------------------------------------------------
int __fastcall sub_218D8(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1572865;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_misc_eth_LTC",
    24,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00021AFC) --------------------------------------------------------
unsigned int *__fastcall sub_21AFC(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 21B34: variable 'v1' is possibly undefined

//----- (00021C0C) --------------------------------------------------------
int __fastcall sub_21C0C(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 524289;
  sub_21AFC(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_freq_LTC",
    20,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 21C8C: variable 'v1' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00021D60) --------------------------------------------------------
int __fastcall sub_21D60(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 8;
  sub_21AFC(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_one_asic_freq_LTC",
    29,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 21E02: variable 'v2' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00021EE0) --------------------------------------------------------
int __fastcall sub_21EE0(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_LTC", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_clk_count_LTC",
    25,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 48;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 48 )
        {
          sub_20E10(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_20C04((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_LTC",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
            74,
            "ChipSetting_clk_count_LTC",
            25,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_LTC", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_clk_count_LTC",
      25,
      436,
      100,
      v5);
    return -1;
  }
}
// 220EE: variable 'v3' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000222CC) --------------------------------------------------------
int __fastcall sub_222CC(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 2883585;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_analog_mux_LTC",
    26,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000223E8) --------------------------------------------------------
int __fastcall sub_223E8(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 28;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (00022434) --------------------------------------------------------
int __fastcall sub_22434(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 28;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (00022554) --------------------------------------------------------
int __fastcall sub_22554(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_223E8(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_22434(a1, a2, a3, s, a6, n);
}

//----- (000225C8) --------------------------------------------------------
int __fastcall sub_225C8(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_22554(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0002266C) --------------------------------------------------------
int __fastcall sub_2266C(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_22554(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00022710) --------------------------------------------------------
int __fastcall sub_22710(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_22554(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00022774) --------------------------------------------------------
int __fastcall sub_22774(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_22554(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (000227D8) --------------------------------------------------------
int __fastcall sub_227D8(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_read_sensor_temp_local_on_pic_LTC",
        45,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_read_sensor_temp_local_on_pic_LTC",
      45,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000229B0) --------------------------------------------------------
int __fastcall sub_229B0(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_read_sensor_temp_remote_on_pic_LTC",
        46,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_read_sensor_temp_remote_on_pic_LTC",
      46,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00022B8C) --------------------------------------------------------
int __fastcall sub_22B8C(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_223E8(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00022BC4) --------------------------------------------------------
int __fastcall sub_22BC4(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 2359297;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00022C18) --------------------------------------------------------
int __fastcall sub_22C18(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 36;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 36 )
    {
      V_LOCK();
      sub_20C04((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_get_crc_status_LTC",
        30,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00022EE4) --------------------------------------------------------
int __fastcall sub_22EE4(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (00022F70) --------------------------------------------------------
unsigned int __fastcall sub_22F70(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0x5A0u);
  memset(v13, 0, 0x5A0u);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 120, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_20C04((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_get_chip_status_LTC",
        31,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00023220) --------------------------------------------------------
int __fastcall sub_23220(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (00023268) --------------------------------------------------------
int __fastcall sub_23268(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000232C0) --------------------------------------------------------
int __fastcall sub_232C0(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00023320) --------------------------------------------------------
int __fastcall sub_23320(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00023384) --------------------------------------------------------
int __fastcall sub_23384(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000233E0) --------------------------------------------------------
int __fastcall sub_233E0(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = 117 * *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_LTC", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_get_core_status_LTC",
    31,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_20C04((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_get_core_status_LTC",
      31,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 235A0: variable 'v5' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00023764) --------------------------------------------------------
int __fastcall sub_23764(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 117;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_LTC", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_get_single_chip_core_status_LTC",
    43,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_20C04((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_get_single_chip_core_status_LTC",
      43,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 23914: variable 'v6' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00023ADC) --------------------------------------------------------
int __fastcall sub_23ADC(int result, int a2)
{
  char v2; // [sp+Fh] [bp+Fh]
  int i; // [sp+10h] [bp+10h]
  int v4; // [sp+14h] [bp+14h]

  v4 = 0;
  for ( i = a2 - 1; v4 < i; --i )
  {
    v2 = *(_BYTE *)(v4 + result);
    *(_BYTE *)(v4 + result) = *(_BYTE *)(i + result);
    *(_BYTE *)(i + result) = v2;
    ++v4;
  }
  return result;
}

//----- (00023B38) --------------------------------------------------------
int __fastcall sub_23B38(int a1, unsigned __int8 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  (*(void (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
  return 1;
}

//----- (00023B80) --------------------------------------------------------
int __fastcall sub_23B80(int a1, unsigned __int8 a2, signed int a3, int a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _WORD s[8]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]
  signed int j; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]

  ptr = calloc(a3, 0xCu);
  memset(s, 0, sizeof(s));
  s[4] = 1;
  s[5] = a2;
  memset(ptr, 0, 12 * a3);
  (*(void (__fastcall **)(int, _WORD *, signed int, void *, int *))(a1 + 176))(a1, s, a3, ptr, &v9);
  for ( i = 0; i < v9; ++i )
  {
    for ( j = 0; j < a3; ++j )
    {
      if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) && a4 )
      {
        *(_BYTE *)(a4 + 8 * i) = *((_BYTE *)ptr + 12 * i + 4);
        *(_BYTE *)(a4 + 8 * i + 1) = *((_WORD *)ptr + 6 * i + 3);
        *(_DWORD *)(a4 + 8 * i + 4) = *((_DWORD *)ptr + 3 * i);
        break;
      }
    }
  }
  free(ptr);
  return v9;
}

//----- (00023CB8) --------------------------------------------------------
int __fastcall pcba_ltc_reg_init(int result)
{
  *(_DWORD *)(result + 304) = 1;
  return result;
}

//----- (00023CD4) --------------------------------------------------------
int pcba_is_ltc_asic_valid()
{
  return 1;
}

//----- (00023CEC) --------------------------------------------------------
int pcba_calc_ltc_core_num()
{
  return *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12);
}
// 1F0C98: using guessed type int g_config_info;

//----- (00023D10) --------------------------------------------------------
bool __fastcall sub_23D10(_DWORD *a1, char a2)
{
  _UNKNOWN **v2; // r0
  _UNKNOWN **v3; // r0
  _UNKNOWN **v4; // r0
  int v5; // r3
  unsigned int v9; // [sp+8h] [bp+8h]
  int v10; // [sp+Ch] [bp+Ch]

  v9 = a1[49];
  v10 = 0;
  a1[59] = 0;
  while ( a1[59] < v9 )
  {
    v5 = v10++;
    if ( v5 > 2 )
      break;
    sub_20E58((int)a1, v9);
    if ( a2 && a1[59] < v9 )
    {
      v2 = dev_ctrl();
      ((void (__fastcall *)(_DWORD))v2[7])(a1[34]);
      usleep(0x493E0u);
      v3 = dev_ctrl();
      ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v3[6])(a1[34], a1[191], a1[194]);
      v4 = dev_ctrl();
      ((void (__fastcall *)(_DWORD))v4[9])(a1[34]);
    }
    usleep(0x493E0u);
  }
  return a1[59] == v9;
}

//----- (00023DD8) --------------------------------------------------------
int __fastcall sub_23DD8(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (00023E28) --------------------------------------------------------
int __fastcall pcba_setup_all_chip_ltc(int a1)
{
  int v4; // [sp+Ch] [bp+Ch]
  int v5; // [sp+10h] [bp+10h]
  float v6; // [sp+14h] [bp+14h]

  v4 = *(_DWORD *)(a1 + 196);
  v6 = 900.0;
  v5 = 1;
  while ( v6 > 200.0 )
  {
    v6 = v6 - 50.0;
    chip_setting_freq_ltc(a1, 1, 0);
    usleep(0x30D40u);
    ++v5;
  }
  printf("set frequency to %.02f\n", v6);
  if ( !sub_23D10((_DWORD *)a1, 0) )
    return 3;
  *(_DWORD *)(a1 + 240) = sub_23DD8(*(_DWORD *)(a1 + 296), v4);
  (*(void (__fastcall **)(int, _DWORD, int))(a1 + 148))(a1, *(_DWORD *)(a1 + 296), v4);
  sub_222CC(a1, 0);
  return 0;
}

//----- (00023F04) --------------------------------------------------------
int __fastcall pcba_ltc_recv(int a1)
{
  _DWORD s[29]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 v5; // [sp+7Eh] [bp+7Eh]
  unsigned __int8 v6; // [sp+7Fh] [bp+7Fh]
  size_t *v7; // [sp+80h] [bp+80h]
  char v8; // [sp+87h] [bp+87h]

  memset(s, 0, 0x70u);
  (*(void (__fastcall **)(int, _DWORD *))(a1 + 32))(a1, s);
  v8 = s[3];
  v7 = (size_t *)(104 * g_patten_offset + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 8));
  v6 = ((unsigned __int8)(*((_BYTE *)v7 + 84) << 7) | (unsigned int)(*((_BYTE *)v7 + 85) >> 1)) / *(_DWORD *)(a1 + 240);
  v5 = *((_BYTE *)v7 + 84) >> 1;
  if ( s[3] != v5 || s[2] != v6 || memcmp(&s[20], v7 + 21, v7[23]) )
    return 0;
  ++v7[25];
  need_pattern = 1;
  return 1;
}
// 1EC5C4: using guessed type char need_pattern;
// 1F0C80: using guessed type int g_patten_offset;
// 1F0C98: using guessed type int g_config_info;

//----- (00023FF0) --------------------------------------------------------
int __fastcall pcba_ltc_send(int a1, int a2)
{
  _BYTE s[216]; // [sp+8h] [bp+8h] BYREF
  int v5; // [sp+E0h] [bp+E0h]
  int v6; // [sp+E4h] [bp+E4h]

  v6 = a2;
  v5 = 0;
  memset(s, 0, sizeof(s));
  memcpy(&s[72], (const void *)(v6 + 4), 0x50u);
  v5 = _byteswap_ulong(*(_DWORD *)(v6 + 84));
  v5 = (v5 - 10) << 7;
  s[72] = HIBYTE(v5);
  s[73] = BYTE2(v5);
  s[74] = BYTE1(v5);
  s[75] = v5;
  sub_23ADC((int)&s[72], 80);
  return (*(int (__fastcall **)(int, _BYTE *))(a1 + 24))(a1, s);
}

//----- (000240B8) --------------------------------------------------------
int __fastcall pcba_read_ltc_temperature(int a1, int *a2, int *a3, int *a4, int *a5, _DWORD *a6, _DWORD *a7)
{
  const char *v7; // r1
  const char *v8; // r3
  const char *v9; // r1
  const char *v10; // r3
  const char *v11; // r1
  const char *v12; // r2
  int v19; // [sp+24h] [bp+14h] BYREF
  int v20; // [sp+28h] [bp+18h] BYREF
  int v21; // [sp+2Ch] [bp+1Ch] BYREF
  int v22; // [sp+30h] [bp+20h] BYREF
  _DWORD *v23; // [sp+34h] [bp+24h]
  _DWORD *v24; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]

  v24 = *(_DWORD **)(a1 + 212);
  *a2 = -150;
  *a3 = 150;
  *a4 = -150;
  *a5 = 150;
  for ( i = 0; v24[1] > i; ++i )
  {
    v23 = (_DWORD *)(20 * i + *v24);
    v20 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 100))(
      a1,
      &v22,
      &v20,
      *v23,
      v23[1],
      v23[2],
      v23[3],
      v23[4]);
    if ( v20 )
    {
      ++*a6;
      if ( *a2 < v22 )
        *a2 = v22;
      if ( *a3 > v22 )
        *a3 = v22;
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + i + 265784) = v22;
    }
    else
    {
      if ( *(_DWORD *)(20 * i + *v24 + 8) )
        v7 = "ARI-OUT";
      else
        v7 = "AIR-IN";
      if ( *(_DWORD *)(20 * i + *v24 + 12) )
        v8 = "BOTTOM";
      else
        v8 = "TOP";
      printf("Read local temp error. Error sensor loacation: %s %s\n", v7, v8);
    }
    v19 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 104))(
      a1,
      &v21,
      &v19,
      *v23,
      v23[1],
      v23[2],
      v23[3],
      v23[4]);
    if ( v19 )
    {
      ++*a7;
      if ( *a4 < v21 )
        *a4 = v21;
      if ( *a5 > v21 )
        *a5 = v21;
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + i + 265788) = v21;
    }
    else
    {
      if ( *(_DWORD *)(20 * i + *v24 + 8) )
        v9 = "ARI-OUT";
      else
        v9 = "AIR-IN";
      if ( *(_DWORD *)(20 * i + *v24 + 12) )
        v10 = "BOTTOM";
      else
        v10 = "TOP";
      printf("Read remote temp error. Error sensor loacation: %s %s\n", v9, v10);
    }
    if ( *(_DWORD *)(20 * i + *v24 + 8) )
      v11 = "ARI-OUT";
    else
      v11 = "AIR-IN";
    if ( *(_DWORD *)(20 * i + *v24 + 12) )
      v12 = "BOTTOM";
    else
      v12 = "TOP";
    printf("%s %s[pcb: %d  chip: %d]\n", v11, v12, v22, v21);
  }
  if ( *a6 == v24[1] && *a7 == v24[1] )
    return 0;
  else
    return -1;
}
// 47BE7C: using guessed type int dword_47BE7C;

//----- (00024374) --------------------------------------------------------
void pcba_statistic_ltc_pattern_test_results()
{
  ;
}

//----- (00024390) --------------------------------------------------------
int pcba_check_nonce_ltc()
{
  return 0;
}

//----- (000243A8) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_243A8(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (000243CC) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_243CC(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (000243F4) --------------------------------------------------------
int __fastcall sub_243F4(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 24438: variable 'v3' is possibly undefined

//----- (000244D4) --------------------------------------------------------
int __fastcall sub_244D4(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000245D8) --------------------------------------------------------
_BYTE *__fastcall sub_245D8(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (00024620) --------------------------------------------------------
int __fastcall sub_24620(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_DASH", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_get_addr_DASH",
    25,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_243CC((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_DASH",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_get_addr_DASH",
    25,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_get_addr_DASH",
      25,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
          74,
          "ChipSetting_get_addr_DASH",
          25,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_243CC((int)v12, *(int *)(a1 + 140));
    sub_243A8(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_get_addr_DASH",
      25,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 24778: variable 'v4' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00024C08) --------------------------------------------------------
int __fastcall sub_24C08(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_DASH", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_software_reset_DASH",
    31,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 4456449;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00024CFC) --------------------------------------------------------
int __fastcall sub_24CFC(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_DASH", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_software_reset_one_asic_DASH",
    40,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 68;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00024E0C) --------------------------------------------------------
int __fastcall sub_24E0C(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_DASH", 255, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_ticket_mask_DASH",
    28,
    137,
    20,
    v5);
  v6[2] = 16711681;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00024F30) --------------------------------------------------------
int __fastcall sub_24F30(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_misc_DASH",
    21,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000251C4) --------------------------------------------------------
int __fastcall sub_251C4(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_misc_eth_DASH",
    25,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000253E8) --------------------------------------------------------
unsigned int *__fastcall sub_253E8(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 25420: variable 'v1' is possibly undefined

//----- (000254F8) --------------------------------------------------------
int __fastcall sub_254F8(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 524289;
  sub_253E8(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_freq_DASH",
    21,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 25578: variable 'v1' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0002564C) --------------------------------------------------------
int __fastcall sub_2564C(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 8;
  sub_253E8(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_one_asic_freq_DASH",
    30,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 256EE: variable 'v2' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000257CC) --------------------------------------------------------
int __fastcall sub_257CC(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_DASH", 10, 255, 20000);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_open_cores_DASH",
    27,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 16711681;
  v8[0] = a3;
  BYTE1(v8[3]) = 10;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v8, 20000, 0);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000258F8) --------------------------------------------------------
int __fastcall sub_258F8(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_DASH");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_close_cores_DASH",
    28,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 16711681;
  v6[0] = 0;
  BYTE1(v6[3]) = 10;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v6, 20000, 0);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00025A08) --------------------------------------------------------
int __fastcall sub_25A08(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_DASH",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_start_nonce_offset_DASH",
    35,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_243CC((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_DASH",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_start_nonce_offset_DASH",
        35,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 25B68: variable 'v2' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00025CF8) --------------------------------------------------------
int __fastcall sub_25CF8(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  unsigned __int8 v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_DASH", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_pmdata_DASH",
    23,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 255;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_DASH", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_pmdata_DASH",
        23,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 255 )
        {
          v12 = -1;
          v5 = 0;
          sub_245D8(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_243CC((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_DASH",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
            74,
            "ChipSetting_pmdata_DASH",
            23,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 255 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0002615C) --------------------------------------------------------
int __fastcall sub_2615C(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_DASH", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_clk_count_DASH",
    26,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 255;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 255 )
        {
          sub_245D8(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_243CC((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_DASH",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
            74,
            "ChipSetting_clk_count_DASH",
            26,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_DASH", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_clk_count_DASH",
      26,
      436,
      100,
      v5);
    return -1;
  }
}
// 2636A: variable 'v3' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00026548) --------------------------------------------------------
int __fastcall sub_26548(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4194305;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_analog_mux_DASH",
    27,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00026664) --------------------------------------------------------
int __fastcall sub_26664(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 32;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (000266B0) --------------------------------------------------------
int __fastcall sub_266B0(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 32;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (000267D0) --------------------------------------------------------
int __fastcall sub_267D0(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_26664(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_266B0(a1, a2, a3, s, a6, n);
}

//----- (00026844) --------------------------------------------------------
int __fastcall sub_26844(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_267D0(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (000268E8) --------------------------------------------------------
int __fastcall sub_268E8(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_267D0(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0002698C) --------------------------------------------------------
int __fastcall sub_2698C(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_267D0(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (000269F0) --------------------------------------------------------
int __fastcall sub_269F0(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_267D0(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00026A54) --------------------------------------------------------
int __fastcall sub_26A54(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_read_sensor_temp_local_on_pic_DASH",
        46,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_read_sensor_temp_local_on_pic_DASH",
      46,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00026C2C) --------------------------------------------------------
int __fastcall sub_26C2C(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_read_sensor_temp_remote_on_pic_DASH",
        47,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_read_sensor_temp_remote_on_pic_DASH",
      47,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00026E08) --------------------------------------------------------
int __fastcall sub_26E08(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_26664(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00026E40) --------------------------------------------------------
int __fastcall sub_26E40(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00026E94) --------------------------------------------------------
int __fastcall sub_26E94(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 52;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 52 )
    {
      V_LOCK();
      sub_243CC((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_get_crc_status_DASH",
        31,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00027160) --------------------------------------------------------
int __fastcall sub_27160(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (000271EC) --------------------------------------------------------
unsigned int __fastcall sub_271EC(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0x348u);
  memset(v13, 0, 0x348u);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 70, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_243CC((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
        74,
        "ChipSetting_get_chip_status_DASH",
        32,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0002749C) --------------------------------------------------------
int __fastcall sub_2749C(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (000274E4) --------------------------------------------------------
int __fastcall sub_274E4(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0002753C) --------------------------------------------------------
int __fastcall sub_2753C(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0002759C) --------------------------------------------------------
int __fastcall sub_2759C(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00027600) --------------------------------------------------------
int __fastcall sub_27600(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0002765C) --------------------------------------------------------
int __fastcall sub_2765C(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = 10 * *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_DASH", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_get_core_status_DASH",
    32,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_243CC((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_get_core_status_DASH",
      32,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 2781E: variable 'v5' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000279E0) --------------------------------------------------------
int __fastcall sub_279E0(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 10;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_DASH", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
    74,
    "ChipSetting_get_single_chip_core_status_DASH",
    44,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_243CC((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/./backend/chip_setting.c",
      74,
      "ChipSetting_get_single_chip_core_status_DASH",
      44,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 27B90: variable 'v6' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00027D58) --------------------------------------------------------
int __fastcall pcba_dash_reg_init(int result)
{
  *(_DWORD *)(result + 304) = 1;
  return result;
}

//----- (00027D74) --------------------------------------------------------
int pcba_is_dash_asic_valid()
{
  return 1;
}

//----- (00027D8C) --------------------------------------------------------
int pcba_calc_dash_core_num()
{
  return *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12);
}
// 1F0C98: using guessed type int g_config_info;

//----- (00027DB0) --------------------------------------------------------
int __fastcall pcba_dash_recv(int a1)
{
  _DWORD s[20]; // [sp+8h] [bp+8h] BYREF
  unsigned int v5; // [sp+58h] [bp+58h]
  unsigned __int8 v6; // [sp+5Eh] [bp+5Eh]
  unsigned __int8 v7; // [sp+5Fh] [bp+5Fh]
  unsigned int *v8; // [sp+60h] [bp+60h]
  char v9; // [sp+67h] [bp+67h]

  memset(s, 0, sizeof(s));
  (*(void (__fastcall **)(int, _DWORD *))(a1 + 32))(a1, s);
  v9 = s[3];
  v8 = (unsigned int *)(104 * g_patten_offset + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 8));
  v7 = (unsigned int)*((unsigned __int8 *)v8 + 84) / *(_DWORD *)(a1 + 240);
  v6 = *((_BYTE *)v8 + 84) >> 1;
  v5 = _byteswap_ulong(v8[21]);
  v6 = (v5 - ((*(_DWORD *)(a1 + 240) * v7) << 24)) % 0xA;
  if ( s[3] != v6 || s[2] != v7 || memcmp(&s[12], v8 + 21, v8[23]) )
    return 0;
  ++v8[25];
  need_pattern = 1;
  return 1;
}
// 1EC5C4: using guessed type char need_pattern;
// 1F0C80: using guessed type int g_patten_offset;
// 1F0C98: using guessed type int g_config_info;

//----- (00027ED4) --------------------------------------------------------
int __fastcall pcba_dash_send(int a1, int a2)
{
  _BYTE s[180]; // [sp+8h] [bp+8h] BYREF
  int v5; // [sp+BCh] [bp+BCh]
  int v6; // [sp+C0h] [bp+C0h]
  int i; // [sp+C4h] [bp+C4h]
  _BYTE vars0[8]; // [sp+C8h] [bp+C8h] BYREF

  v6 = a2;
  v5 = 0;
  memset(s, 0, 0xB0u);
  memcpy(&s[40], (const void *)(v6 + 4), 0x50u);
  for ( i = 0; i <= 19; ++i )
  {
    vars0[4 * i - 149] = *(_BYTE *)(4 * i + v6 + 4);
    vars0[4 * i - 150] = *(_BYTE *)(4 * i + 1 + v6 + 4);
    vars0[4 * i - 151] = *(_BYTE *)(4 * i + 2 + v6 + 4);
    vars0[4 * i - 152] = *(_BYTE *)(4 * i + 3 + v6 + 4);
  }
  return (*(int (__fastcall **)(int, _BYTE *))(a1 + 24))(a1, s);
}

//----- (00027FC0) --------------------------------------------------------
int __fastcall pcba_read_dash_temperature(
        int a1,
        _DWORD *a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7)
{
  int v13; // [sp+24h] [bp+14h] BYREF
  int v14; // [sp+28h] [bp+18h] BYREF
  int v15; // [sp+2Ch] [bp+1Ch] BYREF
  int v16; // [sp+30h] [bp+20h] BYREF
  _DWORD *v17; // [sp+34h] [bp+24h]
  _DWORD *v18; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]

  v18 = *(_DWORD **)(a1 + 212);
  *a2 = -150;
  *a3 = 150;
  *a4 = -150;
  *a5 = 150;
  for ( i = 0; v18[1] > i; ++i )
  {
    v17 = (_DWORD *)(20 * i + *v18);
    v14 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 100))(
      a1,
      &v16,
      &v14,
      *v17,
      v17[1],
      v17[2],
      v17[3],
      v17[4]);
    if ( v14 )
    {
      ++*a6;
      if ( *a2 < v16 )
        *a2 = v16;
      if ( *a3 > v16 )
        *a3 = v16;
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + i + 265784) = v16;
    }
    v13 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 104))(
      a1,
      &v15,
      &v13,
      *v17,
      v17[1],
      v17[2],
      v17[3],
      v17[4]);
    if ( v13 )
    {
      ++*a7;
      if ( *a4 < v15 )
        *a4 = v15;
      if ( *a5 > v15 )
        *a5 = v15;
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + i + 265788) = v15;
    }
  }
  if ( *a6 == v18[1] && *a7 == v18[1] )
    return 0;
  else
    return -1;
}
// 47BE7C: using guessed type int dword_47BE7C;

//----- (00028158) --------------------------------------------------------
void pcba_statistic_dash_pattern_test_results()
{
  ;
}

//----- (00028174) --------------------------------------------------------
int pcba_check_nonce_dash()
{
  return 0;
}

//----- (0002818C) --------------------------------------------------------
int __fastcall pcba_setup_all_chip_dash(int a1)
{
  char v1; // r4
  char v2; // r0
  char *ptr; // [sp+8h] [bp+8h]

  *(_DWORD *)(a1 + 240) = makeup_chip_addr_dash(*(_DWORD *)(a1 + 296), 0x46u);
  (*(void (__fastcall **)(int, _DWORD, int))(a1 + 148))(a1, *(_DWORD *)(a1 + 296), 70);
  sub_24620(a1, 70);
  sub_254F8(a1);
  usleep(0x61A8u);
  set_ticket_mask_dash(a1, 0xFFu);
  ptr = (char *)calloc(1u, 0xB0u);
  v1 = *(_DWORD *)(a1 + 136);
  v2 = rand();
  memset(ptr + 40, (unsigned __int8)(v2 + v1), 0x50u);
  push_work_base(a1, (int)ptr);
  free(ptr);
  sub_24620(a1, 70);
  if ( *(_BYTE *)(a1 + 268) != 1 )
    *(_DWORD *)(a1 + 272) = (int)*(float *)(a1 + 760);
  return 0;
}

//----- (00028264) --------------------------------------------------------
int __fastcall pcba_set_baud_dash(int a1, char *a2)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int v6; // [sp+1Ch] [bp+1Ch]
  char v7; // [sp+26h] [bp+26h]
  unsigned __int8 v8; // [sp+27h] [bp+27h]

  v6 = 0;
  v8 = 26;
  v7 = 3;
  memset(s, 0, sizeof(s));
  s[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v8 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v8 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v8 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v8 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v8 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v8 = 0;
    v7 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v8 = 26;
      goto LABEL_27;
    }
    v8 = 0;
    v7 = 0;
  }
LABEL_27:
  v6 = (v8 << 8) | 0xA0C40031;
  s[0] = v6;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
}

//----- (000283B8) --------------------------------------------------------
int __fastcall dump_pt2_result(int a1, int a2)
{
  time_t timer; // [sp+20h] [bp+8h] BYREF
  struct tm *v6; // [sp+24h] [bp+Ch]
  FILE *stream; // [sp+28h] [bp+10h]
  int k; // [sp+2Ch] [bp+14h]
  int j; // [sp+30h] [bp+18h]
  int i; // [sp+34h] [bp+1Ch]

  stream = fopen("/config/stats.log", "a+");
  if ( !stream )
  {
    puts("open /config/stats.log failed!");
    exit(-1);
  }
  time(&timer);
  v6 = localtime(&timer);
  fprintf(
    stream,
    "chain[%1d], %d%d%d %d:%d:%d\n",
    gChain,
    v6->tm_year + 1900,
    v6->tm_mon + 1,
    v6->tm_mday,
    v6->tm_hour,
    v6->tm_min,
    v6->tm_sec);
  for ( i = 0; *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 28) > i; ++i )
    fprintf(stream, "\t%4d", *((_DWORD *)&gHistory_Result + 66450 * i + 7));
  for ( j = 0; j < a2; ++j )
  {
    fprintf(stream, "\n%4d", *(_DWORD *)(a1 + 272 * j));
    for ( k = 0; *(_DWORD *)(a1 + 272 * j + 8) > k; ++k )
      fprintf(stream, "\t%.4f", *(double *)(8 * (k + 2) + 272 * j + a1));
  }
  fwrite("\n-------------\n", 1u, 0xFu, stream);
  return fclose(stream);
}
// 1EC5C8: using guessed type int gChain;
// 1F0C98: using guessed type int g_config_info;

//----- (00028540) --------------------------------------------------------
int __fastcall init_history_result(int a1)
{
  int result; // r0

  if ( !a1 )
    memset(&gHistory_Result, 0, (size_t)&unk_288ED0);
  *((_BYTE *)&gHistory_Result + 265800 * a1) = 1;
  *((_BYTE *)&gHistory_Result + 265800 * a1 + 1) = 1;
  *((_BYTE *)&gHistory_Result + 265800 * a1 + 2) = 1;
  *((_BYTE *)&gHistory_Result + 265800 * a1 + 4) = 1;
  *((_BYTE *)&gHistory_Result + 265800 * a1 + 6) = 1;
  *((_BYTE *)&gHistory_Result + 265800 * a1 + 5) = 1;
  memset((char *)&gHistory_Result + 265800 * a1 + 265520, -1, 0x100u);
  memset((char *)&gHistory_Result + 265800 * a1 + 263216, -1, 0x400u);
  *((_DWORD *)&gHistory_Result + 66450 * a1 + 65803) = 0;
  *((_DWORD *)&gHistory_Result + 66450 * a1 + 65802) = 0;
  *((_BYTE *)&gHistory_Result + 265800 * a1 + 265796) = -1;
  result = a1;
  if ( *(_DWORD *)(g_config_info + 32) )
    *((_DWORD *)&gHistory_Result + 66450 * a1 + 4) = *(_DWORD *)(16 * (a1 + 2) + MES2Local_Config_Information + 192);
  else
    *((_DWORD *)&gHistory_Result + 66450 * a1 + 4) = a1 + 1;
  return result;
}
// 1F0C98: using guessed type int g_config_info;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0002874C) --------------------------------------------------------
int __fastcall sub_2874C(int a1)
{
  int result; // r0
  int i; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]
  int v6; // [sp+18h] [bp+18h]
  int v7; // [sp+1Ch] [bp+1Ch]
  int k; // [sp+20h] [bp+20h]
  int j; // [sp+24h] [bp+24h]

  g_patten_offset = 0;
  memset(&g_pcba_info, 0, 0x78u);
  g_pcba_info = 1;
  dword_47BE68 = 0;
  dword_47BE7C = a1;
  byte_47BE80 = 1;
  dword_47BEA0 = 0;
  init_history_result(a1);
  if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 2 )
  {
    off_47BE88 = pcba_ckb_recv;
    off_47BE8C = (int (__fastcall *)(_DWORD, _DWORD))pcba_ckb_send;
    off_47BE90 = (int (__fastcall *)(_DWORD))pcba_is_ckb_asic_valid;
    off_47BE94 = (int (__fastcall *)(_DWORD))pcba_calc_ckb_core_num;
    dword_47BE98 = (int)pcba_statistic_ckb_pattern_test_results;
    off_47BE9C = (int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))pcba_read_ckb_temperature;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 1 )
  {
    off_47BE88 = pcba_vbk_recv;
    off_47BE8C = (int (__fastcall *)(_DWORD, _DWORD))pcba_vbk_send;
    off_47BE90 = (int (__fastcall *)(_DWORD))pcba_is_vbk_asic_valid;
    off_47BE94 = (int (__fastcall *)(_DWORD))pcba_calc_vbk_core_num;
    dword_47BE98 = (int)pcba_statistic_vbk_pattern_test_results;
    off_47BE9C = (int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))pcba_read_fpga_temperature;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 6 )
    {
      off_47BE88 = pcba_ltc_recv;
      off_47BE8C = pcba_ltc_send;
      off_47BE90 = (int (__fastcall *)(_DWORD))pcba_is_ltc_asic_valid;
      off_47BE94 = (int (__fastcall *)(_DWORD))pcba_calc_ltc_core_num;
      dword_47BE98 = (int)pcba_statistic_ltc_pattern_test_results;
      off_47BE9C = (int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))pcba_read_ltc_temperature;
      *(_DWORD *)(dword_1F0C8C + 64) = pcba_check_nonce_ltc;
      if ( !strcmp(*(const char **)(g_config_info + 20), "PT1") )
      {
        v7 = dword_1F0C8C + 52;
        *(_DWORD *)(dword_1F0C8C + 52) = pcba_setup_all_chip_ltc;
      }
    }
    else if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 7 )
    {
      off_47BE88 = pcba_dash_recv;
      off_47BE8C = pcba_dash_send;
      off_47BE90 = (int (__fastcall *)(_DWORD))pcba_is_dash_asic_valid;
      off_47BE94 = (int (__fastcall *)(_DWORD))pcba_calc_dash_core_num;
      dword_47BE98 = (int)pcba_statistic_dash_pattern_test_results;
      off_47BE9C = (int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))pcba_read_dash_temperature;
      *(_DWORD *)(dword_1F0C8C + 64) = pcba_check_nonce_dash;
    }
    else
    {
      if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) != 5 )
      {
        printf("unknow algo type %d\n", *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4));
        exit(1);
      }
      off_47BE88 = (int (__fastcall *)(_DWORD))pcba_eth_recv;
      off_47BE8C = (int (__fastcall *)(_DWORD, _DWORD))pcba_eth_send;
      off_47BE90 = (int (__fastcall *)(_DWORD))pcba_is_eth_asic_valid;
      off_47BE94 = (int (__fastcall *)(_DWORD))pcba_calc_eth_core_num;
      dword_47BE98 = (int)pcba_statistic_eth_pattern_test_results;
      off_47BE9C = (int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))pcba_read_eth_temperature;
      *(_DWORD *)(dword_1F0C8C + 64) = pcba_check_nonce_eth;
    }
  }
  else
  {
    off_47BE88 = (int (__fastcall *)(_DWORD))pcba_grin29_recv;
    off_47BE8C = (int (__fastcall *)(_DWORD, _DWORD))pcba_grin29_send;
    off_47BE90 = (int (__fastcall *)(_DWORD))pcba_is_grin29_asic_valid;
    off_47BE94 = (int (__fastcall *)(_DWORD))pcba_calc_grin29_core_num;
    dword_47BE98 = (int)pcba_statistic_grin29_pattern_test_results;
    off_47BE9C = (int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))pcba_read_fpga_temperature;
  }
  result = strcmp(*(const char **)(g_config_info + 20), "PT2");
  if ( !result )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 8);
    for ( i = 0; *(_DWORD *)(g_config_info + 40) > i; ++i )
    {
      result = off_47BE90(&i);
      if ( (unsigned __int8)result == 1 )
      {
        result = off_47BE94(&i);
        v5 = result;
        for ( j = 0; j < v5; ++j )
        {
          for ( k = 0; *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) > k; ++k )
          {
            v4 = 104
               * (k
                + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) * v5 * i
                + j * *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16))
               + v6;
            *(_DWORD *)(v4 + 100) = 0;
          }
        }
      }
    }
  }
  return result;
}
// 2E6F0: using guessed type int pcba_statistic_vbk_pattern_test_results();
// 34B74: using guessed type int pcba_eth_recv();
// 34C3C: using guessed type int pcba_eth_send();
// 3BE60: using guessed type int pcba_ckb_send();
// 3D208: using guessed type int pcba_grin29_recv();
// 3D3E8: using guessed type int pcba_grin29_send();
// 3D4BC: using guessed type int pcba_statistic_grin29_pattern_test_results();
// 1F0C80: using guessed type int g_patten_offset;
// 1F0C8C: using guessed type int dword_1F0C8C;
// 1F0C98: using guessed type int g_config_info;
// 47BE2C: using guessed type char g_pcba_info;
// 47BE68: using guessed type int dword_47BE68;
// 47BE7C: using guessed type int dword_47BE7C;
// 47BE80: using guessed type char byte_47BE80;
// 47BE88: using guessed type int (__fastcall *off_47BE88)(_DWORD);
// 47BE8C: using guessed type int (__fastcall *off_47BE8C)(_DWORD, _DWORD);
// 47BE90: using guessed type int (__fastcall *off_47BE90)(_DWORD);
// 47BE94: using guessed type int (__fastcall *off_47BE94)(_DWORD);
// 47BE98: using guessed type int dword_47BE98;
// 47BE9C: using guessed type int (__fastcall *off_47BE9C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BEA0: using guessed type int dword_47BEA0;

//----- (00028C58) --------------------------------------------------------
int sub_28C58()
{
  sprintf(dest, "NAME:%s", *(const char **)(g_config_info + 28));
  sprintf(byte_47BEB9, "CHIP:%2d", *(_DWORD *)(g_config_info + 40));
  sprintf(&byte_47BEB9[17], "FREQ: %dMHz", **(_DWORD **)(*(_DWORD *)(g_config_info + 8) + 24));
  return sprintf(dword_47BEDB, "Voltage: %3dmV", **(_DWORD **)(g_config_info + 48));
}
// 1F0C98: using guessed type int g_config_info;

//----- (00028CE8) --------------------------------------------------------
int sub_28CE8()
{
  strcpy(dest, "                ");
  sprintf(byte_47BEB9, " LEVEL: %d", dword_47BE7C + 1);
  sprintf(&byte_47BEB9[17], " NONCE: %.2f", flt_47BE70);
  if ( byte_47BE80 )
  {
    strcpy(dword_47BEDB, "      Done      ");
    return *(_DWORD *)"      Done      ";
  }
  else
  {
    strcpy(dword_47BEDB, "      Next      ");
    return *(_DWORD *)"      Next      ";
  }
}
// 47BE70: using guessed type float flt_47BE70;
// 47BE7C: using guessed type int dword_47BE7C;
// 47BE80: using guessed type char byte_47BE80;

//----- (00028DAC) --------------------------------------------------------
int sub_28DAC()
{
  g_lcd_result_with_data = 20;
  sub_28C58();
  return pcba_display_result_on_lcd();
}
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (00028DC8) --------------------------------------------------------
int __fastcall check_whether_board_changed(int a1)
{
  int v1; // r3
  int v2; // r0
  int v5; // [sp+Ch] [bp+Ch]

  v5 = pcba_chain_check();
  if ( *(_DWORD *)(g_config_info + 36) )
  {
    if ( v5 == 1 )
    {
      while ( *(_BYTE *)(a1 + 85) && pcba_chain_check() )
        usleep(0x30D40u);
      lcd_show_one(1u, "Please change");
      lcd_show(2u, "next hashboard");
      sleep(1u);
      while ( 1 )
      {
        v1 = *(_BYTE *)(a1 + 86) ^ 1;
        if ( *(_BYTE *)(a1 + 86) == 1 )
          break;
        if ( pcba_chain_check() == 1 )
          *(_BYTE *)(a1 + 86) = 1;
        usleep(0x30D40u);
      }
    }
    else
    {
      if ( !v5 )
      {
        puts("No board found, please check.");
        lcd_show_one(1u, "Plug off");
        lcd_show(2u, "before test done");
      }
      return 0;
    }
  }
  else if ( v5 == 2 )
  {
    while ( *(_BYTE *)(a1 + 85) && pcba_chain_check() != 1 )
      usleep(0x30D40u);
    lcd_show_one(1u, "Please change");
    lcd_show(2u, "next hashboard");
    sleep(1u);
    while ( 1 )
    {
      v1 = *(_BYTE *)(a1 + 86) ^ 1;
      if ( *(_BYTE *)(a1 + 86) == 1 )
        break;
      if ( pcba_chain_check() == 2 )
        *(_BYTE *)(a1 + 86) = 1;
      usleep(0x30D40u);
    }
  }
  else
  {
    v2 = is_asic_pass(v5 - 1);
    printf("Please check hashboard. Only find chain %d\n", v2);
    lcd_show_one(1u, "Plug off");
    lcd_show(2u, "before test done");
    return 0;
  }
  return v1;
}
// 1F0C98: using guessed type int g_config_info;

//----- (00028F60) --------------------------------------------------------
int __fastcall pcba_set_fan_pwm(int a1)
{
  int v1; // r3
  int v3; // [sp+Ch] [bp+Ch]

  if ( a1 <= 2 || a1 > 100 )
  {
    puts("warning: fan speed range only support [3, 100], otherwise set default value 50");
    v3 = 3276850;
    fpga_write(0x84u, 3276850);
  }
  else
  {
    v3 = (unsigned __int16)(100 - a1) | (a1 << 16);
    fpga_write(0x84u, v3);
  }
  fpga_write(0xA0u, v3);
  return v1;
}
// 28FAE: variable 'v1' is possibly undefined

//----- (00028FB8) --------------------------------------------------------
int __fastcall pcba_save_config_to_pic(int a1)
{
  _BYTE s[32]; // [sp+Ch] [bp+Ch] BYREF
  _WORD v4[2]; // [sp+2Ch] [bp+2Ch] BYREF
  char v5; // [sp+30h] [bp+30h]
  char v6; // [sp+31h] [bp+31h]
  int v7; // [sp+34h] [bp+34h]
  _WORD *v8; // [sp+38h] [bp+38h]
  int v9; // [sp+3Ch] [bp+3Ch]
  unsigned int j; // [sp+40h] [bp+40h]
  unsigned int i; // [sp+44h] [bp+44h]

  v4[0] = *(_DWORD *)(4 * a1 + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 24));
  v4[1] = *(_DWORD *)(4 * a1 + *(_DWORD *)(g_config_info + 48));
  v5 = (char)(int)(*(double *)(8 * a1 + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 36)) * 100.0) / 100;
  v6 = (int)(*(double *)(8 * a1 + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 36)) * 100.0) % 100;
  v9 = 393216;
  v8 = v4;
  for ( i = 0; i <= 5; ++i )
    printf("%02x ", *((unsigned __int8 *)v8 + i));
  puts("--- wbuf pic");
  v7 = (*(int (__fastcall **)(_DWORD, int, int, _WORD *))(dword_1F0C90 + 76))(
         *(_DWORD *)(dword_1F0C8C + 136),
         51,
         v9,
         v8);
  if ( v7 )
  {
    puts("save voltage failed");
    return -1;
  }
  else
  {
    memset(s, 0, sizeof(s));
    v7 = (*(int (__fastcall **)(_DWORD, int, int, _BYTE *))(dword_1F0C90 + 76))(
           *(_DWORD *)(dword_1F0C8C + 136),
           52,
           v9,
           s);
    if ( v7 )
    {
      puts("get voltage failed");
      return -1;
    }
    else
    {
      for ( j = 0; j <= 5; ++j )
        printf("%02x ", (unsigned __int8)s[j]);
      puts("--- rbuf pic");
      return 0;
    }
  }
}
// 1F0C8C: using guessed type int dword_1F0C8C;
// 1F0C90: using guessed type int dword_1F0C90;
// 1F0C98: using guessed type int g_config_info;

//----- (00029190) --------------------------------------------------------
int sub_29190()
{
  pthread_t v0; // r0
  unsigned int v1; // r1
  unsigned int v3; // [sp+Ch] [bp+Ch]

  v0 = pthread_self();
  pthread_detach(v0);
  v3 = 0;
  while ( g_pcba_info )
  {
    v1 = v3++;
    if ( !(v1 % 0xA) )
    {
      (*(void (__fastcall **)(_DWORD))(dword_1F0C90 + 72))(*(_DWORD *)(dword_1F0C8C + 136));
      printf("%s[%d]\n", "pcba_pic_heartbeat_func", 373);
      printf("Got match nonce %d, tatol send work %d\n", dword_47BE74, dword_47BE78);
    }
    sleep(1u);
  }
  printf("%s[%d] quit\n", "pcba_pic_heartbeat_func", 378);
  return 0;
}
// 1F0C8C: using guessed type int dword_1F0C8C;
// 1F0C90: using guessed type int dword_1F0C90;
// 47BE2C: using guessed type char g_pcba_info;
// 47BE74: using guessed type int dword_47BE74;
// 47BE78: using guessed type int dword_47BE78;

//----- (0002925C) --------------------------------------------------------
int sub_2925C()
{
  pthread_t v0; // r0
  int v2; // [sp+Ch] [bp+4h]

  v0 = pthread_self();
  pthread_detach(v0);
  v2 = 0;
  g_lcd_result_with_data = 0;
  while ( g_pcba_info )
  {
    if ( !g_lcd_result_with_data )
    {
      sprintf(dest, "Time %ds", v2);
      sprintf(byte_47BEB9, "Level %d", *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 4));
      sprintf(&byte_47BEB9[17], "Nonce: %.2f%", flt_47BE70);
      sprintf(dword_47BEDB, "T: %d-%d %d-%d", dword_47BE58, dword_47BE54, dword_47BE60, dword_47BE5C);
      printf("board temp %d - %d, chip temp %d - %d\n", dword_47BE58, dword_47BE54, dword_47BE60, dword_47BE5C);
      pcba_display_result_on_lcd();
      ++v2;
    }
    sleep(1u);
  }
  printf("%s[%d] quit\n", "pcba_show_status_func", 405);
  return 0;
}
// 47BE2C: using guessed type char g_pcba_info;
// 47BE54: using guessed type int dword_47BE54;
// 47BE58: using guessed type int dword_47BE58;
// 47BE5C: using guessed type int dword_47BE5C;
// 47BE60: using guessed type int dword_47BE60;
// 47BE70: using guessed type float flt_47BE70;
// 47BE7C: using guessed type int dword_47BE7C;
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (000293BC) --------------------------------------------------------
int __fastcall sub_293BC(int a1)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  while ( g_pcba_info )
    off_47BE88(a1);
  printf("%s[%d] quit\n", "pcba_receive_func", 419);
  return 0;
}
// 47BE2C: using guessed type char g_pcba_info;
// 47BE88: using guessed type int (__fastcall *off_47BE88)(_DWORD);

//----- (00029414) --------------------------------------------------------
int __fastcall sub_29414(int a1)
{
  pthread_t v1; // r0
  int v2; // r3
  _BYTE *v3; // r3
  float v4; // s15
  float v5; // s15
  int v6; // r4
  int v7; // r1
  float v8; // s15
  char src[32]; // [sp+10h] [bp+8h] BYREF
  char s[256]; // [sp+30h] [bp+28h] BYREF
  int i; // [sp+130h] [bp+128h] BYREF
  struct timespec v14[2]; // [sp+134h] [bp+12Ch] BYREF
  struct timespec *tp; // [sp+144h] [bp+13Ch]
  int v16; // [sp+148h] [bp+140h]
  int v17; // [sp+14Ch] [bp+144h]
  int v18; // [sp+150h] [bp+148h]
  float v19; // [sp+154h] [bp+14Ch]
  float v20; // [sp+158h] [bp+150h]
  struct timespec *v21; // [sp+15Ch] [bp+154h]
  int v22; // [sp+160h] [bp+158h]
  int v23; // [sp+164h] [bp+15Ch]
  int v24; // [sp+168h] [bp+160h]
  void *ptr; // [sp+16Ch] [bp+164h]
  int v26; // [sp+170h] [bp+168h]
  int v27; // [sp+174h] [bp+16Ch]
  int v28; // [sp+178h] [bp+170h]
  int v29; // [sp+17Ch] [bp+174h]
  int v30; // [sp+180h] [bp+178h]
  int v31; // [sp+184h] [bp+17Ch]
  int ii; // [sp+188h] [bp+180h]
  int n; // [sp+18Ch] [bp+184h]
  int v34; // [sp+190h] [bp+188h]
  int m; // [sp+194h] [bp+18Ch]
  int v36; // [sp+198h] [bp+190h]
  int k; // [sp+19Ch] [bp+194h]
  int j; // [sp+1A0h] [bp+198h]
  float v39; // [sp+1A4h] [bp+19Ch]

  v1 = pthread_self();
  pthread_detach(v1);
  v31 = 0;
  v30 = 0;
  v29 = a1;
  v28 = *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 8);
  v27 = *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16)
      * *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12)
      * *(_DWORD *)(g_config_info + 40);
  v26 = *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) * *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12);
  ptr = calloc(*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12) * *(_DWORD *)(g_config_info + 40), 1u);
  pcba_set_fan_pwm(5);
  while ( dword_47BE54 < *(_DWORD *)(g_config_info + 76) )
  {
    printf("Wait for temp to start temp :%d, board max %d \n", *(_DWORD *)(g_config_info + 76), dword_47BE54);
    sleep(2u);
  }
  pcba_set_fan_pwm(*(_DWORD *)(g_config_info + 100));
  puts("Reach start temp, start test");
  for ( i = 0; *(_DWORD *)(g_config_info + 40) > i; ++i )
  {
    if ( (unsigned __int8)off_47BE90(&i) == 1 )
    {
      v24 = off_47BE94(&i);
      for ( j = 0; j < v24; ++j )
      {
        for ( k = 0; *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) > k; ++k )
        {
          if ( g_pcba_info != 1 )
          {
            puts("stop send work by other errors");
            goto LABEL_54;
          }
          g_patten_offset = *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) * (v24 * i + j) + k;
          v23 = 104 * g_patten_offset + v28;
          off_47BE8C(v29, v23);
          ++dword_47BE78;
          need_pattern = 0;
          v22 = 1000 * *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 20);
          v36 = 0;
          tp = v14;
          clock_gettime(1, v14);
          do
          {
            usleep(v22 / 100);
            v21 = v14;
            clock_gettime(1, &v14[1]);
            v20 = (float)((v21[1].tv_nsec - v21->tv_nsec) / 1000 + 1000000LL * (v21[1].tv_sec - v21->tv_sec));
            if ( (float)v22 < v20 )
              break;
            if ( need_pattern == 1 )
              break;
            v2 = v36++;
          }
          while ( v2 <= 99 );
          if ( *(_DWORD *)(v23 + 100) )
          {
            v3 = (char *)ptr + j + i * *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12);
            ++*v3;
            ++dword_47BE74;
          }
        }
        v4 = (double)dword_47BE74 * 100.0 / (double)v27;
        flt_47BE70 = v4;
      }
    }
  }
  puts("------------------------------------------------------------------------------------------------");
  puts("                                     Result");
  for ( m = 0; *(_DWORD *)(g_config_info + 40) > m; ++m )
  {
    v19 = 0.0;
    v34 = 0;
    v18 = 0;
    memset(s, 0, sizeof(s));
    sprintf(s, "ASIC-%03d ", m);
    for ( n = 0; *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12) > n; ++n )
    {
      memset(src, 0, sizeof(src));
      v17 = *((unsigned __int8 *)ptr + n + m * *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12));
      sprintf(src, "%d ", v17);
      strcat(s, src);
      v34 += v17;
    }
    v5 = (double)v34 * 100.0 / (double)v26;
    v19 = v5;
    if ( v5 >= *(float *)(*(_DWORD *)(g_config_info + 8) + 76) / 100.0 * flt_47BE70 )
    {
      if ( *(float *)(*(_DWORD *)(g_config_info + 8) + 72) > v19 )
        ++*((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 65802);
    }
    else
    {
      *((float *)&gHistory_Result
      + 66450 * dword_47BE7C
      + *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 65803)
      + 66060) = v19;
      v6 = dword_47BE7C;
      v7 = *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 65803);
      *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 65803) = v7 + 1;
      *((_DWORD *)&gHistory_Result + 66450 * v6 + v7 + 65804) = m;
    }
    printf("%s   %d\n", s, v34);
    *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + m + 65546) = v34;
  }
  if ( *((int *)&gHistory_Result + 66450 * dword_47BE7C + 65803) > 0 )
  {
    puts("------------------------------------------------------------------------------------------------");
    puts("Bad ASIC list:");
    for ( ii = 0; *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 65803) > ii; ++ii )
    {
      v16 = *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + ii + 65804);
      printf(
        "ASIC[%02d] get nonce %d, nonce rate %0.2f\n",
        v16,
        *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + v16 + 65546),
        (double)*((unsigned int *)&gHistory_Result + 66450 * dword_47BE7C + v16 + 65546) * 100.0 / (double)v26);
    }
  }
  *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 5) = *(_DWORD *)(4 * dword_47BE7C
                                                                       + *(_DWORD *)(g_config_info + 48));
  *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 7) = *(_DWORD *)(4 * dword_47BE7C
                                                                       + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 24));
  *((double *)&gHistory_Result + 33225 * dword_47BE7C + 1) = flt_47BE70;
  if ( *(_DWORD *)(g_config_info + 32) )
    v8 = (double)*(unsigned int *)(MES2Local_Config_Information + 212) / 100.0;
  else
    v8 = *(double *)(8 * dword_47BE7C + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 36));
  v39 = v8;
  if ( flt_47BE70 >= v8 && *((int *)&gHistory_Result + 66450 * dword_47BE7C + 65803) <= 0 )
  {
    printf("\nPattern Test Success %0.4f match nocnes %d total nonces %d\n", flt_47BE70, dword_47BE74, v27);
    printf("patten test pass level %d is done %d\n", dword_47BE7C, (unsigned __int8)byte_47BE80);
    *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 265796) = *((int *)&gHistory_Result
                                                                    + 66450 * dword_47BE7C
                                                                    + 65802) > 0;
    if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 6 || *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 7 )
    {
      g_lcd_result_with_data = 1;
      strcpy(dest, "Wait for submit");
    }
    else if ( pcba_save_config_to_pic(dword_47BE7C) >= 0 )
    {
      g_lcd_result_with_data = 1;
      sub_28CE8();
    }
    else
    {
      g_lcd_result_with_data = 21;
    }
  }
  else
  {
    printf("\nPattern Test Failed %0.4f match nocnes %d total nonces %d\n", flt_47BE70, dword_47BE74, v27);
    printf("patten test fail level %d\n", dword_47BE7C + 1);
    *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 265796) = -16;
    if ( dword_47BE7C < *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 28) - 1 )
    {
      byte_47BE80 = 0;
      sub_28CE8();
    }
    else
    {
      strcpy(dest, "Wait for submit");
    }
  }
  g_pcba_info = 0;
  puts("send test pattern done");
LABEL_54:
  free(ptr);
  printf("%s[%d] quit\n", "pcba_send_func", 788);
  return 0;
}
// 1EC5C4: using guessed type char need_pattern;
// 1F0C80: using guessed type int g_patten_offset;
// 1F0C98: using guessed type int g_config_info;
// 479D9C: using guessed type int MES2Local_Config_Information;
// 47BE2C: using guessed type char g_pcba_info;
// 47BE54: using guessed type int dword_47BE54;
// 47BE70: using guessed type float flt_47BE70;
// 47BE74: using guessed type int dword_47BE74;
// 47BE78: using guessed type int dword_47BE78;
// 47BE7C: using guessed type int dword_47BE7C;
// 47BE80: using guessed type char byte_47BE80;
// 47BE8C: using guessed type int (__fastcall *off_47BE8C)(_DWORD, _DWORD);
// 47BE90: using guessed type int (__fastcall *off_47BE90)(_DWORD);
// 47BE94: using guessed type int (__fastcall *off_47BE94)(_DWORD);
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (0002A080) --------------------------------------------------------
int __fastcall sub_2A080(int a1)
{
  pthread_t v1; // r0
  int v2; // r3
  int v5; // [sp+1Ch] [bp+Ch] BYREF
  int v6; // [sp+20h] [bp+10h] BYREF
  int v7; // [sp+24h] [bp+14h] BYREF
  int v8; // [sp+28h] [bp+18h] BYREF
  int v9; // [sp+2Ch] [bp+1Ch] BYREF
  int v10; // [sp+30h] [bp+20h] BYREF
  int v12; // [sp+38h] [bp+28h]
  int v13; // [sp+3Ch] [bp+2Ch]

  v1 = pthread_self();
  pthread_detach(v1);
  v12 = a1;
  v13 = 0;
  (*(void (__fastcall **)(int))(a1 + 96))(a1);
  while ( g_pcba_info )
  {
    sleep(1u);
    v10 = 0;
    v9 = 0;
    v8 = 0;
    v7 = 0;
    v6 = 0;
    v5 = 0;
    if ( off_47BE9C(v12, &v10, &v9, &v8, &v7, &v6, &v5) )
    {
      v2 = v13++;
      if ( v2 > 1 )
      {
        puts("tempture error: can't read all sensor");
        g_lcd_result_with_data = 12;
        strcpy(dest, "Sensor error    ");
        g_pcba_info = 0;
        *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) = 0;
        break;
      }
    }
    else
    {
      v13 = 0;
      dword_47BE54 = v10;
      dword_47BE58 = v9;
      dword_47BE5C = v8;
      dword_47BE60 = v7;
      if ( *(_DWORD *)(g_config_info + 80) < v8 )
      {
        printf("tempture error: max pcb = %d, min pcb = %d, max chip = %d, min chip = %d\n", v10, v9, v8, v7);
        g_lcd_result_with_data = 13;
        g_pcba_info = 0;
        *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) = 0;
        break;
      }
    }
  }
  printf("%s[%d] quit\n", "pcba_read_temp_func", 834);
  return 0;
}
// 1F0C98: using guessed type int g_config_info;
// 47BE2C: using guessed type char g_pcba_info;
// 47BE54: using guessed type int dword_47BE54;
// 47BE58: using guessed type int dword_47BE58;
// 47BE5C: using guessed type int dword_47BE5C;
// 47BE60: using guessed type int dword_47BE60;
// 47BE7C: using guessed type int dword_47BE7C;
// 47BE9C: using guessed type int (__fastcall *off_47BE9C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (0002A240) --------------------------------------------------------
int __fastcall sub_2A240(int a1)
{
  int result; // r0
  int v2; // r3
  int v4; // [sp+1Ch] [bp+Ch] BYREF
  int v5; // [sp+20h] [bp+10h] BYREF
  int v6; // [sp+24h] [bp+14h] BYREF
  int v7; // [sp+28h] [bp+18h] BYREF
  int v8; // [sp+2Ch] [bp+1Ch] BYREF
  _DWORD v9[2]; // [sp+30h] [bp+20h] BYREF
  int i; // [sp+38h] [bp+28h]
  int v11; // [sp+3Ch] [bp+2Ch]

  v11 = 0;
  i = 0;
  result = (*(int (__fastcall **)(int))(a1 + 96))(a1);
  for ( i = 0; i <= 3; ++i )
  {
    sleep(1u);
    v9[0] = 0;
    v8 = 0;
    v7 = 0;
    v6 = 0;
    v5 = 0;
    v4 = 0;
    result = off_47BE9C(a1, v9, &v8, &v7, &v6, &v5, &v4);
    v9[1] = result;
    if ( result )
    {
      v2 = v11++;
      if ( v2 > 1 )
      {
        result = puts("tempture error: can't read all sensor");
        g_pcba_info = 0;
        *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) = 0;
        return result;
      }
    }
    else
    {
      v11 = 0;
      result = printf("board temp %d - %d, chip temp %d - %d\n", v8, v9[0], v6, v7);
      if ( *(_DWORD *)(g_config_info + 80) < v7 )
      {
        result = printf("tempture error: max pcb = %d, min pcb = %d, max chip = %d, min chip = %d\n", v9[0], v8, v7, v6);
        g_pcba_info = 0;
        *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) = 0;
        return result;
      }
    }
  }
  return result;
}
// 1F0C98: using guessed type int g_config_info;
// 47BE2C: using guessed type char g_pcba_info;
// 47BE7C: using guessed type int dword_47BE7C;
// 47BE9C: using guessed type int (__fastcall *off_47BE9C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002A390) --------------------------------------------------------
int pcba_boot_area_test()
{
  return 0;
}

//----- (0002A3A0) --------------------------------------------------------
int pcba_basic_area_test()
{
  int v0; // r3
  int v2; // r3
  int v4; // [sp+4h] [bp+4h]
  int v5; // [sp+4h] [bp+4h]

  v4 = 0;
  while ( (unsigned __int8)pcba_match_fpga_baud(dword_1F0C8C, dword_1F0C90) != 1 )
  {
    v0 = v4;
    v5 = v4 + 1;
    if ( v0 > 10 )
    {
      memset(&ret_str, 0, 0x40u);
      strcpy((char *)&ret_str, "serial:match baud failed\n");
      return 9;
    }
    v2 = v5;
    v4 = v5 + 1;
    printf("check basic system up : count %d\n", v2);
    sleep(1u);
  }
  if ( (unsigned __int8)pcba_start_basic(dword_1F0C8C, dword_1F0C90) != 1 )
    return 6;
  pcba_set_address(dword_1F0C8C);
  return pcba_fpga_ip_test(dword_1F0C8C);
}
// 1F0C8C: using guessed type int dword_1F0C8C;
// 1F0C90: using guessed type int dword_1F0C90;
// 479D5C: using guessed type int ret_str;

//----- (0002A48C) --------------------------------------------------------
int pcba_miner_area_test()
{
  int v0; // r3
  int v2; // r3
  int v4; // [sp+4h] [bp+4h]
  int v5; // [sp+4h] [bp+4h]

  v4 = 0;
  while ( (unsigned __int8)pcba_match_fpga_baud(dword_1F0C8C, dword_1F0C90) != 1 )
  {
    v0 = v4;
    v5 = v4 + 1;
    if ( v0 > 10 )
    {
      memset(&ret_str, 0, 0x40u);
      strcpy((char *)&ret_str, "serial:match baud failed\n");
      return 9;
    }
    v2 = v5;
    v4 = v5 + 1;
    printf("check miner system up : count %d\n", v2);
    sleep(1u);
  }
  if ( (unsigned __int8)pcba_start_fpgaminer(dword_1F0C8C, dword_1F0C90) != 1 )
    return 7;
  pcba_set_chips_baud(dword_1F0C8C, dword_1F0C90, byte_2FAF08);
  (*(void (__fastcall **)(int))(dword_1F0C8C + 4))(dword_1F0C8C);
  if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) != 1 )
    {
      printf("%s unknow algo\n", "pcba_miner_area_test");
      exit(1);
    }
    *(_DWORD *)(dword_1F0C8C + 304) = 0;
    pcba_set_ticket_mask(dword_1F0C8C, 32);
    usleep((__useconds_t)&stru_1869C.st_value);
  }
  else
  {
    *(_DWORD *)(dword_1F0C8C + 304) = 1;
  }
  pthread_create(&newthread, 0, (void *(*)(void *))sub_293BC, (void *)dword_1F0C8C);
  usleep(0x30D40u);
  pthread_create(&dword_47BE38, 0, (void *(*)(void *))sub_29414, (void *)dword_1F0C8C);
  pthread_create(&dword_47BE30, 0, (void *(*)(void *))sub_2A080, (void *)dword_1F0C8C);
  sleep(2u);
  pthread_cancel(newthread);
  pthread_join(newthread, 0);
  pthread_cancel(dword_47BE38);
  pthread_join(dword_47BE38, 0);
  pthread_cancel(dword_47BE30);
  pthread_join(dword_47BE30, 0);
  if ( *(_BYTE *)(dword_1F0C8C + 146) )
  {
    printf("%s stop mining\n", "pcba_miner_area_test");
    (*(void (__fastcall **)(int))(dword_1F0C8C + 8))(dword_1F0C8C);
  }
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 1F0C8C: using guessed type int dword_1F0C8C;
// 1F0C90: using guessed type int dword_1F0C90;
// 1F0C98: using guessed type int g_config_info;
// 479D5C: using guessed type int ret_str;

//----- (0002A734) --------------------------------------------------------
int singleBoardTest_fpgaminer()
{
  int device_num; // [sp+0h] [bp+0h]
  int v2; // [sp+4h] [bp+4h]

  printf("%s begin\n", "singleBoardTest_fpgaminer");
  memset(&g_pcba_info, 0, 0x78u);
  memset(&ret_str, 0, 0x40u);
  (*(void (__fastcall **)(_DWORD))(dword_1F0C90 + 8))(*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4));
  device_num = query_device_num();
  if ( device_num == 1 )
  {
    dword_1F0C8C = (int)runtime_ctrl(*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4));
    *(_DWORD *)(dword_1F0C8C + 136) = 0;
    (*(void (__fastcall **)(int))dword_1F0C8C)(dword_1F0C8C);
    sub_2874C(0);
    g_pcba_info = 1;
    pthread_create(&dword_47BE40, 0, (void *(*)(void *))sub_29190, (void *)dword_1F0C8C);
    pthread_create(&dword_47BE3C, 0, (void *(*)(void *))sub_2925C, 0);
    v2 = pcba_boot_area_test();
    if ( v2 )
    {
      dword_47BEA0 = v2;
    }
    else
    {
      v2 = pcba_basic_area_test();
      if ( v2 )
      {
        dword_47BEA0 = v2;
      }
      else
      {
        v2 = pcba_miner_area_test();
        if ( v2 )
          dword_47BEA0 = v2;
        else
          puts("Test Pass");
      }
    }
  }
  else
  {
    g_lcd_result_with_data = 4;
    printf("check chain failed. query_device_num error code %d and then exit\n", device_num);
  }
  g_pcba_info = 0;
  sleep(2u);
  pthread_cancel(dword_47BE40);
  pthread_join(dword_47BE40, 0);
  pthread_cancel(dword_47BE3C);
  pthread_join(dword_47BE3C, 0);
  if ( v2 )
  {
    g_lcd_result_with_data = 18;
    pcba_fill_lcd_result((const char *)&ret_str);
  }
  else if ( !dword_47BE64 )
  {
    sub_28CE8();
  }
  pcba_display_result_on_lcd();
  if ( dword_1F0C8C )
  {
    if ( *(_BYTE *)(dword_1F0C8C + 144) )
      (*(void (__fastcall **)(int))(dword_1F0C8C + 16))(dword_1F0C8C);
    free((void *)dword_1F0C8C);
  }
  (*(void (**)(void))(dword_1F0C90 + 80))();
  printf("Test finished error_type = %d\n", v2);
  return 1;
}
// 2A8F2: variable 'v2' is possibly undefined
// 1F0C8C: using guessed type int dword_1F0C8C;
// 1F0C90: using guessed type int dword_1F0C90;
// 1F0C98: using guessed type int g_config_info;
// 479D5C: using guessed type int ret_str;
// 47BE2C: using guessed type char g_pcba_info;
// 47BE64: using guessed type int dword_47BE64;
// 47BEA0: using guessed type int dword_47BEA0;
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (0002A99C) --------------------------------------------------------
int __fastcall singleBoardTest_asicminer(int a1)
{
  unsigned int v1; // r0
  const char *v3; // r3
  const char *v4; // r3
  const char *v5; // r2
  const char *v6; // r1
  const char *v7; // r3
  int v8; // r2
  const char *v9; // r2
  const char *v10; // r3
  const char *v11; // r2
  const char *v12; // r3
  const char *v13; // r2
  const char *v14; // r3
  int j; // [sp+14h] [bp+Ch]
  char *s; // [sp+18h] [bp+10h]
  int v19; // [sp+1Ch] [bp+14h]
  int i; // [sp+20h] [bp+18h]
  int v21; // [sp+24h] [bp+1Ch]

  v21 = 0;
  if ( !dword_1F0C94 )
  {
    lcd_clear_result_pcba();
    lcd_show(1u, "Start test...");
    pcba_total_device_no = query_device_num();
    if ( pcba_total_device_no != 1 )
    {
      printf("power on check chain failed. query_device_num error code %d\n", pcba_total_device_no);
      g_lcd_result_with_data = 4;
      pcba_display_result_on_lcd();
      v1 = sleep(3u);
      (*(void (__fastcall **)(unsigned int))(dword_1F0C90 + 80))(v1);
      return -1;
    }
    v21 = (*(int (__fastcall **)(_DWORD))(dword_1F0C90 + 92))(0);
    dword_1F0C8C = (int)runtime_ctrl(*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4));
    *(_DWORD *)(dword_1F0C8C + 136) = 0;
    (*(void (__fastcall **)(int))dword_1F0C8C)(dword_1F0C8C);
    gChain = (*(int (__fastcall **)(int))(dword_1F0C90 + 4))(pcba_total_device_no - 1);
    dword_1F0C94 = 1;
    pcba_set_fan_pwm(*(_DWORD *)(g_config_info + 100));
  }
  for ( i = 0; ; ++i )
  {
    if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 28) <= i )
      goto LABEL_67;
    pcba_set_fan_pwm(*(_DWORD *)(g_config_info + 100));
    printf("%s Begin Level %d\n", "singleBoardTest_asicminer", i + 1);
    memset(&g_lcd_result_with_data, 0, 0x48u);
    sub_2874C(i);
    if ( v21 < 0 )
    {
      *((_BYTE *)&gHistory_Result + 265800 * i + 6) = 0;
      lcd_show_one(1u, "Pic ERROR");
      sleep(2u);
      return -1;
    }
    lcd_show_one(1u, "Check EEPROM...");
    if ( *(_DWORD *)(g_config_info + 112) )
    {
      if ( a1 == 2 && (unsigned __int8)check_PT1_EEPROM_marker() != 1 )
        return -1;
      if ( (unsigned __int8)check_eeprom(0xFFu) != 1 )
      {
        g_lcd_result_with_data = 25;
        puts("Check EEPROM fail");
        *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) = 0;
        goto LABEL_67;
      }
    }
    lcd_show_one(1u, "set vol and freq");
    pcba_power_on(*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4), *(_DWORD *)(4 * i + *(_DWORD *)(g_config_info + 48)));
    (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(dword_1F0C90 + 24))(
      *(_DWORD *)(dword_1F0C8C + 136),
      *(_DWORD *)(4 * i + *(_DWORD *)(g_config_info + 48)),
      *(_DWORD *)(dword_1F0C8C + 776));
    if ( pthread_create(&dword_47BE40, 0, (void *(*)(void *))sub_29190, (void *)dword_1F0C8C) )
    {
      g_lcd_result_with_data = 7;
      dword_47BEA0 = 14;
      goto LABEL_43;
    }
    pcba_set_baud(dword_1F0C8C, dword_1F0C90, 115200);
    pcba_set_baud(dword_1F0C8C, dword_1F0C90, *(_DWORD *)(g_config_info + 96));
    *(_DWORD *)(dword_1F0C8C + 304) = 1;
    if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 6 )
      *(float *)(dword_1F0C8C + 760) = (float)(*(_DWORD *)(4 * i + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 24)) + 50);
    else
      *(float *)(dword_1F0C8C + 760) = (float)*(int *)(4 * i + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 24));
    lcd_show_one(1u, "Find ASIC...");
    if ( a1 == 2 )
      printf("Set freq to %.2f\n", *(float *)(dword_1F0C8C + 760));
    (*(void (__fastcall **)(int))(dword_1F0C8C + 4))(dword_1F0C8C);
    printf("Find %d ASIC\n", *(_DWORD *)(dword_1F0C8C + 236));
    if ( *(_DWORD *)(dword_1F0C8C + 236) != *(_DWORD *)(g_config_info + 40) )
    {
      g_lcd_result_with_data = 10;
      sprintf(dest, "       %03d     ", *(_DWORD *)(dword_1F0C8C + 236));
      dword_47BEA0 = 8;
      goto LABEL_43;
    }
    if ( a1 != 1 )
      break;
    g_lcd_result_with_data = 2;
    lcd_show_one(1u, "Check sensor...");
    sub_2A240(dword_1F0C8C);
    if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) )
      v3 = "OK";
    else
      v3 = "NG";
    sprintf(&byte_47BEB9[17], "EEPROM:   %s    ", v3);
    if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) )
      v4 = "OK";
    else
      v4 = "NG";
    sprintf(dword_47BEDB, "Sensor:   %s    ", v4);
    if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2)
      && *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) )
    {
      write_EEPROM_PT1_marker();
    }
LABEL_56:
    g_pcba_info = 0;
    sleep(2u);
    if ( *(_BYTE *)(dword_1F0C8C + 146) )
      (*(void (__fastcall **)(int))(dword_1F0C8C + 8))(dword_1F0C8C);
    v19 = 0;
    do
    {
      sleep(1u);
      printf("delay power down seconds......%d\n", *(_DWORD *)(g_config_info + 104) - v19);
      v8 = v19++;
    }
    while ( v8 < *(_DWORD *)(g_config_info + 104) );
    (*(void (__fastcall **)(_DWORD))(dword_1F0C90 + 28))(*(_DWORD *)(dword_1F0C8C + 136));
    pcba_power_off(*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4));
    if ( dword_47BEA0 || a1 != 2 )
      goto LABEL_67;
    if ( byte_47BE80 || i + 1 == *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 28) )
    {
      do_PT2_summary_work(dword_47BE7C);
LABEL_67:
      puts("Test finished");
      if ( a1 == 2 )
      {
        strcpy(dest, "Test done       ");
        sprintf(&byte_47BEB9[17], "Nonce: %.2f%", flt_47BE70);
        if ( *((unsigned __int8 *)&gHistory_Result + 265800 * dword_47BE7C + 265796) > 1u )
        {
          strcpy(dest, "Test all fail   ");
          if ( *((int *)&gHistory_Result + 66450 * dword_47BE7C + 65803) <= 0 )
          {
            if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) )
              v13 = "OK";
            else
              v13 = "NG";
            if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) )
              v14 = "OK";
            else
              v14 = "NG";
            sprintf(dword_47BEDB, "P:NG E:%s S:%s", v13, v14);
          }
          else
          {
            if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) )
              v11 = "OK";
            else
              v11 = "NG";
            if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) )
              v12 = "OK";
            else
              v12 = "NG";
            sprintf(&byte_47BEB9[17], "P:NG E:%s S:%s", v11, v12);
            sprintf(dword_47BEDB, "B:%02d:", *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 65803));
            s = (char *)&dword_47BEDF + 1;
            for ( j = 0; *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + 65803) > j; ++j )
            {
              sprintf(s, "%d ", *((_DWORD *)&gHistory_Result + 66450 * dword_47BE7C + j + 65804) + 1);
              if ( *((int *)&gHistory_Result + 66450 * dword_47BE7C + j + 65804) > 8 )
              {
                if ( *((int *)&gHistory_Result + 66450 * dword_47BE7C + j + 65804) > 98 )
                  s += 4;
                else
                  s += 3;
              }
              else
              {
                s += 2;
              }
            }
          }
        }
        else
        {
          if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) )
            v9 = "OK";
          else
            v9 = "NG";
          if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) )
            v10 = "OK";
          else
            v10 = "NG";
          sprintf(dword_47BEDB, "P:OK E:%s S:%s", v9, v10);
        }
LABEL_100:
        pcba_display_result_on_lcd();
      }
      else if ( a1 == 1 )
      {
        goto LABEL_100;
      }
      pcba_set_fan_pwm(30);
      return 0;
    }
    puts("goto next level");
  }
  pcba_set_working_voltage(
    *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4),
    *(_DWORD *)(4 * i + *(_DWORD *)(g_config_info + 48)));
  if ( pthread_create(&dword_47BE3C, 0, (void *(*)(void *))sub_2925C, 0) )
  {
    g_lcd_result_with_data = 14;
    dword_47BEA0 = 14;
  }
  else if ( pthread_create(&newthread, 0, (void *(*)(void *))sub_293BC, (void *)dword_1F0C8C) )
  {
    g_lcd_result_with_data = 9;
    dword_47BEA0 = 14;
  }
  else
  {
    usleep(0x30D40u);
    if ( pthread_create(&dword_47BE38, 0, (void *(*)(void *))sub_29414, (void *)dword_1F0C8C) )
    {
      g_lcd_result_with_data = 15;
      dword_47BEA0 = 14;
    }
    else if ( pthread_create(&dword_47BE30, 0, (void *(*)(void *))sub_2A080, (void *)dword_1F0C8C) )
    {
      g_lcd_result_with_data = 16;
      dword_47BEA0 = 14;
    }
    else
    {
      while ( g_pcba_info )
        sleep(1u);
    }
  }
LABEL_43:
  pcba_display_result_on_lcd();
  if ( a1 != 2
    || *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) == 1
    && *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) == 1 )
  {
    goto LABEL_56;
  }
  sprintf(&byte_47BEB9[17], "Nonce: %.2f%", flt_47BE70);
  if ( *((unsigned __int8 *)&gHistory_Result + 265800 * dword_47BE7C + 265796) > 1u )
    v5 = "NG";
  else
    v5 = "OK";
  if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) )
    v6 = "OK";
  else
    v6 = "NG";
  if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 4) )
    v7 = "OK";
  else
    v7 = "NG";
  sprintf(dword_47BEDB, "P:%s E:%s S:%s", v5, v6, v7);
  g_lcd_result_with_data = 20;
  pcba_display_result_on_lcd();
  sleep(3u);
  (*(void (__fastcall **)(_DWORD))(dword_1F0C90 + 28))(*(_DWORD *)(dword_1F0C8C + 136));
  pcba_power_off(*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4));
  return -1;
}
// 1EC5C8: using guessed type int gChain;
// 1F0C88: using guessed type int pcba_total_device_no;
// 1F0C8C: using guessed type int dword_1F0C8C;
// 1F0C90: using guessed type int dword_1F0C90;
// 1F0C94: using guessed type int dword_1F0C94;
// 1F0C98: using guessed type int g_config_info;
// 47BE2C: using guessed type char g_pcba_info;
// 47BE70: using guessed type float flt_47BE70;
// 47BE7C: using guessed type int dword_47BE7C;
// 47BE80: using guessed type char byte_47BE80;
// 47BEA0: using guessed type int dword_47BEA0;
// 47BEA4: using guessed type int g_lcd_result_with_data;
// 47BEDF: using guessed type int dword_47BEDF;

//----- (0002B754) --------------------------------------------------------
void __noreturn restart_single_board_test()
{
  char v0; // [sp+Fh] [bp+Fh] BYREF
  int v1; // [sp+10h] [bp+10h]
  unsigned int v2; // [sp+14h] [bp+14h]

  v2 = 0;
  sleep(3u);
  while ( 1 )
  {
    v0 = 1;
    v1 = gpio_read(943, &v0);
    if ( v1 < 0 || v0 )
      v2 = 0;
    else
      ++v2;
    if ( v2 > 0x18 )
      system("/etc/init.d/cgminer.sh restart");
    usleep(0x30D40u);
  }
}

//----- (0002B7B4) --------------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _UNKNOWN **v3; // r0
  int v4; // r1
  const char *v6; // r4
  int v7; // r0
  const char *v8; // r4
  int v9; // r0
  _BYTE s[67]; // [sp+8h] [bp+8h] BYREF
  char v12; // [sp+4Bh] [bp+4Bh] BYREF
  pthread_t newthread; // [sp+4Ch] [bp+4Ch] BYREF
  char *v14; // [sp+50h] [bp+50h]
  int v15; // [sp+54h] [bp+54h]

  putenv("HAL_CONFIG_PATH=/mnt/card");
  v14 = getenv("HAL_CONFIG_PATH");
  if ( v14 )
    printf("HAL_CONFIG_PATH=%s\n", v14);
  if ( log_init() )
    puts("log init error!");
  set_flag_to_bad_asic_cfg_freq(4u);
  v3 = dev_ctrl();
  dword_1F0C90 = (int)v3;
  while ( 1 )
  {
    (*(void (__fastcall **)(_UNKNOWN **, int))(dword_1F0C90 + 12))(v3, v4);
    pcba_total_device_no = query_device_num();
    if ( pcba_total_device_no != 1 && pcba_total_device_no != 2 )
    {
      g_lcd_result_with_data = 5;
      pcba_display_result_on_lcd();
      puts("Can't find device, please check hashboard!");
    }
    pcba_set_fan_pwm(30);
    lcd_clear_result();
    lcd_show(1u, "Init...         ");
    if ( !app_config_init() )
      break;
    if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 6 || *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 7 )
    {
      v6 = *(const char **)(g_config_info + 20);
      v7 = strcmp(v6, "PT2");
      printf("%s test %d  pcba_total_device_no %d\n", v6, v7, pcba_total_device_no);
      if ( strcmp(*(const char **)(g_config_info + 20), "PT1")
        || (*(_DWORD *)(g_config_info + 36) = 1,
            *(_DWORD *)(g_config_info + 32) = 0,
            *(_DWORD *)(g_config_info + 108) = 0,
            pcba_total_device_no == 1) )
      {
        if ( *(_DWORD *)(g_config_info + 36) || pcba_total_device_no == 2 )
          goto LABEL_23;
        goto LABEL_18;
      }
      lcd_show(1u, "Chain ERROR");
      printf("PT1 test chain error, find %d chain\n", pcba_total_device_no);
      v3 = (_UNKNOWN **)sleep(5u);
    }
    else
    {
      if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) != 5 )
        goto LABEL_24;
      v8 = *(const char **)(g_config_info + 20);
      v9 = strcmp(v8, "PT2");
      printf("%s test %d  pcba_total_device_no %d\n", v8, v9, pcba_total_device_no);
      *(_DWORD *)(g_config_info + 108) = 1;
      if ( *(_DWORD *)(g_config_info + 36) || pcba_total_device_no == 2 )
      {
LABEL_23:
        prepare_mes_config_test_process(g_config_info);
LABEL_24:
        load_patterns(g_config_info);
        sub_28DAC();
        pthread_create(&newthread, 0, (void *(*)(void *))restart_single_board_test, 0);
        while ( 1 )
        {
          v15 = 0;
          memset(s, 0, 0x40u);
          if ( (*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 6
             || *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 7
             || *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 5)
            && !*(_DWORD *)(g_config_info + 36) )
          {
            if ( *(_DWORD *)(g_config_info + 32) )
            {
              if ( gFind_test_standard != 1 )
              {
                v15 = scan_code_from_hashboard(dword_1F0C90);
                if ( !v15 )
                  continue;
                if ( (unsigned __int8)prepare_test_standard(g_config_info) != 1 )
                {
                  gScanCodeGun_data_ready = 0;
                  continue;
                }
              }
            }
            else if ( gFind_test_standard != 1 )
            {
              v15 = scan_code_from_hashboard(dword_1F0C90);
              if ( !v15 )
                continue;
              gFind_test_standard = 1;
              lcd_clear_result_pcba();
              lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
              lcd_show(1u, "Find test");
              lcd_show(2u, "standard");
              lcd_show(3u, "Press Start Key");
              puts("find test standard from local Config.ini, Press Start Key to Begin Test");
            }
          }
          if ( !strcmp(*(const char **)(g_config_info + 116), "keyboard") )
          {
            v15 = _isoc99_fscanf(stdin, "%s", s);
          }
          else
          {
            if ( strcmp(*(const char **)(g_config_info + 116), "button") )
            {
              puts("please assign ctrl type: keyboard or button");
              app_config_exit();
              return 0;
            }
            v12 = 1;
            v15 = gpio_read(943, &v12);
            s[0] = v12 + 48;
          }
          if ( v15 >= 0 && s[0] == 48 )
          {
            gScanCodeGun_data_ready = 0;
            gFind_test_standard = 0;
            if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 2
              || *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 6
              || *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 7
              || *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 5 )
            {
              if ( !strcmp(*(const char **)(g_config_info + 20), "PT1") )
              {
                singleBoardTest_asicminer(1);
              }
              else if ( !strcmp(*(const char **)(g_config_info + 20), "PT2") )
              {
                singleBoardTest_asicminer(2);
              }
              byte_47BE81 = 1;
              byte_47BE82 = 0;
              while ( byte_47BE81 )
              {
                check_whether_board_changed((int)&g_pcba_info);
                if ( byte_47BE82 )
                  byte_47BE81 = 0;
              }
            }
            else
            {
              singleBoardTest_fpgaminer();
            }
            sub_28DAC();
          }
          usleep(0x30D40u);
        }
      }
LABEL_18:
      lcd_show(1u, "Chain ERROR");
      printf("Chain error, now only find %d chain\n", pcba_total_device_no);
      v3 = (_UNKNOWN **)sleep(5u);
    }
  }
  puts("app_config_init failed");
  return -1;
}
// 2B824: variable 'v4' is possibly undefined
// 20644: using guessed type int _isoc99_fscanf(_DWORD, const char *, ...);
// 1F0C78: using guessed type int stdin;
// 1F0C84: using guessed type char gScanCodeGun_data_ready;
// 1F0C88: using guessed type int pcba_total_device_no;
// 1F0C90: using guessed type int dword_1F0C90;
// 1F0C98: using guessed type int g_config_info;
// 1F0D64: using guessed type char gFind_test_standard;
// 479D9C: using guessed type int MES2Local_Config_Information;
// 47BE2C: using guessed type char g_pcba_info;
// 47BE81: using guessed type char byte_47BE81;
// 47BE82: using guessed type char byte_47BE82;
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (0002BDF8) --------------------------------------------------------
size_t __fastcall pcba_fill_lcd_result(const char *a1)
{
  size_t result; // r0
  int v2; // r3
  signed int v4; // [sp+8h] [bp+8h]
  int i; // [sp+18h] [bp+18h]
  int v6; // [sp+1Ch] [bp+1Ch]

  result = strlen(a1);
  v2 = (result + 1) & 0xF;
  if ( (int)(result + 1) <= 0 )
    v2 = -(-(result + 1) & 0xF);
  v6 = (int)(result + 1) / 16 + (v2 != 0);
  if ( v6 > 4 )
    v6 = 4;
  for ( i = 0; i < v6; ++i )
  {
    v4 = strlen(&a1[16 * i]);
    if ( v4 > 15 )
      result = sprintf((char *)&g_lcd_result_with_data + 17 * i + 4, &a1[16 * i], 16);
    else
      result = sprintf((char *)&g_lcd_result_with_data + 17 * i + 4, &a1[16 * i], v4);
  }
  return result;
}
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (0002BED4) --------------------------------------------------------
int pcba_lcd_dump()
{
  signed int j; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  printf("------------LCD display-------------");
  for ( i = 0; i <= 3; ++i )
  {
    for ( j = strlen((const char *)&g_lcd_result_with_data + 17 * i + 4); j <= 15; ++j )
      *((_BYTE *)&g_lcd_result_with_data + 17 * i + j + 4) = 32;
    printf("%s", (const char *)&g_lcd_result_with_data + 17 * i + 4);
  }
  return printf("-----------------------------------");
}
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (0002BF7C) --------------------------------------------------------
int pcba_display_result_on_lcd()
{
  int result; // r0
  size_t v1; // r0
  signed int j; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  switch ( g_lcd_result_with_data )
  {
    case 0:
    case 1:
    case 18:
    case 20:
      result = lcd_clear_result();
      for ( i = 0; i <= 3; ++i )
      {
        for ( j = strlen((const char *)&g_lcd_result_with_data + 17 * i + 4); j <= 15; ++j )
          *((_BYTE *)&g_lcd_result_with_data + 17 * i + j + 4) = 32;
        result = lcd_show_result(i, (int)&g_lcd_result_with_data + 17 * i + 4, 0x10u);
      }
      break;
    case 2:
      lcd_clear_result();
      lcd_show_result(1u, (int)"Find ASIC:OK    ", 0x10u);
      lcd_show_result(2u, 4701898, 0x10u);
      result = lcd_show_result(3u, 4701915, 0x10u);
      break;
    case 3:
      lcd_clear_result();
      lcd_show_result(1u, (int)"  FPGA version  ", 0x10u);
      result = lcd_show_result(2u, (int)"     error      ", 0x10u);
      break;
    case 4:
      lcd_clear_result();
      lcd_show_result(1u, (int)"Hash board error", 0x10u);
      result = lcd_show_result(2u, (int)"Only support one", 0x10u);
      break;
    case 5:
      lcd_clear_result();
      result = lcd_show_result(1u, (int)"Hash board error", 0x10u);
      break;
    case 6:
      lcd_clear_result();
      result = lcd_show_result(1u, (int)" Pic init error ", 0x10u);
      break;
    case 7:
      lcd_clear_result();
      lcd_show_result(1u, (int)"  Create heart  ", 0x10u);
      result = lcd_show_result(2u, (int)"  thread error  ", 0x10u);
      break;
    case 8:
      lcd_clear_result();
      result = lcd_show_result(1u, (int)" Voltage error  ", 0x10u);
      break;
    case 9:
      lcd_clear_result();
      lcd_show_result(1u, (int)" Create receive ", 0x10u);
      result = lcd_show_result(2u, (int)"  thread error  ", 0x10u);
      break;
    case 10:
      lcd_clear_result();
      lcd_show_result(0, (int)"   Only have    ", 0x10u);
      lcd_show_result(1u, (int)dest, 0x10u);
      result = lcd_show_result(2u, (int)"      ASIC      ", 0x10u);
      break;
    case 12:
      lcd_clear_result();
      result = lcd_show_result(1u, (int)dest, 0x10u);
      break;
    case 13:
      lcd_clear_result();
      lcd_show_result(0, (int)"Sensor: NG", 0x10u);
      result = lcd_show_result(1u, (int)"TEMP Value Error", 0x10u);
      break;
    case 14:
      lcd_clear_result();
      lcd_show_result(1u, (int)" Create status  ", 0x10u);
      result = lcd_show_result(2u, (int)"  thread error  ", 0x10u);
      break;
    case 15:
      lcd_clear_result();
      lcd_show_result(1u, (int)"  Create send   ", 0x10u);
      result = lcd_show_result(2u, (int)"  thread error  ", 0x10u);
      break;
    case 16:
      lcd_clear_result();
      lcd_show_result(1u, (int)"  Create TEMP   ", 0x10u);
      result = lcd_show_result(2u, (int)"  thread error  ", 0x10u);
      break;
    case 17:
      lcd_clear_result();
      lcd_show_result(0, (int)"   dump ASIC   ", 0x10u);
      lcd_show_result(1u, (int)dest, 0x10u);
      result = lcd_show_result(2u, (int)"    failed    ", 0x10u);
      break;
    case 19:
      lcd_clear_result();
      lcd_show_result(1u, (int)" Press Button   ", 0x10u);
      result = lcd_show_result(2u, (int)"   Please       ", 0x10u);
      break;
    case 21:
      lcd_clear_result();
      lcd_show_result(1u, (int)"    Write PIC   ", 0x10u);
      result = lcd_show_result(2u, (int)"    error       ", 0x10u);
      break;
    case 22:
      lcd_clear_result();
      v1 = strlen(dest);
      lcd_show_result(0, (int)dest, v1);
      lcd_show_result(1u, (int)"connect internet ", 0x10u);
      result = lcd_show_result(2u, (int)"please  wait    ", 0x10u);
      break;
    case 23:
      lcd_clear_result();
      lcd_show_result(0, (int)dest, 0x10u);
      lcd_show_result(1u, (int)"Prepare MES     ", 0x10u);
      lcd_show_result(2u, (int)"config handshake", 0x10u);
      result = lcd_show_result(3u, (int)"fail            ", 0x10u);
      break;
    case 25:
      lcd_clear_result();
      result = lcd_show_result(1u, (int)"Check EEPROM:NG ", 0x10u);
      break;
    default:
      lcd_clear_result();
      lcd_show_result(0, (int)"     Fail       ", 0x10u);
      result = lcd_show_result(1u, (int)"  Unknow Error  ", 0x10u);
      break;
  }
  return result;
}
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (0002C3A4) --------------------------------------------------------
int __fastcall lcd_show(unsigned __int8 a1, const char *a2)
{
  size_t v2; // r0

  v2 = strlen(a2);
  return lcd_show_result(a1, (int)a2, v2);
}

//----- (0002C3C8) --------------------------------------------------------
int lcd_clear_result_pcba()
{
  lcd_show_result(0, (int)"                ", 0x10u);
  lcd_show_result(1u, (int)"                ", 0x10u);
  lcd_show_result(2u, (int)"                ", 0x10u);
  return lcd_show_result(3u, (int)"                ", 0x10u);
}

//----- (0002C410) --------------------------------------------------------
int __fastcall lcd_show_one(unsigned __int8 a1, const char *a2)
{
  size_t v2; // r0

  lcd_clear_result_pcba();
  v2 = strlen(a2);
  return lcd_show_result(a1, (int)a2, v2);
}

//----- (0002C438) --------------------------------------------------------
void __cdecl json_decref(json_t_0 *json)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( json && *((_DWORD *)json + 1) != -1 )
  {
    v1 = (unsigned int *)((char *)json + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete(json);
  }
}

//----- (0002C47C) --------------------------------------------------------
int __fastcall get_key_value_string(const json_t *a1, const char *a2, void **a3)
{
  const char *v4; // r0
  json_t *v7; // [sp+14h] [bp+14h]

  v7 = json_object_get(a1, a2);
  if ( !v7 )
    return 0;
  if ( *(_DWORD *)v7 != 2 || !json_string_value(v7) )
    return 0;
  if ( *a3 )
  {
    free(*a3);
    *a3 = 0;
  }
  v4 = json_string_value(v7);
  *a3 = strdup(v4);
  return 1;
}

//----- (0002C4F4) --------------------------------------------------------
int __fastcall get_key_value_interger(const json_t *a1, const char *a2, int *a3)
{
  json_t *v6; // [sp+14h] [bp+14h]

  v6 = json_object_get(a1, a2);
  if ( !v6 )
    return 0;
  if ( *(_DWORD *)v6 != 3 )
    return 0;
  *a3 = json_integer_value(v6);
  return 1;
}

//----- (0002C540) --------------------------------------------------------
int __fastcall get_key_value_real(const json_t *a1, const char *a2, _QWORD *a3)
{
  __int64 v3; // d0
  json_t *v7; // [sp+14h] [bp+14h]

  v7 = json_object_get(a1, a2);
  if ( !v7 )
    return 0;
  if ( *(_DWORD *)v7 != 4 )
    return 0;
  json_real_value(v7);
  *a3 = v3;
  return 1;
}
// 2C57A: variable 'v3' is possibly undefined

//----- (0002C58C) --------------------------------------------------------
int __fastcall get_key_value_boolean(const json_t *a1, const char *a2, bool *a3)
{
  json_t *v6; // [sp+14h] [bp+14h]

  v6 = json_object_get(a1, a2);
  if ( !v6 )
    return 0;
  if ( *(_DWORD *)v6 != 5 && *(_DWORD *)v6 != 6 )
    return 0;
  *a3 = *(_DWORD *)v6 == 5;
  return 1;
}
// 2C5CC: conditional instruction was optimized away because %var_4.4!=0
// 2C5BE: conditional instruction was optimized away because %var_4.4!=0

//----- (0002C5F4) --------------------------------------------------------
int __fastcall get_key_value_array_interger(const json_t *a1, const char *a2, void **a3, size_t *a4)
{
  size_t v5; // r0
  int *v6; // r4
  _DWORD *v10; // [sp+14h] [bp+14h]
  json_t *v11; // [sp+18h] [bp+18h]
  size_t i; // [sp+1Ch] [bp+1Ch]

  v11 = json_object_get(a1, a2);
  if ( v11 )
  {
    if ( *(_DWORD *)v11 != 1 )
      return 0;
    *a4 = json_array_size(v11);
    if ( *a3 )
    {
      free(*a3);
      *a3 = 0;
    }
    if ( json_array_size(v11) )
    {
      v5 = json_array_size(v11);
      *a3 = malloc(4 * v5);
      if ( !*a3 )
      {
        printf("%s malloc failed!\n", "get_key_value_array_interger");
        return 0;
      }
      for ( i = 0; json_array_size(v11) > i; ++i )
      {
        v10 = (_DWORD *)json_array_get(v11, i);
        if ( !v10 )
          break;
        if ( *v10 != 3 )
        {
          printf("%s json is not integer!\n", "get_key_value_array_interger");
          return 0;
        }
        v6 = (int *)((char *)*a3 + 4 * i);
        *v6 = json_integer_value(v10);
      }
    }
    return 1;
  }
  return 0;
}

//----- (0002C708) --------------------------------------------------------
int __fastcall get_key_value_array_real(const json_t *a1, const char *a2, void **a3, size_t *a4)
{
  __int64 v4; // d0
  size_t v6; // r0
  _QWORD *v7; // r4
  const json_t *v11; // [sp+14h] [bp+14h]
  json_t *v12; // [sp+18h] [bp+18h]
  size_t i; // [sp+1Ch] [bp+1Ch]

  v12 = json_object_get(a1, a2);
  if ( v12 )
  {
    if ( *(_DWORD *)v12 != 1 )
      return 0;
    *a4 = json_array_size(v12);
    if ( *a3 )
    {
      free(*a3);
      *a3 = 0;
    }
    if ( json_array_size(v12) )
    {
      v6 = json_array_size(v12);
      *a3 = malloc(8 * v6);
      if ( !*a3 )
      {
        printf("%s malloc failed!\n", "get_key_value_array_real");
        return 0;
      }
      for ( i = 0; json_array_size(v12) > i; ++i )
      {
        v11 = (const json_t *)json_array_get(v12, i);
        if ( !v11 )
          break;
        if ( *(_DWORD *)v11 != 4 )
        {
          printf("%s json is not double!\n", "get_key_value_array_real");
          return 0;
        }
        v7 = (char *)*a3 + 8 * i;
        json_real_value(v11);
        *v7 = v4;
      }
    }
    return 1;
  }
  return 0;
}
// 2C7CA: variable 'v4' is possibly undefined

//----- (0002C81C) --------------------------------------------------------
bool __fastcall parse_config(const json_t *a1, int a2)
{
  bool v3; // r3
  const json_t *v8; // [sp+8h] [bp+8h]
  json_t *v9; // [sp+Ch] [bp+Ch]
  unsigned int i; // [sp+10h] [bp+10h]
  bool v11; // [sp+17h] [bp+17h]

  v11 = 0;
  v9 = json_object_get(a1, "TestCoins");
  if ( v9 && *(_DWORD *)v9 == 1 )
  {
    *(_DWORD *)(a2 + 4) = json_array_size(v9);
    *(_DWORD *)a2 = malloc(80 * *(_DWORD *)(a2 + 4));
    if ( !*(_DWORD *)a2 )
    {
      printf("%s malloc failed!\n", "parse_config");
      return 0;
    }
    memset(*(void **)a2, 0, 80 * *(_DWORD *)(a2 + 4));
    for ( i = 0; *(_DWORD *)(a2 + 4) > i; ++i )
    {
      v8 = (const json_t *)json_array_get(v9, i);
      if ( !v8 )
        break;
      if ( *(_DWORD *)v8 )
      {
        printf("JSON value type error!");
      }
      else
      {
        v3 = get_key_value_string(v8, "Algo", (void **)(80 * i + *(_DWORD *)a2))
          && get_key_value_interger(v8, "CoreNum", (int *)(80 * i + *(_DWORD *)a2 + 12))
          && get_key_value_interger(v8, "PatternNum", (int *)(80 * i + *(_DWORD *)a2 + 16))
          && get_key_value_interger(v8, "Timeout", (int *)(80 * i + *(_DWORD *)a2 + 20))
          && get_key_value_array_interger(
               v8,
               "Frequence",
               (void **)(80 * i + *(_DWORD *)a2 + 24),
               (size_t *)(80 * i + *(_DWORD *)a2 + 28))
          && get_key_value_array_real(
               v8,
               "MinValidPatternPecent",
               (void **)(80 * i + *(_DWORD *)a2 + 36),
               (size_t *)(80 * i + *(_DWORD *)a2 + 40))
          && get_key_value_real(v8, "MaxHWPecent", (_QWORD *)(80 * i + *(_DWORD *)a2 + 48))
          && get_key_value_boolean(v8, "IsTest", (bool *)(80 * i + *(_DWORD *)a2 + 56));
        v11 = v3;
      }
      if ( !v11 )
        break;
    }
  }
  if ( v11 )
    return get_key_value_string(a1, "WorkPathPre", (void **)(a2 + 12))
        && get_key_value_string(a1, "AsicType", (void **)(a2 + 16))
        && get_key_value_interger(a1, "AsicNum", (int *)(a2 + 40))
        && get_key_value_interger(a1, "OpenCoreGap", (int *)(a2 + 44))
        && get_key_value_array_interger(a1, "Voltage", (void **)(a2 + 48), (size_t *)(a2 + 52))
        && get_key_value_array_interger(a1, "TempSensor", (void **)(a2 + 68), (size_t *)(a2 + 72))
        && get_key_value_interger(a1, "StartTemp", (int *)(a2 + 76))
        && get_key_value_interger(a1, "AlarmTemp", (int *)(a2 + 80))
        && get_key_value_interger(a1, "TempWaitingTime", (int *)(a2 + 84))
        && get_key_value_interger(a1, "Baudrate", (int *)(a2 + 96))
        && get_key_value_interger(a1, "TestMode", (int *)(a2 + 92))
        && get_key_value_interger(a1, "FanSpeed", (int *)(a2 + 100))
        && get_key_value_interger(a1, "DelayPowerDown", (int *)(a2 + 104))
        && get_key_value_string(a1, "RepeatCtrl", (void **)(a2 + 116));
  return v11;
}
// 2CA48: masking with 0x1 was optimized away because r3.1 <= 0x1
// 2CC1E: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (0002CC2C) --------------------------------------------------------
bool __fastcall read_config_json(_DWORD *a1)
{
  char s[256]; // [sp+10h] [bp+8h] BYREF
  int v5[23]; // [sp+110h] [bp+108h] BYREF
  char v6[160]; // [sp+16Ch] [bp+164h] BYREF
  json_t_0 *file; // [sp+20Ch] [bp+204h]
  char *v8; // [sp+210h] [bp+208h]
  bool v9; // [sp+217h] [bp+20Fh]

  v8 = getenv("PCBA_CONFIG_PATH");
  if ( v8 )
    snprintf(s, 0x100u, "%s/%s.json", v8, "Config");
  else
    snprintf(s, 0x100u, "/mnt/card/%s.json", "Config");
  printf("pcba config path = %s\n", s);
  file = (json_t_0 *)json_load_file(s, 0, (json_error_t *)v5);
  if ( file && !*(_DWORD *)file )
  {
    v9 = parse_config(file, (int)a1);
    json_decref(file);
  }
  else
  {
    v9 = 0;
    if ( v5[0] >= 0 )
      printf("%s:%d: %s\n", s, v5[0], v6);
    else
      puts(v6);
  }
  if ( *(_DWORD *)(*a1 + 40) == a1[13] && a1[13] == *(_DWORD *)(*a1 + 28) )
    return v9;
  printf(
    "%s the level number is not equal: [%d %d %d]\n ",
    "read_config_json",
    a1[13],
    *(_DWORD *)(*a1 + 28),
    *(_DWORD *)(*a1 + 40));
  return 0;
}

//----- (0002CD84) --------------------------------------------------------
int __cdecl parse_config_ini_array(const char *str, void **pointer)
{
  __int64 v2; // d0
  int v3; // r3
  _QWORD *v4; // r4
  int *v5; // r4
  char nptr[32]; // [sp+8h] [bp+8h] BYREF
  signed int v10; // [sp+28h] [bp+28h]
  signed int j; // [sp+2Ch] [bp+2Ch]
  int v12; // [sp+30h] [bp+30h]
  int v13; // [sp+34h] [bp+34h]
  signed int i; // [sp+38h] [bp+38h]
  void *v15; // [sp+3Ch] [bp+3Ch]
  size_t size; // [sp+40h] [bp+40h]
  int v17; // [sp+44h] [bp+44h]
  _BYTE v18[4]; // [sp+48h] [bp+48h] BYREF

  v10 = strlen(str);
  v17 = 1;
  size = 0;
  v15 = 0;
  for ( i = 0; i < v10; ++i )
  {
    if ( str[i] == 46 )
      v17 = 0;
    if ( str[i] == 44 )
      ++size;
  }
  ++size;
  if ( v17 )
  {
    v15 = malloc(4 * size);
    memset(v15, 0, 4 * size);
  }
  else
  {
    v15 = malloc(8 * size);
    memset(v15, 0, 8 * size);
  }
  v13 = 0;
  memset(nptr, 0, sizeof(nptr));
  v12 = 0;
  for ( j = 0; j < v10; ++j )
  {
    if ( (unsigned __int8)str[j] > 0x2Fu && (unsigned __int8)str[j] <= 0x39u || str[j] == 46 )
    {
      v3 = v13++;
      v18[v3 - 64] = str[j];
    }
    if ( str[j] == 44 || str[j] == 93 )
    {
      nptr[v13] = 0;
      if ( v17 )
      {
        v5 = (int *)((char *)v15 + 4 * v12);
        *v5 = atoi(nptr);
      }
      else
      {
        v4 = (char *)v15 + 8 * v12;
        atof(nptr);
        *v4 = v2;
      }
      ++v12;
      memset(nptr, 32, sizeof(nptr));
      v13 = 0;
    }
  }
  *pointer = v15;
  return size;
}
// 2CEB8: variable 'v2' is possibly undefined

//----- (0002CF0C) --------------------------------------------------------
int __fastcall read_config_ini(void **a1)
{
  double v1; // d0
  _DWORD *v3; // r4
  _DWORD *v4; // r4
  _DWORD *v5; // r4
  float *v6; // r4
  float v7; // s15
  float *v8; // r4
  float v9; // s15
  float *v10; // r4
  float v11; // s15
  double *v12; // r4
  char v15[256]; // [sp+14h] [bp+Ch] BYREF
  int v16; // [sp+114h] [bp+10Ch] BYREF
  char filename[256]; // [sp+118h] [bp+110h] BYREF
  char s[256]; // [sp+218h] [bp+210h] BYREF
  size_t v19; // [sp+318h] [bp+310h]
  size_t v20; // [sp+31Ch] [bp+314h]
  size_t v21; // [sp+320h] [bp+318h]
  size_t v22; // [sp+324h] [bp+31Ch]
  size_t v23; // [sp+328h] [bp+320h]
  size_t n; // [sp+32Ch] [bp+324h]
  size_t size; // [sp+330h] [bp+328h]
  FILE *stream; // [sp+334h] [bp+32Ch]
  char *v27; // [sp+338h] [bp+330h]
  char *nptr; // [sp+33Ch] [bp+334h]

  memset(s, 0, sizeof(s));
  nptr = 0;
  v27 = getenv("PCBA_CONFIG_PATH");
  if ( v27 )
    snprintf(filename, 0x100u, "%s/%s.ini", v27, "Config");
  else
    snprintf(filename, 0x100u, "/mnt/card/%s.ini", "Config");
  stream = fopen(filename, "r");
  if ( stream )
  {
    a1[1] = (void *)1;
    *a1 = malloc(80 * (_DWORD)a1[1]);
    if ( *a1 )
    {
      memset(*a1, 0, 80 * (_DWORD)a1[1]);
      while ( fgets(s, 255, stream) )
      {
        if ( s[0] != 35 && s[1] != 35 )
        {
          nptr = strstr(s, "WorkPathPre=");
          if ( nptr )
          {
            nptr += 12;
            size = strlen(nptr) + 1;
            a1[3] = malloc(size);
            memset(a1[3], 0, size);
            _isoc99_sscanf(nptr, "%s", a1[3]);
          }
          else
          {
            nptr = strstr(s, "Test_Process=");
            if ( nptr )
            {
              nptr += 13;
              n = strlen(nptr) + 1;
              a1[5] = malloc(n);
              memset(a1[5], 0, n);
              _isoc99_sscanf(nptr, "%s", a1[5]);
            }
            else
            {
              nptr = strstr(s, "Miner_Type=");
              if ( nptr )
              {
                nptr += 11;
                v23 = strlen(nptr) + 1;
                a1[6] = malloc(v23);
                memset(a1[6], 0, v23);
                _isoc99_sscanf(nptr, "%s", a1[6]);
              }
              else
              {
                nptr = strstr(s, "Board_Name=");
                if ( nptr )
                {
                  nptr += 11;
                  v22 = strlen(nptr) + 1;
                  a1[7] = malloc(v22);
                  memset(a1[7], 0, v22);
                  _isoc99_sscanf(nptr, "%s", a1[7]);
                }
                else
                {
                  nptr = strstr(s, "AsicType=");
                  if ( nptr )
                  {
                    nptr += 9;
                    v21 = strlen(nptr) + 1;
                    a1[4] = malloc(v21);
                    memset(a1[4], 0, v21);
                    _isoc99_sscanf(nptr, "%s", a1[4]);
                  }
                  else
                  {
                    nptr = strstr(s, "AsicNum=");
                    if ( nptr )
                    {
                      nptr += 8;
                      _isoc99_sscanf(nptr, "%d", a1 + 10);
                    }
                    else
                    {
                      nptr = strstr(s, "Factory_Mode=");
                      if ( nptr )
                      {
                        nptr += 13;
                        _isoc99_sscanf(nptr, "%d", a1 + 8);
                      }
                      else
                      {
                        nptr = strstr(s, "Bypass_Scan_Code_Gun=");
                        if ( nptr )
                        {
                          nptr += 21;
                          _isoc99_sscanf(nptr, "%d", a1 + 9);
                        }
                        else
                        {
                          nptr = strstr(s, "OpenCoreGap=");
                          if ( nptr )
                          {
                            nptr += 12;
                            _isoc99_sscanf(nptr, "%d", a1 + 11);
                          }
                          else
                          {
                            nptr = strstr(s, "Voltage=");
                            if ( nptr )
                            {
                              nptr += 8;
                              memset(v15, 0, sizeof(v15));
                              _isoc99_sscanf(nptr, "%s", v15);
                              a1[13] = (void *)parse_config_ini_array(v15, a1 + 12);
                            }
                            else
                            {
                              nptr = strstr(s, "Power_version=");
                              if ( nptr )
                              {
                                nptr += 14;
                                memset(v15, 0, sizeof(v15));
                                _isoc99_sscanf(nptr, "%s", v15);
                                a1[15] = (void *)parse_config_ini_array(v15, a1 + 14);
                              }
                              else
                              {
                                nptr = strstr(s, "TempSensor=");
                                if ( nptr )
                                {
                                  nptr += 11;
                                  memset(v15, 0, sizeof(v15));
                                  _isoc99_sscanf(nptr, "%s", v15);
                                  a1[18] = (void *)parse_config_ini_array(v15, a1 + 17);
                                }
                                else
                                {
                                  nptr = strstr(s, "StartTemp=");
                                  if ( nptr )
                                  {
                                    nptr += 10;
                                    _isoc99_sscanf(nptr, "%d", a1 + 19);
                                  }
                                  else
                                  {
                                    nptr = strstr(s, "AlarmTemp=");
                                    if ( nptr )
                                    {
                                      nptr += 10;
                                      _isoc99_sscanf(nptr, "%d", a1 + 20);
                                    }
                                    else
                                    {
                                      nptr = strstr(s, "TempWaitingTime=");
                                      if ( nptr )
                                      {
                                        nptr += 16;
                                        _isoc99_sscanf(nptr, "%d", a1 + 21);
                                      }
                                      else
                                      {
                                        nptr = strstr(s, "StartTestTempGap=");
                                        if ( nptr )
                                        {
                                          nptr += 17;
                                          _isoc99_sscanf(nptr, "%d", a1 + 22);
                                        }
                                        else
                                        {
                                          nptr = strstr(s, "TestMode=");
                                          if ( nptr )
                                          {
                                            nptr += 9;
                                            _isoc99_sscanf(nptr, "%d", a1 + 23);
                                          }
                                          else
                                          {
                                            nptr = strstr(s, "Baudrate=");
                                            if ( nptr )
                                            {
                                              nptr += 9;
                                              _isoc99_sscanf(nptr, "%d", a1 + 24);
                                            }
                                            else
                                            {
                                              nptr = strstr(s, "RepeatCtrl=");
                                              if ( nptr )
                                              {
                                                nptr += 11;
                                                v20 = strlen(nptr) + 1;
                                                a1[29] = malloc(v20);
                                                memset(a1[29], 0, v20);
                                                _isoc99_sscanf(nptr, "%s", a1[29]);
                                              }
                                              else
                                              {
                                                nptr = strstr(s, "Algo=");
                                                if ( nptr )
                                                {
                                                  nptr += 5;
                                                  v19 = strlen(nptr) + 1;
                                                  v3 = *a1;
                                                  *v3 = malloc(v19);
                                                  memset(*(void **)*a1, 0, v19);
                                                  _isoc99_sscanf(nptr, "%s", *(_DWORD *)*a1);
                                                }
                                                else
                                                {
                                                  nptr = strstr(s, "CoreNum=");
                                                  if ( nptr )
                                                  {
                                                    nptr += 8;
                                                    _isoc99_sscanf(nptr, "%d", (char *)*a1 + 12);
                                                  }
                                                  else
                                                  {
                                                    nptr = strstr(s, "PatternNum=");
                                                    if ( nptr )
                                                    {
                                                      nptr += 11;
                                                      _isoc99_sscanf(nptr, "%d", (char *)*a1 + 16);
                                                    }
                                                    else
                                                    {
                                                      nptr = strstr(s, "Timeout=");
                                                      if ( nptr )
                                                      {
                                                        nptr += 8;
                                                        _isoc99_sscanf(nptr, "%d", (char *)*a1 + 20);
                                                      }
                                                      else
                                                      {
                                                        nptr = strstr(s, "least_nonce_per_core=");
                                                        if ( nptr )
                                                        {
                                                          nptr += 21;
                                                          _isoc99_sscanf(nptr, "%d", (char *)*a1 + 64);
                                                        }
                                                        else
                                                        {
                                                          nptr = strstr(s, "invalid_core_num=");
                                                          if ( nptr )
                                                          {
                                                            nptr += 17;
                                                            _isoc99_sscanf(nptr, "%d", (char *)*a1 + 60);
                                                          }
                                                          else
                                                          {
                                                            nptr = strstr(s, "Frequence=");
                                                            if ( nptr )
                                                            {
                                                              nptr += 10;
                                                              memset(v15, 0, sizeof(v15));
                                                              _isoc99_sscanf(nptr, "%s", v15);
                                                              v4 = *a1;
                                                              v4[7] = parse_config_ini_array(v15, (void **)*a1 + 6);
                                                            }
                                                            else
                                                            {
                                                              nptr = strstr(s, "MinValidPatternPecent=");
                                                              if ( nptr )
                                                              {
                                                                nptr += 22;
                                                                memset(v15, 0, sizeof(v15));
                                                                _isoc99_sscanf(nptr, "%s", v15);
                                                                v5 = *a1;
                                                                v5[10] = parse_config_ini_array(v15, (void **)*a1 + 9);
                                                              }
                                                              else
                                                              {
                                                                nptr = strstr(s, "SecondPassPercent=");
                                                                if ( nptr )
                                                                {
                                                                  nptr += 18;
                                                                  v6 = (float *)*a1;
                                                                  atof(nptr);
                                                                  v7 = v1;
                                                                  v6[17] = v7;
                                                                }
                                                                else
                                                                {
                                                                  nptr = strstr(s, "LooseStandardPercent=");
                                                                  if ( nptr )
                                                                  {
                                                                    nptr += 21;
                                                                    v8 = (float *)*a1;
                                                                    atof(nptr);
                                                                    v9 = v1;
                                                                    v8[18] = v9;
                                                                  }
                                                                  else
                                                                  {
                                                                    nptr = strstr(s, "FailStandardPercent=");
                                                                    if ( nptr )
                                                                    {
                                                                      nptr += 20;
                                                                      v10 = (float *)*a1;
                                                                      atof(nptr);
                                                                      v11 = v1;
                                                                      v10[19] = v11;
                                                                    }
                                                                    else
                                                                    {
                                                                      nptr = strstr(s, "MaxHWPecent=");
                                                                      if ( nptr )
                                                                      {
                                                                        nptr += 12;
                                                                        v12 = (double *)*a1;
                                                                        atof(nptr);
                                                                        v12[6] = v1;
                                                                      }
                                                                      else
                                                                      {
                                                                        nptr = strstr(s, "FanSpeed=");
                                                                        if ( nptr )
                                                                        {
                                                                          nptr += 9;
                                                                          a1[25] = (void *)atoi(nptr);
                                                                        }
                                                                        else
                                                                        {
                                                                          nptr = strstr(s, "DelayPowerDown=");
                                                                          if ( nptr )
                                                                          {
                                                                            nptr += 15;
                                                                            a1[26] = (void *)atoi(nptr);
                                                                          }
                                                                          else
                                                                          {
                                                                            nptr = strstr(s, "Clear_EEPROM_Data=");
                                                                            if ( nptr )
                                                                            {
                                                                              nptr += 18;
                                                                              a1[27] = (void *)atoi(nptr);
                                                                            }
                                                                            else
                                                                            {
                                                                              nptr = strstr(s, "isUseEEPROM=");
                                                                              if ( nptr )
                                                                              {
                                                                                nptr += 12;
                                                                                a1[28] = (void *)atoi(nptr);
                                                                              }
                                                                              else
                                                                              {
                                                                                nptr = strstr(s, "IsTest=");
                                                                                if ( nptr )
                                                                                {
                                                                                  nptr += 7;
                                                                                  v16 = 0;
                                                                                  _isoc99_sscanf(nptr, "%d", &v16);
                                                                                  *((_BYTE *)*a1 + 56) = v16 == 1;
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      fclose(stream);
      printf("%s done=========\n ", "read_config_ini");
      if ( *((void **)*a1 + 10) == a1[13] && a1[13] == *((void **)*a1 + 7) )
      {
        return 1;
      }
      else
      {
        printf(
          "%s the level number is not equal: [%d %d %d]\n ",
          "read_config_ini",
          a1[13],
          *((_DWORD *)*a1 + 7),
          *((_DWORD *)*a1 + 10));
        return 0;
      }
    }
    else
    {
      printf("app_conf->coins malloc failed!\n");
      return 0;
    }
  }
  else
  {
    printf("open %s failed\n", filename);
    return 0;
  }
}
// 2D9F4: variable 'v1' is possibly undefined
// 20908: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0002DCB0) --------------------------------------------------------
void __fastcall config_free(int a1)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( a1 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) )
    {
      free(*(void **)(*(_DWORD *)(a1 + 8) + 8));
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = 0;
    }
    if ( *(_DWORD *)a1 )
    {
      for ( i = 0; *(_DWORD *)(a1 + 4) > i; ++i )
      {
        if ( *(_DWORD *)(80 * i + *(_DWORD *)a1) )
        {
          free(*(void **)(80 * i + *(_DWORD *)a1));
          *(_DWORD *)(80 * i + *(_DWORD *)a1) = 0;
        }
        if ( *(_DWORD *)(80 * i + *(_DWORD *)a1 + 24) )
        {
          free(*(void **)(80 * i + *(_DWORD *)a1 + 24));
          *(_DWORD *)(80 * i + *(_DWORD *)a1 + 24) = 0;
        }
      }
      free(*(void **)a1);
      *(_DWORD *)a1 = 0;
    }
    if ( *(_DWORD *)(a1 + 12) )
    {
      free(*(void **)(a1 + 12));
      *(_DWORD *)(a1 + 12) = 0;
    }
    if ( *(_DWORD *)(a1 + 48) )
    {
      free(*(void **)(a1 + 48));
      *(_DWORD *)(a1 + 48) = 0;
    }
    if ( *(_DWORD *)(a1 + 68) )
    {
      free(*(void **)(a1 + 68));
      *(_DWORD *)(a1 + 68) = 0;
    }
  }
}

//----- (0002DDE4) --------------------------------------------------------
int __fastcall get_algo_type(const char *a1, int *a2)
{
  size_t n; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 9; ++i )
  {
    n = strlen(a1);
    if ( n && !strncasecmp(a1, off_1EC5CC[i], n) && !a1[n] )
    {
      *a2 = i;
      return 1;
    }
  }
  return 0;
}
// 1EC5CC: using guessed type char *off_1EC5CC[33];

//----- (0002DE50) --------------------------------------------------------
bool __fastcall proofread_config(_DWORD *a1)
{
  int v4; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  v4 = 0;
  for ( i = 0; a1[1] > i; ++i )
  {
    if ( *(_BYTE *)(80 * i + *a1 + 56) )
    {
      if ( (unsigned __int8)get_algo_type(*(const char **)(80 * i + *a1), (int *)(80 * i + *a1 + 4)) != 1 )
      {
        printf("algo %s type err!\n", *(const char **)(80 * i + *a1));
        return 0;
      }
      a1[2] = *a1 + 80 * i;
      *(_DWORD *)(80 * i + *a1 + 32) = 0;
      ++v4;
    }
  }
  a1[16] = 0;
  return v4 == 1;
}

//----- (0002DF30) --------------------------------------------------------
void *app_config_init()
{
  if ( g_config_info )
    puts("app_config_init already done");
  memset(&unk_1F0C9C, 0, 0x78u);
  if ( (unsigned __int8)read_config_ini((void **)&unk_1F0C9C) != 1 )
  {
    printf("read config err!");
    config_free((int)&unk_1F0C9C);
    return 0;
  }
  else if ( !proofread_config(&unk_1F0C9C) )
  {
    printf("proofread config failed!");
    config_free((int)&unk_1F0C9C);
    return 0;
  }
  else
  {
    g_config_info = (int)&unk_1F0C9C;
    return &unk_1F0C9C;
  }
}
// 1F0C98: using guessed type int g_config_info;

//----- (0002DFE8) --------------------------------------------------------
int __fastcall load_patterns(int a1)
{
  if ( !strcmp(*(const char **)(a1 + 20), "PT1") || (unsigned __int8)get_all_works(a1) == 1 )
    return 1;
  printf("get_all_works failed!");
  return 0;
}

//----- (0002E034) --------------------------------------------------------
int get_app_config_handle()
{
  return g_config_info;
}
// 1F0C98: using guessed type int g_config_info;

//----- (0002E04C) --------------------------------------------------------
void app_config_exit()
{
  int app_config_handle; // r0

  app_config_handle = get_app_config_handle();
  config_free(app_config_handle);
}

//----- (0002E060) --------------------------------------------------------
int __fastcall print_app_config(int a1)
{
  double v1; // r2
  const char *v2; // r3
  int m; // [sp+8h] [bp+8h]
  int k; // [sp+Ch] [bp+Ch]
  int j; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  printf("%d coins:\n\n", *(_DWORD *)(a1 + 4));
  for ( i = 0; *(_DWORD *)(a1 + 4) > i; ++i )
  {
    printf("coin: %s\n", *(const char **)(80 * i + *(_DWORD *)a1));
    printf("pattern_num: %d\n", *(_DWORD *)(80 * i + *(_DWORD *)a1 + 16));
    printf("timeout: %d\n", *(_DWORD *)(80 * i + *(_DWORD *)a1 + 20));
    printf("%s: \n", "freq");
    for ( j = 0; *(_DWORD *)(80 * i + *(_DWORD *)a1 + 28) > j; ++j )
      printf("%d \n", *(_DWORD *)(4 * j + *(_DWORD *)(80 * i + *(_DWORD *)a1 + 24)));
    putchar(10);
    LODWORD(v1) = i;
    HIDWORD(v1) = *(_DWORD *)(80 * i + *(_DWORD *)a1 + 36);
    printf("min_valid_pattern_pecent: %f\n", v1);
    printf("max_hw_pecent: %f\n", *(double *)(80 * i + *(_DWORD *)a1 + 48));
    if ( *(_BYTE *)(80 * i + *(_DWORD *)a1 + 56) )
      v2 = "true";
    else
      v2 = "false";
    printf("is_test: %s\n", v2);
    putchar(10);
  }
  printf("\nwork_path_pre: %s\n", *(const char **)(a1 + 12));
  printf("asic_type: %s\n", *(const char **)(a1 + 16));
  printf("asic_num: %d\n", *(_DWORD *)(a1 + 40));
  printf("open_core_gap: %d\n", *(_DWORD *)(a1 + 44));
  printf("%s: \n", "voltage");
  for ( k = 0; *(_DWORD *)(a1 + 52) > k; ++k )
    printf("%d \n", *(_DWORD *)(4 * k + *(_DWORD *)(a1 + 48)));
  putchar(10);
  printf("%s: \n", "temp_sensor");
  for ( m = 0; *(_DWORD *)(a1 + 72) > m; ++m )
    printf("%d \n", *(_DWORD *)(4 * m + *(_DWORD *)(a1 + 68)));
  putchar(10);
  printf("start_temp: %d\n", *(_DWORD *)(a1 + 76));
  printf("alarm_temp: %d\n", *(_DWORD *)(a1 + 80));
  printf("temp_waitting_time: %d\n", *(_DWORD *)(a1 + 84));
  printf("test_mode: %d\n", *(_DWORD *)(a1 + 92));
  printf("baud_rate: %d\n", *(_DWORD *)(a1 + 96));
  return printf("repeat_ctrl: %s\n", *(const char **)(a1 + 116));
}

//----- (0002E338) --------------------------------------------------------
int __fastcall sub_2E338(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 2E37C: variable 'v3' is possibly undefined

//----- (0002E418) --------------------------------------------------------
int __fastcall sub_2E418(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/pcba/../util.h",
    64,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0002E51C) --------------------------------------------------------
int pcba_is_vbk_asic_valid()
{
  return 1;
}

//----- (0002E534) --------------------------------------------------------
int __fastcall pcba_calc_vbk_core_num(_DWORD *a1)
{
  if ( fpga_type[*a1] == 1 )
    return 5;
  else
    return 4;
}
// 47BFAC: using guessed type _DWORD fpga_type[4];

//----- (0002E568) --------------------------------------------------------
int __fastcall pcba_vbk_recv(int a1)
{
  unsigned int v4; // [sp+14h] [bp+Ch]
  _DWORD s[15]; // [sp+18h] [bp+10h] BYREF
  int v6; // [sp+54h] [bp+4Ch]
  int v7; // [sp+58h] [bp+50h]
  unsigned __int8 v8; // [sp+5Fh] [bp+57h]

  memset(s, 0, 0x38u);
  if ( (*(unsigned __int8 (__fastcall **)(int, _DWORD *))(a1 + 36))(a1, s) != 1 )
    return 0;
  v8 = s[6] & 7;
  v7 = *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12);
  v6 = 104
     * (s[4]
      + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) * v7 * s[2]
      + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) * (s[6] & 7))
     + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 8);
  v4 = _byteswap_ulong(*(_DWORD *)(v6 + 84));
  if ( s[6] == v4 )
  {
    printf("can't match: chip%d, coreid%d, nonce_value:%8x, resp.nonce_value=%08x\n", s[2], v8, v4, s[6]);
    ++*(_DWORD *)(v6 + 100);
    return 1;
  }
  else
  {
    printf("can't match: chip%d, coreid%d, nonce_value:%8x, resp.nonce_value=%08x\n", s[2], v8, v4, s[6]);
    return 0;
  }
}
// 1F0C98: using guessed type int g_config_info;

//----- (0002E684) --------------------------------------------------------
int __fastcall pcba_vbk_send(int a1, int *a2)
{
  _QWORD s[15]; // [sp+8h] [bp+8h] BYREF
  int *v5; // [sp+84h] [bp+84h]

  v5 = a2;
  memset(s, 0, sizeof(s));
  s[1] = *v5;
  memset(&s[11], 255, 0x18u);
  memcpy(&s[2], v5 + 1, v5[22]);
  return (*(int (__fastcall **)(int, _QWORD *))(a1 + 24))(a1, s);
}

//----- (0002E6F0) --------------------------------------------------------
int pcba_statistic_vbk_pattern_test_results()
{
  int i; // [sp+Ch] [bp+4h] BYREF
  double v2; // [sp+10h] [bp+8h]
  int v3; // [sp+1Ch] [bp+14h]
  int v4; // [sp+20h] [bp+18h]
  int v5; // [sp+24h] [bp+1Ch]
  int v6; // [sp+28h] [bp+20h]
  int v7; // [sp+2Ch] [bp+24h]
  int k; // [sp+30h] [bp+28h]
  int j; // [sp+34h] [bp+2Ch]

  i = 0;
  j = 0;
  k = 0;
  v5 = *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 8);
  v7 = 0;
  v6 = 0;
  for ( i = 0; *(_DWORD *)(g_config_info + 40) > i; ++i )
  {
    v4 = pcba_calc_vbk_core_num(&i);
    for ( j = 0; j < v4; ++j )
    {
      for ( k = 0; *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) > k; ++k )
      {
        ++v6;
        v3 = 104
           * (k
            + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) * v4 * i
            + j * *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16))
           + v5;
        if ( *(_DWORD *)(v3 + 100) )
          ++v7;
      }
    }
  }
  v2 = (double)v7 / (double)v6;
  v2 = v2 * 100.0;
  if ( *(double *)*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 36) <= v2 )
    return printf("Pattern Test Success %0.4f match nocnes %d total nonces %d\n", v2, v7, v6);
  else
    return printf("Pattern Test Failed %0.4f match nocnes %d total nonces %d\n", v2, v7, v6);
}
// 2E6F0: using guessed type int pcba_statistic_vbk_pattern_test_results();
// 1F0C98: using guessed type int g_config_info;

//----- (0002E868) --------------------------------------------------------
json_t_0 *__cdecl json_incref(json_t_0 *json)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2

  if ( json && *((_DWORD *)json + 1) != -1 )
  {
    v1 = (unsigned int *)((char *)json + 4);
    do
      v2 = __ldrex(v1);
    while ( __strex(v2 + 1, v1) );
    __dmb(0xBu);
  }
  return json;
}

//----- (0002E8A8) --------------------------------------------------------
void __fastcall sub_2E8A8(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (0002E8EC) --------------------------------------------------------
int __cdecl json_object_set(json_t_0 *object, const char *key, json_t_0 *value)
{
  json_t *v3; // r0

  v3 = json_incref(value);
  return json_object_set_new(object, key, v3);
}

//----- (0002E914) --------------------------------------------------------
int __cdecl json_array_append(json_t_0 *array, json_t_0 *value)
{
  json_t *v2; // r0

  v2 = json_incref(value);
  return json_array_append_new(array, v2);
}

//----- (0002E938) --------------------------------------------------------
int __fastcall substr(const char *a1, int a2, unsigned int a3, int a4)
{
  unsigned int i; // [sp+14h] [bp+14h]

  if ( a2 + a3 <= strlen(a1) )
  {
    for ( i = 0; i < a3; ++i )
      *(_BYTE *)(i + a4) = a1[i + a2];
    *(_BYTE *)(i + a4) = 0;
    return 1;
  }
  else
  {
    puts("You want copy to many chars");
    return 0;
  }
}

//----- (0002E9B0) --------------------------------------------------------
int __fastcall set_socket_feature(int a1)
{
  _DWORD optval[2]; // [sp+10h] [bp+8h] BYREF
  int v5; // [sp+18h] [bp+10h] BYREF
  int v6; // [sp+1Ch] [bp+14h] BYREF
  int v7; // [sp+20h] [bp+18h] BYREF
  int v8; // [sp+24h] [bp+1Ch]

  v7 = 1;
  v6 = 45;
  v5 = 30;
  v8 = 0;
  optval[0] = 3;
  optval[1] = 0;
  v8 = setsockopt(a1, 1, 21, optval, 8u);
  if ( v8 >= 0 )
  {
    v8 = setsockopt(a1, 1, 20, optval, 8u);
    if ( v8 >= 0 )
    {
      v8 = setsockopt(a1, 1, 9, &v7, 4u);
      if ( v8 >= 0 )
      {
        v8 = setsockopt(a1, 6, 1, &v7, 4u);
        if ( v8 >= 0 )
        {
          v8 = setsockopt(a1, 6, 6, &v7, 4u);
          if ( v8 >= 0 )
          {
            v8 = setsockopt(a1, 6, 4, &v6, 4u);
            if ( v8 >= 0 )
            {
              v8 = setsockopt(a1, 6, 5, &v5, 4u);
              if ( v8 >= 0 )
              {
                return 1;
              }
              else
              {
                printf("Set socket keep intvl fail, ret = %d\n", v8);
                return 0;
              }
            }
            else
            {
              printf("Set socket keep idle fail, ret = %d\n", v8);
              return 0;
            }
          }
          else
          {
            printf("Set socket keep cnt fail, ret = %d\n", v8);
            return 0;
          }
        }
        else
        {
          printf("Set socket no delay fail, ret = %d\n", v8);
          return 0;
        }
      }
      else
      {
        printf("Set socket keep alive fail, ret = %d\n", v8);
        return 0;
      }
    }
    else
    {
      printf("Set socket send timeout fail, ret = %d\n", v8);
      return 0;
    }
  }
  else
  {
    printf("Set socket send timeout fail, ret = %d\n\n", v8);
    return 0;
  }
}

//----- (0002EB1C) --------------------------------------------------------
int32_t __cdecl get_local_ip(char *ifname, char *ip)
{
  size_t v2; // r0
  size_t v4; // r0
  _BYTE s[20]; // [sp+8h] [bp+8h] BYREF
  struct in_addr v9; // [sp+1Ch] [bp+1Ch]
  int fd; // [sp+28h] [bp+28h]
  char *v11; // [sp+2Ch] [bp+2Ch]

  v11 = 0;
  fd = socket(2, 2, 0);
  memset(s, 0, 0x10u);
  v2 = strlen(ifname);
  memcpy(s, ifname, v2);
  if ( ioctl(fd, 0x8915u, s) )
    return -1;
  v11 = inet_ntoa(v9);
  v4 = strlen(v11);
  memcpy(ip, v11, v4);
  close(fd);
  return 0;
}

//----- (0002EBA4) --------------------------------------------------------
bool create_connection_to_MES_system_by_ip()
{
  struct sockaddr addr; // [sp+4h] [bp+4h] BYREF
  int v3; // [sp+14h] [bp+14h]

  v3 = 30;
  bitmain_MES_system_clientSocket = socket(2, 1, 0);
  if ( bitmain_MES_system_clientSocket >= 0 )
  {
    puts("Creat socket success");
    addr.sa_family = 2;
    *(_WORD *)addr.sa_data = htons(0x1F9Au);
    *(_DWORD *)&addr.sa_data[2] = inet_addr("39.107.255.133");
    while ( v3 > 0 )
    {
      if ( !connect(bitmain_MES_system_clientSocket, &addr, 0x10u) )
      {
        puts("Creat socket connection to MES system succeed");
        return (unsigned __int8)set_socket_feature(bitmain_MES_system_clientSocket) == 1;
      }
      sleep(1u);
      printf("timeout_counter = %d\n", --v3);
    }
    puts("Creat socket connection to MES system fail");
    return 0;
  }
  else
  {
    puts("Creat socket fail");
    return 0;
  }
}
// 1EC650: using guessed type int bitmain_MES_system_clientSocket;

//----- (0002EC90) --------------------------------------------------------
int __fastcall create_connection_to_MES_system_by_name(int a1)
{
  char *v2; // r4
  char *v3; // r0
  size_t v4; // r0
  char s[32]; // [sp+8h] [bp+8h] BYREF
  struct sockaddr addr; // [sp+28h] [bp+28h] BYREF
  unsigned __int8 i; // [sp+3Bh] [bp+3Bh]
  int v10; // [sp+3Ch] [bp+3Ch]
  int v11; // [sp+40h] [bp+40h]
  int v12; // [sp+44h] [bp+44h]
  int v13; // [sp+48h] [bp+48h]
  struct hostent *v14; // [sp+4Ch] [bp+4Ch]

  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  i = 0;
  memset(s, 0, sizeof(s));
  if ( a1 == 1 )
  {
    v13 = 1000000;
    v12 = 1000000;
    v11 = 1000000;
    v10 = 1000000;
  }
  else
  {
    if ( a1 != 2 )
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "don't figer out");
      lcd_show(2u, "which process to");
      lcd_show(3u, "connect MES");
      puts("don't figer out which process to connect MES");
      return 0;
    }
    v13 = 60;
    v12 = 3;
    v11 = 3;
    v10 = 3;
  }
  if ( bitmain_MES_system_clientSocket != -1 )
  {
    close(bitmain_MES_system_clientSocket);
    bitmain_MES_system_clientSocket = -1;
    puts("close socket");
  }
  for ( i = 0; i < v13; ++i )
  {
    sleep(1u);
    if ( !get_local_ip("eth0", s) )
    {
      printf("%s: %s\n", "eth0", s);
      break;
    }
    if ( i >= v13 - 1 )
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "can't get");
      lcd_show(2u, "local ip");
      printf("Can't get %s ip\n", "eth0");
      return 0;
    }
  }
  for ( i = 0; i < v12; ++i )
  {
    v14 = gethostbyname("mtcs.bitmain.vip");
    if ( v14 )
      break;
    printf("try get MES system ip: %d\n", i);
    sleep(3u);
    if ( i >= v12 - 1 )
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "can't get");
      lcd_show(2u, "MES system ip");
      puts("Can't get MES system by host name");
      return 0;
    }
  }
  memset(s, 0, sizeof(s));
  for ( i = 0; v14->h_addr_list[i]; ++i )
  {
    v2 = inet_ntoa(*(struct in_addr *)v14->h_addr_list[i]);
    v3 = inet_ntoa(*(struct in_addr *)v14->h_addr_list[i]);
    v4 = strlen(v3);
    memcpy(s, v2, v4);
  }
  for ( i = 0; i < v11; ++i )
  {
    bitmain_MES_system_clientSocket = socket(v14->h_addrtype, 1, 0);
    if ( bitmain_MES_system_clientSocket >= 0 )
    {
      puts("Creat socket success");
      break;
    }
    puts("Creat socket fail");
    if ( i >= v11 - 1 )
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "can't connect");
      lcd_show(2u, "MES system");
      puts("Creat socket timeout");
      return 0;
    }
  }
  addr.sa_family = v14->h_addrtype;
  *(_WORD *)addr.sa_data = htons(0x1F9Au);
  *(_DWORD *)&addr.sa_data[2] = inet_addr(s);
  while ( 1 )
  {
    if ( v10 <= 0 )
    {
      puts("Creat socket connection to MES system fail");
      return 0;
    }
    if ( !connect(bitmain_MES_system_clientSocket, &addr, 0x10u) )
      break;
    sleep(1u);
    printf("timeout_counter = %d\n", --v10);
  }
  puts("Creat socket connection to MES system succeed");
  if ( (unsigned __int8)set_socket_feature(bitmain_MES_system_clientSocket) == 1 )
    return 1;
  lcd_clear_result();
  lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
  lcd_show(1u, "set socket");
  lcd_show(2u, "feature");
  lcd_show(3u, "fail");
  puts("Creat socket timeout");
  return 0;
}
// 1EC650: using guessed type int bitmain_MES_system_clientSocket;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0002F100) --------------------------------------------------------
int __fastcall prepare_MES_system_handshake_information(int a1)
{
  json_t *v1; // r0
  json_t *v2; // r0
  json_t *v3; // r0
  json_t *v4; // r0
  json_t *v5; // r0
  json_t *v6; // r0
  json_t *v7; // r0
  json_t *v8; // r5
  unsigned __int8 chip_bin; // r0
  json_t *v10; // r0
  json_t *v11; // r0
  json_t *v12; // r0
  json_t *v13; // r0
  char v16[12]; // [sp+Ch] [bp+Ch] BYREF
  _BYTE v17[252]; // [sp+18h] [bp+18h] BYREF
  const json_t *v18; // [sp+114h] [bp+114h]
  char *s; // [sp+118h] [bp+118h]
  json_t *v20; // [sp+11Ch] [bp+11Ch]
  json_t *v21; // [sp+120h] [bp+120h]
  const json_t *v22; // [sp+124h] [bp+124h]
  unsigned __int8 v23; // [sp+12Bh] [bp+12Bh]
  const json_t *file; // [sp+12Ch] [bp+12Ch]

  file = 0;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v18 = 0;
  memset(v16, 0, 10);
  s = 0;
  v23 = 0;
  memset((void *)" ", 0, 0xC8u);
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      file = (const json_t *)json_load_file(
                               "/mnt/card/MES_system_get_particular_config_template.ini",
                               0,
                               (json_error_t *)v17);
      if ( file && !*(_DWORD *)file )
      {
        s = json_dumps(file, 0);
        printf("content: %s\n", s);
        v22 = json_object_get(file, "params");
        if ( v22 && !*(_DWORD *)v22 )
        {
          v20 = json_object_get(v22, "config_ids");
          if ( v20 && *(_DWORD *)v20 == 1 )
          {
            v18 = (const json_t *)json_array_get(v20, 0);
            if ( v18 && !*(_DWORD *)v18 )
            {
              v3 = json_object_get(v18, "miner_type");
              json_string_set((int)v3, (const char *)(MES2Local_Config_Information + 16));
              v4 = json_object_get(v18, "board_name");
              json_string_set((int)v4, (const char *)(MES2Local_Config_Information + 32));
              v5 = json_object_get(v18, "sn");
              json_string_set((int)v5, ::s);
              memset(v16, 48, 0xAu);
              substr(byte_47BF64, 5, 2u, (int)v16);
              v6 = json_object_get(v18, "chip_technology");
              json_string_set((int)v6, v16);
              v7 = json_object_get(v18, "ft_version");
              json_string_set((int)v7, src);
              v8 = json_object_get(v18, "bin");
              chip_bin = get_chip_bin((int)qr_code);
              json_integer_set((int)v8, chip_bin);
              memset(v16, 48, 0xAu);
              substr(byte_47BF64, 0, 3u, (int)v16);
              v10 = json_object_get(v18, "hardware_version");
              json_string_set((int)v10, v16);
              memset(v16, 48, 0xAu);
              substr(byte_47BF64, 3, 2u, (int)v16);
              v11 = json_object_get(v18, "bom_version");
              json_string_set((int)v11, v16);
              s = json_dumps(file, 0);
              mes_system_handshake_file_length = strlen(s);
              memcpy((void *)" ", s, mes_system_handshake_file_length);
              printf("size: %d, content: %s\n", mes_system_handshake_file_length, " ");
              v23 = 1;
            }
            else
            {
              printf(
                "Can't read out array_table in config_ids in %s\n",
                "/mnt/card/MES_system_get_particular_config_template.ini");
              v23 = 0;
            }
          }
          else
          {
            printf("Can't read out config_ids in %s\n", "/mnt/card/MES_system_get_particular_config_template.ini");
            v23 = 0;
          }
        }
        else
        {
          printf("Can't read out params in %s\n", "/mnt/card/MES_system_get_particular_config_template.ini");
          v23 = 0;
        }
      }
      else
      {
        printf("Can't read out %s file.\n", "/mnt/card/MES_system_get_particular_config_template.ini");
        v23 = 0;
      }
    }
    else if ( a1 == 2 )
    {
      file = (const json_t *)json_load_file("/mnt/card/MES_system_get_version_template.ini", 0, (json_error_t *)v17);
      if ( file && !*(_DWORD *)file )
      {
        s = json_dumps(file, 0);
        printf("content: %s\n", s);
        v22 = json_object_get(file, "params");
        if ( v22 && !*(_DWORD *)v22 )
        {
          v20 = json_object_get(v22, "config_ids");
          if ( v20 && *(_DWORD *)v20 == 1 )
          {
            v18 = (const json_t *)json_array_get(v20, 0);
            if ( v18 && !*(_DWORD *)v18 )
            {
              v12 = json_object_get(v18, "miner_type");
              json_string_set((int)v12, (const char *)(MES2Local_Config_Information + 16));
              v13 = json_object_get(v18, "board_name");
              json_string_set((int)v13, (const char *)(MES2Local_Config_Information + 32));
              s = json_dumps(file, 0);
              mes_system_handshake_file_length = strlen(s);
              memcpy((void *)" ", s, mes_system_handshake_file_length);
              printf("size: %d, content: %s\n", mes_system_handshake_file_length, " ");
              v23 = 1;
            }
            else
            {
              printf("Can't read out array_table in configIds in %s\n", "/mnt/card/MES_system_get_version_template.ini");
              v23 = 0;
            }
          }
          else
          {
            printf("Can't read out configIds in %s\n", "/mnt/card/MES_system_get_version_template.ini");
            v23 = 0;
          }
        }
        else
        {
          printf("Can't read out params in %s\n", "/mnt/card/MES_system_get_version_template.ini");
          v23 = 0;
        }
      }
      else
      {
        printf("Can't read out %s file.\n", "/mnt/card/MES_system_get_version_template.ini");
        v23 = 0;
      }
    }
    else
    {
      printf("Do not support get information type %d from MES system\n", a1);
      v23 = 0;
    }
  }
  else
  {
    file = (const json_t *)json_load_file("/mnt/card/MES_system_get_all_config_template.ini", 0, (json_error_t *)v17);
    if ( file && !*(_DWORD *)file )
    {
      s = json_dumps(file, 0);
      v22 = json_object_get(file, "params");
      if ( v22 && !*(_DWORD *)v22 )
      {
        v21 = json_object_get(v22, "software_commit_id");
        if ( v21 && *(_DWORD *)v21 == 2 )
        {
          json_string_set((int)v21, "d39c5dcea203932a2bf416a5fc01c34eaa1f13d7");
          v20 = json_object_get(v22, "config_ids");
          if ( v20 && *(_DWORD *)v20 == 1 )
          {
            v18 = (const json_t *)json_array_get(v20, 0);
            if ( v18 && !*(_DWORD *)v18 )
            {
              v1 = json_object_get(v18, "miner_type");
              json_string_set((int)v1, (const char *)(MES2Local_Config_Information + 16));
              v2 = json_object_get(v18, "board_name");
              json_string_set((int)v2, (const char *)(MES2Local_Config_Information + 32));
              s = json_dumps(file, 0);
              mes_system_handshake_file_length = strlen(s);
              memcpy((void *)" ", s, mes_system_handshake_file_length);
              v23 = 1;
            }
            else
            {
              printf(
                "Can't read out array_table in config_ids in %s\n",
                "/mnt/card/MES_system_get_all_config_template.ini");
              v23 = 0;
            }
          }
          else
          {
            printf("Can't read out config_ids in %s\n", "/mnt/card/MES_system_get_all_config_template.ini");
            v23 = 0;
          }
        }
        else
        {
          printf("Can't read out software_commit_id in %s\n", "/mnt/card/MES_system_get_all_config_template.ini");
          v23 = 0;
        }
      }
      else
      {
        printf("Can't read out params in %s\n", "/mnt/card/MES_system_get_all_config_template.ini");
        v23 = 0;
      }
    }
    else
    {
      printf("Can't read out %s file.\n", "/mnt/card/MES_system_get_all_config_template.ini");
      v23 = 0;
    }
  }
  if ( file )
    sub_2E8A8((int)file);
  if ( v23 != 1 )
    puts("prepare MES system handshake information fail");
  return v23;
}
// 1F0D14: using guessed type int mes_system_handshake_file_length;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0002F8A0) --------------------------------------------------------
int __fastcall send_message_to_bitmain_MES_system(const void *a1, size_t a2)
{
  ssize_t v5; // [sp+10h] [bp+10h]
  unsigned __int8 v6; // [sp+16h] [bp+16h]
  char v7; // [sp+17h] [bp+17h]

  v7 = 5;
  v6 = 0;
  putchar(32);
  while ( v7 )
  {
    v5 = send(bitmain_MES_system_clientSocket, a1, a2, 0);
    if ( v5 )
    {
      if ( v5 >= 0 )
      {
        v6 = 1;
        puts("done");
        break;
      }
      printf("Socket return back: %d\n", v5);
    }
    else
    {
      puts("Timeout. MES close socket");
    }
    ++v7;
  }
  if ( v6 != 1 )
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "send message to");
    lcd_show(2u, "MES system");
    lcd_show(3u, "fail");
    puts("send message to MES system fail");
  }
  return v6;
}
// 1EC650: using guessed type int bitmain_MES_system_clientSocket;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0002F98C) --------------------------------------------------------
char *__fastcall receive_message_from_bitmain_MES_system(unsigned int *a1)
{
  _BYTE v4[10240]; // [sp+Ch] [bp+Ch] BYREF
  ssize_t v5; // [sp+280Ch] [bp+280Ch]
  char *v6; // [sp+2810h] [bp+2810h]
  unsigned int v7; // [sp+2814h] [bp+2814h]
  unsigned int i; // [sp+2818h] [bp+2818h]
  unsigned int v9; // [sp+281Ch] [bp+281Ch]

  v9 = 0;
  i = 0;
  v7 = 0;
  v5 = 0;
  memset(v4, 0, sizeof(v4));
  v6 = 0;
  do
  {
    memset(v4, 0, sizeof(v4));
    v5 = recv(bitmain_MES_system_clientSocket, v4, 0x2800u, 0);
    if ( v5 )
    {
      if ( v5 < 0 )
      {
        printf("Receive message fail: %d\n", v5);
        return 0;
      }
      if ( v6 )
      {
        v6 = (char *)realloc(v6, v9 + v5);
        if ( !v6 )
        {
          lcd_clear_result();
          lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
          lcd_show(1u, "realloc for");
          lcd_show(2u, "MES config");
          lcd_show(3u, "infor fail");
          puts("realloc for MES config infor fail");
          return 0;
        }
        memcpy(&v6[v9], v4, v5);
        v9 += v5;
      }
      else
      {
        v6 = (char *)malloc(v5);
        if ( !v6 )
        {
          lcd_clear_result();
          lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
          lcd_show(1u, "malloc for");
          lcd_show(2u, "MES config");
          lcd_show(3u, "infor fail");
          puts("malloc for MES config infor fail");
          return 0;
        }
        memcpy(v6, v4, v5);
        v9 = v5;
      }
      v7 = 0;
    }
    else
    {
      ++v7;
      sleep(1u);
    }
    if ( v6[v9 - 1] == 10 )
    {
      *a1 = v9;
      puts("Receive all message from MES system");
      return v6;
    }
  }
  while ( v7 <= 6 );
  printf("Only receive %d bytes message during last 6 seconds\n", v9);
  for ( i = 0; i < v9; ++i )
    printf("%c\n", (unsigned __int8)v6[i]);
  putchar(10);
  lcd_clear_result();
  lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
  lcd_show(1u, "Not receive all");
  lcd_show(2u, "MES config");
  lcd_show(3u, "information");
  puts("Not receive all MES config information");
  return 0;
}
// 1EC650: using guessed type int bitmain_MES_system_clientSocket;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0002FD58) --------------------------------------------------------
int download_MES_system_Config_file()
{
  _BYTE v2[252]; // [sp+4h] [bp+4h] BYREF
  int v3; // [sp+100h] [bp+100h]
  char v4; // [sp+107h] [bp+107h]

  v4 = 0;
  v3 = 0;
  putchar(32);
  if ( (unsigned __int8)create_connection_to_MES_system_by_name(1) != 1 )
    return 0;
  if ( (unsigned __int8)send_message_to_bitmain_MES_system(" ", mes_system_handshake_file_length) != 1 )
    return 0;
  mes_system_config_file_length = 0;
  if ( MES_system_Config_information )
  {
    free((void *)MES_system_Config_information);
    MES_system_Config_information = 0;
  }
  MES_system_Config_information = (int)receive_message_from_bitmain_MES_system((unsigned int *)&mes_system_config_file_length);
  if ( !MES_system_Config_information )
    return 0;
  puts("Get MES system Config information, and do integrity verification");
  MES_system_config_File = (int)json_loadb(
                                  MES_system_Config_information,
                                  mes_system_config_file_length - 1,
                                  0,
                                  (json_error_t *)v2);
  if ( MES_system_config_File && !*(_DWORD *)MES_system_config_File )
  {
    puts("The received MES system Config information is in JSON format");
    return 1;
  }
  else
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "MES config");
    lcd_show(2u, "information");
    lcd_show(3u, "is not in JSON");
    puts("The received MES system Config information is not in JSON format");
    return 0;
  }
}
// 1F0D14: using guessed type int mes_system_handshake_file_length;
// 1F0D18: using guessed type int MES_system_Config_information;
// 1F0D1C: using guessed type int mes_system_config_file_length;
// 1F0D20: using guessed type int MES_system_config_File;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0002FECC) --------------------------------------------------------
int check_whether_MES_system_response_is_correct()
{
  const char *v0; // r0
  const char *v1; // r0
  const char *v2; // r0
  json_t *v4; // [sp+0h] [bp+0h]
  json_t *v5; // [sp+4h] [bp+4h]
  json_t *v6; // [sp+8h] [bp+8h]
  unsigned __int8 v7; // [sp+Fh] [bp+Fh]

  v6 = json_object_get((const json_t *)MES_system_config_File, "result");
  if ( v6 && !*(_DWORD *)v6 )
  {
    v5 = json_object_get(v6, "code");
    if ( v5 && *(_DWORD *)v5 == 2 )
    {
      v0 = json_string_value(v5);
      if ( !strcmp(v0, "000000") )
      {
        puts("Get MES system config information success");
        v7 = 1;
      }
      else
      {
        v1 = json_string_value(v5);
        printf("Get MES system config information fail. code: %s\n", v1);
        v4 = json_object_get(v6, "msg");
        if ( v4 && *(_DWORD *)v4 == 2 )
        {
          lcd_clear_result();
          lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
          lcd_show(1u, "MES system");
          lcd_show(2u, "return error");
          lcd_show(3u, "response");
          v2 = json_string_value(v4);
          printf("Get MES system config information fail. msg: %s\n", v2);
          v7 = 0;
        }
        else
        {
          lcd_clear_result();
          lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
          lcd_show(1u, "Don't find");
          lcd_show(2u, "msg in MES");
          lcd_show(3u, "system response");
          puts("Don't get msg in result");
          v7 = 0;
        }
      }
    }
    else
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "Don't find");
      lcd_show(2u, "code in MES");
      lcd_show(3u, "system response");
      puts("Don't get code in result");
      v7 = 0;
    }
  }
  else
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "Don't find");
    lcd_show(2u, "result in MES");
    lcd_show(3u, "system response");
    puts("Don't find result in MES system responce");
    v7 = 0;
  }
  if ( v6 )
    sub_2E8A8((int)v6);
  return v7;
}
// 1F0D20: using guessed type int MES_system_config_File;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (000300F8) --------------------------------------------------------
int __fastcall save_MES_system_config_information(int a1)
{
  FILE *s; // [sp+Ch] [bp+Ch]

  if ( a1 )
  {
    if ( a1 != 1 )
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "Don't support");
      lcd_show(2u, "this type config");
      lcd_show(3u, "information");
      printf("Don't support save this type information. type = %d\n", a1);
      return 0;
    }
    memset(factory_config_file, 0, 0xC8u);
    strcpy(factory_config_file, base_factory_config_file);
    strcat(factory_config_file, (const char *)(MES2Local_Config_Information + 16));
    *(_WORD *)&factory_config_file[strlen(factory_config_file)] = 45;
    strcat(factory_config_file, (const char *)(MES2Local_Config_Information + 32));
    *(_WORD *)&factory_config_file[strlen(factory_config_file)] = 45;
    strcat(factory_config_file, src);
    *(_WORD *)&factory_config_file[strlen(factory_config_file)] = 45;
    strcat(factory_config_file, byte_47BF34);
    *(_WORD *)&factory_config_file[strlen(factory_config_file)] = 45;
    strcat(factory_config_file, byte_47BF64);
  }
  else
  {
    memset(factory_config_file, 0, 0xC8u);
    strcpy(factory_config_file, base_factory_config_file);
    strcat(factory_config_file, (const char *)(MES2Local_Config_Information + 16));
    *(_WORD *)&factory_config_file[strlen(factory_config_file)] = 45;
    strcat(factory_config_file, (const char *)(MES2Local_Config_Information + 32));
  }
  printf("Save MES system config information into %s\n", factory_config_file);
  s = fopen(factory_config_file, "w");
  if ( s )
  {
    printf("Open %s success\n", factory_config_file);
    if ( fwrite((const void *)MES_system_Config_information, mes_system_config_file_length, 1u, s) == 1 )
    {
      printf("Write %s success\n", factory_config_file);
      fclose(s);
      return 1;
    }
    else
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "write MES system");
      lcd_show(2u, "config infor");
      lcd_show(3u, "fail");
      printf("Write %s fail\n", factory_config_file);
      fclose(s);
      return 0;
    }
  }
  else
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "open file to");
    lcd_show(2u, "save MES system");
    lcd_show(3u, "config info fail");
    printf("Open %s fail\n", factory_config_file);
    return 0;
  }
}
// 1F0D18: using guessed type int MES_system_Config_information;
// 1F0D1C: using guessed type int mes_system_config_file_length;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (00030454) --------------------------------------------------------
int init_MES_system_config_information()
{
  if ( Mes_System_Config_File_Information )
  {
    puts("Already malloced parse MES system config information!");
    return 1;
  }
  else
  {
    Mes_System_Config_File_Information = (int)malloc(0x68u);
    if ( Mes_System_Config_File_Information )
    {
      *(_DWORD *)(Mes_System_Config_File_Information + 100) = 0;
      return 1;
    }
    else
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "malloc for parse");
      lcd_show(2u, "MES system");
      lcd_show(3u, "information fail");
      puts("malloc for parse MES system config information fail!");
      return 0;
    }
  }
}
// 1F0D28: using guessed type int Mes_System_Config_File_Information;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (00030500) --------------------------------------------------------
int __fastcall parse_MES_system_config_information(int a1)
{
  if ( !a1 )
    return parse_all_MES_system_config_information();
  if ( a1 != 1 )
    printf("Don't support parse this type config information. type = %d\n", a1);
  return 0;
}

//----- (00030538) --------------------------------------------------------
int parse_all_MES_system_config_information()
{
  char *v0; // r4
  const char *v1; // r0
  char *v2; // r4
  const char *v3; // r0
  char *v4; // r4
  const char *v5; // r0
  char *v6; // r4
  const char *v7; // r0
  json_t *v8; // r0
  int v9; // r0
  char *v10; // r4
  json_t *v11; // r0
  const char *v12; // r0
  char *v13; // r4
  json_t *v14; // r0
  const char *v15; // r0
  json_t *v16; // r0
  int v17; // r0
  json_t *v18; // r0
  int v19; // r0
  json_t *v20; // r0
  int v21; // r0
  int v22; // r0
  json_t *v23; // r0
  int v24; // r0
  json_t *v25; // r0
  int v26; // r0
  json_t *v27; // r0
  int v28; // r0
  json_t *v29; // r0
  int v30; // r0
  json_t *v31; // r0
  int v32; // r0
  json_t *v33; // r0
  int v34; // r0
  json_t *v35; // r0
  int v36; // r0
  json_t *v37; // r0
  int v38; // r0
  json_t *v39; // r0
  int v40; // r0
  json_t *v41; // r0
  int v42; // r0
  json_t *v43; // r0
  int v44; // r0
  json_t *v45; // r0
  int v46; // r0
  json_t *v47; // r0
  int v48; // r0
  json_t *v49; // r0
  int v50; // r0
  json_t *v51; // r0
  int v52; // r0
  json_t *v53; // r0
  int v54; // r0
  json_t *v55; // r0
  int v56; // r0
  json_t *v57; // r0
  int v58; // r0
  char *v59; // r4
  json_t *v60; // r0
  const char *v61; // r0
  json_t *v62; // r0
  int v63; // r0
  json_t *v64; // r0
  int v65; // r0
  json_t *v66; // r0
  int v67; // r0
  char *v68; // r4
  json_t *v69; // r0
  const char *v70; // r0
  char *v71; // r4
  json_t *v72; // r0
  const char *v73; // r0
  char *v74; // r4
  json_t *v75; // r0
  const char *v76; // r0
  char *v77; // r4
  json_t *v78; // r0
  const char *v79; // r0
  json_t *v80; // r0
  int v81; // r0
  char *v82; // r4
  json_t *v83; // r0
  const char *v84; // r0
  json_t *v85; // r0
  int v86; // r0
  json_t *v87; // r0
  int v88; // r0
  json_t *v89; // r0
  int v90; // r0
  json_t *v91; // r0
  int v92; // r0
  json_t *v93; // r0
  int v94; // r0
  json_t *v95; // r0
  int v96; // r0
  int v97; // r0
  _BYTE v99[256]; // [sp+Ch] [bp+4h] BYREF
  size_t v100; // [sp+10Ch] [bp+104h]
  _DWORD *v101; // [sp+110h] [bp+108h]
  const json_t *v102; // [sp+114h] [bp+10Ch]
  const json_t *v103; // [sp+118h] [bp+110h]
  const json_t *v104; // [sp+11Ch] [bp+114h]
  const json_t *v105; // [sp+120h] [bp+118h]
  const json_t *v106; // [sp+124h] [bp+11Ch]
  const json_t *v107; // [sp+128h] [bp+120h]
  _DWORD *v108; // [sp+12Ch] [bp+124h]
  const json_t *v109; // [sp+130h] [bp+128h]
  const json_t *v110; // [sp+134h] [bp+12Ch]
  char *v111; // [sp+138h] [bp+130h]
  char *v112; // [sp+13Ch] [bp+134h]
  _DWORD *v113; // [sp+140h] [bp+138h]
  _DWORD *v114; // [sp+144h] [bp+13Ch]
  _DWORD *v115; // [sp+148h] [bp+140h]
  _DWORD *v116; // [sp+14Ch] [bp+144h]
  _DWORD *v117; // [sp+150h] [bp+148h]
  char *v118; // [sp+154h] [bp+14Ch]
  json_t *v119; // [sp+158h] [bp+150h]
  json_t *v120; // [sp+15Ch] [bp+154h]
  json_t *v121; // [sp+160h] [bp+158h]
  json_t *v122; // [sp+164h] [bp+15Ch]
  json_t *v123; // [sp+168h] [bp+160h]
  json_t *v124; // [sp+16Ch] [bp+164h]
  const json_t *v125; // [sp+170h] [bp+168h]
  json_t *v126; // [sp+174h] [bp+16Ch]
  json_t *v127; // [sp+178h] [bp+170h]
  json_t *v128; // [sp+17Ch] [bp+174h]
  const json_t *v129; // [sp+180h] [bp+178h]
  json_t *v130; // [sp+184h] [bp+17Ch]
  const json_t *v131; // [sp+188h] [bp+180h]
  const json_t *v132; // [sp+18Ch] [bp+184h]
  const json_t *v133; // [sp+190h] [bp+188h]
  const json_t *v134; // [sp+194h] [bp+18Ch]
  int v135; // [sp+198h] [bp+190h]
  unsigned __int8 v136; // [sp+19Fh] [bp+197h]
  size_t i8; // [sp+1A0h] [bp+198h]
  unsigned int i2; // [sp+1A4h] [bp+19Ch]
  unsigned int i6; // [sp+1A8h] [bp+1A0h]
  unsigned int i4; // [sp+1ACh] [bp+1A4h]
  unsigned int nn; // [sp+1B0h] [bp+1A8h]
  unsigned int kk; // [sp+1B4h] [bp+1ACh]
  unsigned int ii; // [sp+1B8h] [bp+1B0h]
  unsigned int n; // [sp+1BCh] [bp+1B4h]
  unsigned int k; // [sp+1C0h] [bp+1B8h]
  unsigned int i; // [sp+1C4h] [bp+1BCh]
  int i7; // [sp+1C8h] [bp+1C0h]
  int i5; // [sp+1CCh] [bp+1C4h]
  int i3; // [sp+1D0h] [bp+1C8h]
  int i1; // [sp+1D4h] [bp+1CCh]
  int mm; // [sp+1D8h] [bp+1D0h]
  int jj; // [sp+1DCh] [bp+1D4h]
  int m; // [sp+1E0h] [bp+1D8h]
  int j; // [sp+1E4h] [bp+1DCh]

  v135 = 0;
  v134 = 0;
  v133 = 0;
  v132 = 0;
  v131 = 0;
  v130 = 0;
  v129 = 0;
  v128 = 0;
  v127 = 0;
  v126 = 0;
  v125 = 0;
  v124 = 0;
  v123 = 0;
  v122 = 0;
  v121 = 0;
  v120 = 0;
  v119 = 0;
  v118 = 0;
  j = 0;
  v117 = 0;
  m = 0;
  v116 = 0;
  jj = 0;
  v115 = 0;
  mm = 0;
  v114 = 0;
  i1 = 0;
  v113 = 0;
  i3 = 0;
  v112 = 0;
  i5 = 0;
  v111 = 0;
  i7 = 0;
  v110 = 0;
  v109 = 0;
  v108 = 0;
  v107 = 0;
  v106 = 0;
  v105 = 0;
  v104 = 0;
  v103 = 0;
  v102 = 0;
  v101 = 0;
  i = 0;
  k = 0;
  n = 0;
  ii = 0;
  kk = 0;
  nn = 0;
  i4 = 0;
  i6 = 0;
  i2 = 0;
  i8 = 0;
  v100 = 0;
  v136 = 1;
  v99[255] = 0;
  puts("begin");
  MES_system_config_File = (int)json_loadb(
                                  MES_system_Config_information,
                                  mes_system_config_file_length - 1,
                                  0,
                                  (json_error_t *)v99);
  if ( MES_system_config_File && !*(_DWORD *)MES_system_config_File )
  {
    v134 = json_object_get((const json_t *)MES_system_config_File, "result");
    if ( v134 && !*(_DWORD *)v134 )
    {
      v133 = json_object_get(v134, "version");
      if ( v133 && *(_DWORD *)v133 == 2 )
      {
        v0 = (char *)(Mes_System_Config_File_Information + 28);
        v1 = json_string_value(v133);
        strcpy(v0, v1);
        printf(
          "MES system paticular config information version is: %s\n",
          (const char *)(Mes_System_Config_File_Information + 28));
        v132 = json_object_get(v134, "code");
        if ( v132 && *(_DWORD *)v132 == 2 )
        {
          v2 = (char *)(Mes_System_Config_File_Information + 52);
          v3 = json_string_value(v132);
          strcpy(v2, v3);
          printf(
            "MES system paticular config information code is: %s\n",
            (const char *)(Mes_System_Config_File_Information + 52));
          if ( !strcmp((const char *)(Mes_System_Config_File_Information + 52), "000000") )
          {
            v131 = json_object_get(v134, "msg");
            if ( v131 && *(_DWORD *)v131 == 2 )
            {
              v4 = (char *)(Mes_System_Config_File_Information + 76);
              v5 = json_string_value(v131);
              strcpy(v4, v5);
              printf(
                "MES system paticular config information msg is: %s\n",
                (const char *)(Mes_System_Config_File_Information + 76));
              if ( !strcmp((const char *)(Mes_System_Config_File_Information + 76), "ok") )
              {
                v130 = json_object_get(v134, "configs");
                if ( v130 && *(_DWORD *)v130 == 1 )
                {
                  gConfigs_array_size = json_array_size(v130);
                  printf("There are %d configs in result\n", gConfigs_array_size);
                  for ( i = 0; i < gConfigs_array_size; ++i )
                  {
                    v110 = (const json_t *)json_array_get(v130, i);
                    if ( !v110 || *(_DWORD *)v110 )
                    {
                      printf("Can't read out configs[%d] in result, error\n", i);
                      v136 = 0;
                      break;
                    }
                    v118 = (char *)malloc(0x34u);
                    if ( !v118 )
                    {
LABEL_28:
                      printf("malloc for configs[%d] in result fail\n", i);
                      v136 = 0;
                      break;
                    }
                    *((_DWORD *)v118 + 12) = 0;
                    if ( *(_DWORD *)(Mes_System_Config_File_Information + 100) )
                    {
                      for ( j = *(_DWORD *)(Mes_System_Config_File_Information + 100);
                            *(_DWORD *)(j + 48);
                            j = *(_DWORD *)(j + 48) )
                      {
                        ;
                      }
                      *(_DWORD *)(j + 48) = v118;
                      j = 0;
                    }
                    else
                    {
                      *(_DWORD *)(Mes_System_Config_File_Information + 100) = v118;
                      *(_DWORD *)(*(_DWORD *)(Mes_System_Config_File_Information + 100) + 48) = 0;
                    }
                    v129 = json_object_get(v110, "miner_type");
                    if ( !v129 || *(_DWORD *)v129 != 2 )
                    {
                      printf("Can't find miner_type in configs[%d] in result\n", i);
                      v136 = 0;
                      break;
                    }
                    v6 = v118;
                    v7 = json_string_value(v129);
                    strcpy(v6, v7);
                    v128 = json_object_get(v110, "hw_info");
                    if ( !v128 || *(_DWORD *)v128 != 1 )
                    {
                      printf("Can't find hw_info in configs[%d] in result\n", i);
                      v136 = 0;
                      break;
                    }
                    gHw_info_array_size = json_array_size(v128);
                    for ( k = 0; k < gHw_info_array_size; ++k )
                    {
                      v109 = (const json_t *)json_array_get(v128, k);
                      if ( !v109 || *(_DWORD *)v109 )
                      {
                        printf("Can't read out hw_info_array[%d] in configs[%d], error\n", k, i);
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v117 = malloc(0x64u);
                      if ( !v117 )
                        goto LABEL_28;
                      v117[24] = 0;
                      if ( *((_DWORD *)v118 + 6) )
                      {
                        for ( m = *((_DWORD *)v118 + 6); *(_DWORD *)(m + 96); m = *(_DWORD *)(m + 96) )
                          ;
                        *(_DWORD *)(m + 96) = v117;
                        m = 0;
                      }
                      else
                      {
                        *((_DWORD *)v118 + 6) = v117;
                        *(_DWORD *)(*((_DWORD *)v118 + 6) + 96) = 0;
                      }
                      v8 = json_object_get(v109, "id");
                      v9 = json_integer_value(v8);
                      *v117 = v9;
                      v10 = (char *)(v117 + 1);
                      v11 = json_object_get(v109, "board_name");
                      v12 = json_string_value(v11);
                      strcpy(v10, v12);
                      v13 = (char *)(v117 + 7);
                      v14 = json_object_get(v109, "asic_type");
                      v15 = json_string_value(v14);
                      strcpy(v13, v15);
                      v16 = json_object_get(v109, "asic_num");
                      v17 = json_integer_value(v16);
                      v117[13] = v17;
                      v18 = json_object_get(v109, "voltage_domain");
                      v19 = json_integer_value(v18);
                      v117[14] = v19;
                      v20 = json_object_get(v109, "asic_num_per_voltage_domain");
                      v21 = json_integer_value(v20);
                      v117[15] = v21;
                      v126 = json_object_get(v109, "power_version");
                      if ( !v126 || *(_DWORD *)v126 != 1 )
                      {
                        printf("Can't find power_version in configs[%d]->hw_info[%d]\n", i, k);
                        v136 = 0;
                        goto LABEL_181;
                      }
                      gPower_version_array_size = json_array_size(v126);
                      for ( n = 0; n < gPower_version_array_size; ++n )
                      {
                        v108 = (_DWORD *)json_array_get(v126, n);
                        if ( !v108 || *v108 != 3 )
                        {
                          printf("Can't find power_version_array[%d] in configs[%d]->hw_info[%d], error\n", n, i, k);
                          v136 = 0;
                          goto LABEL_181;
                        }
                        v22 = json_integer_value(v108);
                        v117[n + 16] = v22;
                        APW_power_version[n] = v117[n + 16];
                      }
                    }
                    v125 = json_object_get(v110, "rule");
                    if ( !v125 || *(_DWORD *)v125 )
                    {
                      printf("Can't find rule configs[%d] in result\n", i);
                      v136 = 0;
                      break;
                    }
                    v124 = json_object_get(v125, "pattern");
                    if ( !v124 || *(_DWORD *)v124 != 1 )
                    {
                      printf("Can't find pattern in configs[%d]->rule\n", i);
                      v136 = 0;
                      break;
                    }
                    gPattern_array_size = json_array_size(v124);
                    for ( ii = 0; ii < gPattern_array_size; ++ii )
                    {
                      v107 = (const json_t *)json_array_get(v124, ii);
                      if ( !v107 || *(_DWORD *)v107 )
                      {
                        printf("Can't find pattern[%d] in configs[%d]->rule, error\n", ii, i);
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v116 = malloc(0x24u);
                      if ( !v116 )
                      {
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v116[8] = 0;
                      if ( *((_DWORD *)v118 + 7) )
                      {
                        for ( jj = *((_DWORD *)v118 + 7); *(_DWORD *)(jj + 32); jj = *(_DWORD *)(jj + 32) )
                          ;
                        *(_DWORD *)(jj + 32) = v116;
                        jj = 0;
                      }
                      else
                      {
                        *((_DWORD *)v118 + 7) = v116;
                        *(_DWORD *)(*((_DWORD *)v118 + 7) + 32) = 0;
                      }
                      v23 = json_object_get(v107, "id");
                      v24 = json_integer_value(v23);
                      *v116 = v24;
                      v25 = json_object_get(v107, "pattern_number");
                      v26 = json_integer_value(v25);
                      v116[1] = v26;
                      v27 = json_object_get(v107, "invalid_core_num");
                      v28 = json_integer_value(v27);
                      v116[2] = v28;
                      v29 = json_object_get(v107, "most_hw_num");
                      v30 = json_integer_value(v29);
                      v116[3] = v30;
                      v31 = json_object_get(v107, "least_nonce_per_core");
                      v32 = json_integer_value(v31);
                      v116[4] = v32;
                      v33 = json_object_get(v107, "nonce_rate");
                      v34 = json_integer_value(v33);
                      v116[5] = v34;
                      v35 = json_object_get(v107, "min_nonce_rate_per_asic");
                      v36 = json_integer_value(v35);
                      v116[6] = v36;
                      v37 = json_object_get(v107, "midstate_number");
                      v38 = json_integer_value(v37);
                      v116[7] = v38;
                    }
                    v127 = json_object_get(v125, "asic_reg");
                    if ( !v127 || *(_DWORD *)v127 != 1 )
                    {
                      printf("Can't find asic_reg in configs[%d]->rule\n", i);
                      v136 = 0;
                      break;
                    }
                    gAsic_reg_array_size = json_array_size(v127);
                    for ( kk = 0; kk < gAsic_reg_array_size; ++kk )
                    {
                      v106 = (const json_t *)json_array_get(v127, kk);
                      if ( !v106 || *(_DWORD *)v106 )
                      {
                        printf("Can't find asic_reg[%d] in configs[%d]->rule, error\n", kk, i);
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v115 = malloc(0x28u);
                      if ( !v115 )
                      {
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v115[9] = 0;
                      if ( *((_DWORD *)v118 + 8) )
                      {
                        for ( mm = *((_DWORD *)v118 + 8); *(_DWORD *)(mm + 36); mm = *(_DWORD *)(mm + 36) )
                          ;
                        *(_DWORD *)(mm + 36) = v115;
                        mm = 0;
                      }
                      else
                      {
                        *((_DWORD *)v118 + 8) = v115;
                        *(_DWORD *)(*((_DWORD *)v118 + 8) + 36) = 0;
                      }
                      v39 = json_object_get(v106, "id");
                      v40 = json_integer_value(v39);
                      *v115 = v40;
                      v41 = json_object_get(v106, "ccdly_sel");
                      v42 = json_integer_value(v41);
                      v115[1] = v42;
                      v43 = json_object_get(v106, "pwth_sel");
                      v44 = json_integer_value(v43);
                      v115[2] = v44;
                      v45 = json_object_get(v106, "swpf_mode");
                      v46 = json_integer_value(v45);
                      v115[3] = v46;
                      v47 = json_object_get(v106, "pulse_mode");
                      v48 = json_integer_value(v47);
                      v115[4] = v48;
                      v49 = json_object_get(v106, "clk_sel");
                      v50 = json_integer_value(v49);
                      v115[5] = v50;
                      v51 = json_object_get(v106, "ro_relay_en");
                      v52 = json_integer_value(v51);
                      v115[6] = v52;
                      v53 = json_object_get(v106, "co_relay_en");
                      v54 = json_integer_value(v53);
                      v115[7] = v54;
                      v55 = json_object_get(v106, "diode_vdd_mux_sel");
                      v56 = json_integer_value(v55);
                      v115[8] = v56;
                    }
                    v122 = json_object_get(v125, "test_method");
                    if ( !v122 || *(_DWORD *)v122 != 1 )
                    {
                      printf("Can't find test_method in configs[%d]->rule\n", i);
                      v136 = 0;
                      break;
                    }
                    gTest_method_array_size = json_array_size(v122);
                    for ( nn = 0; nn < gTest_method_array_size; ++nn )
                    {
                      v105 = (const json_t *)json_array_get(v122, nn);
                      if ( !v105 || *(_DWORD *)v105 )
                      {
                        printf("Can't find test_method[%d] in configs[%d]->rule, error\n", nn, i);
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v114 = malloc(0x20u);
                      if ( !v114 )
                      {
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v114[7] = 0;
                      if ( *((_DWORD *)v118 + 9) )
                      {
                        for ( i1 = *((_DWORD *)v118 + 9); *(_DWORD *)(i1 + 28); i1 = *(_DWORD *)(i1 + 28) )
                          ;
                        *(_DWORD *)(i1 + 28) = v114;
                        i1 = 0;
                      }
                      else
                      {
                        *((_DWORD *)v118 + 9) = v114;
                        *(_DWORD *)(*((_DWORD *)v118 + 9) + 28) = 0;
                      }
                      v57 = json_object_get(v105, "id");
                      v58 = json_integer_value(v57);
                      *v114 = v58;
                      v59 = (char *)(v114 + 1);
                      v60 = json_object_get(v105, "method");
                      v61 = json_string_value(v60);
                      strcpy(v59, v61);
                    }
                    v120 = json_object_get(v125, "test_loop");
                    if ( !v120 || *(_DWORD *)v120 != 1 )
                    {
                      printf("Can't find test_loop in configs[%d]->rule\n", i);
                      v136 = 0;
                      break;
                    }
                    gTest_loop_array_size = json_array_size(v120);
                    for ( i2 = 0; i2 < gTest_loop_array_size; ++i2 )
                    {
                      v102 = (const json_t *)json_array_get(v120, i2);
                      if ( !v102 || *(_DWORD *)v102 )
                      {
                        printf("Can't find test_loop[%d] in configs[%d]->rule, error\n", i2, i);
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v113 = malloc(0x10u);
                      if ( !v113 )
                      {
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v113[3] = 0;
                      if ( *((_DWORD *)v118 + 10) )
                      {
                        for ( i3 = *((_DWORD *)v118 + 10); *(_DWORD *)(i3 + 12); i3 = *(_DWORD *)(i3 + 12) )
                          ;
                        *(_DWORD *)(i3 + 12) = v113;
                        i3 = 0;
                      }
                      else
                      {
                        *((_DWORD *)v118 + 10) = v113;
                        *(_DWORD *)(*((_DWORD *)v118 + 10) + 12) = 0;
                      }
                      v62 = json_object_get(v102, "id");
                      v63 = json_integer_value(v62);
                      *v113 = v63;
                      v64 = json_object_get(v102, "frequency");
                      v65 = json_integer_value(v64);
                      v113[1] = v65;
                      v66 = json_object_get(v102, "voltage");
                      v67 = json_integer_value(v66);
                      v113[2] = v67;
                    }
                    v123 = json_object_get(v110, "test_config");
                    if ( !v123 || *(_DWORD *)v123 != 1 )
                    {
                      printf("Can't find test_config in configs[%d] in result\n", i);
                      v136 = 0;
                      break;
                    }
                    gTest_config_array_size = json_array_size(v123);
                    for ( i4 = 0; i4 < gTest_config_array_size; ++i4 )
                    {
                      v104 = (const json_t *)json_array_get(v123, i4);
                      if ( !v104 || *(_DWORD *)v104 )
                      {
                        printf("Can't find test_config[%d] in configs[%d], error\n", i4, i);
                        v136 = 0;
                        goto LABEL_181;
                      }
                      v112 = (char *)malloc(0x6Cu);
                      if ( !v112 )
                      {
                        v136 = 0;
                        goto LABEL_181;
                      }
                      *((_DWORD *)v112 + 26) = 0;
                      if ( *((_DWORD *)v118 + 11) )
                      {
                        for ( i5 = *((_DWORD *)v118 + 11); *(_DWORD *)(i5 + 104); i5 = *(_DWORD *)(i5 + 104) )
                          ;
                        *(_DWORD *)(i5 + 104) = v112;
                        i5 = 0;
                      }
                      else
                      {
                        *((_DWORD *)v118 + 11) = v112;
                        *(_DWORD *)(*((_DWORD *)v118 + 11) + 104) = 0;
                      }
                      v68 = v112;
                      v69 = json_object_get(v104, "hardware_version");
                      v70 = json_string_value(v69);
                      strcpy(v68, v70);
                      v71 = v112 + 24;
                      v72 = json_object_get(v104, "bom_version");
                      v73 = json_string_value(v72);
                      strcpy(v71, v73);
                      v74 = v112 + 48;
                      v75 = json_object_get(v104, "chip_technology");
                      v76 = json_string_value(v75);
                      strcpy(v74, v76);
                      v77 = v112 + 72;
                      v78 = json_object_get(v104, "ft_vesrion");
                      v79 = json_string_value(v78);
                      strcpy(v77, v79);
                      v80 = json_object_get(v104, "bin");
                      v81 = json_integer_value(v80);
                      *((_DWORD *)v112 + 24) = v81;
                      v121 = json_object_get(v104, "data");
                      if ( !v121 || *(_DWORD *)v121 != 1 )
                      {
                        printf("Can't find data in configs[%d]->test_config[%d]\n", i, i4);
                        v136 = 0;
                        goto LABEL_181;
                      }
                      gData_array_size = json_array_size(v121);
                      for ( i6 = 0; i6 < gData_array_size; ++i6 )
                      {
                        v103 = (const json_t *)json_array_get(v121, i6);
                        if ( !v103 || *(_DWORD *)v103 )
                        {
                          printf("Can't find data[%d] in configs[%d]->test_config[%d], error\n", i6, i, i4);
                          v136 = 0;
                          goto LABEL_181;
                        }
                        v111 = (char *)malloc(0x60u);
                        if ( !v111 )
                        {
                          v136 = 0;
                          goto LABEL_181;
                        }
                        *((_DWORD *)v111 + 23) = 0;
                        if ( *((_DWORD *)v112 + 25) )
                        {
                          for ( i7 = *((_DWORD *)v112 + 25); *(_DWORD *)(i7 + 92); i7 = *(_DWORD *)(i7 + 92) )
                            ;
                          *(_DWORD *)(i7 + 92) = v111;
                          i7 = 0;
                        }
                        else
                        {
                          *((_DWORD *)v112 + 25) = v111;
                          *(_DWORD *)(*((_DWORD *)v112 + 25) + 92) = 0;
                        }
                        v82 = v111;
                        v83 = json_object_get(v103, "version");
                        v84 = json_string_value(v83);
                        strcpy(v82, v84);
                        v85 = json_object_get(v103, "pattern_id");
                        v86 = json_integer_value(v85);
                        *((_DWORD *)v111 + 6) = v86;
                        v87 = json_object_get(v103, "asic_reg_id");
                        v88 = json_integer_value(v87);
                        *((_DWORD *)v111 + 7) = v88;
                        v89 = json_object_get(v103, "test_method_id");
                        v90 = json_integer_value(v89);
                        *((_DWORD *)v111 + 8) = v90;
                        v91 = json_object_get(v103, "voltage_accuracy");
                        v92 = json_integer_value(v91);
                        *((_DWORD *)v111 + 9) = v92;
                        v93 = json_object_get(v103, "fan_speed");
                        v94 = json_integer_value(v93);
                        *((_DWORD *)v111 + 10) = v94;
                        v95 = json_object_get(v103, "pre_open_core_voltage");
                        v96 = json_integer_value(v95);
                        *((_DWORD *)v111 + 22) = v96;
                        v119 = json_object_get(v103, "test_loop_id");
                        if ( !v119 || *(_DWORD *)v119 != 1 )
                        {
                          printf("Can't find test_loop_id in configs[%d]->test_config[%d]->data[%d]\n", i, i4, i6);
                          v136 = 0;
                          goto LABEL_181;
                        }
                        v100 = json_array_size(v119);
                        if ( v100 > 0xA )
                        {
                          printf("Test_loop_id_array_size is %d, bigger than %d\n", v100, 10);
                          v136 = 0;
                          goto LABEL_181;
                        }
                        *((_DWORD *)v111 + 21) = v100;
                        for ( i8 = 0; i8 < v100; ++i8 )
                        {
                          v101 = (_DWORD *)json_array_get(v119, i8);
                          if ( !v101 || *v101 != 3 )
                          {
                            printf(
                              "Can't find test_loop_id[%d] in configs[%d]->test_config[%d]->data[%d], error\n",
                              i8,
                              i,
                              i4,
                              i6);
                            v136 = 0;
                            goto LABEL_181;
                          }
                          v97 = json_integer_value(v101);
                          *(_DWORD *)&v111[4 * i8 + 44] = v97;
                        }
                      }
                    }
                  }
                }
                else
                {
                  puts("Can't find configs in result");
                  v136 = 0;
                }
              }
              else
              {
                printf(
                  "Get all config information fail. msg: %s\n",
                  (const char *)(Mes_System_Config_File_Information + 76));
                v136 = 0;
              }
            }
            else
            {
              puts("Can't find msg in result");
              v136 = 0;
            }
          }
          else
          {
            printf(
              "Get all config information fail. code: %s\n",
              (const char *)(Mes_System_Config_File_Information + 52));
            v136 = 0;
          }
        }
        else
        {
          puts("Can't find code in result");
          v136 = 0;
        }
      }
      else
      {
        puts("Can't find version in result");
        v136 = 0;
      }
    }
    else
    {
      puts("Can't find result in MES system paticular config information");
      v136 = 0;
    }
  }
  else
  {
    puts("The received MES system all config information is not in JSON format");
    v136 = 0;
  }
LABEL_181:
  if ( v135 )
    sub_2E8A8(v135);
  puts("done");
  return v136;
}
// 1F0D18: using guessed type int MES_system_Config_information;
// 1F0D1C: using guessed type int mes_system_config_file_length;
// 1F0D20: using guessed type int MES_system_config_File;
// 1F0D28: using guessed type int Mes_System_Config_File_Information;
// 1F0D30: using guessed type int gConfigs_array_size;
// 1F0D38: using guessed type int gHw_info_array_size;
// 1F0D3C: using guessed type int gPower_version_array_size;
// 1F0D44: using guessed type int gPattern_array_size;
// 1F0D4C: using guessed type int gAsic_reg_array_size;
// 1F0D50: using guessed type int gTest_method_array_size;
// 1F0D54: using guessed type int gTest_config_array_size;
// 1F0D58: using guessed type int gData_array_size;
// 1F0D5C: using guessed type int gTest_loop_array_size;
// 47BEEC: using guessed type unsigned __int8 APW_power_version[8];

//----- (00031B68) --------------------------------------------------------
int print_MES_system_information()
{
  int result; // r0
  int v1; // [sp+10h] [bp+8h]
  int v2; // [sp+14h] [bp+Ch]
  _DWORD *v3; // [sp+18h] [bp+10h]
  int v4; // [sp+1Ch] [bp+14h]
  _DWORD *v5; // [sp+20h] [bp+18h]
  _DWORD *v6; // [sp+24h] [bp+1Ch]
  int v7; // [sp+28h] [bp+20h]
  int v8; // [sp+2Ch] [bp+24h]
  unsigned int j; // [sp+30h] [bp+28h]
  int v10; // [sp+34h] [bp+2Ch]
  int v11; // [sp+38h] [bp+30h]
  int v12; // [sp+3Ch] [bp+34h]
  int v13; // [sp+40h] [bp+38h]
  int v14; // [sp+44h] [bp+3Ch]
  int v15; // [sp+48h] [bp+40h]
  unsigned int i; // [sp+4Ch] [bp+44h]
  int v17; // [sp+50h] [bp+48h]
  int v18; // [sp+54h] [bp+4Ch]

  v18 = 0;
  v17 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  printf(
    "MES system paticular config information version is: %s\n",
    (const char *)(Mes_System_Config_File_Information + 28));
  printf(
    "MES system paticular config information code is: %s\n",
    (const char *)(Mes_System_Config_File_Information + 52));
  result = printf(
             "MES system paticular config information msg is: %s\n",
             (const char *)(Mes_System_Config_File_Information + 76));
  v8 = *(_DWORD *)(Mes_System_Config_File_Information + 100);
  while ( v8 )
  {
    result = printf("configs[%d]->miner_type: %s\n", v18, (const char *)v8);
    v7 = *(_DWORD *)(v8 + 24);
    while ( v7 )
    {
      printf("configs[%d]->hw_info[%d]->id: %d\n", v18, v17, *(_DWORD *)v7);
      printf("configs[%d]->hw_info[%d]->board_name: %s\n", v18, v17, (const char *)(v7 + 4));
      printf("configs[%d]->hw_info[%d]->asic_type: %s\n", v18, v17, (const char *)(v7 + 28));
      printf("configs[%d]->hw_info[%d]->asic_num: %d\n", v18, v17, *(_DWORD *)(v7 + 52));
      printf("configs[%d]->hw_info[%d]->voltage_domain: %d\n", v18, v17, *(_DWORD *)(v7 + 56));
      result = printf("configs[%d]->hw_info[%d]->asic_num_per_voltage_domain: %d\n", v18, v17, *(_DWORD *)(v7 + 60));
      for ( i = 0; i < gPower_version_array_size; ++i )
        result = printf(
                   "configs[%d]->hw_info[%d]->power_version[%d]: %d\n",
                   v18,
                   v17,
                   i,
                   *(_DWORD *)(v7 + 4 * (i + 16)));
      v7 = *(_DWORD *)(v7 + 96);
      ++v17;
    }
    v6 = *(_DWORD **)(v8 + 28);
    while ( v6 )
    {
      printf("configs[%d]->rule->pattern[%d]->id: %d\n", v18, v15, *v6);
      printf("configs[%d]->rule->pattern[%d]->pattern_number: %d\n", v18, v15, v6[1]);
      printf("configs[%d]->rule->pattern[%d]->invalid_core_num: %d\n", v18, v15, v6[2]);
      printf("configs[%d]->rule->pattern[%d]->most_hw_num: %d\n", v18, v15, v6[3]);
      printf("configs[%d]->rule->pattern[%d]->least_nonce_per_core: %d\n", v18, v15, v6[4]);
      printf("configs[%d]->rule->pattern[%d]->nonce_rate: %d\n", v18, v15, v6[5]);
      printf("configs[%d]->rule->pattern[%d]->min_nonce_rate_per_asic: %d\n", v18, v15, v6[6]);
      result = printf("configs[%d]->rule->pattern[%d]->midstate_number: %d\n", v18, v15, v6[7]);
      v6 = (_DWORD *)v6[8];
      ++v15;
    }
    v5 = *(_DWORD **)(v8 + 32);
    while ( v5 )
    {
      printf("configs[%d]->rule->asic_reg[%d]->id: %d\n", v18, v14, *v5);
      printf("configs[%d]->rule->asic_reg[%d]->ccdly_sel: %d\n", v18, v14, v5[1]);
      printf("configs[%d]->rule->asic_reg[%d]->pwth_sel: %d\n", v18, v14, v5[2]);
      printf("configs[%d]->rule->asic_reg[%d]->swpf_mode: %d\n", v18, v14, v5[3]);
      printf("configs[%d]->rule->asic_reg[%d]->pulse_mode: %d\n", v18, v14, v5[4]);
      printf("configs[%d]->rule->asic_reg[%d]->clk_sel: %d\n", v18, v14, v5[5]);
      printf("configs[%d]->rule->asic_reg[%d]->ro_relay_en: %d\n", v18, v14, v5[6]);
      printf("configs[%d]->rule->asic_reg[%d]->co_relay_en: %d\n", v18, v14, v5[7]);
      result = printf("configs[%d]->rule->asic_reg[%d]->diode_vdd_mux_sel: %d\n", v18, v14, v5[8]);
      v5 = (_DWORD *)v5[9];
      ++v14;
    }
    v4 = *(_DWORD *)(v8 + 36);
    while ( v4 )
    {
      printf("configs[%d]->rule->test_method[%d]->id: %d\n", v18, v13, *(_DWORD *)v4);
      result = printf("configs[%d]->rule->test_method[%d]->method: %s\n", v18, v13, (const char *)(v4 + 4));
      v4 = *(_DWORD *)(v4 + 28);
      ++v13;
    }
    v3 = *(_DWORD **)(v8 + 40);
    while ( v3 )
    {
      printf("configs[%d]->rule->test_loop[%d]->id: %d\n", v18, v12, *v3);
      printf("configs[%d]->rule->test_loop[%d]->frequency: %d\n", v18, v12, v3[1]);
      result = printf("configs[%d]->rule->test_loop[%d]->voltage: %d\n", v18, v12, v3[2]);
      v3 = (_DWORD *)v3[3];
      ++v12;
    }
    v2 = *(_DWORD *)(v8 + 44);
    while ( v2 )
    {
      printf("configs[%d]->test_config[%d]->hardware_version: %s\n", v18, v11, (const char *)v2);
      printf("configs[%d]->test_config[%d]->bom_version: %s\n", v18, v11, (const char *)(v2 + 24));
      printf("configs[%d]->test_config[%d]->chip_technology: %s\n", v18, v11, (const char *)(v2 + 48));
      printf("configs[%d]->test_config[%d]->ft_vesrion: %s\n", v18, v11, (const char *)(v2 + 72));
      result = printf("configs[%d]->test_config[%d]->bin: %d\n", v18, v11, *(_DWORD *)(v2 + 96));
      v1 = *(_DWORD *)(v2 + 100);
      while ( v1 )
      {
        printf("configs[%d]->test_config[%d]->data[%d]->version: %s\n", v18, v11, v10, (const char *)v1);
        printf("configs[%d]->test_config[%d]->data[%d]->pattern_id: %d\n", v18, v11, v10, *(_DWORD *)(v1 + 24));
        printf("configs[%d]->test_config[%d]->data[%d]->asic_reg_id: %d\n", v18, v11, v10, *(_DWORD *)(v1 + 28));
        printf("configs[%d]->test_config[%d]->data[%d]->test_method_id: %d\n", v18, v11, v10, *(_DWORD *)(v1 + 32));
        printf("configs[%d]->test_config[%d]->data[%d]->voltage_accuracy: %d\n", v18, v11, v10, *(_DWORD *)(v1 + 36));
        printf("configs[%d]->test_config[%d]->data[%d]->fan_speed: %d\n", v18, v11, v10, *(_DWORD *)(v1 + 40));
        result = printf(
                   "configs[%d]->test_config[%d]->data[%d]->pre_open_core_voltage: %d\n",
                   v18,
                   v11,
                   v10,
                   *(_DWORD *)(v1 + 88));
        for ( j = 0; j < gTest_loop_id_array_size; ++j )
          result = printf(
                     "configs[%d]->test_config[%d]->data[%d]->test_loop_id[%d]: %d\n",
                     v18,
                     v11,
                     v10,
                     j,
                     *(_DWORD *)(4 * (j + 10) + v1 + 4));
        v1 = *(_DWORD *)(v1 + 92);
        ++v10;
      }
      v2 = *(_DWORD *)(v2 + 104);
      ++v11;
    }
    v8 = *(_DWORD *)(v8 + 48);
    ++v18;
  }
  return result;
}
// 1F0D28: using guessed type int Mes_System_Config_File_Information;
// 1F0D3C: using guessed type int gPower_version_array_size;
// 1F0D60: using guessed type int gTest_loop_id_array_size;

//----- (000320B8) --------------------------------------------------------
int __fastcall find_test_standard_position(
        int a1,
        const char *a2,
        const char *a3,
        const char *a4,
        const char *a5,
        const char *a6,
        const char *a7,
        char *a8,
        int a9)
{
  int v9; // r2
  int v10; // r4
  _DWORD v17[2]; // [sp+28h] [bp+10h] BYREF
  __int16 v18; // [sp+30h] [bp+18h]
  int v19; // [sp+34h] [bp+1Ch]
  int v20; // [sp+38h] [bp+20h]
  int v21; // [sp+3Ch] [bp+24h]
  int v22; // [sp+40h] [bp+28h]
  int v23; // [sp+44h] [bp+2Ch]
  char *v24; // [sp+48h] [bp+30h]
  int v25; // [sp+4Ch] [bp+34h]
  int v26; // [sp+50h] [bp+38h]
  int v27; // [sp+54h] [bp+3Ch]
  int v28; // [sp+58h] [bp+40h]
  int v29; // [sp+5Ch] [bp+44h]
  char v30; // [sp+62h] [bp+4Ah]
  char v31; // [sp+63h] [bp+4Bh]
  int v32; // [sp+64h] [bp+4Ch]
  _DWORD *v33; // [sp+68h] [bp+50h]
  _DWORD *v34; // [sp+6Ch] [bp+54h]
  char *src; // [sp+70h] [bp+58h]
  char *j; // [sp+74h] [bp+5Ch]
  int v37; // [sp+78h] [bp+60h]
  int v38; // [sp+7Ch] [bp+64h]
  char *s1; // [sp+80h] [bp+68h]
  int v40; // [sp+84h] [bp+6Ch]
  int v41; // [sp+88h] [bp+70h]
  int v42; // [sp+8Ch] [bp+74h]
  int v43; // [sp+90h] [bp+78h]
  int v44; // [sp+94h] [bp+7Ch]
  bool v45; // [sp+98h] [bp+80h]
  char v46; // [sp+99h] [bp+81h]
  char v47; // [sp+9Ah] [bp+82h]
  char v48; // [sp+9Bh] [bp+83h]
  unsigned int i; // [sp+9Ch] [bp+84h]

  i = 0;
  v48 = 0;
  v47 = 0;
  v46 = 0;
  v31 = 0;
  v30 = 0;
  v17[0] = 0;
  v17[1] = 0;
  v18 = 0;
  v45 = 1;
  v44 = 0;
  v43 = 0;
  v29 = 0;
  v42 = 0;
  v28 = 0;
  v27 = 0;
  v41 = 0;
  v40 = 0;
  v26 = 0;
  v25 = 0;
  s1 = 0;
  v38 = 0;
  v37 = 0;
  j = 0;
  v24 = 0;
  src = 0;
  v34 = 0;
  v23 = 0;
  v22 = 0;
  v33 = 0;
  v21 = 0;
  v32 = 0;
  v20 = 0;
  v19 = 0;
  printf("%s %s %s%s%s %s %s BIN%d\n", a2, a3, a5, a6, a7, a4, a8, a9);
  s1 = *(char **)(Mes_System_Config_File_Information + 100);
  while ( s1 )
  {
    if ( !strcmp(s1, a2) )
    {
      v38 = *((_DWORD *)s1 + 6);
      while ( v38 )
      {
        if ( !strcmp((const char *)(v38 + 4), a3) && !strcmp((const char *)(v38 + 28), a4) )
        {
          *(_DWORD *)(MES2Local_Config_Information + 64) = *(_DWORD *)(v38 + 52);
          printf("Asic_Num: %d\n", *(_DWORD *)(MES2Local_Config_Information + 64));
          *(_DWORD *)(MES2Local_Config_Information + 80) = *(_DWORD *)(v38 + 56);
          printf("Voltage_Domain: %d\n", *(_DWORD *)(MES2Local_Config_Information + 80));
          *(_DWORD *)(MES2Local_Config_Information + 84) = *(_DWORD *)(v38 + 60);
          printf("Asic_Num_Per_Voltage_Domain: %d\n", *(_DWORD *)(MES2Local_Config_Information + 84));
          for ( i = 0; i < gPower_version_array_size; ++i )
          {
            APW_power_version[i] = *(_DWORD *)(v38 + 4 * (i + 16));
            printf("APW_power_version[%d]: %d\n", i, APW_power_version[i]);
          }
          v48 = 1;
          break;
        }
        v38 = *(_DWORD *)(v38 + 96);
        ++v43;
      }
      if ( v48 != 1 )
      {
        printf("can't find:: board_name: %s, asic_type: %s\n", a3, a4);
      }
      else
      {
        v37 = *((_DWORD *)s1 + 11);
        while ( v37 )
        {
          if ( !strcmp((const char *)(v37 + 72), a8) && *(_DWORD *)(v37 + 96) == a9 )
          {
            j = *(char **)(v37 + 100);
            src = j;
            for ( j = (char *)*((_DWORD *)j + 23); j; j = v24 )
            {
              if ( strcmp(src, j) < 0 )
                src = j;
            }
            strcpy((char *)(MES2Local_Config_Information + 442), src);
            printf("version: %s\n", (const char *)(MES2Local_Config_Information + 442));
            v32 = *((_DWORD *)src + 6);
            printf("pattern_id: %d\n", v32);
            v20 = *((_DWORD *)src + 7);
            printf("asic_reg_id: %d\n", v20);
            v19 = *((_DWORD *)src + 8);
            printf("test_method_id: %d\n", v19);
            *(_DWORD *)(MES2Local_Config_Information + 460) = *((_DWORD *)src + 9);
            printf("version: %d\n", *(_DWORD *)(MES2Local_Config_Information + 460));
            *(_DWORD *)(MES2Local_Config_Information + 436) = *((_DWORD *)src + 10);
            printf("Fan_Speed: %d\n", *(_DWORD *)(MES2Local_Config_Information + 436));
            gTest_loop_id_array_size = *((_DWORD *)src + 21);
            printf("gTest_loop_id_array_size: %d\n", gTest_loop_id_array_size);
            if ( (unsigned int)gTest_loop_id_array_size > 0xA )
            {
              printf("gTest_loop_id_array_size is %d, bigger than %d\n", gTest_loop_id_array_size, 10);
              goto LABEL_57;
            }
            v9 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(v9 + 28) = gTest_loop_id_array_size;
            *(_DWORD *)(a1 + 52) = *(_DWORD *)(v9 + 28);
            gTest_loop = gTest_loop_id_array_size;
            printf("gTest_loop: %d\n", gTest_loop_id_array_size);
            for ( i = 0; i < gTest_loop_id_array_size; ++i )
            {
              *(_DWORD *)(16 * (i + 2) + MES2Local_Config_Information + 192) = *(_DWORD *)&src[4 * i + 44];
              printf("Test_Loop[%d]->Level: %d\n", i, *(_DWORD *)(16 * (i + 2) + MES2Local_Config_Information + 192));
              *(_DWORD *)(16 * (i + 2) + MES2Local_Config_Information + 196) = *((_DWORD *)src + 22);
              printf(
                "Test_Loop[%d]->Pre_Open_Core_Voltage: %d\n",
                i,
                *(_DWORD *)(16 * (i + 2) + MES2Local_Config_Information + 196));
            }
            v47 = 1;
            break;
          }
          v37 = *(_DWORD *)(v37 + 104);
          ++v40;
        }
        if ( v47 != 1 )
        {
          printf("can't find::  %s%s%s, %s, BIN%d\n", a5, a6, a7, a8, a9);
        }
        else
        {
          v34 = (_DWORD *)*((_DWORD *)s1 + 7);
          while ( v34 )
          {
            if ( *v34 == v32 )
            {
              printf("pattern[%d]->id: %d\n", v42, *v34);
              *(_DWORD *)(MES2Local_Config_Information + 200) = v34[1];
              *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = v34[1];
              printf("pattern[%d]->Pattern_Number: %d\n", v42, *(_DWORD *)(MES2Local_Config_Information + 200));
              *(_DWORD *)(MES2Local_Config_Information + 204) = v34[2];
              *(_DWORD *)(*(_DWORD *)(a1 + 8) + 60) = v34[2];
              printf("pattern[%d]->Invalid_Core_Number: %d\n", v42, *(_DWORD *)(MES2Local_Config_Information + 204));
              *(_DWORD *)(MES2Local_Config_Information + 220) = v34[3];
              printf("pattern[%d]->Most_HW_Num: %d\n", v42, *(_DWORD *)(MES2Local_Config_Information + 220));
              *(_DWORD *)(MES2Local_Config_Information + 208) = v34[4];
              *(_DWORD *)(*(_DWORD *)(a1 + 8) + 64) = v34[4];
              printf("pattern[%d]->Least_Nonce_Per_Core: %d\n", v42, *(_DWORD *)(MES2Local_Config_Information + 208));
              *(_DWORD *)(MES2Local_Config_Information + 212) = v34[5];
              printf("pattern[%d]->Nonce_Rate: %d\n", v42, *(_DWORD *)(MES2Local_Config_Information + 212));
              *(_DWORD *)(MES2Local_Config_Information + 216) = v34[6];
              printf("pattern[%d]->Min_nonce_rate_per_asic: %d\n", v42, *(_DWORD *)(MES2Local_Config_Information + 216));
              v46 = 1;
              break;
            }
            v34 = (_DWORD *)v34[8];
            ++v42;
          }
          if ( v46 != 1 )
          {
            printf("can't find:: pattern_id: %d\n", v32);
          }
          else
          {
            if ( *(_DWORD *)(a1 + 48) && *(_DWORD *)(*(_DWORD *)(a1 + 8) + 24) )
            {
              free(*(void **)(a1 + 48));
              free(*(void **)(*(_DWORD *)(a1 + 8) + 24));
              *(_DWORD *)(a1 + 48) = malloc(4 * gTest_loop_id_array_size);
              v10 = *(_DWORD *)(a1 + 8);
              *(_DWORD *)(v10 + 24) = malloc(4 * gTest_loop_id_array_size);
            }
            for ( i = 0; i < gTest_loop_id_array_size; ++i )
            {
              *((_BYTE *)v17 + i) = 0;
              v33 = (_DWORD *)*((_DWORD *)s1 + 10);
              while ( v33 )
              {
                if ( *v33 == *(_DWORD *)(16 * (i + 2) + MES2Local_Config_Information + 192) )
                {
                  printf("test_loop[%d]->id: %d\n", v41, *v33);
                  *(_DWORD *)(16 * (i + 14) + MES2Local_Config_Information + 12) = v33[1];
                  *(_DWORD *)(4 * i + *(_DWORD *)(*(_DWORD *)(a1 + 8) + 24)) = v33[1];
                  printf(
                    "test_loop[%d]->Frequence: %d\n",
                    v41,
                    *(_DWORD *)(4 * i + *(_DWORD *)(*(_DWORD *)(a1 + 8) + 24)));
                  *(_DWORD *)(16 * (i + 14) + MES2Local_Config_Information + 8) = v33[2];
                  *(_DWORD *)(4 * i + *(_DWORD *)(a1 + 48)) = v33[2];
                  printf("test_loop[%d]->Voltage: %d\n", v41, *(_DWORD *)(4 * i + *(_DWORD *)(a1 + 48)));
                  *((_BYTE *)v17 + i) = 1;
                  break;
                }
                v33 = (_DWORD *)v33[3];
                ++v41;
              }
            }
            for ( i = 0; i < gTest_loop_id_array_size; ++i )
            {
              v45 = (v45 & *((_BYTE *)v17 + i)) != 0;
              if ( *((_BYTE *)v17 + i) != 1 )
                printf(
                  "can't find:: test_loop id: %d\n",
                  *(_DWORD *)(16 * (i + 2) + MES2Local_Config_Information + 192));
            }
            if ( v45 )
            {
              puts("find all test standard");
              return 1;
            }
          }
        }
      }
    }
LABEL_57:
    s1 = (char *)*((_DWORD *)s1 + 12);
    ++v44;
  }
  return 0;
}
// 1F0D28: using guessed type int Mes_System_Config_File_Information;
// 1F0D3C: using guessed type int gPower_version_array_size;
// 1F0D60: using guessed type int gTest_loop_id_array_size;
// 479D58: using guessed type int gTest_loop;
// 479D9C: using guessed type int MES2Local_Config_Information;
// 47BEEC: using guessed type unsigned __int8 APW_power_version[8];

//----- (000329A8) --------------------------------------------------------
int __fastcall prepare_test_standard(int a1)
{
  const char *v1; // r4
  const char *v2; // r5
  const char *v3; // r6
  int chip_bin; // r0
  int v8; // [sp+24h] [bp+Ch] BYREF
  int v9; // [sp+28h] [bp+10h] BYREF
  char v10[8]; // [sp+2Ch] [bp+14h] BYREF

  *(_DWORD *)v10 = 0;
  v9 = 0;
  v8 = 0;
  substr(byte_47BF64, 0, 3u, (int)v10);
  substr(byte_47BF64, 3, 2u, (int)&v9);
  substr(byte_47BF64, 5, 2u, (int)&v8);
  v1 = (const char *)(MES2Local_Config_Information + 16);
  v2 = (const char *)(MES2Local_Config_Information + 32);
  v3 = (const char *)(MES2Local_Config_Information + 48);
  chip_bin = get_chip_bin((int)qr_code);
  if ( (unsigned __int8)find_test_standard_position(
                          a1,
                          v1,
                          v2,
                          v3,
                          v10,
                          (const char *)&v9,
                          (const char *)&v8,
                          src,
                          chip_bin) != 1 )
  {
    gFind_test_standard = 0;
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "Can't find");
    lcd_show(2u, "test standard");
    lcd_show(3u, "please re-scan");
    puts("Can't find test standard");
    sleep(5u);
    return 0;
  }
  else
  {
    gFind_test_standard = 1;
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "Find test");
    lcd_show(2u, "standard");
    lcd_show(3u, "Press Start Key");
    puts("find test standard, Press Start Key to Begin Test");
    return 1;
  }
}
// 1F0D64: using guessed type char gFind_test_standard;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (00032B20) --------------------------------------------------------
int __fastcall check_whether_MES_system_submit_result_is_correct(const json_t *a1)
{
  const char *v1; // r0
  const char *v2; // r0
  const char *v3; // r0
  json_t *v5; // [sp+8h] [bp+8h]
  unsigned __int8 v6; // [sp+Fh] [bp+Fh]
  json_t *v7; // [sp+10h] [bp+10h]
  json_t *v8; // [sp+14h] [bp+14h]

  v8 = 0;
  v7 = 0;
  v5 = json_object_get(a1, "result");
  if ( v5 && !*(_DWORD *)v5 )
  {
    v8 = json_object_get(v5, "code");
    if ( v8 && *(_DWORD *)v8 == 2 )
    {
      v1 = json_string_value(v8);
      if ( !strcmp(v1, "000000") )
      {
        puts("submit result success");
        v6 = 1;
      }
      else
      {
        v2 = json_string_value(v8);
        printf("submit result fail! code: %s\n", v2);
        v7 = json_object_get(v5, "msg");
        if ( v7 && *(_DWORD *)v7 == 2 )
        {
          v3 = json_string_value(v7);
          printf("submit result fail! msg: %s\n", v3);
          v6 = 0;
        }
        else
        {
          puts("Don't get msg in result");
          v6 = 0;
        }
      }
    }
    else
    {
      puts("Don't get code in result");
      v6 = 0;
    }
  }
  else
  {
    puts("Don't find result in submit result responce");
    v6 = 0;
  }
  if ( v5 )
    sub_2E8A8((int)v5);
  if ( v8 )
    sub_2E8A8((int)v8);
  if ( v7 )
    sub_2E8A8((int)v7);
  return v6;
}

//----- (00032C54) --------------------------------------------------------
int __fastcall prepare_MES_system_submit_information(int a1)
{
  int v1; // r0
  json_t_0 *v2; // r0
  json_t_0 *v3; // r0
  const char *v4; // r3
  int v5; // r0
  int v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  int v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  int v14; // r0
  unsigned int v15; // r0
  int v16; // r0
  int v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  char v23[12]; // [sp+8h] [bp+8h] BYREF
  _BYTE v24[252]; // [sp+14h] [bp+14h] BYREF
  _DWORD v25[256]; // [sp+110h] [bp+110h] BYREF
  int v26[8]; // [sp+510h] [bp+510h] BYREF
  _DWORD v27[8]; // [sp+530h] [bp+530h] BYREF
  _DWORD v28[16]; // [sp+550h] [bp+550h] BYREF
  _DWORD v29[8]; // [sp+590h] [bp+590h] BYREF
  _DWORD s[8]; // [sp+5B0h] [bp+5B0h] BYREF
  unsigned int v31; // [sp+5D0h] [bp+5D0h]
  int chip_bin; // [sp+5D4h] [bp+5D4h]
  char *v33; // [sp+5D8h] [bp+5D8h]
  int v34; // [sp+5DCh] [bp+5DCh]
  int v35; // [sp+5E0h] [bp+5E0h]
  int v36; // [sp+5E4h] [bp+5E4h]
  int v37; // [sp+5E8h] [bp+5E8h]
  size_t v38; // [sp+5ECh] [bp+5ECh]
  size_t v39; // [sp+5F0h] [bp+5F0h]
  size_t v40; // [sp+5F4h] [bp+5F4h]
  size_t v41; // [sp+5F8h] [bp+5F8h]
  int v42; // [sp+5FCh] [bp+5FCh]
  size_t v43; // [sp+600h] [bp+600h]
  size_t v44; // [sp+604h] [bp+604h]
  json_t *v45; // [sp+608h] [bp+608h]
  json_t *v46; // [sp+60Ch] [bp+60Ch]
  const json_t *v47; // [sp+610h] [bp+610h]
  json_t *v48; // [sp+614h] [bp+614h]
  json_t *v49; // [sp+618h] [bp+618h]
  json_t *v50; // [sp+61Ch] [bp+61Ch]
  json_t *v51; // [sp+620h] [bp+620h]
  json_t *v52; // [sp+624h] [bp+624h]
  json_t *v53; // [sp+628h] [bp+628h]
  json_t *v54; // [sp+62Ch] [bp+62Ch]
  json_t *v55; // [sp+630h] [bp+630h]
  json_t *v56; // [sp+634h] [bp+634h]
  json_t *v57; // [sp+638h] [bp+638h]
  json_t *v58; // [sp+63Ch] [bp+63Ch]
  const json_t *v59; // [sp+640h] [bp+640h]
  json_t *v60; // [sp+644h] [bp+644h]
  const json_t *v61; // [sp+648h] [bp+648h]
  json_t *v62; // [sp+64Ch] [bp+64Ch]
  json_t *v63; // [sp+650h] [bp+650h]
  json_t_0 *v64; // [sp+654h] [bp+654h]
  json_t *v65; // [sp+658h] [bp+658h]
  json_t *v66; // [sp+65Ch] [bp+65Ch]
  json_t *v67; // [sp+660h] [bp+660h]
  json_t *v68; // [sp+664h] [bp+664h]
  json_t *v69; // [sp+668h] [bp+668h]
  json_t *v70; // [sp+66Ch] [bp+66Ch]
  json_t *v71; // [sp+670h] [bp+670h]
  json_t *v72; // [sp+674h] [bp+674h]
  json_t *v73; // [sp+678h] [bp+678h]
  json_t *v74; // [sp+67Ch] [bp+67Ch]
  json_t *v75; // [sp+680h] [bp+680h]
  json_t *v76; // [sp+684h] [bp+684h]
  json_t *v77; // [sp+688h] [bp+688h]
  const json_t *v78; // [sp+68Ch] [bp+68Ch]
  const json_t *file; // [sp+690h] [bp+690h]
  char v80; // [sp+696h] [bp+696h]
  unsigned __int8 v81; // [sp+697h] [bp+697h]
  int v82; // [sp+698h] [bp+698h]
  size_t ii; // [sp+69Ch] [bp+69Ch]
  size_t jj; // [sp+6A0h] [bp+6A0h]
  size_t n; // [sp+6A4h] [bp+6A4h]
  size_t m; // [sp+6A8h] [bp+6A8h]
  size_t j; // [sp+6ACh] [bp+6ACh]
  size_t i; // [sp+6B0h] [bp+6B0h]
  size_t k; // [sp+6B4h] [bp+6B4h]

  file = 0;
  v78 = 0;
  v77 = 0;
  v76 = 0;
  v75 = 0;
  v74 = 0;
  v73 = 0;
  v72 = 0;
  v71 = 0;
  v70 = 0;
  v69 = 0;
  v68 = 0;
  v67 = 0;
  v66 = 0;
  v65 = 0;
  v64 = 0;
  v63 = 0;
  v62 = 0;
  v61 = 0;
  v60 = 0;
  v59 = 0;
  v58 = 0;
  v57 = 0;
  v56 = 0;
  v55 = 0;
  v54 = 0;
  v53 = 0;
  v52 = 0;
  v51 = 0;
  v50 = 0;
  v49 = 0;
  v48 = 0;
  v47 = 0;
  v46 = 0;
  v45 = 0;
  memset(s, 0, sizeof(s));
  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  memset(v27, 0, sizeof(v27));
  memset(v26, 0, sizeof(v26));
  memset(v25, 0, sizeof(v25));
  v44 = 0;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  v37 = 0;
  v36 = 0;
  k = 0;
  i = 0;
  j = 0;
  m = 0;
  n = 0;
  jj = 0;
  v35 = 0;
  v34 = 0;
  v33 = 0;
  ii = 0;
  chip_bin = 0;
  memset(v23, 0, 10);
  v31 = 0;
  v82 = 31;
  v81 = 1;
  v80 = 1;
  memset((void *)" ", 0, 0x800u);
  file = (const json_t *)json_load_file("/mnt/card/MES_system_submit_result_template.ini", 0, (json_error_t *)v24);
  if ( file && !*(_DWORD *)file )
  {
    v33 = json_dumps(file, 0);
    v78 = json_object_get(file, "params");
    if ( v78 && !*(_DWORD *)v78 )
    {
      v77 = json_object_get(v78, "software_commit_id");
      if ( v77 && *(_DWORD *)v77 == 2 )
      {
        json_string_set((int)v77, "d39c5dcea203932a2bf416a5fc01c34eaa1f13d7");
        v76 = json_object_get(v78, "datas");
        if ( v76 && *(_DWORD *)v76 == 1 )
        {
          v44 = json_array_size(v76);
          for ( i = 0; i < v44; ++i )
          {
            v1 = json_array_get(v76, i);
            s[i] = v1;
            if ( !s[i] || *(_DWORD *)s[i] )
            {
              printf("Can't read out datas_array[%d] in datas\n", i);
              v81 = 0;
              goto LABEL_223;
            }
            v75 = json_object_get((const json_t *)s[i], "miner_type");
            if ( !v75 || *(_DWORD *)v75 != 2 )
            {
              printf("Can't read out miner_type in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            json_string_set((int)v75, (const char *)(MES2Local_Config_Information + 16));
            v74 = json_object_get((const json_t *)s[i], "board_name");
            if ( !v74 || *(_DWORD *)v74 != 2 )
            {
              printf("Can't read out board_name in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            json_string_set((int)v74, (const char *)(MES2Local_Config_Information + 32));
            v73 = json_object_get((const json_t *)s[i], "sn");
            if ( !v73 || *(_DWORD *)v73 != 2 )
            {
              printf("Can't read out sn in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            json_string_set((int)v73, ::s);
            v72 = json_object_get((const json_t *)s[i], "order_id");
            if ( !v72 || *(_DWORD *)v72 != 2 )
            {
              printf("Can't read out order_id in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            json_string_set((int)v72, qr_code);
            v71 = json_object_get((const json_t *)s[i], "hardware_version");
            if ( !v71 || *(_DWORD *)v71 != 2 )
            {
              printf("Can't read out hardware_version in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            memset(v23, 48, 0xAu);
            substr(byte_47BF64, 0, 3u, (int)v23);
            json_string_set((int)v71, v23);
            v70 = json_object_get((const json_t *)s[i], "bom_version");
            if ( !v70 || *(_DWORD *)v70 != 2 )
            {
              printf("Can't read out bom_version in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            memset(v23, 48, 0xAu);
            substr(byte_47BF64, 3, 2u, (int)v23);
            json_string_set((int)v70, v23);
            v69 = json_object_get((const json_t *)s[i], "chip_technology");
            if ( !v69 || *(_DWORD *)v69 != 2 )
            {
              printf("Can't read out chip_technology in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            memset(v23, 48, 0xAu);
            substr(byte_47BF64, 5, 2u, (int)v23);
            json_string_set((int)v69, v23);
            v68 = json_object_get((const json_t *)s[i], "ft_version");
            if ( !v68 || *(_DWORD *)v68 != 2 )
            {
              printf("Can't read out ft_version in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            json_string_set((int)v68, src);
            v67 = json_object_get((const json_t *)s[i], "bin");
            if ( !v67 || *(_DWORD *)v67 != 3 )
            {
              printf("Can't read out bin in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            chip_bin = get_chip_bin((int)qr_code);
            if ( chip_bin == 255 )
            {
              printf("chip bin is BIN%d, error\n", 255);
              v81 = 0;
              goto LABEL_223;
            }
            json_integer_set((int)v67, (unsigned int)chip_bin);
            v66 = json_object_get((const json_t *)s[i], "rule_version");
            if ( !v66 || *(_DWORD *)v66 != 2 )
            {
              printf("Can't read out rule_version in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            json_string_set((int)v66, (const char *)(MES2Local_Config_Information + 442));
            v65 = json_object_get((const json_t *)s[i], "rule_level");
            if ( !v65 || *(_DWORD *)v65 != 3 )
            {
              printf("Can't read out rule_level in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            if ( *((unsigned __int8 *)&gHistory_Result + 265800 * a1 + 265796) == 240 )
              json_integer_set((int)v65, (unsigned int)(*((_DWORD *)&gHistory_Result + 66450 * a1 + 4) + 100));
            else
              json_integer_set(
                (int)v65,
                100 * (unsigned int)*((unsigned __int8 *)&gHistory_Result + 265800 * a1 + 265796)
              + *((_DWORD *)&gHistory_Result + 66450 * a1 + 4));
            v64 = json_object_get((const json_t *)s[i], "rule_result");
            if ( !v64 || *(_DWORD *)v64 )
            {
              printf("Can't read out rule_result in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            v63 = json_object_get(v64, "result");
            if ( (!v63 || *(_DWORD *)v63 != 5) && (!v63 || *(_DWORD *)v63 != 6) )
              goto LABEL_62;
            v80 = 1;
            if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 265796) )
            {
              if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 265796) == 1 )
              {
                v82 &= ~1u;
                puts("LOOSE_STANDARD: ASIC_OK, fail");
              }
              else
              {
                v80 = 0;
                v82 &= ~1u;
                v82 &= ~2u;
                puts("PATTERN NG: ASIC_OK, NONCE_RATE_OK, fail");
              }
            }
            else
            {
              puts("STRICT_STANDARD: ASIC_OK, NONCE_RATE_OK");
            }
            if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 2) != 1 )
            {
              v80 = 0;
              v82 &= ~4u;
              puts("EEPROM_OK, fail");
            }
            if ( *(_BYTE *)(MES2Local_Config_Information + 88) && *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) != 1 )
            {
              v80 = 0;
              v82 &= ~8u;
              puts("PIC_SENSOR_OK, fail");
            }
            if ( *(_BYTE *)(MES2Local_Config_Information + 89) && *((_BYTE *)&gHistory_Result + 265800 * a1 + 4) != 1 )
            {
              v80 = 0;
              v82 &= ~0x10u;
              puts("ASIC_SENSOR_OK, fail");
            }
            if ( v80 )
            {
              v2 = (json_t_0 *)json_true();
              json_object_set(v64, "result", v2);
              puts("set result as true");
            }
            else
            {
              v3 = (json_t_0 *)json_false();
              json_object_set(v64, "result", v3);
              puts("set result as false");
            }
            printf("test_result: 0x%08x\n", v82);
            v63 = json_object_get(v64, "result");
            if ( (!v63 || *(_DWORD *)v63 != 5) && (!v63 || *(_DWORD *)v63 != 6) )
            {
LABEL_62:
              printf("Can't read out result in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            if ( *(_DWORD *)v63 == 5 )
              v4 = "true";
            else
              v4 = "false";
            printf("result: %s\n", v4);
            v62 = json_object_get(v64, "sensors");
            if ( !v62 || *(_DWORD *)v62 != 1 )
            {
              printf("Can't read out sensors in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            v43 = json_array_size(v62);
            if ( *(_BYTE *)(MES2Local_Config_Information + 88) != 1 && json_array_remove(v62, 0) )
            {
              printf("Can't remove pic sensors template %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            if ( *(_BYTE *)(MES2Local_Config_Information + 89) != 1 && json_array_remove(v62, 1u) )
            {
              printf("Can't remove asic sensors template %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            v43 = json_array_size(v62);
            for ( j = 0; j < v43; ++j )
            {
              v5 = json_array_get(v62, j);
              v29[j] = v5;
              if ( !v29[j] || *(_DWORD *)v29[j] )
              {
                printf("Can't read out sensors[%d] in sensor\n", j);
                v81 = 0;
                goto LABEL_223;
              }
              v59 = json_object_get((const json_t *)v29[j], "name");
              if ( !v59 || *(_DWORD *)v59 != 2 )
              {
                printf("Can't read out name in sensors[%d]\n", j);
                v81 = 0;
                goto LABEL_223;
              }
              v58 = json_object_get((const json_t *)v29[j], "datas");
              if ( !v58 || *(_DWORD *)v58 != 1 )
              {
                printf("Can't read out datas in sensors_array[%d]\n", j);
                v81 = 0;
                goto LABEL_223;
              }
              v40 = json_array_size(v58);
              for ( k = 0; k < v40; ++k )
              {
                v6 = json_array_get(v58, k);
                v27[k] = v6;
                if ( !v27[k] || *(_DWORD *)v27[k] )
                {
                  printf("Can't read out sensors[%d]->datas[%d]\n", j, k);
                  v81 = 0;
                  goto LABEL_223;
                }
                v57 = json_object_get((const json_t *)v27[k], "id");
                if ( !v57 || *(_DWORD *)v57 != 3 )
                {
                  printf("Can't read out id in sensors[%d]->datas[%d]\n", j, k);
                  v81 = 0;
                  goto LABEL_223;
                }
                json_integer_set((int)v57, k);
                v56 = json_object_get((const json_t *)v27[k], "type");
                if ( !v56 || *(_DWORD *)v56 != 2 )
                {
                  printf("Can't read out type in sensors[%d]->datas[%d]\n", j, k);
                  v81 = 0;
                  goto LABEL_223;
                }
                v7 = json_string_value(v59);
                if ( !strcmp(v7, "PIC") )
                  json_string_set((int)v56, byte_47BF54);
                v8 = json_string_value(v59);
                if ( !strcmp(v8, "CHIP") )
                  json_string_set((int)v56, byte_47BF54);
                v55 = json_object_get((const json_t *)v27[k], "code");
                if ( !v55 || *(_DWORD *)v55 != 2 )
                {
                  printf("Can't read out code in sensors[%d]->datas[%d]\n", j, k);
                  v81 = 0;
                  goto LABEL_223;
                }
                json_string_set((int)v55, "0");
                v54 = json_object_get((const json_t *)v27[k], "msg");
                if ( !v54 || *(_DWORD *)v54 != 2 )
                {
                  printf("Can't read out msg in sensors[%d]->datas[%d]\n", j, k);
                  v81 = 0;
                  goto LABEL_223;
                }
                v9 = json_string_value(v59);
                if ( !strcmp(v9, "PIC") )
                {
                  if ( (v82 & 8) != 0 )
                    json_string_set((int)v54, "ok");
                  else
                    json_string_set((int)v54, "ng");
                }
                v10 = json_string_value(v59);
                if ( !strcmp(v10, "ASIC") )
                {
                  if ( (v82 & 0x10) != 0 )
                    json_string_set((int)v54, "ok");
                  else
                    json_string_set((int)v54, "ng");
                }
                v53 = json_object_get((const json_t *)v27[k], "values");
                if ( !v53 || *(_DWORD *)v53 != 1 )
                {
                  printf("Can't read out values in sensors[%d]->datas[%d]\n", j, k);
                  v81 = 0;
                  goto LABEL_223;
                }
                v39 = json_array_size(v53);
                for ( m = 0; m < v39; ++m )
                {
                  v11 = json_array_get(v53, m);
                  v26[m] = v11;
                  if ( !v26[m] || *(_DWORD *)v26[m] != 3 )
                  {
                    printf("Can't find values[%d] in sensors[%d]->datas[%d]\n", m, j, k);
                    v81 = 0;
                    goto LABEL_223;
                  }
                  v12 = json_string_value(v59);
                  if ( !strcmp(v12, "PIC") )
                    json_integer_set(v26[m], *((char *)&gHistory_Result + 265800 * a1 + k + 265792));
                  v13 = json_string_value(v59);
                  if ( !strcmp(v13, "CHIP") )
                  {
                    if ( !m )
                      json_integer_set(v26[0], *((char *)&gHistory_Result + 265800 * a1 + k + 265784));
                    if ( m == 1 )
                      json_integer_set(v26[1], *((char *)&gHistory_Result + 265800 * a1 + k + 265788));
                  }
                }
              }
            }
            v61 = json_object_get(v64, "pattern");
            if ( !v61 || *(_DWORD *)v61 )
            {
              printf("Can't read out pattern in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            v52 = json_object_get(v61, "nonce_rate");
            if ( !v52 || *(_DWORD *)v52 != 3 )
            {
              puts("Can't read out nonce_rate in pattern");
              v81 = 0;
              goto LABEL_223;
            }
            v31 = (unsigned int)(*((double *)&gHistory_Result + 33225 * a1 + 1) * 100.0);
            json_integer_set((int)v52, v31);
            v51 = json_object_get(v61, "code");
            if ( !v51 || *(_DWORD *)v51 != 2 )
            {
              puts("Can't read out code in pattern");
              v81 = 0;
              goto LABEL_223;
            }
            json_string_set((int)v51, "0");
            v50 = json_object_get(v61, "msg");
            if ( !v50 || *(_DWORD *)v50 != 2 )
            {
              puts("Can't read out msg in pattern");
              v81 = 0;
              goto LABEL_223;
            }
            if ( *((unsigned __int8 *)&gHistory_Result + 265800 * a1 + 265796) == 240 )
              json_string_set((int)v50, "ng");
            else
              json_string_set((int)v50, "ok");
            v49 = json_object_get(v61, "asic_number");
            if ( !v49 || *(_DWORD *)v49 != 3 )
            {
              puts("Can't read out asic_number in pattern");
              v81 = 0;
              goto LABEL_223;
            }
            json_integer_set((int)v49, *(unsigned int *)(MES2Local_Config_Information + 64));
            v48 = json_object_get(v61, "asic_nonces");
            if ( !v48 || *(_DWORD *)v48 != 1 )
            {
              puts("Can't read out asic_nonces in pattern");
              v81 = 0;
              goto LABEL_223;
            }
            v38 = json_array_size(v48);
            for ( n = 0; n < v38; ++n )
            {
              v14 = json_array_get(v48, n);
              v25[n] = v14;
              if ( !v25[n] || *(_DWORD *)v25[n] != 3 )
              {
LABEL_178:
                printf("Can't find asic_nonces[%d] in pattern\n", n);
                v81 = 0;
                goto LABEL_223;
              }
            }
            for ( ii = v38; ; ++ii )
            {
              v15 = json_integer_value(v49);
              if ( v15 <= ii )
                break;
              v25[ii] = json_integer(ii);
              json_array_append(v48, (json_t_0 *)v25[ii]);
            }
            v38 = json_array_size(v48);
            for ( n = 0; n < v38; ++n )
            {
              v16 = json_array_get(v48, n);
              v25[n] = v16;
              if ( !v25[n] || *(_DWORD *)v25[n] != 3 )
                goto LABEL_178;
              json_integer_set(v25[n], *((unsigned int *)&gHistory_Result + 66450 * a1 + n + 65546));
            }
            v60 = json_object_get(v64, "commons");
            if ( !v60 || *(_DWORD *)v60 != 1 )
            {
              printf("Can't read out commons in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
              v81 = 0;
              goto LABEL_223;
            }
            v41 = json_array_size(v60);
            for ( jj = 0; jj < v41; ++jj )
            {
              v17 = json_array_get(v60, jj);
              v28[jj] = v17;
              if ( !v28[jj] || *(_DWORD *)v28[jj] )
              {
                printf("Can't read out commons[%d]\n", jj);
                v81 = 0;
                goto LABEL_223;
              }
              v47 = json_object_get((const json_t *)v28[jj], "name");
              if ( !v47 || *(_DWORD *)v47 != 2 )
              {
                printf("Can't read out name in commons[%d]\n", jj);
                v81 = 0;
                goto LABEL_223;
              }
              v46 = json_object_get((const json_t *)v28[jj], "code");
              if ( !v46 || *(_DWORD *)v46 != 2 )
              {
                printf("Can't read out code in commons[%d]\n", jj);
                v81 = 0;
                goto LABEL_223;
              }
              json_string_set((int)v46, "0");
              v45 = json_object_get((const json_t *)v28[jj], "msg");
              if ( !v45 || *(_DWORD *)v45 != 2 )
              {
                printf("Can't read out msg in commons[%d]\n", jj);
                v81 = 0;
                goto LABEL_223;
              }
              v18 = json_string_value(v47);
              if ( !strcmp(v18, "eeprom") )
              {
                if ( (v82 & 4) != 0 )
                  json_string_set((int)v45, "ok");
                else
                  json_string_set((int)v45, "ng");
              }
              v19 = json_string_value(v47);
              if ( !strcmp(v19, "pic") )
              {
                if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 6) )
                  json_string_set((int)v45, "ok");
                else
                  json_string_set((int)v45, "ng");
              }
              v20 = json_string_value(v47);
              if ( !strcmp(v20, "power") )
              {
                if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 5) )
                  json_string_set((int)v45, "ok");
                else
                  json_string_set((int)v45, "ng");
              }
            }
          }
          v33 = json_dumps(file, 0);
          mes_system_submit_result_file_length = strlen(v33);
          memcpy((void *)" ", v33, mes_system_submit_result_file_length);
          printf("size: %d, content: %s\n", mes_system_submit_result_file_length, " ");
        }
        else
        {
          printf("Can't read out datas in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
          v81 = 0;
        }
      }
      else
      {
        printf("Can't read out software_commit_id in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
        v81 = 0;
      }
    }
    else
    {
      printf("Can't read out params in %s\n", "/mnt/card/MES_system_submit_result_template.ini");
      v81 = 0;
    }
  }
  else
  {
    printf("Can't read out %s file.\n", "/mnt/card/MES_system_submit_result_template.ini");
    v81 = 0;
  }
LABEL_223:
  if ( file )
    sub_2E8A8((int)file);
  return v81;
}
// 3383A: conditional instruction was optimized away because %var_6C.4!=0
// 1F0D24: using guessed type int mes_system_submit_result_file_length;
// 479D9C: using guessed type int MES2Local_Config_Information;
// 47BE7C: using guessed type int dword_47BE7C;

//----- (0003463C) --------------------------------------------------------
int submit_result_to_MES_system()
{
  unsigned int v2; // [sp+4h] [bp+4h] BYREF
  _BYTE v3[252]; // [sp+8h] [bp+8h] BYREF
  char *v4; // [sp+104h] [bp+104h]
  unsigned __int8 v5; // [sp+10Bh] [bp+10Bh]
  const json_t *v6; // [sp+10Ch] [bp+10Ch]

  v6 = 0;
  v2 = 0;
  v4 = 0;
  v5 = 1;
  putchar(32);
  if ( (unsigned __int8)create_connection_to_MES_system_by_name(2) != 1 )
    return 0;
  v5 = send_message_to_bitmain_MES_system(" ", mes_system_submit_result_file_length);
  if ( v5 != 1 )
  {
    puts("send submit result information fail");
    return 0;
  }
  v4 = receive_message_from_bitmain_MES_system(&v2);
  if ( !v4 )
    goto LABEL_11;
  printf("length: %d, submit_result_response: %s\n", v2, v4);
  v6 = (const json_t *)json_loadb((int)v4, v2 - 1, 0, (json_error_t *)v3);
  if ( v6 && !*(_DWORD *)v6 )
  {
    if ( check_whether_MES_system_submit_result_is_correct(v6) )
    {
      puts("submit result success");
      v5 = 1;
      goto LABEL_12;
    }
LABEL_11:
    puts("submit result fail");
    v5 = 0;
    goto LABEL_12;
  }
  puts("Don't get all respons after submit result");
  v5 = 0;
LABEL_12:
  if ( v6 )
    sub_2E8A8((int)v6);
  if ( bitmain_MES_system_clientSocket != -1 )
  {
    close(bitmain_MES_system_clientSocket);
    bitmain_MES_system_clientSocket = -1;
    puts("close socket");
  }
  return v5;
}
// 1EC650: using guessed type int bitmain_MES_system_clientSocket;
// 1F0D24: using guessed type int mes_system_submit_result_file_length;

//----- (000347BC) --------------------------------------------------------
int save_MES_system_submit_result()
{
  FILE *s; // [sp+4h] [bp+4h]

  memset(submit_result_file, 0, 0xC8u);
  strcpy(submit_result_file, base_submit_result_file);
  strcat(submit_result_file, (const char *)(MES2Local_Config_Information + 16));
  *(_WORD *)&submit_result_file[strlen(submit_result_file)] = 45;
  strcat(submit_result_file, (const char *)(MES2Local_Config_Information + 32));
  *(_WORD *)&submit_result_file[strlen(submit_result_file)] = 45;
  strcat(submit_result_file, ::s);
  printf("Save MES system config information into %s\n", submit_result_file);
  s = fopen(submit_result_file, "w");
  if ( s )
  {
    printf("Open %s success\n", submit_result_file);
    if ( fwrite(&submit_result_handshake_information, mes_system_submit_result_file_length, 1u, s) == 1 )
    {
      printf("Write %s success\n", submit_result_file);
      fclose(s);
      system("sync");
      return 1;
    }
    else
    {
      printf("Write %s fail\n", submit_result_file);
      fclose(s);
      return 0;
    }
  }
  else
  {
    printf("Open %s fail\n", submit_result_file);
    return 0;
  }
}
// 1F0D24: using guessed type int mes_system_submit_result_file_length;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (00034948) --------------------------------------------------------
int __fastcall sub_34948(int a1)
{
  char v3[68]; // [sp+10h] [bp+8h] BYREF
  char s[68]; // [sp+54h] [bp+4Ch] BYREF
  int j; // [sp+98h] [bp+90h]
  int i; // [sp+9Ch] [bp+94h]

  memset(s, 0, 0x41u);
  memset(v3, 0, 0x41u);
  for ( i = 0; i <= 31; ++i )
    sprintf(&s[2 * i], "%02x", *(unsigned __int8 *)(i + a1 + 34));
  for ( j = 0; j <= 31; ++j )
    sprintf(&v3[2 * j], "%02x", *(unsigned __int8 *)(j + a1 + 98));
  printf(
    "nonce_recv: asic %02d core %02d pe %02d ",
    *(_DWORD *)(a1 + 8),
    *(_DWORD *)(a1 + 12),
    (unsigned int)(*(__int64 *)(a1 + 26) >> 9) & 7);
  return printf("header %s nonce %016llx mixhash %s\n", s, *(_QWORD *)(a1 + 26), v3);
}

//----- (00034A64) --------------------------------------------------------
unsigned __int64 __fastcall sub_34A64(unsigned __int64 *a1)
{
  return _byteswap_uint64(*a1);
}

//----- (00034B74) --------------------------------------------------------
int __fastcall pcba_eth_recv(int a1)
{
  _WORD s[66]; // [sp+8h] [bp+8h] BYREF
  int v5; // [sp+8Ch] [bp+8Ch]
  unsigned __int64 v6; // [sp+90h] [bp+90h]

  v6 = 0;
  memset(s, 0, 0x82u);
  (*(void (__fastcall **)(int, _WORD *))(a1 + 32))(a1, s);
  pthread_mutex_lock(&stru_1F0D6C);
  v5 = dword_1F0D68;
  pthread_mutex_unlock(&stru_1F0D6C);
  if ( !v5 )
    return 0;
  v6 = sub_34A64((unsigned __int64 *)(v5 + 56));
  if ( *(_QWORD *)&s[13] != v6 || memcmp((const void *)(v5 + 64), &s[49], 0x20u) )
    return 0;
  *(_BYTE *)(v5 + 96) = 1;
  need_pattern = 1;
  return 1;
}
// 1EC5C4: using guessed type char need_pattern;
// 1F0D68: using guessed type int dword_1F0D68;
// 1F0D6C: using guessed type pthread_mutex_t stru_1F0D6C;

//----- (00034C3C) --------------------------------------------------------
int __fastcall pcba_eth_send(int a1, int a2)
{
  int v2; // r1
  int v3; // r2
  int v4; // r3
  int v5; // r1
  int v6; // r2
  int v7; // r3
  _BYTE s[89]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int64 v11; // [sp+68h] [bp+68h]
  int v12; // [sp+74h] [bp+74h]

  v12 = a2;
  v11 = 0;
  memset(s, 0, sizeof(s));
  v11 = sub_34A64((unsigned __int64 *)(v12 + 56));
  *(_QWORD *)&s[80] = v11;
  v2 = *(_DWORD *)(v12 + 28);
  v3 = *(_DWORD *)(v12 + 32);
  v4 = *(_DWORD *)(v12 + 36);
  *(_DWORD *)&s[16] = *(_DWORD *)(v12 + 24);
  *(_DWORD *)&s[20] = v2;
  *(_DWORD *)&s[24] = v3;
  *(_DWORD *)&s[28] = v4;
  v5 = *(_DWORD *)(v12 + 44);
  v6 = *(_DWORD *)(v12 + 48);
  v7 = *(_DWORD *)(v12 + 52);
  *(_DWORD *)&s[32] = *(_DWORD *)(v12 + 40);
  *(_DWORD *)&s[36] = v5;
  *(_DWORD *)&s[40] = v6;
  *(_DWORD *)&s[44] = v7;
  return (*(int (__fastcall **)(int, _BYTE *))(a1 + 24))(a1, s);
}

//----- (00034CB0) --------------------------------------------------------
int __fastcall pcba_eth_stage_send_work(int a1)
{
  pthread_mutex_lock(&stru_1F0D6C);
  dword_1F0D68 = a1;
  return pthread_mutex_unlock(&stru_1F0D6C);
}
// 1F0D68: using guessed type int dword_1F0D68;
// 1F0D6C: using guessed type pthread_mutex_t stru_1F0D6C;

//----- (00034CE4) --------------------------------------------------------
int __fastcall pcba_read_eth_temperature(
        int a1,
        _DWORD *a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7)
{
  int v13; // [sp+24h] [bp+14h] BYREF
  int v14; // [sp+28h] [bp+18h] BYREF
  int v15; // [sp+2Ch] [bp+1Ch] BYREF
  int v16; // [sp+30h] [bp+20h] BYREF
  _DWORD *v17; // [sp+34h] [bp+24h]
  _DWORD *v18; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]

  v18 = *(_DWORD **)(a1 + 212);
  *a2 = -150;
  *a3 = 150;
  *a4 = -150;
  *a5 = 150;
  for ( i = 0; v18[1] > i; ++i )
  {
    v17 = (_DWORD *)(20 * i + *v18);
    v14 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 100))(
      a1,
      &v16,
      &v14,
      *v17,
      v17[1],
      v17[2],
      v17[3],
      v17[4]);
    if ( v14 )
    {
      ++*a6;
      if ( *a2 < v16 )
        *a2 = v16;
      if ( *a3 > v16 )
        *a3 = v16;
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + i + 265784) = v16;
    }
    v13 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 104))(
      a1,
      &v15,
      &v13,
      *v17,
      v17[1],
      v17[2],
      v17[3],
      v17[4]);
    if ( v13 )
    {
      ++*a7;
      if ( *a4 < v15 )
        *a4 = v15;
      if ( *a5 > v15 )
        *a5 = v15;
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + i + 265788) = v15;
    }
  }
  if ( *a6 == v18[1] && *a7 == v18[1] )
    return 0;
  else
    return -1;
}
// 47BE7C: using guessed type int dword_47BE7C;

//----- (00034E7C) --------------------------------------------------------
int __fastcall pcba_eth_reg_init(int a1, int a2)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  v3 = a2;
  *(_DWORD *)(a1 + 304) = 1;
  return (*(int (__fastcall **)(int, int *))(a1 + 40))(a1, &v3);
}

//----- (00034EA8) --------------------------------------------------------
int __fastcall pcba_eth_stop_mining(int a1)
{
  return (*(int (__fastcall **)(int))(a1 + 8))(a1);
}

//----- (00034EC0) --------------------------------------------------------
int pcba_is_eth_asic_valid()
{
  return 1;
}

//----- (00034ED8) --------------------------------------------------------
int pcba_calc_eth_core_num()
{
  return *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12);
}
// 1F0C98: using guessed type int g_config_info;

//----- (00034EFC) --------------------------------------------------------
int __fastcall pcba_calc_eth_pe_num(int result, int *a2, int *a3)
{
  int v5; // [sp+10h] [bp+10h]
  int v6; // [sp+14h] [bp+14h]

  v6 = 0;
  v5 = 0;
  switch ( result )
  {
    case 0:
    case 1:
    case 2:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
    case 14:
    case 15:
      v6 = 0;
      v5 = 6;
      break;
    case 3:
      v6 = 4;
      v5 = 6;
      break;
    case 4:
    case 12:
      v6 = 15;
      v5 = 0;
      break;
    default:
      result = puts("error! wrong pe id");
      break;
  }
  *a2 = v6;
  *a3 = v5;
  return result;
}

//----- (00034F9C) --------------------------------------------------------
int pcba_calc_eth_jig_level()
{
  float v0; // s0
  int v1; // r3
  int v3; // [sp+Ch] [bp+Ch]

  v3 = (int)(float)(v0 * 100.0);
  if ( v3 > 9499 )
    return 0;
  if ( v3 <= 9498 && v3 > 8999 )
    return 1;
  if ( v3 <= 8998 && v3 > 8499 )
    return 2;
  if ( v3 <= 8498 && v3 >= 8000 )
    return 3;
  if ( v3 <= 7998 && v3 > 6999 )
    return 4;
  if ( v3 <= 6998 && v3 > 5999 )
    return 5;
  if ( v3 <= 5998 && v3 > 4999 )
    return 6;
  if ( v3 <= 4998 && v3 > 2999 )
    return 7;
  v1 = (int)(float)(v0 * 100.0);
  if ( v3 <= 2998 )
    return 8;
  return v1;
}
// 34FAE: variable 'v0' is possibly undefined

//----- (00035090) --------------------------------------------------------
void pcba_statistic_eth_pattern_test_results()
{
  ;
}

//----- (000350AC) --------------------------------------------------------
int pcba_check_nonce_eth()
{
  return 0;
}

//----- (000350C4) --------------------------------------------------------
int32_t detect_scan_code_gun()
{
  _DWORD s[73]; // [sp+4h] [bp+4h] BYREF
  unsigned int j; // [sp+128h] [bp+128h]
  unsigned int i; // [sp+12Ch] [bp+12Ch]

  i = 0;
  j = 0;
  memset(s, 0, sizeof(s));
  get_system_capability(s);
  for ( i = 0; s[0] > i; ++i )
  {
    for ( j = 0; s[18 * i + 2] > j; ++j )
    {
      if ( s[18 * i + 3 + j] == 3 )
        return 0;
    }
  }
  return -1;
}

//----- (0003516C) --------------------------------------------------------
int __fastcall sub_3516C(const char *a1, _BYTE *a2, _BYTE *a3, const char *a4, _BYTE *a5)
{
  int v6; // r3
  char s[256]; // [sp+30h] [bp+18h] BYREF
  int v13; // [sp+130h] [bp+118h]
  size_t i; // [sp+134h] [bp+11Ch]

  i = 0;
  v13 = 0;
  memset(s, 0, sizeof(s));
  if ( !a1 || !a2 || !a3 || !a4 || !a5 )
    return -1;
  if ( *a1 )
  {
    printf("scan_code_data::%s", a1);
    memset(s, 0, sizeof(s));
    for ( i = 0; strlen(a1) > i; ++i )
    {
      if ( (unsigned __int8)a1[i] > 0x1Fu && (unsigned __int8)a1[i] <= 0x7Eu )
      {
        v6 = v13++;
        s[v6] = a1[i];
      }
    }
    printf("after check, scan_code_data::%s", s);
    if ( strchr(s, 32) )
    {
      *a5 = 1;
      _isoc99_sscanf(s, "%s %s %s %s %s %s %s %s", a4, a4 + 32, a4 + 48, a4 + 64, a4 + 80, a4 + 96, a4 + 112, a4 + 128);
      puts("recv qrcode data::");
      printf("factory_job::[%s].\n", a4);
      printf("chip_die::[%s].\n", a4 + 32);
      printf("chip_marking::[%s].\n", a4 + 48);
      printf("chip_bin::[%s].\n", a4 + 64);
      printf("chip_ftversion::[%s].\n", a4 + 80);
      printf("temp_sensor_type::[%s].\n", a4 + 96);
      printf("hashboard_ctrl_code::[%s].\n", a4 + 112);
      printf("hashboard_index::[%s].\n", a4 + 128);
    }
    else
    {
      if ( strlen(s) != 17 )
      {
        puts("bad data format!!!drop it.");
        return -3;
      }
      *a3 = 1;
      memset(a2 + 1, 0, 0x20u);
      *a2 = 17;
      memcpy(a2 + 1, s, 0x11u);
      printf("recv sn data::[%s]\n", a2 + 1);
    }
    return 0;
  }
  return -2;
}
// 20908: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (00035448) --------------------------------------------------------
int32_t __cdecl recv_scan_data(char *recv_buffer, int32_t length)
{
  int32_t v3; // r3
  int32_t readable_byte_num; // [sp+Ch] [bp+Ch]

  readable_byte_num = uart_get_readable_byte_num(3);
  if ( readable_byte_num <= 0 )
    return -1;
  v3 = readable_byte_num;
  if ( readable_byte_num >= length )
    v3 = length;
  return uart_receive(3, (int)recv_buffer, v3);
}

//----- (00035488) --------------------------------------------------------
int flush_scanner_data()
{
  dword_1F0D84 = 0;
  dword_1ED16C = 255;
  memset(&unk_1F0D88, 0, 0x100u);
  return uart_flush(3);
}
// 1ED16C: using guessed type int dword_1ED16C;
// 1F0D84: using guessed type int dword_1F0D84;

//----- (000354CC) --------------------------------------------------------
int __fastcall scan_hashboard_info(char a1, _BYTE *a2, const char *a3, _BYTE *a4, _BYTE *a5, int a6)
{
  char s[12]; // [sp+1Ch] [bp+14h] BYREF
  char *v12; // [sp+28h] [bp+20h]
  char *v13; // [sp+2Ch] [bp+24h]
  char *v14; // [sp+30h] [bp+28h]
  char *src; // [sp+34h] [bp+2Ch]

  src = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  if ( a1 != 3 )
  {
    printf("%s scanner chain number is wrong!!!\n", "scan_hashboard_info");
    return -1;
  }
  while ( 1 )
  {
    memset(s, 0, 0xAu);
    if ( recv_scan_data(s, 9) > 0 )
      break;
    a6 -= 10;
    usleep(0x2710u);
LABEL_21:
    usleep(0x1388u);
    a6 -= 5;
    if ( a6 <= 0 )
      goto LABEL_22;
  }
  v12 = strstr(s, "\r\n");
  v14 = strchr(s, 10);
  v13 = strchr(s, 13);
  if ( !v12 && !v14 && !v13 )
  {
    if ( strlen(s) > dword_1ED16C )
    {
      memset(byte_1F0D88, 0, sizeof(byte_1F0D88));
      dword_1F0D84 = 0;
    }
    strcpy(&byte_1F0D88[dword_1F0D84], s);
    goto LABEL_20;
  }
  if ( v12 )
  {
    *v12 = 0;
    src = v12 + 2;
  }
  else if ( v13 )
  {
    *v13 = 0;
    src = v13 + 1;
  }
  else
  {
    *v14 = 0;
    src = v14 + 1;
  }
  if ( strlen(s) > dword_1ED16C
    || (strcpy(&byte_1F0D88[dword_1F0D84], s), sub_3516C(byte_1F0D88, a2, a4, a3, a5), !*a4)
    || !*a5 )
  {
    memset(byte_1F0D88, 0, sizeof(byte_1F0D88));
    strcpy(byte_1F0D88, src);
LABEL_20:
    dword_1F0D84 = strlen(byte_1F0D88);
    dword_1ED16C = 255 - strlen(byte_1F0D88);
    goto LABEL_21;
  }
LABEL_22:
  if ( *a4 && *a5 )
    return 0;
  else
    return -1;
}
// 1ED16C: using guessed type int dword_1ED16C;
// 1F0D84: using guessed type int dword_1F0D84;

//----- (00035700) --------------------------------------------------------
int __fastcall get_chip_bin(int a1)
{
  switch ( *(_BYTE *)(a1 + 67) )
  {
    case '1':
      return 1;
    case '2':
      return 2;
    case '3':
      return 3;
    case '4':
      return 4;
    case '5':
      return 5;
  }
  printf("Can't get chip bin number. chip_bin: %s\n", (const char *)(a1 + 64));
  return 255;
}

//----- (0003576C) --------------------------------------------------------
int __fastcall get_chip_ft_program_version(_BYTE *a1, unsigned __int8 *a2)
{
  char nptr; // [sp+14h] [bp+Ch] BYREF
  char v7; // [sp+15h] [bp+Dh]
  char v8; // [sp+16h] [bp+Eh]

  nptr = 0;
  v7 = 0;
  v8 = 0;
  if ( a1[80] == 70 )
  {
    nptr = a1[81];
    *a2 = atoi(&nptr);
    printf("F%d", *a2);
    if ( a1[82] == 86 )
    {
      nptr = a1[83];
      v7 = a1[84];
      a2[1] = atoi(&nptr);
      printf("V%d", a2[1]);
      if ( a1[85] == 66 )
      {
        nptr = a1[86];
        v7 = 0;
        a2[2] = atoi(&nptr);
        printf("B%d", a2[2]);
        if ( a1[87] == 67 )
        {
          nptr = a1[88];
          a2[3] = atoi(&nptr);
          printf("C%d", a2[3]);
          printf("FT version: F%dV%02dB%dC%d\n", *a2, a2[1], a2[2], a2[3]);
          return 1;
        }
        else
        {
          printf("4th FT version is not C, but is %c\n", (unsigned __int8)a1[87]);
          return 0;
        }
      }
      else
      {
        printf("3rd FT version is not B, but is %c\n", (unsigned __int8)a1[85]);
        return 0;
      }
    }
    else
    {
      printf("2nd FT version is not V, but is %c\n", (unsigned __int8)a1[82]);
      return 0;
    }
  }
  else
  {
    printf("1st FT version is not F, but is %c\n", (unsigned __int8)a1[80]);
    return 0;
  }
}

//----- (00035910) --------------------------------------------------------
int __fastcall get_chip_ft_program_version_ex(int a1, int a2)
{
  char s[40]; // [sp+Ch] [bp+Ch] BYREF
  unsigned int v7; // [sp+34h] [bp+34h]
  char v8; // [sp+3Bh] [bp+3Bh]
  size_t v9; // [sp+3Ch] [bp+3Ch]
  char v10; // [sp+42h] [bp+42h]
  char v11; // [sp+43h] [bp+43h]
  size_t i; // [sp+44h] [bp+44h]
  int v13; // [sp+48h] [bp+48h]
  unsigned int v14; // [sp+4Ch] [bp+4Ch]
  _WORD vars0[4]; // [sp+50h] [bp+50h] BYREF

  v14 = 0;
  v13 = 0;
  i = 0;
  v9 = 0;
  v11 = 0;
  v10 = 0;
  v8 = 0;
  v7 = 0;
  memset(s, 0, sizeof(s));
  v9 = strlen((const char *)(a1 + 80)) + 1;
  for ( i = 0; i < v9; ++i )
  {
    if ( *(unsigned __int8 *)(i + a1 + 80) <= 0x2Fu || *(unsigned __int8 *)(i + a1 + 80) > 0x39u )
    {
      if ( v10 )
      {
        v11 = 1;
        v10 = 0;
      }
    }
    else
    {
      v10 = 1;
      *((_BYTE *)&vars0[5 * v14 - 34] + v13++) = *(_BYTE *)(i + a1 + 80);
    }
    if ( v11 )
    {
      if ( v14 > 3 )
      {
        printf("There are too many number sector in ft version: %s, error.\n", (const char *)(a1 + 80));
        return 0;
      }
      v7 = atoi(&s[10 * v14]);
      if ( v7 >= 0x100 )
      {
        printf("FT version: %dst number: %d, error\n", v14, v7);
        return 0;
      }
      *(_BYTE *)(v14 + a2) = v7;
      ++v14;
      v13 = 0;
      v11 = 0;
    }
  }
  return 1;
}

//----- (00035A68) --------------------------------------------------------
int __fastcall get_hardware_infor(char *a1)
{
  char nptr; // [sp+Ch] [bp+Ch] BYREF
  char v4; // [sp+Dh] [bp+Dh]
  char v5; // [sp+Eh] [bp+Eh]

  nptr = 0;
  v4 = 0;
  v5 = 0;
  nptr = a1[112];
  byte_47BFF8 = atoi(&nptr);
  printf("pcb_version_v1 = %d\n", (unsigned __int8)byte_47BFF8);
  nptr = a1[113];
  v4 = a1[114];
  byte_47BFF9 = atoi(&nptr);
  printf("pcb_version_v2 = %02d\n", (unsigned __int8)byte_47BFF9);
  nptr = a1[115];
  v4 = 0;
  byte_47BFFA = atoi(&nptr);
  printf("bom_version_v1 = %d\n", (unsigned __int8)byte_47BFFA);
  nptr = a1[116];
  byte_47BFFB = atoi(&nptr);
  return printf("bom_version_v2 = %d\n", (unsigned __int8)byte_47BFFB);
}
// 47BFF8: using guessed type char byte_47BFF8;
// 47BFF9: using guessed type char byte_47BFF9;
// 47BFFA: using guessed type char byte_47BFFA;
// 47BFFB: using guessed type char byte_47BFFB;

//----- (00035B80) --------------------------------------------------------
void __cdecl get_chip_technology(hashboard_qr_code *qr_code)
{
  byte_47BFFC = *((_BYTE *)qr_code + 117);
  byte_47BFFD = *((_BYTE *)qr_code + 118);
}
// 47BFFC: using guessed type char byte_47BFFC;
// 47BFFD: using guessed type char byte_47BFFD;

//----- (00035BB8) --------------------------------------------------------
int __fastcall sub_35BB8(int a1, unsigned __int8 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  (*(void (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
  return 1;
}

//----- (00035C00) --------------------------------------------------------
int __fastcall sub_35C00(int a1, unsigned __int8 a2, signed int a3, int a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _WORD s[8]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]
  signed int j; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]

  ptr = calloc(a3, 0xCu);
  memset(s, 0, sizeof(s));
  s[4] = 1;
  s[5] = a2;
  memset(ptr, 0, 12 * a3);
  (*(void (__fastcall **)(int, _WORD *, signed int, void *, int *))(a1 + 176))(a1, s, a3, ptr, &v9);
  for ( i = 0; i < v9; ++i )
  {
    for ( j = 0; j < a3; ++j )
    {
      if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) && a4 )
      {
        *(_BYTE *)(a4 + 8 * i) = *((_BYTE *)ptr + 12 * i + 4);
        *(_BYTE *)(a4 + 8 * i + 1) = *((_WORD *)ptr + 6 * i + 3);
        *(_DWORD *)(a4 + 8 * i + 4) = *((_DWORD *)ptr + 3 * i);
        break;
      }
    }
  }
  free(ptr);
  return v9;
}

//----- (00035D38) --------------------------------------------------------
bool __fastcall sub_35D38(unsigned int a1)
{
  return ((HIBYTE(a1) | ((a1 & 0xFF0000) >> 8)) & 1) != 0;
}

//----- (00035D80) --------------------------------------------------------
int __fastcall sub_35D80(int a1, const char *a2, int a3, int a4, int a5)
{
  char s[32]; // [sp+28h] [bp+10h] BYREF
  unsigned int v11; // [sp+48h] [bp+30h]
  int i; // [sp+4Ch] [bp+34h]
  int j; // [sp+50h] [bp+38h]
  int v14; // [sp+54h] [bp+3Ch]

  v14 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      printf("%s unkonw error, exit\n", a2);
      sleep(1u);
      exit(1);
    }
    memset(&ret_str, 0, 0x40u);
    sprintf((char *)&ret_str, "%s error:", (const char *)&unk_1ED200 + 36 * (_DWORD)a2 + 20);
    for ( i = 0; i < a3; ++i )
    {
      printf(
        "%s[%d] ctrl [%02x %02x %08x], result [%02x %02x %08x]\n",
        "pcba_hbm_error_display",
        147,
        *(unsigned __int8 *)(8 * i + a4),
        *(unsigned __int8 *)(8 * i + a4 + 1),
        *(_DWORD *)(8 * i + a4 + 4),
        *(unsigned __int8 *)(8 * i + a5),
        *(unsigned __int8 *)(8 * i + a5 + 1),
        *(_DWORD *)(8 * i + a5 + 4));
      memset(s, 0, sizeof(s));
      v11 = (*(_DWORD *)(8 * i + a4 + 4) << 24)
          | HIBYTE(*(_DWORD *)(8 * i + a4 + 4))
          | ((*(_DWORD *)(8 * i + a4 + 4) & 0xFF0000u) >> 8)
          | ((*(_DWORD *)(8 * i + a4 + 4) & 0xFF00) << 8);
      if ( (v11 & 4) != 0 )
      {
        sprintf(s, "[%02x s0]", *(unsigned __int8 *)(8 * i + a4));
        strcat((char *)&ret_str, s);
        ++v14;
      }
      if ( (v11 & 2) != 0 )
      {
        memset(s, 0, sizeof(s));
        sprintf(s, "[%02x s1]", *(unsigned __int8 *)(8 * i + a4));
        strcat((char *)&ret_str, s);
        ++v14;
      }
      v11 = (*(_DWORD *)(8 * i + a5 + 4) << 24)
          | HIBYTE(*(_DWORD *)(8 * i + a5 + 4))
          | ((*(_DWORD *)(8 * i + a5 + 4) & 0xFF0000u) >> 8)
          | ((*(_DWORD *)(8 * i + a5 + 4) & 0xFF00) << 8);
      if ( v11 )
      {
        memset(s, 0, sizeof(s));
        sprintf(s, "[%02x c%08x]", *(unsigned __int8 *)(8 * i + a5), v11);
        strcat((char *)&ret_str, s);
        ++v14;
      }
    }
  }
  else
  {
    memset(&ret_str, 0, 0x40u);
    sprintf((char *)&ret_str, "%s timeout:", (const char *)&unk_1ED200 + 36 * (_DWORD)a2 + 20);
    for ( j = 0; j < a3; ++j )
    {
      printf(
        "%s[%d] chip-%02x ctrl [%02x %08x]\n",
        "pcba_hbm_error_display",
        130,
        *(unsigned __int8 *)(8 * j + a4),
        *(unsigned __int8 *)(8 * j + a4 + 1),
        *(_DWORD *)(8 * j + a4 + 4));
      memset(s, 0, sizeof(s));
      if ( sub_35D38(*(_DWORD *)(8 * j + a4 + 4)) )
      {
        sprintf(s, "[%02x]", *(unsigned __int8 *)(8 * j + a4));
        strcat((char *)&ret_str, s);
        ++v14;
      }
    }
  }
  if ( v14 )
  {
    printf("%s failed\n", (const char *)&unk_1ED200 + 36 * (_DWORD)a2 + 20);
    return 0;
  }
  else
  {
    printf("%s success\n", (const char *)&unk_1ED200 + 36 * (_DWORD)a2 + 20);
    return 1;
  }
}
// 479D5C: using guessed type int ret_str;

//----- (0003612C) --------------------------------------------------------
int __fastcall sub_3612C(int a1, const char *a2)
{
  int v2; // r3
  int v4; // r3
  void *s; // [sp+10h] [bp+8h]
  int v9; // [sp+14h] [bp+Ch]
  _DWORD *ptr; // [sp+18h] [bp+10h]
  signed int nmemb; // [sp+1Ch] [bp+14h]
  signed int i; // [sp+20h] [bp+18h]
  int v13; // [sp+24h] [bp+1Ch]
  int v14; // [sp+28h] [bp+20h]
  int v15; // [sp+28h] [bp+20h]
  unsigned __int8 v16; // [sp+2Fh] [bp+27h]

  nmemb = *(_DWORD *)(a1 + 196);
  ptr = calloc(nmemb, 8u);
  v16 = 0;
  v14 = 0;
  while ( 1 )
  {
    v2 = v14++;
    if ( v2 > 29 )
      break;
    if ( sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * (_DWORD)a2 + 4), nmemb, (int)ptr) == nmemb )
    {
      v13 = 0;
      for ( i = 0; i < nmemb; ++i )
      {
        if ( sub_35D38(ptr[2 * i + 1]) )
        {
          printf(
            "%s[%d] chip-%02x is still testing [%02x, %08x]\n",
            "pcba_hbm_test",
            211,
            LOBYTE(ptr[2 * i]),
            BYTE1(ptr[2 * i]),
            ptr[2 * i + 1]);
        }
        else
        {
          ++v13;
          printf(
            "%s[%d] chip-%02x test done [%02x, %08x]\n",
            "pcba_hbm_test",
            209,
            LOBYTE(ptr[2 * i]),
            BYTE1(ptr[2 * i]),
            ptr[2 * i + 1]);
        }
      }
      if ( v13 == nmemb )
      {
        v16 = 1;
        break;
      }
    }
    sleep(1u);
  }
  if ( v16 != 1 )
  {
    printf("%s[%d] timeout\n", "pcba_hbm_test", 223);
    sub_35D80(0, a2, nmemb, (int)ptr, 0);
    free(ptr);
    return 0;
  }
  else
  {
    v15 = 0;
    s = calloc(nmemb, 8u);
    while ( 1 )
    {
      v4 = v15++;
      if ( v4 > 29 )
        break;
      memset(s, 0, 4u);
      v9 = sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * (_DWORD)a2 + 5), nmemb, (int)s);
      if ( v9 == nmemb )
      {
        v16 = sub_35D80(1, a2, nmemb, (int)ptr, (int)s);
        break;
      }
      printf("%s[%d] resp num not enough %d\n", "pcba_hbm_test", 239, v9);
      sleep(1u);
    }
    free(ptr);
    free(s);
    return v16;
  }
}

//----- (0003633C) --------------------------------------------------------
int __fastcall sub_3633C(int a1, const char *a2, int a3, int a4)
{
  char s[32]; // [sp+18h] [bp+10h] BYREF
  unsigned int v10; // [sp+38h] [bp+30h]
  int i; // [sp+3Ch] [bp+34h]
  int j; // [sp+40h] [bp+38h]
  int v13; // [sp+44h] [bp+3Ch]

  v13 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      printf("%s unkonw error, exit\n", a2);
      sleep(1u);
      exit(1);
    }
    memset(&ret_str, 0, 0x40u);
    sprintf((char *)&ret_str, "%s error:", (const char *)&unk_1ED200 + 36 * (_DWORD)a2 + 20);
    for ( i = 0; i < a3; ++i )
    {
      printf(
        "%s[%d] chip-%02x result [%02x %08x]\n",
        "pcba_gpio_error_display",
        277,
        *(unsigned __int8 *)(8 * i + a4),
        *(unsigned __int8 *)(8 * i + a4 + 1),
        *(_DWORD *)(8 * i + a4 + 4));
      memset(s, 0, sizeof(s));
      if ( (*(_DWORD *)(8 * i + a4 + 4) & 0x1F) != 0 )
      {
        v10 = (*(_DWORD *)(8 * i + a4 + 4) << 24)
            | HIBYTE(*(_DWORD *)(8 * i + a4 + 4))
            | ((*(_DWORD *)(8 * i + a4 + 4) & 0xFF0000u) >> 8)
            | ((*(_DWORD *)(8 * i + a4 + 4) & 0xFF00) << 8);
        sprintf(s, "[%02x %x]", *(unsigned __int8 *)(8 * i + a4), v10 & 0x1F);
        strcat((char *)&ret_str, s);
        ++v13;
      }
    }
  }
  else
  {
    memset(&ret_str, 0, 0x40u);
    sprintf((char *)&ret_str, "%s timeout:", (const char *)&unk_1ED200 + 36 * (_DWORD)a2 + 20);
    for ( j = 0; j < a3; ++j )
    {
      printf(
        "%s[%d] chip-%02x ctrl [%02x %08x]\n",
        "pcba_gpio_error_display",
        261,
        *(unsigned __int8 *)(8 * j + a4),
        *(unsigned __int8 *)(8 * j + a4 + 1),
        *(_DWORD *)(8 * j + a4 + 4));
      memset(s, 0, sizeof(s));
      if ( sub_35D38(*(_DWORD *)(8 * j + a4 + 4)) )
      {
        sprintf(s, "[%02x]", *(unsigned __int8 *)(8 * j + a4));
        strcat((char *)&ret_str, s);
        ++v13;
      }
    }
  }
  if ( v13 )
  {
    printf("%s failed\n", (const char *)&unk_1ED200 + 36 * (_DWORD)a2 + 20);
    return 0;
  }
  else
  {
    printf("%s success\n", (const char *)&unk_1ED200 + 36 * (_DWORD)a2 + 20);
    return 1;
  }
}
// 479D5C: using guessed type int ret_str;

//----- (000365F8) --------------------------------------------------------
int __fastcall sub_365F8(int a1, const char *a2)
{
  int v2; // r3
  int v4; // r3
  int v8; // [sp+14h] [bp+Ch]
  _DWORD *ptr; // [sp+18h] [bp+10h]
  signed int nmemb; // [sp+1Ch] [bp+14h]
  signed int i; // [sp+20h] [bp+18h]
  int v12; // [sp+24h] [bp+1Ch]
  int v13; // [sp+28h] [bp+20h]
  int v14; // [sp+28h] [bp+20h]
  unsigned __int8 v15; // [sp+2Fh] [bp+27h]

  nmemb = *(_DWORD *)(a1 + 196);
  ptr = calloc(nmemb, 8u);
  v15 = 0;
  v13 = 0;
  while ( 1 )
  {
    v2 = v13++;
    if ( v2 > 29 )
      break;
    if ( sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * (_DWORD)a2 + 4), nmemb, (int)ptr) == nmemb )
    {
      v12 = 0;
      for ( i = 0; i < nmemb; ++i )
      {
        if ( sub_35D38(ptr[2 * i + 1]) )
        {
          printf(
            "%s[%d] chip-%02x is still testing [%02x, %08x]\n",
            "pcba_gpio_test",
            325,
            LOBYTE(ptr[2 * i]),
            BYTE1(ptr[2 * i]),
            ptr[2 * i + 1]);
        }
        else
        {
          ++v12;
          printf(
            "%s[%d] chip-%02x test done [%02x, %08x]\n",
            "pcba_gpio_test",
            323,
            LOBYTE(ptr[2 * i]),
            BYTE1(ptr[2 * i]),
            ptr[2 * i + 1]);
        }
      }
      if ( v12 == nmemb )
      {
        v15 = 1;
        break;
      }
    }
    sleep(1u);
  }
  if ( v15 != 1 )
  {
    printf("%s[%d] timeout\n", "pcba_gpio_test", 337);
    sub_3633C(0, a2, nmemb, (int)ptr);
    free(ptr);
    return 0;
  }
  else
  {
    v14 = 0;
    while ( 1 )
    {
      v4 = v14++;
      if ( v4 > 29 )
        break;
      memset(ptr, 0, sizeof(_DWORD));
      v8 = sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * (_DWORD)a2 + 5), nmemb, (int)ptr);
      if ( v8 == nmemb )
      {
        v15 = sub_3633C(1, a2, nmemb, (int)ptr);
        break;
      }
      printf("%s[%d] resp num not enough %d\n", "pcba_gpio_test", 352, v8);
      sleep(1u);
    }
    free(ptr);
    return v15;
  }
}

//----- (00036840) --------------------------------------------------------
int __fastcall sub_36840(int a1, int a2, int a3, int a4, const char *a5)
{
  const char *v5; // r1
  int v6; // r3
  int v7; // r3
  char s[32]; // [sp+28h] [bp+10h] BYREF
  unsigned int v14; // [sp+48h] [bp+30h]
  int i; // [sp+4Ch] [bp+34h]
  int j; // [sp+50h] [bp+38h]
  int v17; // [sp+54h] [bp+3Ch]

  v17 = 0;
  if ( a1 == 1 )
  {
    memset(&ret_str, 0, 0x40u);
    sprintf((char *)&ret_str, "%s error:", (const char *)&unk_1ED200 + 36 * a2 + 20);
    for ( i = 0; i < a3; ++i )
    {
      printf(
        "%s[%d] ctrl [%02x %02x %08x], result [%02x %02x %08x]\n",
        "pcba_ddr_error_display",
        419,
        *(unsigned __int8 *)(8 * i + a4),
        *(unsigned __int8 *)(8 * i + a4 + 1),
        *(_DWORD *)(8 * i + a4 + 4),
        (unsigned __int8)a5[8 * i],
        (unsigned __int8)a5[8 * i + 1],
        *(_DWORD *)&a5[8 * i + 4]);
      memset(s, 0, sizeof(s));
      v14 = (*(_DWORD *)&a5[8 * i + 4] << 24)
          | HIBYTE(*(_DWORD *)&a5[8 * i + 4])
          | ((*(_DWORD *)&a5[8 * i + 4] & 0xFF0000u) >> 8)
          | ((*(_DWORD *)&a5[8 * i + 4] & 0xFF00) << 8);
      if ( v14 )
      {
        v7 = (unsigned __int8)a5[8 * i];
        if ( v7 == 64 )
        {
          sprintf(s, "[%s %02x %x]", "U67", (unsigned __int8)a5[8 * i], v14);
        }
        else if ( (unsigned __int8)a5[8 * i] > 0x40u )
        {
          if ( v7 == 128 )
          {
            sprintf(s, "[%s %02x %x]", "U76", (unsigned __int8)a5[8 * i], v14);
          }
          else
          {
            if ( v7 != 192 )
            {
LABEL_34:
              printf("%s[%d] unknow chip addr\n", a5, a5);
              sleep(1u);
              exit(1);
            }
            sprintf(s, "[%s %02x %x]", "U70", (unsigned __int8)a5[8 * i], v14);
          }
        }
        else
        {
          if ( a5[8 * i] )
            goto LABEL_34;
          sprintf(s, "[%s %02x %x]", "U73", (unsigned __int8)a5[8 * i], v14);
        }
        strcat((char *)&ret_str, s);
        ++v17;
      }
    }
  }
  else
  {
    if ( a1 != 2 )
    {
      printf("%s unkonw error, exit\n", "pcba_ddr_error_display");
      sleep(1u);
      exit(1);
    }
    memset(&ret_str, 0, 0x40u);
    sprintf((char *)&ret_str, "%s timeout:", (const char *)&unk_1ED200 + 36 * a2 + 20);
    for ( j = 0; j < a3; ++j )
    {
      memset(s, 0, sizeof(s));
      if ( sub_35D38(*(_DWORD *)(8 * j + a4 + 4)) )
      {
        v6 = *(unsigned __int8 *)(8 * j + a4);
        if ( v6 == 64 )
        {
          sprintf(s, "[%s %02x]", "U67", *(unsigned __int8 *)(8 * j + a4));
        }
        else if ( *(unsigned __int8 *)(8 * j + a4) > 0x40u )
        {
          if ( v6 == 128 )
          {
            sprintf(s, "[%s %02x]", "U76", *(unsigned __int8 *)(8 * j + a4));
          }
          else
          {
            if ( v6 != 192 )
            {
LABEL_16:
              printf("%s[%d] unknow chip addr\n", v5, a4);
              sleep(1u);
              exit(1);
            }
            sprintf(s, "[%s %02x]", "U70", *(unsigned __int8 *)(8 * j + a4));
          }
        }
        else
        {
          if ( *(_BYTE *)(8 * j + a4) )
            goto LABEL_16;
          sprintf(s, "[%s %02x]", "U73", *(unsigned __int8 *)(8 * j + a4));
        }
        strcat((char *)&ret_str, s);
        ++v17;
      }
    }
  }
  if ( v17 )
  {
    printf("%s failed\n", (const char *)&unk_1ED200 + 36 * a2 + 20);
    return 0;
  }
  else
  {
    printf("%s success\n", (const char *)&unk_1ED200 + 36 * a2 + 20);
    return 1;
  }
}
// 36984: variable 'v5' is possibly undefined
// 479D5C: using guessed type int ret_str;

//----- (00036C5C) --------------------------------------------------------
int __fastcall sub_36C5C(int a1, int a2)
{
  int v2; // r3
  int v4; // r3
  int v8; // [sp+14h] [bp+Ch]
  void *ptr; // [sp+18h] [bp+10h]
  unsigned __int8 *s; // [sp+1Ch] [bp+14h]
  signed int nmemb; // [sp+20h] [bp+18h]
  int v12; // [sp+24h] [bp+1Ch]
  int v13; // [sp+24h] [bp+1Ch]
  signed int i; // [sp+28h] [bp+20h]
  int v15; // [sp+2Ch] [bp+24h]
  int v16; // [sp+30h] [bp+28h]
  int v17; // [sp+30h] [bp+28h]
  unsigned __int8 v18; // [sp+37h] [bp+2Fh]

  printf("%s begin testing\n", (const char *)&unk_1ED200 + 36 * a2 + 20);
  v18 = 0;
  v16 = 0;
  nmemb = *(_DWORD *)(a1 + 196);
  s = (unsigned __int8 *)calloc(nmemb, 8u);
  while ( 1 )
  {
    v2 = v16++;
    if ( v2 > 29 )
      break;
    memset(s, 0, 4u);
    v12 = sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * a2 + 4), nmemb, (int)s);
    if ( v12 == nmemb )
    {
      v15 = 0;
      for ( i = 0; i < nmemb; ++i )
      {
        if ( sub_35D38(*(_DWORD *)&s[8 * i + 4]) )
        {
          printf(
            "%s[%d] chip%02x is still testing %02x %08x\n",
            "pcba_ddr_test",
            489,
            s[8 * i],
            s[8 * i + 1],
            *(_DWORD *)&s[8 * i + 4]);
        }
        else
        {
          ++v15;
          printf(
            "%s[%d] chip%02x test done %02x %08x\n",
            "pcba_ddr_test",
            487,
            s[8 * i],
            s[8 * i + 1],
            *(_DWORD *)&s[8 * i + 4]);
        }
      }
      if ( v15 == nmemb )
      {
        v18 = 1;
        break;
      }
      v18 = 0;
    }
    else
    {
      v18 = 0;
      printf("%s[%d] resp num not enough %d\n", "pcba_ddr_test", 500, v12);
    }
    sleep(1u);
  }
  if ( v18 != 1 )
  {
    printf("%s[%d] timeout\n", "pcba_ddr_test", 506);
    sub_36840(2, a2, nmemb, (int)s, 0);
    free(s);
    return v18;
  }
  else
  {
    v17 = 0;
    ptr = calloc(nmemb, 8u);
    while ( 1 )
    {
      v4 = v17++;
      if ( v4 > 29 )
        break;
      memset(s, 0, 4u);
      memset(ptr, 0, 4u);
      v13 = sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * a2 + 4), nmemb, (int)s);
      v8 = sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * a2 + 5), nmemb, (int)ptr);
      if ( v13 == nmemb && v8 == nmemb )
      {
        v18 = sub_36840(1, a2, nmemb, (int)s, (const char *)ptr);
        break;
      }
      printf("%s[%d] resp num not enough %d\n", "pcba_ddr_test", 525, v13);
      sleep(1u);
    }
    free(s);
    free(ptr);
    return v18;
  }
}

//----- (00036F08) --------------------------------------------------------
int __fastcall sub_36F08(int a1, int a2, int a3, int a4, int a5)
{
  const char *v5; // r1
  int v6; // r3
  const char *v7; // r1
  _DWORD s[8]; // [sp+2Ch] [bp+14h] BYREF
  unsigned int v14; // [sp+4Ch] [bp+34h]
  unsigned int v15; // [sp+50h] [bp+38h]
  int i; // [sp+54h] [bp+3Ch]
  int j; // [sp+58h] [bp+40h]
  int v18; // [sp+5Ch] [bp+44h]

  v18 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      printf("%s[%d] unknow error\n", "pcba_serdes_error_display", 654);
      sleep(1u);
      exit(1);
    }
    memset(&ret_str, 0, 0x40u);
    sprintf((char *)&ret_str, "%s:", (const char *)&unk_1ED200 + 36 * a2 + 20);
    for ( i = 0; i < a3; ++i )
    {
      printf(
        "%s[%d] ctrl [%02x %02x %08x], result [%02x %02x %08x]\n",
        "pcba_serdes_error_display",
        583,
        *(unsigned __int8 *)(8 * i + a4),
        *(unsigned __int8 *)(8 * i + a4 + 1),
        *(_DWORD *)(8 * i + a4 + 4),
        *(unsigned __int8 *)(8 * i + a5),
        *(unsigned __int8 *)(8 * i + a5 + 1),
        *(_DWORD *)(8 * i + a5 + 4));
      memset(s, 0, sizeof(s));
      if ( *(_DWORD *)(8 * i + a4 + 4) || *(_DWORD *)(8 * i + a5 + 4) )
      {
        if ( *(_BYTE *)(8 * i + a4) )
        {
          if ( *(_BYTE *)(8 * i + a4) == 64 )
          {
            strcpy((char *)s, "[U67 ");
          }
          else if ( *(unsigned __int8 *)(8 * i + a4) == 128 )
          {
            strcpy((char *)s, "[U76 ");
          }
          else
          {
            if ( *(unsigned __int8 *)(8 * i + a4) != 192 )
            {
              printf("%s unknow chip address\n", v7);
              exit(1);
            }
            strcpy((char *)s, "[U70 ");
          }
        }
        else
        {
          strcpy((char *)s, "[U73 ");
        }
        strcat((char *)&ret_str, (const char *)s);
        memset(s, 0, sizeof(s));
        v15 = (*(_DWORD *)(8 * i + a4 + 4) << 24)
            | HIBYTE(*(_DWORD *)(8 * i + a4 + 4))
            | ((*(_DWORD *)(8 * i + a4 + 4) & 0xFF0000u) >> 8)
            | ((*(_DWORD *)(8 * i + a4 + 4) & 0xFF00) << 8);
        if ( (v15 & 0xF0000000) != 0 )
          s[0] = &unk_20314C;
        if ( (v15 & 0xF000000) != 0 )
          s[0] = 2109778;
        strcat((char *)&ret_str, (const char *)s);
        memset(s, 0, sizeof(s));
        if ( (v15 & 0x2000) != 0 )
          s[0] = &unk_20324C;
        if ( (v15 & 0x1000) != 0 )
          s[0] = 2110034;
        strcat((char *)&ret_str, (const char *)s);
        memset(s, 0, sizeof(s));
        if ( (v15 & 0x800) != 0 )
          s[0] = &unk_20334C;
        if ( (v15 & 0x400) != 0 )
          s[0] = 2110290;
        strcat((char *)&ret_str, (const char *)s);
        memset(s, 0, sizeof(s));
        if ( (v15 & 0x200) != 0 )
          s[0] = &unk_20344C;
        if ( (v15 & 0x100) != 0 )
          s[0] = 2110546;
        strcat((char *)&ret_str, (const char *)s);
        memset(s, 0, sizeof(s));
        v14 = (*(_DWORD *)(8 * i + a5 + 4) << 24)
            | HIBYTE(*(_DWORD *)(8 * i + a5 + 4))
            | ((*(_DWORD *)(8 * i + a5 + 4) & 0xFF0000u) >> 8)
            | ((*(_DWORD *)(8 * i + a5 + 4) & 0xFF00) << 8);
        if ( HIWORD(v14) << 16 )
          s[0] = &unk_20354C;
        if ( (_WORD)v14 )
          s[0] = 2110802;
        strcat((char *)&ret_str, (const char *)s);
        *(_WORD *)((char *)&ret_str + strlen((const char *)&ret_str)) = 93;
        ++v18;
      }
    }
  }
  else
  {
    memset(&ret_str, 0, 0x40u);
    sprintf((char *)&ret_str, "%s timeout:", (const char *)&unk_1ED200 + 36 * a2 + 20);
    for ( j = 0; j < a3; ++j )
    {
      memset(s, 0, sizeof(s));
      if ( sub_35D38(*(_DWORD *)(8 * j + a4 + 4)) )
      {
        v6 = *(unsigned __int8 *)(8 * j + a4);
        if ( v6 == 64 )
        {
          sprintf((char *)s, "[%s %02x]", "U67", *(unsigned __int8 *)(8 * j + a4));
        }
        else if ( *(unsigned __int8 *)(8 * j + a4) > 0x40u )
        {
          if ( v6 == 128 )
          {
            sprintf((char *)s, "[%s %02x]", "U76", *(unsigned __int8 *)(8 * j + a4));
          }
          else
          {
            if ( v6 != 192 )
            {
LABEL_17:
              printf("%s[%d] unknow chip addr\n", v5, a4);
              sleep(1u);
              exit(1);
            }
            sprintf((char *)s, "[%s %02x]", "U70", *(unsigned __int8 *)(8 * j + a4));
          }
        }
        else
        {
          if ( *(_BYTE *)(8 * j + a4) )
            goto LABEL_17;
          sprintf((char *)s, "[%s %02x]", "U73", *(unsigned __int8 *)(8 * j + a4));
        }
        strcat((char *)&ret_str, (const char *)s);
        ++v18;
      }
    }
  }
  if ( v18 )
  {
    printf("%s failed\n", (const char *)&unk_1ED200 + 36 * a2 + 20);
    return 0;
  }
  else
  {
    printf("%s success\n", (const char *)&unk_1ED200 + 36 * a2 + 20);
    return 1;
  }
}
// 3704C: variable 'v5' is possibly undefined
// 37200: variable 'v7' is possibly undefined
// 479D5C: using guessed type int ret_str;

//----- (000374F0) --------------------------------------------------------
int __fastcall sub_374F0(int a1, int a2)
{
  int v2; // r3
  int v4; // r3
  void *ptr; // [sp+14h] [bp+Ch]
  int v9; // [sp+18h] [bp+10h]
  unsigned __int8 *s; // [sp+1Ch] [bp+14h]
  signed int nmemb; // [sp+20h] [bp+18h]
  int v12; // [sp+24h] [bp+1Ch]
  int v13; // [sp+24h] [bp+1Ch]
  signed int i; // [sp+28h] [bp+20h]
  int v15; // [sp+2Ch] [bp+24h]
  int v16; // [sp+30h] [bp+28h]
  int v17; // [sp+30h] [bp+28h]
  unsigned __int8 v18; // [sp+37h] [bp+2Fh]

  v18 = 0;
  v16 = 0;
  nmemb = *(_DWORD *)(a1 + 196);
  s = (unsigned __int8 *)calloc(nmemb, 8u);
  while ( 1 )
  {
    v2 = v16++;
    if ( v2 > 29 )
      break;
    memset(s, 0, 4u);
    v12 = sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * a2 + 4), nmemb, (int)s);
    if ( v12 == nmemb )
    {
      v15 = 0;
      for ( i = 0; i < nmemb; ++i )
      {
        if ( sub_35D38(*(_DWORD *)&s[8 * i + 4]) )
        {
          printf(
            "%s[%d] chip%02x is still testing %02x %08x\n",
            "pcba_serdes_test",
            690,
            s[8 * i],
            s[8 * i + 1],
            *(_DWORD *)&s[8 * i + 4]);
        }
        else
        {
          ++v15;
          printf(
            "%s[%d] chip%02x test done %02x %08x\n",
            "pcba_serdes_test",
            688,
            s[8 * i],
            s[8 * i + 1],
            *(_DWORD *)&s[8 * i + 4]);
        }
      }
      if ( v15 == nmemb )
      {
        v18 = 1;
        break;
      }
      v18 = 0;
    }
    else
    {
      v18 = 0;
      printf("%s[%d] resp num not enough %d\n", "pcba_serdes_test", 702, v12);
    }
    sleep(1u);
  }
  if ( v18 != 1 )
  {
    printf("%s[%d] timeout\n", "pcba_serdes_test", 708);
    sub_36F08(0, a2, nmemb, (int)s, 0);
    free(s);
    return v18;
  }
  else
  {
    v17 = 0;
    ptr = calloc(nmemb, 8u);
    while ( 1 )
    {
      v4 = v17++;
      if ( v4 > 29 )
        break;
      memset(s, 0, 4u);
      memset(ptr, 0, 4u);
      v13 = sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * a2 + 4), nmemb, (int)s);
      v9 = sub_35C00(a1, *((_BYTE *)&unk_1ED200 + 36 * a2 + 5), nmemb, (int)ptr);
      if ( v13 == nmemb && v9 == nmemb )
      {
        v18 = sub_36F08(1, a2, nmemb, (int)s, (int)ptr);
        break;
      }
      v18 = 0;
      printf("%s[%d] resp num %d, resp num tmp %d\n", "pcba_serdes_test", 729, v13, v9);
      sleep(1u);
    }
    free(s);
    free(ptr);
    return v18;
  }
}

//----- (00037780) --------------------------------------------------------
int __fastcall sub_37780(int a1)
{
  sub_35BB8(a1, byte_1ED270, dword_1ED274);
  usleep(0x30D40u);
  sub_35BB8(a1, byte_1ED204, dword_1ED208);
  usleep(0x30D40u);
  sub_35BB8(a1, byte_1ED228, dword_1ED22C);
  usleep(0x30D40u);
  sub_35BB8(a1, byte_1ED24C, dword_1ED250);
  usleep(0x30D40u);
  sub_35BB8(a1, byte_1ED294, dword_1ED298);
  return usleep(0x30D40u);
}
// 1ED204: using guessed type char byte_1ED204;
// 1ED208: using guessed type int dword_1ED208;
// 1ED228: using guessed type char byte_1ED228;
// 1ED22C: using guessed type int dword_1ED22C;
// 1ED24C: using guessed type char byte_1ED24C;
// 1ED250: using guessed type int dword_1ED250;
// 1ED270: using guessed type char byte_1ED270;
// 1ED274: using guessed type int dword_1ED274;
// 1ED294: using guessed type char byte_1ED294;
// 1ED298: using guessed type int dword_1ED298;

//----- (00037864) --------------------------------------------------------
int __fastcall pcba_fpga_ip_test(int a1)
{
  sub_37780(a1);
  if ( (unsigned __int8)sub_365F8(a1, (const char *)3) != 1 )
  {
    puts("pcba gpio test failed");
    return 2;
  }
  else if ( (unsigned __int8)sub_374F0(a1, 0) != 1 )
  {
    puts("pcba serdes test failed");
    return 1;
  }
  else if ( (unsigned __int8)sub_36C5C(a1, 1) != 1 )
  {
    puts("pcba DDR0 test failed");
    return 3;
  }
  else if ( (unsigned __int8)sub_36C5C(a1, 2) != 1 )
  {
    puts("pcba DDR1 test failed");
    return 4;
  }
  else if ( (unsigned __int8)sub_3612C(a1, (const char *)4) != 1 )
  {
    puts("pcba hbm test failed");
    return 5;
  }
  else
  {
    return 0;
  }
}

//----- (00037930) --------------------------------------------------------
int __fastcall pcba_match_fpga_baud(int a1, int a2)
{
  int v2; // r2
  char *v7; // [sp+8h] [bp+8h]
  int v8; // [sp+Ch] [bp+Ch]
  int v9; // [sp+10h] [bp+10h]
  int v10; // [sp+14h] [bp+14h]
  signed int v11; // [sp+18h] [bp+18h]
  unsigned int i; // [sp+1Ch] [bp+1Ch]
  _BYTE v13[4]; // [sp+20h] [bp+20h] BYREF

  v7 = "stem_Config_File_Information";
  v8 = 460800;
  v9 = 921600;
  v10 = 3125000;
  v11 = *(_DWORD *)(a1 + 196);
  for ( i = 0; i <= 3; ++i )
  {
    (*(void (__fastcall **)(_DWORD))(a2 + 16))(*(_DWORD *)&v13[4 * i - 24]);
    usleep(0x7A120u);
    v2 = sub_35C00(a1, 0, v11, 0);
    if ( v2 == v11 )
    {
      printf("current baudrate %d bps\n", *(_DWORD *)&v13[4 * i - 24]);
      return 1;
    }
  }
  printf("%s not match baudrate\n", "pcba_match_fpga_baud");
  return 0;
}

//----- (000379DC) --------------------------------------------------------
int __fastcall sub_379DC(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (00037A2C) --------------------------------------------------------
int __fastcall pcba_set_address(int a1)
{
  int v3; // [sp+Ch] [bp+Ch]

  v3 = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(a1 + 240) = sub_379DC(*(_DWORD *)(a1 + 296), v3);
  return (*(int (__fastcall **)(int, _DWORD, int))(a1 + 148))(a1, *(_DWORD *)(a1 + 296), v3);
}

//----- (00037A74) --------------------------------------------------------
int __fastcall pcba_get_chip_num(int a1)
{
  int v3; // [sp+8h] [bp+8h]
  _DWORD *ptr; // [sp+Ch] [bp+Ch]
  size_t nmemb; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  nmemb = *(_DWORD *)(a1 + 196);
  ptr = calloc(nmemb, 8u);
  v3 = sub_35C00(a1, 0, nmemb, (int)ptr);
  for ( i = 0; i < v3; ++i )
    printf("chip-%02x %08x\n", LOBYTE(ptr[2 * i]), ptr[2 * i + 1]);
  free(ptr);
  return v3;
}

//----- (00037AE8) --------------------------------------------------------
unsigned int __fastcall sub_37AE8(char *a1)
{
  char v2; // [sp+8h] [bp+8h]
  int v3; // [sp+Ch] [bp+Ch]

  v2 = 3;
  if ( a1 == (_BYTE *)&loc_17D780 + 4 )
  {
    v3 = 1;
  }
  else if ( (int)a1 > 1562500 )
  {
    if ( a1 == (char *)6250000 )
    {
      v3 = 0;
      v2 = 1;
    }
    else if ( a1 == (char *)12500000 )
    {
      v3 = 0;
      v2 = 0;
    }
    else
    {
      if ( a1 != byte_2FAF08 )
        goto LABEL_18;
      v3 = 0;
    }
  }
  else if ( a1 == (char *)&loc_70800 )
  {
    v3 = 6;
  }
  else if ( a1 == (char *)&loc_E1000 )
  {
    v3 = 2;
  }
  else
  {
    if ( a1 != "stem_Config_File_Information" )
    {
LABEL_18:
      v3 = 26;
      return (unsigned int)&word_1FF00 & (v3 << 8) | (unsigned __int8)(v2 << 6);
    }
    v3 = 26;
  }
  return (unsigned int)&word_1FF00 & (v3 << 8) | (unsigned __int8)(v2 << 6);
}
// 1FF00: using guessed type __int16 word_1FF00;

//----- (00037BA8) --------------------------------------------------------
int __fastcall pcba_set_chips_baud(int a1, int a2, char *a3)
{
  unsigned int v7; // [sp+14h] [bp+14h]

  v7 = sub_37AE8(a3);
  sub_35BB8(a1, 0x1Cu, v7);
  usleep(0xF4240u);
  (*(void (__fastcall **)(char *))(a2 + 16))(a3);
  usleep((__useconds_t)&stru_1869C.st_value);
  return 1;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00037BF0) --------------------------------------------------------
int __fastcall pcba_set_baud(int a1, int a2, int a3)
{
  (*(void (__fastcall **)(int, int))(a1 + 76))(a1, a3);
  usleep(0x2710u);
  return (*(int (__fastcall **)(int))(a2 + 16))(a3);
}

//----- (00037C20) --------------------------------------------------------
int __fastcall pcba_set_ticket_mask(int a1, int a2)
{
  return sub_35BB8(a1, 0x14u, a2);
}

//----- (00037C40) --------------------------------------------------------
int __fastcall pcba_read_fpga_temperature(
        int a1,
        _DWORD *a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7)
{
  int v13; // [sp+24h] [bp+14h] BYREF
  int v14; // [sp+28h] [bp+18h] BYREF
  int v15; // [sp+2Ch] [bp+1Ch] BYREF
  int v16; // [sp+30h] [bp+20h] BYREF
  _DWORD *v17; // [sp+34h] [bp+24h]
  _DWORD *v18; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]

  v18 = *(_DWORD **)(a1 + 212);
  *a2 = -150;
  *a3 = 150;
  *a4 = -150;
  *a5 = 150;
  for ( i = 0; v18[1] > i; ++i )
  {
    v17 = (_DWORD *)(20 * i + *v18);
    v14 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 100))(
      a1,
      &v16,
      &v14,
      *v17,
      v17[1],
      v17[2],
      v17[3],
      v17[4]);
    if ( v14 )
    {
      ++*a6;
      if ( *a2 < v16 )
        *a2 = v16;
      if ( *a3 > v16 )
        *a3 = v16;
    }
    v13 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 104))(
      a1,
      &v15,
      &v13,
      *v17,
      v17[1],
      v17[2],
      v17[3],
      v17[4]);
    if ( v13 )
    {
      ++*a7;
      if ( *a4 < v15 )
        *a4 = v15;
      if ( *a5 > v15 )
        *a5 = v15;
    }
  }
  if ( *a6 == v18[1] && *a7 == v18[1] )
    return 0;
  else
    return -1;
}

//----- (00037D70) --------------------------------------------------------
bool __fastcall sub_37D70(unsigned int a1)
{
  return (((a1 << 24) | HIBYTE(a1) | ((a1 & 0xFF0000) >> 8) | ((a1 & 0xFF00) << 8)) & 0x80000000) == 0;
}

//----- (00037DB0) --------------------------------------------------------
int __fastcall sub_37DB0(unsigned int a1)
{
  unsigned int v3; // [sp+Ch] [bp+Ch]

  v3 = (((a1 << 24) | HIBYTE(a1) | ((a1 & 0xFF0000) >> 8) | ((a1 & 0xFF00) << 8)) >> 24) & 0x7F;
  switch ( v3 )
  {
    case 0x7Fu:
      return 3;
    case 2u:
      return 2;
    case 1u:
      return 1;
    case 0u:
      return 0;
  }
  printf("%s unknow program type\n", "pcba_program_type_check");
  return -1;
}

//----- (00037E2C) --------------------------------------------------------
int pcba_start_boot()
{
  return 0;
}

//----- (00037E44) --------------------------------------------------------
int __fastcall pcba_start_basic(int a1, int a2)
{
  _DWORD *v5; // [sp+8h] [bp+8h]
  int nmemb; // [sp+Ch] [bp+Ch]
  int i; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]

  nmemb = *(_DWORD *)(a1 + 196);
  v5 = calloc(nmemb, 8u);
  sub_35BB8(a1, 0xFCu, -1425866752);
  usleep(0x30D40u);
  (*(void (__fastcall **)(int))(a2 + 16))(115200);
  while ( 1 )
  {
    while ( 1 )
    {
      sleep(1u);
      if ( sub_35C00(a1, 0xFCu, nmemb, (int)v5) >= nmemb )
        break;
      printf("%s[%d] is waiting\n", "pcba_start_basic", 1003);
    }
    v8 = 0;
    for ( i = 0; i < nmemb; ++i )
    {
      printf("%s %02x reg_data %08x\n", "pcba_start_basic", LOBYTE(v5[2 * i]), v5[2 * i + 1]);
      if ( sub_37DB0(v5[2 * i + 1]) == 3 )
        ++v8;
    }
    if ( v8 == nmemb )
      break;
    printf("%s[%d] starting %d\n", "pcba_start_basic", 1019, v8);
  }
  printf("%s[%d] success\n", "pcba_start_basic", 1015);
  return 1;
}

//----- (00037F7C) --------------------------------------------------------
int __fastcall pcba_start_fpgaminer(int a1, int a2)
{
  _DWORD *v5; // [sp+8h] [bp+8h]
  int nmemb; // [sp+Ch] [bp+Ch]
  int i; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]

  nmemb = *(_DWORD *)(a1 + 196);
  v5 = calloc(nmemb, 8u);
  sub_35BB8(a1, 0xFCu, -1425997824);
  usleep(0x30D40u);
  (*(void (__fastcall **)(int))(a2 + 16))(115200);
  while ( 1 )
  {
    while ( 1 )
    {
      sleep(1u);
      if ( sub_35C00(a1, 0xFCu, nmemb, (int)v5) >= nmemb )
        break;
      printf("%s[%d] is waiting\n", "pcba_start_fpgaminer", 1042);
    }
    v8 = 0;
    for ( i = 0; i < nmemb; ++i )
    {
      printf("%s chip%d reg_data %08x\n", "pcba_start_fpgaminer", i, v5[2 * i + 1]);
      fpga_type[i] = sub_37D70(v5[2 * i + 1]);
      if ( sub_37DB0(v5[2 * i + 1]) > 0 && sub_37DB0(v5[2 * i + 1]) <= 2 )
        ++v8;
    }
    if ( v8 == nmemb )
      break;
    printf("%s[%d] starting %d\n", "pcba_start_fpgaminer", 1065, v8);
  }
  printf("%s[%d] success\n", "pcba_start_fpgaminer", 1059);
  return 1;
}
// 47BFAC: using guessed type _DWORD fpga_type[4];

//----- (000380DC) --------------------------------------------------------
int __fastcall find_APW_power_version(int a1)
{
  unsigned __int8 i; // [sp+Fh] [bp+Fh]
  unsigned __int8 j; // [sp+Fh] [bp+Fh]

  if ( *(_DWORD *)(g_config_info + 32) )
  {
    for ( i = 0; i < (unsigned int)gPower_version_array_size; ++i )
    {
      if ( APW_power_version[i] == a1 )
        return 1;
    }
  }
  else
  {
    for ( j = 0; j < *(int *)(g_config_info + 60); ++j )
    {
      if ( *(_DWORD *)(4 * j + *(_DWORD *)(g_config_info + 56)) == a1 )
        return 1;
    }
  }
  return 0;
}
// 1F0C98: using guessed type int g_config_info;
// 1F0D3C: using guessed type int gPower_version_array_size;
// 47BEEC: using guessed type unsigned __int8 APW_power_version[8];

//----- (00038178) --------------------------------------------------------
int __fastcall pcba_power_on(unsigned int a1, int a2)
{
  unsigned __int16 v6; // [sp+16h] [bp+Eh]
  __int16 v7; // [sp+16h] [bp+Eh]

  if ( a1 <= 9 )
  {
    if ( *((_BYTE *)&all_algo_system_info + 68 * a1 + 4) != 1 )
    {
      printf("%s, algo %s donot use adjustable power!\n", "pcba_power_on", off_1ED170[a1]);
      return 0;
    }
    else
    {
      v6 = bitmain_power_version();
      printf("power type version: 0x%04x\n", v6);
      if ( (unsigned __int8)find_APW_power_version(v6) != 1 )
      {
        printf(
          "power version error, expect %04x, actual %04x\n",
          *((unsigned __int16 *)&all_algo_system_info + 34 * a1 + 3),
          v6);
        return -1;
      }
      else
      {
        puts("Power init:");
        printf("check_asic_voltage      = %d\n", *((_DWORD *)&all_algo_system_info + 17 * a1 + 5));
        printf("working_voltage_raw     = %d\n", a2);
        if ( *((_BYTE *)&all_algo_system_info + 68 * a1 + 4) && *((_BYTE *)&all_algo_system_info + 68 * a1 + 16) )
        {
          printf("Set check asic voltage %d\n", *((_DWORD *)&all_algo_system_info + 17 * a1 + 5));
          v7 = set_voltage(*((_DWORD *)&all_algo_system_info + 17 * a1 + 5), 1);
        }
        else
        {
          printf("Set working voltage %d\n", a2);
          v7 = set_voltage(a2, 1);
        }
        if ( v7 )
        {
          puts("set_voltage_by_steps error!");
          return -1;
        }
        else
        {
          power_info_init(
            *((_DWORD *)&all_algo_system_info + 17 * a1 + 1),
            *((_DWORD *)&all_algo_system_info + 17 * a1 + 2),
            *((_DWORD *)&all_algo_system_info + 17 * a1 + 3),
            *((_DWORD *)&all_algo_system_info + 17 * a1 + 4),
            *((_DWORD *)&all_algo_system_info + 17 * a1 + 5));
          set_power_init_status(1);
          power_on();
          return 0;
        }
      }
    }
  }
  else
  {
    printf("%s, unknow algo %d!\n", "pcba_power_on", a1);
    return -1;
  }
}
// 1ED170: using guessed type char *off_1ED170[11];

//----- (00038378) --------------------------------------------------------
int __fastcall pcba_set_working_voltage(int a1, int a2)
{
  int v2; // r3

  v2 = all_algo_system_info[68 * a1 + 4];
  if ( all_algo_system_info[68 * a1 + 4] )
  {
    v2 = all_algo_system_info[68 * a1 + 16];
    if ( all_algo_system_info[68 * a1 + 16] )
    {
      printf("Set voltage to working_voltage %d\n", a2);
      v2 = set_voltage_by_steps(a2, 1);
      if ( v2 )
      {
        puts("set_voltage_by_steps error!");
        return -1;
      }
    }
  }
  return v2;
}
// 1B1744: using guessed type unsigned __int8 all_algo_system_info[612];

//----- (000383F8) --------------------------------------------------------
int __fastcall pcba_power_off(int a1)
{
  int v1; // r3

  if ( all_algo_system_info[68 * a1 + 4] != 1 )
  {
    printf("%s, algo %s donot use adjustable power!", "pcba_power_off", off_1ED170[a1]);
    return 0;
  }
  else
  {
    power_off();
  }
  return v1;
}
// 3844E: variable 'v1' is possibly undefined
// 1B1744: using guessed type unsigned __int8 all_algo_system_info[612];
// 1ED170: using guessed type char *off_1ED170[11];

//----- (00038458) --------------------------------------------------------
int8_t __cdecl get_max_value(int8_t *data, uint8_t data_length)
{
  unsigned __int8 i; // [sp+Eh] [bp+Eh]
  int8_t v4; // [sp+Fh] [bp+Fh]

  v4 = 0x80;
  for ( i = 0; i < (unsigned int)data_length; ++i )
  {
    if ( v4 < data[i] )
      v4 = data[i];
  }
  return v4;
}

//----- (000384AC) --------------------------------------------------------
int8_t __cdecl get_min_value(int8_t *data, uint8_t data_length)
{
  unsigned __int8 i; // [sp+Eh] [bp+Eh]
  int8_t v4; // [sp+Fh] [bp+Fh]

  v4 = 127;
  for ( i = 0; i < (unsigned int)data_length; ++i )
  {
    if ( v4 > data[i] )
      v4 = data[i];
  }
  return v4;
}

//----- (00038500) --------------------------------------------------------
uint8_t __cdecl CRC5_long(const uint8_t *pdata, uint32_t length)
{
  _BYTE v4[5]; // [sp+Ch] [bp+Ch]
  int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  bool v7; // [sp+1Ah] [bp+1Ah]
  uint8_t v8; // [sp+1Bh] [bp+1Bh]
  int v9; // [sp+1Ch] [bp+1Ch]
  unsigned int v10; // [sp+20h] [bp+20h]
  uint32_t i; // [sp+24h] [bp+24h]

  v5 = 16843009;
  v6 = 1;
  v10 = 128;
  v9 = 0;
  for ( i = 0; i < length; ++i )
  {
    v7 = (v10 & *pdata) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 128;
      v9 = 0;
      ++pdata;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (00038620) --------------------------------------------------------
int __fastcall print_eeprom_data_in_hex(int a1, unsigned int a2)
{
  unsigned __int8 i; // [sp+Fh] [bp+Fh]

  for ( i = 0; i < a2; ++i )
  {
    printf("%02X", *(unsigned __int8 *)(i + a1));
    if ( i )
    {
      if ( (i & 7) == 7 )
        putchar(32);
      if ( (i & 0xF) == 0xF )
        putchar(10);
    }
  }
  return puts("\n");
}

//----- (00038698) --------------------------------------------------------
int display_main_page()
{
  char v1[16]; // [sp+0h] [bp+0h] BYREF

  lcd_clear_result();
  if ( !strcmp((const char *)MES2Local_Config_Information, "PT1") )
  {
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(2u, "Only find ASIC");
    return printf("Only find ASIC");
  }
  else if ( !strcmp((const char *)MES2Local_Config_Information, "PT1+") )
  {
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "Find ASIC");
    memset(v1, 0, sizeof(v1));
    sprintf(v1, "%d pattern test", *(_DWORD *)(MES2Local_Config_Information + 200));
    lcd_show(2u, v1);
    return printf("do PT1+ test");
  }
  else if ( !strcmp((const char *)MES2Local_Config_Information, "PT2") )
  {
    if ( *(_DWORD *)(MES2Local_Config_Information + 64) == 1 )
    {
      lcd_show(0, (const char *)(MES2Local_Config_Information + 48));
      memset(v1, 0, sizeof(v1));
      sprintf(
        v1,
        "IC:%2d  P:%d",
        *(_DWORD *)(MES2Local_Config_Information + 64),
        *(_DWORD *)(MES2Local_Config_Information + 200));
      lcd_show(1u, v1);
      memset(v1, 0, sizeof(v1));
      sprintf(
        v1,
        "FREQ:%d L:%d",
        *(_DWORD *)(MES2Local_Config_Information + 236),
        *(_DWORD *)(MES2Local_Config_Information + 224));
      lcd_show(2u, v1);
      lcd_show(3u, "Vol: set power");
      return printf("Single ASIC pattern test");
    }
    else if ( *(_BYTE *)(MES2Local_Config_Information + 188) )
    {
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "Factory Mode:PT2");
      lcd_show(2u, "Please Scan code");
      lcd_show(3u, "first");
      return puts("Factory Mode:PT2, Please Scan code first");
    }
    else if ( *(_BYTE *)(MES2Local_Config_Information + 189) )
    {
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      memset(v1, 0, sizeof(v1));
      sprintf(
        v1,
        "IC:%2d  P:%d",
        *(_DWORD *)(MES2Local_Config_Information + 64),
        *(_DWORD *)(MES2Local_Config_Information + 200));
      lcd_show(1u, v1);
      memset(v1, 0, sizeof(v1));
      sprintf(
        v1,
        "FREQ:%d L:%d",
        *(_DWORD *)(MES2Local_Config_Information + 236),
        *(_DWORD *)(MES2Local_Config_Information + 224));
      lcd_show(2u, v1);
      memset(v1, 0, sizeof(v1));
      sprintf(v1, "Voltage: %d", *(_DWORD *)(MES2Local_Config_Information + 232));
      lcd_show(3u, v1);
      return printf("Manual Mode:PT2, does not use scan code gun");
    }
    else
    {
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "Manual Mode:PT2");
      lcd_show(2u, "Please Scan code");
      lcd_show(3u, "first");
      return puts("Manual Test Mode:PT2, Please Scan code first");
    }
  }
  else
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "Test Process");
    return lcd_show(2u, "error");
  }
}
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (00038A1C) --------------------------------------------------------
int malloc_for_mes_config_information()
{
  if ( MES2Local_Config_Information )
  {
    puts("mes config information already malloced");
    goto LABEL_5;
  }
  MES2Local_Config_Information = (int)calloc(1u, 0x1D8u);
  if ( MES2Local_Config_Information )
  {
LABEL_5:
    puts("malloc for mes config information success");
    return 1;
  }
  puts("malloc for mes config information fail!");
  return 0;
}
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (00038A84) --------------------------------------------------------
void *__fastcall copy_app_config(int a1)
{
  const char *v1; // r4
  size_t v2; // r0
  size_t v3; // r0
  size_t v4; // r0
  size_t v5; // r0
  void *result; // r0

  v1 = *(const char **)(a1 + 20);
  v2 = strlen(v1);
  memcpy((void *)MES2Local_Config_Information, v1, v2);
  v3 = strlen(*(const char **)(a1 + 24));
  memcpy((void *)(MES2Local_Config_Information + 16), *(const void **)(a1 + 24), v3);
  memset((void *)(MES2Local_Config_Information + 32), 0, 0x10u);
  v4 = strlen(*(const char **)(a1 + 28));
  memcpy((void *)(MES2Local_Config_Information + 32), *(const void **)(a1 + 28), v4);
  memset((void *)(MES2Local_Config_Information + 48), 0, 0x10u);
  v5 = strlen(*(const char **)(a1 + 16));
  result = memcpy((void *)(MES2Local_Config_Information + 48), *(const void **)(a1 + 16), v5);
  *(_DWORD *)(MES2Local_Config_Information + 64) = *(_DWORD *)(a1 + 40);
  *(_BYTE *)(MES2Local_Config_Information + 188) = *(_DWORD *)(a1 + 32) != 0;
  *(_BYTE *)(MES2Local_Config_Information + 189) = *(_DWORD *)(a1 + 36) != 0;
  *(_BYTE *)(MES2Local_Config_Information + 468) = *(_DWORD *)(a1 + 108) != 0;
  *(_BYTE *)(MES2Local_Config_Information + 88) = 0;
  *(_BYTE *)(MES2Local_Config_Information + 89) = 1;
  return result;
}
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (00038BE4) --------------------------------------------------------
int __fastcall prepare_mes_config_test_process(int a1)
{
  if ( (unsigned __int8)malloc_for_mes_config_information() != 1 )
    return 0;
  copy_app_config(a1);
  if ( !strcmp(*(const char **)(a1 + 20), "PT2") )
  {
    if ( *(_BYTE *)(MES2Local_Config_Information + 188) )
    {
      *(_BYTE *)(MES2Local_Config_Information + 189) = 0;
      memcpy(dest, (const void *)(MES2Local_Config_Information + 32), sizeof(dest));
      g_lcd_result_with_data = 22;
      pcba_display_result_on_lcd();
      if ( (unsigned __int8)prepare_MES_system_handshake_information(0) != 1 )
      {
        g_lcd_result_with_data = 23;
        pcba_display_result_on_lcd();
        printf("Prepare all config handshake fail");
        return 0;
      }
      if ( (unsigned __int8)download_MES_system_Config_file() != 1 )
        return 0;
      if ( (unsigned __int8)check_whether_MES_system_response_is_correct() != 1 )
        return 0;
      if ( (unsigned __int8)init_MES_system_config_information() != 1 )
        return 0;
      if ( (unsigned __int8)parse_MES_system_config_information(0) != 1 )
      {
        lcd_clear_result();
        lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
        lcd_show(1u, "parse MES all");
        lcd_show(2u, "config infor");
        lcd_show(3u, "fail");
        printf("parse MES all config infor fail");
        return 0;
      }
    }
    else
    {
      if ( *(_BYTE *)(MES2Local_Config_Information + 189) )
        *(_BYTE *)(MES2Local_Config_Information + 468) = 0;
      else
        *(_BYTE *)(MES2Local_Config_Information + 468) = 1;
      display_main_page();
      printf("You are in Manual PT2 test mode, please make sure all the configrations are correct!");
    }
    return 1;
  }
  return 1;
}
// 479D9C: using guessed type int MES2Local_Config_Information;
// 47BEA4: using guessed type int g_lcd_result_with_data;

//----- (00038D94) --------------------------------------------------------
int __fastcall check_scan_code_gun(int a1)
{
  int v2; // r0

  if ( pcba_chain_check() == 2 )
  {
    gCode_gun_chain = is_asic_pass(1);
    if ( gCode_gun_chain == 3 )
    {
      v2 = printf("gCode_gun_chain = %d\n", (unsigned __int8)gCode_gun_chain);
      if ( (*(int (__fastcall **)(int))a1)(v2) != 1 )
        (*(void (__fastcall **)(int))(a1 + 88))(1);
      return 1;
    }
    else
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "Scan code gun");
      lcd_show(2u, "don't plug on");
      lcd_show(3u, "J4");
      puts("Scan code gun don't plug on J4");
      return 0;
    }
  }
  else
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(2u, "Chain Error     ");
    puts("Don't detect hashboard or scan code gun");
    return 0;
  }
}
// 1ED1FC: using guessed type char gCode_gun_chain;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (00038E94) --------------------------------------------------------
int __fastcall check_sn_qr_code_legality(int a1, const char *a2)
{
  if ( strlen((const char *)(a1 + 1)) == 17 )
  {
    if ( strlen(a2 + 32) == 2 )
    {
      if ( strlen(a2 + 48) <= 0xD )
      {
        if ( strlen(a2 + 64) == 4 )
        {
          if ( strlen(a2 + 80) == 9 || strlen(a2 + 80) == 5 )
          {
            return 1;
          }
          else
          {
            lcd_clear_result();
            lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
            lcd_show(1u, "ft version");
            lcd_show(2u, "is not correct");
            printf("ft version isn't correct, ft version: %s", a2 + 80);
            return 0;
          }
        }
        else
        {
          lcd_clear_result();
          lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
          lcd_show(1u, "chip bin");
          lcd_show(2u, "is not correct");
          printf("chip bin isn't correct, chip bin: %s", a2 + 64);
          return 0;
        }
      }
      else
      {
        lcd_clear_result();
        lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
        lcd_show(1u, "chip marking");
        lcd_show(2u, "is not correct");
        printf("chip marking isn't correct, chip marking: %s", a2 + 48);
        return 0;
      }
    }
    else
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "chip die");
      lcd_show(2u, "is not correct");
      printf("chip die isn't correct, chip die: %s", a2 + 32);
      return 0;
    }
  }
  else
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(2u, "SN isn't correct");
    printf("SN isn't correct, sn: %s\n", (const char *)(a1 + 1));
    return 0;
  }
}
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0003906C) --------------------------------------------------------
int __fastcall scan_code_from_hashboard(int a1)
{
  int hardware_version; // r0
  char v5; // [sp+15h] [bp+Dh] BYREF
  _BYTE v6[2]; // [sp+16h] [bp+Eh] BYREF

  v6[0] = 0;
  v5 = 0;
  v6[1] = 0;
  if ( gScanCodeGun_data_ready == 3 )
  {
    if ( byte_1ED2B4 )
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "Got Scan code");
      lcd_show(2u, "Press");
      lcd_show(3u, "Start Key");
      puts("No need scan code, Press Start Key to Begin Test");
      byte_1ED2B4 = 0;
    }
    return 1;
  }
  usleep(0x249F0u);
  hardware_version = get_hardware_version();
  printf("FPGA version is 0x%08x\n", hardware_version);
  check_scan_code_gun(a1);
  (*(void (__fastcall **)(_DWORD, int))(a1 + 20))((unsigned __int8)gCode_gun_chain, 115200);
  flush_scanner_data();
  gScanCodeGun_data_ready = 0;
  while ( gScanCodeGun_data_ready != 3 )
  {
    v6[0] = 0;
    v5 = 0;
    if ( gScanCodeGun_data_ready == 1 )
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "SN code OK      ");
      lcd_show(2u, "Please Scan QR  ");
      lcd_show(3u, "code            ");
      puts("Please Scan QR code");
    }
    else if ( gScanCodeGun_data_ready == 2 )
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "QR code OK      ");
      lcd_show(2u, "Please Scan SN  ");
      lcd_show(3u, "code            ");
      puts("Please Scan SN code");
    }
    else
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "Please Scan code");
      lcd_show(2u, "first");
    }
    scan_hashboard_info(gCode_gun_chain, &sn, qr_code, v6, &v5, 1000);
    if ( v6[0] )
    {
      gScanCodeGun_data_ready |= 1u;
      printf("Got SN code... gScanCodeGun_data_ready = %d", (unsigned __int8)gScanCodeGun_data_ready);
    }
    if ( v5 )
    {
      gScanCodeGun_data_ready |= 2u;
      printf("Got QR code... gScanCodeGun_data_ready = %d", (unsigned __int8)gScanCodeGun_data_ready);
    }
  }
  printf("SN data::[%s]\n", s);
  puts("QR code data::");
  printf("factory_job::[%s].\n", qr_code);
  printf("chip_die::[%s].\n", word_47BF14);
  printf("chip_marking::[%s].\n", dword_47BF24);
  printf("chip_bin::[%s].\n", byte_47BF34);
  printf("chip_ftversion::[%s].\n", src);
  printf("temp_sensor_type::[%s].\n", byte_47BF54);
  printf("hashboard_ctrl_code::[%s].\n", byte_47BF64);
  printf("hashboard_index::[%s].\n", byte_47BF74);
  if ( (unsigned __int8)check_sn_qr_code_legality((int)&sn, qr_code) == 1 )
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "Got Scan code");
    lcd_show(2u, "wait for find");
    lcd_show(3u, "test standard");
    puts("got scan code");
    return 1;
  }
  gScanCodeGun_data_ready = 0;
  return 0;
}
// 1ED1FC: using guessed type char gCode_gun_chain;
// 1ED2B4: using guessed type char byte_1ED2B4;
// 1F0C84: using guessed type char gScanCodeGun_data_ready;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (00039434) --------------------------------------------------------
int print_local_config_after_parse_MES_system_information()
{
  const char *v0; // r3
  const char *v1; // r3
  const char *v2; // r3
  const char *v3; // r3
  const char *v4; // r3
  const char *v5; // r3
  const char *v6; // r3
  const char *v7; // r3
  const char *v8; // r3
  const char *v9; // r3
  unsigned int i; // [sp+4h] [bp+4h]
  unsigned int j; // [sp+4h] [bp+4h]
  unsigned int k; // [sp+4h] [bp+4h]

  putchar(32);
  printf("Test_Process : %s", (const char *)MES2Local_Config_Information);
  printf("Miner_Type : %s", (const char *)(MES2Local_Config_Information + 16));
  printf("Board_Name : %s", (const char *)(MES2Local_Config_Information + 32));
  printf("Asic_Type : %s", (const char *)(MES2Local_Config_Information + 48));
  printf("Asic_Num : %d", *(_DWORD *)(MES2Local_Config_Information + 64));
  printf("Voltage_Domain : %d", *(_DWORD *)(MES2Local_Config_Information + 80));
  printf("Asic_Num_Per_Voltage_Domain : %d", *(_DWORD *)(MES2Local_Config_Information + 84));
  if ( *(_BYTE *)(MES2Local_Config_Information + 88) )
    v0 = "true";
  else
    v0 = "false";
  printf("Read_Temperature_From_Pic : %s", v0);
  if ( *(_BYTE *)(MES2Local_Config_Information + 89) )
    v1 = "true";
  else
    v1 = "false";
  printf("Read_Temperature_From_Asic : %s", v1);
  printf("Pic_Sensor_Model : %s", (const char *)(MES2Local_Config_Information + 92));
  printf("gPic_sensor_num : %d", gPic_sensor_num);
  for ( i = 0; i < gPic_sensor_num; ++i )
    ;
  printf("Asic_Sensor_Model : %s", (const char *)(MES2Local_Config_Information + 124));
  printf("gAsic_sensor_num : %d", gAsic_sensor_num);
  for ( j = 0; j < gAsic_sensor_num; ++j )
    ;
  if ( *(_BYTE *)(MES2Local_Config_Information + 188) )
    v2 = "true";
  else
    v2 = "false";
  printf("Factory_Mode : %s", v2);
  if ( *(_BYTE *)(MES2Local_Config_Information + 189) )
    v3 = "true";
  else
    v3 = "false";
  printf("Bypass_Scan_Code_Gun : %s", v3);
  if ( *(_BYTE *)(MES2Local_Config_Information + 192) )
    v4 = "true";
  else
    v4 = "false";
  printf("Software_Pattern : %s", v4);
  if ( *(_BYTE *)(MES2Local_Config_Information + 193) )
    v5 = "true";
  else
    v5 = "false";
  printf("Hardware_Pattern : %s", v5);
  if ( *(_BYTE *)(MES2Local_Config_Information + 194) )
    v6 = "true";
  else
    v6 = "false";
  printf("Autogen_Pattern : %s", v6);
  printf("Midstate_Number : %d", *(_DWORD *)(MES2Local_Config_Information + 196));
  printf("Pattern_Number : %d", *(_DWORD *)(MES2Local_Config_Information + 200));
  printf("Invalid_Core_Number : %d", *(_DWORD *)(MES2Local_Config_Information + 204));
  printf("Least_Nonce_Per_Core : %d", *(_DWORD *)(MES2Local_Config_Information + 208));
  printf("Nonce_Rate : %d", *(_DWORD *)(MES2Local_Config_Information + 212));
  printf("Most_HW_Num : %d", *(_DWORD *)(MES2Local_Config_Information + 220));
  printf("In local config file, gTest_loop : %d", gTest_loop);
  for ( k = 0; k < gTest_loop; ++k )
  {
    printf("Test_Loop[%d]->Level : %d", k, *(_DWORD *)(16 * (k + 2) + MES2Local_Config_Information + 192));
    printf(
      "Test_Loop[%d]->Pre_Open_Core_Voltage : %d",
      k,
      *(_DWORD *)(16 * (k + 2) + MES2Local_Config_Information + 196));
    printf("Test_Loop[%d]->Voltage : %d", k, *(_DWORD *)(16 * (k + 14) + MES2Local_Config_Information + 8));
    printf("Test_Loop[%d]->Frequence : %d", k, *(_DWORD *)(16 * (k + 14) + MES2Local_Config_Information + 12));
  }
  printf("Baudrate : %d", *(_DWORD *)(MES2Local_Config_Information + 384));
  printf("Timeout : %d", *(_DWORD *)(MES2Local_Config_Information + 388));
  printf("CCdly_Sel : %d", *(_DWORD *)(MES2Local_Config_Information + 392));
  printf("Pwth_Sel : %d", *(_DWORD *)(MES2Local_Config_Information + 396));
  printf("Swpf_Mode : %d", *(_DWORD *)(MES2Local_Config_Information + 400));
  printf("Pulse_Mode : %d", *(_DWORD *)(MES2Local_Config_Information + 404));
  printf("Clk_Sel : %d", *(_DWORD *)(MES2Local_Config_Information + 408));
  printf("RO_Relay_En : %d", *(_DWORD *)(MES2Local_Config_Information + 412));
  printf("CO_Relay_En : %d", *(_DWORD *)(MES2Local_Config_Information + 416));
  printf("Diode_Vdd_Mux_Sel : %d", *(_DWORD *)(MES2Local_Config_Information + 420));
  printf("Start_Temp_Gap_Pic : %d", *(_DWORD *)(MES2Local_Config_Information + 424));
  printf("Time_For_Cooling_Hashboard : %d", *(_DWORD *)(MES2Local_Config_Information + 432));
  printf("Fan_Speed : %d", *(_DWORD *)(MES2Local_Config_Information + 436));
  if ( *(_BYTE *)(MES2Local_Config_Information + 440) )
    v7 = "true";
  else
    v7 = "false";
  printf("Display_result_Voltage_Domain : %s", v7);
  if ( *(_BYTE *)(MES2Local_Config_Information + 441) )
    v8 = "true";
  else
    v8 = "false";
  printf("Display_result_Every_Core : %s", v8);
  printf("Test_Config_Data_Version : %s", (const char *)(MES2Local_Config_Information + 442));
  printf("Voltage_Accuracy : %d", *(_DWORD *)(MES2Local_Config_Information + 460));
  printf("Close_Power_Delay : %d", *(_DWORD *)(MES2Local_Config_Information + 464));
  if ( *(_BYTE *)(MES2Local_Config_Information + 468) )
    v9 = "true";
  else
    v9 = "false";
  printf("Clear_EEPROM_Data : %s", v9);
  return putchar(32);
}
// 479D58: using guessed type int gTest_loop;
// 479D9C: using guessed type int MES2Local_Config_Information;
// 47BFA8: using guessed type int gAsic_sensor_num;
// 47BFC0: using guessed type int gPic_sensor_num;

//----- (00039ACC) --------------------------------------------------------
int __fastcall get_sensor_type(int a1)
{
  if ( !strcmp((const char *)(a1 + 96), "TMP451") )
  {
    printf("sensor type is TMP451");
    return 1;
  }
  else if ( !strcmp((const char *)(a1 + 96), "NCT218") )
  {
    printf("sensor type is NCT218");
    return 5;
  }
  else if ( !strcmp((const char *)(a1 + 96), "LM75A") )
  {
    printf("sensor type is LM75A");
    return 10;
  }
  else if ( !strcmp((const char *)(a1 + 96), "TMP75A") )
  {
    printf("sensor type is TMP75A");
    return 11;
  }
  else if ( !strcmp((const char *)(a1 + 96), "DS75S") )
  {
    printf("sensor type is DS75S");
    return 12;
  }
  else if ( !strcmp((const char *)(a1 + 96), "GM452") )
  {
    printf("sensor type is GM452");
    return 13;
  }
  else if ( !strcmp((const char *)(a1 + 96), "CT75") )
  {
    printf("sensor type is CT75");
    return 14;
  }
  else
  {
    printf("Can't get sensor type. temp_sensor_type: %s", (const char *)(a1 + 96));
    return 0;
  }
}

//----- (00039C08) --------------------------------------------------------
int print_eeprom_data()
{
  printf("algorithm_and_key_version:             0x%02x\n", (unsigned __int8)zhiju_eeprom_data);
  printf("zhiju_information_length:              %d\n", (unsigned __int8)byte_47BFC5);
  printf("zhiju_information_format_version:      %d\n", (unsigned __int8)byte_47BFC6);
  printf(
    "hashboard_sn:                          %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
    (unsigned __int8)dword_47BFC7,
    BYTE1(dword_47BFC7),
    BYTE2(dword_47BFC7),
    HIBYTE(dword_47BFC7),
    (unsigned __int8)dword_47BFCB,
    BYTE1(dword_47BFCB),
    BYTE2(dword_47BFCB),
    HIBYTE(dword_47BFCB),
    (unsigned __int8)dword_47BFCF,
    BYTE1(dword_47BFCF),
    BYTE2(dword_47BFCF),
    HIBYTE(dword_47BFCF),
    (unsigned __int8)dword_47BFD3,
    BYTE1(dword_47BFD3),
    BYTE2(dword_47BFD3),
    HIBYTE(dword_47BFD3),
    (unsigned __int8)byte_47BFD7);
  printf("chip_die:                              %c%c\n", (unsigned __int8)word_47BFD8, HIBYTE(word_47BFD8));
  printf(
    "chip_marking:                          %c%c%c%c%c%c%c%c%c%c%c%c%c\n",
    (unsigned __int8)dword_47BFDA,
    BYTE1(dword_47BFDA),
    BYTE2(dword_47BFDA),
    HIBYTE(dword_47BFDA),
    (unsigned __int8)dword_47BFDE,
    BYTE1(dword_47BFDE),
    BYTE2(dword_47BFDE),
    HIBYTE(dword_47BFDE),
    (unsigned __int8)dword_47BFE2,
    BYTE1(dword_47BFE2),
    BYTE2(dword_47BFE2),
    HIBYTE(dword_47BFE2),
    (unsigned __int8)byte_47BFE6);
  printf("chip_bin:                              %d\n", (unsigned __int8)byte_47BFE7);
  printf(
    "chip_ft_program_version:               %c%c%c%c%c%c%c%c%c\n",
    (unsigned __int8)dword_47BFE8,
    BYTE1(dword_47BFE8),
    BYTE2(dword_47BFE8),
    HIBYTE(dword_47BFE8),
    (unsigned __int8)dword_47BFEC,
    BYTE1(dword_47BFEC),
    BYTE2(dword_47BFEC),
    HIBYTE(dword_47BFEC),
    (unsigned __int8)byte_47BFF0);
  printf("asic_sensor:                           0x%02x\n", (unsigned __int8)byte_47BFF1);
  printf(
    "asic_sensor_addr:                      %d, %d, %d, %d\n",
    (unsigned __int8)byte_47BFF2,
    (unsigned __int8)byte_47BFF3,
    (unsigned __int8)byte_47BFF4,
    (unsigned __int8)byte_47BFF5);
  printf("pic_sensor:                            0x%02x\n", (unsigned __int8)byte_47BFF6);
  printf("pic_sensor_addr:                       0x%02x\n", (unsigned __int8)byte_47BFF7);
  printf("pcb_version_v1:                        %d\n", (unsigned __int8)byte_47BFF8);
  printf("pcb_version_v2:                        %d\n", (unsigned __int8)byte_47BFF9);
  printf("bom_version_v1:                        %d\n", (unsigned __int8)byte_47BFFA);
  printf("bom_version_v2:                        %d\n", (unsigned __int8)byte_47BFFB);
  printf("chip_technology:                       %c%c\n", (unsigned __int8)byte_47BFFC, (unsigned __int8)byte_47BFFD);
  printf(
    "voltage:                               %d\n",
    (unsigned __int8)byte_47BFFF | ((unsigned __int8)byte_47BFFE << 8));
  printf(
    "frequency:                             %d\n",
    (unsigned __int8)byte_47C001 | ((unsigned __int8)byte_47C000 << 8));
  printf(
    "nonce_rate:                            %d\n",
    (unsigned __int8)byte_47C003 | ((unsigned __int8)byte_47C002 << 8));
  printf("pcb_temprature_in:                     %d\n", byte_47C004);
  printf("pcb_temprature_out:                    %d\n", byte_47C005);
  printf("test_version:                          %d\n", (unsigned __int8)byte_47C006);
  printf("test_standard:                         %d\n", (unsigned __int8)byte_47C007);
  printf("miner_type:                         %s\n", byte_47C008);
  return printf("zhiju_information_crc5:                0x%02x\n", (unsigned __int8)byte_47C015);
}
// 47BFC4: using guessed type char zhiju_eeprom_data;
// 47BFC5: using guessed type char byte_47BFC5;
// 47BFC6: using guessed type char byte_47BFC6;
// 47BFC7: using guessed type int dword_47BFC7;
// 47BFCB: using guessed type int dword_47BFCB;
// 47BFCF: using guessed type int dword_47BFCF;
// 47BFD3: using guessed type int dword_47BFD3;
// 47BFD7: using guessed type char byte_47BFD7;
// 47BFD8: using guessed type __int16 word_47BFD8;
// 47BFDA: using guessed type int dword_47BFDA;
// 47BFDE: using guessed type int dword_47BFDE;
// 47BFE2: using guessed type int dword_47BFE2;
// 47BFE6: using guessed type char byte_47BFE6;
// 47BFE7: using guessed type char byte_47BFE7;
// 47BFE8: using guessed type int dword_47BFE8;
// 47BFEC: using guessed type int dword_47BFEC;
// 47BFF0: using guessed type char byte_47BFF0;
// 47BFF1: using guessed type char byte_47BFF1;
// 47BFF2: using guessed type char byte_47BFF2;
// 47BFF3: using guessed type char byte_47BFF3;
// 47BFF4: using guessed type char byte_47BFF4;
// 47BFF5: using guessed type char byte_47BFF5;
// 47BFF6: using guessed type char byte_47BFF6;
// 47BFF7: using guessed type char byte_47BFF7;
// 47BFF8: using guessed type char byte_47BFF8;
// 47BFF9: using guessed type char byte_47BFF9;
// 47BFFA: using guessed type char byte_47BFFA;
// 47BFFB: using guessed type char byte_47BFFB;
// 47BFFC: using guessed type char byte_47BFFC;
// 47BFFD: using guessed type char byte_47BFFD;
// 47BFFE: using guessed type char byte_47BFFE;
// 47BFFF: using guessed type char byte_47BFFF;
// 47C000: using guessed type char byte_47C000;
// 47C001: using guessed type char byte_47C001;
// 47C002: using guessed type char byte_47C002;
// 47C003: using guessed type char byte_47C003;
// 47C004: using guessed type char byte_47C004;
// 47C005: using guessed type char byte_47C005;
// 47C006: using guessed type char byte_47C006;
// 47C007: using guessed type char byte_47C007;
// 47C015: using guessed type char byte_47C015;

//----- (0003A148) --------------------------------------------------------
int __fastcall prepare_eeprom_data(int a1)
{
  size_t v2; // r3
  unsigned __int8 v5[2]; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 v6; // [sp+12h] [bp+Ah]
  unsigned __int8 v7; // [sp+13h] [bp+Bh]
  char v8; // [sp+17h] [bp+Fh]
  int v9; // [sp+18h] [bp+10h]
  int v10; // [sp+1Ch] [bp+14h]
  int v11; // [sp+20h] [bp+18h]
  size_t n; // [sp+24h] [bp+1Ch]

  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 1;
  zhiju_eeprom_data = 17;
  byte_47BFC5 = 80;
  byte_47BFC6 = 3;
  n = strlen(s);
  if ( n > 0x11 )
  {
    dword_47BFC7 = *(_DWORD *)s;
    dword_47BFCB = dword_47BF89;
    dword_47BFCF = dword_47BF8D;
    dword_47BFD3 = dword_47BF91;
    byte_47BFD7 = byte_47BF95;
  }
  else
  {
    memcpy(&dword_47BFC7, s, n);
  }
  n = strlen(word_47BF14);
  if ( n > 2 )
    word_47BFD8 = *(_WORD *)word_47BF14;
  else
    memcpy(&word_47BFD8, word_47BF14, n);
  n = strlen(dword_47BF24);
  if ( n > 0xD )
  {
    dword_47BFDA = *(_DWORD *)dword_47BF24;
    dword_47BFDE = dword_47BF28;
    dword_47BFE2 = dword_47BF2C;
    byte_47BFE6 = byte_47BF30;
  }
  else
  {
    memcpy(&dword_47BFDA, dword_47BF24, n);
  }
  byte_47BFE7 = get_chip_bin((int)qr_code);
  if ( (strlen(src) == 9 || strlen(src) == 5) && get_chip_ft_program_version_ex((int)qr_code, (int)&dword_47BFE8) )
  {
    dword_47BFE8 = *(_DWORD *)src;
    dword_47BFEC = dword_47BF48;
    byte_47BFF0 = byte_47BF4C;
    byte_47BFF6 = 0;
    byte_47BFF1 = 0;
    get_hardware_infor(qr_code);
    get_chip_technology((hashboard_qr_code *)qr_code);
    byte_47BFFE = BYTE1(*((_DWORD *)&gHistory_Result + 66450 * a1 + 5));
    byte_47BFFF = *((_DWORD *)&gHistory_Result + 66450 * a1 + 5);
    byte_47C000 = BYTE1(*((_DWORD *)&gHistory_Result + 66450 * a1 + 7));
    byte_47C001 = *((_DWORD *)&gHistory_Result + 66450 * a1 + 7);
    byte_47C002 = (unsigned __int16)(unsigned int)(*((double *)&gHistory_Result + 33225 * a1 + 1) * 100.0) >> 8;
    byte_47C003 = (unsigned int)(*((double *)&gHistory_Result + 33225 * a1 + 1) * 100.0);
    memset(byte_47C008, 0, 8u);
    if ( *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 4) == 7 )
    {
      if ( !get_chip_ft_program_version(qr_code, v5) )
        return 0;
      printf("FT version : %d %02d %d %d\n", v5[0], v5[1], v6, v7);
      if ( v6 == 1 )
      {
        memcpy(byte_47C008, "D7", 2u);
      }
      else
      {
        if ( v6 != 2 && v6 != 3 )
        {
          printf("Wrong ft version. ft_version[2]: %d\n", v6);
          return 0;
        }
        memcpy(byte_47C008, "D7e", 3u);
      }
    }
    else
    {
      n = strlen((const char *)(MES2Local_Config_Information + 16));
      v2 = n;
      if ( n >= 8 )
        v2 = 8;
      memcpy(byte_47C008, (const void *)(MES2Local_Config_Information + 16), v2);
    }
    byte_47C006 = atoi((const char *)(MES2Local_Config_Information + 442));
    byte_47C007 = *((_BYTE *)&gHistory_Result + 265800 * a1 + 265796);
    memset(eeprom_data_buf, 255, 0x60u);
    eeprom_data_buf[0] = zhiju_eeprom_data;
    byte_1ED19D = byte_47BFC5 + 2;
    memcpy(dword_1ED19E, &byte_47BFC6, (unsigned __int8)byte_47BFC5);
    byte_47C015 = CRC5_long((const uint8_t *)eeprom_data_buf, 8 * ((unsigned __int8)byte_1ED19D - 1));
    eeprom_data_buf[(unsigned __int8)byte_1ED19D - 1] = byte_47C015;
    print_eeprom_data();
    if ( data_enc(dword_1ED19E, 0x50u, 1u, 1u) )
    {
      puts("\nEEPROM data after encrypted:");
      print_eeprom_data_in_hex((int)eeprom_data_buf, 0x52u);
      return 1;
    }
    else
    {
      puts("EEPROM data encrypt fail");
      return 0;
    }
  }
  else
  {
    lcd_show_one(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "FT version");
    lcd_show(2u, "error");
    printf("FT version: %s. error\n", src);
    return 0;
  }
}
// 1ED19D: using guessed type char byte_1ED19D;
// 1ED19E: using guessed type unsigned int dword_1ED19E[23];
// 1F0C98: using guessed type int g_config_info;
// 479D9C: using guessed type int MES2Local_Config_Information;
// 47BF28: using guessed type int dword_47BF28;
// 47BF2C: using guessed type int dword_47BF2C;
// 47BF30: using guessed type char byte_47BF30;
// 47BF48: using guessed type int dword_47BF48;
// 47BF4C: using guessed type char byte_47BF4C;
// 47BF89: using guessed type int dword_47BF89;
// 47BF8D: using guessed type int dword_47BF8D;
// 47BF91: using guessed type int dword_47BF91;
// 47BF95: using guessed type char byte_47BF95;
// 47BFC4: using guessed type char zhiju_eeprom_data;
// 47BFC5: using guessed type char byte_47BFC5;
// 47BFC6: using guessed type char byte_47BFC6;
// 47BFC7: using guessed type int dword_47BFC7;
// 47BFCB: using guessed type int dword_47BFCB;
// 47BFCF: using guessed type int dword_47BFCF;
// 47BFD3: using guessed type int dword_47BFD3;
// 47BFD7: using guessed type char byte_47BFD7;
// 47BFD8: using guessed type __int16 word_47BFD8;
// 47BFDA: using guessed type int dword_47BFDA;
// 47BFDE: using guessed type int dword_47BFDE;
// 47BFE2: using guessed type int dword_47BFE2;
// 47BFE6: using guessed type char byte_47BFE6;
// 47BFE7: using guessed type char byte_47BFE7;
// 47BFE8: using guessed type int dword_47BFE8;
// 47BFEC: using guessed type int dword_47BFEC;
// 47BFF0: using guessed type char byte_47BFF0;
// 47BFF1: using guessed type char byte_47BFF1;
// 47BFF6: using guessed type char byte_47BFF6;
// 47BFFE: using guessed type char byte_47BFFE;
// 47BFFF: using guessed type char byte_47BFFF;
// 47C000: using guessed type char byte_47C000;
// 47C001: using guessed type char byte_47C001;
// 47C002: using guessed type char byte_47C002;
// 47C003: using guessed type char byte_47C003;
// 47C006: using guessed type char byte_47C006;
// 47C007: using guessed type char byte_47C007;
// 47C015: using guessed type char byte_47C015;

//----- (0003A68C) --------------------------------------------------------
int __fastcall PT2_display_result_on_LCD(int a1)
{
  int result; // r0
  int v2; // r3
  int v3; // r3
  int v5; // [sp+14h] [bp+Ch]
  int v6; // [sp+18h] [bp+10h]
  int v7; // [sp+1Ch] [bp+14h]
  int v8; // [sp+20h] [bp+18h]
  char s[16]; // [sp+24h] [bp+1Ch] BYREF
  int v10; // [sp+34h] [bp+2Ch]
  char v11; // [sp+3Bh] [bp+33h]
  unsigned __int8 v12; // [sp+3Ch] [bp+34h]
  unsigned __int8 i; // [sp+3Dh] [bp+35h]
  unsigned __int8 v14; // [sp+3Eh] [bp+36h]
  char v15; // [sp+3Fh] [bp+37h]
  _BYTE v16[4]; // [sp+40h] [bp+38h] BYREF

  v15 = 1;
  v14 = 0;
  i = 0;
  v12 = 0;
  v11 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v10 = 0;
  result = lcd_clear_result();
  if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 265796) )
  {
    if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 265796) == 1 )
    {
      lcd_show(1u, "Pattern: OK");
      for ( i = 0; (unsigned int)i < *(_DWORD *)(MES2Local_Config_Information + 64); ++i )
      {
        if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + i + 265520) != 1 )
        {
          ++v14;
          if ( v12 <= 3u )
          {
            v2 = v12++;
            *(_DWORD *)&v16[4 * v2 - 44] = i;
          }
        }
      }
      if ( v14 )
      {
        memset(s, 0, sizeof(s));
        switch ( v14 )
        {
          case 1u:
            sprintf(s, "B_A: %d", v5);
            break;
          case 2u:
            sprintf(s, "B_A: %d %d", v5, v6);
            break;
          case 3u:
            sprintf(s, "B_A: %d %d %d", v5, v6, v7);
            break;
          default:
            sprintf(s, "B_A: %d %d %d %d", v5, v6, v7, v8);
            break;
        }
        lcd_show(3u, s);
      }
      if ( *(_BYTE *)(MES2Local_Config_Information + 88) )
      {
        if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 2) && *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) )
        {
          result = lcd_show(2u, "EE: OK   P_S: OK");
        }
        else if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 2) && *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) != 1 )
        {
          result = lcd_show(2u, "EE: OK   P_S: NG");
          v15 = 0;
        }
        else if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 2) != 1 && *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) )
        {
          result = lcd_show(2u, "EE: NG   P_S: OK");
          v15 = 0;
        }
        else
        {
          result = lcd_show(2u, "EE: NG   P_S: NG");
          v15 = 0;
        }
      }
      else if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 2) )
      {
        result = lcd_show(2u, "EEPROM:  OK");
      }
      else
      {
        result = lcd_show(2u, "EEPROM:  NG");
        v15 = 0;
      }
      if ( v15 )
      {
        memset(s, 0, sizeof(s));
        sprintf(s, "Level:  %d", *((_DWORD *)&gHistory_Result + 66450 * a1 + 4) + 100);
        return lcd_show(0, s);
      }
    }
    else if ( *((unsigned __int8 *)&gHistory_Result + 265800 * a1 + 265796) == 240 )
    {
      if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 2) )
      {
        result = lcd_show(0, "EEPROM:  OK");
      }
      else
      {
        result = lcd_show(0, "EEPROM:  NG");
        v15 = 0;
      }
      if ( *(_BYTE *)(MES2Local_Config_Information + 88) && *(_BYTE *)(MES2Local_Config_Information + 89) != 1 )
      {
        if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) )
        {
          result = lcd_show(1u, "PIC Sensor: OK");
        }
        else
        {
          result = lcd_show(1u, "PIC Sensor: NG");
          v15 = 0;
        }
      }
      if ( *(_BYTE *)(MES2Local_Config_Information + 88) != 1 && *(_BYTE *)(MES2Local_Config_Information + 89) )
      {
        if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 4) )
        {
          result = lcd_show(1u, "ASIC Sensor:  OK");
        }
        else
        {
          result = lcd_show(1u, "ASIC Sensor:  NG");
          v15 = 0;
        }
      }
      if ( *(_BYTE *)(MES2Local_Config_Information + 88) && *(_BYTE *)(MES2Local_Config_Information + 89) )
      {
        if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) && *((_BYTE *)&gHistory_Result + 265800 * a1 + 4) )
        {
          result = lcd_show(1u, "P_S: OK  A_S: OK");
        }
        else if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) )
        {
          result = lcd_show(1u, "P_S: OK  A_S: NG");
          v15 = 0;
        }
        else
        {
          if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 4) )
            result = lcd_show(1u, "P_S: NG  A_S: OK");
          else
            result = lcd_show(1u, "P_S: NG  A_S: NG");
          v15 = 0;
        }
      }
      for ( i = 0; (unsigned int)i < *(_DWORD *)(MES2Local_Config_Information + 64); ++i )
      {
        result = a1;
        if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + i + 265520) != 1 )
        {
          ++v14;
          if ( v12 <= 3u )
          {
            v3 = v12++;
            *(_DWORD *)&v16[4 * v3 - 44] = i;
          }
        }
      }
      if ( v14 )
      {
        memset(s, 0, sizeof(s));
        sprintf(s, "B_A:  %d  pcs", v14);
        lcd_show(2u, s);
        memset(s, 0, sizeof(s));
        switch ( v14 )
        {
          case 1u:
            sprintf(s, "%d", v5);
            break;
          case 2u:
            sprintf(s, "%d  %d", v5, v6);
            break;
          case 3u:
            sprintf(s, "%d  %d  %d", v5, v6, v7);
            break;
          default:
            sprintf(s, "%d %d %d %d", v5, v6, v7, v8);
            break;
        }
        return lcd_show(3u, s);
      }
    }
    else if ( *((unsigned __int8 *)&gHistory_Result + 265800 * a1 + 265796) == 255 )
    {
      puts("Don't get result");
      return lcd_show(1u, "Don't get result");
    }
  }
  else
  {
    lcd_show(1u, "Pattern: OK");
    if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 2) )
    {
      result = lcd_show(2u, "EEPROM:  OK");
    }
    else
    {
      result = lcd_show(2u, "EEPROM:  NG");
      v15 = 0;
    }
    if ( *(_BYTE *)(MES2Local_Config_Information + 88) && *(_BYTE *)(MES2Local_Config_Information + 89) != 1 )
    {
      if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) )
      {
        result = lcd_show(3u, "PIC Sensor: OK");
      }
      else
      {
        result = lcd_show(3u, "PIC Sensor: NG");
        v15 = 0;
      }
    }
    if ( *(_BYTE *)(MES2Local_Config_Information + 88) != 1 && *(_BYTE *)(MES2Local_Config_Information + 89) )
    {
      if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 4) )
      {
        result = lcd_show(3u, "ASIC Sensor:  OK");
      }
      else
      {
        result = lcd_show(3u, "ASIC Sensor:  NG");
        v15 = 0;
      }
    }
    if ( *(_BYTE *)(MES2Local_Config_Information + 88) && *(_BYTE *)(MES2Local_Config_Information + 89) )
    {
      if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) && *((_BYTE *)&gHistory_Result + 265800 * a1 + 4) )
      {
        result = lcd_show(3u, "P_S: OK  A_S: OK");
      }
      else if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 3) )
      {
        result = lcd_show(3u, "P_S: OK  A_S: NG");
        v15 = 0;
      }
      else
      {
        if ( *((_BYTE *)&gHistory_Result + 265800 * a1 + 4) )
          result = lcd_show(3u, "P_S: NG  A_S: OK");
        else
          result = lcd_show(3u, "P_S: NG  A_S: NG");
        v15 = 0;
      }
    }
    if ( v15 )
    {
      memset(s, 0, sizeof(s));
      sprintf(s, "Level:  %d", *((_DWORD *)&gHistory_Result + 66450 * a1 + 4));
      return lcd_show(0, s);
    }
  }
  return result;
}
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0003B070) --------------------------------------------------------
int __fastcall do_PT2_summary_work(unsigned __int8 a1)
{
  printf("Pattern test done. Test level_index: %d\n", a1);
  if ( *(_BYTE *)(MES2Local_Config_Information + 189) != 1 )
  {
    if ( (unsigned __int8)prepare_eeprom_data(a1) != 1 )
    {
      lcd_show_one(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "prepare");
      lcd_show(2u, "eeprom data");
      lcd_show(3u, "fail");
      puts("prepare eeprom data fail");
      return 0;
    }
    if ( eeprom_write(gChain, 0, (int)eeprom_data_buf, 0x52u) )
    {
      lcd_show_one(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "Write eeprom");
      lcd_show(2u, "fail");
      *((_BYTE *)&gHistory_Result + 265800 * a1 + 2) = 0;
      puts("Write EEPROM fail");
      sleep(5u);
    }
    else
    {
      puts("Write EEPROM ok");
    }
  }
  if ( *(_BYTE *)(MES2Local_Config_Information + 189) != 1 )
  {
    if ( prepare_MES_system_submit_information(a1) )
    {
      if ( submit_result_to_MES_system() )
      {
        puts("submit result ok");
      }
      else
      {
        printf("save result into SD card");
        if ( save_MES_system_submit_result() )
          printf("save result into SD card success");
        else
          printf("save result into SD card fail");
      }
    }
    else
    {
      printf("prepare submit result information fail");
    }
    memset(&sn, 0, 0x21u);
    memset(qr_code, 0, 0x90u);
  }
  return 1;
}
// 1EC5C8: using guessed type int gChain;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0003B238) --------------------------------------------------------
int __fastcall find_submit_history_result_index(unsigned __int8 *a1)
{
  unsigned __int8 i; // [sp+Fh] [bp+Fh]

  if ( dword_47BE7C >= (unsigned int)(gTest_loop - 1) )
  {
    printf("We had do %d tests, and strict standard are not ok", dword_47BE7C + 1);
    for ( i = 0; i < (unsigned int)gTest_loop; ++i )
    {
      if ( *((_BYTE *)&gHistory_Result + 265800 * i + 265796) == 1 )
      {
        *a1 = i;
        printf("find history result index: %d, and it is LOOSE_STANDARD", *a1);
        return 0;
      }
    }
    *a1 = dword_47BE7C;
    printf("find history result index: %d, and this time pattern test fail", *a1);
    return 1;
  }
  else if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 265796) )
  {
    printf("Not find history result index, and go on testing. g_pcba_info.level_index = %d", dword_47BE7C);
    return 2;
  }
  else
  {
    *a1 = dword_47BE7C;
    printf("find history result index: %d, and it is STRICT_STANDARD", *a1);
    return 0;
  }
}
// 479D58: using guessed type int gTest_loop;
// 47BE7C: using guessed type int dword_47BE7C;

//----- (0003B374) --------------------------------------------------------
int __fastcall copy_eeprom(unsigned int a1, unsigned int a2)
{
  int result; // r0
  _BYTE v5[8]; // [sp+Ch] [bp+Ch] BYREF
  int i; // [sp+14h] [bp+14h]

  if ( eeprom_open(a1) < 0 )
    printf("EEPROM init fail!!!");
  result = eeprom_open(a2);
  if ( result < 0 )
    result = printf("EEPROM init fail!!!");
  for ( i = 0; i <= 89; ++i )
  {
    eeprom_read(a1, i, (int)v5, 1u);
    eeprom_write(a2, i, (int)v5, 1u);
    result = printf("write eeprom  %02x\n", v5[0]);
  }
  return result;
}

//----- (0003B3FC) --------------------------------------------------------
int __fastcall check_eeprom(unsigned int a1)
{
  char v3; // [sp+8h] [bp-600h] BYREF
  char v4; // [sp+208h] [bp-400h] BYREF
  char v5; // [sp+408h] [bp-200h] BYREF
  _DWORD v6[9]; // [sp+600h] [bp-8h] BYREF
  unsigned int v7; // [sp+624h] [bp+1Ch]
  char v8; // [sp+62Bh] [bp+23h]
  char *v9; // [sp+62Ch] [bp+24h]
  int v10; // [sp+630h] [bp+28h]
  char *v11; // [sp+634h] [bp+2Ch]
  int v12; // [sp+638h] [bp+30h]
  char *v13; // [sp+63Ch] [bp+34h]
  int v14; // [sp+640h] [bp+38h]
  int v15; // [sp+644h] [bp+3Ch]
  int v16; // [sp+648h] [bp+40h]
  unsigned int i; // [sp+64Ch] [bp+44h]

  v7 = a1;
  v6[8] = v6;
  i = 0;
  v16 = 512;
  v15 = 0;
  v14 = 511;
  v6[7] = 0;
  v6[6] = 4096;
  v6[5] = 0;
  v6[4] = 4096;
  v13 = &v5;
  v12 = 511;
  v6[3] = 0;
  v6[2] = 4096;
  v11 = &v4;
  v10 = 511;
  v9 = &v3;
  v8 = 0;
  *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) = 0;
  if ( eeprom_open(gChain) < 0 )
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(2u, "EEPROM init fail");
    printf("EEPROM init fail!!!");
    return 0;
  }
  for ( i = 0; i < v7; ++i )
  {
    v13[i] = i;
    v11[i] = -1;
  }
  if ( *(_BYTE *)(MES2Local_Config_Information + 468) )
  {
    puts("Check EEPROM with clear data");
    if ( eeprom_write(gChain, 0, (int)v13, v7) )
      goto LABEL_23;
    if ( eeprom_read(gChain, 0, (int)v11, v7) )
    {
LABEL_25:
      puts("Read EEPROM fail");
      return 0;
    }
    for ( i = 0; i < v7; ++i )
    {
      if ( v13[i] != v11[i] )
        goto LABEL_13;
    }
    for ( i = 0; i < v7; ++i )
      v13[i] = -1;
    if ( !eeprom_write(gChain, 0, (int)v13, v7) )
    {
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) = 1;
      return 1;
    }
LABEL_23:
    puts("Write EEPROM fail");
    return 0;
  }
  puts("Check EEPROM without clear data");
  if ( eeprom_read(gChain, 0, (int)v9, v7) )
    goto LABEL_25;
  if ( eeprom_write(gChain, 0, (int)v13, v7) )
    goto LABEL_23;
  if ( eeprom_read(gChain, 0, (int)v11, v7) )
    goto LABEL_25;
  for ( i = 0; i < v7; ++i )
  {
    if ( v13[i] != v11[i] )
    {
LABEL_13:
      printf(
        "EEPROM check fail! write_buf[%d] = 0x%02x, read_buf[%d] = 0x%02x\n",
        i,
        (unsigned __int8)v13[i],
        i,
        (unsigned __int8)v11[i]);
      return 0;
    }
  }
  if ( eeprom_write(gChain, 0, (int)v9, v7) )
  {
    puts("Backup write EEPROM fail");
    return 0;
  }
  else
  {
    *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) = 1;
    return 1;
  }
}
// 1EC5C8: using guessed type int gChain;
// 479D9C: using guessed type int MES2Local_Config_Information;
// 47BE7C: using guessed type int dword_47BE7C;

//----- (0003B7EC) --------------------------------------------------------
int dump_eeprom_data()
{
  _BYTE v1[512]; // [sp+4h] [bp+4h] BYREF
  int i; // [sp+204h] [bp+204h]

  i = 0;
  eeprom_read(gChain, 0, (int)v1, 0x100u);
  for ( i = 0; i <= 255; ++i )
  {
    printf("%02x ", (unsigned __int8)v1[i]);
    if ( i && (i & 7) == 0 )
      putchar(10);
  }
  return putchar(10);
}
// 1EC5C8: using guessed type int gChain;

//----- (0003B86C) --------------------------------------------------------
int write_EEPROM_PT1_marker()
{
  unsigned __int8 v1; // [sp+5h] [bp+5h] BYREF
  char v2; // [sp+6h] [bp+6h] BYREF
  char v3; // [sp+7h] [bp+7h]

  v2 = 90;
  v1 = 0;
  v3 = 1;
  if ( *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) )
  {
    if ( eeprom_write(gChain, 255, (int)&v2, 1u) )
    {
      puts("Write marker into EEPROM fail");
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) = 0;
      return 0;
    }
    else if ( eeprom_read(gChain, 255, (int)&v1, 1u) )
    {
      puts("Read marker from EEPROM fail");
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) = 0;
      return 0;
    }
    else if ( v1 == 90 )
    {
      puts("check marker saved in EEPROM success");
      return 1;
    }
    else
    {
      printf("check EEPROM marker fail. read bak is: 0x%02x\n", v1);
      *((_BYTE *)&gHistory_Result + 265800 * dword_47BE7C + 2) = 0;
      return 0;
    }
  }
  else
  {
    printf("gEEPROM_OK is %s, so no need write eeprom PT1 marker\n", "false");
    return 0;
  }
}
// 1EC5C8: using guessed type int gChain;
// 47BE7C: using guessed type int dword_47BE7C;

//----- (0003B9F4) --------------------------------------------------------
int check_PT1_EEPROM_marker()
{
  unsigned __int8 v2; // [sp+3h] [bp+3h] BYREF
  int v3; // [sp+4h] [bp+4h]

  v2 = 0;
  v3 = 0;
  v3 = eeprom_read(gChain, 255, (int)&v2, 1u);
  if ( v3 && (v3 = eeprom_read(gChain, 255, (int)&v2, 1u)) != 0 )
  {
    lcd_clear_result();
    lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
    lcd_show(1u, "read PT1 marker");
    lcd_show(2u, "fail");
    puts("read PT1 marker fail twice.");
    return 0;
  }
  else if ( v2 == 90 )
  {
    puts("This board already did PT1.");
    return 1;
  }
  else
  {
    printf("PT1 marker is 0x%02x.\n", v2);
    v3 = eeprom_read(gChain, 255, (int)&v2, 1u);
    if ( v3 && (v3 = eeprom_read(gChain, 255, (int)&v2, 1u)) != 0 )
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "read PT1 marker");
      lcd_show(2u, "fail");
      puts("read PT1 marker fail twice...");
      return 0;
    }
    else if ( v2 == 90 )
    {
      puts("This board already did PT1...");
      return 1;
    }
    else
    {
      lcd_clear_result();
      lcd_show(0, (const char *)(MES2Local_Config_Information + 32));
      lcd_show(1u, "This hashboard");
      lcd_show(2u, "didn't do PT1");
      printf("PT1 marker is 0x%02x...\n", v2);
      puts("This board didn't do PT1");
      return 0;
    }
  }
}
// 1EC5C8: using guessed type int gChain;
// 479D9C: using guessed type int MES2Local_Config_Information;

//----- (0003BB90) --------------------------------------------------------
int __fastcall sub_3BB90(int a1, unsigned __int8 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  (*(void (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
  return 1;
}

//----- (0003BBD8) --------------------------------------------------------
int __fastcall sub_3BBD8(int a1, unsigned __int8 a2, signed int a3, int a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _WORD s[8]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]
  signed int j; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]

  ptr = calloc(a3, 0xCu);
  memset(s, 0, sizeof(s));
  s[4] = 1;
  s[5] = a2;
  memset(ptr, 0, 12 * a3);
  (*(void (__fastcall **)(int, _WORD *, signed int, void *, int *))(a1 + 176))(a1, s, a3, ptr, &v9);
  for ( i = 0; i < v9; ++i )
  {
    for ( j = 0; j < a3; ++j )
    {
      if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) && a4 )
      {
        *(_BYTE *)(a4 + 8 * i) = *((_BYTE *)ptr + 12 * i + 4);
        *(_BYTE *)(a4 + 8 * i + 1) = *((_WORD *)ptr + 6 * i + 3);
        *(_DWORD *)(a4 + 8 * i + 4) = *((_DWORD *)ptr + 3 * i);
        break;
      }
    }
  }
  free(ptr);
  return v9;
}

//----- (0003BD10) --------------------------------------------------------
int __fastcall pcba_ckb_reg_init(int result)
{
  *(_DWORD *)(result + 304) = 1;
  return result;
}

//----- (0003BD2C) --------------------------------------------------------
int pcba_is_ckb_asic_valid()
{
  return 1;
}

//----- (0003BD44) --------------------------------------------------------
int pcba_calc_ckb_core_num()
{
  return *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12);
}
// 1F0C98: using guessed type int g_config_info;

//----- (0003BD68) --------------------------------------------------------
int __fastcall pcba_ckb_recv(int a1)
{
  _DWORD s[19]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 v5; // [sp+56h] [bp+56h]
  unsigned __int8 v6; // [sp+57h] [bp+57h]
  int v7; // [sp+58h] [bp+58h]
  unsigned __int8 v8; // [sp+5Fh] [bp+5Fh]

  memset(s, 0, 0x48u);
  if ( (*(unsigned __int8 (__fastcall **)(int, _DWORD *))(a1 + 36))(a1, s) == 1 )
  {
    v8 = s[3];
    v7 = 104 * g_patten_offset + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 8);
    v6 = (unsigned int)*(unsigned __int8 *)(v7 + 84) / *(_DWORD *)(a1 + 240);
    v5 = *(_BYTE *)(v7 + 88) & 0x1F;
    if ( s[3] == v5 && s[2] == v6 )
    {
      if ( !memcmp((char *)&s[14] + 3, (const void *)(v7 + 84), *(_DWORD *)(v7 + 92)) )
      {
        ++*(_DWORD *)(v7 + 100);
        need_pattern = 1;
        return 1;
      }
      printf("nonce match failed: chip%d, coreid%d, nonce offset %d\n", s[2], v8, g_patten_offset);
    }
    return 0;
  }
  return 0;
}
// 1EC5C4: using guessed type char need_pattern;
// 1F0C80: using guessed type int g_patten_offset;
// 1F0C98: using guessed type int g_config_info;

//----- (0003BE60) --------------------------------------------------------
int __fastcall pcba_ckb_send(int a1, int a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r6
  _DWORD *v4; // lr
  int v5; // r1
  int v6; // r2
  int v7; // r3
  char v8; // r1
  _BYTE s[132]; // [sp+8h] [bp+8h] BYREF
  int v12; // [sp+8Ch] [bp+8Ch]

  v12 = a2;
  memset(s, 0, 0x80u);
  v2 = (_DWORD *)(v12 + 4);
  v3 = &s[40];
  v4 = (_DWORD *)(v12 + 52);
  do
  {
    v5 = v2[1];
    v6 = v2[2];
    v7 = v2[3];
    *v3 = *v2;
    v3[1] = v5;
    v3[2] = v6;
    v3[3] = v7;
    v2 += 4;
    v3 += 4;
  }
  while ( v2 != v4 );
  sub_1A363C(s[83], *(_DWORD *)(a1 + 240));
  s[83] = v8;
  memset(&s[92], 255, 0x20u);
  return (*(int (__fastcall **)(int, _BYTE *))(a1 + 24))(a1, s);
}
// 3BEBC: variable 'v8' is possibly undefined

//----- (0003BEE8) --------------------------------------------------------
int __fastcall pcba_read_ckb_temperature(
        int a1,
        _DWORD *a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7)
{
  int v13; // [sp+24h] [bp+14h] BYREF
  int v14; // [sp+28h] [bp+18h] BYREF
  int v15; // [sp+2Ch] [bp+1Ch] BYREF
  int v16; // [sp+30h] [bp+20h] BYREF
  _DWORD *v17; // [sp+34h] [bp+24h]
  _DWORD *v18; // [sp+38h] [bp+28h]
  int i; // [sp+3Ch] [bp+2Ch]

  v18 = *(_DWORD **)(a1 + 212);
  *a2 = -150;
  *a3 = 150;
  *a4 = -150;
  *a5 = 150;
  for ( i = 0; v18[1] > i; ++i )
  {
    v17 = (_DWORD *)(20 * i + *v18);
    v14 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 100))(
      a1,
      &v16,
      &v14,
      *v17,
      v17[1],
      v17[2],
      v17[3],
      v17[4]);
    if ( v14 )
    {
      ++*a6;
      if ( *a2 < v16 )
        *a2 = v16;
      if ( *a3 > v16 )
        *a3 = v16;
    }
    v13 = 0;
    (*(void (__fastcall **)(int, int *, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(a1 + 104))(
      a1,
      &v15,
      &v13,
      *v17,
      v17[1],
      v17[2],
      v17[3],
      v17[4]);
    if ( v13 )
    {
      ++*a7;
      if ( *a4 < v15 )
        *a4 = v15;
      if ( *a5 > v15 )
        *a5 = v15;
    }
  }
  if ( *a6 == v18[1] && *a7 == v18[1] )
    return 0;
  else
    return -1;
}

//----- (0003C018) --------------------------------------------------------
void pcba_statistic_ckb_pattern_test_results()
{
  ;
}

//----- (0003C034) --------------------------------------------------------
int pcba_chain_check()
{
  int v1; // r2
  unsigned int v3; // [sp+0h] [bp+0h] BYREF
  int i; // [sp+8h] [bp+8h]
  int v6; // [sp+Ch] [bp+Ch]

  v6 = 0;
  v3 = 0;
  fpga_init();
  if ( fpga_read(8u, &v3) )
  {
    puts("read HASH_ON_PLUG failed");
    return 0;
  }
  else
  {
    for ( i = 0; i <= 3; ++i )
    {
      if ( ((v3 >> i) & 1) != 0 )
      {
        v1 = v6++;
        pcba_chain_info[v1] = i;
      }
    }
    return v6;
  }
}
// 47C01C: using guessed type _DWORD pcba_chain_info[4];

//----- (0003C0A8) --------------------------------------------------------
int __fastcall is_asic_pass(int a1)
{
  return pcba_chain_info[a1];
}
// 47C01C: using guessed type _DWORD pcba_chain_info[4];

//----- (0003C0CC) --------------------------------------------------------
void __cdecl _list_add(list_head *a1, list_head *prev, list_head *next)
{
  *((_DWORD *)next + 1) = a1;
  *(_DWORD *)a1 = next;
  *((_DWORD *)a1 + 1) = prev;
  *(_DWORD *)prev = a1;
}

//----- (0003C0FC) --------------------------------------------------------
void __cdecl list_add_tail(list_head *a1, list_head *head)
{
  _list_add(a1, *((list_head **)head + 1), head);
}

//----- (0003C11C) --------------------------------------------------------
unsigned __int8 __cdecl c2hex_0(unsigned __int8 value)
{
  unsigned __int8 v2; // [sp+Fh] [bp+Fh]

  v2 = -1;
  if ( value > 0x2Fu && value <= 0x39u )
    return value & 0xF;
  switch ( value )
  {
    case 'a':
    case 'A':
      return 10;
    case 'b':
    case 'B':
      return 11;
    case 'c':
    case 'C':
      return 12;
    case 'd':
    case 'D':
      return 13;
    case 'e':
    case 'E':
      return 14;
    case 'f':
    case 'F':
      return 15;
  }
  printf("input value error: %c\n", value);
  return v2;
}

//----- (0003C1C8) --------------------------------------------------------
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low)
{
  unsigned __int8 v4; // [sp+7h] [bp+7h]

  v4 = c2hex_0(high);
  return c2hex_0(low) ^ (16 * v4);
}

//----- (0003C20C) --------------------------------------------------------
int __cdecl s2hex(unsigned __int8 *dst, const char *src, int inlen)
{
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  if ( src && inlen > 0 && dst )
  {
    v8 = inlen / 2;
    v7 = inlen & 1;
    for ( i = 0; i < v8; ++i )
      dst[i] = twoc2hex(src[2 * i], src[2 * i + 1]);
    if ( v7 )
      dst[i] = twoc2hex(src[2 * i], 0);
    return v7 + v8;
  }
  else
  {
    printf("s2hex para error dst(%p), src(%p), inlen(%d)\n", dst, src, inlen);
    return -1;
  }
}
// 3C260: conditional instruction was optimized away because %var_20.4>=1

//----- (0003C2E4) --------------------------------------------------------
int __fastcall get_work_by_key(const json_t *a1, const char *a2, unsigned __int8 *a3, int a4)
{
  char *s; // [sp+10h] [bp+10h] BYREF
  unsigned __int8 v8; // [sp+17h] [bp+17h]

  v8 = 0;
  s = 0;
  if ( a4 )
  {
    if ( get_key_value_string(a1, a2, (void **)&s) )
    {
      if ( strlen(s) == 2 * a4 && s2hex(a3, s, 2 * a4) == a4 )
        v8 = 1;
      free(s);
    }
  }
  else
  {
    return 1;
  }
  return v8;
}

//----- (0003C35C) --------------------------------------------------------
int __fastcall get_work_element_len(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  unsigned __int8 v5; // [sp+17h] [bp+17h]

  v5 = 1;
  switch ( a1 )
  {
    case 0:
      *a2 = 246;
      *a3 = 4;
      *a4 = 168;
      break;
    case 1:
      *a2 = 64;
      *a3 = 4;
      *a4 = 0;
      break;
    case 2:
      *a2 = 48;
      *a3 = 5;
      *a4 = 0;
      break;
    case 5:
      *a2 = 32;
      *a3 = 8;
      *a4 = 32;
      break;
    case 6:
      *a2 = 80;
      *a3 = 4;
      *a4 = 0;
      break;
    case 7:
      *a2 = 80;
      *a3 = 4;
      *a4 = 0;
      break;
    default:
      v5 = 0;
      printf("%s, algo type error!\n", "get_work_element_len");
      break;
  }
  return v5;
}

//----- (0003C438) --------------------------------------------------------
int __fastcall get_work(int a1, const json_t *a2, int a3, int a4)
{
  bool v4; // r3

  v4 = get_work_element_len(a1, (_DWORD *)(a3 + 88), (_DWORD *)(a3 + 92), (_DWORD *)(a3 + 96))
    && get_work_by_key(a2, "work", (unsigned __int8 *)(a3 + 4), *(_DWORD *)(a3 + 88))
    && get_work_by_key(a2, "nonce", (unsigned __int8 *)(a3 + 84), *(_DWORD *)(a3 + 92))
    && get_work_by_key(a2, "sol", (unsigned __int8 *)(a3 + 88), *(_DWORD *)(a3 + 96));
  *(_DWORD *)(a3 + 100) = 0;
  *(_DWORD *)a3 = a4;
  return v4;
}

//----- (0003C4E0) --------------------------------------------------------
unsigned int __fastcall get_core_works(int a1, const char *a2, int a3, size_t a4)
{
  _BYTE v10[92]; // [sp+14h] [bp+14h] BYREF
  char v11[160]; // [sp+70h] [bp+70h] BYREF
  const json_t *v12; // [sp+110h] [bp+110h]
  json_t *v13; // [sp+114h] [bp+114h]
  const json_t *file; // [sp+118h] [bp+118h]
  unsigned int i; // [sp+11Ch] [bp+11Ch]

  file = (const json_t *)json_load_file(a2, 0, (json_error_t *)v10);
  if ( file && !*(_DWORD *)file )
  {
    v13 = json_object_get(file, "works");
    if ( v13 && *(_DWORD *)v13 == 1 )
    {
      if ( json_array_size(v13) < a4 )
      {
        printf("%s malloc failed!", "get_core_works");
        printf("%s: file_path %s, actual pattern number is less than test pattern_num!\n", "get_core_works", a2);
        return 0;
      }
      for ( i = 0; i < a4; ++i )
      {
        v12 = (const json_t *)json_array_get(v13, i);
        if ( !v12 )
          break;
        if ( *(_DWORD *)v12 || (unsigned __int8)get_work(a1, v12, a3 + 104 * i, i) != 1 )
        {
          printf("file_path %s, get_work error!\n", a2);
          return i;
        }
      }
    }
    return a4;
  }
  puts(v11);
  return 0;
}

//----- (0003C640) --------------------------------------------------------
int __fastcall get_core_works_from_txt(int a1, const char *a2, int a3, int a4)
{
  char s[512]; // [sp+10h] [bp+10h] BYREF
  int v11; // [sp+210h] [bp+210h]
  FILE *stream; // [sp+214h] [bp+214h]
  int i; // [sp+218h] [bp+218h]
  char *v14; // [sp+21Ch] [bp+21Ch]

  memset(s, 0, sizeof(s));
  i = 0;
  stream = fopen(a2, "r");
  for ( i = 0; i < a4; ++i )
  {
    v11 = 104 * i + a3;
    get_work_element_len(a1, (_DWORD *)(v11 + 88), (_DWORD *)(v11 + 92), (_DWORD *)(v11 + 96));
    *(_DWORD *)(v11 + 100) = 0;
    *(_DWORD *)v11 = i;
    fgets(s, 512, stream);
    v14 = strstr(s, "work");
    if ( !v14 )
    {
      puts("get work from pattern file error");
      return 0;
    }
    for ( v14 += 4; *v14 == 32; ++v14 )
      ;
    s2hex((unsigned __int8 *)(v11 + 4), v14, 2 * *(_DWORD *)(v11 + 88));
    v14 = strstr(s, "nonce");
    if ( !v14 )
    {
      puts("get nonce from pattern file error");
      return 0;
    }
    for ( v14 += 5; *v14 == 32; ++v14 )
      ;
    s2hex((unsigned __int8 *)(v11 + 84), v14, 2 * *(_DWORD *)(v11 + 92));
  }
  fclose(stream);
  return i;
}

//----- (0003C7E8) --------------------------------------------------------
int __fastcall eth_get_works_from_txt(const char *a1, list_head *a2, int a3, unsigned int a4)
{
  size_t v5; // r0
  size_t v6; // r0
  size_t v7; // r0
  char v13[68]; // [sp+24h] [bp+14h] BYREF
  char v14[20]; // [sp+68h] [bp+58h] BYREF
  char v15[68]; // [sp+7Ch] [bp+6Ch] BYREF
  int v16; // [sp+C0h] [bp+B0h] BYREF
  int v17; // [sp+C4h] [bp+B4h] BYREF
  int v18; // [sp+C8h] [bp+B8h] BYREF
  char s[512]; // [sp+CCh] [bp+BCh] BYREF
  list_head *v20; // [sp+2CCh] [bp+2BCh]
  int v21; // [sp+2D0h] [bp+2C0h]
  FILE *stream; // [sp+2D4h] [bp+2C4h]
  int v23; // [sp+2D8h] [bp+2C8h]
  unsigned int v24; // [sp+2DCh] [bp+2CCh]

  stream = 0;
  memset(s, 0, sizeof(s));
  v24 = 0;
  v23 = 0;
  stream = fopen(a1, "r");
  if ( stream )
  {
    while ( fgets(s, 512, stream) && v24 <= a4 )
    {
      v18 = 0;
      v17 = 0;
      v16 = 0;
      v21 = 0;
      memset(v15, 0, 0x41u);
      memset(v14, 0, 0x11u);
      memset(v13, 0, 0x41u);
      if ( !strstr(s, "header") || !strstr(s, "nonce") || !strstr(s, "mixhash") )
      {
        puts("error! failed to get work from pattern file");
        return 0;
      }
      v20 = (list_head *)malloc(0x64u);
      v21 = _isoc99_sscanf(s, "asic %d core %d pe %d header %s nonce %s mixhash %s\n", &v18, &v17, &v16, v15, v14, v13);
      if ( v21 != 6 )
      {
        printf("failed to get data from pattern file!");
        return 0;
      }
      *((_DWORD *)v20 + 3) = v18;
      *((_DWORD *)v20 + 4) = v17;
      *((_DWORD *)v20 + 5) = v16;
      v5 = strlen(v15);
      s2hex((unsigned __int8 *)v20 + 24, v15, v5);
      v6 = strlen(v14);
      s2hex((unsigned __int8 *)v20 + 56, v14, v6);
      v7 = strlen(v13);
      s2hex((unsigned __int8 *)v20 + 64, v13, v7);
      *((_BYTE *)v20 + 96) = 0;
      *((_DWORD *)v20 + 2) = (*((_DWORD *)v20 + 3) << 12)
                           | (*((_DWORD *)v20 + 4) << 8)
                           | (16 * *((_DWORD *)v20 + 5))
                           | v23++;
      if ( a3 - 1 < v23 )
        v23 = 0;
      list_add_tail(v20, a2);
      ++v24;
    }
    fclose(stream);
    return v24;
  }
  else
  {
    perror("failed to open pattern file!");
    return -1;
  }
}
// 20908: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0003CA8C) --------------------------------------------------------
int __fastcall get_all_works(int a1)
{
  _DWORD *v1; // r4
  char s[64]; // [sp+1Ch] [bp+Ch] BYREF
  int v6; // [sp+5Ch] [bp+4Ch]
  int v7; // [sp+60h] [bp+50h]
  unsigned int core_works_from_txt; // [sp+64h] [bp+54h]
  unsigned int j; // [sp+68h] [bp+58h]
  unsigned int i; // [sp+6Ch] [bp+5Ch]

  memset(s, 0, sizeof(s));
  i = 0;
  j = 0;
  v7 = 0;
  printf(
    "%s, AsicNum %d, CoreNum %d, PatternNum %d\n",
    "get_all_works",
    *(_DWORD *)(a1 + 40),
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12),
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16));
  v1 = *(_DWORD **)(a1 + 8);
  v1[2] = malloc(104 * v1[4] * v1[3] * *(_DWORD *)(a1 + 40));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) )
  {
    for ( i = 0; *(_DWORD *)(a1 + 40) > i; ++i )
    {
      for ( j = 0; *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12) > j; ++j )
      {
        v6 = 104 * *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) * (j + i * *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12))
           + *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8);
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) == 6 || *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) == 7 )
        {
          sprintf(
            s,
            "%s/%s/%s%02d/%s%02d.txt",
            *(const char **)(a1 + 12),
            **(const char ***)(a1 + 8),
            "asic-",
            i,
            "core-",
            j);
          core_works_from_txt = get_core_works_from_txt(
                                  *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4),
                                  s,
                                  v6,
                                  *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16));
        }
        else
        {
          sprintf(
            s,
            "%s/%s/%s%02d/%s%02d.json",
            *(const char **)(a1 + 12),
            **(const char ***)(a1 + 8),
            "asic-",
            i,
            "core-",
            j);
          core_works_from_txt = get_core_works(
                                  *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4),
                                  s,
                                  v6,
                                  *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16));
        }
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) > core_works_from_txt )
        {
          printf(
            "which_asic %02x, which_core %02x, get core works %d, less than pattern_num %d\n",
            i,
            j,
            core_works_from_txt,
            *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16));
          return 0;
        }
      }
    }
    return 1;
  }
  else
  {
    printf("%s, malloc works sturct error!\n", "get_all_works");
    return 0;
  }
}

//----- (0003CC78) --------------------------------------------------------
int __fastcall print_works(int a1)
{
  int v1; // r3
  _DWORD *v4; // [sp+Ch] [bp+Ch]
  unsigned int k; // [sp+10h] [bp+10h]
  unsigned int j; // [sp+14h] [bp+14h]
  unsigned int i; // [sp+18h] [bp+18h]
  unsigned int m; // [sp+1Ch] [bp+1Ch]
  unsigned int n; // [sp+1Ch] [bp+1Ch]
  unsigned int ii; // [sp+1Ch] [bp+1Ch]

  printf("\n%s begin\n\n", "print_works");
  for ( i = 0; *(_DWORD *)(a1 + 40) > i; ++i )
  {
    for ( j = 0; *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12) > j; ++j )
    {
      for ( k = 0; *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) > k; ++k )
      {
        v4 = (_DWORD *)(104
                      * (k + *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) * (j + i * *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12)))
                      + *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8));
        printf("asic[%02d][%02d][%02d].work=0x", i, j, k);
        for ( m = 0; v4[22] > m; ++m )
          printf("%02x", *((unsigned __int8 *)v4 + m + 4));
        printf(" nonce=0x");
        for ( n = 0; v4[23] > n; ++n )
          printf("%02x", *((unsigned __int8 *)v4 + n + 84));
        printf(" sol=0x");
        for ( ii = 0; v4[24] > ii; ++ii )
          printf("%02x", *((unsigned __int8 *)v4 + ii + 88));
        putchar(10);
      }
      putchar(10);
    }
    putchar(10);
  }
  printf("%s end\n\n", "print_works");
  return v1;
}
// 3CDFC: variable 'v1' is possibly undefined

//----- (0003CE08) --------------------------------------------------------
int __fastcall sub_3CE08(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 3CE4C: variable 'v3' is possibly undefined

//----- (0003CEE8) --------------------------------------------------------
int __fastcall sub_3CEE8(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/pcba/../util.h",
    64,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0003CFEC) --------------------------------------------------------
__int64 __fastcall sub_3CFEC(unsigned __int8 *a1)
{
  __int64 v2; // [sp+0h] [bp+0h]
  __int64 v3; // [sp+8h] [bp+8h]
  __int64 v4; // [sp+10h] [bp+10h]
  __int64 v5; // [sp+18h] [bp+18h]

  HIDWORD(v5) = a1[4];
  LODWORD(v5) = 0;
  HIDWORD(v4) = a1[5] << 8;
  LODWORD(v4) = 0;
  HIDWORD(v3) = a1[6] << 16;
  LODWORD(v3) = 0;
  HIDWORD(v2) = a1[7] << 24;
  LODWORD(v2) = 0;
  return v2 + v3 + v4 + v5 + (a1[1] << 8) + (unsigned __int64)*a1 + (a1[2] << 16) + (a1[3] << 24);
}

//----- (0003D0F4) --------------------------------------------------------
_BYTE *__fastcall sub_3D0F4(_BYTE *result, int a2, int a3, int a4)
{
  result[7] = a3;
  result[6] = BYTE1(a3);
  result[5] = BYTE2(a3);
  result[4] = HIBYTE(a3);
  result[3] = a4;
  result[2] = BYTE1(a4);
  result[1] = BYTE2(a4);
  *result = HIBYTE(a4);
  return result;
}

//----- (0003D1B4) --------------------------------------------------------
bool __fastcall pcba_is_grin29_asic_valid(_DWORD *a1)
{
  return *a1 != 1 && *a1 != 3;
}

//----- (0003D1E4) --------------------------------------------------------
int pcba_calc_grin29_core_num()
{
  return *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 12);
}
// 1F0C98: using guessed type int g_config_info;

//----- (0003D208) --------------------------------------------------------
int __fastcall pcba_grin29_recv(int a1)
{
  _DWORD v4[2]; // [sp+8h] [bp+8h] BYREF
  _DWORD v5[42]; // [sp+10h] [bp+10h] BYREF
  _DWORD s[189]; // [sp+B8h] [bp+B8h] BYREF
  int v7; // [sp+3ACh] [bp+3ACh]
  int v8; // [sp+3B0h] [bp+3B0h]
  void *s2; // [sp+3B4h] [bp+3B4h]
  _DWORD *v10; // [sp+3B8h] [bp+3B8h]
  int v11; // [sp+3BCh] [bp+3BCh]
  int j; // [sp+3C0h] [bp+3C0h]
  int i; // [sp+3C4h] [bp+3C4h]

  memset(s, 0, 0x2F3u);
  if ( (*(unsigned __int8 (__fastcall **)(int, _DWORD *))(a1 + 36))(a1, s) != 1 )
    return 0;
  v11 = 0;
  v10 = (_DWORD *)(104 * g_patten_offset + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 8));
  memset(v5, 0, sizeof(v5));
  for ( i = 0; i <= 41; ++i )
  {
    v5[i] = *(_DWORD *)((char *)&s[i + 8] + 3);
    v5[i] = HIBYTE(v5[i]) | ((v5[i] & 0xFF0000u) >> 8) | ((v5[i] & 0xFF00) << 8) | (v5[i] << 24);
  }
  s2 = v5;
  v8 = memcmp(v10 + 22, v5, 0xA8u);
  v4[0] = 0;
  v4[1] = 0;
  sub_3D0F4(v4, (int)v4, *(_DWORD *)((char *)&s[6] + 1), *(_DWORD *)((char *)&s[7] + 1));
  for ( j = 0; j <= 3; ++j )
    *((_BYTE *)v4 + j) = *((_BYTE *)&v4[1] + j);
  v7 = memcmp(v10 + 21, v4, 4u);
  if ( v8 || v7 )
  {
    puts("receive a nonce not match");
    return 0;
  }
  else
  {
    printf("receive a nonce match total %d\n", ++v10[25]);
    return 1;
  }
}
// 1F0C80: using guessed type int g_patten_offset;
// 1F0C98: using guessed type int g_config_info;

//----- (0003D3E8) --------------------------------------------------------
int __fastcall pcba_grin29_send(int a1, int *a2)
{
  _DWORD v4[2]; // [sp+8h] [bp+8h] BYREF
  _BYTE v5[8]; // [sp+10h] [bp+10h] BYREF
  __int64 v6; // [sp+18h] [bp+18h]
  _BYTE v7[238]; // [sp+20h] [bp+20h] BYREF
  __int64 v8; // [sp+10Eh] [bp+10Eh]
  __int16 v9; // [sp+116h] [bp+116h]
  __int16 v10; // [sp+118h] [bp+118h]
  __int16 v11; // [sp+11Ah] [bp+11Ah]
  __int16 v12; // [sp+11Ch] [bp+11Ch]
  int *v13; // [sp+120h] [bp+120h]
  int i; // [sp+124h] [bp+124h]

  v13 = a2;
  v6 = *a2;
  memcpy(v7, a2 + 1, sizeof(v7));
  v4[0] = 0;
  v4[1] = 0;
  for ( i = 0; i <= 7; ++i )
    *((_BYTE *)v4 + 7 - i) = *((_BYTE *)v13 + i + 242);
  v8 = sub_3CFEC((unsigned __int8 *)v4);
  v9 = -1;
  v10 = -1;
  v11 = -1;
  v12 = -1;
  return (*(int (__fastcall **)(int, _BYTE *))(a1 + 24))(a1, v5);
}

//----- (0003D4BC) --------------------------------------------------------
int pcba_statistic_grin29_pattern_test_results()
{
  int i; // [sp+Ch] [bp+4h] BYREF
  double v2; // [sp+10h] [bp+8h]
  int v3; // [sp+1Ch] [bp+14h]
  int v4; // [sp+20h] [bp+18h]
  int v5; // [sp+24h] [bp+1Ch]
  int v6; // [sp+28h] [bp+20h]
  int v7; // [sp+2Ch] [bp+24h]
  int k; // [sp+30h] [bp+28h]
  int j; // [sp+34h] [bp+2Ch]

  i = 0;
  j = 0;
  k = 0;
  v5 = *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 8);
  v7 = 0;
  v6 = 0;
  for ( i = 0; *(_DWORD *)(g_config_info + 40) > i; ++i )
  {
    if ( pcba_is_grin29_asic_valid(&i) )
    {
      v4 = pcba_calc_grin29_core_num();
      for ( j = 0; j < v4; ++j )
      {
        for ( k = 0; *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) > k; ++k )
        {
          ++v6;
          v3 = 104
             * (k
              + *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16) * v4 * i
              + j * *(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 16))
             + v5;
          if ( *(_DWORD *)(v3 + 100) )
            ++v7;
        }
      }
    }
  }
  v2 = (double)v7 / (double)v6;
  v2 = v2 * 100.0;
  if ( *(double *)*(_DWORD *)(*(_DWORD *)(g_config_info + 8) + 36) <= v2 )
    return printf("Pattern Test Success %0.4f match nocnes %d total nonces %d\n", v2, v7, v6);
  else
    return printf("Pattern Test Failed %0.4f match nocnes %d total nonces %d\n", v2, v7, v6);
}
// 3D4BC: using guessed type int pcba_statistic_grin29_pattern_test_results();
// 1F0C98: using guessed type int g_config_info;

//----- (0003D648) --------------------------------------------------------
__int64 __fastcall sub_3D648(int a1)
{
  __int64 v1; // d0
  int v3; // [sp+4h] [bp-Ch]
  _BYTE v5[8]; // [sp+18h] [bp+8h] BYREF
  __int64 v6; // [sp+1018h] [bp+1008h]

  pic1704_get_an_voltage1(a1);
  v6 = v1;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "read_feedback_voltage chain = %d, voltage = %f\n", a1, v3, v1);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
           72,
           "read_feedback_voltage",
           21,
           49,
           20,
           v5);
}
// 3D686: variable 'v1' is possibly undefined
// 3D6BC: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0003D718) --------------------------------------------------------
__int64 sub_3D718()
{
  double v0; // d0
  _BYTE v2[28]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+1014h] [bp+1004h] BYREF
  double v4; // [sp+1018h] [bp+1008h]
  _DWORD *all_created_runtime; // [sp+1020h] [bp+1010h]
  int i; // [sp+1024h] [bp+1014h]
  double v7; // [sp+1028h] [bp+1018h]

  v7 = 0.0;
  all_created_runtime = get_all_created_runtime(&v3);
  for ( i = 0; i < v3; ++i )
  {
    sub_3D648(*(_DWORD *)(all_created_runtime[i] + 140));
    v4 = v0;
    if ( v0 > 0.1 && (v7 > v4 || v7 < 0.1) )
      v7 = v4;
  }
  V_LOCK();
  logfmt_raw(v2, 0x1000u, 0, "the minimal voltage = %.2f", v7);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
           72,
           "get_minimal_feedback_voltage",
           28,
           65,
           20,
           v2);
}
// 3D788: variable 'v0' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0003D8B8) --------------------------------------------------------
int sub_3D8B8()
{
  double v0; // d0
  int v3; // [sp+4h] [bp-14h]
  _BYTE v4[24]; // [sp+18h] [bp+0h] BYREF
  double v5; // [sp+1018h] [bp+1000h]
  double v6; // [sp+1020h] [bp+1008h]
  int current_voltage; // [sp+1028h] [bp+1010h]
  int v8; // [sp+102Ch] [bp+1014h]

  v8 = 3;
  current_voltage = get_current_voltage();
  v6 = (double)current_voltage * 0.75 / 100.0;
  while ( 1 )
  {
    sleep(1u);
    sub_3D718();
    v5 = v0;
    if ( v0 >= v6 )
      break;
    V_LOCK();
    logfmt_raw(
      v4,
      0x1000u,
      0,
      "power voltage can not meet the target! centi_voltage %d min_fb_vol %f qualified_vol %f",
      current_voltage,
      v3,
      v5,
      v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
      72,
      "check_feedback_voltage",
      22,
      80,
      80,
      v4);
    if ( !--v8 )
      goto LABEL_6;
  }
  V_LOCK();
  logfmt_raw(
    v4,
    0x1000u,
    0,
    "power voltage qualified! centi_voltage %d min_fb_vol %f qualified_vol %f",
    current_voltage,
    v3,
    v5,
    v6);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
    72,
    "check_feedback_voltage",
    22,
    84,
    60,
    v4);
LABEL_6:
  if ( v8 )
    return 0;
  else
    return -1;
}
// 3D918: variable 'v0' is possibly undefined
// 3D97A: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0003DA88) --------------------------------------------------------
int __fastcall sub_3DA88(int a1)
{
  int v1; // r3

  v1 = a1 & ~(a1 >> 31);
  if ( v1 >= 255 )
    return 255;
  return v1;
}

//----- (0003DAAC) --------------------------------------------------------
int __fastcall sub_3DAAC(unsigned int a1, unsigned int a2)
{
  double v2; // d0
  int v3; // r3
  int v4; // r3
  int v5; // r3
  int v7; // [sp+4h] [bp-Ch]
  unsigned int v9; // [sp+14h] [bp+4h]
  int v10; // [sp+1Ch] [bp+Ch] BYREF
  int v11; // [sp+101Ch] [bp+100Ch]

  v9 = a1;
  v11 = a1;
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "step n from %d to %d", v9, a2);
  V_UNLOCK();
  zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c", 72, "stepN", 5, 99, 60, &v10);
  while ( a2 != v9 )
  {
    bitmain_convert_N_to_V();
    bitmain_convert_N_to_V();
    if ( fabs(v2 - v2) <= 0.5 )
      break;
    if ( v9 >= a2 )
    {
      v5 = a2 - v9;
      if ( (int)(a2 - v9) < 0 )
        v5 = v9 - a2;
      v4 = v5 / -2;
    }
    else
    {
      v3 = a2 - v9;
      if ( (int)(a2 - v9) < 0 )
        v3 = v9 - a2;
      v4 = v3 / 2;
    }
    v11 += v4;
    V_LOCK();
    bitmain_convert_N_to_V();
    logfmt_raw(&v10, 0x1000u, 0, "set N to %d, voltage = %.2f", v11, v7, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
      72,
      "stepN",
      5,
      103,
      60,
      &v10);
    bitmain_set_voltage_by_n(v11);
    v9 = v11;
  }
  if ( v9 != a2 )
  {
    V_LOCK();
    bitmain_convert_N_to_V();
    logfmt_raw(&v10, 0x1000u, 0, "final set N to %d, voltage = %.2f", a2, v7, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
      72,
      "stepN",
      5,
      110,
      60,
      &v10);
    bitmain_set_voltage_by_n(a2);
  }
  return 0;
}
// 3DBE8: variable 'v7' is possibly undefined
// 3DBE8: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0003DD40) --------------------------------------------------------
int __fastcall sub_3DD40(int a1, int a2)
{
  _BYTE v6[12]; // [sp+1Ch] [bp+Ch] BYREF
  int v7; // [sp+101Ch] [bp+100Ch]
  double v8; // [sp+1020h] [bp+1010h]

  v8 = (double)a1 / 100.0;
  v7 = bitmain_set_voltage();
  if ( v7 >= 0 )
  {
    usleep(0x7A120u);
    *(_DWORD *)(a2 + 28) = a1;
    *(_DWORD *)(a2 + 32) = *(_DWORD *)(a2 + 28);
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "bitmain_set_voltage failed");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
      72,
      "set_voltage_without_feedback",
      28,
      121,
      100,
      v6);
    return -1;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0003DE48) --------------------------------------------------------
int __fastcall sub_3DE48(int a1, int a2)
{
  double v2; // d0
  double v3; // d7
  _BYTE v8[20]; // [sp+2Ch] [bp+Ch] BYREF
  int v9; // [sp+102Ch] [bp+100Ch]
  int v10; // [sp+1030h] [bp+1010h]
  int v11; // [sp+1034h] [bp+1014h]
  double v12; // [sp+1038h] [bp+1018h]
  double v13; // [sp+1040h] [bp+1020h]
  double v14; // [sp+1048h] [bp+1028h]
  int v15; // [sp+1054h] [bp+1034h]
  unsigned int v16; // [sp+1058h] [bp+1038h]
  int v17; // [sp+105Ch] [bp+103Ch]

  v17 = 0;
  v15 = 255;
  v14 = (double)a1 / 100.0;
  v13 = 0.0;
  v12 = (double)*(int *)(a2 + 32) / 100.0;
  v2 = v14;
  v11 = bitmain_set_voltage();
  while ( 1 )
  {
    sub_3D718();
    v13 = v2;
    v10 = bitmain_convert_V_to_N();
    if ( *(_DWORD *)(a2 + 32) )
      v3 = (double)*(int *)(a2 + 32) / 100.0;
    else
      v3 = v13;
    v12 = v3;
    v2 = v3;
    v16 = bitmain_convert_V_to_N();
    v9 = v11 - v10;
    if ( v13 < 0.1 )
    {
      v17 = -1;
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "minimal feedback voltage is zero");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
        72,
        "set_voltage_with_feedback",
        25,
        147,
        60,
        v8);
      goto LABEL_12;
    }
    if ( !v9 )
      goto LABEL_12;
    V_LOCK();
    logfmt_raw(
      v8,
      0x1000u,
      0,
      "board voltage = %.2f, target voltage = %.2f, power real voltage = %.2f, steps = %d",
      v13,
      v14,
      v12,
      v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
      72,
      "set_voltage_with_feedback",
      25,
      151,
      60,
      v8);
    if ( v9 + v16 >= 0x100 )
      break;
    sub_3DAAC(v16, v9 + v16);
    v16 += v9;
    v16 = sub_3DA88(v16);
    bitmain_convert_N_to_V();
    *(_DWORD *)(a2 + 32) = (int)(v3 * 100.0);
    if ( fabs(v13 - v14) > 0.1 )
    {
      if ( v15-- )
        continue;
    }
    goto LABEL_12;
  }
  V_LOCK();
  logfmt_raw(v8, 0x1000u, 0, "overflow to the N limitation");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
    72,
    "set_voltage_with_feedback",
    25,
    154,
    60,
    v8);
  v17 = -2;
LABEL_12:
  if ( v17 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "fail to set taget voltage = %.2f, feedback_vol = %.2f", v14, v13);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
      72,
      "set_voltage_with_feedback",
      25,
      167,
      60,
      v8);
  }
  else
  {
    V_LOCK();
    bitmain_convert_N_to_V();
    logfmt_raw(
      v8,
      0x1000u,
      0,
      "set to target voltage = %.2f, power real voltage = %.2f, feed back voltage = %.2f",
      v14,
      v3,
      v13);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
      72,
      "set_voltage_with_feedback",
      25,
      164,
      60,
      v8);
    *(_DWORD *)(a2 + 28) = a1;
  }
  return v17;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0003E334) --------------------------------------------------------
unsigned int power_on()
{
  bitmain_power_on();
  byte_479DC8 = 1;
  return sleep(1u);
}
// 479DC8: using guessed type char byte_479DC8;

//----- (0003E354) --------------------------------------------------------
unsigned int power_off()
{
  bitmain_power_off();
  byte_479DC8 = 0;
  return sleep(1u);
}
// 479DC8: using guessed type char byte_479DC8;

//----- (0003E374) --------------------------------------------------------
int __fastcall power_info_init(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)&byte_479DB4 = a1;
  unk_479DB8 = a2;
  dword_479DBC = a3;
  *(_DWORD *)&byte_479DC0 = a4;
  dword_479DC4 = a5;
  return 0;
}
// 479DB4: using guessed type char byte_479DB4;
// 479DBC: using guessed type int dword_479DBC;
// 479DC0: using guessed type char byte_479DC0;
// 479DC4: using guessed type int dword_479DC4;

//----- (0003E3A4) --------------------------------------------------------
int __fastcall set_power_init_status(char a1)
{
  byte_479DB0 = a1;
  return 0;
}
// 479DB0: using guessed type char byte_479DB0;

//----- (0003E3C8) --------------------------------------------------------
int is_power_init()
{
  return (unsigned __int8)byte_479DB0;
}
// 479DB0: using guessed type char byte_479DB0;

//----- (0003E3E0) --------------------------------------------------------
int is_power_on()
{
  return (unsigned __int8)byte_479DC8;
}
// 479DC8: using guessed type char byte_479DC8;

//----- (0003E3F8) --------------------------------------------------------
int power_init()
{
  int v2; // [sp+14h] [bp+4h] BYREF
  unsigned __int16 v3; // [sp+1016h] [bp+1006h]

  v3 = 0;
  if ( byte_479DB4 != 1 )
  {
    V_LOCK();
    logfmt_raw(&v2, 0x1000u, 0, "%s, current algo donot use adjustable power!", "power_init");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
      72,
      "power_init",
      10,
      214,
      60,
      &v2);
    return 0;
  }
  else
  {
    v3 = bitmain_power_version();
    V_LOCK();
    logfmt_raw(&v2, 0x1000u, 0, "power type version: 0x%04x", v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
      72,
      "power_init",
      10,
      219,
      60,
      &v2);
    if ( v3 == (unsigned __int16)word_479DB6 )
    {
      v3 = bitmain_power_fw_version();
      if ( v3 > 0x14u )
        get_power_voltage_calibration_data();
      byte_479DC9 = 0;
      dword_479DCC = 0;
      dword_479DD0 = 0;
      byte_479DB0 = 1;
      if ( opt_custom_voltage_swith || is_eeprom_loaded() )
        dword_479DBC = opt_custom_voltage;
      V_LOCK();
      logfmt_raw(&v2, 0x1000u, 0, "Power init:");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
        72,
        "power_init",
        10,
        241,
        60,
        &v2);
      V_LOCK();
      logfmt_raw(&v2, 0x1000u, 0, "current_voltage_raw     = %d", dword_479DCC);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
        72,
        "power_init",
        10,
        242,
        60,
        &v2);
      V_LOCK();
      logfmt_raw(&v2, 0x1000u, 0, "working_voltage_raw     = %d", dword_479DBC);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
        72,
        "power_init",
        10,
        243,
        60,
        &v2);
      V_LOCK();
      logfmt_raw(&v2, 0x1000u, 0, "check_asic_voltage_enable     = %d", (unsigned __int8)byte_479DC0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
        72,
        "power_init",
        10,
        244,
        60,
        &v2);
      V_LOCK();
      logfmt_raw(&v2, 0x1000u, 0, "check_asic_voltage_raw  = %d", dword_479DC4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
        72,
        "power_init",
        10,
        245,
        60,
        &v2);
      if ( is_check_asic_voltage_enable() )
        v3 = set_check_asic_voltage(0);
      else
        v3 = set_working_voltage(0);
      if ( v3 )
      {
        V_LOCK();
        logfmt_raw(&v2, 0x1000u, 0, "set_voltage_by_steps error!");
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
          72,
          "power_init",
          10,
          253,
          100,
          &v2);
        return -1;
      }
      else
      {
        power_on();
        if ( opt_algo == 5 || !sub_3D8B8() )
        {
          return 0;
        }
        else
        {
          V_LOCK();
          logfmt_raw(&v2, 0x1000u, 0, "check_feedback_voltage error!");
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
            72,
            "power_init",
            10,
            261,
            100,
            &v2);
          return -1;
        }
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(&v2, 0x1000u, 0, "power version error, expect %04x, actual %04x", (unsigned __int16)word_479DB6, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
        72,
        "power_init",
        10,
        223,
        100,
        &v2);
      return -1;
    }
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479DB0: using guessed type char byte_479DB0;
// 479DB4: using guessed type char byte_479DB4;
// 479DB6: using guessed type __int16 word_479DB6;
// 479DBC: using guessed type int dword_479DBC;
// 479DC0: using guessed type char byte_479DC0;
// 479DC4: using guessed type int dword_479DC4;
// 479DC9: using guessed type char byte_479DC9;
// 479DCC: using guessed type int dword_479DCC;
// 479DD0: using guessed type int dword_479DD0;
// 47BE18: using guessed type int g_zc;
// 47BFBC: using guessed type char opt_custom_voltage_swith;
// 47C018: using guessed type int opt_custom_voltage;
// 47C02C: using guessed type int opt_algo;

//----- (0003E8F0) --------------------------------------------------------
int __fastcall set_voltage(int a1, char a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a2 != 1 )
    return -1;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s to %d.", "set_voltage", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
    72,
    "set_voltage",
    11,
    274,
    60,
    v5);
  return sub_3DD40(a1, (int)&byte_479DB0);
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479DB0: using guessed type char byte_479DB0;
// 47BE18: using guessed type int g_zc;

//----- (0003E9AC) --------------------------------------------------------
int __fastcall set_voltage_by_steps(int a1, char a2)
{
  signed int v3; // r2
  int v4; // r3
  _BYTE v7[16]; // [sp+18h] [bp+8h] BYREF
  int v8; // [sp+1018h] [bp+1008h]
  int current_voltage; // [sp+101Ch] [bp+100Ch]
  int v10; // [sp+1020h] [bp+1010h]
  int v11; // [sp+1024h] [bp+1014h]

  if ( a2 != 1 )
    return -1;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s to %d.", "set_voltage_by_steps", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
    72,
    "set_voltage_by_steps",
    20,
    284,
    60,
    v7);
  v8 = 0;
  v11 = 10;
  current_voltage = get_current_voltage();
  v10 = a1 - current_voltage;
  if ( a1 == current_voltage )
    return 0;
  if ( v10 < 0 )
    v11 = -v11;
  while ( 1 )
  {
    v3 = abs32(v10);
    v4 = v11;
    if ( v11 < 0 )
      v4 = -v11;
    if ( v3 <= v4 )
      break;
    current_voltage += v11;
    v10 -= v11;
    sub_3DD40(current_voltage, (int)&byte_479DB0);
  }
  if ( a1 != current_voltage )
    sub_3DD40(a1, (int)&byte_479DB0);
  return v8;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479DB0: using guessed type char byte_479DB0;
// 47BE18: using guessed type int g_zc;

//----- (0003EB84) --------------------------------------------------------
int get_current_voltage()
{
  if ( byte_479DB0 != 1 )
    return -1;
  else
    return dword_479DCC;
}
// 479DB0: using guessed type char byte_479DB0;
// 479DCC: using guessed type int dword_479DCC;

//----- (0003EBB8) --------------------------------------------------------
int get_working_voltage()
{
  if ( byte_479DB0 != 1 )
    return -1;
  else
    return dword_479DBC;
}
// 479DB0: using guessed type char byte_479DB0;
// 479DBC: using guessed type int dword_479DBC;

//----- (0003EBEC) --------------------------------------------------------
int get_max_voltage()
{
  double v0; // d0

  if ( byte_479DB0 != 1 )
    return -1;
  bitmain_convert_N_to_V();
  return (int)(v0 * 100.0);
}
// 3EC18: variable 'v0' is possibly undefined
// 479DB0: using guessed type char byte_479DB0;

//----- (0003EC30) --------------------------------------------------------
int __fastcall set_working_voltage(char a1)
{
  int v3; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v4; // [sp+101Eh] [bp+100Eh]

  v4 = 0;
  if ( a1 )
    v4 = set_voltage_by_steps(dword_479DBC, byte_479DB0);
  else
    v4 = set_voltage(dword_479DBC, byte_479DB0);
  if ( !v4 )
    return 0;
  V_LOCK();
  logfmt_raw(&v3, 0x1000u, 0, "%s error!", "set_working_voltage");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
    72,
    "set_working_voltage",
    19,
    348,
    60,
    &v3);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479DB0: using guessed type char byte_479DB0;
// 479DBC: using guessed type int dword_479DBC;
// 47BE18: using guessed type int g_zc;

//----- (0003ED30) --------------------------------------------------------
int is_check_asic_voltage_enable()
{
  return byte_479DB4 && byte_479DC0;
}
// 479DB4: using guessed type char byte_479DB4;
// 479DC0: using guessed type char byte_479DC0;

//----- (0003ED68) --------------------------------------------------------
int __fastcall set_check_asic_voltage(char a1)
{
  int v3; // [sp+1Ch] [bp+Ch] BYREF
  int v4; // [sp+101Ch] [bp+100Ch]

  v4 = 0;
  if ( a1 )
    v4 = set_voltage_by_steps(dword_479DC4, byte_479DB0);
  else
    v4 = set_voltage(dword_479DC4, byte_479DB0);
  if ( !v4 )
    return 0;
  V_LOCK();
  logfmt_raw(&v3, 0x1000u, 0, "%s error!", "set_check_asic_voltage");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/miner_util/power_api.c",
    72,
    "set_check_asic_voltage",
    22,
    370,
    100,
    &v3);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479DB0: using guessed type char byte_479DB0;
// 479DC4: using guessed type int dword_479DC4;
// 47BE18: using guessed type int g_zc;

//----- (0003EE68) --------------------------------------------------------
int __fastcall fan_info_init(int a1, int a2)
{
  dword_1ED3C4 = a1;
  dword_1ED3C8 = a2;
  return 0;
}
// 1ED3C4: using guessed type int dword_1ED3C4;
// 1ED3C8: using guessed type int dword_1ED3C8;

//----- (0003EE98) --------------------------------------------------------
int fan_get_max_num()
{
  return dword_1ED3C4;
}
// 1ED3C4: using guessed type int dword_1ED3C4;

//----- (0003EEB0) --------------------------------------------------------
int fan_get_max_speed()
{
  return dword_1ED3C8;
}
// 1ED3C8: using guessed type int dword_1ED3C8;

//----- (0003EEC8) --------------------------------------------------------
int fan_get_check_fan_speed()
{
  return 4000;
}

//----- (0003EEDC) --------------------------------------------------------
int fan_pwm_get()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  if ( byte_479DD5 != 1 )
  {
    dword_479DD8 = pwm_init(0, 1);
    byte_479DD5 = 1;
  }
  pwm_get(dword_479DD8, &v1);
  return v1;
}
// 479DD5: using guessed type char byte_479DD5;
// 479DD8: using guessed type int dword_479DD8;

//----- (0003EF34) --------------------------------------------------------
int __fastcall fan_pwm_set(unsigned int a1)
{
  int result; // r0

  if ( byte_479DD5 != 1 )
  {
    dword_479DD8 = pwm_init(0, 100);
    byte_479DD5 = 1;
  }
  if ( a1 > 0x64 )
    a1 = 100;
  result = fan_pwm_get();
  if ( result != a1 )
  {
    if ( fan_pwm_fixed )
      return pwm_set(dword_479DD8, fan_pwm);
    else
      return pwm_set(dword_479DD8, a1);
  }
  return result;
}
// 1ED3C0: using guessed type int fan_pwm;
// 479DD4: using guessed type char fan_pwm_fixed;
// 479DD5: using guessed type char byte_479DD5;
// 479DD8: using guessed type int dword_479DD8;

//----- (0003EFD0) --------------------------------------------------------
int fan_pwm_set_max()
{
  int result; // r0

  if ( byte_479DD5 != 1 )
  {
    dword_479DD8 = pwm_init(0, 100);
    byte_479DD5 = 1;
  }
  result = fan_pwm_get();
  if ( result != 100 )
    return pwm_set(dword_479DD8, 0x64u);
  return result;
}
// 479DD5: using guessed type char byte_479DD5;
// 479DD8: using guessed type int dword_479DD8;

//----- (0003F02C) --------------------------------------------------------
int __fastcall sub_3F02C(int a1)
{
  int v2; // [sp+8h] [bp+8h]
  unsigned int i; // [sp+Ch] [bp+Ch]

  v2 = 0;
  for ( i = 0; i <= 3; ++i )
    v2 = (v2 << 8) | *(unsigned __int8 *)(i + a1);
  return v2;
}

//----- (0003F068) --------------------------------------------------------
int __fastcall sub_3F068(int *a1)
{
  _BYTE buf[4]; // [sp+Ch] [bp+Ch] BYREF
  _BOOL4 v5; // [sp+10h] [bp+10h]
  int fd; // [sp+14h] [bp+14h]

  fd = open("/dev/urandom", 0);
  if ( fd == -1 )
    return 1;
  v5 = read(fd, buf, 4u) == 4;
  close(fd);
  if ( !v5 )
    return 1;
  *a1 = sub_3F02C((int)buf);
  return 0;
}

//----- (0003F0D4) --------------------------------------------------------
int __fastcall sub_3F0D4(int *a1)
{
  struct timeval tv; // [sp+8h] [bp+8h] BYREF

  gettimeofday(&tv, 0);
  *a1 = tv.tv_sec ^ tv.tv_usec;
  *a1 ^= getpid();
  return 0;
}

//----- (0003F110) --------------------------------------------------------
int sub_3F110()
{
  int v1; // [sp+0h] [bp+0h] BYREF

  v1 = 0;
  if ( sub_3F068(&v1) != 0 )
    sub_3F0D4(&v1);
  if ( !v1 )
    return 1;
  return v1;
}

//----- (0003F154) --------------------------------------------------------
int __fastcall json_object_seed(int result)
{
  unsigned __int8 v1; // r2
  int v2; // r3
  int v3; // [sp+Ch] [bp+Ch]

  v3 = result;
  if ( !hashtable_seed )
  {
    do
    {
      v1 = __ldrex(byte_479DE0);
      result = __strex(1u, byte_479DE0);
    }
    while ( result );
    if ( v1 != 1 )
    {
      if ( !v3 )
      {
        result = sub_3F110();
        v3 = result;
      }
      __dmb(0xBu);
      hashtable_seed = v3;
    }
    else
    {
      do
      {
        result = sched_yield();
        v2 = hashtable_seed;
        __dmb(0xBu);
      }
      while ( !v2 );
    }
  }
  return result;
}
// 479DDC: using guessed type int hashtable_seed;
// 479DE0: using guessed type unsigned __int8 byte_479DE0[4];

//----- (0003F1D0) --------------------------------------------------------
int __fastcall sub_3F1D0(int result)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2

  if ( result && *(_DWORD *)(result + 4) != -1 )
  {
    v1 = (unsigned int *)(result + 4);
    do
      v2 = __ldrex(v1);
    while ( __strex(v2 + 1, v1) );
    __dmb(0xBu);
  }
  return result;
}

//----- (0003F210) --------------------------------------------------------
void __fastcall sub_3F210(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (0003F254) --------------------------------------------------------
void *__fastcall sub_3F254(_DWORD *a1, int a2, int a3, int a4)
{
  void *result; // r0

  a1[14] = a2;
  a1[15] = a3;
  *a1 = a4;
  a1[1] = *a1;
  memset(a1 + 2, 0, 0x10u);
  memset(a1 + 6, 0, 0x10u);
  result = memset(a1 + 10, 0, 0x10u);
  a1[16] = 1;
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = 0;
  return result;
}

//----- (0003F2C8) --------------------------------------------------------
int __fastcall sub_3F2C8(_DWORD *a1)
{
  _DWORD *v1; // r4
  int result; // r0
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3
  _BYTE *v10; // [sp+Ch] [bp+Ch]

  v1 = a1 + 2;
  result = a1[6];
  v3 = a1[7];
  v4 = a1[8];
  v5 = a1[9];
  a1[2] = result;
  v1[1] = v3;
  v1[2] = v4;
  v1[3] = v5;
  if ( a1[10] )
  {
    result = a1[10];
    v6 = a1[11];
    v7 = a1[12];
    v8 = a1[13];
    a1[6] = result;
    a1[7] = v6;
    a1[8] = v7;
    a1[9] = v8;
    a1[10] = 0;
  }
  else if ( *((_BYTE *)a1 + 36) || *(_BYTE *)a1[1] )
  {
    v10 = (_BYTE *)a1[1];
    ++a1[17];
    ++a1[18];
    while ( *v10 == 32 || *v10 == 9 || *v10 == 10 || *v10 == 44 || *v10 == 58 )
    {
      if ( *v10 == 10 )
      {
        ++a1[16];
        a1[17] = 1;
      }
      else
      {
        ++a1[17];
      }
      ++a1[18];
      ++v10;
    }
    *((_BYTE *)a1 + 36) = *v10;
    a1[6] = a1[16];
    a1[7] = a1[17];
    a1[8] = a1[18];
    if ( *v10 )
      ++v10;
    a1[1] = v10;
  }
  return result;
}

//----- (0003F3D0) --------------------------------------------------------
int __fastcall sub_3F3D0(_DWORD *a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  _DWORD *v4; // r4
  int result; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3

  v1 = a1[7];
  v2 = a1[8];
  v3 = a1[9];
  a1[10] = a1[6];
  a1[11] = v1;
  a1[12] = v2;
  a1[13] = v3;
  v4 = a1 + 6;
  result = a1[2];
  v6 = a1[3];
  v7 = a1[4];
  v8 = a1[5];
  a1[6] = result;
  v4[1] = v6;
  v4[2] = v7;
  v4[3] = v8;
  return result;
}

//----- (0003F404) --------------------------------------------------------
char *__fastcall sub_3F404(int *a1, const char *a2, char a3, char *format)
{
  __gnuc_va_list __varargs; // [sp+24h] [bp+14h]

  jsonp_error_vset(a1[14], a1[6], a1[7], a1[8], a3, format, __varargs);
  return jsonp_error_set_source((char *)a1[14], a2);
}
// 3F436: variable '__varargs' is possibly undefined

//----- (0003F454) --------------------------------------------------------
char *__fastcall sub_3F454(int a1, char ***a2, int a3, size_t *a4, _DWORD *a5, int a6)
{
  char **v6; // r3
  char **v8; // r3
  size_t *v9; // r3
  size_t *v10; // r3
  size_t v11; // r3
  int v16; // [sp+18h] [bp+10h] BYREF
  size_t v17; // [sp+1Ch] [bp+14h]
  char *s; // [sp+24h] [bp+1Ch]
  char v19; // [sp+2Bh] [bp+23h]
  size_t v20; // [sp+2Ch] [bp+24h]

  sub_3F2C8((_DWORD *)a1);
  v19 = *(_BYTE *)(a1 + 36);
  sub_3F3D0((_DWORD *)a1);
  *a5 = 0;
  if ( v19 == 35 || v19 == 37 || v19 == 43 )
  {
    if ( a6 )
    {
      sub_3F404((int *)a1, "<format>", 9, "Cannot use '%c' on optional strings");
      *(_DWORD *)(a1 + 76) = 1;
      return 0;
    }
    else
    {
      if ( strbuffer_init((strbuffer_t *)&v16) )
      {
        sub_3F404((int *)a1, "<internal>", 1, "Out of memory");
        *(_DWORD *)(a1 + 76) = 1;
      }
      do
      {
        v8 = (*a2)++;
        s = *v8;
        if ( !s )
        {
          sub_3F404((int *)a1, "<args>", 12, "NULL %s");
          *(_DWORD *)(a1 + 76) = 1;
        }
        sub_3F2C8((_DWORD *)a1);
        if ( *(_BYTE *)(a1 + 36) == 35 )
        {
          v9 = (size_t *)(*a2)++;
          v20 = *v9;
        }
        else if ( *(_BYTE *)(a1 + 36) == 37 )
        {
          v10 = (size_t *)(*a2)++;
          v20 = *v10;
        }
        else
        {
          sub_3F3D0((_DWORD *)a1);
          if ( *(_DWORD *)(a1 + 76) )
            v11 = 0;
          else
            v11 = strlen(s);
          v20 = v11;
        }
        if ( !*(_DWORD *)(a1 + 76) && strbuffer_append_bytes((int)&v16, s, v20) == -1 )
        {
          sub_3F404((int *)a1, "<internal>", 1, "Out of memory");
          *(_DWORD *)(a1 + 76) = 1;
        }
        sub_3F2C8((_DWORD *)a1);
      }
      while ( *(_BYTE *)(a1 + 36) == 43 );
      sub_3F3D0((_DWORD *)a1);
      if ( *(_DWORD *)(a1 + 76) )
      {
        strbuffer_close((strbuffer_t *)&v16);
        return 0;
      }
      else if ( utf8_check_string(v16, v17) )
      {
        *a4 = v17;
        *a5 = 1;
        return (char *)strbuffer_steal_value(&v16);
      }
      else
      {
        sub_3F404((int *)a1, "<args>", 5, "Invalid UTF-8 %s");
        strbuffer_close((strbuffer_t *)&v16);
        *(_DWORD *)(a1 + 76) = 1;
        return 0;
      }
    }
  }
  else
  {
    v6 = (*a2)++;
    s = *v6;
    if ( s )
    {
      v20 = strlen(s);
      if ( utf8_check_string((int)s, v20) )
      {
        *a4 = v20;
        return s;
      }
      else
      {
        sub_3F404((int *)a1, "<args>", 5, "Invalid UTF-8 %s");
        *(_DWORD *)(a1 + 76) = 1;
        return 0;
      }
    }
    else
    {
      if ( !a6 )
      {
        sub_3F404((int *)a1, "<args>", 12, "NULL %s");
        *(_DWORD *)(a1 + 76) = 1;
      }
      return 0;
    }
  }
}

//----- (0003F6D0) --------------------------------------------------------
json_t *__fastcall sub_3F6D0(int a1, char ***a2)
{
  int v6; // [sp+10h] [bp+8h] BYREF
  size_t v7; // [sp+14h] [bp+Ch] BYREF
  json_t *v8; // [sp+18h] [bp+10h]
  char v9; // [sp+1Fh] [bp+17h]
  char *v10; // [sp+20h] [bp+18h]
  json_t *v11; // [sp+24h] [bp+1Ch]

  v11 = (json_t *)json_object();
  sub_3F2C8((_DWORD *)a1);
  while ( *(_BYTE *)(a1 + 36) != 125 )
  {
    if ( !*(_BYTE *)(a1 + 36) )
    {
      sub_3F404((int *)a1, "<format>", 9, "Unexpected end of format string");
      goto LABEL_23;
    }
    if ( *(_BYTE *)(a1 + 36) != 115 )
    {
      sub_3F404((int *)a1, "<format>", 9, "Expected format 's', got '%c'");
      goto LABEL_23;
    }
    v10 = sub_3F454(a1, a2, (int)"object key", &v7, &v6, 0);
    sub_3F2C8((_DWORD *)a1);
    sub_3F2C8((_DWORD *)a1);
    v9 = *(_BYTE *)(a1 + 36);
    sub_3F3D0((_DWORD *)a1);
    v8 = (json_t *)sub_3FB38(a1, a2);
    if ( v8 )
    {
      if ( *(_DWORD *)(a1 + 76) )
        sub_3F210((int)v8);
      if ( !*(_DWORD *)(a1 + 76) && json_object_set_new_nocheck(v11, v10, v8) )
      {
        sub_3F404((int *)a1, "<internal>", 1, "Unable to add key \"%s\"");
        *(_DWORD *)(a1 + 76) = 1;
      }
      if ( v6 )
        jsonp_free(v10);
    }
    else
    {
      if ( v6 )
        jsonp_free(v10);
      if ( v9 != 42 )
      {
        sub_3F404((int *)a1, "<args>", 12, "NULL object value");
        *(_DWORD *)(a1 + 76) = 1;
      }
    }
    sub_3F2C8((_DWORD *)a1);
  }
  if ( !*(_DWORD *)(a1 + 76) )
    return v11;
LABEL_23:
  sub_3F210((int)v11);
  return 0;
}
// 3FB38: using guessed type int __fastcall sub_3FB38(_DWORD, _DWORD);

//----- (0003F840) --------------------------------------------------------
json_t *__fastcall sub_3F840(int a1, int a2)
{
  json_t *v6; // [sp+Ch] [bp+Ch]
  char v7; // [sp+13h] [bp+13h]
  json_t *v8; // [sp+14h] [bp+14h]

  v8 = (json_t *)json_array();
  sub_3F2C8((_DWORD *)a1);
  while ( *(_BYTE *)(a1 + 36) != 93 )
  {
    if ( !*(_BYTE *)(a1 + 36) )
    {
      sub_3F404((int *)a1, "<format>", 9, "Unexpected end of format string");
      goto LABEL_17;
    }
    sub_3F2C8((_DWORD *)a1);
    v7 = *(_BYTE *)(a1 + 36);
    sub_3F3D0((_DWORD *)a1);
    v6 = (json_t *)sub_3FB38(a1, a2);
    if ( v6 )
    {
      if ( *(_DWORD *)(a1 + 76) )
        sub_3F210((int)v6);
      if ( !*(_DWORD *)(a1 + 76) && json_array_append_new(v8, v6) )
      {
        sub_3F404((int *)a1, "<internal>", 1, "Unable to append to array");
        *(_DWORD *)(a1 + 76) = 1;
      }
    }
    else if ( v7 != 42 )
    {
      *(_DWORD *)(a1 + 76) = 1;
    }
    sub_3F2C8((_DWORD *)a1);
  }
  if ( !*(_DWORD *)(a1 + 76) )
    return v8;
LABEL_17:
  sub_3F210((int)v8);
  return 0;
}
// 3FB38: using guessed type int __fastcall sub_3FB38(_DWORD, _DWORD);

//----- (0003F924) --------------------------------------------------------
_DWORD *__fastcall sub_3F924(int a1, char ***a2)
{
  _BOOL4 v2; // r3
  int v7; // [sp+14h] [bp+Ch] BYREF
  size_t v8; // [sp+18h] [bp+10h] BYREF
  char *v9; // [sp+1Ch] [bp+14h]
  _BOOL4 v10; // [sp+20h] [bp+18h]
  char v11; // [sp+27h] [bp+1Fh]

  sub_3F2C8((_DWORD *)a1);
  v11 = *(_BYTE *)(a1 + 36);
  v2 = v11 == 63 || v11 == 42;
  v10 = v2;
  if ( !v2 )
    sub_3F3D0((_DWORD *)a1);
  v9 = sub_3F454(a1, a2, (int)"string", &v8, &v7, v10);
  if ( v9 )
  {
    if ( *(_DWORD *)(a1 + 76) )
    {
      return 0;
    }
    else if ( v7 )
    {
      return jsonp_stringn_nocheck_own(v9, v8);
    }
    else
    {
      return json_stringn_nocheck(v9, v8);
    }
  }
  else if ( v11 != 63 || *(_DWORD *)(a1 + 76) )
  {
    return 0;
  }
  else
  {
    return json_null();
  }
}

//----- (0003F9D4) --------------------------------------------------------
void *__fastcall sub_3F9D4(int a1, int **a2, int a3)
{
  int *v3; // r3
  char v9; // [sp+17h] [bp+17h]

  sub_3F2C8((_DWORD *)a1);
  v9 = *(_BYTE *)(a1 + 36);
  if ( v9 != 63 && v9 != 42 )
    sub_3F3D0((_DWORD *)a1);
  v3 = (*a2)++;
  if ( *v3 )
  {
    if ( a3 )
      return (void *)sub_3F1D0(*v3);
    else
      return (void *)*v3;
  }
  else if ( v9 == 42 )
  {
    return 0;
  }
  else if ( v9 == 63 )
  {
    return json_null();
  }
  else
  {
    sub_3F404((int *)a1, "<args>", 12, "NULL object");
    *(_DWORD *)(a1 + 76) = 1;
    return 0;
  }
}

//----- (0003FA68) --------------------------------------------------------
_QWORD *__fastcall sub_3FA68(int *a1, __int64 a2)
{
  _QWORD *v5; // [sp+14h] [bp+14h]

  v5 = json_integer(a2);
  if ( !v5 )
  {
    sub_3F404(a1, "<internal>", 1, "Out of memory");
    a1[19] = 1;
  }
  return v5;
}

//----- (0003FAAC) --------------------------------------------------------
_QWORD *__fastcall sub_3FAAC(double a1)
{
  double v1; // r0
  int *v4; // [sp+Ch] [bp+Ch]
  _QWORD *v5; // [sp+14h] [bp+14h]

  v4 = (int *)LODWORD(a1);
  v5 = json_real(a1);
  if ( v5 )
  {
    LODWORD(v1) = v5;
    if ( json_real_set(v1) )
    {
      sub_3F210((int)v5);
      sub_3F404(v4, "<args>", 15, "Invalid floating point value");
      v4[19] = 1;
      return 0;
    }
    else
    {
      return v5;
    }
  }
  else
  {
    sub_3F404(v4, "<internal>", 1, "Out of memory");
    v4[19] = 1;
    return 0;
  }
}
// 3FAF0: variable 'v1' is possibly undefined

//----- (0003FB38) --------------------------------------------------------
void *__fastcall sub_3FB38(double a1)
{
  double v1; // kr08_8
  void *v2; // r3
  _DWORD *v3; // r3
  int *v4; // r3
  __int64 *v5; // r3

  v1 = a1;
  switch ( *(_BYTE *)(LODWORD(a1) + 36) )
  {
    case 'I':
      v5 = (__int64 *)((*(_DWORD *)HIDWORD(a1) + 7) & 0xFFFFFFF8);
      *(_DWORD *)HIDWORD(a1) = v5 + 1;
      v2 = sub_3FA68((int *)LODWORD(a1), *v5);
      break;
    case 'O':
      v2 = sub_3F9D4(SLODWORD(a1), (int **)HIDWORD(a1), 1);
      break;
    case '[':
      v2 = sub_3F840(SLODWORD(a1), SHIDWORD(a1));
      break;
    case 'b':
      v3 = (_DWORD *)*(_DWORD *)HIDWORD(a1);
      *(_DWORD *)HIDWORD(a1) += 4;
      if ( *v3 )
        v2 = json_true();
      else
        v2 = json_false();
      break;
    case 'f':
      HIDWORD(a1) = ((*(_DWORD *)HIDWORD(a1) + 7) & 0xFFFFFFF8) + 8;
      *(_DWORD *)HIDWORD(v1) = HIDWORD(a1);
      v2 = sub_3FAAC(a1);
      break;
    case 'i':
      v4 = (int *)*(_DWORD *)HIDWORD(a1);
      *(_DWORD *)HIDWORD(a1) += 4;
      v2 = sub_3FA68((int *)LODWORD(a1), *v4);
      break;
    case 'n':
      v2 = json_null();
      break;
    case 'o':
      v2 = sub_3F9D4(SLODWORD(a1), (int **)HIDWORD(a1), 0);
      break;
    case 's':
      v2 = sub_3F924(SLODWORD(a1), (char ***)HIDWORD(a1));
      break;
    case '{':
      v2 = sub_3F6D0(SLODWORD(a1), (char ***)HIDWORD(a1));
      break;
    default:
      sub_3F404((int *)LODWORD(a1), "<format>", 9, "Unexpected format character '%c'");
      *(_DWORD *)(LODWORD(v1) + 76) = 1;
      v2 = 0;
      break;
  }
  return v2;
}

//----- (0003FD24) --------------------------------------------------------
int __fastcall sub_3FD24(int a1, const json_t *a2, char ***a3)
{
  int v4; // r3
  char **v5; // r3
  void *v6; // r0
  size_t v7; // r0
  void *v8; // r0
  size_t v9; // r0
  void *v10; // r0
  void *v11; // r0
  void *v12; // r0
  _BYTE v17[12]; // [sp+18h] [bp+10h] BYREF
  _DWORD v18[7]; // [sp+24h] [bp+1Ch] BYREF
  char *v20; // [sp+44h] [bp+3Ch]
  int v21; // [sp+48h] [bp+40h]
  int appended; // [sp+4Ch] [bp+44h]
  char *s; // [sp+50h] [bp+48h]
  int v24; // [sp+54h] [bp+4Ch]
  json_t *v25; // [sp+58h] [bp+50h]
  int v26; // [sp+5Ch] [bp+54h]
  _BOOL4 v27; // [sp+60h] [bp+58h]
  int v28; // [sp+64h] [bp+5Ch]

  v28 = -1;
  v27 = 0;
  v26 = 0;
  if ( hashtable_init((int)v18) )
  {
    sub_3F404((int *)a1, "<internal>", 1, "Out of memory");
    return -1;
  }
  else
  {
    if ( a2 && *(_DWORD *)a2 )
    {
      sub_3F404((int *)a1, "<validation>", 10, "Expected object, got %s");
    }
    else
    {
      sub_3F2C8((_DWORD *)a1);
      while ( *(_BYTE *)(a1 + 36) != 125 )
      {
        v24 = 0;
        if ( v27 )
        {
          sub_3F404((int *)a1, "<format>", 9, "Expected '}' after '%c', got '%c'");
          goto LABEL_53;
        }
        switch ( *(_BYTE *)(a1 + 36) )
        {
          case 0:
            sub_3F404((int *)a1, "<format>", 9, "Unexpected end of format string");
            goto LABEL_53;
          case 0x21:
          case 0x2A:
            if ( *(_BYTE *)(a1 + 36) == 33 )
              v4 = 1;
            else
              v4 = -1;
            v27 = v4;
            sub_3F2C8((_DWORD *)a1);
            break;
          case 0x73:
            v5 = (*a3)++;
            v20 = *v5;
            if ( !v20 )
            {
              sub_3F404((int *)a1, "<args>", 12, "NULL object key");
              goto LABEL_53;
            }
            sub_3F2C8((_DWORD *)a1);
            if ( *(_BYTE *)(a1 + 36) == 63 )
            {
              v26 = 1;
              v24 = 1;
              sub_3F2C8((_DWORD *)a1);
            }
            if ( a2 )
            {
              v25 = json_object_get(a2, v20);
              if ( !v25 && !v24 )
              {
                sub_3F404((int *)a1, "<validation>", 16, "Object item not found: %s");
                goto LABEL_53;
              }
            }
            else
            {
              v25 = 0;
            }
            if ( sub_40294(a1, v25, a3) )
              goto LABEL_53;
            v6 = json_null();
            hashtable_set((int)v18, v20, (int)v6);
            sub_3F2C8((_DWORD *)a1);
            break;
          default:
            sub_3F404((int *)a1, "<format>", 9, "Expected format 's', got '%c'");
            goto LABEL_53;
        }
      }
      if ( !v27 )
        v27 = (*(_DWORD *)(a1 + 60) & 2) != 0;
      if ( !a2 || !v27 )
        goto LABEL_52;
      appended = 1;
      v21 = 0;
      if ( v26 || (v7 = json_object_size(a2), v7 != v18[0]) )
      {
        v8 = json_object_iter(a2);
        for ( s = (char *)json_object_iter_key(v8); s; s = (char *)json_object_iter_key(v11) )
        {
          v12 = json_object_key_to_iter(s);
          if ( !json_object_iter_value((int)v12) )
            break;
          if ( !hashtable_get((hashtable_t *)v18, s) )
          {
            ++v21;
            if ( appended == 1 )
            {
              appended = strbuffer_init((strbuffer_t *)v17);
            }
            else if ( !appended )
            {
              appended = strbuffer_append_bytes((int)v17, ", ", 2u);
            }
            if ( !appended )
            {
              v9 = strlen(s);
              appended = strbuffer_append_bytes((int)v17, s, v9);
            }
          }
          v10 = json_object_key_to_iter(s);
          v11 = json_object_iter_next(a2, v10);
        }
      }
      if ( v21 )
      {
        if ( !appended )
          strbuffer_value((int)v17);
        sub_3F404((int *)a1, "<validation>", 7, "%li object item(s) left unpacked: %s");
        strbuffer_close((strbuffer_t *)v17);
      }
      else
      {
LABEL_52:
        v28 = 0;
      }
    }
LABEL_53:
    hashtable_close((hashtable_t *)v18);
    return v28;
  }
}
// 3FD76: conditional instruction was optimized away because %var_58.4!=0
// 40294: using guessed type int __fastcall sub_40294(_DWORD, _DWORD, _DWORD);

//----- (00040088) --------------------------------------------------------
int __fastcall sub_40088(int a1, const json_t *a2, int a3)
{
  int v4; // r3
  int v5; // r0
  int v10; // [sp+1Ch] [bp+14h]
  _BOOL4 v11; // [sp+20h] [bp+18h]
  unsigned int v12; // [sp+24h] [bp+1Ch]

  v12 = 0;
  v11 = 0;
  if ( !a2 || *(_DWORD *)a2 == 1 )
  {
    sub_3F2C8((_DWORD *)a1);
    while ( *(_BYTE *)(a1 + 36) != 93 )
    {
      if ( v11 )
      {
        sub_3F404((int *)a1, "<format>", 9, "Expected ']' after '%c', got '%c'");
        return -1;
      }
      if ( !*(_BYTE *)(a1 + 36) )
      {
        sub_3F404((int *)a1, "<format>", 9, "Unexpected end of format string");
        return -1;
      }
      if ( *(_BYTE *)(a1 + 36) == 33 || *(_BYTE *)(a1 + 36) == 42 )
      {
        if ( *(_BYTE *)(a1 + 36) == 33 )
          v4 = 1;
        else
          v4 = -1;
        v11 = v4;
        sub_3F2C8((_DWORD *)a1);
      }
      else
      {
        if ( !strchr("{[siIbfFOon", *(unsigned __int8 *)(a1 + 36)) )
        {
          sub_3F404((int *)a1, "<format>", 9, "Unexpected format character '%c'");
          return -1;
        }
        if ( a2 )
        {
          v10 = json_array_get(a2, v12);
          if ( !v10 )
          {
            sub_3F404((int *)a1, "<validation>", 17, "Array index %lu out of range");
            return -1;
          }
          v5 = sub_40294(a1, v10, a3);
        }
        else
        {
          v5 = sub_40294(a1, 0, a3);
        }
        if ( v5 )
          return -1;
        sub_3F2C8((_DWORD *)a1);
        ++v12;
      }
    }
    if ( !v11 )
      v11 = (*(_DWORD *)(a1 + 60) & 2) != 0;
    if ( a2 && v11 && json_array_size(a2) != v12 )
    {
      json_array_size(a2);
      sub_3F404((int *)a1, "<validation>", 7, "%li array item(s) left unpacked");
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_3F404((int *)a1, "<validation>", 10, "Expected array, got %s");
    return -1;
  }
}
// 40294: using guessed type int __fastcall sub_40294(_DWORD, _DWORD, _DWORD);

//----- (00040294) --------------------------------------------------------
int __fastcall sub_40294(int a1, const json_t *a2, char ***a3)
{
  __int64 v3; // d0
  const char ***v5; // r3
  size_t **v6; // r3
  int **v7; // r3
  int **v8; // r3
  int v9; // r1
  char **v10; // r3
  char **v11; // r3
  char **v12; // r3
  const json_t ***v13; // r3
  char *v18; // [sp+1Ch] [bp+14h]
  char *v19; // [sp+20h] [bp+18h]
  int *v20; // [sp+28h] [bp+20h]
  int *v21; // [sp+2Ch] [bp+24h]
  const char **v22; // [sp+30h] [bp+28h]
  size_t *v23; // [sp+34h] [bp+2Ch]

  switch ( *(_BYTE *)(a1 + 36) )
  {
    case 'F':
      if ( !a2 || *(_DWORD *)a2 == 3 || *(_DWORD *)a2 == 4 )
      {
        if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
        {
          v12 = (*a3)++;
          v18 = *v12;
          if ( a2 )
          {
            json_number_value(a2);
            *(_QWORD *)v18 = v3;
          }
        }
        return 0;
      }
      else
      {
        sub_3F404((int *)a1, "<validation>", 10, "Expected real or integer, got %s");
        return -1;
      }
    case 'I':
      if ( a2 && *(_DWORD *)a2 != 3 )
        goto LABEL_20;
      if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
      {
        v8 = (int **)(*a3)++;
        v20 = *v8;
        if ( a2 )
        {
          *v20 = json_integer_value(a2);
          v20[1] = v9;
        }
      }
      return 0;
    case 'O':
      if ( a2 && (*(_DWORD *)(a1 + 60) & 1) == 0 )
        sub_3F1D0((int)a2);
      goto LABEL_57;
    case '[':
      return sub_40088(a1, a2, (int)a3);
    case 'b':
      if ( !a2 || *(_DWORD *)a2 == 5 || *(_DWORD *)a2 == 6 )
      {
        if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
        {
          v10 = (*a3)++;
          if ( a2 )
            *(_DWORD *)*v10 = *(_DWORD *)a2 == 5;
        }
        return 0;
      }
      else
      {
        sub_3F404((int *)a1, "<validation>", 10, "Expected true or false, got %s");
        return -1;
      }
    case 'f':
      if ( !a2 || *(_DWORD *)a2 == 4 )
      {
        if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
        {
          v11 = (*a3)++;
          v19 = *v11;
          if ( a2 )
          {
            json_real_value(a2);
            *(_QWORD *)v19 = v3;
          }
        }
        return 0;
      }
      else
      {
        sub_3F404((int *)a1, "<validation>", 10, "Expected real, got %s");
        return -1;
      }
    case 'i':
      if ( !a2 || *(_DWORD *)a2 == 3 )
      {
        if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
        {
          v7 = (int **)(*a3)++;
          if ( a2 )
          {
            v21 = *v7;
            *v21 = json_integer_value(a2);
          }
        }
        return 0;
      }
      else
      {
LABEL_20:
        sub_3F404((int *)a1, "<validation>", 10, "Expected integer, got %s");
        return -1;
      }
    case 'n':
      if ( !a2 || *(_DWORD *)a2 == 7 )
        return 0;
      sub_3F404((int *)a1, "<validation>", 10, "Expected null, got %s");
      return -1;
    case 'o':
LABEL_57:
      if ( (*(_DWORD *)(a1 + 60) & 1) == 0 )
      {
        v13 = (const json_t ***)(*a3)++;
        if ( a2 )
          **v13 = a2;
      }
      return 0;
    case 's':
      if ( a2 && *(_DWORD *)a2 != 2 )
      {
        sub_3F404((int *)a1, "<validation>", 10, "Expected string, got %s");
        return -1;
      }
      if ( (*(_DWORD *)(a1 + 60) & 1) != 0 )
        return 0;
      v23 = 0;
      v5 = (const char ***)(*a3)++;
      v22 = *v5;
      if ( !*v5 )
      {
        sub_3F404((int *)a1, "<args>", 12, "NULL string argument");
        return -1;
      }
      sub_3F2C8((_DWORD *)a1);
      if ( *(_BYTE *)(a1 + 36) == 37 )
      {
        v6 = (size_t **)(*a3)++;
        v23 = *v6;
        if ( !*v6 )
        {
          sub_3F404((int *)a1, "<args>", 12, "NULL string length argument");
          return -1;
        }
      }
      else
      {
        sub_3F3D0((_DWORD *)a1);
      }
      if ( a2 )
      {
        *v22 = json_string_value(a2);
        if ( v23 )
          *v23 = json_string_length(a2);
      }
      return 0;
    case '{':
      return sub_3FD24(a1, a2, a3);
    default:
      sub_3F404((int *)a1, "<format>", 9, "Unexpected format character '%c'");
      return -1;
  }
}
// 403B2: conditional instruction was optimized away because %var_2C.4!=0
// 404A8: conditional instruction was optimized away because %var_2C.4!=0
// 40520: conditional instruction was optimized away because %var_2C.4!=0
// 40598: conditional instruction was optimized away because %var_2C.4!=0
// 405A6: conditional instruction was optimized away because %var_2C.4!=0
// 40604: conditional instruction was optimized away because %var_2C.4!=0
// 40626: conditional instruction was optimized away because %var_2C.4!=0
// 4069E: conditional instruction was optimized away because %var_2C.4!=0
// 406AC: conditional instruction was optimized away because %var_2C.4!=0
// 40766: conditional instruction was optimized away because %var_2C.4!=0
// 40586: variable 'v9' is possibly undefined
// 4068C: variable 'v3' is possibly undefined

//----- (000407D0) --------------------------------------------------------
void *__fastcall json_vpack_ex(json_error_t *a1, int a2, _BYTE *a3, int a4)
{
  double v5; // r0
  int v11; // [sp+18h] [bp+10h] BYREF
  int v12[9]; // [sp+1Ch] [bp+14h] BYREF
  char v13; // [sp+40h] [bp+38h]
  void *v14; // [sp+6Ch] [bp+64h]

  if ( a3 && *a3 )
  {
    jsonp_error_init(a1, 0);
    sub_3F254(v12, (int)a1, a2, (int)a3);
    sub_3F2C8(v12);
    v11 = a4;
    HIDWORD(v5) = &v11;
    LODWORD(v5) = v12;
    v14 = sub_3FB38(v5);
    if ( v14 )
    {
      sub_3F2C8(v12);
      if ( v13 )
      {
        sub_3F210((int)v14);
        sub_3F404(v12, "<format>", 9, "Garbage after format string");
        return 0;
      }
      else
      {
        return v14;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    jsonp_error_init(a1, "<format>");
    jsonp_error_set((int)a1, -1, -1, 0, 4, "NULL or empty format string");
    return 0;
  }
}

//----- (0004089C) --------------------------------------------------------
void *g_dbus_create_error(json_error_t *a1, int a2, _BYTE *a3, ...)
{
  va_list varg_r3; // [sp+1Ch] [bp+1Ch] BYREF

  va_start(varg_r3, a3);
  return json_vpack_ex(a1, a2, a3, (int)varg_r3);
}

//----- (000408CC) --------------------------------------------------------
void *json_pack(_BYTE *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+14h] BYREF

  va_start(varg_r1, a1);
  return json_vpack_ex(0, 0, a1, (int)varg_r1);
}

//----- (000408F8) --------------------------------------------------------
int __fastcall json_vunpack_ex(const json_t *a1, json_error_t *a2, int a3, _BYTE *a4, char **a5)
{
  char **v11; // [sp+1Ch] [bp+14h] BYREF
  int v12[9]; // [sp+20h] [bp+18h] BYREF
  char v13; // [sp+44h] [bp+3Ch]

  if ( a1 )
  {
    if ( a4 && *a4 )
    {
      jsonp_error_init(a2, 0);
      sub_3F254(v12, (int)a2, a3, (int)a4);
      sub_3F2C8(v12);
      v11 = a5;
      if ( sub_40294((int)v12, a1, &v11) )
      {
        return -1;
      }
      else
      {
        sub_3F2C8(v12);
        if ( v13 )
        {
          sub_3F404(v12, "<format>", 9, "Garbage after format string");
          return -1;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      jsonp_error_init(a2, "<format>");
      jsonp_error_set((int)a2, -1, -1, 0, 4, "NULL or empty format string");
      return -1;
    }
  }
  else
  {
    jsonp_error_init(a2, "<root>");
    jsonp_error_set((int)a2, -1, -1, 0, 12, "NULL root value");
    return -1;
  }
}

//----- (000409FC) --------------------------------------------------------
int g_dbus_send_error(const json_t *a1, json_error_t *a2, int a3, _BYTE *a4, ...)
{
  va_list va; // [sp+30h] [bp+28h] BYREF

  va_start(va, a4);
  return json_vunpack_ex(a1, a2, a3, a4, (char **)va);
}

//----- (00040A34) --------------------------------------------------------
int json_unpack(const json_t *a1, _BYTE *a2, ...)
{
  va_list varg_r2; // [sp+28h] [bp+20h] BYREF

  va_start(varg_r2, a2);
  return json_vunpack_ex(a1, 0, 0, a2, (char **)varg_r2);
}

//----- (00040A68) --------------------------------------------------------
int __cdecl dump_to_strbuffer(const char *buffer, size_t size, void *data)
{
  return strbuffer_append_bytes((int)data, buffer, size);
}

//----- (00040A88) --------------------------------------------------------
int __fastcall sub_40A88(const void *a1, size_t a2, _DWORD *a3)
{
  if ( a3[1] + a2 <= *a3 )
    memcpy((void *)(a3[1] + a3[2]), a1, a2);
  a3[1] += a2;
  return 0;
}

//----- (00040AD4) --------------------------------------------------------
int __fastcall sub_40AD4(const void *a1, size_t a2, FILE *a3)
{
  if ( fwrite(a1, a2, 1u, a3) == 1 )
    return 0;
  else
    return -1;
}

//----- (00040B08) --------------------------------------------------------
int __fastcall sub_40B08(const void *a1, size_t a2, int *a3)
{
  if ( write(*a3, a1, a2) == a2 )
    return 0;
  else
    return -1;
}

//----- (00040B40) --------------------------------------------------------
int __fastcall sub_40B40(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  int v6; // r3
  int v9; // [sp+14h] [bp+14h]
  unsigned int v10; // [sp+1Ch] [bp+1Ch]

  if ( (a1 & 0x1F) == 0 )
  {
    if ( a3 && (a1 & 0x20) == 0 )
      return a4(" ", 1, a5);
    return 0;
  }
  v10 = (a1 & 0x1F) * a2;
  if ( !a4("\n", 1, a5) )
  {
    while ( v10 )
    {
      v6 = v10;
      if ( v10 >= 0x20 )
        v6 = 32;
      v9 = v6;
      if ( a4("                                ", v6, a5) )
        return -1;
      v10 -= v9;
    }
    return 0;
  }
  return -1;
}

//----- (00040BEC) --------------------------------------------------------
int __fastcall sub_40BEC(const char *a1, int a2, int (__fastcall *a3)(const char *, int, int), int a4, __int16 a5)
{
  char s[16]; // [sp+18h] [bp+10h] BYREF
  int32_t v12; // [sp+28h] [bp+20h] BYREF
  int v13; // [sp+2Ch] [bp+24h]
  int v14; // [sp+30h] [bp+28h]
  const char *v15; // [sp+34h] [bp+2Ch]
  int v16; // [sp+38h] [bp+30h]
  char *v17; // [sp+3Ch] [bp+34h]
  const char *v18; // [sp+40h] [bp+38h]
  const char *v19; // [sp+44h] [bp+3Ch]

  v12 = 0;
  if ( !a3("\"", 1, a4) )
  {
    v19 = a1;
    v18 = a1;
    v15 = &a1[a2];
    while ( 1 )
    {
      while ( v18 < v15 )
      {
        v18 = utf8_iterate(v19, v15 - v19, &v12);
        if ( !v18 )
          return -1;
        if ( v12 == 92 || v12 == 34 || v12 <= 31 || (a5 & 0x400) != 0 && v12 == 47 || (a5 & 0x40) != 0 && v12 > 127 )
          break;
        v19 = v18;
      }
      if ( v19 != a1 && a3(a1, v19 - a1, a4) )
        return -1;
      if ( v18 == v19 )
        return a3("\"", 1, a4);
      v16 = 2;
      if ( v12 == 12 )
      {
        v17 = "\\f";
        goto LABEL_44;
      }
      if ( v12 > 12 )
      {
        if ( v12 == 34 )
        {
          v17 = "\\\"";
          goto LABEL_44;
        }
        if ( v12 > 34 )
        {
          if ( v12 == 47 )
          {
            v17 = "\\/";
            goto LABEL_44;
          }
          if ( v12 == 92 )
          {
            v17 = "\\\\";
            goto LABEL_44;
          }
        }
        else if ( v12 == 13 )
        {
          v17 = "\\r";
          goto LABEL_44;
        }
      }
      else
      {
        switch ( v12 )
        {
          case 9:
            v17 = "\\t";
            goto LABEL_44;
          case 10:
            v17 = "\\n";
            goto LABEL_44;
          case 8:
            v17 = "\\b";
            goto LABEL_44;
        }
      }
      if ( v12 >= 0x10000 )
      {
        v12 -= 0x10000;
        v14 = ((v12 & 0xFFC00) >> 10) | 0xD800;
        v13 = v12 & 0x3FF | 0xDC00;
        snprintf(s, 0xDu, "\\u%04X\\u%04X", v14, v13);
        v16 = 12;
      }
      else
      {
        snprintf(s, 0xDu, "\\u%04X", v12);
        v16 = 6;
      }
      v17 = s;
LABEL_44:
      if ( a3(v17, v16, a4) )
        return -1;
      v19 = v18;
      a1 = v18;
    }
  }
  return -1;
}

//----- (00040E00) --------------------------------------------------------
int __cdecl compare_keys(const void *key1, const void *key2)
{
  return strcmp(*(const char **)key1, *(const char **)key2);
}

//----- (00040E24) --------------------------------------------------------
int __fastcall sub_40E24(hashtable_t *a1, const void *a2, char *a3, size_t a4)
{
  void *v5; // r0

  snprintf(a3, a4, "%p", a2);
  if ( hashtable_get(a1, a3) )
    return -1;
  v5 = json_null();
  return hashtable_set((int)a1, a3, (int)v5);
}

//----- (00040E74) --------------------------------------------------------
int __fastcall sub_40E74(
        _DWORD *a1,
        int a2,
        int a3,
        hashtable_t *a4,
        int (__fastcall *a5)(const char *, int, int),
        int a6)
{
  double v6; // d0
  __int64 v8; // r0
  const char *v9; // r4
  size_t v10; // r0
  int v11; // r0
  const char **v12; // r4
  size_t v13; // r0
  size_t v14; // r0
  int v15; // r0
  unsigned int v19; // [sp+10h] [bp+8h]
  char s[100]; // [sp+1Ch] [bp+14h] BYREF
  char v22[12]; // [sp+80h] [bp+78h] BYREF
  char v23[12]; // [sp+8Ch] [bp+84h] BYREF
  char *v24; // [sp+98h] [bp+90h]
  void *v25; // [sp+9Ch] [bp+94h]
  json_t *v26; // [sp+A0h] [bp+98h]
  char *v27; // [sp+A4h] [bp+9Ch]
  void *base; // [sp+A8h] [bp+A0h]
  size_t nmemb; // [sp+ACh] [bp+A4h]
  size_t v30; // [sp+B0h] [bp+A8h]
  int v31; // [sp+B4h] [bp+ACh]
  double v32; // [sp+B8h] [bp+B0h]
  unsigned int v33; // [sp+C4h] [bp+BCh]
  int v34; // [sp+C8h] [bp+C0h]
  size_t i; // [sp+CCh] [bp+C4h]
  int v36; // [sp+D0h] [bp+C8h]
  const char *v37; // [sp+D4h] [bp+CCh]
  void *v38; // [sp+D8h] [bp+D0h]
  size_t j; // [sp+DCh] [bp+D4h]

  v34 = a2 & 0x10000;
  v19 = a2 & 0xFFFEFFFF;
  if ( a1 )
  {
    switch ( *a1 )
    {
      case 0:
        if ( (a2 & 0x20) != 0 )
        {
          v37 = ":";
          v36 = 1;
        }
        else
        {
          v37 = ": ";
          v36 = 2;
        }
        if ( sub_40E24(a4, a1, v22, 0xBu) )
          return -1;
        v38 = json_object_iter((json_t *)a1);
        if ( !v34 && a5("{", 1, a6) )
          return -1;
        if ( v38 )
        {
          if ( sub_40B40(v19, a3 + 1, 0, a5, a6) )
            return -1;
          if ( (v19 & 0x80) == 0 )
          {
            while ( 1 )
            {
              if ( !v38 )
                goto LABEL_82;
              v25 = json_object_iter_next((json_t *)a1, v38);
              v24 = (char *)json_object_iter_key(v38);
              v14 = strlen(v24);
              sub_40BEC(v24, v14, a5, a6, v19);
              if ( a5(v37, v36, a6) )
                return -1;
              v15 = json_object_iter_value((int)v38);
              if ( sub_40E74(v15, v19, a3 + 1, a4, a5, a6) )
                return -1;
              if ( v25 )
              {
                if ( a5(",", 1, a6) || sub_40B40(v19, a3 + 1, 1, a5, a6) )
                  return -1;
              }
              else if ( sub_40B40(v19, a3, 0, a5, a6) )
              {
                return -1;
              }
              v38 = v25;
            }
          }
          nmemb = json_object_size((const json_t *)a1);
          base = jsonp_malloc(4 * nmemb);
          if ( !base )
            return -1;
          i = 0;
          while ( v38 )
          {
            v12 = (const char **)((char *)base + 4 * i);
            *v12 = json_object_iter_key(v38);
            v38 = json_object_iter_next((json_t *)a1, v38);
            ++i;
          }
          qsort(base, nmemb, 4u, (__compar_fn_t)compare_keys);
          for ( i = 0; i < nmemb; ++i )
          {
            v27 = (char *)*((_DWORD *)base + i);
            v26 = json_object_get((const json_t *)a1, v27);
            v13 = strlen(v27);
            sub_40BEC(v27, v13, a5, a6, v19);
            if ( a5(v37, v36, a6) || sub_40E74(v26, v19, a3 + 1, a4, a5, a6) )
            {
LABEL_67:
              jsonp_free(base);
              return -1;
            }
            if ( nmemb - 1 <= i )
            {
              if ( sub_40B40(v19, a3, 0, a5, a6) )
                goto LABEL_67;
            }
            else if ( a5(",", 1, a6) || sub_40B40(v19, a3 + 1, 1, a5, a6) )
            {
              goto LABEL_67;
            }
          }
          jsonp_free(base);
LABEL_82:
          hashtable_del((int)a4, v22);
          if ( v34 )
            return 0;
        }
        else
        {
          hashtable_del((int)a4, v22);
          if ( v34 )
            return 0;
        }
        return a5("}", 1, a6);
      case 1:
        if ( sub_40E24(a4, a1, v23, 0xBu) )
          return -1;
        v30 = json_array_size((const json_t *)a1);
        if ( !v34 && a5("[", 1, a6) )
          return -1;
        if ( v30 )
        {
          if ( sub_40B40(v19, a3 + 1, 0, a5, a6) )
            return -1;
          for ( j = 0; j < v30; ++j )
          {
            v11 = json_array_get(a1, j);
            if ( sub_40E74(v11, v19, a3 + 1, a4, a5, a6) )
              return -1;
            if ( v30 - 1 <= j )
            {
              if ( sub_40B40(v19, a3, 0, a5, a6) )
                return -1;
            }
            else if ( a5(",", 1, a6) || sub_40B40(v19, a3 + 1, 1, a5, a6) )
            {
              return -1;
            }
          }
          hashtable_del((int)a4, v23);
          if ( v34 )
            return 0;
        }
        else
        {
          hashtable_del((int)a4, v23);
          if ( v34 )
            return 0;
        }
        return a5("]", 1, a6);
      case 2:
        v9 = json_string_value((const json_t *)a1);
        v10 = json_string_length((const json_t *)a1);
        return sub_40BEC(v9, v10, a5, a6, v19);
      case 3:
        LODWORD(v8) = json_integer_value(a1);
        v33 = snprintf(s, 0x64u, "%lld", v8);
        if ( v33 < 0x64 )
          return a5(s, v33, a6);
        else
          return -1;
      case 4:
        json_real_value((const json_t *)a1);
        v32 = v6;
        v31 = jsonp_dtostr(s, 0x64u, (unsigned __int16)v19 >> 11);
        if ( v31 >= 0 )
          return a5(s, v31, a6);
        else
          return -1;
      case 5:
        return a5("true", 4, a6);
      case 6:
        return a5("false", 5, a6);
      case 7:
        return a5("null", 4, a6);
      default:
        return -1;
    }
  }
  return -1;
}
// 40F34: variable 'v8' is possibly undefined
// 40F6E: variable 'v6' is possibly undefined

//----- (00041520) --------------------------------------------------------
char *__fastcall json_dumps(_DWORD *a1, int a2)
{
  const char *v3; // r0
  _BYTE v7[12]; // [sp+8h] [bp+8h] BYREF
  char *v8; // [sp+14h] [bp+14h]

  if ( strbuffer_init((strbuffer_t *)v7) )
    return 0;
  if ( json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))((char *)dump_to_strbuffer + 1), (int)v7, a2) )
  {
    v8 = 0;
  }
  else
  {
    v3 = (const char *)strbuffer_value((int)v7);
    v8 = jsonp_strdup(v3);
  }
  strbuffer_close((strbuffer_t *)v7);
  return v8;
}

//----- (00041588) --------------------------------------------------------
int __fastcall json_dumpb(_DWORD *a1, int a2, int a3, int a4)
{
  int v6; // [sp+14h] [bp+14h] BYREF
  int v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]

  v6 = a3;
  v7 = 0;
  v8 = a2;
  if ( json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))((char *)sub_40A88 + 1), (int)&v6, a4) )
    return 0;
  else
    return v7;
}

//----- (000415CC) --------------------------------------------------------
int __fastcall json_dumpf(_DWORD *a1, int a2, int a3)
{
  return json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))((char *)sub_40AD4 + 1), a2, a3);
}

//----- (000415F4) --------------------------------------------------------
int __fastcall json_dumpfd(_DWORD *a1, int a2, int a3)
{
  _DWORD v4[2]; // [sp+8h] [bp+8h] BYREF

  v4[1] = a1;
  v4[0] = a2;
  return json_dump_callback(a1, (int (__fastcall *)(const char *, int, int))((char *)sub_40B08 + 1), (int)v4, a3);
}

//----- (00041620) --------------------------------------------------------
int __fastcall json_dump_file(_DWORD *a1, const char *a2, int a3)
{
  int v7; // [sp+10h] [bp+10h]
  FILE *stream; // [sp+14h] [bp+14h]

  stream = fopen(a2, "w");
  if ( !stream )
    return -1;
  v7 = json_dumpf(a1, (int)stream, a3);
  if ( fclose(stream) )
    return -1;
  else
    return v7;
}

//----- (00041670) --------------------------------------------------------
int __fastcall json_dump_callback(_DWORD *a1, int (__fastcall *a2)(const char *, int, int), int a3, int a4)
{
  _BYTE v10[28]; // [sp+18h] [bp+10h] BYREF
  int v11; // [sp+34h] [bp+2Ch]

  if ( (a4 & 0x200) == 0 && (!a1 || *a1 != 1) && (!a1 || *a1) )
    return -1;
  if ( hashtable_init((int)v10) )
    return -1;
  v11 = sub_40E74(a1, a4, 0, (hashtable_t *)v10, a2, a3);
  hashtable_close((hashtable_t *)v10);
  return v11;
}

//----- (000416F0) --------------------------------------------------------
void __cdecl jsonp_error_init(json_error_t *error, const char *source)
{
  if ( error )
  {
    *((_BYTE *)error + 92) = 0;
    *(_DWORD *)error = -1;
    *((_DWORD *)error + 1) = -1;
    *((_DWORD *)error + 2) = 0;
    if ( source )
      jsonp_error_set_source((char *)error, source);
    else
      *((_BYTE *)error + 12) = 0;
  }
}

//----- (0004173C) --------------------------------------------------------
char *__fastcall jsonp_error_set_source(char *result, const char *a2)
{
  char *v3; // [sp+4h] [bp+4h]
  size_t v4; // [sp+Ch] [bp+Ch]

  v3 = result;
  if ( result && a2 )
  {
    v4 = strlen(a2);
    if ( v4 > 0x4F )
    {
      memcpy(v3 + 12, "...", 3u);
      return strncpy(v3 + 15, &a2[v4 - 76], 0x4Du);
    }
    else
    {
      return strncpy(v3 + 12, a2, v4 + 1);
    }
  }
  return result;
}

//----- (000417B4) --------------------------------------------------------
int jsonp_error_set(int a1, int a2, int a3, int a4, char a5, char *format, ...)
{
  va_list va; // [sp+38h] [bp+28h] BYREF

  va_start(va, format);
  return jsonp_error_vset(a1, a2, a3, a4, a5, format, va);
}

//----- (000417E8) --------------------------------------------------------
int __fastcall jsonp_error_vset(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg)
{
  int v7; // [sp+Ch] [bp+Ch]

  v7 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, arg);
      *(_BYTE *)(v7 + 250) = 0;
      *(_BYTE *)(v7 + 251) = a5;
    }
  }
  return result;
}

//----- (00041848) --------------------------------------------------------
void __fastcall sub_41848(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (0004188C) --------------------------------------------------------
int sub_4188C(int result, _DWORD *a2, int a3, const char *a4, ...)
{
  int v6; // [sp+1Ch] [bp+Ch]
  char v7[159]; // [sp+20h] [bp+10h] BYREF
  char v8; // [sp+BFh] [bp+AFh]
  char s[160]; // [sp+C0h] [bp+B0h] BYREF
  __gnuc_va_list arg; // [sp+160h] [bp+150h]
  const char *v11; // [sp+164h] [bp+154h]
  char v12[4]; // [sp+168h] [bp+158h]
  int v13; // [sp+16Ch] [bp+15Ch]
  int v14; // [sp+170h] [bp+160h]
  int v15; // [sp+174h] [bp+164h]
  const char *varg_r3; // [sp+184h] [bp+174h]
  va_list va; // [sp+188h] [bp+178h] BYREF

  va_start(va, a4);
  varg_r3 = a4;
  v6 = result;
  v15 = -1;
  v14 = -1;
  v13 = 0;
  *(_DWORD *)v12 = s;
  if ( result )
  {
    va_copy(arg, va);
    vsnprintf(s, 0xA0u, varg_r3, va);
    s[159] = 0;
    if ( a2 )
    {
      v11 = (const char *)strbuffer_value((int)(a2 + 10));
      v15 = a2[6];
      v14 = a2[7];
      v13 = a2[9];
      if ( v11 && *v11 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v7, 0xA0u, "%s near '%s'", s, v11);
          v8 = 0;
          *(_DWORD *)v12 = v7;
        }
      }
      else
      {
        if ( a3 == 8 )
          LOBYTE(a3) = 6;
        if ( a2[5] == -2 )
        {
          *(_DWORD *)v12 = s;
        }
        else
        {
          snprintf(v7, 0xA0u, "%s near end of file", s);
          v8 = 0;
          *(_DWORD *)v12 = v7;
        }
      }
    }
    return jsonp_error_set(v6, v15, v14, v13, a3, "%s", *(const char **)v12);
  }
  return result;
}

//----- (00041A0C) --------------------------------------------------------
int __fastcall stream_init(int result, int a2, int a3)
{
  *(_DWORD *)result = a2;
  *(_DWORD *)(result + 4) = a3;
  *(_BYTE *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 1;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 36) = 0;
  return result;
}
// 41A0C: invalid function type 'void __cdecl stream_init(stream_t *stream, get_func get, void *data)' has been ignored

//----- (00041A54) --------------------------------------------------------
int __fastcall sub_41A54(int a1, int a2)
{
  int v3; // r3
  size_t v7; // [sp+14h] [bp+Ch]
  int v8; // [sp+18h] [bp+10h]
  int v9; // [sp+18h] [bp+10h]
  unsigned int i; // [sp+1Ch] [bp+14h]

  if ( *(_DWORD *)(a1 + 20) )
    return *(_DWORD *)(a1 + 20);
  if ( !*(_BYTE *)(*(_DWORD *)(a1 + 16) + a1 + 8) )
  {
    v8 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    if ( v8 == -1 )
    {
      *(_DWORD *)(a1 + 20) = -1;
      return -1;
    }
    *(_BYTE *)(a1 + 8) = v8;
    *(_DWORD *)(a1 + 16) = 0;
    if ( v8 <= 127 || v8 > 255 )
    {
      *(_BYTE *)(a1 + 9) = 0;
    }
    else
    {
      v7 = utf8_check_first(v8);
      if ( !v7 )
        goto LABEL_20;
      for ( i = 1; i < v7; ++i )
        *(_BYTE *)(i + a1 + 8) = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
      if ( !utf8_check_full((const char *)(a1 + 8), v7, 0) )
      {
LABEL_20:
        *(_DWORD *)(a1 + 20) = -2;
        sub_4188C(a2, (_DWORD *)a1, 5, "unable to decode byte 0x%x", v8);
        return -2;
      }
      *(_BYTE *)(v7 + a1 + 8) = 0;
    }
  }
  v3 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v3 + 1;
  v9 = *(unsigned __int8 *)(v3 + a1 + 8);
  ++*(_DWORD *)(a1 + 36);
  if ( v9 == 10 )
  {
    ++*(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 28) = 0;
  }
  else if ( utf8_check_first(v9) )
  {
    ++*(_DWORD *)(a1 + 28);
  }
  return v9;
}

//----- (00041BAC) --------------------------------------------------------
_DWORD *__fastcall sub_41BAC(_DWORD *result, int a2)
{
  _DWORD *v2; // [sp+4h] [bp+4h]

  v2 = result;
  if ( a2 != -1 && a2 != -2 )
  {
    --result[9];
    if ( a2 == 10 )
    {
      --result[6];
      result[7] = result[8];
    }
    else
    {
      result = (_DWORD *)utf8_check_first(a2);
      if ( result )
        --v2[7];
    }
    --v2[4];
  }
  return result;
}

//----- (00041C18) --------------------------------------------------------
int __fastcall sub_41C18(int a1, int a2)
{
  return sub_41A54(a1, a2);
}

//----- (00041C38) --------------------------------------------------------
void __cdecl lex_save(lex_t *lex, int c)
{
  strbuffer_append_byte((lex_t *)((char *)lex + 40), c);
}

//----- (00041C5C) --------------------------------------------------------
int __cdecl lex_get_save(lex_t *lex, json_error_t *error)
{
  int v4; // [sp+Ch] [bp+Ch]

  v4 = sub_41A54((int)lex, (int)error);
  if ( v4 != -1 && v4 != -2 )
    lex_save(lex, v4);
  return v4;
}

//----- (00041C94) --------------------------------------------------------
_DWORD *__fastcall sub_41C94(_DWORD *a1, int a2)
{
  return sub_41BAC(a1, a2);
}

//----- (00041CB0) --------------------------------------------------------
_DWORD *__fastcall sub_41CB0(_DWORD *result, int a2)
{
  _DWORD *v2; // [sp+4h] [bp+4h]

  v2 = result;
  if ( a2 != -1 && a2 != -2 )
  {
    sub_41BAC(result, a2);
    return (_DWORD *)strbuffer_pop((strbuffer_t *)(v2 + 10));
  }
  return result;
}

//----- (00041CE8) --------------------------------------------------------
void __cdecl lex_save_cached(lex_t *lex)
{
  while ( *((_BYTE *)lex + *((_DWORD *)lex + 4) + 8) )
  {
    lex_save(lex, *((unsigned __int8 *)lex + *((_DWORD *)lex + 4) + 8));
    ++*((_DWORD *)lex + 4);
    ++*((_DWORD *)lex + 9);
  }
}

//----- (00041D30) --------------------------------------------------------
void __cdecl lex_free_string(lex_t *lex)
{
  jsonp_free(*((void **)lex + 16));
  *((_DWORD *)lex + 16) = 0;
  *((_DWORD *)lex + 17) = 0;
}

//----- (00041D58) --------------------------------------------------------
int __fastcall sub_41D58(int a1)
{
  unsigned __int8 v3; // [sp+Fh] [bp+Fh]
  int v4; // [sp+10h] [bp+10h]
  int v5; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  v4 = 0;
  for ( i = 1; i <= 4; ++i )
  {
    v3 = *(_BYTE *)(i + a1);
    v5 = 16 * v4;
    if ( v3 <= 0x2Fu || v3 > 0x39u )
    {
      if ( v3 <= 0x60u || v3 > 0x7Au )
      {
        if ( v3 <= 0x40u || v3 > 0x5Au )
          return -1;
        v4 = v3 - 55 + v5;
      }
      else
      {
        v4 = v3 - 87 + v5;
      }
    }
    else
    {
      v4 = v3 - 48 + v5;
    }
  }
  return v4;
}

//----- (00041DE4) --------------------------------------------------------
void __fastcall sub_41DE4(int a1, json_error_t *a2)
{
  int v2; // r3
  unsigned __int8 *v3; // r3
  unsigned __int8 *v4; // r2
  int v7; // [sp+14h] [bp+Ch] BYREF
  int v8; // [sp+18h] [bp+10h]
  int v9; // [sp+1Ch] [bp+14h]
  int i; // [sp+20h] [bp+18h]
  unsigned __int8 *v11; // [sp+24h] [bp+1Ch]
  const char *v12; // [sp+28h] [bp+20h]
  int save; // [sp+2Ch] [bp+24h]

  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 60) = -1;
  save = lex_get_save((lex_t *)a1, a2);
  while ( save != 34 )
  {
    if ( save == -2 )
      goto LABEL_77;
    if ( save == -1 )
    {
      sub_4188C((int)a2, (_DWORD *)a1, 6, "premature end of input");
LABEL_77:
      lex_free_string((lex_t *)a1);
      return;
    }
    if ( (unsigned int)save < 0x20 )
    {
      sub_41CB0((_DWORD *)a1, save);
      if ( save == 10 )
        sub_4188C((int)a2, (_DWORD *)a1, 8, "unexpected newline");
      else
        sub_4188C((int)a2, (_DWORD *)a1, 8, "control character 0x%x", save);
      goto LABEL_77;
    }
    if ( save == 92 )
    {
      save = lex_get_save((lex_t *)a1, a2);
      if ( save != 117 )
      {
        if ( save != 34
          && save != 92
          && save != 47
          && save != 98
          && save != 102
          && save != 110
          && save != 114
          && save != 116 )
        {
LABEL_18:
          sub_4188C((int)a2, (_DWORD *)a1, 8, "invalid escape");
          goto LABEL_77;
        }
        goto LABEL_32;
      }
      save = lex_get_save((lex_t *)a1, a2);
      for ( i = 0; i <= 3; ++i )
      {
        if ( (save <= 47 || save > 57) && (save <= 64 || save > 70) && (save <= 96 || save > 102) )
          goto LABEL_18;
        save = lex_get_save((lex_t *)a1, a2);
      }
    }
    else
    {
LABEL_32:
      save = lex_get_save((lex_t *)a1, a2);
    }
  }
  v11 = (unsigned __int8 *)jsonp_malloc(*(_DWORD *)(a1 + 44) + 1);
  if ( !v11 )
    goto LABEL_77;
  *(_DWORD *)(a1 + 64) = v11;
  v12 = (const char *)(strbuffer_value(a1 + 40) + 1);
  while ( *v12 != 34 )
  {
    if ( *v12 == 92 )
    {
      if ( *++v12 == 117 )
      {
        v9 = sub_41D58((int)v12);
        if ( v9 < 0 )
          goto LABEL_39;
        v12 += 5;
        if ( v9 < 55296 || v9 >= 56320 )
        {
          if ( v9 >= 56320 && v9 < 57344 )
          {
LABEL_52:
            sub_4188C((int)a2, (_DWORD *)a1, 8, "invalid Unicode '\\u%04X'", v9);
            goto LABEL_77;
          }
        }
        else
        {
          if ( *v12 != 92 || v12[1] != 117 )
            goto LABEL_52;
          v8 = sub_41D58((int)++v12);
          if ( v8 < 0 )
          {
LABEL_39:
            sub_4188C((int)a2, (_DWORD *)a1, 8, "invalid Unicode escape '%.6s'", v12 - 1);
            goto LABEL_77;
          }
          v12 += 5;
          if ( v8 < 56320 || v8 >= 57344 )
          {
            sub_4188C((int)a2, (_DWORD *)a1, 8, "invalid Unicode '\\u%04X\\u%04X'", v9, v8);
            goto LABEL_77;
          }
          v9 = v8 - 56320 + ((v9 - 55296) << 10) + 0x10000;
        }
        utf8_encode(v9, v11, &v7);
        v11 += v7;
      }
      else
      {
        v2 = *(unsigned __int8 *)v12;
        if ( v2 == 98 )
        {
          *v11 = 8;
        }
        else if ( *(unsigned __int8 *)v12 > 0x62u )
        {
          if ( v2 == 110 )
          {
            *v11 = 10;
          }
          else if ( *(unsigned __int8 *)v12 > 0x6Eu )
          {
            if ( v2 == 114 )
            {
              *v11 = 13;
            }
            else if ( v2 == 116 )
            {
              *v11 = 9;
            }
          }
          else if ( v2 == 102 )
          {
            *v11 = 12;
          }
        }
        else if ( v2 == 47 || v2 == 92 || v2 == 34 )
        {
          *v11 = *v12;
        }
        ++v11;
        ++v12;
      }
    }
    else
    {
      v3 = v11++;
      v4 = (unsigned __int8 *)v12++;
      *v3 = *v4;
    }
  }
  *v11 = 0;
  *(_DWORD *)(a1 + 68) = &v11[-*(_DWORD *)(a1 + 64)];
  *(_DWORD *)(a1 + 60) = 256;
}

//----- (00042174) --------------------------------------------------------
int __fastcall sub_42174(int a1, int a2, json_error_t *a3)
{
  int save; // [sp+8h] [bp+8h]
  int v7; // [sp+8h] [bp+8h]
  double v9; // [sp+10h] [bp+10h] BYREF
  char *endptr; // [sp+1Ch] [bp+1Ch] BYREF
  __int64 v11; // [sp+20h] [bp+20h]
  char *nptr; // [sp+2Ch] [bp+2Ch]

  save = a2;
  *(_DWORD *)(a1 + 60) = -1;
  if ( a2 == 45 )
    save = lex_get_save((lex_t *)a1, a3);
  if ( save == 48 )
  {
    save = lex_get_save((lex_t *)a1, a3);
    if ( save > 47 && save <= 57 )
    {
LABEL_6:
      sub_41CB0((_DWORD *)a1, save);
      return -1;
    }
  }
  else
  {
    if ( save <= 47 || save > 57 )
      goto LABEL_6;
    do
      save = lex_get_save((lex_t *)a1, a3);
    while ( save > 47 && save <= 57 );
  }
  if ( (*(_DWORD *)(a1 + 52) & 8) != 0 || save == 46 || save == 69 || save == 101 )
  {
    if ( save == 46 )
    {
      v7 = sub_41C18(a1, (int)a3);
      if ( v7 <= 47 || v7 > 57 )
      {
        sub_41C94((_DWORD *)a1, v7);
        return -1;
      }
      lex_save((lex_t *)a1, v7);
      do
        save = lex_get_save((lex_t *)a1, a3);
      while ( save > 47 && save <= 57 );
    }
    if ( save == 69 || save == 101 )
    {
      save = lex_get_save((lex_t *)a1, a3);
      if ( save == 43 || save == 45 )
        save = lex_get_save((lex_t *)a1, a3);
      if ( save <= 47 || save > 57 )
        goto LABEL_6;
      do
        save = lex_get_save((lex_t *)a1, a3);
      while ( save > 47 && save <= 57 );
    }
    sub_41CB0((_DWORD *)a1, save);
    if ( jsonp_strtod((strbuffer_t *)(a1 + 40), &v9) )
    {
      sub_4188C((int)a3, (_DWORD *)a1, 15, "real number overflow");
      return -1;
    }
    *(_DWORD *)(a1 + 60) = 258;
    *(double *)(a1 + 64) = v9;
    return 0;
  }
  else
  {
    sub_41CB0((_DWORD *)a1, save);
    nptr = (char *)strbuffer_value(a1 + 40);
    *_errno_location() = 0;
    v11 = strtoll(nptr, &endptr, 10);
    if ( *_errno_location() == 34 )
    {
      if ( v11 >= 0 )
        sub_4188C((int)a3, (_DWORD *)a1, 15, "too big integer");
      else
        sub_4188C((int)a3, (_DWORD *)a1, 15, "too big negative integer");
      return -1;
    }
    *(_DWORD *)(a1 + 60) = 257;
    *(_QWORD *)(a1 + 64) = v11;
    return 0;
  }
}
// 42174: too many cbuild loops

//----- (00042384) --------------------------------------------------------
int __cdecl lex_scan(lex_t *lex, json_error_t *error)
{
  char *s1; // [sp+8h] [bp+8h]
  int v6; // [sp+Ch] [bp+Ch]
  int save; // [sp+Ch] [bp+Ch]

  strbuffer_clear((lex_t *)((char *)lex + 40));
  if ( *((_DWORD *)lex + 15) == 256 )
    lex_free_string(lex);
  do
  {
    do
      v6 = sub_41C18((int)lex, (int)error);
    while ( v6 == 32 );
  }
  while ( v6 == 9 || v6 == 10 || v6 == 13 );
  if ( v6 == -1 )
  {
    *((_DWORD *)lex + 15) = 0;
  }
  else if ( v6 == -2 )
  {
    *((_DWORD *)lex + 15) = -1;
  }
  else
  {
    lex_save(lex, v6);
    if ( v6 == 123 || v6 == 125 || v6 == 91 || v6 == 93 || v6 == 58 || v6 == 44 )
    {
      *((_DWORD *)lex + 15) = v6;
    }
    else if ( v6 == 34 )
    {
      sub_41DE4((int)lex, error);
    }
    else if ( v6 > 47 && v6 <= 57 || v6 == 45 )
    {
      sub_42174((int)lex, v6, error);
    }
    else if ( (v6 <= 64 || v6 > 90) && (v6 <= 96 || v6 > 122) )
    {
      lex_save_cached(lex);
      *((_DWORD *)lex + 15) = -1;
    }
    else
    {
      do
      {
        do
          save = lex_get_save(lex, error);
        while ( save > 64 && save <= 90 );
      }
      while ( save > 96 && save <= 122 );
      sub_41CB0(lex, save);
      s1 = (char *)strbuffer_value((int)lex + 40);
      if ( !strcmp(s1, "true") )
      {
        *((_DWORD *)lex + 15) = 259;
      }
      else if ( !strcmp(s1, "false") )
      {
        *((_DWORD *)lex + 15) = 260;
      }
      else if ( !strcmp(s1, "null") )
      {
        *((_DWORD *)lex + 15) = 261;
      }
      else
      {
        *((_DWORD *)lex + 15) = -1;
      }
    }
  }
  return *((_DWORD *)lex + 15);
}

//----- (00042520) --------------------------------------------------------
char *__cdecl lex_steal_string(lex_t *lex, size_t *out_len)
{
  char *v3; // [sp+Ch] [bp+Ch]

  v3 = 0;
  if ( *((_DWORD *)lex + 15) == 256 )
  {
    v3 = (char *)*((_DWORD *)lex + 16);
    *out_len = *((_DWORD *)lex + 17);
    *((_DWORD *)lex + 16) = 0;
    *((_DWORD *)lex + 17) = 0;
  }
  return v3;
}

//----- (00042560) --------------------------------------------------------
int __fastcall lex_init(int a1, int a2, int a3, int a4)
{
  stream_init(a1, a2, a4);
  if ( strbuffer_init((strbuffer_t *)(a1 + 40)) )
    return -1;
  *(_DWORD *)(a1 + 52) = a3;
  *(_DWORD *)(a1 + 60) = -1;
  return 0;
}
// 42560: invalid function type 'int __cdecl lex_init(lex_t *lex, get_func get, size_t flags, void *data)' has been ignored

//----- (000425A8) --------------------------------------------------------
void __cdecl lex_close(lex_t *lex)
{
  if ( *((_DWORD *)lex + 15) == 256 )
    lex_free_string(lex);
  strbuffer_close((lex_t *)((char *)lex + 40));
}

//----- (000425D4) --------------------------------------------------------
json_t *__fastcall sub_425D4(int a1, int a2, json_error_t *a3)
{
  size_t n; // [sp+10h] [bp+10h] BYREF
  json_t *v9; // [sp+14h] [bp+14h]
  void *s; // [sp+18h] [bp+18h]
  json_t *v11; // [sp+1Ch] [bp+1Ch]

  v11 = (json_t *)json_object();
  if ( !v11 )
    return 0;
  lex_scan((lex_t *)a1, a3);
  if ( *(_DWORD *)(a1 + 60) == 125 )
    return v11;
  while ( 1 )
  {
    if ( *(_DWORD *)(a1 + 60) != 256 )
    {
      sub_4188C((int)a3, (_DWORD *)a1, 8, "string or '}' expected");
      goto LABEL_24;
    }
    s = lex_steal_string((lex_t *)a1, &n);
    if ( !s )
      return 0;
    if ( memchr(s, 0, n) )
    {
      jsonp_free(s);
      sub_4188C((int)a3, (_DWORD *)a1, 13, "NUL byte in object key not supported");
      goto LABEL_24;
    }
    if ( (a2 & 1) != 0 && json_object_get(v11, (const char *)s) )
    {
      jsonp_free(s);
      sub_4188C((int)a3, (_DWORD *)a1, 14, "duplicate object key");
      goto LABEL_24;
    }
    lex_scan((lex_t *)a1, a3);
    if ( *(_DWORD *)(a1 + 60) != 58 )
    {
      jsonp_free(s);
      sub_4188C((int)a3, (_DWORD *)a1, 8, "':' expected");
      goto LABEL_24;
    }
    lex_scan((lex_t *)a1, a3);
    v9 = (json_t *)sub_427FC(a1, a2, a3);
    if ( !v9 || json_object_set_new_nocheck(v11, (const char *)s, v9) )
    {
      jsonp_free(s);
      goto LABEL_24;
    }
    jsonp_free(s);
    lex_scan((lex_t *)a1, a3);
    if ( *(_DWORD *)(a1 + 60) != 44 )
      break;
    lex_scan((lex_t *)a1, a3);
  }
  if ( *(_DWORD *)(a1 + 60) == 125 )
    return v11;
  sub_4188C((int)a3, (_DWORD *)a1, 8, "'}' expected");
LABEL_24:
  sub_41848((int)v11);
  return 0;
}
// 427FC: using guessed type int __fastcall sub_427FC(_DWORD, _DWORD, _DWORD);

//----- (00042750) --------------------------------------------------------
json_t *__fastcall sub_42750(int a1, int a2, json_error_t *a3)
{
  json_t *v8; // [sp+10h] [bp+10h]
  json_t *v9; // [sp+14h] [bp+14h]

  v9 = (json_t *)json_array();
  if ( !v9 )
    return 0;
  lex_scan((lex_t *)a1, a3);
  if ( *(_DWORD *)(a1 + 60) == 93 )
    return v9;
  while ( *(_DWORD *)(a1 + 60) )
  {
    v8 = (json_t *)sub_427FC(a1, a2, a3);
    if ( !v8 || json_array_append_new(v9, v8) )
      goto LABEL_13;
    lex_scan((lex_t *)a1, a3);
    if ( *(_DWORD *)(a1 + 60) != 44 )
      break;
    lex_scan((lex_t *)a1, a3);
  }
  if ( *(_DWORD *)(a1 + 60) == 93 )
    return v9;
  sub_4188C((int)a3, (_DWORD *)a1, 8, "']' expected");
LABEL_13:
  sub_41848((int)v9);
  return 0;
}
// 427FC: using guessed type int __fastcall sub_427FC(_DWORD, _DWORD, _DWORD);

//----- (000427FC) --------------------------------------------------------
void *__fastcall sub_427FC(double a1, json_error_t *a2)
{
  int v3; // r3
  _DWORD *v6; // [sp+Ch] [bp+Ch]
  size_t n; // [sp+14h] [bp+14h]
  void *s; // [sp+18h] [bp+18h]
  void *v9; // [sp+1Ch] [bp+1Ch]

  v6 = (_DWORD *)LODWORD(a1);
  if ( ++*(_DWORD *)(LODWORD(a1) + 56) > 0x800u )
  {
    sub_4188C((int)a2, (_DWORD *)LODWORD(a1), 2, "maximum parsing depth reached");
    return 0;
  }
  v3 = *(_DWORD *)(LODWORD(a1) + 60);
  if ( v3 == 257 )
  {
    v9 = json_integer(*(_QWORD *)(LODWORD(a1) + 64));
  }
  else if ( v3 >= 258 )
  {
    if ( v3 == 259 )
    {
      v9 = json_true();
    }
    else if ( v3 <= 258 )
    {
      v9 = json_real(a1);
    }
    else if ( v3 == 260 )
    {
      v9 = json_false();
    }
    else
    {
      if ( v3 != 261 )
        goto LABEL_29;
      v9 = json_null();
    }
  }
  else if ( v3 == 91 )
  {
    v9 = sub_42750(SLODWORD(a1), SHIDWORD(a1), a2);
  }
  else
  {
    if ( v3 <= 91 )
    {
      if ( v3 == -1 )
      {
        sub_4188C((int)a2, (_DWORD *)LODWORD(a1), 8, "invalid token");
        return 0;
      }
LABEL_29:
      sub_4188C((int)a2, (_DWORD *)LODWORD(a1), 8, "unexpected token");
      return 0;
    }
    if ( v3 == 123 )
    {
      v9 = sub_425D4(SLODWORD(a1), SHIDWORD(a1), a2);
    }
    else
    {
      if ( v3 != 256 )
        goto LABEL_29;
      s = *(void **)(LODWORD(a1) + 64);
      n = *(_DWORD *)(LODWORD(a1) + 68);
      if ( (BYTE4(a1) & 0x10) == 0 && memchr(s, 0, n) )
      {
        sub_4188C((int)a2, v6, 11, "\\u0000 is not allowed without JSON_ALLOW_NUL");
        return 0;
      }
      v9 = jsonp_stringn_nocheck_own((const char *)s, n);
      v6[16] = 0;
      v6[17] = 0;
    }
  }
  if ( !v9 )
    return 0;
  --v6[14];
  return v9;
}

//----- (00042974) --------------------------------------------------------
void *__fastcall sub_42974(unsigned int a1, unsigned int a2, int a3)
{
  void *v8; // [sp+14h] [bp+14h]

  *(_DWORD *)(a1 + 56) = 0;
  lex_scan((lex_t *)a1, (json_error_t *)a3);
  if ( (a2 & 4) != 0 || *(_DWORD *)(a1 + 60) == 91 || *(_DWORD *)(a1 + 60) == 123 )
  {
    v8 = sub_427FC(COERCE_DOUBLE(__PAIR64__(a2, a1)), (json_error_t *)a3);
    if ( v8 )
    {
      if ( (a2 & 2) != 0 || (lex_scan((lex_t *)a1, (json_error_t *)a3), !*(_DWORD *)(a1 + 60)) )
      {
        if ( a3 )
          *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 36);
        return v8;
      }
      else
      {
        sub_4188C(a3, (_DWORD *)a1, 7, "end of file expected");
        sub_41848((int)v8);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_4188C(a3, (_DWORD *)a1, 8, "'[' or '{' expected");
    return 0;
  }
}

//----- (00042A64) --------------------------------------------------------
void *__fastcall json_loads(int a1, unsigned int a2, json_error_t *a3)
{
  _DWORD v8[2]; // [sp+10h] [bp+10h] BYREF
  _BYTE v9[76]; // [sp+18h] [bp+18h] BYREF
  void *v10; // [sp+64h] [bp+64h]

  jsonp_error_init(a3, "<string>");
  if ( a1 )
  {
    v8[0] = a1;
    v8[1] = 0;
    if ( lex_init((int)v9, 272933, a2, (int)v8) )
    {
      return 0;
    }
    else
    {
      v10 = sub_42974((unsigned int)v9, a2, (int)a3);
      lex_close((lex_t *)v9);
      return v10;
    }
  }
  else
  {
    sub_4188C((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (00042B2C) --------------------------------------------------------
void *__fastcall json_loadb(int a1, int a2, unsigned int a3, json_error_t *a4)
{
  _DWORD v10[3]; // [sp+14h] [bp+14h] BYREF
  _BYTE v11[76]; // [sp+20h] [bp+20h] BYREF
  void *v12; // [sp+6Ch] [bp+6Ch]

  jsonp_error_init(a4, "<buffer>");
  if ( a1 )
  {
    v10[0] = a1;
    v10[2] = 0;
    v10[1] = a2;
    if ( lex_init((int)v11, 273129, a3, (int)v10) )
    {
      return 0;
    }
    else
    {
      v12 = sub_42974((unsigned int)v11, a3, (int)a4);
      lex_close((lex_t *)v11);
      return v12;
    }
  }
  else
  {
    sub_4188C((int)a4, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (00042BB4) --------------------------------------------------------
void *__fastcall json_loadf(int a1, unsigned int a2, json_error_t *a3)
{
  _BYTE v8[72]; // [sp+10h] [bp+10h] BYREF
  void *v9; // [sp+58h] [bp+58h]
  const char *v10; // [sp+5Ch] [bp+5Ch]

  if ( a1 == stdin )
    v10 = "<stdin>";
  else
    v10 = "<stream>";
  jsonp_error_init(a3, v10);
  if ( a1 )
  {
    if ( lex_init((int)v8, (int)fgetc, a2, a1) )
    {
      return 0;
    }
    else
    {
      v9 = sub_42974((unsigned int)v8, a2, (int)a3);
      lex_close((lex_t *)v8);
      return v9;
    }
  }
  else
  {
    sub_4188C((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}
// 1F0C78: using guessed type int stdin;

//----- (00042C4C) --------------------------------------------------------
int __fastcall sub_42C4C(int *a1)
{
  unsigned __int8 buf; // [sp+Fh] [bp+Fh] BYREF

  if ( read(*a1, &buf, 1u) == 1 )
    return buf;
  else
    return -1;
}

//----- (00042C7C) --------------------------------------------------------
void *__fastcall json_loadfd(int a1, unsigned int a2, json_error_t *a3)
{
  int v7; // [sp+Ch] [bp+Ch] BYREF
  _BYTE v8[72]; // [sp+10h] [bp+10h] BYREF
  void *v9; // [sp+58h] [bp+58h]
  const char *v10; // [sp+5Ch] [bp+5Ch]

  v7 = a1;
  if ( a1 )
    v10 = "<stream>";
  else
    v10 = "<stdin>";
  jsonp_error_init(a3, v10);
  if ( v7 >= 0 )
  {
    if ( lex_init((int)v8, 273485, a2, (int)&v7) )
    {
      return 0;
    }
    else
    {
      v9 = sub_42974((unsigned int)v8, a2, (int)a3);
      lex_close((lex_t *)v8);
      return v9;
    }
  }
  else
  {
    sub_4188C((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (00042D0C) --------------------------------------------------------
void *__fastcall json_load_file(const char *a1, unsigned int a2, json_error_t *a3)
{
  int *v4; // r0
  char *v5; // r0
  void *v10; // [sp+18h] [bp+10h]
  FILE *stream; // [sp+1Ch] [bp+14h]

  jsonp_error_init(a3, a1);
  if ( a1 )
  {
    stream = fopen(a1, "rb");
    if ( stream )
    {
      v10 = json_loadf((int)stream, a2, a3);
      fclose(stream);
      return v10;
    }
    else
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      sub_4188C((int)a3, 0, 3, "unable to open %s: %s", a1, v5);
      return 0;
    }
  }
  else
  {
    sub_4188C((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (00042D9C) --------------------------------------------------------
int __fastcall sub_42D9C(int a1)
{
  if ( *(_DWORD *)(a1 + 1028) >= *(_DWORD *)(a1 + 1024) )
  {
    *(_DWORD *)(a1 + 1028) = 0;
    *(_DWORD *)(a1 + 1024) = (*(int (__fastcall **)(int, int, _DWORD))(a1 + 1032))(a1, 1024, *(_DWORD *)(a1 + 1036));
    if ( !*(_DWORD *)(a1 + 1024) || *(_DWORD *)(a1 + 1024) == -1 )
      return -1;
  }
  return *(unsigned __int8 *)(a1 + (*(_DWORD *)(a1 + 1028))++);
}

//----- (00042E1C) --------------------------------------------------------
void *__fastcall json_load_callback(int a1, int a2, unsigned int a3, json_error_t *a4)
{
  _DWORD s[260]; // [sp+10h] [bp+10h] BYREF
  _BYTE v11[76]; // [sp+420h] [bp+420h] BYREF
  void *v12; // [sp+46Ch] [bp+46Ch]

  memset(s, 0, sizeof(s));
  s[258] = a1;
  s[259] = a2;
  jsonp_error_init(a4, "<callback>");
  if ( a1 )
  {
    if ( lex_init((int)v11, 273821, a3, (int)s) )
    {
      return 0;
    }
    else
    {
      v12 = sub_42974((unsigned int)v11, a3, (int)a4);
      lex_close((lex_t *)v11);
      return v12;
    }
  }
  else
  {
    sub_4188C((int)a4, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (00042EE4) --------------------------------------------------------
int __fastcall sub_42EE4(int result)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2

  if ( result && *(_DWORD *)(result + 4) != -1 )
  {
    v1 = (unsigned int *)(result + 4);
    do
      v2 = __ldrex(v1);
    while ( __strex(v2 + 1, v1) );
    __dmb(0xBu);
  }
  return result;
}

//----- (00042F24) --------------------------------------------------------
void __fastcall sub_42F24(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (00042F68) --------------------------------------------------------
int __fastcall sub_42F68(json_t *a1, const char *a2, int a3)
{
  json_t *v3; // r0

  v3 = (json_t *)sub_42EE4(a3);
  return json_object_set_new_nocheck(a1, a2, v3);
}

//----- (00042F90) --------------------------------------------------------
int __fastcall sub_42F90(json_t *a1, int a2)
{
  json_t *v2; // r0

  v2 = (json_t *)sub_42EE4(a2);
  return json_array_append_new(a1, v2);
}

//----- (00042FB4) --------------------------------------------------------
_DWORD *__fastcall json_init(_DWORD *result, int a2)
{
  *result = a2;
  result[1] = 1;
  return result;
}
// 42FB4: invalid function type 'void __cdecl json_init(json_t *json, json_type type)' has been ignored

//----- (00042FD8) --------------------------------------------------------
_DWORD *json_object()
{
  _DWORD *v2; // [sp+4h] [bp+4h]

  v2 = jsonp_malloc(0x24u);
  if ( !v2 )
    return 0;
  if ( !hashtable_seed )
    json_object_seed(0);
  json_init(v2, 0);
  if ( !hashtable_init((int)(v2 + 2)) )
    return v2;
  jsonp_free(v2);
  return 0;
}
// 479DDC: using guessed type int hashtable_seed;

//----- (00043034) --------------------------------------------------------
void __cdecl json_delete_object(json_object_t *object)
{
  hashtable_close((json_object_t *)((char *)object + 8));
  jsonp_free(object);
}

//----- (00043054) --------------------------------------------------------
size_t __cdecl json_object_size(const json_t *json)
{
  if ( json && !*(_DWORD *)json )
    return *((_DWORD *)json + 2);
  else
    return 0;
}

//----- (00043084) --------------------------------------------------------
json_t *__cdecl json_object_get(const json_t *json, const char *key)
{
  if ( key && json && !*(_DWORD *)json )
    return (json_t *)hashtable_get((const json_t *)((char *)json + 8), key);
  else
    return 0;
}

//----- (000430C0) --------------------------------------------------------
int __cdecl json_object_set_new_nocheck(json_t *json, const char *key, json_t *value)
{
  if ( !value )
    return -1;
  if ( key && json && !*(_DWORD *)json && json != value && !hashtable_set((int)json + 8, (char *)key, (int)value) )
    return 0;
  sub_42F24((int)value);
  return -1;
}

//----- (00043130) --------------------------------------------------------
int __fastcall json_object_set_new(json_t *a1, const char *a2, json_t *a3)
{
  size_t v3; // r0

  if ( a2 )
  {
    v3 = strlen(a2);
    if ( utf8_check_string((int)a2, v3) )
      return json_object_set_new_nocheck(a1, a2, a3);
  }
  sub_42F24((int)a3);
  return -1;
}

//----- (00043178) --------------------------------------------------------
int __fastcall json_object_del(_DWORD *a1, char *a2)
{
  if ( a2 && a1 && !*a1 )
    return hashtable_del((int)(a1 + 2), a2);
  else
    return -1;
}

//----- (000431B8) --------------------------------------------------------
int __fastcall json_object_clear(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return -1;
  hashtable_clear((int)(a1 + 2));
  return 0;
}

//----- (000431EC) --------------------------------------------------------
int __fastcall json_object_update(json_t *a1, json_t *a2)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  int v10; // [sp+8h] [bp+8h]
  const char *i; // [sp+Ch] [bp+Ch]

  if ( !a1 || *(_DWORD *)a1 || !a2 || *(_DWORD *)a2 )
    return -1;
  v3 = json_object_iter(a2);
  for ( i = json_object_iter_key(v3); i; i = json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(i);
    v10 = json_object_iter_value((int)v6);
    if ( !v10 )
      break;
    if ( sub_42F68(a1, i, v10) )
      return -1;
    v4 = json_object_key_to_iter(i);
    v5 = json_object_iter_next(a2, v4);
  }
  return 0;
}

//----- (00043280) --------------------------------------------------------
int __fastcall json_object_update_existing(json_t *a1, json_t *a2)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  int v10; // [sp+8h] [bp+8h]
  const char *i; // [sp+Ch] [bp+Ch]

  if ( !a1 || *(_DWORD *)a1 || !a2 || *(_DWORD *)a2 )
    return -1;
  v3 = json_object_iter(a2);
  for ( i = json_object_iter_key(v3); i; i = json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(i);
    v10 = json_object_iter_value((int)v6);
    if ( !v10 )
      break;
    if ( json_object_get(a1, i) )
      sub_42F68(a1, i, v10);
    v4 = json_object_key_to_iter(i);
    v5 = json_object_iter_next(a2, v4);
  }
  return 0;
}

//----- (00043318) --------------------------------------------------------
int __fastcall json_object_update_missing(json_t *a1, json_t *a2)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  int v10; // [sp+8h] [bp+8h]
  const char *i; // [sp+Ch] [bp+Ch]

  if ( !a1 || *(_DWORD *)a1 || !a2 || *(_DWORD *)a2 )
    return -1;
  v3 = json_object_iter(a2);
  for ( i = json_object_iter_key(v3); i; i = json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter(i);
    v10 = json_object_iter_value((int)v6);
    if ( !v10 )
      break;
    if ( !json_object_get(a1, i) )
      sub_42F68(a1, i, v10);
    v4 = json_object_key_to_iter(i);
    v5 = json_object_iter_next(a2, v4);
  }
  return 0;
}

//----- (000433B0) --------------------------------------------------------
void *__cdecl json_object_iter(json_t *json)
{
  if ( json && !*(_DWORD *)json )
    return hashtable_iter((int)json + 8);
  else
    return 0;
}

//----- (000433E4) --------------------------------------------------------
int __fastcall json_object_iter_at(_DWORD *a1, char *a2)
{
  if ( a2 && a1 && !*a1 )
    return hashtable_iter_at((int)(a1 + 2), a2);
  else
    return 0;
}

//----- (00043420) --------------------------------------------------------
void *__cdecl json_object_iter_next(json_t *json, void *iter)
{
  if ( json && !*(_DWORD *)json && iter )
    return hashtable_iter_next((json_t *)((char *)json + 8), iter);
  else
    return 0;
}

//----- (0004345C) --------------------------------------------------------
const char *__cdecl json_object_iter_key(void *iter)
{
  if ( iter )
    return (const char *)hashtable_iter_key((int)iter);
  else
    return 0;
}

//----- (00043480) --------------------------------------------------------
int __fastcall json_object_iter_value(int a1)
{
  if ( a1 )
    return hashtable_iter_value(a1);
  else
    return 0;
}

//----- (000434A4) --------------------------------------------------------
int __fastcall json_object_iter_set_new(_DWORD *a1, int a2, int a3)
{
  if ( a1 && !*a1 && a2 && a3 )
  {
    hashtable_iter_set(a2, a3);
    return 0;
  }
  else
  {
    sub_42F24(a3);
    return -1;
  }
}

//----- (000434E8) --------------------------------------------------------
void *__cdecl json_object_key_to_iter(const char *key)
{
  if ( key )
    return (void *)(key - 16);
  else
    return 0;
}

//----- (0004350C) --------------------------------------------------------
int __fastcall sub_4350C(const json_t *a1, const json_t *a2)
{
  size_t v2; // r4
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0
  json_t *v11; // [sp+Ch] [bp+Ch]
  const json_t *v12; // [sp+10h] [bp+10h]
  const char *i; // [sp+14h] [bp+14h]

  v2 = json_object_size(a1);
  if ( v2 != json_object_size(a2) )
    return 0;
  v4 = json_object_iter(a1);
  for ( i = json_object_iter_key(v4); i; i = json_object_iter_key(v6) )
  {
    v7 = json_object_key_to_iter(i);
    v12 = (const json_t *)json_object_iter_value((int)v7);
    if ( !v12 )
      break;
    v11 = json_object_get(a2, i);
    if ( !json_equal(v12, v11) )
      return 0;
    v5 = json_object_key_to_iter(i);
    v6 = json_object_iter_next(a1, v5);
  }
  return 1;
}

//----- (0004359C) --------------------------------------------------------
json_t *__fastcall sub_4359C(json_t *a1)
{
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  int v8; // [sp+Ch] [bp+Ch]
  json_t *v9; // [sp+10h] [bp+10h]
  const char *i; // [sp+14h] [bp+14h]

  v9 = (json_t *)json_object();
  if ( !v9 )
    return 0;
  v2 = json_object_iter(a1);
  for ( i = json_object_iter_key(v2); i; i = json_object_iter_key(v4) )
  {
    v5 = json_object_key_to_iter(i);
    v8 = json_object_iter_value((int)v5);
    if ( !v8 )
      break;
    sub_42F68(v9, i, v8);
    v3 = json_object_key_to_iter(i);
    v4 = json_object_iter_next(a1, v3);
  }
  return v9;
}

//----- (00043610) --------------------------------------------------------
json_t *__fastcall sub_43610(json_t *a1)
{
  json_t *v2; // r0
  const json_t *v5; // [sp+8h] [bp+8h]
  const char *v6; // [sp+Ch] [bp+Ch]
  json_t *v7; // [sp+10h] [bp+10h]
  void *i; // [sp+14h] [bp+14h]

  v7 = (json_t *)json_object();
  if ( !v7 )
    return 0;
  for ( i = json_object_iter(a1); i; i = json_object_iter_next(a1, i) )
  {
    v6 = json_object_iter_key(i);
    v5 = (const json_t *)json_object_iter_value((int)i);
    v2 = (json_t *)json_deep_copy(v5);
    json_object_set_new_nocheck(v7, v6, v2);
  }
  return v7;
}

//----- (00043670) --------------------------------------------------------
_DWORD *json_array()
{
  _DWORD *v2; // [sp+4h] [bp+4h]

  v2 = jsonp_malloc(0x14u);
  if ( !v2 )
    return 0;
  json_init(v2, 1);
  v2[3] = 0;
  v2[2] = 8;
  v2[4] = jsonp_malloc(4 * v2[2]);
  if ( v2[4] )
    return v2;
  jsonp_free(v2);
  return 0;
}

//----- (000436CC) --------------------------------------------------------
void __fastcall sub_436CC(int a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; *(_DWORD *)(a1 + 12) > i; ++i )
    sub_42F24(*(_DWORD *)(4 * i + *(_DWORD *)(a1 + 16)));
  jsonp_free(*(void **)(a1 + 16));
  jsonp_free((void *)a1);
}

//----- (00043714) --------------------------------------------------------
size_t __cdecl json_array_size(const json_t *json)
{
  if ( json && *(_DWORD *)json == 1 )
    return *((_DWORD *)json + 3);
  else
    return 0;
}

//----- (00043740) --------------------------------------------------------
int __fastcall json_array_get(_DWORD *a1, unsigned int a2)
{
  if ( !a1 || *a1 != 1 )
    return 0;
  if ( a1[3] > a2 )
    return *(_DWORD *)(4 * a2 + a1[4]);
  return 0;
}

//----- (00043788) --------------------------------------------------------
int __fastcall json_array_set_new(_DWORD *a1, unsigned int a2, int a3)
{
  if ( !a3 )
    return -1;
  if ( a1 && *a1 == 1 && a1 != (_DWORD *)a3 && a1[3] > a2 )
  {
    sub_42F24(*(_DWORD *)(4 * a2 + a1[4]));
    *(_DWORD *)(4 * a2 + a1[4]) = a3;
    return 0;
  }
  else
  {
    sub_42F24(a3);
    return -1;
  }
}

//----- (00043808) --------------------------------------------------------
void *__fastcall sub_43808(int a1, int a2, int a3, int a4)
{
  return memmove((void *)(*(_DWORD *)(a1 + 16) + 4 * a2), (const void *)(*(_DWORD *)(a1 + 16) + 4 * a3), 4 * a4);
}

//----- (0004383C) --------------------------------------------------------
void __cdecl array_copy(json_t **dest, size_t dpos, json_t **src, size_t spos, size_t count)
{
  memcpy(&dest[dpos], &src[spos], 4 * count);
}

//----- (0004386C) --------------------------------------------------------
json_t **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy)
{
  size_t v4; // r3
  void *v8; // [sp+1Ch] [bp+14h]
  size_t v9; // [sp+20h] [bp+18h]
  json_t **v10; // [sp+24h] [bp+1Ch]

  if ( *((_DWORD *)array + 3) + amount <= *((_DWORD *)array + 2) )
    return (json_t **)*((_DWORD *)array + 4);
  v10 = (json_t **)*((_DWORD *)array + 4);
  v4 = amount + *((_DWORD *)array + 2);
  if ( v4 < 2 * *((_DWORD *)array + 2) )
    v4 = 2 * *((_DWORD *)array + 2);
  v9 = v4;
  v8 = jsonp_malloc(4 * v4);
  if ( !v8 )
    return 0;
  *((_DWORD *)array + 2) = v9;
  *((_DWORD *)array + 4) = v8;
  if ( !copy )
    return v10;
  array_copy(*((json_t ***)array + 4), 0, v10, 0, *((_DWORD *)array + 3));
  jsonp_free(v10);
  return (json_t **)*((_DWORD *)array + 4);
}

//----- (000438FC) --------------------------------------------------------
int __cdecl json_array_append_new(json_t *json, json_t *value)
{
  if ( !value )
    return -1;
  if ( json && *(_DWORD *)json == 1 && json != value && json_array_grow(json, 1u, 1) )
  {
    *(_DWORD *)(4 * (*((_DWORD *)json + 3))++ + *((_DWORD *)json + 4)) = value;
    return 0;
  }
  else
  {
    sub_42F24((int)value);
    return -1;
  }
}

//----- (00043978) --------------------------------------------------------
int __fastcall json_array_insert_new(int a1, size_t a2, int a3)
{
  json_t **v8; // [sp+18h] [bp+10h]

  if ( !a3 )
    return -1;
  if ( a1 && *(_DWORD *)a1 == 1 && a1 != a3 && *(_DWORD *)(a1 + 12) >= a2 )
  {
    v8 = json_array_grow((json_array_t *)a1, 1u, 0);
    if ( v8 )
    {
      if ( *(json_t ***)(a1 + 16) == v8 )
      {
        sub_43808(a1, a2 + 1, a2, *(_DWORD *)(a1 + 12) - a2);
      }
      else
      {
        array_copy(*(json_t ***)(a1 + 16), 0, v8, 0, a2);
        array_copy(*(json_t ***)(a1 + 16), a2 + 1, v8, a2, *(_DWORD *)(a1 + 12) - a2);
        jsonp_free(v8);
      }
      *(_DWORD *)(4 * a2 + *(_DWORD *)(a1 + 16)) = a3;
      ++*(_DWORD *)(a1 + 12);
      return 0;
    }
    else
    {
      sub_42F24(a3);
      return -1;
    }
  }
  else
  {
    sub_42F24(a3);
    return -1;
  }
}

//----- (00043A60) --------------------------------------------------------
int __fastcall json_array_remove(_DWORD *a1, unsigned int a2)
{
  if ( !a1 || *a1 != 1 )
    return -1;
  if ( a1[3] <= a2 )
    return -1;
  sub_42F24(*(_DWORD *)(4 * a2 + a1[4]));
  if ( a1[3] - 1 > a2 )
    sub_43808((int)a1, a2, a2 + 1, a1[3] - a2 - 1);
  --a1[3];
  return 0;
}

//----- (00043ADC) --------------------------------------------------------
int __fastcall json_array_clear(_DWORD *a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  if ( !a1 || *a1 != 1 )
    return -1;
  for ( i = 0; a1[3] > i; ++i )
    sub_42F24(*(_DWORD *)(4 * i + a1[4]));
  a1[3] = 0;
  return 0;
}

//----- (00043B34) --------------------------------------------------------
int __fastcall json_array_extend(int a1, int a2)
{
  unsigned int i; // [sp+1Ch] [bp+14h]

  if ( !a1 || *(_DWORD *)a1 != 1 || !a2 || *(_DWORD *)a2 != 1 )
    return -1;
  if ( !json_array_grow((json_array_t *)a1, *(_DWORD *)(a2 + 12), 1) )
    return -1;
  for ( i = 0; *(_DWORD *)(a2 + 12) > i; ++i )
    sub_42EE4(*(_DWORD *)(4 * i + *(_DWORD *)(a2 + 16)));
  array_copy(*(json_t ***)(a1 + 16), *(_DWORD *)(a1 + 12), *(json_t ***)(a2 + 16), 0, *(_DWORD *)(a2 + 12));
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a2 + 12);
  return 0;
}

//----- (00043BDC) --------------------------------------------------------
int __fastcall sub_43BDC(const json_t *a1, const json_t *a2)
{
  int v6; // [sp+8h] [bp+8h]
  int v7; // [sp+Ch] [bp+Ch]
  size_t v8; // [sp+10h] [bp+10h]
  unsigned int i; // [sp+14h] [bp+14h]

  v8 = json_array_size(a1);
  if ( json_array_size(a2) != v8 )
    return 0;
  for ( i = 0; i < v8; ++i )
  {
    v7 = json_array_get(a1, i);
    v6 = json_array_get(a2, i);
    if ( !json_equal(v7, v6) )
      return 0;
  }
  return 1;
}
// 4444C: using guessed type int __fastcall json_equal(_DWORD, _DWORD);

//----- (00043C44) --------------------------------------------------------
json_t *__fastcall sub_43C44(const json_t *a1)
{
  int v2; // r0
  json_t *v5; // [sp+8h] [bp+8h]
  size_t i; // [sp+Ch] [bp+Ch]

  v5 = (json_t *)json_array();
  if ( !v5 )
    return 0;
  for ( i = 0; json_array_size(a1) > i; ++i )
  {
    v2 = json_array_get(a1, i);
    sub_42F90(v5, v2);
  }
  return v5;
}

//----- (00043C94) --------------------------------------------------------
json_t *__fastcall sub_43C94(const json_t *a1)
{
  int v2; // r0
  json_t *v3; // r0
  json_t *v6; // [sp+8h] [bp+8h]
  size_t i; // [sp+Ch] [bp+Ch]

  v6 = (json_t *)json_array();
  if ( !v6 )
    return 0;
  for ( i = 0; json_array_size(a1) > i; ++i )
  {
    v2 = json_array_get(a1, i);
    v3 = (json_t *)json_deep_copy(v2);
    json_array_append_new(v6, v3);
  }
  return v6;
}
// 4456C: using guessed type int __fastcall json_deep_copy(_DWORD);

//----- (00043CEC) --------------------------------------------------------
_DWORD *__fastcall sub_43CEC(const char *a1, size_t a2, int a3)
{
  _DWORD *v6; // [sp+10h] [bp+10h]
  char *v7; // [sp+14h] [bp+14h]

  if ( !a1 )
    return 0;
  if ( a3 )
  {
    v7 = (char *)a1;
  }
  else
  {
    v7 = jsonp_strndup(a1, a2);
    if ( !v7 )
      return 0;
  }
  v6 = jsonp_malloc(0x10u);
  if ( v6 )
  {
    json_init(v6, 2);
    v6[2] = v7;
    v6[3] = a2;
    return v6;
  }
  else
  {
    jsonp_free(v7);
    return 0;
  }
}

//----- (00043D5C) --------------------------------------------------------
_DWORD *__fastcall json_string_nocheck(const char *a1)
{
  size_t v2; // r0

  if ( !a1 )
    return 0;
  v2 = strlen(a1);
  return sub_43CEC(a1, v2, 0);
}

//----- (00043D8C) --------------------------------------------------------
_DWORD *__fastcall json_stringn_nocheck(const char *a1, size_t a2)
{
  return sub_43CEC(a1, a2, 0);
}

//----- (00043DAC) --------------------------------------------------------
_DWORD *__fastcall jsonp_stringn_nocheck_own(const char *a1, size_t a2)
{
  return sub_43CEC(a1, a2, 1);
}

//----- (00043DCC) --------------------------------------------------------
_DWORD *__fastcall json_string(const char *a1)
{
  size_t v2; // r0

  if ( !a1 )
    return 0;
  v2 = strlen(a1);
  return json_stringn(a1, v2);
}

//----- (00043DF8) --------------------------------------------------------
_DWORD *__fastcall json_stringn(const char *a1, size_t a2)
{
  if ( a1 && utf8_check_string((int)a1, a2) )
    return json_stringn_nocheck(a1, a2);
  else
    return 0;
}

//----- (00043E2C) --------------------------------------------------------
const char *__cdecl json_string_value(const json_t *json)
{
  if ( json && *(_DWORD *)json == 2 )
    return (const char *)*((_DWORD *)json + 2);
  else
    return 0;
}

//----- (00043E58) --------------------------------------------------------
size_t __cdecl json_string_length(const json_t *json)
{
  if ( json && *(_DWORD *)json == 2 )
    return *((_DWORD *)json + 3);
  else
    return 0;
}

//----- (00043E84) --------------------------------------------------------
int __fastcall json_string_set_nocheck(int a1, const char *a2)
{
  size_t v3; // r0

  if ( !a2 )
    return -1;
  v3 = strlen(a2);
  return json_string_setn_nocheck(a1, a2, v3);
}

//----- (00043EB8) --------------------------------------------------------
int __fastcall json_string_setn_nocheck(int a1, const char *a2, size_t a3)
{
  char *v7; // [sp+14h] [bp+14h]

  if ( !a1 || *(_DWORD *)a1 != 2 || !a2 )
    return -1;
  v7 = jsonp_strndup(a2, a3);
  if ( !v7 )
    return -1;
  jsonp_free(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 12) = a3;
  return 0;
}

//----- (00043F18) --------------------------------------------------------
int __fastcall json_string_set(int a1, const char *a2)
{
  size_t v3; // r0

  if ( !a2 )
    return -1;
  v3 = strlen(a2);
  return json_string_setn(a1, a2, v3);
}

//----- (00043F4C) --------------------------------------------------------
int __fastcall json_string_setn(int a1, const char *a2, size_t a3)
{
  if ( a2 && utf8_check_string((int)a2, a3) )
    return json_string_setn_nocheck(a1, a2, a3);
  else
    return -1;
}

//----- (00043F88) --------------------------------------------------------
void __cdecl json_delete_string(json_string_t *string)
{
  jsonp_free(*((void **)string + 2));
  jsonp_free(string);
}

//----- (00043FA8) --------------------------------------------------------
bool __fastcall sub_43FA8(int a1, int a2)
{
  return *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && !memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), *(_DWORD *)(a1 + 12));
}

//----- (00043FEC) --------------------------------------------------------
_DWORD *__fastcall sub_43FEC(int a1)
{
  return json_stringn_nocheck(*(const char **)(a1 + 8), *(_DWORD *)(a1 + 12));
}

//----- (00044014) --------------------------------------------------------
_DWORD *__fastcall json_vsprintf(const char *a1, void *a2)
{
  char *s; // [sp+Ch] [bp+Ch]
  size_t v6; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  v7 = 0;
  v6 = vsnprintf(0, 0, a1, a2);
  if ( !v6 )
    return json_string(byte_1B4D34);
  s = (char *)jsonp_malloc(v6 + 1);
  if ( s )
  {
    vsnprintf(s, v6 + 1, a1, a2);
    if ( utf8_check_string((int)s, v6) )
      return jsonp_stringn_nocheck_own(s, v6);
    else
      jsonp_free(s);
  }
  return (_DWORD *)v7;
}

//----- (000440A0) --------------------------------------------------------
_DWORD *json_sprintf(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+14h] BYREF

  va_start(varg_r1, a1);
  return json_vsprintf(a1, varg_r1);
}

//----- (000440C8) --------------------------------------------------------
_QWORD *__fastcall json_integer(__int64 a1)
{
  _QWORD *v4; // [sp+Ch] [bp+Ch]

  v4 = jsonp_malloc(0x10u);
  if ( !v4 )
    return 0;
  json_init(v4, 3);
  v4[1] = a1;
  return v4;
}
// 440C8: invalid function type 'json_t *__cdecl json_integer(json_int_t value)' has been ignored

//----- (00044104) --------------------------------------------------------
int __fastcall json_integer_value(_DWORD *a1)
{
  if ( a1 && *a1 == 3 )
    return a1[2];
  else
    return 0;
}
// 44104: invalid function type 'json_int_t __cdecl json_integer_value(const json_t *json)' has been ignored

//----- (00044138) --------------------------------------------------------
int __fastcall json_integer_set(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (00044170) --------------------------------------------------------
void __fastcall sub_44170(void *a1)
{
  jsonp_free(a1);
}

//----- (00044188) --------------------------------------------------------
bool __fastcall sub_44188(_DWORD *a1, _DWORD *a2)
{
  int v2; // r5
  int v3; // r1
  int v4; // r6
  int v5; // r0
  int v6; // r1
  bool v7; // zf

  v2 = json_integer_value(a1);
  v4 = v3;
  v5 = json_integer_value(a2);
  v7 = v4 == v6;
  if ( v4 == v6 )
    return v2 == v5;
  return v7;
}
// 4419A: variable 'v3' is possibly undefined
// 441A6: variable 'v6' is possibly undefined

//----- (000441BC) --------------------------------------------------------
_QWORD *__fastcall sub_441BC(_DWORD *a1)
{
  __int64 v1; // r0

  LODWORD(v1) = json_integer_value(a1);
  return json_integer(v1);
}
// 441D2: variable 'v1' is possibly undefined

//----- (000441E0) --------------------------------------------------------
_QWORD *__fastcall json_real(double a1)
{
  __int64 v1; // d0
  double v2; // r0
  _QWORD *v5; // [sp+Ch] [bp+Ch]

  LODWORD(v2) = _isnan(a1);
  if ( LODWORD(v2) || _isinf(v2) )
    return 0;
  v5 = jsonp_malloc(0x10u);
  if ( !v5 )
    return 0;
  json_init(v5, 4);
  v5[1] = v1;
  return v5;
}
// 441FC: variable 'v2' is possibly undefined
// 4422C: variable 'v1' is possibly undefined

//----- (0004423C) --------------------------------------------------------
double __cdecl json_real_value(const json_t *json)
{
  double result; // r0

  LODWORD(result) = json;
  return result;
}
// 4423C: variable 'result' is possibly undefined

//----- (00044274) --------------------------------------------------------
int __fastcall json_real_set(double a1)
{
  __int64 v1; // d0
  double v2; // r0
  int v5; // [sp+Ch] [bp+Ch]

  v5 = LODWORD(a1);
  if ( !LODWORD(a1) )
    return -1;
  if ( *(_DWORD *)LODWORD(a1) != 4 )
    return -1;
  LODWORD(v2) = _isnan(a1);
  if ( LODWORD(v2) || _isinf(v2) )
    return -1;
  *(_QWORD *)(v5 + 8) = v1;
  return 0;
}
// 442A0: variable 'v2' is possibly undefined
// 442B6: variable 'v1' is possibly undefined

//----- (000442C4) --------------------------------------------------------
void __fastcall sub_442C4(void *a1)
{
  jsonp_free(a1);
}

//----- (000442DC) --------------------------------------------------------
int __fastcall sub_442DC(const json_t *a1, const json_t *a2)
{
  json_real_value(a1);
  json_real_value(a2);
  return 1;
}

//----- (0004431C) --------------------------------------------------------
_QWORD *__fastcall sub_4431C(const json_t *a1)
{
  double v1; // r0

  v1 = json_real_value(a1);
  return json_real(v1);
}

//----- (00044340) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl json_number_value(const json_t *json)
{
  __int64 v1; // r0
  double result; // r0

  if ( json && *(_DWORD *)json == 3 )
  {
    LODWORD(v1) = json_integer_value(json);
    json = (const json_t *)sub_1A3C1C(v1);
  }
  else if ( json && *(_DWORD *)json == 4 )
  {
    *(double *)&json = json_real_value(json);
  }
  LODWORD(result) = json;
  return result;
}
// 44340: variables would overlap: r0.4 and r0.8

//----- (000443A0) --------------------------------------------------------
void *json_true()
{
  return &unk_1ED3CC;
}

//----- (000443B8) --------------------------------------------------------
void *json_false()
{
  return &unk_1ED3D4;
}

//----- (000443D0) --------------------------------------------------------
void *json_null()
{
  return &unk_1ED3DC;
}

//----- (000443E8) --------------------------------------------------------
void __cdecl json_delete(json_t *json)
{
  if ( json )
  {
    switch ( *(_DWORD *)json )
    {
      case 0:
        json_delete_object(json);
        break;
      case 1:
        sub_436CC((int)json);
        break;
      case 2:
        json_delete_string(json);
        break;
      case 3:
        sub_44170(json);
        break;
      case 4:
        sub_442C4(json);
        break;
      default:
        return;
    }
  }
}

//----- (0004444C) --------------------------------------------------------
int __fastcall json_equal(const json_t *a1, const json_t *a2)
{
  int v2; // r3

  if ( !a1 || !a2 )
    return 0;
  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return 0;
  if ( a1 == a2 )
    return 1;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      v2 = sub_4350C(a1, a2);
      break;
    case 1:
      v2 = sub_43BDC(a1, a2);
      break;
    case 2:
      v2 = sub_43FA8((int)a1, (int)a2);
      break;
    case 3:
      v2 = sub_44188(a1, a2);
      break;
    case 4:
      v2 = sub_442DC(a1, a2);
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}
// 4350C: using guessed type int __fastcall sub_4350C(_DWORD, _DWORD);

//----- (000444EC) --------------------------------------------------------
void *__fastcall json_copy(json_t *a1)
{
  void *v1; // r3

  if ( !a1 )
    return 0;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      v1 = sub_4359C(a1);
      break;
    case 1:
      v1 = sub_43C44(a1);
      break;
    case 2:
      v1 = sub_43FEC((int)a1);
      break;
    case 3:
      v1 = sub_441BC(a1);
      break;
    case 4:
      v1 = sub_4431C(a1);
      break;
    case 5:
    case 6:
    case 7:
      v1 = a1;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}

//----- (0004456C) --------------------------------------------------------
void *__fastcall json_deep_copy(const json_t *a1)
{
  void *v1; // r3

  if ( !a1 )
    return 0;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      v1 = (void *)sub_43610(a1);
      break;
    case 1:
      v1 = sub_43C94(a1);
      break;
    case 2:
      v1 = sub_43FEC((int)a1);
      break;
    case 3:
      v1 = sub_441BC(a1);
      break;
    case 4:
      v1 = sub_4431C(a1);
      break;
    case 5:
    case 6:
    case 7:
      v1 = a1;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}
// 43610: using guessed type int __fastcall sub_43610(_DWORD);

//----- (000445EC) --------------------------------------------------------
int __fastcall utf8_encode(int a1, _BYTE *a2, _DWORD *a3)
{
  if ( a1 >= 0 )
  {
    if ( a1 > 127 )
    {
      if ( a1 >= 2048 )
      {
        if ( a1 >= 0x10000 )
        {
          if ( a1 >= 1114112 )
            return -1;
          *a2 = ((a1 & 0x1C0000) >> 18) - 16;
          a2[1] = ((a1 & 0x3F000) >> 12) + 0x80;
          a2[2] = ((a1 & 0xFC0) >> 6) + 0x80;
          a2[3] = (a1 & 0x3F) + 0x80;
          *a3 = 4;
        }
        else
        {
          *a2 = ((a1 & 0xF000) >> 12) - 32;
          a2[1] = ((a1 & 0xFC0) >> 6) + 0x80;
          a2[2] = (a1 & 0x3F) + 0x80;
          *a3 = 3;
        }
      }
      else
      {
        *a2 = ((a1 & 0x7C0) >> 6) - 64;
        a2[1] = (a1 & 0x3F) + 0x80;
        *a3 = 2;
      }
    }
    else
    {
      *a2 = a1;
      *a3 = 1;
    }
    return 0;
  }
  return -1;
}

//----- (0004470C) --------------------------------------------------------
size_t __cdecl utf8_check_first(char byte)
{
  if ( byte >= 0 )
    return 1;
  if ( (unsigned __int8)byte <= 0xBFu )
    return 0;
  if ( (unsigned __int8)byte == 192 || (unsigned __int8)byte == 193 )
    return 0;
  if ( (unsigned __int8)byte > 0xC1u && (unsigned __int8)byte <= 0xDFu )
    return 2;
  if ( (unsigned __int8)byte > 0xDFu && (unsigned __int8)byte <= 0xEFu )
    return 3;
  if ( (unsigned __int8)byte <= 0xEFu || (unsigned __int8)byte > 0xF4u )
    return 0;
  return 4;
}

//----- (00044788) --------------------------------------------------------
size_t __cdecl utf8_check_full(const char *buffer, size_t size, int32_t *codepoint)
{
  _BYTE v5[5]; // [sp+17h] [bp+17h]
  size_t i; // [sp+1Ch] [bp+1Ch]

  *(_DWORD *)v5 = *(unsigned __int8 *)buffer;
  switch ( size )
  {
    case 2u:
      *(_DWORD *)&v5[1] = v5[0] & 0x1F;
      break;
    case 3u:
      *(_DWORD *)&v5[1] = v5[0] & 0xF;
      break;
    case 4u:
      *(_DWORD *)&v5[1] = v5[0] & 7;
      break;
    default:
      return 0;
  }
  for ( i = 1; i < size; ++i )
  {
    v5[0] = buffer[i];
    if ( v5[0] >= 0 || v5[0] > 0xBFu )
      return 0;
    *(_DWORD *)&v5[1] = (v5[0] & 0x3F) + (*(_DWORD *)&v5[1] << 6);
  }
  if ( *(int *)&v5[1] >= 1114112 )
    return 0;
  if ( *(int *)&v5[1] >= 55296 && *(int *)&v5[1] < 57344 )
    return 0;
  if ( size == 2 && *(int *)&v5[1] <= 127 || size == 3 && *(int *)&v5[1] < 2048 || size == 4 && *(int *)&v5[1] < 0x10000 )
    return 0;
  if ( codepoint )
    *codepoint = *(_DWORD *)&v5[1];
  return 1;
}

//----- (00044878) --------------------------------------------------------
const char *__cdecl utf8_iterate(const char *buffer, size_t bufsize, int32_t *codepoint)
{
  int32_t v8; // [sp+10h] [bp+10h] BYREF
  size_t v9; // [sp+14h] [bp+14h]

  if ( !bufsize )
    return buffer;
  v9 = utf8_check_first(*buffer);
  if ( !v9 )
    return 0;
  if ( v9 == 1 )
  {
    v8 = *(unsigned __int8 *)buffer;
  }
  else if ( v9 > bufsize || !utf8_check_full(buffer, v9, &v8) )
  {
    return 0;
  }
  if ( codepoint )
    *codepoint = v8;
  return &buffer[v9];
}

//----- (000448EC) --------------------------------------------------------
int __fastcall utf8_check_string(int a1, unsigned int a2)
{
  unsigned int v6; // [sp+8h] [bp+8h]
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i < a2; ++i )
  {
    v6 = utf8_check_first(*(_BYTE *)(i + a1));
    if ( !v6 )
      return 0;
    if ( v6 > 1 )
    {
      if ( a2 - i < v6 )
        return 0;
      if ( !utf8_check_full((const char *)(i + a1), v6, 0) )
        return 0;
      i = i + v6 - 1;
    }
  }
  return 1;
}

//----- (00044968) --------------------------------------------------------
void *__cdecl jsonp_malloc(size_t size)
{
  if ( size )
    return off_1ED3E4(size);
  else
    return 0;
}
// 1ED3E4: using guessed type void *(*off_1ED3E4)(size_t size);

//----- (00044994) --------------------------------------------------------
void __cdecl jsonp_free(void *ptr)
{
  if ( ptr )
    off_1ED3E8(ptr);
}
// 1ED3E8: using guessed type void (*off_1ED3E8)(void *ptr);

//----- (000449BC) --------------------------------------------------------
char *__cdecl jsonp_strdup(const char *str)
{
  size_t v1; // r0

  v1 = strlen(str);
  return jsonp_strndup(str, v1);
}

//----- (000449E0) --------------------------------------------------------
char *__cdecl jsonp_strndup(const char *str, size_t len)
{
  void *dest; // [sp+Ch] [bp+Ch]

  dest = jsonp_malloc(len + 1);
  if ( !dest )
    return 0;
  memcpy(dest, str, len);
  *((_BYTE *)dest + len) = 0;
  return (char *)dest;
}

//----- (00044A20) --------------------------------------------------------
void *(*__fastcall json_set_alloc_funcs(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size)
{
  off_1ED3E4 = result;
  off_1ED3E8 = a2;
  return result;
}
// 1ED3E4: using guessed type void *(*off_1ED3E4)(size_t size);
// 1ED3E8: using guessed type void (*off_1ED3E8)(void *ptr);

//----- (00044A50) --------------------------------------------------------
_DWORD *__fastcall json_get_alloc_funcs(_DWORD *result, _DWORD *a2)
{
  if ( result )
    *result = off_1ED3E4;
  if ( a2 )
    *a2 = off_1ED3E8;
  return result;
}
// 1ED3E4: using guessed type void *(*off_1ED3E4)(size_t size);
// 1ED3E8: using guessed type void (*off_1ED3E8)(void *ptr);

//----- (00044A90) --------------------------------------------------------
void __fastcall sub_44A90(int a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && *(_DWORD *)(a1 + 4) != -1 )
  {
    v1 = (unsigned int *)(a1 + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      json_delete((json_t *)a1);
  }
}

//----- (00044AD4) --------------------------------------------------------
int __fastcall sub_44AD4(unsigned __int8 *a1, unsigned int a2, int a3)
{
  int v3; // r3
  unsigned int v5; // [sp+8h] [bp+8h]
  unsigned __int8 *v6; // [sp+18h] [bp+18h]
  unsigned __int16 *v7; // [sp+1Ch] [bp+1Ch]
  _DWORD *v8; // [sp+20h] [bp+20h]
  int v9; // [sp+24h] [bp+24h]
  int v10; // [sp+24h] [bp+24h]
  int v11; // [sp+24h] [bp+24h]
  int v12; // [sp+24h] [bp+24h]
  int v13; // [sp+24h] [bp+24h]
  int v14; // [sp+24h] [bp+24h]
  int v15; // [sp+24h] [bp+24h]
  int v16; // [sp+24h] [bp+24h]
  int v17; // [sp+24h] [bp+24h]
  int v18; // [sp+24h] [bp+24h]
  int v19; // [sp+24h] [bp+24h]
  int v20; // [sp+24h] [bp+24h]
  int v21; // [sp+24h] [bp+24h]
  int v22; // [sp+24h] [bp+24h]
  int v23; // [sp+24h] [bp+24h]
  int v24; // [sp+28h] [bp+28h]
  int v25; // [sp+28h] [bp+28h]
  int v26; // [sp+28h] [bp+28h]
  int v27; // [sp+28h] [bp+28h]
  int v28; // [sp+28h] [bp+28h]
  int v29; // [sp+28h] [bp+28h]
  int v30; // [sp+28h] [bp+28h]
  int v31; // [sp+28h] [bp+28h]
  int v32; // [sp+28h] [bp+28h]
  int v33; // [sp+28h] [bp+28h]
  int v34; // [sp+28h] [bp+28h]
  int v35; // [sp+28h] [bp+28h]
  int v36; // [sp+28h] [bp+28h]
  int v37; // [sp+28h] [bp+28h]
  int v38; // [sp+28h] [bp+28h]
  int v39; // [sp+2Ch] [bp+2Ch]
  int v40; // [sp+2Ch] [bp+2Ch]
  int v41; // [sp+2Ch] [bp+2Ch]
  int v42; // [sp+2Ch] [bp+2Ch]
  int v43; // [sp+2Ch] [bp+2Ch]
  int v44; // [sp+2Ch] [bp+2Ch]
  int v45; // [sp+2Ch] [bp+2Ch]
  int v46; // [sp+2Ch] [bp+2Ch]
  int v47; // [sp+2Ch] [bp+2Ch]
  int v48; // [sp+2Ch] [bp+2Ch]
  int v49; // [sp+2Ch] [bp+2Ch]
  int v50; // [sp+2Ch] [bp+2Ch]
  int v51; // [sp+2Ch] [bp+2Ch]

  v5 = a2;
  v9 = a2 + a3 - 559038737;
  v24 = v9;
  v39 = v9;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( ((unsigned __int8)a1 & 1) != 0 )
    {
      v6 = a1;
      while ( v5 > 0xC )
      {
        v33 = (v6[7] << 24) + (v6[6] << 16) + (v6[5] << 8) + v24 + v6[4];
        v18 = (v6[11] << 24) + (v6[10] << 16) + (v6[9] << 8) + v9 + v6[8];
        v47 = __ROR4__(v18, 28) ^ ((v6[3] << 24) + (v6[2] << 16) + (v6[1] << 8) + v39 + *v6 - v18);
        v19 = v33 + v18;
        v34 = __ROR4__(v47, 26) ^ (v33 - v47);
        v48 = v19 + v47;
        v20 = __ROR4__(v34, 24) ^ (v19 - v34);
        v35 = v48 + v34;
        v49 = __ROR4__(v20, 16) ^ (v48 - v20);
        v21 = v35 + v20;
        v36 = __ROR4__(v49, 13) ^ (v35 - v49);
        v39 = v21 + v49;
        v9 = __ROR4__(v36, 28) ^ (v21 - v36);
        v24 = v39 + v36;
        v5 -= 12;
        v6 += 12;
      }
      switch ( v5 )
      {
        case 0u:
          return v9;
        case 1u:
          goto LABEL_52;
        case 2u:
          goto LABEL_51;
        case 3u:
          goto LABEL_50;
        case 4u:
          goto LABEL_49;
        case 5u:
          goto LABEL_48;
        case 6u:
          goto LABEL_47;
        case 7u:
          goto LABEL_46;
        case 8u:
          goto LABEL_45;
        case 9u:
          goto LABEL_44;
        case 0xAu:
          goto LABEL_43;
        case 0xBu:
          goto LABEL_42;
        case 0xCu:
          v9 += v6[11] << 24;
LABEL_42:
          v9 += v6[10] << 16;
LABEL_43:
          v9 += v6[9] << 8;
LABEL_44:
          v9 += v6[8];
LABEL_45:
          v24 += v6[7] << 24;
LABEL_46:
          v24 += v6[6] << 16;
LABEL_47:
          v24 += v6[5] << 8;
LABEL_48:
          v24 += v6[4];
LABEL_49:
          v39 += v6[3] << 24;
LABEL_50:
          v39 += v6[2] << 16;
LABEL_51:
          v39 += v6[1] << 8;
LABEL_52:
          v43 = v39 + *v6;
          break;
      }
    }
    else
    {
      v7 = (unsigned __int16 *)a1;
      while ( v5 > 0xC )
      {
        v29 = (v7[3] << 16) + v7[2] + v24;
        v14 = (v7[5] << 16) + v7[4] + v9;
        v44 = __ROR4__(v14, 28) ^ ((v7[1] << 16) + *v7 + v39 - v14);
        v15 = v29 + v14;
        v30 = __ROR4__(v44, 26) ^ (v29 - v44);
        v45 = v15 + v44;
        v16 = __ROR4__(v30, 24) ^ (v15 - v30);
        v31 = v45 + v30;
        v46 = __ROR4__(v16, 16) ^ (v45 - v16);
        v17 = v31 + v16;
        v32 = __ROR4__(v46, 13) ^ (v31 - v46);
        v39 = v17 + v46;
        v9 = __ROR4__(v32, 28) ^ (v17 - v32);
        v24 = v39 + v32;
        v5 -= 12;
        v7 += 6;
      }
      switch ( v5 )
      {
        case 0u:
          return v9;
        case 1u:
          v43 = v39 + *(unsigned __int8 *)v7;
          break;
        case 2u:
          goto LABEL_34;
        case 3u:
          v39 += *((unsigned __int8 *)v7 + 2) << 16;
LABEL_34:
          v43 = v39 + *v7;
          break;
        case 4u:
          goto LABEL_32;
        case 5u:
          v24 += *((unsigned __int8 *)v7 + 4);
LABEL_32:
          v43 = (v7[1] << 16) + *v7 + v39;
          break;
        case 6u:
          goto LABEL_30;
        case 7u:
          v24 += *((unsigned __int8 *)v7 + 6) << 16;
LABEL_30:
          v24 += v7[2];
          v43 = (v7[1] << 16) + *v7 + v39;
          break;
        case 8u:
          goto LABEL_28;
        case 9u:
          v9 += *((unsigned __int8 *)v7 + 8);
LABEL_28:
          v24 += (v7[3] << 16) + v7[2];
          v43 = (v7[1] << 16) + *v7 + v39;
          break;
        case 0xAu:
          goto LABEL_26;
        case 0xBu:
          v9 += *((unsigned __int8 *)v7 + 10) << 16;
LABEL_26:
          v9 += v7[4];
          v24 += (v7[3] << 16) + v7[2];
          v43 = (v7[1] << 16) + *v7 + v39;
          break;
        case 0xCu:
          v9 += (v7[5] << 16) + v7[4];
          v24 += (v7[3] << 16) + v7[2];
          v43 = (v7[1] << 16) + *v7 + v39;
          break;
      }
    }
LABEL_54:
    v22 = (v24 ^ v9) - __ROR4__(v24, 18);
    v50 = (v22 ^ v43) - __ROR4__(v22, 21);
    v37 = (v50 ^ v24) - __ROR4__(v50, 7);
    v23 = (v37 ^ v22) - __ROR4__(v37, 16);
    v51 = (v23 ^ v50) - __ROR4__(v23, 28);
    v38 = (v51 ^ v37) - __ROR4__(v51, 18);
    return (v38 ^ v23) - __ROR4__(v38, 8);
  }
  else
  {
    v8 = a1;
    while ( v5 > 0xC )
    {
      v25 = v8[1] + v24;
      v10 = v8[2] + v9;
      v40 = __ROR4__(v10, 28) ^ (*v8 + v39 - v10);
      v11 = v25 + v10;
      v26 = __ROR4__(v40, 26) ^ (v25 - v40);
      v41 = v11 + v40;
      v12 = __ROR4__(v26, 24) ^ (v11 - v26);
      v27 = v41 + v26;
      v42 = __ROR4__(v12, 16) ^ (v41 - v12);
      v13 = v27 + v12;
      v28 = __ROR4__(v42, 13) ^ (v27 - v42);
      v39 = v13 + v42;
      v9 = __ROR4__(v28, 28) ^ (v13 - v28);
      v24 = v39 + v28;
      v5 -= 12;
      v8 += 3;
    }
    switch ( v5 )
    {
      case 0u:
        v3 = v9;
        break;
      case 1u:
        v43 = (unsigned __int8)*v8 + v39;
        goto LABEL_54;
      case 2u:
        v43 = (unsigned __int16)*v8 + v39;
        goto LABEL_54;
      case 3u:
        v43 = (*v8 & 0xFFFFFF) + v39;
        goto LABEL_54;
      case 4u:
        v43 = *v8 + v39;
        goto LABEL_54;
      case 5u:
        v24 += (unsigned __int8)v8[1];
        v43 = *v8 + v39;
        goto LABEL_54;
      case 6u:
        v24 += (unsigned __int16)v8[1];
        v43 = *v8 + v39;
        goto LABEL_54;
      case 7u:
        v24 += v8[1] & 0xFFFFFF;
        v43 = *v8 + v39;
        goto LABEL_54;
      case 8u:
        v24 += v8[1];
        v43 = *v8 + v39;
        goto LABEL_54;
      case 9u:
        v9 += (unsigned __int8)v8[2];
        v24 += v8[1];
        v43 = *v8 + v39;
        goto LABEL_54;
      case 0xAu:
        v9 += (unsigned __int16)v8[2];
        v24 += v8[1];
        v43 = *v8 + v39;
        goto LABEL_54;
      case 0xBu:
        v9 += v8[2] & 0xFFFFFF;
        v24 += v8[1];
        v43 = *v8 + v39;
        goto LABEL_54;
      case 0xCu:
        v9 += v8[2];
        v24 += v8[1];
        v43 = *v8 + v39;
        goto LABEL_54;
    }
  }
  return v3;
}
// 44BF6: the default case was optimized away because %var_2C.4<Du
// 44E8E: the default case was optimized away because %var_2C.4<Du
// 45192: the default case was optimized away because %var_2C.4<Du

//----- (00045314) --------------------------------------------------------
void __cdecl list_init(list_t *list)
{
  *((_DWORD *)list + 1) = list;
  *(_DWORD *)list = list;
}

//----- (00045334) --------------------------------------------------------
void __cdecl list_insert(list_t *list, list_t *node)
{
  *((_DWORD *)node + 1) = list;
  *(_DWORD *)node = *(_DWORD *)list;
  *(_DWORD *)(*(_DWORD *)list + 4) = node;
  *(_DWORD *)list = node;
}

//----- (00045368) --------------------------------------------------------
_DWORD *__fastcall sub_45368(_DWORD *result)
{
  *(_DWORD *)(*result + 4) = result[1];
  *(_DWORD *)result[1] = *result;
  return result;
}

//----- (00045390) --------------------------------------------------------
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket)
{
  return *(hashtable_t **)bucket == (hashtable_t *)((char *)hashtable + 12)
      && *(_DWORD *)bucket == *((_DWORD *)bucket + 1);
}

//----- (000453C4) --------------------------------------------------------
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list)
{
  if ( bucket_is_empty(hashtable, bucket) )
  {
    list_insert((hashtable_t *)((char *)hashtable + 12), list);
    *((_DWORD *)bucket + 1) = list;
    *(_DWORD *)bucket = *((_DWORD *)bucket + 1);
  }
  else
  {
    list_insert(*(list_t **)bucket, list);
    *(_DWORD *)bucket = list;
  }
}

//----- (00045414) --------------------------------------------------------
int __fastcall sub_45414(hashtable_t *a1, bucket_t *a2, const char *a3, int a4)
{
  int i; // [sp+14h] [bp+14h]

  if ( bucket_is_empty(a1, a2) )
    return 0;
  for ( i = *(_DWORD *)a2; ; i = *(_DWORD *)(i + 4) )
  {
    if ( *(_DWORD *)(i + 16) == a4 && !strcmp((const char *)(i + 24), a3) )
      return i;
    if ( *((_DWORD *)a2 + 1) == i )
      break;
  }
  return 0;
}

//----- (0004547C) --------------------------------------------------------
int __fastcall sub_4547C(int a1, const char *a2, int a3)
{
  _DWORD *v6; // [sp+14h] [bp+14h]
  int v7; // [sp+18h] [bp+18h]

  v7 = 8 * (a3 & ((1 << *(_DWORD *)(a1 + 8)) - 1)) + *(_DWORD *)(a1 + 4);
  v6 = (_DWORD *)sub_45414((hashtable_t *)a1, (bucket_t *)v7, a2, a3);
  if ( !v6 )
    return -1;
  if ( v6 == *(_DWORD **)v7 && v6 == *(_DWORD **)(v7 + 4) )
  {
    *(_DWORD *)(v7 + 4) = a1 + 12;
    *(_DWORD *)v7 = *(_DWORD *)(v7 + 4);
  }
  else if ( v6 == *(_DWORD **)v7 )
  {
    *(_DWORD *)v7 = v6[1];
  }
  else if ( v6 == *(_DWORD **)(v7 + 4) )
  {
    *(_DWORD *)(v7 + 4) = *v6;
  }
  sub_45368(v6);
  sub_45368(v6 + 2);
  sub_44A90(v6[5]);
  jsonp_free(v6);
  --*(_DWORD *)a1;
  return 0;
}

//----- (00045544) --------------------------------------------------------
void __fastcall sub_45544(int a1)
{
  _DWORD *v2; // [sp+10h] [bp+10h]
  _DWORD *i; // [sp+14h] [bp+14h]

  for ( i = *(_DWORD **)(a1 + 16); (_DWORD *)(a1 + 12) != i; i = v2 )
  {
    v2 = (_DWORD *)i[1];
    sub_44A90(i[5]);
    jsonp_free(i);
  }
}

//----- (00045588) --------------------------------------------------------
int __fastcall sub_45588(int a1)
{
  int v1; // r3
  _DWORD *v3; // r2
  int v4; // r1
  int v7; // [sp+10h] [bp+10h]
  void *v8; // [sp+14h] [bp+14h]
  unsigned int v9; // [sp+18h] [bp+18h]
  int v10; // [sp+1Ch] [bp+1Ch]
  unsigned int i; // [sp+20h] [bp+20h]
  int v12; // [sp+24h] [bp+24h]

  v1 = *(_DWORD *)(a1 + 8);
  v10 = v1 + 1;
  v9 = 1 << (v1 + 1);
  v8 = jsonp_malloc(8 * v9);
  if ( !v8 )
    return -1;
  jsonp_free(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 4) = v8;
  *(_DWORD *)(a1 + 8) = v10;
  for ( i = 0; 1 << *(_DWORD *)(a1 + 8) > i; ++i )
  {
    v3 = (_DWORD *)(*(_DWORD *)(a1 + 4) + 8 * i);
    v3[1] = a1 + 12;
    *v3 = v3[1];
  }
  v12 = *(_DWORD *)(a1 + 16);
  list_init((list_t *)(a1 + 12));
  while ( a1 + 12 != v12 )
  {
    v7 = *(_DWORD *)(v12 + 4);
    sub_1A363C(*(_DWORD *)(v12 + 16), v9);
    insert_to_bucket((hashtable_t *)a1, (bucket_t *)(8 * v4 + *(_DWORD *)(a1 + 4)), (list_t *)v12);
    v12 = v7;
  }
  return 0;
}
// 4563A: variable 'v4' is possibly undefined

//----- (00045664) --------------------------------------------------------
int __fastcall hashtable_init(int a1)
{
  _DWORD *v2; // r2
  unsigned int i; // [sp+Ch] [bp+Ch]

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 3;
  *(_DWORD *)(a1 + 4) = jsonp_malloc(8 << *(_DWORD *)(a1 + 8));
  if ( !*(_DWORD *)(a1 + 4) )
    return -1;
  list_init((list_t *)(a1 + 12));
  list_init((list_t *)(a1 + 20));
  for ( i = 0; 1 << *(_DWORD *)(a1 + 8) > i; ++i )
  {
    v2 = (_DWORD *)(*(_DWORD *)(a1 + 4) + 8 * i);
    v2[1] = a1 + 12;
    *v2 = v2[1];
  }
  return 0;
}

//----- (000456F4) --------------------------------------------------------
void __cdecl hashtable_close(hashtable_t *hashtable)
{
  sub_45544((int)hashtable);
  jsonp_free(*((void **)hashtable + 1));
}

//----- (00045714) --------------------------------------------------------
int __fastcall hashtable_set(int a1, char *a2, int a3)
{
  size_t v4; // r0
  size_t v9; // [sp+14h] [bp+14h]
  int v10; // [sp+18h] [bp+18h]
  char *v11; // [sp+18h] [bp+18h]
  bucket_t *v12; // [sp+1Ch] [bp+1Ch]
  int v13; // [sp+24h] [bp+24h]

  if ( !(*(_DWORD *)a1 >> *(_DWORD *)(a1 + 8)) || !sub_45588(a1) )
  {
    v4 = strlen(a2);
    v13 = sub_44AD4((unsigned __int8 *)a2, v4, hashtable_seed);
    v12 = (bucket_t *)(8 * (v13 & ((1 << *(_DWORD *)(a1 + 8)) - 1)) + *(_DWORD *)(a1 + 4));
    v10 = sub_45414((hashtable_t *)a1, v12, a2, v13);
    if ( v10 )
    {
      sub_44A90(*(_DWORD *)(v10 + 20));
      *(_DWORD *)(v10 + 20) = a3;
    }
    else
    {
      v9 = strlen(a2);
      if ( v9 > 0xFFFFFFE6 )
        return -1;
      v11 = (char *)jsonp_malloc(v9 + 25);
      if ( !v11 )
        return -1;
      *((_DWORD *)v11 + 4) = v13;
      strncpy(v11 + 24, a2, v9 + 1);
      *((_DWORD *)v11 + 5) = a3;
      list_init((list_t *)v11);
      list_init((list_t *)(v11 + 8));
      insert_to_bucket((hashtable_t *)a1, v12, (list_t *)v11);
      list_insert((list_t *)(a1 + 20), (list_t *)(v11 + 8));
      ++*(_DWORD *)a1;
    }
    return 0;
  }
  return -1;
}
// 479DDC: using guessed type int hashtable_seed;

//----- (00045834) --------------------------------------------------------
void *__cdecl hashtable_get(hashtable_t *hashtable, const char *key)
{
  size_t v2; // r0
  int v7; // [sp+Ch] [bp+Ch]
  int v8; // [sp+14h] [bp+14h]

  v2 = strlen(key);
  v8 = sub_44AD4((unsigned __int8 *)key, v2, hashtable_seed);
  v7 = sub_45414(
         hashtable,
         (bucket_t *)(8 * (v8 & ((1 << *((_DWORD *)hashtable + 2)) - 1)) + *((_DWORD *)hashtable + 1)),
         key,
         v8);
  if ( v7 )
    return *(void **)(v7 + 20);
  else
    return 0;
}
// 479DDC: using guessed type int hashtable_seed;

//----- (00045898) --------------------------------------------------------
int __fastcall hashtable_del(int a1, char *a2)
{
  size_t v2; // r0
  int v6; // [sp+Ch] [bp+Ch]

  v2 = strlen(a2);
  v6 = sub_44AD4((unsigned __int8 *)a2, v2, hashtable_seed);
  return sub_4547C(a1, a2, v6);
}
// 479DDC: using guessed type int hashtable_seed;

//----- (000458D4) --------------------------------------------------------
void __fastcall hashtable_clear(int a1)
{
  _DWORD *v1; // r2
  unsigned int i; // [sp+Ch] [bp+Ch]

  sub_45544(a1);
  for ( i = 0; 1 << *(_DWORD *)(a1 + 8) > i; ++i )
  {
    v1 = (_DWORD *)(*(_DWORD *)(a1 + 4) + 8 * i);
    v1[1] = a1 + 12;
    *v1 = v1[1];
  }
  list_init((list_t *)(a1 + 12));
  list_init((list_t *)(a1 + 20));
  *(_DWORD *)a1 = 0;
}

//----- (0004593C) --------------------------------------------------------
void *__fastcall hashtable_iter(int a1)
{
  return hashtable_iter_next((hashtable_t *)a1, (void *)(a1 + 20));
}

//----- (0004595C) --------------------------------------------------------
int __fastcall hashtable_iter_at(int a1, char *a2)
{
  size_t v2; // r0
  int v7; // [sp+Ch] [bp+Ch]
  int v8; // [sp+14h] [bp+14h]

  v2 = strlen(a2);
  v8 = sub_44AD4((unsigned __int8 *)a2, v2, hashtable_seed);
  v7 = sub_45414(
         (hashtable_t *)a1,
         (bucket_t *)(8 * (v8 & ((1 << *(_DWORD *)(a1 + 8)) - 1)) + *(_DWORD *)(a1 + 4)),
         a2,
         v8);
  if ( v7 )
    return v7 + 8;
  else
    return 0;
}
// 479DDC: using guessed type int hashtable_seed;

//----- (000459C0) --------------------------------------------------------
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter)
{
  if ( *((hashtable_t **)iter + 1) == (hashtable_t *)((char *)hashtable + 20) )
    return 0;
  else
    return (void *)*((_DWORD *)iter + 1);
}

//----- (000459F0) --------------------------------------------------------
int __fastcall hashtable_iter_key(int a1)
{
  return a1 + 16;
}

//----- (00045A10) --------------------------------------------------------
int __fastcall hashtable_iter_value(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (00045A30) --------------------------------------------------------
void __fastcall hashtable_iter_set(int a1, int a2)
{
  int v3; // [sp+Ch] [bp+Ch]

  v3 = a1 - 8;
  sub_44A90(*(_DWORD *)(a1 + 12));
  *(_DWORD *)(v3 + 20) = a2;
}

//----- (00045A58) --------------------------------------------------------
int __cdecl strbuffer_init(strbuffer_t *strbuff)
{
  *((_DWORD *)strbuff + 2) = 16;
  *((_DWORD *)strbuff + 1) = 0;
  *(_DWORD *)strbuff = jsonp_malloc(*((_DWORD *)strbuff + 2));
  if ( !*(_DWORD *)strbuff )
    return -1;
  **(_BYTE **)strbuff = 0;
  return 0;
}

//----- (00045A9C) --------------------------------------------------------
void __cdecl strbuffer_close(strbuffer_t *strbuff)
{
  if ( *(_DWORD *)strbuff )
    jsonp_free(*(void **)strbuff);
  *((_DWORD *)strbuff + 2) = 0;
  *((_DWORD *)strbuff + 1) = 0;
  *(_DWORD *)strbuff = 0;
}

//----- (00045AD0) --------------------------------------------------------
void __cdecl strbuffer_clear(strbuffer_t *strbuff)
{
  *((_DWORD *)strbuff + 1) = 0;
  **(_BYTE **)strbuff = 0;
}

//----- (00045AF4) --------------------------------------------------------
int __fastcall strbuffer_value(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00045B0C) --------------------------------------------------------
int __fastcall strbuffer_steal_value(int *a1)
{
  int v2; // [sp+Ch] [bp+Ch]

  v2 = *a1;
  *a1 = 0;
  return v2;
}

//----- (00045B30) --------------------------------------------------------
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, char byte)
{
  char v3; // [sp+3h] [bp+3h] BYREF
  strbuffer_t *v4; // [sp+4h] [bp+4h]

  v4 = strbuff;
  v3 = byte;
  return strbuffer_append_bytes((int)strbuff, &v3, 1u);
}

//----- (00045B54) --------------------------------------------------------
int __fastcall strbuffer_append_bytes(int a1, const void *a2, size_t a3)
{
  size_t v4; // r3
  void *dest; // [sp+10h] [bp+10h]
  size_t v10; // [sp+14h] [bp+14h]

  if ( *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4) > a3 )
    goto LABEL_11;
  if ( *(int *)(a1 + 8) >= 0 && a3 != -1 && *(_DWORD *)(a1 + 4) <= -2 - a3 )
  {
    v4 = 2 * *(_DWORD *)(a1 + 8);
    if ( v4 < a3 + *(_DWORD *)(a1 + 4) + 1 )
      v4 = a3 + *(_DWORD *)(a1 + 4) + 1;
    v10 = v4;
    dest = jsonp_malloc(v4);
    if ( !dest )
      return -1;
    memcpy(dest, *(const void **)a1, *(_DWORD *)(a1 + 4));
    jsonp_free(*(void **)a1);
    *(_DWORD *)a1 = dest;
    *(_DWORD *)(a1 + 8) = v10;
LABEL_11:
    memcpy((void *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)a1), a2, a3);
    *(_DWORD *)(a1 + 4) += a3;
    *(_BYTE *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)a1) = 0;
    return 0;
  }
  return -1;
}

//----- (00045C24) --------------------------------------------------------
char __cdecl strbuffer_pop(strbuffer_t *strbuff)
{
  int v1; // r2
  char v4; // [sp+Fh] [bp+Fh]

  if ( !*((_DWORD *)strbuff + 1) )
    return 0;
  v1 = *(_DWORD *)strbuff;
  v4 = *(_BYTE *)(--*((_DWORD *)strbuff + 1) + v1);
  *(_BYTE *)(*((_DWORD *)strbuff + 1) + *(_DWORD *)strbuff) = 0;
  return v4;
}

//----- (00045C70) --------------------------------------------------------
void __cdecl to_locale(strbuffer_t *strbuffer)
{
  struct lconv *v1; // r0
  char *v3; // [sp+8h] [bp+8h]
  char *decimal_point; // [sp+Ch] [bp+Ch]

  v1 = localeconv();
  decimal_point = v1->decimal_point;
  if ( *v1->decimal_point != 46 )
  {
    v3 = strchr(*(const char **)strbuffer, 46);
    if ( v3 )
      *v3 = *decimal_point;
  }
}

//----- (00045CB0) --------------------------------------------------------
void __cdecl from_locale(char *buffer)
{
  struct lconv *v1; // r0
  char *v3; // [sp+8h] [bp+8h]

  v1 = localeconv();
  if ( *v1->decimal_point != 46 )
  {
    v3 = strchr(buffer, *(unsigned __int8 *)v1->decimal_point);
    if ( v3 )
      *v3 = 46;
  }
}

//----- (00045CF0) --------------------------------------------------------
int __fastcall jsonp_strtod(strbuffer_t *a1, double *a2)
{
  double v2; // d0
  char *endptr; // [sp+Ch] [bp+Ch] BYREF
  double v8; // [sp+10h] [bp+10h]

  to_locale(a1);
  *_errno_location() = 0;
  strtod(*(const char **)a1, &endptr);
  v8 = v2;
  if ( (v2 > 1.79769313e308 || v8 < -1.79769313e308) && *_errno_location() == 34 )
    return -1;
  *a2 = v8;
  return 0;
}
// 45D1A: variable 'v2' is possibly undefined

//----- (00045D78) --------------------------------------------------------
int __fastcall jsonp_dtostr(char *a1, size_t a2, int a3)
{
  double v3; // d0
  int v6; // [sp+Ch] [bp+4h]
  int v9; // [sp+20h] [bp+18h]
  int v10; // [sp+24h] [bp+1Ch]
  _BYTE *src; // [sp+28h] [bp+20h]
  char *dest; // [sp+2Ch] [bp+24h]
  _BYTE *desta; // [sp+2Ch] [bp+24h]

  v6 = a3;
  if ( !a3 )
    v6 = 17;
  v9 = snprintf(a1, a2, "%.*g", v6, v3);
  if ( v9 < 0 )
    return -1;
  v10 = v9;
  if ( v9 >= a2 )
    return -1;
  from_locale(a1);
  if ( !strchr(a1, 46) && !strchr(a1, 101) )
  {
    if ( v9 + 3 >= a2 )
      return -1;
    a1[v9] = 46;
    a1[v9 + 1] = 48;
    a1[v9 + 2] = 0;
    v10 = v9 + 2;
  }
  dest = strchr(a1, 101);
  if ( dest )
  {
    desta = dest + 1;
    src = desta + 1;
    if ( *desta == 45 )
      ++desta;
    while ( *src == 48 )
      ++src;
    if ( src != desta )
    {
      memmove(desta, src, v10 - (src - a1));
      v10 -= src - desta;
    }
  }
  return v10;
}
// 45DA8: variable 'v3' is possibly undefined

//----- (00045E98) --------------------------------------------------------
int __fastcall eeprom_open(unsigned int a1)
{
  char v4[12]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v5[12]; // [sp+81Ch] [bp+80Ch] BYREF
  unsigned int v6; // [sp+181Ch] [bp+180Ch] BYREF
  __int16 v7; // [sp+1820h] [bp+1810h]
  char v8; // [sp+1822h] [bp+1812h]
  char v9; // [sp+1823h] [bp+1813h]
  int v10; // [sp+1824h] [bp+1814h]

  v10 = 0;
  if ( a1 <= 0xF )
  {
    if ( dword_479DE4[2 * a1] && dword_479DE4[2 * a1 + 1] )
    {
      return dword_479DE4[2 * a1];
    }
    else
    {
      v6 = a1;
      v7 = 0;
      v8 = 10;
      v9 = a1;
      v10 = iic_init((int)&v6);
      if ( v10 >= 0 )
      {
        dword_479DE4[2 * a1] = v10;
        dword_479DE4[2 * a1 + 1] = 1;
      }
      return v10;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_open", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "eeprom_open",
      11,
      50,
      100,
      v5);
    return -2147483391;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479DE4: using guessed type _DWORD dword_479DE4[32];
// 47BE18: using guessed type int g_zc;

//----- (0004604C) --------------------------------------------------------
unsigned int __fastcall eeprom_close(unsigned int result)
{
  unsigned int v1; // [sp+14h] [bp+4h]
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v3[4096]; // [sp+818h] [bp+808h] BYREF

  v1 = result;
  if ( result <= 0xF )
  {
    if ( dword_479DE4[2 * result] || dword_479DE4[2 * result + 1] )
    {
      result = iic_uninit(dword_479DE4[2 * result]);
      dword_479DE4[2 * v1] = 0;
      dword_479DE4[2 * v1 + 1] = 0;
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_close", result);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, s);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
             92,
             "eeprom_close",
             12,
             74,
             100,
             v3);
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479DE4: using guessed type _DWORD dword_479DE4[32];
// 47BE18: using guessed type int g_zc;

//----- (00046168) --------------------------------------------------------
int __fastcall eeprom_write(unsigned int a1, char a2, int a3, unsigned int a4)
{
  char v10[12]; // [sp+24h] [bp+14h] BYREF
  _BYTE v11[12]; // [sp+824h] [bp+814h] BYREF
  unsigned __int8 v12; // [sp+1827h] [bp+1817h] BYREF
  int v13; // [sp+1828h] [bp+1818h]
  unsigned int i; // [sp+182Ch] [bp+181Ch]

  v13 = 0;
  i = 0;
  if ( a1 <= 0xF )
  {
    if ( dword_479DE4[2 * a1 + 1] || (v13 = eeprom_open(a1), v13 >= 0) )
    {
      for ( i = 0; i < a4; ++i )
      {
        v12 = a2 + i;
        v13 = iic_write_reg(dword_479DE4[2 * a1], &v12, 1, i + a3, 1u);
        if ( v13 != 1 )
        {
          snprintf(v10, 0x800u, "fail to write eeprom by iic, chain:%d, addr: %d", a1, v12);
          V_LOCK();
          logfmt_raw(v11, 0x1000u, 0, v10);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
            92,
            "eeprom_write",
            12,
            116,
            100,
            v11);
          return -2147483392;
        }
      }
      sleep(1u);
      return 0;
    }
    else
    {
      snprintf(v10, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_write", a1);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_write",
        12,
        96,
        100,
        v11);
      return v13;
    }
  }
  else
  {
    snprintf(v10, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_write", a1);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "eeprom_write",
      12,
      91,
      100,
      v11);
    return -2147483391;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479DE4: using guessed type _DWORD dword_479DE4[32];
// 47BE18: using guessed type int g_zc;

//----- (0004644C) --------------------------------------------------------
int __fastcall eeprom_read(unsigned int a1, char a2, int a3, unsigned int a4)
{
  char v10[12]; // [sp+24h] [bp+14h] BYREF
  _BYTE v11[12]; // [sp+824h] [bp+814h] BYREF
  unsigned __int8 v12; // [sp+1827h] [bp+1817h] BYREF
  int v13; // [sp+1828h] [bp+1818h]
  unsigned int i; // [sp+182Ch] [bp+181Ch]

  v13 = 0;
  i = 0;
  if ( a1 <= 0xF )
  {
    if ( dword_479DE4[2 * a1 + 1] || (v13 = eeprom_open(a1), v13 >= 0) )
    {
      puts("no use at24c512c!");
      for ( i = 0; i < a4; ++i )
      {
        v12 = a2 + i;
        v13 = iic_read_reg(dword_479DE4[2 * a1], &v12, 1, i + a3, 1u);
        if ( v13 != 1 )
        {
          snprintf(v10, 0x800u, "fail to read eeprom by iic, chain: %d, addr: %d\n", a1, v12);
          V_LOCK();
          logfmt_raw(v11, 0x1000u, 0, v10);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
            92,
            "eeprom_read",
            11,
            158,
            100,
            v11);
          return -2147483392;
        }
      }
      usleep(0x7A120u);
      return 0;
    }
    else
    {
      snprintf(v10, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_read", a1);
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_read",
        11,
        136,
        100,
        v11);
      return v13;
    }
  }
  else
  {
    snprintf(v10, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_read", a1);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "eeprom_read",
      11,
      131,
      100,
      v11);
    return -2147483391;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479DE4: using guessed type _DWORD dword_479DE4[32];
// 47BE18: using guessed type int g_zc;

//----- (00046740) --------------------------------------------------------
void sub_46740()
{
  int v0; // [sp+0h] [bp+0h]
  unsigned __int8 i; // [sp+7h] [bp+7h]

  if ( dword_479E64 )
  {
    for ( i = 0; i < dword_479EA8; ++i )
    {
      v0 = dword_479E68[i];
      if ( *(_DWORD *)(dword_479E64 + 4 * v0) )
      {
        free(*(void **)(dword_479E64 + 4 * v0));
        *(_DWORD *)(dword_479E64 + 4 * v0) = 0;
      }
    }
    free((void *)dword_479E64);
    dword_479E64 = 0;
  }
}
// 479E64: using guessed type int dword_479E64;
// 479E68: using guessed type _DWORD dword_479E68[16];
// 479EA8: using guessed type int dword_479EA8;

//----- (000467E4) --------------------------------------------------------
int sub_467E4()
{
  int v0; // r4
  char v3[2048]; // [sp+10h] [bp+0h] BYREF
  _BYTE v4[8]; // [sp+810h] [bp+800h] BYREF
  int v5; // [sp+1810h] [bp+1800h]
  unsigned __int8 i; // [sp+1817h] [bp+1807h]

  if ( dword_479E64 || (dword_479E64 = (int)calloc(1u, 0x54u)) != 0 )
  {
    for ( i = 0; i < dword_479EA8; ++i )
    {
      v5 = dword_479E68[i];
      if ( !*(_DWORD *)(dword_479E64 + 4 * v5) )
      {
        v0 = dword_479E64;
        *(_DWORD *)(v0 + 4 * v5) = calloc(1u, 0x3Fu);
        if ( !*(_DWORD *)(dword_479E64 + 4 * v5) )
        {
          snprintf(v3, 0x800u, "No memory for configuraion for chain %d.\n", v5);
          V_LOCK();
          logfmt_raw(v4, 0x1000u, 0, v3);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
            92,
            "_alloc_memory",
            13,
            215,
            100,
            v4);
          goto LABEL_11;
        }
      }
    }
    return 0;
  }
  else
  {
    strcpy(v3, "No memory for configuraion.\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "_alloc_memory",
      13,
      202,
      100,
      v4);
LABEL_11:
    sub_46740();
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 479E68: using guessed type _DWORD dword_479E68[16];
// 479EA8: using guessed type int dword_479EA8;
// 47BE18: using guessed type int g_zc;

//----- (000469C4) --------------------------------------------------------
int __fastcall sub_469C4(_BYTE *a1, int a2)
{
  char v4[4]; // [sp+1Ch] [bp+Ch] BYREF
  int v5; // [sp+81Ch] [bp+80Ch] BYREF
  unsigned __int8 v6; // [sp+181Eh] [bp+180Eh]
  unsigned __int8 v7; // [sp+181Fh] [bp+180Fh]

  v6 = 0;
  v7 = 0;
  v6 = BM_CRC5(a1, 8 * (*(unsigned __int8 *)(a2 + 1) - 1));
  if ( v6 == *(unsigned __int8 *)(a2 + 55) )
  {
    return 1;
  }
  else
  {
    snprintf(
      v4,
      0x800u,
      "Fixture CRC check fail.fixture_crc = 0x%x, len = 0x%x, crc = 0x%x\n",
      *(unsigned __int8 *)(a2 + 55),
      *(unsigned __int8 *)(a2 + 1),
      v6);
    V_LOCK();
    logfmt_raw(&v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "_is_fixture_crc_pass",
      20,
      237,
      100,
      &v5);
  }
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00046AF0) --------------------------------------------------------
int __fastcall sub_46AF0(_BYTE *a1, char *a2)
{
  char v6[20]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v7[20]; // [sp+81Ch] [bp+80Ch] BYREF
  unsigned int v8[64]; // [sp+181Ch] [bp+180Ch] BYREF
  unsigned __int8 v9; // [sp+191Eh] [bp+190Eh]
  unsigned __int8 v10; // [sp+191Fh] [bp+190Fh]
  int v11; // [sp+1920h] [bp+1910h]
  signed int v12; // [sp+1924h] [bp+1914h]
  size_t v13; // [sp+1928h] [bp+1918h]
  int v14; // [sp+192Ch] [bp+191Ch]

  memset(v8, 0, sizeof(v8));
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v9 = *a1 & 0xF;
  v10 = *a1 >> 4;
  v14 = (unsigned __int8)a1[1];
  v13 = 2;
  v12 = v14 - 2;
  v11 = v14;
  if ( v14 && v12 >= 0 )
  {
    if ( v9 == 1 && v10 == 1 )
    {
      memcpy(v8, &a1[v13], v12);
      data_dec(v8, v12, v10, v9);
      memcpy(a2, a1, v13);
      memcpy(&a2[v13], v8, v12);
      return 0;
    }
    else
    {
      snprintf(
        v6,
        0x800u,
        "EEPROM eeprom_key_version or eeprom_encryption_algorithm error! eeprom_key_version:%d, eeprom_encryption_algorithm:%d",
        v9,
        v10);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "decode_eeprom_fixture_info",
        26,
        271,
        100,
        v7);
      return -1;
    }
  }
  else
  {
    snprintf(
      v6,
      0x800u,
      "EEPROM info error! fixture_len:%d, fixture_without_header_len:%d, fixture_actual_len:%d",
      v14,
      v12,
      v11);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "decode_eeprom_fixture_info",
      26,
      265,
      100,
      v7);
    return -1;
  }
}
// 46C1E: conditional instruction was optimized away because %0x1920.4<100u
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00046DFC) --------------------------------------------------------
int __fastcall sub_46DFC(_BYTE *a1, char a2)
{
  char v3[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v4; // [sp+81Ch] [bp+80Ch] BYREF
  unsigned __int8 v5; // [sp+181Fh] [bp+180Fh]

  v5 = 1;
  *a1 = 0;
  a1[1] = 1;
  a1[2] = 2;
  a1[3] = 3;
  a1[4] = 20;
  a1[5] = 22;
  a1[6] = 35;
  a1[7] = 36;
  if ( a2 == 3 )
    qmemcpy(a1 + 8, "-.2345678:<>@ABCDQ", 18);
  else
    v5 = 0;
  a1[26] = 1;
  a1[27] = 1;
  a1[28] = 1;
  a1[29] = 17;
  a1[30] = 2;
  a1[31] = 13;
  a1[32] = 1;
  if ( a2 == 3 )
    a1[33] = 9;
  else
    v5 = 0;
  a1[34] = 1;
  a1[35] = 4;
  a1[36] = 1;
  a1[37] = 1;
  a1[38] = 1;
  a1[39] = 1;
  a1[40] = 1;
  a1[41] = 1;
  a1[42] = 2;
  a1[43] = 2;
  a1[44] = 2;
  a1[45] = 2;
  a1[46] = 1;
  a1[47] = 1;
  a1[48] = 1;
  a1[49] = 1;
  a1[50] = 8;
  a1[51] = 1;
  if ( v5 != 1 )
  {
    strcpy(v3, "This FMT is not supported\n");
    V_LOCK();
    logfmt_raw(&v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "init_eeprom_fmt_info",
      20,
      357,
      100,
      &v4);
  }
  return v5;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00047190) --------------------------------------------------------
__int64 __fastcall eeprom_dump_fixture(int a1)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4100]; // [sp+818h] [bp+808h] BYREF

  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "key_version", *(_BYTE *)a1 & 0xF);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    364,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "algorithm_code", *(_BYTE *)a1 >> 4);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    365,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "fixture_info_len", *(unsigned __int8 *)(a1 + 1));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    366,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "fixture_standard", *(unsigned __int8 *)(a1 + 45));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    367,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "test_standard", *(unsigned __int8 *)(a1 + 46));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    368,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "chip_technology", *(const char **)(a1 + 31));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    369,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x\n", "fixture_fmt_version", *(unsigned __int8 *)(a1 + 2));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    370,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "SN", *(const char **)(a1 + 3));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    372,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "pcb", *(unsigned __int8 *)(a1 + 27), *(unsigned __int8 *)(a1 + 28));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    373,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "bom", *(unsigned __int8 *)(a1 + 29), *(unsigned __int8 *)(a1 + 30));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    374,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %u\n", "hash_board_voltage", *(unsigned __int16 *)(a1 + 35));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    375,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %u\n", "hash_board_freq", *(unsigned __int16 *)(a1 + 37));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    376,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %.2f\n", "nonce_response_rate", *(float *)(a1 + 39));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    377,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %u\n", "inlet_temperature", *(unsigned __int8 *)(a1 + 43));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    378,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %u\n", "outlet_temperature", *(unsigned __int8 *)(a1 + 44));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    379,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "asic sensor", *(_BYTE *)(a1 + 20) >> 7, *(_BYTE *)(a1 + 20) & 0x7F);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    380,
    100,
    v4);
  snprintf(
    s,
    0x800u,
    "%-30s : 0x%02x-%02x-%02x-%02x\n",
    "asic sensor addr",
    **(unsigned __int8 **)(a1 + 21),
    *(unsigned __int8 *)(*(_DWORD *)(a1 + 21) + 1),
    *(unsigned __int8 *)(*(_DWORD *)(a1 + 21) + 2),
    *(unsigned __int8 *)(*(_DWORD *)(a1 + 21) + 3));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    381,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x-%02x\n", "pic sensor", *(_BYTE *)(a1 + 25) >> 7, *(_BYTE *)(a1 + 25) & 0x7F);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    382,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : 0x%02x\n", "pic sensor addr", *(unsigned __int8 *)(a1 + 26));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    383,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : bin%d\n", "chip_bin", *(unsigned __int8 *)(a1 + 15));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    384,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "FT", *(const char **)(a1 + 16));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    385,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "chip_die", *(const char **)(a1 + 7));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    386,
    100,
    v4);
  snprintf(s, 0x800u, "%-30s : %s\n", "chip_marking", *(const char **)(a1 + 11));
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "eeprom_dump_fixture",
    19,
    387,
    100,
    v4);
  strcpy(s, "\n");
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
           92,
           "eeprom_dump_fixture",
           19,
           388,
           100,
           v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00047D60) --------------------------------------------------------
int __fastcall sub_47D60(_BYTE *a1, int a2)
{
  float v3; // s15
  char v7[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v8[16]; // [sp+818h] [bp+808h] BYREF
  _BYTE v9[18]; // [sp+1818h] [bp+1808h] BYREF
  unsigned __int16 v10; // [sp+182Ah] [bp+181Ah] BYREF
  unsigned __int16 v11; // [sp+182Ch] [bp+181Ch] BYREF
  unsigned __int16 v12; // [sp+182Eh] [bp+181Eh] BYREF
  _BYTE v13[7]; // [sp+1830h] [bp+1820h] BYREF
  unsigned __int8 v14; // [sp+1837h] [bp+1827h]
  unsigned __int8 v15; // [sp+1838h] [bp+1828h]
  unsigned __int8 v16; // [sp+1839h] [bp+1829h]
  unsigned __int8 v17; // [sp+183Ah] [bp+182Ah]
  unsigned __int8 v18; // [sp+183Bh] [bp+182Bh]
  unsigned __int8 v19; // [sp+183Ch] [bp+182Ch]
  unsigned __int8 v20; // [sp+183Dh] [bp+182Dh]
  unsigned __int8 v21; // [sp+183Eh] [bp+182Eh]
  unsigned __int8 v22; // [sp+183Fh] [bp+182Fh]
  unsigned __int8 v23; // [sp+1840h] [bp+1830h]
  unsigned __int8 v24; // [sp+1841h] [bp+1831h]
  unsigned __int8 v25; // [sp+1842h] [bp+1832h]
  unsigned __int8 v26; // [sp+1843h] [bp+1833h]
  unsigned __int8 v27; // [sp+1844h] [bp+1834h]
  unsigned __int8 v28; // [sp+1845h] [bp+1835h]
  unsigned __int8 v29; // [sp+1846h] [bp+1836h]
  unsigned __int8 v30; // [sp+1847h] [bp+1837h]
  unsigned __int8 v31; // [sp+1848h] [bp+1838h]
  unsigned __int8 v32; // [sp+1849h] [bp+1839h]
  unsigned __int8 v33; // [sp+184Dh] [bp+183Dh]
  unsigned __int8 v34; // [sp+184Eh] [bp+183Eh]
  unsigned __int8 v35; // [sp+184Fh] [bp+183Fh]
  unsigned __int8 v36; // [sp+1851h] [bp+1841h]
  unsigned __int8 v37; // [sp+1853h] [bp+1843h]
  unsigned __int8 v38; // [sp+185Ah] [bp+184Ah]
  unsigned __int8 v39; // [sp+185Bh] [bp+184Bh]
  unsigned __int8 v40; // [sp+185Ch] [bp+184Ch]
  unsigned __int8 v41; // [sp+185Dh] [bp+184Dh]
  unsigned __int8 v42; // [sp+1862h] [bp+1852h]
  unsigned __int8 v43; // [sp+1867h] [bp+1857h]

  v43 = 1;
  *(_BYTE *)a2 = *(_BYTE *)a2 & 0xF | (16 * ((*a1 >> 4) & 0xF));
  *(_BYTE *)a2 = *(_BYTE *)a2 & 0xF0 | *a1 & 0xF;
  *(_BYTE *)(a2 + 1) = a1[1];
  *(_BYTE *)(a2 + 2) = a1[2];
  if ( (unsigned __int8)sub_46DFC(v13, *(_BYTE *)(a2 + 2)) != 1 )
  {
    v43 = 0;
    return 0;
  }
  else
  {
    *(_DWORD *)(a2 + 3) = calloc(v33 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 3) )
    {
      strcpy(v7, "Decode SN OOM\n");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_buf_to_layout",
        20,
        418,
        100,
        v8);
      v43 = 0;
    }
    memcpy(*(void **)(a2 + 3), &a1[v13[3]], v33);
    *(_DWORD *)(a2 + 7) = calloc(v34 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 7) )
    {
      strcpy(v7, "Decode Chip Die OOM\n");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_buf_to_layout",
        20,
        427,
        100,
        v8);
      v43 = 0;
    }
    memcpy(*(void **)(a2 + 7), &a1[v13[4]], v34);
    *(_DWORD *)(a2 + 11) = calloc(v35 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 11) )
    {
      strcpy(v7, "Decode Chip Marking OOM\n");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_buf_to_layout",
        20,
        436,
        100,
        v8);
      v43 = 0;
    }
    memcpy(*(void **)(a2 + 11), &a1[v13[5]], v35);
    *(_BYTE *)(a2 + 15) = a1[v13[6]];
    if ( *(_BYTE *)(a2 + 2) == 1 || *(_BYTE *)(a2 + 2) == 2 )
    {
      memset(v9, 0, 16);
      *(_DWORD *)(a2 + 16) = calloc(v36 + 6, 1u);
      if ( !*(_DWORD *)(a2 + 16) )
      {
        strcpy(v7, "Decode Chip FT Program Version OOM\n");
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
          92,
          "eeprom_buf_to_layout",
          20,
          451,
          100,
          v8);
        v43 = 0;
      }
      memcpy(v9, &a1[v14], v36);
      snprintf(*(char **)(a2 + 16), v36 + 6, "F%dV%02dB%dC%d", v9[0], v9[1], v9[2], v9[3]);
    }
    else
    {
      *(_DWORD *)(a2 + 16) = calloc(v36 + 1, 1u);
      if ( !*(_DWORD *)(a2 + 16) )
      {
        strcpy(v7, "Decode Chip FT Program Version OOM\n");
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
          92,
          "eeprom_buf_to_layout",
          20,
          462,
          100,
          v8);
        v43 = 0;
      }
      memcpy(*(void **)(a2 + 16), &a1[v14], v36);
    }
    *(_BYTE *)(a2 + 20) = *(_BYTE *)(a2 + 20) & 0x80 | a1[v15] & 0x7F;
    *(_BYTE *)(a2 + 20) = *(_BYTE *)(a2 + 20) & 0x7F | (a1[v15] >> 7 << 7);
    *(_DWORD *)(a2 + 21) = calloc(v37 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 21) )
    {
      strcpy(v7, "Decode Chip FT Program Version OOM\n");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_buf_to_layout",
        20,
        476,
        100,
        v8);
      v43 = 0;
    }
    memcpy(*(void **)(a2 + 21), &a1[v16], v37);
    *(_BYTE *)(a2 + 25) = *(_BYTE *)(a2 + 25) & 0x80 | a1[v17] & 0x7F;
    *(_BYTE *)(a2 + 25) = *(_BYTE *)(a2 + 25) & 0x7F | (a1[v17] >> 7 << 7);
    *(_BYTE *)(a2 + 26) = a1[v18];
    *(_BYTE *)(a2 + 27) = a1[v19];
    *(_BYTE *)(a2 + 28) = a1[v20];
    *(_BYTE *)(a2 + 29) = a1[v21];
    *(_BYTE *)(a2 + 30) = a1[v22];
    *(_DWORD *)(a2 + 31) = calloc(v38 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 31) )
    {
      strcpy(v7, "Decode Chip Technology OOM\n");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_buf_to_layout",
        20,
        500,
        100,
        v8);
      v43 = 0;
    }
    memcpy(*(void **)(a2 + 31), &a1[v23], v38);
    memcpy(&v12, &a1[v24], v39);
    *(_WORD *)(a2 + 35) = HIBYTE(v12) | (v12 << 8);
    memcpy(&v11, &a1[v25], v40);
    *(_WORD *)(a2 + 37) = HIBYTE(v11) | (v11 << 8);
    memcpy(&v10, &a1[v26], v41);
    v3 = (double)((unsigned __int16)(v10 << 8) | (unsigned int)HIBYTE(v10)) / 100.0;
    *(float *)(a2 + 39) = v3;
    *(_BYTE *)(a2 + 43) = a1[v27];
    *(_BYTE *)(a2 + 44) = a1[v28];
    *(_BYTE *)(a2 + 45) = a1[v29];
    *(_BYTE *)(a2 + 46) = a1[v30];
    *(_DWORD *)(a2 + 47) = calloc(v42 + 1, 1u);
    if ( !*(_DWORD *)(a2 + 47) )
    {
      strcpy(v7, "Decode miner_type OOM\n");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_buf_to_layout",
        20,
        536,
        100,
        v8);
      v43 = 0;
    }
    memcpy(*(void **)(a2 + 47), &a1[v31], v42);
    *(_BYTE *)(a2 + 55) = a1[v32];
    return v43;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00048968) --------------------------------------------------------
_DWORD *__fastcall add_eeprom_device(int a1)
{
  int v1; // r2

  v1 = dword_479EA8++;
  dword_479E68[v1] = a1;
  return dword_479E68;
}
// 479E68: using guessed type _DWORD dword_479E68[16];
// 479EA8: using guessed type int dword_479EA8;

//----- (000489A4) --------------------------------------------------------
int __fastcall eeprom_load_one_chain(unsigned int a1, int a2)
{
  char v6[12]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v7[12]; // [sp+81Ch] [bp+80Ch] BYREF
  char v8[256]; // [sp+181Ch] [bp+180Ch] BYREF
  _BYTE v9[256]; // [sp+191Ch] [bp+190Ch] BYREF
  int v10; // [sp+1A1Ch] [bp+1A0Ch]
  int v11; // [sp+1A20h] [bp+1A10h]
  int v12; // [sp+1A24h] [bp+1A14h]

  v12 = 0;
  v11 = 3;
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  v10 = *(_DWORD *)(a2 + 4 * a1);
  do
  {
    v12 = eeprom_read(a1, 0, (int)v9, 0x100u);
    if ( v12 )
    {
      snprintf(v6, 0x800u, "Read configuration fail for chain %d.\n", a1);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_load_one_chain",
        21,
        565,
        100,
        v7);
      return v12;
    }
    if ( !sub_46AF0(v9, v8) )
      break;
    snprintf(v6, 0x800u, "Data decode fail for chain %d.\n", a1);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "eeprom_load_one_chain",
      21,
      579,
      100,
      v7);
    usleep(0x7A120u);
    --v11;
  }
  while ( v11 );
  if ( v11 && sub_47D60(v8, v10) && sub_469C4(v8, v10) )
  {
    *(_BYTE *)(a1 + a2 + 64) = 1;
  }
  else
  {
    *(_BYTE *)(a1 + a2 + 64) = 0;
    snprintf(v6, 0x800u, "Data load fail for chain %d.\n", a1);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "eeprom_load_one_chain",
      21,
      596,
      100,
      v7);
    return -1;
  }
  return v12;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00048CA8) --------------------------------------------------------
int eeprom_load()
{
  int v2; // [sp+1000h] [bp+1000h]
  unsigned __int8 i; // [sp+1007h] [bp+1007h]

  v2 = 0;
  if ( dword_479E64 )
  {
    if ( *(_BYTE *)(dword_479E64 + 80) )
      return 0;
  }
  else if ( sub_467E4() )
  {
    return -1;
  }
  for ( i = 0; i < dword_479EA8; ++i )
    v2 |= eeprom_load_one_chain(dword_479E68[i], dword_479E64);
  if ( !v2 )
    *(_BYTE *)(dword_479E64 + 80) = 1;
  return v2;
}
// 479E64: using guessed type int dword_479E64;
// 479E68: using guessed type _DWORD dword_479E68[16];
// 479EA8: using guessed type int dword_479EA8;

//----- (00048D90) --------------------------------------------------------
int __fastcall eeprom_get_voltage(int a1, _DWORD *a2)
{
  char v4[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v5; // [sp+81Ch] [bp+80Ch] BYREF
  int v6; // [sp+181Ch] [bp+180Ch]

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
  {
    v6 = *(unsigned __int16 *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 35);
    if ( a2 )
    {
      *a2 = v6;
      return 0;
    }
    else
    {
      strcpy(v4, "voltage level not match");
      V_LOCK();
      logfmt_raw(&v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_get_voltage",
        18,
        653,
        100,
        &v5);
      return -2;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "No work mode voltage, chain = %d.\n", a1);
    V_LOCK();
    logfmt_raw(&v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "eeprom_get_voltage",
      18,
      642,
      100,
      &v5);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (00048F0C) --------------------------------------------------------
int eeprom_get_max_voltage()
{
  char v2[8]; // [sp+10h] [bp+0h] BYREF
  _BYTE v3[8]; // [sp+810h] [bp+800h] BYREF
  int i; // [sp+1810h] [bp+1800h]
  int v5; // [sp+1814h] [bp+1804h]

  v5 = 0;
  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
  {
    for ( i = 0; i < dword_479EA8; ++i )
    {
      if ( *(unsigned __int16 *)(*(_DWORD *)(dword_479E64 + 4 * dword_479E68[i]) + 35) > v5 )
        v5 = *(unsigned __int16 *)(*(_DWORD *)(dword_479E64 + 4 * dword_479E68[i]) + 35);
    }
    return v5;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: eeprom is not ready\n", "eeprom_get_max_voltage");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "eeprom_get_max_voltage",
      22,
      663,
      100,
      v3);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 479E68: using guessed type _DWORD dword_479E68[16];
// 479EA8: using guessed type int dword_479EA8;
// 47BE18: using guessed type int g_zc;

//----- (00049064) --------------------------------------------------------
int __fastcall eeprom_get_freq(int a1, _DWORD *a2)
{
  char v4[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v5; // [sp+81Ch] [bp+80Ch] BYREF
  int v6; // [sp+181Ch] [bp+180Ch]

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
  {
    v6 = *(unsigned __int16 *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 37);
    if ( a2 )
    {
      *a2 = v6;
      return 0;
    }
    else
    {
      strcpy(v4, "freq level not match");
      V_LOCK();
      logfmt_raw(&v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "eeprom_get_freq",
        15,
        692,
        100,
        &v5);
      return -2;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "No work mode freq, chain = %d.\n", a1);
    V_LOCK();
    logfmt_raw(&v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "eeprom_get_freq",
      15,
      681,
      100,
      &v5);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (000491E4) --------------------------------------------------------
int eeprom_get_min_freq()
{
  char v2[8]; // [sp+10h] [bp+0h] BYREF
  _BYTE v3[8]; // [sp+810h] [bp+800h] BYREF
  int i; // [sp+1810h] [bp+1800h]
  int v5; // [sp+1814h] [bp+1804h]

  v5 = 0xFFFF;
  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
  {
    for ( i = 0; i < dword_479EA8; ++i )
    {
      if ( *(unsigned __int16 *)(*(_DWORD *)(dword_479E64 + 4 * dword_479E68[i]) + 37) < v5 )
        v5 = *(unsigned __int16 *)(*(_DWORD *)(dword_479E64 + 4 * dword_479E68[i]) + 37);
    }
    return v5;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: g_eeprom_data is not ready\n", "eeprom_get_min_freq");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "eeprom_get_min_freq",
      19,
      702,
      100,
      v3);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 479E68: using guessed type _DWORD dword_479E68[16];
// 479EA8: using guessed type int dword_479EA8;
// 47BE18: using guessed type int g_zc;

//----- (0004933C) --------------------------------------------------------
int is_eeprom_loaded()
{
  char v2[2048]; // [sp+10h] [bp+0h] BYREF
  _BYTE v3[4096]; // [sp+810h] [bp+800h] BYREF

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
    return *(unsigned __int8 *)(dword_479E64 + 80);
  snprintf(v2, 0x800u, "%s: g_eeprom_data is not ready\n", "is_eeprom_loaded");
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "is_eeprom_loaded",
    16,
    718,
    20,
    v3);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (000493E8) --------------------------------------------------------
int __fastcall sub_493E8(int a1)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4096]; // [sp+818h] [bp+808h] BYREF

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 15);
  snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_chip_bin", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "get_chip_bin",
    12,
    729,
    100,
    v4);
  return 255;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (000494B8) --------------------------------------------------------
int __fastcall sub_494B8(int a1)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4096]; // [sp+818h] [bp+808h] BYREF

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
    return *(_DWORD *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 16);
  snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_chip_ft", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "get_chip_ft",
    11,
    739,
    100,
    v4);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (00049588) --------------------------------------------------------
int __fastcall sub_49588(int a1)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4096]; // [sp+818h] [bp+808h] BYREF

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 46);
  snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_test_standard_code", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "get_test_standard_code",
    22,
    749,
    100,
    v4);
  return 255;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (00049658) --------------------------------------------------------
int __fastcall sub_49658(int a1)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4096]; // [sp+818h] [bp+808h] BYREF

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
    return *(_DWORD *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 3);
  snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_chip_sn", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "get_chip_sn",
    11,
    759,
    100,
    v4);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (00049728) --------------------------------------------------------
int __fastcall sub_49728(int a1, char *a2)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[4096]; // [sp+818h] [bp+808h] BYREF

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
  {
    sprintf(
      a2,
      "%x%02x",
      *(unsigned __int8 *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 27),
      *(unsigned __int8 *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 28));
    return 0;
  }
  else
  {
    snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_pcb_version", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "get_pcb_version",
      15,
      769,
      100,
      v5);
    return 255;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (00049830) --------------------------------------------------------
int __fastcall sub_49830(int a1, char *a2)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[4096]; // [sp+818h] [bp+808h] BYREF

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
  {
    sprintf(
      a2,
      "%x%x",
      *(unsigned __int8 *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 29),
      *(unsigned __int8 *)(*(_DWORD *)(dword_479E64 + 4 * a1) + 30));
    return 0;
  }
  else
  {
    snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_bom_version", a1);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "get_bom_version",
      15,
      780,
      100,
      v5);
    return 255;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (00049938) --------------------------------------------------------
int __fastcall sub_49938(int a1, void *a2)
{
  size_t v2; // r0
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[4100]; // [sp+818h] [bp+808h] BYREF

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
  {
    v2 = strlen(*(const char **)(*(_DWORD *)(dword_479E64 + 4 * a1) + 47));
    memcpy(a2, *(const void **)(*(_DWORD *)(dword_479E64 + 4 * a1) + 47), v2);
  }
  else
  {
    snprintf(s, 0x800u, "%s: g_eeprom_data is not ready, chain = %d.\n", "get_miner_type", a1);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "get_miner_type",
      14,
      792,
      100,
      v7);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 47BE18: using guessed type int g_zc;

//----- (00049A44) --------------------------------------------------------
int __fastcall api_get_eeprom_nonce_response_rate(int a1, _DWORD *a2)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[4096]; // [sp+818h] [bp+808h] BYREF

  if ( dword_479E64 && *(_BYTE *)(dword_479E64 + 80) )
  {
    if ( a2 )
    {
      *a2 = *(_DWORD *)(*(_DWORD *)(dword_479E64 + 4 * dword_479E68[a1]) + 39);
      return 0;
    }
    else
    {
      snprintf(
        s,
        0x800u,
        "%s: chain = %d nonce response rate in eeprom is invalid\n",
        "api_get_eeprom_nonce_response_rate",
        dword_479E68[a1]);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
        92,
        "api_get_eeprom_nonce_response_rate",
        34,
        813,
        100,
        v5);
      return -2;
    }
  }
  else
  {
    snprintf(
      s,
      0x800u,
      "%s: g_eeprom_data is not ready, chain = %d.\n",
      "api_get_eeprom_nonce_response_rate",
      dword_479E68[a1]);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
      92,
      "api_get_eeprom_nonce_response_rate",
      34,
      804,
      100,
      v5);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 479E68: using guessed type _DWORD dword_479E68[16];
// 47BE18: using guessed type int g_zc;

//----- (00049BD8) --------------------------------------------------------
int __fastcall api_get_eeprom_freq(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  v2 = 0;
  eeprom_get_freq(dword_479E68[a1], &v2);
  return v2;
}
// 479E68: using guessed type _DWORD dword_479E68[16];

//----- (00049C0C) --------------------------------------------------------
int __fastcall api_get_eeprom_voltage(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  v2 = 0;
  eeprom_get_voltage(dword_479E68[a1], &v2);
  return v2;
}
// 479E68: using guessed type _DWORD dword_479E68[16];

//----- (00049C40) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_bin(int a1)
{
  return sub_493E8(dword_479E68[a1]);
}
// 479E68: using guessed type _DWORD dword_479E68[16];

//----- (00049C68) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_ft(int a1)
{
  return sub_494B8(dword_479E68[a1]);
}
// 479E68: using guessed type _DWORD dword_479E68[16];

//----- (00049C90) --------------------------------------------------------
int __fastcall api_get_eeprom_test_standard_code(int a1)
{
  return sub_49588(dword_479E68[a1]);
}
// 479E68: using guessed type _DWORD dword_479E68[16];

//----- (00049CB8) --------------------------------------------------------
int __fastcall api_get_eeprom_chip_sn(int a1)
{
  return sub_49658(dword_479E68[a1]);
}
// 479E68: using guessed type _DWORD dword_479E68[16];

//----- (00049CE0) --------------------------------------------------------
int __fastcall api_get_eeprom_miner_type(int a1, void *a2)
{
  return sub_49938(dword_479E68[a1], a2);
}
// 479E68: using guessed type _DWORD dword_479E68[16];

//----- (00049D0C) --------------------------------------------------------
int __fastcall api_get_eeprom_chain_load_state(int a1)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4096]; // [sp+818h] [bp+808h] BYREF

  if ( dword_479E64 )
    return *(unsigned __int8 *)(dword_479E68[a1] + dword_479E64 + 64);
  snprintf(
    s,
    0x800u,
    "%s: g_eeprom_data is not ready, chain = %d.\n",
    "api_get_eeprom_chain_load_state",
    dword_479E68[a1]);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/eeprom/bitmain_eeprom.c",
    92,
    "api_get_eeprom_chain_load_state",
    31,
    862,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479E64: using guessed type int dword_479E64;
// 479E68: using guessed type _DWORD dword_479E68[16];
// 47BE18: using guessed type int g_zc;

//----- (00049DE4) --------------------------------------------------------
int __fastcall api_get_eeprom_pcb_version(int a1, char *a2)
{
  return sub_49728(dword_479E68[a1], a2);
}
// 479E68: using guessed type _DWORD dword_479E68[16];

//----- (00049E10) --------------------------------------------------------
int __fastcall api_get_eeprom_bom_version(int a1, char *a2)
{
  return sub_49830(dword_479E68[a1], a2);
}
// 479E68: using guessed type _DWORD dword_479E68[16];

//----- (00049E40) --------------------------------------------------------
int __fastcall sub_49E40(int a1, char a2, char a3, int a4, int a5)
{
  _BYTE v6[4]; // [sp+10h] [bp+10h] BYREF
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int v9; // [sp+1Ch] [bp+1Ch]

  v6[0] = a2;
  v6[1] = a3;
  v7 = a4;
  v8 = a5;
  v9 = ioctl(a1, 0x720u, v6);
  if ( v9 < 0 )
    perror("failed to get i2c_smbus ioctl");
  return v9;
}

//----- (00049E90) --------------------------------------------------------
int __fastcall sub_49E90(int a1, char *a2)
{
  char v3[36]; // [sp+10h] [bp+8h] BYREF

  v3[0] = a2[1];
  return sub_49E40(a1, 0, *a2, 2, (int)v3);
}

//----- (00049EC0) --------------------------------------------------------
int __fastcall sub_49EC0(int a1, int a2)
{
  _WORD v3[18]; // [sp+10h] [bp+8h] BYREF

  v3[0] = *(unsigned __int8 *)(a2 + 1) | (*(unsigned __int8 *)(a2 + 2) << 8);
  return sub_49E40(a1, 0, *(_BYTE *)a2, 3, (int)v3);
}

//----- (00049F04) --------------------------------------------------------
int __fastcall at24c512_eeprom_read_byte(int a1, unsigned __int8 a2, __int16 a3, _BYTE *a4)
{
  _BYTE v8[36]; // [sp+1Ch] [bp+14h] BYREF
  char v9[4]; // [sp+40h] [bp+38h] BYREF
  int v10; // [sp+44h] [bp+3Ch]

  v9[0] = HIBYTE(a3);
  v9[1] = a3;
  if ( ioctl(a1, 0x703u, a2) >= 0 )
  {
    v10 = sub_49E90(a1, v9);
    if ( !v10 )
      usleep(0xBB8u);
    if ( v10 >= 0 )
    {
      if ( sub_49E40(a1, 1, 0, 1, (int)v8) )
      {
        return -1;
      }
      else
      {
        *a4 = v8[0];
        return 0;
      }
    }
    else
    {
      return v10;
    }
  }
  else
  {
    perror("failed to get i2c_slave ioctl");
    return -1;
  }
}

//----- (00049FA4) --------------------------------------------------------
int __fastcall at24c512_eeprom_write_byte(int a1, unsigned __int8 a2, __int16 a3, char a4)
{
  _BYTE v7[4]; // [sp+8h] [bp+8h] BYREF
  int v8; // [sp+Ch] [bp+Ch]

  v7[0] = HIBYTE(a3);
  v7[1] = a3;
  v7[2] = a4;
  if ( ioctl(a1, 0x703u, a2) >= 0 )
  {
    v8 = sub_49EC0(a1, (int)v7);
    if ( !v8 )
      usleep(0xBB8u);
    return v8;
  }
  else
  {
    perror("failed to get i2c_slave ioctl");
    return -1;
  }
}

//----- (0004A020) --------------------------------------------------------
int __fastcall at24c512_eeprom_open(const char *a1, int a2)
{
  int fd; // [sp+Ch] [bp+Ch]

  fd = open(a1, 2);
  if ( fd > 0 )
  {
    if ( ioctl(fd, 0x703u, a2) >= 0 )
    {
      return fd;
    }
    else
    {
      perror("failed to get i2c_slave ioctl");
      return -1;
    }
  }
  else
  {
    perror("failed to open i2c dev");
    return -1;
  }
}

//----- (0004A07C) --------------------------------------------------------
int __fastcall at24c512_eeprom_close(int a1)
{
  close(a1);
  return 0;
}

//----- (0004A094) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4A094(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0004A0BC) --------------------------------------------------------
int __fastcall send_work(int a1)
{
  int v1; // r0
  _BYTE v3[12]; // [sp+1Ch] [bp+Ch] BYREF
  void *i; // [sp+101Ch] [bp+100Ch]
  char *v5; // [sp+1020h] [bp+1010h]
  int v6; // [sp+1024h] [bp+1014h]

  v6 = a1;
  v5 = (char *)calloc(1u, 0x40u);
  snprintf(v5, 0x40u, "%.10s_%d", "send_work", *(_DWORD *)(v6 + 136));
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v3, 0x1000u, 0, "%s on pid %ld", v5, v1);
  V_UNLOCK();
  zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_base.c", 72, "send_work", 9, 46, 60, v3);
  prctl(15, v5);
  for ( i = calloc(1u, *(_DWORD *)(v6 + 628)); ; push_work_base(v6, (int)i) )
  {
    memset(i, 0, *(_DWORD *)(v6 + 628));
    queue_dequeue(*(_DWORD *)(v6 + 652), (char *)i, 1u);
    if ( *(_BYTE *)(v6 + 686) )
      break;
  }
  *(_BYTE *)(v6 + 686) = 0;
  free(i);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004A25C) --------------------------------------------------------
int __fastcall platform_check_repeat_nonce(int *a1, int a2, unsigned __int8 *a3)
{
  _BYTE v8[4080]; // [sp+48h] [bp+10h] BYREF
  _DWORD v9[7]; // [sp+1048h] [bp+1010h] BYREF
  int v10; // [sp+1064h] [bp+102Ch]
  char *v11; // [sp+106Ch] [bp+1034h]
  char *v12; // [sp+1070h] [bp+1038h]
  char *v13; // [sp+1074h] [bp+103Ch]
  size_t v14; // [sp+1078h] [bp+1040h]
  size_t v15; // [sp+107Ch] [bp+1044h]
  size_t v16; // [sp+1080h] [bp+1048h]
  size_t i; // [sp+1084h] [bp+104Ch]

  v16 = a1[159];
  v15 = 2 * v16 * a2;
  v14 = v16 + v15;
  if ( !memcmp((const void *)(a1[73] + v15), a3, v16) || !memcmp((const void *)(a1[73] + v14), a3, v16) )
  {
    v13 = (char *)calloc(2 * v16 + 1, 1u);
    v12 = (char *)calloc(2 * v16 + 1, 1u);
    v11 = (char *)calloc(2 * v16 + 1, 1u);
    if ( v13 && v12 && v11 )
    {
      for ( i = 0; i < v16; ++i )
      {
        sprintf(&v13[2 * i], "%02x", a3[i]);
        sprintf(&v12[2 * i], "%02x", *(unsigned __int8 *)(v15 + i + a1[73]));
        sprintf(&v11[2 * i], "%02x", *(unsigned __int8 *)(v14 + i + a1[73]));
      }
      V_LOCK();
      sub_4A094((int)v9, a1[35]);
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v10,
        v9[0],
        v9[1],
        v9[2],
        v9[3],
        v9[4],
        v9[5],
        v9[6],
        v10,
        "asic %d repeat nonce %s %s %s",
        a2,
        v13,
        v12,
        v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_base.c",
        72,
        "platform_check_repeat_nonce",
        27,
        81,
        20,
        v8);
    }
    if ( v11 )
      free(v11);
    if ( v12 )
      free(v12);
    if ( v13 )
      free(v13);
    return 4;
  }
  else
  {
    memcpy((void *)(a1[73] + v14), (const void *)(v15 + a1[73]), v16);
    memcpy((void *)(a1[73] + v15), a3, v16);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004A66C) --------------------------------------------------------
int __fastcall scanhash(int *a1)
{
  int v1; // r0
  _BYTE v3[12]; // [sp+1Ch] [bp+Ch] BYREF
  char v4; // [sp+101Fh] [bp+100Fh] BYREF
  int v5; // [sp+1020h] [bp+1010h] BYREF
  int v6; // [sp+1024h] [bp+1014h] BYREF
  char v7[512]; // [sp+1028h] [bp+1018h] BYREF
  unsigned int v8; // [sp+1228h] [bp+1218h]
  int v9; // [sp+122Ch] [bp+121Ch]
  unsigned int v10; // [sp+1230h] [bp+1220h]
  unsigned __int8 *v11; // [sp+1234h] [bp+1224h]
  void *v12; // [sp+1238h] [bp+1228h]
  int v13; // [sp+123Ch] [bp+122Ch]
  char *v14; // [sp+1240h] [bp+1230h]
  int *v15; // [sp+1244h] [bp+1234h]

  v15 = a1;
  v14 = (char *)calloc(1u, 0x40u);
  snprintf(v14, 0x40u, "%.10s_%d", "scanhash", v15[34]);
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v3, 0x1000u, 0, "%s on pid %ld", v14, v1);
  V_UNLOCK();
  zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_base.c", 72, "scanhash", 8, 99, 60, v3);
  prctl(15, v14);
  v13 = v15[164];
  memset(v7, 0, sizeof(v7));
  v12 = calloc(1u, v15[158]);
  v11 = (unsigned __int8 *)calloc(1u, v15[159]);
  while ( 1 )
  {
    memset(v7, 0, sizeof(v7));
    queue_dequeue(v13, v7, 1u);
    if ( *((_BYTE *)v15 + 684) )
    {
      *((_BYTE *)v15 + 684) = 0;
      goto LABEL_26;
    }
    while ( 1 )
    {
      while ( (unsigned __int8)v7[0] != 170 )
      {
        queue_dequeue(v13, v7, 1u);
        if ( *((_BYTE *)v15 + 684) )
        {
          *((_BYTE *)v15 + 684) = 0;
          goto LABEL_26;
        }
      }
      queue_dequeue(v13, &v7[1], 1u);
      if ( *((_BYTE *)v15 + 684) )
      {
        *((_BYTE *)v15 + 684) = 0;
        goto LABEL_26;
      }
      if ( v7[1] == 85 )
        break;
      v7[0] = v7[1];
    }
    queue_dequeue(v13, &v7[2], 1u);
    v10 = ((int (__fastcall *)(_DWORD))v15[30])((unsigned __int8)v7[2]);
    queue_dequeue(v13, &v7[3], v10);
    if ( *((_BYTE *)v15 + 684) )
      break;
    memset(v12, 0, v15[158]);
    v6 = 0;
    v5 = 0;
    v4 = 0;
    v9 = ((int (__fastcall *)(int *, char *, void *, char *, unsigned __int8 *, int *, int *))v15[15])(
           v15,
           v7,
           v12,
           &v4,
           v11,
           &v6,
           &v5);
    switch ( v9 )
    {
      case 0:
        if ( *((_BYTE *)v15 + v5 + 336) != 1 && v4 && platform_check_repeat_nonce(v15, v6, v11) )
        {
          ++*(_QWORD *)(v15[66] + 48 * v6 + 32);
        }
        else
        {
          v8 = ((int (__fastcall *)(int *, void *))v15[16])(v15, v12);
          if ( v8 <= 5 )
          {
            *(_QWORD *)(v15[66] + 48 * v6 + 8 * v8) = *(_QWORD *)(8 * v8 + v15[66] + 48 * v6) + 1LL;
            if ( v8 <= 1 )
            {
              ++*(_DWORD *)(4 * v6 + v15[72]);
              ++*((_QWORD *)v15 + 32);
              ++*(_QWORD *)&v15[2 * v5 + 92];
              if ( !v8 && *((_BYTE *)v15 + v5 + 336) != 1 )
                queue_enqueue(*(_DWORD *)(v15[167] + 660), (char *)v12, 1);
            }
          }
        }
        break;
      case 1:
        queue_enqueue(v15[166], v7, v10 + 3);
        break;
      case 2:
        ++*(_QWORD *)(v15[66] + 40);
        break;
      default:
        continue;
    }
  }
  *((_BYTE *)v15 + 684) = 0;
LABEL_26:
  free(v12);
  free(v11);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004AC98) --------------------------------------------------------
int __fastcall get_response(int a1)
{
  int v1; // r0
  _UNKNOWN **v2; // r0
  __useconds_t v3; // r3
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  char v6[256]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+111Ch] [bp+110Ch]
  __useconds_t v8; // [sp+1120h] [bp+1110h]
  char *v9; // [sp+1124h] [bp+1114h]
  int v10; // [sp+1128h] [bp+1118h]
  __useconds_t v11; // [sp+112Ch] [bp+111Ch]

  v10 = a1;
  v9 = (char *)calloc(1u, 0x40u);
  snprintf(v9, 0x40u, "%.10s_%d", "get_response", *(_DWORD *)(v10 + 136));
  V_LOCK();
  v1 = syscall(224);
  logfmt_raw(v5, 0x1000u, 0, "%s on pid %ld", v9, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_base.c",
    72,
    "get_response",
    12,
    186,
    60,
    v5);
  prctl(15, v9);
  memset(v6, 0, sizeof(v6));
  v8 = 64;
  v11 = 64;
  while ( 1 )
  {
    v2 = dev_ctrl();
    v7 = ((int (__fastcall *)(_DWORD, char *, int))v2[13])(*(_DWORD *)(v10 + 136), v6, 256);
    if ( *(_BYTE *)(v10 + 685) )
      break;
    if ( v7 <= 0 )
    {
      usleep(v11);
      v11 *= 2;
      v3 = v11;
      if ( v11 >= 0x3E8 )
        v3 = 1000;
      v11 = v3;
    }
    else
    {
      queue_enqueue(*(_DWORD *)(v10 + 656), v6, v7);
      v11 = v8;
      memset(v6, 0, v7);
    }
  }
  *(_BYTE *)(v10 + 685) = 0;
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004AEB8) --------------------------------------------------------
int __fastcall backend_exit_base(int a1)
{
  _UNKNOWN **v1; // r0
  void *thread_return[2]; // [sp+Ch] [bp+Ch] BYREF

  *(_BYTE *)(a1 + 145) = 0;
  *(_BYTE *)(a1 + 146) = 0;
  *(_BYTE *)(a1 + 144) = 0;
  (*(void (__fastcall **)(int))(a1 + 48))(a1);
  if ( *(_DWORD *)(a1 + 72) )
    (*(void (__fastcall **)(int))(a1 + 72))(a1);
  *(_BYTE *)(a1 + 684) = 1;
  *(_BYTE *)(a1 + 685) = 1;
  *(_BYTE *)(a1 + 686) = 1;
  queue_force_wakeup(*(_DWORD *)(a1 + 656));
  queue_force_wakeup(*(_DWORD *)(a1 + 660));
  queue_force_wakeup(*(_DWORD *)(a1 + 664));
  queue_force_wakeup(*(_DWORD *)(a1 + 652));
  pthread_join(*(_DWORD *)(a1 + 676), thread_return);
  pthread_join(*(_DWORD *)(a1 + 672), thread_return);
  pthread_join(*(_DWORD *)(a1 + 680), thread_return);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 688));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 712));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 736));
  queue_free(*(_DWORD *)(a1 + 656));
  queue_free(*(_DWORD *)(a1 + 660));
  queue_free(*(_DWORD *)(a1 + 664));
  queue_free(*(_DWORD *)(a1 + 652));
  free(*(void **)(a1 + 296));
  free(*(void **)(a1 + 288));
  free(*(void **)(a1 + 292));
  free(*(void **)(a1 + 300));
  free(*(void **)(a1 + 264));
  if ( *(_DWORD *)(a1 + 648) )
    free(*(void **)(a1 + 324));
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 240) = -1;
  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(_DWORD *)(a1 + 668) = 0;
  v1 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v1[7])(*(_DWORD *)(a1 + 136));
  return 0;
}

//----- (0004B06C) --------------------------------------------------------
int __fastcall async_push_work_base(int a1, char *a2)
{
  queue_enqueue(*(_DWORD *)(a1 + 652), a2, 1);
  return 0;
}

//----- (0004B090) --------------------------------------------------------
int __fastcall push_work_base(int a1, int a2)
{
  _UNKNOWN **v3; // r0
  unsigned int v4; // r0
  _UNKNOWN **v5; // r0
  _BYTE v9[12]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned int v10; // [sp+101Ch] [bp+100Ch] BYREF
  int v11; // [sp+1020h] [bp+1010h]
  void *v12; // [sp+1024h] [bp+1014h]

  if ( *(_BYTE *)(a1 + 146) != 1 && *(_BYTE *)(a1 + 145) != 1 )
    return 4;
  v12 = calloc(1u, *(_DWORD *)(a1 + 640));
  v10 = 0;
  (*(void (__fastcall **)(int, int, void *, unsigned int *))(a1 + 56))(a1, a2, v12, &v10);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 736));
  do
  {
    v3 = dev_ctrl();
    v4 = ((int (__fastcall *)(_DWORD))v3[15])(*(_DWORD *)(a1 + 136));
  }
  while ( v4 < v10 );
  v5 = dev_ctrl();
  v11 = ((int (__fastcall *)(_DWORD, void *, unsigned int))v5[11])(*(_DWORD *)(a1 + 136), v12, v10);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 736));
  if ( v11 > 0 )
  {
    ++*(_QWORD *)(a1 + 248);
  }
  else
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "device %d push work failed,errcode %d", *(_DWORD *)(a1 + 136), v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_base.c",
      72,
      "push_work_base",
      14,
      284,
      100,
      v9);
  }
  free(v12);
  return 0;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004B274) --------------------------------------------------------
int __fastcall pop_ans_base(int a1, char *a2)
{
  queue_dequeue(*(_DWORD *)(*(_DWORD *)(a1 + 668) + 660), a2, 1u);
  return 0;
}

//----- (0004B29C) --------------------------------------------------------
int __fastcall try_pop_ans_base(int a1, char *a2)
{
  return queue_try_dequeue(*(_DWORD *)(*(_DWORD *)(a1 + 668) + 660), a2, 1u);
}

//----- (0004B2C4) --------------------------------------------------------
int __fastcall backend_init_base(int a1)
{
  _UNKNOWN **v1; // r0
  _UNKNOWN **v2; // r0
  _UNKNOWN **v3; // r0
  _UNKNOWN **v4; // r0
  int v5; // r3

  v1 = dev_ctrl();
  *(_DWORD *)(a1 + 140) = ((int (__fastcall *)(_DWORD))v1[10])(*(_DWORD *)(a1 + 136));
  v2 = dev_ctrl();
  ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v2[6])(
    *(_DWORD *)(a1 + 136),
    *(_DWORD *)(a1 + 764),
    *(_DWORD *)(a1 + 776));
  v3 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v3[9])(*(_DWORD *)(a1 + 136));
  v4 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v4[1])(*(_DWORD *)(a1 + 136));
  *(_DWORD *)(a1 + 656) = queue_new(1, 0);
  *(_DWORD *)(a1 + 660) = queue_new(*(_DWORD *)(a1 + 632), 0);
  *(_DWORD *)(a1 + 664) = queue_new(1, 0);
  *(_DWORD *)(a1 + 652) = queue_new(*(_DWORD *)(a1 + 628), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 688), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 712), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 736), 0);
  *(_DWORD *)(a1 + 296) = calloc(*(_DWORD *)(a1 + 196), 1u);
  *(_DWORD *)(a1 + 288) = calloc(*(_DWORD *)(a1 + 196), 4u);
  *(_DWORD *)(a1 + 292) = calloc(*(_DWORD *)(a1 + 196), 2 * *(_DWORD *)(a1 + 636));
  v5 = *(_DWORD *)(a1 + 196) + 31;
  if ( v5 < 0 )
    v5 = *(_DWORD *)(a1 + 196) + 62;
  *(_DWORD *)(a1 + 300) = calloc(v5 >> 5, 4u);
  *(_DWORD *)(a1 + 264) = calloc(*(_DWORD *)(a1 + 196), 0x30u);
  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(_DWORD *)(a1 + 240) = -1;
  *(_BYTE *)(a1 + 268) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  *(_DWORD *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( *(_DWORD *)(a1 + 648) )
    *(_DWORD *)(a1 + 324) = calloc(*(_DWORD *)(a1 + 196), *(_DWORD *)(a1 + 648));
  *(_DWORD *)(a1 + 328) = 0;
  memset((void *)(a1 + 368), 0, 0x100u);
  *(_BYTE *)(a1 + 684) = 0;
  *(_BYTE *)(a1 + 685) = 0;
  *(_BYTE *)(a1 + 686) = 0;
  if ( !*(_DWORD *)(a1 + 668) )
    *(_DWORD *)(a1 + 668) = a1;
  if ( *(_DWORD *)(a1 + 68) )
    (*(void (__fastcall **)(int))(a1 + 68))(a1);
  pthread_create((pthread_t *)(a1 + 676), 0, (void *(*)(void *))get_response, (void *)a1);
  pthread_create((pthread_t *)(a1 + 672), 0, (void *(*)(void *))scanhash, (void *)a1);
  pthread_create((pthread_t *)(a1 + 680), 0, (void *(*)(void *))send_work, (void *)a1);
  *(_BYTE *)(a1 + 144) = 1;
  return 0;
}

//----- (0004B558) --------------------------------------------------------
int __fastcall start_mining_base(int a1)
{
  _UNKNOWN **v1; // r0

  (*(void (__fastcall **)(int))(a1 + 48))(a1);
  v1 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v1[9])(*(_DWORD *)(a1 + 136));
  queue_clear(*(_DWORD *)(a1 + 656));
  *(_BYTE *)(a1 + 145) = 1;
  (*(void (__fastcall **)(int))(a1 + 52))(a1);
  *(_BYTE *)(a1 + 146) = 1;
  return 0;
}

//----- (0004B5A8) --------------------------------------------------------
int __fastcall stop_mining_base(int a1)
{
  _UNKNOWN **v1; // r0

  (*(void (__fastcall **)(int))(a1 + 48))(a1);
  v1 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v1[9])(*(_DWORD *)(a1 + 136));
  *(_BYTE *)(a1 + 145) = 0;
  *(_BYTE *)(a1 + 146) = 0;
  return 0;
}

//----- (0004B5E4) --------------------------------------------------------
int __fastcall reset_mining_base(int a1)
{
  __int64 v1; // r0
  int v2; // r2
  int v3; // r2
  _UNKNOWN **v4; // r0
  _UNKNOWN **v5; // r0
  _UNKNOWN **v6; // r0
  _UNKNOWN **v7; // r0
  _UNKNOWN **v8; // r0
  _UNKNOWN **v9; // r0
  int v10; // r3
  int v12; // [sp+14h] [bp+4h]
  _BYTE v13[4100]; // [sp+18h] [bp+8h] BYREF

  v12 = a1;
  V_LOCK();
  logfmt_raw(v13, 0x1000u, 0, "chain %d reset mining!", *(_DWORD *)(v12 + 140));
  V_UNLOCK();
  v1 = zlog(
         g_zc,
         "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_base.c",
         72,
         "reset_mining_base",
         17,
         387,
         100,
         v13);
  (*(void (__fastcall **)(int, _DWORD))(v12 + 8))(v12, HIDWORD(v1));
  *(_BYTE *)(v12 + 145) = 0;
  *(_BYTE *)(v12 + 146) = 0;
  v2 = v12;
  *(_DWORD *)(v12 + 248) = 0;
  *(_DWORD *)(v2 + 252) = 0;
  v3 = v12 + 256;
  *(_DWORD *)(v12 + 256) = 0;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v12 + 328) = 0;
  memset(*(void **)(v12 + 324), 0, *(_DWORD *)(v12 + 648) * *(_DWORD *)(v12 + 196));
  v4 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v4[7])(*(_DWORD *)(v12 + 136));
  sleep(0xAu);
  v5 = dev_ctrl();
  ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v5[6])(
    *(_DWORD *)(v12 + 136),
    *(_DWORD *)(v12 + 764),
    *(_DWORD *)(v12 + 776));
  sleep(1u);
  v6 = dev_ctrl();
  ((void (__fastcall *)(int))v6[4])(115200);
  usleep(0x2710u);
  (*(void (__fastcall **)(int, char *))(v12 + 76))(v12, byte_2FAF08);
  usleep(0x2710u);
  v7 = dev_ctrl();
  ((void (__fastcall *)(char *))v7[4])(byte_2FAF08);
  usleep(0x2710u);
  v8 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v8[9])(*(_DWORD *)(v12 + 136));
  v9 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v9[1])(*(_DWORD *)(v12 + 136));
  (*(void (__fastcall **)(int))(v12 + 4))(v12);
  return v10;
}
// 4B7E0: variable 'v10' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004B7EC) --------------------------------------------------------
_DWORD *__fastcall runtime_ctrl(int a1)
{
  _DWORD *v3; // [sp+Ch] [bp+Ch]

  switch ( a1 )
  {
    case 1:
      v3 = runtime_ctrl_vbk();
      break;
    case 2:
      v3 = runtime_ctrl_ckb();
      break;
    case 3:
      v3 = runtime_ctrl_ae();
      break;
    case 4:
      v3 = runtime_ctrl_grin32();
      break;
    case 5:
      v3 = runtime_ctrl_eth();
      break;
    case 6:
      v3 = runtime_ctrl_ltc();
      break;
    case 7:
      v3 = runtime_ctrl_dash();
      break;
    case 8:
      v3 = runtime_ctrl_ckb2();
      break;
    case 9:
      v3 = runtime_ctrl_dcr();
      break;
    default:
      v3 = runtime_ctrl_grin29();
      break;
  }
  if ( v3 )
  {
    pthread_mutex_lock(&stru_47A2B0);
    v3[58] = a1;
    dword_479EAC[dword_47A2AC] = v3;
    v3[34] = dword_47A2AC++;
    pthread_mutex_unlock(&stru_47A2B0);
  }
  return v3;
}
// 479EAC: using guessed type _DWORD dword_479EAC[256];
// 47A2AC: using guessed type int dword_47A2AC;
// 47A2B0: using guessed type pthread_mutex_t stru_47A2B0;

//----- (0004B8F4) --------------------------------------------------------
int query_device_num()
{
  int (**v0)(void); // r0

  v0 = (int (**)(void))dev_ctrl();
  return (*v0)();
}

//----- (0004B908) --------------------------------------------------------
int __fastcall redirect_nonce_output(int result, int a2)
{
  while ( *(_DWORD *)(result + 668) != result && *(_DWORD *)(result + 668) )
    *(_DWORD *)(result + 668) = result;
  *(_DWORD *)(a2 + 668) = result;
  return result;
}

//----- (0004B948) --------------------------------------------------------
void *__fastcall get_all_created_runtime(_DWORD *a1)
{
  pthread_mutex_lock(&stru_47A2B0);
  *a1 = dword_47A2AC;
  pthread_mutex_unlock(&stru_47A2B0);
  return &unk_479EAC;
}
// 47A2AC: using guessed type int dword_47A2AC;
// 47A2B0: using guessed type pthread_mutex_t stru_47A2B0;

//----- (0004B98C) --------------------------------------------------------
int check_and_destroy_abnormal_runtime()
{
  _BYTE v1[8]; // [sp+10h] [bp+0h] BYREF
  _DWORD s[256]; // [sp+1010h] [bp+1000h] BYREF
  int v3; // [sp+1410h] [bp+1400h]
  int i; // [sp+1414h] [bp+1404h]

  i = 0;
  memset(s, 0, sizeof(s));
  v3 = 0;
  pthread_mutex_lock(&stru_47A2B0);
  for ( i = 0; i < dword_47A2AC; ++i )
  {
    if ( *(_DWORD *)(dword_479EAC[i] + 236) == *(_DWORD *)(dword_479EAC[i] + 196) )
    {
      s[v3++] = dword_479EAC[i];
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v1,
        0x1000u,
        0,
        "chain %d runtime check asic number error, destroy it!",
        *(_DWORD *)(dword_479EAC[i] + 140));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_interface.c",
        77,
        "check_and_destroy_abnormal_runtime",
        34,
        131,
        80,
        v1);
      (*(void (__fastcall **)(_DWORD))(dword_479EAC[i] + 8))(dword_479EAC[i]);
      (*(void (__fastcall **)(_DWORD))(dword_479EAC[i] + 16))(dword_479EAC[i]);
      free((void *)dword_479EAC[i]);
      dword_479EAC[i] = 0;
    }
  }
  for ( i = 0; i < v3; ++i )
    dword_479EAC[i] = s[i];
  dword_47A2AC = v3;
  return pthread_mutex_unlock(&stru_47A2B0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 479EAC: using guessed type _DWORD dword_479EAC[256];
// 47A2AC: using guessed type int dword_47A2AC;
// 47A2B0: using guessed type pthread_mutex_t stru_47A2B0;
// 47BE18: using guessed type int g_zc;

//----- (0004BC04) --------------------------------------------------------
_UNKNOWN **dev_ctrl()
{
  return dev_ctrl_hal();
}

//----- (0004BC18) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4BC18(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (0004BC3C) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_4BC3C(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0004BC64) --------------------------------------------------------
int __fastcall sub_4BC64(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 4BCA8: variable 'v3' is possibly undefined

//----- (0004BD44) --------------------------------------------------------
int __fastcall sub_4BD44(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004BE48) --------------------------------------------------------
int __fastcall sub_4BE48(unsigned __int8 *a1)
{
  return (*a1 << 24) + a1[3] + (a1[2] << 8) + (a1[1] << 16);
}

//----- (0004BE84) --------------------------------------------------------
_BYTE *__fastcall sub_4BE84(_BYTE *result, int a2, int a3, int a4)
{
  result[7] = a3;
  result[6] = BYTE1(a3);
  result[5] = BYTE2(a3);
  result[4] = HIBYTE(a3);
  result[3] = a4;
  result[2] = BYTE1(a4);
  result[1] = BYTE2(a4);
  *result = HIBYTE(a4);
  return result;
}

//----- (0004BF44) --------------------------------------------------------
_BYTE *__fastcall sub_4BF44(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (0004BF8C) --------------------------------------------------------
int __fastcall sub_4BF8C(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_GRIN32", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_GRIN32",
    27,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_4BC3C((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_GRIN32",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_GRIN32",
    27,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_GRIN32",
      27,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_GRIN32",
          27,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_4BC3C((int)v12, *(int *)(a1 + 140));
    sub_4BC18(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_GRIN32",
      27,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 4C0E4: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004C574) --------------------------------------------------------
int __fastcall sub_4C574(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_GRIN32", 32);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_GRIN32",
    33,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 2097153;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004C668) --------------------------------------------------------
int __fastcall sub_4C668(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_GRIN32", 32);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_GRIN32",
    42,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 32;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004C778) --------------------------------------------------------
int __fastcall sub_4C778(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_GRIN32", 20, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_ticket_mask_GRIN32",
    30,
    137,
    20,
    v5);
  v6[2] = 1310721;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004C89C) --------------------------------------------------------
int __fastcall sub_4C89C(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_GRIN32",
    23,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004CB30) --------------------------------------------------------
int __fastcall sub_4CB30(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_GRIN32",
    27,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004CD54) --------------------------------------------------------
unsigned int *__fastcall sub_4CD54(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 4CD8C: variable 'v1' is possibly undefined

//----- (0004CE64) --------------------------------------------------------
int __fastcall sub_4CE64(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 786433;
  sub_4CD54(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_GRIN32",
    23,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 4CEE4: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004CFB8) --------------------------------------------------------
int __fastcall sub_4CFB8(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 12;
  sub_4CD54(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_GRIN32",
    32,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 4D05A: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004D138) --------------------------------------------------------
int __fastcall sub_4D138(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_GRIN32", 1, 8, 20000);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_open_cores_GRIN32",
    29,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 524289;
  v8[0] = a3;
  BYTE1(v8[3]) = 1;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v8, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004D264) --------------------------------------------------------
int __fastcall sub_4D264(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_GRIN32");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_close_cores_GRIN32",
    30,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 524289;
  v6[0] = 0;
  BYTE1(v6[3]) = 1;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v6, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004D374) --------------------------------------------------------
int __fastcall sub_4D374(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_GRIN32",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_start_nonce_offset_GRIN32",
    37,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_4BC3C((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_GRIN32",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_start_nonce_offset_GRIN32",
        37,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 4D4D4: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004D664) --------------------------------------------------------
int __fastcall sub_4D664(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  char v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_GRIN32", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_pmdata_GRIN32",
    25,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 60;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_GRIN32", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_pmdata_GRIN32",
        25,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 60 )
        {
          v12 = 60;
          v5 = 0;
          sub_4BF44(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_4BC3C((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_GRIN32",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_pmdata_GRIN32",
            25,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 60 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004DAC8) --------------------------------------------------------
int __fastcall sub_4DAC8(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_GRIN32", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_GRIN32",
    28,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 108;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 108 )
        {
          sub_4BF44(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_4BC3C((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_GRIN32",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_GRIN32",
            28,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_GRIN32", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_GRIN32",
      28,
      436,
      100,
      v5);
    return -1;
  }
}
// 4DCD6: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004DEB4) --------------------------------------------------------
int __fastcall sub_4DEB4(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4194305;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_GRIN32",
    29,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004DFD0) --------------------------------------------------------
int __fastcall sub_4DFD0(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 56;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (0004E01C) --------------------------------------------------------
int __fastcall sub_4E01C(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 56;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (0004E13C) --------------------------------------------------------
int __fastcall sub_4E13C(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_4DFD0(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_4E01C(a1, a2, a3, s, a6, n);
}

//----- (0004E1B0) --------------------------------------------------------
int __fastcall sub_4E1B0(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_4E13C(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0004E254) --------------------------------------------------------
int __fastcall sub_4E254(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_4E13C(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0004E2F8) --------------------------------------------------------
int __fastcall sub_4E2F8(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_4E13C(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (0004E35C) --------------------------------------------------------
int __fastcall sub_4E35C(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_4E13C(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (0004E3C0) --------------------------------------------------------
int __fastcall sub_4E3C0(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_GRIN32",
        48,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_GRIN32",
      48,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004E598) --------------------------------------------------------
int __fastcall sub_4E598(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_GRIN32",
        49,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_GRIN32",
      49,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004E774) --------------------------------------------------------
int __fastcall sub_4E774(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_4DFD0(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0004E7AC) --------------------------------------------------------
int __fastcall sub_4E7AC(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0004E800) --------------------------------------------------------
int __fastcall sub_4E800(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 52;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 52 )
    {
      V_LOCK();
      sub_4BC3C((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_GRIN32",
        33,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004EACC) --------------------------------------------------------
int __fastcall sub_4EACC(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (0004EB58) --------------------------------------------------------
unsigned int __fastcall sub_4EB58(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0xCu);
  memset(v13, 0, 0xCu);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 1, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_4BC3C((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_GRIN32",
        34,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004EE04) --------------------------------------------------------
int __fastcall sub_4EE04(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (0004EE4C) --------------------------------------------------------
int __fastcall sub_4EE4C(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0004EEA4) --------------------------------------------------------
int __fastcall sub_4EEA4(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0004EF04) --------------------------------------------------------
int __fastcall sub_4EF04(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0004EF68) --------------------------------------------------------
int __fastcall sub_4EF68(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0004EFC4) --------------------------------------------------------
int __fastcall sub_4EFC4(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_GRIN32", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_GRIN32",
    34,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_4BC3C((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_GRIN32",
      34,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 4F17E: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004F340) --------------------------------------------------------
int __fastcall sub_4F340(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 1;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_GRIN32", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_GRIN32",
    46,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_4BC3C((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_GRIN32",
      46,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 4F4F0: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004F6B8) --------------------------------------------------------
int __fastcall sub_4F6B8(_DWORD *a1)
{
  int v3; // [sp+24h] [bp+Ch] BYREF
  unsigned int i; // [sp+1024h] [bp+100Ch]

  V_LOCK();
  logfmt_raw(
    &v3,
    0x1000u,
    0,
    "grin32 dump work poolid %ld jobid %lu start_nonce %lu",
    *a1,
    a1[1],
    a1[2],
    a1[3],
    *(_DWORD *)((char *)a1 + 254),
    *(_DWORD *)((char *)a1 + 258));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin32/backend_grin32.c",
    89,
    "dump_work",
    9,
    71,
    60,
    &v3);
  for ( i = 0; i <= 0xED; ++i )
    printf("%02x ", *((unsigned __int8 *)a1 + i + 16));
  return putchar(10);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004F7BC) --------------------------------------------------------
int __fastcall sub_4F7BC(int a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  printf("work: ");
  for ( i = 0; i <= 0xFC; ++i )
    printf("%02x ", *(unsigned __int8 *)(i + a1));
  return putchar(10);
}

//----- (0004F80C) --------------------------------------------------------
int __fastcall work_2_packet_grin32(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int v4; // r4
  _DWORD *v5; // r2
  int v6; // r4
  _DWORD *v7; // r2
  int v8; // r4
  _DWORD *v9; // r2
  int v10; // r4
  _DWORD *v11; // r2
  unsigned __int16 v12; // r0
  int v15; // [sp+14h] [bp+14h]

  v15 = *(_DWORD *)(a1 + 624);
  *(_BYTE *)a3 = 85;
  *(_BYTE *)(a3 + 1) = -86;
  *(_BYTE *)(a3 + 2) = 33;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    *(_BYTE *)(a3 + 2) |= 0x10u;
  *(_BYTE *)(a3 + 4) = 0;
  v4 = a2[3];
  v5 = (_DWORD *)(8 * (*(unsigned __int8 *)(v15 + 57088) + 128) + v15);
  *v5 = a2[2];
  v5[1] = v4;
  v6 = a2[1];
  v7 = (_DWORD *)(8 * *(unsigned __int8 *)(v15 + 57088) + v15);
  *v7 = *a2;
  v7[1] = v6;
  memcpy((void *)(a3 + 5), a2 + 4, 0xEEu);
  sub_4BE84((_BYTE *)(a3 + 243), a3 + 243, *(_DWORD *)((char *)a2 + 254), *(_DWORD *)((char *)a2 + 258));
  v8 = *(_DWORD *)((char *)a2 + 258);
  v9 = (_DWORD *)(8 * (*(unsigned __int8 *)(v15 + 57088) + 256) + v15);
  *v9 = 0;
  v9[1] = v8;
  memcpy((void *)(v15 + 246 * *(unsigned __int8 *)(v15 + 57088) + 4096), a2 + 4, 0xF6u);
  v10 = *(_DWORD *)((char *)a2 + 266);
  v11 = (_DWORD *)(8 * (*(unsigned __int8 *)(v15 + 57088) + 384) + v15);
  *v11 = *(_DWORD *)((char *)a2 + 262);
  v11[1] = v10;
  *(_BYTE *)(a3 + 3) = (*(_BYTE *)(v15 + 57088))++;
  if ( *(char *)(v15 + 57088) < 0 )
    *(_BYTE *)(v15 + 57088) = 0;
  v12 = CRC16_v1((const unsigned __int8 *)(a3 + 2), 249);
  *(_BYTE *)(a3 + 251) = HIBYTE(v12);
  *(_BYTE *)(a3 + 252) = v12;
  *a4 = 253;
  return 0;
}

//----- (0004F9A4) --------------------------------------------------------
int __fastcall sub_4F9A4(int a1, int a2)
{
  int v5; // [sp+10h] [bp+8h]
  unsigned int i; // [sp+14h] [bp+Ch]

  v5 = a2 + 35;
  printf("nonce wc %d\n", *(unsigned __int8 *)(a2 + 16));
  printf("nonce: %llx\n", *(_QWORD *)(a2 + 25));
  printf(
    "chain %d asic %d core %d addr_interval %d\n",
    *(_DWORD *)(a1 + 136),
    *(_DWORD *)(a2 + 8),
    *(_DWORD *)(a2 + 12),
    *(_DWORD *)(a1 + 240));
  printf("order len %d, order: ", *(unsigned __int16 *)(a2 + 33));
  for ( i = 0; *(unsigned __int16 *)(a2 + 33) > i; ++i )
    printf("%02x ", *(unsigned __int8 *)(i + v5));
  return putchar(10);
}

//----- (0004FA5C) --------------------------------------------------------
int __fastcall packet_2_nonce_grin32(int a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  int *v8; // r3
  int v9; // r8
  int v10; // r9
  int v11; // r0
  int *v12; // r1
  int *v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r1
  int v17; // r3
  int v18; // r3
  _DWORD *v19; // r1
  int *v20; // r1
  int v21; // r2
  int v22; // r3
  int v23; // r1
  int *v24; // r1
  int v25; // r2
  int v26; // r3
  int v27; // r1
  _BYTE v32[4080]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 v33; // [sp+1023h] [bp+1013h]
  int v34; // [sp+1024h] [bp+1014h]
  unsigned __int16 v35; // [sp+1028h] [bp+1018h]
  unsigned __int16 v36; // [sp+102Ah] [bp+101Ah]
  int v37; // [sp+102Ch] [bp+101Ch]
  _BYTE *v38; // [sp+1030h] [bp+1020h]
  unsigned __int8 v39; // [sp+1036h] [bp+1026h]
  unsigned __int8 v40; // [sp+1037h] [bp+1027h]
  int v41; // [sp+1038h] [bp+1028h]
  unsigned int i; // [sp+103Ch] [bp+102Ch]

  v41 = a3;
  v40 = 0;
  v39 = 0;
  if ( *(_BYTE *)(a2 + 2) != 33 )
    return 1;
  v38 = (_BYTE *)a2;
  v37 = 175;
  v36 = CRC16_v1((const unsigned __int8 *)(a2 + 2), 175);
  v35 = _byteswap_ushort(*(_WORD *)(a2 + 177));
  if ( v36 == v35 )
  {
    v34 = *(_DWORD *)(a1 + 624);
    v33 = v38[3];
    v8 = (int *)(8 * (v33 + 256) + v34);
    v9 = *v8;
    v10 = v8[1];
    v11 = sub_4BE48(v38 + 5);
    v12 = (int *)(8 * (v33 + 256) + v34);
    *v12 = v11 | v9;
    v12[1] = v10;
    v13 = (int *)(v34 + 8 * (v33 + 256));
    v14 = *v13;
    v15 = v13[1];
    v16 = v41 + 25;
    *(_DWORD *)(v41 + 25) = v14;
    *(_DWORD *)(v16 + 4) = v15;
    memcpy((void *)(v34 + 168 * v33 + 35584), v38 + 9, 0xA8u);
    for ( i = 0; i <= 0xA7; i += 4 )
    {
      v17 = i;
      *(_DWORD *)(4 * ((v17 >> 2) + 8) + v41 + 3) = sub_4BE48((unsigned __int8 *)(i + 168 * v33 + 35584 + v34));
    }
    v18 = *(_DWORD *)(v34 + 8 * (v33 + 256) + 4);
    v19 = (_DWORD *)(8 * (v33 + 256) + v34);
    *v19 = 0;
    v19[1] = v18;
    memset((void *)(168 * v33 + 35584 + v34), 0, 0xA8u);
    *(_BYTE *)(v41 + 16) = v33;
    v20 = (int *)(v34 + 8 * (v33 + 128));
    v21 = *v20;
    v22 = v20[1];
    v23 = v41 + 17;
    *(_DWORD *)(v41 + 17) = v21;
    *(_DWORD *)(v23 + 4) = v22;
    v24 = (int *)(v34 + 8 * v33);
    v25 = *v24;
    v26 = v24[1];
    v27 = v41;
    *(_DWORD *)v41 = v25;
    *(_DWORD *)(v27 + 4) = v26;
    *a7 = *(_DWORD *)(v34 + 8 * v33);
    v39 = *(_DWORD *)(v41 + 25) & 1;
    v40 = sub_1A3E94((unsigned __int8)HIBYTE(*(_DWORD *)(v41 + 25)), *(unsigned int *)(a1 + 240));
    *(_DWORD *)(v41 + 8) = v40;
    *(_DWORD *)(v41 + 12) = v39;
    *a6 = v40;
    memcpy(a5, (const void *)(v41 + 25), 8u);
    *a4 = 0;
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v32, 0x1000u, 0, "get nonce crc error calc value %04x resp value %04x", v36, v35);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin32/backend_grin32.c",
      89,
      "packet_2_nonce_grin32",
      21,
      167,
      20,
      v32);
    return 2;
  }
}
// 4FCB6: conditional instruction was optimized away because %0x103C.4<A8u
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0004FF2C) --------------------------------------------------------
int __fastcall sub_4FF2C(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (0004FF7C) --------------------------------------------------------
int __fastcall sub_4FF7C(int a1, unsigned __int8 a2)
{
  _BYTE v6[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v7[4]; // [sp+1018h] [bp+1008h] BYREF
  int v8; // [sp+1028h] [bp+1018h]
  int i; // [sp+102Ch] [bp+101Ch]

  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = a2;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "%s chip_addr %02x reg %02x", "open_33p_double_results_grin32", a2, 2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin32/backend_grin32.c",
    89,
    "open_33p_double_results_grin32",
    30,
    227,
    60,
    v6);
  for ( i = 0; i <= 0; ++i )
  {
    HIWORD(v7[2]) = 2;
    LOBYTE(v7[3]) = -1;
    v7[0] = 1;
    v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v7);
    if ( v8 < 0 )
    {
      printf("%s failed, reg:%02x, core_id:%d", "open_33p_double_results_grin32", HIWORD(v7[2]), i);
      return -1;
    }
    usleep(0x4E20u);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00050108) --------------------------------------------------------
int __fastcall sub_50108(int a1, unsigned __int8 a2)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; a2 > i; ++i )
  {
    if ( (i & 1) != 0 )
    {
      sub_4FF7C(a1, *(_BYTE *)(i + *(_DWORD *)(a1 + 296)));
      usleep(0x4E20u);
    }
  }
  return 0;
}

//----- (00050158) --------------------------------------------------------
int __fastcall sub_50158(int a1, unsigned __int8 a2)
{
  _BYTE v6[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v7[4]; // [sp+1018h] [bp+1008h] BYREF
  int v8; // [sp+1028h] [bp+1018h]
  int i; // [sp+102Ch] [bp+101Ch]

  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = a2;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "%s chip_addr %02x reg %02x", "set_3p_timenout_cycle_grin32", a2, 177);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin32/backend_grin32.c",
    89,
    "set_3p_timenout_cycle_grin32",
    28,
    262,
    60,
    v6);
  for ( i = 0; i <= 0; ++i )
  {
    HIWORD(v7[2]) = 177;
    LOBYTE(v7[3]) = -1;
    v7[0] = 60000000;
    v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v7);
    if ( v8 < 0 )
    {
      printf("%s failed, reg:%02x, core_id:%d\n", "set_3p_timenout_cycle_grin32", HIWORD(v7[2]), i);
      return -1;
    }
    usleep(0x4E20u);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000502EC) --------------------------------------------------------
int __fastcall sub_502EC(int a1, unsigned __int8 a2)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; a2 > i; ++i )
  {
    if ( (i & 1) == 0 )
    {
      sub_50158(a1, *(_BYTE *)(i + *(_DWORD *)(a1 + 296)));
      usleep(0x4E20u);
    }
  }
  return 0;
}

//----- (0005033C) --------------------------------------------------------
int __fastcall enable_core_clk(int a1)
{
  _DWORD s[4]; // [sp+8h] [bp+8h] BYREF

  memset(s, 0, sizeof(s));
  s[2] = 1441793;
  s[0] = -2147483647;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
}

//----- (00050380) --------------------------------------------------------
int __fastcall setup_all_chip_grin32(int a1)
{
  puts("setup_all_chip_grin32");
  *(_DWORD *)(a1 + 240) = sub_4FF2C(*(_DWORD *)(a1 + 296), 1u);
  (*(void (__fastcall **)(int, _DWORD, int))(a1 + 148))(a1, *(_DWORD *)(a1 + 296), 1);
  sub_4BF8C(a1, 1);
  enable_core_clk(a1);
  sub_4D138(a1, 16, 1);
  if ( *(_BYTE *)(a1 + 268) != 1 )
    *(_DWORD *)(a1 + 272) = (int)*(float *)(a1 + 760);
  return 0;
}

//----- (0005040C) --------------------------------------------------------
int __fastcall global_idx_init_grin32(int a1)
{
  int v1; // r3
  void *s; // [sp+Ch] [bp+Ch]

  s = malloc(0xDF01u);
  memset(s, 0, 0xDF01u);
  *(_DWORD *)(a1 + 624) = s;
  printf("__custom_data init %p\n", s);
  return v1;
}
// 50444: variable 'v1' is possibly undefined

//----- (0005044C) --------------------------------------------------------
int __fastcall global_idx_free_grin32(int a1)
{
  int v1; // r3

  v1 = *(_DWORD *)(a1 + 624);
  if ( v1 )
    free(*(void **)(a1 + 624));
  return v1;
}
// 5046C: variable 'v1' is possibly undefined

//----- (00050474) --------------------------------------------------------
int __fastcall set_baud_grin32(int a1, char *a2)
{
  return sub_4C89C(a1, a2);
}

//----- (00050490) --------------------------------------------------------
int __fastcall sub_50490(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (000504B0) --------------------------------------------------------
int __fastcall sub_504B0(int a1, int a2, _DWORD *a3, int a4, int a5, int a6)
{
  int v10; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v11[28]; // [sp+24h] [bp+14h] BYREF
  struct timeval v12; // [sp+1024h] [bp+1014h] BYREF
  struct timeval v13; // [sp+102Ch] [bp+101Ch] BYREF
  _DWORD *v14; // [sp+1034h] [bp+1024h]
  __int64 v15; // [sp+1038h] [bp+1028h]
  __int64 v16; // [sp+1040h] [bp+1030h]
  void (__fastcall **v17)(_DWORD); // [sp+104Ch] [bp+103Ch]
  int k; // [sp+1050h] [bp+1040h]
  int j; // [sp+1054h] [bp+1044h]
  int i; // [sp+1058h] [bp+1048h]
  int v21; // [sp+105Ch] [bp+104Ch]

  v10 = a1;
  v21 = 0;
  gettimeofday(&v13, 0);
  v17 = (void (__fastcall **)(_DWORD))new_graph32(32, 25);
  (*((void (__fastcall **)(void (__fastcall *)(_DWORD), int, int, int *, int, int, int, _DWORD))v17[23] + 18))(
    v17[23],
    v10,
    a2,
    &v10,
    a5,
    a6,
    21,
    0);
  for ( i = 0; a4 / 4 > i; ++i )
  {
    v16 = ((__int64 (__fastcall *)(void (__fastcall **)(_DWORD), _DWORD, _DWORD))v17[29])(v17, a3[i], 0);
    v15 = ((__int64 (__fastcall *)(void (__fastcall **)(_DWORD), _DWORD, int))v17[29])(v17, a3[i], 1);
    ((void (__fastcall *)(void (__fastcall **)(_DWORD), _DWORD, _DWORD))v17[27])(v17, v15, v16);
  }
  v14 = (_DWORD *)((int (__fastcall *)(_DWORD))v17[28])(v17);
  if ( v14 )
  {
    for ( j = 0; *v14 > j; ++j )
    {
      for ( k = 0; k <= 41; ++k )
        a3[k] = a3[*(_DWORD *)(4 * k + v14[1] + 172 * j + 4)];
      qsort(a3, 0x2Au, 4u, (__compar_fn_t)sub_50490);
      v21 = *(_DWORD *)(172 * j + v14[1]);
    }
  }
  else
  {
    v21 = 0;
  }
  free_graph32(v17);
  gettimeofday(&v12, 0);
  V_LOCK();
  logfmt_raw(
    v11,
    0x1000u,
    0,
    "%s, nsols: %d, time: %ld us",
    "findcycle_grin32",
    *v14,
    1000000 * v12.tv_sec + v12.tv_usec - 1000000 * v13.tv_sec - v13.tv_usec);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin32/backend_grin32.c",
    89,
    "findcycle_grin32",
    16,
    378,
    20,
    v11);
  return v21;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00050854) --------------------------------------------------------
int __fastcall check_nonce_grin32(int a1, int a2)
{
  unsigned int *v3; // r2
  unsigned int v4; // r4
  int v6; // [sp+24h] [bp-1Ch]
  _BYTE v9[24]; // [sp+48h] [bp+8h] BYREF
  unsigned __int64 v10; // [sp+1048h] [bp+1008h] BYREF
  _QWORD v11[4]; // [sp+1050h] [bp+1010h] BYREF
  _BYTE v12[168]; // [sp+1070h] [bp+1030h] BYREF
  _BYTE v13[248]; // [sp+1118h] [bp+10D8h] BYREF
  _DWORD v14[7]; // [sp+1210h] [bp+11D0h] BYREF
  int v15; // [sp+122Ch] [bp+11ECh]
  _DWORD v16[7]; // [sp+1230h] [bp+11F0h] BYREF
  int v17; // [sp+124Ch] [bp+120Ch]
  unsigned int v18; // [sp+1250h] [bp+1210h]
  int v19; // [sp+1254h] [bp+1214h]
  unsigned int v20; // [sp+125Ch] [bp+121Ch]
  unsigned int v21; // [sp+1260h] [bp+1220h]
  int v22; // [sp+1264h] [bp+1224h]
  unsigned int v23; // [sp+1268h] [bp+1228h]
  unsigned __int8 v24; // [sp+126Fh] [bp+122Fh]
  int v25; // [sp+1270h] [bp+1230h]
  int v26; // [sp+1274h] [bp+1234h]
  unsigned int j; // [sp+1278h] [bp+1238h]
  unsigned int i; // [sp+127Ch] [bp+123Ch]

  memset(v13, 0, 0xF6u);
  v26 = a2;
  v25 = *(_DWORD *)(a1 + 624);
  memcpy(v13, (const void *)(246 * *(unsigned __int8 *)(a2 + 16) + 4096 + v25), 0xF6u);
  v24 = sub_504B0(
          (int)v13,
          246,
          (_DWORD *)(v26 + 35),
          *(unsigned __int16 *)(v26 + 33),
          *(_DWORD *)(v26 + 25),
          *(_DWORD *)(v26 + 29));
  V_LOCK();
  sub_4BC3C((int)v14, *(int *)(a1 + 140));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v15,
    v14[0],
    v14[1],
    v14[2],
    v14[3],
    v14[4],
    v14[5],
    v14[6],
    v15,
    "nonce %llx wc %d sols_len %d cycle len (%d/42)",
    v6,
    *(_DWORD *)(v26 + 25),
    *(_DWORD *)(v26 + 29),
    *(unsigned __int8 *)(v26 + 16),
    *(unsigned __int16 *)(v26 + 33),
    v24);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin32/backend_grin32.c",
    89,
    "check_nonce_grin32",
    18,
    392,
    20,
    v9);
  if ( v24 == 42 )
  {
    memset(v11, 0, sizeof(v11));
    memset(v12, 0, sizeof(v12));
    v23 = 32;
    v22 = -1;
    for ( i = 0; i <= 0x29; ++i )
    {
      v21 = v22 & *(_DWORD *)(4 * (i + 8) + v26 + 3);
      for ( j = 0; j < v23; ++j )
      {
        v20 = j + v23 * i;
        if ( ((v21 >> j) & 1) != 0 )
          v12[v20 >> 3] |= 1 << (v20 & 7);
      }
    }
    blake2b(v11, (int)v12, 0xA8u);
    v10 = v11[0];
    sub_4BE84(&v10, (int)&v10, v11[0], SHIDWORD(v11[0]));
    v3 = (unsigned int *)(v25 + 8 * (*(unsigned __int8 *)(v26 + 16) + 384));
    v4 = v3[1];
    v18 = *v3;
    v19 = v4;
    if ( __PAIR64__(v4, v18) >= v10 )
    {
      return 0;
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "nonce %016llx hw target (%016llx:%016llx) not reach pool",
        *(_DWORD *)(v26 + 25),
        *(_DWORD *)(v26 + 29),
        v10,
        v18,
        v19);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin32/backend_grin32.c",
        89,
        "check_nonce_grin32",
        18,
        420,
        20,
        v9);
      return 1;
    }
  }
  else
  {
    V_LOCK();
    sub_4BC3C((int)v16, *(int *)(a1 + 140));
    logfmt_raw(
      v9,
      0x1000u,
      0,
      v17,
      v16[0],
      v16[1],
      v16[2],
      v16[3],
      v16[4],
      v16[5],
      v16[6],
      v17,
      "wc %d error_nonce",
      *(unsigned __int8 *)(v26 + 16));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin32/backend_grin32.c",
      89,
      "check_nonce_grin32",
      18,
      394,
      20,
      v9);
    return 2;
  }
}
// 509C8: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00050D88) --------------------------------------------------------
int get_chip_status_grin32()
{
  return 0;
}

//----- (00050DA4) --------------------------------------------------------
int get_algo_type_grin32()
{
  return 0;
}

//----- (00050DC0) --------------------------------------------------------
int softreset_all_chip_grin32()
{
  return 0;
}

//----- (00050DD8) --------------------------------------------------------
int __fastcall get_theory_hashrate_grin32(int a1, double *a2)
{
  if ( *(_BYTE *)(a1 + 268) )
    *a2 = *(double *)(a1 + 280);
  else
    *a2 = (double)*(int *)(a1 + 272) * 0.5 / (double)*(unsigned int *)(a1 + 204) * 1000.0 * 1000.0;
  return 0;
}

//----- (00050E50) --------------------------------------------------------
int set_boot_config_grin32()
{
  return 0;
}

//----- (00050E68) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_grin32(int a1)
{
  if ( !sub_4E774(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (00050E90) --------------------------------------------------------
int __fastcall read_sensor_temp_local_grin32(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_4E2F8(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_4E3C0(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00050EE0) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_grin32(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_4E35C(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_4E598(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00050F30) --------------------------------------------------------
int parameter_update_grin32()
{
  return 0;
}

//----- (00050F54) --------------------------------------------------------
int overclock_update_grin32()
{
  return 0;
}

//----- (00050F6C) --------------------------------------------------------
int __fastcall get_pcba_test_level_grin32(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 768);
  return 0;
}

//----- (00050F90) --------------------------------------------------------
int __fastcall get_packet_remain_len_grin32(unsigned __int8 a1)
{
  int v1; // r3

  if ( a1 == 33 )
    return 176;
  if ( !a1 )
    return 7;
  v1 = a1;
  if ( a1 == 1 )
    return 9;
  return v1;
}

//----- (00050FC4) --------------------------------------------------------
void *runtime_ctrl_grin32()
{
  void *dest; // [sp+CCh] [bp+CCh]

  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1ED4A0, 0x310u);
  return dest;
}
// 1ED4A0: using guessed type _UNKNOWN *off_1ED4A0;

//----- (00051000) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_51000(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (00051024) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_51024(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0005104C) --------------------------------------------------------
int __fastcall sub_5104C(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 51090: variable 'v3' is possibly undefined

//----- (0005112C) --------------------------------------------------------
int __fastcall sub_5112C(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00051230) --------------------------------------------------------
_BYTE *__fastcall sub_51230(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (00051278) --------------------------------------------------------
int __fastcall sub_51278(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_CKB", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_CKB",
    24,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_51024((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_CKB",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_CKB",
    24,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_CKB",
      24,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_CKB",
          24,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_51024((int)v12, *(int *)(a1 + 140));
    sub_51000(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_CKB",
      24,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 513D0: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00051860) --------------------------------------------------------
int __fastcall sub_51860(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_CKB", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_CKB",
    30,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 4456449;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00051954) --------------------------------------------------------
int __fastcall sub_51954(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_CKB", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_CKB",
    39,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 68;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00051A64) --------------------------------------------------------
int __fastcall sub_51A64(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_CKB", 20, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_ticket_mask_CKB",
    27,
    137,
    20,
    v5);
  v6[2] = 1310721;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00051B88) --------------------------------------------------------
int __fastcall sub_51B88(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_CKB",
    20,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00051E1C) --------------------------------------------------------
int __fastcall sub_51E1C(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_CKB",
    24,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00052040) --------------------------------------------------------
unsigned int *__fastcall sub_52040(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 52078: variable 'v1' is possibly undefined

//----- (00052150) --------------------------------------------------------
int __fastcall sub_52150(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 786433;
  sub_52040(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_CKB",
    20,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 521D0: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000522A4) --------------------------------------------------------
int __fastcall sub_522A4(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 12;
  sub_52040(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_CKB",
    29,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 52346: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00052424) --------------------------------------------------------
int __fastcall sub_52424(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_CKB", 20, 80, 20000);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_open_cores_CKB",
    26,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 5242881;
  v8[0] = a3;
  BYTE1(v8[3]) = 20;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v8, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00052550) --------------------------------------------------------
int __fastcall sub_52550(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_CKB");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_close_cores_CKB",
    27,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 5242881;
  v6[0] = 0;
  BYTE1(v6[3]) = 20;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v6, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00052660) --------------------------------------------------------
int __fastcall sub_52660(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_CKB",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_start_nonce_offset_CKB",
    34,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_51024((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_CKB",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_start_nonce_offset_CKB",
        34,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 527C0: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00052950) --------------------------------------------------------
int __fastcall sub_52950(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  char v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_CKB", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_pmdata_CKB",
    22,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 60;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_CKB", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_pmdata_CKB",
        22,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 60 )
        {
          v12 = 60;
          v5 = 0;
          sub_51230(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_51024((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_CKB",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_pmdata_CKB",
            22,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 60 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00052DB4) --------------------------------------------------------
int __fastcall sub_52DB4(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_CKB", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_CKB",
    25,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 108;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 108 )
        {
          sub_51230(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_51024((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_CKB",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_CKB",
            25,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_CKB", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_CKB",
      25,
      436,
      100,
      v5);
    return -1;
  }
}
// 52FC2: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000531A0) --------------------------------------------------------
int __fastcall sub_531A0(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4194305;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_CKB",
    26,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000532BC) --------------------------------------------------------
int __fastcall sub_532BC(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 32;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (00053308) --------------------------------------------------------
int __fastcall sub_53308(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 32;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (00053428) --------------------------------------------------------
int __fastcall sub_53428(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_532BC(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_53308(a1, a2, a3, s, a6, n);
}

//----- (0005349C) --------------------------------------------------------
int __fastcall sub_5349C(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_53428(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00053540) --------------------------------------------------------
int __fastcall sub_53540(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_53428(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (000535E4) --------------------------------------------------------
int __fastcall sub_535E4(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_53428(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00053648) --------------------------------------------------------
int __fastcall sub_53648(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_53428(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (000536AC) --------------------------------------------------------
int __fastcall sub_536AC(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_CKB",
        45,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_CKB",
      45,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00053884) --------------------------------------------------------
int __fastcall sub_53884(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_CKB",
        46,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_CKB",
      46,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00053A60) --------------------------------------------------------
int __fastcall sub_53A60(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_532BC(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00053A98) --------------------------------------------------------
int __fastcall sub_53A98(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00053AEC) --------------------------------------------------------
int __fastcall sub_53AEC(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 52;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 52 )
    {
      V_LOCK();
      sub_51024((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_CKB",
        30,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00053DB8) --------------------------------------------------------
int __fastcall sub_53DB8(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (00053E44) --------------------------------------------------------
unsigned int __fastcall sub_53E44(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0x144u);
  memset(v13, 0, 0x144u);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 27, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_51024((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_CKB",
        31,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000540F4) --------------------------------------------------------
int __fastcall sub_540F4(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (0005413C) --------------------------------------------------------
int __fastcall sub_5413C(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00054194) --------------------------------------------------------
int __fastcall sub_54194(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000541F4) --------------------------------------------------------
int __fastcall sub_541F4(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00054258) --------------------------------------------------------
int __fastcall sub_54258(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000542B4) --------------------------------------------------------
int __fastcall sub_542B4(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = 20 * *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_CKB", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_CKB",
    31,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_51024((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_CKB",
      31,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 54476: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00054638) --------------------------------------------------------
int __fastcall sub_54638(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 20;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_CKB", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_CKB",
    43,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_51024((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_CKB",
      43,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 547E8: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000549B0) --------------------------------------------------------
int __fastcall global_idx_init_ckb(int a1)
{
  void *s; // [sp+Ch] [bp+Ch]

  s = malloc(0x7C08u);
  memset(s, 0, 0x7C08u);
  *(_DWORD *)(a1 + 624) = s;
  printf("__custom_data init %p\n", s);
  return 0;
}

//----- (000549F0) --------------------------------------------------------
int __fastcall global_idx_free_ckb(int a1)
{
  free(*(void **)(a1 + 624));
  return 0;
}

//----- (00054A10) --------------------------------------------------------
__int64 __fastcall sub_54A10(int a1, unsigned __int8 a2)
{
  int v2; // r0
  _BYTE v6[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[4088]; // [sp+1018h] [bp+1008h] BYREF
  int v8; // [sp+2018h] [bp+2008h]
  unsigned int i; // [sp+201Ch] [bp+200Ch]

  v8 = 0;
  for ( i = 0; i <= 0x2F; ++i )
  {
    v2 = snprintf(&v7[v8], 4096 - v8, "%02x ", *(unsigned __int8 *)(i + a1 + 40));
    v8 += v2;
  }
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "ckb dump work jobid %s, work count %d", a1 + 8, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
    83,
    "dump_work_ckb",
    13,
    106,
    20,
    v6);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "dump work: %s", v7);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
           83,
           "dump_work_ckb",
           13,
           107,
           20,
           v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00054BA4) --------------------------------------------------------
int __fastcall work_2_packet_ckb(int a1, int a2, _BYTE *a3, _DWORD *a4)
{
  char v4; // r3
  _BYTE v7[20]; // [sp+24h] [bp+14h] BYREF
  unsigned __int16 v8; // [sp+1026h] [bp+1016h]
  int v9; // [sp+1028h] [bp+1018h]
  int v10; // [sp+102Ch] [bp+101Ch]
  int v11; // [sp+1030h] [bp+1020h]
  _BYTE *v12; // [sp+1034h] [bp+1024h]

  v12 = a3;
  v11 = a2;
  v10 = 0;
  v9 = *(_DWORD *)(a1 + 624);
  *a3 = 85;
  v12[1] = -86;
  v12[2] = 32;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    v12[2] |= 0x10u;
  *(_QWORD *)(8 * *(unsigned __int8 *)(v9 + 31744) + v9) = *(_QWORD *)v11;
  *(_DWORD *)(v9 + 4 * (*(unsigned __int8 *)(v9 + 31744) + 5632)) = *(_DWORD *)(v11 + 88);
  memcpy((void *)(v9 + 32 * (*(unsigned __int8 *)(v9 + 31744) + 736)), (const void *)(v11 + 92), 0x20u);
  strcpy((char *)(v9 + 32 * (*(unsigned __int8 *)(v9 + 31744) + 64)), (const char *)(v11 + 8));
  memcpy((void *)(v9 + 48 * *(unsigned __int8 *)(v9 + 31744) + 10240), (const void *)(v11 + 40), 0x30u);
  v4 = *(_BYTE *)(v9 + 31744);
  *(_BYTE *)(v9 + 31744) = v4 + 1;
  v12[3] = v4;
  *(_BYTE *)(v9 + 31744) = *(_BYTE *)(v9 + 31744);
  memcpy(v12 + 4, (const void *)(v11 + 40), 0x30u);
  if ( !memcmp(&last_header_ckb, (const void *)(v11 + 40), 0x30u) )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
      83,
      "work_2_packet_ckb",
      17,
      142,
      80,
      v7);
    sub_54A10(v11, v12[3]);
  }
  memcpy(&last_header_ckb, (const void *)(v11 + 40), 0x30u);
  v10 = 50;
  v8 = CRC16_v1(v12 + 2, 50);
  v12[52] = HIBYTE(v8);
  v12[53] = v8;
  *a4 = 54;
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00054EF0) --------------------------------------------------------
__int64 __fastcall sub_54EF0(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  _BYTE v9[40]; // [sp+40h] [bp+10h] BYREF
  _BYTE v10[4080]; // [sp+1040h] [bp+1010h] BYREF
  _DWORD v11[7]; // [sp+2040h] [bp+2010h] BYREF
  int v12; // [sp+205Ch] [bp+202Ch]
  int v13; // [sp+2060h] [bp+2030h]
  unsigned int i; // [sp+2064h] [bp+2034h]

  v13 = 0;
  for ( i = 0; i <= 4; ++i )
  {
    v3 = snprintf(&v10[v13], 4096 - v13, "%02x ", *(unsigned __int8 *)(i + a2 + 2));
    v13 += v3;
  }
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "work_id: %02x diff %02x", *(unsigned __int8 *)(a2 + 8), *(_BYTE *)(a2 + 7) & 0x7F);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
    83,
    "dump_nonce_ckb",
    14,
    170,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "back nonce: %s", v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
    83,
    "dump_nonce_ckb",
    14,
    171,
    20,
    v9);
  i = 0;
  v13 = 0;
  while ( i <= 0xF )
  {
    v4 = snprintf(&v10[v13], 4096 - v13, "%02x ", *(unsigned __int8 *)(i + a3 + 48));
    v13 += v4;
    ++i;
  }
  V_LOCK();
  sub_51024((int)v11, *(int *)(a1 + 140));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "asic %d core %d addr_interval %d",
    *(_DWORD *)(a3 + 8),
    *(_DWORD *)(a3 + 12),
    *(_DWORD *)(a1 + 240));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
    83,
    "dump_nonce_ckb",
    14,
    177,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "nonce: %s", v10);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
           83,
           "dump_nonce_ckb",
           14,
           178,
           20,
           v9);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00055248) --------------------------------------------------------
int __fastcall packet_2_nonce_ckb(unsigned int *a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7)
{
  int v8; // r0
  int v9; // r1
  unsigned __int16 v13; // [sp+14h] [bp+14h]
  unsigned int v14; // [sp+18h] [bp+18h]
  unsigned __int8 v15; // [sp+1Fh] [bp+1Fh]

  if ( (char)a2[9] >= 0 )
    return 1;
  v14 = a1[156];
  *(_QWORD *)a3 = *(_QWORD *)(8 * (unsigned __int8)a2[8] + v14);
  *a7 = *(_DWORD *)(8 * (unsigned __int8)a2[8] + v14);
  strcpy((char *)(a3 + 16), (const char *)(32 * ((unsigned __int8)a2[8] + 64) + v14));
  memcpy((void *)(a3 + 48), (const void *)(48 * (unsigned __int8)a2[8] + 10240 + v14 + 32), 0x10u);
  memcpy((void *)(a3 + 59), a2 + 2, 5u);
  *(_BYTE *)(a3 + 64) = a2[7] & 0x7F;
  *(_BYTE *)(a3 + 65) = a2[8];
  v15 = (unsigned __int8)a2[2] / a1[60];
  if ( v15 >= (int)a1[49] )
  {
    v8 = rand();
    sub_1A38EC(v8, a1[49]);
    *a6 = v9;
  }
  else
  {
    *a6 = v15;
  }
  *(_DWORD *)(a3 + 8) = *a6;
  *(_DWORD *)(a3 + 12) = a2[6] & 0x1F;
  v13 = BM_CRC5(a2 + 2, 0x3Bu);
  if ( v13 == (a2[9] & 0x1F) )
  {
    memcpy(dest, (const void *)(a3 + 48), 0x10u);
    *a4 = 1;
    return 0;
  }
  else
  {
    printf("get nonce crc error calc value %04x expected value %04x\n", v13, a2[9] & 0x1F);
    return 2;
  }
}
// 55352: variable 'v9' is possibly undefined

//----- (000553CC) --------------------------------------------------------
int __fastcall makeup_chip_addr_ckb(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (0005541C) --------------------------------------------------------
int __fastcall setup_all_chip_ckb(int a1)
{
  char *v1; // r5
  char v2; // r4
  char v3; // r0
  int v5; // [sp+14h] [bp+4h]
  _BYTE v6[16]; // [sp+18h] [bp+8h] BYREF
  char *v7; // [sp+1018h] [bp+1008h]
  int v8; // [sp+101Ch] [bp+100Ch]
  int v9; // [sp+1020h] [bp+1010h]
  int i; // [sp+1024h] [bp+1014h]

  v5 = a1;
  puts("setup_all_chip_ckb");
  v9 = *(_DWORD *)(v5 + 624);
  *(_DWORD *)(v5 + 240) = makeup_chip_addr_ckb(*(_DWORD *)(v5 + 296), 0x1Bu);
  (*(void (__fastcall **)(int, _DWORD, int))(v5 + 148))(v5, *(_DWORD *)(v5 + 296), 27);
  sub_51278(v5, 27);
  sub_52550(v5, 0);
  v8 = (int)(float)(*(float *)(v5 + 760) - 100.0) / 25;
  for ( i = 1; i <= v8; ++i )
  {
    sub_52150(v5);
    usleep(0x61A8u);
  }
  sub_51A64(v5, 0x30u);
  v7 = (char *)calloc(1u, 0x80u);
  v1 = v7 + 40;
  v2 = *(_DWORD *)(v5 + 136);
  v3 = rand();
  memset(v1, (unsigned __int8)(v3 + v2), 0x30u);
  push_work_base(v5, (int)v7);
  free(v7);
  sub_52424(v5, 0, 1);
  sub_51A64(v5, 0x20u);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "get addr after open cores.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
    83,
    "setup_all_chip_ckb",
    18,
    286,
    60,
    v6);
  sub_51278(v5, 27);
  if ( *(_BYTE *)(v5 + 268) != 1 )
    *(_DWORD *)(v5 + 272) = (int)*(float *)(v5 + 760);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000556B4) --------------------------------------------------------
int __fastcall set_baud_ckb(int a1, char *a2)
{
  return sub_51B88(a1, a2);
}

//----- (000556D0) --------------------------------------------------------
int __fastcall sub_556D0(int a1, int a2)
{
  unsigned __int8 v3; // [sp+Bh] [bp+Bh]
  int i; // [sp+Ch] [bp+Ch]

  v3 = 1;
  for ( i = 0; i <= 31; ++i )
  {
    if ( *(unsigned __int8 *)(i + a1) < (unsigned int)*(unsigned __int8 *)(i + a2) )
      return 1;
    if ( *(unsigned __int8 *)(i + a1) > (unsigned int)*(unsigned __int8 *)(i + a2) )
      return 0;
  }
  return v3;
}

//----- (00055734) --------------------------------------------------------
int __fastcall check_nonce_ckb(int a1, unsigned __int8 *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r6
  _DWORD *v4; // lr
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v10; // [sp+Ch] [bp-4h]
  _BYTE v13[4088]; // [sp+18h] [bp+8h] BYREF
  _BYTE v14[24]; // [sp+1018h] [bp+1008h] BYREF
  _BYTE v15[24]; // [sp+1038h] [bp+1028h] BYREF
  _BYTE v16[16]; // [sp+1058h] [bp+1048h] BYREF
  unsigned __int8 v17; // [sp+106Bh] [bp+105Bh]
  unsigned int v18; // [sp+106Ch] [bp+105Ch]
  int v19; // [sp+1070h] [bp+1060h]
  unsigned __int8 *v20; // [sp+1074h] [bp+1064h]

  v20 = a2;
  v19 = *(_DWORD *)(a1 + 624);
  v18 = *(_DWORD *)(v19 + 4 * (a2[65] + 5632));
  v2 = (_DWORD *)(48 * a2[65] + 10240 + v19);
  v3 = v15;
  v4 = v2 + 12;
  do
  {
    v5 = v2[1];
    v6 = v2[2];
    v7 = v2[3];
    *v3 = *v2;
    v3[1] = v5;
    v3[2] = v6;
    v3[3] = v7;
    v2 += 4;
    v3 += 4;
  }
  while ( v2 != v4 );
  memcpy(v16, v20 + 48, sizeof(v16));
  EaglesongHash((int)v14, (int)v15, 0x30u);
  v17 = target_to_diff_ckb((int)v14);
  if ( v17 > 0x1Fu )
  {
    if ( v17 == v20[64] )
    {
      if ( v20[64] < v18 || (unsigned __int8)sub_556D0((int)v14, v19 + 32 * (v20[65] + 736)) != 1 )
      {
        V_LOCK();
        logfmt_raw(v13, 0x1000u, 0, "hw diff (%d<%d) not reach pool", v20[64], v18);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
          83,
          "check_nonce_ckb",
          15,
          346,
          20,
          v13);
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "diff not match (%d!=%d) expected diff %d", v17, v20[64], v18, v10, a2, a1);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
        83,
        "check_nonce_ckb",
        15,
        341,
        20,
        v13);
      return 3;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(
      v13,
      0x1000u,
      0,
      "hw error calculate diff %d ans diff %d TICKET_MASK_CKB %d",
      v17,
      v20[64],
      32,
      v10,
      a2,
      a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
      83,
      "check_nonce_ckb",
      15,
      336,
      20,
      v13);
    return 2;
  }
}
// 5587A: variable 'v10' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00055A30) --------------------------------------------------------
int get_chip_status_ckb()
{
  return 0;
}

//----- (00055A4C) --------------------------------------------------------
int get_algo_type_ckb()
{
  return 0;
}

//----- (00055A68) --------------------------------------------------------
int __fastcall softreset_all_chip_ckb(int a1)
{
  sub_51860(a1);
  return 0;
}

//----- (00055A80) --------------------------------------------------------
int __fastcall get_theory_hashrate_ckb(int a1, double *a2)
{
  if ( *(_BYTE *)(a1 + 268) )
    *a2 = *(double *)(a1 + 280) * 1000.0 * 1000.0 * 1000.0;
  else
    *a2 = *(float *)(a1 + 760) * 540.0 * 1000.0 * 1000.0;
  return 0;
}

//----- (00055B00) --------------------------------------------------------
int set_boot_config_ckb()
{
  return 0;
}

//----- (00055B18) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_ckb(int a1)
{
  if ( !sub_53A60(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (00055B40) --------------------------------------------------------
int __fastcall read_sensor_temp_local_ckb(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_535E4(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_536AC(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00055B90) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_ckb(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_53648(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_53884(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00055BE0) --------------------------------------------------------
int __fastcall parameter_update_ckb(int a1, char a2, int a3, char a4, int a5)
{
  if ( *(_BYTE *)(a1 + 144) != 1 )
  {
    if ( a2 && a3 >= 500 && a3 <= 800 )
    {
      *(_DWORD *)(a1 + 772) = (int)*(float *)(a1 + 760) * (*(_DWORD *)(a1 + 772) / (unsigned int)a3);
      *(float *)(a1 + 760) = (float)a3;
    }
    if ( a4 && a5 >= 800 && a5 <= 850 )
      *(_DWORD *)(a1 + 764) = a5;
  }
  return 0;
}

//----- (00055C80) --------------------------------------------------------
int __fastcall overclock_update_ckb(int a1, int a2)
{
  _BYTE v5[8]; // [sp+38h] [bp+8h] BYREF
  _DWORD v6[7]; // [sp+1038h] [bp+1008h] BYREF
  int v7; // [sp+1054h] [bp+1024h]
  _DWORD v8[7]; // [sp+1058h] [bp+1028h] BYREF
  int v9; // [sp+1074h] [bp+1044h]
  unsigned int i; // [sp+1078h] [bp+1048h]
  char v11; // [sp+107Fh] [bp+104Fh]

  v11 = 0;
  if ( *(_BYTE *)(a1 + 144) != 1 )
  {
    for ( i = 0; i <= 1; ++i )
    {
      if ( dword_1B721C[2 * i] == a2 )
      {
        *(_DWORD *)(a1 + 772) = (int)*(float *)(a1 + 760) * (*(_DWORD *)(a1 + 772) / (unsigned int)a2);
        *(float *)(a1 + 760) = (float)a2;
        *(_DWORD *)(a1 + 764) = dword_1B721C[2 * i + 1];
        v11 = 1;
        break;
      }
    }
    V_LOCK();
    if ( v11 )
    {
      sub_51024((int)v6, *(int *)(a1 + 140));
      logfmt_raw(
        v5,
        0x1000u,
        0,
        v7,
        v6[0],
        v6[1],
        v6[2],
        v6[3],
        v6[4],
        v6[5],
        v6[6],
        v7,
        "overclock freq %d voltage %d",
        (int)*(float *)(a1 + 760),
        *(_DWORD *)(a1 + 764));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
        83,
        "overclock_update_ckb",
        20,
        460,
        60,
        v5);
    }
    else
    {
      sub_51024((int)v8, *(int *)(a1 + 140));
      logfmt_raw(
        v5,
        0x1000u,
        0,
        v9,
        v8[0],
        v8[1],
        v8[2],
        v8[3],
        v8[4],
        v8[5],
        v8[6],
        v9,
        "cannot overclock with freq %d",
        a2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
        83,
        "overclock_update_ckb",
        20,
        462,
        60,
        v5);
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1B721C: using guessed type _DWORD dword_1B721C[4];
// 47BE18: using guessed type int g_zc;

//----- (00055F14) --------------------------------------------------------
int __fastcall get_pcba_test_level_ckb(_DWORD *a1, _DWORD *a2)
{
  _UNKNOWN **v2; // r0
  _BYTE v7[16]; // [sp+50h] [bp+8h] BYREF
  int v8; // [sp+1050h] [bp+1008h] BYREF
  __int16 v9; // [sp+1054h] [bp+100Ch]
  _DWORD v10[7]; // [sp+1058h] [bp+1010h] BYREF
  int v11; // [sp+1074h] [bp+102Ch]
  const char *v12[8]; // [sp+1078h] [bp+1030h] BYREF
  _DWORD v13[7]; // [sp+1098h] [bp+1050h] BYREF
  int v14; // [sp+10B4h] [bp+106Ch]
  unsigned int j; // [sp+10B8h] [bp+1070h]
  unsigned int i; // [sp+10BCh] [bp+1074h]

  v8 = 0;
  v9 = 0;
  if ( a1[192] )
  {
LABEL_22:
    *a2 = a1[192];
    return 0;
  }
  v2 = dev_ctrl();
  if ( ((int (__fastcall *)(_DWORD, int, int, int *))v2[19])(a1[34], 52, 393216, &v8) )
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( (unsigned __int16)v8 == *((unsigned __int16 *)&unk_1B725C + 5 * i + 2)
        && HIWORD(v8) == *((unsigned __int16 *)&unk_1B725C + 5 * i + 3)
        && (unsigned __int8)v9 == *((unsigned __int8 *)&unk_1B725C + 10 * i + 8)
        && HIBYTE(v9) == *((unsigned __int8 *)&unk_1B725C + 10 * i + 9) )
      {
        a1[192] = *(_DWORD *)((char *)&unk_1B725C + 10 * i);
        break;
      }
    }
    if ( !a1[192] )
    {
      for ( j = 0; j <= 4; ++j )
      {
        if ( (unsigned __int16)v8 == *((unsigned __int16 *)&unk_1B725C + 5 * j + 2)
          && HIWORD(v8) == *((unsigned __int16 *)&unk_1B725C + 5 * j + 3) )
        {
          a1[192] = *(_DWORD *)((char *)&unk_1B725C + 10 * j);
          break;
        }
      }
    }
    if ( !a1[192] )
      a1[192] = 5;
    V_LOCK();
    sub_51024((int)v13, (int)a1[35]);
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "pic freq %d voltage %d rate%d.%d",
      (unsigned __int16)v8,
      HIWORD(v8),
      *((unsigned __int8 *)&unk_1B725C + 10 * a1[192] - 2),
      *((unsigned __int8 *)&unk_1B725C + 10 * a1[192] - 1));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
      83,
      "get_pcba_test_level_ckb",
      23,
      520,
      60,
      v7);
    goto LABEL_22;
  }
  *a2 = -1;
  V_LOCK();
  sub_51024((int)v10, (int)a1[35]);
  sub_51000(v12, "pic info error");
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v12[7],
    "pic info lost");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb/backend_ckb.c",
    83,
    "get_pcba_test_level_ckb",
    23,
    498,
    120,
    v7);
  return 6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00056368) --------------------------------------------------------
int get_packet_remain_len_ckb()
{
  return 7;
}

//----- (00056380) --------------------------------------------------------
void *runtime_ctrl_ckb()
{
  void *dest; // [sp+4Ch] [bp+4Ch]

  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1ED7E0, 0x310u);
  return dest;
}
// 1ED7E0: using guessed type _UNKNOWN *off_1ED7E0;

//----- (000563B0) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_563B0(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (000563D4) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_563D4(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (000563FC) --------------------------------------------------------
int __fastcall sub_563FC(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 56440: variable 'v3' is possibly undefined

//----- (000564DC) --------------------------------------------------------
int __fastcall sub_564DC(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000565E0) --------------------------------------------------------
_BYTE *__fastcall sub_565E0(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (00056628) --------------------------------------------------------
int __fastcall sub_56628(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_DASH", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_DASH",
    25,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_563D4((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_DASH",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_DASH",
    25,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_DASH",
      25,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_DASH",
          25,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_563D4((int)v12, *(int *)(a1 + 140));
    sub_563B0(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_DASH",
      25,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 56780: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00056C10) --------------------------------------------------------
int __fastcall sub_56C10(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_DASH", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_DASH",
    31,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 4456449;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00056D04) --------------------------------------------------------
int __fastcall sub_56D04(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_DASH", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_DASH",
    40,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 68;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00056E14) --------------------------------------------------------
int __fastcall sub_56E14(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_DASH", 255, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_ticket_mask_DASH",
    28,
    137,
    20,
    v5);
  v6[2] = 16711681;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00056F38) --------------------------------------------------------
int __fastcall sub_56F38(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_DASH",
    21,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000571CC) --------------------------------------------------------
int __fastcall sub_571CC(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_DASH",
    25,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000573F0) --------------------------------------------------------
unsigned int *__fastcall sub_573F0(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 57428: variable 'v1' is possibly undefined

//----- (00057500) --------------------------------------------------------
int __fastcall sub_57500(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 524289;
  sub_573F0(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_DASH",
    21,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 57580: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00057654) --------------------------------------------------------
int __fastcall sub_57654(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 8;
  sub_573F0(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_DASH",
    30,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 576F6: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000577D4) --------------------------------------------------------
int __fastcall sub_577D4(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_DASH", 10, 255, 20000);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_open_cores_DASH",
    27,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 16711681;
  v8[0] = a3;
  BYTE1(v8[3]) = 10;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v8, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00057900) --------------------------------------------------------
int __fastcall sub_57900(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_DASH");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_close_cores_DASH",
    28,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 16711681;
  v6[0] = 0;
  BYTE1(v6[3]) = 10;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v6, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00057A10) --------------------------------------------------------
int __fastcall sub_57A10(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_DASH",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_start_nonce_offset_DASH",
    35,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_563D4((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_DASH",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_start_nonce_offset_DASH",
        35,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 57B70: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00057D00) --------------------------------------------------------
int __fastcall sub_57D00(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  unsigned __int8 v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_DASH", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_pmdata_DASH",
    23,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 255;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_DASH", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_pmdata_DASH",
        23,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 255 )
        {
          v12 = -1;
          v5 = 0;
          sub_565E0(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_563D4((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_DASH",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_pmdata_DASH",
            23,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 255 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00058164) --------------------------------------------------------
int __fastcall sub_58164(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_DASH", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_DASH",
    26,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 255;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 255 )
        {
          sub_565E0(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_563D4((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_DASH",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_DASH",
            26,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_DASH", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_DASH",
      26,
      436,
      100,
      v5);
    return -1;
  }
}
// 58372: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00058550) --------------------------------------------------------
int __fastcall sub_58550(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4194305;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_DASH",
    27,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005866C) --------------------------------------------------------
int __fastcall sub_5866C(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 32;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (000586B8) --------------------------------------------------------
int __fastcall sub_586B8(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 32;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (000587D8) --------------------------------------------------------
int __fastcall sub_587D8(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_5866C(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_586B8(a1, a2, a3, s, a6, n);
}

//----- (0005884C) --------------------------------------------------------
int __fastcall sub_5884C(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_587D8(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (000588F0) --------------------------------------------------------
int __fastcall sub_588F0(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_587D8(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00058994) --------------------------------------------------------
int __fastcall sub_58994(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_587D8(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (000589F8) --------------------------------------------------------
int __fastcall sub_589F8(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_587D8(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00058A5C) --------------------------------------------------------
int __fastcall sub_58A5C(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_DASH",
        46,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_DASH",
      46,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00058C34) --------------------------------------------------------
int __fastcall sub_58C34(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_DASH",
        47,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_DASH",
      47,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00058E10) --------------------------------------------------------
int __fastcall sub_58E10(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_5866C(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00058E48) --------------------------------------------------------
int __fastcall sub_58E48(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00058E9C) --------------------------------------------------------
int __fastcall sub_58E9C(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 52;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 52 )
    {
      V_LOCK();
      sub_563D4((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_DASH",
        31,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00059168) --------------------------------------------------------
int __fastcall sub_59168(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (000591F4) --------------------------------------------------------
unsigned int __fastcall sub_591F4(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0x348u);
  memset(v13, 0, 0x348u);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 70, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_563D4((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_DASH",
        32,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000594A4) --------------------------------------------------------
int __fastcall sub_594A4(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (000594EC) --------------------------------------------------------
int __fastcall sub_594EC(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00059544) --------------------------------------------------------
int __fastcall sub_59544(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000595A4) --------------------------------------------------------
int __fastcall sub_595A4(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00059608) --------------------------------------------------------
int __fastcall sub_59608(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00059664) --------------------------------------------------------
int __fastcall sub_59664(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = 10 * *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_DASH", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_DASH",
    32,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_563D4((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_DASH",
      32,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 59826: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000599E8) --------------------------------------------------------
int __fastcall sub_599E8(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 10;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_DASH", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_DASH",
    44,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_563D4((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_DASH",
      44,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 59B98: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00059D60) --------------------------------------------------------
int __fastcall global_idx_init_dash(int a1)
{
  int v3; // [sp+1Ch] [bp+Ch] BYREF
  void *v4; // [sp+101Ch] [bp+100Ch]

  v4 = malloc(0x5808u);
  memset(v4, 0, 0x5808u);
  *(_DWORD *)(a1 + 624) = v4;
  V_LOCK();
  logfmt_raw(&v3, 0x1000u, 0, "__custom_data init %p\n", v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "global_idx_init_dash",
    20,
    59,
    20,
    &v3);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00059E1C) --------------------------------------------------------
int __fastcall global_idx_free_dash(int a1)
{
  free(*(void **)(a1 + 624));
  return 0;
}

//----- (00059E3C) --------------------------------------------------------
__int64 __fastcall sub_59E3C(int a1, unsigned __int8 a2)
{
  int v2; // r0
  _BYTE v6[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[4088]; // [sp+1018h] [bp+1008h] BYREF
  int v8; // [sp+2018h] [bp+2008h]
  unsigned int i; // [sp+201Ch] [bp+200Ch]

  v8 = 0;
  for ( i = 0; i <= 0x4F; ++i )
  {
    v2 = snprintf(&v7[v8], 4096 - v8, "%02x ", *(unsigned __int8 *)(i + a1 + 40));
    v8 += v2;
  }
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "dash dump work jobid %s, work count %d", a1 + 8, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "dump_work_dash",
    14,
    78,
    20,
    v6);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "dump work: %s", v7);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
           85,
           "dump_work_dash",
           14,
           79,
           20,
           v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00059FD0) --------------------------------------------------------
int __fastcall work_2_packet_dash(int a1, int a2, _BYTE *a3, _DWORD *a4)
{
  char v4; // r3
  _BYTE v8[24]; // [sp+20h] [bp+10h] BYREF
  unsigned __int16 v9; // [sp+1022h] [bp+1012h]
  int v10; // [sp+1024h] [bp+1014h]
  int v11; // [sp+1028h] [bp+1018h]
  int v12; // [sp+102Ch] [bp+101Ch]
  _BYTE *v13; // [sp+1030h] [bp+1020h]
  int i; // [sp+1034h] [bp+1024h]

  v13 = a3;
  v12 = a2;
  v11 = 0;
  v10 = *(_DWORD *)(a1 + 624);
  *a3 = 85;
  v13[1] = -86;
  v13[2] = 32;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    v13[2] |= 0x10u;
  *(_QWORD *)(8 * *(unsigned __int8 *)(v10 + 21504) + v10) = *(_QWORD *)v12;
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 21504) + 3840)) = *(_DWORD *)(v12 + 120);
  memcpy((void *)(v10 + 12 * *(unsigned __int8 *)(v10 + 21504) + 19968), (const void *)(v12 + 156), 8u);
  memcpy((void *)(v10 + 32 * (*(unsigned __int8 *)(v10 + 21504) + 496)), (const void *)(v12 + 124), 0x20u);
  strcpy((char *)(v10 + 32 * (*(unsigned __int8 *)(v10 + 21504) + 32)), (const char *)(v12 + 8));
  memcpy((void *)(v10 + 80 * *(unsigned __int8 *)(v10 + 21504) + 5120), (const void *)(v12 + 40), 0x50u);
  *(_QWORD *)(8 * (*(unsigned __int8 *)(v10 + 21504) + 2689) + v10) = *(_QWORD *)(v12 + 168);
  v4 = *(_BYTE *)(v10 + 21504);
  *(_BYTE *)(v10 + 21504) = v4 + 1;
  v13[3] = v4;
  *(_BYTE *)(v10 + 21504) &= ~0x80u;
  memcpy(v13 + 4, (const void *)(v12 + 40), 0x50u);
  for ( i = 0; i <= 19; ++i )
  {
    v13[4 * i + 7] = *(_BYTE *)(4 * i + v12 + 40);
    v13[4 * i + 6] = *(_BYTE *)(4 * i + 1 + v12 + 40);
    v13[4 * i + 5] = *(_BYTE *)(4 * i + 2 + v12 + 40);
    v13[4 * i + 4] = *(_BYTE *)(4 * i + 3 + v12 + 40);
  }
  if ( !memcmp(&last_header_dash, (const void *)(v12 + 40), 0x50u) )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
      85,
      "work_2_packet_dash",
      18,
      122,
      80,
      v8);
    sub_59E3C(v12, v13[3]);
  }
  memcpy(&last_header_dash, (const void *)(v12 + 40), 0x50u);
  v11 = 82;
  v9 = CRC16_v1(v13 + 2, 82);
  v13[84] = HIBYTE(v9);
  v13[85] = v9;
  *a4 = 86;
  if ( *(_BYTE *)(a1 + 145) && *(_BYTE *)(a1 + 146) )
  {
    set_ticket_mask_dash(a1, 0x23u);
    *(_BYTE *)(a1 + 145) = 0;
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005A4DC) --------------------------------------------------------
__int64 __fastcall sub_5A4DC(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  _BYTE v9[40]; // [sp+40h] [bp+10h] BYREF
  _BYTE v10[4080]; // [sp+1040h] [bp+1010h] BYREF
  _DWORD v11[7]; // [sp+2040h] [bp+2010h] BYREF
  int v12; // [sp+205Ch] [bp+202Ch]
  int v13; // [sp+2060h] [bp+2030h]
  unsigned int i; // [sp+2064h] [bp+2034h]

  v13 = 0;
  for ( i = 0; i <= 3; ++i )
  {
    v3 = snprintf(&v10[v13], 4096 - v13, "%02x ", *(unsigned __int8 *)(i + a2 + 2));
    v13 += v3;
  }
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "work_id: %02x diff %02x", *(unsigned __int8 *)(a2 + 7), *(_BYTE *)(a2 + 6) & 0x7F);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "dump_nonce_dash",
    15,
    150,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "back nonce: %s", v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "dump_nonce_dash",
    15,
    151,
    20,
    v9);
  i = 0;
  v13 = 0;
  while ( i <= 3 )
  {
    v4 = snprintf(&v10[v13], 4096 - v13, "%02x ", *(unsigned __int8 *)(i + a3 + 48));
    v13 += v4;
    ++i;
  }
  V_LOCK();
  sub_563D4((int)v11, *(int *)(a1 + 140));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "asic %d core %d addr_interval %d",
    *(_DWORD *)(a3 + 8),
    *(_DWORD *)(a3 + 12),
    *(_DWORD *)(a1 + 240));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "dump_nonce_dash",
    15,
    157,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "nonce: %s", v10);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
           85,
           "dump_nonce_dash",
           15,
           158,
           20,
           v9);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005A834) --------------------------------------------------------
int __fastcall packet_2_nonce_dash(int *a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  _BYTE v11[28]; // [sp+34h] [bp+14h] BYREF
  unsigned __int16 v12; // [sp+1036h] [bp+1016h]
  unsigned __int16 v13; // [sp+1038h] [bp+1018h]
  __int16 v14; // [sp+103Ah] [bp+101Ah]
  unsigned int v15; // [sp+103Ch] [bp+101Ch]
  int v16; // [sp+1040h] [bp+1020h]
  unsigned __int8 v17; // [sp+1047h] [bp+1027h]
  int v18; // [sp+1048h] [bp+1028h]
  unsigned __int8 *v19; // [sp+104Ch] [bp+102Ch]

  v19 = (unsigned __int8 *)a2;
  v18 = a3;
  v17 = 0;
  if ( *(char *)(a2 + 8) >= 0 )
    return 1;
  v16 = a1[156];
  *(_QWORD *)v18 = *(_QWORD *)(8 * v19[7] + v16);
  *a7 = *(_DWORD *)(8 * v19[7] + v16);
  strcpy((char *)(v18 + 16), (const char *)(32 * (v19[7] + 32) + v16));
  memcpy((void *)(v18 + 48), v19 + 2, 4u);
  *(_BYTE *)(v18 + 52) = v19[6] & 0x7F;
  *(_BYTE *)(v18 + 53) = v19[7];
  *(_QWORD *)(v18 + 72) = *(_QWORD *)(8 * (v19[7] + 2689) + v16);
  v17 = v19[2] / (unsigned int)a1[60];
  if ( v17 >= a1[49] )
  {
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, "Nonce error, wrong source chip number");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
      85,
      "packet_2_nonce_dash",
      19,
      187,
      100,
      v11);
    *a6 = 0;
  }
  else
  {
    *a6 = v17;
  }
  *(_DWORD *)(v18 + 8) = *a6;
  v15 = _byteswap_ulong(*(_DWORD *)(v19 + 2));
  *(_DWORD *)(v18 + 12) = (v15 - ((a1[60] * v17) << 24)) % 0xA;
  V_LOCK();
  logfmt_raw(
    v11,
    0x1000u,
    0,
    "%s Nonce: %02x%02x%02x%02x  chipid:%d  coreid:%d",
    "packet_2_nonce_dash",
    v19[2],
    v19[3],
    v19[4],
    v19[5],
    *(_DWORD *)(v18 + 8),
    *(_DWORD *)(v18 + 12));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "packet_2_nonce_dash",
    19,
    201,
    20,
    v11);
  v14 = 7;
  v13 = BM_CRC5(v19 + 2, 0x33u);
  v12 = v19[8] & 0x1F;
  if ( v13 == v12 )
  {
    memcpy(a5, (const void *)(v18 + 48), 4u);
    *a4 = 1;
    return 0;
  }
  else
  {
    printf("get nonce crc error calc value %04x expected value %04x\n", v13, v12);
    return 2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005ACAC) --------------------------------------------------------
int __fastcall makeup_chip_addr_dash(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (0005ACFC) --------------------------------------------------------
void __fastcall get_chip_regdata(int a1, unsigned __int8 a2)
{
  _BYTE v3[10]; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v4; // [sp+26h] [bp+16h]
  int v5; // [sp+2Ch] [bp+1Ch] BYREF
  void *s; // [sp+30h] [bp+20h]
  int v7; // [sp+34h] [bp+24h]

  v5 = 0;
  v7 = *(_DWORD *)(a1 + 196);
  v3[8] = 1;
  v3[9] = 0;
  v4 = a2;
  s = malloc(12 * v7);
  memset(s, 0, 12 * v7);
  (*(void (__fastcall **)(int, _BYTE *, int, void *, int *))(a1 + 176))(a1, v3, v7, s, &v5);
  free(s);
}

//----- (0005AD7C) --------------------------------------------------------
void __fastcall get_core_regdata(int a1, unsigned __int8 a2)
{
  _BYTE v3[10]; // [sp+18h] [bp+8h] BYREF
  __int16 v4; // [sp+22h] [bp+12h]
  char v5; // [sp+24h] [bp+14h]
  int v6; // [sp+28h] [bp+18h] BYREF
  void *s; // [sp+2Ch] [bp+1Ch]
  int v8; // [sp+30h] [bp+20h]
  int v9; // [sp+34h] [bp+24h]

  v6 = 0;
  v9 = *(_DWORD *)(a1 + 196);
  v8 = *(_DWORD *)(a1 + 200);
  v3[8] = 1;
  v3[9] = 0;
  v5 = -1;
  v4 = a2;
  s = malloc(12 * v8 * v9);
  memset(s, 0, 12 * v8 * v9);
  (*(void (__fastcall **)(int, _BYTE *, int, void *, int *))(a1 + 184))(a1, v3, v8 * v9, s, &v6);
  free(s);
}

//----- (0005AE1C) --------------------------------------------------------
int __fastcall set_ticket_mask_dash(int a1, unsigned __int8 a2)
{
  int result; // r0
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  memset(v6, 0, 0x10u);
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s core reg %02x tm %d", "set_ticket_mask_dash", 20, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "set_ticket_mask_dash",
    20,
    282,
    20,
    v5);
  v6[2] = 1310721;
  v6[0] = a2;
  LOWORD(v6[3]) = 2815;
  result = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v6);
  *(_DWORD *)(a1 + 244) = a2;
  return result;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005AF50) --------------------------------------------------------
int __fastcall sub_5AF50(int a1, int a2)
{
  _BYTE v5[12]; // [sp+1Ch] [bp+Ch] BYREF
  float v6; // [sp+101Ch] [bp+100Ch]
  float v7; // [sp+1020h] [bp+1010h]
  int v8; // [sp+1024h] [bp+1014h]

  v8 = 1;
  v6 = 50.0;
  v7 = 50.0;
  do
  {
    sub_57500(a1);
    usleep(0x61A8u);
    v7 = (float)(a2 * v8++) + v6;
  }
  while ( *(float *)(a1 + 760) >= v7 );
  v7 = v7 - (float)a2;
  if ( *(float *)(a1 + 760) > v7 )
  {
    sub_57500(a1);
    usleep(0x61A8u);
    v7 = *(float *)(a1 + 760);
  }
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "Set chip final freq=%f", v7);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "set_working_freq_by_steps",
    25,
    313,
    60,
    v5);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005B130) --------------------------------------------------------
int __fastcall setup_all_chip_dash(int a1)
{
  char *v1; // r5
  char v2; // r4
  char v3; // r0
  int v5; // [sp+4h] [bp-Ch]
  _BYTE v7[28]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 v8; // [sp+101Fh] [bp+100Fh] BYREF
  int v9; // [sp+1020h] [bp+1010h]
  int v10; // [sp+1024h] [bp+1014h]
  char v11; // [sp+1028h] [bp+1018h]
  unsigned __int8 v12; // [sp+102Bh] [bp+101Bh] BYREF
  char *v13; // [sp+102Ch] [bp+101Ch]
  int v14; // [sp+1030h] [bp+1020h]
  char v15; // [sp+1037h] [bp+1027h]

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "setup_all_chip_dash\n");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "setup_all_chip_dash",
    19,
    319,
    60,
    v7);
  v12 = 0;
  v15 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  v8 = 0;
  sub_5AF50(a1, 25);
  softreset_all_chip_dash(a1);
  usleep(0x4E20u);
  eeprom_read(*(_DWORD *)(a1 + 140), 195, (int)&v12, 1u);
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "read marker %x", v12);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "setup_all_chip_dash",
    19,
    354,
    60,
    v7);
  if ( v12 == 165 )
  {
    *(_BYTE *)(a1 + 310) = 1;
    eeprom_read(*(_DWORD *)(a1 + 140), 196, (int)&v8, 1u);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "read eeprom high hashrate: %02x", v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
      85,
      "setup_all_chip_dash",
      19,
      358,
      20,
      v7);
    v14 = v8;
    eeprom_read(*(_DWORD *)(a1 + 140), 197, (int)&v8, 1u);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "read eeprom low hashrate: %02x", v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
      85,
      "setup_all_chip_dash",
      19,
      361,
      20,
      v7);
    v14 = (v14 << 8) | v8;
    *(double *)(a1 + 312) = (double)v14 * 1000.0 * 1000.0 * 1000.0;
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "chain%d  avg hashrate is %f",
      *(_DWORD *)(a1 + 140),
      v5,
      *(_DWORD *)(a1 + 312),
      *(_DWORD *)(a1 + 316));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
      85,
      "setup_all_chip_dash",
      19,
      364,
      20,
      v7);
  }
  set_ticket_mask_dash(a1, 0xFFu);
  v13 = (char *)calloc(1u, 0xB0u);
  v1 = v13 + 40;
  v2 = *(_DWORD *)(a1 + 136);
  v3 = rand();
  memset(v1, (unsigned __int8)(v3 + v2), 0x50u);
  push_work_base(a1, (int)v13);
  free(v13);
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get addr after open cores.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "setup_all_chip_dash",
    19,
    375,
    60,
    v7);
  sub_56628(a1, 70);
  if ( *(_BYTE *)(a1 + 268) != 1 )
    *(_DWORD *)(a1 + 272) = (int)*(float *)(a1 + 760);
  return 0;
}
// 5B426: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005B590) --------------------------------------------------------
int __fastcall set_baud_dash(int a1, char *a2)
{
  _DWORD s[4]; // [sp+8h] [bp+8h] BYREF
  unsigned int v6; // [sp+18h] [bp+18h]
  unsigned int v7; // [sp+1Ch] [bp+1Ch]
  int v8; // [sp+20h] [bp+20h]
  char v9; // [sp+27h] [bp+27h]
  int j; // [sp+28h] [bp+28h]
  int i; // [sp+2Ch] [bp+2Ch]
  unsigned __int8 v12; // [sp+33h] [bp+33h]
  int v13; // [sp+34h] [bp+34h]

  v13 = 0;
  v7 = 0;
  v12 = 26;
  v9 = 3;
  v8 = *(_DWORD *)(a1 + 624);
  *(_DWORD *)(a1 + 240) = makeup_chip_addr_dash(*(_DWORD *)(a1 + 296), 0x46u);
  (*(void (__fastcall **)(int, _DWORD, int))(a1 + 148))(a1, *(_DWORD *)(a1 + 296), 70);
  sub_56628(a1, 70);
  memset(s, 0, sizeof(s));
  s[2] = 1835009;
  v12 = 26;
  v7 = -1597760975;
  s[0] = -1597760975;
  v13 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  LOBYTE(s[2]) = 0;
  v6 = (v12 << 8) | 0xA0840031;
  for ( i = 0; *(_DWORD *)(a1 + 196) > i; ++i )
  {
    if ( i && i % 5 == 4 )
    {
      BYTE1(s[2]) = *(_DWORD *)(a1 + 240) * i;
      s[0] = v6;
      v13 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
    }
  }
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_27;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v12 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_32;
      v12 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v12 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_32;
      v12 = 26;
    }
    goto LABEL_33;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_26:
    v12 = 0;
    goto LABEL_33;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_32;
      goto LABEL_26;
    }
LABEL_27:
    v12 = 1;
    goto LABEL_33;
  }
  if ( a2 == (char *)6250000 )
  {
    v12 = 0;
    v9 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_32:
      v12 = 26;
      goto LABEL_33;
    }
    v12 = 0;
    v9 = 0;
  }
LABEL_33:
  v7 = (v12 << 8) | 0xA0C40031;
  v6 = (v12 << 8) | 0xA0840031;
  LOBYTE(s[2]) = 0;
  for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
  {
    BYTE1(s[2]) = *(_DWORD *)(a1 + 240) * j;
    if ( j && j % 5 == 4 )
    {
      s[0] = v6;
      v13 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
    }
    else
    {
      s[0] = v7;
      v13 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
    }
  }
  sleep(1u);
  return v13;
}

//----- (0005B854) --------------------------------------------------------
int __fastcall sub_5B854(int a1, int a2)
{
  unsigned __int8 v3; // [sp+13h] [bp+13h]
  int i; // [sp+14h] [bp+14h]

  v3 = 1;
  for ( i = 7; i >= 0; --i )
  {
    if ( *(_DWORD *)(4 * i + a1) < *(_DWORD *)(4 * i + a2) )
      return 1;
    if ( *(_DWORD *)(4 * i + a1) > *(_DWORD *)(4 * i + a2) )
      return 0;
  }
  return v3;
}

//----- (0005B8C8) --------------------------------------------------------
int __fastcall check_nonce_dash(int a1, unsigned __int8 *a2)
{
  _BYTE v5[8]; // [sp+38h] [bp+8h] BYREF
  _BYTE v6[24]; // [sp+1038h] [bp+1008h] BYREF
  _BYTE v7[80]; // [sp+1058h] [bp+1028h] BYREF
  _DWORD v8[7]; // [sp+10A8h] [bp+1078h] BYREF
  int v9; // [sp+10C4h] [bp+1094h]
  unsigned __int8 v10; // [sp+10CFh] [bp+109Fh]
  unsigned int v11; // [sp+10D0h] [bp+10A0h]
  int v12; // [sp+10D4h] [bp+10A4h]
  unsigned __int8 *v13; // [sp+10D8h] [bp+10A8h]
  int i; // [sp+10DCh] [bp+10ACh]

  v13 = a2;
  V_LOCK();
  sub_563D4((int)v8, *(int *)(a1 + 140));
  logfmt_raw(
    v5,
    0x1000u,
    0,
    v9,
    v8[0],
    v8[1],
    v8[2],
    v8[3],
    v8[4],
    v8[5],
    v8[6],
    v9,
    "nonce %llx back wc %d",
    *((_DWORD *)v13 + 12),
    v13[53]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "check_nonce_dash",
    16,
    617,
    20,
    v5);
  v12 = *(_DWORD *)(a1 + 624);
  v11 = *(_DWORD *)(v12 + 4 * (v13[53] + 3840));
  memcpy(v13 + 54, (const void *)(12 * v13[53] + 19968 + v12), 8u);
  memcpy(v7, (const void *)(v12 + 80 * v13[53] + 5120), sizeof(v7));
  for ( i = 0; i <= 19; ++i )
  {
    v7[4 * i + 3] = *(_BYTE *)(80 * v13[53] + v12 + 4 * i + 5120);
    v7[4 * i + 2] = *(_BYTE *)(80 * v13[53] + v12 + 4 * i + 1 + 5120);
    v7[4 * i + 1] = *(_BYTE *)(80 * v13[53] + v12 + 4 * i + 2 + 5120);
    v7[4 * i] = *(_BYTE *)(80 * v13[53] + v12 + 4 * i + 3 + 5120);
  }
  memcpy(&v7[76], v13 + 48, 4u);
  Xhash(v6, v7);
  v10 = target_to_diff_dash((int)v6);
  if ( v10 > 0x22u )
  {
    if ( v10 == v13[52] )
    {
      if ( v13[52] < v11 || (unsigned __int8)sub_5B854((int)v6, v12 + 32 * (v13[53] + 496)) != 1 )
      {
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, "hw diff (%d<%d) not reach pool", v13[52], v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
          85,
          "check_nonce_dash",
          16,
          661,
          20,
          v5);
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "diff not match (%d!=%d) expected diff %d", v10, v13[52], v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
        85,
        "check_nonce_dash",
        16,
        647,
        20,
        v5);
      return 3;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "hw error calculate diff %d ans diff %d TICKET_MASK_DASH %d", v10, v13[52], 35);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
      85,
      "check_nonce_dash",
      16,
      638,
      20,
      v5);
    if ( (unsigned __int8)++*(_BYTE *)(a1 + 308) % 0x3E8u )
      return 6;
    else
      return 2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1156E0: using guessed type int __fastcall Xhash(_DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005BE8C) --------------------------------------------------------
void check_asic_status_dash()
{
  ;
}

//----- (0005BEA0) --------------------------------------------------------
int __fastcall save_avg_hashrate_dash(int a1)
{
  double v1; // d0
  int result; // r0
  int v3; // [sp+4h] [bp-Ch]
  _BYTE v5[8]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 v6; // [sp+1022h] [bp+1012h] BYREF
  unsigned __int8 v7; // [sp+1023h] [bp+1013h] BYREF
  int v8; // [sp+1024h] [bp+1014h]

  v7 = 0;
  v6 = 0;
  v8 = 0;
  result = eeprom_read(*(_DWORD *)(a1 + 140), 195, (int)&v7, 1u);
  if ( v7 != 165 )
  {
    result = is_eeprom_loaded();
    if ( result )
    {
      v8 = (int)(v1 / 1000.0 / 1000.0 / 1000.0);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "avg hashrate to save: %d, lifetime_avg: %f", v8, v3, v1);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
        85,
        "save_avg_hashrate_dash",
        22,
        728,
        20,
        v5);
      v6 = BYTE1(v8);
      eeprom_write(*(_DWORD *)(a1 + 140), 196, (int)&v6, 1u);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "save hashrate high %02x to addr %d", v6, 196);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
        85,
        "save_avg_hashrate_dash",
        22,
        731,
        20,
        v5);
      v6 = v8;
      eeprom_write(*(_DWORD *)(a1 + 140), 197, (int)&v6, 1u);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "save hashrate low %02x to addr %d", v6, 197);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
        85,
        "save_avg_hashrate_dash",
        22,
        734,
        20,
        v5);
      v6 = -91;
      eeprom_write(*(_DWORD *)(a1 + 140), 195, (int)&v6, 1u);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "save hashrate marker addr %d", v6, 195);
      V_UNLOCK();
      result = zlog(
                 g_zc,
                 "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
                 85,
                 "save_avg_hashrate_dash",
                 22,
                 737,
                 20,
                 v5);
      *(_BYTE *)(a1 + 310) = 1;
      *(double *)(a1 + 312) = v1;
    }
  }
  return result;
}
// 5BF28: variable 'v1' is possibly undefined
// 5BF80: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005C1C8) --------------------------------------------------------
int get_chip_status_dash()
{
  return 0;
}

//----- (0005C1E4) --------------------------------------------------------
int get_algo_type_dash()
{
  return 0;
}

//----- (0005C200) --------------------------------------------------------
int __fastcall softreset_all_chip_dash(int a1)
{
  sub_56C10(a1);
  return 0;
}

//----- (0005C218) --------------------------------------------------------
int __fastcall get_theory_hashrate_dash(int a1, double *a2)
{
  if ( *(_BYTE *)(a1 + 310) )
  {
    *a2 = *(double *)(a1 + 312);
    return 0;
  }
  else
  {
    if ( !strcmp((const char *)(a1 + 216), "D7") )
    {
      *a2 = 3.79e11;
    }
    else if ( !strcmp((const char *)(a1 + 216), "D7e") )
    {
      *a2 = 3.6e11;
    }
    else
    {
      *a2 = *(float *)(a1 + 760) * 700.0 * 1000.0 * 1000.0 * 0.98;
    }
    return 8;
  }
}

//----- (0005C2F0) --------------------------------------------------------
int set_boot_config_dash()
{
  return 0;
}

//----- (0005C308) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_dash(int a1)
{
  if ( !sub_58E10(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (0005C330) --------------------------------------------------------
int __fastcall read_sensor_temp_local_dash(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_58994(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_58A5C(a1, a2, a3, a8);
  }
  return 0;
}

//----- (0005C380) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_dash(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
    {
      sub_589F8(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
      if ( *a3 )
        *a2 -= 15;
    }
  }
  else
  {
    sub_58C34(a1, a2, a3, a8);
  }
  return 0;
}

//----- (0005C3E4) --------------------------------------------------------
int __fastcall parameter_update_dash(int a1, char a2, int a3)
{
  _BYTE v5[4100]; // [sp+20h] [bp+10h] BYREF

  if ( *(_BYTE *)(a1 + 144) != 1 )
  {
    if ( a2 && a3 <= 800 )
    {
      *(_DWORD *)(a1 + 772) = (unsigned int)((double)((int)*(float *)(a1 + 760)
                                                    * (*(_DWORD *)(a1 + 772)
                                                     / (unsigned int)a3))
                                           * 0.35);
      *(float *)(a1 + 760) = (float)a3;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, "Update parameter failed, freq:%f", *(float *)(a1 + 760));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
        85,
        "parameter_update_dash",
        21,
        815,
        60,
        v5);
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005C540) --------------------------------------------------------
int __fastcall overclock_update_dash(int a1, int a2)
{
  _BYTE v5[8]; // [sp+38h] [bp+8h] BYREF
  _DWORD v6[7]; // [sp+1038h] [bp+1008h] BYREF
  int v7; // [sp+1054h] [bp+1024h]
  _DWORD v8[7]; // [sp+1058h] [bp+1028h] BYREF
  int v9; // [sp+1074h] [bp+1044h]
  unsigned int i; // [sp+1078h] [bp+1048h]
  char v11; // [sp+107Fh] [bp+104Fh]

  v11 = 0;
  if ( *(_BYTE *)(a1 + 144) != 1 )
  {
    for ( i = 0; i <= 1; ++i )
    {
      if ( dword_1B80C4[2 * i] == a2 )
      {
        *(_DWORD *)(a1 + 772) = (int)*(float *)(a1 + 760) * (*(_DWORD *)(a1 + 772) / (unsigned int)a2);
        *(float *)(a1 + 760) = (float)a2;
        *(_DWORD *)(a1 + 764) = dword_1B80C4[2 * i + 1];
        v11 = 1;
        break;
      }
    }
    V_LOCK();
    if ( v11 )
    {
      sub_563D4((int)v6, *(int *)(a1 + 140));
      logfmt_raw(
        v5,
        0x1000u,
        0,
        v7,
        v6[0],
        v6[1],
        v6[2],
        v6[3],
        v6[4],
        v6[5],
        v6[6],
        v7,
        "overclock freq %d voltage %d",
        (int)*(float *)(a1 + 760),
        *(_DWORD *)(a1 + 764));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
        85,
        "overclock_update_dash",
        21,
        846,
        60,
        v5);
    }
    else
    {
      sub_563D4((int)v8, *(int *)(a1 + 140));
      logfmt_raw(
        v5,
        0x1000u,
        0,
        v9,
        v8[0],
        v8[1],
        v8[2],
        v8[3],
        v8[4],
        v8[5],
        v8[6],
        v9,
        "cannot overclock with freq %d",
        a2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
        85,
        "overclock_update_dash",
        21,
        848,
        60,
        v5);
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1B80C4: using guessed type _DWORD dword_1B80C4[4];
// 47BE18: using guessed type int g_zc;

//----- (0005C7D4) --------------------------------------------------------
int __fastcall get_pcba_test_level_dash(_DWORD *a1, _DWORD *a2)
{
  _UNKNOWN **v2; // r0
  _BYTE v7[16]; // [sp+50h] [bp+8h] BYREF
  int v8; // [sp+1050h] [bp+1008h] BYREF
  __int16 v9; // [sp+1054h] [bp+100Ch]
  _DWORD v10[7]; // [sp+1058h] [bp+1010h] BYREF
  int v11; // [sp+1074h] [bp+102Ch]
  const char *v12[8]; // [sp+1078h] [bp+1030h] BYREF
  _DWORD v13[7]; // [sp+1098h] [bp+1050h] BYREF
  int v14; // [sp+10B4h] [bp+106Ch]
  unsigned int j; // [sp+10B8h] [bp+1070h]
  unsigned int i; // [sp+10BCh] [bp+1074h]

  v8 = 0;
  v9 = 0;
  if ( a1[192] )
  {
LABEL_22:
    *a2 = a1[192];
    return 0;
  }
  v2 = dev_ctrl();
  if ( !((int (__fastcall *)(_DWORD, int, int, int *))v2[19])(a1[34], 52, 393216, &v8) )
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( (unsigned __int16)v8 == *((unsigned __int16 *)&unk_1B8108 + 5 * i + 2)
        && HIWORD(v8) == *((unsigned __int16 *)&unk_1B8108 + 5 * i + 3)
        && (unsigned __int8)v9 == *((unsigned __int8 *)&unk_1B8108 + 10 * i + 8)
        && HIBYTE(v9) == *((unsigned __int8 *)&unk_1B8108 + 10 * i + 9) )
      {
        a1[192] = *(_DWORD *)((char *)&unk_1B8108 + 10 * i);
        break;
      }
    }
    if ( !a1[192] )
    {
      for ( j = 0; j <= 4; ++j )
      {
        if ( (unsigned __int16)v8 == *((unsigned __int16 *)&unk_1B8108 + 5 * j + 2)
          && HIWORD(v8) == *((unsigned __int16 *)&unk_1B8108 + 5 * j + 3) )
        {
          a1[192] = *(_DWORD *)((char *)&unk_1B8108 + 10 * j);
          break;
        }
      }
    }
    if ( !a1[192] )
      a1[192] = 5;
    V_LOCK();
    sub_563D4((int)v13, (int)a1[35]);
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "pic freq %d voltage %d rate%d.%d",
      (unsigned __int16)v8,
      HIWORD(v8),
      *((unsigned __int8 *)&unk_1B8108 + 10 * a1[192] - 2),
      *((unsigned __int8 *)&unk_1B8108 + 10 * a1[192] - 1));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
      85,
      "get_pcba_test_level_dash",
      24,
      906,
      60,
      v7);
    goto LABEL_22;
  }
  *a2 = -1;
  V_LOCK();
  sub_563D4((int)v10, (int)a1[35]);
  sub_563B0(v12, "pic info error");
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    v12[0],
    v12[1],
    v12[2],
    v12[3],
    v12[4],
    v12[5],
    v12[6],
    v12[7],
    "pic info lost");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dash/backend_dash.c",
    85,
    "get_pcba_test_level_dash",
    24,
    884,
    120,
    v7);
  return 6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005CC28) --------------------------------------------------------
int get_packet_remain_len_dash()
{
  return 6;
}

//----- (0005CC40) --------------------------------------------------------
void *runtime_ctrl_dash()
{
  void *dest; // [sp+54h] [bp+54h]

  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1EDB70, 0x310u);
  return dest;
}
// 1EDB70: using guessed type _UNKNOWN *off_1EDB70;

//----- (0005CC70) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5CC70(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (0005CC94) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_5CC94(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0005CCBC) --------------------------------------------------------
int __fastcall sub_5CCBC(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 5CD00: variable 'v3' is possibly undefined

//----- (0005CD9C) --------------------------------------------------------
int __fastcall sub_5CD9C(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005CEA0) --------------------------------------------------------
_BYTE *__fastcall sub_5CEA0(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (0005CEE8) --------------------------------------------------------
int __fastcall sub_5CEE8(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_DCR", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_DCR",
    24,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_5CC94((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_DCR",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_DCR",
    24,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_DCR",
      24,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_DCR",
          24,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_5CC94((int)v12, *(int *)(a1 + 140));
    sub_5CC70(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_DCR",
      24,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 5D040: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005D4D0) --------------------------------------------------------
int __fastcall sub_5D4D0(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_DCR", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_DCR",
    30,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 4456449;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005D5C4) --------------------------------------------------------
int __fastcall sub_5D5C4(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_DCR", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_DCR",
    39,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 68;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005D6D4) --------------------------------------------------------
int __fastcall sub_5D6D4(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_DCR", 255, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_ticket_mask_DCR",
    27,
    137,
    20,
    v5);
  v6[2] = 16711681;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005D7F8) --------------------------------------------------------
int __fastcall sub_5D7F8(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_DCR",
    20,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005DA8C) --------------------------------------------------------
int __fastcall sub_5DA8C(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_DCR",
    24,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005DCB0) --------------------------------------------------------
unsigned int *__fastcall sub_5DCB0(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 5DCE8: variable 'v1' is possibly undefined

//----- (0005DDC0) --------------------------------------------------------
int __fastcall sub_5DDC0(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 524289;
  sub_5DCB0(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_DCR",
    20,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 5DE40: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005DF14) --------------------------------------------------------
int __fastcall sub_5DF14(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 8;
  sub_5DCB0(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_DCR",
    29,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 5DFB6: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005E094) --------------------------------------------------------
int __fastcall sub_5E094(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_DCR", -1, 255, -1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_open_cores_DCR",
    26,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 16711681;
  v8[0] = a3;
  BYTE1(v8[3]) = -1;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, int))(a1 + 168))(a1, v8, -1, -1);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005E1C4) --------------------------------------------------------
int __fastcall sub_5E1C4(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_DCR");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_close_cores_DCR",
    27,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 16711681;
  v6[0] = 0;
  BYTE1(v6[3]) = -1;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, int))(a1 + 168))(a1, v6, -1, -1);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005E2D4) --------------------------------------------------------
int __fastcall sub_5E2D4(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_DCR",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_start_nonce_offset_DCR",
    34,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_5CC94((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_DCR",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_start_nonce_offset_DCR",
        34,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 5E434: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005E5C4) --------------------------------------------------------
int __fastcall sub_5E5C4(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  unsigned __int8 v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_DCR", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_pmdata_DCR",
    22,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 255;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_DCR", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_pmdata_DCR",
        22,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 255 )
        {
          v12 = -1;
          v5 = 0;
          sub_5CEA0(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_5CC94((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_DCR",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_pmdata_DCR",
            22,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 255 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005EA28) --------------------------------------------------------
int __fastcall sub_5EA28(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_DCR", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_DCR",
    25,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 255;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 255 )
        {
          sub_5CEA0(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_5CC94((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_DCR",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_DCR",
            25,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_DCR", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_DCR",
      25,
      436,
      100,
      v5);
    return -1;
  }
}
// 5EC36: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005EE14) --------------------------------------------------------
int __fastcall sub_5EE14(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4194305;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_DCR",
    26,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005EF30) --------------------------------------------------------
int __fastcall sub_5EF30(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 255;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (0005EF7C) --------------------------------------------------------
int __fastcall sub_5EF7C(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 255;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (0005F09C) --------------------------------------------------------
int __fastcall sub_5F09C(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_5EF30(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_5EF7C(a1, a2, a3, s, a6, n);
}

//----- (0005F110) --------------------------------------------------------
int __fastcall sub_5F110(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_5F09C(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0005F1B4) --------------------------------------------------------
int __fastcall sub_5F1B4(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_5F09C(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0005F258) --------------------------------------------------------
int __fastcall sub_5F258(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_5F09C(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (0005F2BC) --------------------------------------------------------
int __fastcall sub_5F2BC(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_5F09C(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (0005F320) --------------------------------------------------------
int __fastcall sub_5F320(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_DCR",
        45,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_DCR",
      45,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005F4F8) --------------------------------------------------------
int __fastcall sub_5F4F8(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_DCR",
        46,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_DCR",
      46,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005F6D4) --------------------------------------------------------
int __fastcall sub_5F6D4(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_5EF30(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0005F70C) --------------------------------------------------------
int __fastcall sub_5F70C(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0005F760) --------------------------------------------------------
int __fastcall sub_5F760(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 52;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 52 )
    {
      V_LOCK();
      sub_5CC94((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_DCR",
        30,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005FA2C) --------------------------------------------------------
int __fastcall sub_5FA2C(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (0005FAB8) --------------------------------------------------------
unsigned int __fastcall sub_5FAB8(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0xCu);
  memset(v13, 0, 0xCu);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 1, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_5CC94((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_DCR",
        31,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0005FD64) --------------------------------------------------------
int __fastcall sub_5FD64(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (0005FDAC) --------------------------------------------------------
int __fastcall sub_5FDAC(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0005FE04) --------------------------------------------------------
int __fastcall sub_5FE04(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0005FE64) --------------------------------------------------------
int __fastcall sub_5FE64(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0005FEC8) --------------------------------------------------------
int __fastcall sub_5FEC8(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0005FF24) --------------------------------------------------------
int __fastcall sub_5FF24(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = -*(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_DCR", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_DCR",
    31,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_5CC94((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_DCR",
      31,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 600E0: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000602A4) --------------------------------------------------------
int __fastcall sub_602A4(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = -1;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_DCR", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_DCR",
    43,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_5CC94((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_DCR",
      43,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 60456: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006061C) --------------------------------------------------------
int __fastcall global_idx_init_dcr(int a1)
{
  void *s; // [sp+Ch] [bp+Ch]

  s = malloc(0x8008u);
  memset(s, 0, 0x8008u);
  *(_DWORD *)(a1 + 624) = s;
  printf("__custom_data init %p\n", s);
  return 0;
}

//----- (0006065C) --------------------------------------------------------
int __fastcall global_idx_free_dcr(int a1)
{
  free(*(void **)(a1 + 624));
  return 0;
}

//----- (0006067C) --------------------------------------------------------
__int64 __fastcall sub_6067C(int a1, unsigned __int8 a2)
{
  int v2; // r0
  _BYTE v6[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[4088]; // [sp+1018h] [bp+1008h] BYREF
  int v8; // [sp+2018h] [bp+2008h]
  unsigned int i; // [sp+201Ch] [bp+200Ch]

  v8 = 0;
  for ( i = 0; i <= 0xB3; ++i )
  {
    v2 = snprintf(&v7[v8], 4096 - v8, "%02x ", *(unsigned __int8 *)(i + a1 + 40));
    v8 += v2;
  }
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "dcr dump work jobid %s, work count %d", a1 + 8, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
    83,
    "dump_work_dcr",
    13,
    84,
    20,
    v6);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "dump work: %s", v7);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
           83,
           "dump_work_dcr",
           13,
           85,
           20,
           v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00060810) --------------------------------------------------------
int __fastcall work_2_packet_dcr(int a1, int a2, _BYTE *a3, _DWORD *a4)
{
  char v4; // r3
  _BYTE v8[20]; // [sp+24h] [bp+14h] BYREF
  unsigned __int16 v9; // [sp+1026h] [bp+1016h]
  int v10; // [sp+1028h] [bp+1018h]
  __int16 v11; // [sp+102Eh] [bp+101Eh]
  int v12; // [sp+1030h] [bp+1020h]
  _BYTE *v13; // [sp+1034h] [bp+1024h]

  v13 = a3;
  v12 = a2;
  v11 = 0;
  v10 = *(_DWORD *)(a1 + 624);
  *a3 = 85;
  v13[1] = -86;
  v13[2] = 32;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    v13[2] |= 0x10u;
  *(_QWORD *)(8 * *(unsigned __int8 *)(v10 + 0x8000) + v10) = *(_QWORD *)v12;
  strcpy((char *)(v10 + 32 * (*(unsigned __int8 *)(v10 + 0x8000) + 32)), (const char *)(v12 + 8));
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 0x8000) + 7040)) = *(_DWORD *)(v12 + 220);
  memcpy((void *)(v10 + 32 * (*(unsigned __int8 *)(v10 + 0x8000) + 896)), (const void *)(v12 + 224), 0x20u);
  memcpy((void *)(v10 + 180 * *(unsigned __int8 *)(v10 + 0x8000) + 5120), (const void *)(v12 + 40), 0xB4u);
  v4 = *(_BYTE *)(v10 + 0x8000);
  *(_BYTE *)(v10 + 0x8000) = v4 + 1;
  v13[3] = v4;
  *(_BYTE *)(v10 + 0x8000) &= ~0x80u;
  memcpy(v13 + 4, (const void *)(v12 + 40), 0xB4u);
  if ( !memcmp(&last_header_dcr, (const void *)(v12 + 40), 0xB4u) )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
      83,
      "work_2_packet_dcr",
      17,
      118,
      80,
      v8);
  }
  memcpy(&last_header_dcr, (const void *)(v12 + 40), 0xB4u);
  v11 = 182;
  v9 = CRC16_v1(v13 + 2, 182);
  v13[184] = HIBYTE(v9);
  v13[185] = v9;
  *a4 = 186;
  if ( *(_BYTE *)(a1 + 145) && *(_BYTE *)(a1 + 146) )
  {
    memset(*(void **)(a1 + 264), 0, 48 * *(_DWORD *)(a1 + 196));
    chip_setting_ticket_value_dcr(a1, 32);
    *(_BYTE *)(a1 + 145) = 0;
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00060BB0) --------------------------------------------------------
__int64 __fastcall sub_60BB0(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  _BYTE v9[40]; // [sp+40h] [bp+10h] BYREF
  _BYTE v10[4080]; // [sp+1040h] [bp+1010h] BYREF
  _DWORD v11[7]; // [sp+2040h] [bp+2010h] BYREF
  int v12; // [sp+205Ch] [bp+202Ch]
  int v13; // [sp+2060h] [bp+2030h]
  unsigned int i; // [sp+2064h] [bp+2034h]

  v13 = 0;
  for ( i = 0; i <= 4; ++i )
  {
    v3 = snprintf(&v10[v13], 4096 - v13, "%02x ", *(unsigned __int8 *)(i + a2 + 3));
    v13 += v3;
  }
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "work_id: %02x diff %02x", *(unsigned __int8 *)(a2 + 9), *(_BYTE *)(a2 + 8) & 0x7F);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
    83,
    "dump_nonce_dcr",
    14,
    148,
    20,
    v9);
  V_LOCK();
  logfmt_raw(
    v9,
    0x1000u,
    0,
    "back nonce: %s B:%3d S:%1d",
    v10,
    *(unsigned __int8 *)(a3 + 48),
    (*(unsigned __int8 *)(a3 + 49) >> 6) & 3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
    83,
    "dump_nonce_dcr",
    14,
    149,
    20,
    v9);
  i = 0;
  v13 = 0;
  while ( i <= 3 )
  {
    v4 = snprintf(&v10[v13], 4096 - v13, "%02x", *(unsigned __int8 *)(i + a3 + 48));
    v13 += v4;
    ++i;
  }
  V_LOCK();
  sub_5CC94((int)v11, *(int *)(a1 + 140));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "asic %d core %d addr_interval %d",
    *(_DWORD *)(a3 + 8),
    *(_DWORD *)(a3 + 12),
    *(_DWORD *)(a1 + 240));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
    83,
    "dump_nonce_dcr",
    14,
    155,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "nonce: %s", v10);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
           83,
           "dump_nonce_dcr",
           14,
           156,
           20,
           v9);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00060F2C) --------------------------------------------------------
int __fastcall packet_2_nonce_dcr(unsigned int *a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7)
{
  int v8; // r0
  int v9; // r1
  unsigned __int16 v13; // [sp+14h] [bp+14h]
  unsigned int v14; // [sp+18h] [bp+18h]
  unsigned __int8 v15; // [sp+1Fh] [bp+1Fh]

  if ( (char)a2[10] >= 0 )
    return 1;
  v14 = a1[156];
  *(_QWORD *)a3 = *(_QWORD *)(8 * (unsigned __int8)a2[9] + v14);
  *a7 = *(_DWORD *)(8 * (unsigned __int8)a2[9] + v14);
  strcpy((char *)(a3 + 16), (const char *)(32 * ((unsigned __int8)a2[9] + 32) + v14));
  *(_BYTE *)(a3 + 52) = a2[3];
  memcpy((void *)(a3 + 53), (const void *)(180 * (unsigned __int8)a2[9] + 5260 + v14), 0xBu);
  memcpy((void *)(a3 + 48), a2 + 4, 4u);
  *(_BYTE *)(a3 + 64) = a2[8];
  *(_BYTE *)(a3 + 65) = a2[9] & 0x7F;
  v15 = (unsigned __int8)a2[3] / a1[60];
  if ( v15 >= (int)a1[49] )
  {
    v8 = rand();
    sub_1A38EC(v8, a1[49]);
    *a6 = v9;
  }
  else
  {
    *a6 = v15;
  }
  *(_DWORD *)(a3 + 8) = *a6;
  *(_DWORD *)(a3 + 12) = (unsigned __int8)a2[4];
  v13 = BM_CRC5(a2 + 2, 0x43u);
  if ( v13 == (a2[10] & 0x1F) )
  {
    memcpy(dest, (const void *)(a3 + 48), 4u);
    *a4 = 1;
    return 0;
  }
  else
  {
    printf("get nonce crc error calc value %04x expected value %04x\n", v13, a2[10] & 0x1F);
    return 2;
  }
}
// 6103C: variable 'v9' is possibly undefined

//----- (000610B4) --------------------------------------------------------
bool __fastcall sub_610B4(int a1)
{
  unsigned int v3; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v3 = *(_DWORD *)(a1 + 196);
  for ( i = 0; i <= 2; ++i )
  {
    sub_5CEE8(a1, v3);
    usleep(0x2710u);
    if ( *(_DWORD *)(a1 + 236) >= v3 )
      break;
  }
  return *(_DWORD *)(a1 + 236) == v3;
}

//----- (0006110C) --------------------------------------------------------
int __fastcall makeup_chip_addr_dcr(_BYTE *a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    a1[i] = v5 * i;
  *a1 = rand();
  return v5;
}

//----- (00061168) --------------------------------------------------------
int __fastcall setup_all_chip_dcr(int a1)
{
  char *v2; // r5
  char v3; // r4
  char v4; // r0
  int v6; // [sp+14h] [bp+4h]
  _BYTE v7[12]; // [sp+1Ch] [bp+Ch] BYREF
  char *v8; // [sp+101Ch] [bp+100Ch]
  int v9; // [sp+1020h] [bp+1010h]
  unsigned __int16 i; // [sp+1026h] [bp+1016h]

  v6 = a1;
  v9 = *(_DWORD *)(a1 + 196);
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s", "setup_all_chip_dcr");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
    83,
    "setup_all_chip_dcr",
    18,
    248,
    60,
    v7);
  *(_DWORD *)(v6 + 240) = makeup_chip_addr_dcr(*(_BYTE **)(v6 + 296), v9);
  (*(void (__fastcall **)(int, _DWORD, int))(v6 + 148))(v6, *(_DWORD *)(v6 + 296), v9);
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get addr after open cores and set frequency.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
    83,
    "setup_all_chip_dcr",
    18,
    263,
    60,
    v7);
  if ( !sub_610B4(v6) )
    return 3;
  sub_5FD64(v6, 96, 48);
  sub_5FDAC(v6, 8, 0);
  chip_setting_ticket_value_dcr(v6, 255);
  chip_setting_misc_dcr(v6);
  v8 = (char *)calloc(1u, 0x118u);
  for ( i = 0; i <= 0xBFu; ++i )
  {
    sub_5FEC8(v6, i, 2, 23130);
    usleep(0x4E20u);
    v2 = v8 + 40;
    v3 = *(_DWORD *)(v6 + 136);
    v4 = rand();
    memset(v2, (unsigned __int8)(v4 + v3), 0xB4u);
    push_work_base(v6, (int)v8);
    usleep(0x3D090u);
  }
  free(v8);
  if ( *(_BYTE *)(v6 + 268) != 1 )
    *(_DWORD *)(v6 + 272) = (int)*(float *)(v6 + 760);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00061408) --------------------------------------------------------
int __fastcall set_baud_dcr(int a1, char *a2)
{
  return chip_setting_fuart_cfg_dcr(a1, a2);
}

//----- (00061424) --------------------------------------------------------
int __fastcall sub_61424(int a1, int a2)
{
  int v6; // [sp+1Ch] [bp+Ch] BYREF
  int i; // [sp+101Ch] [bp+100Ch]

  for ( i = 31; i >= 0; --i )
  {
    V_LOCK();
    logfmt_raw(&v6, 0x1000u, 0, "%02x Vs %02x", *(unsigned __int8 *)(a1 + i), *(unsigned __int8 *)(a2 + i));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
      83,
      "fulltest_dcr",
      12,
      306,
      60,
      &v6);
    if ( *(unsigned __int8 *)(a1 + i) < (unsigned int)*(unsigned __int8 *)(a2 + i) )
      return 1;
    if ( *(unsigned __int8 *)(a1 + i) > (unsigned int)*(unsigned __int8 *)(a2 + i) )
      return 0;
  }
  return 1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00061570) --------------------------------------------------------
int __fastcall sub_61570(const char *a1, int a2, int a3)
{
  int i; // [sp+14h] [bp+14h]

  printf("%s[%3d] ", a1, a3);
  for ( i = 0; i < a3; ++i )
    printf("%02x", *(unsigned __int8 *)(i + a2));
  return putchar(10);
}

//----- (000615C4) --------------------------------------------------------
int __fastcall check_nonce_dcr(int a1, unsigned __int8 *a2)
{
  int v4; // [sp+Ch] [bp-4h]
  int v7; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v8[20]; // [sp+101Ch] [bp+100Ch] BYREF
  char v9[180]; // [sp+103Ch] [bp+102Ch] BYREF
  unsigned __int8 v10; // [sp+10F3h] [bp+10E3h]
  unsigned int v11; // [sp+10F4h] [bp+10E4h]
  int v12; // [sp+10F8h] [bp+10E8h]
  unsigned __int8 *v13; // [sp+10FCh] [bp+10ECh]

  v13 = a2;
  v12 = *(_DWORD *)(a1 + 624);
  v11 = *(_DWORD *)(v12 + 4 * (a2[65] + 7040));
  memset(v9, 0, sizeof(v9));
  memcpy(v9, (const void *)(v12 + 180 * v13[65] + 5120), 0x8Cu);
  memcpy(&v9[140], v13 + 48, 4u);
  memcpy(&v9[144], v13 + 52, 0xCu);
  memcpy(&v9[176], (const void *)(v12 + 180 * v13[65] + 5291), 4u);
  decred_hash((int)v8, v9);
  v10 = target_to_diff_dcr((int)v8);
  if ( v10 > 0x1Fu )
  {
    if ( v10 == v13[64] )
    {
      if ( v10 < v11 || (unsigned __int8)sub_61424((int)v8, v12 + 32 * (v13[65] + 896)) != 1 )
      {
        V_LOCK();
        logfmt_raw(&v7, 0x1000u, 0, "hw diff (%d<%d) not reach pool", v13[64], v11);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
          83,
          "check_nonce_dcr",
          15,
          367,
          20,
          &v7);
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(&v7, 0x1000u, 0, "diff not match (%d!=%d) expected diff %d", v10, v13[64], v11, v4, a2, a1);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
        83,
        "check_nonce_dcr",
        15,
        362,
        20,
        &v7);
      return 3;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(
      &v7,
      0x1000u,
      0,
      "hw error calculate diff %d ans diff %d TICKET_MASK_DCR %d",
      v10,
      v13[64],
      32,
      v4,
      a2,
      a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/backend_dcr.c",
      83,
      "check_nonce_dcr",
      15,
      357,
      20,
      &v7);
    return 2;
  }
}
// 6176C: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00061928) --------------------------------------------------------
int __fastcall get_chip_status_dcr(int a1)
{
  sub_5FAB8(a1, 52, 0);
  sub_5FAB8(a1, 60, 0);
  return 0;
}

//----- (00061950) --------------------------------------------------------
int get_algo_type_dcr()
{
  return 0;
}

//----- (0006196C) --------------------------------------------------------
int __fastcall softreset_all_chip_dcr(int a1)
{
  sub_5FD64(a1, 252, -1414856447);
  sleep(7u);
  sub_5D4D0(a1);
  return 0;
}

//----- (0006199C) --------------------------------------------------------
int __fastcall get_theory_hashrate_dcr(int a1, double *a2)
{
  *a2 = *(float *)(a1 + 760) * 760.0 * 1000.0 * 1000.0;
  return 0;
}

//----- (000619F0) --------------------------------------------------------
int set_boot_config_dcr()
{
  return 0;
}

//----- (00061A08) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_dcr(int a1)
{
  if ( !sub_5F6D4(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (00061A30) --------------------------------------------------------
int __fastcall read_sensor_temp_local_dcr(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_5F258(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_5F320(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00061A80) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_dcr(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_5F2BC(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_5F4F8(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00061AD0) --------------------------------------------------------
int parameter_update_dcr()
{
  return 0;
}

//----- (00061AF4) --------------------------------------------------------
int overclock_update_dcr()
{
  return 0;
}

//----- (00061B0C) --------------------------------------------------------
int get_pcba_test_level_dcr()
{
  return 0;
}

//----- (00061B24) --------------------------------------------------------
int __fastcall get_packet_remain_len_dcr(unsigned __int8 a1)
{
  return a1 - 1;
}

//----- (00061B40) --------------------------------------------------------
void *runtime_ctrl_dcr()
{
  void *dest; // [sp+54h] [bp+54h]

  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1EDEB0, 0x310u);
  return dest;
}
// 1EDEB0: using guessed type _UNKNOWN *off_1EDEB0;

//----- (00061B70) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_61B70(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (00061B94) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_61B94(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (00061BBC) --------------------------------------------------------
int __fastcall sub_61BBC(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 61C00: variable 'v3' is possibly undefined

//----- (00061C9C) --------------------------------------------------------
int __fastcall sub_61C9C(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00061DA0) --------------------------------------------------------
_BYTE *__fastcall sub_61DA0(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (00061DE8) --------------------------------------------------------
int __fastcall sub_61DE8(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_CKB2", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_CKB2",
    25,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_61B94((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_CKB2",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_CKB2",
    25,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_CKB2",
      25,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_CKB2",
          25,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_61B94((int)v12, *(int *)(a1 + 140));
    sub_61B70(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_CKB2",
      25,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 61F40: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000623D0) --------------------------------------------------------
int __fastcall sub_623D0(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_CKB2", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_CKB2",
    31,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 4456449;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000624C4) --------------------------------------------------------
int __fastcall sub_624C4(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_CKB2", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_CKB2",
    40,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 68;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000625D4) --------------------------------------------------------
int __fastcall sub_625D4(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_CKB2", 255, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_ticket_mask_CKB2",
    28,
    137,
    20,
    v5);
  v6[2] = 16711681;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000626F8) --------------------------------------------------------
int __fastcall sub_626F8(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_CKB2",
    21,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006298C) --------------------------------------------------------
int __fastcall sub_6298C(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_CKB2",
    25,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00062BB0) --------------------------------------------------------
unsigned int *__fastcall sub_62BB0(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 62BE8: variable 'v1' is possibly undefined

//----- (00062CC0) --------------------------------------------------------
int __fastcall sub_62CC0(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 524289;
  sub_62BB0(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_CKB2",
    21,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 62D40: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00062E14) --------------------------------------------------------
int __fastcall sub_62E14(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 8;
  sub_62BB0(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_CKB2",
    30,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 62EB6: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00062F94) --------------------------------------------------------
int __fastcall sub_62F94(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_CKB2", -1, 255, -1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_open_cores_CKB2",
    27,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 16711681;
  v8[0] = a3;
  BYTE1(v8[3]) = -1;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, int))(a1 + 168))(a1, v8, -1, -1);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000630C4) --------------------------------------------------------
int __fastcall sub_630C4(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_CKB2");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_close_cores_CKB2",
    28,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 16711681;
  v6[0] = 0;
  BYTE1(v6[3]) = -1;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, int))(a1 + 168))(a1, v6, -1, -1);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000631D4) --------------------------------------------------------
int __fastcall sub_631D4(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_CKB2",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_start_nonce_offset_CKB2",
    35,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_61B94((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_CKB2",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_start_nonce_offset_CKB2",
        35,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 63334: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000634C4) --------------------------------------------------------
int __fastcall sub_634C4(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  unsigned __int8 v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_CKB2", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_pmdata_CKB2",
    23,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 255;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_CKB2", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_pmdata_CKB2",
        23,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 255 )
        {
          v12 = -1;
          v5 = 0;
          sub_61DA0(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_61B94((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_CKB2",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_pmdata_CKB2",
            23,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 255 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00063928) --------------------------------------------------------
int __fastcall sub_63928(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_CKB2", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_CKB2",
    26,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 255;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 255 )
        {
          sub_61DA0(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_61B94((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_CKB2",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_CKB2",
            26,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_CKB2", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_CKB2",
      26,
      436,
      100,
      v5);
    return -1;
  }
}
// 63B36: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00063D14) --------------------------------------------------------
int __fastcall sub_63D14(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4194305;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_CKB2",
    27,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00063E30) --------------------------------------------------------
int __fastcall sub_63E30(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 255;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (00063E7C) --------------------------------------------------------
int __fastcall sub_63E7C(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 255;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (00063F9C) --------------------------------------------------------
int __fastcall sub_63F9C(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_63E30(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_63E7C(a1, a2, a3, s, a6, n);
}

//----- (00064010) --------------------------------------------------------
int __fastcall sub_64010(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_63F9C(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (000640B4) --------------------------------------------------------
int __fastcall sub_640B4(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_63F9C(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00064158) --------------------------------------------------------
int __fastcall sub_64158(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_63F9C(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (000641BC) --------------------------------------------------------
int __fastcall sub_641BC(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_63F9C(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00064220) --------------------------------------------------------
int __fastcall sub_64220(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_CKB2",
        46,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_CKB2",
      46,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000643F8) --------------------------------------------------------
int __fastcall sub_643F8(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_CKB2",
        47,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_CKB2",
      47,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000645D4) --------------------------------------------------------
int __fastcall sub_645D4(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_63E30(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0006460C) --------------------------------------------------------
int __fastcall sub_6460C(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00064660) --------------------------------------------------------
int __fastcall sub_64660(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 52;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 52 )
    {
      V_LOCK();
      sub_61B94((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_CKB2",
        31,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006492C) --------------------------------------------------------
int __fastcall sub_6492C(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (000649B8) --------------------------------------------------------
unsigned int __fastcall sub_649B8(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0xCu);
  memset(v13, 0, 0xCu);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 1, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_61B94((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_CKB2",
        32,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00064C64) --------------------------------------------------------
int __fastcall sub_64C64(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (00064CAC) --------------------------------------------------------
int __fastcall sub_64CAC(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00064D04) --------------------------------------------------------
int __fastcall sub_64D04(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00064D64) --------------------------------------------------------
int __fastcall sub_64D64(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00064DC8) --------------------------------------------------------
int __fastcall sub_64DC8(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00064E24) --------------------------------------------------------
int __fastcall sub_64E24(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = -*(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_CKB2", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_CKB2",
    32,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_61B94((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_CKB2",
      32,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 64FE0: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000651A4) --------------------------------------------------------
int __fastcall sub_651A4(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = -1;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_CKB2", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_CKB2",
    44,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_61B94((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_CKB2",
      44,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 65356: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006551C) --------------------------------------------------------
int __fastcall global_idx_init_ckb2(int a1)
{
  void *s; // [sp+Ch] [bp+Ch]

  s = malloc(0x3E08u);
  memset(s, 0, 0x3E08u);
  *(_DWORD *)(a1 + 624) = s;
  printf("__custom_data init %p\n", s);
  return 0;
}

//----- (0006555C) --------------------------------------------------------
int __fastcall global_idx_free_ckb2(int a1)
{
  free(*(void **)(a1 + 624));
  return 0;
}

//----- (0006557C) --------------------------------------------------------
__int64 __fastcall sub_6557C(int a1, unsigned __int8 a2)
{
  int v2; // r0
  _BYTE v6[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[4088]; // [sp+1018h] [bp+1008h] BYREF
  int v8; // [sp+2018h] [bp+2008h]
  unsigned int i; // [sp+201Ch] [bp+200Ch]

  v8 = 0;
  for ( i = 0; i <= 0x2F; ++i )
  {
    v2 = snprintf(&v7[v8], 4096 - v8, "%02x ", *(unsigned __int8 *)(i + a1 + 40));
    v8 += v2;
  }
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "ckb dump work jobid %s, work count %d", a1 + 8, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
    85,
    "dump_work_ckb2",
    14,
    84,
    20,
    v6);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "dump work: %s", v7);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
           85,
           "dump_work_ckb2",
           14,
           85,
           20,
           v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00065710) --------------------------------------------------------
int __fastcall work_2_packet_ckb2(int a1, int a2, _BYTE *a3, _DWORD *a4)
{
  char v4; // r3
  _BYTE v8[20]; // [sp+24h] [bp+14h] BYREF
  unsigned __int16 v9; // [sp+1026h] [bp+1016h]
  int v10; // [sp+1028h] [bp+1018h]
  int v11; // [sp+102Ch] [bp+101Ch]
  int v12; // [sp+1030h] [bp+1020h]
  _BYTE *v13; // [sp+1034h] [bp+1024h]

  v13 = a3;
  v12 = a2;
  v11 = 0;
  v10 = *(_DWORD *)(a1 + 624);
  *a3 = 85;
  v13[1] = -86;
  v13[2] = 32;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    v13[2] |= 0x10u;
  *(_QWORD *)(8 * *(unsigned __int8 *)(v10 + 15872) + v10) = *(_QWORD *)v12;
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 15872) + 2816)) = *(_DWORD *)(v12 + 88);
  memcpy((void *)(v10 + 32 * (*(unsigned __int8 *)(v10 + 15872) + 368)), (const void *)(v12 + 92), 0x20u);
  strcpy((char *)(v10 + 32 * (*(unsigned __int8 *)(v10 + 15872) + 32)), (const char *)(v12 + 8));
  memcpy((void *)(v10 + 48 * *(unsigned __int8 *)(v10 + 15872) + 5120), (const void *)(v12 + 40), 0x30u);
  v4 = *(_BYTE *)(v10 + 15872);
  *(_BYTE *)(v10 + 15872) = v4 + 1;
  v13[3] = v4;
  *(_BYTE *)(v10 + 15872) &= ~0x80u;
  memcpy(v13 + 4, (const void *)(v12 + 40), 0x30u);
  if ( !memcmp(&last_header_ckb2, (const void *)(v12 + 40), 0x30u) )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
      85,
      "work_2_packet_ckb2",
      18,
      117,
      80,
      v8);
    sub_6557C(v12, v13[3]);
  }
  memcpy(&last_header_ckb2, (const void *)(v12 + 40), 0x30u);
  v11 = 50;
  v9 = CRC16_v1(v13 + 2, 50);
  v13[52] = HIBYTE(v9);
  v13[53] = v9;
  *a4 = 54;
  if ( *(_BYTE *)(a1 + 145) && *(_BYTE *)(a1 + 146) )
  {
    memset(*(void **)(a1 + 264), 0, 48 * *(_DWORD *)(a1 + 196));
    chip_setting_ticket_value_ckb2(a1, 25);
    *(_BYTE *)(a1 + 145) = 0;
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00065AC8) --------------------------------------------------------
__int64 __fastcall sub_65AC8(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  _BYTE v9[40]; // [sp+40h] [bp+10h] BYREF
  _BYTE v10[4080]; // [sp+1040h] [bp+1010h] BYREF
  _DWORD v11[7]; // [sp+2040h] [bp+2010h] BYREF
  int v12; // [sp+205Ch] [bp+202Ch]
  int v13; // [sp+2060h] [bp+2030h]
  unsigned int i; // [sp+2064h] [bp+2034h]

  v13 = 0;
  for ( i = 0; i <= 4; ++i )
  {
    v3 = snprintf(&v10[v13], 4096 - v13, "%02x ", *(unsigned __int8 *)(i + a2 + 3));
    v13 += v3;
  }
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "work_id: %02x diff %02x", *(unsigned __int8 *)(a2 + 10), *(_BYTE *)(a2 + 9) & 0x7F);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
    85,
    "dump_nonce_ckb2",
    15,
    147,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "back nonce: %s", v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
    85,
    "dump_nonce_ckb2",
    15,
    148,
    20,
    v9);
  i = 0;
  v13 = 0;
  while ( i <= 0xF )
  {
    v4 = snprintf(&v10[v13], 4096 - v13, "%02x ", *(unsigned __int8 *)(i + a3 + 48));
    v13 += v4;
    ++i;
  }
  V_LOCK();
  sub_61B94((int)v11, *(int *)(a1 + 140));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "asic %d core %d addr_interval %d",
    *(_DWORD *)(a3 + 8),
    *(_DWORD *)(a3 + 12),
    *(_DWORD *)(a1 + 240));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
    85,
    "dump_nonce_ckb2",
    15,
    154,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "nonce: %s", v10);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
           85,
           "dump_nonce_ckb2",
           15,
           155,
           20,
           v9);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00065E20) --------------------------------------------------------
int __fastcall packet_2_nonce_ckb2(unsigned int *a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7)
{
  int v8; // r0
  int v9; // r1
  unsigned __int16 v13; // [sp+14h] [bp+14h]
  unsigned int v14; // [sp+20h] [bp+20h]
  unsigned __int8 v15; // [sp+27h] [bp+27h]

  if ( (char)a2[11] >= 0 )
    return 1;
  v14 = a1[156];
  *(_QWORD *)a3 = *(_QWORD *)(8 * (unsigned __int8)a2[10] + v14);
  *a7 = *(_DWORD *)(8 * (unsigned __int8)a2[10] + v14);
  strcpy((char *)(a3 + 16), (const char *)(32 * ((unsigned __int8)a2[10] + 32) + v14));
  memcpy((void *)(a3 + 48), (const void *)(48 * (unsigned __int8)a2[10] + 5120 + v14 + 32), 0x10u);
  memcpy((void *)(a3 + 58), a2 + 3, 7u);
  *(_BYTE *)(a3 + 65) = a2[10] & 0x7F;
  v15 = (unsigned __int8)a2[3] / a1[60];
  if ( v15 >= (int)a1[49] )
  {
    v8 = rand();
    sub_1A38EC(v8, a1[49]);
    *a6 = v9;
  }
  else
  {
    *a6 = v15;
  }
  *(_DWORD *)(a3 + 8) = *a6;
  *(_DWORD *)(a3 + 12) = (a2[8] & 7) + 4 * (a2[8] >> 3);
  v13 = BM_CRC5(a2 + 2, 0x4Bu);
  if ( v13 == (a2[11] & 0x1F) )
  {
    memcpy(dest, (const void *)(a3 + 48), 0x10u);
    *a4 = 1;
    return 0;
  }
  else
  {
    printf("get nonce crc error calc value %04x expected value %04x\n", v13, a2[11] & 0x1F);
    return 2;
  }
}
// 65F32: variable 'v9' is possibly undefined

//----- (00065FC0) --------------------------------------------------------
bool __fastcall sub_65FC0(int a1)
{
  unsigned int v3; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v3 = *(_DWORD *)(a1 + 196);
  for ( i = 0; i <= 2; ++i )
  {
    sub_61DE8(a1, v3);
    usleep(0x2710u);
    if ( *(_DWORD *)(a1 + 236) >= v3 )
      break;
  }
  return *(_DWORD *)(a1 + 236) == v3;
}

//----- (00066018) --------------------------------------------------------
int __fastcall makeup_chip_addr_ckb2(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (00066068) --------------------------------------------------------
int __fastcall setup_all_chip_ckb2(int a1)
{
  char *v2; // r5
  char v3; // r4
  char v4; // r0
  int v6; // [sp+14h] [bp+4h]
  _BYTE v7[8]; // [sp+18h] [bp+8h] BYREF
  char *v8; // [sp+1018h] [bp+1008h]
  int v9; // [sp+101Ch] [bp+100Ch]

  v6 = a1;
  v9 = *(_DWORD *)(a1 + 196);
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s", "setup_all_chip_ckb2");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
    85,
    "setup_all_chip_ckb2",
    19,
    238,
    60,
    v7);
  if ( !sub_65FC0(v6) )
    return 3;
  *(_DWORD *)(v6 + 240) = makeup_chip_addr_ckb2(*(_DWORD *)(v6 + 296), v9);
  (*(void (__fastcall **)(int, _DWORD, int))(v6 + 148))(v6, *(_DWORD *)(v6 + 296), v9);
  sub_63D14(v6, 0);
  chip_setting_ticket_value_ckb2(v6, 255);
  chip_setting_misc_ckb2(v6);
  v8 = (char *)calloc(1u, 0x80u);
  v2 = v8 + 40;
  v3 = *(_DWORD *)(v6 + 136);
  v4 = rand();
  memset(v2, (unsigned __int8)(v4 + v3), 0x30u);
  push_work_base(v6, (int)v8);
  free(v8);
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get addr after open cores and set frequency.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
    85,
    "setup_all_chip_ckb2",
    19,
    266,
    60,
    v7);
  if ( !sub_65FC0(v6) )
    return 3;
  if ( *(_BYTE *)(v6 + 268) != 1 )
    *(_DWORD *)(v6 + 272) = (int)*(float *)(v6 + 760);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000662AC) --------------------------------------------------------
int __fastcall set_baud_ckb2(int a1, char *a2)
{
  return chip_setting_fuart_cfg_ckb2(a1, a2);
}

//----- (000662C8) --------------------------------------------------------
int __fastcall sub_662C8(int a1, int a2)
{
  unsigned __int8 v3; // [sp+Bh] [bp+Bh]
  int i; // [sp+Ch] [bp+Ch]

  v3 = 1;
  for ( i = 0; i <= 31; ++i )
  {
    if ( *(unsigned __int8 *)(i + a1) < (unsigned int)*(unsigned __int8 *)(i + a2) )
      return 1;
    if ( *(unsigned __int8 *)(i + a1) > (unsigned int)*(unsigned __int8 *)(i + a2) )
      return 0;
  }
  return v3;
}

//----- (0006632C) --------------------------------------------------------
int __fastcall check_nonce_ckb2(int a1, unsigned __int8 *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r6
  _DWORD *v4; // lr
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v10; // [sp+Ch] [bp-4h]
  _BYTE v13[4088]; // [sp+18h] [bp+8h] BYREF
  _BYTE v14[24]; // [sp+1018h] [bp+1008h] BYREF
  _BYTE v15[24]; // [sp+1038h] [bp+1028h] BYREF
  _BYTE v16[16]; // [sp+1058h] [bp+1048h] BYREF
  unsigned __int8 v17; // [sp+106Bh] [bp+105Bh]
  unsigned int v18; // [sp+106Ch] [bp+105Ch]
  int v19; // [sp+1070h] [bp+1060h]
  unsigned __int8 *v20; // [sp+1074h] [bp+1064h]

  v20 = a2;
  v19 = *(_DWORD *)(a1 + 624);
  v18 = *(_DWORD *)(v19 + 4 * (a2[65] + 2816));
  v2 = (_DWORD *)(48 * a2[65] + 5120 + v19);
  v3 = v15;
  v4 = v2 + 12;
  do
  {
    v5 = v2[1];
    v6 = v2[2];
    v7 = v2[3];
    *v3 = *v2;
    v3[1] = v5;
    v3[2] = v6;
    v3[3] = v7;
    v2 += 4;
    v3 += 4;
  }
  while ( v2 != v4 );
  memcpy(v16, v20 + 48, sizeof(v16));
  EaglesongHash((int)v14, (int)v15, 0x30u);
  v17 = target_to_diff_ckb((int)v14);
  if ( v17 > 0x18u )
  {
    if ( v17 == v20[64] )
    {
      if ( v20[64] < v18 || (unsigned __int8)sub_662C8((int)v14, v19 + 32 * (v20[65] + 368)) != 1 )
      {
        V_LOCK();
        logfmt_raw(v13, 0x1000u, 0, "hw diff (%d<%d) not reach pool", v20[64], v18);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
          85,
          "check_nonce_ckb2",
          16,
          328,
          20,
          v13);
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "diff not match (%d!=%d) expected diff %d", v17, v20[64], v18, v10, a2, a1);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
        85,
        "check_nonce_ckb2",
        16,
        323,
        20,
        v13);
      return 3;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(
      v13,
      0x1000u,
      0,
      "hw error calculate diff %d ans diff %d TICKET_MASK_CKB2 %d",
      v17,
      v20[64],
      25,
      v10,
      a2,
      a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/backend_ckb2.c",
      85,
      "check_nonce_ckb2",
      16,
      318,
      20,
      v13);
    return 2;
  }
}
// 66472: variable 'v10' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00066628) --------------------------------------------------------
int get_chip_status_ckb2()
{
  return 0;
}

//----- (00066640) --------------------------------------------------------
int get_algo_type_ckb2()
{
  return 0;
}

//----- (0006665C) --------------------------------------------------------
int __fastcall softreset_all_chip_ckb2(int a1)
{
  sub_623D0(a1);
  return 0;
}

//----- (00066674) --------------------------------------------------------
int __fastcall get_theory_hashrate_ckb2(int a1, double *a2)
{
  *a2 = *(float *)(a1 + 760) * 352.0 * 1000.0 * 1000.0;
  return 0;
}

//----- (000666C8) --------------------------------------------------------
int set_boot_config_ckb2()
{
  return 0;
}

//----- (000666E0) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_ckb2(int a1)
{
  if ( !sub_645D4(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (00066708) --------------------------------------------------------
int __fastcall read_sensor_temp_local_ckb2(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_64158(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_64220(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00066758) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_ckb2(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_641BC(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_643F8(a1, a2, a3, a8);
  }
  return 0;
}

//----- (000667A8) --------------------------------------------------------
int parameter_update_ckb2()
{
  return 0;
}

//----- (000667CC) --------------------------------------------------------
int overclock_update_ckb2()
{
  return 0;
}

//----- (000667E4) --------------------------------------------------------
int get_pcba_test_level_ckb2()
{
  return 0;
}

//----- (000667FC) --------------------------------------------------------
int __fastcall get_packet_remain_len_ckb2(unsigned __int8 a1)
{
  return a1 - 1;
}

//----- (00066818) --------------------------------------------------------
void *runtime_ctrl_ckb2()
{
  void *dest; // [sp+4Ch] [bp+4Ch]

  dword_1EE4F4 = -1621098496;
  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1EE1F0, 0x310u);
  return dest;
}
// 1EE1F0: using guessed type _UNKNOWN *off_1EE1F0;
// 1EE4F4: using guessed type int dword_1EE4F4;

//----- (00066868) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_66868(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (0006688C) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6688C(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (000668B4) --------------------------------------------------------
int __fastcall sub_668B4(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 668F8: variable 'v3' is possibly undefined

//----- (00066994) --------------------------------------------------------
int __fastcall sub_66994(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00066A98) --------------------------------------------------------
_BYTE *__fastcall sub_66A98(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (00066AE0) --------------------------------------------------------
int __fastcall sub_66AE0(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_VBK", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_VBK",
    24,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_6688C((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_VBK",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_VBK",
    24,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_VBK",
      24,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_VBK",
          24,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_6688C((int)v12, *(int *)(a1 + 140));
    sub_66868(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_VBK",
      24,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 66C38: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000670C8) --------------------------------------------------------
int __fastcall sub_670C8(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_VBK", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_VBK",
    30,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 4456449;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000671BC) --------------------------------------------------------
int __fastcall sub_671BC(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_VBK", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_VBK",
    39,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 68;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000672CC) --------------------------------------------------------
int __fastcall sub_672CC(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_VBK", 20, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_ticket_mask_VBK",
    27,
    137,
    20,
    v5);
  v6[2] = 1310721;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000673F0) --------------------------------------------------------
int __fastcall sub_673F0(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_VBK",
    20,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00067684) --------------------------------------------------------
int __fastcall sub_67684(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_VBK",
    24,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000678A8) --------------------------------------------------------
unsigned int *__fastcall sub_678A8(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 678E0: variable 'v1' is possibly undefined

//----- (000679B8) --------------------------------------------------------
int __fastcall sub_679B8(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 786433;
  sub_678A8(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_VBK",
    20,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 67A38: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00067B0C) --------------------------------------------------------
int __fastcall sub_67B0C(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 12;
  sub_678A8(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_VBK",
    29,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 67BAE: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00067C8C) --------------------------------------------------------
int __fastcall sub_67C8C(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_VBK", 5, 132, 20000);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_open_cores_VBK",
    26,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 8650753;
  v8[0] = a3;
  BYTE1(v8[3]) = 5;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v8, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00067DB8) --------------------------------------------------------
int __fastcall sub_67DB8(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_VBK");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_close_cores_VBK",
    27,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 8650753;
  v6[0] = 0;
  BYTE1(v6[3]) = 5;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v6, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00067EC8) --------------------------------------------------------
int __fastcall sub_67EC8(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_VBK",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_start_nonce_offset_VBK",
    34,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_6688C((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_VBK",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_start_nonce_offset_VBK",
        34,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 68028: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000681B8) --------------------------------------------------------
int __fastcall sub_681B8(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  char v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_VBK", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_pmdata_VBK",
    22,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 60;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_VBK", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_pmdata_VBK",
        22,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 60 )
        {
          v12 = 60;
          v5 = 0;
          sub_66A98(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_6688C((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_VBK",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_pmdata_VBK",
            22,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 60 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006861C) --------------------------------------------------------
int __fastcall sub_6861C(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_VBK", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_VBK",
    25,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 108;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 108 )
        {
          sub_66A98(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_6688C((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_VBK",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_VBK",
            25,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_VBK", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_VBK",
      25,
      436,
      100,
      v5);
    return -1;
  }
}
// 6882A: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00068A08) --------------------------------------------------------
int __fastcall sub_68A08(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4194305;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_VBK",
    26,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00068B24) --------------------------------------------------------
int __fastcall sub_68B24(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 32;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (00068B70) --------------------------------------------------------
int __fastcall sub_68B70(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 32;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (00068C90) --------------------------------------------------------
int __fastcall sub_68C90(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_68B24(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_68B70(a1, a2, a3, s, a6, n);
}

//----- (00068D04) --------------------------------------------------------
int __fastcall sub_68D04(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_68C90(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00068DA8) --------------------------------------------------------
int __fastcall sub_68DA8(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_68C90(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00068E4C) --------------------------------------------------------
int __fastcall sub_68E4C(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_68C90(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00068EB0) --------------------------------------------------------
int __fastcall sub_68EB0(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_68C90(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00068F14) --------------------------------------------------------
int __fastcall sub_68F14(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_VBK",
        45,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_VBK",
      45,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000690EC) --------------------------------------------------------
int __fastcall sub_690EC(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_VBK",
        46,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_VBK",
      46,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000692C8) --------------------------------------------------------
int __fastcall sub_692C8(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_68B24(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00069300) --------------------------------------------------------
int __fastcall sub_69300(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00069354) --------------------------------------------------------
int __fastcall sub_69354(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 52;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 52 )
    {
      V_LOCK();
      sub_6688C((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_VBK",
        30,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00069620) --------------------------------------------------------
int __fastcall sub_69620(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (000696AC) --------------------------------------------------------
unsigned int __fastcall sub_696AC(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0x30u);
  memset(v13, 0, 0x30u);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 4, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_6688C((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_VBK",
        31,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00069958) --------------------------------------------------------
int __fastcall sub_69958(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (000699A0) --------------------------------------------------------
int __fastcall sub_699A0(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000699F8) --------------------------------------------------------
int __fastcall sub_699F8(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00069A58) --------------------------------------------------------
int __fastcall sub_69A58(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00069ABC) --------------------------------------------------------
int __fastcall sub_69ABC(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00069B18) --------------------------------------------------------
int __fastcall sub_69B18(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = 5 * *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_VBK", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_VBK",
    31,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_6688C((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_VBK",
      31,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 69CD8: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00069E9C) --------------------------------------------------------
int __fastcall sub_69E9C(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 5;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_VBK", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_VBK",
    43,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_6688C((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_VBK",
      43,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 6A04C: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006A214) --------------------------------------------------------
int __fastcall global_idx_init_vbk(int a1)
{
  void *s; // [sp+Ch] [bp+Ch]

  s = malloc(0x7008u);
  memset(s, 0, 0x7008u);
  *(_DWORD *)(a1 + 624) = s;
  printf("__custom_data init %p\n", s);
  return 0;
}

//----- (0006A254) --------------------------------------------------------
int __fastcall global_idx_free_vbk(int a1)
{
  free(*(void **)(a1 + 624));
  return 0;
}

//----- (0006A274) --------------------------------------------------------
int __fastcall dump_work_vbk(int a1, unsigned __int8 a2)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  printf("dump work wc %d:", a2);
  for ( i = 0; i <= 0x3F; ++i )
    printf("%02x ", *(unsigned __int8 *)(i + a1 + 16));
  return putchar(10);
}

//----- (0006A2C8) --------------------------------------------------------
int __fastcall work_2_packet_vbk(int a1, int a2, _BYTE *a3, _DWORD *a4)
{
  char v4; // r3
  _BYTE v7[20]; // [sp+24h] [bp+14h] BYREF
  unsigned __int16 v8; // [sp+1026h] [bp+1016h]
  int v9; // [sp+1028h] [bp+1018h]
  int v10; // [sp+102Ch] [bp+101Ch]
  int v11; // [sp+1030h] [bp+1020h]
  _BYTE *v12; // [sp+1034h] [bp+1024h]

  v12 = a3;
  v11 = a2;
  v10 = *(_DWORD *)(a1 + 624);
  *a3 = 85;
  v12[1] = -86;
  v12[2] = 32;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    v12[2] |= 0x10u;
  *(_QWORD *)(8 * *(unsigned __int8 *)(v10 + 28672) + v10) = *(_QWORD *)v11;
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 28672) + 5376)) = *(_DWORD *)(v11 + 84);
  memcpy((void *)(v10 + 24 * *(unsigned __int8 *)(v10 + 28672) + 22528), (const void *)(v11 + 88), 0x18u);
  *(_QWORD *)(8 * (*(unsigned __int8 *)(v10 + 28672) + 256) + v10) = *(_QWORD *)(v11 + 8);
  memcpy((void *)(v10 + ((*(unsigned __int8 *)(v10 + 28672) + 64) << 6)), (const void *)(v11 + 16), 0x40u);
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 28672) + 5120)) = *(_DWORD *)(v11 + 80);
  v4 = *(_BYTE *)(v10 + 28672);
  *(_BYTE *)(v10 + 28672) = v4 + 1;
  v12[4] = v4;
  *(_BYTE *)(v10 + 28672) = *(_BYTE *)(v10 + 28672);
  v12[3] = 64;
  memcpy(v12 + 5, (const void *)(v11 + 16), 0x40u);
  if ( !memcmp(&last_header, (const void *)(v11 + 16), 0x40u) )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_vbk/backend_vbk.c",
      83,
      "work_2_packet_vbk",
      17,
      123,
      80,
      v7);
    dump_work_vbk(v11, v12[4]);
  }
  memcpy(&last_header, (const void *)(v11 + 16), 0x40u);
  v9 = (unsigned __int8)v12[3] + 3;
  v8 = CRC16_v1(v12 + 2, v9);
  v12[69] = HIBYTE(v8);
  v12[70] = v8;
  *a4 = 71;
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006A650) --------------------------------------------------------
int __fastcall pakcet_2_nonce_vbk(int a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7)
{
  unsigned __int16 v11; // [sp+16h] [bp+16h]
  int v12; // [sp+18h] [bp+18h]
  unsigned __int8 v13; // [sp+1Fh] [bp+1Fh]

  if ( a2[2] != 8 || (char)a2[9] >= 0 )
    return 1;
  v12 = *(_DWORD *)(a1 + 624);
  *(_QWORD *)a3 = *(_QWORD *)(8 * (unsigned __int8)a2[8] + v12);
  *a7 = *(_DWORD *)(8 * (unsigned __int8)a2[8] + v12);
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(8 * ((unsigned __int8)a2[8] + 256) + v12);
  memcpy((void *)(a3 + 24), a2 + 3, 4u);
  *(_DWORD *)(a3 + 24) = _byteswap_ulong(*(_DWORD *)(a2 + 3));
  *(_BYTE *)(a3 + 28) = a2[7] & 0x7F;
  *(_BYTE *)(a3 + 29) = a2[8];
  *(_DWORD *)(a3 + 36) = *(_DWORD *)(v12 + 4 * ((unsigned __int8)a2[8] + 5120));
  memcpy((void *)(a3 + 40), (const void *)(((unsigned __int8)a2[8] << 6) + 4132 + v12), 0x10u);
  v13 = (unsigned int)(unsigned __int8)a2[3] / *(_DWORD *)(a1 + 240);
  *a6 = v13;
  *(_DWORD *)(a3 + 8) = v13;
  *(_DWORD *)(a3 + 12) = 0;
  v11 = BM_CRC5(a2 + 2, 8 * (unsigned __int8)a2[2] - 5);
  if ( v11 == (a2[9] & 0x1F) )
  {
    memcpy(dest, (const void *)(a3 + 24), 4u);
    *a4 = 1;
    return 0;
  }
  else
  {
    printf("get nonce crc error calc value %04x expected value %04x\n", v11, a2[9] & 0x1F);
    return 2;
  }
}

//----- (0006A7D0) --------------------------------------------------------
int __fastcall makeup_chip_addr_vbk(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (0006A820) --------------------------------------------------------
int __fastcall setup_all_chip_vbk(int a1)
{
  int v2; // [sp+14h] [bp+4h]
  _DWORD v3[1026]; // [sp+1Ch] [bp+Ch] BYREF

  v2 = a1;
  puts("setup_all_chip_vbk");
  v3[1024] = *(_DWORD *)(v2 + 624);
  *(_DWORD *)(v2 + 240) = makeup_chip_addr_vbk(*(_DWORD *)(v2 + 296), 4u);
  (*(void (__fastcall **)(int, _DWORD, int))(v2 + 148))(v2, *(_DWORD *)(v2 + 296), 4);
  sub_66AE0(v2, 4);
  sub_672CC(v2, 0x20u);
  sub_67C8C(v2, 0, 1);
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "get addr after open cores.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_vbk/backend_vbk.c",
    83,
    "setup_all_chip_vbk",
    18,
    215,
    60,
    v3);
  sub_66AE0(v2, 4);
  if ( *(_BYTE *)(v2 + 268) != 1 )
    *(_DWORD *)(v2 + 272) = (int)*(float *)(v2 + 760);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006A970) --------------------------------------------------------
int __fastcall set_baud_vbk(int a1, char *a2)
{
  return sub_673F0(a1, a2);
}

//----- (0006A98C) --------------------------------------------------------
int __fastcall sub_6A98C(int a1, int a2)
{
  unsigned int v3; // [sp+8h] [bp+8h]
  unsigned int v4; // [sp+Ch] [bp+Ch]
  unsigned __int8 v5; // [sp+13h] [bp+13h]
  int i; // [sp+14h] [bp+14h]

  v5 = 1;
  for ( i = 0; i <= 5; ++i )
  {
    v4 = HIBYTE(*(_DWORD *)(4 * i + a1))
       | (*(_DWORD *)(4 * i + a1) << 24)
       | (*(_DWORD *)(4 * i + a1) << 8) & 0xFF0000
       | (*(_DWORD *)(4 * i + a1) >> 8) & 0xFF00;
    v3 = HIBYTE(*(_DWORD *)(4 * i + a2))
       | (*(_DWORD *)(4 * i + a2) << 24)
       | (*(_DWORD *)(4 * i + a2) << 8) & 0xFF0000
       | (*(_DWORD *)(4 * i + a2) >> 8) & 0xFF00;
    if ( v4 > v3 )
      return 0;
    if ( v4 < v3 )
      return 1;
  }
  return v5;
}

//----- (0006AA58) --------------------------------------------------------
int __fastcall check_nonce_vbk(int a1, int a2)
{
  _BYTE v6[16]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[24]; // [sp+1018h] [bp+1008h] BYREF
  _BYTE v8[67]; // [sp+1038h] [bp+1028h] BYREF
  unsigned __int8 v9; // [sp+107Bh] [bp+106Bh]
  unsigned int v10; // [sp+107Ch] [bp+106Ch]
  int v11; // [sp+1080h] [bp+1070h]
  int v12; // [sp+1084h] [bp+1074h]

  v12 = a2;
  v11 = *(_DWORD *)(a1 + 624);
  v10 = *(_DWORD *)(v11 + 4 * (*(unsigned __int8 *)(a2 + 29) + 5376));
  memcpy(v8, (const void *)(v11 + ((*(unsigned __int8 *)(a2 + 29) + 64) << 6)), 0x3Cu);
  v8[60] = HIBYTE(*(_DWORD *)(v12 + 24));
  v8[61] = BYTE2(*(_DWORD *)(v12 + 24));
  v8[62] = BYTE1(*(_DWORD *)(v12 + 24));
  v8[63] = *(_DWORD *)(v12 + 24);
  vblake_hash((int)v7, (int)v8);
  v9 = target_to_diff_vbk((int)v7);
  if ( v9 > 0x1Fu )
  {
    if ( v9 == *(unsigned __int8 *)(v12 + 28) )
    {
      return *(unsigned __int8 *)(v12 + 28) < v10
          || (unsigned __int8)sub_6A98C((int)v7, v11 + 24 * *(unsigned __int8 *)(v12 + 29) + 22528) != 1;
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v6,
        0x1000u,
        0,
        "nonce %x DIFF not match (%d:%d) not reach pool %d",
        *(_DWORD *)(v12 + 24),
        *(unsigned __int8 *)(v12 + 28),
        v9,
        v10,
        a2,
        a1);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_vbk/backend_vbk.c",
        83,
        "check_nonce_vbk",
        15,
        278,
        20,
        v6);
      return 3;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(
      v6,
      0x1000u,
      0,
      "check_nonce_vbk hw error diff %d %d expected diff %d nonce %x",
      v9,
      *(unsigned __int8 *)(v12 + 28),
      v10,
      *(_DWORD *)(v12 + 24),
      a2,
      a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_vbk/backend_vbk.c",
      83,
      "check_nonce_vbk",
      15,
      273,
      20,
      v6);
    return 2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006AD40) --------------------------------------------------------
int get_chip_status_vbk()
{
  return 0;
}

//----- (0006AD5C) --------------------------------------------------------
int get_algo_type_vbk()
{
  return 0;
}

//----- (0006AD78) --------------------------------------------------------
int __fastcall softreset_all_chip_vbk(int a1)
{
  sub_670C8(a1);
  return 0;
}

//----- (0006AD90) --------------------------------------------------------
int __fastcall get_theory_hashrate_vbk(int a1, double *a2)
{
  if ( *(_BYTE *)(a1 + 268) )
    *a2 = *(double *)(a1 + 280) * 1000.0 * 1000.0 * 1000.0;
  else
    *a2 = (double)*(int *)(a1 + 272) * 20.0 / (double)*(unsigned int *)(a1 + 204) * 1000.0 * 1000.0;
  return 0;
}

//----- (0006AE20) --------------------------------------------------------
int set_boot_config_vbk()
{
  return 0;
}

//----- (0006AE38) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_vbk(int a1)
{
  if ( !sub_692C8(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (0006AE60) --------------------------------------------------------
int __fastcall read_sensor_temp_local_vbk(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_68E4C(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_68F14(a1, a2, a3, a8);
  }
  return 0;
}

//----- (0006AEB0) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_vbk(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_68EB0(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_690EC(a1, a2, a3, a8);
  }
  return 0;
}

//----- (0006AF00) --------------------------------------------------------
int parameter_update_vbk()
{
  return 0;
}

//----- (0006AF24) --------------------------------------------------------
int overclock_update_vbk()
{
  return 0;
}

//----- (0006AF3C) --------------------------------------------------------
int __fastcall get_pcba_test_level_vbk(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 768);
  return 0;
}

//----- (0006AF60) --------------------------------------------------------
int __fastcall get_packet_remain_len_vbk(unsigned __int8 a1)
{
  return a1 - 1;
}

//----- (0006AF7C) --------------------------------------------------------
void *runtime_ctrl_vbk()
{
  void *dest; // [sp+3Ch] [bp+3Ch]

  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1EE530, 0x310u);
  return dest;
}
// 1EE530: using guessed type _UNKNOWN *off_1EE530;

//----- (0006AFB0) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6AFB0(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (0006AFD4) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_6AFD4(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0006AFFC) --------------------------------------------------------
int __fastcall sub_6AFFC(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 6B040: variable 'v3' is possibly undefined

//----- (0006B0DC) --------------------------------------------------------
int __fastcall sub_6B0DC(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006B1E0) --------------------------------------------------------
int __fastcall sub_6B1E0(unsigned __int8 *a1)
{
  return (*a1 << 24) + a1[3] + (a1[2] << 8) + (a1[1] << 16);
}

//----- (0006B21C) --------------------------------------------------------
_BYTE *__fastcall sub_6B21C(_BYTE *result, int a2, int a3, int a4)
{
  result[7] = a3;
  result[6] = BYTE1(a3);
  result[5] = BYTE2(a3);
  result[4] = HIBYTE(a3);
  result[3] = a4;
  result[2] = BYTE1(a4);
  result[1] = BYTE2(a4);
  *result = HIBYTE(a4);
  return result;
}

//----- (0006B2DC) --------------------------------------------------------
_BYTE *__fastcall sub_6B2DC(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (0006B324) --------------------------------------------------------
int __fastcall sub_6B324(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_GRIN29", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_GRIN29",
    27,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_6AFD4((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_GRIN29",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_GRIN29",
    27,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_GRIN29",
      27,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_GRIN29",
          27,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_6AFD4((int)v12, *(int *)(a1 + 140));
    sub_6AFB0(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_GRIN29",
      27,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 6B47C: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006B90C) --------------------------------------------------------
int __fastcall sub_6B90C(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_GRIN29", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_GRIN29",
    33,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 4456449;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006BA00) --------------------------------------------------------
int __fastcall sub_6BA00(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_GRIN29", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_GRIN29",
    42,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 68;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006BB10) --------------------------------------------------------
int __fastcall sub_6BB10(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_GRIN29", 20, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_ticket_mask_GRIN29",
    30,
    137,
    20,
    v5);
  v6[2] = 1310721;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006BC34) --------------------------------------------------------
int __fastcall sub_6BC34(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_GRIN29",
    23,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006BEC8) --------------------------------------------------------
int __fastcall sub_6BEC8(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_GRIN29",
    27,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006C0EC) --------------------------------------------------------
unsigned int *__fastcall sub_6C0EC(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 6C124: variable 'v1' is possibly undefined

//----- (0006C1FC) --------------------------------------------------------
int __fastcall sub_6C1FC(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 786433;
  sub_6C0EC(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_GRIN29",
    23,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 6C27C: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006C350) --------------------------------------------------------
int __fastcall sub_6C350(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 12;
  sub_6C0EC(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_GRIN29",
    32,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 6C3F2: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006C4D0) --------------------------------------------------------
int __fastcall sub_6C4D0(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_GRIN29", 1, 132, 20000);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_open_cores_GRIN29",
    29,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 8650753;
  v8[0] = a3;
  BYTE1(v8[3]) = 1;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v8, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006C5FC) --------------------------------------------------------
int __fastcall sub_6C5FC(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_GRIN29");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_close_cores_GRIN29",
    30,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 8650753;
  v6[0] = 0;
  BYTE1(v6[3]) = 1;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v6, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006C70C) --------------------------------------------------------
int __fastcall sub_6C70C(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_GRIN29",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_start_nonce_offset_GRIN29",
    37,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_6AFD4((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_GRIN29",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_start_nonce_offset_GRIN29",
        37,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 6C86C: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006C9FC) --------------------------------------------------------
int __fastcall sub_6C9FC(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  char v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_GRIN29", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_pmdata_GRIN29",
    25,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 60;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_GRIN29", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_pmdata_GRIN29",
        25,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 60 )
        {
          v12 = 60;
          v5 = 0;
          sub_6B2DC(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_6AFD4((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_GRIN29",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_pmdata_GRIN29",
            25,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 60 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006CE60) --------------------------------------------------------
int __fastcall sub_6CE60(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_GRIN29", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_GRIN29",
    28,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 108;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 108 )
        {
          sub_6B2DC(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_6AFD4((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_GRIN29",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_GRIN29",
            28,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_GRIN29", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_GRIN29",
      28,
      436,
      100,
      v5);
    return -1;
  }
}
// 6D06E: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006D24C) --------------------------------------------------------
int __fastcall sub_6D24C(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4194305;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_GRIN29",
    29,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006D368) --------------------------------------------------------
int __fastcall sub_6D368(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 32;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (0006D3B4) --------------------------------------------------------
int __fastcall sub_6D3B4(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 32;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (0006D4D4) --------------------------------------------------------
int __fastcall sub_6D4D4(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_6D368(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_6D3B4(a1, a2, a3, s, a6, n);
}

//----- (0006D548) --------------------------------------------------------
int __fastcall sub_6D548(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_6D4D4(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0006D5EC) --------------------------------------------------------
int __fastcall sub_6D5EC(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_6D4D4(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (0006D690) --------------------------------------------------------
int __fastcall sub_6D690(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_6D4D4(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (0006D6F4) --------------------------------------------------------
int __fastcall sub_6D6F4(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_6D4D4(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (0006D758) --------------------------------------------------------
int __fastcall sub_6D758(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_GRIN29",
        48,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_GRIN29",
      48,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006D930) --------------------------------------------------------
int __fastcall sub_6D930(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_GRIN29",
        49,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_GRIN29",
      49,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006DB0C) --------------------------------------------------------
int __fastcall sub_6DB0C(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_6D368(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0006DB44) --------------------------------------------------------
int __fastcall sub_6DB44(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0006DB98) --------------------------------------------------------
int __fastcall sub_6DB98(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 52;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 52 )
    {
      V_LOCK();
      sub_6AFD4((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_GRIN29",
        33,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006DE64) --------------------------------------------------------
int __fastcall sub_6DE64(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (0006DEF0) --------------------------------------------------------
unsigned int __fastcall sub_6DEF0(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0x30u);
  memset(v13, 0, 0x30u);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 4, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_6AFD4((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_GRIN29",
        34,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006E19C) --------------------------------------------------------
int __fastcall sub_6E19C(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (0006E1E4) --------------------------------------------------------
int __fastcall sub_6E1E4(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0006E23C) --------------------------------------------------------
int __fastcall sub_6E23C(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0006E29C) --------------------------------------------------------
int __fastcall sub_6E29C(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0006E300) --------------------------------------------------------
int __fastcall sub_6E300(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0006E35C) --------------------------------------------------------
int __fastcall sub_6E35C(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_GRIN29", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_GRIN29",
    34,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_6AFD4((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_GRIN29",
      34,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 6E516: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006E6D8) --------------------------------------------------------
int __fastcall sub_6E6D8(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 1;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_GRIN29", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_GRIN29",
    46,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_6AFD4((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_GRIN29",
      46,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 6E888: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006EA50) --------------------------------------------------------
int __fastcall dump_work(_DWORD *a1)
{
  int v3; // [sp+24h] [bp+Ch] BYREF
  unsigned int i; // [sp+1024h] [bp+100Ch]

  V_LOCK();
  logfmt_raw(
    &v3,
    0x1000u,
    0,
    "grin29 dump work poolid %ld jobid %lu start_nonce %lu",
    *a1,
    a1[1],
    a1[2],
    a1[3],
    *(_DWORD *)((char *)a1 + 254),
    *(_DWORD *)((char *)a1 + 258));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin29/backend_grin29.c",
    89,
    "dump_work",
    9,
    71,
    60,
    &v3);
  for ( i = 0; i <= 0xED; ++i )
    printf("%02x ", *((unsigned __int8 *)a1 + i + 16));
  return putchar(10);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006EB54) --------------------------------------------------------
int __fastcall dump_work_packet(int a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  printf("work: ");
  for ( i = 0; i <= 0xFC; ++i )
    printf("%02x ", *(unsigned __int8 *)(i + a1));
  return putchar(10);
}

//----- (0006EBA4) --------------------------------------------------------
int __fastcall work_2_packet_grin29(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int v4; // r4
  _DWORD *v5; // r2
  int v6; // r4
  _DWORD *v7; // r2
  int v8; // r4
  _DWORD *v9; // r2
  int v10; // r4
  _DWORD *v11; // r2
  unsigned __int16 v12; // r0
  int v15; // [sp+1Ch] [bp+1Ch]

  v15 = *(_DWORD *)(a1 + 624);
  *(_BYTE *)a3 = 85;
  *(_BYTE *)(a3 + 1) = -86;
  *(_BYTE *)(a3 + 2) = 32;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    *(_BYTE *)(a3 + 2) |= 0x10u;
  v4 = a2[3];
  v5 = (_DWORD *)(8 * (*(unsigned __int8 *)(v15 + 128000) + 128) + v15);
  *v5 = a2[2];
  v5[1] = v4;
  v6 = a2[1];
  v7 = (_DWORD *)(8 * *(unsigned __int8 *)(v15 + 128000) + v15);
  *v7 = *a2;
  v7[1] = v6;
  memcpy((void *)(a3 + 5), a2 + 4, 0xEEu);
  sub_6B21C((_BYTE *)(a3 + 243), a3 + 243, *(_DWORD *)((char *)a2 + 254), *(_DWORD *)((char *)a2 + 258));
  v8 = *(_DWORD *)((char *)a2 + 258);
  v9 = (_DWORD *)(8 * (*(unsigned __int8 *)(v15 + 128000) + 256) + v15);
  *v9 = 0;
  v9[1] = v8;
  memcpy((void *)(v15 + 246 * *(unsigned __int8 *)(v15 + 128000) + 4352), a2 + 4, 0xF6u);
  v10 = *(_DWORD *)((char *)a2 + 266);
  v11 = (_DWORD *)(8 * (*(unsigned __int8 *)(v15 + 128000) + 384) + v15);
  *v11 = *(_DWORD *)((char *)a2 + 262);
  v11[1] = v10;
  *(_BYTE *)(a3 + 4) = (*(_BYTE *)(v15 + 128000))++;
  if ( *(char *)(v15 + 128000) < 0 )
    *(_BYTE *)(v15 + 128000) = 0;
  *(_BYTE *)(a3 + 3) = -10;
  v12 = CRC16_v1((const unsigned __int8 *)(a3 + 2), *(unsigned __int8 *)(a3 + 3) + 3);
  *(_BYTE *)(a3 + 251) = HIBYTE(v12);
  *(_BYTE *)(a3 + 252) = v12;
  *a4 = 253;
  return 0;
}

//----- (0006ED48) --------------------------------------------------------
int __fastcall sub_6ED48(int a1, int a2)
{
  int v5; // [sp+10h] [bp+8h]
  unsigned int i; // [sp+14h] [bp+Ch]

  v5 = a2 + 35;
  printf("nonce wc %d\n", *(unsigned __int8 *)(a2 + 16));
  printf("nonce: %llx\n", *(_QWORD *)(a2 + 25));
  printf(
    "chain %d asic %d core %d addr_interval %d\n",
    *(_DWORD *)(a1 + 136),
    *(_DWORD *)(a2 + 8),
    *(_DWORD *)(a2 + 12),
    *(_DWORD *)(a1 + 240));
  printf("order len %d, order: ", *(unsigned __int16 *)(a2 + 33));
  for ( i = 0; *(unsigned __int16 *)(a2 + 33) > i; ++i )
    printf("%02x ", *(unsigned __int8 *)(i + v5));
  return putchar(10);
}

//----- (0006EE00) --------------------------------------------------------
int __fastcall packet_2_nonce_grin29(int a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  _DWORD *v8; // r1
  int v9; // r3
  int *v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r3
  _DWORD *v17; // r1
  int *v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // r1
  int *v22; // r1
  int v23; // r2
  int v24; // r3
  int v25; // r1
  int v29; // [sp+24h] [bp+14h] BYREF
  int v30; // [sp+1024h] [bp+1014h]
  unsigned __int8 v31; // [sp+102Bh] [bp+101Bh]
  int v32; // [sp+102Ch] [bp+101Ch]
  unsigned __int16 v33; // [sp+1030h] [bp+1020h]
  unsigned __int16 v34; // [sp+1032h] [bp+1022h]
  unsigned __int8 v35; // [sp+1034h] [bp+1024h]
  unsigned __int8 v36; // [sp+1035h] [bp+1025h]
  unsigned __int8 v37; // [sp+1036h] [bp+1026h]
  unsigned __int8 v38; // [sp+1037h] [bp+1027h]
  int v39; // [sp+1038h] [bp+1028h]
  int v40; // [sp+103Ch] [bp+102Ch]
  int i; // [sp+1040h] [bp+1030h]
  unsigned __int16 v42; // [sp+1044h] [bp+1034h]
  unsigned __int8 v43; // [sp+1047h] [bp+1037h]

  v40 = a2;
  v39 = a3;
  v38 = 0;
  v37 = 0;
  if ( *(unsigned __int8 *)(a2 + 2) <= 9u )
    return 1;
  v36 = *(_BYTE *)(v40 + 2) - 2;
  v35 = v36 + 2;
  v34 = CRC16_v1((const unsigned __int8 *)(v40 + 2), v36);
  v33 = *(unsigned __int8 *)(v35 + 1 + v40) + (*(unsigned __int8 *)(v35 + v40) << 8);
  if ( v34 == v33 )
  {
    v32 = *(_DWORD *)(a1 + 624);
    v43 = 6;
    v42 = *(unsigned __int8 *)(v40 + 2) - 6;
    v31 = *(_BYTE *)(v40 + 3);
    if ( *(_BYTE *)(v40 + 5) == 1 )
    {
      v30 = sub_6B1E0((unsigned __int8 *)(v40 + 6));
      v8 = (_DWORD *)(v32 + 8 * (v31 + 256));
      v9 = v8[1];
      *v8 |= v30;
      v8[1] = v9;
      v42 -= 4;
      v43 += 4;
    }
    memcpy(
      (void *)(v32 + 720 * v31 + *(unsigned __int16 *)(v32 + 2 * (v31 + 2048)) + 35840),
      (const void *)(v43 + v40),
      v42);
    *(_WORD *)(v32 + 2 * (v31 + 2048)) += v42;
    if ( *(unsigned __int8 *)(v40 + 4) == *(unsigned __int8 *)(v40 + 5) )
    {
      *(_WORD *)(v39 + 33) = *(_WORD *)(v32 + 2 * (v31 + 2048));
      v10 = (int *)(v32 + 8 * (v31 + 256));
      v11 = *v10;
      v12 = v10[1];
      v13 = v39 + 25;
      *(_DWORD *)(v39 + 25) = v11;
      *(_DWORD *)(v13 + 4) = v12;
      for ( i = 0; *(_WORD *)(v32 + 2 * (v31 + 2048)) >> 2 > i; ++i )
        *(_DWORD *)(4 * (i + 8) + v39 + 3) = sub_6B1E0((unsigned __int8 *)(4 * i + 720 * v31 + 35840 + v32));
      v14 = v32;
      v15 = v31 + 2048;
      *(_BYTE *)(v32 + 2 * v15) = 0;
      *(_BYTE *)(2 * v15 + v14 + 1) = 0;
      v16 = *(_DWORD *)(v32 + 8 * (v31 + 256) + 4);
      v17 = (_DWORD *)(8 * (v31 + 256) + v32);
      *v17 = 0;
      v17[1] = v16;
      memset((void *)(720 * v31 + 35840 + v32), 0, 0x2D0u);
      *(_BYTE *)(v39 + 16) = v31;
      v18 = (int *)(v32 + 8 * (v31 + 128));
      v19 = *v18;
      v20 = v18[1];
      v21 = v39 + 17;
      *(_DWORD *)(v39 + 17) = v19;
      *(_DWORD *)(v21 + 4) = v20;
      v22 = (int *)(v32 + 8 * v31);
      v23 = *v22;
      v24 = v22[1];
      v25 = v39;
      *(_DWORD *)v39 = v23;
      *(_DWORD *)(v25 + 4) = v24;
      *a7 = *(_DWORD *)(v32 + 8 * v31);
      v37 = *(_DWORD *)(v39 + 25) & 1;
      v38 = sub_1A3E94((unsigned __int8)HIBYTE(*(_DWORD *)(v39 + 25)), *(unsigned int *)(a1 + 240));
      *(_DWORD *)(v39 + 8) = v38;
      *(_DWORD *)(v39 + 12) = v37;
      *a6 = v38;
      memcpy(a5, (const void *)(v39 + 25), 8u);
      *a4 = 0;
      return 0;
    }
    else
    {
      return 5;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(&v29, 0x1000u, 0, "get nonce crc error calc value %04x resp value %04x", v34, v33);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin29/backend_grin29.c",
      89,
      "packet_2_nonce_grin29",
      21,
      189,
      20,
      &v29);
    return 2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006F4A4) --------------------------------------------------------
int __fastcall makeup_chip_addr(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (0006F4F4) --------------------------------------------------------
int __fastcall sub_6F4F4(int a1, unsigned __int8 a2)
{
  _BYTE v6[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v7[4]; // [sp+1018h] [bp+1008h] BYREF
  int v8; // [sp+1028h] [bp+1018h]
  int i; // [sp+102Ch] [bp+101Ch]

  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = a2;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "%s chip_addr %02x reg %02x", "open_33p_double_results_grin29", a2, 2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin29/backend_grin29.c",
    89,
    "open_33p_double_results_grin29",
    30,
    264,
    60,
    v6);
  for ( i = 0; i <= 0; ++i )
  {
    HIWORD(v7[2]) = 2;
    LOBYTE(v7[3]) = -1;
    v7[0] = 1;
    v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v7);
    if ( v8 < 0 )
    {
      printf("%s failed, reg:%02x, core_id:%d", "open_33p_double_results_grin29", HIWORD(v7[2]), i);
      return -1;
    }
    usleep(0x4E20u);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006F680) --------------------------------------------------------
int __fastcall sub_6F680(int a1, unsigned __int8 a2)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; a2 > i; ++i )
  {
    if ( (i & 1) != 0 )
    {
      sub_6F4F4(a1, *(_BYTE *)(i + *(_DWORD *)(a1 + 296)));
      usleep(0x4E20u);
    }
  }
  return 0;
}

//----- (0006F6D0) --------------------------------------------------------
int __fastcall sub_6F6D0(int a1, unsigned __int8 a2)
{
  _BYTE v6[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v7[4]; // [sp+1018h] [bp+1008h] BYREF
  int v8; // [sp+1028h] [bp+1018h]
  int i; // [sp+102Ch] [bp+101Ch]

  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = a2;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "%s chip_addr %02x reg %02x\n", "set_3p_timenout_cycle_grin29", a2, 177);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin29/backend_grin29.c",
    89,
    "set_3p_timenout_cycle_grin29",
    28,
    299,
    60,
    v6);
  for ( i = 0; i <= 0; ++i )
  {
    HIWORD(v7[2]) = 177;
    LOBYTE(v7[3]) = -1;
    v7[0] = 60000000;
    v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v7);
    if ( v8 < 0 )
    {
      printf("%s failed, reg:%02x, core_id:%d\n", "set_3p_timenout_cycle_grin29", HIWORD(v7[2]), i);
      return -1;
    }
    usleep(0x4E20u);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006F864) --------------------------------------------------------
int __fastcall sub_6F864(int a1, unsigned __int8 a2)
{
  int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; a2 > i; ++i )
  {
    if ( (i & 1) == 0 )
    {
      sub_6F6D0(a1, *(_BYTE *)(i + *(_DWORD *)(a1 + 296)));
      usleep(0x4E20u);
    }
  }
  return 0;
}

//----- (0006F8B4) --------------------------------------------------------
int __fastcall setup_all_chip_grin29(int a1)
{
  puts("setup_all_chip_grin29");
  *(_DWORD *)(a1 + 240) = makeup_chip_addr(*(_DWORD *)(a1 + 296), 4u);
  (*(void (__fastcall **)(int, _DWORD, int))(a1 + 148))(a1, *(_DWORD *)(a1 + 296), 4);
  sub_6B324(a1, 4);
  sub_6F680(a1, 4u);
  sub_6C4D0(a1, 0, 1);
  if ( *(_BYTE *)(a1 + 268) != 1 )
    *(_DWORD *)(a1 + 272) = (int)*(float *)(a1 + 760);
  return 0;
}

//----- (0006F944) --------------------------------------------------------
int __fastcall global_idx_init_grin29(int a1)
{
  int v1; // r3
  void *s; // [sp+Ch] [bp+Ch]

  s = malloc(0x1F401u);
  memset(s, 0, 0x1F401u);
  *(_DWORD *)(a1 + 624) = s;
  printf("__custom_data init %p\n", s);
  return v1;
}
// 6F984: variable 'v1' is possibly undefined

//----- (0006F98C) --------------------------------------------------------
int __fastcall global_idx_free_grin29(int a1)
{
  int v1; // r3

  v1 = *(_DWORD *)(a1 + 624);
  if ( v1 )
    free(*(void **)(a1 + 624));
  return v1;
}
// 6F9AC: variable 'v1' is possibly undefined

//----- (0006F9B4) --------------------------------------------------------
int __fastcall set_baud_grin29(int a1, char *a2)
{
  return sub_6BC34(a1, a2);
}

//----- (0006F9D0) --------------------------------------------------------
int __fastcall sub_6F9D0(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0006F9F0) --------------------------------------------------------
int __fastcall sub_6F9F0(int a1, int a2, _DWORD *a3, int a4, int a5, int a6)
{
  int v10; // [sp+24h] [bp+14h] BYREF
  _BYTE v11[4072]; // [sp+28h] [bp+18h] BYREF
  struct timeval v12; // [sp+1028h] [bp+1018h] BYREF
  struct timeval tv; // [sp+1030h] [bp+1020h] BYREF
  _DWORD *v14; // [sp+1038h] [bp+1028h]
  int v15; // [sp+103Ch] [bp+102Ch]
  int v16; // [sp+1040h] [bp+1030h]
  int v17; // [sp+1044h] [bp+1034h]
  __int64 v18; // [sp+1048h] [bp+1038h]
  void (__fastcall **v19)(_DWORD); // [sp+1054h] [bp+1044h]
  int k; // [sp+1058h] [bp+1048h]
  int j; // [sp+105Ch] [bp+104Ch]
  int i; // [sp+1060h] [bp+1050h]
  int v23; // [sp+1064h] [bp+1054h]

  v10 = a1;
  v23 = 0;
  gettimeofday(&tv, 0);
  v19 = (void (__fastcall **)(_DWORD))new_graph29(29, 21);
  (*((void (__fastcall **)(void (__fastcall *)(_DWORD), int, int, int *, int, int, int, _DWORD))v19[23] + 18))(
    v19[23],
    v10,
    a2,
    &v10,
    a5,
    a6,
    25,
    0);
  for ( i = 0; a4 / 4 > i; ++i )
  {
    v18 = ((__int64 (__fastcall *)(void (__fastcall **)(_DWORD), _DWORD))v19[29])(v19, a3[i]);
    v17 = a3[i] & 1;
    v16 = v17 | (2 * (v18 & 0xFFFFFFF));
    v15 = v17 | (2 * (HIDWORD(v18) & 0xFFFFFFF));
    ((void (__fastcall *)(void (__fastcall **)(_DWORD), int, int))v19[27])(v19, v16, v15);
  }
  v14 = (_DWORD *)((int (__fastcall *)(_DWORD))v19[28])(v19);
  if ( v14 )
  {
    for ( j = 0; *v14 > j; ++j )
    {
      for ( k = 0; k <= 41; ++k )
        a3[k] = a3[*(_DWORD *)(4 * k + v14[1] + 172 * j + 4)];
      qsort(a3, 0x2Au, 4u, (__compar_fn_t)sub_6F9D0);
      v23 = *(_DWORD *)(172 * j + v14[1]);
    }
  }
  else
  {
    v23 = 0;
  }
  free_graph29(v19);
  gettimeofday(&v12, 0);
  V_LOCK();
  logfmt_raw(
    v11,
    0x1000u,
    0,
    "%s, nsols: %d, time: %ld us",
    "findcycle_grin29",
    *v14,
    1000000 * v12.tv_sec + v12.tv_usec - 1000000 * tv.tv_sec - tv.tv_usec);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin29/backend_grin29.c",
    89,
    "findcycle_grin29",
    16,
    408,
    20,
    v11);
  return v23;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0006FDE8) --------------------------------------------------------
int __fastcall check_nonce_grin29(int a1, int a2)
{
  unsigned int *v3; // r2
  unsigned int v4; // r4
  int v6; // [sp+24h] [bp-1Ch]
  _BYTE v9[16]; // [sp+48h] [bp+8h] BYREF
  unsigned __int64 v10; // [sp+1048h] [bp+1008h] BYREF
  _QWORD v11[4]; // [sp+1050h] [bp+1010h] BYREF
  _BYTE v12[156]; // [sp+1074h] [bp+1034h] BYREF
  _BYTE v13[248]; // [sp+1110h] [bp+10D0h] BYREF
  _DWORD v14[7]; // [sp+1208h] [bp+11C8h] BYREF
  int v15; // [sp+1224h] [bp+11E4h]
  _DWORD v16[7]; // [sp+1228h] [bp+11E8h] BYREF
  int v17; // [sp+1244h] [bp+1204h]
  unsigned int v18; // [sp+1248h] [bp+1208h]
  int v19; // [sp+124Ch] [bp+120Ch]
  unsigned int v20; // [sp+1254h] [bp+1214h]
  unsigned int v21; // [sp+1258h] [bp+1218h]
  int v22; // [sp+125Ch] [bp+121Ch]
  unsigned int v23; // [sp+1260h] [bp+1220h]
  unsigned __int8 v24; // [sp+1267h] [bp+1227h]
  int v25; // [sp+1268h] [bp+1228h]
  int v26; // [sp+126Ch] [bp+122Ch]
  unsigned int j; // [sp+1270h] [bp+1230h]
  unsigned int i; // [sp+1274h] [bp+1234h]

  memset(v13, 0, 0xF6u);
  v26 = a2;
  v25 = *(_DWORD *)(a1 + 624);
  memcpy(v13, (const void *)(246 * *(unsigned __int8 *)(a2 + 16) + 4352 + v25), 0xF6u);
  v24 = sub_6F9F0(
          (int)v13,
          246,
          (_DWORD *)(v26 + 35),
          *(unsigned __int16 *)(v26 + 33),
          *(_DWORD *)(v26 + 25),
          *(_DWORD *)(v26 + 29));
  V_LOCK();
  sub_6AFD4((int)v14, *(int *)(a1 + 140));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v15,
    v14[0],
    v14[1],
    v14[2],
    v14[3],
    v14[4],
    v14[5],
    v14[6],
    v15,
    "nonce %llx wc %d sols_len %d cycle len (%d/42)",
    v6,
    *(_DWORD *)(v26 + 25),
    *(_DWORD *)(v26 + 29),
    *(unsigned __int8 *)(v26 + 16),
    *(unsigned __int16 *)(v26 + 33),
    v24);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin29/backend_grin29.c",
    89,
    "check_nonce_grin29",
    18,
    434,
    20,
    v9);
  if ( v24 == 42 )
  {
    memset(v11, 0, sizeof(v11));
    memset(v12, 0, 0x99u);
    v23 = 29;
    v22 = 0x1FFFFFFF;
    for ( i = 0; i <= 0x29; ++i )
    {
      v21 = v22 & *(_DWORD *)(4 * (i + 8) + v26 + 3);
      for ( j = 0; j < v23; ++j )
      {
        v20 = j + v23 * i;
        if ( ((v21 >> j) & 1) != 0 )
          v12[v20 >> 3] |= 1 << (v20 & 7);
      }
    }
    blake2b(v11, (int)v12, 0x99u);
    v10 = v11[0];
    sub_6B21C(&v10, (int)&v10, v11[0], SHIDWORD(v11[0]));
    v3 = (unsigned int *)(v25 + 8 * (*(unsigned __int8 *)(v26 + 16) + 384));
    v4 = v3[1];
    v18 = *v3;
    v19 = v4;
    if ( __PAIR64__(v4, v18) >= v10 )
    {
      return 0;
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "nonce %016llx hw target (%016llx:%016llx) not reach pool\n",
        *(_DWORD *)(v26 + 25),
        *(_DWORD *)(v26 + 29),
        v10,
        v18,
        v19);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin29/backend_grin29.c",
        89,
        "check_nonce_grin29",
        18,
        462,
        20,
        v9);
      return 1;
    }
  }
  else
  {
    V_LOCK();
    sub_6AFD4((int)v16, *(int *)(a1 + 140));
    logfmt_raw(
      v9,
      0x1000u,
      0,
      v17,
      v16[0],
      v16[1],
      v16[2],
      v16[3],
      v16[4],
      v16[5],
      v16[6],
      v17,
      "wc %d error_nonce",
      *(unsigned __int8 *)(v26 + 16));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_grin29/backend_grin29.c",
      89,
      "check_nonce_grin29",
      18,
      436,
      20,
      v9);
    return 2;
  }
}
// 6FF62: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000702F8) --------------------------------------------------------
int get_chip_status_grin29()
{
  return 0;
}

//----- (00070314) --------------------------------------------------------
int get_algo_type_grin29()
{
  return 0;
}

//----- (00070330) --------------------------------------------------------
int __fastcall softreset_all_chip_grin29(int a1)
{
  sub_6B90C(a1);
  return 0;
}

//----- (00070348) --------------------------------------------------------
int __fastcall get_theory_hashrate_grin29(int a1, double *a2)
{
  if ( *(_BYTE *)(a1 + 268) )
    *a2 = *(double *)(a1 + 280);
  else
    *a2 = ((double)*(int *)(a1 + 272) + (double)*(int *)(a1 + 272))
        / (double)*(unsigned int *)(a1 + 204)
        * 1000.0
        * 1000.0;
  return 0;
}

//----- (000703B8) --------------------------------------------------------
int set_boot_config_grin29()
{
  return 0;
}

//----- (000703D0) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_grin29(int a1)
{
  if ( !sub_6DB0C(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (000703F8) --------------------------------------------------------
int __fastcall read_sensor_temp_local_grin29(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_6D690(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_6D758(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00070448) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_grin29(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_6D6F4(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_6D930(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00070498) --------------------------------------------------------
int parameter_update_grin29()
{
  return 0;
}

//----- (000704BC) --------------------------------------------------------
int overclock_update_grin29()
{
  return 0;
}

//----- (000704D4) --------------------------------------------------------
int __fastcall get_pcba_test_level_grin29(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 768);
  return 0;
}

//----- (000704F8) --------------------------------------------------------
int __fastcall get_packet_remain_len_grin29(unsigned __int8 a1)
{
  return a1 - 1;
}

//----- (00070514) --------------------------------------------------------
void *runtime_ctrl_grin29()
{
  void *dest; // [sp+2F4h] [bp+2F4h]

  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1EE870, 0x310u);
  return dest;
}
// 1EE870: using guessed type _UNKNOWN *off_1EE870;

//----- (00070550) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_70550(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (00070574) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_70574(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0007059C) --------------------------------------------------------
int __fastcall sub_7059C(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 705E0: variable 'v3' is possibly undefined

//----- (0007067C) --------------------------------------------------------
int __fastcall sub_7067C(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00070780) --------------------------------------------------------
int __fastcall sub_70780(unsigned __int8 *a1)
{
  return (*a1 << 24) + a1[3] + (a1[2] << 8) + (a1[1] << 16);
}

//----- (000707BC) --------------------------------------------------------
_BYTE *__fastcall sub_707BC(_BYTE *result, int a2, int a3, int a4)
{
  result[7] = a3;
  result[6] = BYTE1(a3);
  result[5] = BYTE2(a3);
  result[4] = HIBYTE(a3);
  result[3] = a4;
  result[2] = BYTE1(a4);
  result[1] = BYTE2(a4);
  *result = HIBYTE(a4);
  return result;
}

//----- (0007087C) --------------------------------------------------------
_BYTE *__fastcall sub_7087C(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (000708C4) --------------------------------------------------------
_DWORD *__fastcall LZ4F_writeLE32(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}
// 708C4: invalid function type 'void __cdecl LZ4F_writeLE32(void *dst, U32 value32)' has been ignored

//----- (0007090C) --------------------------------------------------------
int __fastcall sub_7090C(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_AE", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_AE",
    23,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_70574((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_AE",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_AE",
    23,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_AE",
      23,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_AE",
          23,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_70574((int)v12, *(int *)(a1 + 140));
    sub_70550(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_AE",
      23,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 70A64: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00070EF4) --------------------------------------------------------
int __fastcall sub_70EF4(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_AE", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_AE",
    29,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 4456449;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00070FE8) --------------------------------------------------------
int __fastcall sub_70FE8(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_AE", 68);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_AE",
    38,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 68;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000710F8) --------------------------------------------------------
int __fastcall sub_710F8(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_AE", 20, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_ticket_mask_AE",
    26,
    137,
    20,
    v5);
  v6[2] = 1310721;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007121C) --------------------------------------------------------
int __fastcall sub_7121C(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_AE",
    19,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000714B0) --------------------------------------------------------
int __fastcall sub_714B0(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1835009;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_AE",
    23,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000716D4) --------------------------------------------------------
unsigned int *__fastcall sub_716D4(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 7170C: variable 'v1' is possibly undefined

//----- (000717E4) --------------------------------------------------------
int __fastcall sub_717E4(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 786433;
  sub_716D4(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_AE",
    19,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 71864: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00071938) --------------------------------------------------------
int __fastcall sub_71938(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 12;
  sub_716D4(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_AE",
    28,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 719DA: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00071AB8) --------------------------------------------------------
int __fastcall sub_71AB8(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_AE", 1, 132, 20000);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_open_cores_AE",
    25,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 8650753;
  v8[0] = a3;
  BYTE1(v8[3]) = 1;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v8, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00071BE4) --------------------------------------------------------
int __fastcall sub_71BE4(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_AE");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_close_cores_AE",
    26,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 8650753;
  v6[0] = 0;
  BYTE1(v6[3]) = 1;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v6, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00071CF4) --------------------------------------------------------
int __fastcall sub_71CF4(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_AE",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_start_nonce_offset_AE",
    33,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_70574((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_AE",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_start_nonce_offset_AE",
        33,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 71E54: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00071FE4) --------------------------------------------------------
int __fastcall sub_71FE4(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  char v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_AE", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_pmdata_AE",
    21,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 60;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_AE", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_pmdata_AE",
        21,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 60 )
        {
          v12 = 60;
          v5 = 0;
          sub_7087C(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_70574((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_AE",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_pmdata_AE",
            21,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 60 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00072448) --------------------------------------------------------
int __fastcall sub_72448(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_AE", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_AE",
    24,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 108;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 108 )
        {
          sub_7087C(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_70574((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_AE",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_AE",
            24,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_AE", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_AE",
      24,
      436,
      100,
      v5);
    return -1;
  }
}
// 72656: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00072834) --------------------------------------------------------
int __fastcall sub_72834(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4194305;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_AE",
    25,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00072950) --------------------------------------------------------
int __fastcall sub_72950(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 32;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (0007299C) --------------------------------------------------------
int __fastcall sub_7299C(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 32;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (00072ABC) --------------------------------------------------------
int __fastcall sub_72ABC(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_72950(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_7299C(a1, a2, a3, s, a6, n);
}

//----- (00072B30) --------------------------------------------------------
int __fastcall sub_72B30(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_72ABC(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00072BD4) --------------------------------------------------------
int __fastcall sub_72BD4(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_72ABC(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00072C78) --------------------------------------------------------
int __fastcall sub_72C78(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_72ABC(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00072CDC) --------------------------------------------------------
int __fastcall sub_72CDC(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_72ABC(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00072D40) --------------------------------------------------------
int __fastcall sub_72D40(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_AE",
        44,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_AE",
      44,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00072F18) --------------------------------------------------------
int __fastcall sub_72F18(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_AE",
        45,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_AE",
      45,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000730F4) --------------------------------------------------------
int __fastcall sub_730F4(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_72950(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0007312C) --------------------------------------------------------
int __fastcall sub_7312C(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 3407873;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00073180) --------------------------------------------------------
int __fastcall sub_73180(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 52;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 52 )
    {
      V_LOCK();
      sub_70574((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_AE",
        29,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007344C) --------------------------------------------------------
int __fastcall sub_7344C(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (000734D8) --------------------------------------------------------
unsigned int __fastcall sub_734D8(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0x30u);
  memset(v13, 0, 0x30u);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 4, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_70574((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_AE",
        30,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00073784) --------------------------------------------------------
int __fastcall sub_73784(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (000737CC) --------------------------------------------------------
int __fastcall sub_737CC(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00073824) --------------------------------------------------------
int __fastcall sub_73824(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00073884) --------------------------------------------------------
int __fastcall sub_73884(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000738E8) --------------------------------------------------------
int __fastcall sub_738E8(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00073944) --------------------------------------------------------
int __fastcall sub_73944(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_AE", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_AE",
    30,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_70574((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_AE",
      30,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 73AFE: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00073CC0) --------------------------------------------------------
int __fastcall sub_73CC0(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 1;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_AE", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_AE",
    42,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_70574((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_AE",
      42,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 73E70: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00074038) --------------------------------------------------------
int __fastcall global_idx_init_ae(int a1)
{
  int v1; // r3
  void *s; // [sp+Ch] [bp+Ch]

  s = malloc(0x1BD01u);
  memset(s, 0, 0x1BD01u);
  *(_DWORD *)(a1 + 624) = s;
  printf("__custom_data init %p\n", s);
  return v1;
}
// 74078: variable 'v1' is possibly undefined

//----- (00074080) --------------------------------------------------------
int __fastcall global_idx_free_ae(int a1)
{
  int v1; // r3

  free(*(void **)(a1 + 624));
  return v1;
}
// 74096: variable 'v1' is possibly undefined

//----- (000740A0) --------------------------------------------------------
int __fastcall dump_work_ae(_DWORD *a1)
{
  int v2; // [sp+Ch] [bp-Ch]
  int v4; // [sp+24h] [bp+Ch] BYREF
  unsigned int i; // [sp+1024h] [bp+100Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "ae dump work poolid %lld jobid %s start_nonce %llx",
    *a1,
    a1[1],
    a1 + 2,
    v2,
    a1[31],
    a1[32]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ae/backend_ae.c",
    81,
    "dump_work_ae",
    12,
    83,
    60,
    &v4);
  for ( i = 0; i <= 0x4F; ++i )
    printf("%02x ", *((unsigned __int8 *)a1 + i + 40));
  return putchar(10);
}
// 740FA: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000741A0) --------------------------------------------------------
int __fastcall dump_work_packet_ae(int a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  printf("the work packet ");
  for ( i = 0; i <= 0x56; ++i )
    printf("%02x ", *(unsigned __int8 *)(i + a1));
  return putchar(10);
}

//----- (000741F0) --------------------------------------------------------
int __fastcall work_2_packet_ae(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r4
  _DWORD *v5; // r2
  int v6; // r4
  _DWORD *v7; // r2
  unsigned __int16 v8; // r0
  int v11; // [sp+1Ch] [bp+1Ch]

  v11 = *(_DWORD *)(a1 + 624);
  *(_BYTE *)a3 = 85;
  *(_BYTE *)(a3 + 1) = -86;
  *(_BYTE *)(a3 + 2) = 32;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    *(_BYTE *)(a3 + 2) |= 0x10u;
  strcpy((char *)(v11 + 32 * (*(unsigned __int8 *)(v11 + 113920) + 32)), (const char *)(a2 + 8));
  v4 = *(_DWORD *)(a2 + 4);
  v5 = (_DWORD *)(8 * *(unsigned __int8 *)(v11 + 113920) + v11);
  *v5 = *(_DWORD *)a2;
  v5[1] = v4;
  memset((void *)(a3 + 5), 0, 0x50u);
  memcpy((void *)(v11 + 32 * (*(unsigned __int8 *)(v11 + 113920) + 232)), (const void *)(a2 + 40), 0x20u);
  base64_encode(a3 + 5, a2 + 40, 32);
  memcpy((void *)(a3 + 49), (const void *)(a2 + 72), 8u);
  memcpy((void *)(v11 + 80 * *(unsigned __int8 *)(v11 + 113920) + 11520), (const void *)(a3 + 5), 0x50u);
  v6 = *(_DWORD *)(a2 + 136);
  v7 = (_DWORD *)(8 * (*(unsigned __int8 *)(v11 + 113920) + 768) + v11);
  *v7 = *(_DWORD *)(a2 + 132);
  v7[1] = v6;
  *(_BYTE *)(a3 + 4) = (*(_BYTE *)(v11 + 113920))++;
  if ( *(char *)(v11 + 113920) < 0 )
    *(_BYTE *)(v11 + 113920) = 0;
  *(_BYTE *)(a3 + 3) = 80;
  v8 = CRC16_v1((const unsigned __int8 *)(a3 + 2), *(unsigned __int8 *)(a3 + 3) + 3);
  *(_BYTE *)(a3 + 85) = HIBYTE(v8);
  *(_BYTE *)(a3 + 86) = v8;
  *a4 = 87;
  return 0;
}

//----- (000743AC) --------------------------------------------------------
int __fastcall sub_743AC(int a1, int a2)
{
  int i; // [sp+14h] [bp+Ch]

  printf("nonce wc %d\n", *(unsigned __int8 *)(a2 + 48));
  printf("nonce: %08x\n", *(_DWORD *)(a2 + 81));
  printf(
    "chain %d asic %d core %d addr_interval %d\n",
    *(_DWORD *)(a1 + 136),
    *(_DWORD *)(a2 + 8),
    *(_DWORD *)(a2 + 12),
    *(_DWORD *)(a1 + 240));
  printf("sols[%3d]: ", *(_WORD *)(a2 + 85) >> 2);
  for ( i = 0; *(_WORD *)(a2 + 85) >> 2 > i; ++i )
    printf("%08x ", *(_DWORD *)(4 * (i + 20) + a2 + 7));
  return putchar(10);
}

//----- (00074468) --------------------------------------------------------
int __fastcall packet_2_nonce_ae(int a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  int v8; // r2
  int v9; // r3
  int *v10; // r2
  int v11; // r3
  int v12; // r4
  int v13; // r2
  _BYTE v17[4080]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 v18; // [sp+1023h] [bp+1013h]
  int v19; // [sp+1024h] [bp+1014h]
  unsigned __int16 v20; // [sp+1028h] [bp+1018h]
  unsigned __int16 v21; // [sp+102Ah] [bp+101Ah]
  unsigned __int8 v22; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v23; // [sp+102Dh] [bp+101Dh]
  unsigned __int8 v24; // [sp+102Eh] [bp+101Eh]
  unsigned __int8 v25; // [sp+102Fh] [bp+101Fh]
  int v26; // [sp+1030h] [bp+1020h]
  int v27; // [sp+1034h] [bp+1024h]
  int i; // [sp+1038h] [bp+1028h]
  unsigned __int16 v29; // [sp+103Ch] [bp+102Ch]
  unsigned __int8 v30; // [sp+103Fh] [bp+102Fh]

  v27 = a2;
  v26 = a3;
  v25 = 0;
  v24 = 0;
  if ( *(unsigned __int8 *)(a2 + 2) <= 9u )
    return 1;
  v23 = *(_BYTE *)(v27 + 2) - 2;
  v22 = v23 + 2;
  v21 = CRC16_v1((const unsigned __int8 *)(v27 + 2), v23);
  v20 = *(unsigned __int8 *)(v22 + 1 + v27) + (*(unsigned __int8 *)(v22 + v27) << 8);
  if ( v21 == v20 )
  {
    v19 = *(_DWORD *)(a1 + 624);
    v30 = 6;
    v29 = *(unsigned __int8 *)(v27 + 2) - 6;
    v18 = *(_BYTE *)(v27 + 3);
    if ( *(_BYTE *)(v27 + 5) == 1 )
    {
      *(_DWORD *)(v19 + 4 * (v18 + 1408)) = sub_70780((unsigned __int8 *)(v27 + 6));
      v29 -= 4;
      v30 += 4;
    }
    memcpy(
      (void *)(v19 + 720 * v18 + *(unsigned __int16 *)(v19 + 2 * (v18 + 3584)) + 21760),
      (const void *)(v30 + v27),
      v29);
    *(_WORD *)(v19 + 2 * (v18 + 3584)) += v29;
    if ( *(unsigned __int8 *)(v27 + 4) == *(unsigned __int8 *)(v27 + 5) )
    {
      *(_WORD *)(v26 + 85) = *(_WORD *)(v19 + 2 * (v18 + 3584));
      *(_DWORD *)(v26 + 81) = *(_DWORD *)(v19 + 4 * (v18 + 1408));
      for ( i = 0; *(_WORD *)(v19 + 2 * (v18 + 3584)) >> 2 > i; ++i )
        *(_DWORD *)(4 * (i + 20) + v26 + 7) = sub_70780((unsigned __int8 *)(4 * i + 720 * v18 + 21760 + v19));
      v8 = v19;
      v9 = v18 + 3584;
      *(_BYTE *)(v19 + 2 * v9) = 0;
      *(_BYTE *)(2 * v9 + v8 + 1) = 0;
      memset((void *)(720 * v18 + 21760 + v19), 0, 0x2D0u);
      *(_BYTE *)(v26 + 48) = v18;
      strcpy((char *)(v26 + 49), (const char *)(32 * (v18 + 32) + v19));
      v10 = (int *)(v19 + 8 * v18);
      v11 = *v10;
      v12 = v10[1];
      v13 = v26;
      *(_DWORD *)v26 = v11;
      *(_DWORD *)(v13 + 4) = v12;
      *a7 = *(_DWORD *)(v19 + 8 * v18);
      v24 = *(_DWORD *)(v19 + 4 * (v18 + 1408)) & 1;
      v25 = HIBYTE(*(_DWORD *)(v19 + 4 * (v18 + 1408))) / *(_DWORD *)(a1 + 240);
      *(_DWORD *)(v26 + 8) = v25;
      *(_DWORD *)(v26 + 12) = v24;
      memcpy((void *)(v26 + 16), (const void *)(32 * (v18 + 232) + v19), 0x20u);
      *a6 = v25;
      memcpy(a5, (const void *)(v26 + 81), 4u);
      *a4 = 0;
      return 0;
    }
    else
    {
      return 5;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v17, 0x1000u, 0, "get nonce crc error calc value %04x resp value %04x", v21, v20);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ae/backend_ae.c",
      81,
      "packet_2_nonce_ae",
      17,
      184,
      20,
      v17);
    return 2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00074A78) --------------------------------------------------------
int __fastcall makeup_chip_addr_ae(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (00074AC8) --------------------------------------------------------
int __fastcall setup_all_chip_ae(int a1)
{
  puts("setup_all_chip_ae");
  *(_DWORD *)(a1 + 240) = makeup_chip_addr_ae(*(_DWORD *)(a1 + 296), 4u);
  (*(void (__fastcall **)(int, _DWORD, int))(a1 + 148))(a1, *(_DWORD *)(a1 + 296), 4);
  sub_7090C(a1, 4);
  sub_71AB8(a1, 0, 1);
  if ( *(_BYTE *)(a1 + 268) != 1 )
    *(_DWORD *)(a1 + 272) = (int)*(float *)(a1 + 760);
  return 0;
}

//----- (00074B50) --------------------------------------------------------
int __fastcall set_baud_ae(int a1, char *a2)
{
  return sub_7121C(a1, a2);
}

//----- (00074BF0) --------------------------------------------------------
int __fastcall sub_74BF0(int a1, unsigned int a2, int a3, int a4, unsigned int a5)
{
  _BYTE v10[16]; // [sp+38h] [bp+10h] BYREF
  __int64 v11[4]; // [sp+1038h] [bp+1010h] BYREF
  _BYTE v12[168]; // [sp+105Ch] [bp+1034h] BYREF
  struct timeval v13; // [sp+1104h] [bp+10DCh] BYREF
  struct timeval v14; // [sp+110Ch] [bp+10E4h] BYREF
  unsigned __int8 sols_ae; // [sp+1117h] [bp+10EFh]
  unsigned int v16; // [sp+1118h] [bp+10F0h]
  unsigned int v17; // [sp+111Ch] [bp+10F4h]
  int j; // [sp+1120h] [bp+10F8h]
  int i; // [sp+1124h] [bp+10FCh]
  _DWORD vars0[4]; // [sp+1128h] [bp+1100h] BYREF

  memset(v12, 0, sizeof(v12));
  gettimeofday(&v14, 0);
  memset(v11, 0, sizeof(v11));
  generate_sipkeys_ae(a1, a2, v11);
  graph_init_ae(a5);
  for ( i = 0; a4 / 4 > i; ++i )
  {
    v17 = sip_node_ae(a5, v11[0], v11[1], v11[2], v11[3], *(_DWORD *)(a3 + 4 * i), 0);
    v16 = sip_node_ae(a5, v11[0], v11[1], v11[2], v11[3], *(_DWORD *)(a3 + 4 * i), 1u);
    graph_add_edge_ae(a5, v17 >> 1, v16 >> 1);
  }
  sols_ae = get_sols_ae(a5, v11[0], v11[1], v11[2], v11[3], (int)v12, a3, a4 / 4);
  if ( sols_ae )
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "[FindCycle] get golden nonce!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ae/backend_ae.c",
      81,
      "findcycle_ae",
      12,
      311,
      20,
      v10);
    qsort(v12, 0x2Au, 4u, (__compar_fn_t)sub_74BD0);
    for ( j = 0; j <= 41; ++j )
      *(_DWORD *)(4 * j + a3) = vars0[j - 51];
  }
  graph_exit_ae(a5);
  gettimeofday(&v13, 0);
  V_LOCK();
  logfmt_raw(
    v10,
    0x1000u,
    0,
    "[FindCycle], runtime_id:%d time: %ld us",
    a5,
    1000000 * v13.tv_sec + v13.tv_usec - 1000000 * v14.tv_sec - v14.tv_usec);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ae/backend_ae.c",
    81,
    "findcycle_ae",
    12,
    320,
    20,
    v10);
  return sols_ae;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 74BD0: using guessed type int sub_74BD0();
// 47BE18: using guessed type int g_zc;

//----- (00074FA4) --------------------------------------------------------
int __fastcall check_nonce_ae(_DWORD *a1, int a2)
{
  _DWORD *v3; // r0
  int v6; // [sp+3Ch] [bp+Ch] BYREF
  int v7; // [sp+103Ch] [bp+100Ch] BYREF
  _BYTE v8[4]; // [sp+1040h] [bp+1010h] BYREF
  _DWORD v9[3]; // [sp+1044h] [bp+1014h] BYREF
  int dest[20]; // [sp+1050h] [bp+1020h] BYREF
  _DWORD v11[36]; // [sp+10A0h] [bp+1070h] BYREF
  int v12[8]; // [sp+1148h] [bp+1118h] BYREF
  unsigned __int64 v13; // [sp+1168h] [bp+1138h] BYREF
  _DWORD v14[7]; // [sp+1170h] [bp+1140h] BYREF
  int v15; // [sp+118Ch] [bp+115Ch]
  char v16; // [sp+1193h] [bp+1163h]
  int v17; // [sp+1194h] [bp+1164h]
  int v18; // [sp+1198h] [bp+1168h]
  int i; // [sp+119Ch] [bp+116Ch]

  v18 = a2;
  v17 = a1[156];
  v13 = 0;
  memset(v12, 0, sizeof(v12));
  memcpy(dest, (const void *)(80 * *(unsigned __int8 *)(v18 + 48) + 11520 + v17), sizeof(dest));
  LZ4F_writeLE32(&v7, *(_DWORD *)(v17 + 4 * (*(unsigned __int8 *)(v18 + 48) + 1408)));
  sub_7087C(v8, dest[11]);
  base64_encode((int)v9, (int)&v7, 8);
  dest[11] = v9[0];
  dest[12] = v9[1];
  dest[13] = v9[2];
  v16 = sub_74BF0((int)dest, 0x50u, v18 + 87, *(unsigned __int16 *)(v18 + 85), a1[34]);
  if ( v16 != 1 )
  {
    V_LOCK();
    sub_70574((int)v14, (int)a1[35]);
    logfmt_raw(
      &v6,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "wc %d error_nonce %08x",
      *(unsigned __int8 *)(v18 + 48),
      *(_DWORD *)(v18 + 81));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ae/backend_ae.c",
      81,
      "check_nonce_ae",
      14,
      398,
      20,
      &v6);
    return 2;
  }
  else
  {
    memset(v12, 0, sizeof(v12));
    for ( i = 0; i <= 41; ++i )
      sub_7087C(&v11[i], *(_DWORD *)(4 * (i + 20) + v18 + 7));
    blake2b(v12, (int)v11, 0xA8u);
    sub_707BC(&v13, (int)&v13, v12[0], v12[1]);
    if ( *(_QWORD *)(v17 + 8 * (*(unsigned __int8 *)(v18 + 48) + 768)) >= v13 )
    {
      return 0;
    }
    else
    {
      V_LOCK();
      v3 = (_DWORD *)(v17 + 8 * (*(unsigned __int8 *)(v18 + 48) + 768));
      logfmt_raw(
        &v6,
        0x1000u,
        0,
        "wc %d nonce %08x hw target (%016llx > %016llx) not reach pool\n",
        *(unsigned __int8 *)(v18 + 48),
        *(_DWORD *)(v18 + 81),
        v13,
        *v3,
        v3[1]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ae/backend_ae.c",
        81,
        "check_nonce_ae",
        14,
        410,
        20,
        &v6);
      return 1;
    }
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00075374) --------------------------------------------------------
int get_chip_status_ae()
{
  return 0;
}

//----- (00075390) --------------------------------------------------------
int get_algo_type_ae()
{
  return 0;
}

//----- (000753AC) --------------------------------------------------------
int __fastcall softreset_all_chip_ae(int a1)
{
  sub_70EF4(a1);
  return 0;
}

//----- (000753C4) --------------------------------------------------------
int __fastcall get_theory_hashrate_ae(int a1, double *a2)
{
  if ( *(_BYTE *)(a1 + 268) )
    *a2 = *(double *)(a1 + 280);
  else
    *a2 = (double)*(int *)(a1 + 272) * 4.0 / (double)*(unsigned int *)(a1 + 204) * 1000.0 * 1000.0;
  return 0;
}

//----- (00075438) --------------------------------------------------------
int set_boot_config_ae()
{
  return 0;
}

//----- (00075450) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_ae(int a1)
{
  if ( !sub_730F4(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (00075478) --------------------------------------------------------
int __fastcall read_sensor_temp_local_ae(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_72C78(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_72D40(a1, a2, a3, a8);
  }
  return 0;
}

//----- (000754C8) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_ae(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_72CDC(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_72F18(a1, a2, a3, a8);
  }
  return 0;
}

//----- (00075518) --------------------------------------------------------
int parameter_update_ae()
{
  return 0;
}

//----- (0007553C) --------------------------------------------------------
int overclock_update_ae()
{
  return 0;
}

//----- (00075554) --------------------------------------------------------
int __fastcall get_pcba_test_level_ae(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 768);
  return 0;
}

//----- (00075578) --------------------------------------------------------
int __fastcall get_packet_remain_len_ae(unsigned __int8 a1)
{
  return a1 - 1;
}

//----- (00075594) --------------------------------------------------------
void *runtime_ctrl_ae()
{
  void *dest; // [sp+32Ch] [bp+32Ch]

  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1EEBB0, 0x310u);
  return dest;
}
// 1EEBB0: using guessed type _UNKNOWN *off_1EEBB0;

//----- (000755D0) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_755D0(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (000755F4) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_755F4(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (0007561C) --------------------------------------------------------
int __fastcall sub_7561C(int a1, int a2, unsigned int a3)
{
  return eth_sha3_256(a1, 0x20u, a2, a3);
}

//----- (0007563C) --------------------------------------------------------
int __fastcall sub_7563C(int a1, int a2, unsigned int a3)
{
  return eth_sha3_512(a1, 0x40u, a2, a3);
}

//----- (0007565C) --------------------------------------------------------
int __fastcall sub_7565C(const void *a1, const void *a2, const void *a3, int a4)
{
  _BYTE dest[32]; // [sp+10h] [bp+10h] BYREF
  _BYTE v9[8]; // [sp+30h] [bp+30h] BYREF
  _BYTE v10[32]; // [sp+50h] [bp+50h] BYREF

  memcpy(dest, a1, sizeof(dest));
  memcpy(v9, a2, sizeof(v9));
  sub_7563C((int)dest, (int)dest, 0x28u);
  memcpy(v10, a3, sizeof(v10));
  return sub_7561C(a4, (int)dest, 0x60u);
}

//----- (000756C0) --------------------------------------------------------
int __fastcall sub_756C0(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// 75704: variable 'v3' is possibly undefined

//----- (000757A0) --------------------------------------------------------
int __fastcall sub_757A0(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000758A4) --------------------------------------------------------
int __fastcall sub_758A4(unsigned __int8 *a1)
{
  return (*a1 << 24) + a1[3] + (a1[2] << 8) + (a1[1] << 16);
}

//----- (000758E0) --------------------------------------------------------
_BYTE *__fastcall sub_758E0(_BYTE *result, int a2, int a3, int a4)
{
  result[7] = a3;
  result[6] = BYTE1(a3);
  result[5] = BYTE2(a3);
  result[4] = HIBYTE(a3);
  result[3] = a4;
  result[2] = BYTE1(a4);
  result[1] = BYTE2(a4);
  *result = HIBYTE(a4);
  return result;
}

//----- (000759A0) --------------------------------------------------------
_BYTE *__fastcall sub_759A0(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (000759E8) --------------------------------------------------------
int __fastcall sub_759E8(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_ETH", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_ETH",
    24,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_755F4((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_ETH",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_ETH",
    24,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_ETH",
      24,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_ETH",
          24,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_755F4((int)v12, *(int *)(a1 + 140));
    sub_755D0(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_ETH",
      24,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// 75B40: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00075FD0) --------------------------------------------------------
int __fastcall sub_75FD0(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_ETH", 32);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_ETH",
    30,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 2097153;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000760C4) --------------------------------------------------------
int __fastcall sub_760C4(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_ETH", 32);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_ETH",
    39,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 32;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000761D4) --------------------------------------------------------
int __fastcall sub_761D4(int a1, unsigned __int8 a2)
{
  int v4; // [sp+14h] [bp+4h]
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]

  v4 = a1;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %d", "ChipSetting_ticket_mask_ETH", 20, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_ticket_mask_ETH",
    27,
    137,
    20,
    v5);
  v6[2] = 1310721;
  v6[0] = a2;
  v7 = (*(int (__fastcall **)(int, _DWORD *))(v4 + 156))(v4, v6);
  *(_DWORD *)(v4 + 244) = a2;
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000762F8) --------------------------------------------------------
int __fastcall sub_762F8(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 3145729;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_ETH",
    20,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007658C) --------------------------------------------------------
int __fastcall sub_7658C(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 3145729;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_ETH",
    24,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000767B0) --------------------------------------------------------
unsigned int *__fastcall sub_767B0(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// 767E8: variable 'v1' is possibly undefined

//----- (000768C0) --------------------------------------------------------
int __fastcall sub_768C0(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 786433;
  sub_767B0(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_ETH",
    20,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// 76940: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00076A14) --------------------------------------------------------
int __fastcall sub_76A14(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 12;
  sub_767B0(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_ETH",
    29,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// 76AB6: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00076B94) --------------------------------------------------------
int __fastcall sub_76B94(int a1, char a2, int a3)
{
  _BYTE v7[16]; // [sp+20h] [bp+10h] BYREF
  _DWORD v8[5]; // [sp+1020h] [bp+1010h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s core_num %d reg %02x %d", "ChipSetting_open_cores_ETH", 16, 13, 20000);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_open_cores_ETH",
    26,
    315,
    40,
    v7);
  memset(v8, 0, 0x10u);
  v8[2] = 851969;
  v8[0] = a3;
  BYTE1(v8[3]) = 16;
  LOBYTE(v8[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v8, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00076CC0) --------------------------------------------------------
int __fastcall sub_76CC0(int a1, char a2)
{
  _BYTE v5[16]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[5]; // [sp+1018h] [bp+1008h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s", "ChipSetting_close_cores_ETH");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_close_cores_ETH",
    27,
    329,
    20,
    v5);
  memset(v6, 0, 0x10u);
  v6[2] = 851969;
  v6[0] = 0;
  BYTE1(v6[3]) = 16;
  LOBYTE(v6[3]) = a2;
  return (*(int (__fastcall **)(int, _DWORD *, int, _DWORD))(a1 + 168))(a1, v6, 20000, 0);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00076DD0) --------------------------------------------------------
int __fastcall sub_76DD0(int a1)
{
  int v2; // [sp+4h] [bp-34h]
  int v4; // [sp+44h] [bp+Ch] BYREF
  int v5; // [sp+1044h] [bp+100Ch] BYREF
  _WORD v6[8]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v7[7]; // [sp+1058h] [bp+1020h] BYREF
  int v8; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v9; // [sp+107Ch] [bp+1044h]
  int j; // [sp+1080h] [bp+1048h]
  int i; // [sp+1084h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    &v4,
    0x1000u,
    0,
    "get start nonce offset %s chip_no %d",
    "ChipSetting_start_nonce_offset_ETH",
    *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_start_nonce_offset_ETH",
    34,
    352,
    20,
    &v4);
  memset(v6, 0, sizeof(v6));
  LOBYTE(v6[4]) = 1;
  v9 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
  for ( i = 0; i <= 1; ++i )
  {
    v6[5] = 8 * (i + 2);
    memset(v9, 0, 12 * *(_DWORD *)(a1 + 196));
    (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
      a1,
      v6,
      *(_DWORD *)(a1 + 196),
      v9,
      &v5,
      v2,
      2000,
      0);
    for ( j = 0; j < v5; ++j )
    {
      V_LOCK();
      sub_755F4((int)v7, *(int *)(a1 + 140));
      logfmt_raw(
        &v4,
        0x1000u,
        0,
        v8,
        v7[0],
        v7[1],
        v7[2],
        v7[3],
        v7[4],
        v7[5],
        v7[6],
        v8,
        "%s asic %d, reg %02x SNO %08x",
        "ChipSetting_start_nonce_offset_ETH",
        v9[12 * j + 4],
        *(unsigned __int16 *)&v9[12 * j + 6],
        *(_DWORD *)&v9[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_start_nonce_offset_ETH",
        34,
        365,
        60,
        &v4);
    }
  }
  free(v9);
  return v5;
}
// 76F30: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000770C0) --------------------------------------------------------
int __fastcall sub_770C0(int a1)
{
  _BYTE v4[16]; // [sp+40h] [bp+8h] BYREF
  int v5; // [sp+1040h] [bp+1008h] BYREF
  int v6; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v7[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v8[7]; // [sp+1058h] [bp+1020h] BYREF
  int v9; // [sp+1074h] [bp+103Ch]
  int v10; // [sp+1078h] [bp+1040h]
  int j; // [sp+107Ch] [bp+1044h]
  char v12; // [sp+1083h] [bp+104Bh]
  int i; // [sp+1084h] [bp+104Ch]
  unsigned __int8 v14; // [sp+108Bh] [bp+1053h]
  unsigned __int8 *v15; // [sp+108Ch] [bp+1054h]

  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get pmdata %s chip_no %d", "ChipSetting_pmdata_ETH", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_pmdata_ETH",
    22,
    380,
    20,
    v4);
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 1;
  v14 = 0;
  for ( i = 0; i <= 1; ++i )
  {
    HIWORD(v7[2]) = 60;
    v7[0] = i << 8;
    v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_pmdata_ETH", HIWORD(v7[2]));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_pmdata_ETH",
        22,
        391,
        100,
        v4);
      return -1;
    }
    v15 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      usleep(0x3E8u);
      memset(v15, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD, unsigned __int8 *, int *, int, _DWORD))(a1 + 172))(
        a1,
        *(_DWORD *)(a1 + 196),
        v15,
        &v6,
        2000,
        0);
      v12 = 0;
      for ( j = 0; j < v6; ++j )
      {
        if ( *(_WORD *)&v15[12 * j + 6] == 60 )
        {
          v12 = 60;
          v5 = 0;
          sub_759A0(&v5, *(_DWORD *)&v15[12 * j]);
          V_LOCK();
          sub_755F4((int)v8, *(int *)(a1 + 140));
          logfmt_raw(
            v4,
            0x1000u,
            0,
            v9,
            v8[0],
            v8[1],
            v8[2],
            v8[3],
            v8[4],
            v8[5],
            v8[6],
            v9,
            "%s asic %d, reg %02x VT %d PMDATA %08x",
            "ChipSetting_pmdata_ETH",
            v15[12 * j + 4],
            *(unsigned __int16 *)&v15[12 * j + 6],
            i,
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_pmdata_ETH",
            22,
            406,
            60,
            v4);
        }
      }
      if ( v6 && v12 == 60 )
        break;
      ++v14;
    }
    while ( v14 <= 4u );
    v14 = 0;
  }
  free(v15);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00077524) --------------------------------------------------------
int __fastcall sub_77524(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_ETH", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_ETH",
    25,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 108;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 108 )
        {
          sub_759A0(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_755F4((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_ETH",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_ETH",
            25,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_ETH", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_ETH",
      25,
      436,
      100,
      v5);
    return -1;
  }
}
// 77732: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00077910) --------------------------------------------------------
int __fastcall sub_77910(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 4718593;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_ETH",
    26,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00077A2C) --------------------------------------------------------
int __fastcall sub_77A2C(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 56;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (00077A78) --------------------------------------------------------
int __fastcall sub_77A78(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 56;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (00077B98) --------------------------------------------------------
int __fastcall sub_77B98(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_77A2C(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_77A78(a1, a2, a3, s, a6, n);
}

//----- (00077C0C) --------------------------------------------------------
int __fastcall sub_77C0C(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_77B98(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00077CB0) --------------------------------------------------------
int __fastcall sub_77CB0(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_77B98(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (00077D54) --------------------------------------------------------
int __fastcall sub_77D54(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_77B98(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00077DB8) --------------------------------------------------------
int __fastcall sub_77DB8(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_77B98(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (00077E1C) --------------------------------------------------------
int __fastcall sub_77E1C(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_ETH",
        45,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_ETH",
      45,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00077FF4) --------------------------------------------------------
int __fastcall sub_77FF4(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_ETH",
        46,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_ETH",
      46,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000781D0) --------------------------------------------------------
int __fastcall sub_781D0(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_77A2C(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00078208) --------------------------------------------------------
int __fastcall sub_78208(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 5308417;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0007825C) --------------------------------------------------------
int __fastcall sub_7825C(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 81;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 81 )
    {
      V_LOCK();
      sub_755F4((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_ETH",
        30,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00078528) --------------------------------------------------------
int __fastcall sub_78528(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (000785B4) --------------------------------------------------------
unsigned int __fastcall sub_785B4(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0x60u);
  memset(v13, 0, 0x60u);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 8, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_755F4((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_ETH",
        31,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00078860) --------------------------------------------------------
int __fastcall sub_78860(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (000788A8) --------------------------------------------------------
int __fastcall sub_788A8(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00078900) --------------------------------------------------------
int __fastcall sub_78900(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00078960) --------------------------------------------------------
int __fastcall sub_78960(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000789C4) --------------------------------------------------------
int __fastcall sub_789C4(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (00078A20) --------------------------------------------------------
int __fastcall sub_78A20(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = 16 * *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_ETH", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_ETH",
    31,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_755F4((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_ETH",
      31,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// 78BDC: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00078DA0) --------------------------------------------------------
int __fastcall sub_78DA0(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 16;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_ETH", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_ETH",
    43,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_755F4((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_ETH",
      43,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// 78F50: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079118) --------------------------------------------------------
char *__fastcall sub_79118(const char *a1, signed int a2)
{
  char *result; // r0
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a2 > 63 || dword_47A2D0[0] > 63 )
  {
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, "slt_result is full!");
    V_UNLOCK();
    return (char *)zlog(
                     g_zc,
                     "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
                     83,
                     "set_test_result",
                     15,
                     141,
                     100,
                     v3);
  }
  else
  {
    result = strncpy((char *)&dword_47A2D0[16 * dword_47A2D0[0] + 1], a1, a2);
    ++dword_47A2D0[0];
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47A2D0: using guessed type int dword_47A2D0[1025];
// 47BE18: using guessed type int g_zc;

//----- (000791EC) --------------------------------------------------------
__int64 sub_791EC()
{
  _BYTE v1[8]; // [sp+10h] [bp+0h] BYREF
  int i; // [sp+1010h] [bp+1000h]
  int v3; // [sp+1014h] [bp+1004h]

  v3 = 0;
  for ( i = 0; dword_47A2D0[0] > i; ++i )
  {
    V_LOCK();
    logfmt_raw(v1, 0x1000u, 0, "%s", &dword_47A2D0[16 * i + 1]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "print_test_result",
      17,
      149,
      60,
      v1);
    if ( strstr((const char *)&dword_47A2D0[16 * i + 1], "failed") )
      ++v3;
  }
  V_LOCK();
  logfmt_raw(v1, 0x1000u, 0, "slt test end!!!\n");
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
           83,
           "print_test_result",
           17,
           160,
           60,
           v1);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47A2D0: using guessed type int dword_47A2D0[1025];
// 47BE18: using guessed type int g_zc;

//----- (00079338) --------------------------------------------------------
unsigned int __fastcall sub_79338(unsigned int a1)
{
  return HIBYTE(a1) | (a1 << 24) | ((a1 & 0xFF00) << 8) | ((a1 & 0xFF0000) >> 8);
}

//----- (0007936C) --------------------------------------------------------
int __fastcall sub_7936C(void *a1)
{
  memcpy(a1, &unk_1C3D88, 0xEu);
  return 14;
}

//----- (00079398) --------------------------------------------------------
__int64 __fastcall sub_79398(_DWORD *a1)
{
  _BYTE v3[8]; // [sp+20h] [bp+8h] BYREF
  _WORD v4[28]; // [sp+1020h] [bp+1008h] BYREF
  unsigned int i; // [sp+1064h] [bp+104Ch]

  for ( i = 0; i <= 0x1F; ++i )
    sprintf((char *)&v4[i], "%02x", *((unsigned __int8 *)a1 + i + 16));
  V_LOCK();
  logfmt_raw(
    v3,
    0x1000u,
    0,
    "eth dump work poolid %lld start_nonce %016llx, header_hash %s",
    *a1,
    a1[1],
    a1[20],
    a1[21],
    v4);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
           83,
           "dump_work",
           9,
           197,
           60,
           v3);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000794A4) --------------------------------------------------------
int __fastcall sub_794A4(int a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  printf("work[%3d]: ", 46);
  for ( i = 0; i <= 0x2D; ++i )
    printf("%02x", *(unsigned __int8 *)(i + a1));
  return putchar(10);
}

//----- (000794F4) --------------------------------------------------------
int __fastcall sub_794F4(int a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  printf("nonce[%3d]: ", 46);
  for ( i = 0; i <= 0x2D; ++i )
    printf("%02x ", *(unsigned __int8 *)(i + a1));
  return putchar(10);
}

//----- (00079544) --------------------------------------------------------
int __fastcall set_ticketmask(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s %u...", "set_ticketmask", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_ticketmask",
    14,
    228,
    60,
    v5);
  sub_788A8(a1, 10, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000795F0) --------------------------------------------------------
int __fastcall open_core_clk_tops(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "open_core_clk_tops");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_clk_tops",
    18,
    239,
    60,
    v3);
  sub_78860(a1, 22, -2147483641);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079688) --------------------------------------------------------
int __fastcall open_serdes_clk_close_core_clk(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "open_serdes_clk_close_core_clk");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_serdes_clk_close_core_clk",
    30,
    246,
    60,
    v3);
  sub_78860(a1, 22, -2147483642);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079720) --------------------------------------------------------
int __fastcall set_pll_div(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "set_pll_div");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_pll_div",
    11,
    253,
    60,
    v3);
  sub_78860(a1, 24, 131080);
  usleep(0x2710u);
  sub_78860(a1, 24, 131081);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000797D4) --------------------------------------------------------
int __fastcall set_debug_ctrl(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_debug_ctrl");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_debug_ctrl",
    14,
    262,
    60,
    v5);
  sub_78860(a1, 80, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079878) --------------------------------------------------------
int __fastcall set_core_reset(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "set_core_reset");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_core_reset",
    14,
    269,
    60,
    v3);
  sub_78860(a1, 32, 9);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78860(a1, 32, 15);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_788A8(a1, 240, 0x80000000);
  usleep(0x2710u);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079948) --------------------------------------------------------
int __fastcall set_start_delay(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_start_delay");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_start_delay",
    15,
    280,
    60,
    v5);
  sub_788A8(a1, 22, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000799EC) --------------------------------------------------------
int __fastcall set_initial_interval_time(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_initial_interval_time");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_initial_interval_time",
    25,
    287,
    60,
    v5);
  sub_788A8(a1, 59, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079A90) --------------------------------------------------------
int __fastcall set_reset_to_normal(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_reset_to_normal");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_reset_to_normal",
    19,
    294,
    60,
    v5);
  sub_788A8(a1, 198, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079B34) --------------------------------------------------------
int __fastcall get_timeout_count(int a1)
{
  int v3; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 i; // [sp+101Fh] [bp+100Fh]

  V_LOCK();
  logfmt_raw(&v3, 0x1000u, 0, "%s...", "get_timeout_count");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "get_timeout_count",
    17,
    301,
    60,
    &v3);
  for ( i = 0; i <= 5u; ++i )
  {
    sub_78A20(a1, 255, i + 23, 0);
    usleep(0x2710u);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079C0C) --------------------------------------------------------
int __fastcall reverse_start_nonce(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "reverse_start_nonce");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "reverse_start_nonce",
    19,
    310,
    60,
    v5);
  sub_788A8(a1, 203, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079CB0) --------------------------------------------------------
int __fastcall close_core9(int a1)
{
  sub_789C4(a1, 9, 13, 0);
  usleep(0x2710u);
  return 0;
}

//----- (00079CD8) --------------------------------------------------------
int __fastcall get_count_sync(int a1, unsigned __int8 a2)
{
  _BYTE v5[12]; // [sp+1Ch] [bp+Ch] BYREF
  int v6; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 *v7; // [sp+1020h] [bp+1010h]
  int i; // [sp+1024h] [bp+1014h]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "get_count_sync");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "get_count_sync",
    14,
    323,
    60,
    v5);
  v7 = (unsigned __int8 *)malloc(0x600u);
  v6 = sub_78A20(a1, a2, 202, v7);
  for ( i = 0; i < v6; ++i )
  {
    V_LOCK();
    logfmt_raw(
      v5,
      0x1000u,
      0,
      "chip %02x core %02x reg %02x cnt %08x",
      v7[12 * i + 4],
      v7[12 * i + 8],
      *(unsigned __int16 *)&v7[12 * i + 6],
      *(_DWORD *)&v7[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "get_count_sync",
      14,
      328,
      60,
      v5);
  }
  free(v7);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00079EDC) --------------------------------------------------------
int __fastcall get_work_mode(int a1)
{
  _BYTE v3[12]; // [sp+1Ch] [bp+Ch] BYREF
  int v4; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 *v5; // [sp+1020h] [bp+1010h]
  int i; // [sp+1024h] [bp+1014h]

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "get_work_mode");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "get_work_mode",
    13,
    335,
    60,
    v3);
  v5 = (unsigned __int8 *)malloc(0x600u);
  v4 = sub_78A20(a1, 255, 12, v5);
  for ( i = 0; i < v4; ++i )
  {
    V_LOCK();
    logfmt_raw(
      v3,
      0x1000u,
      0,
      "chip %02x core %02x reg %02x cnt %08x",
      v5[12 * i + 4],
      v5[12 * i + 8],
      *(unsigned __int16 *)&v5[12 * i + 6],
      *(_DWORD *)&v5[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "get_work_mode",
      13,
      340,
      60,
      v3);
  }
  free(v5);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007A0CC) --------------------------------------------------------
int __fastcall setup_count_sync(int a1, char a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "setup_count_sync");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "setup_count_sync",
    16,
    348,
    60,
    v5);
  sub_789C4(a1, a2, 202, 0);
  sub_789C4(a1, a2, 202, 1);
  usleep(0x3E8u);
  sub_789C4(a1, a2, 202, 0x80000000);
  usleep(0x2710u);
  get_count_sync(a1, a2);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007A1C4) --------------------------------------------------------
int __fastcall set_dag_node_num(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s %08x", "set_dag_node_num", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_dag_node_num",
    16,
    363,
    60,
    v5);
  sub_788A8(a1, 11, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007A270) --------------------------------------------------------
int __fastcall clear_dag_mode(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "clear_dag_mode");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "clear_dag_mode",
    14,
    370,
    60,
    v3);
  sub_788A8(a1, 196, 0);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007A304) --------------------------------------------------------
int __fastcall set_mac_stats(int a1)
{
  int v3; // [sp+8h] [bp+8h] BYREF
  unsigned int i; // [sp+Ch] [bp+Ch]

  v3 = -1734895979;
  for ( i = 0; i <= 3; ++i )
    sub_788A8(a1, *((unsigned __int8 *)&v3 + i), 0);
  return 0;
}

//----- (0007A34C) --------------------------------------------------------
int __fastcall get_mac_stats(int a1)
{
  _BYTE v3[28]; // [sp+1Ch] [bp+Ch] BYREF
  int v4; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v5; // [sp+1020h] [bp+1010h]
  int v6; // [sp+1024h] [bp+1014h]
  unsigned __int8 *v7; // [sp+1028h] [bp+1018h]
  int k; // [sp+102Ch] [bp+101Ch]
  unsigned int j; // [sp+1030h] [bp+1020h]
  unsigned __int8 i; // [sp+1037h] [bp+1027h]

  v4 = -1734895979;
  v7 = (unsigned __int8 *)malloc(0x600u);
  for ( i = 0; i <= 7u; ++i )
  {
    for ( j = 0; j <= 3; ++j )
    {
      v6 = sub_78DA0(a1, i, 255, *((unsigned __int8 *)&v4 + j), v7);
      for ( k = 0; k < v6; ++k )
      {
        v5 = sub_79338(*(_DWORD *)&v7[12 * k]);
        V_LOCK();
        logfmt_raw(
          v3,
          0x1000u,
          0,
          "[MAC STATS]chip %02x core %02x addr %04x, %08x",
          v7[12 * k + 4],
          v7[12 * k + 8],
          *((unsigned __int8 *)&v4 + j),
          v5);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "get_mac_stats",
          13,
          397,
          60,
          v3);
      }
    }
  }
  free(v7);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007A574) --------------------------------------------------------
int __fastcall check_mac_done(int a1, int a2, unsigned __int8 a3, int a4)
{
  _UNKNOWN **v4; // r0
  int v5; // r4
  int v6; // r5
  int v7; // r6
  unsigned int v8; // r0
  int v9; // r4
  int v10; // r5
  int v11; // r6
  unsigned int v12; // r0
  int v13; // r4
  int v14; // r5
  int v15; // r6
  unsigned int v16; // r0
  int v17; // r4
  int v18; // r5
  int v19; // r6
  unsigned int v20; // r0
  int v21; // r4
  int v22; // r5
  int v23; // r6
  unsigned int v24; // r0
  _BYTE s[64]; // [sp+20h] [bp+10h] BYREF
  _BYTE v30[4080]; // [sp+60h] [bp+50h] BYREF
  _BYTE v31[16]; // [sp+1060h] [bp+1050h] BYREF
  int v32; // [sp+1070h] [bp+1060h]
  int v33; // [sp+1074h] [bp+1064h]
  int v34; // [sp+1078h] [bp+1068h]
  int v35; // [sp+107Ch] [bp+106Ch]
  unsigned __int8 v36; // [sp+1083h] [bp+1073h]
  int v37; // [sp+1084h] [bp+1074h]
  int v38; // [sp+1088h] [bp+1078h]
  unsigned __int8 *v39; // [sp+108Ch] [bp+107Ch]
  int j; // [sp+1090h] [bp+1080h]
  int i; // [sp+1094h] [bp+1084h]
  unsigned __int8 v42; // [sp+109Bh] [bp+108Bh]
  int v43; // [sp+109Ch] [bp+108Ch]

  V_LOCK();
  logfmt_raw(v30, 0x1000u, 0, "%s...", "check_mac_done");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_mac_done",
    14,
    409,
    60,
    v30);
  sub_789C4(a1, a3, 149, 0);
  sub_789C4(a1, a3, 151, 0);
  sub_789C4(a1, a3, 153, 0);
  sub_789C4(a1, a3, 87, 255);
  sub_789C4(a1, a3, 159, 0);
  sub_789C4(a1, a3, 133, 805306367);
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      sub_789C4(a1, a3, 134, 0xFFFFFFF);
      sub_789C4(a1, a3, 132, -2147483647);
    }
  }
  else
  {
    sub_789C4(a1, a3, 134, 0xFFFFFFF);
    sub_789C4(a1, a3, 132, 17);
  }
  sleep(8u);
  v39 = (unsigned __int8 *)malloc(0x600u);
  v43 = 1;
  memset(v31, 0, sizeof(v31));
  if ( a3 == 255 )
    v43 = sub_7936C(v31);
  v42 = 0;
  for ( i = 0; i < v43; ++i )
  {
    if ( a3 == 255 )
      v42 = v31[i];
    else
      v42 = a3;
    v4 = dev_ctrl();
    ((void (__fastcall *)(_DWORD))v4[18])(*(_DWORD *)(a1 + 136));
    memset(s, 0, sizeof(s));
    v38 = 0;
    v37 = sub_78A20(a1, v42, 139, v39);
    for ( j = 0; j < v37; ++j )
    {
      v36 = v39[12 * j + 4];
      if ( (*(_DWORD *)&v39[12 * j] & 0xFF000000) == 0xFF000000 )
      {
        v34 = 0;
        v35 = 0;
        v32 = 0;
        v33 = 0;
        if ( (unsigned __int8)*(_DWORD *)&v39[12 * j] == 255 || v42 == 3 )
        {
          if ( (*(_DWORD *)&v39[12 * j] & 0xF0) != 0xF0 && v42 == 3 )
          {
            V_LOCK();
            logfmt_raw(
              v30,
              0x1000u,
              0,
              "chain %d chip %02x core %02x mac bist status %02x",
              *(_DWORD *)(a1 + 136),
              v39[12 * j + 4],
              v39[12 * j + 8],
              *(_DWORD *)&v39[12 * j] & 0xF0);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
              83,
              "check_mac_done",
              14,
              473,
              100,
              v30);
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(
            v30,
            0x1000u,
            0,
            "chain %d chip %02x core %02x mac bist status %02x",
            *(_DWORD *)(a1 + 136),
            v39[12 * j + 4],
            v39[12 * j + 8],
            (unsigned __int8)*(_DWORD *)&v39[12 * j]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_mac_done",
            14,
            470,
            100,
            v30);
        }
        v38 = sub_78DA0(a1, v36, v42, 135, v39);
        if ( v38 && *(_DWORD *)v39 && v42 != 3 )
        {
          V_LOCK();
          v5 = *(_DWORD *)(a1 + 136);
          v6 = v39[4];
          v7 = v39[8];
          v8 = sub_79338(*(_DWORD *)v39);
          logfmt_raw(
            v30,
            0x1000u,
            0,
            "chain %d channel[0~3] chip %02x core %02x reg 0x87 mac bist err cnt %08x",
            v5,
            v6,
            v7,
            v8);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_mac_done",
            14,
            479,
            100,
            v30);
        }
        v38 = sub_78DA0(a1, v36, v42, 136, v39);
        if ( v38 && *(_DWORD *)v39 )
        {
          V_LOCK();
          v9 = *(_DWORD *)(a1 + 136);
          v10 = v39[4];
          v11 = v39[8];
          v12 = sub_79338(*(_DWORD *)v39);
          logfmt_raw(
            v30,
            0x1000u,
            0,
            "chain %d channel[4~7] chip %02x core %02x reg 0x88 mac bist err cnt %08x",
            v9,
            v10,
            v11,
            v12);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_mac_done",
            14,
            488,
            100,
            v30);
        }
        v38 = sub_78DA0(a1, v36, v42, 137, v39);
        if ( v38 && *(_DWORD *)v39 && v42 != 3 )
        {
          V_LOCK();
          v13 = *(_DWORD *)(a1 + 136);
          v14 = v39[4];
          v15 = v39[8];
          v16 = sub_79338(*(_DWORD *)v39);
          logfmt_raw(
            v30,
            0x1000u,
            0,
            "chain %d channel[0~3] chip %02x core %02x reg 0x89 mac bist lost cnt %08x",
            v13,
            v14,
            v15,
            v16);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_mac_done",
            14,
            497,
            100,
            v30);
        }
        v38 = sub_78DA0(a1, v36, v42, 138, v39);
        if ( v38 && *(_DWORD *)v39 )
        {
          V_LOCK();
          v17 = *(_DWORD *)(a1 + 136);
          v18 = v39[4];
          v19 = v39[8];
          v20 = sub_79338(*(_DWORD *)v39);
          logfmt_raw(
            v30,
            0x1000u,
            0,
            "chain %d channel[4~7] chip %02x core %02x reg 0x8a mac bist lost cnt %08x",
            v17,
            v18,
            v19,
            v20);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_mac_done",
            14,
            506,
            100,
            v30);
        }
      }
      else
      {
        V_LOCK();
        v21 = *(_DWORD *)(a1 + 136);
        v22 = v36;
        v23 = v39[12 * j + 8];
        v24 = sub_79338(*(_DWORD *)&v39[12 * j]);
        logfmt_raw(
          v30,
          0x1000u,
          0,
          "chain %d xxxxxxxxxx chip %02x core %02x mac bist not done(%08x) xxxxxxxxxxx",
          v21,
          v22,
          v23,
          v24);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "check_mac_done",
          14,
          514,
          60,
          v30);
      }
    }
  }
  free(v39);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007AFA4) --------------------------------------------------------
int __fastcall enable_one_lane(int a1, unsigned __int8 a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s lane %d...", "enable_one_lane", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "enable_one_lane",
    15,
    529,
    60,
    v5);
  sub_78960(a1, 0, 255, 197, 0);
  sub_789C4(a1, 0, 199, 0x7FFFF);
  sub_789C4(a1, 1, 199, 2097103);
  sub_789C4(a1, 2, 199, 0x7FFFF);
  sub_789C4(a1, 5, 199, 0x7FFFF);
  sub_789C4(a1, 6, 199, 0x7FFFF);
  sub_789C4(a1, 7, 199, 2097103);
  sub_789C4(a1, 15, 199, 0x7FFFF);
  sub_789C4(a1, 8, 199, 2097103);
  sub_789C4(a1, 0, 159, 29360576);
  sub_789C4(a1, 1, 159, 25297282);
  sub_789C4(a1, 2, 159, 29360576);
  sub_789C4(a1, 5, 159, 29360576);
  sub_789C4(a1, 6, 159, 29360576);
  sub_789C4(a1, 7, 159, 25297282);
  sub_789C4(a1, 15, 159, 29360576);
  sub_789C4(a1, 8, 159, 25297282);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007B1CC) --------------------------------------------------------
int __fastcall setup_clk(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "setup_clk");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "setup_clk",
    9,
    556,
    60,
    v3);
  sub_78860(a1, 32, 1);
  sub_78860(a1, 16, 0);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78860(a1, 18, 4727297);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78860(a1, 20, 2105857);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78860(a1, 16, 7);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78860(a1, 32, 15);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78860(a1, 22, -2147483633);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78860(a1, 49, 0);
  usleep((__useconds_t)&stru_1869C.st_value);
  set_core_reset(a1);
  setup_ref_clk_termination(a1);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007B344) --------------------------------------------------------
int __fastcall sub_7B344(int a1, char a2, char a3)
{
  int v8; // [sp+10h] [bp+8h]
  int v9; // [sp+14h] [bp+Ch]
  int v10; // [sp+18h] [bp+10h]
  int v11; // [sp+1Ch] [bp+14h]
  _DWORD v12[2]; // [sp+20h] [bp+18h] BYREF
  unsigned __int8 v13; // [sp+2Bh] [bp+23h]
  unsigned int i; // [sp+2Ch] [bp+24h]
  _BYTE v15[4]; // [sp+30h] [bp+28h] BYREF

  v12[0] = 100991489;
  v12[1] = 235735561;
  v8 = 50462721;
  v9 = 117834757;
  v10 = 185206793;
  v11 = 252578829;
  v13 = 16;
  for ( i = 0; i <= 7; ++i )
  {
    if ( a3 == *((_BYTE *)v12 + i) )
    {
      v13 = v15[2 * i - 31];
      sub_78960(a1, a2, a3, 80, 0);
      usleep((__useconds_t)&stru_1869C.st_value);
      sub_78960(a1, a2, a3, 80, 0x10000);
      usleep((__useconds_t)&stru_1869C.st_value);
      sub_78960(a1, a2, v13, 80, 0);
      usleep((__useconds_t)&stru_1869C.st_value);
      sub_78960(a1, a2, v13, 80, 0x10000);
      usleep((__useconds_t)&stru_1869C.st_value);
      return v13;
    }
  }
  sub_78960(a1, a2, a3, 80, 0);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, a2, a3, 80, 0x10000);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v13;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (0007B47C) --------------------------------------------------------
int __fastcall sub_7B47C(int a1, int a2)
{
  int v6; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v7[16]; // [sp+101Ch] [bp+100Ch] BYREF
  _BYTE v8[1026]; // [sp+102Ch] [bp+101Ch] BYREF
  unsigned __int8 v9; // [sp+142Eh] [bp+141Eh]
  unsigned __int8 v10; // [sp+142Fh] [bp+141Fh]
  int v11; // [sp+1430h] [bp+1420h]
  unsigned __int8 j; // [sp+1436h] [bp+1426h]
  unsigned __int8 i; // [sp+1437h] [bp+1427h]
  char *v14; // [sp+1438h] [bp+1428h]
  int v15; // [sp+143Ch] [bp+142Ch]

  memset(v8, 0, 0x400u);
  v15 = 0;
  v11 = sub_7936C(v7);
  v14 = v8;
  for ( i = 0; i <= 7u; ++i )
  {
    for ( j = 0; j < v11; ++j )
    {
      v10 = v7[j];
      V_LOCK();
      logfmt_raw(
        &v6,
        0x1000u,
        0,
        "%s chip %x core %x cmn status %x",
        "check_cmn_lock_and_reset_worse_phy",
        i,
        v10,
        *(unsigned __int8 *)(a2 + v10 + 16 * i));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_cmn_lock_and_reset_worse_phy",
        34,
        632,
        20,
        &v6);
      if ( *(_BYTE *)(a2 + v10 + 16 * i) )
      {
        v9 = sub_7B344(a1, i, v10);
        if ( v9 == v10 || v9 > 0xFu )
        {
          sprintf(v14, "%1x-%1x ", i, v10);
          v14 += 4;
        }
        else
        {
          sprintf(v14, "%1x-%1x-%1x ", i, v10, v9);
          v14 += 6;
        }
        ++v15;
      }
    }
  }
  V_LOCK();
  logfmt_raw(&v6, 0x1000u, 0, "%s (%d) %s", "check_cmn_lock_and_reset_worse_phy", v15, v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_cmn_lock_and_reset_worse_phy",
    34,
    646,
    60,
    &v6);
  if ( v15 <= 0 )
    return 0;
  else
    return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007B7C4) --------------------------------------------------------
int __fastcall phy_power_reset(int a1)
{
  _BYTE v3[8]; // [sp+18h] [bp+8h] BYREF
  unsigned __int32 *p_st_value; // [sp+1018h] [bp+1008h]
  unsigned __int8 i; // [sp+101Fh] [bp+100Fh]

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "phy_power_reset");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "phy_power_reset",
    15,
    657,
    60,
    v3);
  p_st_value = &stru_1869C.st_value;
  sub_788A8(a1, 80, 0);
  usleep((__useconds_t)p_st_value);
  for ( i = 0; i <= 7u; ++i )
  {
    sub_78960(a1, i, 1, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 2, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 5, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 6, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 9, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 10, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 13, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 14, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 0, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 3, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 7, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 8, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 11, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
    sub_78960(a1, i, 15, 80, 0x10000);
    usleep((__useconds_t)p_st_value);
  }
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007BB48) --------------------------------------------------------
int __fastcall sub_7BB48(_DWORD *a1, signed int a2)
{
  _BYTE v6[12]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE *v7; // [sp+101Ch] [bp+100Ch]
  char v8; // [sp+1022h] [bp+1012h]
  char v9; // [sp+1023h] [bp+1013h]
  signed int i; // [sp+1024h] [bp+1014h]

  v9 = 0;
  v8 = 0;
  v7 = calloc(a2, 8u);
  if ( v7 )
  {
    for ( i = 0; i < a2; ++i )
    {
      if ( BYTE1(a1[2 * i]) == i )
      {
        v7[8 * i + 1] = i;
        *(_DWORD *)&v7[8 * i + 4] = a1[2 * i + 1];
      }
    }
    memcpy(a1, v7, 8 * a2);
    free(v7);
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "%s calloc failed!", "sort_resp_data_by_core_id");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "sort_resp_data_by_core_id",
      25,
      786,
      100,
      v6);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007BD00) --------------------------------------------------------
int __fastcall serdes_apb_write(int a1, int a2, char a3, unsigned __int16 a4, int a5)
{
  sub_789C4(a1, a3, 144, a5);
  sub_789C4(a1, a3, 145, a4 | 0x80000000);
  return 0;
}

//----- (0007BD40) --------------------------------------------------------
int __fastcall serdes_apb_write_1_chip(int a1, char a2, char a3, unsigned __int16 a4, int a5)
{
  sub_78960(a1, a2, a3, 144, a5);
  sub_78960(a1, a2, a3, 145, a4 | 0x80000000);
  return 0;
}

//----- (0007BD88) --------------------------------------------------------
int __fastcall serdes_apb_read(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4)
{
  _BYTE v8[8]; // [sp+20h] [bp+8h] BYREF
  _BYTE v9[16]; // [sp+1020h] [bp+1008h] BYREF
  int v10; // [sp+1030h] [bp+1018h]
  unsigned __int8 *v11; // [sp+1034h] [bp+101Ch]
  int j; // [sp+1038h] [bp+1020h]
  int i; // [sp+103Ch] [bp+1024h]
  unsigned __int8 v14; // [sp+1043h] [bp+102Bh]
  int v15; // [sp+1044h] [bp+102Ch]

  sub_789C4(a1, a3, 145, a4);
  v11 = (unsigned __int8 *)malloc(0x600u);
  v15 = 1;
  if ( a3 == 255 )
    v15 = sub_7936C(v9);
  v14 = 0;
  for ( i = 0; i < v15; ++i )
  {
    if ( a3 == 255 )
      v14 = v9[i];
    else
      v14 = a3;
    v10 = sub_78A20(a1, v14, 145, v11);
    for ( j = 0; j < v10; ++j )
    {
      if ( v10 && (*(_DWORD *)&v11[12 * j] & 0x20) != 0 )
      {
        V_LOCK();
        logfmt_raw(
          v8,
          0x1000u,
          0,
          "[PHY READ] channel %1x chip %02x core %02x apb_addr %04x apb_adata %08x, pslerr is 1",
          HIBYTE(a4) >> 4,
          v11[12 * j + 4],
          v11[12 * j + 8],
          a4,
          *(_DWORD *)&v11[12 * j]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "serdes_apb_read",
          15,
          847,
          100,
          v8);
      }
    }
    v10 = sub_78A20(a1, v14, 146, v11);
  }
  free(v11);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007C05C) --------------------------------------------------------
int __fastcall serdes_apb_read_back(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4, int a5)
{
  _BYTE v9[24]; // [sp+20h] [bp+8h] BYREF
  int v10; // [sp+1020h] [bp+1008h]
  unsigned __int8 *v11; // [sp+1024h] [bp+100Ch]
  int k; // [sp+1028h] [bp+1010h]
  int j; // [sp+102Ch] [bp+1014h]
  unsigned __int8 i; // [sp+1032h] [bp+101Ah]
  unsigned __int8 v15; // [sp+1033h] [bp+101Bh]
  int v16; // [sp+1034h] [bp+101Ch]

  sub_789C4(a1, a3, 145, a4);
  v11 = (unsigned __int8 *)malloc(0x600u);
  v16 = 0;
  v15 = 16;
  if ( a3 != 255 )
    v15 = 1;
  for ( i = 0; i < (unsigned int)v15; ++i )
  {
    if ( a3 != 255 )
      i = a3;
    v10 = sub_78A20(a1, i, 145, v11);
    for ( j = 0; j < v10; ++j )
    {
      if ( (*(_DWORD *)&v11[12 * j] & 0x20) != 0 )
      {
        V_LOCK();
        logfmt_raw(
          v9,
          0x1000u,
          0,
          "[PHY READ] channel %1x chip %02x core %02x apb_addr %04x apb_adata %08x, pslerr is 1",
          HIBYTE(a4) >> 4,
          v11[12 * j + 4],
          v11[12 * j + 8],
          a4,
          *(_DWORD *)&v11[12 * j]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "serdes_apb_read_back",
          20,
          881,
          20,
          v9);
      }
    }
    v10 = sub_78A20(a1, i, 146, v11);
    for ( k = 0; k < v10; ++k )
    {
      *(_BYTE *)(a5 + 8 * v16) = v11[12 * k + 4];
      *(_BYTE *)(a5 + 8 * v16 + 1) = v11[12 * k + 8];
      *(_DWORD *)(a5 + 8 * v16++ + 4) = HIBYTE(*(_DWORD *)&v11[12 * k])
                                      | (*(_DWORD *)&v11[12 * k] << 24)
                                      | ((unsigned __int8)BYTE1(*(_DWORD *)&v11[12 * k]) << 16)
                                      | (unsigned __int16)(HIWORD(*(_DWORD *)&v11[12 * k]) << 8);
    }
  }
  free(v11);
  return v16;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007C490) --------------------------------------------------------
int __fastcall serdes_apb_read_back_1_chip(int a1, char a2, unsigned __int8 a3, unsigned __int16 a4, int a5)
{
  _BYTE v10[24]; // [sp+20h] [bp+8h] BYREF
  int v11; // [sp+1020h] [bp+1008h]
  unsigned __int8 *v12; // [sp+1024h] [bp+100Ch]
  int k; // [sp+1028h] [bp+1010h]
  int j; // [sp+102Ch] [bp+1014h]
  unsigned __int8 i; // [sp+1032h] [bp+101Ah]
  unsigned __int8 v16; // [sp+1033h] [bp+101Bh]
  int v17; // [sp+1034h] [bp+101Ch]

  sub_789C4(a1, a3, 145, a4);
  v12 = (unsigned __int8 *)malloc(0x600u);
  v17 = 0;
  v16 = 16;
  if ( a3 != 255 )
    v16 = 1;
  for ( i = 0; i < (unsigned int)v16; ++i )
  {
    if ( a3 != 255 )
      i = a3;
    v11 = sub_78DA0(a1, a2, i, 145, v12);
    for ( j = 0; j < v11; ++j )
    {
      if ( (*(_DWORD *)&v12[12 * j] & 0x20) != 0 )
      {
        V_LOCK();
        logfmt_raw(
          v10,
          0x1000u,
          0,
          "[PHY READ] channel %1x chip %02x core %02x apb_addr %04x apb_adata %08x, pslerr is 1",
          HIBYTE(a4) >> 4,
          v12[12 * j + 4],
          v12[12 * j + 8],
          a4,
          *(_DWORD *)&v12[12 * j]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "serdes_apb_read_back_1_chip",
          27,
          924,
          20,
          v10);
      }
    }
    v11 = sub_78DA0(a1, a2, i, 146, v12);
    for ( k = 0; k < v11; ++k )
    {
      *(_BYTE *)(a5 + 8 * v17) = v12[12 * k + 4];
      *(_BYTE *)(a5 + 8 * v17 + 1) = v12[12 * k + 8];
      *(_DWORD *)(a5 + 8 * v17++ + 4) = HIBYTE(*(_DWORD *)&v12[12 * k])
                                      | (*(_DWORD *)&v12[12 * k] << 24)
                                      | ((unsigned __int8)BYTE1(*(_DWORD *)&v12[12 * k]) << 16)
                                      | (unsigned __int16)(HIWORD(*(_DWORD *)&v12[12 * k]) << 8);
    }
  }
  free(v12);
  return v17;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007C8D8) --------------------------------------------------------
int __fastcall phy_reg_read(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int16 i; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "phy_reg_read");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "phy_reg_read",
    12,
    954,
    60,
    &v9);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 3);
    serdes_apb_read(a1, a2, a3, (i << 12) | 8);
  }
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x67);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
  }
  serdes_apb_read(a1, a2, a3, 0x8051u);
  serdes_apb_read(a1, a2, a3, 0x800Du);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x43);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xB0);
  }
  serdes_apb_read(a1, a2, a3, 0x8030u);
  serdes_apb_read(a1, a2, a3, 0x803Bu);
  serdes_apb_read(a1, a2, a3, 0x8044u);
  serdes_apb_read(a1, a2, a3, 0x8060u);
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xF);
  }
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x16);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAB);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x89);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x95);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x85);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x13);
  }
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x8009u);
  serdes_apb_read(a1, a2, a3, 0xA002u);
  serdes_apb_read(a1, a2, a3, 0xA026u);
  for ( i = 0; i < (unsigned int)a4; ++i )
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xD);
  serdes_apb_read(a1, a2, a3, 0x801Bu);
  serdes_apb_read(a1, a2, a3, 0x801Cu);
  serdes_apb_read(a1, a2, a3, 0x803Cu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x19);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x22);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x74);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xB6);
  }
  serdes_apb_read(a1, a2, a3, 0x8002u);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 8);
    serdes_apb_read(a1, a2, a3, (i << 12) | 8);
    serdes_apb_read(a1, a2, a3, (i << 12) | 3);
  }
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
  }
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -65521);
    serdes_apb_write(a1, a2, a3, (i << 12) | 2, 0x8000);
  }
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1D);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x45);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x71);
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x99);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA5);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6F);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0007F7F0) --------------------------------------------------------
int __fastcall check_phy_reg_0917(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int16 i; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "check_phy_reg_0917", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_phy_reg_0917",
    18,
    1241,
    60,
    &v9);
  for ( i = 0; i < (unsigned int)a4; ++i )
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6E);
  serdes_apb_read(a1, a2, a3, 0xB03Fu);
  serdes_apb_read(a1, a2, a3, 0xC03Fu);
  serdes_apb_read(a1, a2, a3, 0xB03Eu);
  serdes_apb_read(a1, a2, a3, 0xC03Eu);
  serdes_apb_read(a1, a2, a3, 0xB03Fu);
  serdes_apb_read(a1, a2, a3, 0xC03Fu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6E);
  }
  serdes_apb_read(a1, a2, a3, 0xB002u);
  serdes_apb_read(a1, a2, a3, 0xB002u);
  serdes_apb_read(a1, a2, a3, 0xB003u);
  serdes_apb_read(a1, a2, a3, 0xC003u);
  serdes_apb_read(a1, a2, a3, 0xB005u);
  serdes_apb_read(a1, a2, a3, 0xC005u);
  serdes_apb_read(a1, a2, a3, 0xB006u);
  serdes_apb_read(a1, a2, a3, 0xC006u);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x30);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x19);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1D);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
  }
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x8009u);
  for ( i = 0; i < (unsigned int)a4; ++i )
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x20);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xB6);
  }
  serdes_apb_read(a1, a2, a3, 0x805Du);
  serdes_apb_read(a1, a2, a3, 0x805Du);
  serdes_apb_read(a1, a2, a3, 0x805Du);
  serdes_apb_read(a1, a2, a3, 0x805Du);
  serdes_apb_read(a1, a2, a3, 0x805Eu);
  serdes_apb_read(a1, a2, a3, 0x805Eu);
  serdes_apb_read(a1, a2, a3, 0x805Eu);
  serdes_apb_read(a1, a2, a3, 0x805Eu);
  serdes_apb_read(a1, a2, a3, 0x805Eu);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x8041u);
  serdes_apb_read(a1, a2, a3, 0x8002u);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 8);
    serdes_apb_read(a1, a2, a3, (i << 12) | 3);
  }
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  serdes_apb_read(a1, a2, a3, 0x8002u);
  serdes_apb_read(a1, a2, a3, 0x8048u);
  serdes_apb_read(a1, a2, a3, 0x804Cu);
  serdes_apb_read(a1, a2, a3, 0x800Cu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x8B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x69);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x48);
  }
  serdes_apb_read(a1, a2, a3, 0x8002u);
  serdes_apb_read(a1, a2, a3, 0x803Cu);
  serdes_apb_read(a1, a2, a3, 0x801Bu);
  serdes_apb_read(a1, a2, a3, 0x801Cu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x19);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x22);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x74);
  }
  serdes_apb_read(a1, a2, a3, 0x8014u);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x50);
    serdes_apb_read(a1, a2, a3, (i << 12) | 5);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x50);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAF);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9D);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9D);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x97);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x97);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
  }
  serdes_apb_read(a1, a2, a3, 0xB03Bu);
  serdes_apb_read(a1, a2, a3, 0xC03Bu);
  serdes_apb_read(a1, a2, a3, 0xB03Cu);
  serdes_apb_read(a1, a2, a3, 0xC03Cu);
  serdes_apb_read(a1, a2, a3, 0xB03Cu);
  serdes_apb_read(a1, a2, a3, 0xC03Cu);
  serdes_apb_read(a1, a2, a3, 0xB03Cu);
  serdes_apb_read(a1, a2, a3, 0xC03Cu);
  serdes_apb_read(a1, a2, a3, 0xB03Du);
  serdes_apb_read(a1, a2, a3, 0xC03Du);
  serdes_apb_read(a1, a2, a3, 0xB03Du);
  serdes_apb_read(a1, a2, a3, 0xC03Du);
  serdes_apb_read(a1, a2, a3, 0xB03Du);
  serdes_apb_read(a1, a2, a3, 0xC03Du);
  serdes_apb_read(a1, a2, a3, 0xB01Cu);
  serdes_apb_read(a1, a2, a3, 0xC01Cu);
  serdes_apb_read(a1, a2, a3, 0xB01Cu);
  serdes_apb_read(a1, a2, a3, 0xC01Cu);
  serdes_apb_read(a1, a2, a3, 0xB01Du);
  serdes_apb_read(a1, a2, a3, 0xC01Du);
  serdes_apb_read(a1, a2, a3, 0xB01Du);
  serdes_apb_read(a1, a2, a3, 0xC01Du);
  serdes_apb_read(a1, a2, a3, 0xB01Du);
  serdes_apb_read(a1, a2, a3, 0xC01Du);
  serdes_apb_read(a1, a2, a3, 0xB01Du);
  serdes_apb_read(a1, a2, a3, 0xC01Du);
  serdes_apb_read(a1, a2, a3, 0xB01Eu);
  serdes_apb_read(a1, a2, a3, 0xC01Eu);
  serdes_apb_read(a1, a2, a3, 0xB01Eu);
  serdes_apb_read(a1, a2, a3, 0xC01Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x13);
  }
  serdes_apb_read(a1, a2, a3, 0xA005u);
  serdes_apb_read(a1, a2, a3, 0xA007u);
  serdes_apb_read(a1, a2, a3, 0xB025u);
  serdes_apb_read(a1, a2, a3, 0xC025u);
  serdes_apb_read(a1, a2, a3, 0xB025u);
  serdes_apb_read(a1, a2, a3, 0xC025u);
  serdes_apb_read(a1, a2, a3, 0xB028u);
  serdes_apb_read(a1, a2, a3, 0xC028u);
  serdes_apb_read(a1, a2, a3, 0xB029u);
  serdes_apb_read(a1, a2, a3, 0xC029u);
  serdes_apb_read(a1, a2, a3, 0xB029u);
  serdes_apb_read(a1, a2, a3, 0xC029u);
  serdes_apb_read(a1, a2, a3, 0xB029u);
  serdes_apb_read(a1, a2, a3, 0xC029u);
  serdes_apb_read(a1, a2, a3, 0xB02Du);
  serdes_apb_read(a1, a2, a3, 0xC02Du);
  serdes_apb_read(a1, a2, a3, 0xB02Du);
  serdes_apb_read(a1, a2, a3, 0xC02Du);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 8);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9D);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x50);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x53);
  }
  serdes_apb_read(a1, a2, a3, 0x803Du);
  serdes_apb_read(a1, a2, a3, 0x803Du);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x48);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x48);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x48);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x48);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x48);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x67);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
  }
  serdes_apb_read(a1, a2, a3, 0x8051u);
  serdes_apb_read(a1, a2, a3, 0x800Du);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x43);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xB0);
  }
  serdes_apb_read(a1, a2, a3, 0x8030u);
  serdes_apb_read(a1, a2, a3, 0x803Bu);
  serdes_apb_read(a1, a2, a3, 0x8044u);
  serdes_apb_read(a1, a2, a3, 0x8060u);
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xF);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00081EDC) --------------------------------------------------------
int __fastcall phy_reg_read_0922(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _WORD v9[2049]; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int16 i7; // [sp+101Eh] [bp+100Eh]
  unsigned __int16 i6; // [sp+1020h] [bp+1010h]
  unsigned __int16 i5; // [sp+1022h] [bp+1012h]
  unsigned __int16 i4; // [sp+1024h] [bp+1014h]
  unsigned __int16 i3; // [sp+1026h] [bp+1016h]
  unsigned __int16 i2; // [sp+1028h] [bp+1018h]
  unsigned __int16 i1; // [sp+102Ah] [bp+101Ah]
  unsigned __int16 nn; // [sp+102Ch] [bp+101Ch]
  unsigned __int16 mm; // [sp+102Eh] [bp+101Eh]
  unsigned __int16 kk; // [sp+1030h] [bp+1020h]
  unsigned __int16 jj; // [sp+1032h] [bp+1022h]
  unsigned __int16 ii; // [sp+1034h] [bp+1024h]
  unsigned __int16 n; // [sp+1036h] [bp+1026h]
  unsigned __int16 m; // [sp+1038h] [bp+1028h]
  unsigned __int16 k; // [sp+103Ah] [bp+102Ah]
  unsigned __int16 j; // [sp+103Ch] [bp+102Ch]
  unsigned __int16 i; // [sp+103Eh] [bp+102Eh]

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "phy_reg_read_0922", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "phy_reg_read_0922",
    17,
    1498,
    60,
    v9);
  v9[2048] = 0;
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x67);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
  }
  serdes_apb_read(a1, a2, a3, 0x8051u);
  serdes_apb_read(a1, a2, a3, 0x800Du);
  for ( j = 0; j < (unsigned int)a4; ++j )
  {
    serdes_apb_read(a1, a2, a3, (j << 12) | 0x43);
    serdes_apb_read(a1, a2, a3, (j << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (j << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (j << 12) | 0xB0);
  }
  serdes_apb_read(a1, a2, a3, 0x8030u);
  serdes_apb_read(a1, a2, a3, 0x803Bu);
  serdes_apb_read(a1, a2, a3, 0x8044u);
  serdes_apb_read(a1, a2, a3, 0x8060u);
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( k = 0; k < (unsigned int)a4; ++k )
  {
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (k << 12) | 0xF);
  }
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( m = 0; m < (unsigned int)a4; ++m )
  {
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x16);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAB);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x89);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x95);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA2);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x85);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x13);
  }
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x8009u);
  serdes_apb_read(a1, a2, a3, 0xA002u);
  serdes_apb_read(a1, a2, a3, 0xA026u);
  for ( n = 0; n < (unsigned int)a4; ++n )
    serdes_apb_read(a1, a2, a3, (n << 12) | 0xD);
  serdes_apb_read(a1, a2, a3, 0x801Bu);
  serdes_apb_read(a1, a2, a3, 0x801Cu);
  serdes_apb_read(a1, a2, a3, 0x803Cu);
  for ( ii = 0; ii < (unsigned int)a4; ++ii )
  {
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x19);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x22);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x74);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x7E);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0xB6);
  }
  serdes_apb_read(a1, a2, a3, 0x8002u);
  for ( jj = 0; jj < (unsigned int)a4; ++jj )
  {
    serdes_apb_read(a1, a2, a3, (jj << 12) | 2);
    serdes_apb_read(a1, a2, a3, (jj << 12) | 8);
    serdes_apb_read(a1, a2, a3, (jj << 12) | 8);
    serdes_apb_read(a1, a2, a3, (jj << 12) | 3);
  }
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( kk = 0; kk < (unsigned int)a4; ++kk )
  {
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x1D);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x1E);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x45);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x71);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 2);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x99);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x7F);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x13);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x14);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x15);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x16);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x17);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x17);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA5);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA5);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x90);
  }
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0);
  for ( mm = 0; mm < (unsigned int)a4; ++mm )
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x6A);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0);
  for ( nn = 0; nn < (unsigned int)a4; ++nn )
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x6A);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0);
  for ( i1 = 0; i1 < (unsigned int)a4; ++i1 )
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x6A);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 0);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 128);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 0);
  for ( i2 = 0; i2 < (unsigned int)a4; ++i2 )
    serdes_apb_read(a1, a2, a3, (i2 << 12) | 0x98);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 0);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 128);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 0);
  for ( i3 = 0; i3 < (unsigned int)a4; ++i3 )
    serdes_apb_read(a1, a2, a3, (i3 << 12) | 0x98);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 0);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 128);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 0);
  for ( i4 = 0; i4 < (unsigned int)a4; ++i4 )
    serdes_apb_read(a1, a2, a3, (i4 << 12) | 0x98);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_read(a1, a2, a3, 0x8057u);
  serdes_apb_read(a1, a2, a3, 0x8058u);
  serdes_apb_read(a1, a2, a3, 0x8058u);
  serdes_apb_read(a1, a2, a3, 0x8048u);
  serdes_apb_read(a1, a2, a3, 0x804Cu);
  for ( i5 = 0; i5 < (unsigned int)a4; ++i5 )
  {
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x9A);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x65);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x9A);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x96);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x8B);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x53);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x73);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x84);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0xE);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0xE);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x85);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x86);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0xF);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x91);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x91);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x60);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x60);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x41);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x7B);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x7B);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x89);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x94);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x95);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0xA4);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x6E);
    serdes_apb_read(a1, a2, a3, (i5 << 12) | 0x6E);
  }
  serdes_apb_read(a1, a2, a3, 0x804Au);
  serdes_apb_read(a1, a2, a3, 0x804Fu);
  serdes_apb_read(a1, a2, a3, 0x803Du);
  serdes_apb_read(a1, a2, a3, 0x8041u);
  serdes_apb_read(a1, a2, a3, 0x8002u);
  serdes_apb_read(a1, a2, a3, 0x8014u);
  for ( i6 = 0; i6 < (unsigned int)a4; ++i6 )
  {
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x69);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x48);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 6);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x2C);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i6 << 12) | 0x2C);
  }
  serdes_apb_read(a1, a2, a3, 0x801Du);
  serdes_apb_read(a1, a2, a3, 0x8023u);
  serdes_apb_read(a1, a2, a3, 0x8024u);
  serdes_apb_read(a1, a2, a3, 0x8046u);
  serdes_apb_read(a1, a2, a3, 0x8061u);
  for ( i7 = 0; i7 < (unsigned int)a4; ++i7 )
  {
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 6);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x5B);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x5B);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x57);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x58);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x5D);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x5D);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x5D);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x5E);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x34);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x60);
    serdes_apb_read(a1, a2, a3, (i7 << 12) | 0x61);
  }
  serdes_apb_write(a1, a2, a3, 0xF001u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000867FC) --------------------------------------------------------
int __fastcall phy_reg_read_0927_old_28G(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[24]; // [sp+18h] [bp+8h] BYREF
  unsigned __int16 i1; // [sp+101Ah] [bp+100Ah]
  unsigned __int16 nn; // [sp+101Ch] [bp+100Ch]
  unsigned __int16 mm; // [sp+101Eh] [bp+100Eh]
  unsigned __int16 kk; // [sp+1020h] [bp+1010h]
  unsigned __int16 jj; // [sp+1022h] [bp+1012h]
  unsigned __int16 ii; // [sp+1024h] [bp+1014h]
  unsigned __int16 n; // [sp+1026h] [bp+1016h]
  unsigned __int16 m; // [sp+1028h] [bp+1018h]
  unsigned __int16 k; // [sp+102Ah] [bp+101Ah]
  unsigned __int16 j; // [sp+102Ch] [bp+101Ch]
  unsigned __int16 i; // [sp+102Eh] [bp+101Eh]

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "phy_reg_read_0927_old_28G", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "phy_reg_read_0927_old_28G",
    25,
    1938,
    60,
    v9);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x67);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
  }
  serdes_apb_read(a1, a2, a3, 0x8051u);
  serdes_apb_read(a1, a2, a3, 0x800Du);
  for ( j = 0; j < (unsigned int)a4; ++j )
  {
    serdes_apb_read(a1, a2, a3, (j << 12) | 0x43);
    serdes_apb_read(a1, a2, a3, (j << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (j << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (j << 12) | 0xB0);
  }
  serdes_apb_read(a1, a2, a3, 0x8030u);
  serdes_apb_read(a1, a2, a3, 0x803Bu);
  serdes_apb_read(a1, a2, a3, 0x8044u);
  serdes_apb_read(a1, a2, a3, 0x8060u);
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( k = 0; k < (unsigned int)a4; ++k )
  {
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (k << 12) | 0xF);
  }
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( m = 0; m < (unsigned int)a4; ++m )
  {
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x16);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xAB);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x89);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x95);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0xA2);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x85);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (m << 12) | 0x13);
  }
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x8009u);
  serdes_apb_read(a1, a2, a3, 0xA002u);
  serdes_apb_read(a1, a2, a3, 0xA026u);
  for ( n = 0; n < (unsigned int)a4; ++n )
    serdes_apb_read(a1, a2, a3, (n << 12) | 0xD);
  serdes_apb_read(a1, a2, a3, 0x801Bu);
  serdes_apb_read(a1, a2, a3, 0x801Cu);
  serdes_apb_read(a1, a2, a3, 0x803Cu);
  for ( ii = 0; ii < (unsigned int)a4; ++ii )
  {
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x19);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x22);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x74);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0x7E);
    serdes_apb_read(a1, a2, a3, (ii << 12) | 0xB6);
  }
  serdes_apb_read(a1, a2, a3, 0x8002u);
  for ( jj = 0; jj < (unsigned int)a4; ++jj )
  {
    serdes_apb_read(a1, a2, a3, (jj << 12) | 2);
    serdes_apb_read(a1, a2, a3, (jj << 12) | 8);
    serdes_apb_read(a1, a2, a3, (jj << 12) | 8);
    serdes_apb_read(a1, a2, a3, (jj << 12) | 3);
  }
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( kk = 0; kk < (unsigned int)a4; ++kk )
  {
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x1D);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x1E);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x45);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x71);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 2);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x99);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x7F);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x13);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x14);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x15);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x16);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x17);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x17);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA5);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA5);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x90);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x98);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x98);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (kk << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (kk << 12) | 0x98);
  }
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_read(a1, a2, a3, 0x8057u);
  serdes_apb_read(a1, a2, a3, 0x8058u);
  serdes_apb_read(a1, a2, a3, 0x8058u);
  serdes_apb_read(a1, a2, a3, 0x8048u);
  serdes_apb_read(a1, a2, a3, 0x804Cu);
  for ( mm = 0; mm < (unsigned int)a4; ++mm )
  {
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x9A);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x65);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x9A);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x96);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x8B);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x53);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x73);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x84);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0xE);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0xE);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x85);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x86);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0xF);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x91);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 2);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x91);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x60);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x60);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x41);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x7B);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x7B);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x89);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x94);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x95);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0xA4);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x6E);
    serdes_apb_read(a1, a2, a3, (mm << 12) | 0x6E);
  }
  serdes_apb_read(a1, a2, a3, 0x804Au);
  serdes_apb_read(a1, a2, a3, 0x804Fu);
  serdes_apb_read(a1, a2, a3, 0x803Du);
  serdes_apb_read(a1, a2, a3, 0x8041u);
  serdes_apb_read(a1, a2, a3, 0x8002u);
  serdes_apb_read(a1, a2, a3, 0x8014u);
  for ( nn = 0; nn < (unsigned int)a4; ++nn )
  {
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x69);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x48);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 2);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 6);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x2C);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (nn << 12) | 0x2C);
  }
  serdes_apb_read(a1, a2, a3, 0x801Du);
  serdes_apb_read(a1, a2, a3, 0x8023u);
  serdes_apb_read(a1, a2, a3, 0x8024u);
  serdes_apb_read(a1, a2, a3, 0x8046u);
  serdes_apb_read(a1, a2, a3, 0x8061u);
  for ( i1 = 0; i1 < (unsigned int)a4; ++i1 )
  {
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x57);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x58);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x5D);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x5D);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x5D);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x5E);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x5B);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x5B);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (i1 << 12) | 0x61);
  }
  serdes_apb_write(a1, a2, a3, 0xF001u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0008B2AC) --------------------------------------------------------
int __fastcall phy_reg_read_0928_28G(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 m; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 k; // [sp+101Dh] [bp+100Dh]
  unsigned __int8 j; // [sp+101Eh] [bp+100Eh]
  unsigned __int8 i; // [sp+101Fh] [bp+100Fh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "phy_reg_read_0928_28G", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "phy_reg_read_0928_28G",
    21,
    2369,
    60,
    &v9);
  serdes_apb_read(a1, a2, a3, 0xF013u);
  serdes_apb_read(a1, a2, a3, 0xF014u);
  serdes_apb_read(a1, a2, a3, 0xF015u);
  serdes_apb_read(a1, a2, a3, 0xF016u);
  serdes_apb_read(a1, a2, a3, 0xF017u);
  serdes_apb_read(a1, a2, a3, 0xF016u);
  serdes_apb_read(a1, a2, a3, 0xF017u);
  serdes_apb_read(a1, a2, a3, 0xF017u);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0xF001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xF03Au, 0);
  for ( i = 0; i < (unsigned int)a4; ++i )
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 0);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 128);
  serdes_apb_write(a1, a2, a3, 0xF001u, -129);
  serdes_apb_write(a1, a2, a3, 0xF05Fu, 0);
  for ( j = 0; j < (unsigned int)a4; ++j )
    serdes_apb_read(a1, a2, a3, (j << 12) | 0x98);
  serdes_apb_write(a1, a2, a3, 0x8001u, -17);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -17);
  serdes_apb_write(a1, a2, a3, 0x8026u, 16);
  serdes_apb_write(a1, a2, a3, 0x8001u, -17);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0);
  serdes_apb_read(a1, a2, a3, 0x8024u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2097153);
  serdes_apb_write(a1, a2, a3, 0x8023u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2097153);
  serdes_apb_write(a1, a2, a3, 0x8023u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2097153);
  serdes_apb_write(a1, a2, a3, 0x8023u, 0);
  serdes_apb_read(a1, a2, a3, 0x8026u);
  for ( k = 0; k < (unsigned int)a4; ++k )
  {
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (k << 12) | 0x1A);
  }
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  for ( m = 0; m < (unsigned int)a4; ++m )
    serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0xF001u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0008BC5C) --------------------------------------------------------
int __fastcall phy_reg_read_0826(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int16 i; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "phy_reg_read_0826", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "phy_reg_read_0826",
    17,
    2439,
    60,
    &v9);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x67);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
  }
  serdes_apb_read(a1, a2, a3, 0x8051u);
  serdes_apb_read(a1, a2, a3, 0x800Du);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x43);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xB0);
  }
  serdes_apb_read(a1, a2, a3, 0x8030u);
  serdes_apb_read(a1, a2, a3, 0x803Bu);
  serdes_apb_read(a1, a2, a3, 0x8044u);
  serdes_apb_read(a1, a2, a3, 0x8060u);
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xF);
  }
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x16);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAB);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x89);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x95);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x85);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x13);
  }
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x8009u);
  serdes_apb_read(a1, a2, a3, 0xA002u);
  serdes_apb_read(a1, a2, a3, 0xA026u);
  for ( i = 0; i < (unsigned int)a4; ++i )
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xD);
  serdes_apb_read(a1, a2, a3, 0x801Bu);
  serdes_apb_read(a1, a2, a3, 0x801Cu);
  serdes_apb_read(a1, a2, a3, 0x803Cu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x19);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x22);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x74);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xB6);
  }
  serdes_apb_read(a1, a2, a3, 0x8002u);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 8);
    serdes_apb_read(a1, a2, a3, (i << 12) | 8);
    serdes_apb_read(a1, a2, a3, (i << 12) | 3);
  }
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1D);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x45);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x71);
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x99);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x13);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x14);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x15);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x16);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x17);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x17);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA5);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA5);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x90);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
  }
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_read(a1, a2, a3, 0x8057u);
  serdes_apb_read(a1, a2, a3, 0x8058u);
  serdes_apb_read(a1, a2, a3, 0x8058u);
  serdes_apb_read(a1, a2, a3, 0x8048u);
  serdes_apb_read(a1, a2, a3, 0x804Cu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x65);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x8B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x53);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x73);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x84);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x85);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x86);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xF);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x91);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x91);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x60);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x60);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x41);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x89);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x94);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x95);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA4);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6E);
  }
  serdes_apb_read(a1, a2, a3, 0x804Au);
  serdes_apb_read(a1, a2, a3, 0x804Fu);
  serdes_apb_read(a1, a2, a3, 0x803Du);
  serdes_apb_read(a1, a2, a3, 0x8041u);
  serdes_apb_read(a1, a2, a3, 0x8002u);
  serdes_apb_read(a1, a2, a3, 0x8014u);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x69);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x48);
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x69);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x48);
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x2C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 3);
  }
  serdes_apb_read(a1, a2, a3, 0x801Du);
  serdes_apb_read(a1, a2, a3, 0x8023u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -17);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -17);
  serdes_apb_write(a1, a2, a3, 0x8026u, 16);
  serdes_apb_write(a1, a2, a3, 0x8001u, -17);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0);
  serdes_apb_read(a1, a2, a3, 0x8024u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2097153);
  serdes_apb_write(a1, a2, a3, 0x8023u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2097153);
  serdes_apb_write(a1, a2, a3, 0x8023u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2097153);
  serdes_apb_write(a1, a2, a3, 0x8023u, 0);
  serdes_apb_read(a1, a2, a3, 0x8026u);
  serdes_apb_read(a1, a2, a3, 0x8046u);
  serdes_apb_read(a1, a2, a3, 0x8061u);
  for ( i = 0; i < (unsigned int)a4; ++i )
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00090AA8) --------------------------------------------------------
int __fastcall phy_reg_read_0805(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int16 i; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "phy_reg_read_0805", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "phy_reg_read_0805",
    17,
    2934,
    60,
    &v9);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x67);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
  }
  serdes_apb_read(a1, a2, a3, 0x8051u);
  serdes_apb_read(a1, a2, a3, 0x800Du);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x43);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xB0);
  }
  serdes_apb_read(a1, a2, a3, 0x8030u);
  serdes_apb_read(a1, a2, a3, 0x803Bu);
  serdes_apb_read(a1, a2, a3, 0x8044u);
  serdes_apb_read(a1, a2, a3, 0x8060u);
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x49);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xF);
  }
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x16);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA9);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAA);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xAB);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x75);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x76);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x78);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x79);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x28);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x29);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x26);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x89);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x95);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x85);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x13);
  }
  serdes_apb_read(a1, a2, a3, 0x8008u);
  serdes_apb_read(a1, a2, a3, 0x8009u);
  serdes_apb_read(a1, a2, a3, 0xA002u);
  serdes_apb_read(a1, a2, a3, 0xA026u);
  for ( i = 0; i < (unsigned int)a4; ++i )
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xD);
  serdes_apb_read(a1, a2, a3, 0x801Bu);
  serdes_apb_read(a1, a2, a3, 0x801Cu);
  serdes_apb_read(a1, a2, a3, 0x803Cu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x19);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x22);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x74);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x12);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xB6);
  }
  serdes_apb_read(a1, a2, a3, 0x8002u);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 8);
    serdes_apb_read(a1, a2, a3, (i << 12) | 8);
    serdes_apb_read(a1, a2, a3, (i << 12) | 3);
  }
  serdes_apb_read(a1, a2, a3, 0x803Eu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1D);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x45);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x47);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x71);
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x99);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7F);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x13);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x14);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x15);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x16);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x17);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x17);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA5);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA5);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA7);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x90);
  }
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0x4000000);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -67108865);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x3A, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 128);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -129);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x5F, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x98);
  }
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_read(a1, a2, a3, 0x805Fu);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8043u, 0);
  serdes_apb_read(a1, a2, a3, 0x8042u);
  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s change list 20210807", "phy_reg_read_0805");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "phy_reg_read_0805",
    17,
    3247,
    60,
    &v9);
  serdes_apb_read(a1, a2, a3, 0x8057u);
  serdes_apb_read(a1, a2, a3, 0x8058u);
  serdes_apb_read(a1, a2, a3, 0x8058u);
  serdes_apb_read(a1, a2, a3, 0x8048u);
  serdes_apb_read(a1, a2, a3, 0x804Cu);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x65);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x9A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x27);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x96);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA6);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xBE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x8B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x8C);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x46);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4A);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x56);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x4B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x53);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x73);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x84);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xE);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x85);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x86);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x11);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xF);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x91);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 2);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x91);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x77);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x25);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x60);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x60);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x24);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x41);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x7B);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x88);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x89);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x94);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x95);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA1);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0xA4);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6E);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x6E);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, 0);
  }
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00094CA4) --------------------------------------------------------
int __fastcall serdes_initial_seq_1_by_vendor(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int16 i; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s ...", "serdes_initial_seq_1_by_vendor");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_initial_seq_1_by_vendor",
    30,
    3328,
    60,
    &v9);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 252182532);
  serdes_apb_write(a1, a2, a3, 0xB002u, 839027724);
  serdes_apb_write(a1, a2, a3, 0xB003u, -1073676160);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 252182532);
  serdes_apb_write(a1, a2, a3, 0xC002u, 839027724);
  serdes_apb_write(a1, a2, a3, 0xC003u, -1073676160);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x6E, 17694978);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x1D, 134283265);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x2A, 504234034);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x19, 267913217);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x1A, -1610579952);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x47, 338179136);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00094FEC) --------------------------------------------------------
int __fastcall serdes_initial_seq_2_by_vendor(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v8; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v9; // [sp+101Eh] [bp+100Eh]

  v9 = 0;
  if ( a4 == 8 )
    v9 = 15;
  V_LOCK();
  logfmt_raw(&v8, 0x1000u, 0, "%s ...", "serdes_initial_seq_2_by_vendor");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_initial_seq_2_by_vendor",
    30,
    3354,
    60,
    &v8);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x45, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -524289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -33);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x71, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 624);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 40894464);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 1879048192);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 112);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 28672);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 7340032);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 1879048192);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000957DC) --------------------------------------------------------
int __fastcall check_d54(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5)
{
  int v5; // r4
  int v6; // r5
  int v7; // r6
  unsigned int v8; // r0
  int v9; // r3
  _QWORD v15[2]; // [sp+20h] [bp+8h] BYREF
  _BYTE v16[16]; // [sp+60h] [bp+48h] BYREF
  _BYTE v17[16]; // [sp+1060h] [bp+1048h] BYREF
  int back; // [sp+1070h] [bp+1058h]
  int k; // [sp+1074h] [bp+105Ch]
  unsigned __int16 j; // [sp+107Ah] [bp+1062h]
  int i; // [sp+107Ch] [bp+1064h]
  unsigned __int8 v22; // [sp+1083h] [bp+106Bh]
  int v23; // [sp+1084h] [bp+106Ch]
  int v24; // [sp+1088h] [bp+1070h]
  int v25; // [sp+108Ch] [bp+1074h]

  V_LOCK();
  logfmt_raw(v16, 0x1000u, 0, "%s...", "check_d54");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_d54",
    9,
    3404,
    60,
    v16);
  v25 = 0;
  v24 = 0;
  v23 = 1;
  if ( a3 == 255 )
    v23 = sub_7936C(v17);
  v22 = 0;
  for ( i = 0; i < v23; ++i )
  {
    if ( a3 == 255 )
      v22 = v17[i];
    else
      v22 = a3;
    v25 = 0;
    while ( 1 )
    {
      v24 = 0;
      usleep((__useconds_t)&stru_1869C.st_value);
      for ( j = 0; j < (unsigned int)a4; ++j )
      {
        if ( v22 != 3 || j > 3u )
        {
          back = serdes_apb_read_back(a1, a2, v22, (j << 12) | 0x36, (int)v15);
          for ( k = 0; k < back; ++k )
          {
            if ( (!a5 || (HIDWORD(v15[k]) & a5) != a5) && (a5 || (v15[k] & 0x800000000LL) != 0) )
            {
              v24 /= 8;
              V_LOCK();
              v5 = j;
              v6 = LOBYTE(v15[k]);
              v7 = BYTE1(v15[k]);
              v8 = sub_79338(HIDWORD(v15[k]));
              logfmt_raw(
                v16,
                0x1000u,
                0,
                "channel %1x, chip_id %02x core_id %02x %08x d'54 bit[3] error status, exp:%02x",
                v5,
                v6,
                v7,
                v8,
                a5);
              V_UNLOCK();
              zlog(
                g_zc,
                "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
                83,
                "check_d54",
                9,
                3438,
                100,
                v16);
              break;
            }
            ++v24;
            V_LOCK();
            logfmt_raw(
              v16,
              0x1000u,
              0,
              "channel %1x, chip_id %02x core_id %02x d'54 bit[3] change to %d",
              j,
              LOBYTE(v15[k]),
              BYTE1(v15[k]),
              a5);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
              83,
              "check_d54",
              9,
              3434,
              20,
              v16);
          }
          if ( 8 * (j + 1) > v24 )
            break;
        }
      }
      if ( 8 * a4 <= v24 )
        break;
      v9 = v25++;
      if ( v9 > 19 )
        goto LABEL_25;
    }
    V_LOCK();
    logfmt_raw(v16, 0x1000u, 0, "all lanes d'54 bit[3] change to %d", a5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_d54",
      9,
      3447,
      20,
      v16);
LABEL_25:
    ;
  }
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00095D18) --------------------------------------------------------
int __fastcall check_d54_one_lane(
        int a1,
        unsigned __int8 a2,
        unsigned __int8 a3,
        unsigned __int8 a4,
        unsigned __int8 a5)
{
  int v5; // r3
  unsigned __int8 v11; // [sp+20h] [bp+8h] BYREF
  unsigned __int8 v12; // [sp+21h] [bp+9h]
  int v13; // [sp+24h] [bp+Ch]
  _BYTE v14[8]; // [sp+60h] [bp+48h] BYREF
  int back_1_chip; // [sp+1060h] [bp+1048h]
  int v16; // [sp+1064h] [bp+104Ch]

  V_LOCK();
  logfmt_raw(
    v14,
    0x1000u,
    0,
    "%s chip_id %02x core_id %02x channel_id %1x exp %1x",
    "check_d54_one_lane",
    a2,
    a3,
    a4,
    a5);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_d54_one_lane",
    18,
    3459,
    60,
    v14);
  v16 = 0;
  while ( 1 )
  {
    usleep((__useconds_t)&stru_1869C.st_value);
    back_1_chip = serdes_apb_read_back_1_chip(a1, a2, a3, (a4 << 12) | 0x36, (int)&v11);
    if ( (!back_1_chip || !a5 || (unsigned __int8)(v13 & a5) != a5) && (a5 || (v13 & 8) != 0) )
      break;
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "channel %1x, chip_id %02x core_id %02x d'54 bit[3] change to %d", a4, v11, v12, a5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_d54_one_lane",
      18,
      3469,
      20,
      v14);
    v5 = v16++;
    if ( v5 > 19 )
      return 0;
  }
  V_LOCK();
  logfmt_raw(
    v14,
    0x1000u,
    0,
    "channel %1x, chip_id %02x core_id %02x %08x d'54 bit[3] error status, exp:%02x",
    a4,
    v11,
    v12,
    v13,
    a5);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_d54_one_lane",
    18,
    3472,
    100,
    v14);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00095FB4) --------------------------------------------------------
int __fastcall enable_rx_equalizer_tuning(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "enable_rx_equalizer_tuning");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "enable_rx_equalizer_tuning",
    26,
    3482,
    60,
    &v9);
  v10 = 0;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x37, 2048);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1073741825);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x40000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16777217);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x98, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16777217);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x98, 0x1000000);
  check_d54(a1, a2, a3, a4, 8u);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16777217);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x98, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  check_d54(a1, a2, a3, a4, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000964A0) --------------------------------------------------------
int __fastcall enable_rx_equalizer_tuning_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(
    v9,
    0x1000u,
    0,
    "%s chip_id %02x core_id %02x channel_id %02x",
    "enable_rx_equalizer_tuning_one_lane",
    a2,
    a3,
    a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "enable_rx_equalizer_tuning_one_lane",
    35,
    3553,
    60,
    v9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x2F, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x2F, 0x400000);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x2F, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x37, 2048);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -1073741825);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x7E, 0x40000000);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -16777217);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x98, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -16777217);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x98, 0x1000000);
  check_d54_one_lane(a1, a2, a3, a4, 8u);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -16777217);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x98, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0);
  check_d54_one_lane(a1, a2, a3, a4, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00096960) --------------------------------------------------------
int __fastcall clear_rxeqcal_ext(int a1, unsigned __int8 a2, int a3)
{
  int v7; // [sp+24h] [bp+14h] BYREF
  _BYTE v8[12]; // [sp+1024h] [bp+1014h] BYREF
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]
  int v10; // [sp+1038h] [bp+1028h]
  __int16 v11; // [sp+103Ch] [bp+102Ch]
  unsigned __int8 k; // [sp+103Fh] [bp+102Fh]
  int j; // [sp+1040h] [bp+1030h]
  unsigned __int8 i; // [sp+1047h] [bp+1037h]

  V_LOCK();
  logfmt_raw(&v7, 0x1000u, 0, "%s...", "clear_rxeqcal_ext");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "clear_rxeqcal_ext",
    17,
    3584,
    60,
    &v7);
  v11 = 0;
  v10 = sub_7936C(v8);
  for ( i = 0; i <= 7u; ++i )
  {
    for ( j = 0; j < v10; ++j )
    {
      v9 = v8[j];
      for ( k = 0; k < (unsigned int)a2; ++k )
      {
        if ( v9 != 3 || k > 3u )
        {
          if ( *(_BYTE *)(a3 + k + 8 * (v9 + 2 * i)) )
          {
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, -4194305);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 0x2F, 0x400000);
          }
        }
      }
    }
  }
  serdes_apb_write(a1, 0, 255, 0xF001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (00096BD4) --------------------------------------------------------
int __fastcall enable_rx_equalizer_tuning_ext(int a1, unsigned __int8 a2, int a3)
{
  int v7; // [sp+24h] [bp+14h] BYREF
  _BYTE v8[12]; // [sp+1024h] [bp+1014h] BYREF
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]
  int v10; // [sp+1038h] [bp+1028h]
  __int16 v11; // [sp+103Ch] [bp+102Ch]
  unsigned __int8 k; // [sp+103Fh] [bp+102Fh]
  int j; // [sp+1040h] [bp+1030h]
  unsigned __int8 i; // [sp+1047h] [bp+1037h]

  V_LOCK();
  logfmt_raw(&v7, 0x1000u, 0, "%s...", "enable_rx_equalizer_tuning_ext");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "enable_rx_equalizer_tuning_ext",
    30,
    3610,
    60,
    &v7);
  v11 = 0;
  v10 = sub_7936C(v8);
  for ( i = 0; i <= 7u; ++i )
  {
    for ( j = 0; j < v10; ++j )
    {
      v9 = v8[j];
      for ( k = 0; k < (unsigned int)a2; ++k )
      {
        if ( v9 != 3 || k > 3u )
        {
          if ( *(_BYTE *)(a3 + k + 8 * (v9 + 2 * i)) )
          {
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, -4194305);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 0x2F, 0);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, -4194305);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 0x2F, 0x400000);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, -4194305);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 0x2F, 0);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, -2049);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 0x37, 2048);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, -1073741825);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 0x7E, 0x40000000);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, -16777217);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 0x98, 0);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, -16777217);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 0x98, 0x1000000);
            check_d54_one_lane(a1, i, v9, k, 8u);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, -16777217);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 0x98, 0);
            serdes_apb_write_1_chip(a1, i, v9, (k << 12) | 1, 0);
            check_d54_one_lane(a1, i, v9, k, 0);
          }
        }
      }
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0009722C) --------------------------------------------------------
int __fastcall BM_debug_seq_16G_update_20210819_500M(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v8; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v9; // [sp+101Eh] [bp+100Eh]

  v9 = 0;
  if ( a4 == 8 )
    v9 = 15;
  V_LOCK();
  logfmt_raw(&v8, 0x1000u, 0, "%s ...", "BM_debug_seq_16G_update_20210819_500M");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "BM_debug_seq_16G_update_20210819_500M",
    37,
    3661,
    60,
    &v8);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0x20000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1E, 4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x45, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x46, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -524289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 0x80000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -33);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x71, 32);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x11, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -66060289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x13, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, 0xA001u, -9);
  serdes_apb_write(a1, a2, a3, 0xA002u, 8);
  serdes_apb_write(a1, a2, a3, 0xA001u, -4097);
  serdes_apb_write(a1, a2, a3, 0xA026u, 4096);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xD, 0x40000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x19, 1);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -201326593);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x22, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -805306369);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x74, 0x10000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 32);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 805306368);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x96, 0x2000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000989DC) --------------------------------------------------------
int __fastcall BM_debug_seq_update_20210805_500M(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v8; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v9; // [sp+101Eh] [bp+100Eh]

  v9 = 0;
  if ( a4 == 8 )
    v9 = 15;
  V_LOCK();
  logfmt_raw(&v8, 0x1000u, 0, "%s ...", "BM_debug_seq_update_20210805_500M");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "BM_debug_seq_update_20210805_500M",
    33,
    3800,
    60,
    &v8);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0x20000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1E, 4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x45, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x46, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -524289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 0x80000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -33);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x71, 32);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x11, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -66060289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x13, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, 0xA001u, -9);
  serdes_apb_write(a1, a2, a3, 0xA002u, 8);
  serdes_apb_write(a1, a2, a3, 0xA001u, -4097);
  serdes_apb_write(a1, a2, a3, 0xA026u, 4096);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xD, 0x40000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x19, 1);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -201326593);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x22, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -805306369);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x74, 0x10000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 96);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  V_LOCK();
  logfmt_raw(&v8, 0x1000u, 0, "change list 202100807");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "BM_debug_seq_update_20210805_500M",
    33,
    3934,
    60,
    &v8);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x96, 12288);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 100663296);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0009A278) --------------------------------------------------------
int __fastcall SOC_16G_20210819_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v8; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v9; // [sp+101Eh] [bp+100Eh]

  v9 = 0;
  if ( a4 == 8 )
    v9 = 15;
  V_LOCK();
  logfmt_raw(&v8, 0x1000u, 0, "%s ...", "SOC_16G_20210819_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_16G_20210819_update",
    23,
    3987,
    60,
    &v8);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0x20000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 32);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 0x10000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 3, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 805306368);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x96, 4096);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 2);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0009B4A0) --------------------------------------------------------
int __fastcall SOC_24G_20210817_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v8; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v9; // [sp+101Eh] [bp+100Eh]

  v9 = 0;
  if ( a4 == 8 )
    v9 = 15;
  V_LOCK();
  logfmt_raw(&v8, 0x1000u, 0, "%s ...", "SOC_24G_20210817_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_24G_20210817_update",
    23,
    4121,
    60,
    &v8);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0x20000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 64);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0x20000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 2);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 805306368);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x96, 0x2000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 0x2000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x5F, -268435456);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -256);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x60, 255);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0009C6F4) --------------------------------------------------------
int __fastcall SOC_24G_20210915_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "SOC_24G_20210915_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_24G_20210915_update",
    23,
    4240,
    60,
    &v9);
  v10 = 0;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2097153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 64);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 805306368);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 32);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 0x2000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -13);
  serdes_apb_write(a1, a2, a3, 0x8002u, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -28673);
  serdes_apb_write(a1, a2, a3, 0x8014u, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0009E354) --------------------------------------------------------
int __fastcall SOC_24G_20210916_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "SOC_24G_20210916_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_24G_20210916_update",
    23,
    4417,
    60,
    &v9);
  v10 = 0;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2097153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 64);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 805306368);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 0x2000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 0);
  serdes_apb_write_1_chip(a1, 1, 7, 0x70BEu, 0x2000);
  serdes_apb_write_1_chip(a1, 1, 5, 0x50BEu, 24576);
  serdes_apb_write_1_chip(a1, 1, 7, 0x10BEu, 24576);
  serdes_apb_write_1_chip(a1, 0, 7, 0x40BEu, 0x2000);
  serdes_apb_write_1_chip(a1, 0, 7, 0x60BEu, 0x2000);
  serdes_apb_write_1_chip(a1, 0, 7, 0x70BEu, 0x2000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -13);
  serdes_apb_write(a1, a2, a3, 0x8002u, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -201326593);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x22, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -805306369);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x74, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -28673);
  serdes_apb_write(a1, a2, a3, 0x8014u, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x27, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x27, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3585);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3585);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1793);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2C, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -241);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000A09AC) --------------------------------------------------------
int __fastcall SOC_24G_20210917_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "SOC_24G_20210917_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_24G_20210917_update",
    23,
    4667,
    60,
    &v9);
  v10 = 0;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2097153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 64);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 32);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 0x2000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -13);
  serdes_apb_write(a1, a2, a3, 0x8002u, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -201326593);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x22, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -805306369);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x74, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -28673);
  serdes_apb_write(a1, a2, a3, 0x8014u, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -241);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x50, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -524289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 5, 0x80000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -117440513);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA, 117440512);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x50, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1056964609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xAF, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -128);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9D, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -133169153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9D, 0x100000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -267386881);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9C, 0x200000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9C, 256);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9E, 0x10000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4081);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9F, 768);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -268369921);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 6422528);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x97, 200);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -268369921);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x97, 3145728);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x98, 100);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1056964609);
  serdes_apb_write(a1, a2, a3, 0xB03Bu, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1056964609);
  serdes_apb_write(a1, a2, a3, 0xC03Bu, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB03Cu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC03Cu, 4);
  serdes_apb_write(a1, a2, a3, 0xB001u, -16129);
  serdes_apb_write(a1, a2, a3, 0xB03Cu, 1024);
  serdes_apb_write(a1, a2, a3, 0xC001u, -16129);
  serdes_apb_write(a1, a2, a3, 0xC03Cu, 1024);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4128769);
  serdes_apb_write(a1, a2, a3, 0xB03Cu, 0x40000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4128769);
  serdes_apb_write(a1, a2, a3, 0xC03Cu, 0x40000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1056964609);
  serdes_apb_write(a1, a2, a3, 0xB03Cu, 603979776);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1056964609);
  serdes_apb_write(a1, a2, a3, 0xC03Cu, 603979776);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB03Du, 36);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC03Du, 36);
  serdes_apb_write(a1, a2, a3, 0xB001u, -16129);
  serdes_apb_write(a1, a2, a3, 0xB03Du, 9216);
  serdes_apb_write(a1, a2, a3, 0xC001u, -16129);
  serdes_apb_write(a1, a2, a3, 0xC03Du, 9216);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4128769);
  serdes_apb_write(a1, a2, a3, 0xB03Du, 2359296);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4128769);
  serdes_apb_write(a1, a2, a3, 0xC03Du, 2359296);
  serdes_apb_write(a1, a2, a3, 0xB001u, -393217);
  serdes_apb_write(a1, a2, a3, 0xB01Cu, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -393217);
  serdes_apb_write(a1, a2, a3, 0xC01Cu, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0xB01Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0xC01Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -7);
  serdes_apb_write(a1, a2, a3, 0xB01Du, 2);
  serdes_apb_write(a1, a2, a3, 0xC001u, -7);
  serdes_apb_write(a1, a2, a3, 0xC01Du, 2);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1537);
  serdes_apb_write(a1, a2, a3, 0xB01Du, 512);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1537);
  serdes_apb_write(a1, a2, a3, 0xC01Du, 512);
  serdes_apb_write(a1, a2, a3, 0xB001u, -393217);
  serdes_apb_write(a1, a2, a3, 0xB01Du, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -393217);
  serdes_apb_write(a1, a2, a3, 0xC01Du, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0xB01Du, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0xC01Du, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -7);
  serdes_apb_write(a1, a2, a3, 0xB01Eu, 2);
  serdes_apb_write(a1, a2, a3, 0xC001u, -7);
  serdes_apb_write(a1, a2, a3, 0xC01Eu, 2);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1537);
  serdes_apb_write(a1, a2, a3, 0xB01Eu, 512);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1537);
  serdes_apb_write(a1, a2, a3, 0xC01Eu, 512);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA, 2048);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 9, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x4000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x13, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -33);
  serdes_apb_write(a1, a2, a3, 0xA005u, 32);
  serdes_apb_write(a1, a2, a3, 0xA001u, -2);
  serdes_apb_write(a1, a2, a3, 0xA007u, 1);
  serdes_apb_write(a1, a2, a3, 0xB001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xB025u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xC025u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0xB025u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0xC025u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0xB028u, 0x8000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0xC028u, 0x8000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -17);
  serdes_apb_write(a1, a2, a3, 0xB029u, 16);
  serdes_apb_write(a1, a2, a3, 0xC001u, -17);
  serdes_apb_write(a1, a2, a3, 0xC029u, 16);
  serdes_apb_write(a1, a2, a3, 0xB001u, -65537);
  serdes_apb_write(a1, a2, a3, 0xB029u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -65537);
  serdes_apb_write(a1, a2, a3, 0xC029u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -131073);
  serdes_apb_write(a1, a2, a3, 0xB029u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -131073);
  serdes_apb_write(a1, a2, a3, 0xC029u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0xB02Du, 0x800000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0xC02Du, 0x800000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -268435457);
  serdes_apb_write(a1, a2, a3, 0xB02Du, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -268435457);
  serdes_apb_write(a1, a2, a3, 0xC02Du, 0x10000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1879048193);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6B, 805306368);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9D, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9E, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1073741825);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -786433);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x50, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6A, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -458753);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x53, 0x40000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2049);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x27, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x27, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3585);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3585);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1793);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2C, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000A54F8) --------------------------------------------------------
int __fastcall SOC_24G_seq1_20210922_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "SOC_24G_seq1_20210922_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_24G_seq1_20210922_update",
    28,
    5127,
    60,
    &v9);
  v10 = 0;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2097153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, -1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 64);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 32);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 0x2000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 0x4000);
  serdes_apb_write_1_chip(a1, 1, 7, (v10 << 12) | 0xBE, 24576);
  serdes_apb_write_1_chip(a1, 1, 6, (v10 << 12) | 0xBE, 20480);
  serdes_apb_write_1_chip(a1, 2, 5, (v10 << 12) | 0xBE, 20480);
  serdes_apb_write_1_chip(a1, 4, 7, (v10 << 12) | 0xBE, 24576);
  serdes_apb_write_1_chip(a1, 4, 3, (v10 << 12) | 0xBE, 20480);
  serdes_apb_write_1_chip(a1, 5, 7, (v10 << 12) | 0xBE, 24576);
  serdes_apb_write_1_chip(a1, 5, 15, (v10 << 12) | 0xBE, 20480);
  serdes_apb_write_1_chip(a1, 6, 7, (v10 << 12) | 0xBE, 24576);
  serdes_apb_write_1_chip(a1, 6, 15, (v10 << 12) | 0xBE, 20480);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -13);
  serdes_apb_write(a1, a2, a3, 0x8002u, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 100663296);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -201326593);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x22, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -805306369);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x74, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -28673);
  serdes_apb_write(a1, a2, a3, 0x8014u, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x27, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x27, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3585);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3585);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1793);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2C, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -241);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8193);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x32, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x34, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x35, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -134217729);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x36, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3145729);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 7, 0x200000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x65, -268435456);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x66, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x37, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 6);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1793);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 768);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -458753);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 393216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -117440513);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 0x2000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x39, 6);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x32, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x35, 2048);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000A8C6C) --------------------------------------------------------
int __fastcall SOC_24G_seq2_20210922_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "SOC_24G_seq2_20210922_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_24G_seq2_20210922_update",
    28,
    5481,
    60,
    &v9);
  v10 = 0;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2097153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, -1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 64);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 32);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 0x2000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -13);
  serdes_apb_write(a1, a2, a3, 0x8002u, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -201326593);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x22, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -805306369);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x74, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -28673);
  serdes_apb_write(a1, a2, a3, 0x8014u, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x50, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -524289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 5, 0x80000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -117440513);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA, 117440512);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x50, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1056964609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xAF, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -128);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9D, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -133169153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9D, 0x100000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -267386881);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9C, 0x200000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9C, 256);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9E, 0x10000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4081);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9F, 768);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -268369921);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 32636928);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x97, 1000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -268369921);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x97, 6422528);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x98, 200);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1056964609);
  serdes_apb_write(a1, a2, a3, 0xB03Bu, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1056964609);
  serdes_apb_write(a1, a2, a3, 0xC03Bu, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB03Cu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC03Cu, 4);
  serdes_apb_write(a1, a2, a3, 0xB001u, -16129);
  serdes_apb_write(a1, a2, a3, 0xB03Cu, 1024);
  serdes_apb_write(a1, a2, a3, 0xC001u, -16129);
  serdes_apb_write(a1, a2, a3, 0xC03Cu, 1024);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4128769);
  serdes_apb_write(a1, a2, a3, 0xB03Cu, 0x40000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4128769);
  serdes_apb_write(a1, a2, a3, 0xC03Cu, 0x40000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1056964609);
  serdes_apb_write(a1, a2, a3, 0xB03Cu, 603979776);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1056964609);
  serdes_apb_write(a1, a2, a3, 0xC03Cu, 603979776);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB03Du, 36);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC03Du, 36);
  serdes_apb_write(a1, a2, a3, 0xB001u, -16129);
  serdes_apb_write(a1, a2, a3, 0xB03Du, 9216);
  serdes_apb_write(a1, a2, a3, 0xC001u, -16129);
  serdes_apb_write(a1, a2, a3, 0xC03Du, 9216);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4128769);
  serdes_apb_write(a1, a2, a3, 0xB03Du, 2359296);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4128769);
  serdes_apb_write(a1, a2, a3, 0xC03Du, 2359296);
  serdes_apb_write(a1, a2, a3, 0xB001u, -393217);
  serdes_apb_write(a1, a2, a3, 0xB01Cu, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -393217);
  serdes_apb_write(a1, a2, a3, 0xC01Cu, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0xB01Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0xC01Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -7);
  serdes_apb_write(a1, a2, a3, 0xB01Du, 2);
  serdes_apb_write(a1, a2, a3, 0xC001u, -7);
  serdes_apb_write(a1, a2, a3, 0xC01Du, 2);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1537);
  serdes_apb_write(a1, a2, a3, 0xB01Du, 512);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1537);
  serdes_apb_write(a1, a2, a3, 0xC01Du, 512);
  serdes_apb_write(a1, a2, a3, 0xB001u, -393217);
  serdes_apb_write(a1, a2, a3, 0xB01Du, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -393217);
  serdes_apb_write(a1, a2, a3, 0xC01Du, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0xB01Du, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0xC01Du, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -7);
  serdes_apb_write(a1, a2, a3, 0xB01Eu, 2);
  serdes_apb_write(a1, a2, a3, 0xC001u, -7);
  serdes_apb_write(a1, a2, a3, 0xC01Eu, 2);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1537);
  serdes_apb_write(a1, a2, a3, 0xB01Eu, 512);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1537);
  serdes_apb_write(a1, a2, a3, 0xC01Eu, 512);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA, 2048);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 9, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x4000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x13, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -33);
  serdes_apb_write(a1, a2, a3, 0xA005u, 32);
  serdes_apb_write(a1, a2, a3, 0xA001u, -2);
  serdes_apb_write(a1, a2, a3, 0xA007u, 1);
  serdes_apb_write(a1, a2, a3, 0xB001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xB025u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0xC025u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0xB025u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0xC025u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0xB028u, 0x8000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0xC028u, 0x8000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -17);
  serdes_apb_write(a1, a2, a3, 0xB029u, 16);
  serdes_apb_write(a1, a2, a3, 0xC001u, -17);
  serdes_apb_write(a1, a2, a3, 0xC029u, 16);
  serdes_apb_write(a1, a2, a3, 0xB001u, -65537);
  serdes_apb_write(a1, a2, a3, 0xB029u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -65537);
  serdes_apb_write(a1, a2, a3, 0xC029u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -131073);
  serdes_apb_write(a1, a2, a3, 0xB029u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -131073);
  serdes_apb_write(a1, a2, a3, 0xC029u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0xB02Du, 0x800000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0xC02Du, 0x800000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -268435457);
  serdes_apb_write(a1, a2, a3, 0xB02Du, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, -268435457);
  serdes_apb_write(a1, a2, a3, 0xC02Du, 0x10000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1879048193);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6B, 805306368);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9D, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x9E, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1073741825);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -786433);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x50, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6A, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -458753);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x53, 0x40000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2049);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32505857);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x49, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -126977);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x27, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x27, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3585);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x28, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3585);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x29, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1793);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -917505);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2C, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -241);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8193);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x32, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x34, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x35, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -134217729);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x36, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3145729);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 7, 0x200000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x65, -268435456);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x66, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x37, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 6);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1793);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 768);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -458753);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 393216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -117440513);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 0x2000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x39, 6);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x32, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x35, 2048);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000ADEB0) --------------------------------------------------------
int __fastcall SOC_28G_20210927_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "SOC_28G_20210927_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_28G_20210927_update",
    23,
    5964,
    60,
    &v9);
  v10 = 0;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2097153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 80);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 32);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 24576);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -13);
  serdes_apb_write(a1, a2, a3, 0x8002u, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 100663296);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -28673);
  serdes_apb_write(a1, a2, a3, 0x8014u, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -241);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000B008C) --------------------------------------------------------
int __fastcall SOC_32G_20210826_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v8; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v9; // [sp+101Eh] [bp+100Eh]

  v9 = 0;
  if ( a4 == 8 )
    v9 = 15;
  V_LOCK();
  logfmt_raw(&v8, 0x1000u, 0, "%s ...", "SOC_32G_20210826_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_32G_20210826_update",
    23,
    6192,
    60,
    &v8);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -33);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x71, 32);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, -520093697);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 0x3F, 251658240);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -520093697);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x3F, 251658240);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, -1048321);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 0x3E, 256);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1048321);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x3E, 256);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 0x3F, 4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x3F, 4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 2, 838860800);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 838860800);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 3, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 3, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 2, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 3, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 3, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 5, -268435456);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 5, -268435456);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, -64);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 6, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -64);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 6, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 5, -268435456);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 5, -268435456);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, -64);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 6, 1);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -64);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 6, 1);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x2F, -16777216);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x2F, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x19, 2048);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 1024);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0x20000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 3145728);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 80);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 20480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 5242880);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 1342177280);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 96);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 96);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x96, 12288);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -13);
  serdes_apb_write(a1, a2, a3, 0x8002u, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 100663296);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -28673);
  serdes_apb_write(a1, a2, a3, 0x8014u, 12288);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 11) | 1, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000B258C) --------------------------------------------------------
int __fastcall SOC_32G_20210817_update(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v8; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v9; // [sp+101Eh] [bp+100Eh]

  v9 = 0;
  if ( a4 == 8 )
    v9 = 15;
  V_LOCK();
  logfmt_raw(&v8, 0x1000u, 0, "%s ...", "SOC_32G_20210817_update");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_32G_20210817_update",
    23,
    6386,
    60,
    &v8);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0x20000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 96);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 96);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x96, 12288);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v9 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000B3740) --------------------------------------------------------
int __fastcall SOC_32G_static_config_20210911(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s core_id %02x ...", "SOC_32G_static_config_20210911", a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_32G_static_config_20210911",
    30,
    6486,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -520093697);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x3F, 251658240);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1048321);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x3E, 256);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x3F, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 5, -268435456);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -64);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 5, -268435456);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -64);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0x20000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -65521);
  serdes_apb_write(a1, a2, a3, 0x8022u, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -15728641);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x100000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8021u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8022u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8023u, 0x80000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -24577);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1025);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7937);
  serdes_apb_write(a1, a2, a3, 0x8009u, 768);
  serdes_apb_write(a1, a2, a3, 0x8001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0x8009u, 50331648);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0x8004u, 0x8000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -24577);
  serdes_apb_write(a1, a2, a3, 0x8012u, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x8022u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8048u, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8049u, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x804Au, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x804Bu, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -256);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 255);
  serdes_apb_write(a1, a2, a3, 0x8001u, -267386881);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 267386880);
  serdes_apb_write(a1, a2, a3, 0x8001u, -65281);
  serdes_apb_write(a1, a2, a3, 0x804Du, 65280);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x804Du, -268435456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16);
  serdes_apb_write(a1, a2, a3, 0x804Eu, 15);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16711681);
  serdes_apb_write(a1, a2, a3, 0x804Eu, 16711680);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4081);
  serdes_apb_write(a1, a2, a3, 0x804Fu, 4080);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x804Fu, -16777216);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8050u, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -196609);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x10000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -33);
  serdes_apb_write(a1, a2, a3, 0xA005u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -8193);
  serdes_apb_write(a1, a2, a3, 0xA005u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -16385);
  serdes_apb_write(a1, a2, a3, 0xA005u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -9);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -32769);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x8000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -262145);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x40000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -524289);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x80000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -65);
  serdes_apb_write(a1, a2, a3, 0xA007u, 64);
  serdes_apb_write(a1, a2, a3, 0xA001u, -469762049);
  serdes_apb_write(a1, a2, a3, 0xA005u, 469762048);
  serdes_apb_write(a1, a2, a3, 0xA001u, -58720257);
  serdes_apb_write(a1, a2, a3, 0xA005u, 58720256);
  serdes_apb_write(a1, a2, a3, 0xA001u, -939524097);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -117440513);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -12289);
  serdes_apb_write(a1, a2, a3, 0x8013u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -225);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 32);
  serdes_apb_write(a1, a2, a3, 0x8001u, -25);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -33554433);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -61441);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0x2000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -241);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 32);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2049);
  serdes_apb_write(a1, a2, a3, 0x8039u, 2048);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1025);
  serdes_apb_write(a1, a2, a3, 0x8039u, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 1342177280);
  serdes_apb_write(a1, a2, a3, 0x8001u, -15728641);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 5242880);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -65537);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -61441);
  serdes_apb_write(a1, a2, a3, 0x803Du, 24576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -241);
  serdes_apb_write(a1, a2, a3, 0x803Du, 96);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x8027u, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8027u, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x8028u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8028u, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x8028u, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x8028u, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8028u, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x8029u, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8029u, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x8029u, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x8029u, 7340032);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8029u, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x802Au, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x802Au, 80);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x802Au, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x802Au, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x802Au, 1342177280);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x802Bu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x802Bu, 608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x802Bu, 159744);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8022u, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -129);
  serdes_apb_write(a1, a2, a3, 0x8021u, 128);
  serdes_apb_write(a1, a2, a3, 0x8001u, -9);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x803Bu, -1073741824);
  serdes_apb_write(a1, a2, a3, 0x8001u, -32769);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x8000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2097153);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -49);
  serdes_apb_write(a1, a2, a3, 0x8008u, 32);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8007u, 12288);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8008u, 51200);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8005u, 127488);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8006u, 512000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1072693249);
  serdes_apb_write(a1, a2, a3, 0x801Fu, 20971520);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1024);
  serdes_apb_write(a1, a2, a3, 0x8020u, 20);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x3FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8003u, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16711681);
  serdes_apb_write(a1, a2, a3, 0x8025u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8025u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -32513);
  serdes_apb_write(a1, a2, a3, 0x8026u, 512);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8323073);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048577);
  serdes_apb_write(a1, a2, a3, 0x8005u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -241);
  serdes_apb_write(a1, a2, a3, 0x8046u, 16);
  serdes_apb_write(a1, a2, a3, 0x8001u, -61441);
  serdes_apb_write(a1, a2, a3, 0x8046u, 4096);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -3);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -33488897);
  serdes_apb_write(a1, a2, a3, 0x8004u, 327680);
  serdes_apb_write(a1, a2, a3, 0x8001u, -15728641);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -262145);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x40000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x80000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -24577);
  serdes_apb_write(a1, a2, a3, 0x8016u, 0x2000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -6291457);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -196609);
  serdes_apb_write(a1, a2, a3, 0x8027u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -201326593);
  serdes_apb_write(a1, a2, a3, 0x8003u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -458753);
  serdes_apb_write(a1, a2, a3, 0x8003u, 393216);
  serdes_apb_write(a1, a2, a3, 0x8001u, -113);
  serdes_apb_write(a1, a2, a3, 0x8007u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -49153);
  serdes_apb_write(a1, a2, a3, 0x8004u, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8049u, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000B71F4) --------------------------------------------------------
int __fastcall SOC_28G_20210929_update(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s core_id %02x ...", "SOC_28G_20210929_update", a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_28G_20210929_update",
    23,
    6856,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2097153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 80);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 805306368);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 24576);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -13);
  serdes_apb_write(a1, a2, a3, 0x8002u, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 100663296);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -28673);
  serdes_apb_write(a1, a2, a3, 0x8014u, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -241);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8193);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x32, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x34, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x35, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -134217729);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x36, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3145729);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 7, 0x200000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x65, -268435456);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x66, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x37, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 6);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1793);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 768);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -458753);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 393216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -117440513);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 0x2000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x39, 6);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x32, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x35, 2048);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000B9B14) --------------------------------------------------------
int __fastcall SOC_28G_20210928_update(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s core_id %02x ...", "SOC_28G_20210928_update", a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_28G_20210928_update",
    23,
    7116,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2097153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7340033);
  serdes_apb_write(a1, a2, a3, 0x8008u, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -57345);
  serdes_apb_write(a1, a2, a3, 0x8009u, 40960);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Du, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Du, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Du, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Du, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x805Eu, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x805Fu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 80);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8002u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -97);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 32);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 24576);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -13);
  serdes_apb_write(a1, a2, a3, 0x8002u, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 100663296);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -28673);
  serdes_apb_write(a1, a2, a3, 0x8014u, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -241);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8193);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x32, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x34, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x35, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -134217729);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x36, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x46, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3145729);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 7, 0x200000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x65, -268435456);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x66, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -234881025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x37, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 6);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1793);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 768);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -458753);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 393216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -117440513);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x38, 0x2000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x39, 6);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x32, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x35, 2048);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000BC434) --------------------------------------------------------
int __fastcall SOC_28G_static_config_20210914(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s core_id %02x ...", "SOC_28G_static_config_20210914", a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_28G_static_config_20210914",
    30,
    7374,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 3);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 838860800);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2097153);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -65521);
  serdes_apb_write(a1, a2, a3, 0x8022u, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -15728641);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x100000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8021u, -268435456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8022u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8023u, 0x80000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -24577);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1025);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7937);
  serdes_apb_write(a1, a2, a3, 0x8009u, 768);
  serdes_apb_write(a1, a2, a3, 0x8001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0x8009u, 50331648);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0x8004u, 0x8000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -24577);
  serdes_apb_write(a1, a2, a3, 0x8012u, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -6291457);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x8022u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -268435457);
  serdes_apb_write(a1, a2, a3, 0x801Du, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8048u, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8049u, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x804Au, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x804Bu, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -256);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 255);
  serdes_apb_write(a1, a2, a3, 0x8001u, -267386881);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 267386880);
  serdes_apb_write(a1, a2, a3, 0x8001u, -65281);
  serdes_apb_write(a1, a2, a3, 0x804Du, 65280);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x804Du, -268435456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16);
  serdes_apb_write(a1, a2, a3, 0x804Eu, 15);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16711681);
  serdes_apb_write(a1, a2, a3, 0x804Eu, 16711680);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4081);
  serdes_apb_write(a1, a2, a3, 0x804Fu, 4080);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x804Fu, -16777216);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8050u, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -25);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -196609);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x10000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -33);
  serdes_apb_write(a1, a2, a3, 0xA005u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -8193);
  serdes_apb_write(a1, a2, a3, 0xA005u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -16385);
  serdes_apb_write(a1, a2, a3, 0xA005u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -9);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -32769);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x8000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -262145);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x40000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -524289);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x80000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -65);
  serdes_apb_write(a1, a2, a3, 0xA007u, 64);
  serdes_apb_write(a1, a2, a3, 0xA001u, -469762049);
  serdes_apb_write(a1, a2, a3, 0xA005u, 469762048);
  serdes_apb_write(a1, a2, a3, 0xA001u, -58720257);
  serdes_apb_write(a1, a2, a3, 0xA005u, 58720256);
  serdes_apb_write(a1, a2, a3, 0xA001u, -939524097);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -117440513);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -12289);
  serdes_apb_write(a1, a2, a3, 0x8013u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -225);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 32);
  serdes_apb_write(a1, a2, a3, 0x8001u, -25);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -33554433);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -61441);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0x2000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -241);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 32);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2049);
  serdes_apb_write(a1, a2, a3, 0x8039u, 2048);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1025);
  serdes_apb_write(a1, a2, a3, 0x8039u, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 1342177280);
  serdes_apb_write(a1, a2, a3, 0x8001u, -15728641);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 5242880);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -65537);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -61441);
  serdes_apb_write(a1, a2, a3, 0x803Du, 24576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -241);
  serdes_apb_write(a1, a2, a3, 0x803Du, 96);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x8027u, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8027u, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x8028u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8028u, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x8028u, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x8028u, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8028u, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x8029u, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8029u, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x8029u, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x8029u, 7340032);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8029u, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x802Au, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x802Au, 80);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x802Au, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x802Au, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x802Au, 1342177280);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x802Bu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x802Bu, 608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x802Bu, 159744);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8022u, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -129);
  serdes_apb_write(a1, a2, a3, 0x8021u, 128);
  serdes_apb_write(a1, a2, a3, 0x8001u, -9);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x803Bu, -1073741824);
  serdes_apb_write(a1, a2, a3, 0x8001u, -32769);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x8000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2097153);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -49);
  serdes_apb_write(a1, a2, a3, 0x8008u, 32);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8007u, 12288);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8008u, 51200);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8005u, 127488);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8006u, 512000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1072693249);
  serdes_apb_write(a1, a2, a3, 0x801Fu, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1024);
  serdes_apb_write(a1, a2, a3, 0x8020u, 16);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x3FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8003u, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16711681);
  serdes_apb_write(a1, a2, a3, 0x8025u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8025u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -32513);
  serdes_apb_write(a1, a2, a3, 0x8026u, 512);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8323073);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048577);
  serdes_apb_write(a1, a2, a3, 0x8005u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -241);
  serdes_apb_write(a1, a2, a3, 0x8046u, 16);
  serdes_apb_write(a1, a2, a3, 0x8001u, -61441);
  serdes_apb_write(a1, a2, a3, 0x8046u, 4096);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -3);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -33488897);
  serdes_apb_write(a1, a2, a3, 0x8004u, 327680);
  serdes_apb_write(a1, a2, a3, 0x8001u, -15728641);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -262145);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x40000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x80000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -24577);
  serdes_apb_write(a1, a2, a3, 0x8016u, 0x2000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -6291457);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -196609);
  serdes_apb_write(a1, a2, a3, 0x8027u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -201326593);
  serdes_apb_write(a1, a2, a3, 0x8003u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -458753);
  serdes_apb_write(a1, a2, a3, 0x8003u, 393216);
  serdes_apb_write(a1, a2, a3, 0x8001u, -113);
  serdes_apb_write(a1, a2, a3, 0x8007u, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -49153);
  serdes_apb_write(a1, a2, a3, 0x8004u, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8049u, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -241);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000BFD54) --------------------------------------------------------
int __fastcall SOC_28G_static_axlk_txdata_en(int a1, unsigned __int8 a2, char a3)
{
  _BYTE v7[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s...", "SOC_28G_static_axlk_txdata_en");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_28G_static_axlk_txdata_en",
    29,
    7754,
    60,
    v7);
  serdes_apb_write(a1, a2, a3, 0xF001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xF088u, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0xF001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xF0A1u, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0xF001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xF0A1u, 0);
  serdes_apb_write(a1, a2, a3, 0xF001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xF0A1u, 0x80000000);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000BFF24) --------------------------------------------------------
int __fastcall SOC_32G_static_config_20210912(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s core_id %02x ...", "SOC_32G_static_config_20210912", a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "SOC_32G_static_config_20210912",
    30,
    7770,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -3);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2A, 50);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, -268435456);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, -268435456);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, -268435456);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, -268435456);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 1);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 1);
  serdes_apb_write(a1, a2, a3, 0xB001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xC001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 251658240);
  serdes_apb_write(a1, a2, a3, 0xB001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xB03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xC001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0xC03Eu, 256);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xB03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4096);
  serdes_apb_write(a1, a2, a3, 0xC03Fu, 4);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 838860800);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB002u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC002u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, -4);
  serdes_apb_write(a1, a2, a3, 0xB003u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -4);
  serdes_apb_write(a1, a2, a3, 0xC003u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, -268435456);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, -268435456);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xB005u, -268435456);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0xC005u, -268435456);
  serdes_apb_write(a1, a2, a3, 0xB001u, -64);
  serdes_apb_write(a1, a2, a3, 0xB006u, 1);
  serdes_apb_write(a1, a2, a3, 0xC001u, -64);
  serdes_apb_write(a1, a2, a3, 0xC006u, 1);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, -16777216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x2F, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x30, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -2049);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x19, 2048);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -536870913);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0x20000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1D, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x6E, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x1A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x47, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -67108865);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x20, 0x4000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -262145);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x12, 0x40000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1025);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x4A, 1024);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -8388609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7E, 0x800000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xB6, 1610612736);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -12289);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x96, 12288);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4194305);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7C, 0x400000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -497);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 384);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -225);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xA6, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -61441);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0xBE, 0x4000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -32769);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x10000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -131073);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65521);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x8000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x69, 8);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1537);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x48, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, -65521);
  serdes_apb_write(a1, a2, a3, 0x8022u, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -15728641);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x100000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8041u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8021u, -268435456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x8022u, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8023u, 0x80000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -24577);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1025);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -7937);
  serdes_apb_write(a1, a2, a3, 0x8009u, 768);
  serdes_apb_write(a1, a2, a3, 0x8001u, -520093697);
  serdes_apb_write(a1, a2, a3, 0x8009u, 50331648);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0x8004u, 0x8000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -24577);
  serdes_apb_write(a1, a2, a3, 0x8012u, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -6291457);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x8022u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -268435457);
  serdes_apb_write(a1, a2, a3, 0x801Du, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8048u, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8049u, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x804Au, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x804Bu, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -256);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 255);
  serdes_apb_write(a1, a2, a3, 0x8001u, -267386881);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 267386880);
  serdes_apb_write(a1, a2, a3, 0x8001u, -65281);
  serdes_apb_write(a1, a2, a3, 0x804Du, 65280);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x804Du, -268435456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16);
  serdes_apb_write(a1, a2, a3, 0x804Eu, 15);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16711681);
  serdes_apb_write(a1, a2, a3, 0x804Eu, 16711680);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4081);
  serdes_apb_write(a1, a2, a3, 0x804Fu, 4080);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x804Fu, -16777216);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1044481);
  serdes_apb_write(a1, a2, a3, 0x8050u, 1044480);
  serdes_apb_write(a1, a2, a3, 0x8001u, -25);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -196609);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x10000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -33);
  serdes_apb_write(a1, a2, a3, 0xA005u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -8193);
  serdes_apb_write(a1, a2, a3, 0xA005u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -16385);
  serdes_apb_write(a1, a2, a3, 0xA005u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -9);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, -32769);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x8000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -262145);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x40000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -524289);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x80000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -65);
  serdes_apb_write(a1, a2, a3, 0xA007u, 64);
  serdes_apb_write(a1, a2, a3, 0xA001u, -469762049);
  serdes_apb_write(a1, a2, a3, 0xA005u, 469762048);
  serdes_apb_write(a1, a2, a3, 0xA001u, -58720257);
  serdes_apb_write(a1, a2, a3, 0xA005u, 58720256);
  serdes_apb_write(a1, a2, a3, 0xA001u, -939524097);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0xA001u, -117440513);
  serdes_apb_write(a1, a2, a3, 0xA007u, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -12289);
  serdes_apb_write(a1, a2, a3, 0x8013u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -225);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 32);
  serdes_apb_write(a1, a2, a3, 0x8001u, -25);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 8);
  serdes_apb_write(a1, a2, a3, 0x8001u, -33554433);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16777217);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x1000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -61441);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 0x2000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -241);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 32);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2049);
  serdes_apb_write(a1, a2, a3, 0x8039u, 2048);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1025);
  serdes_apb_write(a1, a2, a3, 0x8039u, 1024);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 1342177280);
  serdes_apb_write(a1, a2, a3, 0x8001u, -15728641);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 5242880);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -65537);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -61441);
  serdes_apb_write(a1, a2, a3, 0x803Du, 24576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -241);
  serdes_apb_write(a1, a2, a3, 0x803Du, 96);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x8027u, 0x400000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8027u, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x8028u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8028u, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x8028u, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x8028u, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8028u, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x8029u, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8029u, 576);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x8029u, 147456);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x8029u, 7340032);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8029u, 1610612736);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x802Au, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x802Au, 80);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x802Au, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -66060289);
  serdes_apb_write(a1, a2, a3, 0x802Au, 37748736);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x802Au, 1342177280);
  serdes_apb_write(a1, a2, a3, 0x8001u, -4);
  serdes_apb_write(a1, a2, a3, 0x802Bu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x802Bu, 608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -258049);
  serdes_apb_write(a1, a2, a3, 0x802Bu, 159744);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8022u, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -129);
  serdes_apb_write(a1, a2, a3, 0x8021u, 128);
  serdes_apb_write(a1, a2, a3, 0x8001u, -9);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x803Bu, -1073741824);
  serdes_apb_write(a1, a2, a3, 0x8001u, -32769);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x8000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x800Cu, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2097153);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -49);
  serdes_apb_write(a1, a2, a3, 0x8008u, 32);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8007u, 12288);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8008u, 51200);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8005u, 127488);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048321);
  serdes_apb_write(a1, a2, a3, 0x8006u, 512000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1072693249);
  serdes_apb_write(a1, a2, a3, 0x801Fu, 20971520);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1024);
  serdes_apb_write(a1, a2, a3, 0x8020u, 20);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x3FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8003u, 0x40000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16711681);
  serdes_apb_write(a1, a2, a3, 0x8025u, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8025u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -16);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -32513);
  serdes_apb_write(a1, a2, a3, 0x8026u, 512);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8323073);
  serdes_apb_write(a1, a2, a3, 0x8026u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -1048577);
  serdes_apb_write(a1, a2, a3, 0x8005u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -241);
  serdes_apb_write(a1, a2, a3, 0x8046u, 16);
  serdes_apb_write(a1, a2, a3, 0x8001u, -61441);
  serdes_apb_write(a1, a2, a3, 0x8046u, 4096);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 1);
  serdes_apb_write(a1, a2, a3, 0x8001u, -3);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, -33488897);
  serdes_apb_write(a1, a2, a3, 0x8004u, 327680);
  serdes_apb_write(a1, a2, a3, 0x8001u, -15728641);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0xFFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x803Du, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -262145);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x40000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -524289);
  serdes_apb_write(a1, a2, a3, 0x8039u, 0x80000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -24577);
  serdes_apb_write(a1, a2, a3, 0x8016u, 0x2000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x801Bu, 0x80000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -2);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -6291457);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x200000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -196609);
  serdes_apb_write(a1, a2, a3, 0x8027u, 0x10000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -100663297);
  serdes_apb_write(a1, a2, a3, 0x803Cu, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -201326593);
  serdes_apb_write(a1, a2, a3, 0x8003u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -458753);
  serdes_apb_write(a1, a2, a3, 0x8003u, 393216);
  serdes_apb_write(a1, a2, a3, 0x8001u, -113);
  serdes_apb_write(a1, a2, a3, 0x8007u, 64);
  serdes_apb_write(a1, a2, a3, 0x8001u, -49153);
  serdes_apb_write(a1, a2, a3, 0x8004u, 0x4000);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8049u, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -241);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 6, 96);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  serdes_apb_write(a1, a2, a3, 0xB001u, 0);
  serdes_apb_write(a1, a2, a3, 0xC001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C43C8) --------------------------------------------------------
int __fastcall overwrite_to_24G(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s core_id %02x ...", "overwrite_to_24G", a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "overwrite_to_24G",
    16,
    8217,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, 0x8001u, -1009);
  serdes_apb_write(a1, a2, a3, 0x8002u, 64);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 2, 0x20000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 2);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 8, 196608);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -196609);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 3, 196608);
  serdes_apb_write(a1, a2, a3, 0x8001u, -786433);
  serdes_apb_write(a1, a2, a3, 0x803Eu, 786432);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8048u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 805306368);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C481C) --------------------------------------------------------
int __fastcall cmnadj_20210813_500M_test(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  int v10; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v11; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s%d core_id %02x ...", "cmnadj_20210813_500M_test", a5, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "cmnadj_20210813_500M_test",
    25,
    8280,
    60,
    &v10);
  v11 = a4;
  if ( a4 == 8 )
    v11 = 15;
  switch ( a5 )
  {
    case 1:
      serdes_apb_write(a1, a2, a3, 0x8001u, -97);
      serdes_apb_write(a1, a2, a3, 0x800Cu, 64);
      serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
      serdes_apb_write(a1, a2, a3, 0x8001u, 0);
      serdes_apb_write(a1, a2, a3, 0xA001u, 0);
      break;
    case 2:
      serdes_apb_write(a1, a2, a3, 0x8001u, -97);
      serdes_apb_write(a1, a2, a3, 0x800Cu, 96);
      serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
      serdes_apb_write(a1, a2, a3, 0x8001u, 0);
      serdes_apb_write(a1, a2, a3, 0xA001u, 0);
      break;
    case 3:
      serdes_apb_write(a1, a2, a3, 0x8001u, -97);
      serdes_apb_write(a1, a2, a3, 0x800Cu, 96);
      serdes_apb_write(a1, a2, a3, 0x8001u, -805306369);
      serdes_apb_write(a1, a2, a3, 0x804Cu, 0x10000000);
      serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
      serdes_apb_write(a1, a2, a3, 0x8001u, 0);
      serdes_apb_write(a1, a2, a3, 0xA001u, 0);
      break;
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C4BCC) --------------------------------------------------------
int __fastcall atp_test(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[4100]; // [sp+18h] [bp+8h] BYREF

  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -520093697);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x89, 251658240);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s channel_id %1x, core_id %1x test vdda please", "atp_test", a4, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "atp_test",
    8,
    8328,
    60,
    v9);
  while ( getchar() != 10 )
    ;
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x89, 385875968);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s channel_id %1x, core_id %1x test vddhv please", "atp_test", a4, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "atp_test",
    8,
    8332,
    60,
    v9);
  getchar();
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s reset atp address", "atp_test");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "atp_test",
    8,
    8335,
    60,
    v9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x89, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C4E70) --------------------------------------------------------
int __fastcall get_special_core_reg(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  int v4; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 *v5; // [sp+1020h] [bp+1010h]
  int j; // [sp+1024h] [bp+1014h]
  unsigned __int8 i; // [sp+102Bh] [bp+101Bh]
  int v8; // [sp+102Ch] [bp+101Ch]

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "get_special_core_reg");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "get_special_core_reg",
    20,
    8344,
    60,
    v3);
  v8 = 0;
  v5 = (unsigned __int8 *)malloc(0x600u);
  for ( i = 0; i <= 7u; ++i )
  {
    v4 = sub_78DA0(a1, i, 255, 81, v5);
    for ( j = 0; j < v4; ++j )
    {
      V_LOCK();
      logfmt_raw(
        v3,
        0x1000u,
        0,
        "chip %02x core %02x addr %04x, %08x",
        v5[12 * j + 4],
        v5[12 * j + 8],
        81,
        *(_DWORD *)&v5[12 * j]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "get_special_core_reg",
        20,
        8351,
        20,
        v3);
    }
    if ( v4 != 16 )
    {
      v8 = 1;
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, "chip %02x core reg %04x, resp_num(%d) is not enough", i, 81, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "get_special_core_reg",
        20,
        8356,
        100,
        v3);
    }
  }
  free(v5);
  return v8;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C511C) --------------------------------------------------------
int __fastcall read_dag(int a1)
{
  _BYTE v3[4088]; // [sp+28h] [bp+8h] BYREF
  _DWORD v4[6]; // [sp+1028h] [bp+1008h]
  _WORD s[66]; // [sp+1040h] [bp+1020h] BYREF
  _BYTE v6[60]; // [sp+10C4h] [bp+10A4h] BYREF
  unsigned int v8; // [sp+1108h] [bp+10E8h]
  unsigned int kk; // [sp+110Ch] [bp+10ECh]
  unsigned __int8 jj; // [sp+1113h] [bp+10F3h]
  unsigned int ii; // [sp+1114h] [bp+10F4h]
  unsigned int n; // [sp+1118h] [bp+10F8h]
  unsigned int m; // [sp+111Ch] [bp+10FCh]
  unsigned int k; // [sp+1120h] [bp+1100h]
  unsigned __int8 j; // [sp+1126h] [bp+1106h]
  unsigned __int8 i; // [sp+1127h] [bp+1107h]

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "read_dag");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "read_dag",
    8,
    8367,
    60,
    v3);
  for ( i = 0; i <= 0xFu; ++i )
  {
    sub_789C4(a1, i, 19, i);
    usleep(0x2710u);
  }
  for ( j = 0; j <= 0xFu; ++j )
  {
    if ( j > 7u )
      sub_789C4(a1, j, 12, 0);
    else
      sub_789C4(a1, j, 12, 3);
  }
  memset(s, 0, 0x81u);
  v4[0] = 0;
  v4[1] = 1;
  v4[2] = 4096;
  v4[3] = 4096;
  v4[4] = 16382;
  v4[5] = 0x3FFF;
  for ( k = 0; k <= 0xB; ++k )
  {
    for ( m = 0; m <= 7; ++m )
    {
      for ( n = 0; n <= 7; ++n )
      {
        for ( ii = 0; ii <= 5; ++ii )
        {
          v8 = (4 * n) | (k << 22) | (v4[ii] << 8) | (32 * m);
          for ( jj = 0; jj <= 7u; ++jj )
          {
            if ( sub_78528(a1, jj, v8, v6) )
            {
              for ( kk = 0; kk <= 0x3F; ++kk )
                sprintf((char *)&s[kk], "%02x", (unsigned __int8)v6[kk]);
              V_LOCK();
              logfmt_raw(
                v3,
                0x1000u,
                0,
                "[DAG] node_index %08x(chip %1d row %02d col %d ch %d s_addr %04x %s",
                v8,
                jj,
                k,
                m,
                n,
                v4[ii],
                s);
              V_UNLOCK();
              zlog(
                g_zc,
                "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
                83,
                "read_dag",
                8,
                8399,
                60,
                v3);
            }
          }
        }
      }
    }
  }
  sub_788A8(a1, 12, 2);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C5538) --------------------------------------------------------
int __fastcall get_core_clk(int a1)
{
  int v2; // [sp+14h] [bp-4h]
  __int64 v3; // [sp+18h] [bp+0h]
  __int64 v4; // [sp+20h] [bp+8h]
  _BYTE v6[8]; // [sp+30h] [bp+18h] BYREF
  unsigned int v7; // [sp+1030h] [bp+1018h]
  unsigned int v8; // [sp+1034h] [bp+101Ch]
  int v9; // [sp+1038h] [bp+1020h]
  unsigned __int8 *v10; // [sp+103Ch] [bp+1024h]
  unsigned __int64 v11; // [sp+1040h] [bp+1028h]
  int k; // [sp+1048h] [bp+1030h]
  int j; // [sp+104Ch] [bp+1034h]
  unsigned __int8 i; // [sp+1053h] [bp+103Bh]
  int v15; // [sp+1054h] [bp+103Ch]

  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "%s...", "get_core_clk");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "get_core_clk",
    12,
    8414,
    60,
    v6);
  v4 = 4800000000LL;
  v3 = 37600000000LL;
  v11 = 150000000000LL;
  v15 = 0;
  v10 = (unsigned __int8 *)malloc(0x600u);
  for ( i = 0; i <= 7u; ++i )
  {
    v9 = sub_78DA0(a1, i, 255, 121, v10);
    for ( j = 0; j < v9; ++j )
    {
      v8 = sub_79338(*(_DWORD *)&v10[12 * j]);
      if ( v8 )
        v15 = sub_1A3E94(v11 >> 10, v8);
      else
        v15 = 0;
      V_LOCK();
      logfmt_raw(
        v6,
        0x1000u,
        0,
        "chip %02x core %02x addr %04x, %08x, tx_clk %lld",
        v10[12 * j + 4],
        v10[12 * j + 8],
        121,
        v8,
        v15,
        v2,
        v3,
        v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "get_core_clk",
        12,
        8428,
        60,
        v6);
    }
    v9 = sub_78DA0(a1, i, 255, 122, v10);
    for ( k = 0; k < v9; ++k )
    {
      v7 = sub_79338(*(_DWORD *)&v10[12 * k]);
      if ( v7 )
        v15 = sub_1A3E94(v11 >> 10, v7);
      else
        v15 = 0;
      V_LOCK();
      logfmt_raw(
        v6,
        0x1000u,
        0,
        "chip %02x core %02x addr %04x, %08x, rx_clk0 %lld",
        v10[12 * k + 4],
        v10[12 * k + 8],
        122,
        v7,
        v15);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "get_core_clk",
        12,
        8438,
        60,
        v6);
    }
  }
  free(v10);
  return 0;
}
// C579E: variable 'v2' is possibly undefined
// C579E: variable 'v3' is possibly undefined
// C579E: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C5A08) --------------------------------------------------------
int __fastcall check_ref_clock_ready(int a1, int a2, unsigned __int8 a3)
{
  _BYTE v6[12]; // [sp+1Ch] [bp+Ch] BYREF
  int v7; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 *v8; // [sp+1020h] [bp+1010h]
  int kk; // [sp+1024h] [bp+1014h]
  int jj; // [sp+1028h] [bp+1018h]
  int ii; // [sp+102Ch] [bp+101Ch]
  int n; // [sp+1030h] [bp+1020h]
  int m; // [sp+1034h] [bp+1024h]
  int k; // [sp+1038h] [bp+1028h]
  unsigned __int8 j; // [sp+103Fh] [bp+102Fh]
  int i; // [sp+1040h] [bp+1030h]
  unsigned __int8 v17; // [sp+1047h] [bp+1037h]

  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "write 0x70: 0 to clear debug_cmnlockstatus_cnt");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_ref_clock_ready",
    21,
    8450,
    60,
    v6);
  sub_788A8(a1, 112, 0);
  v17 = 16;
  if ( a3 != 255 )
    v17 = 1;
  for ( i = 0; i <= 2; ++i )
  {
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, "%s round:%d", "check_ref_clock_ready", i);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_ref_clock_ready",
      21,
      8457,
      60,
      v6);
    v8 = (unsigned __int8 *)malloc(0x600u);
    for ( j = 0; j < (unsigned int)v17; ++j )
    {
      if ( a3 != 255 )
        j = a3;
      v7 = sub_78A20(a1, j, 112, v8);
      for ( k = 0; k < v7; ++k )
      {
        if ( (*(_DWORD *)&v8[12 * k] & 0x9000000) == 0x9000000 )
        {
          V_LOCK();
          logfmt_raw(
            v6,
            0x1000u,
            0,
            "chip %02x core %02x addr %04x, %08x, cmn locked",
            v8[12 * k + 4],
            v8[12 * k + 8],
            112,
            *(_DWORD *)&v8[12 * k]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_ref_clock_ready",
            21,
            8465,
            20,
            v6);
        }
        else
        {
          V_LOCK();
          logfmt_raw(
            v6,
            0x1000u,
            0,
            "chip %02x core %02x addr %04x, %08x, cmn lock failed",
            v8[12 * k + 4],
            v8[12 * k + 8],
            112,
            *(_DWORD *)&v8[12 * k]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_ref_clock_ready",
            21,
            8467,
            100,
            v6);
        }
      }
      v7 = sub_78A20(a1, j, 113, v8);
      for ( m = 0; m < v7; ++m )
      {
        if ( *(_DWORD *)&v8[12 * m] == -1 )
        {
          V_LOCK();
          logfmt_raw(
            v6,
            0x1000u,
            0,
            "chip %02x core %02x addr %04x, %08x, tx/rx locked",
            v8[12 * m + 4],
            v8[12 * m + 8],
            113,
            *(_DWORD *)&v8[12 * m]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_ref_clock_ready",
            21,
            8476,
            20,
            v6);
        }
        else
        {
          V_LOCK();
          logfmt_raw(
            v6,
            0x1000u,
            0,
            "chip %02x core %02x addr %04x, %08x, tx/rx lock failed",
            v8[12 * m + 4],
            v8[12 * m + 8],
            113,
            *(_DWORD *)&v8[12 * m]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_ref_clock_ready",
            21,
            8474,
            100,
            v6);
        }
      }
      v7 = sub_78A20(a1, j, 114, v8);
      for ( n = 0; n < v7; ++n )
      {
        V_LOCK();
        logfmt_raw(
          v6,
          0x1000u,
          0,
          "chip %02x core %02x addr %04x, %08x",
          v8[12 * n + 4],
          v8[12 * n + 8],
          114,
          *(_DWORD *)&v8[12 * n]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "check_ref_clock_ready",
          21,
          8482,
          100,
          v6);
      }
      v7 = sub_78A20(a1, j, 115, v8);
      for ( ii = 0; ii < v7; ++ii )
      {
        V_LOCK();
        logfmt_raw(
          v6,
          0x1000u,
          0,
          "chip %02x core %02x addr %04x, %08x",
          v8[12 * ii + 4],
          v8[12 * ii + 8],
          115,
          *(_DWORD *)&v8[12 * ii]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "check_ref_clock_ready",
          21,
          8487,
          100,
          v6);
      }
      v7 = sub_78A20(a1, j, 116, v8);
      for ( jj = 0; jj < v7; ++jj )
      {
        V_LOCK();
        logfmt_raw(
          v6,
          0x1000u,
          0,
          "chip %02x core %02x addr %04x, %08x",
          v8[12 * jj + 4],
          v8[12 * jj + 8],
          116,
          *(_DWORD *)&v8[12 * jj]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "check_ref_clock_ready",
          21,
          8492,
          100,
          v6);
      }
      v7 = sub_78A20(a1, j, 117, v8);
      for ( kk = 0; kk < v7; ++kk )
      {
        V_LOCK();
        logfmt_raw(
          v6,
          0x1000u,
          0,
          "chip %02x core %02x addr %04x, %08x",
          v8[12 * kk + 4],
          v8[12 * kk + 8],
          117,
          *(_DWORD *)&v8[12 * kk]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "check_ref_clock_ready",
          21,
          8497,
          100,
          v6);
      }
    }
    free(v8);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C6504) --------------------------------------------------------
int __fastcall check_tx_rx_status(int a1, int a2, unsigned __int8 a3)
{
  int v6; // [sp+1Ch] [bp+Ch] BYREF
  int v7; // [sp+101Ch] [bp+100Ch] BYREF
  int v8; // [sp+102Ch] [bp+101Ch]
  int v9; // [sp+1030h] [bp+1020h]
  unsigned __int8 *v10; // [sp+1034h] [bp+1024h]
  int j; // [sp+1038h] [bp+1028h]
  unsigned __int8 i; // [sp+103Eh] [bp+102Eh]
  unsigned __int8 v13; // [sp+103Fh] [bp+102Fh]
  _BYTE v14[4]; // [sp+1040h] [bp+1030h] BYREF

  V_LOCK();
  logfmt_raw(&v6, 0x1000u, 0, "%s...", "check_tx_rx_status");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_tx_rx_status",
    18,
    8509,
    60,
    &v6);
  v10 = (unsigned __int8 *)malloc(0x600u);
  v9 = sub_7936C(&v7);
  v13 = 0;
  for ( i = 0; i < v9; ++i )
  {
    if ( a3 == 255 )
      v13 = v14[i - 36];
    else
      v13 = a3;
    v8 = sub_78A20(a1, v13, 113, v10);
    for ( j = 0; j < v8; ++j )
    {
      if ( *(_DWORD *)&v10[12 * j] == -1 )
      {
        V_LOCK();
        logfmt_raw(
          &v6,
          0x1000u,
          0,
          "chip %02x core %02x addr %04x, %08x, tx/rx locked",
          v10[12 * j + 4],
          v10[12 * j + 8],
          113,
          *(_DWORD *)&v10[12 * j]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "check_tx_rx_status",
          18,
          8526,
          20,
          &v6);
      }
      else
      {
        V_LOCK();
        logfmt_raw(
          &v6,
          0x1000u,
          0,
          "chip %02x core %02x addr %04x, %08x, tx/rx lock failed",
          v10[12 * j + 4],
          v10[12 * j + 8],
          113,
          *(_DWORD *)&v10[12 * j]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "check_tx_rx_status",
          18,
          8524,
          100,
          &v6);
      }
    }
  }
  free(v10);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C6890) --------------------------------------------------------
int __fastcall check_cmn_calibration_status_1_phy(int a1, char a2, unsigned __int8 a3)
{
  const char *v3; // r3
  int v8; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v9[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v10; // [sp+1020h] [bp+1010h]

  V_LOCK();
  logfmt_raw(&v8, 0x1000u, 0, "%s...", "check_cmn_calibration_status_1_phy");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_cmn_calibration_status_1_phy",
    34,
    8538,
    60,
    &v8);
  if ( serdes_apb_read_back_1_chip(a1, a2, a3, 0x801Du, (int)v9) )
  {
    V_LOCK();
    if ( (v10 & 0x8000) != 0 )
      v3 = "done";
    else
      v3 = "not ready";
    logfmt_raw(&v8, 0x1000u, 0, "chip_id %02x core_id %02x cmn clibration %08x", v9[0], v9[1], v10, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_cmn_calibration_status_1_phy",
      34,
      8544,
      60,
      &v8);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C6A10) --------------------------------------------------------
int __fastcall check_cmn_calibration_status(int a1, int a2, int a3)
{
  _BYTE v6[4080]; // [sp+20h] [bp+10h] BYREF
  _BYTE v7[16]; // [sp+1020h] [bp+1010h] BYREF
  unsigned __int8 v8; // [sp+1033h] [bp+1023h]
  int v9; // [sp+1034h] [bp+1024h]
  int j; // [sp+1038h] [bp+1028h]
  unsigned __int8 i; // [sp+103Fh] [bp+102Fh]

  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "%s...", "check_cmn_calibration_status");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_cmn_calibration_status",
    28,
    8552,
    60,
    v6);
  v9 = 1;
  v9 = sub_7936C(v7);
  for ( i = 0; i <= 7u; ++i )
  {
    for ( j = 0; j < v9; ++j )
    {
      v8 = v7[j];
      if ( v8 != 3 && *(_BYTE *)(a3 + v8 + 16 * i) )
        check_cmn_calibration_status_1_phy(a1, i, v8);
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C6BAC) --------------------------------------------------------
int __fastcall do_32G_stop_seq_all_phy(int a1, unsigned __int8 a2, char a3)
{
  _BYTE v7[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s...", "do_32G_stop_seq_all_phy");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "do_32G_stop_seq_all_phy",
    23,
    8574,
    60,
    v7);
  serdes_apb_write(a1, a2, a3, 0x8001u, -3);
  serdes_apb_write(a1, a2, a3, 0x8050u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -257);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C6D04) --------------------------------------------------------
int __fastcall do_32G_retry_seq_all_phy(int a1, unsigned __int8 a2, char a3)
{
  _BYTE v7[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s...", "do_32G_retry_seq_all_phy");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "do_32G_retry_seq_all_phy",
    24,
    8587,
    60,
    v7);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0x20000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -536870913);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0x20000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -131073);
  serdes_apb_write(a1, a2, a3, 0x801Eu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -536870913);
  serdes_apb_write(a1, a2, a3, 0x801Cu, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0x801Du, 0x8000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -134217729);
  serdes_apb_write(a1, a2, a3, 0x801Du, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -8388609);
  serdes_apb_write(a1, a2, a3, 0x8049u, 0x800000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -33554433);
  serdes_apb_write(a1, a2, a3, 0x804Du, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -33554433);
  serdes_apb_write(a1, a2, a3, 0x804Du, 0x2000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -33554433);
  serdes_apb_write(a1, a2, a3, 0x804Du, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -268435457);
  serdes_apb_write(a1, a2, a3, 0x8049u, 0x10000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x804Du, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x804Du, 0x4000000);
  serdes_apb_write(a1, a2, a3, 0x8001u, -67108865);
  serdes_apb_write(a1, a2, a3, 0x804Du, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, -257);
  serdes_apb_write(a1, a2, a3, 0x804Cu, 256);
  serdes_apb_write(a1, a2, a3, 0x8001u, -3);
  serdes_apb_write(a1, a2, a3, 0x8050u, 2);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C7278) --------------------------------------------------------
int __fastcall do_32G_retry_seq_by_worse_phy(int a1, int a2, int a3, int a4, int a5)
{
  int v7; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v8[16]; // [sp+101Ch] [bp+100Ch] BYREF
  _BYTE v9[1027]; // [sp+102Ch] [bp+101Ch] BYREF
  unsigned __int8 v10; // [sp+142Fh] [bp+141Fh]
  int v11; // [sp+1430h] [bp+1420h]
  unsigned __int8 j; // [sp+1436h] [bp+1426h]
  unsigned __int8 i; // [sp+1437h] [bp+1427h]
  char *v14; // [sp+1438h] [bp+1428h]
  int v15; // [sp+143Ch] [bp+142Ch]

  V_LOCK();
  logfmt_raw(&v7, 0x1000u, 0, "%s...", "do_32G_retry_seq_by_worse_phy");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "do_32G_retry_seq_by_worse_phy",
    29,
    8627,
    60,
    &v7);
  memset(v9, 0, 0x400u);
  v15 = 0;
  v11 = sub_7936C(v8);
  v14 = v9;
  for ( i = 0; i <= 7u; ++i )
  {
    for ( j = 0; j < v11; ++j )
    {
      v10 = v8[j];
      V_LOCK();
      logfmt_raw(
        &v7,
        0x1000u,
        0,
        "%s chip %x core %x cmn status %x",
        "do_32G_retry_seq_by_worse_phy",
        i,
        v10,
        *(unsigned __int8 *)(a5 + v10 + 16 * i));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "do_32G_retry_seq_by_worse_phy",
        29,
        8637,
        20,
        &v7);
      if ( *(_BYTE *)(a5 + v10 + 16 * i) )
      {
        V_LOCK();
        logfmt_raw(&v7, 0x1000u, 0, "do retry chip %02x core_id %02x", i, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "do_32G_retry_seq_by_worse_phy",
          29,
          8639,
          60,
          &v7);
        sprintf(v14, "%1x-%1x ", i, v10);
        v14 += 4;
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -131073);
        serdes_apb_write_1_chip(a1, i, v10, 0x801Eu, 0x20000);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -536870913);
        serdes_apb_write_1_chip(a1, i, v10, 0x801Cu, 0x20000000);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -131073);
        serdes_apb_write_1_chip(a1, i, v10, 0x801Eu, 0);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -536870913);
        serdes_apb_write_1_chip(a1, i, v10, 0x801Cu, 0);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -134217729);
        serdes_apb_write_1_chip(a1, i, v10, 0x801Du, 0x8000000);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -134217729);
        serdes_apb_write_1_chip(a1, i, v10, 0x801Du, 0);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -8388609);
        serdes_apb_write_1_chip(a1, i, v10, 0x8049u, 0x800000);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -33554433);
        serdes_apb_write_1_chip(a1, i, v10, 0x804Du, 0);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -33554433);
        serdes_apb_write_1_chip(a1, i, v10, 0x804Du, 0x2000000);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -33554433);
        serdes_apb_write_1_chip(a1, i, v10, 0x804Du, 0);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -268435457);
        serdes_apb_write_1_chip(a1, i, v10, 0x8049u, 0x10000000);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -67108865);
        serdes_apb_write_1_chip(a1, i, v10, 0x804Du, 0);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -67108865);
        serdes_apb_write_1_chip(a1, i, v10, 0x804Du, 0x4000000);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -67108865);
        serdes_apb_write_1_chip(a1, i, v10, 0x804Du, 0);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -257);
        serdes_apb_write_1_chip(a1, i, v10, 0x804Cu, 256);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -3);
        serdes_apb_write_1_chip(a1, i, v10, 0x8050u, 2);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, 0);
        usleep((__useconds_t)&stru_1869C.st_value);
        check_cmn_calibration_status_1_phy(a1, i, v10);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -3);
        serdes_apb_write_1_chip(a1, i, v10, 0x8050u, 0);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, -257);
        serdes_apb_write_1_chip(a1, i, v10, 0x804Cu, 0);
        serdes_apb_write_1_chip(a1, i, v10, 0x8001u, 0);
        ++v15;
      }
    }
  }
  V_LOCK();
  logfmt_raw(&v7, 0x1000u, 0, "%s (%d) %s", "do_32G_retry_seq_by_worse_phy", v15, v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "do_32G_retry_seq_by_worse_phy",
    29,
    8689,
    60,
    &v7);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C7C48) --------------------------------------------------------
int __fastcall load_32G_advance(int a1, unsigned __int8 a2, char a3)
{
  _BYTE v7[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "%s...", "load_32G_advance");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "load_32G_advance",
    16,
    8696,
    60,
    v7);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, 0x8049u, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C7D58) --------------------------------------------------------
int __fastcall ajust_retry_param(int a1, char a2, char a3)
{
  int v7; // [sp+1Ch] [bp+Ch] BYREF
  int v8; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v9; // [sp+1020h] [bp+1010h]

  V_LOCK();
  logfmt_raw(&v7, 0x1000u, 0, "%s...", "ajust_retry_param");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "ajust_retry_param",
    17,
    8707,
    60,
    &v7);
  if ( serdes_apb_read_back_1_chip(a1, a2, a3, 0x8023u, (int)&v8) )
  {
    if ( v9 <= 0xFA )
    {
      if ( v9 <= 9 )
      {
        serdes_apb_write_1_chip(a1, a2, a3, 0x8001u, -4190209);
        serdes_apb_write_1_chip(a1, a2, a3, 0x8021u, (int)&unk_3FE000);
      }
    }
    else
    {
      serdes_apb_write_1_chip(a1, a2, a3, 0x8001u, -4190209);
      serdes_apb_write_1_chip(a1, a2, a3, 0x8021u, 0x2000);
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C7F00) --------------------------------------------------------
int __fastcall check_cmn_lock_status(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5)
{
  _BYTE v9[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v10[8]; // [sp+58h] [bp+48h] BYREF
  _BYTE v11[16]; // [sp+1058h] [bp+1048h] BYREF
  int back; // [sp+1068h] [bp+1058h]
  int j; // [sp+106Ch] [bp+105Ch]
  int i; // [sp+1070h] [bp+1060h]
  unsigned __int8 v15; // [sp+1077h] [bp+1067h]
  int v16; // [sp+1078h] [bp+1068h]
  int v17; // [sp+107Ch] [bp+106Ch]

  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s...", "check_cmn_lock_status");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_cmn_lock_status",
    21,
    8727,
    60,
    v10);
  v17 = 1;
  v16 = 0;
  if ( a3 == 255 )
    v17 = sub_7936C(v11);
  v15 = 0;
  for ( i = 0; i < v17; ++i )
  {
    if ( a3 == 255 )
      v15 = v11[i];
    else
      v15 = a3;
    if ( v15 != 3 )
    {
      back = serdes_apb_read_back(a1, a2, v15, 0x801Du, (int)v9);
      for ( j = 0; j < back; ++j )
      {
        if ( (*(_DWORD *)&v9[8 * j + 4] & 0x20000000) != 0 )
        {
          if ( a5 )
            *(_BYTE *)(a5 + v15 + 16 * j) = 0;
          V_LOCK();
          logfmt_raw(
            v10,
            0x1000u,
            0,
            "chip_id %02x core_id %02x cmn locked",
            (unsigned __int8)v9[8 * j],
            (unsigned __int8)v9[8 * j + 1]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_cmn_lock_status",
            21,
            8752,
            20,
            v10);
        }
        else
        {
          ++v16;
          if ( a5 )
            *(_BYTE *)(a5 + v15 + 16 * j) = 1;
          V_LOCK();
          logfmt_raw(
            v10,
            0x1000u,
            0,
            "chip_id %02x core_id %02x %08x cmn lock failed!",
            (unsigned __int8)v9[8 * j],
            (unsigned __int8)v9[8 * j + 1],
            *(_DWORD *)&v9[8 * j + 4]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_cmn_lock_status",
            21,
            8758,
            100,
            v10);
          ajust_retry_param(a1, v9[8 * j], v15);
        }
      }
    }
  }
  if ( byte_1EEF8C )
    byte_1EEF8C = 0;
  return v16;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1EEF8C: using guessed type char byte_1EEF8C;
// 47BE18: using guessed type int g_zc;

//----- (000C82EC) --------------------------------------------------------
int __fastcall check_ref_clock_ready_ext(int a1, int a2, unsigned __int8 a3, int a4, int a5)
{
  _BYTE v9[24]; // [sp+18h] [bp+8h] BYREF
  int v10; // [sp+1018h] [bp+1008h] BYREF
  int v11; // [sp+1028h] [bp+1018h]
  int v12; // [sp+102Ch] [bp+101Ch]
  _DWORD *v13; // [sp+1030h] [bp+1020h]
  unsigned __int8 *v14; // [sp+1034h] [bp+1024h]
  int n; // [sp+1038h] [bp+1028h]
  unsigned __int8 m; // [sp+103Fh] [bp+102Fh]
  int k; // [sp+1040h] [bp+1030h]
  unsigned __int8 j; // [sp+1046h] [bp+1036h]
  unsigned __int8 v19; // [sp+1047h] [bp+1037h]
  int i; // [sp+1048h] [bp+1038h]
  int v21; // [sp+104Ch] [bp+103Ch]
  _BYTE v22[4]; // [sp+1050h] [bp+1040h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "clear debug_cmnlockstatus_cnt");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_ref_clock_ready_ext",
    25,
    8774,
    60,
    v9);
  sub_788A8(a1, 112, 0);
  v21 = 1;
  if ( a3 == 255 )
    v21 = sub_7936C(&v10);
  for ( i = 0; i <= 2; ++i )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "%s round:%d", "check_ref_clock_ready_ext", i);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_ref_clock_ready_ext",
      25,
      8783,
      60,
      v9);
    v14 = (unsigned __int8 *)malloc(0x600u);
    v13 = malloc(0x600u);
    v19 = 0;
    for ( j = 0; j < v21; ++j )
    {
      if ( a3 == 255 )
        v19 = v22[j - 56];
      else
        v19 = a3;
      v12 = sub_78A20(a1, v19, 112, v14);
      for ( k = 0; k < v12; ++k )
      {
        if ( (*(_DWORD *)&v14[12 * k] & 0x9000000) == 0x9000000 )
        {
          if ( a5 )
            *(_BYTE *)(a5 + v19 + 16 * k) = 0;
          V_LOCK();
          logfmt_raw(
            v9,
            0x1000u,
            0,
            "chip %02x core %02x addr %04x, %08x, cmn locked",
            v14[12 * k + 4],
            v14[12 * k + 8],
            112,
            *(_DWORD *)&v14[12 * k]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_ref_clock_ready_ext",
            25,
            8798,
            20,
            v9);
          v11 = sub_78DA0(a1, v14[12 * k + 4], v19, 113, v13);
          if ( !v11 || *v13 == -1 )
          {
            if ( a5 )
              *(_BYTE *)(a5 + v19 + 16 * k) = 0;
            V_LOCK();
            logfmt_raw(
              v9,
              0x1000u,
              0,
              "chip %02x core %02x addr %04x, %08x, tx/rx locked",
              *((unsigned __int8 *)v13 + 4),
              *((unsigned __int8 *)v13 + 8),
              113,
              *v13);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
              83,
              "check_ref_clock_ready_ext",
              25,
              8810,
              20,
              v9);
          }
          else
          {
            if ( a5 )
              *(_BYTE *)(a5 + v19 + 16 * k) = 1;
            V_LOCK();
            logfmt_raw(
              v9,
              0x1000u,
              0,
              "chip %02x core %02x addr %04x, %08x, tx/rx lock failed",
              *((unsigned __int8 *)v13 + 4),
              *((unsigned __int8 *)v13 + 8),
              113,
              *v13);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
              83,
              "check_ref_clock_ready_ext",
              25,
              8805,
              100,
              v9);
          }
        }
        else
        {
          if ( a5 )
            *(_BYTE *)(a5 + v19 + 16 * k) = 1;
          V_LOCK();
          logfmt_raw(
            v9,
            0x1000u,
            0,
            "chip %02x core %02x addr %04x, %08x, cmn lock failed",
            v14[12 * k + 4],
            v14[12 * k + 8],
            112,
            *(_DWORD *)&v14[12 * k]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_ref_clock_ready_ext",
            25,
            8816,
            100,
            v9);
        }
      }
    }
    free(v14);
    free(v13);
  }
  if ( a5 )
  {
    for ( m = 0; m <= 7u; ++m )
    {
      for ( n = 0; n <= 15; ++n )
      {
        if ( n != 4 && n != 12 && *(_BYTE *)(a5 + n + 16 * m) )
          return -1;
      }
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C8A60) --------------------------------------------------------
int __fastcall check_bist_tx_running(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[12]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v10[12]; // [sp+5Ch] [bp+4Ch] BYREF
  _BYTE v11[16]; // [sp+105Ch] [bp+104Ch] BYREF
  int back; // [sp+106Ch] [bp+105Ch]
  int v13; // [sp+1070h] [bp+1060h]
  int k; // [sp+1074h] [bp+1064h]
  unsigned __int16 j; // [sp+107Ah] [bp+106Ah]
  int i; // [sp+107Ch] [bp+106Ch]
  unsigned __int8 v17; // [sp+1083h] [bp+1073h]
  int v18; // [sp+1084h] [bp+1074h]

  v18 = 1;
  if ( a3 == 255 )
    v18 = sub_7936C(v11);
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s phy_num %d...", "check_bist_tx_running", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_bist_tx_running",
    21,
    8878,
    60,
    v10);
  v17 = 0;
  v13 = 0;
  for ( i = 0; i < v18; ++i )
  {
    if ( a3 == 255 )
      v17 = v11[i];
    else
      v17 = a3;
    for ( j = 0; j < (unsigned int)a4; ++j )
    {
      if ( v17 != 3 || j > 3u )
      {
        back = serdes_apb_read_back(a1, a2, v17, (j << 12) | 0x4A, (int)v9);
        for ( k = 0; k < back; ++k )
        {
          if ( (*(_DWORD *)&v9[8 * k + 4] & 0x200) != 0 )
          {
            V_LOCK();
            logfmt_raw(
              v10,
              0x1000u,
              0,
              "channel %1x, chip_id %02x core_id %02x tx bist is running",
              j,
              (unsigned __int8)v9[8 * k],
              (unsigned __int8)v9[8 * k + 1]);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
              83,
              "check_bist_tx_running",
              21,
              8896,
              20,
              v10);
          }
          else
          {
            V_LOCK();
            logfmt_raw(
              v10,
              0x1000u,
              0,
              "channel %1x, chip_id %02x core_id %02x %08x tx bist run failed",
              j,
              (unsigned __int8)v9[8 * k],
              (unsigned __int8)v9[8 * k + 1],
              *(_DWORD *)&v9[8 * k + 4]);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
              83,
              "check_bist_tx_running",
              21,
              8899,
              100,
              v10);
          }
        }
      }
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C8E18) --------------------------------------------------------
int __fastcall check_bist_tx_running_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[8]; // [sp+18h] [bp+8h] BYREF
  int v10; // [sp+1018h] [bp+1008h] BYREF
  int back; // [sp+1058h] [bp+1048h]
  int i; // [sp+105Ch] [bp+104Ch]
  int v13; // [sp+1060h] [bp+1050h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s...", "check_bist_tx_running_one_lane");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_bist_tx_running_one_lane",
    30,
    8910,
    60,
    v9);
  back = serdes_apb_read_back(a1, a2, a3, (a4 << 12) | 0x4A, (int)&v10);
  for ( i = 0; i < back; ++i )
  {
    if ( (*(&v13 + 2 * i - 17) & 0x200) != 0 )
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "channel %1x, chip_id %02x core_id %02x tx bist is running",
        a4,
        *((unsigned __int8 *)&v13 + 8 * i - 72),
        *((unsigned __int8 *)&v13 + 8 * i - 71));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_bist_tx_running_one_lane",
        30,
        8916,
        60,
        v9);
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "channel %1x, chip_id %02x core_id %02x %08x tx bist run failed",
        a4,
        *((unsigned __int8 *)&v13 + 8 * i - 72),
        *((unsigned __int8 *)&v13 + 8 * i - 71),
        *(&v13 + 2 * i - 17));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_bist_tx_running_one_lane",
        30,
        8919,
        100,
        v9);
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C90B8) --------------------------------------------------------
int __fastcall check_bist_rx_running(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[12]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v10[12]; // [sp+5Ch] [bp+4Ch] BYREF
  int back; // [sp+105Ch] [bp+104Ch]
  int k; // [sp+1060h] [bp+1050h]
  unsigned __int16 j; // [sp+1064h] [bp+1054h]
  unsigned __int8 i; // [sp+1066h] [bp+1056h]
  unsigned __int8 v15; // [sp+1067h] [bp+1057h]

  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s...", "check_bist_rx_running");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_bist_rx_running",
    21,
    8928,
    60,
    v10);
  v15 = 16;
  if ( a3 != 255 )
    v15 = 1;
  for ( i = 0; i < (unsigned int)v15; ++i )
  {
    if ( a3 != 255 )
      i = a3;
    for ( j = 0; j < (unsigned int)a4; ++j )
    {
      back = serdes_apb_read_back(a1, a2, i, (j << 12) | 0x11, (int)v9);
      for ( k = 0; k < back; ++k )
      {
        if ( (*(_DWORD *)&v9[8 * k + 4] & 0x400) != 0 || (*(_DWORD *)&v9[8 * k + 4] & 0x8000000) == 0 )
        {
          V_LOCK();
          logfmt_raw(
            v10,
            0x1000u,
            0,
            "channel %1x, chip_id %02x core_id %02x %08x rx bist run failed",
            j,
            (unsigned __int8)v9[8 * k],
            (unsigned __int8)v9[8 * k + 1],
            v9);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_bist_rx_running",
            21,
            8945,
            100,
            v10);
        }
        else
        {
          V_LOCK();
          logfmt_raw(
            v10,
            0x1000u,
            0,
            "channel %1x, chip_id %02x core_id %02x rx bist is running",
            j,
            (unsigned __int8)v9[8 * k],
            (unsigned __int8)v9[8 * k + 1]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_bist_rx_running",
            21,
            8942,
            60,
            v10);
        }
      }
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C940C) --------------------------------------------------------
int __fastcall check_bist_rx_running_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[8]; // [sp+18h] [bp+8h] BYREF
  int v10; // [sp+1018h] [bp+1008h] BYREF
  int back; // [sp+1058h] [bp+1048h]
  int i; // [sp+105Ch] [bp+104Ch]
  int v13; // [sp+1060h] [bp+1050h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s...", "check_bist_rx_running_one_lane");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_bist_rx_running_one_lane",
    30,
    8956,
    60,
    v9);
  back = serdes_apb_read_back(a1, a2, a3, (a4 << 12) | 0x11, (int)&v10);
  for ( i = 0; i < back; ++i )
  {
    if ( (*(&v13 + 2 * i - 17) & 0x400) != 0 || (*(&v13 + 2 * i - 17) & 0x8000000) == 0 )
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "channel %1x, chip_id %02x core_id %02x rx bist run failed",
        a4,
        *((unsigned __int8 *)&v13 + 8 * i - 72),
        *((unsigned __int8 *)&v13 + 8 * i - 71));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_bist_rx_running_one_lane",
        30,
        8965,
        100,
        v9);
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "channel %1x, chip_id %02x core_id %02x rx bist is running",
        a4,
        *((unsigned __int8 *)&v13 + 8 * i - 72),
        *((unsigned __int8 *)&v13 + 8 * i - 71));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_bist_rx_running_one_lane",
        30,
        8962,
        60,
        v9);
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C96B0) --------------------------------------------------------
int __fastcall check_bist_done(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v10[8]; // [sp+58h] [bp+48h] BYREF
  _BYTE v11[16]; // [sp+1058h] [bp+1048h] BYREF
  int back; // [sp+1068h] [bp+1058h]
  int k; // [sp+106Ch] [bp+105Ch]
  unsigned __int16 j; // [sp+1072h] [bp+1062h]
  int i; // [sp+1074h] [bp+1064h]
  unsigned __int8 v16; // [sp+107Bh] [bp+106Bh]
  int v17; // [sp+107Ch] [bp+106Ch]

  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s...", "check_bist_done");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_bist_done",
    15,
    8974,
    60,
    v10);
  v17 = 1;
  if ( a3 == 255 )
    v17 = sub_7936C(v11);
  v16 = 0;
  for ( i = 0; i < v17; ++i )
  {
    if ( a3 == 255 )
      v16 = v11[i];
    else
      v16 = a3;
    for ( j = 0; j < (unsigned int)a4; ++j )
    {
      if ( v16 != 3 || j > 3u )
      {
        back = serdes_apb_read_back(a1, a2, v16, (j << 12) | 0x11, (int)v9);
        for ( k = 0; k < back; ++k )
        {
          if ( (*(_DWORD *)&v9[8 * k + 4] & 0x20000) != 0 || (*(_DWORD *)&v9[8 * k + 4] & 0x400) == 0 )
          {
            V_LOCK();
            logfmt_raw(
              v10,
              0x1000u,
              0,
              "chain %d channel %1x, chip_id %02x core_id %02x bist error",
              *(_DWORD *)(a1 + 136),
              j,
              (unsigned __int8)v9[8 * k],
              (unsigned __int8)v9[8 * k + 1]);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
              83,
              "check_bist_done",
              15,
              8996,
              100,
              v10);
          }
        }
      }
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C99D0) --------------------------------------------------------
int __fastcall check_bist_done_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[8]; // [sp+18h] [bp+8h] BYREF
  int v10; // [sp+1018h] [bp+1008h] BYREF
  int back; // [sp+1058h] [bp+1048h]
  int i; // [sp+105Ch] [bp+104Ch]
  int v13; // [sp+1060h] [bp+1050h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s...", "check_bist_done_one_lane");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_bist_done_one_lane",
    24,
    9007,
    60,
    v9);
  back = serdes_apb_read_back(a1, a2, a3, (a4 << 12) | 0x11, (int)&v10);
  for ( i = 0; i < back; ++i )
  {
    if ( (*(&v13 + 2 * i - 17) & 0x20000) != 0 || (*(&v13 + 2 * i - 17) & 0x400) == 0 )
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "channel %1x, chip_id %02x core_id %02x bist error",
        a4,
        *((unsigned __int8 *)&v13 + 8 * i - 72),
        *((unsigned __int8 *)&v13 + 8 * i - 71));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_bist_done_one_lane",
        24,
        9016,
        100,
        v9);
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "channel %1x, chip_id %02x core_id %02x bist done",
        a4,
        *((unsigned __int8 *)&v13 + 8 * i - 72),
        *((unsigned __int8 *)&v13 + 8 * i - 71));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_bist_done_one_lane",
        24,
        9013,
        60,
        v9);
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C9C74) --------------------------------------------------------
int __fastcall sub_C9C74(int a1, int a2, unsigned __int8 a3, _DWORD *a4)
{
  int v7; // [sp+24h] [bp+14h] BYREF
  int i; // [sp+1024h] [bp+1014h]

  for ( i = 0; i < a2; ++i )
  {
    if ( a3 == *(unsigned __int8 *)(a1 + 8 * i + 1) )
    {
      *a4 = *(_DWORD *)(a1 + 8 * i + 4);
      return 0;
    }
  }
  V_LOCK();
  logfmt_raw(&v7, 0x1000u, 0, "%s %d data not found!", "get_the_core_data", a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "get_the_core_data",
    17,
    9031,
    100,
    &v7);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000C9DA0) --------------------------------------------------------
int __fastcall check_bist_error(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _DWORD v9[8]; // [sp+34h] [bp+14h] BYREF
  int v10; // [sp+54h] [bp+34h] BYREF
  _BYTE v11[76]; // [sp+1054h] [bp+1034h] BYREF
  int v12; // [sp+10A4h] [bp+1084h] BYREF
  _BYTE v13[60]; // [sp+10E4h] [bp+10C4h] BYREF
  int v14; // [sp+1124h] [bp+1104h] BYREF
  int v15; // [sp+1164h] [bp+1144h]
  unsigned __int8 v16; // [sp+116Bh] [bp+114Bh]
  int v17; // [sp+116Ch] [bp+114Ch]
  int back; // [sp+1170h] [bp+1150h]
  int jj; // [sp+1174h] [bp+1154h]
  int ii; // [sp+1178h] [bp+1158h]
  int n; // [sp+117Ch] [bp+115Ch]
  int m; // [sp+1180h] [bp+1160h]
  int k; // [sp+1184h] [bp+1164h]
  unsigned __int16 j; // [sp+118Ah] [bp+116Ah]
  int i; // [sp+118Ch] [bp+116Ch]
  unsigned __int8 v26; // [sp+1193h] [bp+1173h]
  int v27; // [sp+1194h] [bp+1174h]
  int v28; // [sp+1198h] [bp+1178h] BYREF

  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s...", "check_bist_error");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_bist_error",
    16,
    9038,
    60,
    &v10);
  v27 = 1;
  memset(v11, 0, 0x10u);
  if ( a3 == 255 )
    v27 = sub_7936C(v11);
  v26 = 0;
  back = 0;
  for ( i = 0; i < v27; ++i )
  {
    if ( a3 == 255 )
      v26 = v11[i];
    else
      v26 = a3;
    for ( j = 0; j < (unsigned int)a4; ++j )
    {
      if ( v26 != 3 || j > 3u )
      {
        back = serdes_apb_read_back(a1, a2, v26, (j << 12) | 0x10, (int)&v14);
        if ( *(_DWORD *)(a1 + 236) != back )
        {
          V_LOCK();
          logfmt_raw(
            &v10,
            0x1000u,
            0,
            "%s d'16 resp_num is not enough(%d<%d), bist err",
            "check_bist_error",
            back,
            *(_DWORD *)(a1 + 236));
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_bist_error",
            16,
            9064,
            100,
            &v10);
        }
        back = serdes_apb_read_back(a1, a2, v26, (j << 12) | 0x13, (int)v13);
        if ( *(_DWORD *)(a1 + 236) == back )
        {
          for ( k = 0; k < back; ++k )
            *(_DWORD *)&v11[8 * k + 20] = (unsigned int)*(&v28 + 2 * k - 44) >> 28;
          back = serdes_apb_read_back(a1, a2, v26, (j << 12) | 0x14, (int)v13);
          if ( *(_DWORD *)(a1 + 236) == back )
          {
            for ( m = 0; m < back; ++m )
              *(_DWORD *)&v11[8 * m + 20] |= 16 * *(&v28 + 2 * m - 44);
            back = serdes_apb_read_back(a1, a2, v26, (j << 12) | 0x15, (int)&v12);
            if ( *(_DWORD *)(a1 + 236) == back )
            {
              v17 = 0;
              for ( n = 0; n < back; ++n )
              {
                if ( (*(&v28 + 2 * n - 28) & 0xE000000) != 0 )
                {
                  v16 = *((_BYTE *)&v28 + 8 * n - 116);
                  V_LOCK();
                  logfmt_raw(
                    &v10,
                    0x1000u,
                    0,
                    "chain %d channel %1x, chip_id %02x c_id %02x bist err(%02x) cnt %08x %08x",
                    *(_DWORD *)(a1 + 136),
                    j,
                    v16,
                    *((unsigned __int8 *)&v28 + 8 * n - 115),
                    ((unsigned int)*(&v28 + 2 * n - 28) >> 25) & 7,
                    *(&v28 + 2 * v16 - 60),
                    *(_DWORD *)&v11[8 * v16 + 20]);
                  V_UNLOCK();
                  zlog(
                    g_zc,
                    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
                    83,
                    "check_bist_error",
                    16,
                    9095,
                    100,
                    &v10);
                  memset(v9, 0, sizeof(v9));
                  v15 = serdes_apb_read_back(a1, v16, *((_BYTE *)&v28 + 8 * n - 115), (j << 12) | 0x16, (int)v13);
                  for ( ii = 0; ii < v15; ++ii )
                    v9[ii] = (unsigned int)*(&v28 + 2 * ii - 44) >> 12;
                  v15 = serdes_apb_read_back(a1, v16, *((_BYTE *)&v28 + 8 * n - 115), (j << 12) | 0x17, (int)v13);
                  for ( jj = 0; jj < v15; ++jj )
                  {
                    v9[jj] |= *(&v28 + 2 * jj - 44) << 20;
                    if ( *((unsigned __int8 *)&v28 + 8 * jj - 180) == *((unsigned __int8 *)&v28 + 8 * n - 116) )
                    {
                      V_LOCK();
                      logfmt_raw(
                        &v10,
                        0x1000u,
                        0,
                        "chain %d channel %1x, chip_id %02x c_id %02x sample_cnt %08x",
                        *(_DWORD *)(a1 + 136),
                        j,
                        *((unsigned __int8 *)&v28 + 8 * jj - 180),
                        *((unsigned __int8 *)&v28 + 8 * jj - 179),
                        v9[jj]);
                      V_UNLOCK();
                      zlog(
                        g_zc,
                        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
                        83,
                        "check_bist_error",
                        16,
                        9110,
                        60,
                        &v10);
                    }
                  }
                }
              }
            }
            else
            {
              V_LOCK();
              logfmt_raw(
                &v10,
                0x1000u,
                0,
                "%s d'21 resp_num is not enough(%d<%d), bist err",
                "check_bist_error",
                back,
                *(_DWORD *)(a1 + 236));
              V_UNLOCK();
              zlog(
                g_zc,
                "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
                83,
                "check_bist_error",
                16,
                9086,
                100,
                &v10);
            }
          }
          else
          {
            V_LOCK();
            logfmt_raw(
              &v10,
              0x1000u,
              0,
              "%s d'20 resp_num is not enough(%d<%d), bist err",
              "check_bist_error",
              back,
              *(_DWORD *)(a1 + 236));
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
              83,
              "check_bist_error",
              16,
              9078,
              100,
              &v10);
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(
            &v10,
            0x1000u,
            0,
            "%s d'19 resp_num is not enough(%d<%d), bist err",
            "check_bist_error",
            back,
            *(_DWORD *)(a1 + 236));
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "check_bist_error",
            16,
            9070,
            100,
            &v10);
        }
      }
    }
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CA818) --------------------------------------------------------
int __fastcall check_bist_error_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[24]; // [sp+20h] [bp+8h] BYREF
  _DWORD v10[22]; // [sp+1020h] [bp+1008h] BYREF
  int v11; // [sp+1080h] [bp+1068h] BYREF
  _BYTE v12[56]; // [sp+10C0h] [bp+10A8h] BYREF
  int v13; // [sp+1100h] [bp+10E8h] BYREF
  int back; // [sp+1140h] [bp+1128h]
  int n; // [sp+1144h] [bp+112Ch]
  int m; // [sp+1148h] [bp+1130h]
  int k; // [sp+114Ch] [bp+1134h]
  int j; // [sp+1150h] [bp+1138h]
  int i; // [sp+1154h] [bp+113Ch]
  _BYTE v20[4]; // [sp+1158h] [bp+1140h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s...", "check_bist_error_one_lane");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_bist_error_one_lane",
    25,
    9123,
    60,
    v9);
  back = serdes_apb_read_back(a1, a2, a3, (a4 << 12) | 0x10, (int)&v13);
  if ( *(_DWORD *)(a1 + 236) != back )
  {
    V_LOCK();
    logfmt_raw(
      v9,
      0x1000u,
      0,
      "%s d'16 resp_num is not enough(%d<%d), bist err",
      "check_bist_error_one_lane",
      back,
      *(_DWORD *)(a1 + 236));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_bist_error_one_lane",
      25,
      9131,
      100,
      v9);
  }
  back = serdes_apb_read_back(a1, a2, a3, (a4 << 12) | 0x13, (int)v12);
  if ( *(_DWORD *)(a1 + 236) != back )
  {
    V_LOCK();
    logfmt_raw(
      v9,
      0x1000u,
      0,
      "%s d'19 resp_num is not enough(%d<%d), bist err",
      "check_bist_error_one_lane",
      back,
      *(_DWORD *)(a1 + 236));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_bist_error_one_lane",
      25,
      9137,
      100,
      v9);
  }
  for ( i = 0; i < back; ++i )
    v10[2 * i + 9] = *(_DWORD *)&v20[8 * i - 148] >> 28;
  back = serdes_apb_read_back(a1, a2, a3, (a4 << 12) | 0x14, (int)v12);
  if ( *(_DWORD *)(a1 + 236) != back )
  {
    V_LOCK();
    logfmt_raw(
      v9,
      0x1000u,
      0,
      "%s d'19 resp_num is not enough(%d<%d), bist err",
      "check_bist_error_one_lane",
      back,
      *(_DWORD *)(a1 + 236));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_bist_error_one_lane",
      25,
      9143,
      100,
      v9);
  }
  for ( j = 0; j < back; ++j )
    v10[2 * j + 9] |= 16 * *(_DWORD *)&v20[8 * j - 148];
  back = serdes_apb_read_back(a1, a2, a3, (a4 << 12) | 0x15, (int)&v11);
  if ( *(_DWORD *)(a1 + 236) != back )
  {
    V_LOCK();
    logfmt_raw(
      v9,
      0x1000u,
      0,
      "%s d'19 resp_num is not enough(%d<%d), bist err",
      "check_bist_error_one_lane",
      back,
      *(_DWORD *)(a1 + 236));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_bist_error_one_lane",
      25,
      9149,
      100,
      v9);
  }
  for ( k = 0; k < back; ++k )
  {
    if ( (*(_DWORD *)&v20[8 * k - 84] & 0xE000000) != 0 )
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "channel %1x, chip_id %02x core_id %02x bist err(%02x) cnt %08x %08x",
        a4,
        (unsigned __int8)v20[8 * k - 88],
        (unsigned __int8)v20[8 * k - 87],
        (*(_DWORD *)&v20[8 * k - 84] >> 25) & 7,
        *(_DWORD *)&v20[8 * k - 212],
        v10[2 * k + 9]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_bist_error_one_lane",
        25,
        9154,
        60,
        v9);
    }
    else
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "channel %1x, chip_id %02x core_id %02x bist ok",
        a4,
        (unsigned __int8)v20[8 * k - 88],
        (unsigned __int8)v20[8 * k - 87]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_bist_error_one_lane",
        25,
        9157,
        60,
        v9);
    }
  }
  memset(v10, 0, 0x20u);
  back = serdes_apb_read_back(a1, a2, a3, (a4 << 12) | 0x16, (int)v12);
  for ( m = 0; m < back; ++m )
    v10[m] = *(_DWORD *)&v20[8 * m - 148] >> 12;
  back = serdes_apb_read_back(a1, a2, a3, (a4 << 12) | 0x17, (int)v12);
  for ( n = 0; n < back; ++n )
  {
    v10[n] |= *(_DWORD *)&v20[8 * n - 148] << 20;
    V_LOCK();
    logfmt_raw(
      v9,
      0x1000u,
      0,
      "channel %1x, chip_id %02x core_id %02x sample_cnt %08x",
      a4,
      (unsigned __int8)v20[8 * n - 152],
      (unsigned __int8)v20[8 * n - 151],
      v10[n]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_bist_error_one_lane",
      25,
      9169,
      60,
      v9);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CB128) --------------------------------------------------------
int __fastcall config_rxifrx_sigdet_ovr(int a1, unsigned __int8 a2, char a3, char a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "config_rxifrx_sigdet_ovr");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "config_rxifrx_sigdet_ovr",
    24,
    9177,
    60,
    &v9);
  v10 = 0;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -134217729);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x99, 0x8000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x7F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CB310) --------------------------------------------------------
int __fastcall config_rxifrx_sigdet_ovr_one_lane(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4)
{
  _BYTE v9[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s...", "config_rxifrx_sigdet_ovr_one_lane");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "config_rxifrx_sigdet_ovr_one_lane",
    33,
    9193,
    60,
    v9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -134217729);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x99, 0x8000000);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x7F, 0x80000000);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CB4C8) --------------------------------------------------------
int __fastcall enable_rxbist_autostop(int a1, unsigned __int8 a2, char a3, char a4, char a5)
{
  _BYTE v10[8]; // [sp+18h] [bp+8h] BYREF
  int v11; // [sp+1018h] [bp+1008h]
  __int16 v12; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s...", "enable_rxbist_autostop");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "enable_rxbist_autostop",
    22,
    9205,
    60,
    v10);
  v11 = ((a5 & 0x3F) << 20) & 0x3F00000;
  v12 = 0;
  if ( a4 == 8 )
    v12 = 15;
  serdes_apb_write(a1, a2, a3, (v12 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (v12 << 12) | 0x11, 4);
  serdes_apb_write(a1, a2, a3, (v12 << 12) | 1, -66060289);
  serdes_apb_write(a1, a2, a3, (v12 << 12) | 0x13, v11);
  serdes_apb_write(a1, a2, a3, (v12 << 12) | 1, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CB6D0) --------------------------------------------------------
int __fastcall enable_rxbist_autostop_one_lane(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4, char a5)
{
  int v10; // [sp+1Ch] [bp+Ch] BYREF
  int v11; // [sp+101Ch] [bp+100Ch]

  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s...", "enable_rxbist_autostop_one_lane");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "enable_rxbist_autostop_one_lane",
    31,
    9222,
    60,
    &v10);
  v11 = ((a5 & 0x3F) << 20) & 0x3F00000;
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -5);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x11, 4);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -66060289);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x13, v11);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CB8A8) --------------------------------------------------------
int __fastcall read_rx_debug_reg2(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int16 i; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s...", "read_rx_debug_reg2");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "read_rx_debug_reg2",
    18,
    9237,
    60,
    &v9);
  for ( i = 0; i < (unsigned int)a4; ++i )
  {
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x16, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x16, 8);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x16, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x16, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x16, 8);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x16, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x16, 0);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x16, 8);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (i << 12) | 0x16, 0);
    serdes_apb_read(a1, a2, a3, (i << 12) | 0x1A);
    serdes_apb_write(a1, a2, a3, (i << 12) | 1, 0);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CBE60) --------------------------------------------------------
int __fastcall read_rx_debug_reg2_one_lane(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4)
{
  _BYTE v9[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s...", "read_rx_debug_reg2_one_lane");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "read_rx_debug_reg2_one_lane",
    27,
    9268,
    60,
    v9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x16, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x16, 8);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x16, 0);
  serdes_apb_read(a1, a2, a3, (a4 << 12) | 0x1A);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x16, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x16, 8);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x16, 0);
  serdes_apb_read(a1, a2, a3, (a4 << 12) | 0x1A);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x16, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x16, 8);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x16, 0);
  serdes_apb_read(a1, a2, a3, (a4 << 12) | 0x1A);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CC3AC) --------------------------------------------------------
int __fastcall serdes_phy_bist_internal_serial(int a1, unsigned __int8 a2, char a3, char a4, char a5)
{
  _DWORD v10[1025]; // [sp+18h] [bp+8h] BYREF
  __int16 v11; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s...", "serdes_phy_bist_internal_serial");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_internal_serial",
    31,
    9297,
    60,
    v10);
  v11 = 0;
  if ( a4 == 8 )
    v11 = 15;
  v10[1024] = a5 & 7
            | ((a5 & 7) << 28)
            | ((a5 & 7) << 24)
            | ((a5 & 7) << 20)
            | ((a5 & 7) << 16)
            | ((a5 & 7) << 12)
            | ((a5 & 7) << 8)
            | (16 * (a5 & 7));
  sub_789C4(
    a1,
    a3,
    97,
    a5 & 7
  | (((a5 & 7) << 28)
   | ((a5 & 7) << 24)
   | ((a5 & 7) << 20)
   | ((a5 & 7) << 16)
   | ((a5 & 7) << 12)
   | ((a5 & 7) << 8)
   | (16 * (a5 & 7)))
  & 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x12, 2 * (a5 & 7));
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  sub_789C4(a1, a3, 98, 255);
  check_bist_tx_running(a1, a2, a3, a4);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -13);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0xE, 12);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  config_rxifrx_sigdet_ovr(a1, a2, a3, a4);
  read_rx_debug_reg2(a1, a2, a3, a4);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x91, 8);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -1073741825);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x77, 0x40000000);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  usleep((__useconds_t)&stru_1869C.st_value);
  check_bist_rx_running(a1, a2, a3, a4);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x91, 0);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  check_ref_clock_ready(a1, a2, a3);
  check_bist_done(a1, a2, a3, a4);
  check_bist_error(a1, a2, a3, a4);
  enable_rx_equalizer_tuning(a1, a2, a3, a4);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x91, 8);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -1073741825);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x77, 0x40000000);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  usleep((__useconds_t)&stru_1869C.st_value);
  check_bist_rx_running(a1, a2, a3, a4);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x91, 0);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  sub_789C4(a1, a3, 98, 0);
  check_ref_clock_ready(a1, a2, a3);
  check_bist_done(a1, a2, a3, a4);
  check_bist_error(a1, a2, a3, a4);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CCC0C) --------------------------------------------------------
int __fastcall serdes_phy_bist_internal_digital(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4, char a5)
{
  _DWORD v10[1025]; // [sp+18h] [bp+8h] BYREF
  __int16 v11; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s...", "serdes_phy_bist_internal_digital");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_internal_digital",
    32,
    9419,
    60,
    v10);
  v11 = 0;
  if ( a4 == 8 )
    v11 = 15;
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -521);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x49, 520);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  v10[1024] = a5 & 7
            | ((a5 & 7) << 28)
            | ((a5 & 7) << 24)
            | ((a5 & 7) << 20)
            | ((a5 & 7) << 16)
            | ((a5 & 7) << 12)
            | ((a5 & 7) << 8)
            | (16 * (a5 & 7));
  sub_789C4(
    a1,
    a3,
    97,
    a5 & 7
  | (((a5 & 7) << 28)
   | ((a5 & 7) << 24)
   | ((a5 & 7) << 20)
   | ((a5 & 7) << 16)
   | ((a5 & 7) << 12)
   | ((a5 & 7) << 8)
   | (16 * (a5 & 7)))
  & 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x12, 2 * (a5 & 7));
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  sub_789C4(a1, a3, 98, 255);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x91, 8);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -1073741825);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x77, 0x40000000);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  usleep((__useconds_t)&stru_1869C.st_value);
  check_bist_tx_running(a1, a2, a3, a4);
  check_bist_rx_running(a1, a2, a3, a4);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, -9);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 0x91, 0);
  serdes_apb_write(a1, a2, a3, (v11 << 12) | 1, 0);
  sub_789C4(a1, a3, 98, 0);
  check_ref_clock_ready(a1, a2, a3);
  check_bist_done(a1, a2, a3, a4);
  check_bist_error(a1, a2, a3, a4);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CD190) --------------------------------------------------------
int __fastcall serdes_phy_bist_external(int a1, unsigned __int8 a2, char a3, unsigned __int8 a4, char a5, int a6)
{
  const char *v6; // r3
  _BYTE v12[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v13[2]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int j; // [sp+1024h] [bp+1014h]
  unsigned int i; // [sp+1028h] [bp+1018h]
  __int16 v16; // [sp+102Eh] [bp+101Eh]

  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "%s...", "serdes_phy_bist_external");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external",
    24,
    9489,
    60,
    v12);
  v16 = 0;
  if ( a4 == 8 )
    v16 = 15;
  v13[1] = a5 & 7
         | ((a5 & 7) << 28)
         | ((a5 & 7) << 24)
         | ((a5 & 7) << 20)
         | ((a5 & 7) << 16)
         | ((a5 & 7) << 12)
         | ((a5 & 7) << 8)
         | (16 * (a5 & 7));
  sub_789C4(
    a1,
    a3,
    97,
    a5 & 7
  | (((a5 & 7) << 28)
   | ((a5 & 7) << 24)
   | ((a5 & 7) << 20)
   | ((a5 & 7) << 16)
   | ((a5 & 7) << 12)
   | ((a5 & 7) << 8)
   | (16 * (a5 & 7)))
  & 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v16 << 12) | 0x12, 2 * (a5 & 7));
  serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, 0);
  V_LOCK();
  if ( a5 )
    v6 = "prbs";
  else
    v6 = "clock";
  logfmt_raw(v12, 0x1000u, 0, "test %d %s...", a6, v6);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external",
    24,
    9512,
    60,
    v12);
  if ( a6 > 2 )
  {
    sub_789C4(a1, a3, 98, 255);
    read_rx_debug_reg2(a1, a2, a3, a4);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, -2);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 0x91, 1);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, -4194305);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 0x77, 0x400000);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, 0);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 0x91, 8);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, -1073741825);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 0x77, 0x40000000);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, 0);
    check_bist_tx_running(a1, a2, a3, a4);
    check_bist_rx_running(a1, a2, a3, a4);
    usleep(0x493E0u);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 0x91, 0);
    serdes_apb_write(a1, a2, a3, (v16 << 12) | 1, 0);
    sub_789C4(a1, a3, 98, 0);
    check_ref_clock_ready(a1, a2, a3);
    check_bist_done(a1, a2, a3, a4);
    check_bist_error(a1, a2, a3, a4);
  }
  else
  {
    v13[0] = 336529925;
    sub_789C4(a1, a3, 98, 16);
    for ( i = 0; i <= 3; ++i )
    {
      enable_rxbist_autostop_one_lane(a1, a2, a3, 7u, *((_BYTE *)v13 + i));
      read_rx_debug_reg2_one_lane(a1, a2, a3, 4u);
      read_rx_debug_reg2_one_lane(a1, a2, a3, 7u);
      serdes_apb_write(a1, a2, a3, 0x7001u, -9);
      serdes_apb_write(a1, a2, a3, 0x7091u, 8);
      serdes_apb_write(a1, a2, a3, 0x7001u, -1073741825);
      serdes_apb_write(a1, a2, a3, 0x7077u, 0x40000000);
      serdes_apb_write(a1, a2, a3, 0x7001u, 0);
      usleep(0xF4240u);
      check_bist_tx_running_one_lane(a1, a2, a3, 4u);
      check_bist_rx_running_one_lane(a1, a2, a3, 7u);
      usleep(0x493E0u);
      serdes_apb_write(a1, a2, a3, 0x7001u, -9);
      serdes_apb_write(a1, a2, a3, 0x7091u, 0);
      serdes_apb_write(a1, a2, a3, 0x7001u, 0);
      check_ref_clock_ready(a1, a2, a3);
      check_bist_done_one_lane(a1, a2, a3, 4u);
      check_bist_done_one_lane(a1, a2, a3, 7u);
      check_bist_error_one_lane(a1, a2, a3, 7u);
    }
    sub_789C4(a1, a3, 98, 0);
    sub_789C4(a1, 3, 83, 0);
    sub_789C4(a1, a3, 98, 128);
    for ( j = 0; j <= 3; ++j )
    {
      enable_rxbist_autostop_one_lane(a1, a2, a3, 7u, *((_BYTE *)v13 + j));
      serdes_apb_write(a1, a2, a3, 0x7001u, -13);
      serdes_apb_write(a1, a2, a3, 0x700Eu, 12);
      serdes_apb_write(a1, a2, a3, 0x7001u, 0);
      config_rxifrx_sigdet_ovr_one_lane(a1, a2, a3, 7u);
      read_rx_debug_reg2_one_lane(a1, a2, a3, 7u);
      serdes_apb_write(a1, a2, a3, 0x7001u, -9);
      serdes_apb_write(a1, a2, a3, 0x7091u, 8);
      serdes_apb_write(a1, a2, a3, 0x7001u, -1073741825);
      serdes_apb_write(a1, a2, a3, 0x7077u, 0x40000000);
      serdes_apb_write(a1, a2, a3, 0x7001u, 0);
      usleep(0xF4240u);
      check_bist_tx_running_one_lane(a1, a2, a3, 7u);
      check_bist_rx_running_one_lane(a1, a2, a3, 7u);
      usleep(0x493E0u);
      serdes_apb_write(a1, a2, a3, 0x7001u, -9);
      serdes_apb_write(a1, a2, a3, 0x7091u, 0);
      serdes_apb_write(a1, a2, a3, 0x7001u, 0);
      check_ref_clock_ready(a1, a2, a3);
      check_bist_done_one_lane(a1, a2, a3, 7u);
      check_bist_error_one_lane(a1, a2, a3, 7u);
    }
    sub_789C4(a1, a3, 98, 0);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CDE84) --------------------------------------------------------
int __fastcall div2_seq(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "div2_seq", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "div2_seq",
    8,
    9778,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, -859045888);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65536);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 52428);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, -859832320);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1048576);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8D, 838860);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8D, -872415232);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16777216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8E, 13421772);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 4095);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8A, -858996736);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 3276);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CE3A4) --------------------------------------------------------
int __fastcall div4_seq(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "div4_seq", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "div4_seq",
    8,
    9809,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, -252706816);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65536);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 61680);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 251658240);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1048576);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8D, 986895);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8D, -268435456);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16777216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8E, 15790320);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 4095);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8A, 252641280);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 3855);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CE8C0) --------------------------------------------------------
int __fastcall div8_seq(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "div8_seq", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "div8_seq",
    8,
    9840,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, -16777216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65536);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 65280);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, -268435456);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1048576);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8D, 1044495);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8D, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16777216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8E, 16711935);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 4095);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8A, 267386880);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 4080);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CEDD0) --------------------------------------------------------
int __fastcall div32_20210813_500M(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v10; // [sp+101Eh] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v9, 0x1000u, 0, "%s chip_id %02x core_id %02x", "div32_20210813_500M", a2, a3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "div32_20210813_500M",
    19,
    9871,
    60,
    &v9);
  v10 = a4;
  if ( a4 == 8 )
    v10 = 15;
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, -65536);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -65536);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8C, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -1048576);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8D, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8D, -16777216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -16777216);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8E, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 4095);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8A, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 0x8B, 0);
  serdes_apb_write(a1, a2, a3, (v10 << 12) | 1, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CF290) --------------------------------------------------------
int __fastcall div2_seq_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s chip_id %02x core_id %02x channel_id %02x", "div2_seq_one_lane", a2, a3, a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "div2_seq_one_lane",
    17,
    9907,
    60,
    v9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8B, -859045888);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -65536);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8C, 52428);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8C, -859832320);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -1048576);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8D, 838860);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8D, -872415232);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -16777216);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8E, 13421772);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 4095);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8A, -858996736);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8B, 3276);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CF768) --------------------------------------------------------
int __fastcall div4_seq_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s chip_id %02x core_id %02x channel_id %02x", "div4_seq_one_lane", a2, a3, a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "div4_seq_one_lane",
    17,
    9933,
    60,
    v9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8B, -252706816);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -65536);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8C, 61680);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8C, 251658240);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -1048576);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8D, 986895);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8D, -268435456);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -16777216);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8E, 15790320);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 4095);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8A, 252641280);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8B, 3855);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000CFC3C) --------------------------------------------------------
int __fastcall div8_seq_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s chip_id %02x core_id %02x channel_id %02x", "div8_seq_one_lane", a2, a3, a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "div8_seq_one_lane",
    17,
    9959,
    60,
    v9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8B, -16777216);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -65536);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8C, 65280);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8C, -268435456);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -1048576);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8D, 1044495);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8D, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -16777216);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8E, 16711935);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 4095);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8A, 267386880);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8B, 4080);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0);
  serdes_apb_write(a1, a2, a3, 0x8001u, 0);
  serdes_apb_write(a1, a2, a3, 0xA001u, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D0108) --------------------------------------------------------
int __fastcall div32_20210813_500M_one_lane(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  _BYTE v9[4100]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "%s chip_id %02x core_id %02x channel_id %02x", "div32_20210813_500M_one_lane", a2, a3, a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "div32_20210813_500M_one_lane",
    28,
    9985,
    60,
    v9);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8B, -65536);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -65536);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8C, 0xFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8C, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -1048576);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8D, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8D, -16777216);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -16777216);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8E, 0xFFFFFF);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 4095);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8A, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, -4096);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 0x8B, 0);
  serdes_apb_write(a1, a2, a3, (a4 << 12) | 1, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D0584) --------------------------------------------------------
int __fastcall sub_D0584(unsigned int a1, unsigned int a2)
{
  unsigned int v4; // [sp+4h] [bp+4h]
  int v5; // [sp+Ch] [bp+Ch]

  v4 = a1;
  v5 = 0;
  if ( !a1 )
    return 1;
  while ( 1 )
  {
    v4 /= a2;
    if ( !v4 )
      break;
    ++v5;
  }
  return v5;
}

//----- (000D05C4) --------------------------------------------------------
int __fastcall serdes_phy_bist_external_0811(
        int a1,
        unsigned __int8 a2,
        char a3,
        char a4,
        char a5,
        unsigned int a6,
        int a7)
{
  const char *v7; // r3
  _BYTE v13[24]; // [sp+18h] [bp+8h] BYREF
  int v14; // [sp+1018h] [bp+1008h] BYREF
  char v15; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 v16; // [sp+101Fh] [bp+100Fh]
  int v17; // [sp+1020h] [bp+1010h]
  unsigned int j; // [sp+1024h] [bp+1014h]
  unsigned int i; // [sp+1028h] [bp+1018h]
  __int16 v20; // [sp+102Eh] [bp+101Eh]

  V_LOCK();
  logfmt_raw(v13, 0x1000u, 0, "%s...", "serdes_phy_bist_external_0811");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external_0811",
    29,
    10029,
    60,
    v13);
  v20 = 0;
  if ( a4 == 8 )
    v20 = 15;
  v17 = a5 & 7
      | ((a5 & 7) << 28)
      | ((a5 & 7) << 24)
      | ((a5 & 7) << 20)
      | ((a5 & 7) << 16)
      | ((a5 & 7) << 12)
      | ((a5 & 7) << 8)
      | (16 * (a5 & 7));
  sub_789C4(
    a1,
    a3,
    97,
    a5 & 7
  | (((a5 & 7) << 28)
   | ((a5 & 7) << 24)
   | ((a5 & 7) << 20)
   | ((a5 & 7) << 16)
   | ((a5 & 7) << 12)
   | ((a5 & 7) << 8)
   | (16 * (a5 & 7)))
  & 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v20 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v20 << 12) | 0x12, 2 * (a5 & 7));
  serdes_apb_write(a1, a2, a3, (v20 << 12) | 1, 0);
  v16 = sub_D0584(a6, 2u);
  V_LOCK();
  if ( a5 )
    v7 = "prbs";
  else
    v7 = "clock";
  logfmt_raw(v13, 0x1000u, 0, "group %d test %d %s...", a7, v16, v7);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external_0811",
    29,
    10051,
    60,
    v13);
  switch ( a6 )
  {
    case 2u:
      if ( a7 )
        div2_seq_one_lane(a1, a2, a3, 4u);
      else
        div2_seq_one_lane(a1, a2, a3, 7u);
      break;
    case 4u:
      if ( a7 )
        div4_seq_one_lane(a1, a2, a3, 4u);
      else
        div4_seq_one_lane(a1, a2, a3, 7u);
      break;
    case 8u:
      if ( a7 )
        div8_seq_one_lane(a1, a2, a3, 4u);
      else
        div8_seq_one_lane(a1, a2, a3, 7u);
      break;
    case 0x20u:
      if ( a7 )
        div32_20210813_500M_one_lane(a1, a2, a3, 4u);
      else
        div32_20210813_500M_one_lane(a1, a2, a3, 7u);
      break;
    default:
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "do not set div_seq with testcase 4");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "serdes_phy_bist_external_0811",
        29,
        10074,
        60,
        v13);
      break;
  }
  v14 = 336529925;
  v15 = 28;
  if ( a7 )
    sub_789C4(a1, a3, 98, 16);
  else
    sub_789C4(a1, a3, 98, 128);
  for ( i = 0; i <= 4; ++i )
  {
    if ( a7 )
      enable_rxbist_autostop_one_lane(a1, a2, a3, 7u, *((_BYTE *)&v14 + i));
    else
      enable_rxbist_autostop_one_lane(a1, a2, a3, 4u, *((_BYTE *)&v14 + i));
    read_rx_debug_reg2_one_lane(a1, a2, a3, 4u);
    read_rx_debug_reg2_one_lane(a1, a2, a3, 7u);
    if ( a7 )
    {
      serdes_apb_write(a1, a2, a3, 0x7001u, -9);
      serdes_apb_write(a1, a2, a3, 0x7091u, 8);
      serdes_apb_write(a1, a2, a3, 0x7001u, -1073741825);
      serdes_apb_write(a1, a2, a3, 0x7077u, 0x40000000);
      serdes_apb_write(a1, a2, a3, 0x7001u, 0);
    }
    else
    {
      serdes_apb_write(a1, a2, a3, 0x4001u, -9);
      serdes_apb_write(a1, a2, a3, 0x4091u, 8);
      serdes_apb_write(a1, a2, a3, 0x4001u, -1073741825);
      serdes_apb_write(a1, a2, a3, 0x4077u, 0x40000000);
      serdes_apb_write(a1, a2, a3, 0x4001u, 0);
    }
    usleep(0xF4240u);
    if ( a7 )
    {
      check_bist_tx_running_one_lane(a1, a2, a3, 4u);
      check_bist_rx_running_one_lane(a1, a2, a3, 7u);
    }
    else
    {
      check_bist_tx_running_one_lane(a1, a2, a3, 7u);
      check_bist_rx_running_one_lane(a1, a2, a3, 4u);
    }
    usleep(0x493E0u);
    if ( a7 )
    {
      serdes_apb_write(a1, a2, a3, 0x7001u, -9);
      serdes_apb_write(a1, a2, a3, 0x7091u, 0);
      serdes_apb_write(a1, a2, a3, 0x7001u, 0);
    }
    else
    {
      serdes_apb_write(a1, a2, a3, 0x4001u, -9);
      serdes_apb_write(a1, a2, a3, 0x4091u, 0);
      serdes_apb_write(a1, a2, a3, 0x4001u, 0);
    }
    check_ref_clock_ready(a1, a2, a3);
    check_bist_done_one_lane(a1, a2, a3, 4u);
    check_bist_done_one_lane(a1, a2, a3, 7u);
    if ( a7 )
      check_bist_error_one_lane(a1, a2, a3, 7u);
    else
      check_bist_error_one_lane(a1, a2, a3, 4u);
  }
  if ( v16 == 4 )
  {
    if ( a7 )
      enable_rx_equalizer_tuning_one_lane(a1, a2, a3, 7u);
    else
      enable_rx_equalizer_tuning_one_lane(a1, a2, a3, 4u);
    for ( j = 0; j <= 4; ++j )
    {
      if ( a7 )
        enable_rxbist_autostop_one_lane(a1, a2, a3, 7u, *((_BYTE *)&v14 + j));
      else
        enable_rxbist_autostop_one_lane(a1, a2, a3, 4u, *((_BYTE *)&v14 + j));
      read_rx_debug_reg2_one_lane(a1, a2, a3, 4u);
      read_rx_debug_reg2_one_lane(a1, a2, a3, 7u);
      if ( a7 )
      {
        serdes_apb_write(a1, a2, a3, 0x7001u, -9);
        serdes_apb_write(a1, a2, a3, 0x7091u, 8);
        serdes_apb_write(a1, a2, a3, 0x7001u, -1073741825);
        serdes_apb_write(a1, a2, a3, 0x7077u, 0x40000000);
        serdes_apb_write(a1, a2, a3, 0x7001u, 0);
      }
      else
      {
        serdes_apb_write(a1, a2, a3, 0x4001u, -9);
        serdes_apb_write(a1, a2, a3, 0x4091u, 8);
        serdes_apb_write(a1, a2, a3, 0x4001u, -1073741825);
        serdes_apb_write(a1, a2, a3, 0x4077u, 0x40000000);
        serdes_apb_write(a1, a2, a3, 0x4001u, 0);
      }
      usleep(0xF4240u);
      if ( a7 )
      {
        check_bist_tx_running_one_lane(a1, a2, a3, 4u);
        check_bist_rx_running_one_lane(a1, a2, a3, 7u);
      }
      else
      {
        check_bist_tx_running_one_lane(a1, a2, a3, 7u);
        check_bist_rx_running_one_lane(a1, a2, a3, 4u);
      }
      usleep(0x493E0u);
      if ( a7 )
      {
        serdes_apb_write(a1, a2, a3, 0x7001u, -9);
        serdes_apb_write(a1, a2, a3, 0x7091u, 0);
        serdes_apb_write(a1, a2, a3, 0x7001u, 0);
      }
      else
      {
        serdes_apb_write(a1, a2, a3, 0x4001u, -9);
        serdes_apb_write(a1, a2, a3, 0x4091u, 0);
        serdes_apb_write(a1, a2, a3, 0x4001u, 0);
      }
      check_ref_clock_ready(a1, a2, a3);
      check_bist_done_one_lane(a1, a2, a3, 4u);
      check_bist_done_one_lane(a1, a2, a3, 7u);
      if ( a7 )
        check_bist_error_one_lane(a1, a2, a3, 7u);
      else
        check_bist_error_one_lane(a1, a2, a3, 4u);
    }
  }
  sub_789C4(a1, a3, 98, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D149C) --------------------------------------------------------
int __fastcall serdes_phy_bist_external_0811_all_lane(
        int a1,
        unsigned __int8 a2,
        char a3,
        char a4,
        char a5,
        unsigned int a6)
{
  const char *v6; // r3
  _BYTE v12[24]; // [sp+18h] [bp+8h] BYREF
  int v13; // [sp+1018h] [bp+1008h] BYREF
  char v14; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 v15; // [sp+101Fh] [bp+100Fh]
  int v16; // [sp+1020h] [bp+1010h]
  unsigned int j; // [sp+1024h] [bp+1014h]
  unsigned int i; // [sp+1028h] [bp+1018h]
  __int16 v19; // [sp+102Eh] [bp+101Eh]

  V_LOCK();
  logfmt_raw(v12, 0x1000u, 0, "%s...", "serdes_phy_bist_external_0811_all_lane");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external_0811_all_lane",
    38,
    10343,
    60,
    v12);
  v19 = 0;
  if ( a4 == 8 )
    v19 = 15;
  v16 = a5 & 7
      | ((a5 & 7) << 28)
      | ((a5 & 7) << 24)
      | ((a5 & 7) << 20)
      | ((a5 & 7) << 16)
      | ((a5 & 7) << 12)
      | ((a5 & 7) << 8)
      | (16 * (a5 & 7));
  sub_789C4(
    a1,
    a3,
    97,
    a5 & 7
  | (((a5 & 7) << 28)
   | ((a5 & 7) << 24)
   | ((a5 & 7) << 20)
   | ((a5 & 7) << 16)
   | ((a5 & 7) << 12)
   | ((a5 & 7) << 8)
   | (16 * (a5 & 7)))
  & 0x7FFFFFFF);
  serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, -15);
  serdes_apb_write(a1, a2, a3, (v19 << 12) | 0x12, 2 * (a5 & 7));
  serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, 0);
  v15 = sub_D0584(a6, 2u);
  V_LOCK();
  if ( a5 )
    v6 = "prbs";
  else
    v6 = "clock";
  logfmt_raw(v12, 0x1000u, 0, "test %d %s...", v15, v6);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external_0811_all_lane",
    38,
    10365,
    60,
    v12);
  switch ( a6 )
  {
    case 2u:
      div2_seq(a1, a2, a3, a4);
      break;
    case 4u:
      div4_seq(a1, a2, a3, a4);
      break;
    case 8u:
      div8_seq_one_lane(a1, a2, a3, a4);
      break;
    case 0x20u:
      div32_20210813_500M_one_lane(a1, a2, a3, a4);
      break;
    default:
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, "do not set div_seq with testcase 4");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "serdes_phy_bist_external_0811_all_lane",
        38,
        10376,
        60,
        v12);
      break;
  }
  v13 = 336529925;
  v14 = 28;
  sub_789C4(a1, a3, 98, 255);
  for ( i = 0; i <= 4; ++i )
  {
    enable_rxbist_autostop(a1, a2, a3, a4, *((_BYTE *)&v13 + i));
    read_rx_debug_reg2_one_lane(a1, a2, a3, a4);
    serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (v19 << 12) | 0x91, 8);
    serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, -1073741825);
    serdes_apb_write(a1, a2, a3, (v19 << 12) | 0x77, 0x40000000);
    serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, 0);
    usleep(0xF4240u);
    check_bist_tx_running(a1, a2, a3, a4);
    check_bist_rx_running(a1, a2, a3, a4);
    usleep(0x493E0u);
    serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, -9);
    serdes_apb_write(a1, a2, a3, (v19 << 12) | 0x91, 0);
    serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, 0);
    check_ref_clock_ready(a1, a2, a3);
    check_bist_done(a1, a2, a3, a4);
    check_bist_done(a1, a2, a3, a4);
    check_bist_error(a1, a2, a3, a4);
  }
  if ( v15 == 4 )
  {
    enable_rx_equalizer_tuning(a1, a2, a3, a4);
    for ( j = 0; j <= 4; ++j )
    {
      enable_rxbist_autostop(a1, a2, a3, a4, *((_BYTE *)&v13 + j));
      read_rx_debug_reg2_one_lane(a1, a2, a3, a4);
      serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, -9);
      serdes_apb_write(a1, a2, a3, (v19 << 12) | 0x91, 8);
      serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, -1073741825);
      serdes_apb_write(a1, a2, a3, (v19 << 12) | 0x77, 0x40000000);
      serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, 0);
      usleep(0xF4240u);
      check_bist_tx_running(a1, a2, a3, a4);
      check_bist_rx_running(a1, a2, a3, a4);
      usleep(0x493E0u);
      serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, -9);
      serdes_apb_write(a1, a2, a3, (v19 << 12) | 0x91, 0);
      serdes_apb_write(a1, a2, a3, (v19 << 12) | 1, 0);
      check_ref_clock_ready(a1, a2, a3);
      check_bist_done(a1, a2, a3, a4);
      check_bist_done(a1, a2, a3, a4);
      check_bist_error(a1, a2, a3, a4);
    }
  }
  sub_789C4(a1, a3, 98, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D1FE0) --------------------------------------------------------
int __fastcall serdes_phy_bist_external_phy1tx_phy2rx(
        int a1,
        unsigned __int8 a2,
        char a3,
        char a4,
        unsigned int a5,
        unsigned __int8 a6,
        unsigned __int8 a7,
        unsigned __int8 a8,
        unsigned __int8 a9)
{
  const char *v9; // r3
  _BYTE v15[24]; // [sp+18h] [bp+8h] BYREF
  int v16; // [sp+1018h] [bp+1008h] BYREF
  unsigned __int8 v17; // [sp+101Eh] [bp+100Eh]
  unsigned __int8 v18; // [sp+101Fh] [bp+100Fh]
  int v19; // [sp+1020h] [bp+1010h]
  unsigned int j; // [sp+1024h] [bp+1014h]
  unsigned int i; // [sp+1028h] [bp+1018h]
  __int16 v22; // [sp+102Eh] [bp+101Eh]

  V_LOCK();
  logfmt_raw(v15, 0x1000u, 0, "%s...", "serdes_phy_bist_external_phy1tx_phy2rx");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external_phy1tx_phy2rx",
    38,
    10478,
    60,
    v15);
  v22 = 0;
  if ( a3 == 8 )
    v22 = 15;
  v19 = a4 & 7
      | ((a4 & 7) << 28)
      | ((a4 & 7) << 24)
      | ((a4 & 7) << 20)
      | ((a4 & 7) << 16)
      | ((a4 & 7) << 12)
      | ((a4 & 7) << 8)
      | (16 * (a4 & 7));
  v18 = a6;
  sub_789C4(
    a1,
    a6,
    97,
    a4 & 7
  | (((a4 & 7) << 28)
   | ((a4 & 7) << 24)
   | ((a4 & 7) << 20)
   | ((a4 & 7) << 16)
   | ((a4 & 7) << 12)
   | ((a4 & 7) << 8)
   | (16 * (a4 & 7)))
  & 0x7FFFFFFF);
  v18 = a7;
  serdes_apb_write(a1, a2, a7, (v22 << 12) | 1, -15);
  serdes_apb_write(a1, a2, v18, (v22 << 12) | 0x12, 2 * (a4 & 7));
  serdes_apb_write(a1, a2, v18, (v22 << 12) | 1, 0);
  v17 = sub_D0584(a5, 2u);
  V_LOCK();
  if ( a4 )
    v9 = "prbs";
  else
    v9 = "clock";
  logfmt_raw(v15, 0x1000u, 0, "test %d %s...", v17, v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external_phy1tx_phy2rx",
    38,
    10502,
    60,
    v15);
  v18 = a6;
  switch ( a5 )
  {
    case 2u:
      div2_seq_one_lane(a1, a2, v18, a8);
      div2_seq_one_lane(a1, a2, v18, a8);
      break;
    case 4u:
      div4_seq_one_lane(a1, a2, v18, a8);
      div4_seq_one_lane(a1, a2, v18, a8);
      break;
    case 8u:
      div8_seq_one_lane(a1, a2, v18, a8);
      div8_seq_one_lane(a1, a2, v18, a8);
      break;
    default:
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, "do not set div_seq with testcase 4");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "serdes_phy_bist_external_phy1tx_phy2rx",
        38,
        10517,
        60,
        v15);
      break;
  }
  v16 = 336529925;
  v18 = a6;
  sub_789C4(a1, a6, 98, 1 << a8);
  for ( i = 0; i <= 3; ++i )
  {
    v18 = a7;
    enable_rxbist_autostop_one_lane(a1, a2, a7, a9, *((_BYTE *)&v16 + i));
    v18 = a6;
    read_rx_debug_reg2_one_lane(a1, a2, a6, a8);
    v18 = a7;
    read_rx_debug_reg2_one_lane(a1, a2, a7, a9);
    v18 = a7;
    serdes_apb_write(a1, a2, a7, (a9 << 12) | 1, -9);
    serdes_apb_write(a1, a2, v18, (a9 << 12) | 0x91, 8);
    serdes_apb_write(a1, a2, v18, (a9 << 12) | 1, -1073741825);
    serdes_apb_write(a1, a2, v18, (a9 << 12) | 0x77, 0x40000000);
    serdes_apb_write(a1, a2, v18, (a9 << 12) | 1, 0);
    usleep(0xF4240u);
    v18 = a6;
    check_bist_tx_running_one_lane(a1, a2, a6, a8);
    v18 = a7;
    check_bist_rx_running_one_lane(a1, a2, a7, a9);
    usleep(0x493E0u);
    v18 = a7;
    serdes_apb_write(a1, a2, a7, (a9 << 12) | 1, -9);
    serdes_apb_write(a1, a2, v18, (a9 << 12) | 0x91, 0);
    serdes_apb_write(a1, a2, v18, (a9 << 12) | 1, 0);
    v18 = a6;
    check_ref_clock_ready(a1, a2, a6);
    check_bist_done_one_lane(a1, a2, v18, a9);
    v18 = a7;
    check_ref_clock_ready(a1, a2, a7);
    check_bist_done_one_lane(a1, a2, v18, a9);
    check_bist_error_one_lane(a1, a2, v18, a9);
  }
  if ( v17 == 4 )
  {
    v18 = a7;
    enable_rx_equalizer_tuning_one_lane(a1, a2, a7, a9);
    for ( j = 0; j <= 3; ++j )
    {
      v18 = a7;
      enable_rxbist_autostop_one_lane(a1, a2, a7, a9, *((_BYTE *)&v16 + j));
      v18 = a6;
      read_rx_debug_reg2_one_lane(a1, a2, a6, a8);
      v18 = a7;
      read_rx_debug_reg2_one_lane(a1, a2, a7, a9);
      v18 = a7;
      serdes_apb_write(a1, a2, a7, (a9 << 12) | 1, -9);
      serdes_apb_write(a1, a2, v18, (a9 << 12) | 0x91, 8);
      serdes_apb_write(a1, a2, v18, (a9 << 12) | 1, -1073741825);
      serdes_apb_write(a1, a2, v18, (a9 << 12) | 0x77, 0x40000000);
      serdes_apb_write(a1, a2, v18, (a9 << 12) | 1, 0);
      usleep(0xF4240u);
      v18 = a6;
      check_bist_tx_running_one_lane(a1, a2, a6, a8);
      v18 = a7;
      check_bist_rx_running_one_lane(a1, a2, a7, a9);
      usleep(0x493E0u);
      v18 = a7;
      serdes_apb_write(a1, a2, a7, (a9 << 12) | 1, -9);
      serdes_apb_write(a1, a2, v18, (a9 << 12) | 0x91, 0);
      serdes_apb_write(a1, a2, v18, (a9 << 12) | 1, 0);
      v18 = a6;
      check_ref_clock_ready(a1, a2, a6);
      check_bist_done_one_lane(a1, a2, v18, a9);
      v18 = a7;
      check_ref_clock_ready(a1, a2, a7);
      check_bist_done_one_lane(a1, a2, v18, a9);
      check_bist_error_one_lane(a1, a2, v18, a9);
    }
  }
  v18 = a6;
  sub_789C4(a1, a6, 98, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D2DEC) --------------------------------------------------------
int __fastcall serdes_phy_bist_external_all_phy(int a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  const char *v4; // r3
  _BYTE v10[4088]; // [sp+18h] [bp+8h] BYREF
  char v11; // [sp+1018h] [bp+1008h]
  int v12; // [sp+101Ch] [bp+100Ch] BYREF
  _DWORD v13[2]; // [sp+1020h] [bp+1010h] BYREF
  unsigned __int8 v14; // [sp+1029h] [bp+1019h]
  __int16 v15; // [sp+102Ah] [bp+101Ah]
  int j; // [sp+102Ch] [bp+101Ch]
  int i; // [sp+1030h] [bp+1020h]
  unsigned __int8 v18; // [sp+1037h] [bp+1027h]

  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s...", "serdes_phy_bist_external_all_phy");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external_all_phy",
    32,
    10644,
    60,
    v10);
  v15 = 15;
  v14 = -1;
  v13[1] = a4 & 7
         | ((a4 & 7) << 28)
         | ((a4 & 7) << 24)
         | ((a4 & 7) << 20)
         | ((a4 & 7) << 16)
         | ((a4 & 7) << 12)
         | ((a4 & 7) << 8)
         | (16 * (a4 & 7));
  sub_789C4(
    a1,
    255,
    97,
    a4 & 7
  | (((a4 & 7) << 28)
   | ((a4 & 7) << 24)
   | ((a4 & 7) << 20)
   | ((a4 & 7) << 16)
   | ((a4 & 7) << 12)
   | ((a4 & 7) << 8)
   | (16 * (a4 & 7)))
  & 0x7FFFFFFF);
  serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, -15);
  serdes_apb_write(a1, a2, v14, (v15 << 12) | 0x12, 2 * (a4 & 7));
  serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, 0);
  v12 = 0;
  v13[0] = 0;
  v18 = 0;
  if ( (a4 & 0xF) == 0 )
    v18 = 0;
  if ( (a4 & 0xF) == 1 )
    v18 = 7;
  if ( (a4 & 0xF) == 2 )
    v18 = 9;
  if ( (a4 & 0xF) == 3 )
    v18 = 11;
  if ( (a4 & 0xF) == 4 )
    v18 = 13;
  if ( (a4 & 0xF) == 5 )
    v18 = 15;
  if ( (a4 & 0xF) == 6 )
    v18 = 23;
  if ( (a4 & 0xF) == 7 )
    v18 = 31;
  if ( v18 )
    v4 = "prbs";
  else
    v4 = "clock";
  strcpy((char *)&v12, v4);
  if ( v18 )
    sprintf((char *)v13, "%2d", v18);
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, "%s %s...", "serdes_phy_bist_external_all_phy", &v12);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist_external_all_phy",
    32,
    10678,
    60,
    v10);
  v11 = 31;
  sub_789C4(a1, v14, 98, 255);
  for ( i = 0; !i; ++i )
  {
    enable_rxbist_autostop(a1, a2, v14, a3, v11);
    read_rx_debug_reg2(a1, a2, v14, a3);
    serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, -9);
    serdes_apb_write(a1, a2, v14, (v15 << 12) | 0x91, 8);
    serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, -1073741825);
    serdes_apb_write(a1, a2, v14, (v15 << 12) | 0x77, 0x40000000);
    serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, 0);
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "wait rx bist done!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "serdes_phy_bist_external_all_phy",
      32,
      10715,
      60,
      v10);
    usleep(0xF42400u);
    check_bist_tx_running(a1, a2, v14, a3);
    usleep(0x493E0u);
    serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, -9);
    serdes_apb_write(a1, a2, v14, (v15 << 12) | 0x91, 0);
    serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, 0);
    check_ref_clock_ready_ext(a1, a2, v14, a3, 0);
    check_bist_done(a1, a2, v14, a3);
    check_bist_error(a1, a2, v14, a3);
  }
  if ( a4 )
  {
    enable_rx_equalizer_tuning(a1, a2, v14, a3);
    for ( j = 0; !j; ++j )
    {
      enable_rxbist_autostop(a1, a2, v14, a3, v11);
      read_rx_debug_reg2(a1, a2, v14, a3);
      serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, -9);
      serdes_apb_write(a1, a2, v14, (v15 << 12) | 0x91, 8);
      serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, -1073741825);
      serdes_apb_write(a1, a2, v14, (v15 << 12) | 0x77, 0x40000000);
      serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, 0);
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "wait rx bist done!");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "serdes_phy_bist_external_all_phy",
        32,
        10762,
        60,
        v10);
      usleep(0xF42400u);
      check_bist_tx_running(a1, a2, v14, a3);
      usleep(0x493E0u);
      serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, -9);
      serdes_apb_write(a1, a2, v14, (v15 << 12) | 0x91, 0);
      serdes_apb_write(a1, a2, v14, (v15 << 12) | 1, 0);
      check_ref_clock_ready_ext(a1, a2, v14, a3, 0);
      check_bist_done(a1, a2, v14, a3);
      check_bist_error(a1, a2, v14, a3);
    }
  }
  sub_789C4(a1, v14, 98, 0);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D3938) --------------------------------------------------------
int __fastcall serdes_phy_bist(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  int v10; // [sp+24h] [bp+14h] BYREF
  __int16 v11; // [sp+1026h] [bp+1016h]

  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_id %02x", "serdes_phy_bist", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "serdes_phy_bist",
    15,
    10880,
    60,
    &v10);
  v11 = 0;
  if ( a3 == 8 )
    v11 = 15;
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 1, -241);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 6, 80);
  serdes_apb_write_1_chip(a1, 1, 2, 0x1006u, 64);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 1, -13);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 0x69, 8);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 1, -4);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 2, 2);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 1, -4);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 3, 0);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 1, 0x7FFFFFFF);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 0x1B, 0);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 1, -2);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 0x1C, 0);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 1, -2);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 0x3C, 100663296);
  serdes_apb_write(a1, 0, a2, (v11 << 12) | 1, 0);
  sub_788A8(a1, 80, (int)&word_1FFFE + 1);
  usleep(0x2710u);
  sub_789C4(a1, a2, 112, 0);
  sub_789C4(a1, a2, 113, 0);
  sub_789C4(a1, a2, 114, 0);
  sub_789C4(a1, a2, 115, 0);
  sub_789C4(a1, a2, 116, 0);
  sub_789C4(a1, a2, 117, 0);
  check_tx_rx_status(a1, 0, a2);
  if ( check_ref_clock_ready_ext(a1, 0, a2, a3, a4) && (++dword_47B2F4, dword_47B2F4 <= 2) )
  {
    V_LOCK();
    logfmt_raw(&v10, 0x1000u, 0, "check_ref_clock_ready_ext failed!");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "serdes_phy_bist",
      15,
      11071,
      60,
      &v10);
    return -1;
  }
  else
  {
    sub_789C4(a1, a2, 87, 255);
    usleep(0x2710u);
    serdes_phy_bist_external_all_phy(a1, 0, a3, 119);
    sub_788A8(a1, 158, 2);
    check_mac_done(a1, 0, a2, 0);
    return 0;
  }
}
// 1FFFE: using guessed type __int16 word_1FFFE;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B2F4: using guessed type int dword_47B2F4;
// 47BE18: using guessed type int g_zc;

//----- (000D3EFC) --------------------------------------------------------
int __fastcall setup_serdes_phy_x_y(
        int a1,
        unsigned __int8 a2,
        unsigned __int8 a3,
        unsigned __int8 a4,
        unsigned __int8 a5,
        char a6)
{
  int v11; // [sp+24h] [bp+Ch] BYREF
  unsigned __int8 v12; // [sp+1025h] [bp+100Dh]
  __int16 v13; // [sp+1026h] [bp+100Eh]

  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s PHY%dL%d->PHY%dL%d", "setup_serdes_phy_x_y", a2, a4, a3, a5);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "setup_serdes_phy_x_y",
    20,
    11148,
    60,
    &v11);
  v13 = 0;
  if ( a6 == 8 )
    v13 = 15;
  v12 = a2;
  serdes_apb_write(a1, 0, a2, (v13 << 12) | 1, -13);
  serdes_apb_write(a1, 0, v12, (v13 << 12) | 0x69, 8);
  serdes_apb_write(a1, 0, v12, (v13 << 12) | 1, 0);
  v12 = a3;
  serdes_apb_write(a1, 0, a3, (v13 << 12) | 1, -13);
  serdes_apb_write(a1, 0, v12, (v13 << 12) | 0x69, 8);
  serdes_apb_write(a1, 0, v12, (v13 << 12) | 1, 0);
  sub_788A8(a1, 80, (int)&word_1FFFE + 1);
  usleep(0x2710u);
  v12 = a2;
  sub_789C4(a1, a2, 112, 0);
  sub_789C4(a1, v12, 113, 0);
  sub_789C4(a1, v12, 114, 0);
  sub_789C4(a1, v12, 115, 0);
  sub_789C4(a1, v12, 116, 0);
  sub_789C4(a1, v12, 117, 0);
  check_ref_clock_ready(a1, 0, v12);
  v12 = a3;
  sub_789C4(a1, a3, 112, 0);
  sub_789C4(a1, v12, 113, 0);
  sub_789C4(a1, v12, 114, 0);
  sub_789C4(a1, v12, 115, 0);
  sub_789C4(a1, v12, 116, 0);
  sub_789C4(a1, v12, 117, 0);
  check_ref_clock_ready(a1, 0, v12);
  v12 = a2;
  sub_789C4(a1, a2, 87, 255);
  usleep(0x2710u);
  serdes_phy_bist_external_phy1tx_phy2rx(a1, 0, a6, 17, 0x10u, a2, a3, a4, a5);
  return 0;
}
// 1FFFE: using guessed type __int16 word_1FFFE;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D4384) --------------------------------------------------------
int __fastcall set_logic_core_id(int a1)
{
  _BYTE v3[16]; // [sp+18h] [bp+8h] BYREF
  int v4; // [sp+1018h] [bp+1008h] BYREF
  int v5; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int j; // [sp+1020h] [bp+1010h]
  unsigned int i; // [sp+1024h] [bp+1014h]

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "set_logic_core_id");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_logic_core_id",
    17,
    11216,
    60,
    v3);
  v5 = 100925952;
  v4 = 117768961;
  for ( i = 0; i <= 3; ++i )
  {
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 0, 19, 256);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 1, 19, 257);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 2, 19, 258);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 3, 19, 259);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 4, 19, 260);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 5, 19, 261);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 6, 19, 262);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 7, 19, 263);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 8, 19, 264);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 9, 19, 265);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 10, 19, 266);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 11, 19, 267);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 12, 19, 268);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 13, 19, 269);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 14, 19, 270);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 15, 19, 271);
  }
  for ( j = 0; j <= 3; ++j )
  {
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 0, 19, 263);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 1, 19, 262);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 2, 19, 261);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 3, 19, 259);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 4, 19, 260);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 5, 19, 258);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 6, 19, 257);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 7, 19, 256);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 8, 19, 271);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 9, 19, 270);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 10, 19, 269);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 11, 19, 267);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 12, 19, 268);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 13, 19, 266);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 14, 19, 265);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 15, 19, 264);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D4C14) --------------------------------------------------------
int __fastcall setup_mac_lane_cross(int a1)
{
  _BYTE v3[16]; // [sp+18h] [bp+8h] BYREF
  int v4; // [sp+1018h] [bp+1008h] BYREF
  int v5; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int j; // [sp+1020h] [bp+1010h]
  unsigned int i; // [sp+1024h] [bp+1014h]

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "setup_mac_lane_cross");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "setup_mac_lane_cross",
    20,
    11325,
    60,
    v3);
  v5 = 100925952;
  v4 = 117768961;
  for ( i = 0; i <= 3; ++i )
  {
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 3, 199, (int)&unk_1ACFFF);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 0, 83, 255);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 1, 83, 255);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 2, 83, 0);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 3, 83, 192);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 5, 83, 127);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 6, 83, 254);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 7, 83, 255);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 8, 83, 255);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 9, 83, 15);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 10, 83, 32);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 11, 83, 0);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 13, 83, 0);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 14, 83, 15);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 15, 83, 0);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 0, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 1, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 2, 96, 128);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 3, 96, 16);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 5, 96, 128);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 6, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 7, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 8, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 9, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 10, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 11, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 13, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 14, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v5 + i)), 15, 96, 1);
  }
  for ( j = 0; j <= 3; ++j )
  {
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 0, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 1, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 3, 199, 1527807);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 6, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 7, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 8, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 9, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 10, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 11, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 13, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 14, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 15, 199, 342384);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 0, 83, 255);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 1, 83, 255);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 2, 83, 0);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 3, 83, 192);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 5, 83, 127);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 6, 83, 254);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 7, 83, 255);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 8, 83, 255);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 9, 83, 15);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 10, 83, 32);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 11, 83, 0);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 13, 83, 0);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 14, 83, 15);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 15, 83, 0);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 0, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 1, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 2, 96, 128);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 3, 96, 16);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 5, 96, 128);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 6, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 7, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 8, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 9, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 10, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 11, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 13, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 14, 96, 1);
    sub_78960(a1, *(_BYTE *)(*(_DWORD *)(a1 + 296) + *((unsigned __int8 *)&v4 + j)), 15, 96, 1);
  }
  usleep(0xF4240u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D5D24) --------------------------------------------------------
int __fastcall setup_mac(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "setup_mac");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "setup_mac",
    9,
    11510,
    60,
    v3);
  sub_788A8(a1, 159, -1);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D5DBC) --------------------------------------------------------
int __fastcall disable_mac(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "disable_mac");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "disable_mac",
    11,
    11517,
    60,
    v3);
  sub_788A8(a1, 159, 0);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D5E50) --------------------------------------------------------
int __fastcall membist0(int a1)
{
  int v1; // r4
  int v2; // r5
  unsigned int v3; // r0
  unsigned int v4; // r0
  int v5; // r4
  int v6; // r5
  unsigned int v7; // r0
  unsigned int v8; // r0
  int v9; // r4
  int v10; // r5
  unsigned int v11; // r0
  __int16 v12; // r0
  const char *v13; // r3
  size_t v14; // r0
  _UNKNOWN **v15; // r0
  _BYTE v18[4088]; // [sp+18h] [bp+8h] BYREF
  char v19[64]; // [sp+1018h] [bp+1008h] BYREF
  _DWORD v20[133]; // [sp+1058h] [bp+1048h] BYREF
  unsigned __int8 *v21; // [sp+126Ch] [bp+125Ch]
  int v22; // [sp+1270h] [bp+1260h]
  unsigned __int8 jj; // [sp+1277h] [bp+1267h]
  unsigned __int64 v24; // [sp+1278h] [bp+1268h]
  unsigned int ii; // [sp+1280h] [bp+1270h]
  int n; // [sp+1284h] [bp+1274h]
  int m; // [sp+1288h] [bp+1278h]
  int k; // [sp+128Ch] [bp+127Ch]
  unsigned __int8 j; // [sp+1293h] [bp+1283h]
  unsigned int i; // [sp+1294h] [bp+1284h]
  _DWORD savedregs[4]; // [sp+1298h] [bp+1288h] BYREF

  V_LOCK();
  logfmt_raw(v18, 0x1000u, 0, "%s...", "membist0");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "membist0",
    8,
    11524,
    60,
    v18);
  v22 = 0;
  v20[128] = -2023406815;
  v20[129] = 1266163410;
  v20[130] = 2015285835;
  v20[131] = 517098360;
  v20[132] = -766805986;
  memset(v20, 0, 0x200u);
  v21 = (unsigned __int8 *)malloc(0x600u);
  for ( i = 0; i <= 4; ++i )
  {
    V_LOCK();
    logfmt_raw(v18, 0x1000u, 0, "membist final pattern %08x", savedregs[i - 16]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "membist0",
      8,
      11532,
      60,
      v18);
    sub_788A8(a1, 164, savedregs[i - 16]);
    for ( j = 0; j <= 7u; ++j )
    {
      sub_789C4(a1, j, 12, 1);
      sub_789C4(a1, j, 160, 3);
      usleep((__useconds_t)&stru_1869C.st_value);
      v22 = sub_78A20(a1, j, 161, v21);
      for ( k = 0; k < v22; ++k )
      {
        if ( (*(_DWORD *)&v21[12 * k] & 0x80) != 0 )
        {
          if ( (*(_DWORD *)&v21[12 * k] & 0xFFFFFF00) != 0 )
          {
            V_LOCK();
            v1 = v21[12 * k + 4];
            v2 = v21[12 * k + 8];
            v3 = sub_79338(*(_DWORD *)&v21[12 * k]);
            logfmt_raw(v18, 0x1000u, 0, "chip %02x core %02x membist err cnt: %08x", v1, v2, v3);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
              83,
              "membist0",
              8,
              11544,
              100,
              v18);
            v4 = sub_79338(*(_DWORD *)&v21[12 * k]);
            v20[16 * v21[12 * k + 4] + i] += v4 & 0x7FFFFF;
          }
        }
        else
        {
          V_LOCK();
          logfmt_raw(v18, 0x1000u, 0, "chip %02x core %02x membist not done!", v21[12 * k + 4], v21[12 * k + 8]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "membist0",
            8,
            11548,
            100,
            v18);
        }
      }
      v22 = sub_78A20(a1, j, 162, v21);
      for ( m = 0; m < v22; ++m )
      {
        if ( (*(_DWORD *)&v21[12 * m] & 0xFFFFFF00) != 0 && (*(_DWORD *)&v21[12 * m] & 0x80) != 0 )
        {
          V_LOCK();
          v5 = v21[12 * m + 4];
          v6 = v21[12 * m + 8];
          v7 = sub_79338(*(_DWORD *)&v21[12 * m]);
          logfmt_raw(v18, 0x1000u, 0, "chip %02x core %02x membist lost cnt: %08x", v5, v6, v7);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "membist0",
            8,
            11555,
            100,
            v18);
          v8 = sub_79338(*(_DWORD *)&v21[12 * m]);
          v20[16 * v21[12 * m + 4] + i] += v8 & 0x7FFFFF;
        }
      }
      v22 = sub_78A20(a1, j, 163, v21);
      for ( n = 0; n < v22; ++n )
      {
        if ( (*(_DWORD *)&v21[12 * n] & 0xFFFF00) != 0 && (*(_DWORD *)&v21[12 * n] & 0xC0) != 0 )
        {
          V_LOCK();
          v9 = v21[12 * n + 4];
          v10 = v21[12 * n + 8];
          v11 = sub_79338(*(_DWORD *)&v21[12 * n]);
          logfmt_raw(v18, 0x1000u, 0, "chip %02x core %02x ethbist err cnt: %08x", v9, v10, v11);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "membist0",
            8,
            11563,
            100,
            v18);
          v12 = sub_79338(*(_DWORD *)&v21[12 * n]);
          v20[16 * v21[12 * n + 4] + i] += v12 & 0x7FFF;
        }
      }
    }
  }
  free(v21);
  memset(v19, 0, sizeof(v19));
  for ( ii = 0; ii <= 4; ++ii )
  {
    v24 = 0;
    for ( jj = 0; jj <= 7u; ++jj )
      v24 += (unsigned int)v20[16 * jj + ii];
    if ( v24 <= 0x800 )
      v13 = "ok";
    else
      v13 = "failed";
    sprintf(v19, "<mbist0 %08x> test %s(%llu)", savedregs[ii - 16], v13, v24);
    v14 = strlen(v19);
    sub_79118(v19, v14);
  }
  v15 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v15[18])(*(_DWORD *)(a1 + 136));
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D6918) --------------------------------------------------------
int __fastcall membist1(int a1)
{
  int v1; // r4
  int v2; // r5
  unsigned int v3; // r0
  unsigned int v4; // r0
  int v5; // r4
  int v6; // r5
  unsigned int v7; // r0
  unsigned int v8; // r0
  const char *v9; // r3
  size_t v10; // r0
  _UNKNOWN **v11; // r0
  _BYTE v14[8]; // [sp+18h] [bp+8h] BYREF
  _DWORD v15[25]; // [sp+1018h] [bp+1008h] BYREF
  unsigned __int8 *v16; // [sp+107Ch] [bp+106Ch]
  int v17; // [sp+1080h] [bp+1070h]
  unsigned __int8 m; // [sp+1087h] [bp+1077h]
  unsigned __int64 v19; // [sp+1088h] [bp+1078h]
  int k; // [sp+1094h] [bp+1084h]
  int j; // [sp+1098h] [bp+1088h]
  unsigned __int8 i; // [sp+109Fh] [bp+108Fh]
  _DWORD savedregs[4]; // [sp+10A0h] [bp+1090h] BYREF

  V_LOCK();
  logfmt_raw(v14, 0x1000u, 0, "%s...", "membist1");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "membist1",
    8,
    11590,
    60,
    v14);
  v17 = 0;
  memset(&v15[16], 0, 0x20u);
  v16 = (unsigned __int8 *)malloc(0x600u);
  for ( i = 0; i <= 7u; ++i )
  {
    v15[24] = 0;
    sub_789C4(a1, i, 12, 1);
    usleep(0x2710u);
    sub_789C4(a1, i, 160, -2147483647);
    usleep((__useconds_t)&stru_1869C.st_value);
    v17 = sub_78A20(a1, i, 161, v16);
    for ( j = 0; j < v17; ++j )
    {
      if ( (*(_DWORD *)&v16[12 * j] & 0x80) != 0 )
      {
        if ( (*(_DWORD *)&v16[12 * j] & 0xFFFFFF00) != 0 )
        {
          V_LOCK();
          v1 = v16[12 * j + 4];
          v2 = v16[12 * j + 8];
          v3 = sub_79338(*(_DWORD *)&v16[12 * j]);
          logfmt_raw(v14, 0x1000u, 0, "chip %02x core %02x membist err cnt: %08x", v1, v2, v3);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
            83,
            "membist1",
            8,
            11608,
            100,
            v14);
          v4 = sub_79338(*(_DWORD *)&v16[12 * j]);
          savedregs[v16[12 * j + 4] - 18] += v4 & 0x7FFFFF;
        }
      }
      else
      {
        V_LOCK();
        logfmt_raw(v14, 0x1000u, 0, "chip %02x core %02x membist not done!", v16[12 * j + 4], v16[12 * j + 8]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "membist1",
          8,
          11612,
          100,
          v14);
      }
    }
    v17 = sub_78A20(a1, i, 162, v16);
    for ( k = 0; k < v17; ++k )
    {
      if ( (*(_DWORD *)&v16[12 * k] & 0xFFFFFF00) != 0 && (*(_DWORD *)&v16[12 * k] & 0x80) != 0 )
      {
        V_LOCK();
        v5 = v16[12 * k + 4];
        v6 = v16[12 * k + 8];
        v7 = sub_79338(*(_DWORD *)&v16[12 * k]);
        logfmt_raw(v14, 0x1000u, 0, "chip %02x core %02x membist lost cnt: %08x", v5, v6, v7);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
          83,
          "membist1",
          8,
          11620,
          100,
          v14);
        v8 = sub_79338(*(_DWORD *)&v16[12 * k]);
        savedregs[v16[12 * k + 4] - 18] += v8 & 0x7FFFFF;
      }
    }
  }
  free(v16);
  memset(v15, 0, 0x40u);
  v19 = 0;
  for ( m = 0; m <= 7u; ++m )
    v19 += (unsigned int)savedregs[m - 18];
  if ( v19 <= 0x800 )
    v9 = "ok";
  else
    v9 = "failed";
  sprintf((char *)v15, "<mbist1> test %s(%llu)", v9, v19);
  v10 = strlen((const char *)v15);
  sub_79118((const char *)v15, v10);
  v11 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v11[18])(*(_DWORD *)(a1 + 136));
  unk_47B2D4 = v15[16];
  unk_47B2D8 = v15[17];
  unk_47B2DC = v15[18];
  unk_47B2E0 = v15[19];
  unk_47B2E4 = v15[20];
  unk_47B2E8 = v15[21];
  unk_47B2EC = v15[22];
  unk_47B2F0 = v15[23];
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D7094) --------------------------------------------------------
int __fastcall enable_work(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "enable_work");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "enable_work",
    11,
    11644,
    60,
    v5);
  sub_788A8(a1, 240, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D7138) --------------------------------------------------------
int __fastcall open_core_clk(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "open_core_clk");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_clk",
    13,
    11651,
    60,
    v3);
  sub_788A8(a1, 15, 1);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D71CC) --------------------------------------------------------
int __fastcall close_core_clk(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "close_core_clk");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "close_core_clk",
    14,
    11658,
    60,
    v3);
  sub_788A8(a1, 15, 0);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D7260) --------------------------------------------------------
int __fastcall open_cores_by_work_num(int a1)
{
  _DWORD *v1; // r0
  int v2; // r1
  int v3; // r2
  int v4; // r3
  int v5; // r1
  int v6; // r2
  int v7; // r3
  _BYTE *v8; // r3
  _BYTE *v9; // r3
  _BYTE v12[8]; // [sp+18h] [bp+8h] BYREF
  _DWORD v13[8]; // [sp+1018h] [bp+1008h] BYREF
  _BYTE *v14; // [sp+1038h] [bp+1028h]
  unsigned int i; // [sp+103Ch] [bp+102Ch]

  sub_788A8(a1, 21, 0);
  str2hex((int)v13, (int)"ab77b2cb3d32b0b61304401cbe540448a4cacd7e98421a850503e2f0d102f1d3", 64);
  v1 = calloc(1u, 0x59u);
  v14 = v1;
  v2 = v13[1];
  v3 = v13[2];
  v4 = v13[3];
  v1[4] = v13[0];
  v1[5] = v2;
  v1[6] = v3;
  v1[7] = v4;
  v5 = v13[5];
  v6 = v13[6];
  v7 = v13[7];
  v1[8] = v13[4];
  v1[9] = v5;
  v1[10] = v6;
  v1[11] = v7;
  v8 = v14;
  v14[8] = 86;
  v8[9] = 52;
  v8[10] = 18;
  v8[11] = 0;
  v8[12] = 0;
  v8[13] = 0;
  v8[14] = 0;
  v8[15] = 0;
  v9 = v14;
  v14[8] = 86;
  v9[9] = 52;
  v9[10] = 18;
  v9[11] = 0;
  v9[12] = 0;
  v9[13] = 0;
  v9[14] = 0;
  v9[15] = 0;
  for ( i = 1; i <= 0x40; ++i )
  {
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, "%s %u", "open_cores_by_work_num", i);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "open_cores_by_work_num",
      22,
      11674,
      60,
      v12);
    sub_788A8(a1, 21, i);
    push_work_base(a1, (int)v14);
    usleep((__useconds_t)&stru_1869C.st_value);
  }
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D7428) --------------------------------------------------------
int __fastcall set_work_mode(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_work_mode");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_work_mode",
    13,
    11685,
    60,
    v5);
  sub_788A8(a1, 12, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D74CC) --------------------------------------------------------
int __fastcall set_work_num(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_work_num");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_work_num",
    12,
    11692,
    60,
    v5);
  sub_788A8(a1, 21, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D7570) --------------------------------------------------------
int __fastcall set_nonce_num(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_nonce_num");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_nonce_num",
    13,
    11710,
    60,
    v5);
  sub_788A8(a1, 55, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D7614) --------------------------------------------------------
int __fastcall set_work_timeout(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_work_timeout");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_work_timeout",
    16,
    11717,
    60,
    v5);
  sub_788A8(a1, 197, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D76B8) --------------------------------------------------------
int __fastcall set_work_debug(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_work_debug");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_work_debug",
    14,
    11724,
    60,
    v5);
  sub_788A8(a1, 57, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D775C) --------------------------------------------------------
int __fastcall set_safe_mode(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_safe_mode");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_safe_mode",
    13,
    11732,
    60,
    v5);
  sub_788A8(a1, 158, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D7800) --------------------------------------------------------
int __fastcall set_data_preemptive(int a1, int a2)
{
  _BYTE v5[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "%s...", "set_data_preemptive");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_data_preemptive",
    19,
    11739,
    60,
    v5);
  sub_788A8(a1, 204, a2);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D78A4) --------------------------------------------------------
int __fastcall set_core_bus_reset(int a1)
{
  int v3; // [sp+1Ch] [bp+Ch] BYREF
  unsigned __int8 i; // [sp+101Fh] [bp+100Fh]

  V_LOCK();
  logfmt_raw(&v3, 0x1000u, 0, "%s...", "set_core_bus_reset");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_core_bus_reset",
    18,
    11746,
    60,
    &v3);
  for ( i = 0; i <= 0xFu; ++i )
  {
    sub_789C4(a1, i, 201, 0);
    usleep((__useconds_t)&stru_1869C.st_value);
    sub_789C4(a1, i, 201, 1);
    usleep((__useconds_t)&stru_1869C.st_value);
  }
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D79A0) --------------------------------------------------------
int __fastcall open_core_by_steps(int a1)
{
  __int64 v1; // kr00_8
  __int64 v2; // kr08_8
  __int64 v3; // kr10_8
  __int64 v4; // kr18_8
  __int64 v5; // kr20_8
  __int64 v6; // kr28_8
  __int64 v7; // kr30_8
  __int64 v8; // kr38_8
  __int64 v9; // kr40_8
  __int64 v10; // kr48_8
  __int64 v11; // kr50_8
  __int64 v12; // kr58_8
  __int64 v13; // kr60_8
  __int64 v14; // kr68_8
  __int64 v15; // kr70_8
  __int64 v16; // kr78_8
  __int64 v17; // kr80_8
  __int64 v18; // kr88_8
  __int64 v19; // kr90_8
  __int64 v20; // kr98_8
  __int64 v21; // krA0_8
  __int64 v22; // krA8_8
  __int64 v23; // krB0_8
  __int64 v24; // krB8_8
  __int64 v25; // krC0_8
  __int64 v26; // krC8_8
  __int64 v27; // krD0_8
  __int64 v28; // krD8_8
  int v31; // [sp+1Ch] [bp+Ch] BYREF
  _QWORD *v32; // [sp+101Ch] [bp+100Ch]

  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s...", "open_core_by_steps");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11758,
    60,
    &v31);
  v32 = calloc(1u, 0x59u);
  memset(v32 + 2, 0, 0x20u);
  sub_788A8(a1, 201, 0);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11767);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11767,
    60,
    &v31);
  sub_78960(a1, 0, 0, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 0, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 0, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 0, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 7, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 7, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 7, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 7, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v1 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v1;
  v2 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v2;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11788);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11788,
    60,
    &v31);
  sub_78960(a1, 0, 1, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 1, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 1, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 1, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 6, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 6, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 6, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 6, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v3 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v3;
  v4 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v4;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11809);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11809,
    60,
    &v31);
  sub_78960(a1, 0, 2, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 2, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 2, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 2, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 5, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 5, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 5, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 5, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v5 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v5;
  v6 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v6;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11830);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11830,
    60,
    &v31);
  sub_78960(a1, 0, 3, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 3, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 3, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 3, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 3, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 3, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 3, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 3, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v7 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v7;
  v8 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v8;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11851);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11851,
    60,
    &v31);
  sub_78960(a1, 0, 5, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 5, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 5, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 5, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 2, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 2, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 2, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 2, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v9 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v9;
  v10 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v10;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11872);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11872,
    60,
    &v31);
  sub_78960(a1, 0, 6, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 6, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 6, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 6, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 1, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 1, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 1, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 1, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v11 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v11;
  v12 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v12;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11893);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11893,
    60,
    &v31);
  sub_78960(a1, 0, 7, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 7, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 7, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 7, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 0, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 0, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 0, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 0, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v13 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v13;
  v14 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v14;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11914);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11914,
    60,
    &v31);
  sub_78960(a1, 0, 8, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 8, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 8, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 8, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 15, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 15, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 15, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 15, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v15 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v15;
  v16 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v16;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11935);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11935,
    60,
    &v31);
  sub_78960(a1, 0, 9, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 9, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 9, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 9, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 14, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 14, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 14, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 14, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v17 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v17;
  v18 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v18;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11956);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11956,
    60,
    &v31);
  sub_78960(a1, 0, 10, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 10, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 10, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 10, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 13, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 13, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 13, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 13, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v19 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v19;
  v20 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v20;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11977);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11977,
    60,
    &v31);
  sub_78960(a1, 0, 11, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 11, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 11, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 11, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 11, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 11, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 11, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 11, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v21 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v21;
  v22 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v22;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 11998);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    11998,
    60,
    &v31);
  sub_78960(a1, 0, 13, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 13, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 13, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 13, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 10, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 10, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 10, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 10, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v23 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v23;
  v24 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v24;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 12019);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    12019,
    60,
    &v31);
  sub_78960(a1, 0, 14, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 14, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 14, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 14, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 9, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 9, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 9, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 9, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v25 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v25;
  v26 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v26;
  push_work_base(a1, (int)v32);
  V_LOCK();
  logfmt_raw(&v31, 0x1000u, 0, "%s %d", "open_core_by_steps", 12040);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "open_core_by_steps",
    18,
    12040,
    60,
    &v31);
  sub_78960(a1, 0, 15, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 2, 15, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 4, 15, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 6, 15, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 1, 8, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 3, 8, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 5, 8, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_78960(a1, 7, 8, 201, 1);
  usleep((__useconds_t)&stru_1869C.st_value);
  v27 = (*(_QWORD *)&dword_1EEF90)++;
  *v32 = v27;
  v28 = (*(_QWORD *)&dword_1EEF98)++;
  v32[1] = v28;
  push_work_base(a1, (int)v32);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1EEF90: using guessed type int dword_1EEF90;
// 1EEF98: using guessed type int dword_1EEF98;
// 47BE18: using guessed type int g_zc;

//----- (000D94D4) --------------------------------------------------------
int __fastcall set_chip0_1_work_1_pe(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "set_chip0_1_work_1_pe");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "set_chip0_1_work_1_pe",
    21,
    12065,
    60,
    v3);
  sub_78900(a1, 0, 21, 0);
  usleep(0x2710u);
  sub_78900(a1, 0, 21, 1);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D95C8) --------------------------------------------------------
int __fastcall work_2_packet_eth(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r4
  _DWORD *v5; // r2
  int v6; // r4
  _DWORD *v7; // r2
  int v8; // r4
  _DWORD *v9; // r2
  unsigned __int16 v10; // r0
  int v13; // [sp+14h] [bp+14h]

  v13 = *(_DWORD *)(a1 + 624);
  *(_BYTE *)a3 = 85;
  *(_BYTE *)(a3 + 1) = -86;
  *(_BYTE *)(a3 + 2) = 32;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    *(_BYTE *)(a3 + 2) |= 0x10u;
  v4 = *(_DWORD *)(a2 + 12);
  v5 = (_DWORD *)(8 * (*(unsigned __int8 *)(v13 + 35072) + 256) + v13);
  *v5 = *(_DWORD *)(a2 + 8);
  v5[1] = v4;
  v6 = *(_DWORD *)(a2 + 4);
  v7 = (_DWORD *)(8 * *(unsigned __int8 *)(v13 + 35072) + v13);
  *v7 = *(_DWORD *)a2;
  v7[1] = v6;
  *(_BYTE *)(a3 + 3) = *(_BYTE *)(v13 + 35072);
  *(_BYTE *)(v13 + *(unsigned __int8 *)(v13 + 35072) + 34816) = *(_BYTE *)(a2 + 88);
  memcpy((void *)(a3 + 4), (const void *)(a2 + 16), 0x20u);
  memcpy((void *)(v13 + 40 * *(unsigned __int8 *)(v13 + 35072) + 0x2000), (const void *)(a2 + 16), 0x28u);
  memcpy((void *)(v13 + 32 * (*(unsigned __int8 *)(v13 + 35072) + 576)), (const void *)(a2 + 48), 0x20u);
  sub_758E0((_BYTE *)(a3 + 36), a3 + 36, *(_DWORD *)(a2 + 80), *(_DWORD *)(a2 + 84));
  v8 = *(_DWORD *)(a2 + 84);
  v9 = (_DWORD *)(8 * (*(unsigned __int8 *)(v13 + 35072) + 512) + v13);
  *v9 = 0;
  v9[1] = v8;
  ++*(_BYTE *)(v13 + 35072);
  v10 = CRC16_v1((const unsigned __int8 *)(a3 + 2), 42);
  *(_BYTE *)(a3 + 44) = HIBYTE(v10);
  *(_BYTE *)(a3 + 45) = v10;
  *a4 = 46;
  return 0;
}

//----- (000D9754) --------------------------------------------------------
__int64 __fastcall sub_D9754(int a1, int a2)
{
  int v3; // [sp+4h] [bp-14h]
  _BYTE v6[24]; // [sp+20h] [bp+8h] BYREF
  _WORD v7[28]; // [sp+1020h] [bp+1008h] BYREF
  _WORD v8[26]; // [sp+1064h] [bp+104Ch] BYREF
  unsigned __int8 v9; // [sp+10A7h] [bp+108Fh]
  int v10; // [sp+10A8h] [bp+1090h]
  int v11; // [sp+10ACh] [bp+1094h]
  int i; // [sp+10B0h] [bp+1098h]
  unsigned int j; // [sp+10B4h] [bp+109Ch]

  v11 = a2 + 34;
  v10 = a2 + 98;
  v9 = (*(__int64 *)(a2 + 26) >> 9) & 7;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "wc %d diff: %d", *(unsigned __int8 *)(a2 + 16), *(unsigned __int8 *)(a2 + 17));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "dump_nonce",
    10,
    12303,
    60,
    v6);
  V_LOCK();
  logfmt_raw(
    v6,
    0x1000u,
    0,
    "chain %d asic %d core %d pe %d addr_interval %d",
    *(_DWORD *)(a1 + 136),
    *(_DWORD *)(a2 + 8),
    *(_DWORD *)(a2 + 12),
    v9,
    *(_DWORD *)(a1 + 240));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "dump_nonce",
    10,
    12305,
    60,
    v6);
  for ( i = 0; i <= 31; ++i )
    sprintf((char *)&v8[i], "%02x", *(unsigned __int8 *)(i + v11));
  for ( j = 0; j <= 0x1F; ++j )
    sprintf((char *)&v7[j], "%02x", *(unsigned __int8 *)(j + v10));
  V_LOCK();
  logfmt_raw(
    v6,
    0x1000u,
    0,
    "header %s nonce %016llx mixhash %s",
    v8,
    v3,
    *(_DWORD *)(a2 + 26),
    *(_DWORD *)(a2 + 30),
    v7);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
           83,
           "dump_nonce",
           10,
           12313,
           60,
           v6);
}
// D99BE: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D9A08) --------------------------------------------------------
int __fastcall packet_2_nonce_eth(int a1, int a2, int a3, _BYTE *a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  int *v8; // r3
  int v9; // r8
  int v10; // r9
  int v11; // r0
  int *v12; // r2
  int *v13; // r2
  int v14; // r3
  int v15; // r4
  int v16; // r2
  int v17; // r4
  _DWORD *v18; // r2
  int *v19; // r2
  int v20; // r3
  int v21; // r4
  int v22; // r2
  int *v23; // r2
  int v24; // r3
  int v25; // r4
  int v26; // r2
  _BYTE v31[4080]; // [sp+20h] [bp+10h] BYREF
  unsigned __int8 v32; // [sp+1023h] [bp+1013h]
  int v33; // [sp+1024h] [bp+1014h]
  unsigned __int16 v34; // [sp+1028h] [bp+1018h]
  unsigned __int16 v35; // [sp+102Ah] [bp+101Ah]
  int v36; // [sp+102Ch] [bp+101Ch]
  _BYTE *v37; // [sp+1030h] [bp+1020h]
  unsigned __int8 v38; // [sp+1037h] [bp+1027h]
  int v39; // [sp+1038h] [bp+1028h]
  unsigned __int8 v40; // [sp+103Fh] [bp+102Fh]

  v39 = a3;
  v40 = 0;
  v38 = 0;
  if ( *(_BYTE *)(a2 + 2) != 32 )
    return 1;
  if ( *(_BYTE *)(a1 + 146) != 1 && *(_BYTE *)(a1 + 145) != 1 )
    return 5;
  v37 = (_BYTE *)a2;
  v36 = 39;
  v35 = CRC16_v1((const unsigned __int8 *)(a2 + 2), 39);
  v34 = _byteswap_ushort(*(_WORD *)(a2 + 41));
  if ( v35 == v34 )
  {
    v33 = *(_DWORD *)(a1 + 624);
    v32 = v37[3];
    memcpy((void *)(v39 + 34), (const void *)(40 * v32 + 0x2000 + v33), 0x20u);
    memcpy((void *)(v39 + 66), (const void *)(32 * (v32 + 576) + v33), 0x20u);
    v8 = (int *)(8 * (v32 + 512) + v33);
    v9 = *v8;
    v10 = v8[1];
    v11 = sub_758A4(v37 + 5);
    v12 = (int *)(8 * (v32 + 512) + v33);
    *v12 = v11 | v9;
    v12[1] = v10;
    memcpy((void *)(v39 + 98), v37 + 9, 0x20u);
    v13 = (int *)(v33 + 8 * (v32 + 512));
    v14 = *v13;
    v15 = v13[1];
    v16 = v39 + 26;
    *(_DWORD *)(v39 + 26) = v14;
    *(_DWORD *)(v16 + 4) = v15;
    v17 = *(_DWORD *)(v33 + 8 * (v32 + 512) + 4);
    v18 = (_DWORD *)(8 * (v32 + 512) + v33);
    *v18 = 0;
    v18[1] = v17;
    *(_BYTE *)(v39 + 16) = v32;
    *(_BYTE *)(v39 + 17) = v37[4];
    v19 = (int *)(v33 + 8 * (v32 + 256));
    v20 = *v19;
    v21 = v19[1];
    v22 = v39 + 18;
    *(_DWORD *)(v39 + 18) = v20;
    *(_DWORD *)(v22 + 4) = v21;
    v23 = (int *)(v33 + 8 * v32);
    v24 = *v23;
    v25 = v23[1];
    v26 = v39;
    *(_DWORD *)v39 = v24;
    *(_DWORD *)(v26 + 4) = v25;
    *a7 = *(_DWORD *)(v33 + 8 * v32);
    v38 = (*(_DWORD *)(v39 + 26) >> 12) & 0xF;
    v40 = sub_1A3E94(*(_DWORD *)(v39 + 26) & 7LL, *(unsigned int *)(a1 + 240));
    if ( v40 > 7u )
      v40 = 7;
    *(_DWORD *)(v39 + 8) = v40;
    *(_DWORD *)(v39 + 12) = v38;
    *a6 = v40;
    memcpy(a5, (const void *)(v39 + 26), 8u);
    *a4 = 1;
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v31, 0x1000u, 0, "get nonce crc error calc value %04x resp value %04x", v35, v34);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "packet_2_nonce_eth",
      18,
      12335,
      100,
      v31);
    return 2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000D9ED8) --------------------------------------------------------
int __fastcall sub_D9ED8(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(8, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (000D9F28) --------------------------------------------------------
int __fastcall setup_ref_clk_termination(int a1)
{
  _BYTE v3[4096]; // [sp+18h] [bp+8h] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "%s...", "setup_ref_clk_termination");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "setup_ref_clk_termination",
    25,
    12406,
    60,
    v3);
  sub_788A8(a1, 81, 256);
  usleep(0x2710u);
  sub_789C4(a1, 1, 81, 138);
  usleep(0x2710u);
  sub_789C4(a1, 5, 81, 138);
  usleep(0x2710u);
  sub_789C4(a1, 9, 81, 138);
  usleep(0x2710u);
  sub_789C4(a1, 13, 81, 138);
  usleep(0x2710u);
  sub_789C4(a1, 2, 81, 6);
  usleep(0x2710u);
  sub_789C4(a1, 6, 81, 6);
  usleep(0x2710u);
  sub_789C4(a1, 10, 81, 6);
  usleep(0x2710u);
  sub_789C4(a1, 14, 81, 6);
  usleep(0x2710u);
  sub_788A8(a1, 84, 9586980);
  usleep(0x2710u);
  sub_788A8(a1, 92, 9586980);
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DA0CC) --------------------------------------------------------
int __fastcall setup_serdes_phy(int a1)
{
  int v1; // r3
  _BYTE v4[4084]; // [sp+1Ch] [bp+Ch] BYREF
  int v5; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 v6; // [sp+1023h] [bp+1013h]
  int v7; // [sp+1024h] [bp+1014h]
  int v8; // [sp+1028h] [bp+1018h]
  int i; // [sp+102Ch] [bp+101Ch]

  v8 = 3;
  v7 = 3;
  for ( i = 0; ; ++i )
  {
    v1 = v7;
    if ( i >= v7 )
      break;
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "%s try cmn lock times %d", "setup_serdes_phy", i + 1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "setup_serdes_phy",
      16,
      12448,
      60,
      v4);
    v6 = -1;
    serdes_initial_seq_1_by_vendor(a1, 0, 255, 8u);
    SOC_24G_seq1_20210922_update(a1, 0, v6, 8);
    memset(v4, 0, 0x80u);
    v5 = serdes_phy_bist(a1, v6, 8u, (int)v4);
    v1 = v5;
    if ( !v5 )
      break;
    sub_7B47C(a1, (int)v4);
  }
  return v1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DA24C) --------------------------------------------------------
int __fastcall setup_all_chip_eth(int a1)
{
  puts("setup_all_chip_eth");
  *(_DWORD *)(a1 + 240) = sub_D9ED8(*(_DWORD *)(a1 + 296), 8u);
  (*(void (__fastcall **)(int, _DWORD, int))(a1 + 148))(a1, *(_DWORD *)(a1 + 296), 8);
  sub_759E8(a1, 8);
  setup_clk(a1);
  set_debug_ctrl(a1, 19);
  sub_77910(a1, 1);
  if ( *(_BYTE *)(a1 + 268) != 1 )
    *(_DWORD *)(a1 + 272) = (int)*(float *)(a1 + 760);
  return 0;
}

//----- (000DA2E0) --------------------------------------------------------
int __fastcall global_idx_init_eth(int a1)
{
  int v1; // r3
  void *s; // [sp+Ch] [bp+Ch]

  s = malloc(0x8901u);
  memset(s, 0, 0x8901u);
  *(_DWORD *)(a1 + 624) = s;
  printf("__custom_data init %p\n", s);
  return v1;
}
// DA318: variable 'v1' is possibly undefined

//----- (000DA320) --------------------------------------------------------
int __fastcall global_idx_free_eth(int a1)
{
  int v1; // r3

  v1 = *(_DWORD *)(a1 + 624);
  if ( v1 )
    free(*(void **)(a1 + 624));
  return v1;
}
// DA340: variable 'v1' is possibly undefined

//----- (000DA348) --------------------------------------------------------
int __fastcall set_baud_eth(int a1, char *a2)
{
  return sub_7658C(a1, a2);
}

//----- (000DA364) --------------------------------------------------------
int __fastcall check_nonce_eth(int a1, int a2)
{
  _DWORD *v2; // r5
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v18; // [sp+Ch] [bp-4h]
  _BYTE v21[20]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v22[8]; // [sp+101Ch] [bp+100Ch] BYREF
  _BYTE v23[12]; // [sp+1024h] [bp+1014h] BYREF
  _DWORD v24[8]; // [sp+1044h] [bp+1034h] BYREF
  _DWORD v25[8]; // [sp+1064h] [bp+1054h] BYREF
  unsigned __int8 v26; // [sp+1085h] [bp+1075h]
  unsigned __int8 v27; // [sp+1086h] [bp+1076h]
  char v28; // [sp+1087h] [bp+1077h]
  int v29; // [sp+1088h] [bp+1078h]
  int v30; // [sp+108Ch] [bp+107Ch]

  v30 = a2;
  v29 = *(_DWORD *)(a1 + 624);
  v28 = *(_BYTE *)(a2 + 16);
  v2 = (_DWORD *)(a2 + 34);
  v3 = *(_DWORD *)(a2 + 34);
  v4 = *(_DWORD *)(a2 + 38);
  v5 = v2[2];
  v6 = v2[3];
  v25[0] = v3;
  v25[1] = v4;
  v25[2] = v5;
  v25[3] = v6;
  v7 = v2[5];
  v8 = v2[6];
  v9 = v2[7];
  v25[4] = v2[4];
  v25[5] = v7;
  v25[6] = v8;
  v25[7] = v9;
  v10 = *(_DWORD *)(v30 + 102);
  v11 = *(_DWORD *)(v30 + 106);
  v12 = *(_DWORD *)(v30 + 110);
  v24[0] = *(_DWORD *)(v30 + 98);
  v24[1] = v10;
  v24[2] = v11;
  v24[3] = v12;
  v13 = *(_DWORD *)(v30 + 118);
  v14 = *(_DWORD *)(v30 + 122);
  v15 = *(_DWORD *)(v30 + 126);
  v24[4] = *(_DWORD *)(v30 + 114);
  v24[5] = v13;
  v24[6] = v14;
  v24[7] = v15;
  memcpy(v22, (const void *)(v30 + 26), sizeof(v22));
  sub_7565C(v25, v22, v24, (int)v23);
  v27 = target_to_diff_eth((int)v23);
  v26 = *(_BYTE *)(v29 + *(unsigned __int8 *)(v30 + 16) + 34816);
  V_LOCK();
  logfmt_raw(v21, 0x1000u, 0, "check_nonce_eth, diff:%d", v27);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
    83,
    "check_nonce_eth",
    15,
    12704,
    20,
    v21);
  if ( v27 > 0x1Cu )
  {
    if ( v27 >= (unsigned int)v26 )
    {
      return 0;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v21, 0x1000u, 0, "hw diff (%d<%d) not reach pool", v27, v26);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
        83,
        "check_nonce_eth",
        15,
        12739,
        20,
        v21);
      return 1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(
      v21,
      0x1000u,
      0,
      "hw error calculate diff %d ans diff %d TICKET_MASK_ETH %d",
      v27,
      *(unsigned __int8 *)(v30 + 17),
      29,
      v18,
      a2,
      a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_eth/backend_eth.c",
      83,
      "check_nonce_eth",
      15,
      12734,
      20,
      v21);
    return 2;
  }
}
// DA536: variable 'v18' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DA610) --------------------------------------------------------
int get_chip_status_eth()
{
  return 0;
}

//----- (000DA628) --------------------------------------------------------
int get_algo_type_eth()
{
  return 0;
}

//----- (000DA644) --------------------------------------------------------
int softreset_all_chip_eth()
{
  return 0;
}

//----- (000DA65C) --------------------------------------------------------
int __fastcall get_theory_hashrate_eth(int a1, double *a2)
{
  if ( *(_BYTE *)(a1 + 268) )
    *a2 = *(double *)(a1 + 280);
  else
    *a2 = 51200.0 / (double)0x1A9u * 10.0 * 1000.0 * 1000.0;
  return 0;
}

//----- (000DA6D0) --------------------------------------------------------
int set_boot_config_eth()
{
  return 0;
}

//----- (000DA6E8) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_eth(int a1)
{
  if ( !sub_781D0(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (000DA710) --------------------------------------------------------
int __fastcall read_sensor_temp_local_eth(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_77D54(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_77E1C(a1, a2, a3, a8);
  }
  return 0;
}

//----- (000DA760) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_eth(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  unsigned int v10; // [sp+14h] [bp+14h] BYREF

  if ( a5 )
  {
    if ( a5 == 1 )
    {
      v10 = 0;
      sub_77DB8(a1, &v10, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
      *a2 = v10 - 6;
    }
  }
  else
  {
    sub_77FF4(a1, a2, a3, a8);
  }
  return 0;
}

//----- (000DA7C0) --------------------------------------------------------
int parameter_update_eth()
{
  return 0;
}

//----- (000DA7E4) --------------------------------------------------------
int overclock_update_eth()
{
  return 0;
}

//----- (000DA7FC) --------------------------------------------------------
int __fastcall get_pcba_test_level_eth(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 768);
  return 0;
}

//----- (000DA820) --------------------------------------------------------
int __fastcall get_packet_remain_len_eth(unsigned __int8 a1)
{
  int v1; // r3

  switch ( a1 )
  {
    case 0x20u:
      return 40;
    case 0u:
      return 7;
    case 1u:
      return 9;
  }
  v1 = a1;
  if ( a1 == 2 )
    return 71;
  return v1;
}

//----- (000DA860) --------------------------------------------------------
int __fastcall stop_mining_eth(int a1)
{
  _UNKNOWN **v1; // r0

  (*(void (__fastcall **)(int))(a1 + 48))(a1);
  v1 = dev_ctrl();
  ((void (__fastcall *)(_DWORD))v1[9])(*(_DWORD *)(a1 + 136));
  *(_BYTE *)(a1 + 145) = 0;
  *(_BYTE *)(a1 + 146) = 0;
  set_ticketmask(a1, 63);
  sub_78860(a1, 82, 9);
  usleep((__useconds_t)&stru_1869C.st_value);
  sub_788A8(a1, 12, 2);
  usleep((__useconds_t)&stru_1869C.st_value);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000DA8D0) --------------------------------------------------------
int __fastcall recover_mining_eth(int a1)
{
  set_core_reset(*(_DWORD *)a1);
  setup_ref_clk_termination(*(_DWORD *)a1);
  get_special_core_reg(*(_DWORD *)a1);
  set_safe_mode(*(_DWORD *)a1, 42);
  disable_mac(*(_DWORD *)a1);
  set_logic_core_id(*(_DWORD *)a1);
  setup_mac_lane_cross(*(_DWORD *)a1);
  phy_power_reset(*(_DWORD *)a1);
  setup_serdes_phy(*(_DWORD *)a1);
  set_dag_node_num(*(_DWORD *)a1, *(__int64 *)(a1 + 8) >> 6);
  set_start_delay(*(_DWORD *)a1, 65554);
  set_reset_to_normal(*(_DWORD *)a1, 2);
  reverse_start_nonce(*(_DWORD *)a1, 0);
  set_data_preemptive(*(_DWORD *)a1, 1);
  set_nonce_num(*(_DWORD *)a1, 0);
  setup_mac(*(_DWORD *)a1);
  open_core_clk(*(_DWORD *)a1);
  set_work_mode(*(_DWORD *)a1, 0);
  set_work_timeout(*(_DWORD *)a1, 1);
  sub_76B94(*(_DWORD *)a1, 255, 127);
  set_core_bus_reset(*(_DWORD *)a1);
  setup_count_sync(*(_DWORD *)a1, 255);
  set_ticketmask(*(_DWORD *)a1, 63);
  open_cores_by_work_num(*(_DWORD *)a1);
  set_ticketmask(*(_DWORD *)a1, 29);
  *(_BYTE *)(*(_DWORD *)a1 + 145) = 1;
  *(_BYTE *)(*(_DWORD *)a1 + 146) = 1;
  return 0;
}

//----- (000DAA24) --------------------------------------------------------
int __fastcall update_mbist_cnt_for_pcba_test_base(int a1, void *a2)
{
  memcpy(a2, &unk_47B2D4, 0x20u);
  return 0;
}

//----- (000DAA4C) --------------------------------------------------------
int __fastcall prepare_for_pcba_test_base(int a1, int *a2)
{
  int v5; // [sp+Ch] [bp+Ch]

  v5 = *a2;
  if ( (unsigned int)*a2 <= 4 )
  {
    printf("%s: start to do prepare for pcba test\n", "prepare_for_pcba_test_base");
    *(_DWORD *)(a1 + 240) = sub_D9ED8(*(_DWORD *)(a1 + 296), 8u);
    (*(void (__fastcall **)(int, _DWORD, int))(a1 + 148))(a1, *(_DWORD *)(a1 + 296), 8);
    sub_759E8(a1, 8);
    setup_clk(a1);
    set_debug_ctrl(a1, 19);
    get_special_core_reg(a1);
    set_safe_mode(a1, 42);
    disable_mac(a1);
    set_logic_core_id(a1);
    setup_mac_lane_cross(a1);
    phy_power_reset(a1);
    if ( v5 == 2 || v5 != 4 && v5 )
      setup_serdes_phy(a1);
    membist1(a1);
    set_dag_node_num(a1, 100663198);
    set_start_delay(a1, 65554);
    set_reset_to_normal(a1, 2);
    reverse_start_nonce(a1, 0);
    set_data_preemptive(a1, 1);
    set_nonce_num(a1, 0);
    setup_mac(a1);
    open_core_clk(a1);
    set_work_mode(a1, 0);
    set_work_timeout(a1, 1);
    sub_76B94(a1, 255, 127);
    set_core_bus_reset(a1);
    setup_count_sync(a1, 255);
    set_ticketmask(a1, 63);
    open_cores_by_work_num(a1);
    set_ticketmask(a1, 29);
    *(_BYTE *)(a1 + 145) = 1;
    *(_BYTE *)(a1 + 146) = 1;
    printf("%s: do prepare finished\n", "prepare_for_pcba_test_base");
    return 0;
  }
  else
  {
    printf("%s: error! wrong PHY sequence parameter\n", "prepare_for_pcba_test_base");
    return 6;
  }
}

//----- (000DABD4) --------------------------------------------------------
void *runtime_ctrl_eth()
{
  void *dest; // [sp+84h] [bp+84h]

  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1EEFA0, 0x310u);
  return dest;
}
// 1EEFA0: using guessed type _UNKNOWN *off_1EEFA0;

//----- (000DAC10) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_DAC10(const char **a1, const char *a2)
{
  V_STR(a1, "error", a2);
}

//----- (000DAC34) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_DAC34(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (000DAC5C) --------------------------------------------------------
int __fastcall sub_DAC5C(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// DACA0: variable 'v3' is possibly undefined

//----- (000DAD3C) --------------------------------------------------------
int __fastcall sub_DAD3C(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DAE40) --------------------------------------------------------
_BYTE *__fastcall sub_DAE40(_BYTE *result, int a2)
{
  result[3] = a2;
  result[2] = BYTE1(a2);
  result[1] = BYTE2(a2);
  *result = HIBYTE(a2);
  return result;
}

//----- (000DAE88) --------------------------------------------------------
int __fastcall sub_DAE88(int a1, int a2)
{
  int v2; // r3
  int v4; // [sp+4h] [bp-44h]
  _BYTE v7[12]; // [sp+54h] [bp+Ch] BYREF
  int v8; // [sp+1054h] [bp+100Ch] BYREF
  _WORD v9[8]; // [sp+1058h] [bp+1010h] BYREF
  _DWORD v10[7]; // [sp+1068h] [bp+1020h] BYREF
  int v11; // [sp+1084h] [bp+103Ch]
  _DWORD v12[7]; // [sp+1088h] [bp+1040h] BYREF
  int v13; // [sp+10A4h] [bp+105Ch]
  const char *v14[8]; // [sp+10A8h] [bp+1060h] BYREF
  unsigned __int16 *v15; // [sp+10CCh] [bp+1084h]
  int v16; // [sp+10D0h] [bp+1088h]
  int j; // [sp+10D4h] [bp+108Ch]
  int i; // [sp+10D8h] [bp+1090h]
  int v19; // [sp+10DCh] [bp+1094h]

  v8 = 0;
  v19 = 0;
  v16 = 0;
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "get_addr %s chip_no %d", "ChipSetting_get_addr_LTC", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_LTC",
    24,
    26,
    20,
    v7);
  memset(v9, 0, sizeof(v9));
  LOBYTE(v9[4]) = 1;
  v9[5] = 0;
  v15 = (unsigned __int16 *)malloc(12 * a2);
  memset(v15, 0, 12 * a2);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int16 *, int *, int, int, _DWORD))(a1 + 176))(
    a1,
    v9,
    a2,
    v15,
    &v8,
    v4,
    3000,
    0);
  V_LOCK();
  sub_DAC34((int)v10, *(int *)(a1 + 140));
  logfmt_raw(
    v7,
    0x1000u,
    0,
    v11,
    v10[0],
    v10[1],
    v10[2],
    v10[3],
    v10[4],
    v10[5],
    v10[6],
    v11,
    "%s detect %d chips",
    "ChipSetting_get_addr_LTC",
    v8);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_addr_LTC",
    24,
    36,
    60,
    v7);
  for ( i = 0; i < v8; ++i )
  {
    v16 = (unsigned __int8)BYTE1(*(_DWORD *)&v15[6 * i]) | (unsigned __int16)(v15[6 * i] << 8);
    V_LOCK();
    logfmt_raw(
      v7,
      0x1000u,
      0,
      "[GET ADDR] chip_type %04x/%04x chip %d reg %d addr %02x",
      v16,
      *(_DWORD *)(a1 + 192),
      i,
      v15[6 * i + 3],
      LOBYTE(v15[6 * i + 2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_LTC",
      24,
      40,
      20,
      v7);
    if ( *(_DWORD *)(a1 + 192) == v16 )
      ++v19;
    for ( j = 0; *(_DWORD *)(a1 + 196) > j; ++j )
    {
      if ( LOBYTE(v15[6 * i + 2]) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
      {
        LOBYTE(v2) = j & 0x1F;
        if ( j <= 0 )
          v2 = -(-j & 0x1F);
        *(_DWORD *)(*(_DWORD *)(a1 + 300) + 4 * (j / 32)) = (1 << v2)
                                                          | *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300));
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, "detected_chip_bitmask %x", *(_DWORD *)(4 * (j / 32) + *(_DWORD *)(a1 + 300)));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
          72,
          "ChipSetting_get_addr_LTC",
          24,
          47,
          20,
          v7);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 196) > v19 )
  {
    V_LOCK();
    sub_DAC34((int)v12, *(int *)(a1 + 140));
    sub_DAC10(v14, "asic num error");
    logfmt_raw(
      v7,
      0x1000u,
      0,
      v13,
      v12[0],
      v12[1],
      v12[2],
      v12[3],
      v12[4],
      v12[5],
      v12[6],
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v14[7],
      "detected asic num less than design");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_addr_LTC",
      24,
      54,
      100,
      v7);
  }
  free(v15);
  *(_DWORD *)(a1 + 236) = v19;
  return v8;
}
// DAFE0: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DB470) --------------------------------------------------------
int __fastcall sub_DB470(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_LTC", 52);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_LTC",
    30,
    108,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 3407873;
  v4[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DB564) --------------------------------------------------------
int __fastcall sub_DB564(int a1, char a2)
{
  _BYTE v5[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "software_reset %s %02x", "ChipSetting_software_reset_one_asic_LTC", 52);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_software_reset_one_asic_LTC",
    39,
    121,
    20,
    v5);
  memset(v6, 0, 0x10u);
  LOBYTE(v6[2]) = 0;
  BYTE1(v6[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v6[2]) = 52;
  v6[0] = 1;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DB674) --------------------------------------------------------
int __fastcall sub_DB674(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1036h] [bp+1026h]
  unsigned __int8 v9; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v9 = 26;
  v8 = 3;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1572865;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v9 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v9 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v9 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v9 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v9 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v9 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v9 = 0;
    v8 = 1;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v9 = 26;
      goto LABEL_27;
    }
    v9 = 0;
    v8 = 0;
  }
LABEL_27:
  v7 = ((v9 & 0x1F) << 8) | (((v9 >> 5) & 0x1F) << 16) | 0x6061;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_LTC",
    20,
    204,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DB908) --------------------------------------------------------
int __fastcall sub_DB908(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = -65536;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1572865;
  if ( a2 == (char *)&loc_FE502 )
  {
LABEL_18:
    v8 = 2;
    goto LABEL_23;
  }
  if ( (int)a2 > 1041666 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( (int)a2 > 1562500 )
      {
        if ( a2 != (char *)&unk_2DC6C0 && a2 != byte_2FAF08 )
          goto LABEL_22;
        v8 = 0;
        goto LABEL_23;
      }
      if ( a2 != (char *)&loc_16E360 )
        goto LABEL_22;
    }
    v8 = 1;
    goto LABEL_23;
  }
  if ( a2 == "stem_Config_File_Information" )
  {
    v8 = 26;
    goto LABEL_23;
  }
  if ( (int)a2 > 115200 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
      goto LABEL_23;
    }
    if ( a2 != (char *)&loc_E1000 )
      goto LABEL_22;
    goto LABEL_18;
  }
  if ( a2 != (char *)38400 )
  {
LABEL_22:
    v8 = 26;
    goto LABEL_23;
  }
  v8 = 80;
LABEL_23:
  v7 |= v8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc_eth value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_misc_eth_LTC",
    24,
    252,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DBB2C) --------------------------------------------------------
unsigned int *__fastcall sub_DBB2C(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xC0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// DBB64: variable 'v1' is possibly undefined

//----- (000DBC3C) --------------------------------------------------------
int __fastcall sub_DBC3C(int a1)
{
  float v1; // s0
  _BYTE v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v5[4]; // [sp+101Ch] [bp+100Ch] BYREF
  unsigned int v6; // [sp+102Ch] [bp+101Ch] BYREF
  int v7; // [sp+1030h] [bp+1020h]
  float v8; // [sp+1034h] [bp+1024h]

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  v5[2] = 524289;
  sub_DBB2C(&v6);
  v8 = v1;
  v5[0] = v6;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v8, v1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_freq_LTC",
    20,
    288,
    20,
    v4);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
  usleep(0x2710u);
  return v7;
}
// DBCBC: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DBD90) --------------------------------------------------------
int __fastcall sub_DBD90(int a1, char a2)
{
  float v2; // s0
  _BYTE v6[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v7[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v8; // [sp+1034h] [bp+1024h] BYREF
  int v9; // [sp+1038h] [bp+1028h]
  float v10; // [sp+103Ch] [bp+102Ch]

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  LOBYTE(v7[2]) = 0;
  BYTE1(v7[2]) = *(_DWORD *)(a1 + 240) * a2;
  HIWORD(v7[2]) = 8;
  sub_DBB2C(&v8);
  v10 = v2;
  v7[0] = v8;
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v10, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_one_asic_freq_LTC",
    29,
    304,
    20,
    v6);
  v9 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v7);
  usleep(0x2710u);
  return v9;
}
// DBE32: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DBF10) --------------------------------------------------------
int __fastcall sub_DBF10(int a1)
{
  int v3; // [sp+4h] [bp-34h]
  _BYTE v5[8]; // [sp+40h] [bp+8h] BYREF
  int v6; // [sp+1040h] [bp+1008h] BYREF
  int v7; // [sp+1044h] [bp+100Ch] BYREF
  _DWORD v8[4]; // [sp+1048h] [bp+1010h] BYREF
  _DWORD v9[7]; // [sp+1058h] [bp+1020h] BYREF
  int v10; // [sp+1074h] [bp+103Ch]
  unsigned __int8 *v11; // [sp+1078h] [bp+1040h]
  int v12; // [sp+107Ch] [bp+1044h]
  int i; // [sp+1080h] [bp+1048h]
  unsigned __int8 v14; // [sp+1087h] [bp+104Fh]

  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "get clk cnt %s chip_no %d", "ChipSetting_clk_count_LTC", *(_DWORD *)(a1 + 196));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_clk_count_LTC",
    25,
    428,
    20,
    v5);
  memset(v8, 0, sizeof(v8));
  LOBYTE(v8[2]) = 1;
  HIWORD(v8[2]) = 48;
  v8[0] = 0x80000000;
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v8);
  if ( v12 >= 0 )
  {
    v14 = 0;
    v11 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 196));
    do
    {
      v6 = 0;
      usleep(0x3E8u);
      memset(v11, 0, 12 * *(_DWORD *)(a1 + 196));
      (*(void (__fastcall **)(int, _DWORD *, _DWORD, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 176))(
        a1,
        v8,
        *(_DWORD *)(a1 + 196),
        v11,
        &v7,
        v3,
        2000,
        0);
      for ( i = 0; i < v7; ++i )
      {
        if ( *(_WORD *)&v11[12 * i + 6] == 48 )
        {
          sub_DAE40(&v6, *(_DWORD *)&v11[12 * i]);
          V_LOCK();
          sub_DAC34((int)v9, *(int *)(a1 + 140));
          logfmt_raw(
            v5,
            0x1000u,
            0,
            v10,
            v9[0],
            v9[1],
            v9[2],
            v9[3],
            v9[4],
            v9[5],
            v9[6],
            v10,
            "%s asic %d, reg %02x CLKCNT %08x",
            "ChipSetting_clk_count_LTC",
            v11[12 * i + 4],
            *(unsigned __int16 *)&v11[12 * i + 6],
            v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
            72,
            "ChipSetting_clk_count_LTC",
            25,
            451,
            60,
            v5);
        }
      }
      if ( (_WORD)v6 )
        break;
      if ( !v7 )
        ++v14;
    }
    while ( v14 <= 4u );
    free(v11);
    return v7;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "%s failed, set reg:%02x", "ChipSetting_clk_count_LTC", HIWORD(v8[2]));
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_clk_count_LTC",
      25,
      436,
      100,
      v5);
    return -1;
  }
}
// DC11E: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DC2FC) --------------------------------------------------------
int __fastcall sub_DC2FC(int a1, int a2)
{
  _BYTE v5[24]; // [sp+18h] [bp+8h] BYREF
  _DWORD v6[6]; // [sp+1018h] [bp+1008h] BYREF

  memset(v6, 0, 0x10u);
  v6[2] = 2883585;
  v6[4] = a2;
  v6[0] = a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set analog value %08x", v6[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_analog_mux_LTC",
    26,
    480,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DC418) --------------------------------------------------------
int __fastcall sub_DC418(int a1, char a2, char a3, int a4)
{
  _DWORD v5[2]; // [sp+10h] [bp+10h] BYREF
  char v6; // [sp+18h] [bp+18h]
  char v7; // [sp+19h] [bp+19h]
  __int16 v8; // [sp+1Ah] [bp+1Ah]
  int v9; // [sp+1Ch] [bp+1Ch]

  v5[1] = 0;
  v9 = 0;
  v6 = a2;
  v7 = a3;
  v8 = 28;
  v5[0] = a4;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v5);
}

//----- (000DC464) --------------------------------------------------------
int __fastcall sub_DC464(int a1, char a2, int a3, _DWORD *a4, _DWORD *a5, signed int a6)
{
  size_t v6; // r3
  int v12; // [sp+24h] [bp+14h] BYREF
  _DWORD v13[2]; // [sp+28h] [bp+18h] BYREF
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  void *ptr; // [sp+38h] [bp+28h]
  size_t nmemb; // [sp+3Ch] [bp+2Ch]
  signed int j; // [sp+40h] [bp+30h]
  int i; // [sp+44h] [bp+34h]

  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  v15 = 0;
  v6 = a6;
  if ( a6 >= *(_DWORD *)(a1 + 196) )
    v6 = *(_DWORD *)(a1 + 196);
  nmemb = v6;
  ptr = calloc(v6, 0xCu);
  LOBYTE(v14) = a2;
  BYTE1(v14) = a3;
  HIWORD(v14) = 28;
  (*(void (__fastcall **)(int, _DWORD *, size_t, void *, int *))(a1 + 176))(a1, v13, nmemb, ptr, &v12);
  if ( a2 )
  {
    for ( i = 0; i < v12; ++i )
    {
      for ( j = 0; j < (int)nmemb; ++j )
      {
        if ( *((unsigned __int8 *)ptr + 12 * i + 4) == *(unsigned __int8 *)(j + *(_DWORD *)(a1 + 296)) )
        {
          a4[j] = *((_DWORD *)ptr + 3 * i);
          a5[j] = 1;
          break;
        }
      }
    }
  }
  else if ( v12 == 1 && *((unsigned __int8 *)ptr + 4) == a3 )
  {
    *a4 = *(_DWORD *)ptr;
    *a5 = 1;
  }
  free(ptr);
  return v12;
}

//----- (000DC584) --------------------------------------------------------
int __fastcall sub_DC584(int a1, char a2, int a3, int a4, _DWORD *s, _DWORD *a6, size_t n)
{
  if ( sub_DC418(a1, a2, a3, a4 | 0x1980000) )
    return 0;
  usleep(0xC350u);
  memset(s, 0, 4 * n);
  memset(a6, 0, 4 * n);
  return sub_DC464(a1, a2, a3, s, a6, n);
}

//----- (000DC5F8) --------------------------------------------------------
int __fastcall sub_DC5F8(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_DC584(a1, 1, 0, 0, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (000DC69C) --------------------------------------------------------
int __fastcall sub_DC69C(int a1, int a2, int a3, size_t a4)
{
  int v9; // [sp+28h] [bp+18h]
  _DWORD *ptr; // [sp+2Ch] [bp+1Ch]
  _DWORD *s; // [sp+30h] [bp+20h]
  int i; // [sp+34h] [bp+24h]

  s = malloc(4 * a4);
  ptr = malloc(4 * a4);
  v9 = sub_DC584(a1, 1, 0, 256, s, ptr, a4);
  for ( i = 0; i < v9; ++i )
  {
    *(_DWORD *)(4 * i + a2) = HIBYTE(s[i]) - 64;
    *(_DWORD *)(4 * i + a3) = ptr[i];
  }
  free(ptr);
  free(s);
  return v9;
}

//----- (000DC740) --------------------------------------------------------
int __fastcall sub_DC740(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_DC584(a1, 0, a4, 0, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (000DC7A4) --------------------------------------------------------
int __fastcall sub_DC7A4(int a1, unsigned int *a2, _DWORD *a3, int a4)
{
  int v8; // [sp+20h] [bp+10h] BYREF
  unsigned int s; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+28h] [bp+18h]
  unsigned int v11; // [sp+2Ch] [bp+1Ch]

  v10 = 0;
  v10 = sub_DC584(a1, 0, a4, 256, &s, &v8, 1u);
  if ( v10 == 1 )
  {
    v11 = HIBYTE(s);
    if ( *(_DWORD *)(a1 + 320) == 1 )
      v11 -= 64;
    *a2 = v11;
    *a3 = v8;
  }
  return v10;
}

//----- (000DC808) --------------------------------------------------------
int __fastcall sub_DC808(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_local_on_pic_LTC",
        45,
        636,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_local_on_pic_LTC",
      45,
      625,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DC9E0) --------------------------------------------------------
int __fastcall sub_DC9E0(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  _BYTE v10[8]; // [sp+20h] [bp+10h] BYREF
  char v11; // [sp+1023h] [bp+1013h] BYREF
  int v12; // [sp+1024h] [bp+1014h]

  *a3 = 0;
  v12 = pic1704_write_iic(*(_DWORD *)(a1 + 140), a4);
  if ( v12 )
  {
    usleep(0x2710u);
    v12 = pic1704_read_iic(*(_DWORD *)(a1 + 140), a4, &v11);
    if ( v12 )
    {
      *a3 = 1;
      *a2 = v11 + 15;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, "fail to read pic temp for chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_read_sensor_temp_remote_on_pic_LTC",
        46,
        661,
        20,
        v10);
    }
    return v12;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, "pic temp write iic error! chain %d iic_addr %d", *(_DWORD *)(a1 + 140), a4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_read_sensor_temp_remote_on_pic_LTC",
      46,
      650,
      20,
      v10);
    return v12;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DCBBC) --------------------------------------------------------
int __fastcall sub_DCBBC(int a1)
{
  int v2; // [sp+8h] [bp+8h]

  v2 = sub_DC418(a1, 1, 0, 26806532);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v2;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000DCBF4) --------------------------------------------------------
int __fastcall sub_DCBF4(int a1)
{
  _DWORD s[4]; // [sp+Ch] [bp+Ch] BYREF
  int v4; // [sp+1Ch] [bp+1Ch]

  memset(s, 0, sizeof(s));
  s[2] = 2359297;
  s[0] = 0x80000000;
  v4 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v4;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000DCC48) --------------------------------------------------------
int __fastcall sub_DCC48(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = 36;
  v13 = (unsigned __int8 *)malloc(12 * *(_DWORD *)(a1 + 236));
  memset(v13, 0, 12 * *(_DWORD *)(a1 + 236));
  (*(void (__fastcall **)(int, _WORD *, _DWORD, unsigned __int8 *, int *))(a1 + 176))(
    a1,
    v10,
    *(_DWORD *)(a1 + 236),
    v13,
    &v9);
  for ( i = 0; i < v9; ++i )
  {
    if ( *(_WORD *)&v13[12 * i + 6] == 36 )
    {
      V_LOCK();
      sub_DAC34((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_crc_status_LTC",
        30,
        705,
        60,
        v8);
    }
  }
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 236);
    if ( v3 >= a3 )
      v3 = a3;
    memcpy(a2, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DCF14) --------------------------------------------------------
int __fastcall sub_DCF14(int a1, char a2, int a3, void *a4)
{
  int v9; // [sp+20h] [bp+10h] BYREF
  _DWORD s[4]; // [sp+24h] [bp+14h] BYREF
  void *ptr; // [sp+34h] [bp+24h]

  v9 = 0;
  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  s[1] = a3;
  ptr = malloc(0x4Cu);
  memset(ptr, 0, 0xCu);
  (*(void (__fastcall **)(int, _DWORD *, int, void *, int *))(a1 + 180))(a1, s, 1, ptr, &v9);
  if ( a4 )
    memcpy(a4, (char *)ptr + 10, 0x40u);
  free(ptr);
  return v9;
}

//----- (000DCFA0) --------------------------------------------------------
unsigned int __fastcall sub_DCFA0(int a1, int a2, void *a3)
{
  unsigned int v3; // r2
  _BYTE v8[28]; // [sp+44h] [bp+14h] BYREF
  unsigned int v9; // [sp+1044h] [bp+1014h] BYREF
  _WORD v10[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v11[7]; // [sp+1058h] [bp+1028h] BYREF
  int v12; // [sp+1074h] [bp+1044h]
  unsigned __int8 *v13; // [sp+1078h] [bp+1048h]
  int i; // [sp+107Ch] [bp+104Ch]

  v9 = 0;
  memset(v10, 0, sizeof(v10));
  v10[4] = 1;
  v10[5] = a2;
  v13 = (unsigned __int8 *)malloc(0x5A0u);
  memset(v13, 0, 0x5A0u);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, unsigned int *))(a1 + 176))(a1, v10, 120, v13, &v9);
  for ( i = 0; i < (int)v9; ++i )
  {
    if ( *(unsigned __int16 *)&v13[12 * i + 6] == a2 )
    {
      V_LOCK();
      sub_DAC34((int)v11, *(int *)(a1 + 140));
      logfmt_raw(
        v8,
        0x1000u,
        0,
        v12,
        v11[0],
        v11[1],
        v11[2],
        v11[3],
        v11[4],
        v11[5],
        v11[6],
        v12,
        "[Chip status] asic %02x, reg %02x state %08x",
        v13[12 * i + 4],
        *(unsigned __int16 *)&v13[12 * i + 6],
        *(_DWORD *)&v13[12 * i]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
        72,
        "ChipSetting_get_chip_status_LTC",
        31,
        758,
        60,
        v8);
    }
  }
  if ( a3 )
  {
    v3 = v9;
    if ( v9 >= *(_DWORD *)(a1 + 236) )
      v3 = *(_DWORD *)(a1 + 236);
    memcpy(a3, v13, 12 * v3);
  }
  free(v13);
  return v9;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DD250) --------------------------------------------------------
int __fastcall sub_DD250(int a1, __int16 a2, int a3)
{
  _DWORD v4[2]; // [sp+10h] [bp+10h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  __int16 v6; // [sp+1Ah] [bp+1Ah]
  int v7; // [sp+1Ch] [bp+1Ch]

  v4[1] = 0;
  v5 = 1;
  v7 = 0;
  v6 = a2;
  v4[0] = a3;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}

//----- (000DD298) --------------------------------------------------------
int __fastcall sub_DD298(int a1, __int16 a2, int a3)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v8; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a2;
  LOBYTE(s[3]) = -1;
  s[0] = a3;
  v8 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v8;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000DD2F0) --------------------------------------------------------
int __fastcall sub_DD2F0(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = -1;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000DD350) --------------------------------------------------------
int __fastcall sub_DD350(int a1, char a2, char a3, __int16 a4, int a5)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 0;
  BYTE1(s[2]) = a2;
  HIWORD(s[2]) = a4;
  LOBYTE(s[3]) = a3;
  s[0] = a5;
  v11 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v11;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000DD3B4) --------------------------------------------------------
int __fastcall sub_DD3B4(int a1, char a2, __int16 a3, int a4)
{
  _DWORD s[4]; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+24h] [bp+24h]

  memset(s, 0, sizeof(s));
  LOBYTE(s[2]) = 1;
  HIWORD(s[2]) = a3;
  LOBYTE(s[3]) = a2;
  s[0] = a4;
  v10 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, s);
  usleep((__useconds_t)&stru_1869C.st_value);
  return v10;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000DD410) --------------------------------------------------------
int __fastcall sub_DD410(int a1, __int16 a2, __int16 a3, void *a4)
{
  int v5; // [sp+4h] [bp-34h]
  char v8; // [sp+42h] [bp+Ah]
  int v10; // [sp+4Ch] [bp+14h] BYREF
  int v11; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v12[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v13[7]; // [sp+1060h] [bp+1028h] BYREF
  int v14; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v15; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v17; // [sp+108Ch] [bp+1054h]

  v8 = a2;
  v11 = 0;
  v17 = *(_DWORD *)(a1 + 236);
  if ( a2 == 255 )
    v17 = 117 * *(_DWORD *)(a1 + 236);
  V_LOCK();
  logfmt_raw(&v10, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_core_status_LTC", v17);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_core_status_LTC",
    31,
    844,
    20,
    &v10);
  memset(v12, 0, sizeof(v12));
  v12[4] = 1;
  v15 = (unsigned __int8 *)malloc(12 * v17);
  v12[5] = a3;
  LOBYTE(v12[6]) = v8;
  memset(v15, 0, 12 * v17);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v12,
    v17,
    v15,
    &v11,
    v5,
    2000,
    0);
  for ( i = 0; i < v11; ++i )
  {
    V_LOCK();
    sub_DAC34((int)v13, *(int *)(a1 + 140));
    logfmt_raw(
      &v10,
      0x1000u,
      0,
      v14,
      v13[0],
      v13[1],
      v13[2],
      v13[3],
      v13[4],
      v13[5],
      v13[6],
      v14,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v15[12 * i + 4],
      v15[12 * i + 8],
      *(unsigned __int16 *)&v15[12 * i + 6],
      *(_DWORD *)&v15[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_core_status_LTC",
      31,
      856,
      20,
      &v10);
  }
  if ( a4 )
    memcpy(a4, v15, 12 * v17);
  free(v15);
  return v11;
}
// DD5D0: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DD794) --------------------------------------------------------
int __fastcall sub_DD794(int a1, char a2, __int16 a3, __int16 a4, void *a5)
{
  int v6; // [sp+4h] [bp-34h]
  char v8; // [sp+40h] [bp+8h]
  int v11; // [sp+4Ch] [bp+14h] BYREF
  int v12; // [sp+104Ch] [bp+1014h] BYREF
  _WORD v13[8]; // [sp+1050h] [bp+1018h] BYREF
  _DWORD v14[7]; // [sp+1060h] [bp+1028h] BYREF
  int v15; // [sp+107Ch] [bp+1044h]
  unsigned __int8 *v16; // [sp+1084h] [bp+104Ch]
  int i; // [sp+1088h] [bp+1050h]
  int v18; // [sp+108Ch] [bp+1054h]

  v8 = a3;
  v12 = 0;
  v18 = 1;
  if ( a3 == 255 )
    v18 = 117;
  V_LOCK();
  logfmt_raw(&v11, 0x1000u, 0, "%s core_no %d", "ChipSetting_get_single_chip_core_status_LTC", v18);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
    72,
    "ChipSetting_get_single_chip_core_status_LTC",
    43,
    873,
    20,
    &v11);
  memset(v13, 0, sizeof(v13));
  LOBYTE(v13[4]) = 0;
  HIBYTE(v13[4]) = a2;
  v16 = (unsigned __int8 *)malloc(12 * v18);
  v13[5] = a4;
  LOBYTE(v13[6]) = v8;
  memset(v16, 0, 12 * v18);
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v13,
    v18,
    v16,
    &v12,
    v6,
    2000,
    0);
  for ( i = 0; i < v12; ++i )
  {
    V_LOCK();
    sub_DAC34((int)v14, *(int *)(a1 + 140));
    logfmt_raw(
      &v11,
      0x1000u,
      0,
      v15,
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v14[4],
      v14[5],
      v14[6],
      v15,
      "[Core State] asic %02x core %02x reg %04x state %08x",
      v16[12 * i + 4],
      v16[12 * i + 8],
      *(unsigned __int16 *)&v16[12 * i + 6],
      *(_DWORD *)&v16[12 * i]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_setting.c",
      72,
      "ChipSetting_get_single_chip_core_status_LTC",
      43,
      885,
      20,
      &v11);
  }
  if ( a5 )
    memcpy(a5, v16, 12 * v18);
  free(v16);
  return v12;
}
// DD944: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DDB0C) --------------------------------------------------------
int __fastcall global_idx_init_ltc(int a1)
{
  void *s; // [sp+Ch] [bp+Ch]

  s = malloc(0x6A08u);
  memset(s, 0, 0x6A08u);
  *(_DWORD *)(a1 + 624) = s;
  printf("__custom_data init %p\n", s);
  return 0;
}

//----- (000DDB4C) --------------------------------------------------------
int __fastcall global_idx_free_ltc(int a1)
{
  free(*(void **)(a1 + 624));
  return 0;
}

//----- (000DDB6C) --------------------------------------------------------
__int64 __fastcall sub_DDB6C(int a1, unsigned __int8 a2)
{
  int v2; // r0
  _BYTE v6[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[4088]; // [sp+1018h] [bp+1008h] BYREF
  int v8; // [sp+2018h] [bp+2008h]
  unsigned int i; // [sp+201Ch] [bp+200Ch]

  v8 = 0;
  for ( i = 0; i <= 0x4F; ++i )
  {
    v2 = snprintf(&v7[v8], 4096 - v8, "%02x ", *(unsigned __int8 *)(i + a1 + 72));
    v8 += v2;
  }
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "ltc dump work jobid %s, work count %02x", a1 + 8, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
    83,
    "dump_work_ltc",
    13,
    106,
    20,
    v6);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, "dump work: %s", v7);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
           83,
           "dump_work_ltc",
           13,
           107,
           20,
           v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DDD00) --------------------------------------------------------
int __fastcall sub_DDD00(int a1, int a2, int a3)
{
  unsigned int v4; // [sp+14h] [bp+14h]
  unsigned int v5; // [sp+20h] [bp+20h]

  v5 = (_byteswap_ulong(*(_DWORD *)a3) - a2) << 7;
  v4 = ((((v5 & 0x1FE0000) >> 17)
       - *(unsigned __int8 *)(((v5 & 0x1FE0000) >> 17) / *(_DWORD *)(a1 + 240) + *(_DWORD *)(a1 + 296))) << 17)
     | v5 & 0xFE01FFFF;
  *(_BYTE *)a3 = HIBYTE(v4);
  *(_BYTE *)(a3 + 1) = BYTE2(v4);
  *(_BYTE *)(a3 + 2) = BYTE1(v4);
  *(_BYTE *)(a3 + 3) = v4;
  return 0;
}

//----- (000DDDB0) --------------------------------------------------------
int __fastcall sub_DDDB0(int result, int a2)
{
  char v2; // [sp+Fh] [bp+Fh]
  int i; // [sp+10h] [bp+10h]
  int v4; // [sp+14h] [bp+14h]

  v4 = 0;
  for ( i = a2 - 1; v4 < i; --i )
  {
    v2 = *(_BYTE *)(v4 + result);
    *(_BYTE *)(v4 + result) = *(_BYTE *)(i + result);
    *(_BYTE *)(i + result) = v2;
    ++v4;
  }
  return result;
}

//----- (000DDE0C) --------------------------------------------------------
int __fastcall work_2_packet_ltc(int a1, int a2, _BYTE *a3, _DWORD *a4)
{
  char v4; // r3
  _BYTE v8[20]; // [sp+24h] [bp+14h] BYREF
  unsigned __int16 v9; // [sp+1026h] [bp+1016h]
  int v10; // [sp+1028h] [bp+1018h]
  int v11; // [sp+102Ch] [bp+101Ch]
  int v12; // [sp+1030h] [bp+1020h]
  _BYTE *v13; // [sp+1034h] [bp+1024h]

  v13 = a3;
  v12 = a2;
  v11 = 0;
  v10 = *(_DWORD *)(a1 + 624);
  *a3 = 85;
  v13[1] = -86;
  v13[2] = 32;
  if ( *(_DWORD *)(a1 + 304) == 1 )
    v13[2] |= 0x10u;
  *(_QWORD *)(8 * *(unsigned __int8 *)(v10 + 27136) + v10) = *(_QWORD *)v12;
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 27136) + 4864)) = *(_DWORD *)(v12 + 152);
  memcpy((void *)(v10 + 32 * (*(unsigned __int8 *)(v10 + 27136) + 624)), (const void *)(v12 + 156), 0x20u);
  strcpy((char *)(v10 + ((*(unsigned __int8 *)(v10 + 27136) + 16) << 6)), (const char *)(v12 + 8));
  memcpy((void *)(v10 + 80 * *(unsigned __int8 *)(v10 + 27136) + 9216), (const void *)(v12 + 72), 0x50u);
  memcpy(
    (void *)(v10 + 16 * (*(unsigned __int8 *)(v10 + 27136) + 1504)),
    (const void *)(v12 + 188),
    *(_DWORD *)(v12 + 204));
  *(_DWORD *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 27136) + 6528)) = *(_DWORD *)(v12 + 204);
  memcpy((void *)(v10 + 4 * (*(unsigned __int8 *)(v10 + 27136) + 6656)), (const void *)(v12 + 208), 4u);
  v4 = *(_BYTE *)(v10 + 27136);
  *(_BYTE *)(v10 + 27136) = v4 + 1;
  v13[3] = v4;
  *(_BYTE *)(v10 + 27136) &= ~0x80u;
  memcpy(v13 + 4, (const void *)(v12 + 72), 0x50u);
  sub_DDDB0((int)(v13 + 4), 80);
  if ( !memcmp(&last_work_ltc, (const void *)(v12 + 72), 0x50u) )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "found repeat work");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
      83,
      "work_2_packet_ltc",
      17,
      185,
      80,
      v8);
    sub_DDB6C(v12, v13[3]);
  }
  memcpy(&last_work_ltc, (const void *)(v12 + 72), 0x50u);
  v11 = 82;
  v9 = CRC16_v1(v13 + 2, 82);
  v13[84] = HIBYTE(v9);
  v13[85] = v9;
  *a4 = 86;
  if ( *(_BYTE *)(a1 + 145) && *(_BYTE *)(a1 + 146) )
  {
    memset(*(void **)(a1 + 264), 0, 48 * *(_DWORD *)(a1 + 196));
    chip_setting_ticket_mask_ltc(a1, 0x7FFu);
    *(_BYTE *)(a1 + 145) = 0;
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DE278) --------------------------------------------------------
__int64 __fastcall sub_DE278(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  _BYTE v9[40]; // [sp+40h] [bp+10h] BYREF
  _BYTE v10[4080]; // [sp+1040h] [bp+1010h] BYREF
  _DWORD v11[7]; // [sp+2040h] [bp+2010h] BYREF
  int v12; // [sp+205Ch] [bp+202Ch]
  int v13; // [sp+2060h] [bp+2030h]
  unsigned int i; // [sp+2064h] [bp+2034h]

  v13 = 0;
  for ( i = 0; i <= 3; ++i )
  {
    v3 = snprintf(&v10[v13], 4096 - v13, "%02x ", *(unsigned __int8 *)(i + a2 + 2));
    v13 += v3;
  }
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "work_id: %02x diff %02x", *(unsigned __int8 *)(a2 + 7), *(_BYTE *)(a2 + 6) & 0x3F);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
    83,
    "dump_nonce_ltc",
    14,
    214,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "back nonce: %s", v10);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
    83,
    "dump_nonce_ltc",
    14,
    215,
    20,
    v9);
  i = 0;
  v13 = 0;
  while ( i <= 3 )
  {
    v4 = snprintf(&v10[v13], 4096 - v13, "%02x ", *(unsigned __int8 *)(i + a3 + 80));
    v13 += v4;
    ++i;
  }
  V_LOCK();
  sub_DAC34((int)v11, *(int *)(a1 + 140));
  logfmt_raw(
    v9,
    0x1000u,
    0,
    v12,
    v11[0],
    v11[1],
    v11[2],
    v11[3],
    v11[4],
    v11[5],
    v11[6],
    v12,
    "asic %d core %d addr_interval %d",
    *(_DWORD *)(a3 + 8),
    *(_DWORD *)(a3 + 12),
    *(_DWORD *)(a1 + 240));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
    83,
    "dump_nonce_ltc",
    14,
    221,
    20,
    v9);
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "nonce: %s", v10);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
           83,
           "dump_nonce_ltc",
           14,
           222,
           20,
           v9);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DE5D0) --------------------------------------------------------
int __fastcall packet_2_nonce_ltc(_DWORD *a1, _BYTE *a2, int a3, _BYTE *a4, void *dest, _DWORD *a6, _DWORD *a7)
{
  int v8; // r0
  int v9; // r1
  int v13; // [sp+14h] [bp+14h]
  unsigned __int16 v14; // [sp+1Ah] [bp+1Ah]
  unsigned __int8 v15; // [sp+1Fh] [bp+1Fh]

  if ( a2[8] >> 5 != 4 )
    return 1;
  v14 = BM_CRC5(a2 + 2, 0x33u);
  if ( v14 == (a2[8] & 0x1F) )
  {
    v13 = a1[156];
    *(_QWORD *)a3 = *(_QWORD *)(8 * (unsigned __int8)a2[7] + v13);
    *a7 = *(_DWORD *)(8 * (unsigned __int8)a2[7] + v13);
    strcpy((char *)(a3 + 16), (const char *)((((unsigned __int8)a2[7] + 16) << 6) + v13));
    memcpy((void *)(a3 + 80), a2 + 2, 4u);
    *(_BYTE *)(a3 + 84) = a2[6] & 0x3F;
    *(_BYTE *)(a3 + 85) = a2[7];
    memcpy(
      (void *)(a3 + 86),
      (const void *)(v13 + 16 * ((unsigned __int8)a2[7] + 1504)),
      *(_DWORD *)(v13 + 4 * ((unsigned __int8)a2[7] + 6528)));
    *(_DWORD *)(a3 + 104) = *(_DWORD *)(v13 + 4 * ((unsigned __int8)a2[7] + 6528));
    memcpy((void *)(a3 + 108), (const void *)(4 * ((unsigned __int8)a2[7] + 6656) + v13), 4u);
    v15 = ((a2[3] >> 1) | (unsigned int)(unsigned __int8)(a2[2] << 7)) / a1[60];
    if ( v15 >= (int)a1[49] )
    {
      v8 = rand();
      sub_1A38EC(v8, a1[49]);
      *a6 = v9;
    }
    else
    {
      *a6 = v15;
    }
    *(_DWORD *)(a3 + 8) = *a6;
    *(_DWORD *)(a3 + 12) = a2[2] >> 1;
    memcpy(dest, (const void *)(a3 + 80), 4u);
    *a4 = 1;
    return 0;
  }
  else
  {
    printf("chain[%d] get nonce crc error calc value %04x expected value %04x\n", a1[34], v14, a2[8] & 0x1F);
    return 2;
  }
}
// DE762: variable 'v9' is possibly undefined

//----- (000DE798) --------------------------------------------------------
bool __fastcall sub_DE798(_DWORD *a1, char a2)
{
  _UNKNOWN **v2; // r0
  _UNKNOWN **v3; // r0
  _UNKNOWN **v4; // r0
  int v5; // r3
  unsigned int v9; // [sp+8h] [bp+8h]
  int v10; // [sp+Ch] [bp+Ch]

  v9 = a1[49];
  v10 = 0;
  a1[59] = 0;
  while ( a1[59] < v9 )
  {
    v5 = v10++;
    if ( v5 > 2 )
      break;
    sub_DAE88((int)a1, v9);
    if ( a2 && a1[59] < v9 )
    {
      v2 = dev_ctrl();
      ((void (__fastcall *)(_DWORD))v2[7])(a1[34]);
      usleep(0x493E0u);
      v3 = dev_ctrl();
      ((void (__fastcall *)(_DWORD, _DWORD, _DWORD))v3[6])(a1[34], a1[191], a1[194]);
      v4 = dev_ctrl();
      ((void (__fastcall *)(_DWORD))v4[9])(a1[34]);
    }
    usleep(0x493E0u);
  }
  return a1[59] == v9;
}

//----- (000DE860) --------------------------------------------------------
int __fastcall sub_DE860(int a1, unsigned __int8 a2)
{
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v5 = sub_1A3658(256, a2);
  for ( i = 0; a2 > i; ++i )
    *(_BYTE *)(i + a1) = v5 * i;
  return v5;
}

//----- (000DE8B0) --------------------------------------------------------
int __fastcall sub_DE8B0(int a1, unsigned int a2)
{
  int v2; // r1
  int v3; // r3
  _BYTE v7[20]; // [sp+1Ch] [bp+Ch] BYREF
  int v8; // [sp+101Ch] [bp+100Ch]
  int v9; // [sp+1020h] [bp+1010h]
  float v10; // [sp+1024h] [bp+1014h]
  int i; // [sp+1028h] [bp+1018h]
  float v12; // [sp+102Ch] [bp+101Ch]

  v10 = 900.0;
  v9 = sub_1A3658((int)(float)(*(float *)(a1 + 760) - 900.0), a2);
  sub_1A38EC((int)(float)(*(float *)(a1 + 760) - 900.0), a2);
  v8 = v2;
  for ( i = 0; i < v9; ++i )
  {
    chip_setting_freq_ltc(a1, 1, 0);
    *(_DWORD *)(a1 + 272) = (int)(float)((float)(int)(a2 * (i + 1)) + v10);
    usleep(0x7A120u);
    v12 = (float)(int)(a2 * (i + 1)) + v10;
  }
  if ( v8 )
  {
    chip_setting_freq_ltc(a1, 1, 0);
    *(_DWORD *)(a1 + 272) = (int)*(float *)(a1 + 760);
    usleep(0x7A120u);
    v12 = *(float *)(a1 + 760);
  }
  V_LOCK();
  logfmt_raw(v7, 0x1000u, 0, "Set chip freq=%f", v12);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
    83,
    "set_working_freq_by_steps",
    25,
    329,
    60,
    v7);
  return v3;
}
// DE936: variable 'v2' is possibly undefined
// DEB14: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DEB24) --------------------------------------------------------
int __fastcall setup_all_chip_ltc(_DWORD *a1)
{
  _DWORD *v3; // [sp+14h] [bp+4h]
  _BYTE v4[4100]; // [sp+1Ch] [bp+Ch] BYREF
  void *v5; // [sp+1020h] [bp+1010h]
  int v6; // [sp+1024h] [bp+1014h]
  int i; // [sp+102Ch] [bp+101Ch]

  v3 = a1;
  v6 = a1[49];
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "%s", "setup_all_chip_ltc");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
    83,
    "setup_all_chip_ltc",
    18,
    335,
    60,
    v4);
  if ( !sub_DE798(v3, 1) )
    return 3;
  v3[60] = sub_DE860(v3[74], v6);
  ((void (__fastcall *)(_DWORD *, _DWORD, int))v3[37])(v3, v3[74], v6);
  sub_DC2FC((int)v3, 0);
  chip_setting_ticket_mask_ltc((int)v3, 0xFFFFFFFF);
  for ( i = 0; v3[50] > i; ++i )
  {
    v5 = malloc(4 * v6);
    v4[4099] = 1;
    chip_setting_working_mode_ltc((int)v3, 1, 0, 0, i, 0xFFu);
    free(v5);
  }
  v3[68] = 900;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "get addr after open cores and set frequency.");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
    83,
    "setup_all_chip_ltc",
    18,
    403,
    60,
    v4);
  if ( !sub_DE798(v3, 0) )
    return 3;
  else
    return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DEE04) --------------------------------------------------------
int __fastcall set_baud_ltc(int a1, char *a2)
{
  return chip_setting_misc_ltc(a1, a2);
}

//----- (000DEE20) --------------------------------------------------------
int __fastcall sub_DEE20(int a1, int a2)
{
  int i; // [sp+10h] [bp+10h]
  unsigned __int8 v4; // [sp+17h] [bp+17h]

  v4 = 1;
  for ( i = 7; i >= 0; --i )
  {
    if ( *(_DWORD *)(4 * i + a1) > *(_DWORD *)(4 * i + a2) )
      return 0;
    if ( *(_DWORD *)(4 * i + a1) < *(_DWORD *)(4 * i + a2) )
      return 1;
  }
  return v4;
}

//----- (000DEE94) --------------------------------------------------------
int __fastcall check_nonce_ltc(int a1, int a2)
{
  int v4; // [sp+Ch] [bp-4h]
  int v7; // [sp+1Ch] [bp+Ch] BYREF
  unsigned int v8; // [sp+101Ch] [bp+100Ch] BYREF
  _DWORD v9[4]; // [sp+1020h] [bp+1010h] BYREF
  _BYTE v10[80]; // [sp+1040h] [bp+1030h] BYREF
  unsigned __int8 v11; // [sp+1093h] [bp+1083h]
  unsigned int v12; // [sp+1094h] [bp+1084h]
  int v13; // [sp+1098h] [bp+1088h]
  int v14; // [sp+109Ch] [bp+108Ch]

  v14 = a2;
  v13 = *(_DWORD *)(a1 + 624);
  v12 = *(_DWORD *)(v13 + 4 * (*(unsigned __int8 *)(a2 + 85) + 4864));
  memcpy(v10, (const void *)(v13 + 80 * *(unsigned __int8 *)(a2 + 85) + 9216), sizeof(v10));
  v8 = _byteswap_ulong(*(_DWORD *)(v14 + 80));
  memcpy(&v10[76], &v8, 4u);
  scrypt_regenhash(v9, (int)v10);
  v11 = target_to_diff_ltc((int)v9);
  if ( v11 > 0x1Au )
  {
    if ( (*(_BYTE *)(v14 + 84) & 0x20) != 0 )
    {
      if ( v11 <= 0x2Fu )
      {
        V_LOCK();
        logfmt_raw(
          &v7,
          0x1000u,
          0,
          "calculate diff %02x, but ans diff %02x (bit5 is 1)",
          v11,
          *(unsigned __int8 *)(v14 + 84));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
          83,
          "check_nonce_ltc",
          15,
          467,
          20,
          &v7);
        return 3;
      }
    }
    else if ( v11 != *(unsigned __int8 *)(v14 + 84) + 16 )
    {
      V_LOCK();
      logfmt_raw(&v7, 0x1000u, 0, "diff not match, calculate %02x ans diff %02x", v11, *(unsigned __int8 *)(v14 + 84));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
        83,
        "check_nonce_ltc",
        15,
        472,
        20,
        &v7);
      return 3;
    }
    if ( v11 < v12 || (unsigned __int8)sub_DEE20((int)v9, v13 + 32 * (*(unsigned __int8 *)(v14 + 85) + 624)) != 1 )
    {
      V_LOCK();
      logfmt_raw(&v7, 0x1000u, 0, "hw diff (%d<%d) not reach pool", v11, v12);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
        83,
        "check_nonce_ltc",
        15,
        478,
        20,
        &v7);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(
      &v7,
      0x1000u,
      0,
      "hw error calculate diff %02x ans diff %02x TICKET_MASK_ZERO_COUNT_LTC %02x",
      v11,
      *(unsigned __int8 *)(v14 + 84),
      27,
      v4,
      a2,
      a1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/backend_ltc.c",
      83,
      "check_nonce_ltc",
      15,
      461,
      20,
      &v7);
    return 2;
  }
}
// DF01C: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DF264) --------------------------------------------------------
int __fastcall get_chip_status_ltc(_DWORD *a1, int a2)
{
  int v3; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v3 = a1[81];
  for ( i = 0; a1[49] > i; ++i )
  {
    if ( (int)a1[82] <= 1
      && *(_BYTE *)(8 * i + v3) != 1
      && (*(_DWORD *)(4 * i + a2) == 2 || *(_DWORD *)(4 * i + a2) == 3) )
    {
      *(_BYTE *)(8 * i + v3) = 1;
      ++a1[82];
    }
    if ( *(_BYTE *)(8 * i + v3) && (*(_DWORD *)(4 * i + a2) == 2 || *(_DWORD *)(4 * i + a2) == 3) )
      *(_DWORD *)(4 * i + a2) = 0;
  }
  return 0;
}

//----- (000DF328) --------------------------------------------------------
int get_algo_type_ltc()
{
  return 0;
}

//----- (000DF344) --------------------------------------------------------
int __fastcall softreset_all_chip_ltc(int a1)
{
  chip_setting_software_reset_ltc(a1);
  return 0;
}

//----- (000DF35C) --------------------------------------------------------
int __fastcall get_theory_hashrate_ltc(int a1, double *a2)
{
  *a2 = (double)*(int *)(a1 + 196)
      * (float)((float)(*(float *)(a1 + 760) + *(float *)(a1 + 760)) / 130050.0)
      * (double)(8 * *(_DWORD *)(a1 + 200) - 5)
      * 1000.0
      * 1000.0;
  return 0;
}

//----- (000DF400) --------------------------------------------------------
int set_boot_config_ltc()
{
  return 0;
}

//----- (000DF418) --------------------------------------------------------
int __fastcall set_sensor_extern_mode_ltc(int a1)
{
  if ( !sub_DCBBC(a1) )
    *(_DWORD *)(a1 + 320) = 1;
  return 0;
}

//----- (000DF440) --------------------------------------------------------
int __fastcall read_sensor_temp_local_ltc(int a1, unsigned int *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
      sub_DC740(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
  }
  else
  {
    sub_DC808(a1, a2, a3, a8);
  }
  return 0;
}

//----- (000DF490) --------------------------------------------------------
int __fastcall read_sensor_temp_remote_ltc(
        int a1,
        unsigned int *a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  if ( a5 )
  {
    if ( a5 == 1 )
    {
      sub_DC7A4(a1, a2, a3, *(unsigned __int8 *)(*(_DWORD *)(a1 + 296) + a8));
      if ( *a3 )
        *a2 -= 13;
    }
  }
  else
  {
    sub_DC9E0(a1, a2, a3, a8);
  }
  return 0;
}

//----- (000DF4F4) --------------------------------------------------------
int __fastcall parameter_update_ltc(int a1, char a2, int a3, char a4, int a5)
{
  if ( *(_BYTE *)(a1 + 144) != 1 )
  {
    if ( a2 && a3 >= 900 && a3 <= 1900 )
    {
      *(_DWORD *)(a1 + 772) = (int)*(float *)(a1 + 760) * (*(_DWORD *)(a1 + 772) / (unsigned int)a3);
      *(float *)(a1 + 760) = (float)a3;
    }
    if ( a4 && a5 >= 1400 && a5 <= 1550 )
      *(_DWORD *)(a1 + 764) = a5;
  }
  return 0;
}

//----- (000DF598) --------------------------------------------------------
int overclock_update_ltc()
{
  return 0;
}

//----- (000DF5B0) --------------------------------------------------------
int get_pcba_test_level_ltc()
{
  return 0;
}

//----- (000DF5C8) --------------------------------------------------------
int get_packet_remain_len_ltc()
{
  return 6;
}

//----- (000DF5E0) --------------------------------------------------------
int __fastcall adjust_working_freq_ltc(int a1, int a2)
{
  float v5; // [sp+8h] [bp+8h]
  int v6; // [sp+Ch] [bp+Ch]

  v6 = 9;
  v5 = (float)(a2 + *(_DWORD *)(a1 + 272));
  if ( *(float *)(a1 + 760) <= v5 )
  {
    v5 = *(float *)(a1 + 760);
    v6 = 0;
LABEL_5:
    chip_setting_freq_ltc(a1, 1, 0);
    *(_DWORD *)(a1 + 272) = (int)v5;
    return v6;
  }
  if ( v5 >= 900.0 )
    goto LABEL_5;
  return 9;
}

//----- (000DF66C) --------------------------------------------------------
void *runtime_ctrl_ltc()
{
  void *dest; // [sp+74h] [bp+74h]

  dest = calloc(1u, 0x310u);
  memcpy(dest, &off_1EF330, 0x310u);
  return dest;
}
// 1EF330: using guessed type _UNKNOWN *off_1EF330;

//----- (000DF6A0) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_DF6A0(int a1, __int64 a2)
{
  V_INT(a1, "chain", a2);
}

//----- (000DF6C8) --------------------------------------------------------
int __fastcall sub_DF6C8(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// DF70C: variable 'v3' is possibly undefined

//----- (000DF7A8) --------------------------------------------------------
int __fastcall sub_DF7A8(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DF8AC) --------------------------------------------------------
int __fastcall chip_setting_software_reset_ltc(int a1)
{
  _BYTE v3[20]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF

  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "software_reset %s %02x", "chip_setting_software_reset_ltc", 52);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
    88,
    "chip_setting_software_reset_ltc",
    31,
    39,
    20,
    v3);
  memset(v4, 0, 0x10u);
  v4[2] = 3407873;
  v4[0] = 0;
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DF9A0) --------------------------------------------------------
int __fastcall chip_setting_misc_ltc(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  char v8; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 1572865;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v8 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v8 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v8 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v8 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v8 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v8 = 0;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v8 = 26;
      goto LABEL_27;
    }
    v8 = 0;
  }
LABEL_27:
  v7 = ((v8 & 0x1F) << 8) | 0x70060F1;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set_misc value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
    88,
    "chip_setting_misc_ltc",
    21,
    98,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DFBFC) --------------------------------------------------------
unsigned int *__fastcall sub_DFBFC(unsigned int *result)
{
  float v1; // s0
  int v2; // r0
  int v3; // r0
  unsigned int v4; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+14h] [bp+14h]
  unsigned __int8 j; // [sp+16h] [bp+16h]
  unsigned __int8 i; // [sp+17h] [bp+17h]

  for ( i = 7; i; --i )
  {
    for ( j = i; j; --j )
    {
      v4 = (unsigned int)(float)((float)((float)i * v1) * (float)j);
      if ( v4 <= 0x960 && v4 >= 0x320 )
      {
        v5 = v4 / 0x19;
        *result = j & 7 | (v5 << 16) | 0xA0000100 | (16 * (i & 7));
        v2 = sub_1A3658(25 * v5, 1u);
        v3 = sub_1A3658(v2, i);
        return (unsigned int *)sub_1A3658(v3, j);
      }
    }
  }
  return result;
}
// DFC34: variable 'v1' is possibly undefined

//----- (000DFD0C) --------------------------------------------------------
int __fastcall chip_setting_freq_ltc(int a1, char a2, int a3)
{
  float v3; // s0
  char v4; // r3
  _BYTE v9[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v10[4]; // [sp+1024h] [bp+1014h] BYREF
  unsigned int v11; // [sp+1034h] [bp+1024h] BYREF
  int v12; // [sp+1038h] [bp+1028h]
  float v13; // [sp+103Ch] [bp+102Ch]

  v11 = 0;
  memset(v10, 0, sizeof(v10));
  LOBYTE(v10[2]) = a2;
  if ( a2 )
    v4 = 0;
  else
    v4 = *(_BYTE *)(a3 + *(_DWORD *)(a1 + 296));
  BYTE1(v10[2]) = v4;
  HIWORD(v10[2]) = 8;
  sub_DFBFC(&v11);
  v13 = v3;
  v10[0] = v11;
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "set freq: %.2f, expected freq: %.2f", v13, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
    88,
    "chip_setting_freq_ltc",
    21,
    135,
    60,
    v9);
  v12 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v10);
  usleep(0x2710u);
  return v12;
}
// DFDC8: variable 'v3' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000DFEA4) --------------------------------------------------------
int __fastcall chip_setting_ticket_mask_ltc(int a1, unsigned int a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned int v8; // [sp+1030h] [bp+1020h]
  int v9; // [sp+1034h] [bp+1024h]

  v9 = 0;
  v8 = a2;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %08x", "chip_setting_ticket_mask_ltc", 2, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
    88,
    "chip_setting_ticket_mask_ltc",
    28,
    146,
    60,
    v5);
  v6[2] = 131073;
  v6[0] = (unsigned __int16)a2;
  BYTE2(v6[3]) = 1;
  LOBYTE(v6[3]) = 0;
  BYTE1(v6[3]) = *(_DWORD *)(a1 + 200);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v6);
  usleep(0x3E8u);
  v6[2] = 262145;
  v6[0] = HIWORD(a2);
  BYTE2(v6[3]) = 1;
  LOBYTE(v6[3]) = 0;
  BYTE1(v6[3]) = *(_DWORD *)(a1 + 200);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v6);
  while ( (v8 & 1) != 0 )
  {
    ++v9;
    v8 >>= 1;
  }
  v9 += 16;
  *(_DWORD *)(a1 + 244) = v9;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "cal mask %d", v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
    88,
    "chip_setting_ticket_mask_ltc",
    28,
    175,
    60,
    v5);
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E0158) --------------------------------------------------------
int __fastcall chip_setting_check_bist_ltc(int a1, unsigned __int8 a2, int a3, int a4, _BOOL4 *a5)
{
  int v5; // r3
  char v6; // r3
  int v7; // r2
  int v9; // [sp+4h] [bp-2Ch]
  _BYTE v14[20]; // [sp+44h] [bp+14h] BYREF
  int v15; // [sp+1044h] [bp+1014h] BYREF
  _WORD v16[8]; // [sp+1048h] [bp+1018h] BYREF
  _DWORD v17[7]; // [sp+1058h] [bp+1028h] BYREF
  int v18; // [sp+1074h] [bp+1044h]
  unsigned int v19; // [sp+107Ch] [bp+104Ch]
  unsigned __int8 *v20; // [sp+1080h] [bp+1050h]
  int v21; // [sp+1084h] [bp+1054h]
  int j; // [sp+1088h] [bp+1058h]
  int i; // [sp+108Ch] [bp+105Ch]
  int v24; // [sp+1090h] [bp+1060h]
  _BOOL4 v25; // [sp+1094h] [bp+1064h]

  v15 = 0;
  if ( a2 )
    v5 = *(_DWORD *)(a1 + 196);
  else
    v5 = 1;
  v21 = v5;
  v24 = 0;
  V_LOCK();
  logfmt_raw(v14, 0x1000u, 0, "check bist result, chip_all %d chip_no %d core %d ", a2, a3, a4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
    88,
    "chip_setting_check_bist_ltc",
    27,
    186,
    20,
    v14);
  v20 = (unsigned __int8 *)malloc(12 * v21);
  memset(v20, 0, 12 * v21);
  memset(a5, 0, 4 * v21);
  memset(v16, 0, sizeof(v16));
  LOBYTE(v16[4]) = a2;
  if ( a2 )
    v6 = 0;
  else
    v6 = *(_BYTE *)(a3 + *(_DWORD *)(a1 + 296));
  HIBYTE(v16[4]) = v6;
  HIBYTE(v16[7]) = a4;
  LOBYTE(v16[7]) = 0;
  HIBYTE(v16[6]) = *(_DWORD *)(a1 + 200);
  LOBYTE(v16[6]) = a4;
  v16[5] = 6;
  (*(void (__fastcall **)(int, _WORD *, int, unsigned __int8 *, int *, int, int, _DWORD))(a1 + 184))(
    a1,
    v16,
    v21,
    v20,
    &v15,
    v9,
    2000,
    0);
  for ( i = 0; i < v15; ++i )
  {
    v19 = (unsigned int)v20[12 * i + 4] / *(_DWORD *)(a1 + 240);
    v25 = *(_WORD *)&v20[12 * i + 6] == 6 && (*(_DWORD *)&v20[12 * i] & 0x1000000) != 0;
    if ( a2 )
      a5[v19] = v25;
    else
      *a5 = v25;
  }
  if ( v15 < v21 )
  {
    V_LOCK();
    sub_DF6A0((int)v17, *(int *)(a1 + 140));
    logfmt_raw(
      v14,
      0x1000u,
      0,
      v18,
      v17[0],
      v17[1],
      v17[2],
      v17[3],
      v17[4],
      v17[5],
      v17[6],
      v18,
      "detected core %d get check bist results less than expect num(%d < %d)",
      a4,
      v15,
      v21);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
      88,
      "chip_setting_check_bist_ltc",
      27,
      220,
      80,
      v14);
    for ( j = 0; j < v21; ++j )
    {
      if ( !a5[j] )
      {
        v24 = -1;
        V_LOCK();
        if ( a2 )
          v7 = j;
        else
          v7 = a3;
        logfmt_raw(v14, 0x1000u, 0, "chip %d core %d check bist failed", v7, a4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
          88,
          "chip_setting_check_bist_ltc",
          27,
          225,
          80,
          v14);
      }
    }
  }
  free(v20);
  return v24;
}
// E0384: variable 'v9' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E0680) --------------------------------------------------------
int __fastcall chip_setting_reset_bist_ltc(int a1, char a2, int a3, char a4, int a5)
{
  char v5; // r3
  char v7; // r3
  _BYTE v13[8]; // [sp+20h] [bp+10h] BYREF
  _DWORD v14[4]; // [sp+1020h] [bp+1010h] BYREF
  int v15; // [sp+1030h] [bp+1020h]
  int v16; // [sp+1034h] [bp+1024h]
  int j; // [sp+1038h] [bp+1028h]
  int i; // [sp+103Ch] [bp+102Ch]
  int v19; // [sp+1040h] [bp+1030h]
  int v20; // [sp+1044h] [bp+1034h]

  V_LOCK();
  logfmt_raw(v13, 0x1000u, 0, "%s", "chip_setting_reset_bist_ltc");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
    88,
    "chip_setting_reset_bist_ltc",
    27,
    239,
    40,
    v13);
  if ( a4 )
  {
    v20 = 0;
    v19 = *(_DWORD *)(a1 + 200) - 1;
  }
  else
  {
    v19 = a5;
    v20 = a5;
  }
  memset(v14, 0, sizeof(v14));
  LOBYTE(v14[2]) = a2;
  if ( a2 )
    v5 = 0;
  else
    v5 = *(_BYTE *)(a3 + *(_DWORD *)(a1 + 296));
  BYTE1(v14[2]) = v5;
  BYTE1(v14[3]) = *(_DWORD *)(a1 + 200);
  for ( i = v20; i <= v19; ++i )
  {
    v14[0] = 1024;
    HIWORD(v14[2]) = 0;
    LOBYTE(v14[3]) = i;
    HIWORD(v14[3]) = 0;
    v16 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v14);
    if ( v16 )
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "%s failed, reg:%02x, core_id:%d", "chip_setting_reset_bist_ltc", HIWORD(v14[2]), i);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
        88,
        "chip_setting_reset_bist_ltc",
        27,
        262,
        100,
        v13);
      return v16;
    }
    usleep(0x3E8u);
  }
  usleep(0x2710u);
  memset(v14, 0, sizeof(v14));
  LOBYTE(v14[2]) = a2;
  if ( a2 )
    v7 = 0;
  else
    v7 = *(_BYTE *)(a3 + *(_DWORD *)(a1 + 296));
  BYTE1(v14[2]) = v7;
  BYTE1(v14[3]) = *(_DWORD *)(a1 + 200);
  for ( j = v20; j <= v19; ++j )
  {
    v14[0] = 37888;
    HIWORD(v14[2]) = 0;
    LOBYTE(v14[3]) = j;
    HIWORD(v14[3]) = 0;
    v15 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v14);
    if ( v15 )
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "%s failed, reg:%02x, core_id:%d", "chip_setting_reset_bist_ltc", HIWORD(v14[2]), j);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
        88,
        "chip_setting_reset_bist_ltc",
        27,
        284,
        100,
        v13);
      return v15;
    }
    usleep(0x3E8u);
  }
  usleep(0x2710u);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E0B00) --------------------------------------------------------
int __fastcall chip_setting_working_mode_ltc(int a1, char a2, int a3, char a4, int a5, unsigned __int8 a6)
{
  char v6; // r3
  char v8; // r3
  int v14; // [sp+2Ch] [bp+14h] BYREF
  _DWORD v15[4]; // [sp+102Ch] [bp+1014h] BYREF
  int v16; // [sp+103Ch] [bp+1024h]
  int v17; // [sp+1040h] [bp+1028h]
  int v18; // [sp+1044h] [bp+102Ch]
  int v19; // [sp+1048h] [bp+1030h]
  int i; // [sp+104Ch] [bp+1034h]

  V_LOCK();
  logfmt_raw(&v14, 0x1000u, 0, "%s", "chip_setting_working_mode_ltc");
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
    88,
    "chip_setting_working_mode_ltc",
    29,
    298,
    20,
    &v14);
  if ( !a4 )
  {
    v18 = a5;
    v17 = a5;
    memset(v15, 0, sizeof(v15));
    LOBYTE(v15[2]) = a2;
    if ( a2 )
      v8 = 0;
    else
      v8 = *(_BYTE *)(a3 + *(_DWORD *)(a1 + 296));
    BYTE1(v15[2]) = v8;
    BYTE1(v15[3]) = *(_DWORD *)(a1 + 200);
    for ( i = v17; i <= v18; ++i )
    {
      v15[0] = a6 | 0x400;
      HIWORD(v15[2]) = 0;
      LOBYTE(v15[3]) = i;
      HIWORD(v15[3]) = 0;
      v16 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v15);
      if ( v16 )
      {
        V_LOCK();
        logfmt_raw(
          &v14,
          0x1000u,
          0,
          "%s failed, chip_all %d chip_addr %02x reg:%02x, core_id:%d",
          "chip_setting_working_mode_ltc",
          LOBYTE(v15[2]),
          BYTE1(v15[2]),
          HIWORD(v15[2]),
          i);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
          88,
          "chip_setting_working_mode_ltc",
          29,
          336,
          100,
          &v14);
        return v16;
      }
      usleep(0x3E8u);
    }
    return 0;
  }
  memset(v15, 0, sizeof(v15));
  LOBYTE(v15[2]) = a2;
  if ( a2 )
    v6 = 0;
  else
    v6 = *(_BYTE *)(a3 + *(_DWORD *)(a1 + 296));
  BYTE1(v15[2]) = v6;
  BYTE1(v15[3]) = *(_DWORD *)(a1 + 200);
  v15[0] = a6 | 0x400;
  HIWORD(v15[2]) = 0;
  LOBYTE(v15[3]) = a5;
  HIWORD(v15[3]) = 1;
  v19 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v15);
  if ( !v19 )
  {
    usleep(0x3E8u);
    return 0;
  }
  V_LOCK();
  logfmt_raw(
    &v14,
    0x1000u,
    0,
    "%s failed, chip_all %d chip_addr %02x reg:%02x, all core",
    "chip_setting_working_mode_ltc",
    LOBYTE(v15[2]),
    BYTE1(v15[2]),
    HIWORD(v15[2]));
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_setting_ltc.c",
    88,
    "chip_setting_working_mode_ltc",
    29,
    314,
    100,
    &v14);
  return v19;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E0F50) --------------------------------------------------------
_DWORD *__fastcall sub_E0F50(_DWORD *result, _DWORD *a2, int a3)
{
  *(_DWORD *)(a3 + 4) = result;
  *result = a3;
  result[1] = a2;
  *a2 = result;
  return result;
}

//----- (000E0F80) --------------------------------------------------------
_DWORD *__fastcall sub_E0F80(_DWORD *a1, int a2)
{
  return sub_E0F50(a1, *(_DWORD **)(a2 + 4), a2);
}

//----- (000E0FA0) --------------------------------------------------------
void __cdecl _list_del(list_head *prev, list_head *next)
{
  *((_DWORD *)next + 1) = prev;
  *(_DWORD *)prev = next;
}

//----- (000E0FC4) --------------------------------------------------------
void __cdecl list_del(list_head *entry)
{
  _list_del(*((list_head **)entry + 1), *(list_head **)entry);
  *(_DWORD *)entry = 0;
  *((_DWORD *)entry + 1) = 0;
}

//----- (000E0FF0) --------------------------------------------------------
bool __fastcall sub_E0FF0(_DWORD *a1)
{
  return *a1 == (_DWORD)a1;
}

//----- (000E1014) --------------------------------------------------------
int __fastcall sub_E1014(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// E1058: variable 'v3' is possibly undefined

//----- (000E10B4) --------------------------------------------------------
int __fastcall sub_E10B4(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp+Fh]

  v2 = 0;
  if ( a1 <= 0x60u || a1 > 0x66u )
  {
    if ( a1 > 0x2Fu && a1 <= 0x39u )
      return 1;
  }
  else
  {
    return 1;
  }
  return v2;
}

//----- (000E10F4) --------------------------------------------------------
int __fastcall sub_E10F4(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/util.h",
    56,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E11F8) --------------------------------------------------------
int __fastcall extract_byte_from_hex(const char *a1, int a2)
{
  _BYTE v5[12]; // [sp+1Ch] [bp+Ch] BYREF
  int v6; // [sp+101Ch] [bp+100Ch]
  int v7; // [sp+1020h] [bp+1010h]
  unsigned __int8 v8; // [sp+1026h] [bp+1016h]
  unsigned __int8 v9; // [sp+1027h] [bp+1017h]

  if ( (strlen(a1) & 1) != 0 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Provided hex %s is not valid!", a1);
    V_UNLOCK();
    zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "extract_byte_from_hex", 21, 36, 100, v5);
  }
  v9 = tolower((unsigned __int8)a1[a2]);
  v8 = tolower((unsigned __int8)a1[a2 + 1]);
  if ( (unsigned __int8)sub_E10B4(v9) != 1 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Hex character %d is not valid!", v9);
    V_UNLOCK();
    zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "extract_byte_from_hex", 21, 43, 100, v5);
  }
  if ( (unsigned __int8)sub_E10B4(v8) != 1 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "Hex character %d is not valid!", v8);
    V_UNLOCK();
    zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "extract_byte_from_hex", 21, 46, 100, v5);
  }
  v7 = 16 * sub_E10F4(v9);
  v6 = sub_E10F4(v8);
  if ( v6 + v7 > 255 )
  {
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, "The provided hex %s at index %d is not a valid byte!", a1, a2);
    V_UNLOCK();
    zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "extract_byte_from_hex", 21, 53, 100, v5);
  }
  return (unsigned __int8)(v6 + v7);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E14B0) --------------------------------------------------------
int __fastcall format_hashrate_string(const char *a1, char *a2)
{
  double v2; // d0
  double v6; // [sp+18h] [bp+8h]
  int v7; // [sp+24h] [bp+14h] BYREF
  unsigned __int8 v8; // [sp+1027h] [bp+1017h]

  v6 = v2;
  v8 = 0;
  V_LOCK();
  logfmt_raw(&v7, 0x1000u, 0, "format hashrate string %f %s", v2, a1);
  V_UNLOCK();
  zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "format_hashrate_string", 22, 63, 20, &v7);
  if ( v2 >= 10000.0 )
  {
    if ( v2 >= 10000000.0 )
    {
      if ( v2 >= 1.0e10 )
      {
        if ( v2 >= 1.0e13 )
        {
          v8 = 84;
          v6 = v2 * 1.0e-12;
        }
        else
        {
          v8 = 71;
          v6 = v2 * 0.000000001;
        }
      }
      else
      {
        v8 = 77;
        v6 = v2 * 0.000001;
      }
    }
    else
    {
      v8 = 75;
      v6 = v2 * 0.001;
    }
  }
  if ( v8 )
    return sprintf(a2, "%.2f %c%s/s", v6, v8, a1);
  else
    return sprintf(a2, "%.2f %s/s", v6, a1);
}
// E14C0: variable 'v2' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E1710) --------------------------------------------------------
int __fastcall format_hashrate_double(const char *a1, double *a2, char *a3)
{
  double v3; // d0
  char *v5; // [sp+14h] [bp+4h]
  double *v6; // [sp+18h] [bp+8h]
  const char *v7; // [sp+1Ch] [bp+Ch]
  double v8; // [sp+20h] [bp+10h]
  _BYTE v9[16]; // [sp+28h] [bp+18h] BYREF
  double v10; // [sp+1028h] [bp+1018h]
  unsigned __int8 v11; // [sp+1037h] [bp+1027h]

  v8 = v3;
  v7 = a1;
  v6 = a2;
  v5 = a3;
  v11 = 0;
  v10 = 0.0;
  V_LOCK();
  logfmt_raw(v9, 0x1000u, 0, "format hashrate double %f %s", v3, v7);
  V_UNLOCK();
  zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "format_hashrate_double", 22, 98, 20, v9);
  if ( v3 >= 10000.0 )
  {
    if ( v8 >= 10000000.0 )
    {
      if ( v8 >= 1.0e10 )
      {
        if ( v8 >= 1.0e13 )
        {
          v11 = 84;
          v10 = 1.0e-12;
        }
        else
        {
          v11 = 71;
          v10 = 0.000000001;
        }
      }
      else
      {
        v11 = 77;
        v10 = 0.000001;
      }
    }
    else
    {
      v11 = 75;
      v10 = 0.001;
    }
  }
  else
  {
    v10 = 1.0;
  }
  *v6 = v8 * v10;
  if ( v11 )
    return sprintf(v5, "%c%s/s", v11, v7);
  else
    return sprintf(v5, "%s/s", v7);
}
// E1720: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E1998) --------------------------------------------------------
int __fastcall bin2hex(int result, int a2, unsigned int a3)
{
  int v5; // [sp+Ch] [bp+Ch]
  unsigned int i; // [sp+14h] [bp+14h]

  v5 = result;
  for ( i = 0; i < a3; ++i )
    result = sprintf((char *)(v5 + 2 * i), "%02x", *(unsigned __int8 *)(i + a2));
  return result;
}

//----- (000E19E0) --------------------------------------------------------
void *__fastcall abin2hex(int a1, unsigned int a2)
{
  void *v6; // [sp+Ch] [bp+Ch]

  v6 = malloc(2 * a2 + 1);
  if ( !v6 )
    return 0;
  bin2hex((int)v6, a1, a2);
  return v6;
}

//----- (000E1A18) --------------------------------------------------------
bool __fastcall hex2bin(_BYTE *a1, char *a2, int a3)
{
  _BYTE v8[8]; // [sp+20h] [bp+10h] BYREF
  char *v9; // [sp+1020h] [bp+1010h] BYREF
  char v10[4]; // [sp+1024h] [bp+1014h] BYREF

  v10[2] = 0;
  while ( *a2 && a3 )
  {
    if ( !a2[1] )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "hex2bin str truncated");
      V_UNLOCK();
      zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "hex2bin", 7, 154, 100, v8);
      return 0;
    }
    v10[0] = *a2;
    v10[1] = a2[1];
    *a1 = strtol(v10, &v9, 16);
    if ( *v9 )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, "hex2bin failed on '%s'", v10);
      V_UNLOCK();
      zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "hex2bin", 7, 161, 100, v8);
      return 0;
    }
    ++a1;
    a2 += 2;
    --a3;
  }
  return a3 == 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E1BE0) --------------------------------------------------------
int __fastcall sub_E1BE0(unsigned __int8 a1)
{
  int v1; // r3

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return (unsigned __int8)(a1 - 48);
  v1 = a1;
  if ( a1 > 0x60u )
  {
    v1 = a1;
    if ( a1 <= 0x66u )
      return (unsigned __int8)(a1 - 87);
  }
  return v1;
}

//----- (000E1C20) --------------------------------------------------------
int __fastcall str2hex(int a1, int a2, int a3)
{
  char v7; // [sp+13h] [bp+13h]
  int i; // [sp+14h] [bp+14h]

  for ( i = 0; i < a3; i += 2 )
  {
    v7 = sub_E1BE0(*(_BYTE *)(i + a2));
    *(_BYTE *)(a1 + i / 2) = sub_E1BE0(*(_BYTE *)(i + 1 + a2)) | (16 * v7);
  }
  return a3 / 2;
}

//----- (000E1C98) --------------------------------------------------------
int __fastcall valid_hex(const char *a1)
{
  _BYTE v4[16]; // [sp+18h] [bp+8h] BYREF
  unsigned __int8 v5; // [sp+101Bh] [bp+100Bh]
  signed int v6; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 v7; // [sp+1023h] [bp+1013h]
  signed int i; // [sp+1024h] [bp+1014h]

  v7 = 0;
  if ( a1 )
  {
    v6 = strlen(a1);
    for ( i = 0; i < v6; ++i )
    {
      v5 = a1[i];
      if ( dword_1C7E68[v5] < 0 )
      {
        V_LOCK();
        logfmt_raw(v4, 0x1000u, 0, "Invalid charpassed to valid_hex");
        V_UNLOCK();
        zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "valid_hex", 9, 228, 20, v4);
        return v7;
      }
    }
    v7 = 1;
    return 1;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "Null string passed to valid_hex");
    V_UNLOCK();
    zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "valid_hex", 9, 218, 20, v4);
    return v7;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1C7E68: using guessed type int dword_1C7E68[256];
// 47BE18: using guessed type int g_zc;

//----- (000E1E34) --------------------------------------------------------
int __fastcall valid_ascii(const char *a1)
{
  _BYTE v4[16]; // [sp+18h] [bp+8h] BYREF
  unsigned __int8 v5; // [sp+101Bh] [bp+100Bh]
  signed int v6; // [sp+101Ch] [bp+100Ch]
  unsigned __int8 v7; // [sp+1023h] [bp+1013h]
  signed int i; // [sp+1024h] [bp+1014h]

  v7 = 0;
  if ( a1 )
  {
    v6 = strlen(a1);
    if ( v6 )
    {
      for ( i = 0; i < v6; ++i )
      {
        v5 = a1[i];
        if ( v5 <= 0x1Fu || v5 > 0x7Eu )
        {
          V_LOCK();
          logfmt_raw(v4, 0x1000u, 0, "Invalid char passed to valid_ascii");
          V_UNLOCK();
          zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "valid_ascii", 11, 258, 20, v4);
          return v7;
        }
      }
      v7 = 1;
      return 1;
    }
    else
    {
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, "Zero length string passed to valid_ascii");
      V_UNLOCK();
      zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "valid_ascii", 11, 249, 20, v4);
      return v7;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "Null string passed to valid_ascii");
    V_UNLOCK();
    zlog(g_zc, "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c", 56, "valid_ascii", 11, 243, 20, v4);
    return v7;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E2040) --------------------------------------------------------
char *tq_new()
{
  char *v2; // [sp+4h] [bp+4h]

  v2 = (char *)calloc(1u, 0x58u);
  if ( !v2 )
    return 0;
  *(_DWORD *)v2 = v2;
  *((_DWORD *)v2 + 1) = v2;
  pthread_mutex_init((pthread_mutex_t *)(v2 + 12), 0);
  pthread_cond_init((pthread_cond_t *)(v2 + 40), 0);
  return v2;
}

//----- (000E208C) --------------------------------------------------------
void __fastcall tq_free(char *a1)
{
  int v2; // [sp+8h] [bp+8h]
  char *ptr; // [sp+Ch] [bp+Ch]

  if ( a1 )
  {
    ptr = (char *)(*(_DWORD *)a1 - 4);
    v2 = **(_DWORD **)a1 - 4;
    while ( ptr + 4 != a1 )
    {
      list_del((list_head *)(ptr + 4));
      free(ptr);
      ptr = (char *)v2;
      v2 = *(_DWORD *)(v2 + 4) - 4;
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    memset(a1, 0, 0x58u);
    free(a1);
  }
}

//----- (000E2100) --------------------------------------------------------
int __fastcall sub_E2100(int a1, char a2)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12));
}

//----- (000E2138) --------------------------------------------------------
int __fastcall tq_freeze(int a1)
{
  return sub_E2100(a1, 1);
}

//----- (000E2150) --------------------------------------------------------
int __fastcall tq_thaw(int a1)
{
  return sub_E2100(a1, 0);
}

//----- (000E2168) --------------------------------------------------------
int __fastcall tq_push(int a1, int a2)
{
  _DWORD *ptr; // [sp+8h] [bp+8h]
  unsigned __int8 v7; // [sp+Fh] [bp+Fh]

  v7 = 1;
  ptr = calloc(1u, 0xCu);
  if ( !ptr )
    return 0;
  *ptr = a2;
  ptr[1] = ptr + 1;
  ptr[2] = ptr + 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  if ( *(_BYTE *)(a1 + 8) != 1 )
  {
    sub_E0F80(ptr + 1, a1);
  }
  else
  {
    free(ptr);
    v7 = 0;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12));
  return v7;
}

//----- (000E21F4) --------------------------------------------------------
int __fastcall tq_pop(int a1, const struct timespec *a2)
{
  int *ptr; // [sp+Ch] [bp+Ch]
  int v6; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  v7 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  if ( !sub_E0FF0((_DWORD *)a1)
    || (!a2
      ? (v6 = pthread_cond_wait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 12)))
      : (v6 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 12), a2)),
        !v6 && !sub_E0FF0((_DWORD *)a1)) )
  {
    ptr = (int *)(*(_DWORD *)a1 - 4);
    v7 = *ptr;
    list_del(*(list_head **)a1);
    free(ptr);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12));
  return v7;
}

//----- (000E229C) --------------------------------------------------------
int __fastcall sub_E229C(int a1, int a2)
{
  int i; // [sp+10h] [bp+8h]
  int v6; // [sp+14h] [bp+Ch]

  v6 = 0;
  for ( i = 0; i <= 31; i += 4 )
    v6 += sprintf(
            (char *)(a1 + v6),
            "%02x%02x%02x%02x ",
            *(unsigned __int8 *)(i + a2),
            *(unsigned __int8 *)(i + 1 + a2),
            *(unsigned __int8 *)(i + 2 + a2),
            *(unsigned __int8 *)(i + 3 + a2));
  return a1;
}

//----- (000E2314) --------------------------------------------------------
int __fastcall cgtime(struct timeval *a1)
{
  return gettimeofday(a1, 0);
}

//----- (000E232C) --------------------------------------------------------
_DWORD *__fastcall cgtimer_sub(_DWORD *result, _DWORD *a2, _DWORD *a3)
{
  *a3 = *result - *a2;
  a3[1] = result[1] - a2[1];
  if ( (int)a3[1] < 0 )
  {
    --*a3;
    a3[1] += 1000000;
  }
  return result;
}

//----- (000E2384) --------------------------------------------------------
int __fastcall sub_E2384(const char *a1, int *a2, int a3, int a4)
{
  int result; // r0
  _BYTE v9[8]; // [sp+20h] [bp+10h] BYREF
  char *v10; // [sp+1020h] [bp+1010h] BYREF
  int v11; // [sp+1024h] [bp+1014h]

  result = strtol(a1, &v10, 0);
  v11 = result;
  if ( *v10 || !*a1 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "'%s' is not a number", a1);
    V_UNLOCK();
    result = zlog(
               g_zc,
               "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c",
               56,
               "opt_set_longval",
               15,
               453,
               100,
               v9);
  }
  if ( v11 == 0x7FFFFFFF || v11 == 0x80000000 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "'%s' is out of range", a1);
    V_UNLOCK();
    result = zlog(
               g_zc,
               "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c",
               56,
               "opt_set_longval",
               15,
               455,
               100,
               v9);
  }
  if ( v11 < a3 && v11 > a4 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "'%s' is out of range", a1);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/util.c",
             56,
             "opt_set_longval",
             15,
             459,
             100,
             v9);
  }
  else
  {
    *a2 = v11;
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E257C) --------------------------------------------------------
int __fastcall get_server_port_from_url(const char *a1, char *a2, _WORD *a3)
{
  int v7; // [sp+14h] [bp+14h] BYREF
  char *v8; // [sp+18h] [bp+18h]
  unsigned __int8 v9; // [sp+1Fh] [bp+1Fh]

  v9 = 0;
  if ( a1 )
  {
    v8 = strchr(a1, 58);
    if ( v8 )
    {
      if ( v8 != a1 )
      {
        strncpy(a2, a1, v8 - a1);
        a2[v8 - a1] = 0;
        if ( v8 + 1 - a1 < strlen(a1) )
        {
          sub_E2384(v8 + 1, &v7, 0, 0xFFFF);
          *a3 = v7;
          return 1;
        }
      }
    }
  }
  return v9;
}

//----- (000E260C) --------------------------------------------------------
int __fastcall find_min_and_max_float(int result, int a2, float *a3, float *a4)
{
  int i; // [sp+14h] [bp+14h]
  float v5; // [sp+18h] [bp+18h]
  float v6; // [sp+1Ch] [bp+1Ch]

  v6 = INFINITY;
  v5 = -INFINITY;
  for ( i = 0; i < a2; ++i )
  {
    if ( *(float *)(4 * i + result) < v6 )
      v6 = *(float *)(4 * i + result);
    if ( *(float *)(4 * i + result) > v5 )
      v5 = *(float *)(4 * i + result);
  }
  *a3 = v6;
  *a4 = v5;
  return result;
}

//----- (000E26A4) --------------------------------------------------------
int *__fastcall find_min_and_max_int(int *result, int a2, _DWORD *a3, _DWORD *a4)
{
  int i; // [sp+14h] [bp+14h]
  int v5; // [sp+18h] [bp+18h]
  int v6; // [sp+1Ch] [bp+1Ch]

  if ( a2 > 0 )
  {
    v6 = *result;
    v5 = *result;
    for ( i = 1; i < a2; ++i )
    {
      if ( result[i] < v6 )
        v6 = result[i];
      if ( result[i] > v5 )
        v5 = result[i];
    }
    *a3 = v6;
    *a4 = v5;
  }
  return result;
}

//----- (000E2730) --------------------------------------------------------
void __cdecl set_flag_to_bad_asic_cfg_freq(uint8_t flag)
{
  byte_47B310 = flag;
}
// 47B310: using guessed type char byte_47B310;

//----- (000E2754) --------------------------------------------------------
_BYTE *__fastcall sub_E2754(_BYTE *result, char a2, int a3, unsigned __int8 a4)
{
  unsigned __int8 i; // [sp+15h] [bp+15h]
  __int16 v5; // [sp+16h] [bp+16h]

  *result = 85;
  result[1] = -86;
  result[2] = a4 + 4;
  result[3] = a2;
  v5 = (unsigned __int8)result[3] + (unsigned __int8)result[2];
  if ( a3 )
  {
    for ( i = 0; i < (unsigned int)a4; ++i )
    {
      result[i + 4] = *(_BYTE *)(i + a3);
      v5 += *(unsigned __int8 *)(i + a3);
    }
    result[i + 4] = HIBYTE(v5);
    result[i + 5] = v5;
  }
  else
  {
    result[4] = HIBYTE(v5);
    result[5] = v5;
  }
  return result;
}

//----- (000E282C) --------------------------------------------------------
int __fastcall sub_E282C(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4, unsigned __int8 a5)
{
  pthread_mutex_lock(&i2c_mutex_all);
  iic_write(g_bitmain_pic_state[2 * a1], a2, a3);
  usleep(0x2710u);
  iic_read(g_bitmain_pic_state[2 * a1], a4, a5);
  return pthread_mutex_unlock(&i2c_mutex_all);
}
// 47B2F8: using guessed type pthread_mutex_t i2c_mutex_all;
// 47C224: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (000E289C) --------------------------------------------------------
int __fastcall sub_E289C(int a1, int a2, _BYTE *a3, unsigned __int8 *a4)
{
  unsigned int v5; // r3
  char v10[4]; // [sp+24h] [bp+14h] BYREF
  int v11; // [sp+824h] [bp+814h] BYREF
  unsigned __int8 v12; // [sp+1827h] [bp+1817h]

  v12 = 0;
  sub_E2754(a3, a1, a2, BYTE1(a1));
  do
  {
    sub_E282C(HIBYTE(a1), (int)a3, BYTE1(a1) + 6, (int)a4, BYTE2(a1));
    if ( BYTE2(a1) == 2 )
    {
      if ( *a4 == (unsigned __int8)a1 && a4[1] == 1 )
      {
        snprintf(v10, 0x800u, "PICCMD %d passed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
        V_LOCK();
        logfmt_raw(&v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
          87,
          "pic_process_cmd",
          15,
          98,
          20,
          &v11);
        return 1;
      }
      snprintf(v10, 0x800u, "PICCMD %d failed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
      V_LOCK();
      logfmt_raw(&v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
        87,
        "pic_process_cmd",
        15,
        103,
        20,
        &v11);
      sleep(1u);
    }
    else if ( BYTE2(a1) <= 2u )
    {
      snprintf(v10, 0x800u, "ret_len = %d should never happen!!", BYTE2(a1));
      V_LOCK();
      logfmt_raw(&v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
        87,
        "pic_process_cmd",
        15,
        121,
        20,
        &v11);
    }
    else
    {
      if ( __PAIR64__(a4[1], *a4) == __PAIR64__((unsigned __int8)a1, BYTE2(a1)) )
      {
        snprintf(v10, 0x800u, "PICCMD %d passed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
        V_LOCK();
        logfmt_raw(&v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
          87,
          "pic_process_cmd",
          15,
          111,
          20,
          &v11);
        return 1;
      }
      snprintf(v10, 0x800u, "PICCMD %d failed on Chain[%d]!", (unsigned __int8)a1, HIBYTE(a1));
      V_LOCK();
      logfmt_raw(&v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
        87,
        "pic_process_cmd",
        15,
        116,
        20,
        &v11);
      sleep(1u);
    }
    v5 = v12++;
  }
  while ( v5 <= 2 );
  return 0;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E2C40) --------------------------------------------------------
int __fastcall pic1704_get_sw_version(char a1, _BYTE *a2)
{
  int v4; // [sp+Ch] [bp+Ch] BYREF
  char v5; // [sp+10h] [bp+10h]
  int v6; // [sp+14h] [bp+14h] BYREF
  __int16 v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]
  int v9; // [sp+20h] [bp+20h]
  unsigned __int8 v10; // [sp+27h] [bp+27h]

  v6 = 0;
  v7 = 0;
  v4 = 255;
  v5 = 0;
  *a2 = -1;
  LOWORD(v8) = 23;
  v9 = 0;
  HIBYTE(v8) = a1;
  BYTE2(v8) = 5;
  v10 = sub_E289C(v8, 0, &v6, (unsigned __int8 *)&v4);
  if ( v10 )
    *a2 = BYTE2(v4);
  return v10;
}

//----- (000E2CB0) --------------------------------------------------------
int __fastcall pic1704_jump_to_app(char a1)
{
  __int16 v2; // [sp+8h] [bp+8h] BYREF
  int v3; // [sp+Ch] [bp+Ch] BYREF
  __int16 v4; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]
  int v6; // [sp+18h] [bp+18h]

  v3 = 0;
  v4 = 0;
  v2 = 255;
  LOWORD(v5) = 6;
  v6 = 0;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  return (unsigned __int8)sub_E289C(v5, 0, &v3, (unsigned __int8 *)&v2);
}

//----- (000E2D00) --------------------------------------------------------
int __fastcall pic1704_reset(char a1)
{
  __int16 v2; // [sp+8h] [bp+8h] BYREF
  int v3; // [sp+Ch] [bp+Ch] BYREF
  __int16 v4; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]
  int v6; // [sp+18h] [bp+18h]

  v3 = 0;
  v4 = 0;
  v2 = 255;
  LOWORD(v5) = 7;
  v6 = 0;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  return (unsigned __int8)sub_E289C(v5, 0, &v3, (unsigned __int8 *)&v2);
}

//----- (000E2D50) --------------------------------------------------------
int __fastcall pic1704_enable_disable_dc_dc(char a1, char a2)
{
  _BYTE v3[2]; // [sp+6h] [bp+6h] BYREF
  __int16 v4; // [sp+8h] [bp+8h] BYREF
  _DWORD v5[2]; // [sp+Ch] [bp+Ch] BYREF
  int v6; // [sp+14h] [bp+14h]
  _BYTE *v7; // [sp+18h] [bp+18h]

  v3[1] = a1;
  v3[0] = a2;
  v5[0] = 0;
  *(_DWORD *)((char *)v5 + 3) = 0;
  v4 = 255;
  LOWORD(v6) = 277;
  v7 = v3;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 2;
  return (unsigned __int8)sub_E289C(v6, (int)v3, v5, (unsigned __int8 *)&v4);
}

//----- (000E2DA8) --------------------------------------------------------
int __fastcall pic1704_erase_program(char a1)
{
  __int16 v2; // [sp+8h] [bp+8h] BYREF
  int v3; // [sp+Ch] [bp+Ch] BYREF
  __int16 v4; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]
  int v6; // [sp+18h] [bp+18h]

  v3 = 0;
  v4 = 0;
  v2 = 255;
  LOWORD(v5) = 9;
  v6 = 0;
  HIBYTE(v5) = a1;
  BYTE2(v5) = 2;
  return (unsigned __int8)sub_E289C(v5, 0, &v3, (unsigned __int8 *)&v2);
}

//----- (000E2DF8) --------------------------------------------------------
int __fastcall pic1704_heart_beat(char a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF
  __int16 v3; // [sp+10h] [bp+10h]
  int v4; // [sp+14h] [bp+14h] BYREF
  __int16 v5; // [sp+18h] [bp+18h]
  int v6; // [sp+1Ch] [bp+1Ch]
  int v7; // [sp+20h] [bp+20h]

  v4 = 0;
  v5 = 0;
  v2 = 255;
  v3 = 0;
  LOWORD(v6) = 22;
  v7 = 0;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 6;
  return (unsigned __int8)sub_E289C(v6, 0, &v4, (unsigned __int8 *)&v2);
}

//----- (000E2E54) --------------------------------------------------------
int __fastcall sub_E2E54(char a1, int a2)
{
  __int16 v3; // [sp+8h] [bp+8h] BYREF
  _BYTE v4[20]; // [sp+Ch] [bp+Ch] BYREF
  __int16 v5; // [sp+20h] [bp+20h]
  int v6; // [sp+24h] [bp+24h]
  int v7; // [sp+28h] [bp+28h]

  memset(v4, 0, sizeof(v4));
  v5 = 0;
  v3 = 255;
  LOWORD(v6) = 4098;
  v7 = a2;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 2;
  return (unsigned __int8)sub_E289C(v6, a2, v4, (unsigned __int8 *)&v3);
}

//----- (000E2EBC) --------------------------------------------------------
int __fastcall pic1704_update_app_program(unsigned __int8 a1)
{
  char *v2; // r3
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  char v9[20]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v10[20]; // [sp+81Ch] [bp+80Ch] BYREF
  int v11; // [sp+181Ch] [bp+180Ch] BYREF
  int v12; // [sp+1820h] [bp+1810h]
  int v13; // [sp+1824h] [bp+1814h]
  int v14; // [sp+1828h] [bp+1818h]
  char v15[8]; // [sp+182Ch] [bp+181Ch] BYREF
  char *v16; // [sp+1834h] [bp+1824h]
  FILE *v17; // [sp+1838h] [bp+1828h]
  int v18; // [sp+183Ch] [bp+182Ch]
  unsigned int v19; // [sp+1840h] [bp+1830h]
  unsigned int v20; // [sp+1844h] [bp+1834h]
  unsigned int v21; // [sp+1848h] [bp+1838h]
  unsigned int i; // [sp+184Ch] [bp+183Ch]

  i = 0;
  memset(v15, 0, 7);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v21 = 0;
  v20 = 3520;
  v19 = 880;
  v18 = 0;
  v17 = fopen("/etc/config/dsPIC33EP16GS202_app.txt", "r");
  if ( v17 )
  {
    v16 = (char *)malloc(0x3700u);
    if ( v16 )
    {
      fseek(v17, 0, 0);
      memset(v16, 0, 0x3700u);
      for ( i = 0; i < v20; ++i )
      {
        fgets(v15, 7, v17);
        v21 = strtoul(v15, 0, 16);
        v16[4 * i] = HIBYTE(v21);
        v16[4 * i + 1] = BYTE2(v21);
        v16[4 * i + 2] = BYTE1(v21);
        v16[4 * i + 3] = v21;
      }
      fclose(v17);
      v18 = pic1704_reset(a1);
      if ( v18 )
      {
        v18 = pic1704_erase_program(a1);
        if ( v18 )
        {
          for ( i = 0; i < v19; ++i )
          {
            v2 = &v16[16 * i];
            v3 = *(_DWORD *)v2;
            v4 = *((_DWORD *)v2 + 1);
            v5 = *((_DWORD *)v2 + 2);
            v6 = *((_DWORD *)v2 + 3);
            v11 = v3;
            v12 = v4;
            v13 = v5;
            v14 = v6;
            v18 = sub_E2E54(a1, (int)&v11);
            if ( !v18 )
            {
              snprintf(v9, 0x800u, "%s send data to pic error chain[%d]!", "pic1704_update_app_program", a1);
              V_LOCK();
              logfmt_raw(v10, 0x1000u, 0, v9);
              V_UNLOCK();
              zlog(
                g_zc,
                "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
                87,
                "pic1704_update_app_program",
                26,
                335,
                20,
                v10);
              free(v16);
              return 0;
            }
          }
          v18 = pic1704_reset(a1);
          if ( v18 )
          {
            free(v16);
            return 1;
          }
          else
          {
            snprintf(v9, 0x800u, "%s reset error after program chain[%d]!", "pic1704_update_app_program", a1);
            V_LOCK();
            logfmt_raw(v10, 0x1000u, 0, v9);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
              87,
              "pic1704_update_app_program",
              26,
              345,
              20,
              v10);
            free(v16);
            return 0;
          }
        }
        else
        {
          snprintf(v9, 0x800u, "%s erase pic error chain[%d]!", "pic1704_update_app_program", a1);
          V_LOCK();
          logfmt_raw(v10, 0x1000u, 0, v9);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
            87,
            "pic1704_update_app_program",
            26,
            315,
            20,
            v10);
          free(v16);
          return 0;
        }
      }
      else
      {
        snprintf(v9, 0x800u, "%s reset pic error chain[%d]!", "pic1704_update_app_program", a1);
        V_LOCK();
        logfmt_raw(v10, 0x1000u, 0, v9);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
          87,
          "pic1704_update_app_program",
          26,
          306,
          20,
          v10);
        free(v16);
        return 0;
      }
    }
    else
    {
      snprintf(v9, 0x800u, "%s malloc failed chain[%d]!", "pic1704_update_app_program", a1);
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
        87,
        "pic1704_update_app_program",
        26,
        281,
        20,
        v10);
      return -1;
    }
  }
  else
  {
    snprintf(v9, 0x800u, "%s open DSPIC33EP16GS202_PIC_PROGRAM failed chain[%d]!", "pic1704_update_app_program", a1);
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
      87,
      "pic1704_update_app_program",
      26,
      274,
      20,
      v10);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E3530) --------------------------------------------------------
int __fastcall pic1704_set_voltage(char a1, unsigned __int8 a2)
{
  __int16 v3; // [sp+8h] [bp+8h] BYREF
  char v4; // [sp+Ah] [bp+Ah]
  __int16 v5; // [sp+Ch] [bp+Ch] BYREF
  _DWORD v6[2]; // [sp+10h] [bp+10h] BYREF
  char v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]
  __int16 *v9; // [sp+20h] [bp+20h]

  v6[0] = 0;
  v6[1] = 0;
  v7 = 0;
  v5 = 255;
  v4 = 0;
  v3 = a2;
  LOWORD(v8) = 784;
  v9 = &v3;
  HIBYTE(v8) = a1;
  BYTE2(v8) = 2;
  return (unsigned __int8)sub_E289C(v8, (int)&v3, v6, (unsigned __int8 *)&v5);
}

//----- (000E35A0) --------------------------------------------------------
bool __fastcall sub_E35A0(unsigned __int8 *a1)
{
  unsigned __int8 *v2; // r2
  unsigned __int8 *v4; // [sp+14h] [bp+4h]
  char v5[16]; // [sp+18h] [bp+8h] BYREF
  _BYTE v6[16]; // [sp+818h] [bp+808h] BYREF
  int v7; // [sp+1818h] [bp+1808h]
  unsigned __int16 v8; // [sp+181Eh] [bp+180Eh]
  unsigned int i; // [sp+1820h] [bp+1810h]
  unsigned __int16 v10; // [sp+1826h] [bp+1816h]

  v4 = a1;
  v10 = 0;
  v8 = 0;
  v7 = 0;
  i = 0;
  if ( !a1 || *a1 <= 3u )
    return 0;
  v7 = *a1;
  for ( i = 0; v7 - 2 > i; ++i )
  {
    v2 = v4++;
    v10 += *v2;
  }
  v8 = *v4 << 8;
  v8 |= v4[1];
  snprintf(v5, 0x800u, "sum1,sum2 = %d,%d", v10, v8);
  V_LOCK();
  logfmt_raw(v6, 0x1000u, 0, v5);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
    87,
    "check_pic_crc",
    13,
    397,
    20,
    v6);
  return v10 == v8;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E3770) --------------------------------------------------------
__int64 __fastcall sub_E3770(unsigned int a1)
{
  float v1; // s0
  char v3[16]; // [sp+18h] [bp+8h] BYREF
  double v4[513]; // [sp+818h] [bp+808h] BYREF
  double v5; // [sp+1820h] [bp+1810h]

  v5 = (double)a1 * 3.3 / (float)(v1 * 1024.0);
  snprintf(v3, 0x800u, "v_an2 = %f", v5);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
    87,
    "decode_an_voltage_buf",
    21,
    407,
    20,
    v4);
  v4[512] = v5 * 7.5999999;
  snprintf(v3, 0x800u, "v_10 = %f", v5 * 7.5999999);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
           87,
           "decode_an_voltage_buf",
           21,
           410,
           20,
           v4);
}
// E37C6: variable 'v1' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E392C) --------------------------------------------------------
int __fastcall pic1704_get_an_voltage1(char a1)
{
  int result; // r0
  unsigned int v2; // [sp+8h] [bp+8h] BYREF
  char v3; // [sp+Fh] [bp+Fh]
  double v4; // [sp+10h] [bp+10h]

  v2 = 0;
  v4 = 0.0;
  result = pic1704_get_single_voltage(a1, (int *)&v2);
  v3 = result;
  if ( (_BYTE)result )
    return sub_E3770(v2);
  return result;
}

//----- (000E3980) --------------------------------------------------------
int __fastcall pic1704_get_an_voltage2(char a1, char a2)
{
  float v2; // s0
  float v3; // s1
  int result; // r0
  int v5; // s15
  char s[2048]; // [sp+28h] [bp+10h] BYREF
  _BYTE v8[4080]; // [sp+828h] [bp+810h] BYREF
  unsigned int v9; // [sp+1828h] [bp+1810h] BYREF
  unsigned int v10; // [sp+182Ch] [bp+1814h] BYREF
  int v11[2]; // [sp+1830h] [bp+1818h] BYREF
  double v12; // [sp+1838h] [bp+1820h]
  char v13; // [sp+1847h] [bp+182Fh]

  v11[0] = 0;
  v10 = 0;
  v9 = 0;
  result = pic1704_get_all_voltage(a1, v11, (int *)&v10, (int *)&v9);
  v13 = result;
  if ( (_BYTE)result )
  {
    strcpy(s, "Received an voltage response.");
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
      87,
      "pic1704_get_an_voltage2",
      23,
      442,
      20,
      v8);
    snprintf(
      s,
      0x800u,
      "an0 = %f, an2 %f, an6 %f.",
      (double)(unsigned int)v11[0] * 3.3 / 1024.0,
      (double)v10 * 3.3 / 1024.0,
      (double)v9 * 3.3 / 1024.0);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
      87,
      "pic1704_get_an_voltage2",
      23,
      443,
      20,
      v8);
    if ( a2 )
    {
      v12 = (double)v9 * 3.3 / 1024.0;
      if ( v2 <= v12 && v3 >= v12 )
      {
        *(float *)&v5 = v12 / 2.5;
        v11[1] = v5;
        return sub_E3770(v10);
      }
      else
      {
        strcpy(s, "Ref an vol too high or too low.");
        V_LOCK();
        logfmt_raw(v8, 0x1000u, 0, s);
        V_UNLOCK();
        return zlog(
                 g_zc,
                 "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
                 87,
                 "pic1704_get_an_voltage2",
                 23,
                 449,
                 20,
                 v8);
      }
    }
    else
    {
      return sub_E3770(v10);
    }
  }
  return result;
}
// E3B9A: variable 'v2' is possibly undefined
// E3BBA: variable 'v3' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E3CC8) --------------------------------------------------------
int __fastcall pic1704_get_single_voltage(char a1, int *a2)
{
  char v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v6[28]; // [sp+81Ch] [bp+80Ch] BYREF
  _BYTE v7[7]; // [sp+181Ch] [bp+180Ch] BYREF
  int v8; // [sp+1824h] [bp+1814h] BYREF
  __int16 v9; // [sp+1828h] [bp+1818h]
  int v10; // [sp+182Ch] [bp+181Ch]
  int v11; // [sp+1830h] [bp+1820h]

  v8 = 0;
  v9 = 0;
  *(_DWORD *)&v7[3] = 0;
  *(_DWORD *)v7 = 255;
  LOWORD(v10) = 58;
  v11 = 0;
  HIBYTE(v10) = a1;
  BYTE2(v10) = 7;
  if ( !(unsigned __int8)sub_E289C(v10, 0, &v8, v7) )
    return 0;
  if ( v7[2] == 1 && sub_E35A0(v7) )
  {
    *a2 = (v7[3] << 8) | v7[4];
    snprintf(v5, 0x800u, "Received one voltage response: vol = %d.", *a2);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
      87,
      "pic1704_get_single_voltage",
      26,
      484,
      20,
      v6);
    return 1;
  }
  else
  {
    snprintf(v5, 0x800u, "ret_buff error: buff0 = %d, buff1 = %d, buff2 = %d.", v7[0], v7[1], v7[2]);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
      87,
      "pic1704_get_single_voltage",
      26,
      480,
      20,
      v6);
    return 1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E3EEC) --------------------------------------------------------
int __fastcall pic1704_get_all_voltage(char a1, int *a2, int *a3, int *a4)
{
  char v9[28]; // [sp+24h] [bp+14h] BYREF
  _BYTE v10[28]; // [sp+824h] [bp+814h] BYREF
  int v11; // [sp+1824h] [bp+1814h] BYREF
  unsigned __int8 v12[8]; // [sp+1828h] [bp+1818h]
  int v13; // [sp+1830h] [bp+1820h] BYREF
  int v14; // [sp+1834h] [bp+1824h]
  int v15; // [sp+1838h] [bp+1828h]

  v13 = 0;
  *(_DWORD *)v12 = 0;
  *(_DWORD *)&v12[3] = 0;
  v11 = 255;
  LOWORD(v14) = 55;
  v15 = 0;
  HIBYTE(v14) = a1;
  BYTE2(v14) = 11;
  if ( !(unsigned __int8)sub_E289C(v14, 0, &v13, (unsigned __int8 *)&v11) )
    return 0;
  *a2 = (HIBYTE(v11) << 8) | v12[0];
  *a3 = (v12[1] << 8) | v12[2];
  *a4 = (v12[3] << 8) | v12[4];
  snprintf(v9, 0x800u, "Received all voltage response: vol0 = %d, vol1 = %d, vol2 = %d.", *a2, *a3, *a4);
  V_LOCK();
  logfmt_raw(v10, 0x1000u, 0, v9);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
    87,
    "pic1704_get_all_voltage",
    23,
    511,
    20,
    v10);
  return 1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E40C4) --------------------------------------------------------
int __fastcall pic1704_voltage_clamp_ctrl(char a1, char a2)
{
  _BYTE v3[2]; // [sp+6h] [bp+6h] BYREF
  __int16 v4; // [sp+8h] [bp+8h] BYREF
  _DWORD v5[2]; // [sp+Ch] [bp+Ch] BYREF
  int v6; // [sp+14h] [bp+14h]
  _BYTE *v7; // [sp+18h] [bp+18h]

  v3[1] = a1;
  v3[0] = a2;
  v5[0] = 0;
  *(_DWORD *)((char *)v5 + 3) = 0;
  v4 = 255;
  LOWORD(v6) = 305;
  v7 = v3;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 2;
  return (unsigned __int8)sub_E289C(v6, (int)v3, v5, (unsigned __int8 *)&v4);
}

//----- (000E411C) --------------------------------------------------------
int __fastcall pic1704_get_PDCx(char a1, int *a2, int *a3, int *a4)
{
  int v9; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+18h] [bp+18h]
  unsigned __int8 v11; // [sp+1Ch] [bp+1Ch]
  int v12; // [sp+20h] [bp+20h] BYREF
  __int16 v13; // [sp+24h] [bp+24h]
  int v14; // [sp+28h] [bp+28h]
  int v15; // [sp+2Ch] [bp+2Ch]
  int v16; // [sp+30h] [bp+30h]

  v12 = 0;
  v13 = 0;
  v9 = 255;
  v10 = 0;
  v11 = 0;
  LOWORD(v14) = 43;
  v15 = 0;
  HIBYTE(v14) = a1;
  BYTE2(v14) = 9;
  if ( !(unsigned __int8)sub_E289C(v14, 0, &v12, (unsigned __int8 *)&v9) )
    return 0;
  v16 = HIBYTE(v9) << 8;
  *a2 = (unsigned __int8)v10 | v16;
  v16 = BYTE1(v10) << 8;
  *a3 = BYTE2(v10) | v16;
  v16 = HIBYTE(v10) << 8;
  *a4 = v11 | v16;
  return 1;
}

//----- (000E41C8) --------------------------------------------------------
int __fastcall pic1704_get_raw_crab_voltage(char a1, int *a2, int *a3, int *a4, int *a5)
{
  int v10; // [sp+10h] [bp+10h] BYREF
  int v11; // [sp+14h] [bp+14h]
  int v12; // [sp+18h] [bp+18h]
  char v13; // [sp+1Ch] [bp+1Ch]
  int v14; // [sp+20h] [bp+20h] BYREF
  __int16 v15; // [sp+24h] [bp+24h]
  int v16; // [sp+28h] [bp+28h]
  int v17; // [sp+2Ch] [bp+2Ch]
  int v18; // [sp+30h] [bp+30h]

  v14 = 0;
  v15 = 0;
  v10 = 255;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  LOWORD(v16) = 40;
  v17 = 0;
  HIBYTE(v16) = a1;
  BYTE2(v16) = 13;
  if ( !(unsigned __int8)sub_E289C(v16, 0, &v14, (unsigned __int8 *)&v10) )
    return 0;
  v18 = HIBYTE(v10) << 8;
  v18 |= (unsigned __int8)v11;
  *a2 = v18;
  v18 = BYTE1(v11) << 8;
  v18 |= BYTE2(v11);
  *a3 = v18;
  v18 = HIBYTE(v11) << 8;
  v18 |= (unsigned __int8)v12;
  *a4 = v18;
  v18 = BYTE1(v12) << 8;
  v18 |= BYTE2(v12);
  *a5 = v18;
  return 1;
}

//----- (000E4298) --------------------------------------------------------
int __fastcall pic1704_write_iic(char a1, char a2)
{
  _BYTE v3[4]; // [sp+Ch] [bp+Ch] BYREF
  __int16 v4; // [sp+10h] [bp+10h] BYREF
  _DWORD v5[2]; // [sp+14h] [bp+14h] BYREF
  int v6; // [sp+1Ch] [bp+1Ch]
  _BYTE *v7; // [sp+20h] [bp+20h]

  v5[0] = 0;
  v5[1] = 0;
  v4 = 255;
  v3[0] = a2;
  v3[1] = 0;
  LOWORD(v6) = 571;
  v7 = v3;
  HIBYTE(v6) = a1;
  BYTE2(v6) = 2;
  return (unsigned __int8)sub_E289C(v6, (int)v3, v5, (unsigned __int8 *)&v4);
}

//----- (000E42FC) --------------------------------------------------------
int __fastcall pic1704_read_iic(char a1, char a2, _BYTE *a3)
{
  _BYTE v6[4]; // [sp+8h] [bp+8h] BYREF
  _BYTE v7[7]; // [sp+Ch] [bp+Ch] BYREF
  _DWORD v8[2]; // [sp+14h] [bp+14h] BYREF
  int v9; // [sp+1Ch] [bp+1Ch]
  _BYTE *v10; // [sp+20h] [bp+20h]
  int i; // [sp+28h] [bp+28h]
  __int16 v13; // [sp+2Eh] [bp+2Eh]
  _BYTE vars0[8]; // [sp+30h] [bp+30h] BYREF

  v8[0] = 0;
  *(_DWORD *)((char *)v8 + 3) = 0;
  *(_DWORD *)v7 = 255;
  *(_DWORD *)&v7[3] = 0;
  v6[0] = a2;
  v6[1] = 2;
  LOWORD(v9) = 572;
  v10 = v6;
  HIBYTE(v9) = a1;
  BYTE2(v9) = 7;
  if ( !(unsigned __int8)sub_E289C(v9, (int)v6, v8, v7) )
    return 0;
  v13 = 0;
  for ( i = 0; BYTE2(v9) - 2 > i; ++i )
    v13 += (unsigned __int8)v7[i];
  if ( HIBYTE(v13) != (unsigned __int8)vars0[BYTE2(v9) - 38]
    || (unsigned __int8)v13 != (unsigned __int8)vars0[BYTE2(v9) - 37] )
  {
    return 0;
  }
  if ( v7[2] != 1 )
    return 0;
  *a3 = v7[3];
  return 1;
}

//----- (000E43E8) --------------------------------------------------------
int __fastcall pic1704_write_flash(char a1, const void *a2, char a3, size_t a4)
{
  int v9; // [sp+14h] [bp+14h] BYREF
  char v10; // [sp+18h] [bp+18h]
  int v11; // [sp+1Ch] [bp+1Ch]
  void *v12; // [sp+20h] [bp+20h]
  unsigned __int8 v13; // [sp+27h] [bp+27h]
  void *ptr; // [sp+28h] [bp+28h]
  void *v15; // [sp+2Ch] [bp+2Ch]

  v9 = 255;
  v10 = 0;
  v15 = malloc(a4 + 8);
  ptr = malloc(a4 + 2);
  *(_BYTE *)ptr = a3;
  *((_BYTE *)ptr + 1) = a4;
  memcpy((char *)ptr + 2, a2, a4);
  LOBYTE(v11) = 51;
  v12 = ptr;
  BYTE1(v11) = a4 + 2;
  HIBYTE(v11) = a1;
  BYTE2(v11) = 5;
  v13 = sub_E289C(v11, (int)ptr, v15, (unsigned __int8 *)&v9);
  free(ptr);
  free(v15);
  return v13;
}

//----- (000E448C) --------------------------------------------------------
int __fastcall pic1704_read_flash(char a1, void *a2, char a3, size_t a4)
{
  _BYTE v9[4]; // [sp+10h] [bp+10h] BYREF
  _DWORD v10[2]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+1Ch] [bp+1Ch]
  _BYTE *v12; // [sp+20h] [bp+20h]
  void *ptr; // [sp+24h] [bp+24h]
  unsigned int i; // [sp+28h] [bp+28h]
  __int16 v15; // [sp+2Ch] [bp+2Ch]
  unsigned __int8 v16; // [sp+2Fh] [bp+2Fh]

  v10[0] = 0;
  v10[1] = 0;
  ptr = malloc(a4 + 5);
  v9[0] = a3;
  v9[1] = a4;
  LOWORD(v11) = 564;
  v12 = v9;
  HIBYTE(v11) = a1;
  BYTE2(v11) = a4 + 5;
  v16 = sub_E289C(v11, (int)v9, v10, (unsigned __int8 *)ptr);
  if ( v16 )
  {
    v15 = 0;
    for ( i = 0; a4 + 3 > i; ++i )
      v15 += *((unsigned __int8 *)ptr + i);
    if ( HIBYTE(v15) == *((unsigned __int8 *)ptr + a4 + 3) && (unsigned __int8)v15 == *((unsigned __int8 *)ptr + a4 + 4) )
      memcpy(a2, (char *)ptr + 3, a4);
    else
      v16 = 0;
  }
  free(ptr);
  return v16;
}

//----- (000E4574) --------------------------------------------------------
int __fastcall open_pic(unsigned __int8 a1)
{
  int v4; // [sp+Ch] [bp+Ch] BYREF
  __int16 v5; // [sp+10h] [bp+10h]
  char v6; // [sp+12h] [bp+12h]
  unsigned __int8 v7; // [sp+13h] [bp+13h]
  int v8; // [sp+14h] [bp+14h]

  if ( g_bitmain_pic_state[2 * a1] && g_bitmain_pic_state[2 * a1 + 1] )
    return g_bitmain_pic_state[2 * a1];
  v4 = a1;
  v5 = 0;
  v6 = byte_47B310;
  v7 = a1;
  pthread_mutex_lock(&i2c_mutex_all);
  v8 = iic_init((int)&v4);
  pthread_mutex_unlock(&i2c_mutex_all);
  if ( v8 >= 0 )
  {
    g_bitmain_pic_state[2 * a1] = v8;
    g_bitmain_pic_state[2 * a1 + 1] = 1;
  }
  return v8;
}
// 47B2F8: using guessed type pthread_mutex_t i2c_mutex_all;
// 47B310: using guessed type char byte_47B310;
// 47C224: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (000E4628) --------------------------------------------------------
int __fastcall close_pic(int result)
{
  unsigned __int8 v1; // [sp+17h] [bp+7h]
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v3[4096]; // [sp+818h] [bp+808h] BYREF

  v1 = result;
  if ( (unsigned __int8)result <= 0xFu )
  {
    if ( g_bitmain_pic_state[2 * (unsigned __int8)result] || g_bitmain_pic_state[2 * (unsigned __int8)result + 1] )
    {
      pthread_mutex_lock(&i2c_mutex_all);
      iic_uninit(g_bitmain_pic_state[2 * v1]);
      g_bitmain_pic_state[2 * v1 + 1] = 0;
      return pthread_mutex_unlock(&i2c_mutex_all);
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d", "close_pic", (unsigned __int8)result);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, s);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/pic_1704.c",
             87,
             "close_pic",
             9,
             762,
             100,
             v3);
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B2F8: using guessed type pthread_mutex_t i2c_mutex_all;
// 47BE18: using guessed type int g_zc;
// 47C224: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (000E4748) --------------------------------------------------------
int fpga_init()
{
  char v2[2048]; // [sp+10h] [bp+0h] BYREF
  _BYTE v3[4096]; // [sp+810h] [bp+800h] BYREF

  if ( dword_47B314 )
    return 0;
  dword_47B318 = open("/dev/axi_fpga_dev", 2);
  if ( dword_47B318 >= 0 )
  {
    dword_47B31C = (int)mmap(0, 0x1200u, 3, 1, dword_47B318, 0);
    if ( dword_47B31C )
    {
      snprintf(v2, 0x800u, "fpga_init success. axi_fpga_addr_hal = 0x%x\n", dword_47B31C);
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fpga.c",
        94,
        "fpga_init",
        9,
        59,
        20,
        v3);
      dword_47B320 = open("/dev/fpga_mem", 2);
      if ( dword_47B320 >= 0 )
      {
        dword_47B324 = (int)mmap(0, 0x1000000u, 3, 1, dword_47B320, 0);
        if ( dword_47B324 )
        {
          snprintf(v2, 0x800u, "mmap fpga_mem_addr_hal = 0x%x\n", dword_47B324);
          V_LOCK();
          logfmt_raw(v3, 0x1000u, 0, v2);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fpga.c",
            94,
            "fpga_init",
            9,
            76,
            40,
            v3);
          dword_47B314 = 1;
          return 0;
        }
        else
        {
          snprintf(v2, 0x800u, "mmap fpga_mem_addr_hal failed. fpga_mem_addr_hal = 0x%x\n", 0);
          V_LOCK();
          logfmt_raw(v3, 0x1000u, 0, v2);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fpga.c",
            94,
            "fpga_init",
            9,
            73,
            100,
            v3);
          return -1;
        }
      }
      else
      {
        snprintf(v2, 0x800u, "/dev/fpga_mem open failed. fd_fpga_mem_hal = %d\n", dword_47B320);
        V_LOCK();
        logfmt_raw(v3, 0x1000u, 0, v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fpga.c",
          94,
          "fpga_init",
          9,
          64,
          100,
          v3);
        perror("open");
        return -1;
      }
    }
    else
    {
      snprintf(v2, 0x800u, "mmap axi_fpga_addr_hal failed. axi_fpga_addr_hal = 0x%x\n", 0);
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fpga.c",
        94,
        "fpga_init",
        9,
        53,
        100,
        v3);
      close(dword_47B318);
      return -2;
    }
  }
  else
  {
    snprintf(v2, 0x800u, "/dev/axi_fpga_dev open failed. fd = %d\n", dword_47B318);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fpga.c",
      94,
      "fpga_init",
      9,
      45,
      100,
      v3);
    return -1;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B314: using guessed type int dword_47B314;
// 47B318: using guessed type int dword_47B318;
// 47B31C: using guessed type int dword_47B31C;
// 47B320: using guessed type int dword_47B320;
// 47B324: using guessed type int dword_47B324;
// 47BE18: using guessed type int g_zc;

//----- (000E4AD4) --------------------------------------------------------
void fpga_uninit()
{
  char v0[2048]; // [sp+14h] [bp+4h] BYREF
  int v1; // [sp+814h] [bp+804h] BYREF
  int v2; // [sp+1814h] [bp+1804h]

  if ( dword_47B314 )
  {
    v2 = munmap((void *)dword_47B31C, 0x1200u);
    if ( v2 < 0 )
    {
      strcpy(v0, "munmap axi_fpga_addr_hal failed!\n");
      V_LOCK();
      logfmt_raw(&v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fpga.c",
        94,
        "fpga_uninit",
        11,
        95,
        100,
        &v1);
    }
    v2 = munmap((void *)dword_47B324, 0x1000000u);
    if ( v2 < 0 )
    {
      strcpy(v0, "munmap fpga_mem_addr_hal failed!\n");
      V_LOCK();
      logfmt_raw(&v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fpga.c",
        94,
        "fpga_uninit",
        11,
        101,
        100,
        &v1);
    }
    dword_47B314 = 0;
    close(dword_47B318);
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B314: using guessed type int dword_47B314;
// 47B318: using guessed type int dword_47B318;
// 47B31C: using guessed type int dword_47B31C;
// 47B324: using guessed type int dword_47B324;
// 47BE18: using guessed type int g_zc;

//----- (000E4C50) --------------------------------------------------------
int __fastcall fpga_read(unsigned int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(4 * (a1 >> 2) + dword_47B31C);
  return 0;
}
// 47B31C: using guessed type int dword_47B31C;

//----- (000E4C80) --------------------------------------------------------
int __fastcall fpga_write(unsigned int a1, int a2)
{
  *(_DWORD *)(4 * (a1 >> 2) + dword_47B31C) = a2;
  return 0;
}
// 47B31C: using guessed type int dword_47B31C;

//----- (000E4CB0) --------------------------------------------------------
int get_fpga_map_mem_addr()
{
  return dword_47B324;
}
// 47B324: using guessed type int dword_47B324;

//----- (000E4CC8) --------------------------------------------------------
int sub_E4CC8()
{
  _DWORD v1[3]; // [sp+Ch] [bp+Ch] BYREF
  int v2; // [sp+18h] [bp+18h]
  void *ptr; // [sp+1Ch] [bp+1Ch]
  _DWORD *v4; // [sp+20h] [bp+20h]
  int i; // [sp+24h] [bp+24h]

  while ( dword_47B348 )
  {
    if ( !pthread_mutex_lock(&stru_47B328) )
    {
      v4 = new_iterator_c_map(dword_47B340);
      for ( i = ((int (__fastcall *)(_DWORD *))*v4)(v4); i; i = ((int (__fastcall *)(_DWORD *))*v4)(v4) )
      {
        ptr = (void *)((int (__fastcall *)(int))v4[2])(i);
        v2 = v4[5];
        if ( !*((_DWORD *)ptr + 1) )
        {
          gpio_write(***(_DWORD ***)(v2 + 16), *((_DWORD *)ptr + 2));
          *((_DWORD *)ptr + 2) = *((_DWORD *)ptr + 2) != 1;
          *((_DWORD *)ptr + 1) = *(_DWORD *)ptr;
        }
        *((_DWORD *)ptr + 1) -= 200;
        *((_DWORD *)ptr + 1) = *((_DWORD *)ptr + 1);
        v1[0] = *(_DWORD *)ptr;
        v1[1] = *((_DWORD *)ptr + 1);
        v1[2] = *((_DWORD *)ptr + 2);
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v4[1])(v4, v1, 12);
        free(ptr);
      }
      delete_iterator_c_map(v4);
      pthread_mutex_unlock(&stru_47B328);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 47B328: using guessed type pthread_mutex_t stru_47B328;
// 47B340: using guessed type int dword_47B340;
// 47B348: using guessed type int dword_47B348;

//----- (000E4DF4) --------------------------------------------------------
int __fastcall sub_E4DF4(unsigned int a1)
{
  int v2; // [sp+Ch] [bp+Ch]

  v2 = 0;
  if ( a1 == 2 )
    return 942;
  if ( a1 > 2 )
  {
    if ( a1 == 256 )
    {
      return 921;
    }
    else if ( a1 == 257 )
    {
      return 943;
    }
  }
  else if ( a1 == 1 )
  {
    return 941;
  }
  return v2;
}

//----- (000E4E50) --------------------------------------------------------
int __fastcall sub_E4E50(int a1)
{
  int v2; // [sp+Ch] [bp+Ch]

  v2 = 259;
  if ( a1 == 921 )
    return 256;
  if ( a1 == 943 )
    return 257;
  return v2;
}

//----- (000E4E90) --------------------------------------------------------
int __fastcall sub_E4E90(int a1, char a2)
{
  int result; // r0
  char v5[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v6[8]; // [sp+818h] [bp+808h] BYREF
  int v7; // [sp+1818h] [bp+1808h]
  int i; // [sp+181Ch] [bp+180Ch]

  result = sub_E4E50(a1);
  v7 = result;
  if ( result == 259 )
  {
    snprintf(v5, 0x800u, "gpio port %d is not a supported key\n", a1);
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, v5);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
             92,
             "gpio_key_callback",
             17,
             134,
             80,
             v6);
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( dword_47B350[i] )
        result = dword_47B350[i](v7, a2 != 0);
    }
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B350: using guessed type int (__fastcall *dword_47B350[5])(int, bool);
// 47BE18: using guessed type int g_zc;

//----- (000E4FD0) --------------------------------------------------------
int ui_init()
{
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  char v8[2048]; // [sp+14h] [bp+4h] BYREF
  int v9; // [sp+814h] [bp+804h] BYREF
  int i; // [sp+1814h] [bp+1804h]

  i = 0;
  if ( dword_47B344 )
    return 0;
  if ( gpio_init() )
  {
    strcpy(v8, "gpio init failed\n");
    V_LOCK();
    logfmt_raw(&v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
      92,
      "ui_init",
      7,
      152,
      100,
      &v9);
    return -1;
  }
  else
  {
    v1 = sub_E4DF4(1u);
    gpio_export(v1);
    v2 = sub_E4DF4(2u);
    gpio_export(v2);
    v3 = sub_E4DF4(0x100u);
    gpio_export(v3);
    v4 = sub_E4DF4(0x101u);
    gpio_export(v4);
    v5 = sub_E4DF4(0x100u);
    gpio_reg_callback(v5, 937617);
    v6 = sub_E4DF4(0x101u);
    gpio_reg_callback(v6, 937617);
    pthread_mutex_init(&stru_47B328, 0);
    for ( i = 0; i <= 4; ++i )
      dword_47B350[i] = 0;
    dword_47B340 = (int)new_c_map(937429, 0, 0);
    dword_47B348 = 1;
    pthread_create((pthread_t *)&dword_47B34C, 0, (void *(*)(void *))sub_E4CC8, 0);
    dword_47B344 = 1;
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B328: using guessed type pthread_mutex_t stru_47B328;
// 47B340: using guessed type int dword_47B340;
// 47B344: using guessed type int dword_47B344;
// 47B348: using guessed type int dword_47B348;
// 47B34C: using guessed type int dword_47B34C;
// 47B350: using guessed type int (__fastcall *dword_47B350[5])(int, bool);
// 47BE18: using guessed type int g_zc;

//----- (000E5194) --------------------------------------------------------
void ui_uninit()
{
  int v0; // r0
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0

  if ( dword_47B344 )
  {
    dword_47B348 = 0;
    pthread_join(dword_47B34C, 0);
    delete_c_map((void ***)dword_47B340);
    pthread_mutex_destroy(&stru_47B328);
    v0 = sub_E4DF4(0x100u);
    gpio_unreg_callback(v0, 937617);
    v1 = sub_E4DF4(0x101u);
    gpio_unreg_callback(v1, 937617);
    v2 = sub_E4DF4(1u);
    gpio_unexport(v2);
    v3 = sub_E4DF4(2u);
    gpio_unexport(v3);
    v4 = sub_E4DF4(0x100u);
    gpio_unexport(v4);
    v5 = sub_E4DF4(0x101u);
    gpio_unexport(v5);
    gpio_uninit();
    dword_47B344 = 0;
  }
}
// 47B328: using guessed type pthread_mutex_t stru_47B328;
// 47B340: using guessed type int dword_47B340;
// 47B344: using guessed type int dword_47B344;
// 47B348: using guessed type int dword_47B348;
// 47B34C: using guessed type int dword_47B34C;

//----- (000E5260) --------------------------------------------------------
int __fastcall sub_E5260(int result, int *a2)
{
  int v3; // [sp+14h] [bp+4h] BYREF
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[4096]; // [sp+818h] [bp+808h] BYREF

  v3 = result;
  if ( a2 )
  {
    result = exists_c_map(a2, (int)&v3);
    if ( result == 1 )
    {
      snprintf(s, 0x800u, "remove %d from flicker list\n", v3);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
        92,
        "remove_port_form_gpio_map",
        25,
        205,
        20,
        v5);
      return remove_c_map(a2, (int)&v3);
    }
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E5330) --------------------------------------------------------
int __fastcall sub_E5330(int result, int a2, int *a3)
{
  _DWORD v5[2]; // [sp+1Ch] [bp+Ch] BYREF
  char v6[12]; // [sp+24h] [bp+14h] BYREF
  _BYTE v7[12]; // [sp+824h] [bp+814h] BYREF
  _DWORD v8[3]; // [sp+1824h] [bp+1814h] BYREF

  v5[0] = result;
  if ( a3 )
  {
    if ( exists_c_map(a3, (int)v5) )
    {
      snprintf(v6, 0x800u, "port %d already exist in map\n", v5[0]);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
               92,
               "add_port_to_gpio_map",
               20,
               227,
               20,
               v7);
    }
    else
    {
      snprintf(v6, 0x800u, "add %d to flicker map with interval %d\n", v5[0], a2);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
        92,
        "add_port_to_gpio_map",
        20,
        221,
        20,
        v7);
      v8[0] = a2;
      v8[1] = 0;
      v8[2] = 1;
      return insert_c_map(a3, v5, 4u, v8, 0xCu);
    }
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E54C4) --------------------------------------------------------
int __fastcall sub_E54C4(unsigned int a1, int a2)
{
  char v6[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[8]; // [sp+818h] [bp+808h] BYREF
  int v8; // [sp+1818h] [bp+1808h]
  int v9; // [sp+181Ch] [bp+180Ch]

  v9 = -1;
  v8 = sub_E4DF4(a1);
  if ( v8 )
  {
    snprintf(v6, 0x800u, "ui type = %d, port = %d, status = %d\n", a1, v8, a2);
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
      92,
      "gpio_ctrl_ui",
      12,
      277,
      20,
      v7);
    if ( pthread_mutex_lock(&stru_47B328) )
    {
      strcpy(v6, "failed to api lock\n");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
        92,
        "gpio_ctrl_ui",
        12,
        280,
        100,
        v7);
      return -1;
    }
    else
    {
      if ( a2 == 1 )
      {
        sub_E5260(v8, (int *)dword_47B340);
        v9 = gpio_write(v8, 0);
      }
      else if ( a2 )
      {
        if ( a2 == 2 )
        {
          sub_E5330(v8, 200, (int *)dword_47B340);
        }
        else
        {
          strcpy(v6, "unsuported led status\n");
          V_LOCK();
          logfmt_raw(v7, 0x1000u, 0, v6);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
            92,
            "gpio_ctrl_ui",
            12,
            297,
            100,
            v7);
          v9 = -2;
        }
      }
      else
      {
        sub_E5260(v8, (int *)dword_47B340);
        v9 = gpio_write(v8, 1);
      }
      pthread_mutex_unlock(&stru_47B328);
      return v9;
    }
  }
  else
  {
    strcpy(v6, "unsuported gpio port\n");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
      92,
      "gpio_ctrl_ui",
      12,
      273,
      100,
      v7);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B328: using guessed type pthread_mutex_t stru_47B328;
// 47B340: using guessed type int dword_47B340;
// 47BE18: using guessed type int g_zc;

//----- (000E57E4) --------------------------------------------------------
int red_led_on()
{
  return sub_E54C4(1u, 0);
}

//----- (000E57F8) --------------------------------------------------------
int red_led_off()
{
  return sub_E54C4(1u, 1);
}

//----- (000E580C) --------------------------------------------------------
int red_led_flicker()
{
  return sub_E54C4(1u, 2);
}

//----- (000E5820) --------------------------------------------------------
int green_led_on()
{
  return sub_E54C4(2u, 0);
}

//----- (000E5834) --------------------------------------------------------
int green_led_off()
{
  return sub_E54C4(2u, 1);
}

//----- (000E5848) --------------------------------------------------------
int green_led_flicker()
{
  return sub_E54C4(2u, 2);
}

//----- (000E585C) --------------------------------------------------------
int beeper_on()
{
  return sub_E54C4(0x10u, 0);
}

//----- (000E5870) --------------------------------------------------------
int beeper_off()
{
  return sub_E54C4(0x10u, 1);
}

//----- (000E5884) --------------------------------------------------------
int beeper_flicker()
{
  return sub_E54C4(0x10u, 2);
}

//----- (000E5898) --------------------------------------------------------
int __fastcall reg_key_callback(int (__fastcall *a1)(int, bool))
{
  char v4[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[8]; // [sp+818h] [bp+808h] BYREF
  int v6; // [sp+1818h] [bp+1808h]
  int i; // [sp+181Ch] [bp+180Ch]

  i = 0;
  v6 = 0;
  if ( pthread_mutex_lock(&stru_47B328) )
  {
    strcpy(v4, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
      92,
      "reg_key_callback",
      16,
      398,
      100,
      v5);
    return -1;
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( !dword_47B350[i] )
      {
        dword_47B350[i] = a1;
        break;
      }
    }
    if ( i > 4 )
    {
      v6 = -2;
      strcpy(v4, "no more listener available\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
        92,
        "reg_key_callback",
        16,
        414,
        100,
        v5);
    }
    pthread_mutex_unlock(&stru_47B328);
    return v6;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B328: using guessed type pthread_mutex_t stru_47B328;
// 47B350: using guessed type int (__fastcall *dword_47B350[5])(int, bool);
// 47BE18: using guessed type int g_zc;

//----- (000E5A64) --------------------------------------------------------
int __fastcall unreg_key_callback(int (__fastcall *a1)(int, bool))
{
  char v4[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v5; // [sp+81Ch] [bp+80Ch] BYREF
  int i; // [sp+181Ch] [bp+180Ch]

  i = 0;
  if ( pthread_mutex_lock(&stru_47B328) )
  {
    strcpy(v4, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(&v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
      92,
      "unreg_key_callback",
      18,
      434,
      100,
      &v5);
    return -1;
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( dword_47B350[i] == a1 )
      {
        dword_47B350[i] = 0;
        break;
      }
    }
    if ( i > 4 )
    {
      strcpy(v4, "listener not registered before\n");
      V_LOCK();
      logfmt_raw(&v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
        92,
        "unreg_key_callback",
        18,
        448,
        80,
        &v5);
    }
    pthread_mutex_unlock(&stru_47B328);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B328: using guessed type pthread_mutex_t stru_47B328;
// 47B350: using guessed type int (__fastcall *dword_47B350[5])(int, bool);
// 47BE18: using guessed type int g_zc;

//----- (000E5C10) --------------------------------------------------------
int __fastcall lcd_show_result(unsigned __int8 a1, int a2, unsigned int a3)
{
  char v8[2048]; // [sp+24h] [bp+14h] BYREF
  int v9; // [sp+824h] [bp+814h] BYREF
  int v10; // [sp+1824h] [bp+1814h]

  v10 = -1;
  if ( pthread_mutex_lock(&stru_47B328) )
  {
    strcpy(v8, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(&v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
      92,
      "lcd_show_result",
      15,
      470,
      100,
      &v9);
    return -4;
  }
  else
  {
    if ( dword_1EF698 < 0 )
    {
      dword_1EF698 = lcd_init(lcd_path[0]);
      lcd_clear(dword_1EF698);
    }
    if ( dword_1EF698 <= 0 )
    {
      snprintf(v8, 0x800u, "failed to init %s\n", lcd_path[0]);
      V_LOCK();
      logfmt_raw(&v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
        92,
        "lcd_show_result",
        15,
        486,
        100,
        &v9);
      v10 = -1;
    }
    else
    {
      v10 = lcd_write(dword_1EF698, a1, a2, a3);
    }
    pthread_mutex_unlock(&stru_47B328);
    return v10;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1EF698: using guessed type int dword_1EF698;
// 1EF69C: using guessed type char *lcd_path[34];
// 47B328: using guessed type pthread_mutex_t stru_47B328;
// 47BE18: using guessed type int g_zc;

//----- (000E5DE8) --------------------------------------------------------
int lcd_clear_result()
{
  char v1[2048]; // [sp+10h] [bp+0h] BYREF
  _BYTE v2[4096]; // [sp+810h] [bp+800h] BYREF

  if ( pthread_mutex_lock(&stru_47B328) )
  {
    strcpy(v1, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_ui.c",
             92,
             "lcd_clear_result",
             16,
             501,
             100,
             v2);
  }
  else
  {
    if ( dword_1EF698 > 0 )
      lcd_clear(dword_1EF698);
    return pthread_mutex_unlock(&stru_47B328);
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1EF698: using guessed type int dword_1EF698;
// 47B328: using guessed type pthread_mutex_t stru_47B328;
// 47BE18: using guessed type int g_zc;

//----- (000E5E9C) --------------------------------------------------------
int bitmain_power_on()
{
  if ( !is_gpio_exist(907) )
  {
    gpio_export(907);
    gpio_direction(907, 1);
  }
  return gpio_write(907, 0);
}

//----- (000E5ED0) --------------------------------------------------------
int bitmain_power_off()
{
  if ( !is_gpio_exist(907) )
  {
    gpio_export(907);
    gpio_direction(907, 1);
  }
  return gpio_write(907, 1);
}

//----- (000E5F04) --------------------------------------------------------
int __fastcall iic_init(int a1)
{
  char v4[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[8]; // [sp+818h] [bp+808h] BYREF
  int v6; // [sp+1818h] [bp+1808h]
  int v7; // [sp+181Ch] [bp+180Ch]

  v7 = -1;
  v6 = 0;
  if ( pthread_mutex_lock(&stru_47B364) )
  {
    strcpy(v4, "failed to iic lock\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
      93,
      "iic_init",
      8,
      20,
      100,
      v5);
    return -4;
  }
  else
  {
    if ( a1 )
    {
      v6 = i2c_init();
      if ( v6 >= 0 )
      {
        snprintf(
          v4,
          0x800u,
          "i2c chain = %d, master = 0x%x, slave high= 0x%x, slave low = 0x%x\n",
          *(_DWORD *)a1,
          *(unsigned __int16 *)(a1 + 4),
          *(unsigned __int8 *)(a1 + 6),
          *(unsigned __int8 *)(a1 + 7));
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
          93,
          "iic_init",
          8,
          36,
          20,
          v5);
        if ( i2c_select(v6, *(unsigned __int16 *)(a1 + 4)) )
        {
          strcpy(v4, "failed to i2c_select\n");
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
            93,
            "iic_init",
            8,
            38,
            100,
            v5);
          v7 = -1;
        }
        else
        {
          if ( !i2c_ioctl(v6, 1795, (2 * *(unsigned __int8 *)(a1 + 7)) | (16 * *(unsigned __int8 *)(a1 + 6))) )
          {
            pthread_mutex_unlock(&stru_47B364);
            return v6;
          }
          strcpy(v4, "failed to i2c_ioctl\n");
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
            93,
            "iic_init",
            8,
            43,
            100,
            v5);
          v7 = -1;
        }
      }
      else
      {
        strcpy(v4, "failed to i2c_init\n");
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
          93,
          "iic_init",
          8,
          32,
          100,
          v5);
        v7 = -1;
      }
    }
    else
    {
      strcpy(v4, "bad param\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
        93,
        "iic_init",
        8,
        26,
        100,
        v5);
      v7 = -3;
    }
    if ( v6 > 0 )
      i2c_uninit(v6);
    pthread_mutex_unlock(&stru_47B364);
    return v7;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B364: using guessed type pthread_mutex_t stru_47B364;
// 47BE18: using guessed type int g_zc;

//----- (000E6320) --------------------------------------------------------
int __fastcall iic_uninit(int a1)
{
  char v3[2048]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[1025]; // [sp+81Ch] [bp+80Ch] BYREF

  v4[1024] = 0;
  if ( pthread_mutex_lock(&stru_47B364) )
  {
    strcpy(v3, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
             93,
             "iic_uninit",
             10,
             64,
             100,
             v4);
  }
  else
  {
    i2c_uninit(a1);
    return pthread_mutex_unlock(&stru_47B364);
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B364: using guessed type pthread_mutex_t stru_47B364;
// 47BE18: using guessed type int g_zc;

//----- (000E63E0) --------------------------------------------------------
int __fastcall iic_read(int a1, int a2, unsigned int a3)
{
  int v6; // [sp+14h] [bp+4h]
  char v9[2048]; // [sp+20h] [bp+10h] BYREF
  _BYTE v10[4096]; // [sp+820h] [bp+810h] BYREF

  if ( pthread_mutex_lock(&stru_47B364) )
  {
    strcpy(v9, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
      93,
      "iic_read",
      8,
      83,
      100,
      v10);
    return -4;
  }
  else
  {
    v6 = i2c_read(a1, a2, a3);
    pthread_mutex_unlock(&stru_47B364);
    return v6;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B364: using guessed type pthread_mutex_t stru_47B364;
// 47BE18: using guessed type int g_zc;

//----- (000E64C4) --------------------------------------------------------
int __fastcall iic_write(int a1, int a2, unsigned int a3)
{
  int v6; // [sp+14h] [bp+4h]
  char v9[2048]; // [sp+20h] [bp+10h] BYREF
  _BYTE v10[4096]; // [sp+820h] [bp+810h] BYREF

  if ( pthread_mutex_lock(&stru_47B364) )
  {
    strcpy(v9, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
      93,
      "iic_write",
      9,
      103,
      100,
      v10);
    return -4;
  }
  else
  {
    v6 = i2c_write(a1, a2, a3);
    pthread_mutex_unlock(&stru_47B364);
    return v6;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B364: using guessed type pthread_mutex_t stru_47B364;
// 47BE18: using guessed type int g_zc;

//----- (000E65A8) --------------------------------------------------------
int __fastcall iic_read_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  char v11[2048]; // [sp+20h] [bp+10h] BYREF
  _BYTE v12[4096]; // [sp+820h] [bp+810h] BYREF
  int reg; // [sp+1830h] [bp+1820h]

  if ( pthread_mutex_lock(&stru_47B364) )
  {
    strcpy(v11, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
      93,
      "iic_read_reg",
      12,
      124,
      100,
      v12);
    return -4;
  }
  else
  {
    reg = i2c_read_reg(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&stru_47B364);
    return reg;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B364: using guessed type pthread_mutex_t stru_47B364;
// 47BE18: using guessed type int g_zc;

//----- (000E66A0) --------------------------------------------------------
int __fastcall iic_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  char v11[2048]; // [sp+20h] [bp+10h] BYREF
  _BYTE v12[4096]; // [sp+820h] [bp+810h] BYREF
  int v13; // [sp+1830h] [bp+1820h]

  if ( pthread_mutex_lock(&stru_47B364) )
  {
    strcpy(v11, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_iic.c",
      93,
      "iic_write_reg",
      13,
      146,
      100,
      v12);
    return -4;
  }
  else
  {
    v13 = i2c_write_reg(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&stru_47B364);
    return v13;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B364: using guessed type pthread_mutex_t stru_47B364;
// 47BE18: using guessed type int g_zc;

//----- (000E6798) --------------------------------------------------------
unsigned int *__fastcall sub_E6798(unsigned int *result)
{
  unsigned int *v1; // [sp+14h] [bp+4h]
  char v2[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v3[8]; // [sp+818h] [bp+808h] BYREF
  unsigned int j; // [sp+1818h] [bp+1808h]
  unsigned int i; // [sp+181Ch] [bp+180Ch]

  v1 = result;
  if ( result )
  {
    strcpy(v2, "==================capability start==================\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "platform_dump_capability",
      24,
      43,
      20,
      v3);
    snprintf(v2, 0x800u, "board num = %d\n", *v1);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "platform_dump_capability",
      24,
      44,
      20,
      v3);
    for ( i = 0; *v1 > i; ++i )
    {
      snprintf(v2, 0x800u, "board id = %d, chain num = %d\n", v1[18 * i + 1], v1[18 * i + 2]);
      V_LOCK();
      logfmt_raw(v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
        96,
        "platform_dump_capability",
        24,
        48,
        20,
        v3);
      for ( j = 0; v1[18 * i + 2] > j; ++j )
      {
        snprintf(v2, 0x800u, "\tchain id = %d\n", v1[18 * i + 3 + j]);
        V_LOCK();
        logfmt_raw(v3, 0x1000u, 0, v2);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
          96,
          "platform_dump_capability",
          24,
          50,
          20,
          v3);
      }
    }
    strcpy(v2, "==================capability end==================\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    return (unsigned int *)zlog(
                             g_zc,
                             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
                             96,
                             "platform_dump_capability",
                             24,
                             54,
                             20,
                             v3);
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E6AF4) --------------------------------------------------------
int platform_init()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  if ( platform_inited )
    return 0;
  strcpy(v2, "platform_init\n");
  V_LOCK();
  logfmt_raw(&v3, 0x1000u, 0, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
    96,
    "platform_init",
    13,
    63,
    60,
    &v3);
  if ( fpga_init() )
  {
    strcpy(v2, "fpga init failed\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "platform_init",
      13,
      67,
      100,
      &v3);
    return -1;
  }
  else if ( gpio_init() )
  {
    strcpy(v2, "gpio init failed\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "platform_init",
      13,
      73,
      100,
      &v3);
    return -2;
  }
  else
  {
    memset(&unk_47B3B0, 0, 0x124u);
    v4 = 0;
    fpga_read(0, &v4);
    v4 |= 0x20000000u;
    snprintf(v2, 0x800u, "HARDWARE_VERSION = 0x%x\n", v4);
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "platform_init",
      13,
      86,
      40,
      &v3);
    fpga_write(0, v4);
    platform_inited = 1;
    fan_init();
    uart_init();
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E6D64) --------------------------------------------------------
int platform_uninit()
{
  int result; // r0

  if ( platform_inited )
  {
    uart_uninit();
    fpga_uninit();
    fan_uninit();
    ui_uninit();
    result = gpio_uninit();
    platform_inited = 0;
  }
  return result;
}
// 47B37C: using guessed type int platform_inited;

//----- (000E6D9C) --------------------------------------------------------
void *__fastcall get_system_capability(void *result)
{
  if ( result )
    return memcpy(result, &unk_47B3B0, 0x124u);
  return result;
}

//----- (000E6DC4) --------------------------------------------------------
int __fastcall sub_E6DC4(const char *a1, int a2)
{
  char v6[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[8]; // [sp+818h] [bp+808h] BYREF
  char v8[24]; // [sp+1818h] [bp+1808h] BYREF
  int v9; // [sp+1838h] [bp+1828h]
  int i; // [sp+183Ch] [bp+182Ch]

  v9 = socket(2, 1, 0);
  if ( v9 >= 0 )
  {
    strcpy(v8, a1);
    if ( ioctl(v9, 0x8927u, v8) >= 0 )
    {
      for ( i = 0; i <= 5; ++i )
        *(_BYTE *)(a2 + i) = v8[i + 18];
      close(v9);
      return 0;
    }
    else
    {
      strcpy(v6, "error ioctl");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
        96,
        "get_eth_mac",
        11,
        134,
        100,
        v7);
      close(v9);
      return -2;
    }
  }
  else
  {
    strcpy(v6, "error sock");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "get_eth_mac",
      11,
      128,
      100,
      v7);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E6FA8) --------------------------------------------------------
int __fastcall get_uuid(void *a1)
{
  if ( !a1 )
    return -1;
  memset(a1, 0, 0x10u);
  return sub_E6DC4("eth0", (int)a1);
}

//----- (000E6FE4) --------------------------------------------------------
int __fastcall get_mac_hal(int a1)
{
  if ( a1 )
    return sub_1A4070("eth0", a1);
  else
    return -1;
}
// 1A4070: using guessed type int __fastcall sub_1A4070(_DWORD, _DWORD);

//----- (000E7014) --------------------------------------------------------
int __fastcall chain_reset(char a1)
{
  chain_reset_low(a1);
  usleep((__useconds_t)&stru_1869C.st_value);
  return chain_reset_high(a1);
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000E703C) --------------------------------------------------------
int __fastcall chain_reset_low(char a1)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  v3 = 0;
  fpga_read(0x34u, &v3);
  return fpga_write(0x34u, v3 | (1 << a1));
}

//----- (000E7078) --------------------------------------------------------
int __fastcall chain_reset_high(char a1)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  v3 = 0;
  fpga_read(0x34u, &v3);
  return fpga_write(0x34u, v3 & ~(1 << a1));
}

//----- (000E70B4) --------------------------------------------------------
unsigned int all_chain_reset_high()
{
  unsigned int v1; // [sp+4h] [bp+4h] BYREF

  v1 = 0;
  fpga_read(0x34u, &v1);
  v1 = ~(~HIWORD(v1) << 16);
  fpga_write(0x34u, v1);
  return sleep(2u);
}

//----- (000E70EC) --------------------------------------------------------
unsigned int all_chain_reset_low()
{
  unsigned int v1; // [sp+4h] [bp+4h] BYREF

  v1 = 0;
  fpga_read(0x34u, &v1);
  v1 = HIWORD(v1) << 16;
  fpga_write(0x34u, v1);
  return sleep(2u);
}

//----- (000E7120) --------------------------------------------------------
void board_reset()
{
  board_reset_low();
  usleep((__useconds_t)&stru_1869C.st_value);
  board_reset_high();
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000E7148) --------------------------------------------------------
void board_reset_low()
{
  ;
}

//----- (000E715C) --------------------------------------------------------
void board_reset_high()
{
  ;
}

//----- (000E7170) --------------------------------------------------------
int get_hardware_type()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v4);
    return v4 < 0;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "get_hardware_type",
      17,
      240,
      100,
      &v3);
    return 2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E723C) --------------------------------------------------------
int __fastcall set_hardware_type(int a1)
{
  char v4[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v5; // [sp+81Ch] [bp+80Ch] BYREF
  int v6; // [sp+181Ch] [bp+180Ch] BYREF

  v6 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v6);
    if ( a1 )
    {
      if ( a1 == 1 )
        v6 |= 0x80000000;
    }
    else
    {
      v6 &= ~0x80000000;
    }
    fpga_write(0, v6);
    return 0;
  }
  else
  {
    strcpy(v4, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "set_hardware_type",
      17,
      257,
      100,
      &v5);
    return -2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E7358) --------------------------------------------------------
int enable_bypass_mode()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v4);
    v4 |= 0x20000000u;
    fpga_write(0, v4);
    return 0;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "enable_bypass_mode",
      18,
      280,
      100,
      &v3);
    return -2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E7440) --------------------------------------------------------
int disable_bypass_mode()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v4);
    v4 &= ~0x20000000u;
    fpga_write(0, v4);
    return 0;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "disable_bypass_mode",
      19,
      294,
      100,
      &v3);
    return -2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E7528) --------------------------------------------------------
bool is_bypass_mode_enable()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v4);
    v4 &= 0x20000000u;
    return v4 != 0;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "is_bypass_mode_enable",
      21,
      308,
      100,
      &v3);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E760C) --------------------------------------------------------
int get_hardware_version()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0, &v4);
    return v4;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "get_hardware_version",
      20,
      322,
      100,
      &v3);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E76D0) --------------------------------------------------------
int get_dhash_acc_control()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  v1 = 0;
  fpga_read(0x100u, &v1);
  return v1;
}

//----- (000E76F0) --------------------------------------------------------
__int64 __fastcall set_dhash_acc_control(int a1)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4096]; // [sp+818h] [bp+808h] BYREF

  fpga_write(0x100u, a1);
  snprintf(s, 0x800u, "set DHASH_ACC_CONTROL is 0x%x\n", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
           96,
           "set_dhash_acc_control",
           21,
           343,
           40,
           v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E7788) --------------------------------------------------------
__int64 disable_dhash_chip_work()
{
  int dhash_acc_control; // r0
  int v2; // [sp+4h] [bp+4h] BYREF

  v2 = 0;
  fpga_read(0xC0u, &v2);
  v2 &= ~0x400000u;
  fpga_write(0xC0u, v2);
  dhash_acc_control = get_dhash_acc_control();
  return set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
}

//----- (000E77C8) --------------------------------------------------------
__int64 fpga_chain_reset_all()
{
  char v1[4]; // [sp+14h] [bp+4h] BYREF
  int v2; // [sp+814h] [bp+804h] BYREF
  unsigned int v3; // [sp+1814h] [bp+1804h] BYREF

  v3 = 0;
  fpga_read(0x34u, &v3);
  fpga_write(0x34u, ~(~HIWORD(v3) << 16));
  sleep(3u);
  fpga_read(0x34u, &v3);
  fpga_write(0x34u, HIWORD(v3) << 16);
  sleep(1u);
  snprintf(v1, 0x800u, "fpga fpga_chain_reset_all success 0x%x\n", v3);
  V_LOCK();
  logfmt_raw(&v2, 0x1000u, 0, v1);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
           96,
           "fpga_chain_reset_all",
           20,
           369,
           20,
           &v2);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E78BC) --------------------------------------------------------
__int64 __fastcall read_fpga_id(char *a1)
{
  char v3[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[8]; // [sp+818h] [bp+808h] BYREF
  int v5; // [sp+1818h] [bp+1808h] BYREF
  int v6; // [sp+181Ch] [bp+180Ch] BYREF

  v6 = 0;
  v5 = 0;
  fpga_read(0xF0u, &v6);
  fpga_read(0xF4u, &v5);
  sprintf(a1, "%08x%08x", v5, v6);
  snprintf(v3, 0x800u, "\n%x %x\n", v6, v5);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, v3);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
           96,
           "read_fpga_id",
           12,
           379,
           100,
           v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E79BC) --------------------------------------------------------
int __fastcall set_hardware_version(int a1)
{
  return fpga_write(0, a1);
}

//----- (000E79D4) --------------------------------------------------------
int get_job_start_address()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x118u, &v1);
  return v1;
}

//----- (000E79F0) --------------------------------------------------------
int __fastcall set_job_start_address(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x118u, a1);
  return fpga_read(0x118u, &v2);
}

//----- (000E7A18) --------------------------------------------------------
int get_nonce2_and_job_id_store_address()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x110u, &v1);
  return v1;
}

//----- (000E7A34) --------------------------------------------------------
int __fastcall set_nonce2_and_job_id_store_address(int a1)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  fpga_read(0x110u, &v3);
  fpga_write(0x110u, a1);
  return fpga_read(0x110u, &v3);
}

//----- (000E7A6C) --------------------------------------------------------
int __fastcall get_fan_speed(_BYTE *a1, _DWORD *a2)
{
  int v5; // [sp+Ch] [bp+Ch] BYREF

  fpga_read(4u, &v5);
  *a2 = (unsigned __int8)v5;
  *a1 = BYTE1(v5) & 7;
  return v5;
}

//----- (000E7AA4) --------------------------------------------------------
int __fastcall set_time_out_control(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x88u, a1);
  return fpga_read(0x88u, &v2);
}

//----- (000E7AC8) --------------------------------------------------------
int get_hash_counting_number()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x90u, &v1);
  return v1;
}

//----- (000E7AE4) --------------------------------------------------------
int __fastcall set_hash_counting_number(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x90u, a1);
  return fpga_read(0x90u, &v2);
}

//----- (000E7B08) --------------------------------------------------------
int enable_mid_auto_gen_rx()
{
  return fpga_write(0xF8u, 196608);
}

//----- (000E7B1C) --------------------------------------------------------
int disable_mid_auto_gen_rx()
{
  return fpga_write(0xF8u, 0x10000);
}

//----- (000E7B30) --------------------------------------------------------
int get_crc_count()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0xF8u, &v1);
  return (unsigned __int16)v1;
}

//----- (000E7B4C) --------------------------------------------------------
int __fastcall reset_crc_count(char a1)
{
  if ( a1 )
    return fpga_write(0xF8u, 0x80000000);
  else
    return fpga_write(0xF8u, 0);
}

//----- (000E7B78) --------------------------------------------------------
int get_hash_on_plug()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(8u, &v1);
  return v1;
}

//----- (000E7B94) --------------------------------------------------------
int get_nonce_number_in_fifo()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x18u, &v1);
  return v1;
}

//----- (000E7BB0) --------------------------------------------------------
int __fastcall get_return_nonce(_DWORD *a1)
{
  int result; // r0
  int v3; // [sp+8h] [bp+8h] BYREF
  int v4; // [sp+Ch] [bp+Ch] BYREF

  fpga_read(0x10u, &v4);
  result = fpga_read(0x14u, &v3);
  *a1 = v4;
  a1[1] = v3;
  return result;
}

//----- (000E7BE8) --------------------------------------------------------
int __fastcall get_return_nonce_128bit(_DWORD *a1)
{
  int result; // r0
  int v3; // [sp+8h] [bp+8h] BYREF
  int v4; // [sp+Ch] [bp+Ch] BYREF
  int v5; // [sp+10h] [bp+10h] BYREF
  int v6; // [sp+14h] [bp+14h] BYREF

  v6 = 0;
  v5 = 0;
  v4 = 0;
  v3 = 0;
  fpga_read(0x10u, &v6);
  fpga_read(0x14u, &v5);
  fpga_read(0x10u, &v4);
  result = fpga_read(0x14u, &v3);
  *a1 = v6;
  a1[1] = v5;
  a1[2] = v4;
  a1[3] = v3;
  return result;
}

//----- (000E7C58) --------------------------------------------------------
int get_ticket_mask()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x8Cu, &v1);
  return v1;
}

//----- (000E7C74) --------------------------------------------------------
int __fastcall set_ticket_mask(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x8Cu, a1);
  return fpga_read(0x8Cu, &v2);
}

//----- (000E7C98) --------------------------------------------------------
int get_job_id()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x124u, &v1);
  return v1;
}

//----- (000E7CB4) --------------------------------------------------------
int __fastcall set_job_id(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x124u, a1);
  return fpga_read(0x124u, &v2);
}

//----- (000E7CDC) --------------------------------------------------------
int get_job_length()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x11Cu, &v1);
  return v1;
}

//----- (000E7CF8) --------------------------------------------------------
int __fastcall set_job_length(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x11Cu, a1);
  return fpga_read(0x11Cu, &v2);
}

//----- (000E7D20) --------------------------------------------------------
int get_work_fifo_state()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0xCu, &v1);
  return v1;
}

//----- (000E7D3C) --------------------------------------------------------
int get_block_header_version()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x130u, &v1);
  return v1;
}

//----- (000E7D58) --------------------------------------------------------
int __fastcall set_block_header_version(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x130u, a1);
  return fpga_read(0x130u, &v2);
}

//----- (000E7D80) --------------------------------------------------------
int get_block_header_version_1()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x164u, &v1);
  return v1;
}

//----- (000E7D9C) --------------------------------------------------------
int get_block_header_version_2()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x168u, &v1);
  return v1;
}

//----- (000E7DB8) --------------------------------------------------------
int get_block_header_version_3()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x16Cu, &v1);
  return v1;
}

//----- (000E7DD4) --------------------------------------------------------
int __fastcall set_block_header_version_1(int a1)
{
  return fpga_write(0x164u, a1);
}

//----- (000E7DF0) --------------------------------------------------------
int __fastcall set_block_header_version_2(int a1)
{
  return fpga_write(0x168u, a1);
}

//----- (000E7E0C) --------------------------------------------------------
int __fastcall set_block_header_version_3(int a1)
{
  return fpga_write(0x16Cu, a1);
}

//----- (000E7E28) --------------------------------------------------------
int __fastcall set_block_header_version_4(int a1)
{
  return fpga_write(0x470u, a1);
}

//----- (000E7E44) --------------------------------------------------------
int __fastcall set_block_header_version_5(int a1)
{
  return fpga_write(0x474u, a1);
}

//----- (000E7E60) --------------------------------------------------------
int __fastcall set_block_header_version_6(int a1)
{
  return fpga_write(0x478u, a1);
}

//----- (000E7E7C) --------------------------------------------------------
int __fastcall set_block_header_version_7(int a1)
{
  return fpga_write(0x47Cu, a1);
}

//----- (000E7E98) --------------------------------------------------------
int get_time_stamp()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x134u, &v1);
  return v1;
}

//----- (000E7EB4) --------------------------------------------------------
int __fastcall set_time_stamp(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x134u, a1);
  return fpga_read(0x134u, &v2);
}

//----- (000E7EDC) --------------------------------------------------------
int get_target_bits()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x138u, &v1);
  return v1;
}

//----- (000E7EF8) --------------------------------------------------------
int __fastcall set_target_bits(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x138u, a1);
  return fpga_read(0x138u, &v2);
}

//----- (000E7F20) --------------------------------------------------------
int __fastcall set_pre_header_hash(int result)
{
  int v1; // [sp+4h] [bp+4h]
  int i; // [sp+Ch] [bp+Ch]

  v1 = result;
  for ( i = 0; i <= 7; ++i )
    result = fpga_write(4 * (i + 80), *(_DWORD *)(4 * i + v1));
  return result;
}

//----- (000E7F5C) --------------------------------------------------------
int __fastcall set_coinbase_length_and_nonce2_length(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x104u, a1);
  return fpga_read(0x104u, &v2);
}

//----- (000E7F84) --------------------------------------------------------
int __fastcall set_work_nonce2(int *a1)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x108u, *a1);
  fpga_write(0x10Cu, a1[1]);
  fpga_read(0x108u, &v3);
  return fpga_read(0x10Cu, &v3);
}

//----- (000E7FD0) --------------------------------------------------------
int __fastcall set_merkle_bin_number(unsigned __int16 a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x114u, a1);
  return fpga_read(0x114u, &v2);
}

//----- (000E7FFC) --------------------------------------------------------
int get_nonce_fifo_interrupt()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x1Cu, &v1);
  return v1;
}

//----- (000E8018) --------------------------------------------------------
int __fastcall set_nonce_fifo_interrupt(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x1Cu, a1);
  return fpga_read(0x1Cu, &v2);
}

//----- (000E803C) --------------------------------------------------------
int __fastcall sub_E803C(int *a1)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0xC4u, *a1);
  fpga_write(0xC8u, a1[1]);
  fpga_write(0xCCu, a1[2]);
  fpga_read(0xC4u, &v3);
  fpga_read(0xC8u, &v3);
  return fpga_read(0xCCu, &v3);
}

//----- (000E8098) --------------------------------------------------------
int sub_E8098()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0xC0u, &v1);
  return v1;
}

//----- (000E80B4) --------------------------------------------------------
int __fastcall sub_E80B4(int a1)
{
  int result; // r0
  char v3[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v4; // [sp+81Ch] [bp+80Ch] BYREF
  int v5; // [sp+181Ch] [bp+180Ch]

  v5 = 0;
  fpga_write(0xC0u, a1);
  if ( a1 >= 0 )
    return sub_E8098();
  while ( 1 )
  {
    result = sub_E8098();
    if ( result >= 0 )
      break;
    usleep(0x3E8u);
    if ( (unsigned int)++v5 > 0xBB8 )
    {
      strcpy(v3, "Error: set_BC_write_command timeout!\n");
      V_LOCK();
      logfmt_raw(&v4, 0x1000u, 0, v3);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
               96,
               "set_BC_write_command",
               20,
               782,
               100,
               &v4);
    }
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E81B4) --------------------------------------------------------
int set_BC_nullen_all_chain()
{
  pthread_mutex_lock(&bc_cmd_acc_mutex);
  sub_E8098();
  return pthread_mutex_unlock(&bc_cmd_acc_mutex);
}
// 47B398: using guessed type pthread_mutex_t bc_cmd_acc_mutex;

//----- (000E81FC) --------------------------------------------------------
int __fastcall set_BC_baud(char a1)
{
  unsigned int v3; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&bc_cmd_acc_mutex);
  usleep(0xC350u);
  v3 = a1 & 0x3F | sub_E8098() & 0xFFFFFFC0;
  sub_E80B4(v3);
  return pthread_mutex_unlock(&bc_cmd_acc_mutex);
}
// 47B398: using guessed type pthread_mutex_t bc_cmd_acc_mutex;

//----- (000E8248) --------------------------------------------------------
int __fastcall set_BC_nullen(int a1, char a2)
{
  unsigned int v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&bc_cmd_acc_mutex);
  v5 = sub_E8098() & 0xFFF0FFFF | (a1 << 16) | 0x800000;
  if ( a2 )
    v6 = v5 | 0x400000;
  else
    v6 = v5 & 0xFFBFFFFF;
  sub_E80B4(v6);
  return pthread_mutex_unlock(&bc_cmd_acc_mutex);
}
// 47B398: using guessed type pthread_mutex_t bc_cmd_acc_mutex;

//----- (000E82AC) --------------------------------------------------------
int __fastcall send_BC_command(int *a1, int a2)
{
  unsigned int v5; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&bc_cmd_acc_mutex);
  sub_E803C(a1);
  v5 = sub_E8098() & 0xFFF0FFFF | (a2 << 16) | 0x80800000;
  sub_E80B4(v5);
  return pthread_mutex_unlock(&bc_cmd_acc_mutex);
}
// 47B398: using guessed type pthread_mutex_t bc_cmd_acc_mutex;

//----- (000E8300) --------------------------------------------------------
int __fastcall set_TW_write_command(int result)
{
  int v1; // [sp+4h] [bp+4h]
  unsigned int i; // [sp+Ch] [bp+Ch]

  v1 = result;
  for ( i = 0; i <= 0xC; ++i )
    result = fpga_write(4 * (i + 16), *(_DWORD *)(4 * i + v1));
  return result;
}

//----- (000E8338) --------------------------------------------------------
int __fastcall set_TW_write_command_vil(int *a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&tw_cmd_acc_mutex);
  for ( i = 0; i <= 0xC; ++i )
  {
    if ( i )
      fpga_write(0x44u, a1[i]);
    else
      fpga_write(0x40u, *a1);
  }
  return pthread_mutex_unlock(&tw_cmd_acc_mutex);
}
// 47B380: using guessed type pthread_mutex_t tw_cmd_acc_mutex;

//----- (000E8398) --------------------------------------------------------
int __fastcall set_TW_write_command_chunk0(int *a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&tw_cmd_acc_mutex);
  for ( i = 0; i < 0x15; ++i )
  {
    if ( i )
      fpga_write(0x44u, a1[i]);
    else
      fpga_write(0x40u, *a1);
  }
  return pthread_mutex_unlock(&tw_cmd_acc_mutex);
}
// 47B380: using guessed type pthread_mutex_t tw_cmd_acc_mutex;

//----- (000E8400) --------------------------------------------------------
int __fastcall set_TW_write_command_x_midstate(int *a1, int a2)
{
  unsigned int v4; // [sp+8h] [bp+8h]
  unsigned int i; // [sp+Ch] [bp+Ch]

  v4 = 32 * (a2 - 1) + 52;
  pthread_mutex_lock(&tw_cmd_acc_mutex);
  for ( i = 0; v4 >> 2 > i; ++i )
  {
    if ( i )
      fpga_write(0x44u, a1[i]);
    else
      fpga_write(0x40u, *a1);
  }
  return pthread_mutex_unlock(&tw_cmd_acc_mutex);
}
// 47B380: using guessed type pthread_mutex_t tw_cmd_acc_mutex;

//----- (000E8470) --------------------------------------------------------
int get_QN_write_data_command()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  fpga_read(0x80u, &v1);
  return v1;
}

//----- (000E848C) --------------------------------------------------------
int __fastcall set_QN_write_data_command(int a1)
{
  int v2; // [sp+Ch] [bp+Ch] BYREF

  fpga_write(0x80u, a1);
  return fpga_read(0x80u, &v2);
}

//----- (000E84B0) --------------------------------------------------------
int get_temperature_0_3()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0x20u, &v4);
    return v4;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "get_temperature_0_3",
      19,
      941,
      100,
      &v3);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E8574) --------------------------------------------------------
int get_temperature_4_7()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0x24u, &v4);
    return v4;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "get_temperature_4_7",
      19,
      956,
      100,
      &v3);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E8638) --------------------------------------------------------
int get_temperature_8_11()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0x28u, &v4);
    return v4;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "get_temperature_8_11",
      20,
      971,
      100,
      &v3);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E86FC) --------------------------------------------------------
int get_temperature_12_15()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0x2Cu, &v4);
    return v4;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "get_temperature_12_15",
      21,
      986,
      100,
      &v3);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E87C0) --------------------------------------------------------
int __fastcall set_fan_control(int a1)
{
  char v2[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v3; // [sp+81Ch] [bp+80Ch] BYREF
  int v4; // [sp+181Ch] [bp+180Ch] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_write(0x84u, a1);
    return fpga_read(0x84u, &v4);
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
             96,
             "set_fan_control",
             15,
             1001,
             100,
             &v3);
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E8888) --------------------------------------------------------
int __fastcall set_fan_control_1(int a1)
{
  char v2[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v3; // [sp+81Ch] [bp+80Ch] BYREF
  int v4; // [sp+181Ch] [bp+180Ch] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_write(0xA0u, a1);
    return fpga_read(0xA0u, &v4);
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
             96,
             "set_fan_control_1",
             17,
             1015,
             100,
             &v3);
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E8950) --------------------------------------------------------
int get_bt8d_control()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    fpga_read(0x3Cu, &v4);
    return v4;
  }
  else
  {
    strcpy(v2, "platform not inited\n");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
      96,
      "get_bt8d_control",
      16,
      1029,
      100,
      &v3);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E8A14) --------------------------------------------------------
int __fastcall set_bt8d_control(int a1)
{
  char v2[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v3[4096]; // [sp+818h] [bp+808h] BYREF

  if ( platform_inited )
    return fpga_write(0x3Cu, a1);
  strcpy(v2, "platform not inited\n");
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, v2);
  V_UNLOCK();
  return zlog(
           g_zc,
           "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_common.c",
           96,
           "set_bt8d_control",
           16,
           1042,
           100,
           v3);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E8ABC) --------------------------------------------------------
int __fastcall lcd_init(const char *a1)
{
  const char *v3; // [sp+14h] [bp+4h]
  char v4[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[4096]; // [sp+818h] [bp+808h] BYREF

  v3 = a1;
  if ( dword_47B4D8 )
    return 0;
  if ( v3 )
  {
    dword_47B4D4 = open(v3, 2050);
    if ( dword_47B4D4 >= 0 )
    {
      dword_47B4D8 = 1;
      return dword_47B4D4;
    }
    else
    {
      strcpy(v4, "open lcd failed!!!\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_lcd.c",
        93,
        "lcd_init",
        8,
        41,
        100,
        v5);
      return -1;
    }
  }
  else
  {
    strcpy(v4, "bad param\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_lcd.c",
      93,
      "lcd_init",
      8,
      35,
      100,
      v5);
    return -3;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B4D4: using guessed type int dword_47B4D4;
// 47B4D8: using guessed type int dword_47B4D8;
// 47BE18: using guessed type int g_zc;

//----- (000E8C0C) --------------------------------------------------------
int __fastcall lcd_write(int a1, unsigned __int8 a2, int a3, unsigned int a4)
{
  size_t v5; // r3
  int v6; // r2
  unsigned int v8; // [sp+10h] [bp+0h]
  unsigned __int8 v10; // [sp+1Bh] [bp+Bh]
  char v11[2048]; // [sp+20h] [bp+10h] BYREF
  _BYTE v12[8]; // [sp+820h] [bp+810h] BYREF
  size_t v13; // [sp+1820h] [bp+1810h]
  int v14; // [sp+1824h] [bp+1814h]

  v8 = a4;
  v10 = a2;
  v14 = 0;
  if ( !dword_47B4D8 )
    return -2;
  if ( a1 == dword_47B4D4 && a2 <= 3u && a4 <= 0x40 )
  {
    if ( pthread_mutex_lock(&stru_47B4DC) )
    {
      strcpy(v11, "failed to lcd lock\n");
      V_LOCK();
      logfmt_raw(v12, 0x1000u, 0, v11);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_lcd.c",
        93,
        "lcd_write",
        9,
        75,
        100,
        v12);
      return -4;
    }
    else
    {
      do
      {
        v5 = v8;
        if ( v8 >= 0x10 )
          v5 = 16;
        v13 = v5;
        v6 = (char)v10++;
        memcpy((char *)&unk_47B4F4 + 16 * v6, (const void *)(a3 + v14), v5);
        v14 += v13;
        v8 -= v13;
      }
      while ( v8 && v10 <= 3u );
      write(dword_47B4D4, &unk_47B4F4, 0x40u);
      pthread_mutex_unlock(&stru_47B4DC);
      return 0;
    }
  }
  else
  {
    strcpy(v11, "bad param\n");
    V_LOCK();
    logfmt_raw(v12, 0x1000u, 0, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_lcd.c",
      93,
      "lcd_write",
      9,
      69,
      80,
      v12);
    return -3;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B4D4: using guessed type int dword_47B4D4;
// 47B4D8: using guessed type int dword_47B4D8;
// 47B4DC: using guessed type pthread_mutex_t stru_47B4DC;
// 47BE18: using guessed type int g_zc;

//----- (000E8E68) --------------------------------------------------------
int lcd_flush()
{
  return 0;
}

//----- (000E8E80) --------------------------------------------------------
int __fastcall lcd_clear(int a1)
{
  char v3[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4096]; // [sp+818h] [bp+808h] BYREF

  if ( !dword_47B4D8 )
    return -2;
  if ( a1 == dword_47B4D4 )
  {
    if ( pthread_mutex_lock(&stru_47B4DC) )
    {
      strcpy(v3, "failed to lcd lock\n");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_lcd.c",
        93,
        "lcd_clear",
        9,
        123,
        100,
        v4);
      return -4;
    }
    else
    {
      memset(&unk_47B4F4, 32, 0x40u);
      lseek(dword_47B4D4, 0, 0);
      write(dword_47B4D4, &unk_47B4F4, 0x40u);
      pthread_mutex_unlock(&stru_47B4DC);
      return 0;
    }
  }
  else
  {
    strcpy(v3, "bad param\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_lcd.c",
      93,
      "lcd_clear",
      9,
      117,
      80,
      v4);
    return -3;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B4D4: using guessed type int dword_47B4D4;
// 47B4D8: using guessed type int dword_47B4D8;
// 47B4DC: using guessed type pthread_mutex_t stru_47B4DC;
// 47BE18: using guessed type int g_zc;

//----- (000E8FFC) --------------------------------------------------------
int __fastcall lcd_uninit(int a1)
{
  char v2[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v3; // [sp+81Ch] [bp+80Ch] BYREF
  int v4; // [sp+181Ch] [bp+180Ch]

  v4 = 0;
  if ( dword_47B4D8 )
  {
    if ( close(a1) )
    {
      strcpy(v2, "lcd close failed!!!\n");
      V_LOCK();
      logfmt_raw(&v3, 0x1000u, 0, v2);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_lcd.c",
        93,
        "lcd_uninit",
        10,
        147,
        100,
        &v3);
      v4 = -1;
    }
    dword_47B4D8 = 0;
  }
  return v4;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B4D8: using guessed type int dword_47B4D8;
// 47BE18: using guessed type int g_zc;

//----- (000E90DC) --------------------------------------------------------
int __fastcall pwm_init(unsigned int a1, int a2)
{
  char v4[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[4096]; // [sp+818h] [bp+808h] BYREF

  if ( platform_inited )
  {
    if ( a1 <= 1 )
    {
      *((_DWORD *)&unk_47B534 + 2 * a1) = a2;
      *((_BYTE *)&unk_47B534 + 8 * a1 + 4) = 1;
      return a1 + 1;
    }
    else
    {
      strcpy(v4, "bad param\n");
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_pwm.c",
        93,
        "pwm_init",
        8,
        30,
        100,
        v5);
      return -3;
    }
  }
  else
  {
    strcpy(v4, "please init platform first!!\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_pwm.c",
      93,
      "pwm_init",
      8,
      25,
      100,
      v5);
    return -2;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000E9234) --------------------------------------------------------
int __fastcall pwm_uninit(int result)
{
  char v1[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v2[4096]; // [sp+818h] [bp+808h] BYREF

  if ( result - 1 <= 1 )
  {
    dword_47B534[2 * result - 2] = 0;
    LOBYTE(dword_47B534[2 * result - 1]) = 0;
  }
  else
  {
    strcpy(v1, "bad param\n");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_pwm.c",
             93,
             "pwm_uninit",
             10,
             41,
             100,
             v2);
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B534: using guessed type _DWORD dword_47B534[4];
// 47BE18: using guessed type int g_zc;

//----- (000E92F8) --------------------------------------------------------
int __fastcall pwm_set(int a1, unsigned int a2)
{
  int v3; // r2
  char v5[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v6[8]; // [sp+818h] [bp+808h] BYREF
  int v7; // [sp+1818h] [bp+1808h]
  unsigned __int16 v8; // [sp+181Ch] [bp+180Ch]
  unsigned __int16 v9; // [sp+181Eh] [bp+180Eh]

  if ( a1 - 1 <= 1 )
  {
    v3 = a2;
    if ( a2 >= 0x64 )
      v3 = 100;
    v9 = v3 * dword_47B534[2 * a1 - 2] / 0x64u;
    v8 = dword_47B534[2 * a1 - 2] * (100 - v3) / 0x64u;
    v7 = v8 | (v9 << 16);
    if ( a1 == 1 )
    {
      fpga_write(0x84u, v7);
      fpga_write(0xA0u, v7);
    }
    else
    {
      snprintf(v5, 0x800u, "pwm type %d not supported\n", a1 - 1);
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_pwm.c",
        93,
        "pwm_set",
        7,
        81,
        100,
        v6);
    }
    return 0;
  }
  else
  {
    strcpy(v5, "bad param\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_pwm.c",
      93,
      "pwm_set",
      7,
      62,
      100,
      v6);
    return -3;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B534: using guessed type _DWORD dword_47B534[4];
// 47BE18: using guessed type int g_zc;

//----- (000E94F4) --------------------------------------------------------
int __fastcall pwm_get(int a1, _DWORD *a2)
{
  char v5[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v6; // [sp+81Ch] [bp+80Ch] BYREF
  int v7; // [sp+181Ch] [bp+180Ch]

  v7 = -5;
  if ( a1 - 1 <= 1 )
  {
    if ( a1 == 1 )
    {
      fpga_read(0x84u, a2);
      *a2 >>= 16;
      snprintf(v5, 0x800u, "duty of fpga = 0x%x\n", *a2);
      V_LOCK();
      logfmt_raw(&v6, 0x1000u, 0, v5);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_pwm.c",
        93,
        "pwm_get",
        7,
        109,
        20,
        &v6);
      return 0;
    }
    return v7;
  }
  else
  {
    strcpy(v5, "bad param\n");
    V_LOCK();
    logfmt_raw(&v6, 0x1000u, 0, v5);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_pwm.c",
      93,
      "pwm_get",
      7,
      101,
      100,
      &v6);
    return -3;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000E9684) --------------------------------------------------------
int i2c_init()
{
  char v2[2048]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v3[12]; // [sp+81Ch] [bp+80Ch] BYREF
  _DWORD v4[2]; // [sp+181Ch] [bp+180Ch] BYREF
  int v5; // [sp+1824h] [bp+1814h] BYREF

  v5 = -1;
  if ( platform_inited )
  {
    if ( !dword_47B560 )
    {
      dword_47B55C = (int)new_c_map(956005, 0, 0);
      pthread_mutex_init(&stru_47B544, 0);
    }
    v5 = ++dword_47B560;
    v4[0] = 0;
    v4[1] = 0;
    insert_c_map((int *)dword_47B55C, &v5, 4u, v4, 8u);
    return v5;
  }
  else
  {
    strcpy(v2, "please init platform first!!\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
      93,
      "i2c_init",
      8,
      38,
      100,
      v3);
    return -2;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47B544: using guessed type pthread_mutex_t stru_47B544;
// 47B55C: using guessed type int dword_47B55C;
// 47B560: using guessed type int dword_47B560;
// 47BE18: using guessed type int g_zc;

//----- (000E97E0) --------------------------------------------------------
int __fastcall i2c_uninit(int a1)
{
  int result; // r0
  _DWORD v2[2]; // [sp+14h] [bp+4h] BYREF
  char v3[2048]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v4[12]; // [sp+81Ch] [bp+80Ch] BYREF
  _DWORD *v5; // [sp+181Ch] [bp+180Ch]
  int i; // [sp+1820h] [bp+1810h]
  int v7; // [sp+1824h] [bp+1814h]

  v2[0] = a1;
  v7 = 0;
  if ( pthread_mutex_lock(&stru_47B544) )
  {
    strcpy(v3, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
             93,
             "i2c_uninit",
             10,
             59,
             100,
             v4);
  }
  else
  {
    if ( exists_c_map((int *)dword_47B55C, (int)v2) )
    {
      snprintf(v3, 0x800u, "remove %d from callback list\n", v2[0]);
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
        93,
        "i2c_uninit",
        10,
        63,
        20,
        v4);
      remove_c_map((int *)dword_47B55C, (int)v2);
    }
    else
    {
      snprintf(v3, 0x800u, "ctx(%d) is not inited\n", v2[0]);
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
        93,
        "i2c_uninit",
        10,
        66,
        80,
        v4);
    }
    v5 = new_iterator_c_map(dword_47B55C);
    for ( i = ((int (__fastcall *)(_DWORD *))*v5)(v5); i; i = ((int (__fastcall *)(_DWORD *))*v5)(v5) )
      ++v7;
    delete_iterator_c_map(v5);
    pthread_mutex_unlock(&stru_47B544);
    if ( v7 )
    {
      snprintf(v3, 0x800u, "still have %d nodes\n", v7);
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      return zlog(
               g_zc,
               "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
               93,
               "i2c_uninit",
               10,
               82,
               20,
               v4);
    }
    else
    {
      strcpy(v3, "all i2c uninited\n");
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
        93,
        "i2c_uninit",
        10,
        77,
        20,
        v4);
      dword_47B560 = 0;
      result = delete_c_map((void ***)dword_47B55C);
      dword_47B55C = 0;
    }
  }
  return result;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B544: using guessed type pthread_mutex_t stru_47B544;
// 47B55C: using guessed type int dword_47B55C;
// 47B560: using guessed type int dword_47B560;
// 47BE18: using guessed type int g_zc;

//----- (000E9B58) --------------------------------------------------------
int sub_E9B58()
{
  unsigned int v1; // r3
  unsigned int v3; // [sp+0h] [bp+0h] BYREF
  unsigned int v4; // [sp+4h] [bp+4h]

  v3 = 0;
  v4 = 0;
  do
  {
    fpga_read(0x30u, &v3);
    if ( v3 >> 31 == 1 )
      return 1;
    usleep(0x1388u);
    v1 = v4++;
  }
  while ( v1 < 0x258 );
  return 0;
}

//----- (000E9B9C) --------------------------------------------------------
int __fastcall sub_E9B9C(_BYTE *a1)
{
  unsigned int v2; // r3
  unsigned int v5; // [sp+8h] [bp+8h] BYREF
  unsigned int v6; // [sp+Ch] [bp+Ch]

  v5 = 0;
  v6 = 0;
  do
  {
    fpga_read(0x30u, &v5);
    if ( v5 >> 31 == 1 )
    {
      *a1 = v5;
      return 1;
    }
    usleep(0x1388u);
    v2 = v6++;
  }
  while ( v2 < 0x258 );
  return 0;
}

//----- (000E9BEC) --------------------------------------------------------
int __fastcall i2c_read(int a1, int a2, unsigned int a3)
{
  int v7; // [sp+1Ch] [bp+Ch] BYREF
  char v8[2048]; // [sp+20h] [bp+10h] BYREF
  _BYTE v9[16]; // [sp+820h] [bp+810h] BYREF
  _DWORD *v10; // [sp+1820h] [bp+1810h] BYREF
  _DWORD *v11; // [sp+1824h] [bp+1814h]
  int v12; // [sp+1828h] [bp+1818h]
  unsigned int i; // [sp+182Ch] [bp+181Ch]

  v7 = a1;
  i = 0;
  if ( pthread_mutex_lock(&stru_47B544) )
  {
    strcpy(v8, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
      93,
      "i2c_read",
      8,
      127,
      100,
      v9);
    return -1;
  }
  else
  {
    v12 = 0;
    v10 = 0;
    if ( find_c_map((int *)dword_47B55C, (int)&v7, (void **)&v10) == 1 )
    {
      v11 = v10;
      snprintf(v8, 0x800u, "i2c read master = %d, slave = %d\n", *v10, v10[1]);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
        93,
        "i2c_read",
        8,
        134,
        20,
        v9);
      v12 = (((v11[1] >> 1) & 7) << 16) | (*v11 << 26) | (v11[1] >> 4 << 20) | 0x2000000;
      for ( i = 0; i < a3; ++i )
      {
        if ( !sub_E9B58() )
        {
          free(v10);
          strcpy(v8, "iic not ready 4 read1\n");
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, v8);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
            93,
            "i2c_read",
            8,
            141,
            100,
            v9);
          pthread_mutex_unlock(&stru_47B544);
          return -2;
        }
        fpga_write(0x30u, v12);
        if ( !sub_E9B9C((_BYTE *)(i + a2)) )
        {
          free(v10);
          strcpy(v8, "iic not ready 4 read2\n");
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, v8);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
            93,
            "i2c_read",
            8,
            152,
            100,
            v9);
          pthread_mutex_unlock(&stru_47B544);
          return -3;
        }
      }
      free(v10);
      pthread_mutex_unlock(&stru_47B544);
      return a3;
    }
    else
    {
      snprintf(v8, 0x800u, "ctx %d not inited\n", v7);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
        93,
        "i2c_read",
        8,
        159,
        100,
        v9);
      pthread_mutex_unlock(&stru_47B544);
      return -2;
    }
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B544: using guessed type pthread_mutex_t stru_47B544;
// 47B55C: using guessed type int dword_47B55C;
// 47BE18: using guessed type int g_zc;

//----- (000EA014) --------------------------------------------------------
int __fastcall i2c_write(int a1, int a2, unsigned int a3)
{
  int v7; // [sp+1Ch] [bp+Ch] BYREF
  char v8[2048]; // [sp+20h] [bp+10h] BYREF
  _BYTE v9[16]; // [sp+820h] [bp+810h] BYREF
  _DWORD *v10; // [sp+1820h] [bp+1810h] BYREF
  _DWORD *v11; // [sp+1824h] [bp+1814h]
  int v12; // [sp+1828h] [bp+1818h]
  unsigned int i; // [sp+182Ch] [bp+181Ch]

  v7 = a1;
  i = 0;
  if ( pthread_mutex_lock(&stru_47B544) )
  {
    strcpy(v8, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
      93,
      "i2c_write",
      9,
      180,
      100,
      v9);
    return -1;
  }
  else
  {
    v12 = 0;
    v10 = 0;
    if ( find_c_map((int *)dword_47B55C, (int)&v7, (void **)&v10) == 1 )
    {
      v11 = v10;
      snprintf(v8, 0x800u, "i2c read master = %d, slave = %d\n", *v10, v10[1]);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
        93,
        "i2c_write",
        9,
        187,
        20,
        v9);
      for ( i = 0; i < a3; ++i )
      {
        v12 = *(unsigned __int8 *)(i + a2) | (*v11 << 26) | (v11[1] >> 4 << 20) | (((v11[1] >> 1) & 7) << 16);
        if ( !sub_E9B58() )
        {
          free(v10);
          strcpy(v8, "iic not ready 4 write\n");
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, v8);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
            93,
            "i2c_write",
            9,
            194,
            100,
            v9);
          pthread_mutex_unlock(&stru_47B544);
          return -2;
        }
        fpga_write(0x30u, v12);
      }
      free(v10);
      pthread_mutex_unlock(&stru_47B544);
      return a3;
    }
    else
    {
      snprintf(v8, 0x800u, "ctx %d not inited\n", v7);
      V_LOCK();
      logfmt_raw(v9, 0x1000u, 0, v8);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
        93,
        "i2c_write",
        9,
        203,
        100,
        v9);
      pthread_mutex_unlock(&stru_47B544);
      return -2;
    }
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B544: using guessed type pthread_mutex_t stru_47B544;
// 47B55C: using guessed type int dword_47B55C;
// 47BE18: using guessed type int g_zc;

//----- (000EA394) --------------------------------------------------------
int __fastcall i2c_read_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  char v10[2048]; // [sp+20h] [bp+10h] BYREF
  _BYTE v11[16]; // [sp+820h] [bp+810h] BYREF
  _DWORD *v12; // [sp+1820h] [bp+1810h] BYREF
  _DWORD *v13; // [sp+1824h] [bp+1814h]
  unsigned int v14; // [sp+1828h] [bp+1818h]
  unsigned int i; // [sp+182Ch] [bp+181Ch]

  v9 = a1;
  i = 0;
  if ( a3 == 1 )
  {
    if ( pthread_mutex_lock(&stru_47B544) )
    {
      strcpy(v10, "failed to i2c lock\n");
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
        93,
        "i2c_read_reg",
        12,
        229,
        100,
        v11);
      return -1;
    }
    else
    {
      v14 = 0;
      v12 = 0;
      if ( find_c_map((int *)dword_47B55C, (int)&v9, (void **)&v12) == 1 )
      {
        v13 = v12;
        snprintf(v10, 0x800u, "i2c read master = %d, slave = %d\n", *v12, v12[1]);
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
          93,
          "i2c_read_reg",
          12,
          236,
          20,
          v11);
        for ( i = 0; i < a5; ++i )
        {
          v14 = ((i + *a2) << 8) | (*v13 << 26) | (v13[1] >> 4 << 20) | (((v13[1] >> 1) & 7) << 16) | 0x3000000;
          if ( !sub_E9B58() )
          {
            strcpy(v10, "iic not ready 4 read1\n");
            V_LOCK();
            logfmt_raw(v11, 0x1000u, 0, v10);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
              93,
              "i2c_read_reg",
              12,
              243,
              100,
              v11);
            free(v12);
            pthread_mutex_unlock(&stru_47B544);
            return -2;
          }
          fpga_write(0x30u, v14);
          if ( !sub_E9B9C((_BYTE *)(i + a4)) )
          {
            strcpy(v10, "iic failed to read data\n");
            V_LOCK();
            logfmt_raw(v11, 0x1000u, 0, v10);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
              93,
              "i2c_read_reg",
              12,
              254,
              100,
              v11);
            free(v12);
            pthread_mutex_unlock(&stru_47B544);
            return -3;
          }
        }
        free(v12);
        pthread_mutex_unlock(&stru_47B544);
        return a5;
      }
      else
      {
        snprintf(v10, 0x800u, "ctx %d not inited\n", v9);
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
          93,
          "i2c_read_reg",
          12,
          262,
          100,
          v11);
        pthread_mutex_unlock(&stru_47B544);
        return -2;
      }
    }
  }
  else
  {
    strcpy(v10, "more than one byte reg address is not supported\n");
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
      93,
      "i2c_read_reg",
      12,
      225,
      100,
      v11);
    return -3;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B544: using guessed type pthread_mutex_t stru_47B544;
// 47B55C: using guessed type int dword_47B55C;
// 47BE18: using guessed type int g_zc;

//----- (000EA85C) --------------------------------------------------------
int __fastcall i2c_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  int v9; // [sp+1Ch] [bp+Ch] BYREF
  char v10[2048]; // [sp+20h] [bp+10h] BYREF
  _BYTE v11[16]; // [sp+820h] [bp+810h] BYREF
  _DWORD *v12; // [sp+1820h] [bp+1810h] BYREF
  _DWORD *v13; // [sp+1824h] [bp+1814h]
  unsigned int v14; // [sp+1828h] [bp+1818h]
  unsigned int i; // [sp+182Ch] [bp+181Ch]

  v9 = a1;
  i = 0;
  if ( a3 == 1 )
  {
    if ( pthread_mutex_lock(&stru_47B544) )
    {
      strcpy(v10, "failed to i2c lock\n");
      V_LOCK();
      logfmt_raw(v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
        93,
        "i2c_write_reg",
        13,
        288,
        100,
        v11);
      return -1;
    }
    else
    {
      v14 = 0;
      v12 = 0;
      if ( find_c_map((int *)dword_47B55C, (int)&v9, (void **)&v12) == 1 )
      {
        v13 = v12;
        snprintf(v10, 0x800u, "i2c read master = %d, slave = %d\n", *v12, v12[1]);
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
          93,
          "i2c_write_reg",
          13,
          295,
          20,
          v11);
        for ( i = 0; i < a5; ++i )
        {
          v14 = ((i + *a2) << 8)
              | (*v13 << 26)
              | (v13[1] >> 4 << 20)
              | (((v13[1] >> 1) & 7) << 16)
              | *(unsigned __int8 *)(i + a4)
              | 0x1000000;
          if ( !sub_E9B58() )
          {
            strcpy(v10, "iic not ready 4 write\n");
            V_LOCK();
            logfmt_raw(v11, 0x1000u, 0, v10);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
              93,
              "i2c_write_reg",
              13,
              303,
              100,
              v11);
            free(v12);
            pthread_mutex_unlock(&stru_47B544);
            return -2;
          }
          fpga_write(0x30u, v14);
        }
        free(v12);
        pthread_mutex_unlock(&stru_47B544);
        return a5;
      }
      else
      {
        snprintf(v10, 0x800u, "ctx %d not inited\n", v9);
        V_LOCK();
        logfmt_raw(v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
          93,
          "i2c_write_reg",
          13,
          313,
          100,
          v11);
        pthread_mutex_unlock(&stru_47B544);
        return -2;
      }
    }
  }
  else
  {
    strcpy(v10, "more than one byte reg address is not supported\n");
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
      93,
      "i2c_write_reg",
      13,
      284,
      100,
      v11);
    return -3;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B544: using guessed type pthread_mutex_t stru_47B544;
// 47B55C: using guessed type int dword_47B55C;
// 47BE18: using guessed type int g_zc;

//----- (000EAC90) --------------------------------------------------------
int __fastcall i2c_ioctl(int a1, __int16 a2, int a3)
{
  char v8[24]; // [sp+20h] [bp+10h] BYREF
  _BYTE v9[24]; // [sp+820h] [bp+810h] BYREF
  _DWORD v10[2]; // [sp+1820h] [bp+1810h] BYREF
  _DWORD *v11; // [sp+1828h] [bp+1818h]
  int v12; // [sp+182Ch] [bp+181Ch]
  _DWORD *v13; // [sp+1830h] [bp+1820h]
  int i; // [sp+1834h] [bp+1824h]

  if ( pthread_mutex_lock(&stru_47B544) )
  {
    strcpy(v8, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
      93,
      "i2c_ioctl",
      9,
      333,
      100,
      v9);
    return -4;
  }
  else
  {
    v13 = new_iterator_c_map(dword_47B55C);
    for ( i = ((int (__fastcall *)(_DWORD *))*v13)(v13); i; i = ((int (__fastcall *)(_DWORD *))*v13)(v13) )
    {
      v12 = v13[5];
      if ( ***(_DWORD ***)(v12 + 16) == a1 )
      {
        v11 = (_DWORD *)((int (__fastcall *)(int))v13[2])(i);
        if ( a2 == 1795 )
        {
          v10[0] = *v11;
          v10[1] = a3;
          ((void (__fastcall *)(_DWORD *, _DWORD *, int))v13[1])(v13, v10, 8);
          snprintf(v8, 0x800u, "update the slave address to %d\n", a3);
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, v8);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
            93,
            "i2c_ioctl",
            9,
            347,
            20,
            v9);
          free(v11);
        }
        break;
      }
    }
    delete_iterator_c_map(v13);
    pthread_mutex_unlock(&stru_47B544);
    return 0;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B544: using guessed type pthread_mutex_t stru_47B544;
// 47B55C: using guessed type int dword_47B55C;
// 47BE18: using guessed type int g_zc;

//----- (000EAEE0) --------------------------------------------------------
int __fastcall i2c_select(int a1, int a2)
{
  char v6[24]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[24]; // [sp+818h] [bp+808h] BYREF
  _DWORD v8[2]; // [sp+1818h] [bp+1808h] BYREF
  _DWORD *v9; // [sp+1820h] [bp+1810h]
  int v10; // [sp+1824h] [bp+1814h]
  _DWORD *v11; // [sp+1828h] [bp+1818h]
  int i; // [sp+182Ch] [bp+181Ch]

  if ( pthread_mutex_lock(&stru_47B544) )
  {
    strcpy(v6, "failed to i2c lock\n");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
      93,
      "i2c_select",
      10,
      366,
      100,
      v7);
    return -4;
  }
  else
  {
    v11 = new_iterator_c_map(dword_47B55C);
    for ( i = ((int (__fastcall *)(_DWORD *))*v11)(v11); i; i = ((int (__fastcall *)(_DWORD *))*v11)(v11) )
    {
      v10 = v11[5];
      if ( ***(_DWORD ***)(v10 + 16) == a1 )
      {
        v9 = (_DWORD *)((int (__fastcall *)(int))v11[2])(i);
        v8[0] = a2;
        v8[1] = v9[1];
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v11[1])(v11, v8, 8);
        snprintf(v6, 0x800u, "update the master address to %d\n", a2);
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_i2c.c",
          93,
          "i2c_select",
          10,
          377,
          20,
          v7);
        free(v9);
        break;
      }
    }
    delete_iterator_c_map(v11);
    pthread_mutex_unlock(&stru_47B544);
    return 0;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B544: using guessed type pthread_mutex_t stru_47B544;
// 47B55C: using guessed type int dword_47B55C;
// 47BE18: using guessed type int g_zc;

//----- (000EB14C) --------------------------------------------------------
int sub_EB14C()
{
  char v1[4]; // [sp+1Ch] [bp+Ch] BYREF
  int v2; // [sp+81Ch] [bp+80Ch] BYREF
  _DWORD v3[2]; // [sp+181Ch] [bp+180Ch] BYREF
  unsigned __int8 v4; // [sp+1827h] [bp+1817h] BYREF
  int v5; // [sp+1828h] [bp+1818h]
  void (__fastcall **v6)(int, _DWORD); // [sp+182Ch] [bp+181Ch]
  int v7; // [sp+1830h] [bp+1820h]
  _DWORD *v8; // [sp+1834h] [bp+1824h]
  int v9; // [sp+1838h] [bp+1828h]
  int i; // [sp+183Ch] [bp+182Ch]

  v9 = 0;
  while ( dword_47B568 )
  {
    if ( !pthread_mutex_lock(&stru_47B588) )
    {
      v8 = new_iterator_c_map(dword_47B5A0);
      for ( i = ((int (__fastcall *)(_DWORD *))*v8)(v8); i; i = ((int (__fastcall *)(_DWORD *))*v8)(v8) )
      {
        v7 = v8[5];
        v6 = (void (__fastcall **)(int, _DWORD))((int (__fastcall *)(int))v8[2])(i);
        v5 = ***(_DWORD ***)(v7 + 16);
        v4 = 0;
        v9 = gpio_read(v5, &v4);
        if ( v9 )
        {
          snprintf(v1, 0x800u, "failed to read gpio port %d\n", v5);
          V_LOCK();
          logfmt_raw(&v2, 0x1000u, 0, v1);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
            94,
            "gpio_thread_function",
            20,
            65,
            20,
            &v2);
          free(v6);
          break;
        }
        if ( v6[1] != (void (__fastcall *)(int, _DWORD))v4 )
        {
          snprintf(v1, 0x800u, "gpio port %d, last val = %d, new val = %d\n", ***(_DWORD ***)(v7 + 16), v6[1], v4);
          V_LOCK();
          logfmt_raw(&v2, 0x1000u, 0, v1);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
            94,
            "gpio_thread_function",
            20,
            72,
            20,
            &v2);
          (*v6)(v5, v4);
          v3[0] = *v6;
          v3[1] = v4;
          ((void (__fastcall *)(_DWORD *, _DWORD *, int))v8[1])(v8, v3, 8);
        }
        free(v6);
      }
      delete_iterator_c_map(v8);
      pthread_mutex_unlock(&stru_47B588);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// EB14C: using guessed type int sub_EB14C();
// 47B568: using guessed type int dword_47B568;
// 47B588: using guessed type pthread_mutex_t stru_47B588;
// 47B5A0: using guessed type int dword_47B5A0;
// 47BE18: using guessed type int g_zc;

//----- (000EB46C) --------------------------------------------------------
int gpio_init()
{
  char v1[2048]; // [sp+10h] [bp+0h] BYREF
  _BYTE v2[4100]; // [sp+810h] [bp+800h] BYREF

  if ( dword_47B564 )
  {
    strcpy(v1, "gpio re init\n");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
      94,
      "gpio_init",
      9,
      98,
      80,
      v2);
  }
  else
  {
    pthread_mutex_init(&stru_47B588, 0);
    dword_47B5A0 = (int)new_c_map(962861, 0, 0);
    pthread_mutex_init(&stru_47B570, 0);
    dword_47B568 = 1;
    pthread_create((pthread_t *)&dword_47B56C, 0, (void *(*)(void *))sub_EB14C, 0);
    dword_47B564 = 1;
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// EB14C: using guessed type int sub_EB14C();
// 47B564: using guessed type int dword_47B564;
// 47B568: using guessed type int dword_47B568;
// 47B56C: using guessed type int dword_47B56C;
// 47B570: using guessed type pthread_mutex_t stru_47B570;
// 47B588: using guessed type pthread_mutex_t stru_47B588;
// 47B5A0: using guessed type int dword_47B5A0;
// 47BE18: using guessed type int g_zc;

//----- (000EB55C) --------------------------------------------------------
int gpio_uninit()
{
  int result; // r0

  if ( dword_47B564 )
  {
    dword_47B568 = 0;
    pthread_join(dword_47B56C, 0);
    pthread_mutex_destroy(&stru_47B588);
    delete_c_map((void ***)dword_47B5A0);
    dword_47B564 = 0;
    return pthread_mutex_destroy(&stru_47B570);
  }
  return result;
}
// 47B564: using guessed type int dword_47B564;
// 47B568: using guessed type int dword_47B568;
// 47B56C: using guessed type int dword_47B56C;
// 47B570: using guessed type pthread_mutex_t stru_47B570;
// 47B588: using guessed type pthread_mutex_t stru_47B588;
// 47B5A0: using guessed type int dword_47B5A0;

//----- (000EB5C8) --------------------------------------------------------
int __fastcall gpio_reg_callback(int a1, int a2)
{
  int v5; // [sp+14h] [bp+4h] BYREF
  char v6[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[8]; // [sp+818h] [bp+808h] BYREF
  _DWORD v8[2]; // [sp+1818h] [bp+1808h] BYREF

  v5 = a1;
  if ( a2 )
  {
    if ( pthread_mutex_lock(&stru_47B588) )
    {
      strcpy(v6, "fail to lock gpio ctrl mutex\n");
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
        94,
        "gpio_reg_callback",
        17,
        152,
        100,
        v7);
      return -1;
    }
    else
    {
      if ( exists_c_map((int *)dword_47B5A0, (int)&v5) )
      {
        snprintf(v6, 0x800u, "port %d already exist in callback map \n", v5);
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_reg_callback",
          17,
          165,
          20,
          v7);
      }
      else
      {
        snprintf(v6, 0x800u, "add %d to callback map\n", v5);
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_reg_callback",
          17,
          158,
          20,
          v7);
        v8[0] = a2;
        v8[1] = -1;
        insert_c_map((int *)dword_47B5A0, &v5, 4u, v8, 8u);
      }
      pthread_mutex_unlock(&stru_47B588);
      return 0;
    }
  }
  else
  {
    strcpy(v6, "bad param\n");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
      94,
      "gpio_reg_callback",
      17,
      147,
      100,
      v7);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B588: using guessed type pthread_mutex_t stru_47B588;
// 47B5A0: using guessed type int dword_47B5A0;
// 47BE18: using guessed type int g_zc;

//----- (000EB844) --------------------------------------------------------
int __fastcall gpio_unreg_callback(int a1, int a2)
{
  int v4; // [sp+14h] [bp+4h] BYREF
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v6[4096]; // [sp+818h] [bp+808h] BYREF

  v4 = a1;
  if ( a2 )
  {
    if ( pthread_mutex_lock(&stru_47B588) )
    {
      strcpy(s, "fail to lock gpio ctrl mutex\n");
      V_LOCK();
      logfmt_raw(v6, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
        94,
        "gpio_unreg_callback",
        19,
        189,
        100,
        v6);
      return -1;
    }
    else
    {
      if ( exists_c_map((int *)dword_47B5A0, (int)&v4) )
      {
        snprintf(s, 0x800u, "remove %d from callback list\n", v4);
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_unreg_callback",
          19,
          195,
          20,
          v6);
        remove_c_map((int *)dword_47B5A0, (int)&v4);
      }
      else
      {
        strcpy(s, "callback function not registered before\n");
        V_LOCK();
        logfmt_raw(v6, 0x1000u, 0, s);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_unreg_callback",
          19,
          200,
          80,
          v6);
      }
      pthread_mutex_unlock(&stru_47B588);
      return 0;
    }
  }
  else
  {
    strcpy(s, "bad param\n");
    V_LOCK();
    logfmt_raw(v6, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
      94,
      "gpio_unreg_callback",
      19,
      183,
      100,
      v6);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B588: using guessed type pthread_mutex_t stru_47B588;
// 47B5A0: using guessed type int dword_47B5A0;
// 47BE18: using guessed type int g_zc;

//----- (000EBA7C) --------------------------------------------------------
int __fastcall gpio_export(int a1)
{
  char v4[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[8]; // [sp+818h] [bp+808h] BYREF
  char v6[56]; // [sp+1818h] [bp+1808h] BYREF
  size_t v7; // [sp+1858h] [bp+1848h]
  int v8; // [sp+185Ch] [bp+184Ch]

  if ( pthread_mutex_lock(&stru_47B570) )
  {
    strcpy(v4, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
      94,
      "gpio_export",
      11,
      221,
      100,
      v5);
    return -1;
  }
  else
  {
    snprintf(v6, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(v6, 0) )
    {
      v8 = open("/sys/class/gpio/export", 1);
      if ( v8 >= 0 )
      {
        v7 = snprintf(v6, 0x40u, "%d", a1);
        if ( write(v8, v6, v7) >= 0 )
        {
          snprintf(v4, 0x800u, "export gpio %d success\n", a1);
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
            94,
            "gpio_export",
            11,
            251,
            20,
            v5);
          close(v8);
          pthread_mutex_unlock(&stru_47B570);
          return 0;
        }
        else
        {
          snprintf(v4, 0x800u, "Failed to export gpio %d!", a1);
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
            94,
            "gpio_export",
            11,
            246,
            100,
            v5);
          close(v8);
          pthread_mutex_unlock(&stru_47B570);
          return -3;
        }
      }
      else
      {
        strcpy(v4, "Failed to open export for writing!\n");
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_export",
          11,
          238,
          100,
          v5);
        pthread_mutex_unlock(&stru_47B570);
        return -2;
      }
    }
    else
    {
      snprintf(v4, 0x800u, "port %d already exported\n", a1);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
        94,
        "gpio_export",
        11,
        229,
        80,
        v5);
      pthread_mutex_unlock(&stru_47B570);
      return 0;
    }
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B570: using guessed type pthread_mutex_t stru_47B570;
// 47BE18: using guessed type int g_zc;

//----- (000EBDE4) --------------------------------------------------------
int __fastcall gpio_unexport(int a1)
{
  char v4[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[8]; // [sp+818h] [bp+808h] BYREF
  char v6[56]; // [sp+1818h] [bp+1808h] BYREF
  size_t v7; // [sp+1858h] [bp+1848h]
  int v8; // [sp+185Ch] [bp+184Ch]

  if ( pthread_mutex_lock(&stru_47B570) )
  {
    strcpy(v4, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
      94,
      "gpio_unexport",
      13,
      273,
      100,
      v5);
    return -1;
  }
  else
  {
    snprintf(v6, 0x40u, "/sys/class/gpio/gpio%d", a1);
    v8 = access(v6, 0);
    if ( v8 )
    {
      snprintf(v4, 0x800u, "port %d already unexported, ret = %d\n", a1, v8);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
        94,
        "gpio_unexport",
        13,
        281,
        80,
        v5);
      pthread_mutex_unlock(&stru_47B570);
      return 0;
    }
    else
    {
      v8 = open("/sys/class/gpio/unexport", 1);
      if ( v8 >= 0 )
      {
        v7 = snprintf(v6, 0x40u, "%d", a1);
        if ( write(v8, v6, v7) >= 0 )
        {
          snprintf(v4, 0x800u, "unexport gpio %d success\n", a1);
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
            94,
            "gpio_unexport",
            13,
            304,
            20,
            v5);
          close(v8);
          pthread_mutex_unlock(&stru_47B570);
          return 0;
        }
        else
        {
          snprintf(v4, 0x800u, "Failed to unexport gpio %d!", a1);
          V_LOCK();
          logfmt_raw(v5, 0x1000u, 0, v4);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
            94,
            "gpio_unexport",
            13,
            298,
            100,
            v5);
          close(v8);
          pthread_mutex_unlock(&stru_47B570);
          return -2;
        }
      }
      else
      {
        strcpy(v4, "Failed to open unexport for writing!\n");
        V_LOCK();
        logfmt_raw(v5, 0x1000u, 0, v4);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_unexport",
          13,
          290,
          100,
          v5);
        pthread_mutex_unlock(&stru_47B570);
        return -2;
      }
    }
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B570: using guessed type pthread_mutex_t stru_47B570;
// 47BE18: using guessed type int g_zc;

//----- (000EC17C) --------------------------------------------------------
int __fastcall gpio_direction(int a1, int a2)
{
  int v3; // r2
  size_t v4; // r3
  int v5; // r2
  int v6; // r2
  char v10[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v11; // [sp+81Ch] [bp+80Ch] BYREF
  char v12[52]; // [sp+181Ch] [bp+180Ch] BYREF
  int v13; // [sp+185Ch] [bp+184Ch]

  if ( pthread_mutex_lock(&stru_47B570) )
  {
    strcpy(v10, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(&v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
      94,
      "gpio_direction",
      14,
      327,
      100,
      &v11);
    return -1;
  }
  else
  {
    snprintf(v12, 0x40u, "/sys/class/gpio/gpio%d/direction", a1);
    v13 = open(v12, 1);
    if ( v13 >= 0 )
    {
      if ( a2 )
        v3 = 3;
      else
        v3 = 0;
      if ( a2 )
        v4 = 3;
      else
        v4 = 2;
      if ( write(v13, &aIn[v3], v4) >= 0 )
      {
        if ( a2 )
          v6 = 3;
        else
          v6 = 0;
        snprintf(v10, 0x800u, "set gpio %d direction %s success!\n", a1, &aIn[v6]);
        V_LOCK();
        logfmt_raw(&v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_direction",
          14,
          350,
          20,
          &v11);
        close(v13);
        pthread_mutex_unlock(&stru_47B570);
        return 0;
      }
      else
      {
        if ( a2 )
          v5 = 3;
        else
          v5 = 0;
        snprintf(v10, 0x800u, "Failed to set gpio %d direction %s !\n", a1, &aIn[v5]);
        V_LOCK();
        logfmt_raw(&v11, 0x1000u, 0, v10);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_direction",
          14,
          343,
          100,
          &v11);
        close(v13);
        pthread_mutex_unlock(&stru_47B570);
        return -3;
      }
    }
    else
    {
      snprintf(v10, 0x800u, "Failed to open gpio %d direction for writing!\n", a1);
      V_LOCK();
      logfmt_raw(&v11, 0x1000u, 0, v10);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
        94,
        "gpio_direction",
        14,
        334,
        100,
        &v11);
      pthread_mutex_unlock(&stru_47B570);
      return -2;
    }
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B570: using guessed type pthread_mutex_t stru_47B570;
// 47BE18: using guessed type int g_zc;

//----- (000EC490) --------------------------------------------------------
int __fastcall gpio_read(int a1, _BYTE *a2)
{
  char v6[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v7[8]; // [sp+818h] [bp+808h] BYREF
  int v8; // [sp+1818h] [bp+1808h] BYREF
  char v9[52]; // [sp+181Ch] [bp+180Ch] BYREF
  int v10; // [sp+185Ch] [bp+184Ch]

  v8 = 0;
  if ( pthread_mutex_lock(&stru_47B570) )
  {
    strcpy(v6, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
      94,
      "gpio_read",
      9,
      372,
      100,
      v7);
    return -1;
  }
  else
  {
    snprintf(v9, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    v10 = open(v9, 0);
    if ( v10 >= 0 )
    {
      if ( read(v10, &v8, 4u) >= 0 )
      {
        close(v10);
        pthread_mutex_unlock(&stru_47B570);
        *a2 = atoi((const char *)&v8);
        return 0;
      }
      else
      {
        strcpy(v6, "Failed to read value!\n");
        V_LOCK();
        logfmt_raw(v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_read",
          9,
          387,
          100,
          v7);
        close(v10);
        pthread_mutex_unlock(&stru_47B570);
        return -3;
      }
    }
    else
    {
      snprintf(v6, 0x800u, "Failed to open gpio %d value for reading!\n", a1);
      V_LOCK();
      logfmt_raw(v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
        94,
        "gpio_read",
        9,
        380,
        100,
        v7);
      pthread_mutex_unlock(&stru_47B570);
      return -2;
    }
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B570: using guessed type pthread_mutex_t stru_47B570;
// 47BE18: using guessed type int g_zc;

//----- (000EC704) --------------------------------------------------------
int __fastcall gpio_write(int a1, char a2)
{
  char v6[2048]; // [sp+1Ch] [bp+Ch] BYREF
  int v7; // [sp+81Ch] [bp+80Ch] BYREF
  char v8[52]; // [sp+181Ch] [bp+180Ch] BYREF
  int v9; // [sp+185Ch] [bp+184Ch]

  if ( pthread_mutex_lock(&stru_47B570) )
  {
    strcpy(v6, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(&v7, 0x1000u, 0, v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
      94,
      "gpio_write",
      10,
      415,
      100,
      &v7);
    return -1;
  }
  else
  {
    snprintf(v8, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    v9 = open(v8, 1);
    if ( v9 >= 0 )
    {
      if ( write(v9, &a01[a2 != 0], 1u) >= 0 )
      {
        close(v9);
        pthread_mutex_unlock(&stru_47B570);
        return 0;
      }
      else
      {
        strcpy(v6, "Failed to write value!\n");
        V_LOCK();
        logfmt_raw(&v7, 0x1000u, 0, v6);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
          94,
          "gpio_write",
          10,
          429,
          100,
          &v7);
        close(v9);
        pthread_mutex_unlock(&stru_47B570);
        return -3;
      }
    }
    else
    {
      strcpy(v6, "Failed to open gpio value for writing!\n");
      V_LOCK();
      logfmt_raw(&v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
        94,
        "gpio_write",
        10,
        423,
        100,
        &v7);
      pthread_mutex_unlock(&stru_47B570);
      return -2;
    }
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B570: using guessed type pthread_mutex_t stru_47B570;
// 47BE18: using guessed type int g_zc;

//----- (000EC964) --------------------------------------------------------
int __fastcall is_gpio_exist(int a1)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[4088]; // [sp+818h] [bp+808h] BYREF
  char v6[64]; // [sp+1818h] [bp+1808h] BYREF

  if ( pthread_mutex_lock(&stru_47B570) )
  {
    strcpy(s, "failed to api lock\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, s);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
      94,
      "is_gpio_exist",
      13,
      443,
      100,
      v5);
    return -1;
  }
  else
  {
    snprintf(v6, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(v6, 0) )
    {
      pthread_mutex_unlock(&stru_47B570);
      return 0;
    }
    else
    {
      snprintf(s, 0x800u, "port %d already exported\n", a1);
      V_LOCK();
      logfmt_raw(v5, 0x1000u, 0, s);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_gpio.c",
        94,
        "is_gpio_exist",
        13,
        449,
        20,
        v5);
      pthread_mutex_unlock(&stru_47B570);
      return 1;
    }
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B570: using guessed type pthread_mutex_t stru_47B570;
// 47BE18: using guessed type int g_zc;

//----- (000ECABC) --------------------------------------------------------
int fan_init()
{
  char v2[2048]; // [sp+10h] [bp+0h] BYREF
  _BYTE v3[4096]; // [sp+810h] [bp+800h] BYREF

  if ( platform_inited )
    return 0;
  strcpy(v2, "please init platform first!!\n");
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fan.c",
    93,
    "fan_init",
    8,
    25,
    100,
    v3);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000ECB4C) --------------------------------------------------------
void fan_uninit()
{
  ;
}

//----- (000ECB5C) --------------------------------------------------------
int __fastcall fan_get_realtime_speed(int a1)
{
  char v4[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v5[8]; // [sp+818h] [bp+808h] BYREF
  unsigned int v6; // [sp+1818h] [bp+1808h] BYREF
  int i; // [sp+181Ch] [bp+180Ch]

  v6 = 0;
  for ( i = 0; i <= 7; ++i )
  {
    fpga_read(4u, &v6);
    snprintf(v4, 0x800u, "FAN_SPEED fpga value = 0x%x\n", v6);
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_fan.c",
      93,
      "fan_get_realtime_speed",
      22,
      56,
      20,
      v5);
    if ( ((v6 >> 8) & 7) == a1 )
      return 120 * (unsigned __int8)v6;
    usleep(0x2710u);
  }
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000ECC78) --------------------------------------------------------
int __fastcall sub_ECC78(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  char v6[4]; // [sp+24h] [bp+14h] BYREF
  int v7; // [sp+824h] [bp+814h] BYREF
  int v8; // [sp+1824h] [bp+1814h]

  v8 = 0;
  switch ( a1 )
  {
    case 0:
      *a2 = 24;
      *a3 = 384;
      *a4 = 400;
      *a5 = 404;
      break;
    case 1:
      *a2 = 16;
      *a3 = 384;
      *a4 = 408;
      *a5 = 412;
      break;
    case 2:
      *a2 = 8;
      *a3 = 384;
      *a4 = 416;
      *a5 = 420;
      break;
    case 3:
      *a2 = 0;
      *a3 = 384;
      *a4 = 424;
      *a5 = 428;
      break;
    case 4:
      *a2 = 24;
      *a3 = 388;
      *a4 = 432;
      *a5 = 436;
      break;
    case 5:
      *a2 = 16;
      *a3 = 388;
      *a4 = 440;
      *a5 = 444;
      break;
    case 6:
      *a2 = 8;
      *a3 = 388;
      *a4 = 448;
      *a5 = 452;
      break;
    case 7:
      *a2 = 0;
      *a3 = 388;
      *a4 = 456;
      *a5 = 460;
      break;
    case 8:
      *a2 = 24;
      *a3 = 392;
      *a4 = 464;
      *a5 = 468;
      break;
    case 9:
      *a2 = 16;
      *a3 = 392;
      *a4 = 472;
      *a5 = 476;
      break;
    case 10:
      *a2 = 8;
      *a3 = 392;
      *a4 = 608;
      *a5 = 612;
      break;
    case 11:
      *a2 = 0;
      *a3 = 392;
      *a4 = 616;
      *a5 = 620;
      break;
    case 12:
      *a2 = 24;
      *a3 = 396;
      *a4 = 624;
      *a5 = 628;
      break;
    case 13:
      *a2 = 16;
      *a3 = 396;
      *a4 = 632;
      *a5 = 636;
      break;
    default:
      snprintf(v6, 0x800u, "%s: The uart %d is not supported!!!\n", "get_send_address_info", a1);
      V_LOCK();
      logfmt_raw(&v7, 0x1000u, 0, v6);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
        94,
        "get_send_address_info",
        21,
        121,
        100,
        &v7);
      v8 = -1;
      break;
  }
  return v8;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000ED0C8) --------------------------------------------------------
int __fastcall sub_ED0C8(int a1, _DWORD *a2, _DWORD *a3)
{
  char v4[4]; // [sp+24h] [bp+14h] BYREF
  int v5; // [sp+824h] [bp+814h] BYREF
  int v6; // [sp+1824h] [bp+1814h]

  v6 = 0;
  switch ( a1 )
  {
    case 0:
      *a2 = 528;
      *a3 = 532;
      break;
    case 1:
      *a2 = 536;
      *a3 = 540;
      break;
    case 2:
      *a2 = 544;
      *a3 = 548;
      break;
    case 3:
      *a2 = 552;
      *a3 = 556;
      break;
    case 4:
      *a2 = 560;
      *a3 = 564;
      break;
    case 5:
      *a2 = 568;
      *a3 = 572;
      break;
    case 6:
      *a2 = 576;
      *a3 = 580;
      break;
    case 7:
      *a2 = 584;
      *a3 = 588;
      break;
    case 8:
      *a2 = 592;
      *a3 = 596;
      break;
    case 9:
      *a2 = 600;
      *a3 = 604;
      break;
    case 10:
      *a2 = 656;
      *a3 = 660;
      break;
    case 11:
      *a2 = 664;
      *a3 = 668;
      break;
    case 12:
      *a2 = 672;
      *a3 = 676;
      break;
    case 13:
      *a2 = 680;
      *a3 = 684;
      break;
    default:
      snprintf(v4, 0x800u, "%s: The uart%d is not supported!!!\n", "get_read_address_info", a1);
      V_LOCK();
      logfmt_raw(&v5, 0x1000u, 0, v4);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
        94,
        "get_read_address_info",
        21,
        207,
        100,
        &v5);
      v6 = -1;
      break;
  }
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000ED388) --------------------------------------------------------
int __fastcall sub_ED388(unsigned __int8 a1)
{
  int v1; // r3
  char v3[4]; // [sp+1Ch] [bp+Ch] BYREF
  int v4; // [sp+81Ch] [bp+80Ch] BYREF
  unsigned int v5; // [sp+181Ch] [bp+180Ch] BYREF

  v5 = 0;
  switch ( a1 )
  {
    case 0u:
      fpga_read(0x1F0u, &v5);
      v1 = HIWORD(v5) & 0x3FF;
      break;
    case 1u:
      fpga_read(0x1F0u, &v5);
      v1 = v5 & 0x3FF;
      break;
    case 2u:
      fpga_read(0x1F4u, &v5);
      v1 = HIWORD(v5) & 0x3FF;
      break;
    case 3u:
      fpga_read(0x1F4u, &v5);
      v1 = v5 & 0x3FF;
      break;
    case 4u:
      fpga_read(0x1F8u, &v5);
      v1 = HIWORD(v5) & 0x3FF;
      break;
    case 5u:
      fpga_read(0x1F8u, &v5);
      v1 = v5 & 0x3FF;
      break;
    case 6u:
      fpga_read(0x1FCu, &v5);
      v1 = HIWORD(v5) & 0x3FF;
      break;
    case 7u:
      fpga_read(0x1FCu, &v5);
      v1 = v5 & 0x3FF;
      break;
    case 8u:
      fpga_read(0x200u, &v5);
      v1 = HIWORD(v5) & 0x3FF;
      break;
    case 9u:
      fpga_read(0x200u, &v5);
      v1 = v5 & 0x3FF;
      break;
    case 0xAu:
      fpga_read(0x204u, &v5);
      v1 = HIWORD(v5) & 0x3FF;
      break;
    case 0xBu:
      fpga_read(0x204u, &v5);
      v1 = v5 & 0x3FF;
      break;
    case 0xCu:
      fpga_read(0x208u, &v5);
      v1 = HIWORD(v5) & 0x3FF;
      break;
    case 0xDu:
      fpga_read(0x208u, &v5);
      v1 = v5 & 0x3FF;
      break;
    default:
      snprintf(v3, 0x800u, "%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
      V_LOCK();
      logfmt_raw(&v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
        94,
        "check_how_many_uart_data_in_fpga",
        32,
        273,
        100,
        &v4);
      v1 = 0;
      break;
  }
  return v1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000ED668) --------------------------------------------------------
int __fastcall sub_ED668(int a1, int a2, unsigned int a3)
{
  char v8[28]; // [sp+24h] [bp+14h] BYREF
  _BYTE v9[28]; // [sp+824h] [bp+814h] BYREF
  int v10; // [sp+1824h] [bp+1814h] BYREF
  unsigned int v11; // [sp+1828h] [bp+1818h] BYREF
  unsigned int v12; // [sp+182Ch] [bp+181Ch] BYREF
  unsigned int v13; // [sp+1830h] [bp+1820h]
  unsigned int v14; // [sp+1834h] [bp+1824h]
  int v15; // [sp+1838h] [bp+1828h]
  unsigned int i; // [sp+183Ch] [bp+182Ch]

  v12 = 0;
  v11 = 0;
  v14 = 0;
  v13 = 0;
  i = 0;
  v10 = 0;
  v15 = 0;
  if ( sub_ED0C8(a1, &v12, &v11) )
  {
    snprintf(v8, 0x800u, "get_read_address_info error, chain_id = %d\n", a1);
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "read_uart_data_in_fpga",
      22,
      285,
      100,
      v9);
    return 0;
  }
  else
  {
    v14 = a3 & 0x3FF | 0x80000000;
    fpga_write(v12, v14);
    v13 = a3 >> 2;
    for ( i = 0; i < v13; ++i )
    {
      fpga_read(v11, &v10);
      *(_BYTE *)(a2 + 4 * i) = HIBYTE(v10);
      *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v10);
      *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(v10);
      *(_BYTE *)(a2 + 4 * i + 3) = v10;
    }
    v15 = 4 * v13;
    v13 = a3 & 3;
    if ( (a3 & 3) != 0 )
    {
      fpga_read(v11, &v10);
      switch ( v13 )
      {
        case 2u:
          *(_BYTE *)(a2 + 4 * i) = HIBYTE(v10);
          *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v10);
          v15 += 2;
          break;
        case 3u:
          *(_BYTE *)(a2 + 4 * i) = HIBYTE(v10);
          *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v10);
          *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(v10);
          v15 += 3;
          break;
        case 1u:
          *(_BYTE *)(a2 + 4 * i) = HIBYTE(v10);
          ++v15;
          break;
        default:
          snprintf(v8, 0x800u, "%s: the uart%d left data is 4*N length, error!!!\n", "read_uart_data_in_fpga", a1);
          V_LOCK();
          logfmt_raw(v9, 0x1000u, 0, v8);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
            94,
            "read_uart_data_in_fpga",
            22,
            331,
            100,
            v9);
          break;
      }
    }
    return v15;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000EDAC8) --------------------------------------------------------
int uart_init()
{
  char v2[2048]; // [sp+10h] [bp+0h] BYREF
  _BYTE v3[4096]; // [sp+810h] [bp+800h] BYREF

  if ( platform_inited )
    return 0;
  strcpy(v2, "please init platform first!!\n");
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
    94,
    "uart_init",
    9,
    342,
    100,
    v3);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B37C: using guessed type int platform_inited;
// 47BE18: using guessed type int g_zc;

//----- (000EDB58) --------------------------------------------------------
void uart_uninit()
{
  ;
}

//----- (000EDB68) --------------------------------------------------------
int __fastcall sub_EDB68(const char *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v4; // r3
  int v5; // [sp+4h] [bp+4h]
  unsigned int i; // [sp+10h] [bp+10h]
  unsigned int j; // [sp+10h] [bp+10h]
  unsigned __int8 *v8; // [sp+14h] [bp+14h]

  v5 = a3;
  v8 = a2;
  result = printf("Dumping %u %s bytes from %p:\n", a3, a1, a2);
  while ( v5 > 0 )
  {
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( i >= v5 )
        printf("   ");
      else
        printf("%02x ", v8[i]);
    }
    for ( j = 0; j <= 0xF; ++j )
    {
      if ( j >= v5 )
      {
        putchar(32);
      }
      else
      {
        if ( v8[j] <= 0x1Fu || v8[j] > 0x7Eu )
          v4 = 46;
        else
          v4 = v8[j];
        putchar(v4);
      }
    }
    result = putchar(10);
    v8 += 16;
    if ( v5 <= 16 )
      break;
    v5 -= 16;
  }
  return result;
}

//----- (000EDC40) --------------------------------------------------------
size_t __fastcall uart_send(int a1, const void *a2, size_t a3)
{
  char v8[8]; // [sp+20h] [bp+10h] BYREF
  _BYTE v9[8]; // [sp+820h] [bp+810h] BYREF
  int v10; // [sp+1820h] [bp+1810h] BYREF
  size_t v11; // [sp+1824h] [bp+1814h] BYREF
  unsigned int v12; // [sp+1828h] [bp+1818h] BYREF
  unsigned int v13; // [sp+182Ch] [bp+181Ch] BYREF
  unsigned int v14; // [sp+1830h] [bp+1820h] BYREF
  _BYTE v15[256]; // [sp+1834h] [bp+1824h] BYREF
  size_t v16; // [sp+1934h] [bp+1924h]
  signed int v17; // [sp+1938h] [bp+1928h]
  int v18; // [sp+193Ch] [bp+192Ch]
  int v19; // [sp+1940h] [bp+1930h]
  signed int i; // [sp+1944h] [bp+1934h]

  v18 = 0;
  v17 = 0;
  i = 0;
  memset(v15, 0, sizeof(v15));
  v16 = a3;
  v19 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  pthread_mutex_lock(&stru_47B5A4[a1]);
  if ( sub_ECC78(a1, &v10, &v14, &v13, &v12) )
  {
    snprintf(v8, 0x800u, "get_send_address_info error, chain_id = %d\n", a1);
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "uart_send",
      9,
      408,
      100,
      v9);
    pthread_mutex_unlock(&stru_47B5A4[a1]);
    return 0;
  }
  else
  {
    while ( 1 )
    {
      fpga_read(v14, &v11);
      v11 = (unsigned __int8)(v11 >> v10);
      if ( v11 >= a3 )
        break;
      usleep(0);
    }
    fpga_read(v13, &v11);
    v11 = (unsigned __int8)(v11 >> v10);
    memcpy(v15, a2, a3);
    v17 = v16 >> 2;
    for ( i = 0; i < v17; ++i )
    {
      v19 = ((unsigned __int8)v15[4 * i + 2] << 8)
          | ((unsigned __int8)v15[4 * i] << 24)
          | ((unsigned __int8)v15[4 * i + 1] << 16)
          | (unsigned __int8)v15[4 * i + 3];
      fpga_write(v12, v19);
    }
    v17 = v16 & 3;
    if ( (v16 & 3) != 0 )
    {
      switch ( v17 )
      {
        case 2:
          v19 = ((unsigned __int8)v15[4 * i + 1] << 16) | ((unsigned __int8)v15[4 * i] << 24);
          break;
        case 3:
          v19 = ((unsigned __int8)v15[4 * i + 2] << 8)
              | ((unsigned __int8)v15[4 * i] << 24)
              | ((unsigned __int8)v15[4 * i + 1] << 16);
          break;
        case 1:
          v19 = (unsigned __int8)v15[4 * i] << 24;
          break;
        default:
          printf("%s: the uart%d send left data is 4*N length, error!!!\n", "uart_send", a1);
          break;
      }
      fpga_write(v12, v19);
    }
    fpga_write(v13, v16 | 0x80000000);
    pthread_mutex_unlock(&stru_47B5A4[a1]);
    return v16;
  }
}
// EDE7E: conditional instruction was optimized away because %0x1824.4<100u
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B5A4: using guessed type pthread_mutex_t stru_47B5A4[16];
// 47BE18: using guessed type int g_zc;

//----- (000EE114) --------------------------------------------------------
int __fastcall uart_receive(int a1, int a2, unsigned int a3)
{
  int v8; // [sp+18h] [bp+18h]
  unsigned int v9; // [sp+1Ch] [bp+1Ch]

  pthread_mutex_lock(&stru_47B724[a1]);
  v9 = sub_ED388(a1);
  if ( v9 > a3 )
    v9 = a3;
  if ( v9 )
  {
    v8 = sub_ED668(a1, a2, v9);
    pthread_mutex_unlock(&stru_47B724[a1]);
    return v8;
  }
  else
  {
    pthread_mutex_unlock(&stru_47B724[a1]);
    return 0;
  }
}
// 47B724: using guessed type pthread_mutex_t stru_47B724[16];

//----- (000EE1D0) --------------------------------------------------------
int __fastcall uart_set_config(int a1, int a2, int *a3)
{
  char v8[4]; // [sp+24h] [bp+14h] BYREF
  int v9; // [sp+824h] [bp+814h] BYREF
  int v10; // [sp+1824h] [bp+1814h]

  v10 = -5;
  if ( !a3 )
    return -3;
  pthread_mutex_lock(&stru_47B5A4[a1]);
  if ( a2 )
  {
    snprintf(v8, 0x800u, "unknown set config type = %d\n", a2);
    V_LOCK();
    logfmt_raw(&v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "uart_set_config",
      15,
      576,
      80,
      &v9);
  }
  else
  {
    fpga_write(0x3Cu, *a3);
  }
  pthread_mutex_unlock(&stru_47B5A4[a1]);
  return v10;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B5A4: using guessed type pthread_mutex_t stru_47B5A4[16];
// 47BE18: using guessed type int g_zc;

//----- (000EE304) --------------------------------------------------------
int __fastcall uart_get_config(int a1, int a2, _DWORD *a3, int a4)
{
  char v9[8]; // [sp+20h] [bp+10h] BYREF
  _BYTE v10[8]; // [sp+820h] [bp+810h] BYREF
  int v11; // [sp+1820h] [bp+1810h] BYREF
  int v12; // [sp+1824h] [bp+1814h]

  v12 = -5;
  if ( !a3 || a4 )
    return -3;
  pthread_mutex_lock(&stru_47B5A4[a1]);
  if ( a2 )
  {
    snprintf(v9, 0x800u, "unknown set config type = %d\n", a2);
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "uart_get_config",
      15,
      600,
      80,
      v10);
  }
  else
  {
    v11 = 0;
    v12 = fpga_read(0x3Cu, &v11);
    *a3 = v11;
    MEMORY[0] = 4;
    snprintf(v9, 0x800u, "uart_get_config return %d\n", *a3);
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "uart_get_config",
      15,
      596,
      40,
      v10);
  }
  pthread_mutex_unlock(&stru_47B5A4[a1]);
  return v12;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B5A4: using guessed type pthread_mutex_t stru_47B5A4[16];
// 47BE18: using guessed type int g_zc;

//----- (000EE4EC) --------------------------------------------------------
int __fastcall high_speed_uart_set_config(int a1, int a2, _DWORD *a3)
{
  char v8[4]; // [sp+24h] [bp+14h] BYREF
  int v9; // [sp+824h] [bp+814h] BYREF
  int v10; // [sp+1824h] [bp+1814h]

  v10 = -5;
  if ( !a3 )
    return -3;
  pthread_mutex_lock(&stru_47B5A4[a1]);
  if ( a2 )
  {
    snprintf(v8, 0x800u, "unknown set config type = %d\n", a2);
    V_LOCK();
    logfmt_raw(&v9, 0x1000u, 0, v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "high_speed_uart_set_config",
      26,
      620,
      80,
      &v9);
  }
  else
  {
    fpga_write(0x3Cu, *a3 << 16);
  }
  pthread_mutex_unlock(&stru_47B5A4[a1]);
  return v10;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B5A4: using guessed type pthread_mutex_t stru_47B5A4[16];
// 47BE18: using guessed type int g_zc;

//----- (000EE624) --------------------------------------------------------
int __fastcall high_speed_uart_get_config(int a1, int a2, unsigned int *a3, int a4)
{
  char v9[8]; // [sp+20h] [bp+10h] BYREF
  _BYTE v10[8]; // [sp+820h] [bp+810h] BYREF
  int v11; // [sp+1820h] [bp+1810h] BYREF
  int v12; // [sp+1824h] [bp+1814h]

  v12 = -5;
  if ( !a3 || a4 )
    return -3;
  pthread_mutex_lock(&stru_47B5A4[a1]);
  if ( a2 )
  {
    snprintf(v9, 0x800u, "unknown set config type = %d\n", a2);
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "high_speed_uart_get_config",
      26,
      644,
      80,
      v10);
  }
  else
  {
    v11 = 0;
    v12 = fpga_read(0x3Cu, &v11);
    *a3 = (v11 & 0x3F0000u) >> 16;
    MEMORY[0] = 4;
    snprintf(v9, 0x800u, "uart_get_config return %d\n", *a3);
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "high_speed_uart_get_config",
      26,
      640,
      40,
      v10);
  }
  pthread_mutex_unlock(&stru_47B5A4[a1]);
  return v12;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B5A4: using guessed type pthread_mutex_t stru_47B5A4[16];
// 47BE18: using guessed type int g_zc;

//----- (000EE814) --------------------------------------------------------
int __fastcall sub_EE814(int a1)
{
  int v2; // [sp+14h] [bp+4h]
  char v3[24]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[24]; // [sp+818h] [bp+808h] BYREF
  int v5; // [sp+1818h] [bp+1808h] BYREF
  unsigned int v6; // [sp+181Ch] [bp+180Ch] BYREF
  int v7; // [sp+1820h] [bp+1810h] BYREF
  unsigned int v8; // [sp+1824h] [bp+1814h] BYREF
  unsigned int v9; // [sp+1828h] [bp+1818h] BYREF
  unsigned int i; // [sp+182Ch] [bp+181Ch]

  v2 = a1;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  i = 0;
  pthread_mutex_lock(&stru_47B5A4[a1]);
  if ( sub_ECC78(v2, &v5, &v9, &v8, &v7) )
  {
    snprintf(v3, 0x800u, "get_send_address_info error, chain_id = %d\n", v2);
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "clear_uart_tx_fifo",
      18,
      660,
      100,
      v4);
    return pthread_mutex_unlock(&stru_47B5A4[v2]);
  }
  else
  {
    for ( i = 0; i <= 0x14; ++i )
    {
      fpga_read(v9, &v6);
      v6 = (unsigned __int8)(v6 >> v5);
      if ( v6 == 255 )
        return pthread_mutex_unlock(&stru_47B5A4[v2]);
      printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_tx_fifo", v2);
      fpga_write(v8, v6 | 0x80000000);
      usleep(0xBB8u);
    }
    snprintf(v3, 0x800u, "%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_tx_fifo", v2);
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "clear_uart_tx_fifo",
      18,
      681,
      100,
      v4);
    return pthread_mutex_unlock(&stru_47B5A4[v2]);
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B5A4: using guessed type pthread_mutex_t stru_47B5A4[16];
// 47BE18: using guessed type int g_zc;

//----- (000EEAE0) --------------------------------------------------------
int __fastcall clear_uart_rx_fifo(int a1)
{
  char v3[12]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v4[12]; // [sp+81Ch] [bp+80Ch] BYREF
  void *v5; // [sp+181Ch] [bp+180Ch]
  size_t v6; // [sp+1820h] [bp+1810h]
  int v7; // [sp+1824h] [bp+1814h]

  v7 = 0;
  v5 = 0;
  pthread_mutex_lock(&stru_47B724[a1]);
  v6 = sub_ED388(a1);
  if ( !v6 )
    return pthread_mutex_unlock(&stru_47B724[a1]);
  v5 = malloc(v6);
  if ( v5 )
  {
    v7 = sub_ED668(a1, (int)v5, v6);
    if ( v7 == v6 )
    {
      free(v5);
      usleep(0x2710u);
      return pthread_mutex_unlock(&stru_47B724[a1]);
    }
    else
    {
      snprintf(v3, 0x800u, "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n", "clear_uart_rx_fifo", a1, v6, v7);
      V_LOCK();
      logfmt_raw(v4, 0x1000u, 0, v3);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
        94,
        "clear_uart_rx_fifo",
        18,
        718,
        100,
        v4);
      free(v5);
      v5 = 0;
      usleep(0x2710u);
      return pthread_mutex_unlock(&stru_47B724[a1]);
    }
  }
  else
  {
    snprintf(v3, 0x800u, "%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
      94,
      "clear_uart_rx_fifo",
      18,
      709,
      100,
      v4);
    v5 = 0;
    usleep(0x7A120u);
    return pthread_mutex_unlock(&stru_47B724[a1]);
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B724: using guessed type pthread_mutex_t stru_47B724[16];
// 47BE18: using guessed type int g_zc;

//----- (000EEDC8) --------------------------------------------------------
int __fastcall uart_flush(int a1)
{
  char s[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4096]; // [sp+818h] [bp+808h] BYREF

  snprintf(s, 0x800u, "flush uart %d\n", a1);
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, s);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/platform/7007/7007_uart.c",
    94,
    "uart_flush",
    10,
    737,
    20,
    v4);
  clear_uart_rx_fifo(a1);
  usleep(0x2710u);
  sub_EE814(a1);
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000EEE74) --------------------------------------------------------
int __fastcall uart_flush_tx(int a1)
{
  sub_EE814(a1);
  return 0;
}

//----- (000EEE8C) --------------------------------------------------------
int __fastcall uart_flush_rx(int a1)
{
  clear_uart_rx_fifo(a1);
  return 0;
}

//----- (000EEEA4) --------------------------------------------------------
int __fastcall uart_get_readable_byte_num(int a1)
{
  int v3; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&stru_47B724[a1]);
  v3 = sub_ED388(a1);
  pthread_mutex_unlock(&stru_47B724[a1]);
  return v3;
}
// 47B724: using guessed type pthread_mutex_t stru_47B724[16];

//----- (000EEEF8) --------------------------------------------------------
int __fastcall sub_EEEF8(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  char v7[2048]; // [sp+24h] [bp+14h] BYREF
  _BYTE v8[12]; // [sp+824h] [bp+814h] BYREF
  unsigned __int16 v9; // [sp+1824h] [bp+1814h]
  unsigned __int16 v10; // [sp+1826h] [bp+1816h]
  int v11; // [sp+1828h] [bp+1818h]
  unsigned int i; // [sp+182Ch] [bp+181Ch]

  i = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  if ( !a1 || !a2 || !a3 )
    return -2147482879;
  i = 2;
  v10 = 0;
  while ( a3 - 2 > i )
    v10 += a2[i++];
  v9 = a2[a3 - 2] + (a2[a3 - 1] << 8);
  if ( v10 == v9 )
  {
    if ( *a1 != *a2 || a1[1] != a2[1] || a1[3] != a2[3] || a2[2] + 2 != a3 )
    {
      strcpy(v7, "power reply the bad data\n");
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
        95,
        "check_read_back_data",
        20,
        94,
        100,
        v8);
      v11 = -2147482880;
    }
  }
  else
  {
    snprintf(v7, 0x800u, "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x\n", v10, v9);
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "check_read_back_data",
      20,
      88,
      100,
      v8);
    v11 = -2147482880;
  }
  if ( v11 )
  {
    for ( i = 0; i < a3; ++i )
    {
      snprintf(v7, 0x800u, "read_back_data[%d] = 0x%02x", i, a2[i]);
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, v7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
        95,
        "check_read_back_data",
        20,
        100,
        100,
        v8);
    }
  }
  return v11;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000EF2B0) --------------------------------------------------------
int __fastcall sub_EF2B0(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5)
{
  char v10[12]; // [sp+24h] [bp+14h] BYREF
  _BYTE v11[12]; // [sp+824h] [bp+814h] BYREF
  unsigned __int8 v12; // [sp+1827h] [bp+1817h] BYREF
  int v13; // [sp+1828h] [bp+1818h]
  unsigned __int8 i; // [sp+182Eh] [bp+181Eh]
  unsigned __int8 j; // [sp+182Fh] [bp+181Fh]

  j = 0;
  v13 = 0;
  v12 = 0;
  pthread_mutex_lock(&power_mutex);
  for ( i = 0; i <= 2u; ++i )
  {
    for ( j = 0; j < a3; iic_write_reg(a1, &v12, 1, (int)&a2[j++], 1u) )
      ;
    usleep(0x61A80u);
    for ( j = 0; j < a5; iic_read_reg(a1, &v12, 1, (int)&a4[j++], 1u) )
      ;
    usleep((__useconds_t)&stru_1869C.st_value);
    v13 = sub_EEEF8(a2, a4, a5);
    if ( !v13 )
      break;
    snprintf(v10, 0x800u, "Send power cmd(0x%02x) failed, retry %d\n", a2[3], i);
    V_LOCK();
    logfmt_raw(v11, 0x1000u, 0, v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "exec_power_cmd",
      14,
      175,
      100,
      v11);
  }
  pthread_mutex_unlock(&power_mutex);
  return v13;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B8A8: using guessed type pthread_mutex_t power_mutex;
// 47BE18: using guessed type int g_zc;

//----- (000EF50C) --------------------------------------------------------
int __fastcall sub_EF50C(int a1)
{
  char v3[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4088]; // [sp+818h] [bp+808h] BYREF
  int v5; // [sp+1818h] [bp+1808h] BYREF
  __int16 v6; // [sp+181Ch] [bp+180Ch]
  int v7; // [sp+1820h] [bp+1810h] BYREF
  int v8; // [sp+1824h] [bp+1814h]
  int v9; // [sp+1828h] [bp+1818h]
  __int16 v10; // [sp+182Eh] [bp+181Eh]
  char v11; // [sp+1831h] [bp+1821h]
  char v12; // [sp+1832h] [bp+1822h]
  char v13; // [sp+1833h] [bp+1823h]
  int v14; // [sp+1834h] [bp+1824h]

  v14 = -2147482880;
  v13 = 4;
  v12 = 1;
  v7 = 0;
  v8 = 0;
  v5 = 17082965;
  v9 = -1;
  v10 = 5;
  v6 = 5;
  v11 = 6;
  if ( sub_EF2B0(a1, (unsigned __int8 *)&v5, 6u, (unsigned __int8 *)&v7, 8u) )
  {
    strcpy(v3, "get power version failed\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "_bitmain_get_power_fw_version",
      29,
      206,
      100,
      v4);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v8) << 8) | (unsigned __int8)v8;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000EF790) --------------------------------------------------------
int __fastcall sub_EF790(int a1)
{
  char v3[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[4088]; // [sp+818h] [bp+808h] BYREF
  int v5; // [sp+1818h] [bp+1808h] BYREF
  __int16 v6; // [sp+181Ch] [bp+180Ch]
  int v7; // [sp+1820h] [bp+1810h] BYREF
  int v8; // [sp+1824h] [bp+1814h]
  int v9; // [sp+1828h] [bp+1818h]
  __int16 v10; // [sp+182Eh] [bp+181Eh]
  char v11; // [sp+1831h] [bp+1821h]
  char v12; // [sp+1832h] [bp+1822h]
  char v13; // [sp+1833h] [bp+1823h]
  int v14; // [sp+1834h] [bp+1824h]

  v14 = -2147482880;
  v13 = 4;
  v12 = 2;
  v7 = 0;
  v8 = 0;
  v5 = 33860181;
  v9 = -1;
  v10 = 6;
  v6 = 6;
  v11 = 6;
  if ( sub_EF2B0(a1, (unsigned __int8 *)&v5, 6u, (unsigned __int8 *)&v7, 8u) )
  {
    strcpy(v3, "get power version failed\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "_bitmain_get_power_version",
      26,
      251,
      100,
      v4);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v8) << 8) | (unsigned __int8)v8;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000EFA14) --------------------------------------------------------
int __fastcall sub_EFA14(int a1)
{
  char v3[2048]; // [sp+18h] [bp+8h] BYREF
  _BYTE v4[24]; // [sp+818h] [bp+808h] BYREF
  int v5; // [sp+1818h] [bp+1808h] BYREF
  int v6; // [sp+181Ch] [bp+180Ch]
  int v7; // [sp+1820h] [bp+1810h] BYREF
  __int16 v8; // [sp+1824h] [bp+1814h]
  __int16 v9; // [sp+1826h] [bp+1816h]
  int v10; // [sp+1828h] [bp+1818h]
  char v11; // [sp+182Dh] [bp+181Dh]
  char v12; // [sp+182Eh] [bp+181Eh]
  char v13; // [sp+182Fh] [bp+181Fh]

  v13 = 4;
  v12 = 3;
  v7 = 50637397;
  v5 = 0;
  v6 = 0;
  v10 = -2147482880;
  v9 = 7;
  v8 = 7;
  v11 = 6;
  if ( sub_EF2B0(a1, (unsigned __int8 *)&v7, 6u, (unsigned __int8 *)&v5, 8u) )
  {
    strcpy(v3, "get AD conversion N failed\n");
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, v3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "_bitmain_get_AD_conversion_N",
      28,
      311,
      100,
      v4);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v6) << 8) | (unsigned __int8)v6;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000EFC70) --------------------------------------------------------
int __fastcall sub_EFC70(int a1, unsigned __int8 a2)
{
  char v4[28]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v5[28]; // [sp+81Ch] [bp+80Ch] BYREF
  int v6; // [sp+181Ch] [bp+180Ch] BYREF
  int v7; // [sp+1820h] [bp+1810h]
  int v8; // [sp+1824h] [bp+1814h] BYREF
  unsigned __int8 v9; // [sp+1828h] [bp+1818h]
  char v10; // [sp+1829h] [bp+1819h]
  __int16 v11; // [sp+182Ah] [bp+181Ah]
  __int16 v12; // [sp+182Eh] [bp+181Eh]
  int v13; // [sp+1830h] [bp+1820h]
  char v14; // [sp+1835h] [bp+1825h]
  char v15; // [sp+1836h] [bp+1826h]
  char v16; // [sp+1837h] [bp+1827h]

  v16 = 6;
  v15 = -125;
  v8 = -2096715179;
  v6 = 0;
  v7 = 0;
  v13 = -2147482880;
  v12 = a2 + 137;
  v9 = a2;
  v10 = 0;
  v11 = v12;
  v14 = 8;
  if ( sub_EF2B0(a1, (unsigned __int8 *)&v8, 8u, (unsigned __int8 *)&v6, 8u) )
  {
    strcpy(v4, "set DA conversion N failed\n");
    V_LOCK();
    logfmt_raw(v5, 0x1000u, 0, v4);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "_bitmain_set_DA_conversion_N",
      28,
      357,
      100,
      v5);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v7) << 8) | (unsigned __int8)v7;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000EFF44) --------------------------------------------------------
int __fastcall sub_EFF44(int a1)
{
  return sub_EF790(a1);
}

//----- (000EFF68) --------------------------------------------------------
int bitmain_power_open()
{
  char v2[2048]; // [sp+14h] [bp+4h] BYREF
  _BYTE v3[12]; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h] BYREF
  __int16 v5; // [sp+1818h] [bp+1808h]
  char v6; // [sp+181Ah] [bp+180Ah]
  char v7; // [sp+181Bh] [bp+180Bh]
  int v8; // [sp+181Ch] [bp+180Ch]

  v8 = 0;
  if ( dword_47B8C0 && dword_47B8C4 )
    return dword_47B8C0;
  v4 = 0;
  v5 = 1;
  v6 = 2;
  v7 = 0;
  pthread_mutex_lock(&power_mutex);
  v8 = iic_init((int)&v4);
  pthread_mutex_unlock(&power_mutex);
  if ( v8 < 0 )
    return v8;
  dword_47B8C0 = v8;
  dword_47B8C4 = 1;
  memset(&unk_47B8D0, 0, 0x68u);
  v8 = bitmain_power_version();
  if ( v8 >= 0 )
  {
    dword_47B8C8 = v8;
    snprintf(v2, 0x800u, "power open power_version = 0x%x", v8);
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "bitmain_power_open",
      18,
      416,
      40,
      v3);
    return 0;
  }
  else
  {
    strcpy(v2, "power open power_version < 0 will close power\n");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "bitmain_power_open",
      18,
      411,
      40,
      v3);
    bitmain_power_close();
    return v8;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B8A8: using guessed type pthread_mutex_t power_mutex;
// 47B8C0: using guessed type int dword_47B8C0;
// 47B8C4: using guessed type int dword_47B8C4;
// 47B8C8: using guessed type int dword_47B8C8;
// 47BE18: using guessed type int g_zc;

//----- (000F018C) --------------------------------------------------------
int bitmain_power_close()
{
  char v1[2048]; // [sp+10h] [bp+0h] BYREF
  _BYTE v2[4096]; // [sp+810h] [bp+800h] BYREF

  if ( !dword_47B8C0 || !dword_47B8C4 )
  {
    pthread_mutex_lock(&power_mutex);
    strcpy(v1, "bitmain power close ===========\n");
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, v1);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "bitmain_power_close",
      19,
      428,
      40,
      v2);
    iic_uninit(dword_47B8C0);
    dword_47B8C4 = 0;
    dword_47B8C8 = 0;
    memset(&unk_47B8D0, 0, 0x68u);
    pthread_mutex_unlock(&power_mutex);
  }
  return 0;
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B8A8: using guessed type pthread_mutex_t power_mutex;
// 47B8C0: using guessed type int dword_47B8C0;
// 47B8C4: using guessed type int dword_47B8C4;
// 47B8C8: using guessed type int dword_47B8C8;
// 47BE18: using guessed type int g_zc;

//----- (000F0278) --------------------------------------------------------
int bitmain_power_fw_version()
{
  char v2[4]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h]

  v4 = 0;
  if ( dword_47B8C4 )
    return sub_EF50C(dword_47B8C0);
  v4 = bitmain_power_open();
  if ( v4 >= 0 )
    return sub_EF50C(dword_47B8C0);
  snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_fw_version");
  V_LOCK();
  logfmt_raw(&v3, 0x1000u, 0, v2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
    95,
    "bitmain_power_fw_version",
    24,
    442,
    100,
    &v3);
  return v4;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B8C0: using guessed type int dword_47B8C0;
// 47B8C4: using guessed type int dword_47B8C4;
// 47BE18: using guessed type int g_zc;

//----- (000F0368) --------------------------------------------------------
int bitmain_power_version()
{
  char v2[4]; // [sp+14h] [bp+4h] BYREF
  int v3; // [sp+814h] [bp+804h] BYREF
  int v4; // [sp+1814h] [bp+1804h]

  v4 = 0;
  if ( dword_47B8C4 || (v4 = bitmain_power_open(), v4 >= 0) )
  {
    v4 = sub_EFF44(dword_47B8C0);
    if ( v4 > 0 )
      dword_47B8C8 = v4;
    return v4;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_version");
    V_LOCK();
    logfmt_raw(&v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "bitmain_power_version",
      21,
      452,
      100,
      &v3);
    return v4;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// EFF68: using guessed type int bitmain_power_open(void);
// 47B8C0: using guessed type int dword_47B8C0;
// 47B8C4: using guessed type int dword_47B8C4;
// 47B8C8: using guessed type int dword_47B8C8;
// 47BE18: using guessed type int g_zc;

//----- (000F0478) --------------------------------------------------------
void bitmain_get_voltage()
{
  char v0[2048]; // [sp+14h] [bp+4h] BYREF
  int v1; // [sp+814h] [bp+804h] BYREF
  int v2; // [sp+1814h] [bp+1804h]

  v2 = 0;
  if ( dword_47B8C4 || (v2 = bitmain_power_open(), v2 >= 0) )
  {
    v2 = sub_EFA14(dword_47B8C0);
    if ( v2 >= 0 )
    {
      bitmain_convert_N_to_V();
    }
    else
    {
      strcpy(v0, "can nont get voltage\n");
      V_LOCK();
      logfmt_raw(&v1, 0x1000u, 0, v0);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
        95,
        "bitmain_get_voltage",
        19,
        467,
        100,
        &v1);
    }
  }
  else
  {
    snprintf(v0, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_voltage");
    V_LOCK();
    logfmt_raw(&v1, 0x1000u, 0, v0);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "bitmain_get_voltage",
      19,
      463,
      100,
      &v1);
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B8C0: using guessed type int dword_47B8C0;
// 47B8C4: using guessed type int dword_47B8C4;
// 47BE18: using guessed type int g_zc;

//----- (000F0610) --------------------------------------------------------
int bitmain_set_voltage()
{
  char v2[8]; // [sp+18h] [bp+8h] BYREF
  _BYTE v3[8]; // [sp+818h] [bp+808h] BYREF
  unsigned int v4; // [sp+1818h] [bp+1808h]
  int v5; // [sp+181Ch] [bp+180Ch]

  v5 = 0;
  v4 = 0;
  if ( dword_47B8C4 || (v5 = bitmain_power_open(), v5 >= 0) )
  {
    v4 = bitmain_convert_V_to_N();
    if ( v4 < 0x100 )
      return sub_EFC70(dword_47B8C0, v4);
    else
      return -2147482879;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage");
    V_LOCK();
    logfmt_raw(v3, 0x1000u, 0, v2);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "bitmain_set_voltage",
      19,
      479,
      100,
      v3);
    return v5;
  }
}
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B8C0: using guessed type int dword_47B8C0;
// 47B8C4: using guessed type int dword_47B8C4;
// 47BE18: using guessed type int g_zc;

//----- (000F0760) --------------------------------------------------------
int __fastcall bitmain_set_voltage_by_n(unsigned __int8 a1)
{
  char v4[4]; // [sp+1Ch] [bp+Ch] BYREF
  int v5; // [sp+81Ch] [bp+80Ch] BYREF
  int v6; // [sp+181Ch] [bp+180Ch]

  v6 = 0;
  if ( dword_47B8C4 )
    return sub_EFC70(dword_47B8C0, a1);
  v6 = bitmain_power_open();
  if ( v6 >= 0 )
    return sub_EFC70(dword_47B8C0, a1);
  snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage_by_n");
  V_LOCK();
  logfmt_raw(&v5, 0x1000u, 0, v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
    95,
    "bitmain_set_voltage_by_n",
    24,
    493,
    100,
    &v5);
  return v6;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B8C0: using guessed type int dword_47B8C0;
// 47B8C4: using guessed type int dword_47B8C4;
// 47BE18: using guessed type int g_zc;

//----- (000F0864) --------------------------------------------------------
void bitmain_convert_N_to_V_calibration()
{
  int i; // [sp+14h] [bp+14h]

  if ( dword_47B930 > 1 )
  {
    for ( i = 0; dword_47B930 - 1 > i; ++i )
      ;
  }
}
// 47B930: using guessed type int dword_47B930;

//----- (000F0978) --------------------------------------------------------
int bitmain_convert_V_to_N_calibration()
{
  double v0; // d0
  int i; // [sp+18h] [bp+18h]
  int v4; // [sp+1Ch] [bp+1Ch]

  v4 = -1;
  if ( dword_47B930 <= 1 )
    return -1;
  for ( i = 0; dword_47B930 - 1 > i; ++i )
  {
    if ( *((double *)&unk_47B8D0 + i + 2) <= v0 && *((double *)&unk_47B8D0 + i + 3) > v0
      || *((double *)&unk_47B8D0 + i + 2) > v0 && *((double *)&unk_47B8D0 + i + 3) <= v0 )
    {
      v4 = (int)((v0 - *((double *)&unk_47B8D0 + i + 2))
               * ((double)(*((unsigned __int8 *)&unk_47B8D0 + i + 1) - *((unsigned __int8 *)&unk_47B8D0 + i))
                / (*((double *)&unk_47B8D0 + i + 3) - *((double *)&unk_47B8D0 + i + 2)))
               + (double)*((unsigned __int8 *)&unk_47B8D0 + i));
    }
  }
  return v4;
}
// F09B8: variable 'v0' is possibly undefined
// 47B930: using guessed type int dword_47B930;

//----- (000F0ABC) --------------------------------------------------------
int bitmain_convert_V_to_N()
{
  double v0; // d0
  int v3; // [sp+1Ch] [bp+Ch] BYREF
  int v4; // [sp+101Ch] [bp+100Ch]

  v4 = bitmain_convert_V_to_N_calibration();
  V_LOCK();
  logfmt_raw(&v3, 0x1000u, 0, "N before calibration %d, N after calibration %d", (int)(1280.57782 - v0 * 73.979365), v4);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
    95,
    "bitmain_convert_V_to_N",
    22,
    547,
    60,
    &v3);
  if ( v4 > 0 )
    return v4;
  switch ( dword_47B8C8 )
  {
    case 'A':
      v4 = (int)(765.411764 - v0 * 35.833333);
      break;
    case 'B':
      v4 = (int)(765.411764 - v0 * 35.833333);
      break;
    case 'C':
      v4 = (int)(933.240365 - v0 * 59.806034);
      break;
    case 'a':
      v4 = (int)(1144.50226 - v0 * 52.243589);
      break;
    case 'q':
      v4 = (int)(1190.93534 - v0 * 78.742588);
      break;
    case 'r':
      v4 = (int)(1190.93534 - v0 * 78.742588);
      break;
    case 's':
      v4 = (int)(1280.57782 - v0 * 73.979365);
      break;
    default:
      v4 = -1;
      break;
  }
  return v4;
}
// F0B06: variable 'v0' is possibly undefined
// 20AAC: using guessed type int __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B8C8: using guessed type int dword_47B8C8;
// 47BE18: using guessed type int g_zc;

//----- (000F0E30) --------------------------------------------------------
void bitmain_convert_N_to_V()
{
  bitmain_convert_N_to_V_calibration();
}
// 47B8C8: using guessed type int dword_47B8C8;

//----- (000F10A8) --------------------------------------------------------
int __fastcall bitmain_power_read(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  int v4; // r3
  char v9[2048]; // [sp+1Ch] [bp+Ch] BYREF
  _BYTE v10[12]; // [sp+81Ch] [bp+80Ch] BYREF
  unsigned __int8 v11[52]; // [sp+181Ch] [bp+180Ch] BYREF
  int v12; // [sp+1850h] [bp+1840h] BYREF
  unsigned __int8 v13; // [sp+1854h] [bp+1844h]
  unsigned __int8 v14; // [sp+1855h] [bp+1845h]
  __int16 v15; // [sp+1856h] [bp+1846h]
  __int16 v16; // [sp+1858h] [bp+1848h]
  char v17; // [sp+185Ah] [bp+184Ah]
  char v18; // [sp+185Bh] [bp+184Bh]
  int v19; // [sp+185Ch] [bp+184Ch]
  unsigned __int8 i; // [sp+1863h] [bp+1853h]
  int v21; // [sp+1864h] [bp+1854h]
  _DWORD savedregs[4]; // [sp+1868h] [bp+1858h] BYREF

  v21 = 0;
  v18 = 6;
  v17 = 6;
  v12 = 101100117;
  memset(v11, 0, 0x32u);
  v19 = 5;
  v16 = a3 + a1 + 12;
  v13 = a1;
  v14 = a3;
  v15 = v16;
  i = 8;
  if ( dword_47B8C4 || (v21 = bitmain_power_open(), v21 >= 0) )
  {
    if ( sub_EF2B0(dword_47B8C0, (unsigned __int8 *)&v12, 8u, v11, a3 + 7) )
    {
      strcpy(v9, "set DA conversion N failed\n");
      V_LOCK();
      logfmt_raw(v10, 0x1000u, 0, v9);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
        95,
        "bitmain_power_read",
        18,
        649,
        100,
        v10);
      return -2147482880;
    }
    else
    {
      for ( i = 0; i < (unsigned int)a3; ++i )
      {
        v4 = v19++;
        *(_BYTE *)(i + a2) = *((_BYTE *)&savedregs[-19] + v4);
      }
      return v21;
    }
  }
  else
  {
    snprintf(v9, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_read");
    V_LOCK();
    logfmt_raw(v10, 0x1000u, 0, v9);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "bitmain_power_read",
      18,
      639,
      100,
      v10);
    return v21;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B8C0: using guessed type int dword_47B8C0;
// 47B8C4: using guessed type int dword_47B8C4;
// 47BE18: using guessed type int g_zc;

//----- (000F14B0) --------------------------------------------------------
int get_power_voltage_calibration_data()
{
  _BYTE v2[16]; // [sp+10h] [bp+0h] BYREF
  uint8_t v3[30]; // [sp+1010h] [bp+1000h] BYREF
  unsigned __int16 v4; // [sp+102Eh] [bp+101Eh]
  unsigned __int16 v5; // [sp+1032h] [bp+1022h]
  unsigned __int8 v6; // [sp+1035h] [bp+1025h]
  uint16_t v7; // [sp+1036h] [bp+1026h]
  _DWORD *v8; // [sp+1038h] [bp+1028h]
  int i; // [sp+103Ch] [bp+102Ch]
  _BYTE v10[4]; // [sp+1040h] [bp+1030h] BYREF

  v8 = &unk_47B8D0;
  bitmain_power_read(0x40u, (int)v3, 0x20u);
  v4 = HIBYTE(v4) | (v4 << 8);
  v7 = CRC16(v3, 0x1Eu);
  if ( v7 == v4 )
  {
    v8[24] = 0;
    for ( i = 0; i <= 9 && (v10[3 * i - 48] || v10[3 * i - 47] || v10[3 * i - 46]); ++i )
    {
      v6 = v10[3 * i - 47] >> 2;
      v5 = v10[3 * i - 47] & 3;
      v5 <<= 8;
      v5 |= (unsigned __int8)v10[3 * i - 46];
      *(double *)&v8[2 * i + 4] = (double)v6 + (double)v5 / 1000.0;
      *((_BYTE *)v8 + i) = v10[3 * i - 48];
      ++v8[24];
      V_LOCK();
      logfmt_raw(v2, 0x1000u, 0, "vol %f N %d", v8[2 * i + 4], v8[2 * i + 5], *((unsigned __int8 *)v8 + i));
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
        95,
        "get_power_voltage_calibration_data",
        34,
        697,
        60,
        v2);
    }
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "%s error!", "get_power_voltage_calibration_data");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/power/bitmain_power_APW9.c",
      95,
      "get_power_voltage_calibration_data",
      34,
      680,
      100,
      v2);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F1838) --------------------------------------------------------
int __fastcall set_chipaddr_base(int a1, int a2, int a3)
{
  char v4; // r0
  __int16 v9; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+16h] [bp+16h] BYREF
  char v11; // [sp+1Ah] [bp+1Ah]
  int i; // [sp+1Ch] [bp+1Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  (*(void (__fastcall **)(int))(a1 + 152))(a1);
  usleep(0x2710u);
  v9 = -21931;
  v11 = 0;
  v10 = 1344;
  for ( i = 0; i < a3; ++i )
  {
    usleep(0x2710u);
    BYTE2(v10) = *(_BYTE *)(i + a2);
    v4 = BM_CRC5(&v10, 8 * (BYTE1(v10) - 1));
    v11 = v11 & 0xE0 | v4 & 0x1F;
    send_command_packet(a1, (int)&v9, 7u);
  }
  return 0;
}

//----- (000F18F0) --------------------------------------------------------
int __fastcall set_inactive_base(int a1)
{
  char v2; // r0
  __int16 v5; // [sp+8h] [bp+8h] BYREF
  int v6; // [sp+Ah] [bp+Ah] BYREF
  char v7; // [sp+Eh] [bp+Eh]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v5 = -21931;
  v7 = 0;
  v6 = 1363;
  v2 = BM_CRC5(&v6, 0x20u);
  v7 = v7 & 0xE0 | v2 & 0x1F;
  send_command_packet(a1, (int)&v5, 7u);
  return 0;
}

//----- (000F197C) --------------------------------------------------------
int __fastcall set_chip_reg_base(int a1, int a2)
{
  char v3; // r0
  __int16 v6; // [sp+Ch] [bp+Ch] BYREF
  _WORD v7[5]; // [sp+Eh] [bp+Eh] BYREF

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v6 = -21931;
  memset(&v7[2], 0, 5);
  *(_DWORD *)v7 = 1;
  LOBYTE(v7[0]) = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1E | 0x41;
  HIBYTE(v7[0]) = 9;
  LOBYTE(v7[1]) = *(_BYTE *)(a2 + 9);
  HIBYTE(v7[1]) = *(_WORD *)(a2 + 10);
  *(_DWORD *)&v7[2] = reverse_byte_order_32(*(_DWORD *)a2);
  v3 = BM_CRC5(v7, 0x40u);
  LOBYTE(v7[4]) = v7[4] & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, (int)&v6, 0xBu);
  return 0;
}

//----- (000F1A30) --------------------------------------------------------
int __fastcall sync_get_status_unclear_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _DWORD v13[2]; // [sp+14h] [bp+14h] BYREF
  char v14[2]; // [sp+1Ch] [bp+1Ch] BYREF
  int v15; // [sp+1Eh] [bp+1Eh] BYREF
  char v16; // [sp+22h] [bp+22h]
  unsigned __int8 v17; // [sp+23h] [bp+23h]
  char v18; // [sp+25h] [bp+25h]
  int v19; // [sp+28h] [bp+28h]
  int v20; // [sp+2Ch] [bp+2Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  v20 = 0;
  v19 = 0;
  sub_1A3E94(a5, 0x3E8u);
  v13[1] = 1000000 * v6;
  v13[0] = sub_1A3E94(a5, 0x3E8u);
  while ( v20 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), v14, 0xAu, v13) == 110 )
    {
      v19 = 3;
      break;
    }
    if ( (unsigned __int8)v14[0] != 170 || v14[1] != 85 )
    {
      v19 = 1;
      break;
    }
    v7 = v18 & 0x1F;
    if ( v7 == BM_CRC5(&v15, 0x3Bu) )
    {
      *(_BYTE *)(a3 + 12 * v20 + 4) = v16;
      *(_WORD *)(a3 + 12 * v20 + 6) = v17;
      *(_DWORD *)(a3 + 12 * v20++) = v15;
    }
    else
    {
      v19 = 2;
    }
  }
  *a4 = v20;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v19;
}
// F1A88: variable 'v6' is possibly undefined

//----- (000F1B6C) --------------------------------------------------------
int __fastcall sync_get_status_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _BYTE v13[28]; // [sp+2Ch] [bp+14h] BYREF
  _DWORD v14[2]; // [sp+102Ch] [bp+1014h] BYREF
  unsigned __int8 v15; // [sp+1034h] [bp+101Ch] BYREF
  unsigned __int8 v16; // [sp+1035h] [bp+101Dh]
  int v17; // [sp+1036h] [bp+101Eh] BYREF
  unsigned __int8 v18; // [sp+103Ah] [bp+1022h]
  unsigned __int8 v19; // [sp+103Bh] [bp+1023h]
  char v20; // [sp+103Ch] [bp+1024h]
  int v21; // [sp+1040h] [bp+1028h]
  int v22; // [sp+1044h] [bp+102Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  v22 = 0;
  v21 = 0;
  sub_1A3E94(a5, 0x3E8u);
  v14[1] = 1000000 * v6;
  v14[0] = sub_1A3E94(a5, 0x3E8u);
  while ( v22 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), (char *)&v15, 9u, v14) == 110 )
    {
      v21 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(
      v13,
      0x1000u,
      0,
      "header:%02x%02x chip_addr:%02x, reg value:%08x, reg addr:%02x",
      v15,
      v16,
      v18,
      v17,
      v19);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_reg_io_base.c",
      76,
      "sync_get_status_base",
      20,
      261,
      20,
      v13);
    if ( v15 != 170 || v16 != 85 )
    {
      v21 = 1;
      break;
    }
    v7 = v20 & 0x1F;
    if ( v7 == BM_CRC5(&v17, 0x33u) )
    {
      *(_BYTE *)(a3 + 12 * v22 + 4) = v18;
      *(_WORD *)(a3 + 12 * v22 + 6) = v19;
      *(_DWORD *)(a3 + 12 * v22++) = v17;
    }
    else
    {
      v21 = 2;
    }
  }
  *a4 = v22;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v21;
}
// F1C1A: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F1E60) --------------------------------------------------------
int __fastcall sync_get_dag_base(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  unsigned int *v7; // r4
  __int16 *v8; // r4
  _DWORD *v9; // lr
  int v10; // r1
  int v11; // r2
  int v12; // r3
  _BYTE v18[28]; // [sp+24h] [bp+14h] BYREF
  _DWORD v19[2]; // [sp+1024h] [bp+1014h] BYREF
  unsigned __int8 v20; // [sp+102Ch] [bp+101Ch] BYREF
  unsigned __int8 v21; // [sp+102Dh] [bp+101Dh]
  unsigned __int8 v22; // [sp+102Eh] [bp+101Eh] BYREF
  unsigned __int8 v23; // [sp+102Fh] [bp+101Fh]
  unsigned int v24; // [sp+1030h] [bp+1020h]
  int v25; // [sp+1034h] [bp+1024h] BYREF
  unsigned __int16 v26; // [sp+1074h] [bp+1064h] BYREF
  unsigned __int16 v27; // [sp+1076h] [bp+1066h]
  int v28; // [sp+1078h] [bp+1068h]
  int v29; // [sp+107Ch] [bp+106Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  v29 = 0;
  v28 = 0;
  sub_1A3E94(a5, 0x3E8u);
  v19[1] = 1000000 * v6;
  v19[0] = sub_1A3E94(a5, 0x3E8u);
  while ( v29 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), (char *)&v20, 0x4Au, v19) == 110 )
    {
      v28 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(v18, 0x1000u, 0, "[DAG] header:%02x%02x chip_addr:%02x", v20, v21, v23);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_reg_io_base.c",
      76,
      "sync_get_dag_base",
      17,
      326,
      20,
      v18);
    if ( v20 != 170 || v21 != 85 )
    {
      v28 = 1;
      break;
    }
    v27 = CRC16_v1(&v22, 70);
    v27 = (v27 << 8) | HIBYTE(v27);
    if ( v27 == v26 )
    {
      *(_BYTE *)(a3 + 76 * v29 + 4) = v23;
      v7 = (unsigned int *)(a3 + 76 * v29);
      *v7 = reverse_byte_order_32(v24);
      v8 = (__int16 *)&v25;
      v9 = (_DWORD *)(a3 + 76 * v29 + 10);
      do
      {
        v10 = *((_DWORD *)v8 + 1);
        v11 = *((_DWORD *)v8 + 2);
        v12 = *((_DWORD *)v8 + 3);
        *v9 = *(_DWORD *)v8;
        v9[1] = v10;
        v9[2] = v11;
        v9[3] = v12;
        v8 += 8;
        v9 += 4;
      }
      while ( v8 != (__int16 *)&v26 );
      ++v29;
    }
    else
    {
      v28 = 2;
    }
  }
  *a4 = v29;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v28;
}
// F1F12: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F2188) --------------------------------------------------------
int __fastcall sync_get_chip_reg_base(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // r0
  __int16 v15; // [sp+18h] [bp+10h] BYREF
  int v16; // [sp+1Ah] [bp+12h] BYREF
  char v17; // [sp+1Eh] [bp+16h]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v15 = -21931;
  v17 = 0;
  v16 = 2;
  LOBYTE(v16) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 2;
  LOBYTE(v16) = v16 & 0x1F | 0x40;
  BYTE1(v16) = 5;
  BYTE2(v16) = *(_BYTE *)(a2 + 9);
  HIBYTE(v16) = *(_WORD *)(a2 + 10);
  v9 = BM_CRC5(&v16, 0x20u);
  v17 = v17 & 0xE0 | v9 & 0x1F;
  send_command_packet(a1, (int)&v15, 7u);
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  return (*(int (__fastcall **)(int, int, int, int, int, int))(a1 + 172))(a1, a3, a4, a5, a7, a8);
}

//----- (000F2258) --------------------------------------------------------
int __fastcall sync_get_dag_node_base(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  char v7; // r0
  __int16 v13; // [sp+1Ch] [bp+14h] BYREF
  __int64 v14; // [sp+1Eh] [bp+16h] BYREF
  void *s; // [sp+28h] [bp+20h]
  size_t nmemb; // [sp+2Ch] [bp+24h]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v13 = -21931;
  v14 = 6;
  LOBYTE(v14) = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x19 | 0x46;
  BYTE1(v14) = 8;
  BYTE2(v14) = *(_BYTE *)(a2 + 9);
  *(_DWORD *)((char *)&v14 + 3) = reverse_byte_order_32(*(_DWORD *)(a2 + 4));
  nmemb = 8;
  s = calloc(8u, 1u);
  memset(s, 0, 8u);
  memcpy(s, &v14, 7u);
  v7 = BM_CRC5(s, 8 * nmemb);
  HIBYTE(v14) = HIBYTE(v14) & 0xE0 | v7 & 0x1F;
  free(s);
  send_command_packet(a1, (int)&v13, 0xAu);
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  return sync_get_dag_base(a1, a3, a4, a5, a6);
}

//----- (000F2374) --------------------------------------------------------
int __fastcall set_core_reg_base(int a1, int a2)
{
  char v3; // r0
  __int16 v6; // [sp+Ch] [bp+Ch] BYREF
  _WORD v7[5]; // [sp+Eh] [bp+Eh] BYREF

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v6 = -21931;
  memset(&v7[2], 0, 6);
  *(_DWORD *)v7 = 4;
  LOBYTE(v7[0]) = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1B | 0x44;
  HIBYTE(v7[0]) = 10;
  LOBYTE(v7[1]) = *(_BYTE *)(a2 + 9);
  HIBYTE(v7[1]) = *(_WORD *)(a2 + 10);
  LOBYTE(v7[2]) = *(_BYTE *)(a2 + 12);
  *(_DWORD *)((char *)&v7[2] + 1) = reverse_byte_order_32(*(_DWORD *)a2);
  v3 = BM_CRC5(v7, 0x48u);
  HIBYTE(v7[4]) = HIBYTE(v7[4]) & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, (int)&v6, 0xCu);
  return 0;
}

//----- (000F242C) --------------------------------------------------------
int __fastcall set_core_reg_base_9(int a1, int a2)
{
  char v3; // r0
  __int16 v6; // [sp+Ch] [bp+Ch] BYREF
  int v7; // [sp+Eh] [bp+Eh] BYREF
  char v8; // [sp+12h] [bp+12h]
  int v9; // [sp+13h] [bp+13h]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v6 = -21931;
  v8 = 0;
  v9 = 0;
  v7 = 4;
  LOBYTE(v7) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 4;
  LOBYTE(v7) = v7 & 0x1F | 0x40;
  BYTE1(v7) = 9;
  BYTE2(v7) = *(_BYTE *)(a2 + 9);
  HIBYTE(v7) = *(_WORD *)(a2 + 10);
  v8 = *(_BYTE *)(a2 + 12);
  LOBYTE(v9) = BYTE2(*(_DWORD *)a2);
  BYTE1(v9) = BYTE1(*(_DWORD *)a2);
  BYTE2(v9) = *(_DWORD *)a2;
  v3 = BM_CRC5(&v7, 0x40u);
  HIBYTE(v9) = HIBYTE(v9) & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, (int)&v6, 0xBu);
  return 0;
}

//----- (000F24F0) --------------------------------------------------------
int __fastcall sync_get_core_reg_base_3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  int v15; // [sp+3Ch] [bp+1Ch] BYREF
  _DWORD v16[2]; // [sp+103Ch] [bp+101Ch] BYREF
  unsigned __int8 v17; // [sp+1044h] [bp+1024h] BYREF
  unsigned __int8 v18; // [sp+1045h] [bp+1025h]
  char v19; // [sp+1046h] [bp+1026h] BYREF
  unsigned __int8 v20; // [sp+1047h] [bp+1027h]
  unsigned __int8 v21; // [sp+1048h] [bp+1028h]
  unsigned __int8 v22; // [sp+1049h] [bp+1029h]
  unsigned __int8 v23; // [sp+104Ah] [bp+102Ah]
  unsigned __int8 v24; // [sp+104Bh] [bp+102Bh]
  char v25; // [sp+104Ch] [bp+102Ch]
  __int16 v26; // [sp+1050h] [bp+1030h] BYREF
  int v27; // [sp+1052h] [bp+1032h] BYREF
  __int16 v28; // [sp+1056h] [bp+1036h]
  int v29; // [sp+1058h] [bp+1038h]
  int v30; // [sp+105Ch] [bp+103Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v26 = -21931;
  v28 = 0;
  v27 = 5;
  LOBYTE(v27) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 5;
  LOBYTE(v27) = v27 & 0x1F | 0x40;
  BYTE1(v27) = 6;
  BYTE2(v27) = *(_BYTE *)(a2 + 9);
  HIBYTE(v27) = *(_WORD *)(a2 + 10);
  LOBYTE(v28) = *(_BYTE *)(a2 + 12);
  v7 = BM_CRC5(&v27, 0x28u);
  HIBYTE(v28) = HIBYTE(v28) & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  send_command_packet(a1, (int)&v26, 8u);
  v30 = 0;
  v29 = 0;
  sub_1A3E94(a6, 0x3E8u);
  v16[1] = 1000000 * v8;
  v16[0] = sub_1A3E94(a6, 0x3E8u);
  while ( v30 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), (char *)&v17, 9u, v16) == 110 )
    {
      v29 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(
      &v15,
      0x1000u,
      0,
      "core reg: %02x %02x chip addr %02x reg addr %02x reg value %02x%02x%02x",
      v17,
      v18,
      v23,
      v24,
      v20,
      v21,
      v22);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_reg_io_base.c",
      76,
      "sync_get_core_reg_base_3",
      24,
      588,
      20,
      &v15);
    if ( v17 != 170 || v18 != 85 || (v25 & 0x40) == 0 )
    {
      v29 = 1;
      break;
    }
    v9 = v25 & 0x1F;
    if ( v9 == BM_CRC5(&v19, 0x33u) )
    {
      *(_BYTE *)(a4 + 12 * v30 + 4) = v23;
      *(_WORD *)(a4 + 12 * v30 + 6) = v24;
      *(_BYTE *)(a4 + 12 * v30 + 8) = v19;
      *(_DWORD *)(a4 + 12 * v30++) = (v21 << 16) | (v22 << 24) | v20;
    }
    else
    {
      v29 = 2;
    }
  }
  *a5 = v30;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v29;
}
// F26E2: variable 'v8' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F29A0) --------------------------------------------------------
int __fastcall sync_get_core_reg_base(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _DWORD v15[2]; // [sp+14h] [bp+14h] BYREF
  char v16[2]; // [sp+1Ch] [bp+1Ch] BYREF
  _BYTE v17[2]; // [sp+1Eh] [bp+1Eh] BYREF
  int v18; // [sp+20h] [bp+20h]
  char v19; // [sp+24h] [bp+24h]
  unsigned __int8 v20; // [sp+25h] [bp+25h]
  char v21; // [sp+26h] [bp+26h]
  __int16 v22; // [sp+28h] [bp+28h] BYREF
  int v23; // [sp+2Ah] [bp+2Ah] BYREF
  __int16 v24; // [sp+2Eh] [bp+2Eh]
  int v25; // [sp+30h] [bp+30h]
  int v26; // [sp+34h] [bp+34h]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v22 = -21931;
  v24 = 0;
  v23 = 5;
  LOBYTE(v23) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 5;
  LOBYTE(v23) = v23 & 0x1F | 0x40;
  BYTE1(v23) = 6;
  BYTE2(v23) = *(_BYTE *)(a2 + 9);
  HIBYTE(v23) = *(_WORD *)(a2 + 10);
  LOBYTE(v24) = *(_BYTE *)(a2 + 12);
  v7 = BM_CRC5(&v23, 0x28u);
  HIBYTE(v24) = HIBYTE(v24) & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  send_command_packet(a1, (int)&v22, 8u);
  v26 = 0;
  v25 = 0;
  sub_1A3E94(a6, 0x3E8u);
  v15[1] = 1000000 * v8;
  v15[0] = sub_1A3E94(a6, 0x3E8u);
  while ( v26 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), v16, 0xBu, v15) == 110 )
    {
      v25 = 3;
      break;
    }
    if ( (unsigned __int8)v16[0] != 170 || v16[1] != 85 || v17[0] != 9 || (v21 & 0x40) == 0 )
    {
      v25 = 1;
      break;
    }
    v9 = v21 & 0x1F;
    if ( v9 == BM_CRC5(v17, 0x43u) )
    {
      *(_BYTE *)(a4 + 12 * v26 + 4) = v19;
      *(_WORD *)(a4 + 12 * v26 + 6) = v20;
      *(_BYTE *)(a4 + 12 * v26 + 8) = v17[1];
      *(_DWORD *)(a4 + 12 * v26++) = v18;
    }
    else
    {
      v25 = 2;
    }
  }
  *a5 = v26;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v25;
}
// F2AB8: variable 'v8' is possibly undefined

//----- (000F2BC0) --------------------------------------------------------
int __fastcall sync_get_status_base2(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _DWORD v13[2]; // [sp+14h] [bp+14h] BYREF
  char v14[2]; // [sp+1Ch] [bp+1Ch] BYREF
  _BYTE v15[3]; // [sp+1Eh] [bp+1Eh] BYREF
  int v16; // [sp+21h] [bp+21h]
  char v17; // [sp+25h] [bp+25h]
  int v18; // [sp+28h] [bp+28h]
  int v19; // [sp+2Ch] [bp+2Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  v19 = 0;
  v18 = 0;
  sub_1A3E94(a5, 0x3E8u);
  v13[1] = 1000000 * v6;
  v13[0] = sub_1A3E94(a5, 0x3E8u);
  while ( v19 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), v14, 0xAu, v13) == 110 )
    {
      v18 = 3;
      break;
    }
    if ( (unsigned __int8)v14[0] != 170 || v14[1] != 85 || (v15[0] & 0xF) != 0 || (v15[0] & 0xE0) != 0 )
    {
      v18 = 1;
      break;
    }
    v7 = v17 & 0x1F;
    if ( v7 == BM_CRC5(v15, 0x38u) )
    {
      *(_BYTE *)(a3 + 12 * v19 + 4) = v15[1];
      *(_WORD *)(a3 + 12 * v19 + 6) = v15[2];
      *(_DWORD *)(a3 + 12 * v19++) = v16;
    }
    else
    {
      v18 = 2;
    }
  }
  *a4 = v19;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v18;
}
// F2C24: variable 'v6' is possibly undefined

//----- (000F2D1C) --------------------------------------------------------
int __fastcall sync_get_chip_reg_base2(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  char v7; // r0
  __int16 v13; // [sp+18h] [bp+10h] BYREF
  int v14; // [sp+1Ah] [bp+12h] BYREF
  char v15; // [sp+1Eh] [bp+16h]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v13 = -21931;
  v15 = 0;
  v14 = 2;
  LOBYTE(v14) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 2;
  LOBYTE(v14) = v14 & 0x1F | 0x40;
  BYTE1(v14) = 5;
  BYTE2(v14) = *(_BYTE *)(a2 + 9);
  HIBYTE(v14) = *(_WORD *)(a2 + 10);
  v7 = BM_CRC5(&v14, 0x20u);
  v15 = v15 & 0xE0 | v7 & 0x1F;
  send_command_packet(a1, (int)&v13, 7u);
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  return sync_get_status_base2(a1, a3, a4, a5, a6);
}

//----- (000F2DE8) --------------------------------------------------------
int __fastcall set_core_reg_base2(int a1, int a2)
{
  char v3; // r0
  __int16 v7; // [sp+8h] [bp+8h] BYREF
  _BYTE v8[10]; // [sp+Ah] [bp+Ah] BYREF
  char v9; // [sp+14h] [bp+14h]
  void *s; // [sp+18h] [bp+18h]
  size_t nmemb; // [sp+1Ch] [bp+1Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v7 = -21931;
  *(_WORD *)&v8[4] = 0;
  *(_DWORD *)&v8[6] = 0;
  v9 = 0;
  *(_DWORD *)v8 = 4;
  v8[0] = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1B | 0x44;
  v8[1] = 11;
  v8[2] = *(_BYTE *)(a2 + 9);
  v8[3] = *(_BYTE *)(a2 + 12);
  *(_WORD *)&v8[4] = reverse_byte_order_16(*(_WORD *)(a2 + 10));
  *(_DWORD *)&v8[6] = reverse_byte_order_32(*(_DWORD *)a2);
  nmemb = 12;
  s = calloc(0xCu, 1u);
  memset(s, 0, 4u);
  memcpy(s, v8, 0xAu);
  v3 = BM_CRC5(s, 8 * nmemb);
  v9 = v9 & 0xE0 | v3 & 0x1F;
  free(s);
  send_command_packet(a1, (int)&v7, 0xDu);
  return 0;
}

//----- (000F2EE8) --------------------------------------------------------
int __fastcall sync_get_core_reg_base2(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _DWORD v15[2]; // [sp+10h] [bp+10h] BYREF
  char v16[2]; // [sp+18h] [bp+18h] BYREF
  _BYTE v17[3]; // [sp+1Ah] [bp+1Ah] BYREF
  __int16 v18; // [sp+1Dh] [bp+1Dh]
  int v19; // [sp+1Fh] [bp+1Fh]
  char v20; // [sp+23h] [bp+23h]
  __int16 v21; // [sp+24h] [bp+24h] BYREF
  _BYTE v22[6]; // [sp+26h] [bp+26h] BYREF
  char v23; // [sp+2Ch] [bp+2Ch]
  void *s; // [sp+30h] [bp+30h]
  size_t nmemb; // [sp+34h] [bp+34h]
  int v26; // [sp+38h] [bp+38h]
  int v27; // [sp+3Ch] [bp+3Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v21 = -21931;
  *(_WORD *)&v22[4] = 0;
  v23 = 0;
  *(_DWORD *)v22 = 5;
  v22[0] = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1A | 0x45;
  v22[1] = 7;
  v22[2] = *(_BYTE *)(a2 + 9);
  v22[3] = *(_BYTE *)(a2 + 12);
  *(_WORD *)&v22[4] = reverse_byte_order_16(*(_WORD *)(a2 + 10));
  nmemb = 8;
  s = calloc(8u, 1u);
  memset(s, 0, 4u);
  memcpy(s, v22, 6u);
  v7 = BM_CRC5(s, 8 * nmemb);
  v23 = v23 & 0xE0 | v7 & 0x1F;
  free(s);
  if ( *(_BYTE *)(a2 + 8) != 1 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  send_command_packet(a1, (int)&v21, 9u);
  v27 = 0;
  v26 = 0;
  sub_1A3E94(a6, 0x3E8u);
  v15[1] = 1000000 * v8;
  v15[0] = sub_1A3E94(a6, 0x3E8u);
  while ( v27 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), v16, 0xCu, v15) == 110 )
    {
      v26 = 3;
      break;
    }
    if ( (unsigned __int8)v16[0] != 170 || v16[1] != 85 || (v17[0] & 0xF) != 1 || (v17[0] & 0xE0) != 0 )
    {
      v26 = 1;
      break;
    }
    v9 = v20 & 0x1F;
    if ( v9 == BM_CRC5(v17, 0x48u) )
    {
      *(_BYTE *)(a4 + 12 * v27 + 4) = v17[1];
      *(_WORD *)(a4 + 12 * v27 + 6) = v18;
      *(_BYTE *)(a4 + 12 * v27 + 8) = v17[2];
      *(_DWORD *)(a4 + 12 * v27++) = v19;
    }
    else
    {
      v26 = 2;
    }
  }
  *a5 = v27;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v26;
}
// F304E: variable 'v8' is possibly undefined

//----- (000F315C) --------------------------------------------------------
int __fastcall set_core_enable_base(int a1, int *a2, __useconds_t a3)
{
  int v3; // r3
  int v4; // r3
  _BYTE v9[12]; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+1024h] [bp+1014h]
  int v11; // [sp+1028h] [bp+1018h]
  int i; // [sp+102Ch] [bp+101Ch]

  v11 = *a2;
  for ( i = 0; ; ++i )
  {
    v4 = i;
    if ( *((unsigned __int8 *)a2 + 13) <= i )
      break;
    if ( (i & 0x1F) == 0 )
    {
      *a2 = -1;
      if ( v11 )
        *a2 = 0;
      *((_WORD *)a2 + 5) += 4 * (i / 32);
    }
    *((_BYTE *)a2 + 12) = i;
    if ( v11 )
    {
      LOBYTE(v3) = i & 0x1F;
      if ( i <= 0 )
        v3 = -(-i & 0x1F);
      *a2 |= 1 << v3;
    }
    else
    {
      *a2 *= 2;
    }
    v10 = (*(int (__fastcall **)(int, int *))(a1 + 164))(a1, a2);
    if ( v10 < 0 )
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "%s failed, reg:%02x, core_id:%d",
        "set_core_enable_base",
        *((unsigned __int16 *)a2 + 5),
        i);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_reg_io_base.c",
        76,
        "set_core_enable_base",
        20,
        980,
        100,
        v9);
      return -1;
    }
    usleep(a3);
  }
  return v4;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F3380) --------------------------------------------------------
int __fastcall set_core_enable_base2(int a1, int a2, __useconds_t a3)
{
  int v5; // [sp+4h] [bp-Ch]
  _BYTE v9[24]; // [sp+20h] [bp+10h] BYREF
  int v10; // [sp+1020h] [bp+1010h] BYREF
  int v11; // [sp+102Ch] [bp+101Ch] BYREF
  int v12; // [sp+1030h] [bp+1020h]
  int i; // [sp+1034h] [bp+1024h]

  puts("set_core_enable_base2");
  for ( i = 0; *(unsigned __int8 *)(a2 + 13) > i; ++i )
  {
    if ( (i & 0x1F) == 0 )
      *(_WORD *)(a2 + 10) += i / 32;
    if ( *(unsigned __int8 *)(a2 + 13) > 1u )
      *(_BYTE *)(a2 + 12) = i;
    v12 = (*(int (__fastcall **)(int, int))(a1 + 164))(a1, a2);
    if ( v12 < 0 )
    {
      V_LOCK();
      logfmt_raw(
        v9,
        0x1000u,
        0,
        "%s failed, reg:%02x, core_id:%d",
        "set_core_enable_base2",
        *(unsigned __int16 *)(a2 + 10),
        i);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_reg_io_base.c",
        76,
        "set_core_enable_base2",
        21,
        999,
        100,
        v9);
      return 3;
    }
    usleep(a3);
    v11 = 0;
    (*(void (__fastcall **)(int, int, int, int *, int *, int, int, _DWORD))(a1 + 184))(
      a1,
      a2,
      1,
      &v10,
      &v11,
      v5,
      2000,
      0);
  }
  return 0;
}
// F351C: variable 'v5' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F355C) --------------------------------------------------------
int __fastcall sync_get_status_base3(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _BYTE v13[28]; // [sp+2Ch] [bp+14h] BYREF
  _DWORD v14[2]; // [sp+102Ch] [bp+1014h] BYREF
  unsigned __int8 v15; // [sp+1034h] [bp+101Ch] BYREF
  unsigned __int8 v16; // [sp+1035h] [bp+101Dh]
  char v17; // [sp+1036h] [bp+101Eh] BYREF
  int v18; // [sp+1037h] [bp+101Fh]
  unsigned __int8 v19; // [sp+103Bh] [bp+1023h]
  unsigned __int8 v20; // [sp+103Ch] [bp+1024h]
  char v21; // [sp+103Dh] [bp+1025h]
  int v22; // [sp+1040h] [bp+1028h]
  int v23; // [sp+1044h] [bp+102Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  v23 = 0;
  v22 = 0;
  sub_1A3E94(a5, 0x3E8u);
  v14[1] = 1000000 * v6;
  v14[0] = sub_1A3E94(a5, 0x3E8u);
  while ( v23 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), (char *)&v15, 0xAu, v14) == 110 )
    {
      v22 = 3;
      break;
    }
    V_LOCK();
    logfmt_raw(
      v13,
      0x1000u,
      0,
      "header:%02x%02x chip_addr:%02x, reg value:%08x, reg addr:%02x",
      v15,
      v16,
      v19,
      v18,
      v20);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_reg_io_base.c",
      76,
      "sync_get_status_base3",
      21,
      1047,
      20,
      v13);
    if ( v15 != 170 || v16 != 85 || v17 != 8 || (v21 & 0x40) != 0 )
    {
      v22 = 1;
      break;
    }
    v7 = v21 & 0x1F;
    if ( v7 == BM_CRC5(&v17, 0x3Bu) )
    {
      *(_BYTE *)(a3 + 12 * v23 + 4) = v19;
      *(_WORD *)(a3 + 12 * v23 + 6) = v20;
      *(_DWORD *)(a3 + 12 * v23++) = v18;
    }
    else
    {
      v22 = 2;
    }
  }
  *a4 = v23;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v22;
}
// F360A: variable 'v6' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F3888) --------------------------------------------------------
int __fastcall sync_get_core_reg_base3(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _DWORD v15[2]; // [sp+14h] [bp+14h] BYREF
  char v16[2]; // [sp+1Ch] [bp+1Ch] BYREF
  _BYTE v17[7]; // [sp+1Eh] [bp+1Eh] BYREF
  char v18; // [sp+25h] [bp+25h]
  __int16 v19; // [sp+28h] [bp+28h] BYREF
  int v20; // [sp+2Ah] [bp+2Ah] BYREF
  __int16 v21; // [sp+2Eh] [bp+2Eh]
  int v22; // [sp+30h] [bp+30h]
  int v23; // [sp+34h] [bp+34h]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v19 = -21931;
  v21 = 0;
  v20 = 5;
  LOBYTE(v20) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 5;
  LOBYTE(v20) = v20 & 0x1F | 0x40;
  BYTE1(v20) = 6;
  BYTE2(v20) = *(_BYTE *)(a2 + 9);
  HIBYTE(v20) = *(_WORD *)(a2 + 10);
  LOBYTE(v21) = *(_BYTE *)(a2 + 12);
  v7 = BM_CRC5(&v20, 0x28u);
  HIBYTE(v21) = HIBYTE(v21) & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 && *(unsigned __int8 *)(a2 + 12) != 255 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  send_command_packet(a1, (int)&v19, 8u);
  v23 = 0;
  v22 = 0;
  sub_1A3E94(a6, 0x3E8u);
  v15[1] = 1000000 * v8;
  v15[0] = sub_1A3E94(a6, 0x3E8u);
  while ( v23 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), v16, 0xAu, v15) == 110 )
    {
      v22 = 3;
      break;
    }
    if ( (unsigned __int8)v16[0] != 170 || v16[1] != 85 || v17[0] != 8 || (v18 & 0x40) == 0 || v18 < 0 )
    {
      v22 = 1;
      break;
    }
    v9 = v18 & 0x1F;
    if ( v9 == BM_CRC5(v17, 0x3Bu) )
    {
      *(_BYTE *)(a4 + 12 * v23 + 4) = v17[5];
      *(_WORD *)(a4 + 12 * v23 + 6) = v17[6];
      *(_BYTE *)(a4 + 12 * v23 + 8) = v17[1];
      *(_DWORD *)(a4 + 12 * v23++) = (v17[3] << 8) | (v17[2] << 16) | v17[4];
    }
    else
    {
      v22 = 2;
    }
  }
  *a5 = v23;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v22;
}
// F39A0: variable 'v8' is possibly undefined

//----- (000F3AC8) --------------------------------------------------------
int __fastcall get_fake_regio_runtime(int a1)
{
  _UNKNOWN **v1; // r0
  int v2; // r4

  if ( !dword_47B938[a1] )
  {
    dword_47B938[a1] = calloc(1u, 0x310u);
    *(_DWORD *)(dword_47B938[a1] + 136) = a1;
    v1 = dev_ctrl();
    ((void (__fastcall *)(int))v1[1])(a1);
    pthread_mutex_init((pthread_mutex_t *)(dword_47B938[a1] + 688), 0);
    pthread_mutex_init((pthread_mutex_t *)(dword_47B938[a1] + 712), 0);
    v2 = dword_47B938[a1];
    *(_DWORD *)(v2 + 664) = queue_new(1, 0);
    *(_DWORD *)(dword_47B938[a1] + 656) = *(_DWORD *)(dword_47B938[a1] + 664);
    *(_DWORD *)(dword_47B938[a1] + 148) = set_chipaddr_base;
    *(_DWORD *)(dword_47B938[a1] + 152) = set_inactive_base;
    *(_DWORD *)(dword_47B938[a1] + 156) = set_chip_reg_base;
    *(_DWORD *)(dword_47B938[a1] + 160) = set_core_reg_base;
    *(_DWORD *)(dword_47B938[a1] + 176) = sync_get_chip_reg_base;
    *(_DWORD *)(dword_47B938[a1] + 184) = sync_get_core_reg_base;
    *(_BYTE *)(dword_47B938[a1] + 144) = 1;
  }
  return dword_47B938[a1];
}
// 47B938: using guessed type _DWORD dword_47B938[256];

//----- (000F3C5C) --------------------------------------------------------
int __fastcall set_chipaddr_by_id(int a1, int a2, int a3)
{
  int v3; // r3
  int v7; // [sp+14h] [bp+14h] BYREF
  int fake_regio_runtime; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]
  _DWORD *all_created_runtime; // [sp+20h] [bp+20h]
  int v11; // [sp+24h] [bp+24h]
  int v12; // [sp+28h] [bp+28h]
  int v13; // [sp+2Ch] [bp+2Ch]

  v12 = a1;
  v11 = a1;
  v7 = 0;
  all_created_runtime = get_all_created_runtime(&v7);
  for ( i = 0; i < v7; ++i )
  {
    if ( v11 == *(_DWORD *)(all_created_runtime[i] + 136) )
    {
      v3 = all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v3 = 0;
LABEL_7:
  fake_regio_runtime = v3;
  if ( !v3 )
    fake_regio_runtime = get_fake_regio_runtime(v12);
  v13 = fake_regio_runtime;
  return (*(int (__fastcall **)(int, int, int))(fake_regio_runtime + 148))(fake_regio_runtime, a2, a3);
}

//----- (000F3CE4) --------------------------------------------------------
int __fastcall set_inactive_by_id(int a1)
{
  int v1; // r3
  int v3; // [sp+Ch] [bp+Ch] BYREF
  int fake_regio_runtime; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]
  _DWORD *all_created_runtime; // [sp+18h] [bp+18h]
  int v7; // [sp+1Ch] [bp+1Ch]
  int v8; // [sp+20h] [bp+20h]
  int v9; // [sp+24h] [bp+24h]

  v8 = a1;
  v7 = a1;
  v3 = 0;
  all_created_runtime = get_all_created_runtime(&v3);
  for ( i = 0; i < v3; ++i )
  {
    if ( v7 == *(_DWORD *)(all_created_runtime[i] + 136) )
    {
      v1 = all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v1 = 0;
LABEL_7:
  fake_regio_runtime = v1;
  if ( !v1 )
    fake_regio_runtime = get_fake_regio_runtime(v8);
  v9 = fake_regio_runtime;
  return (*(int (__fastcall **)(int))(fake_regio_runtime + 152))(fake_regio_runtime);
}

//----- (000F3D64) --------------------------------------------------------
int __fastcall set_chip_reg_by_id(int a1, int a2)
{
  int v2; // r3
  int v5; // [sp+Ch] [bp+Ch] BYREF
  int fake_regio_runtime; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]
  _DWORD *all_created_runtime; // [sp+18h] [bp+18h]
  int v9; // [sp+1Ch] [bp+1Ch]
  int v10; // [sp+20h] [bp+20h]
  int v11; // [sp+24h] [bp+24h]

  v10 = a1;
  v9 = a1;
  v5 = 0;
  all_created_runtime = get_all_created_runtime(&v5);
  for ( i = 0; i < v5; ++i )
  {
    if ( v9 == *(_DWORD *)(all_created_runtime[i] + 136) )
    {
      v2 = all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v2 = 0;
LABEL_7:
  fake_regio_runtime = v2;
  if ( !v2 )
    fake_regio_runtime = get_fake_regio_runtime(v10);
  v11 = fake_regio_runtime;
  return (*(int (__fastcall **)(int, int))(fake_regio_runtime + 156))(fake_regio_runtime, a2);
}

//----- (000F3DE8) --------------------------------------------------------
int __fastcall set_core_reg_by_id(int a1, int a2)
{
  int v2; // r3
  int v5; // [sp+Ch] [bp+Ch] BYREF
  int fake_regio_runtime; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]
  _DWORD *all_created_runtime; // [sp+18h] [bp+18h]
  int v9; // [sp+1Ch] [bp+1Ch]
  int v10; // [sp+20h] [bp+20h]
  int v11; // [sp+24h] [bp+24h]

  v10 = a1;
  v9 = a1;
  v5 = 0;
  all_created_runtime = get_all_created_runtime(&v5);
  for ( i = 0; i < v5; ++i )
  {
    if ( v9 == *(_DWORD *)(all_created_runtime[i] + 136) )
    {
      v2 = all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v2 = 0;
LABEL_7:
  fake_regio_runtime = v2;
  if ( !v2 )
    fake_regio_runtime = get_fake_regio_runtime(v10);
  v11 = fake_regio_runtime;
  return (*(int (__fastcall **)(int, int))(fake_regio_runtime + 160))(fake_regio_runtime, a2);
}

//----- (000F3E6C) --------------------------------------------------------
int __fastcall sync_get_chip_reg_by_id(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // r3
  int v10; // [sp+20h] [bp+10h] BYREF
  _DWORD *fake_regio_runtime; // [sp+24h] [bp+14h]
  int i; // [sp+28h] [bp+18h]
  _DWORD *all_created_runtime; // [sp+2Ch] [bp+1Ch]
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  int v16; // [sp+38h] [bp+28h]
  void *arg; // [sp+3Ch] [bp+2Ch]

  v15 = a1;
  v14 = a1;
  v10 = 0;
  all_created_runtime = get_all_created_runtime(&v10);
  for ( i = 0; i < v10; ++i )
  {
    if ( v14 == *(_DWORD *)(all_created_runtime[i] + 136) )
    {
      v5 = (_DWORD *)all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v5 = 0;
LABEL_7:
  fake_regio_runtime = v5;
  if ( !v5 )
    fake_regio_runtime = (_DWORD *)get_fake_regio_runtime(v15);
  arg = fake_regio_runtime;
  if ( fake_regio_runtime[164] == fake_regio_runtime[166] )
    pthread_create((pthread_t *)arg + 169, 0, (void *(*)(void *))get_response, arg);
  v16 = (*((int (__fastcall **)(void *, int, int, int, int))arg + 44))(arg, a2, a3, a4, a5);
  if ( *((_DWORD *)arg + 164) == *((_DWORD *)arg + 166) )
  {
    *((_BYTE *)arg + 685) = 1;
    pthread_join(*((_DWORD *)arg + 169), 0);
  }
  return v16;
}

//----- (000F3F50) --------------------------------------------------------
int __fastcall sync_get_core_reg_by_id(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // r3
  int v10; // [sp+20h] [bp+10h] BYREF
  _DWORD *fake_regio_runtime; // [sp+24h] [bp+14h]
  int i; // [sp+28h] [bp+18h]
  _DWORD *all_created_runtime; // [sp+2Ch] [bp+1Ch]
  int v14; // [sp+30h] [bp+20h]
  int v15; // [sp+34h] [bp+24h]
  int v16; // [sp+38h] [bp+28h]
  void *arg; // [sp+3Ch] [bp+2Ch]

  v15 = a1;
  v14 = a1;
  v10 = 0;
  all_created_runtime = get_all_created_runtime(&v10);
  for ( i = 0; i < v10; ++i )
  {
    if ( v14 == *(_DWORD *)(all_created_runtime[i] + 136) )
    {
      v5 = (_DWORD *)all_created_runtime[i];
      goto LABEL_7;
    }
  }
  v5 = 0;
LABEL_7:
  fake_regio_runtime = v5;
  if ( !v5 )
    fake_regio_runtime = (_DWORD *)get_fake_regio_runtime(v15);
  arg = fake_regio_runtime;
  if ( fake_regio_runtime[164] == fake_regio_runtime[166] )
    pthread_create((pthread_t *)arg + 169, 0, (void *(*)(void *))get_response, arg);
  v16 = (*((int (__fastcall **)(void *, int, int, int, int))arg + 46))(arg, a2, a3, a4, a5);
  if ( *((_DWORD *)arg + 164) == *((_DWORD *)arg + 166) )
  {
    *((_BYTE *)arg + 685) = 1;
    pthread_join(*((_DWORD *)arg + 169), 0);
  }
  return v16;
}

//----- (000F4034) --------------------------------------------------------
unsigned int __fastcall sub_F4034(unsigned int a1)
{
  return bswap32(a1);
}

//----- (000F404C) --------------------------------------------------------
int __fastcall reverse_byte_order_16(unsigned __int16 a1)
{
  return (unsigned __int16)__rev16(a1);
}

//----- (000F406C) --------------------------------------------------------
unsigned int __fastcall reverse_byte_order_32(unsigned int a1)
{
  return sub_F4034(a1);
}

//----- (000F4084) --------------------------------------------------------
int __fastcall send_command_packet(int a1, int a2, unsigned int a3)
{
  _UNKNOWN **v3; // r0
  _UNKNOWN **v4; // r0
  int v9; // [sp+24h] [bp+14h] BYREF
  int v10; // [sp+1024h] [bp+1014h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 712));
  v10 = 0;
  while ( 1 )
  {
    v3 = dev_ctrl();
    if ( ((int (__fastcall *)(_DWORD))v3[14])(*(_DWORD *)(a1 + 136)) >= a3 )
      break;
    usleep(0x2710u);
  }
  v4 = dev_ctrl();
  v10 = ((int (__fastcall *)(_DWORD, int, unsigned int))v4[12])(*(_DWORD *)(a1 + 136), a2, a3);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 712));
  if ( v10 <= 0 )
  {
    V_LOCK();
    logfmt_raw(&v9, 0x1000u, 0, "device %d send cmd failed,errcode %d \n", *(_DWORD *)(a1 + 136), v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/chip_reg_io_interface.c",
      81,
      "send_command_packet",
      19,
      44,
      100,
      &v9);
  }
  return v10;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F41C8) --------------------------------------------------------
int __fastcall convert_offset_to_chain_id(int a1)
{
  return g_chain_info[2 * a1];
}
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F41EC) --------------------------------------------------------
int scan_miner_device_hal()
{
  return total_chain;
}
// 47BD38: using guessed type int total_chain;

//----- (000F4204) --------------------------------------------------------
int __fastcall dev_init_hal(int a1)
{
  _BYTE v4[16]; // [sp+18h] [bp+8h] BYREF
  unsigned __int8 v5; // [sp+101Bh] [bp+100Bh] BYREF
  unsigned int hash_on_plug; // [sp+1020h] [bp+1010h]
  unsigned int i; // [sp+1024h] [bp+1014h]

  if ( platform_init() )
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "platform init failed!\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
      86,
      "dev_init_hal",
      12,
      52,
      100,
      v4);
    return -1;
  }
  else
  {
    total_chain = 0;
    hash_on_plug = get_hash_on_plug();
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( ((hash_on_plug >> i) & 1) != 0 )
      {
        g_chain_info[2 * total_chain] = i;
        LOBYTE(g_chain_info[2 * total_chain + 1]) = 1;
        V_LOCK();
        logfmt_raw(v4, 0x1000u, 0, "chain_offset %d, chain %d", total_chain, g_chain_info[2 * total_chain]);
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
          86,
          "dev_init_hal",
          12,
          62,
          60,
          v4);
        if ( open_pic(i) < 0 )
        {
          V_LOCK();
          logfmt_raw(
            v4,
            0x1000u,
            0,
            "chain_offset %d, chain %d, open pic error!",
            total_chain,
            g_chain_info[2 * total_chain]);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
            86,
            "dev_init_hal",
            12,
            65,
            100,
            v4);
          return -1;
        }
        pic1704_reset(i);
        usleep(0x493E0u);
        pic1704_jump_to_app(i);
        usleep(0x493E0u);
        if ( a1 != 7 )
        {
          if ( !pic1704_get_sw_version(g_chain_info[2 * total_chain], &v5) )
          {
            V_LOCK();
            logfmt_raw(
              v4,
              0x1000u,
              0,
              "chain_offset %d, chain %d, get_sw_version error!",
              total_chain,
              g_chain_info[2 * total_chain]);
            V_UNLOCK();
            zlog(
              g_zc,
              "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
              86,
              "dev_init_hal",
              12,
              77,
              100,
              v4);
            return -1;
          }
          V_LOCK();
          logfmt_raw(
            v4,
            0x1000u,
            0,
            "chain_offset %d, chain %d, pic firmware verion = 0x%02x",
            total_chain,
            g_chain_info[2 * total_chain],
            v5);
          V_UNLOCK();
          zlog(
            g_zc,
            "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
            86,
            "dev_init_hal",
            12,
            83,
            60,
            v4);
        }
        ++total_chain;
      }
    }
    enable_bypass_mode();
    dev_config_hal(115200);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BD38: using guessed type int total_chain;
// 47BE18: using guessed type int g_zc;
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F45F0) --------------------------------------------------------
int dev_init_hal_pcba()
{
  _BYTE v2[8]; // [sp+10h] [bp+0h] BYREF
  unsigned int hash_on_plug; // [sp+1010h] [bp+1000h]
  unsigned int i; // [sp+1014h] [bp+1004h]

  if ( platform_init() )
  {
    V_LOCK();
    logfmt_raw(v2, 0x1000u, 0, "platform init failed!\n");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
      86,
      "dev_init_hal_pcba",
      17,
      102,
      100,
      v2);
    return -1;
  }
  else
  {
    total_chain = 0;
    hash_on_plug = get_hash_on_plug();
    printf("plug_on_status: %x\n", hash_on_plug);
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( ((hash_on_plug >> i) & 1) != 0 )
      {
        g_chain_info[2 * total_chain] = i;
        LOBYTE(g_chain_info[2 * total_chain + 1]) = 1;
        printf("chain_offset %d, chain %d\n", total_chain, g_chain_info[2 * total_chain]);
        ++total_chain;
      }
    }
    enable_bypass_mode();
    dev_config_hal(115200);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BD38: using guessed type int total_chain;
// 47BE18: using guessed type int g_zc;
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F476C) --------------------------------------------------------
int __fastcall dev_init_pic_for_one_chain(int a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( LOBYTE(g_chain_info[2 * a1 + 1]) != 1 )
  {
    printf("Chain offset %d is invalid\n", a1);
    return -1;
  }
  else if ( open_pic(g_chain_info[2 * a1]) >= 0 )
  {
    if ( pic1704_reset(g_chain_info[2 * a1]) )
    {
      usleep(0x493E0u);
      if ( pic1704_jump_to_app(g_chain_info[2 * a1]) )
      {
        usleep(0x493E0u);
        return 0;
      }
      else
      {
        printf("chain_offset %d, chain %, pic jump to app error!", total_chain, g_chain_info[2 * total_chain]);
        return -1;
      }
    }
    else
    {
      printf("chain_offset %d, chain %, reset pic error!", total_chain, g_chain_info[2 * total_chain]);
      return -1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v4, 0x1000u, 0, "chain_offset %d, chain %, open pic error!", total_chain, g_chain_info[2 * total_chain]);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
      86,
      "dev_init_pic_for_one_chain",
      26,
      132,
      100,
      v4);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BD38: using guessed type int total_chain;
// 47BE18: using guessed type int g_zc;
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F4928) --------------------------------------------------------
int __fastcall sub_dev_init_hal(unsigned int a1)
{
  if ( a1 >= total_chain )
    puts("warning: get pcie fd error");
  return g_chain_info[2 * a1];
}
// 47BD38: using guessed type int total_chain;
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F4964) --------------------------------------------------------
int __fastcall dev_is_valid_hal(int a1)
{
  return LOBYTE(g_chain_info[2 * a1 + 1]);
}
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F4988) --------------------------------------------------------
int __fastcall set_dev_invalid_hal(int result)
{
  LOBYTE(g_chain_info[2 * result + 1]) = 0;
  --total_chain;
  return result;
}
// 47BD38: using guessed type int total_chain;
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F49C4) --------------------------------------------------------
int __fastcall dev_config_hal(int a1)
{
  int v2; // [sp+8h] [bp+8h] BYREF
  int v3; // [sp+Ch] [bp+Ch]

  if ( a1 == 1562500 )
    goto LABEL_21;
  if ( a1 <= 1562500 )
  {
    if ( a1 == 460800 )
    {
      v3 = 6;
      goto LABEL_26;
    }
    if ( a1 <= 460800 )
    {
      if ( a1 != 115200 )
        goto LABEL_25;
      v3 = 26;
      goto LABEL_26;
    }
    if ( a1 == 921600 )
    {
      v3 = 2;
      goto LABEL_26;
    }
    if ( a1 != 1500000 )
      goto LABEL_25;
LABEL_21:
    v3 = 1;
    goto LABEL_26;
  }
  if ( a1 == 6250000 )
  {
    v3 = 3;
  }
  else if ( a1 > 6250000 )
  {
    if ( a1 == 12500000 )
    {
      v3 = 4;
    }
    else
    {
      if ( a1 != 25000000 )
      {
LABEL_25:
        v3 = 26;
        goto LABEL_26;
      }
      v3 = 5;
    }
  }
  else
  {
    if ( (_UNKNOWN *)a1 != &unk_2DC6C0 && (char *)a1 != byte_2FAF08 )
      goto LABEL_25;
    v3 = 0;
  }
LABEL_26:
  printf("%s: set zynq bt8d %d\n", "dev_config_hal", v3);
  v2 = v3 | (v3 << 24) | (v3 << 16) | (v3 << 8);
  uart_set_config(0, 0, &v2);
  usleep((__useconds_t)&stru_1869C.st_value);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000F4AE0) --------------------------------------------------------
int __fastcall dev_config_one_chain_baud(int a1, int a2)
{
  _BYTE v5[4]; // [sp+Ch] [bp+Ch] BYREF
  int v6; // [sp+10h] [bp+10h] BYREF
  int v7; // [sp+14h] [bp+14h]

  uart_get_config(0, 0, &v6, (int)v5);
  printf("%s: get zynq bt8d %08x\n", "dev_config_one_chain_baud", v6);
  if ( a2 == 1562500 )
    goto LABEL_21;
  if ( a2 <= 1562500 )
  {
    if ( a2 == 460800 )
    {
      v7 = 6;
      goto LABEL_26;
    }
    if ( a2 <= 460800 )
    {
      if ( a2 != 115200 )
        goto LABEL_25;
      v7 = 26;
      goto LABEL_26;
    }
    if ( a2 == 921600 )
    {
      v7 = 2;
      goto LABEL_26;
    }
    if ( a2 != 1500000 )
      goto LABEL_25;
LABEL_21:
    v7 = 1;
    goto LABEL_26;
  }
  if ( a2 == 6250000 )
  {
    v7 = 3;
  }
  else if ( a2 > 6250000 )
  {
    if ( a2 == 12500000 )
    {
      v7 = 4;
    }
    else
    {
      if ( a2 != 25000000 )
      {
LABEL_25:
        v7 = 26;
        goto LABEL_26;
      }
      v7 = 5;
    }
  }
  else
  {
    if ( (_UNKNOWN *)a2 != &unk_2DC6C0 && (char *)a2 != byte_2FAF08 )
      goto LABEL_25;
    v7 = 0;
  }
LABEL_26:
  printf("%s: set zynq bt8d %d\n", "dev_config_one_chain_baud", v7);
  v6 = v6 & ~(63 << (8 * a1)) | (v7 << (8 * a1));
  uart_set_config(a1, 0, &v6);
  usleep((__useconds_t)&stru_1869C.st_value);
  uart_get_config(0, 0, &v6, (int)v5);
  printf("%s: after set baud, get zynq bt8d %08x\n", "dev_config_one_chain_baud", v6);
  return 0;
}
// 1869C: using guessed type Elf32_Sym stru_1869C;

//----- (000F4C58) --------------------------------------------------------
int __fastcall dump_log_hal(const char *a1, int a2, int a3, int a4)
{
  int i; // [sp+14h] [bp+14h]

  printf("%s[%d] ", a1, a2);
  for ( i = 0; i < a4; ++i )
    printf("%02x ", *(unsigned __int8 *)(i + a3));
  return putchar(10);
}

//----- (000F4CB0) --------------------------------------------------------
size_t __fastcall dev_send_work_cmd_hal(int a1, int a2, unsigned int a3)
{
  int v7; // [sp+10h] [bp+10h]
  unsigned int i; // [sp+14h] [bp+14h]

  v7 = 0;
  for ( i = 0; a3 >> 7 > i; ++i )
  {
    v7 += uart_send(g_chain_info[2 * a1], (const void *)(a2 + (i << 7)), 0x80u);
    usleep(0x1F4u);
  }
  return v7 + uart_send(g_chain_info[2 * a1], (const void *)(a2 + (i << 7)), a3 & 0x7F);
}
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F4D40) --------------------------------------------------------
size_t __fastcall dev_send_reg_cmd_hal(int a1, const void *a2, size_t a3)
{
  return uart_send(g_chain_info[2 * a1], a2, a3);
}
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F4D70) --------------------------------------------------------
int __fastcall dev_read_nonce_reg_data_hal(int a1, int a2, unsigned int a3)
{
  return uart_receive(g_chain_info[2 * a1], a2, a3);
}
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F4DA4) --------------------------------------------------------
int dev_get_nonce_reg_fifo_size_hal()
{
  return 0;
}

//----- (000F4DBC) --------------------------------------------------------
int dev_get_reg_fifo_capacity_hal()
{
  return 0x10000;
}

//----- (000F4DD4) --------------------------------------------------------
int dev_get_work_fifo_capacity_hal()
{
  return 0x10000;
}

//----- (000F4DEC) --------------------------------------------------------
int dev_dma_rw_dispatcher_hal()
{
  return 0;
}

//----- (000F4E04) --------------------------------------------------------
int dev_exit_hal()
{
  uart_uninit();
  fpga_uninit();
  platform_uninit();
  return 0;
}

//----- (000F4E1C) --------------------------------------------------------
int __fastcall power_on_hal(int a1, unsigned __int16 a2, int a3)
{
  _BYTE v8[12]; // [sp+24h] [bp+14h] BYREF
  int v9; // [sp+1024h] [bp+1014h]
  int v10; // [sp+1028h] [bp+1018h]
  int i; // [sp+102Ch] [bp+101Ch]

  v10 = 0;
  i = 0;
  v9 = 2;
  chain_reset_low(g_chain_info[2 * a1]);
  usleep(0x493E0u);
  v10 = pic1704_reset(g_chain_info[2 * a1]);
  usleep(0x493E0u);
  v10 += pic1704_jump_to_app(g_chain_info[2 * a1]);
  usleep(0x493E0u);
  if ( !a3 )
    set_chain_isl_voltage(g_chain_info[2 * a1], a2);
  v10 += pic1704_enable_disable_dc_dc(g_chain_info[2 * a1], 1);
  if ( v10 == 3 )
  {
    usleep(0x493E0u);
    chain_reset_high(g_chain_info[2 * a1]);
    for ( i = 0; i < v9; ++i )
    {
      usleep(0x493E0u);
      chain_reset_low(g_chain_info[2 * a1]);
      usleep(0xF4240u);
      chain_reset_high(g_chain_info[2 * a1]);
    }
    usleep(0x493E0u);
    return 0;
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "chain %d, pic init failed, err:%d!!!", g_chain_info[2 * a1], v10);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
      86,
      "power_on_hal",
      12,
      369,
      100,
      v8);
    return -1;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F50C4) --------------------------------------------------------
int __fastcall power_off_hal(int a1)
{
  pic1704_enable_disable_dc_dc(g_chain_info[2 * a1], 0);
  usleep(0x493E0u);
  return 0;
}
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F50FC) --------------------------------------------------------
int hardreset_hal()
{
  return 0;
}

//----- (000F5114) --------------------------------------------------------
int __fastcall softreset_hal(int a1)
{
  _BYTE v3[16]; // [sp+8h] [bp+8h] BYREF

  while ( dev_read_nonce_reg_data_hal(a1, (int)v3, 0x10u) )
    ;
  sleep(1u);
  while ( dev_read_nonce_reg_data_hal(a1, (int)v3, 0x10u) )
    ;
  return 0;
}

//----- (000F5158) --------------------------------------------------------
int __fastcall heartbeat_to_hal(int a1)
{
  return pic1704_heart_beat(g_chain_info[2 * a1]);
}
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F5180) --------------------------------------------------------
int __fastcall pic_operation_to_hal(int a1, int a2, unsigned int a3, void *a4)
{
  int v6; // [sp+24h] [bp+14h] BYREF
  int flash; // [sp+1024h] [bp+1014h]

  flash = -1;
  if ( a2 == 51 )
  {
    flash = pic1704_write_flash(g_chain_info[2 * a1], a4, a3, HIWORD(a3));
    if ( flash != 1 )
    {
      V_LOCK();
      logfmt_raw(&v6, 0x1000u, 0, "chain %d, pic1704_write_flash failed!!!", g_chain_info[2 * a1]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
        86,
        "pic_operation_to_hal",
        20,
        427,
        100,
        &v6);
    }
  }
  else if ( a2 == 52 )
  {
    flash = pic1704_read_flash(g_chain_info[2 * a1], a4, a3, HIWORD(a3));
    if ( flash != 1 )
    {
      V_LOCK();
      logfmt_raw(&v6, 0x1000u, 0, "chain %d, pic1704_read_flash failed!!!", g_chain_info[2 * a1]);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/platform_device_hal.c",
        86,
        "pic_operation_to_hal",
        20,
        435,
        100,
        &v6);
    }
  }
  return flash;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;
// 47C2C0: using guessed type _DWORD g_chain_info[32];

//----- (000F5360) --------------------------------------------------------
_UNKNOWN **dev_ctrl_hal()
{
  return &off_1EF724;
}
// 1EF724: using guessed type _UNKNOWN *off_1EF724;

//----- (000F5378) --------------------------------------------------------
int __fastcall sub_F5378(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// F53BC: variable 'v3' is possibly undefined

//----- (000F5458) --------------------------------------------------------
int __fastcall sub_F5458(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F555C) --------------------------------------------------------
int __fastcall chip_setting_fuart_cfg_dcr(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 6291457;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v8 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v8 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v8 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v8 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v8 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v8 = 0;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v8 = 26;
      goto LABEL_27;
    }
    v8 = 0;
  }
LABEL_27:
  v7 = v8 << 8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set fuart cfg value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/chip_setting_dcr.c",
    88,
    "chip_setting_fuart_cfg_dcr",
    26,
    74,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F57A8) --------------------------------------------------------
int __fastcall chip_setting_misc_dcr(int a1)
{
  _BYTE v3[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF
  char v5; // [sp+1037h] [bp+1027h]

  v5 = 26;
  memset(v4, 0, 0x10u);
  v4[2] = 1835009;
  v4[4] = 5381904;
  v4[0] = 5381904;
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "set_misc value %08x", v4[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/chip_setting_dcr.c",
    88,
    "chip_setting_misc_dcr",
    21,
    93,
    60,
    v3);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F58C8) --------------------------------------------------------
int __fastcall chip_setting_ticket_value_dcr(int a1, int a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  int v8; // [sp+1030h] [bp+1020h]
  int v9; // [sp+1034h] [bp+1024h]

  v9 = 0;
  v8 = a2;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %02x", "chip_setting_ticket_value_dcr", 3, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/chip_setting_dcr.c",
    88,
    "chip_setting_ticket_value_dcr",
    29,
    103,
    60,
    v5);
  v6[2] = 196609;
  v6[0] = (unsigned __int8)a2;
  BYTE2(v6[3]) = 1;
  LOBYTE(v6[3]) = -1;
  BYTE1(v6[3]) = *(_DWORD *)(a1 + 200);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v6);
  usleep(0x3E8u);
  *(_DWORD *)(a1 + 244) = (unsigned __int8)a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set tm %d", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_dcr/chip_setting_dcr.c",
    88,
    "chip_setting_ticket_value_dcr",
    29,
    117,
    60,
    v5);
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F5AA0) --------------------------------------------------------
int __fastcall sub_F5AA0(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// F5AE4: variable 'v3' is possibly undefined

//----- (000F5B80) --------------------------------------------------------
int __fastcall sub_F5B80(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F5C84) --------------------------------------------------------
int __fastcall chip_setting_fuart_cfg_ckb2(int a1, char *a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  unsigned __int8 v8; // [sp+1037h] [bp+1027h]

  v7 = 0;
  v8 = 26;
  memset(v6, 0, sizeof(v6));
  v6[2] = 6291457;
  if ( a2 == (char *)&loc_16E360 )
    goto LABEL_21;
  if ( (int)a2 <= 1500000 )
  {
    if ( a2 == (char *)&loc_70800 )
    {
      v8 = 6;
    }
    else if ( (int)a2 > 460800 )
    {
      if ( a2 != (char *)&loc_E1000 && a2 != (char *)&loc_FE502 )
        goto LABEL_26;
      v8 = 2;
    }
    else if ( a2 == (char *)38400 )
    {
      v8 = 80;
    }
    else
    {
      if ( a2 != "stem_Config_File_Information" )
        goto LABEL_26;
      v8 = 26;
    }
    goto LABEL_27;
  }
  if ( a2 == byte_2FAF08 )
  {
LABEL_20:
    v8 = 0;
    goto LABEL_27;
  }
  if ( (int)a2 <= (int)byte_2FAF08 )
  {
    if ( a2 != (_BYTE *)&loc_17D780 + 4 )
    {
      if ( a2 != (char *)&unk_2DC6C0 )
        goto LABEL_26;
      goto LABEL_20;
    }
LABEL_21:
    v8 = 1;
    goto LABEL_27;
  }
  if ( a2 == (char *)6250000 )
  {
    v8 = 0;
  }
  else
  {
    if ( a2 != (char *)12500000 )
    {
LABEL_26:
      v8 = 26;
      goto LABEL_27;
    }
    v8 = 0;
  }
LABEL_27:
  v7 = v8 << 8;
  v6[0] = v7;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set fuart cfg value %08x/%d", v6[0], a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/chip_setting_ckb2.c",
    90,
    "chip_setting_fuart_cfg_ckb2",
    27,
    74,
    60,
    v5);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F5ED0) --------------------------------------------------------
int __fastcall chip_setting_misc_ckb2(int a1)
{
  _BYTE v3[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v4[5]; // [sp+101Ch] [bp+100Ch] BYREF
  char v5; // [sp+1037h] [bp+1027h]

  v5 = 26;
  memset(v4, 0, 0x10u);
  v4[2] = 1835009;
  v4[4] = 7479056;
  v4[0] = 7479056;
  V_LOCK();
  logfmt_raw(v3, 0x1000u, 0, "set_misc value %08x", v4[0]);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/chip_setting_ckb2.c",
    90,
    "chip_setting_misc_ckb2",
    22,
    93,
    60,
    v3);
  return (*(int (__fastcall **)(int, _DWORD *))(a1 + 156))(a1, v4);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F5FF0) --------------------------------------------------------
int __fastcall chip_setting_ticket_value_ckb2(int a1, int a2)
{
  _BYTE v5[28]; // [sp+1Ch] [bp+Ch] BYREF
  _DWORD v6[4]; // [sp+101Ch] [bp+100Ch] BYREF
  int v7; // [sp+102Ch] [bp+101Ch]
  int v8; // [sp+1030h] [bp+1020h]
  int v9; // [sp+1034h] [bp+1024h]

  v9 = 0;
  v8 = a2;
  memset(v6, 0, sizeof(v6));
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "ticket_mask %s reg %02x tm %02x", "chip_setting_ticket_value_ckb2", 3, a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/chip_setting_ckb2.c",
    90,
    "chip_setting_ticket_value_ckb2",
    30,
    103,
    60,
    v5);
  v6[2] = 196609;
  v6[0] = (unsigned __int8)a2;
  BYTE2(v6[3]) = 1;
  LOBYTE(v6[3]) = -1;
  BYTE1(v6[3]) = *(_DWORD *)(a1 + 200);
  v7 = (*(int (__fastcall **)(int, _DWORD *))(a1 + 160))(a1, v6);
  usleep(0x3E8u);
  *(_DWORD *)(a1 + 244) = (unsigned __int8)a2;
  V_LOCK();
  logfmt_raw(v5, 0x1000u, 0, "set tm %d", a2);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ckb2/chip_setting_ckb2.c",
    90,
    "chip_setting_ticket_value_ckb2",
    30,
    117,
    60,
    v5);
  return v7;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F61C8) --------------------------------------------------------
int __fastcall set_chip_reg_ltc(int a1, int a2)
{
  char v3; // r0
  __int16 v7; // [sp+Ch] [bp+Ch] BYREF
  _WORD v8[5]; // [sp+Eh] [bp+Eh] BYREF

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v7 = -21931;
  memset(&v8[2], 0, 5);
  *(_DWORD *)v8 = 1;
  LOBYTE(v8[0]) = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1E | 0x41;
  HIBYTE(v8[0]) = 9;
  LOBYTE(v8[1]) = *(_BYTE *)(a2 + 9);
  HIBYTE(v8[1]) = *(_WORD *)(a2 + 10);
  *(_DWORD *)&v8[2] = reverse_byte_order_32(*(_DWORD *)a2);
  LOBYTE(v8[4]) = 32 * (*(_BYTE *)(a2 + 15) & 3);
  v3 = BM_CRC5(v8, 0x40u);
  LOBYTE(v8[4]) = v8[4] & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, (int)&v7, 0xBu);
  return 0;
}

//----- (000F628C) --------------------------------------------------------
int __fastcall sync_get_status_unclear_ltc(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _DWORD v13[2]; // [sp+14h] [bp+14h] BYREF
  char v14[2]; // [sp+1Ch] [bp+1Ch] BYREF
  int v15; // [sp+1Eh] [bp+1Eh] BYREF
  char v16; // [sp+22h] [bp+22h]
  unsigned __int8 v17; // [sp+23h] [bp+23h]
  unsigned __int8 v18; // [sp+24h] [bp+24h]
  int v19; // [sp+28h] [bp+28h]
  int v20; // [sp+2Ch] [bp+2Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  v20 = 0;
  v19 = 0;
  sub_1A3E94(a5, 0x3E8u);
  v13[1] = 1000000 * v6;
  v13[0] = sub_1A3E94(a5, 0x3E8u);
  while ( v20 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), v14, 9u, v13) == 110 )
    {
      v19 = 3;
      break;
    }
    if ( (unsigned __int8)v14[0] != 170 || v14[1] != 85 || (v18 & 0x80) != 0 )
    {
      v19 = 1;
      break;
    }
    v7 = v18 & 0x1F;
    if ( v7 == BM_CRC5(&v15, 0x33u) )
    {
      *(_BYTE *)(a3 + 12 * v20 + 4) = v16;
      *(_WORD *)(a3 + 12 * v20 + 6) = v17;
      *(_DWORD *)(a3 + 12 * v20) = v15;
      *(_BYTE *)(a3 + 12 * v20++ + 9) = (v18 >> 5) & 3;
    }
    else
    {
      v19 = 2;
    }
  }
  *a4 = v20;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v19;
}
// F62E4: variable 'v6' is possibly undefined

//----- (000F63F0) --------------------------------------------------------
int __fastcall sync_get_status_ltc(int a1, int a2, int a3, _DWORD *a4, unsigned __int64 a5)
{
  int v6; // r2
  int v7; // r4
  _DWORD v13[2]; // [sp+14h] [bp+14h] BYREF
  char v14[2]; // [sp+1Ch] [bp+1Ch] BYREF
  int v15; // [sp+1Eh] [bp+1Eh] BYREF
  char v16; // [sp+22h] [bp+22h]
  unsigned __int8 v17; // [sp+23h] [bp+23h]
  unsigned __int8 v18; // [sp+24h] [bp+24h]
  int v19; // [sp+28h] [bp+28h]
  int v20; // [sp+2Ch] [bp+2Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  v20 = 0;
  v19 = 0;
  sub_1A3E94(a5, 0x3E8u);
  v13[1] = 1000000 * v6;
  v13[0] = sub_1A3E94(a5, 0x3E8u);
  while ( v20 < a2 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), v14, 9u, v13) == 110 )
    {
      v19 = 3;
      break;
    }
    if ( (unsigned __int8)v14[0] != 170 || v14[1] != 85 || (v18 & 0x80) != 0 )
    {
      v19 = 1;
      break;
    }
    v7 = v18 & 0x1F;
    if ( v7 == BM_CRC5(&v15, 0x33u) )
    {
      *(_BYTE *)(a3 + 12 * v20 + 4) = v16;
      *(_WORD *)(a3 + 12 * v20 + 6) = v17;
      *(_DWORD *)(a3 + 12 * v20) = v15;
      *(_BYTE *)(a3 + 12 * v20++ + 9) = (v18 >> 5) & 3;
    }
    else
    {
      v19 = 2;
    }
  }
  *a4 = v20;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v19;
}
// F6454: variable 'v6' is possibly undefined

//----- (000F6560) --------------------------------------------------------
int __fastcall sync_get_chip_reg_ltc(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int64 a6)
{
  char v7; // r0
  __int16 v13; // [sp+18h] [bp+10h] BYREF
  int v14; // [sp+1Ah] [bp+12h] BYREF
  char v15; // [sp+1Eh] [bp+16h]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  v13 = -21931;
  v15 = 0;
  v14 = 2;
  LOBYTE(v14) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 2;
  LOBYTE(v14) = v14 & 0x1F | 0x40;
  BYTE1(v14) = 5;
  BYTE2(v14) = *(_BYTE *)(a2 + 9);
  HIBYTE(v14) = *(_WORD *)(a2 + 10);
  v15 = 32 * (*(_BYTE *)(a2 + 15) & 3);
  v7 = BM_CRC5(&v14, 0x20u);
  v15 = v15 & 0xE0 | v7 & 0x1F;
  send_command_packet(a1, (int)&v13, 7u);
  if ( *(_BYTE *)(a2 + 8) != 1 )
    a3 = 1;
  return sync_get_status_ltc(a1, a3, a4, a5, a6);
}

//----- (000F663C) --------------------------------------------------------
int __fastcall set_core_reg_ltc(int a1, int a2)
{
  char v3; // r0
  __int16 v7; // [sp+8h] [bp+8h] BYREF
  _WORD v8[5]; // [sp+Ah] [bp+Ah] BYREF
  unsigned int v9; // [sp+14h] [bp+14h]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  LOWORD(v9) = *(_DWORD *)a2;
  BYTE2(v9) = BYTE2(v9) & 0xF0 | *(_WORD *)(a2 + 10) & 0xF;
  HIWORD(v9) = HIWORD(v9) & 0xF00F | (16 * *(unsigned __int8 *)(a2 + 12));
  HIBYTE(v9) = HIBYTE(v9) & 0xF | 0x40 | ((*(_BYTE *)(a2 + 14) & 1) << 7);
  v7 = -21931;
  memset(&v8[2], 0, 5);
  *(_DWORD *)v8 = 1;
  LOBYTE(v8[0]) = (16 * (*(_BYTE *)(a2 + 8) & 1)) & 0x1E | 0x41;
  HIBYTE(v8[0]) = 9;
  LOBYTE(v8[1]) = *(_BYTE *)(a2 + 9);
  HIBYTE(v8[1]) = 60;
  *(_DWORD *)&v8[2] = reverse_byte_order_32(v9);
  LOBYTE(v8[4]) = 32 * (*(_BYTE *)(a2 + 15) & 3);
  v3 = BM_CRC5(v8, 0x40u);
  LOBYTE(v8[4]) = v8[4] & 0xE0 | v3 & 0x1F;
  send_command_packet(a1, (int)&v7, 0xBu);
  return 0;
}

//----- (000F674C) --------------------------------------------------------
int __fastcall sync_get_core_reg_ltc(int a1, int a2, int a3, int a4, int *a5, unsigned __int64 a6)
{
  char v7; // r0
  int v8; // r2
  int v9; // r4
  _BYTE v15[12]; // [sp+24h] [bp+14h] BYREF
  _DWORD v16[2]; // [sp+1024h] [bp+1014h] BYREF
  char v17[2]; // [sp+102Ch] [bp+101Ch] BYREF
  _BYTE v18[4]; // [sp+102Eh] [bp+101Eh] BYREF
  unsigned __int8 v19; // [sp+1032h] [bp+1022h]
  unsigned __int8 v20; // [sp+1033h] [bp+1023h]
  char v21; // [sp+1034h] [bp+1024h]
  __int16 v22; // [sp+1038h] [bp+1028h] BYREF
  _WORD v23[5]; // [sp+103Ah] [bp+102Ah] BYREF
  unsigned int v24; // [sp+1044h] [bp+1034h]
  int v25; // [sp+1048h] [bp+1038h]
  int v26; // [sp+104Ch] [bp+103Ch]

  if ( *(_BYTE *)(a1 + 144) != 1 )
    return 4;
  LOWORD(v24) = 0;
  BYTE2(v24) = BYTE2(v24) & 0xF0 | *(_WORD *)(a2 + 10) & 0xF;
  HIWORD(v24) = HIWORD(v24) & 0xF00F | (16 * *(unsigned __int8 *)(a2 + 12));
  HIBYTE(v24) &= ~0x10u;
  HIBYTE(v24) &= ~0x20u;
  HIBYTE(v24) &= ~0x40u;
  HIBYTE(v24) = HIBYTE(v24) & 0x7F | ((*(_BYTE *)(a2 + 14) & 1) << 7);
  v22 = -21931;
  memset(&v23[2], 0, 5);
  *(_DWORD *)v23 = 1;
  LOBYTE(v23[0]) = (16 * (*(_BYTE *)(a2 + 8) & 1)) | 1;
  LOBYTE(v23[0]) = v23[0] & 0x1F | 0x40;
  HIBYTE(v23[0]) = 9;
  LOBYTE(v23[1]) = *(_BYTE *)(a2 + 9);
  HIBYTE(v23[1]) = 60;
  *(_DWORD *)&v23[2] = reverse_byte_order_32(v24);
  LOBYTE(v23[4]) = v23[4] & 0x9F | (32 * (*(_BYTE *)(a2 + 15) & 3));
  v7 = BM_CRC5(v23, 8 * (HIBYTE(v23[0]) - 1));
  LOBYTE(v23[4]) = v23[4] & 0xE0 | v7 & 0x1F;
  if ( *(_BYTE *)(a2 + 8) != 1 && *(_BYTE *)(a2 + 14) != 1 )
    a3 = 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 688));
  queue_clear(*(_DWORD *)(a1 + 664));
  send_command_packet(a1, (int)&v22, 0xBu);
  v26 = 0;
  v25 = 0;
  sub_1A3E94(a6, 0x3E8u);
  v16[1] = 1000000 * v8;
  v16[0] = sub_1A3E94(a6, 0x3E8u);
  while ( v26 < a3 )
  {
    if ( queue_dequeue_for(*(_DWORD *)(a1 + 664), v17, 9u, v16) == 110 )
    {
      v25 = 3;
      break;
    }
    if ( (unsigned __int8)v17[0] != 170 || v17[1] != 85 || (v21 & 0x20) != 0 || (v21 & 0x40) == 0 || (v21 & 0x80) == 0 )
    {
      v25 = 1;
      break;
    }
    if ( (v20 & 0x10) != 0 )
    {
      V_LOCK();
      logfmt_raw(v15, 0x1000u, 0, "core %d get parity", v19);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_reg_io_ltc.c",
        87,
        "sync_get_core_reg_ltc",
        21,
        370,
        100,
        v15);
    }
    v9 = v21 & 0x1F;
    if ( v9 == BM_CRC5(v18, 0x33u) )
    {
      *(_BYTE *)(a4 + 12 * v26 + 4) = v18[3];
      *(_WORD *)(a4 + 12 * v26 + 6) = v20 & 0xF;
      *(_BYTE *)(a4 + 12 * v26 + 8) = v19;
      *(_DWORD *)(a4 + 12 * v26) = (v18[1] << 8) | (((v20 & 0x20) != 0) << 24) | (v18[0] << 16) | v18[2];
      *(_BYTE *)(a4 + 12 * v26++ + 9) = v20 >> 6;
    }
    else
    {
      v25 = 2;
    }
  }
  *a5 = v26;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 688));
  return v25;
}
// F6A34: variable 'v8' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F6D10) --------------------------------------------------------
int __fastcall set_core_enable_ltc(int a1, int a2, __useconds_t a3)
{
  _BYTE v8[8]; // [sp+20h] [bp+10h] BYREF
  int v9; // [sp+1020h] [bp+1010h]
  int i; // [sp+1024h] [bp+1014h]

  for ( i = 0; *(unsigned __int8 *)(a2 + 13) > i; ++i )
  {
    *(_DWORD *)a2 = 34047;
    *(_WORD *)(a2 + 10) = 0;
    *(_BYTE *)(a2 + 12) = i;
    *(_BYTE *)(a2 + 14) = 0;
    *(_BYTE *)(a2 + 15) = 0;
    v9 = (*(int (__fastcall **)(int, int))(a1 + 164))(a1, a2);
    if ( v9 )
    {
      V_LOCK();
      logfmt_raw(
        v8,
        0x1000u,
        0,
        "%s failed, reg:%02x, core_id:%d",
        "set_core_enable_ltc",
        *(unsigned __int16 *)(a2 + 10),
        i);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/backend_ltc/chip_reg_io_ltc.c",
        87,
        "set_core_enable_ltc",
        19,
        408,
        100,
        v8);
      return v9;
    }
    usleep(a3);
  }
  return 0;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F6E98) --------------------------------------------------------
_DWORD *__fastcall new_c_map(int a1, int a2, int a3)
{
  _DWORD *v8; // [sp+14h] [bp+14h]

  v8 = malloc(4u);
  if ( !v8 )
    return 0;
  *v8 = new_c_rb(a1, a2, a3);
  if ( *v8 )
    return v8;
  else
    return 0;
}

//----- (000F6EE0) --------------------------------------------------------
int __fastcall insert_c_map(int *a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  if ( a1 )
    return insert_c_rb(*a1, a2, a3, a4, a5);
  else
    return 501;
}

//----- (000F6F18) --------------------------------------------------------
bool __fastcall exists_c_map(int *a1, int a2)
{
  return a1 && find_c_rb(*a1, a2) != 0;
}

//----- (000F6F54) --------------------------------------------------------
int __fastcall remove_c_map(int *a1, int a2)
{
  void *ptr; // [sp+Ch] [bp+Ch] BYREF
  void *v5; // [sp+10h] [bp+10h]
  int v6; // [sp+14h] [bp+14h]

  v6 = 0;
  if ( !a1 )
    return 501;
  v5 = remove_c_rb(*a1, a2);
  if ( v5 )
  {
    get_raw_clib_object(*((_DWORD *)v5 + 4), &ptr);
    free(ptr);
    delete_clib_object(*((void ***)v5 + 4));
    get_raw_clib_object(*((_DWORD *)v5 + 5), &ptr);
    free(ptr);
    delete_clib_object(*((void ***)v5 + 5));
    free(v5);
  }
  return v6;
}

//----- (000F6FD8) --------------------------------------------------------
int __fastcall find_c_map(int *a1, int a2, void **a3)
{
  _DWORD *c_rb; // [sp+14h] [bp+14h]

  if ( !a1 )
    return 0;
  c_rb = find_c_rb(*a1, a2);
  if ( !c_rb )
    return 0;
  get_raw_clib_object(c_rb[5], a3);
  return 1;
}

//----- (000F701C) --------------------------------------------------------
int __fastcall delete_c_map(void ***a1)
{
  int v3; // [sp+Ch] [bp+Ch]

  v3 = 0;
  if ( a1 )
  {
    v3 = delete_c_rb(*a1);
    free(a1);
  }
  return v3;
}

//----- (000F704C) --------------------------------------------------------
_DWORD *__fastcall sub_F704C(int *a1)
{
  return minimum_c_rb(*a1, *(_DWORD **)*a1);
}

//----- (000F7070) --------------------------------------------------------
int __fastcall sub_F7070(int a1)
{
  if ( *(_DWORD *)(a1 + 20) )
    *(_DWORD *)(a1 + 20) = tree_successor(**(int ***)(a1 + 12), *(_DWORD *)(a1 + 20));
  else
    *(_DWORD *)(a1 + 20) = sub_F704C(*(int **)(a1 + 12));
  if ( *(_DWORD *)(a1 + 20) )
    return *(_DWORD *)(*(_DWORD *)(a1 + 20) + 20);
  else
    return 0;
}

//----- (000F70C8) --------------------------------------------------------
void *__fastcall sub_F70C8(int a1)
{
  void *v2; // [sp+Ch] [bp+Ch] BYREF

  get_raw_clib_object(a1, &v2);
  return v2;
}

//----- (000F70E8) --------------------------------------------------------
void *__fastcall sub_F70E8(int a1, const void *a2, size_t a3)
{
  void *v7; // [sp+10h] [bp+10h] BYREF
  int v8; // [sp+14h] [bp+14h]

  v8 = *(_DWORD *)(a1 + 12);
  if ( *(_DWORD *)(*(_DWORD *)v8 + 32) )
  {
    get_raw_clib_object(*(_DWORD *)(a1 + 20), &v7);
    (*(void (__fastcall **)(void *))(*(_DWORD *)v8 + 32))(v7);
  }
  return replace_raw_clib_object(*(void ***)(*(_DWORD *)(a1 + 20) + 20), a2, a3);
}

//----- (000F7138) --------------------------------------------------------
_DWORD *__fastcall new_iterator_c_map(int a1)
{
  _DWORD *result; // r0

  result = malloc(0x18u);
  *result = 1011825;
  result[2] = 1011913;
  result[1] = 1011945;
  result[3] = a1;
  result[4] = 0;
  result[5] = 0;
  return result;
}

//----- (000F718C) --------------------------------------------------------
void __fastcall delete_iterator_c_map(void *a1)
{
  free(a1);
}

//----- (000F71A4) --------------------------------------------------------
int __fastcall sub_F71A4(unsigned __int8 a1, int a2, unsigned int a3)
{
  return iic_write(g_bitmain_pic_state[2 * a1], a2, a3);
}
// 47C224: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (000F71D4) --------------------------------------------------------
int __fastcall sub_F71D4(unsigned __int8 a1, int a2, unsigned int a3)
{
  return iic_read(g_bitmain_pic_state[2 * a1], a2, a3);
}
// 47C224: using guessed type _DWORD g_bitmain_pic_state[32];

//----- (000F7204) --------------------------------------------------------
int __fastcall sub_F7204(unsigned __int8 a1, char a2, char a3, int a4, int a5)
{
  unsigned int v5; // r2
  unsigned int v6; // r3
  unsigned int v7; // r3
  int v8; // r0
  _BYTE v14[20]; // [sp+2Ch] [bp+14h] BYREF
  int v15; // [sp+102Ch] [bp+1014h] BYREF
  int v16; // [sp+1030h] [bp+1018h]
  int v17; // [sp+1034h] [bp+101Ch]
  int v18; // [sp+1038h] [bp+1020h]
  _DWORD v19[4]; // [sp+103Ch] [bp+1024h] BYREF
  __int16 v20; // [sp+104Ch] [bp+1034h]
  char v21; // [sp+104Fh] [bp+1037h]
  int v22; // [sp+1050h] [bp+1038h]
  unsigned int v23; // [sp+1054h] [bp+103Ch]
  int j; // [sp+1058h] [bp+1040h]
  unsigned __int8 i; // [sp+105Dh] [bp+1045h]
  __int16 v26; // [sp+105Eh] [bp+1046h]
  _BYTE v27[4]; // [sp+1060h] [bp+1048h] BYREF

  v20 = 255;
  memset(&v19[1], 0, 12);
  v19[0] = 255;
  v26 = 0;
  v15 = 838904405;
  v17 = 0;
  v18 = 0;
  j = 0;
  v21 = a5 + 6;
  v22 = 1;
  pthread_mutex_lock(&i2c_mutex_all);
  BYTE2(v15) = a5 + 6;
  v16 = (unsigned __int8)(2 * a2);
  v23 = 6;
  BYTE1(v16) = a3;
  for ( i = 0; i < a5; ++i )
  {
    v5 = v23++;
    *((_BYTE *)&v15 + v5) = *(_BYTE *)(a4 + i);
  }
  for ( j = 2; a5 + 6 > j; ++j )
    v26 += *((unsigned __int8 *)&v15 + j);
  LOBYTE(v20) = HIBYTE(v26);
  HIBYTE(v20) = v26;
  v6 = v23++;
  v27[v6 - 52] = HIBYTE(v26);
  v7 = v23++;
  v27[v7 - 52] = HIBYTE(v20);
  v8 = sub_F71A4(a1, (int)&v15, v23);
  if ( v8 == v23 )
  {
    usleep(0x30D40u);
    memset(v19, 0, sizeof(v19));
    if ( sub_F71D4(a1, (int)v19, 5u) == 5 )
    {
      if ( BYTE1(v19[0]) != 50 || BYTE2(v19[0]) != 1 )
      {
        V_LOCK();
        logfmt_raw(
          v14,
          0x1000u,
          0,
          "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x",
          "write_dc_dc",
          LOBYTE(v19[0]),
          BYTE1(v19[0]),
          BYTE2(v19[0]),
          HIBYTE(v19[0]));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
          87,
          "write_dc_dc",
          11,
          75,
          100,
          v14);
        v22 = 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v14, 0x1000u, 0, "%s read iic err", "write_dc_dc");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
        87,
        "write_dc_dc",
        11,
        68,
        100,
        v14);
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v14, 0x1000u, 0, "%s write iic err", "write_dc_dc");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
      87,
      "write_dc_dc",
      11,
      61,
      100,
      v14);
  }
  pthread_mutex_unlock(&i2c_mutex_all);
  return v22;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B2F8: using guessed type pthread_mutex_t i2c_mutex_all;
// 47BE18: using guessed type int g_zc;

//----- (000F7748) --------------------------------------------------------
int __fastcall sub_F7748(unsigned __int8 a1, char a2, char a3, int a4, int a5)
{
  unsigned int v5; // r3
  unsigned int v6; // r3
  int v7; // r0
  _BYTE v13[16]; // [sp+28h] [bp+10h] BYREF
  int v14; // [sp+1028h] [bp+1010h] BYREF
  int v15; // [sp+102Ch] [bp+1014h]
  char v16; // [sp+1030h] [bp+1018h]
  _DWORD v17[4]; // [sp+1034h] [bp+101Ch] BYREF
  __int16 v18; // [sp+1044h] [bp+102Ch]
  unsigned int v19; // [sp+1048h] [bp+1030h]
  unsigned __int8 v20; // [sp+104Fh] [bp+1037h]
  int v21; // [sp+1050h] [bp+1038h]
  unsigned __int8 i; // [sp+1055h] [bp+103Dh]
  __int16 v23; // [sp+1056h] [bp+103Eh]
  _BYTE v24[4]; // [sp+1058h] [bp+1040h] BYREF

  v20 = 7;
  v18 = 255;
  memset(&v17[1], 0, 12);
  v17[0] = 255;
  v23 = 0;
  v14 = 839363157;
  v16 = 0;
  v21 = 1;
  pthread_mutex_lock(&i2c_mutex_all);
  v15 = (unsigned __int8)(2 * a2) | 1;
  BYTE1(v15) = a3;
  v19 = 7;
  BYTE2(v15) = a5;
  for ( i = 2; i < (unsigned int)v20; ++i )
    v23 += (unsigned __int8)v24[i - 48];
  LOBYTE(v18) = HIBYTE(v23);
  HIBYTE(v18) = v23;
  v5 = v19++;
  v24[v5 - 48] = HIBYTE(v23);
  v6 = v19++;
  v24[v6 - 48] = HIBYTE(v18);
  v7 = sub_F71A4(a1, (int)&v14, v19);
  if ( v7 == v19 )
  {
    usleep(0x30D40u);
    memset(v17, 0, sizeof(v17));
    if ( sub_F71D4(a1, (int)v17, 5u) == 5 )
    {
      if ( BYTE1(v17[0]) == 50 && BYTE2(v17[0]) == 1 )
      {
        for ( i = 0; i < a5; ++i )
          *(_BYTE *)(a4 + i) = v24[i - 33];
        v21 = 1;
      }
      else
      {
        V_LOCK();
        logfmt_raw(
          v13,
          0x1000u,
          0,
          "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x",
          "read_dc_dc",
          LOBYTE(v17[0]),
          BYTE1(v17[0]),
          BYTE2(v17[0]),
          HIBYTE(v17[0]));
        V_UNLOCK();
        zlog(
          g_zc,
          "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
          87,
          "read_dc_dc",
          10,
          125,
          100,
          v13);
        v21 = 0;
      }
    }
    else
    {
      V_LOCK();
      logfmt_raw(v13, 0x1000u, 0, "%s read iic err", "read_dc_dc");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
        87,
        "read_dc_dc",
        10,
        118,
        100,
        v13);
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v13, 0x1000u, 0, "%s write iic err", "read_dc_dc");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
      87,
      "read_dc_dc",
      10,
      110,
      100,
      v13);
  }
  pthread_mutex_unlock(&i2c_mutex_all);
  return v21;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47B2F8: using guessed type pthread_mutex_t i2c_mutex_all;
// 47BE18: using guessed type int g_zc;

//----- (000F7C84) --------------------------------------------------------
int __fastcall sub_F7C84(unsigned __int8 a1, char a2, _WORD *a3)
{
  __int16 s; // [sp+1Ch] [bp+14h] BYREF

  memset(&s, 0, sizeof(s));
  sub_F7748(a1, a2, 33, (int)&s, 2);
  *a3 = (HIBYTE(s) << 8) | (unsigned __int8)s;
  return 1;
}

//----- (000F7CD8) --------------------------------------------------------
int __fastcall sub_F7CD8(int a1, char a2, unsigned __int16 a3)
{
  int v4; // [sp+Ch] [bp-4h]
  char v6; // [sp+13h] [bp+3h]
  int v7; // [sp+14h] [bp+4h]
  _BYTE v8[12]; // [sp+1Ch] [bp+Ch] BYREF
  __int16 v9; // [sp+101Ch] [bp+100Ch] BYREF
  char v10; // [sp+101Fh] [bp+100Fh] BYREF
  unsigned __int16 v11; // [sp+1020h] [bp+1010h] BYREF
  unsigned __int8 v12; // [sp+1022h] [bp+1012h]
  unsigned __int8 v13; // [sp+1023h] [bp+1013h]
  int v14; // [sp+1024h] [bp+1014h]

  v7 = a1;
  v6 = a2;
  v14 = a3;
  if ( a3 > 0x3DEu || v14 <= 809 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "illegal voltage [%d, %d], set default voltage %d", 810, 990, 900, v4, a3, v7);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
      87,
      "ISL_set_voltage_dynamic",
      23,
      154,
      60,
      v8);
    v14 = 900;
  }
  v13 = 0;
  v12 = 3;
  v11 = 0;
  do
  {
    v10 = -1;
    sub_F7204(v7, v6, 0, (int)&v10, 1);
    usleep((__useconds_t)&stru_1869C.st_value);
    v9 = v14;
    sub_F7204(v7, v6, 33, (int)&v9, 2);
    usleep(0x30D40u);
    sub_F7C84(v7, v6, &v11);
    if ( v11 > v14 - 10 && v11 < v14 + 10 )
      break;
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "set vol %d,  %d, set again!", v14, v11);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
      87,
      "ISL_set_voltage_dynamic",
      23,
      181,
      60,
      v8);
    usleep(0x30D40u);
    ++v13;
  }
  while ( v13 <= (unsigned int)v12 );
  return v11;
}
// F7D62: variable 'v4' is possibly undefined
// F7DFC: variable 'v7' is possibly undefined
// F7DFC: variable 'v6' is possibly undefined
// 1869C: using guessed type Elf32_Sym stru_1869C;
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F7F7C) --------------------------------------------------------
int __fastcall get_chain_isl_voltage(unsigned __int8 a1, int a2, int a3)
{
  _BYTE v7[8]; // [sp+20h] [bp+10h] BYREF
  unsigned __int16 v8; // [sp+1022h] [bp+1012h] BYREF
  unsigned int i; // [sp+1024h] [bp+1014h]

  if ( a3 <= 2 )
    return 0;
  for ( i = 0; i <= 2; ++i )
  {
    v8 = 0;
    sub_F7C84(a1, aPqt[i], &v8);
    *(_WORD *)(a2 + 2 * i) = v8;
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "Get one chain ISL: domain addr = %x vol=%u", (unsigned __int8)aPqt[i], v8);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
      87,
      "get_chain_isl_voltage",
      21,
      202,
      60,
      v7);
  }
  return 1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F80C0) --------------------------------------------------------
int __fastcall set_chain_isl_voltage(int a1, unsigned __int16 a2)
{
  _BYTE v5[8]; // [sp+18h] [bp+8h] BYREF
  unsigned __int16 v6; // [sp+101Ah] [bp+100Ah]
  unsigned int i; // [sp+101Ch] [bp+100Ch]

  for ( i = 0; i <= 2; ++i )
  {
    v6 = sub_F7CD8(a1, aPqt[i], a2);
    V_LOCK();
    logfmt_raw(
      v5,
      0x1000u,
      0,
      "Set one chain ISL: domain addr = %x set vol %d, get vol %d",
      (unsigned __int8)aPqt[i],
      a2,
      v6);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/backend/device/hal/drv_pic/isl68127.c",
      87,
      "set_chain_isl_voltage",
      21,
      215,
      60,
      v5);
  }
  return 1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F81D4) --------------------------------------------------------
void *__fastcall clib_copy(void *a1, const void *a2, size_t a3)
{
  return memcpy(a1, a2, a3);
}

//----- (000F81F4) --------------------------------------------------------
void *__fastcall clib_get(void *a1, const void *a2, size_t a3)
{
  return memcpy(a1, a2, a3);
}

//----- (000F8214) --------------------------------------------------------
void **__fastcall new_clib_object(const void *a1, size_t a2)
{
  void **ptr; // [sp+Ch] [bp+Ch]

  ptr = (void **)malloc(8u);
  if ( !ptr )
    return 0;
  ptr[1] = (void *)a2;
  *ptr = malloc(a2);
  if ( *ptr )
  {
    memcpy(*ptr, a1, a2);
    return ptr;
  }
  else
  {
    free(ptr);
    return 0;
  }
}

//----- (000F8270) --------------------------------------------------------
int __fastcall get_raw_clib_object(int a1, void **a2)
{
  *a2 = malloc(*(_DWORD *)(a1 + 4));
  if ( !*a2 )
    return 3;
  memcpy(*a2, *(const void **)a1, *(_DWORD *)(a1 + 4));
  return 0;
}

//----- (000F82B4) --------------------------------------------------------
void *__fastcall replace_raw_clib_object(void **a1, const void *a2, size_t a3)
{
  free(*a1);
  *a1 = malloc(a3);
  return memcpy(*a1, a2, a3);
}

//----- (000F82F0) --------------------------------------------------------
void __fastcall delete_clib_object(void **a1)
{
  if ( a1 )
  {
    free(*a1);
    free(a1);
  }
}

//----- (000F8318) --------------------------------------------------------
char *__fastcall clib_strdup(const char *a1)
{
  return strdup(a1);
}

//----- (000F8330) --------------------------------------------------------
_DWORD *__fastcall sub_F8330(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // [sp+Ch] [bp+Ch]

  v2 = (_DWORD *)a2[1];
  a2[1] = *v2;
  if ( (_DWORD *)*v2 != result + 1 )
    *(_DWORD *)(*v2 + 8) = a2;
  if ( result + 1 != v2 )
    v2[2] = a2[2];
  if ( a2[2] )
  {
    if ( *(_DWORD **)a2[2] == a2 )
      *(_DWORD *)a2[2] = v2;
    else
      *(_DWORD *)(a2[2] + 4) = v2;
  }
  else
  {
    *result = v2;
  }
  *v2 = a2;
  if ( result + 1 != a2 )
    a2[2] = v2;
  return result;
}

//----- (000F83C0) --------------------------------------------------------
_DWORD *__fastcall sub_F83C0(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // [sp+Ch] [bp+Ch]

  v2 = (_DWORD *)*a2;
  *a2 = *(_DWORD *)(*a2 + 4);
  if ( (_DWORD *)v2[1] != result + 1 )
    *(_DWORD *)(v2[1] + 8) = a2;
  if ( result + 1 != v2 )
    v2[2] = a2[2];
  if ( a2[2] )
  {
    if ( *(_DWORD **)(a2[2] + 4) == a2 )
      *(_DWORD *)(a2[2] + 4) = v2;
    else
      *(_DWORD *)a2[2] = v2;
  }
  else
  {
    *result = v2;
  }
  v2[1] = a2;
  if ( result + 1 != a2 )
    a2[2] = v2;
  return result;
}

//----- (000F8450) --------------------------------------------------------
_DWORD *__fastcall new_c_rb(int a1, int a2, int a3)
{
  _DWORD *s; // [sp+14h] [bp+14h]

  s = malloc(0x28u);
  if ( !s )
    return 0;
  memset(s, 0, 0x28u);
  s[9] = a1;
  s[7] = a2;
  s[8] = a3;
  *s = s + 1;
  s[1] = s + 1;
  s[2] = s + 1;
  s[3] = 0;
  s[4] = 0;
  return s;
}

//----- (000F84BC) --------------------------------------------------------
_DWORD *__fastcall sub_F84BC(_DWORD *result, _DWORD *a2)
{
  _DWORD *v3; // [sp+4h] [bp+4h]
  int v4; // [sp+8h] [bp+8h]
  int v5; // [sp+Ch] [bp+Ch]

  v3 = result;
  while ( (_DWORD *)*v3 != a2 && *(_DWORD *)(a2[2] + 12) == 1 )
  {
    if ( a2[2] == **(_DWORD **)(a2[2] + 8) )
    {
      v5 = *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 4);
      if ( *(_DWORD *)(v5 + 12) == 1 )
      {
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(v5 + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        a2 = *(_DWORD **)(a2[2] + 8);
      }
      else
      {
        if ( *(_DWORD **)(a2[2] + 4) == a2 )
        {
          a2 = (_DWORD *)a2[2];
          sub_F8330(v3, a2);
        }
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        result = sub_F83C0(v3, *(_DWORD **)(a2[2] + 8));
      }
    }
    else
    {
      v4 = **(_DWORD **)(a2[2] + 8);
      if ( *(_DWORD *)(v4 + 12) == 1 )
      {
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(v4 + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        a2 = *(_DWORD **)(a2[2] + 8);
      }
      else
      {
        if ( *(_DWORD **)a2[2] == a2 )
        {
          a2 = (_DWORD *)a2[2];
          sub_F83C0(v3, a2);
        }
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        result = sub_F8330(v3, *(_DWORD **)(a2[2] + 8));
      }
    }
  }
  *(_DWORD *)(*v3 + 12) = 0;
  return result;
}

//----- (000F85DC) --------------------------------------------------------
_DWORD *__fastcall find_c_rb(int a1, int a2)
{
  _DWORD *v2; // r3
  void *ptr; // [sp+Ch] [bp+Ch] BYREF
  int v8; // [sp+10h] [bp+10h]
  _DWORD *i; // [sp+14h] [bp+14h]

  for ( i = *(_DWORD **)a1; (_DWORD *)(a1 + 4) != i; i = v2 )
  {
    v8 = 0;
    get_raw_clib_object(i[4], &ptr);
    v8 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v8 )
      break;
    if ( v8 >= 0 )
      v2 = (_DWORD *)i[1];
    else
      v2 = (_DWORD *)*i;
  }
  if ( (_DWORD *)(a1 + 4) == i )
    return 0;
  else
    return i;
}

//----- (000F8658) --------------------------------------------------------
int __fastcall insert_c_rb(int a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  void *v11; // [sp+10h] [bp+10h] BYREF
  void *v12; // [sp+14h] [bp+14h] BYREF
  void *v13; // [sp+18h] [bp+18h] BYREF
  void *ptr; // [sp+1Ch] [bp+1Ch] BYREF
  int v15; // [sp+20h] [bp+20h]
  int v16; // [sp+24h] [bp+24h]
  _DWORD *v17; // [sp+28h] [bp+28h]
  int v18; // [sp+2Ch] [bp+2Ch]
  _DWORD *v19; // [sp+30h] [bp+30h]
  _DWORD *v20; // [sp+34h] [bp+34h]

  v18 = 0;
  v17 = malloc(0x18u);
  if ( !v17 )
    return 2;
  *v17 = a1 + 4;
  v17[1] = a1 + 4;
  v17[3] = 1;
  v17[4] = new_clib_object(a2, a3);
  if ( a4 )
    v17[5] = new_clib_object(a4, a5);
  else
    v17[5] = 0;
  v20 = *(_DWORD **)a1;
  v19 = 0;
  while ( (_DWORD *)(a1 + 4) != v20 )
  {
    v16 = 0;
    get_raw_clib_object(v20[4], &ptr);
    get_raw_clib_object(v17[4], &v13);
    v16 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v13, ptr);
    free(ptr);
    free(v13);
    if ( !v16 )
      return 401;
    v19 = v20;
    if ( v16 >= 0 )
      v20 = (_DWORD *)v20[1];
    else
      v20 = (_DWORD *)*v20;
  }
  v17[2] = v19;
  if ( v19 )
  {
    v15 = 0;
    get_raw_clib_object(v19[4], &v12);
    get_raw_clib_object(v17[4], &v11);
    v15 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v11, v12);
    free(v12);
    free(v11);
    if ( v15 >= 0 )
      v19[1] = v17;
    else
      *v19 = v17;
  }
  else
  {
    *(_DWORD *)a1 = v17;
  }
  sub_F84BC((_DWORD *)a1, v17);
  sub_F8CDC((_DWORD **)a1);
  return v18;
}

//----- (000F87BC) --------------------------------------------------------
int *__fastcall sub_F87BC(int *result, int a2)
{
  int *v3; // [sp+4h] [bp+4h]
  _DWORD *v4; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]

  v3 = result;
  while ( *v3 != a2 && !*(_DWORD *)(a2 + 12) )
  {
    if ( **(_DWORD **)(a2 + 8) == a2 )
    {
      v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
      if ( v5[3] == 1 )
      {
        v5[3] = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 1;
        result = sub_F8330(v3, *(_DWORD **)(a2 + 8));
        v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
      }
      if ( *(_DWORD *)(*v5 + 12) || *(_DWORD *)(v5[1] + 12) )
      {
        if ( !*(_DWORD *)(v5[1] + 12) )
        {
          *(_DWORD *)(*v5 + 12) = 0;
          v5[3] = 1;
          sub_F83C0(v3, v5);
          v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
        }
        v5[3] = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 0;
        *(_DWORD *)(v5[1] + 12) = 0;
        result = sub_F8330(v3, *(_DWORD **)(a2 + 8));
        a2 = *v3;
      }
      else
      {
        v5[3] = 1;
        a2 = *(_DWORD *)(a2 + 8);
      }
    }
    else
    {
      v4 = **(_DWORD ***)(a2 + 8);
      if ( v4[3] == 1 )
      {
        v4[3] = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 1;
        result = sub_F83C0(v3, *(_DWORD **)(a2 + 8));
        v4 = **(_DWORD ***)(a2 + 8);
      }
      if ( *(_DWORD *)(v4[1] + 12) || *(_DWORD *)(*v4 + 12) )
      {
        if ( !*(_DWORD *)(*v4 + 12) )
        {
          *(_DWORD *)(v4[1] + 12) = 0;
          v4[3] = 1;
          sub_F8330(v3, v4);
          v4 = **(_DWORD ***)(a2 + 8);
        }
        v4[3] = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 0;
        *(_DWORD *)(*v4 + 12) = 0;
        result = sub_F83C0(v3, *(_DWORD **)(a2 + 8));
        a2 = *v3;
      }
      else
      {
        v4[3] = 1;
        a2 = *(_DWORD *)(a2 + 8);
      }
    }
  }
  *(_DWORD *)(a2 + 12) = 0;
  return result;
}

//----- (000F8948) --------------------------------------------------------
int *__fastcall sub_F8948(int *a1, int *a2)
{
  int v4; // [sp+Ch] [bp+Ch]
  int v5; // [sp+Ch] [bp+Ch]
  int *i; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  if ( (int *)*a2 == a1 + 1 || (int *)a2[1] == a1 + 1 )
  {
    i = a2;
  }
  else
  {
    for ( i = (int *)a2[1]; (int *)*i != a1 + 1; i = (int *)*i )
      ;
  }
  if ( (int *)*i == a1 + 1 )
    v7 = i[1];
  else
    v7 = *i;
  *(_DWORD *)(v7 + 8) = i[2];
  if ( i[2] )
  {
    if ( *(int **)i[2] == i )
      *(_DWORD *)i[2] = v7;
    else
      *(_DWORD *)(i[2] + 4) = v7;
  }
  else
  {
    *a1 = v7;
  }
  if ( i != a2 )
  {
    v4 = a2[4];
    a2[4] = i[4];
    i[4] = v4;
    v5 = a2[5];
    a2[5] = i[5];
    i[5] = v5;
  }
  if ( !i[3] )
    sub_F87BC(a1, v7);
  sub_F8CDC((_DWORD **)a1);
  return i;
}

//----- (000F8A34) --------------------------------------------------------
int *__fastcall remove_c_rb(int a1, int a2)
{
  int *v2; // r3
  void *ptr; // [sp+Ch] [bp+Ch] BYREF
  int v8; // [sp+10h] [bp+10h]
  int *i; // [sp+14h] [bp+14h]

  i = 0;
  for ( i = *(int **)a1; (int *)(a1 + 4) != i; i = v2 )
  {
    v8 = 0;
    get_raw_clib_object(i[4], &ptr);
    v8 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v8 )
      break;
    if ( v8 >= 0 )
      v2 = (int *)i[1];
    else
      v2 = (int *)*i;
  }
  if ( (int *)(a1 + 4) == i )
    return 0;
  else
    return sub_F8948((int *)a1, i);
}

//----- (000F8ABC) --------------------------------------------------------
void __fastcall sub_F8ABC(int a1, int a2)
{
  void *v4; // [sp+8h] [bp+8h] BYREF
  void *v5; // [sp+Ch] [bp+Ch] BYREF

  if ( *(_DWORD *)(a1 + 28) )
  {
    get_raw_clib_object(*(_DWORD *)(a2 + 16), &v5);
    (*(void (__fastcall **)(void *))(a1 + 28))(v5);
  }
  delete_clib_object(*(void ***)(a2 + 16));
  if ( *(_DWORD *)(a2 + 20) )
  {
    if ( *(_DWORD *)(a1 + 32) )
    {
      get_raw_clib_object(*(_DWORD *)(a2 + 20), &v4);
      (*(void (__fastcall **)(void *))(a1 + 32))(v4);
    }
    delete_clib_object(*(void ***)(a2 + 20));
  }
}

//----- (000F8B30) --------------------------------------------------------
int __fastcall delete_c_rb(void **a1)
{
  void **ptr; // [sp+Ch] [bp+Ch]

  ptr = (void **)*a1;
  while ( a1 + 1 != ptr )
  {
    if ( *ptr == a1 + 1 )
    {
      if ( ptr[1] == a1 + 1 )
      {
        sub_F8ABC((int)a1, (int)ptr);
        if ( ptr[2] )
        {
          ptr = (void **)ptr[2];
          if ( *ptr == a1 + 1 )
          {
            if ( ptr[1] != a1 + 1 )
            {
              free(ptr[1]);
              ptr[1] = a1 + 1;
            }
          }
          else
          {
            free(*ptr);
            *ptr = a1 + 1;
          }
        }
        else
        {
          free(ptr);
          ptr = a1 + 1;
        }
      }
      else
      {
        ptr = (void **)ptr[1];
      }
    }
    else
    {
      ptr = (void **)*ptr;
    }
  }
  free(a1);
  return 0;
}

//----- (000F8BE8) --------------------------------------------------------
_DWORD *__fastcall minimum_c_rb(int a1, _DWORD *a2)
{
  while ( *a2 != a1 + 4 )
    a2 = (_DWORD *)*a2;
  return a2;
}

//----- (000F8C14) --------------------------------------------------------
int __fastcall maximum_c_rb(int a1, int a2)
{
  while ( *(_DWORD *)(a2 + 4) != a1 + 4 )
    a2 = *(_DWORD *)(a2 + 4);
  return a2;
}

//----- (000F8C40) --------------------------------------------------------
bool __fastcall empty_c_rb(_DWORD *a1)
{
  return *a1 != (_DWORD)(a1 + 1);
}

//----- (000F8C68) --------------------------------------------------------
int *__fastcall tree_successor(int *a1, int a2)
{
  int *v4; // [sp+0h] [bp+0h]
  int *i; // [sp+Ch] [bp+Ch]

  v4 = (int *)a2;
  if ( *(int **)(a2 + 4) != a1 + 1 )
    return minimum_c_rb((int)a1, *(_DWORD **)(a2 + 4));
  if ( maximum_c_rb((int)a1, *a1) == a2 )
    return 0;
  for ( i = (int *)v4[2]; a1 + 1 != i && (int *)i[1] == v4; i = (int *)i[2] )
    v4 = i;
  return i;
}

//----- (000F8CDC) --------------------------------------------------------
int __fastcall sub_F8CDC(_DWORD **a1)
{
  sub_F8D1C((int)a1, *a1);
  sub_F8D54();
  sub_F8D94((int)a1, *a1);
  return sub_F8DD4((int)a1, *a1);
}

//----- (000F8D1C) --------------------------------------------------------
int __fastcall sub_F8D1C(int result, _DWORD *a2)
{
  int v3; // [sp+4h] [bp+4h]

  v3 = result;
  if ( (_DWORD *)(result + 4) != a2 )
  {
    sub_F8D1C(result, *a2);
    return sub_F8D1C(v3, a2[1]);
  }
  return result;
}

//----- (000F8D54) --------------------------------------------------------
void sub_F8D54()
{
  ;
}

//----- (000F8D6C) --------------------------------------------------------
int __fastcall sub_F8D6C(int a1, int a2)
{
  if ( a1 + 4 == a2 )
    return 0;
  else
    return *(_DWORD *)(a2 + 12);
}

//----- (000F8D94) --------------------------------------------------------
int __fastcall sub_F8D94(int a1, _DWORD *a2)
{
  int result; // r0

  result = sub_F8D6C(a1, (int)a2);
  if ( (_DWORD *)(a1 + 4) != a2 )
  {
    sub_F8D94(a1, *a2);
    return sub_F8D94(a1, a2[1]);
  }
  return result;
}

//----- (000F8DD4) --------------------------------------------------------
int __fastcall sub_F8DD4(int a1, _DWORD *a2)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  v3 = -1;
  return sub_F8DFC(a1, a2, 0, &v3);
}

//----- (000F8DFC) --------------------------------------------------------
int __fastcall sub_F8DFC(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int result; // r0

  result = sub_F8D6C(a1, (int)a2);
  if ( !result )
    ++a3;
  if ( (_DWORD *)(a1 + 4) == a2 )
  {
    if ( *a4 == -1 )
      *a4 = a3;
  }
  else
  {
    sub_F8DFC(a1, *a2, a3, a4);
    return sub_F8DFC(a1, a2[1], a3, a4);
  }
  return result;
}

//----- (000F8E60) --------------------------------------------------------
int __fastcall sub_F8E60(__int64 *a1)
{
  sub_1A3C0C(a1[3]);
  sub_1A3C0C(a1[2]);
  sub_1A3C0C(a1[1]);
  return sub_1A3C0C(*a1);
}

//----- (000F8F30) --------------------------------------------------------
double __cdecl diff_from_target(void *target)
{
  double result; // r0

  LODWORD(result) = sub_F8E60((__int64 *)target);
  return result;
}

//----- (000F8F90) --------------------------------------------------------
void *__fastcall diff_to_target_dash(void *a1)
{
  double v1; // d0
  double v2; // r0
  double v3; // r0
  double v4; // r0
  double v6; // [sp+10h] [bp+0h]
  _BYTE v8[28]; // [sp+24h] [bp+14h] BYREF
  _QWORD v9[4]; // [sp+1024h] [bp+1014h] BYREF
  _QWORD *v10; // [sp+1044h] [bp+1034h]
  __int64 v11; // [sp+1048h] [bp+1038h]
  double v12; // [sp+1050h] [bp+1040h]
  double v13; // [sp+1058h] [bp+1048h]

  v6 = v1;
  if ( v1 <= 0.0 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "Diff zero passed to set_target");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/common/mining/dash/dash_common.c",
      82,
      "diff_to_target_dash",
      19,
      59,
      20,
      v8);
    v6 = 1.0;
  }
  v13 = 2.69595353e67 / v6;
  v12 = 2.69595353e67 / v6 / 6.27710174e57;
  v11 = (unsigned __int64)v12;
  v10 = &v9[3];
  v9[3] = (unsigned __int64)v12;
  LODWORD(v2) = sub_1A3C0C((unsigned __int64)v12);
  v13 = v13 - v2 * 6.27710174e57;
  v12 = v13 / 3.40282367e38;
  v11 = (unsigned __int64)(v13 / 3.40282367e38);
  v10 = &v9[2];
  v9[2] = v11;
  LODWORD(v3) = sub_1A3C0C(v11);
  v13 = v13 - v3 * 3.40282367e38;
  v12 = v13 / 1.84467441e19;
  v11 = (unsigned __int64)(v13 / 1.84467441e19);
  v10 = &v9[1];
  v9[1] = v11;
  LODWORD(v4) = sub_1A3C0C(v11);
  v9[0] = (unsigned __int64)(v13 - v4 * 1.84467441e19);
  return memcpy(a1, v9, 0x20u);
}
// F8FA8: variable 'v1' is possibly undefined
// F90F8: variable 'v2' is possibly undefined
// F91B6: variable 'v3' is possibly undefined
// F9274: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000F9330) --------------------------------------------------------
int __fastcall target_to_diff_dash(int a1)
{
  int j; // [sp+Ch] [bp+Ch]
  int i; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+17h] [bp+17h]

  v5 = 0;
  for ( i = 31; i >= 0; --i )
  {
    for ( j = 7; j >= 0; --j )
    {
      if ( (((int)*(unsigned __int8 *)(i + a1) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (000F9398) --------------------------------------------------------
int __fastcall target_to_diff_vbk(int a1)
{
  int j; // [sp+Ch] [bp+Ch]
  int i; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+17h] [bp+17h]

  v5 = 0;
  for ( i = 0; i <= 7; ++i )
  {
    for ( j = 7; j >= 0; --j )
    {
      if ( (((int)*(unsigned __int8 *)(i + a1) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (000F93FC) --------------------------------------------------------
void target_to_double_diff_vbk()
{
  ;
}

//----- (000F941C) --------------------------------------------------------
void diff_to_target_vbk()
{
  ;
}

//----- (000F9438) --------------------------------------------------------
__int64 __fastcall sub_F9438(unsigned __int8 *a1)
{
  __int64 v2; // [sp+20h] [bp+20h]

  LODWORD(v2) = *a1 ^ (a1[3] << 24) ^ (a1[2] << 16) ^ (a1[1] << 8);
  HIDWORD(v2) = a1[4] ^ (a1[5] << 8) ^ (a1[7] << 24) ^ (a1[6] << 16);
  return v2;
}

//----- (000F953C) --------------------------------------------------------
__int64 *__fastcall sub_F953C(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  __int64 v9; // kr18_8
  __int64 v10; // kr20_8
  __int64 v11; // kr30_8
  __int64 v12; // kr38_8
  __int64 v13; // r10
  __int64 v14; // kr40_8
  __int64 v15; // kr48_8
  __int64 v16; // r8
  __int64 *result; // r0
  __int64 v18; // kr50_8
  __int64 v19; // kr58_8
  unsigned __int64 v20; // kr60_8
  __int64 v21; // kr68_8
  __int64 v22; // r8
  int v23; // r5
  int v24; // r6
  __int64 v25; // r8
  __int64 v26; // kr78_8
  __int64 v27; // kr80_8
  __int64 v28; // kr88_8
  unsigned __int64 v29; // kr90_8
  __int64 v30; // kr98_8
  __int64 v31; // r8
  int v32; // r5
  int v33; // r6
  __int64 v34; // r8
  __int64 v35; // krA8_8
  __int64 v36; // [sp+0h] [bp+0h]
  __int64 v37; // [sp+8h] [bp+8h]

  *(_QWORD *)(a1 + 8 * a2) = *(_QWORD *)(8 * a2 + a1) + *(_QWORD *)(8 * a3 + a1) + (a6 ^ a8);
  *(_QWORD *)(a1 + 8 * a5) = *(_QWORD *)(8 * a2 + a1) ^ *(_QWORD *)(8 * a5 + a1);
  HIDWORD(v37) = *(__int64 *)(8 * a5 + a1) >> 28;
  LODWORD(v37) = (16 * *(_DWORD *)(8 * a5 + a1)) | (*(_DWORD *)(8 * a5 + a1 + 4) >> 28);
  *(_QWORD *)(a1 + 8 * a5) = v37;
  *(_QWORD *)(a1 + 8 * a4) = *(_QWORD *)(8 * a5 + a1) + *(_QWORD *)(8 * a4 + a1);
  v9 = *(_QWORD *)(8 * a3 + a1);
  v10 = *(_QWORD *)(8 * a4 + a1);
  HIDWORD(v36) = (v10 ^ v9) >> 11;
  LODWORD(v36) = (((unsigned int)v10 ^ (unsigned int)v9) << 21) | ((unsigned int)(HIDWORD(v10) ^ HIDWORD(v9)) >> 11);
  *(_QWORD *)(a1 + 8 * a3) = v36;
  *(_QWORD *)(a1 + 8 * a2) = (a9 ^ a7) + *(_QWORD *)(8 * a2 + a1) + *(_QWORD *)(8 * a3 + a1);
  v11 = *(_QWORD *)(8 * a5 + a1);
  v12 = *(_QWORD *)(8 * a2 + a1);
  LODWORD(v13) = (v12 ^ v11) >> 5;
  HIDWORD(v13) = (((unsigned int)v12 ^ (unsigned int)v11) << 27) | ((unsigned int)(HIDWORD(v12) ^ HIDWORD(v11)) >> 5);
  *(_QWORD *)(a1 + 8 * a5) = v13;
  *(_QWORD *)(a1 + 8 * a4) = *(_QWORD *)(8 * a5 + a1) + *(_QWORD *)(8 * a4 + a1);
  v14 = *(_QWORD *)(8 * a3 + a1);
  v15 = *(_QWORD *)(8 * a4 + a1);
  LODWORD(v16) = (v15 ^ v14) >> 18;
  HIDWORD(v16) = (((unsigned int)v15 ^ (unsigned int)v14) << 14) | ((unsigned int)(HIDWORD(v15) ^ HIDWORD(v14)) >> 18);
  *(_QWORD *)(a1 + 8 * a3) = v16;
  result = (__int64 *)(a1 + 8 * a5);
  v18 = *result;
  v19 = *(_QWORD *)(8 * a2 + a1);
  v20 = *(_QWORD *)(8 * a3 + a1);
  v21 = *(_QWORD *)(8 * a4 + a1);
  v22 = ~v19 & v20;
  v23 = ~(v21 | v19 | v20) | v21 & v22;
  v24 = ~(HIDWORD(v21) | HIDWORD(v19) | HIDWORD(v20)) | HIDWORD(v21) & HIDWORD(v22);
  v25 = v19 & ~v20;
  v26 = v21;
  *(_DWORD *)result ^= ~(_DWORD)v26 & v19 & v20 | v23 | v26 & v25;
  *((_DWORD *)result + 1) = (~HIDWORD(v26) & ((v19 & v20) >> 32) | v24 | HIDWORD(v26) & HIDWORD(v25)) ^ HIDWORD(v18);
  v27 = *result;
  v28 = *(_QWORD *)(8 * a2 + a1);
  v29 = *(_QWORD *)(8 * a3 + a1);
  v30 = *(_QWORD *)(8 * a4 + a1);
  v31 = ~v28 & v29;
  v32 = ~(v29 | v28) & v30 | ~(_DWORD)v30 & v31;
  v33 = ~(HIDWORD(v29) | HIDWORD(v28)) & HIDWORD(v30) | ~HIDWORD(v30) & HIDWORD(v31);
  v34 = v28 & ~v29;
  v35 = v30;
  *(_DWORD *)result ^= v35 & v28 & v29 | v32 | ~(_DWORD)v35 & v34;
  *((_DWORD *)result + 1) = (HIDWORD(v35) & ((v28 & v29) >> 32) | v33 | ~HIDWORD(v35) & HIDWORD(v34)) ^ HIDWORD(v27);
  return result;
}

//----- (000F99A4) --------------------------------------------------------
int __fastcall sub_F99A4(int a1, int a2)
{
  __int64 v2; // r0
  _QWORD *v3; // r0
  __int64 v4; // kr58_8
  __int64 v5; // kr60_8
  int v6; // r4
  _QWORD v10[16]; // [sp+30h] [bp+8h] BYREF
  _QWORD s[16]; // [sp+B0h] [bp+88h] BYREF
  int m; // [sp+130h] [bp+108h]
  int k; // [sp+134h] [bp+10Ch]
  int j; // [sp+138h] [bp+110h]
  int i; // [sp+13Ch] [bp+114h]
  _BYTE v16[4]; // [sp+140h] [bp+118h] BYREF

  memset(s, 0, sizeof(s));
  memset(v10, 0, sizeof(v10));
  for ( i = 0; i <= 7; ++i )
  {
    *(_QWORD *)&v16[8 * i - 144] = *(_QWORD *)(8 * i + a1);
    *(_QWORD *)&v16[8 * i - 80] = *(_QWORD *)&dword_1EF838[2 * i];
  }
  s[12] ^= 0x40uLL;
  s[14] = ~s[14];
  for ( j = 0; j <= 7; ++j )
  {
    v2 = sub_F9438((unsigned __int8 *)(a2 + 8 * j));
    v10[j] = v2;
  }
  for ( k = 0; k <= 15; ++k )
  {
    sub_F953C(
      (int)s,
      0,
      4,
      8,
      12,
      v10[byte_1EF878[16 * k + 1]],
      v10[byte_1EF878[16 * k]],
      qword_1EF978[byte_1EF878[16 * k + 1]],
      qword_1EF978[byte_1EF878[16 * k]]);
    sub_F953C(
      (int)s,
      1,
      5,
      9,
      13,
      v10[byte_1EF878[16 * k + 3]],
      v10[byte_1EF878[16 * k + 2]],
      qword_1EF978[byte_1EF878[16 * k + 3]],
      qword_1EF978[byte_1EF878[16 * k + 2]]);
    sub_F953C(
      (int)s,
      2,
      6,
      10,
      14,
      v10[byte_1EF878[16 * k + 5]],
      v10[byte_1EF878[16 * k + 4]],
      qword_1EF978[byte_1EF878[16 * k + 5]],
      qword_1EF978[byte_1EF878[16 * k + 4]]);
    sub_F953C(
      (int)s,
      3,
      7,
      11,
      15,
      v10[byte_1EF878[16 * k + 7]],
      v10[byte_1EF878[16 * k + 6]],
      qword_1EF978[byte_1EF878[16 * k + 7]],
      qword_1EF978[byte_1EF878[16 * k + 6]]);
    sub_F953C(
      (int)s,
      0,
      5,
      10,
      15,
      v10[byte_1EF878[16 * k + 9]],
      v10[byte_1EF878[16 * k + 8]],
      qword_1EF978[byte_1EF878[16 * k + 9]],
      qword_1EF978[byte_1EF878[16 * k + 8]]);
    sub_F953C(
      (int)s,
      1,
      6,
      11,
      12,
      v10[byte_1EF878[16 * k + 11]],
      v10[byte_1EF878[16 * k + 10]],
      qword_1EF978[byte_1EF878[16 * k + 11]],
      qword_1EF978[byte_1EF878[16 * k + 10]]);
    sub_F953C(
      (int)s,
      2,
      7,
      8,
      13,
      v10[byte_1EF878[16 * k + 13]],
      v10[byte_1EF878[16 * k + 12]],
      qword_1EF978[byte_1EF878[16 * k + 13]],
      qword_1EF978[byte_1EF878[16 * k + 12]]);
    sub_F953C(
      (int)s,
      3,
      4,
      9,
      14,
      v10[byte_1EF878[16 * k + 15]],
      v10[byte_1EF878[16 * k + 14]],
      qword_1EF978[byte_1EF878[16 * k + 15]],
      qword_1EF978[byte_1EF878[16 * k + 14]]);
  }
  for ( m = 0; m <= 7; ++m )
  {
    v3 = (_QWORD *)(a1 + 8 * m);
    *v3 ^= *(_QWORD *)&v16[8 * m - 80] ^ *(_QWORD *)&v16[8 * m - 144];
  }
  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 48);
  v6 = HIDWORD(v5) ^ HIDWORD(v4) ^ *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 ^= v5 ^ (unsigned int)v4;
  *(_DWORD *)(a1 + 4) = v6;
  *(_QWORD *)(a1 + 8) ^= *(_QWORD *)(a1 + 56) ^ *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 16) ^= *(_QWORD *)(a1 + 40);
  return a1 + 16;
}
// 1EF838: using guessed type int dword_1EF838[];
// 1EF878: using guessed type unsigned __int8 byte_1EF878[256];
// 1EF978: using guessed type _QWORD qword_1EF978[33];

//----- (000FA148) --------------------------------------------------------
int __fastcall sub_FA148(int result, int a2)
{
  int i; // [sp+2Ch] [bp+2Ch]

  for ( i = 0; i <= 2; ++i )
  {
    *(_WORD *)(result + 8 * i) = *(_QWORD *)(a2 + 8 * i);
    *(_BYTE *)(result + 8 * i + 2) = BYTE2(*(_DWORD *)(a2 + 8 * i));
    *(_BYTE *)(result + 8 * i + 3) = HIBYTE(*(_DWORD *)(a2 + 8 * i));
    *(_BYTE *)(result + 8 * i + 4) = *(_DWORD *)(a2 + 8 * i + 4);
    *(_BYTE *)(result + 8 * i + 5) = BYTE1(*(_DWORD *)(a2 + 8 * i + 4));
    *(_BYTE *)(result + 8 * i + 6) = BYTE2(*(_DWORD *)(a2 + 8 * i + 4));
    *(_BYTE *)(result + 8 * i + 7) = HIBYTE(*(_DWORD *)(a2 + 8 * i + 4));
  }
  return result;
}

//----- (000FA288) --------------------------------------------------------
int __fastcall vblake_hash(int a1, int a2)
{
  _BYTE v5[64]; // [sp+8h] [bp+8h] BYREF
  _QWORD s[8]; // [sp+48h] [bp+48h] BYREF
  int i; // [sp+8Ch] [bp+8Ch]

  memset(v5, 0, sizeof(v5));
  s[1] = *(_QWORD *)&dword_1EF840;
  s[2] = *(_QWORD *)&dword_1EF848;
  s[3] = *(_QWORD *)&dword_1EF850;
  s[4] = *(_QWORD *)&dword_1EF858;
  s[5] = *(_QWORD *)&dword_1EF860;
  s[6] = *(_QWORD *)&dword_1EF868;
  s[7] = *(_QWORD *)&dword_1EF870;
  s[0] = *(_QWORD *)dword_1EF838 ^ 0x1010018LL;
  for ( i = 0; i <= 63; ++i )
    v5[i] = *(_BYTE *)(i + a2);
  sub_F99A4((int)s, (int)v5);
  return sub_FA148(a1, (int)s);
}
// 1EF838: using guessed type int dword_1EF838[];
// 1EF840: using guessed type int dword_1EF840;
// 1EF848: using guessed type int dword_1EF848;
// 1EF850: using guessed type int dword_1EF850;
// 1EF858: using guessed type int dword_1EF858;
// 1EF860: using guessed type int dword_1EF860;
// 1EF868: using guessed type int dword_1EF868;
// 1EF870: using guessed type int dword_1EF870;

//----- (000FA3A8) --------------------------------------------------------
int __fastcall sub_FA3A8(int a1, int a2, unsigned int a3)
{
  return eth_sha3_256(a1, 0x20u, a2, a3);
}

//----- (000FA3C8) --------------------------------------------------------
int __fastcall sub_FA3C8(int result, int a2, unsigned int a3)
{
  char v3; // r1
  int v6; // [sp+Ch] [bp+Ch]
  _DWORD v7[7]; // [sp+14h] [bp+14h] BYREF
  __int16 v8; // [sp+30h] [bp+30h]
  int v9; // [sp+34h] [bp+34h]
  int v10; // [sp+38h] [bp+38h]
  int v11; // [sp+3Ch] [bp+3Ch]

  v6 = result;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  v11 = 0;
  while ( a2 && v11 <= 29 )
  {
    sub_1A38EC(a2, a3);
    *((_BYTE *)v7 + v11++) = v3 + 48;
    result = sub_1A3658(a2, a3);
    a2 = result;
  }
  v10 = 0;
  v9 = v11 - 1;
  while ( v10 < v11 )
  {
    *(_BYTE *)(v10 + v6) = *((_BYTE *)v7 + v9);
    ++v10;
    --v9;
  }
  return result;
}
// FA40C: variable 'v3' is possibly undefined

//----- (000FA4A8) --------------------------------------------------------
int __fastcall sub_FA4A8(unsigned __int8 a1)
{
  _BYTE v4[4096]; // [sp+18h] [bp+8h] BYREF

  if ( a1 > 0x2Fu && a1 <= 0x39u )
    return a1 - 48;
  if ( a1 > 0x60u && a1 <= 0x66u )
    return a1 - 87;
  V_LOCK();
  logfmt_raw(v4, 0x1000u, 0, "The provided character %c is invalid and was not rejected in preliminary hex checks!", a1);
  V_UNLOCK();
  zlog(
    g_zc,
    "/home/xingfeiwang/work/share-d/code/1489/godminer/./util.h",
    58,
    "get_value_from_lower_hex",
    24,
    42,
    100,
    v4);
  return -1;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000FA5AC) --------------------------------------------------------
void *__fastcall diff_to_target_eth(void *a1)
{
  return diff_to_be256_target_base(a1);
}

//----- (000FA5CC) --------------------------------------------------------
int __fastcall target_to_diff_eth(int a1)
{
  return be256_target_to_diff_base(a1);
}

//----- (000FA5E4) --------------------------------------------------------
int __fastcall target_to_double_diff_eth(int a1)
{
  return be256_target_to_double_diff_base(a1);
}

//----- (000FA600) --------------------------------------------------------
int __fastcall get_epoch_num(unsigned __int64 a1)
{
  return sub_1A3E94(a1, 0x7530u);
}

//----- (000FA628) --------------------------------------------------------
__int64 __fastcall get_cache_size(int a1)
{
  return qword_1CF328[a1];
}
// 1CF328: using guessed type _QWORD qword_1CF328[2048];

//----- (000FA650) --------------------------------------------------------
__int64 __fastcall get_dag_size(int a1)
{
  return qword_1CB328[a1];
}
// 1CB328: using guessed type _QWORD qword_1CB328[2048];

//----- (000FA678) --------------------------------------------------------
int __fastcall get_epoch_number_eth(const void *a1)
{
  _DWORD v4[8]; // [sp+Ch] [bp+Ch] BYREF
  _DWORD s[8]; // [sp+2Ch] [bp+2Ch] BYREF
  int i; // [sp+4Ch] [bp+4Ch]

  memset(s, 0, sizeof(s));
  for ( i = 1; i < 2048; ++i )
  {
    sub_FA3A8((int)v4, (int)s, 0x20u);
    s[0] = v4[0];
    s[1] = v4[1];
    s[2] = v4[2];
    s[3] = v4[3];
    s[4] = v4[4];
    s[5] = v4[5];
    s[6] = v4[6];
    s[7] = v4[7];
    if ( !memcmp(s, a1, 0x20u) )
      break;
  }
  if ( i == 2048 )
    return 0;
  else
    return i;
}

//----- (000FA6F8) --------------------------------------------------------
_DWORD *__fastcall get_seedhash_by_block_num(_DWORD *a1, unsigned __int64 a2)
{
  int v3; // r1
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r1
  int v8; // r2
  int v9; // r3
  _DWORD s[8]; // [sp+10h] [bp+10h] BYREF
  unsigned __int64 v14; // [sp+30h] [bp+30h]
  unsigned int i; // [sp+3Ch] [bp+3Ch]

  memset(s, 0, sizeof(s));
  LODWORD(v14) = sub_1A3E94(a2, 0x7530u);
  HIDWORD(v14) = v3;
  for ( i = 0; i < v14; ++i )
    sub_FA3A8((int)s, (int)s, 0x20u);
  v4 = s[1];
  v5 = s[2];
  v6 = s[3];
  *a1 = s[0];
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  v7 = s[5];
  v8 = s[6];
  v9 = s[7];
  a1[4] = s[4];
  a1[5] = v7;
  a1[6] = v8;
  a1[7] = v9;
  return a1;
}
// FA726: variable 'v3' is possibly undefined

//----- (000FA780) --------------------------------------------------------
int __fastcall set_cur_seed(_DWORD *a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r1
  int v5; // r2
  int v6; // r3

  pthread_mutex_lock(&stru_47BD5C);
  memset(dword_47BD3C, 0, 0x20u);
  v1 = a1[1];
  v2 = a1[2];
  v3 = a1[3];
  dword_47BD3C[0] = *a1;
  dword_47BD3C[1] = v1;
  dword_47BD3C[2] = v2;
  dword_47BD3C[3] = v3;
  v4 = a1[5];
  v5 = a1[6];
  v6 = a1[7];
  unk_47BD4C = a1[4];
  unk_47BD50 = v4;
  unk_47BD54 = v5;
  unk_47BD58 = v6;
  return pthread_mutex_unlock(&stru_47BD5C);
}
// 47BD3C: using guessed type _DWORD dword_47BD3C[4];
// 47BD5C: using guessed type pthread_mutex_t stru_47BD5C;

//----- (000FA7DC) --------------------------------------------------------
int __fastcall get_cur_seed(_DWORD *a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // r1
  int v5; // r2
  int v6; // r3

  pthread_mutex_lock(&stru_47BD5C);
  v1 = dword_47BD3C[1];
  v2 = dword_47BD3C[2];
  v3 = dword_47BD3C[3];
  *a1 = dword_47BD3C[0];
  a1[1] = v1;
  a1[2] = v2;
  a1[3] = v3;
  v4 = unk_47BD50;
  v5 = unk_47BD54;
  v6 = unk_47BD58;
  a1[4] = unk_47BD4C;
  a1[5] = v4;
  a1[6] = v5;
  a1[7] = v6;
  return pthread_mutex_unlock(&stru_47BD5C);
}
// 47BD3C: using guessed type _DWORD dword_47BD3C[4];
// 47BD40: using guessed type _DWORD;
// 47BD44: using guessed type _DWORD;
// 47BD48: using guessed type _DWORD;
// 47BD5C: using guessed type pthread_mutex_t stru_47BD5C;

//----- (000FA828) --------------------------------------------------------
int __fastcall sub_FA828(__int64 *a1)
{
  sub_1A3C0C(a1[3]);
  sub_1A3C0C(a1[2]);
  sub_1A3C0C(a1[1]);
  return sub_1A3C0C(*a1);
}

//----- (000FA8F8) --------------------------------------------------------
int __fastcall target_to_double_diff_dcr(__int64 *a1)
{
  return sub_FA828(a1);
}

//----- (000FA958) --------------------------------------------------------
void *__fastcall diff_to_target_dcr(void *a1)
{
  double v1; // d0
  void *result; // r0
  double v3; // [sp+0h] [bp+0h]
  unsigned __int64 v5; // [sp+10h] [bp+10h]
  int i; // [sp+1Ch] [bp+1Ch]

  v3 = v1;
  for ( i = 6; i > 0 && v3 > 1.0; --i )
    v3 = v3 / 4294967300.0;
  v5 = (unsigned __int64)(4294901760.0 / v3);
  if ( !v5 && i == 6 )
    return memset(a1, 255, 0x20u);
  result = memset(a1, 0, 0x20u);
  *((_DWORD *)a1 + i) = v5;
  *((_DWORD *)a1 + i + 1) = HIDWORD(v5);
  return result;
}
// FA960: variable 'v1' is possibly undefined

//----- (000FAA18) --------------------------------------------------------
int __fastcall target_to_diff_dcr(int a1)
{
  int j; // [sp+Ch] [bp+Ch]
  int i; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+17h] [bp+17h]

  v5 = 0;
  for ( i = 31; i >= 0; --i )
  {
    for ( j = 7; j >= 0; --j )
    {
      if ( (((int)*(unsigned __int8 *)(i + a1) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (000FAA80) --------------------------------------------------------
void *__fastcall graph_init_ae(int a1)
{
  memset(gEdges, 0, sizeof(gEdges));
  memset(&gSols, 0, 0x2B0u);
  return cuckoo_hash_init(a1);
}
// 47E340: using guessed type _DWORD gEdges[336];

//----- (000FAABC) --------------------------------------------------------
void __fastcall graph_exit_ae(int a1)
{
  cuckoo_hash_exit(a1);
}

//----- (000FAAD4) --------------------------------------------------------
int __fastcall sub_FAAD4(int a1, int a2, unsigned int a3, unsigned int a4)
{
  int result; // r0

  gEdges[84 * a1 + 2 * a2] = a3 >> 1;
  result = 42 * a1;
  gEdges[2 * a2 + 1 + 2 * result] = a4 >> 1;
  return result;
}
// 47E340: using guessed type _DWORD gEdges[336];

//----- (000FAB28) --------------------------------------------------------
int __fastcall sub_FAB28(int a1, unsigned int *a2, int a3, unsigned int *a4, int a5)
{
  int result; // r0
  int v6; // r1
  int v8; // r1
  int v14; // [sp+14h] [bp+14h]

  v14 = 1;
  for ( result = sub_FAAD4(a1, 0, *a2, *a4); a3--; result = sub_FAAD4(a1, v6, a2[(a3 + 1) & 0xFFFFFFFE], a2[a3 | 1]) )
    v6 = v14++;
  while ( a5-- )
  {
    v8 = v14++;
    result = sub_FAAD4(a1, v8, a4[a5 | 1], a4[(a5 + 1) & 0xFFFFFFFE]);
  }
  if ( v14 == 42 )
    gSols[172 * a1] = 1;
  return result;
}
// 47E880: using guessed type _BYTE gSols[688];

//----- (000FABE4) --------------------------------------------------------
unsigned int __fastcall sub_FABE4(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // r3
  unsigned int v5; // r3
  unsigned int v8; // [sp+8h] [bp+8h]
  unsigned int i; // [sp+14h] [bp+14h]

  v8 = a2;
  for ( i = 0; ; ++i )
  {
    if ( !v8 )
      return i;
    if ( i > 0xFF )
      break;
    v5 = i;
    *(_DWORD *)(4 * v5 + a3) = v8;
    v8 = cuckoo_hash_operator(a1, v8);
  }
  do
    v3 = i--;
  while ( v3 && *(_DWORD *)(4 * i + a3) != v8 );
  if ( i != -1 )
  {
    printf("illegal %4d-cycle from node %d\n", 256 - i, a2);
    exit(0);
  }
  puts("\nWARNINIG: maximum path length exceeded");
  return 0;
}

//----- (000FAC7C) --------------------------------------------------------
unsigned int __fastcall graph_add_edge_ae(unsigned int result, int a2, int a3)
{
  unsigned int v3; // r3
  unsigned int v4; // r3
  int v7; // [sp+14h] [bp+Ch]
  int v8; // [sp+20h] [bp+18h]
  int v9; // [sp+24h] [bp+1Ch]
  unsigned int v10; // [sp+28h] [bp+20h]
  int i; // [sp+28h] [bp+20h]
  unsigned int v12; // [sp+2Ch] [bp+24h]
  unsigned int v13; // [sp+2Ch] [bp+24h]
  int v14; // [sp+2Ch] [bp+24h]

  v7 = result;
  v9 = 2 * a2;
  v8 = (2 * a3) | 1;
  if ( 2 * a2 )
  {
    v12 = sub_FABE4(result, v9, (int)&us[512 * result]);
    result = sub_FABE4(v7, v8, (int)&vs[512 * v7]);
    v3 = v12;
    v13 = v12 - 1;
    if ( v3 )
    {
      v10 = result - 1;
      if ( result )
      {
        if ( us[512 * v7 + v13] == vs[512 * v7 + v10] )
        {
          v4 = v13;
          if ( v13 >= v10 )
            v4 = result - 1;
          v14 = v13 - v4;
          for ( i = v10 - v4; ; ++i )
          {
            result = v7 << 9;
            if ( us[512 * v7 + v14] == vs[512 * v7 + i] )
              break;
            ++v14;
          }
          if ( i + v14 == 41 )
            return sub_FAB28(v7, &us[512 * v7], v14, &vs[512 * v7], i);
        }
        else if ( v13 >= v10 )
        {
          while ( v10-- )
            cuckoo_hash_set(v7, vs[512 * v7 + 1 + v10], vs[512 * v7 + v10]);
          return cuckoo_hash_set(v7, v8, v9);
        }
        else
        {
          while ( v13-- )
            cuckoo_hash_set(v7, us[512 * v7 + 1 + v13], us[512 * v7 + v13]);
          return cuckoo_hash_set(v7, v9, v8);
        }
      }
    }
  }
  return result;
}
// 47C340: using guessed type unsigned int vs[2048];
// 47EB30: using guessed type unsigned int us[2048];

//----- (000FAE50) --------------------------------------------------------
int __fastcall get_sols_ae(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, int a8)
{
  int v9; // r3
  unsigned int v13; // [sp+2Ch] [bp+Ch]
  unsigned int v14; // [sp+30h] [bp+10h]
  int j; // [sp+34h] [bp+14h]
  int i; // [sp+38h] [bp+18h]
  int v17; // [sp+3Ch] [bp+1Ch]

  if ( !gSols[172 * a1] )
    return 0;
  v17 = 0;
  for ( i = 0; i < a8; ++i )
  {
    v14 = sip_node_ae(a1, a2, a3, a4, a5, *(_DWORD *)(4 * i + a7), 0);
    v13 = sip_node_ae(a1, a2, a3, a4, a5, *(_DWORD *)(4 * i + a7), 1u);
    for ( j = 0; j <= 41; ++j )
    {
      if ( v14 >> 1 == gEdges[84 * a1 + 2 * j] && v13 >> 1 == gEdges[84 * a1 + 1 + 2 * j] )
      {
        v9 = v17++;
        *(_DWORD *)(4 * v9 + a6) = *(_DWORD *)(4 * i + a7);
      }
    }
  }
  return 1;
}
// 47E340: using guessed type _DWORD gEdges[336];
// 47E880: using guessed type _BYTE gSols[688];

//----- (000FAF7C) --------------------------------------------------------
void *__fastcall cuckoo_hash_init(int a1)
{
  void *result; // r0

  result = calloc(0x100u, 8u);
  cuckoo[a1] = result;
  return result;
}
// 480B30: using guessed type _DWORD cuckoo[4];

//----- (000FAFA8) --------------------------------------------------------
void __fastcall cuckoo_hash_exit(int a1)
{
  free((void *)cuckoo[a1]);
}
// 480B30: using guessed type _DWORD cuckoo[4];

//----- (000FAFCC) --------------------------------------------------------
int __fastcall cuckoo_hash_set(int result, unsigned int a2, int a3)
{
  unsigned __int64 v3; // kr00_8
  __int64 v4; // [sp+18h] [bp+18h]
  unsigned int i; // [sp+24h] [bp+24h]

  for ( i = a2 >> 22; ; i = (unsigned __int8)(i + 1) )
  {
    v3 = *(_QWORD *)(8 * i + cuckoo[result]);
    if ( !v3 || v3 >> 30 == a2 )
      break;
  }
  HIDWORD(v4) = (unsigned __int64)a2 >> 2;
  LODWORD(v4) = a3 | (a2 << 30);
  *(_QWORD *)(cuckoo[result] + 8 * i) = v4;
  return result;
}
// 480B30: using guessed type _DWORD cuckoo[4];

//----- (000FB074) --------------------------------------------------------
int __fastcall cuckoo_hash_operator(int a1, unsigned int a2)
{
  unsigned __int64 v2; // kr00_8
  unsigned int i; // [sp+14h] [bp+14h]

  for ( i = a2 >> 22; ; i = (unsigned __int8)(i + 1) )
  {
    v2 = *(_QWORD *)(8 * i + cuckoo[a1]);
    if ( !v2 )
      return 0;
    if ( v2 >> 30 == a2 )
      break;
  }
  return v2 & 0x3FFFFFFF;
}
// 480B30: using guessed type _DWORD cuckoo[4];

//----- (000FB0E4) --------------------------------------------------------
int __fastcall sub_FB0E4(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  int result; // r0

  qword_47BD78[a1] = a2;
  qword_47BD98[a1] = a3;
  qword_47BDB8[a1] = a4;
  result = 8 * a1;
  *(_QWORD *)((char *)&unk_47BDD8 + result) = a5;
  return result;
}
// 47BD78: using guessed type _QWORD qword_47BD78[4];
// 47BD98: using guessed type _QWORD qword_47BD98[4];
// 47BDB8: using guessed type _QWORD qword_47BDB8[4];

//----- (000FB15C) --------------------------------------------------------
unsigned __int64 __fastcall sub_FB15C(unsigned __int64 a1, char a2)
{
  return (a1 >> (-a2 & 0x3F)) | (a1 << a2);
}

//----- (000FB1E4) --------------------------------------------------------
unsigned __int64 __fastcall sub_FB1E4(int a1)
{
  __int64 v1; // kr08_8
  int v2; // r2
  __int64 v3; // kr10_8
  __int64 v4; // kr18_8
  unsigned __int64 v5; // r0

  v1 = qword_47BD98[a1];
  v2 = HIDWORD(qword_47BD78[a1]) ^ HIDWORD(v1);
  v3 = qword_47BDB8[a1];
  v4 = qword_47BDD8[a1];
  LODWORD(v5) = LODWORD(qword_47BD78[a1]) ^ v1 ^ v4 ^ v3;
  HIDWORD(v5) = v2 ^ HIDWORD(v4) ^ HIDWORD(v3);
  return sub_FB15C(v5, 17);
}
// 47BD78: using guessed type _QWORD qword_47BD78[4];
// 47BD98: using guessed type _QWORD qword_47BD98[4];
// 47BDB8: using guessed type _QWORD qword_47BDB8[4];
// 47BDD8: using guessed type _QWORD qword_47BDD8[4];

//----- (000FB268) --------------------------------------------------------
int __fastcall sub_FB268(int result)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r2
  _DWORD *v3; // r2
  _DWORD *v4; // r2

  v1 = &qword_47BD78[result];
  *v1 = 0;
  v1[1] = 0;
  v2 = &qword_47BD98[result];
  *v2 = 0;
  v2[1] = 0;
  v3 = &qword_47BDB8[result];
  *v3 = 0;
  v3[1] = 0;
  v4 = (_DWORD *)((char *)&unk_47BDD8 + 8 * result);
  *v4 = 0;
  v4[1] = 0;
  return result;
}
// 47BD78: using guessed type _QWORD qword_47BD78[4];
// 47BD98: using guessed type _QWORD qword_47BD98[4];
// 47BDB8: using guessed type _QWORD qword_47BDB8[4];

//----- (000FB2E4) --------------------------------------------------------
int __fastcall sub_FB2E4(int a1)
{
  qword_47BD78[a1] += qword_47BD98[a1];
  qword_47BDB8[a1] += qword_47BDD8[a1];
  qword_47BD98[a1] = sub_FB15C(qword_47BD98[a1], 13);
  qword_47BDD8[a1] = sub_FB15C(qword_47BDD8[a1], 16);
  qword_47BD98[a1] ^= qword_47BD78[a1];
  qword_47BDD8[a1] ^= qword_47BDB8[a1];
  qword_47BD78[a1] = sub_FB15C(qword_47BD78[a1], 32);
  qword_47BDB8[a1] += qword_47BD98[a1];
  qword_47BD78[a1] += qword_47BDD8[a1];
  qword_47BD98[a1] = sub_FB15C(qword_47BD98[a1], 17);
  qword_47BDD8[a1] = sub_FB15C(qword_47BDD8[a1], 21);
  qword_47BD98[a1] ^= qword_47BDB8[a1];
  qword_47BDD8[a1] ^= qword_47BD78[a1];
  qword_47BDB8[a1] = sub_FB15C(qword_47BDB8[a1], 32);
  return 8 * a1;
}
// 47BD78: using guessed type _QWORD qword_47BD78[4];
// 47BD98: using guessed type _QWORD qword_47BD98[4];
// 47BDB8: using guessed type _QWORD qword_47BDB8[4];
// 47BDD8: using guessed type _QWORD qword_47BDD8[4];

//----- (000FB614) --------------------------------------------------------
int __fastcall sub_FB614(int a1, __int64 a2)
{
  int v3; // r2
  _DWORD *v4; // r3
  int v5; // r3

  qword_47BDD8[a1] ^= a2;
  sub_FB2E4(a1);
  sub_FB2E4(a1);
  qword_47BD78[a1] ^= a2;
  v3 = HIDWORD(qword_47BDB8[a1]);
  v4 = &qword_47BDB8[a1];
  *v4 ^= 0xFFu;
  v4[1] = v3;
  sub_FB2E4(a1);
  sub_FB2E4(a1);
  sub_FB2E4(a1);
  sub_FB2E4(a1);
  return v5;
}
// FB6D0: variable 'v5' is possibly undefined
// 47BD78: using guessed type _QWORD qword_47BD78[4];
// 47BDB8: using guessed type _QWORD qword_47BDB8[4];
// 47BDD8: using guessed type _QWORD qword_47BDD8[4];

//----- (000FB6D8) --------------------------------------------------------
_QWORD *__fastcall sub_FB6D8(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  result[3] = a2[3];
  return result;
}

//----- (000FB71C) --------------------------------------------------------
int __fastcall sip_node_ae(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, unsigned int a7)
{
  sub_FB0E4(a1, a2, a3, a4, a5);
  sub_FB614(a1, a7 | (unsigned __int64)(unsigned int)(2 * a6));
  return sub_FB1E4(a1) & 0x1FFFFFFF;
}

//----- (000FB77C) --------------------------------------------------------
_QWORD *__fastcall generate_sipkeys_ae(int a1, unsigned int a2, _QWORD *a3)
{
  _QWORD v5[4]; // [sp+10h] [bp+10h] BYREF

  blake2b(v5, a1, a2);
  return sub_FB6D8(a3, v5);
}

//----- (000FB7AC) --------------------------------------------------------
int __fastcall siphash_verify_ae(int a1, int a2, int a3, int a4)
{
  return 0;
}

//----- (000FB7D0) --------------------------------------------------------
void *__fastcall diff_to_target_ltc(void *a1)
{
  double v1; // d0
  double v2; // r0
  double v3; // r0
  double v4; // r0
  double v6; // [sp+0h] [bp+0h]
  _QWORD src[4]; // [sp+14h] [bp+14h] BYREF
  _QWORD *v9; // [sp+34h] [bp+34h]
  __int64 v10; // [sp+38h] [bp+38h]
  double v11; // [sp+40h] [bp+40h]
  double v12; // [sp+48h] [bp+48h]

  v6 = v1;
  if ( v1 <= 0.0 )
    v6 = 1.0;
  v12 = 2.69595353e67 * 65536.0 / v6;
  v11 = v12 / 6.27710174e57;
  v10 = (unsigned __int64)(v12 / 6.27710174e57);
  v9 = &src[3];
  src[3] = v10;
  LODWORD(v2) = sub_1A3C0C(v10);
  v12 = v12 - v2 * 6.27710174e57;
  v11 = v12 / 3.40282367e38;
  v10 = (unsigned __int64)(v12 / 3.40282367e38);
  v9 = &src[2];
  src[2] = v10;
  LODWORD(v3) = sub_1A3C0C(v10);
  v12 = v12 - v3 * 3.40282367e38;
  v11 = v12 / 1.84467441e19;
  v10 = (unsigned __int64)(v12 / 1.84467441e19);
  v9 = &src[1];
  src[1] = v10;
  LODWORD(v4) = sub_1A3C0C(v10);
  src[0] = (unsigned __int64)(v12 - v4 * 1.84467441e19);
  return memcpy(a1, src, 0x20u);
}
// FB7D8: variable 'v1' is possibly undefined
// FB872: variable 'v2' is possibly undefined
// FB8D4: variable 'v3' is possibly undefined
// FB936: variable 'v4' is possibly undefined

//----- (000FB9A8) --------------------------------------------------------
int __fastcall target_to_diff_ltc(int a1)
{
  int j; // [sp+14h] [bp+14h]
  int i; // [sp+18h] [bp+18h]
  unsigned __int8 v5; // [sp+1Fh] [bp+1Fh]

  v5 = 0;
  for ( i = 24; i >= 0; i -= 8 )
  {
    for ( j = 63; j >= 0; --j )
    {
      if ( ((*(_QWORD *)(i + a1) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (000FBA34) --------------------------------------------------------
int __fastcall sub_FBA34(__int64 *a1)
{
  sub_1A3C0C(a1[3]);
  sub_1A3C0C(a1[2]);
  sub_1A3C0C(a1[1]);
  return sub_1A3C0C(*a1);
}

//----- (000FBB08) --------------------------------------------------------
int __fastcall target_to_double_diff_ltc(__int64 *a1)
{
  return sub_FBA34(a1);
}

//----- (000FBB68) --------------------------------------------------------
void *__fastcall sub_FBB68(int *a1, int a2, int a3)
{
  int v3; // r0
  __int64 v4; // kr00_8
  int v5; // r3
  void *result; // r0

  *a1 = a2;
  v3 = *a1;
  a1[4] = 1 << *a1;
  a1[5] = (1 << (v3 - 32)) | (1u >> (32 - v3));
  *((_QWORD *)a1 + 1) = *((_QWORD *)a1 + 2);
  v4 = *((_QWORD *)a1 + 2);
  v5 = v4 >> 1;
  a1[6] = v5 - 1;
  a1[7] = (v5 != 0) + (HIDWORD(v4) >> 1) - 1;
  *((_QWORD *)a1 + 4) = *((_QWORD *)a1 + 3);
  a1[12] = a3;
  a1[10] = *((_QWORD *)a1 + 1) >> a1[12];
  a1[11] = a1[10];
  a1[15] = 2;
  a1[13] = -1;
  a1[20] = (int)new_compressor(*a1, a1[12]);
  a1[21] = (int)new_compressor(*a1, a1[12]);
  a1[22] = (int)new_bitmap(2 * a1[10]);
  a1[23] = (int)new_siphash();
  a1[17] = (int)calloc(2 * a1[10], 4u);
  if ( !a1[17] )
    puts("graph adjlist calloc failed!");
  a1[19] = (int)calloc(2 * a1[10], 8u);
  if ( !a1[19] )
    puts("graph link calloc failed!");
  a1[18] = (int)calloc(a1[15], 0xACu);
  if ( !a1[18] )
    puts("graph sols calloc failed!");
  result = memset((void *)a1[17], (unsigned __int8)a1[13], 8 * a1[10]);
  a1[14] = 0;
  a1[16] = 0;
  return result;
}

//----- (000FBD18) --------------------------------------------------------
void __fastcall sub_FBD18(int a1)
{
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)(a1 + 88) + 32))(*(_DWORD *)(a1 + 88));
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)(a1 + 80) + 44))(*(_DWORD *)(a1 + 80));
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)(a1 + 84) + 44))(*(_DWORD *)(a1 + 84));
  if ( *(_DWORD *)(a1 + 76) )
    free(*(void **)(a1 + 76));
  if ( *(_DWORD *)(a1 + 68) )
    free(*(void **)(a1 + 68));
  if ( *(_DWORD *)(a1 + 72) )
    free(*(void **)(a1 + 72));
}

//----- (000FBD88) --------------------------------------------------------
__int64 __fastcall sub_FBD88(int a1, int a2)
{
  __int64 v2; // r0
  _QWORD s[64]; // [sp+8h] [bp+8h] BYREF
  __int64 v7; // [sp+208h] [bp+208h]
  unsigned int v8; // [sp+210h] [bp+210h]
  unsigned int i; // [sp+214h] [bp+214h]

  memset(s, 0, sizeof(s));
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)(a1 + 92) + 84))(*(_DWORD *)(a1 + 92));
  v8 = a2 & 0xFFFFFFC0;
  for ( i = 0; i <= 0x3E; ++i )
  {
    (*(void (__fastcall **)(_DWORD, _DWORD, unsigned int, _DWORD))(*(_DWORD *)(a1 + 92) + 80))(
      *(_DWORD *)(a1 + 92),
      *(_DWORD *)(*(_DWORD *)(a1 + 92) + 80),
      i + v8,
      0);
    v2 = ((__int64 (__fastcall *)(_DWORD))*(_DWORD *)(*(_DWORD *)(a1 + 92) + 76))(*(_DWORD *)(a1 + 92));
    s[i] = v2;
  }
  (*(void (__fastcall **)(_DWORD, _DWORD, unsigned int, _DWORD))(*(_DWORD *)(a1 + 92) + 80))(
    *(_DWORD *)(a1 + 92),
    *(_DWORD *)(*(_DWORD *)(a1 + 92) + 80),
    v8 + 63,
    0);
  s[63] = 0;
  v7 = ((__int64 (__fastcall *)(_DWORD))*(_DWORD *)(*(_DWORD *)(a1 + 92) + 76))(*(_DWORD *)(a1 + 92));
  return v7 ^ s[a2 & 0x3F];
}

//----- (000FBEA4) --------------------------------------------------------
void *__fastcall sub_FBEA4(_DWORD *a1, int a2, int a3, int a4)
{
  void *result; // r0
  int v9; // [sp+14h] [bp+14h]

  result = (void *)(*(int (__fastcall **)(_DWORD, int))(a1[22] + 24))(a1[22], a3);
  if ( !result )
  {
    *(_DWORD *)(172 * a1[14] + a1[18]) = a2;
    if ( a3 == a4 )
    {
      if ( a2 == 42 && a1[14] < a1[15] )
      {
        result = memcpy((void *)(172 * (a1[14] + 1) + a1[18] + 4), (const void *)(172 * a1[14] + a1[18] + 4), 0xA8u);
        ++a1[14];
      }
    }
    else if ( a2 != 42 )
    {
      v9 = *(_DWORD *)(4 * a3 + a1[17]);
      if ( a1[13] != v9 )
      {
        (*(void (__fastcall **)(_DWORD, int))(a1[22] + 20))(a1[22], a3);
        while ( a1[13] != v9 )
        {
          *(_DWORD *)(4 * a2 + a1[18] + 172 * a1[14] + 4) = v9;
          sub_FBEA4(a1, a2 + 1, *(_DWORD *)(8 * v9 + a1[19] + 4), a4);
          v9 = *(_DWORD *)(8 * v9 + a1[19]);
        }
        return (void *)(*(int (__fastcall **)(_DWORD, int))(a1[22] + 16))(a1[22], a3);
      }
    }
  }
  return result;
}

//----- (000FBFD4) --------------------------------------------------------
_DWORD *__fastcall sub_FBFD4(_DWORD *result, int a2, int a3, int a4)
{
  int v4; // r3
  int v5; // r2
  _DWORD *v6; // r3
  int v7; // [sp+4h] [bp+4h]
  int v8; // [sp+8h] [bp+8h]
  _DWORD *v9; // [sp+Ch] [bp+Ch]
  int v10; // [sp+10h] [bp+10h]

  v9 = result;
  v8 = a2;
  v7 = result[11] + a3;
  if ( a4 )
  {
    v7 = a2;
    v8 = result[11] + a3;
  }
  if ( *(_DWORD *)(4 * v7 + result[17]) != result[13] )
  {
    *(_DWORD *)(172 * result[14] + result[18] + 4) = result[16];
    result = sub_FBEA4(result, 1, v7, v8);
  }
  v4 = v9[16];
  v9[16] = v4 + 1;
  v10 = v4;
  *(_DWORD *)(8 * v4 + v9[19]) = *(_DWORD *)(4 * v8 + v9[17]);
  v5 = v9[19];
  v6 = (_DWORD *)(4 * v8 + v9[17]);
  *v6 = v10;
  *(_DWORD *)(8 * *v6 + v5 + 4) = v7;
  return result;
}

//----- (000FC080) --------------------------------------------------------
_DWORD *__fastcall sub_FC080(_DWORD *a1, int a2, int a3)
{
  char v5; // [sp+8h] [bp+8h]
  unsigned int v7; // [sp+10h] [bp+10h]
  unsigned int v8; // [sp+14h] [bp+14h]

  v5 = a2;
  v8 = (*(int (__fastcall **)(_DWORD, int))(a1[20] + 52))(a1[20], a2);
  v7 = (*(int (__fastcall **)(_DWORD, int))(a1[21] + 52))(a1[21], a3);
  return sub_FBFD4(a1, v8 >> 1, v7 >> 1, v5 & 1);
}

//----- (000FC0CC) --------------------------------------------------------
size_t *__fastcall sub_FC0CC(int a1)
{
  _DWORD *v4; // [sp+Ch] [bp+Ch]
  size_t *v5; // [sp+10h] [bp+10h]
  signed int i; // [sp+14h] [bp+14h]

  v5 = (size_t *)calloc(1u, 8u);
  if ( !v5 )
    puts("sols stats calloc failed!");
  *v5 = *(_DWORD *)(a1 + 56);
  if ( !*v5 )
    return v5;
  v4 = calloc(*v5, 0xACu);
  if ( v4 )
  {
    for ( i = 0; (int)*v5 > i; ++i )
    {
      *v4 = *(_DWORD *)(172 * i + *(_DWORD *)(a1 + 72));
      memcpy(v4 + 1, (const void *)(172 * i + *(_DWORD *)(a1 + 72) + 4), 0xA8u);
    }
    v5[1] = (size_t)v4;
    return v5;
  }
  puts("s calloc failed!");
  return 0;
}

//----- (000FC180) --------------------------------------------------------
_DWORD *__fastcall new_graph29(int a1, int a2)
{
  _DWORD *v5; // [sp+Ch] [bp+Ch]

  v5 = calloc(1u, 0x78u);
  if ( !v5 )
    puts("graph calloc failed!");
  v5[24] = 1031017;
  v5[25] = 1031449;
  v5[29] = 1031561;
  v5[26] = 1032149;
  v5[27] = 1032321;
  v5[28] = 1032397;
  ((void (__fastcall *)(_DWORD *, int, int))v5[24])(v5, a1, a2);
  return v5;
}

//----- (000FC208) --------------------------------------------------------
void __fastcall free_graph29(void (__fastcall **a1)(_DWORD))
{
  if ( a1 )
  {
    a1[25](a1);
    free(a1);
  }
}

//----- (000FC22C) --------------------------------------------------------
void *__fastcall diff_to_target_ckb(void *a1)
{
  return diff_to_be256_target_base(a1);
}

//----- (000FC24C) --------------------------------------------------------
int __fastcall target_to_diff_ckb(int a1)
{
  return be256_target_to_diff_base(a1);
}

//----- (000FC264) --------------------------------------------------------
int __fastcall target_to_double_diff_ckb(int a1)
{
  return be256_target_to_double_diff_base(a1);
}

//----- (000FC280) --------------------------------------------------------
void *__fastcall sub_FC280(int *a1, int a2, int a3)
{
  int v3; // r0
  void *result; // r0

  *a1 = a2;
  v3 = *a1;
  a1[4] = 1 << *a1;
  a1[5] = (1 << (v3 - 32)) | (1u >> (32 - v3));
  *((_QWORD *)a1 + 1) = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 3) = *((_QWORD *)a1 + 2) - 1LL;
  *((_QWORD *)a1 + 4) = *((_QWORD *)a1 + 3);
  a1[12] = a3;
  a1[10] = *((_QWORD *)a1 + 1) >> a1[12];
  a1[11] = a1[10];
  a1[15] = 2;
  a1[13] = -1;
  a1[20] = (int)new_compressor(*a1, a1[12]);
  a1[21] = (int)new_compressor(*a1, a1[12]);
  a1[22] = (int)new_bitmap(2 * a1[10]);
  a1[23] = (int)new_siphash();
  a1[17] = (int)calloc(2 * a1[10], 4u);
  if ( !a1[17] )
    puts("graph adjlist calloc failed!");
  a1[19] = (int)calloc(2 * a1[10], 8u);
  if ( !a1[19] )
    puts("graph link calloc failed!");
  a1[18] = (int)calloc(a1[15], 0xACu);
  if ( !a1[18] )
    puts("graph sols calloc failed!");
  result = memset((void *)a1[17], (unsigned __int8)a1[13], 8 * a1[10]);
  a1[14] = 0;
  a1[16] = 0;
  return result;
}

//----- (000FC428) --------------------------------------------------------
void __fastcall sub_FC428(int a1)
{
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)(a1 + 88) + 32))(*(_DWORD *)(a1 + 88));
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)(a1 + 80) + 44))(*(_DWORD *)(a1 + 80));
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)(a1 + 84) + 44))(*(_DWORD *)(a1 + 84));
  if ( *(_DWORD *)(a1 + 76) )
    free(*(void **)(a1 + 76));
  if ( *(_DWORD *)(a1 + 68) )
    free(*(void **)(a1 + 68));
  if ( *(_DWORD *)(a1 + 72) )
    free(*(void **)(a1 + 72));
}

//----- (000FC498) --------------------------------------------------------
__int64 __fastcall sub_FC498(int a1, int a2, int a3)
{
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)(a1 + 92) + 84))(*(_DWORD *)(a1 + 92));
  (*(void (__fastcall **)(_DWORD, int, int, int))(*(_DWORD *)(a1 + 92) + 80))(
    *(_DWORD *)(a1 + 92),
    2 * a2,
    a3 | (2 * a2),
    (a3 >> 31) | __CFADD__(a2, a2));
  return *(_QWORD *)(a1 + 32)
       & ((__int64 (__fastcall *)(_DWORD))*(_DWORD *)(*(_DWORD *)(a1 + 92) + 76))(*(_DWORD *)(a1 + 92));
}

//----- (000FC50C) --------------------------------------------------------
void *__fastcall sub_FC50C(_DWORD *a1, int a2, unsigned int a3, int a4)
{
  void *result; // r0
  unsigned int v9; // [sp+14h] [bp+14h]

  result = (void *)(*(int (__fastcall **)(_DWORD, unsigned int))(a1[22] + 24))(a1[22], a3 >> 1);
  if ( !result )
  {
    *(_DWORD *)(172 * a1[14] + a1[18]) = a2;
    if ( (a3 ^ 1) == a4 )
    {
      if ( a2 == 42 && (int)a1[14] <= 1 )
      {
        result = memcpy((void *)(172 * (a1[14] + 1) + a1[18] + 4), (const void *)(172 * a1[14] + a1[18] + 4), 0xA8u);
        ++a1[14];
      }
    }
    else if ( a2 != 42 )
    {
      v9 = *(_DWORD *)(4 * (a3 ^ 1) + a1[17]);
      if ( a1[13] != v9 )
      {
        (*(void (__fastcall **)(_DWORD, unsigned int))(a1[22] + 20))(a1[22], a3 >> 1);
        while ( a1[13] != v9 )
        {
          *(_DWORD *)(4 * a2 + a1[18] + 172 * a1[14] + 4) = v9 >> 1;
          sub_FC50C(a1, a2 + 1, *(_DWORD *)(8 * (v9 ^ 1) + a1[19] + 4), a4);
          v9 = *(_DWORD *)(8 * v9 + a1[19]);
        }
        return (void *)(*(int (__fastcall **)(_DWORD, unsigned int))(a1[22] + 16))(a1[22], a3 >> 1);
      }
    }
  }
  return result;
}

//----- (000FC64C) --------------------------------------------------------
_DWORD *__fastcall sub_FC64C(_DWORD *result, unsigned int a2, int a3)
{
  int v3; // r3
  int v4; // r3
  int v5; // r2
  _DWORD *v6; // r3
  int v7; // r2
  _DWORD *v8; // r3
  int v9; // [sp+4h] [bp+4h]
  _DWORD *v11; // [sp+Ch] [bp+Ch]
  int v12; // [sp+10h] [bp+10h]
  int v13; // [sp+14h] [bp+14h]

  v11 = result;
  v9 = result[11] + a3;
  if ( *(_DWORD *)(4 * (a2 ^ 1) + result[17]) != result[13] && *(_DWORD *)(4 * (v9 ^ 1) + result[17]) != result[13] )
  {
    *(_DWORD *)(172 * result[14] + result[18] + 4) = result[16] >> 1;
    result = sub_FC50C(result, 1, a2, v9);
  }
  v3 = v11[16];
  v11[16] = v3 + 1;
  v13 = v3;
  v4 = v11[16];
  v11[16] = v4 + 1;
  v12 = v4;
  *(_DWORD *)(8 * v13 + v11[19]) = *(_DWORD *)(4 * a2 + v11[17]);
  *(_DWORD *)(8 * v4 + v11[19]) = *(_DWORD *)(4 * v9 + v11[17]);
  v5 = v11[19];
  v6 = (_DWORD *)(4 * a2 + v11[17]);
  *v6 = v13;
  *(_DWORD *)(8 * *v6 + v5 + 4) = a2;
  v7 = v11[19];
  v8 = (_DWORD *)(4 * v9 + v11[17]);
  *v8 = v12;
  *(_DWORD *)(8 * *v8 + v7 + 4) = v9;
  return result;
}

//----- (000FC740) --------------------------------------------------------
_DWORD *__fastcall sub_FC740(_DWORD *a1, int a2, int a3)
{
  int v6; // [sp+10h] [bp+10h]
  unsigned int v7; // [sp+14h] [bp+14h]

  v7 = (*(int (__fastcall **)(_DWORD, int))(a1[20] + 52))(a1[20], a2);
  v6 = (*(int (__fastcall **)(_DWORD, int))(a1[21] + 52))(a1[21], a3);
  return sub_FC64C(a1, v7, v6);
}

//----- (000FC784) --------------------------------------------------------
size_t *__fastcall sub_FC784(int a1)
{
  _DWORD *v4; // [sp+Ch] [bp+Ch]
  size_t *v5; // [sp+10h] [bp+10h]
  signed int i; // [sp+14h] [bp+14h]

  v5 = (size_t *)calloc(1u, 8u);
  if ( !v5 )
    puts("sols stats calloc failed!");
  *v5 = *(_DWORD *)(a1 + 56);
  if ( !*v5 )
    return v5;
  v4 = calloc(*v5, 0xACu);
  if ( v4 )
  {
    for ( i = 0; (int)*v5 > i; ++i )
    {
      *v4 = *(_DWORD *)(172 * i + *(_DWORD *)(a1 + 72));
      memcpy(v4 + 1, (const void *)(172 * i + *(_DWORD *)(a1 + 72) + 4), 0xA8u);
    }
    v5[1] = (size_t)v4;
    return v5;
  }
  puts("s calloc failed!");
  return 0;
}

//----- (000FC838) --------------------------------------------------------
_DWORD *__fastcall new_graph32(int a1, int a2)
{
  _DWORD *v5; // [sp+Ch] [bp+Ch]

  v5 = calloc(1u, 0x78u);
  if ( !v5 )
    puts("graph calloc failed!");
  v5[24] = 1032833;
  v5[25] = 1033257;
  v5[29] = 1033369;
  v5[26] = 1033805;
  v5[27] = 1034049;
  v5[28] = 1034117;
  ((void (__fastcall *)(_DWORD *, int, int))v5[24])(v5, a1, a2);
  return v5;
}

//----- (000FC8C0) --------------------------------------------------------
void __fastcall free_graph32(void (__fastcall **a1)(_DWORD))
{
  if ( a1 )
  {
    a1[25](a1);
    free(a1);
  }
}

//----- (000FC8E4) --------------------------------------------------------
int logfmt_raw(void *a1, size_t a2, int a3, ...)
{
  unsigned int v3; // r2
  int result; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  const char *v8; // r3
  int v9; // r0
  int v10; // r0
  const char *v12; // [sp+10h] [bp+8h]
  double v13; // [sp+20h] [bp+18h]
  const char **v14; // [sp+30h] [bp+28h]
  char v15[4096]; // [sp+34h] [bp+2Ch] BYREF
  const char *v16; // [sp+1034h] [bp+102Ch]
  int v17; // [sp+1038h] [bp+1030h]
  int v18; // [sp+103Ch] [bp+1034h]
  va_list varg_r3; // [sp+1054h] [bp+104Ch] BYREF

  va_start(varg_r3, a3);
  v18 = 0;
  memset(a1, 0, a2);
  memset(v15, 0, sizeof(v15));
  va_copy(v14, varg_r3);
  v17 = 0;
  while ( 2 )
  {
    if ( v17 < dword_47BE10 )
    {
      v3 = ((unsigned int)v14 + 7) & 0xFFFFFFF8;
      v14 = (const char **)(v3 + 32);
      v12 = *(const char **)v3;
      result = *(_DWORD *)(v3 + 16);
      v13 = *(double *)(v3 + 16);
      switch ( *(_DWORD *)(v3 + 8) )
      {
        case 0:
          if ( strchr((const char *)LODWORD(v13), 32)
            || !strcmp((const char *)LODWORD(v13), "true") && strlen((const char *)LODWORD(v13)) == 4 )
          {
            v5 = sprintf((char *)a1 + v18, "%s=\"%s\" ", v12, (const char *)LODWORD(v13));
            v18 += v5;
          }
          else
          {
            v6 = sprintf((char *)a1 + v18, "%s=%s ", v12, (const char *)LODWORD(v13));
            v18 += v6;
          }
          goto LABEL_14;
        case 1:
          v7 = sprintf((char *)a1 + v18, "%s=%lf ", v12, v13);
          v18 += v7;
          goto LABEL_14;
        case 2:
          if ( LOBYTE(v13) )
            v8 = "true";
          else
            v8 = "false";
          v9 = sprintf((char *)a1 + v18, "%s=%s ", v12, v8);
          v18 += v9;
          goto LABEL_14;
        case 3:
          v10 = sprintf((char *)a1 + v18, "%s=%lld ", v12, v13);
          v18 += v10;
LABEL_14:
          ++v17;
          continue;
        default:
          return result;
      }
    }
    break;
  }
  v16 = *v14;
  vsprintf(v15, v16, v14 + 1);
  if ( strchr(v15, 32) )
    result = sprintf((char *)a1 + v18, "msg=\"%s\"", v15);
  else
    result = sprintf((char *)a1 + v18, "msg=%s", v15);
  dword_47BE10 = 0;
  return result;
}
// 47BE10: using guessed type int dword_47BE10;

//----- (000FCC6C) --------------------------------------------------------
int V_LOCK()
{
  return pthread_mutex_lock(&stru_47BDF8);
}
// 47BDF8: using guessed type pthread_mutex_t stru_47BDF8;

//----- (000FCC80) --------------------------------------------------------
int V_UNLOCK()
{
  return pthread_mutex_unlock(&stru_47BDF8);
}
// 47BDF8: using guessed type pthread_mutex_t stru_47BDF8;

//----- (000FCC94) --------------------------------------------------------
const char **__fastcall V_STR(const char **a1, const char *a2, const char *a3)
{
  size_t v3; // r5
  size_t v4; // r4

  ++dword_47BE10;
  v3 = strlen(a2);
  v4 = strlen(a3);
  memset(a1, 0, 0x20u);
  *a1 = a2;
  a1[1] = (const char *)v3;
  a1[4] = a3;
  a1[6] = (const char *)v4;
  return a1;
}
// 47BE10: using guessed type int dword_47BE10;

//----- (000FCCF0) --------------------------------------------------------
int __fastcall V_FLOAT(int a1, const char *a2)
{
  __int64 v2; // d0
  size_t v3; // r1

  ++dword_47BE10;
  v3 = strlen(a2);
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = v3;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = v2;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}
// FCD32: variable 'v2' is possibly undefined
// 47BE10: using guessed type int dword_47BE10;

//----- (000FCD44) --------------------------------------------------------
const char **__fastcall V_BOOL(const char **a1, const char *a2, char a3)
{
  size_t v3; // r4

  ++dword_47BE10;
  v3 = strlen(a2);
  memset(a1, 0, 0x20u);
  *a1 = a2;
  a1[1] = (const char *)v3;
  a1[2] = (const char *)2;
  *((_BYTE *)a1 + 16) = a3;
  return a1;
}
// 47BE10: using guessed type int dword_47BE10;

//----- (000FCD9C) --------------------------------------------------------
int __fastcall V_INT(int a1, const char *a2, __int64 a3)
{
  size_t v3; // r1

  ++dword_47BE10;
  v3 = strlen(a2);
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = v3;
  *(_DWORD *)(a1 + 8) = 3;
  *(_QWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}
// 47BE10: using guessed type int dword_47BE10;

//----- (000FCDF0) --------------------------------------------------------
int log_init()
{
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0

  if ( !opt_zlog_conf_file )
    opt_zlog_conf_file = (int)strdup("/etc/zlog.conf");
  if ( zlog_init(opt_zlog_conf_file) )
  {
    puts("zlog init failed");
    return -1;
  }
  else
  {
    g_zc = zlog_get_category("miner_zc");
    if ( g_zc )
    {
      g_temp_zc = zlog_get_category("miner_temp_zc");
      if ( g_temp_zc )
      {
        g_fan_zc = zlog_get_category("miner_fan_zc");
        if ( g_fan_zc )
        {
          g_hash_zc = zlog_get_category("miner_hash_zc");
          if ( g_hash_zc )
          {
            puts("zlog init OK!");
            return 0;
          }
          else
          {
            v4 = puts("zlog get miner_hash_zc category fail");
            zlog_fini(v4);
            return -4;
          }
        }
        else
        {
          v3 = puts("zlog get miner_fan_zc category fail");
          zlog_fini(v3);
          return -3;
        }
      }
      else
      {
        v2 = puts("zlog get miner_temp_zc category fail");
        zlog_fini(v2);
        return -3;
      }
    }
    else
    {
      v1 = puts("zlog get miner_zc category fail");
      zlog_fini(v1);
      return -2;
    }
  }
}
// 205CC: using guessed type int __fastcall zlog_init(_DWORD);
// 205E4: using guessed type int __fastcall zlog_get_category(_DWORD);
// 209D4: using guessed type int __fastcall zlog_fini(_DWORD);
// 47BE14: using guessed type int opt_zlog_conf_file;
// 47BE18: using guessed type int g_zc;
// 47BE1C: using guessed type int g_temp_zc;
// 47BE20: using guessed type int g_fan_zc;
// 47BE24: using guessed type int g_hash_zc;

//----- (000FCF50) --------------------------------------------------------
int __fastcall log_uninit(int a1)
{
  if ( g_zc || g_temp_zc || g_fan_zc || g_hash_zc )
  {
    zlog_fini(a1);
    g_hash_zc = 0;
    g_temp_zc = 0;
    g_zc = 0;
    puts("zlog uninit!");
  }
  return 0;
}
// 209D4: using guessed type int __fastcall zlog_fini(_DWORD);
// 47BE18: using guessed type int g_zc;
// 47BE1C: using guessed type int g_temp_zc;
// 47BE20: using guessed type int g_fan_zc;
// 47BE24: using guessed type int g_hash_zc;

//----- (000FCFD8) --------------------------------------------------------
int log_reload()
{
  if ( g_zc && g_temp_zc && g_fan_zc && g_hash_zc )
  {
    zlog_reload(opt_zlog_conf_file);
    puts("zlog reload!");
  }
  return 0;
}
// 20A04: using guessed type int __fastcall zlog_reload(_DWORD);
// 47BE14: using guessed type int opt_zlog_conf_file;
// 47BE18: using guessed type int g_zc;
// 47BE1C: using guessed type int g_temp_zc;
// 47BE20: using guessed type int g_fan_zc;
// 47BE24: using guessed type int g_hash_zc;

//----- (000FD038) --------------------------------------------------------
int __fastcall _init_pipe_of_queue(int *a1, int a2, int a3)
{
  int result; // r0

  *a1 = (int)pipe_new(a2, a3);
  a1[2] = pipe_consumer_new(*a1);
  result = pipe_producer_new(*a1);
  a1[1] = result;
  return result;
}

//----- (000FD07C) --------------------------------------------------------
void __fastcall _deinit_pipe_of_queue(int *a1)
{
  pipe_free(*a1);
  pipe_consumer_free(a1[2]);
  pipe_producer_free(a1[1]);
}

//----- (000FD0AC) --------------------------------------------------------
char *__fastcall queue_new(int a1, int a2)
{
  char *v5; // [sp+Ch] [bp+Ch]

  v5 = (char *)calloc(1u, 0x60u);
  _init_pipe_of_queue((int *)v5, a1, a2);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 16), 0);
  pthread_condattr_init((pthread_condattr_t *)v5 + 22);
  pthread_condattr_setclock((pthread_condattr_t *)v5 + 22, 1);
  pthread_cond_init((pthread_cond_t *)(v5 + 40), (const pthread_condattr_t *)v5 + 22);
  *((_DWORD *)v5 + 3) = 0;
  v5[92] = 0;
  return v5;
}

//----- (000FD118) --------------------------------------------------------
void __fastcall queue_free(int a1)
{
  pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  _deinit_pipe_of_queue((int *)a1);
  free((void *)a1);
}

//----- (000FD148) --------------------------------------------------------
int __fastcall queue_enqueue(int a1, char *a2, int a3)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pipe_push(*(_DWORD **)(a1 + 4), a2, a3);
  *(_DWORD *)(a1 + 12) += a3;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
}

//----- (000FD198) --------------------------------------------------------
int __fastcall clean_up(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1);
}

//----- (000FD1B4) --------------------------------------------------------
void __fastcall queue_dequeue(int a1, char *a2, unsigned int a3)
{
  struct __jmp_buf_tag v6; // [sp+20h] [bp+10h] BYREF
  _BYTE v7[12]; // [sp+13Ch] [bp+12Ch] BYREF
  pthread_mutex_t *v9; // [sp+1140h] [bp+1130h]
  int (__fastcall *v10)(pthread_mutex_t *); // [sp+1144h] [bp+1134h]

  v10 = clean_up;
  v9 = (pthread_mutex_t *)(a1 + 16);
  if ( _sigsetjmp(&v6, 0) )
  {
    v10(v9);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&v6);
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&v6);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  while ( *(_DWORD *)(a1 + 12) < a3 )
  {
    if ( *(_BYTE *)(a1 + 92) )
    {
      *(_BYTE *)(a1 + 92) = 0;
      goto LABEL_11;
    }
    pthread_cond_wait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 16));
  }
  if ( pipe_pop(*(_DWORD **)(a1 + 8), a2, a3) != a3 )
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, "%s, unkown error", "queue_dequeue");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/thread_safe_queue.c",
      84,
      "queue_dequeue",
      13,
      81,
      100,
      v7);
    exit(-1);
  }
  *(_DWORD *)(a1 + 12) -= a3;
LABEL_11:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  _pthread_unregister_cancel((__pthread_unwind_buf_t *)&v6);
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000FD394) --------------------------------------------------------
int __fastcall queue_dequeue_for(int a1, char *a2, unsigned int a3, _DWORD *a4)
{
  _BYTE v9[16]; // [sp+20h] [bp+10h] BYREF
  struct timespec v10; // [sp+1020h] [bp+1010h] BYREF
  int v11; // [sp+1028h] [bp+1018h]
  int v12; // [sp+102Ch] [bp+101Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  clock_gettime(1, &v10);
  v11 = v10.tv_nsec + a4[1];
  v10.tv_sec += *a4 + v11 / 1000000000;
  v10.tv_nsec = v11 % 1000000000;
  v12 = 0;
  while ( *(_DWORD *)(a1 + 12) < a3 )
  {
    v12 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 40), (pthread_mutex_t *)(a1 + 16), &v10);
    if ( v12 == 110 )
      goto LABEL_7;
  }
  if ( pipe_pop(*(_DWORD **)(a1 + 8), a2, a3) != a3 )
  {
    V_LOCK();
    logfmt_raw(v9, 0x1000u, 0, "%s, unkown error", "queue_dequeue_for");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/thread_safe_queue.c",
      84,
      "queue_dequeue_for",
      17,
      106,
      100,
      v9);
    exit(-1);
  }
  *(_DWORD *)(a1 + 12) -= a3;
LABEL_7:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return v12;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000FD5A4) --------------------------------------------------------
int __fastcall queue_clear(int a1)
{
  size_t v1; // r0
  int v4; // [sp+1Ch] [bp+Ch] BYREF
  char *v5; // [sp+101Ch] [bp+100Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v1 = pipe_elem_size(*(_DWORD *)a1);
  v5 = (char *)calloc(1u, v1);
  while ( *(int *)(a1 + 12) > 0 )
  {
    if ( pipe_pop(*(_DWORD **)(a1 + 8), v5, 1) != 1 )
    {
      V_LOCK();
      logfmt_raw(&v4, 0x1000u, 0, "%s, unkown error", "queue_clear");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/thread_safe_queue.c",
        84,
        "queue_clear",
        11,
        121,
        100,
        &v4);
      exit(-1);
    }
    --*(_DWORD *)(a1 + 12);
  }
  free(v5);
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000FD6C4) --------------------------------------------------------
int __fastcall queue_try_dequeue(int a1, char *a2, unsigned int a3)
{
  int v7; // [sp+24h] [bp+14h] BYREF
  unsigned __int8 v8; // [sp+1027h] [bp+1017h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v8 = 0;
  if ( *(_DWORD *)(a1 + 12) >= a3 )
  {
    if ( pipe_pop(*(_DWORD **)(a1 + 8), a2, a3) != a3 )
    {
      V_LOCK();
      logfmt_raw(&v7, 0x1000u, 0, "%s, unkown error", "queue_try_dequeue");
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/thread_safe_queue.c",
        84,
        "queue_try_dequeue",
        17,
        140,
        100,
        &v7);
      exit(-1);
    }
    *(_DWORD *)(a1 + 12) -= a3;
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return v8;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000FD810) --------------------------------------------------------
int __fastcall queue_element_num(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (000FD828) --------------------------------------------------------
int __fastcall queue_force_wakeup(int a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  *(_BYTE *)(a1 + 92) = 1;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
}

//----- (000FD860) --------------------------------------------------------
unsigned __int16 __cdecl crc_itu_t_byte(unsigned __int16 crc, const unsigned __int8 data)
{
  return crc_itu_t_table[(unsigned __int8)(data ^ HIBYTE(crc))] ^ (crc << 8);
}
// 1D3840: using guessed type _WORD crc_itu_t_table[256];

//----- (000FD8A4) --------------------------------------------------------
unsigned __int16 __cdecl CRC16_v1(const unsigned __int8 *buffer, int len)
{
  const unsigned __int8 *v2; // r3
  unsigned __int16 i; // [sp+Eh] [bp+Eh]

  for ( i = -1; len--; i = crc_itu_t_byte(i, *v2) )
    v2 = buffer++;
  return i;
}

//----- (000FD8E0) --------------------------------------------------------
int __fastcall BM_CRC16_WITH_KEY(const unsigned __int8 *a1, int a2, unsigned __int16 a3)
{
  const unsigned __int8 *v3; // r3

  while ( a2-- )
  {
    v3 = a1++;
    a3 = crc_itu_t_byte(a3, *v3);
  }
  return a3;
}

//----- (000FD920) --------------------------------------------------------
int BM_CRC8()
{
  return 0;
}

//----- (000FD93C) --------------------------------------------------------
int __fastcall BM_CRC5(_BYTE *a1, unsigned int a2)
{
  _BYTE v4[5]; // [sp+Ch] [bp+Ch]
  int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  bool v7; // [sp+1Ah] [bp+1Ah]
  unsigned __int8 v8; // [sp+1Bh] [bp+1Bh]
  int v9; // [sp+1Ch] [bp+1Ch]
  unsigned int v10; // [sp+20h] [bp+20h]
  unsigned int i; // [sp+24h] [bp+24h]

  v5 = 16843009;
  v6 = 1;
  v10 = 128;
  v9 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v7 = (v10 & *a1) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 128;
      v9 = 0;
      ++a1;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (000FDA5C) --------------------------------------------------------
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len)
{
  const uint8_t *v2; // r3
  unsigned __int16 v7; // [sp+Ch] [bp+Ch]
  unsigned __int8 v8; // [sp+Eh] [bp+Eh]
  unsigned __int8 v9; // [sp+Fh] [bp+Fh]

  v9 = -1;
  v8 = -1;
  while ( w_len-- )
  {
    v2 = p_data++;
    v7 = (unsigned __int8)(v8 ^ *v2);
    v8 = v9 ^ chCRCHTalbe[v8 ^ *v2];
    v9 = chCRCLTalbe[v7];
  }
  return v8 | (v9 << 8);
}
// 1D3A48: using guessed type _BYTE chCRCHTalbe[256];
// 1D3B48: using guessed type _BYTE chCRCLTalbe[256];

//----- (000FDACC) --------------------------------------------------------
int __fastcall xxtea_encode(unsigned int *a1, unsigned int a2, int a3)
{
  int result; // r0
  unsigned int *v4; // r2
  unsigned int *v5; // r2
  _BYTE v8[24]; // [sp+20h] [bp+10h] BYREF
  unsigned int v9; // [sp+1020h] [bp+1010h]
  int v10; // [sp+1024h] [bp+1014h]
  unsigned int v11; // [sp+1028h] [bp+1018h]
  unsigned int i; // [sp+102Ch] [bp+101Ch]
  unsigned int v13; // [sp+1030h] [bp+1020h]
  unsigned int v14; // [sp+1034h] [bp+1024h]

  if ( a2 > 1 )
  {
    v11 = 0x34 / a2 + 6;
    v13 = 0;
    v14 = a1[a2 - 1];
    do
    {
      v13 -= 1640531527;
      v10 = (v13 >> 2) & 3;
      for ( i = 0; a2 - 1 > i; ++i )
      {
        v9 = a1[i + 1];
        v4 = &a1[i];
        *v4 += ((v14 ^ *(_DWORD *)(a3 + 4 * (v10 ^ i & 3))) + (v13 ^ v9))
             ^ (((v14 >> 5) ^ (4 * v9)) + ((16 * v14) ^ (v9 >> 3)));
        v14 = *v4;
      }
      v9 = *a1;
      v5 = &a1[a2 - 1];
      result = ((v14 >> 5) ^ (4 * v9)) + ((16 * v14) ^ (v9 >> 3));
      *v5 += ((v14 ^ *(_DWORD *)(a3 + 4 * (v10 ^ i & 3))) + (v13 ^ v9)) ^ result;
      v14 = *v5;
      --v11;
    }
    while ( v11 );
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, " xxtea encode input data length <= 1");
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/xxtea.c",
             72,
             "xxtea_encode",
             12,
             24,
             100,
             v8);
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000FDDE4) --------------------------------------------------------
int __fastcall xxtea_decode(unsigned int *a1, unsigned int a2, int a3)
{
  int result; // r0
  unsigned int *v4; // r2
  _BYTE v7[24]; // [sp+20h] [bp+10h] BYREF
  unsigned int v8; // [sp+1020h] [bp+1010h]
  int v9; // [sp+1024h] [bp+1014h]
  unsigned int v10; // [sp+1028h] [bp+1018h]
  unsigned int i; // [sp+102Ch] [bp+101Ch]
  unsigned int v12; // [sp+1030h] [bp+1020h]
  unsigned int v13; // [sp+1034h] [bp+1024h]

  if ( a2 > 1 )
  {
    v10 = 0x34 / a2 + 6;
    v12 = -1640531527 * v10;
    v13 = *a1;
    do
    {
      v9 = (v12 >> 2) & 3;
      for ( i = a2 - 1; i; --i )
      {
        v8 = a1[i - 1];
        v4 = &a1[i];
        *v4 -= ((v8 ^ *(_DWORD *)(a3 + 4 * (v9 ^ i & 3))) + (v12 ^ v13))
             ^ (((v8 >> 5) ^ (4 * v13)) + ((16 * v8) ^ (v13 >> 3)));
        v13 = *v4;
      }
      v8 = a1[a2 - 1];
      result = v12 ^ v13;
      *a1 -= ((v8 ^ *(_DWORD *)(a3 + 4 * v9)) + (v12 ^ v13)) ^ (((v8 >> 5) ^ (4 * v13)) + ((16 * v8) ^ (v13 >> 3)));
      v13 = *a1;
      v12 += 1640531527;
      --v10;
    }
    while ( v10 );
  }
  else
  {
    V_LOCK();
    logfmt_raw(v7, 0x1000u, 0, " xxtea decode input data length <= 1");
    V_UNLOCK();
    return zlog(
             g_zc,
             "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/xxtea.c",
             72,
             "xxtea_decode",
             12,
             53,
             100,
             v7);
  }
  return result;
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000FE0FC) --------------------------------------------------------
int __fastcall data_enc(unsigned int *a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  char v7; // [sp+18h] [bp+8h]
  _BYTE v8[4100]; // [sp+20h] [bp+10h] BYREF

  v7 = a2;
  if ( a3 == 1 )
  {
    if ( (a2 & 7) != 0 )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, " xxtea input data length %% 8 must be 0, but now is %d", v7 & 7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/xxtea.c",
        72,
        "data_enc",
        8,
        93,
        100,
        v8);
      return 0;
    }
    else
    {
      xxtea_encode(a1, a2 >> 2, (int)&xxtea_key + 16 * a4);
      return 1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "algorithm_type is %d, but not support it", a3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/xxtea.c",
      72,
      "data_enc",
      8,
      100,
      100,
      v8);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000FE240) --------------------------------------------------------
int __fastcall data_dec(unsigned int *a1, unsigned int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  char v7; // [sp+18h] [bp+8h]
  _BYTE v8[4100]; // [sp+20h] [bp+10h] BYREF

  v7 = a2;
  if ( a3 == 1 )
  {
    if ( (a2 & 7) != 0 )
    {
      V_LOCK();
      logfmt_raw(v8, 0x1000u, 0, " xxtea input data length %% 8 must be 0, but now is %d", v7 & 7);
      V_UNLOCK();
      zlog(
        g_zc,
        "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/xxtea.c",
        72,
        "data_dec",
        8,
        112,
        100,
        v8);
      return 0;
    }
    else
    {
      xxtea_decode(a1, a2 >> 2, (int)&xxtea_key + 16 * a4);
      return 1;
    }
  }
  else
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "algorithm_type is %d, but not support it", a3);
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/common/general/xxtea.c",
      72,
      "data_dec",
      8,
      119,
      100,
      v8);
    return 0;
  }
}
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (000FE384) --------------------------------------------------------
int __fastcall sub_FE384(int a1)
{
  return *(_DWORD *)a1;
}

//----- (000FE39C) --------------------------------------------------------
int __fastcall pipe_elem_size(int a1)
{
  return sub_FE384(a1);
}

//----- (000FE3B4) --------------------------------------------------------
_DWORD *__fastcall sub_FE3B4(_DWORD *a1, _DWORD *a2)
{
  int v2; // r6
  int v3; // r5
  int v4; // r4
  int v5; // r0
  int v7; // [sp+4h] [bp+4h]

  v7 = a2[3];
  v2 = a2[4];
  v3 = a2[5];
  v4 = a2[6];
  v5 = sub_FE384((int)a2);
  *a1 = v7;
  a1[1] = v2;
  a1[2] = v3;
  a1[3] = v4;
  a1[4] = v5;
  return a1;
}

//----- (000FE3F8) --------------------------------------------------------
int __fastcall sub_FE3F8(int a1, int a2, int a3, int a4, int a5)
{
  return a2 - a1 - a5;
}

//----- (000FE420) --------------------------------------------------------
bool __fastcall sub_FE420(int a1, int a2, unsigned int a3, unsigned int a4)
{
  return a3 >= a4;
}

//----- (000FE450) --------------------------------------------------------
int __fastcall sub_FE450(int a1, int a2, unsigned int a3, unsigned int a4, int a5)
{
  int v5; // r2

  if ( sub_FE420(a1, a2, a3, a4) )
    v5 = a2 - a3 + a4 - a1;
  else
    v5 = a4 - a3;
  return v5 - a5;
}

//----- (000FE4A4) --------------------------------------------------------
unsigned int __fastcall sub_FE4A4(int a1, unsigned int a2, unsigned int a3)
{
  if ( a2 < a3 )
    return a2;
  else
    return a2 - a3 + a1;
}

//----- (000FE4D8) --------------------------------------------------------
unsigned int __fastcall sub_FE4D8(unsigned int a1, unsigned int a2, int a3)
{
  if ( a2 >= a1 )
    return a2;
  else
    return a2 - a1 + a3;
}

//----- (000FE50C) --------------------------------------------------------
char *__fastcall sub_FE50C(char *a1, const void *a2, size_t a3)
{
  memcpy(a1, a2, a3);
  return &a1[a3];
}

//----- (000FE530) --------------------------------------------------------
unsigned int __fastcall sub_FE530(unsigned int a1)
{
  unsigned int v3; // [sp+4h] [bp+4h]
  unsigned int i; // [sp+Ch] [bp+Ch]

  if ( a1 >= 0x80000000 )
    return a1;
  v3 = a1 - 1;
  for ( i = 1; i <= 0x1F; i *= 2 )
    v3 |= v3 >> i;
  return v3 + 1;
}

//----- (000FE590) --------------------------------------------------------
_DWORD *__fastcall sub_FE590(_DWORD *result)
{
  _DWORD v1[5]; // [sp+Ch] [bp+Ch] BYREF

  if ( result )
  {
    if ( result[3] )
      return sub_FE3B4(v1, result);
  }
  return result;
}

//----- (000FE5C0) --------------------------------------------------------
_DWORD *__fastcall sub_FE5C0(int a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  return sub_FE590((_DWORD *)a1);
}

//----- (000FE5EC) --------------------------------------------------------
int __fastcall sub_FE5EC(int a1)
{
  sub_FE590((_DWORD *)a1);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
}

//----- (000FE618) --------------------------------------------------------
_DWORD *__fastcall pipe_new(int a1, int a2)
{
  unsigned int v3; // r3
  unsigned int v4; // r6
  char *v8; // [sp+Ch] [bp+Ch]
  size_t size; // [sp+10h] [bp+10h]
  _DWORD *ptr; // [sp+14h] [bp+14h]

  if ( !a1 )
    return 0;
  ptr = malloc(0xB8u);
  size = 32 * a1;
  v8 = (char *)malloc(32 * a1);
  if ( ptr && v8 )
  {
    if ( a2 )
    {
      v3 = 32 * a1;
      if ( size < a1 * (a2 + 1) )
        v3 = a1 * (a2 + 1);
      v4 = sub_FE530(v3);
    }
    else
    {
      v4 = -1;
    }
    memset(ptr, 0, 0xB8u);
    *ptr = a1;
    ptr[1] = size;
    ptr[2] = v4;
    ptr[3] = v8;
    ptr[4] = &v8[size];
    ptr[5] = v8;
    ptr[6] = &v8[a1];
    ptr[7] = 1;
    ptr[8] = 1;
    pthread_mutex_init((pthread_mutex_t *)(ptr + 9), 0);
    pthread_mutex_init((pthread_mutex_t *)(ptr + 15), 0);
    pthread_cond_init((pthread_cond_t *)(ptr + 22), 0);
    pthread_cond_init((pthread_cond_t *)(ptr + 34), 0);
    sub_FE590(ptr);
    return ptr;
  }
  else
  {
    free(ptr);
    free(v8);
    return 0;
  }
}

//----- (000FE72C) --------------------------------------------------------
int __fastcall pipe_producer_new(int a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  ++*(_DWORD *)(a1 + 28);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
  return a1;
}

//----- (000FE75C) --------------------------------------------------------
int __fastcall pipe_consumer_new(int a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  ++*(_DWORD *)(a1 + 32);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
  return a1;
}

//----- (000FE78C) --------------------------------------------------------
void __fastcall sub_FE78C(int a1)
{
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 36));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 60));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 88));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 136));
  free(*(void **)(a1 + 12));
  free((void *)a1);
}

//----- (000FE7D4) --------------------------------------------------------
void __fastcall pipe_free(int a1)
{
  int v2; // [sp+8h] [bp+8h]
  int v3; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  v3 = --*(_DWORD *)(a1 + 28);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  v2 = --*(_DWORD *)(a1 + 32);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
  if ( v2 )
  {
    if ( !v3 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 88));
  }
  else
  {
    free(*(void **)(a1 + 12));
    *(_DWORD *)(a1 + 12) = 0;
    if ( v3 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 136));
    else
      sub_FE78C(a1);
  }
}

//----- (000FE88C) --------------------------------------------------------
void __fastcall pipe_producer_free(int a1)
{
  int v1; // [sp+Ch] [bp+Ch]
  int v2; // [sp+10h] [bp+10h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
  v2 = --*(_DWORD *)(a1 + 28);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
  if ( !v2 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
    v1 = *(_DWORD *)(a1 + 32);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
    if ( v1 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 88));
    else
      sub_FE78C(a1);
  }
}

//----- (000FE910) --------------------------------------------------------
void __fastcall pipe_consumer_free(int a1)
{
  int v1; // [sp+Ch] [bp+Ch]
  int v2; // [sp+10h] [bp+10h]

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60));
  v2 = --*(_DWORD *)(a1 + 32);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60));
  if ( !v2 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 36));
    v1 = *(_DWORD *)(a1 + 28);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 36));
    if ( v1 )
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 136));
    else
      sub_FE78C(a1);
  }
}

//----- (000FE994) --------------------------------------------------------
char *__fastcall sub_FE994(const void *a1, int a2, const void *a3, unsigned int a4, int a5, char *a6)
{
  char *v6; // r0

  if ( !sub_FE420((int)a1, a2, (unsigned int)a3, a4) )
    return sub_FE50C(a6, a3, a4 - (_DWORD)a3);
  v6 = sub_FE50C(a6, a3, a2 - (_DWORD)a3);
  return sub_FE50C(v6, a1, a4 - (_DWORD)a1);
}

//----- (000FEA04) --------------------------------------------------------
_DWORD *__fastcall sub_FEA04(_DWORD *a1, int a2, unsigned int a3)
{
  const void *v7[5]; // [sp+1Ch] [bp+14h] BYREF
  char *v8; // [sp+30h] [bp+28h]
  int v9; // [sp+34h] [bp+2Ch]
  unsigned int v10; // [sp+38h] [bp+30h]
  unsigned int v11; // [sp+3Ch] [bp+34h]

  sub_FE590((_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 8);
  v10 = *(_DWORD *)(a2 + 4);
  v9 = sub_FE384(a2);
  if ( a3 >= v11 )
    a3 = v11;
  if ( a3 > v10 )
  {
    v8 = (char *)malloc(v9 + a3);
    sub_FE3B4(v7, (_DWORD *)a2);
    *(_DWORD *)(a2 + 24) = sub_FE994(v7[0], (int)v7[1], v7[2], (unsigned int)v7[3], (int)v7[4], v8);
    free(*(void **)(a2 + 12));
    *(_DWORD *)(a2 + 12) = v8;
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 16) = &v8[v9 + a3];
    sub_FE590((_DWORD *)a2);
    sub_FE3B4(a1, (_DWORD *)a2);
  }
  else
  {
    sub_FE3B4(a1, (_DWORD *)a2);
  }
  return a1;
}

//----- (000FEAC8) --------------------------------------------------------
_DWORD *sub_FEAC8(_DWORD *a1, _DWORD *a2, ...)
{
  unsigned int v2; // r0
  _DWORD *v3; // r4
  int v4; // r1
  _DWORD v6[6]; // [sp+8h] [bp+0h] BYREF
  _DWORD *v7; // [sp+20h] [bp+18h]
  _DWORD *v8; // [sp+24h] [bp+1Ch]
  int v9; // [sp+28h] [bp+20h]
  unsigned int v10; // [sp+2Ch] [bp+24h]
  unsigned int v11; // [sp+30h] [bp+28h]
  unsigned int v12; // [sp+34h] [bp+2Ch]
  int varg_r2; // [sp+48h] [bp+40h] BYREF
  va_list varg_r2a; // [sp+48h] [bp+40h]
  int varg_r3; // [sp+4Ch] [bp+44h]
  unsigned int v16; // [sp+50h] [bp+48h]
  unsigned int v17; // [sp+54h] [bp+4Ch]
  int v18; // [sp+58h] [bp+50h]
  int v19; // [sp+5Ch] [bp+54h]
  va_list va1; // [sp+60h] [bp+58h] BYREF

  va_start(va1, a2);
  va_start(varg_r2a, a2);
  varg_r2 = va_arg(va1, _DWORD);
  varg_r3 = va_arg(va1, _DWORD);
  v16 = va_arg(va1, _DWORD);
  v17 = va_arg(va1, _DWORD);
  v18 = va_arg(va1, _DWORD);
  v19 = va_arg(va1, _DWORD);
  v8 = a1;
  v7 = a2;
  v12 = sub_FE384((int)a2);
  v11 = sub_FE3F8(varg_r2, varg_r3, v16, v17, v18);
  if ( v19 + sub_FE450(varg_r2, varg_r3, v16, v17, v18) > v11 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 9));
    sub_FE3B4((int *)varg_r2a, v7);
    v10 = v19 + sub_FE450(varg_r2, varg_r3, v16, v17, v18);
    v9 = v10 / v12;
    if ( v10 > v11 )
    {
      v2 = sub_FE530(v9 + 1);
      sub_FEA04(v6, (int)v7, v12 * v2);
      varg_r2 = v6[0];
      varg_r3 = v6[1];
      v16 = v6[2];
      v17 = v6[3];
      v18 = v6[4];
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 9));
  }
  v3 = v8;
  v4 = varg_r3;
  *v8 = varg_r2;
  v3[1] = v4;
  v3[2] = v16;
  v3[3] = v17;
  v3[4] = v18;
  return v8;
}

//----- (000FEBB8) --------------------------------------------------------
unsigned int __fastcall sub_FEBB8(
        int a1,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        int a5,
        char *a6,
        size_t a7)
{
  size_t v7; // r3
  unsigned int result; // r0
  size_t v9; // [sp+Ch] [bp+4h]
  char *varg_r3; // [sp+24h] [bp+1Ch]
  char *varg_r3a; // [sp+24h] [bp+1Ch]
  unsigned int varg_r3b; // [sp+24h] [bp+1Ch]

  varg_r3 = (char *)a4;
  if ( !sub_FE420(a1, a2, a3, a4) )
  {
    v7 = a7;
    if ( a7 >= a2 - (unsigned int)varg_r3 )
      v7 = a2 - (_DWORD)varg_r3;
    v9 = v7;
    varg_r3 = sub_FE50C(varg_r3, a6, v7);
    a6 += v9;
    a7 -= v9;
  }
  if ( a7 )
  {
    varg_r3a = (char *)sub_FE4A4(a1, (unsigned int)varg_r3, a2);
    varg_r3 = sub_FE50C(varg_r3a, a6, a7);
  }
  result = sub_FE4A4(a1, (unsigned int)varg_r3, a2);
  varg_r3b = result;
  return result;
}

//----- (000FEC5C) --------------------------------------------------------
_DWORD *__fastcall sub_FEC5C(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // r5
  int v4; // r1
  unsigned int v5; // r2
  unsigned int v6; // r3
  int v8; // [sp+8h] [bp+0h] BYREF
  int v9; // [sp+Ch] [bp+4h]
  unsigned int v10; // [sp+10h] [bp+8h]
  unsigned int v11; // [sp+14h] [bp+Ch]
  int v12; // [sp+18h] [bp+10h]
  _DWORD *v13; // [sp+24h] [bp+1Ch]
  _DWORD *v14; // [sp+28h] [bp+20h]
  _DWORD *v15; // [sp+2Ch] [bp+24h]
  int v16; // [sp+34h] [bp+2Ch] BYREF
  int v17; // [sp+38h] [bp+30h]
  unsigned int v18; // [sp+3Ch] [bp+34h]
  unsigned int v19; // [sp+40h] [bp+38h]
  int v20; // [sp+44h] [bp+3Ch]
  int v21; // [sp+48h] [bp+40h]
  int v22; // [sp+4Ch] [bp+44h]

  v15 = a1;
  v14 = a2;
  v13 = a3;
  sub_FE3B4(&v16, a2);
  v22 = sub_FE450(v16, v17, v18, v19, v20);
  v21 = v14[8];
  for ( *v13 = v14[2]; *v13 == v22 && v21; *v13 = v14[2] )
  {
    pthread_cond_wait((pthread_cond_t *)(v14 + 34), (pthread_mutex_t *)(v14 + 15));
    sub_FE3B4(&v8, v14);
    v16 = v8;
    v17 = v9;
    v18 = v10;
    v19 = v11;
    v20 = v12;
    v22 = sub_FE450(v8, v9, v10, v11, v12);
    v21 = v14[8];
  }
  v3 = v15;
  v4 = v17;
  v5 = v18;
  v6 = v19;
  *v15 = v16;
  v3[1] = v4;
  v3[2] = v5;
  v3[3] = v6;
  v3[4] = v20;
  return v15;
}

//----- (000FED18) --------------------------------------------------------
int __fastcall _pipe_push(_DWORD *a1, char *a2, unsigned int a3)
{
  int result; // r0
  int v4; // r4
  int v5; // r0
  int v6; // r4
  size_t v7; // r3
  unsigned int v8; // r0
  int v9; // [sp+10h] [bp+0h] BYREF
  int v10; // [sp+14h] [bp+4h]
  unsigned int v11; // [sp+18h] [bp+8h]
  unsigned int v12; // [sp+1Ch] [bp+Ch]
  int v13; // [sp+20h] [bp+10h]
  unsigned int v14; // [sp+2Ch] [bp+1Ch]
  char *v15; // [sp+30h] [bp+20h]
  _DWORD *v16; // [sp+34h] [bp+24h]
  int v17; // [sp+3Ch] [bp+2Ch] BYREF
  int v18; // [sp+40h] [bp+30h]
  unsigned int v19; // [sp+44h] [bp+34h]
  unsigned int v20; // [sp+48h] [bp+38h]
  int v21; // [sp+4Ch] [bp+3Ch]
  int v22; // [sp+50h] [bp+40h] BYREF
  unsigned int v23; // [sp+54h] [bp+44h]
  size_t v24; // [sp+58h] [bp+48h]
  int v25; // [sp+5Ch] [bp+4Ch]

  v16 = a1;
  v15 = a2;
  v14 = a3;
  result = sub_FE384((int)a1);
  v25 = result;
  if ( v14 )
  {
    v24 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(v16 + 15));
    sub_FEC5C(&v17, v16, &v22);
    if ( v16[8] )
    {
      sub_FEAC8(&v9, v16, v17, v18, v19, v20, v21, v14);
      v17 = v9;
      v18 = v10;
      v19 = v11;
      v20 = v12;
      v21 = v13;
      v4 = v22;
      v5 = sub_FE450(v9, v10, v11, v12, v13);
      if ( v4 - v5 >= v14 )
      {
        v7 = v14;
      }
      else
      {
        v6 = v22;
        v7 = v6 - sub_FE450(v17, v18, v19, v20, v21);
      }
      v24 = v7;
      v8 = sub_FEBB8(v17, v18, v19, v20, v21, v15, v7);
      v16[6] = v8;
      pthread_mutex_unlock((pthread_mutex_t *)(v16 + 15));
      if ( v24 == v25 )
        result = pthread_cond_signal((pthread_cond_t *)(v16 + 22));
      else
        result = pthread_cond_broadcast((pthread_cond_t *)(v16 + 22));
      v23 = v14 - v24;
      if ( v14 != v24 )
        return _pipe_push(v16, &v15[v24], v23);
    }
    else
    {
      return pthread_mutex_unlock((pthread_mutex_t *)(v16 + 15));
    }
  }
  return result;
}

//----- (000FEE54) --------------------------------------------------------
int __fastcall pipe_push(_DWORD *a1, char *a2, int a3)
{
  int v3; // r0

  v3 = sub_FE384((int)a1);
  return _pipe_push(a1, a2, v3 * a3);
}

//----- (000FEE88) --------------------------------------------------------
_DWORD *__fastcall sub_FEE88(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r5
  int v3; // r1
  unsigned int v4; // r2
  unsigned int v5; // r3
  int v7; // [sp+8h] [bp+0h] BYREF
  int v8; // [sp+Ch] [bp+4h]
  unsigned int v9; // [sp+10h] [bp+8h]
  unsigned int v10; // [sp+14h] [bp+Ch]
  int v11; // [sp+18h] [bp+10h]
  _DWORD *v12; // [sp+20h] [bp+18h]
  _DWORD *v13; // [sp+24h] [bp+1Ch]
  int v14; // [sp+28h] [bp+20h] BYREF
  int v15; // [sp+2Ch] [bp+24h]
  unsigned int v16; // [sp+30h] [bp+28h]
  unsigned int v17; // [sp+34h] [bp+2Ch]
  int v18; // [sp+38h] [bp+30h]
  int i; // [sp+3Ch] [bp+34h]

  v13 = a1;
  v12 = a2;
  sub_FE3B4(&v14, a2);
  for ( i = sub_FE450(v14, v15, v16, v17, v18); !i && v12[7]; i = sub_FE450(v7, v8, v9, v10, v11) )
  {
    pthread_cond_wait((pthread_cond_t *)(v12 + 22), (pthread_mutex_t *)(v12 + 9));
    sub_FE3B4(&v7, v12);
    v14 = v7;
    v15 = v8;
    v16 = v9;
    v17 = v10;
    v18 = v11;
  }
  v2 = v13;
  v3 = v15;
  v4 = v16;
  v5 = v17;
  *v13 = v14;
  v2[1] = v3;
  v2[2] = v4;
  v2[3] = v5;
  v2[4] = v18;
  return v13;
}

//----- (000FEF24) --------------------------------------------------------
unsigned int *__fastcall sub_FEF24(
        unsigned int *a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        unsigned int a5,
        int a6,
        char *dest,
        size_t n,
        unsigned int *a9)
{
  size_t v9; // r2
  size_t v10; // r3
  unsigned int v11; // r0
  size_t v14; // [sp+8h] [bp+8h]
  unsigned int varg_r3a; // [sp+2Ch] [bp+2Ch]
  const void *varg_r3b; // [sp+2Ch] [bp+2Ch]
  char *desta; // [sp+38h] [bp+38h]
  size_t na; // [sp+3Ch] [bp+3Ch]

  v9 = a3 - a4 - a6;
  v10 = n;
  if ( n >= v9 )
    v10 = v9;
  v14 = v10;
  desta = sub_FE50C(dest, (const void *)(a6 + a4), v10);
  na = n - v14;
  varg_r3a = sub_FE4A4(a2, v14 + a4, a3);
  if ( na )
  {
    varg_r3b = (const void *)sub_FE4A4(a2, a6 + varg_r3a, a3);
    memcpy(desta, varg_r3b, na);
    v11 = sub_FE4A4(a2, (unsigned int)varg_r3b + na, a3);
    varg_r3a = sub_FE4D8(a2, v11 - a6, a3);
  }
  *a9 = varg_r3a;
  *a1 = a2;
  a1[1] = a3;
  a1[2] = varg_r3a;
  a1[3] = a5;
  a1[4] = a6;
  return a1;
}

//----- (000FF010) --------------------------------------------------------
int sub_FF010(_DWORD *a1, ...)
{
  _DWORD v2[7]; // [sp+8h] [bp+0h] BYREF
  _DWORD *v3; // [sp+24h] [bp+1Ch]
  unsigned int v4; // [sp+2Ch] [bp+24h]
  int varg_r1; // [sp+3Ch] [bp+34h] BYREF
  va_list varg_r1a; // [sp+3Ch] [bp+34h]
  int varg_r2; // [sp+40h] [bp+38h]
  unsigned int varg_r3; // [sp+44h] [bp+3Ch]
  unsigned int v9; // [sp+48h] [bp+40h]
  int v10; // [sp+4Ch] [bp+44h]
  va_list va1; // [sp+50h] [bp+48h] BYREF

  va_start(va1, a1);
  va_start(varg_r1a, a1);
  varg_r1 = va_arg(va1, _DWORD);
  varg_r2 = va_arg(va1, _DWORD);
  varg_r3 = va_arg(va1, _DWORD);
  v9 = va_arg(va1, _DWORD);
  v10 = va_arg(va1, _DWORD);
  v3 = a1;
  v4 = sub_FE3F8(varg_r1, varg_r2, varg_r3, v9, v10);
  if ( sub_FE450(varg_r1, varg_r2, varg_r3, v9, v10) > v4 >> 2 )
    return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 9));
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 9));
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 15));
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 9));
  sub_FE3B4((int *)varg_r1a, v3);
  v4 = sub_FE3F8(varg_r1, varg_r2, varg_r3, v9, v10);
  if ( sub_FE450(varg_r1, varg_r2, varg_r3, v9, v10) <= v4 >> 2 )
    sub_FEA04(v2, (int)v3, v4 >> 1);
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 9));
  return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 15));
}

//----- (000FF0EC) --------------------------------------------------------
size_t __fastcall sub_FF0EC(_DWORD *a1, void *a2, size_t a3)
{
  size_t n; // r3
  int v5; // r0
  unsigned int v7[7]; // [sp+18h] [bp+0h] BYREF
  size_t v8; // [sp+34h] [bp+1Ch]
  void *dest; // [sp+38h] [bp+20h]
  _DWORD *v10; // [sp+3Ch] [bp+24h]
  unsigned int v11; // [sp+44h] [bp+2Ch] BYREF
  unsigned int v12; // [sp+48h] [bp+30h]
  unsigned int v13; // [sp+4Ch] [bp+34h]
  unsigned int v14; // [sp+50h] [bp+38h]
  int v15; // [sp+54h] [bp+3Ch]
  unsigned int v16; // [sp+58h] [bp+40h]
  size_t v17; // [sp+5Ch] [bp+44h]

  v10 = a1;
  dest = a2;
  v8 = a3;
  if ( !a3 )
    return 0;
  v17 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 9));
  sub_FEE88(&v11, v10);
  v16 = sub_FE450(v11, v12, v13, v14, v15);
  if ( v16 )
  {
    sub_FE590(v10);
    n = v16;
    if ( v16 >= v8 )
      n = v8;
    v17 = n;
    sub_FEF24(v7, v11, v12, v13, v14, v15, (char *)dest, n, v10 + 5);
    v11 = v7[0];
    v12 = v7[1];
    v13 = v7[2];
    v14 = v7[3];
    v15 = v7[4];
    sub_FE590(v10);
    sub_FF010(v10, v11, v12, v13, v14, v15);
    v5 = sub_FE384((int)v10);
    if ( v5 == v17 )
      pthread_cond_signal((pthread_cond_t *)(v10 + 34));
    else
      pthread_cond_broadcast((pthread_cond_t *)(v10 + 34));
    return v17;
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 9));
    return 0;
  }
}

//----- (000FF1F8) --------------------------------------------------------
int __fastcall pipe_pop(_DWORD *a1, char *a2, int a3)
{
  size_t v7; // [sp+10h] [bp+10h]
  unsigned int v8; // [sp+14h] [bp+14h]
  unsigned int v9; // [sp+18h] [bp+18h]
  size_t v10; // [sp+1Ch] [bp+1Ch]

  v8 = sub_FE384((int)a1);
  v10 = v8 * a3;
  v9 = 0;
  do
  {
    v7 = sub_FF0EC(a1, a2, v10);
    a2 += v7;
    v9 += v7;
    v10 -= v7;
  }
  while ( v7 && v10 );
  return v9 / v8;
}

//----- (000FF264) --------------------------------------------------------
size_t __fastcall pipe_pop_eager(_DWORD *a1, void *a2, int a3)
{
  unsigned int v7; // [sp+14h] [bp+14h]

  v7 = sub_FE384((int)a1);
  return sub_FF0EC(a1, a2, v7 * a3) / v7;
}

//----- (000FF2A0) --------------------------------------------------------
int __fastcall pipe_reserve(_DWORD *a1, int a2)
{
  _DWORD v3[6]; // [sp+8h] [bp+0h] BYREF
  unsigned int v4; // [sp+20h] [bp+18h]
  _DWORD *v5; // [sp+24h] [bp+1Ch]
  int v6[6]; // [sp+2Ch] [bp+24h] BYREF
  _DWORD *v7; // [sp+44h] [bp+3Ch]

  v5 = a1;
  v7 = a1;
  v4 = sub_FE384((int)a1) * a2;
  if ( !v4 )
    v4 = 32;
  v6[5] = v7[2];
  sub_FE5C0((int)v7);
  sub_FE3B4(v6, v7);
  if ( sub_FE450(v6[0], v6[1], v6[2], v6[3], v6[4]) < v4 )
    sub_FEA04(v3, (int)v7, v4);
  return sub_FE5EC((int)v7);
}

//----- (000FF320) --------------------------------------------------------
void *__fastcall compressor_init(int a1, int a2, int a3)
{
  *(_DWORD *)a1 = a3;
  *(_DWORD *)(a1 + 4) = a2 - a3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4) - 1;
  *(_DWORD *)(a1 + 12) = 1 << *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 12) - 1;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 16) >> 1;
  *(_DWORD *)(a1 + 28) = calloc(*(_DWORD *)(a1 + 12), 4u);
  if ( !*(_DWORD *)(a1 + 28) )
    puts("calloc failed!");
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = -1;
  return memset(*(void **)(a1 + 28), (unsigned __int8)*(_DWORD *)(a1 + 32), 4 * *(_DWORD *)(a1 + 12));
}

//----- (000FF3BC) --------------------------------------------------------
void __fastcall compressor_exit(int a1)
{
  if ( *(_DWORD *)(a1 + 28) )
    free(*(void **)(a1 + 28));
}

//----- (000FF3E0) --------------------------------------------------------
void **__fastcall compressor_reset(void **result)
{
  void **v1; // [sp+4h] [bp+4h]

  v1 = result;
  if ( result[7] )
    result = (void **)memset(result[7], (unsigned __int8)result[8], 4 * (_DWORD)result[3]);
  v1[6] = 0;
  return result;
}

//----- (000FF418) --------------------------------------------------------
int __fastcall compressor_stats(_DWORD *a1)
{
  if ( !a1 )
    return puts("compressor is NULL\n");
  printf("compressbits: %d\n", *a1);
  printf("sizebits: %d\n", a1[1]);
  printf("sizebits1: %d\n", a1[2]);
  printf("npairs: %d\n", a1[6]);
  printf("size: %08x\n", a1[3]);
  printf("mask: %08x\n", a1[4]);
  printf("mask1: %08x\n", a1[5]);
  return printf("NIL: %08x\n\n", a1[8]);
}

//----- (000FF4CC) --------------------------------------------------------
int __fastcall compress(_DWORD *a1, unsigned int a2)
{
  int v3; // r3
  unsigned int v5; // [sp+0h] [bp+0h]
  int v6; // [sp+Ch] [bp+Ch]
  int v7; // [sp+10h] [bp+10h]
  unsigned int v8; // [sp+14h] [bp+14h]

  v7 = a2 & 1;
  v8 = a2 >> *a1;
  v5 = a2 >> 1;
  while ( 1 )
  {
    v6 = *(_DWORD *)(4 * v8 + a1[7]);
    if ( a1[8] == v6 )
      break;
    if ( (~a1[5] & v6) == v5 << a1[2] )
      return v7 | (2 * (v6 & a1[5]));
    v8 = a1[4] & (v8 + 1);
  }
  if ( a1[6] >= a1[3] )
    return a2 & 1;
  *(_DWORD *)(4 * v8 + a1[7]) = a1[6] | (v5 << a1[2]);
  v3 = a1[6];
  a1[6] = v3 + 1;
  return v7 | (2 * v3);
}

//----- (000FF588) --------------------------------------------------------
_DWORD *__fastcall new_compressor(int a1, int a2)
{
  _DWORD *v5; // [sp+Ch] [bp+Ch]

  v5 = calloc(1u, 0x38u);
  if ( !v5 )
    puts("alloc compressor failed!");
  v5[9] = compressor_init;
  v5[10] = compressor_reset;
  v5[11] = compressor_exit;
  v5[12] = compressor_stats;
  v5[13] = compress;
  ((void (__fastcall *)(_DWORD *, int, int))v5[9])(v5, a1, a2);
  return v5;
}

//----- (000FF604) --------------------------------------------------------
int __fastcall free_compressor(int a1)
{
  return (*(int (__fastcall **)(int))(a1 + 44))(a1);
}

//----- (000FF61C) --------------------------------------------------------
unsigned int __fastcall sub_FF61C(unsigned int a1)
{
  return bswap32(a1);
}

//----- (000FF634) --------------------------------------------------------
unsigned int __fastcall sub_FF634(unsigned int result, int a2, unsigned int a3)
{
  unsigned int v5; // [sp+Ch] [bp+Ch]
  unsigned int i; // [sp+14h] [bp+14h]

  v5 = result;
  for ( i = 0; i < a3; ++i )
  {
    result = sub_FF61C(*(_DWORD *)(4 * i + a2));
    *(_DWORD *)(v5 + 4 * i) = result;
  }
  return result;
}

//----- (000FF678) --------------------------------------------------------
int __fastcall sub_FF678(const void *a1, _DWORD *a2, int a3)
{
  unsigned int v3; // r0
  int result; // r0
  _DWORD v7[8]; // [sp+14h] [bp+14h] BYREF
  _DWORD dest[64]; // [sp+34h] [bp+34h] BYREF
  int v9; // [sp+134h] [bp+134h]
  int v10; // [sp+138h] [bp+138h]
  int i; // [sp+13Ch] [bp+13Ch]

  if ( a3 )
  {
    for ( i = 0; i <= 15; ++i )
    {
      v3 = sub_FF61C(a2[i]);
      dest[i] = v3;
    }
  }
  else
  {
    memcpy(dest, a2, 0x40u);
  }
  for ( i = 16; i <= 63; i += 2 )
  {
    dest[i] = (__ROR4__(dest[i - 2], 17) ^ __ROR4__(dest[i - 2], 19) ^ (dest[i - 2] >> 10))
            + dest[i - 7]
            + ((dest[i - 15] >> 3) ^ __ROR4__(dest[i - 15], 7) ^ __ROR4__(dest[i - 15], 18))
            + dest[i - 16];
    dest[i + 1] = (__ROR4__(dest[i - 1], 17) ^ __ROR4__(dest[i - 1], 19) ^ (dest[i - 1] >> 10))
                + dest[i - 6]
                + ((dest[i - 14] >> 3) ^ __ROR4__(dest[i - 14], 7) ^ __ROR4__(dest[i - 14], 18))
                + dest[i - 15];
  }
  memcpy(v7, a1, sizeof(v7));
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[0]
      + 1116352408;
  v9 = (v7[2] & v7[1] | v7[0] & (v7[2] | v7[1])) + (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22));
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[1]
      + 1899447441;
  v9 = (v7[1] & v7[0] | v7[7] & (v7[1] | v7[0])) + (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22));
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[2]
      - 1245643825;
  v9 = (v7[0] & v7[7] | v7[6] & (v7[0] | v7[7])) + (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22));
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[3]
      - 373957723;
  v9 = (v7[7] & v7[6] | v7[5] & (v7[7] | v7[6])) + (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22));
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[4]
      + 961987163;
  v9 = (v7[6] & v7[5] | v7[4] & (v7[6] | v7[5])) + (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22));
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[5]
      + 1508970993;
  v9 = (v7[5] & v7[4] | v7[3] & (v7[5] | v7[4])) + (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22));
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[6]
      - 1841331548;
  v9 = (v7[4] & v7[3] | v7[2] & (v7[4] | v7[3])) + (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22));
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[7]
      - 1424204075;
  v9 = (v7[3] & v7[2] | v7[1] & (v7[3] | v7[2])) + (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22));
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[8]
      - 670586216;
  v9 = (v7[2] & v7[1] | v7[0] & (v7[2] | v7[1])) + (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22));
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[9]
      + 310598401;
  v9 = (v7[1] & v7[0] | v7[7] & (v7[1] | v7[0])) + (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22));
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[10]
      + 607225278;
  v9 = (v7[0] & v7[7] | v7[6] & (v7[0] | v7[7])) + (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22));
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[11]
      + 1426881987;
  v9 = (v7[7] & v7[6] | v7[5] & (v7[7] | v7[6])) + (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22));
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[12]
      + 1925078388;
  v9 = (v7[6] & v7[5] | v7[4] & (v7[6] | v7[5])) + (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22));
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[13]
      - 2132889090;
  v9 = (v7[5] & v7[4] | v7[3] & (v7[5] | v7[4])) + (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22));
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[14]
      - 1680079193;
  v9 = (v7[4] & v7[3] | v7[2] & (v7[4] | v7[3])) + (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22));
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[15]
      - 1046744716;
  v9 = (v7[3] & v7[2] | v7[1] & (v7[3] | v7[2])) + (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22));
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[16]
      - 459576895;
  v9 = (v7[2] & v7[1] | v7[0] & (v7[2] | v7[1])) + (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22));
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[17]
      - 272742522;
  v9 = (v7[1] & v7[0] | v7[7] & (v7[1] | v7[0])) + (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22));
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[18]
      + 264347078;
  v9 = (v7[0] & v7[7] | v7[6] & (v7[0] | v7[7])) + (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22));
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[19]
      + 604807628;
  v9 = (v7[7] & v7[6] | v7[5] & (v7[7] | v7[6])) + (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22));
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[20]
      + 770255983;
  v9 = (v7[6] & v7[5] | v7[4] & (v7[6] | v7[5])) + (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22));
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[21]
      + 1249150122;
  v9 = (v7[5] & v7[4] | v7[3] & (v7[5] | v7[4])) + (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22));
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[22]
      + 1555081692;
  v9 = (v7[4] & v7[3] | v7[2] & (v7[4] | v7[3])) + (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22));
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[23]
      + 1996064986;
  v9 = (v7[3] & v7[2] | v7[1] & (v7[3] | v7[2])) + (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22));
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[24]
      - 1740746414;
  v9 = (v7[2] & v7[1] | v7[0] & (v7[2] | v7[1])) + (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22));
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[25]
      - 1473132947;
  v9 = (v7[1] & v7[0] | v7[7] & (v7[1] | v7[0])) + (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22));
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[26]
      - 1341970488;
  v9 = (v7[0] & v7[7] | v7[6] & (v7[0] | v7[7])) + (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22));
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[27]
      - 1084653625;
  v9 = (v7[7] & v7[6] | v7[5] & (v7[7] | v7[6])) + (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22));
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[28]
      - 958395405;
  v9 = (v7[6] & v7[5] | v7[4] & (v7[6] | v7[5])) + (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22));
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[29]
      - 710438585;
  v9 = (v7[5] & v7[4] | v7[3] & (v7[5] | v7[4])) + (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22));
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[30]
      + 113926993;
  v9 = (v7[4] & v7[3] | v7[2] & (v7[4] | v7[3])) + (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22));
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[31]
      + 338241895;
  v9 = (v7[3] & v7[2] | v7[1] & (v7[3] | v7[2])) + (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22));
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[32]
      + 666307205;
  v9 = (v7[2] & v7[1] | v7[0] & (v7[2] | v7[1])) + (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22));
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[33]
      + 773529912;
  v9 = (v7[1] & v7[0] | v7[7] & (v7[1] | v7[0])) + (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22));
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[34]
      + 1294757372;
  v9 = (v7[0] & v7[7] | v7[6] & (v7[0] | v7[7])) + (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22));
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[35]
      + 1396182291;
  v9 = (v7[7] & v7[6] | v7[5] & (v7[7] | v7[6])) + (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22));
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[36]
      + 1695183700;
  v9 = (v7[6] & v7[5] | v7[4] & (v7[6] | v7[5])) + (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22));
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[37]
      + 1986661051;
  v9 = (v7[5] & v7[4] | v7[3] & (v7[5] | v7[4])) + (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22));
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[38]
      - 2117940946;
  v9 = (v7[4] & v7[3] | v7[2] & (v7[4] | v7[3])) + (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22));
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[39]
      - 1838011259;
  v9 = (v7[3] & v7[2] | v7[1] & (v7[3] | v7[2])) + (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22));
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[40]
      - 1564481375;
  v9 = (v7[2] & v7[1] | v7[0] & (v7[2] | v7[1])) + (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22));
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[41]
      - 1474664885;
  v9 = (v7[1] & v7[0] | v7[7] & (v7[1] | v7[0])) + (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22));
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[42]
      - 1035236496;
  v9 = (v7[0] & v7[7] | v7[6] & (v7[0] | v7[7])) + (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22));
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[43]
      - 949202525;
  v9 = (v7[7] & v7[6] | v7[5] & (v7[7] | v7[6])) + (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22));
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[44]
      - 778901479;
  v9 = (v7[6] & v7[5] | v7[4] & (v7[6] | v7[5])) + (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22));
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[45]
      - 694614492;
  v9 = (v7[5] & v7[4] | v7[3] & (v7[5] | v7[4])) + (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22));
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[46]
      - 200395387;
  v9 = (v7[4] & v7[3] | v7[2] & (v7[4] | v7[3])) + (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22));
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[47]
      + 275423344;
  v9 = (v7[3] & v7[2] | v7[1] & (v7[3] | v7[2])) + (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22));
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[48]
      + 430227734;
  v9 = (v7[2] & v7[1] | v7[0] & (v7[2] | v7[1])) + (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22));
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[49]
      + 506948616;
  v9 = (v7[1] & v7[0] | v7[7] & (v7[1] | v7[0])) + (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22));
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[50]
      + 659060556;
  v9 = (v7[0] & v7[7] | v7[6] & (v7[0] | v7[7])) + (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22));
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[51]
      + 883997877;
  v9 = (v7[7] & v7[6] | v7[5] & (v7[7] | v7[6])) + (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22));
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[52]
      + 958139571;
  v9 = (v7[6] & v7[5] | v7[4] & (v7[6] | v7[5])) + (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22));
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[53]
      + 1322822218;
  v9 = (v7[5] & v7[4] | v7[3] & (v7[5] | v7[4])) + (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22));
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[54]
      + 1537002063;
  v9 = (v7[4] & v7[3] | v7[2] & (v7[4] | v7[3])) + (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22));
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[55]
      + 1747873779;
  v9 = (v7[3] & v7[2] | v7[1] & (v7[3] | v7[2])) + (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22));
  v7[4] += v10;
  v7[0] = v10 + v9;
  v10 = v7[7]
      + (__ROR4__(v7[4], 25) ^ __ROR4__(v7[4], 6) ^ __ROR4__(v7[4], 11))
      + (v7[6] ^ v7[4] & (v7[6] ^ v7[5]))
      + dest[56]
      + 1955562222;
  v9 = (v7[2] & v7[1] | v7[0] & (v7[2] | v7[1])) + (__ROR4__(v7[0], 2) ^ __ROR4__(v7[0], 13) ^ __ROR4__(v7[0], 22));
  v7[3] += v10;
  v7[7] = v10 + v9;
  v10 = v7[6]
      + (__ROR4__(v7[3], 25) ^ __ROR4__(v7[3], 6) ^ __ROR4__(v7[3], 11))
      + (v7[5] ^ v7[3] & (v7[5] ^ v7[4]))
      + dest[57]
      + 2024104815;
  v9 = (v7[1] & v7[0] | v7[7] & (v7[1] | v7[0])) + (__ROR4__(v7[7], 2) ^ __ROR4__(v7[7], 13) ^ __ROR4__(v7[7], 22));
  v7[2] += v10;
  v7[6] = v10 + v9;
  v10 = v7[5]
      + (__ROR4__(v7[2], 25) ^ __ROR4__(v7[2], 6) ^ __ROR4__(v7[2], 11))
      + (v7[4] ^ v7[2] & (v7[4] ^ v7[3]))
      + dest[58]
      - 2067236844;
  v9 = (v7[0] & v7[7] | v7[6] & (v7[0] | v7[7])) + (__ROR4__(v7[6], 2) ^ __ROR4__(v7[6], 13) ^ __ROR4__(v7[6], 22));
  v7[1] += v10;
  v7[5] = v10 + v9;
  v10 = v7[4]
      + (__ROR4__(v7[1], 25) ^ __ROR4__(v7[1], 6) ^ __ROR4__(v7[1], 11))
      + (v7[3] ^ v7[1] & (v7[3] ^ v7[2]))
      + dest[59]
      - 1933114872;
  v9 = (v7[7] & v7[6] | v7[5] & (v7[7] | v7[6])) + (__ROR4__(v7[5], 2) ^ __ROR4__(v7[5], 13) ^ __ROR4__(v7[5], 22));
  v7[0] += v10;
  v7[4] = v10 + v9;
  v10 = v7[3]
      + (__ROR4__(v7[0], 25) ^ __ROR4__(v7[0], 6) ^ __ROR4__(v7[0], 11))
      + (v7[2] ^ v7[0] & (v7[2] ^ v7[1]))
      + dest[60]
      - 1866530822;
  v9 = (v7[6] & v7[5] | v7[4] & (v7[6] | v7[5])) + (__ROR4__(v7[4], 2) ^ __ROR4__(v7[4], 13) ^ __ROR4__(v7[4], 22));
  v7[7] += v10;
  v7[3] = v10 + v9;
  v10 = v7[2]
      + (__ROR4__(v7[7], 25) ^ __ROR4__(v7[7], 6) ^ __ROR4__(v7[7], 11))
      + (v7[1] ^ v7[7] & (v7[1] ^ v7[0]))
      + dest[61]
      - 1538233109;
  v9 = (v7[5] & v7[4] | v7[3] & (v7[5] | v7[4])) + (__ROR4__(v7[3], 2) ^ __ROR4__(v7[3], 13) ^ __ROR4__(v7[3], 22));
  v7[6] += v10;
  v7[2] = v10 + v9;
  v10 = v7[1]
      + (__ROR4__(v7[6], 25) ^ __ROR4__(v7[6], 6) ^ __ROR4__(v7[6], 11))
      + (v7[0] ^ v7[6] & (v7[0] ^ v7[7]))
      + dest[62]
      - 1090935817;
  v9 = (v7[4] & v7[3] | v7[2] & (v7[4] | v7[3])) + (__ROR4__(v7[2], 2) ^ __ROR4__(v7[2], 13) ^ __ROR4__(v7[2], 22));
  v7[5] += v10;
  v7[1] = v10 + v9;
  v10 = v7[0]
      + (__ROR4__(v7[5], 25) ^ __ROR4__(v7[5], 6) ^ __ROR4__(v7[5], 11))
      + (v7[7] ^ v7[5] & (v7[7] ^ v7[6]))
      + dest[63]
      - 965641998;
  result = v7[2];
  v9 = (v7[3] & v7[2] | v7[1] & (v7[3] | v7[2])) + (__ROR4__(v7[1], 2) ^ __ROR4__(v7[1], 13) ^ __ROR4__(v7[1], 22));
  v7[4] += v10;
  v7[0] = v10 + v9;
  for ( i = 0; i <= 7; ++i )
  {
    result = i;
    *((_DWORD *)a1 + i) += v7[i];
  }
  return result;
}

//----- (00102CF4) --------------------------------------------------------
_DWORD *__fastcall sub_102CF4(_DWORD *result)
{
  *result = 1779033703;
  result[1] = -1150833019;
  result[2] = 1013904242;
  result[3] = -1521486534;
  result[4] = 1359893119;
  result[5] = -1694144372;
  result[6] = 528734635;
  result[7] = 1541459225;
  return result;
}

//----- (00102D84) --------------------------------------------------------
void *__fastcall sub_102D84(_DWORD *a1, int a2)
{
  void *result; // r0
  int v5; // [sp+Ch] [bp+Ch] BYREF
  int v6; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int v9; // [sp+1Ch] [bp+1Ch]
  int v10; // [sp+20h] [bp+20h]
  int v11; // [sp+24h] [bp+24h]
  int v12; // [sp+28h] [bp+28h]
  _DWORD v13[8]; // [sp+2Ch] [bp+2Ch] BYREF
  _DWORD dest[4]; // [sp+4Ch] [bp+4Ch] BYREF
  _BYTE v15[48]; // [sp+5Ch] [bp+5Ch] BYREF
  _DWORD v16[8]; // [sp+8Ch] [bp+8Ch]
  _DWORD v17[8]; // [sp+ACh] [bp+ACh] BYREF
  _DWORD v18[8]; // [sp+CCh] [bp+CCh] BYREF
  _DWORD v19[8]; // [sp+ECh] [bp+ECh] BYREF
  _BYTE v20[32]; // [sp+10Ch] [bp+10Ch] BYREF
  _DWORD v21[8]; // [sp+12Ch] [bp+12Ch] BYREF
  _DWORD v22[5]; // [sp+14Ch] [bp+14Ch] BYREF
  int v23; // [sp+160h] [bp+160h] BYREF
  unsigned int i; // [sp+18Ch] [bp+18Ch]

  sub_102CF4(v17);
  sub_FF678(v17, a1, 1);
  memcpy(dest, a1 + 16, sizeof(dest));
  memcpy(v15, &unk_1D3ED8, sizeof(v15));
  sub_FF678(v17, dest, 1);
  v16[0] = v17[0];
  v16[1] = v17[1];
  v16[2] = v17[2];
  v16[3] = v17[3];
  v16[4] = v17[4];
  v16[5] = v17[5];
  v16[6] = v17[6];
  v16[7] = v17[7];
  sub_102CF4(v21);
  for ( i = 0; i <= 7; ++i )
    dest[i] = v16[i] ^ 0x36363636;
  while ( i <= 0xF )
    dest[i++] = 909522486;
  sub_FF678(v21, dest, 0);
  sub_FF678(v21, a1, 1);
  sub_FF634((unsigned int)v22, (int)(a1 + 16), 4u);
  sub_FF634((unsigned int)&v23, (int)&unk_1D3F2C, 0xBu);
  sub_102CF4(v18);
  for ( i = 0; i <= 7; ++i )
    dest[i] = v16[i] ^ 0x5C5C5C5C;
  while ( i <= 0xF )
    dest[i++] = 1549556828;
  sub_FF678(v18, dest, 0);
  result = memcpy(v20, &unk_1D3F08, sizeof(v20));
  for ( i = 0; i <= 3; ++i )
  {
    v5 = v21[0];
    v6 = v21[1];
    v7 = v21[2];
    v8 = v21[3];
    v9 = v21[4];
    v10 = v21[5];
    v11 = v21[6];
    v12 = v21[7];
    v22[4] = i + 1;
    sub_FF678(&v5, v22, 0);
    v19[0] = v5;
    v19[1] = v6;
    v19[2] = v7;
    v19[3] = v8;
    v19[4] = v9;
    v19[5] = v10;
    v19[6] = v11;
    v19[7] = v12;
    v13[0] = v18[0];
    v13[1] = v18[1];
    v13[2] = v18[2];
    v13[3] = v18[3];
    v13[4] = v18[4];
    v13[5] = v18[5];
    v13[6] = v18[6];
    v13[7] = v18[7];
    sub_FF678(v13, v19, 0);
    result = (void *)sub_FF634(32 * i + a2, (int)v13, 8u);
  }
  return result;
}

//----- (00102FE8) --------------------------------------------------------
int __fastcall sub_102FE8(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD dest[4]; // [sp+14h] [bp+14h] BYREF
  _DWORD v8[20]; // [sp+24h] [bp+24h] BYREF
  int v9; // [sp+74h] [bp+74h] BYREF
  int v10; // [sp+78h] [bp+78h]
  int v11; // [sp+7Ch] [bp+7Ch]
  int v12; // [sp+80h] [bp+80h]
  int v13; // [sp+84h] [bp+84h]
  int v14; // [sp+88h] [bp+88h]
  int v15; // [sp+8Ch] [bp+8Ch]
  int v16; // [sp+90h] [bp+90h]
  unsigned int i; // [sp+94h] [bp+94h]
  _DWORD vars0[4]; // [sp+98h] [bp+98h] BYREF

  sub_102CF4(&v9);
  sub_FF678(&v9, a1, 1);
  memcpy(dest, a1 + 16, sizeof(dest));
  memcpy(v8, &unk_1D3ED8, 0x30u);
  sub_FF678(&v9, dest, 1);
  v8[12] = v9;
  v8[13] = v10;
  v8[14] = v11;
  v8[15] = v12;
  v8[16] = v13;
  v8[17] = v14;
  v8[18] = v15;
  v8[19] = v16;
  sub_102CF4(a3);
  for ( i = 0; i <= 7; ++i )
    vars0[i - 33] = vars0[i - 17] ^ 0x5C5C5C5C;
  while ( i <= 0xF )
    vars0[i++ - 33] = 1549556828;
  sub_FF678(a3, dest, 0);
  sub_102CF4(&v9);
  for ( i = 0; i <= 7; ++i )
    vars0[i - 33] = vars0[i - 17] ^ 0x36363636;
  while ( i <= 0xF )
    vars0[i++ - 33] = 909522486;
  sub_FF678(&v9, dest, 0);
  sub_FF678(&v9, a2, 1);
  sub_FF678(&v9, a2 + 16, 1);
  sub_FF678(&v9, dword_1D3F58, 0);
  dest[0] = v9;
  dest[1] = v10;
  dest[2] = v11;
  dest[3] = v12;
  v8[0] = v13;
  v8[1] = v14;
  v8[2] = v15;
  v8[3] = v16;
  memcpy(&v8[4], &unk_1D3F08, 0x20u);
  return sub_FF678(a3, dest, 0);
}
// 1D3F58: using guessed type _DWORD dword_1D3F58[16];

//----- (001031C8) --------------------------------------------------------
int *__fastcall sub_1031C8(int *result, _DWORD *a2)
{
  unsigned int i; // [sp+Ch] [bp+Ch]
  int v3; // [sp+10h] [bp+10h]
  int v4; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]
  int v6; // [sp+14h] [bp+14h]
  int v7; // [sp+18h] [bp+18h]
  int v8; // [sp+18h] [bp+18h]
  int v9; // [sp+1Ch] [bp+1Ch]
  int v10; // [sp+1Ch] [bp+1Ch]
  int v11; // [sp+20h] [bp+20h]
  int v12; // [sp+20h] [bp+20h]
  int v13; // [sp+24h] [bp+24h]
  int v14; // [sp+24h] [bp+24h]
  int v15; // [sp+28h] [bp+28h]
  int v16; // [sp+28h] [bp+28h]
  int v17; // [sp+2Ch] [bp+2Ch]
  int v18; // [sp+2Ch] [bp+2Ch]
  int v19; // [sp+30h] [bp+30h]
  int v20; // [sp+30h] [bp+30h]
  int v21; // [sp+34h] [bp+34h]
  int v22; // [sp+34h] [bp+34h]
  int v23; // [sp+38h] [bp+38h]
  int v24; // [sp+38h] [bp+38h]
  int v25; // [sp+3Ch] [bp+3Ch]
  int v26; // [sp+3Ch] [bp+3Ch]
  int v27; // [sp+40h] [bp+40h]
  int v28; // [sp+40h] [bp+40h]
  int v29; // [sp+44h] [bp+44h]
  int v30; // [sp+44h] [bp+44h]
  int v31; // [sp+48h] [bp+48h]
  int v32; // [sp+48h] [bp+48h]
  int v33; // [sp+4Ch] [bp+4Ch]
  int v34; // [sp+4Ch] [bp+4Ch]

  *result ^= *a2;
  v33 = *result;
  result[1] ^= a2[1];
  v31 = result[1];
  result[2] ^= a2[2];
  v29 = result[2];
  result[3] ^= a2[3];
  v27 = result[3];
  result[4] ^= a2[4];
  v25 = result[4];
  result[5] ^= a2[5];
  v23 = result[5];
  result[6] ^= a2[6];
  v21 = result[6];
  result[7] ^= a2[7];
  v19 = result[7];
  result[8] ^= a2[8];
  v17 = result[8];
  result[9] ^= a2[9];
  v15 = result[9];
  result[10] ^= a2[10];
  v13 = result[10];
  result[11] ^= a2[11];
  v11 = result[11];
  result[12] ^= a2[12];
  v9 = result[12];
  result[13] ^= a2[13];
  v7 = result[13];
  result[14] ^= a2[14];
  v5 = result[14];
  result[15] ^= a2[15];
  v3 = result[15];
  for ( i = 0; i <= 7; i += 2 )
  {
    v26 = __ROR4__(v9 + v33, 25) ^ v25;
    v16 = __ROR4__(v31 + v23, 25) ^ v15;
    v6 = __ROR4__(v21 + v13, 25) ^ v5;
    v28 = __ROR4__(v11 + v3, 25) ^ v27;
    v18 = __ROR4__(v33 + v26, 23) ^ v17;
    v8 = __ROR4__(v23 + v16, 23) ^ v7;
    v30 = __ROR4__(v13 + v6, 23) ^ v29;
    v20 = __ROR4__(v3 + v28, 23) ^ v19;
    v10 = __ROR4__(v26 + v18, 19) ^ v9;
    v32 = __ROR4__(v16 + v8, 19) ^ v31;
    v22 = __ROR4__(v6 + v30, 19) ^ v21;
    v12 = __ROR4__(v28 + v20, 19) ^ v11;
    v34 = __ROR4__(v18 + v10, 14) ^ v33;
    v24 = __ROR4__(v8 + v32, 14) ^ v23;
    v14 = __ROR4__(v30 + v22, 14) ^ v13;
    v4 = __ROR4__(v20 + v12, 14) ^ v3;
    v31 = __ROR4__(v28 + v34, 25) ^ v32;
    v21 = __ROR4__(v26 + v24, 25) ^ v22;
    v11 = __ROR4__(v16 + v14, 25) ^ v12;
    v9 = __ROR4__(v6 + v4, 25) ^ v10;
    v29 = __ROR4__(v34 + v31, 23) ^ v30;
    v19 = __ROR4__(v24 + v21, 23) ^ v20;
    v17 = __ROR4__(v14 + v11, 23) ^ v18;
    v7 = __ROR4__(v4 + v9, 23) ^ v8;
    v27 = __ROR4__(v31 + v29, 19) ^ v28;
    v25 = __ROR4__(v21 + v19, 19) ^ v26;
    v15 = __ROR4__(v11 + v17, 19) ^ v16;
    v5 = __ROR4__(v9 + v7, 19) ^ v6;
    v33 = __ROR4__(v29 + v27, 14) ^ v34;
    v23 = __ROR4__(v19 + v25, 14) ^ v24;
    v13 = __ROR4__(v17 + v15, 14) ^ v14;
    v3 = __ROR4__(v7 + v5, 14) ^ v4;
  }
  *result += v33;
  result[1] += v31;
  result[2] += v29;
  result[3] += v27;
  result[4] += v25;
  result[5] += v23;
  result[6] += v21;
  result[7] += v19;
  result[8] += v17;
  result[9] += v15;
  result[10] += v13;
  result[11] += v11;
  result[12] += v9;
  result[13] += v7;
  result[14] += v5;
  result[15] += v3;
  return result;
}

//----- (0010366C) --------------------------------------------------------
int __fastcall sub_10366C(_DWORD *a1, int a2, _DWORD *a3)
{
  int *v3; // r0
  int *v4; // r0
  int src[32]; // [sp+10h] [bp+10h] BYREF
  unsigned int v9; // [sp+90h] [bp+90h]
  int v10; // [sp+94h] [bp+94h]
  unsigned int v11; // [sp+98h] [bp+98h]
  int *v12; // [sp+9Ch] [bp+9Ch]
  unsigned int j; // [sp+A0h] [bp+A0h]
  unsigned int i; // [sp+A4h] [bp+A4h]

  v12 = src;
  v11 = (a2 + 63) & 0xFFFFFFC0;
  sub_102D84(a1, (int)src);
  for ( i = 0; i < 0x400; i += 2 )
  {
    memcpy((void *)((i << 7) + v11), src, 0x80u);
    sub_1031C8(src, &src[16]);
    sub_1031C8(&src[16], src);
    memcpy((void *)(((i + 1) << 7) + v11), src, 0x80u);
    sub_1031C8(src, &src[16]);
    sub_1031C8(&src[16], src);
  }
  for ( i = 0; i < 0x400; i += 2 )
  {
    v10 = src[16] & 0x3FF;
    v9 = (v10 << 7) + v11;
    for ( j = 0; j <= 0xF; ++j )
    {
      v3 = &v12[2 * j];
      *(_QWORD *)v3 ^= *(_QWORD *)(8 * j + v9);
    }
    sub_1031C8(src, &src[16]);
    sub_1031C8(&src[16], src);
    v10 = src[16] & 0x3FF;
    v9 = (v10 << 7) + v11;
    for ( j = 0; j <= 0xF; ++j )
    {
      v4 = &v12[2 * j];
      *(_QWORD *)v4 ^= *(_QWORD *)(8 * j + v9);
    }
    sub_1031C8(src, &src[16]);
    sub_1031C8(&src[16], src);
  }
  return sub_102FE8(a1, src, a3);
}

//----- (0010388C) --------------------------------------------------------
int __fastcall sub_10388C(int result, int a2)
{
  int v2; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  v2 = result;
  for ( i = 0; i <= 7; ++i )
  {
    result = a2;
    *(_DWORD *)(4 * i + v2) = HIBYTE(*(_DWORD *)(4 * i + a2))
                            | (*(_DWORD *)(4 * i + a2) << 24)
                            | (*(_DWORD *)(4 * i + a2) << 8) & 0xFF0000
                            | (*(_DWORD *)(4 * i + a2) >> 8) & 0xFF00;
  }
  return result;
}

//----- (00103904) --------------------------------------------------------
int __fastcall scrypt_regenhash(_DWORD *a1, int a2)
{
  _DWORD v5[150]; // [sp+10h] [bp+10h] BYREF
  _DWORD v6[20]; // [sp+20210h] [bp+20210h] BYREF
  _DWORD *v7; // [sp+20260h] [bp+20260h]
  unsigned int *v8; // [sp+20264h] [bp+20264h]

  v5[0] = 0;
  memset(&v5[1], 0, (size_t)&stru_201FC);
  v8 = (unsigned int *)(a2 + 76);
  v7 = a1;
  sub_FF634((unsigned int)v6, a2, 0x13u);
  v6[19] = sub_FF61C(*v8);
  sub_10366C(v6, (int)v5, v7);
  return sub_10388C((int)v7, (int)v7);
}
// 201FC: using guessed type Elf32_Rel stru_201FC;

//----- (001039F4) --------------------------------------------------------
int __fastcall scrypt_test(int a1, int a2, unsigned int a3)
{
  _BYTE v5[131596]; // [sp-20208h] [bp-20208h] BYREF
  unsigned int v6; // [sp+4h] [bp+4h]
  int v7; // [sp+8h] [bp+8h]
  int v8; // [sp+Ch] [bp+Ch]
  _DWORD v9[8]; // [sp+14h] [bp+14h] BYREF
  _DWORD v10[20]; // [sp+34h] [bp+34h] BYREF
  unsigned int v11; // [sp+84h] [bp+84h]
  _BYTE *v12; // [sp+88h] [bp+88h]
  unsigned int v13; // [sp+8Ch] [bp+8Ch]

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v13 = *(_DWORD *)(a2 + 28);
  sub_FF634((unsigned int)v10, a1, 0x13u);
  v10[19] = sub_FF61C(v6);
  v12 = v5;
  sub_10366C(v10, (int)v5, v9);
  v11 = sub_FF61C(v9[7]);
  if ( v11 <= 0xFFFF )
    return v11 <= v13;
  else
    return -1;
}

//----- (00103A84) --------------------------------------------------------
int __fastcall PrintState(int a1)
{
  int i; // [sp+14h] [bp+Ch]

  for ( i = 0; i <= 15; ++i )
    printf(
      "0x%02x%02x%02x%02x ",
      HIBYTE(*(_DWORD *)(4 * i + a1)),
      (unsigned __int8)BYTE2(*(_DWORD *)(4 * i + a1)),
      BYTE1(*(_DWORD *)(4 * i + a1)),
      (unsigned __int8)*(_DWORD *)(4 * i + a1));
  return putchar(10);
}

//----- (00103AF4) --------------------------------------------------------
int __fastcall EaglesongPermutation(int result)
{
  int v1; // [sp+4h] [bp+4h]
  int k; // [sp+4Ch] [bp+4Ch]
  int j; // [sp+50h] [bp+50h]
  int i; // [sp+54h] [bp+54h]
  _DWORD vars0[2]; // [sp+58h] [bp+58h] BYREF

  v1 = result;
  for ( i = 0; i < num_rounds; ++i )
  {
    for ( j = 0; j <= 15; ++j )
    {
      vars0[j - 19] = 0;
      for ( k = 0; k <= 15; ++k )
      {
        result = v1;
        vars0[j - 19] ^= *(_DWORD *)(4 * k + v1) * bit_matrix[16 * k + j];
      }
    }
    for ( j = 0; j <= 15; ++j )
      *(_DWORD *)(v1 + 4 * j) = vars0[j - 19];
    for ( j = 0; j <= 15; ++j )
    {
      result = *(_DWORD *)(4 * j + v1)
             ^ (*(_DWORD *)(4 * j + v1) << coefficients[3 * j + 1])
             ^ (*(_DWORD *)(4 * j + v1) >> (32 - coefficients[3 * j + 1]))
             ^ (*(_DWORD *)(4 * j + v1) << coefficients[3 * j + 2]);
      *(_DWORD *)(v1 + 4 * j) = (*(_DWORD *)(4 * j + v1) >> (32 - coefficients[3 * j + 2])) ^ result;
    }
    for ( j = 0; j <= 15; ++j )
    {
      result = 16 * i + j;
      *(_DWORD *)(v1 + 4 * j) = injection_constants[result] ^ *(_DWORD *)(4 * j + v1);
    }
    for ( j = 0; j <= 15; j += 2 )
    {
      *(_DWORD *)(4 * j + v1) += *(_DWORD *)(4 * (j + 1) + v1);
      *(_DWORD *)(4 * j + v1) = __ROR4__(*(_DWORD *)(4 * j + v1), 24);
      *(_DWORD *)(4 * (j + 1) + v1) = __ROR4__(*(_DWORD *)(4 * (j + 1) + v1), 8);
      result = v1;
      *(_DWORD *)(4 * (j + 1) + v1) += *(_DWORD *)(4 * j + v1);
    }
  }
  return result;
}
// 1EFC70: using guessed type _DWORD bit_matrix[256];
// 1F0070: using guessed type _DWORD coefficients[48];
// 1F0130: using guessed type _DWORD injection_constants[688];
// 1F0BF0: using guessed type int num_rounds;

//----- (00103D50) --------------------------------------------------------
unsigned int __fastcall EaglesongSponge(int a1, unsigned int a2, int a3, unsigned int a4, unsigned __int8 a5)
{
  unsigned int result; // r0
  _BYTE v10[64]; // [sp+10h] [bp+10h] BYREF
  int v11; // [sp+50h] [bp+50h]
  int k; // [sp+54h] [bp+54h]
  int j; // [sp+58h] [bp+58h]
  unsigned int i; // [sp+5Ch] [bp+5Ch]
  _DWORD vars0[2]; // [sp+60h] [bp+60h] BYREF

  for ( i = 0; (int)i <= 15; ++i )
    vars0[i - 20] = 0;
  for ( i = 0; (rate + 8 * (a4 + 1) - 1) / rate > i; ++i )
  {
    for ( j = 0; rate / 32 > j; ++j )
    {
      v11 = 0;
      for ( k = 0; k <= 3; ++k )
      {
        if ( k + (int)(i * rate) / 8 + 4 * j >= a4 )
        {
          if ( k + (int)(i * rate) / 8 + 4 * j == a4 )
            v11 = a5 ^ (v11 << 8);
        }
        else
        {
          v11 = *(unsigned __int8 *)(a3 + k + (int)(i * rate) / 8 + 4 * j) ^ (v11 << 8);
        }
      }
      vars0[j - 20] ^= v11;
    }
    EaglesongPermutation((int)v10);
  }
  for ( i = 0; ; ++i )
  {
    result = a2 / (rate / 8);
    if ( result <= i )
      break;
    for ( j = 0; rate / 32 > j; ++j )
    {
      for ( k = 0; k <= 3; ++k )
        *(_BYTE *)(k + (int)(i * rate) / 8 + 4 * j + a1) = vars0[j - 20] >> (8 * k);
    }
    EaglesongPermutation((int)v10);
  }
  return result;
}
// 1F0BF8: using guessed type int rate;

//----- (00103FA0) --------------------------------------------------------
unsigned int __fastcall EaglesongHash(int a1, int a2, unsigned int a3)
{
  return EaglesongSponge(a1, 0x20u, a2, a3, 6u);
}

//----- (00103FC4) --------------------------------------------------------
unsigned int __fastcall _bswap_64(int a1, unsigned int a2)
{
  return bswap32(a2);
}

//----- (00103FEC) --------------------------------------------------------
_QWORD *__fastcall sub_103FEC(_QWORD *result)
{
  *result = result[5];
  result[1] = result[6];
  result[2] = result[7];
  result[3] = result[8];
  return result;
}

//----- (0010403C) --------------------------------------------------------
int __fastcall sub_10403C(int a1, int a2, unsigned int a3, int a4, int a5, unsigned int a6, __int64 a7)
{
  unsigned int *v7; // r5
  unsigned int v8; // r1
  int result; // r0

  memset((void *)(a1 + 40), 0, 0x20u);
  v7 = (unsigned int *)(a2 + a3 - 8);
  *v7 = _bswap_64(a5, a6);
  v7[1] = v8;
  result = blake2b((_DWORD *)(a1 + 40), a2, a3);
  *(_QWORD *)(a1 + 32) = a7;
  return result;
}
// 10406A: variable 'v8' is possibly undefined

//----- (00104090) --------------------------------------------------------
int __fastcall sub_104090(_DWORD *a1)
{
  return a1[6] ^ a1[4] ^ *a1 ^ a1[2];
}

//----- (001040D4) --------------------------------------------------------
_DWORD *__fastcall sub_1040D4(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  return result;
}

//----- (00104120) --------------------------------------------------------
unsigned __int64 __fastcall sub_104120(unsigned __int64 a1, char a2)
{
  return (a1 >> (-a2 & 0x3F)) | (a1 << a2);
}

//----- (001041A8) --------------------------------------------------------
unsigned __int64 __fastcall sub_1041A8(int a1)
{
  int v1; // r4
  int v2; // r2
  __int64 v3; // kr20_8
  int v4; // r2
  __int64 v5; // kr38_8
  int v6; // r4
  unsigned __int64 result; // r0

  *(_QWORD *)a1 += *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) += *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 8) = sub_104120(*(_QWORD *)(a1 + 8), 13);
  *(_QWORD *)(a1 + 24) = sub_104120(*(_QWORD *)(a1 + 24), 16);
  v1 = *(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 8) ^= *(_DWORD *)a1;
  *(_DWORD *)(a1 + 12) = v1;
  v2 = *(_DWORD *)(a1 + 28);
  v3 = *(_QWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 24) ^= v3;
  *(_DWORD *)(a1 + 28) = HIDWORD(v3) ^ v2;
  *(_QWORD *)a1 = sub_104120(*(_QWORD *)a1, 32);
  *(_QWORD *)(a1 + 16) += *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 += *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 8) = sub_104120(*(_QWORD *)(a1 + 8), 17);
  *(_QWORD *)(a1 + 24) = sub_104120(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  v4 = *(_DWORD *)(a1 + 12);
  v5 = *(_QWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) ^= v5;
  *(_DWORD *)(a1 + 12) = HIDWORD(v5) ^ v4;
  v6 = *(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 24) ^= *(_DWORD *)a1;
  *(_DWORD *)(a1 + 28) = v6;
  result = sub_104120(*(_QWORD *)(a1 + 16), 32);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

//----- (0010432C) --------------------------------------------------------
unsigned __int64 __fastcall sub_10432C(int a1, __int64 a2)
{
  int v3; // r2
  int v4; // r4
  __int64 v5; // kr08_8

  v3 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 24) ^= a2;
  *(_DWORD *)(a1 + 28) = HIDWORD(a2) ^ v3;
  sub_1041A8(a1);
  sub_1041A8(a1);
  v4 = HIDWORD(a2) ^ *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 ^= a2;
  *(_DWORD *)(a1 + 4) = v4;
  v5 = *(_QWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v5 ^ 0xFF;
  *(_DWORD *)(a1 + 20) = HIDWORD(v5);
  sub_1041A8(a1);
  sub_1041A8(a1);
  sub_1041A8(a1);
  return sub_1041A8(a1);
}

//----- (001043A4) --------------------------------------------------------
_DWORD *new_siphash()
{
  _DWORD *v1; // [sp+4h] [bp+4h]

  v1 = calloc(1u, 0x60u);
  if ( !v1 )
    puts("siphash calloc failed!");
  v1[18] = 1065021;
  v1[19] = 1065105;
  v1[20] = 1065773;
  v1[21] = 1064941;
  return v1;
}

//----- (00104404) --------------------------------------------------------
void __fastcall free_siphash(void *a1)
{
  if ( a1 )
    free(a1);
}

//----- (00104420) --------------------------------------------------------
int __fastcall sub_104420(unsigned __int8 a1)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; i <= 0x40; ++i )
  {
    if ( a1 == (unsigned __int8)aAbcdefghijklmn[i] )
      return i;
  }
  printf("%s (%02x) failed!\n\n", "base64_decode_value", a1);
  return -1;
}

//----- (00104478) --------------------------------------------------------
int __fastcall base64_encode_nonce(unsigned __int64 a1, int a2)
{
  int v2; // r3
  int v3; // r3
  int v4; // r3
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r3
  int v9; // r3
  int v10; // r3
  unsigned __int64 v12; // [sp+8h] [bp+8h]
  _BYTE v13[8]; // [sp+14h] [bp+14h] BYREF
  unsigned int v14; // [sp+1Ch] [bp+1Ch]
  int v15; // [sp+20h] [bp+20h]
  int v16; // [sp+24h] [bp+24h]
  int v17; // [sp+28h] [bp+28h]
  int v18; // [sp+2Ch] [bp+2Ch]
  int v19; // [sp+30h] [bp+30h]
  int i; // [sp+34h] [bp+34h]
  _BYTE vars0[8]; // [sp+38h] [bp+38h] BYREF

  v12 = a1;
  for ( i = 0; i <= 7; ++i )
  {
    LODWORD(a1) = (unsigned __int8)v12;
    v13[i] = v12;
    v12 >>= 8;
  }
  v19 = 0;
  v18 = 0;
  while ( v19 <= 7 )
  {
    v2 = v19++;
    v17 = (unsigned __int8)vars0[v2 - 36];
    if ( v19 > 7 )
    {
      v4 = 0;
    }
    else
    {
      v3 = v19++;
      v4 = (unsigned __int8)vars0[v3 - 36];
    }
    v16 = v4;
    if ( v19 > 7 )
    {
      v6 = 0;
    }
    else
    {
      v5 = v19++;
      v6 = (unsigned __int8)vars0[v5 - 36];
    }
    v15 = v6;
    v14 = v6 + (v17 << 16) + (v16 << 8);
    v7 = v18++;
    *(_BYTE *)(v7 + a2) = aAbcdefghijklmn[(v14 >> 18) & 0x3F];
    v8 = v18++;
    *(_BYTE *)(v8 + a2) = aAbcdefghijklmn[(v14 >> 12) & 0x3F];
    v9 = v18++;
    *(_BYTE *)(v9 + a2) = aAbcdefghijklmn[(v14 >> 6) & 0x3F];
    v10 = v18++;
    *(_BYTE *)(v10 + a2) = aAbcdefghijklmn[v14 & 0x3F];
  }
  *(_BYTE *)(a2 + 11) = 61;
  return a1;
}
// 1044C2: conditional instruction was optimized away because %var_8.4<8

//----- (001045B8) --------------------------------------------------------
int __fastcall base64_encode(int result, int a2, int a3)
{
  int v3; // r3
  int v4; // r3
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r3
  unsigned int v9; // [sp+14h] [bp+14h]
  int v10; // [sp+1Ch] [bp+1Ch]
  int v11; // [sp+20h] [bp+20h]
  int v12; // [sp+24h] [bp+24h]
  int v13; // [sp+28h] [bp+28h]
  int v14; // [sp+2Ch] [bp+2Ch]

  v14 = 0;
  v13 = 0;
  while ( v14 < a3 )
  {
    v3 = v14++;
    v11 = *(unsigned __int8 *)(a2 + v3);
    if ( v14 >= a3 )
    {
      v5 = 0;
    }
    else
    {
      v4 = v14++;
      v5 = *(unsigned __int8 *)(a2 + v4);
    }
    v10 = v5;
    if ( v14 >= a3 )
    {
      v7 = 0;
    }
    else
    {
      v6 = v14++;
      v7 = *(unsigned __int8 *)(a2 + v6);
    }
    v9 = v7 + (v11 << 16) + (v10 << 8);
    *(_BYTE *)(v13 + result) = aAbcdefghijklmn[(v9 >> 18) & 0x3F];
    *(_BYTE *)(v13 + 1 + result) = aAbcdefghijklmn[(v9 >> 12) & 0x3F];
    *(_BYTE *)(v13 + 2 + result) = aAbcdefghijklmn[(v9 >> 6) & 0x3F];
    v8 = v13 + 3;
    v13 += 4;
    *(_BYTE *)(v8 + result) = aAbcdefghijklmn[v9 & 0x3F];
  }
  v12 = 8 * a3 / 6;
  if ( 8 * a3 % 6 )
    ++v12;
  *(_BYTE *)(v12 + result) = 61;
  return result;
}

//----- (0010470C) --------------------------------------------------------
int __fastcall base64_decode(int result, int a2, int a3)
{
  int v3; // r3
  char v4; // r3
  int v5; // r3
  char v6; // r3
  int v7; // r3
  char v8; // r3
  int v9; // r3
  char v10; // r3
  int v11; // r3
  int v14; // [sp+Ch] [bp+Ch]
  int v15; // [sp+14h] [bp+14h]
  char v16; // [sp+1Ch] [bp+1Ch]
  char v17; // [sp+20h] [bp+20h]
  char v18; // [sp+24h] [bp+24h]
  int v19; // [sp+28h] [bp+28h]
  int v20; // [sp+2Ch] [bp+2Ch]

  v14 = result;
  v20 = 0;
  v19 = 0;
  while ( a3 - 1 > v20 )
  {
    if ( v20 >= a3 )
    {
      v4 = 0;
    }
    else
    {
      v3 = v20++;
      result = sub_104420(*(_BYTE *)(a2 + v3));
      v4 = result;
    }
    v18 = v4;
    if ( v20 >= a3 )
    {
      v6 = 0;
    }
    else
    {
      v5 = v20++;
      result = sub_104420(*(_BYTE *)(a2 + v5));
      v6 = result;
    }
    v17 = v6;
    if ( v20 >= a3 )
    {
      v8 = 0;
    }
    else
    {
      v7 = v20++;
      result = sub_104420(*(_BYTE *)(a2 + v7));
      v8 = result;
    }
    v16 = v8;
    if ( v20 >= a3 )
    {
      v10 = 0;
    }
    else
    {
      v9 = v20++;
      result = sub_104420(*(_BYTE *)(a2 + v9));
      v10 = result;
    }
    v15 = (v10 & 0x3F) + ((v18 & 0x3F) << 18) + ((v17 & 0x3F) << 12) + ((v16 & 0x3F) << 6);
    *(_BYTE *)(v14 + v19) = BYTE2(v15);
    *(_BYTE *)(v14 + v19 + 1) = (unsigned __int16)((v10 & 0x3F) + ((v17 & 0x3F) << 12) + ((v16 & 0x3F) << 6)) >> 8;
    v11 = v19 + 2;
    v19 += 3;
    *(_BYTE *)(v14 + v11) = v15;
  }
  return result;
}

//----- (00104824) --------------------------------------------------------
void *__fastcall sub_104824(int a1)
{
  void *result; // r0
  _DWORD *v2; // r2
  __int64 *v3; // r0
  __int64 v4; // kr10_8
  __int64 v5; // kr20_8
  int v6; // r2
  __int64 v7; // r10
  int v8; // r2
  __int64 v9; // r8
  __int64 v10; // kr50_8
  int v11; // r4
  int v12; // r2
  __int64 v13; // [sp+0h] [bp+0h]
  _QWORD s[5]; // [sp+18h] [bp+18h] BYREF
  int v15; // [sp+44h] [bp+44h]
  int k; // [sp+48h] [bp+48h]
  int j; // [sp+4Ch] [bp+4Ch]
  int i; // [sp+50h] [bp+50h]
  unsigned __int8 v19; // [sp+56h] [bp+56h]
  unsigned __int8 v20; // [sp+57h] [bp+57h]
  __int64 v21; // [sp+58h] [bp+58h]
  _BYTE v22[4]; // [sp+60h] [bp+60h] BYREF

  v15 = a1;
  result = memset(s, 0, sizeof(s));
  v21 = 0;
  for ( i = 0; i <= 23; ++i )
  {
    v20 = 0;
    for ( j = 0; j <= 4; ++j )
    {
      v2 = &v22[8 * v20 - 72];
      *v2 = 0;
      v2[1] = 0;
      v19 = 0;
      for ( k = 0; k <= 4; ++k )
      {
        *(_QWORD *)&v22[8 * v20 - 72] ^= *(_QWORD *)(8 * (v19 + v20) + v15);
        v19 += 5;
      }
      ++v20;
    }
    v20 = 0;
    for ( j = 0; j <= 4; ++j )
    {
      v19 = 0;
      for ( k = 0; k <= 4; ++k )
      {
        v3 = (__int64 *)(v15 + 8 * (v20 + v19));
        v4 = *v3;
        v13 = *(_QWORD *)&v22[8 * ((v20 + 4) % 5) - 72];
        v5 = *(_QWORD *)&v22[8 * ((v20 + 1) % 5) - 72];
        *(_DWORD *)v3 ^= ((2 * v5) | (HIDWORD(v5) >> 31)) ^ (unsigned int)v13;
        *((_DWORD *)v3 + 1) = (v5 >> 31) ^ HIDWORD(v13) ^ HIDWORD(v4);
        v19 += 5;
      }
      ++v20;
    }
    v21 = *(_QWORD *)(v15 + 8);
    v20 = 0;
    for ( j = 0; j <= 23; ++j )
    {
      s[0] = *(_QWORD *)(8 * byte_1D4008[v20] + v15);
      v6 = byte_1D3FF0[v20];
      v7 = v21 << v6;
      v8 = -v6 & 0x3F;
      LODWORD(v9) = ((unsigned int)v21 >> v8) | (HIDWORD(v21) << (32 - v8)) | (HIDWORD(v21) >> (v8 - 32)) | v7;
      HIDWORD(v9) = (HIDWORD(v21) >> v8) | HIDWORD(v7);
      *(_QWORD *)(v15 + 8 * byte_1D4008[v20]) = v9;
      v21 = s[0];
      ++v20;
    }
    v19 = 0;
    for ( j = 0; j <= 4; ++j )
    {
      v20 = 0;
      for ( k = 0; k <= 4; ++k )
      {
        *(_QWORD *)&v22[8 * v20 - 72] = *(_QWORD *)(8 * (v20 + v19) + v15);
        ++v20;
      }
      v20 = 0;
      for ( k = 0; k <= 4; ++k )
      {
        *(_QWORD *)(v15 + 8 * (v20 + v19)) = ~*(_QWORD *)&v22[8 * ((v20 + 1) % 5) - 72]
                                           & *(_QWORD *)&v22[8 * ((v20 + 2) % 5) - 72]
                                           ^ *(_QWORD *)&v22[8 * v20 - 72];
        ++v20;
      }
      v19 += 5;
    }
    result = (void *)(8 * i);
    v10 = qword_1D4020[i];
    v11 = HIDWORD(v10) ^ *(_DWORD *)(v15 + 4);
    v12 = v15;
    *(_DWORD *)v15 ^= v10;
    *(_DWORD *)(v12 + 4) = v11;
  }
  return result;
}
// 104824: too many cbuild loops
// 1D3FF0: using guessed type unsigned __int8 byte_1D3FF0[24];
// 1D4008: using guessed type unsigned __int8 byte_1D4008[24];
// 1D4020: using guessed type _QWORD qword_1D4020[24];

//----- (00104C24) --------------------------------------------------------
int __fastcall sub_104C24(int result, int a2, unsigned int a3)
{
  int v3; // [sp+Ch] [bp+Ch]
  unsigned int i; // [sp+14h] [bp+14h]

  v3 = result;
  for ( i = 0; i < a3; ++i )
  {
    result = a2;
    *(_BYTE *)(i + v3) ^= *(_BYTE *)(i + a2);
  }
  return result;
}

//----- (00104C6C) --------------------------------------------------------
int __fastcall sub_104C6C(int result, int a2, unsigned int a3)
{
  unsigned int i; // [sp+14h] [bp+14h]

  for ( i = 0; i < a3; ++i )
    *(_BYTE *)(i + a2) = *(_BYTE *)(i + result);
  return result;
}

//----- (00104CA8) --------------------------------------------------------
int __fastcall sub_104CA8(int a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5, char a6)
{
  unsigned int v8; // [sp+0h] [bp+0h]
  int v9; // [sp+4h] [bp+4h]
  int v11; // [sp+Ch] [bp+Ch]
  _BYTE s[208]; // [sp+10h] [bp+10h] BYREF

  v11 = a1;
  v9 = a3;
  v8 = a4;
  if ( !a1 || !a3 && a4 || a5 > 0xC7 )
    return -1;
  memset(s, 0, 0xC8u);
  while ( v8 >= a5 )
  {
    sub_104C24((int)s, v9, a5);
    sub_104824((int)s);
    v9 += a5;
    v8 -= a5;
  }
  s[v8] ^= a6;
  s[a5 - 1] = ~(s[a5 - 1] ^ 0x7F);
  sub_104C24((int)s, v9, v8);
  sub_104824((int)s);
  while ( a2 >= a5 )
  {
    sub_104C6C((int)s, v11, a5);
    sub_104824((int)s);
    v11 += a5;
    a2 -= a5;
  }
  sub_104C6C((int)s, v11, a2);
  memset(s, 0, 0xC8u);
  return 0;
}

//----- (00104DE0) --------------------------------------------------------
int __fastcall eth_sha3_256(int a1, unsigned int a2, int a3, unsigned int a4)
{
  if ( a2 <= 0x20 )
    return sub_104CA8(a1, a2, a3, a4, 0x88u, 1);
  else
    return -1;
}

//----- (00104E18) --------------------------------------------------------
int __fastcall eth_sha3_512(int a1, unsigned int a2, int a3, unsigned int a4)
{
  if ( a2 <= 0x40 )
    return sub_104CA8(a1, a2, a3, a4, 0x48u, 1);
  else
    return -1;
}

//----- (00104E50) --------------------------------------------------------
unsigned int __fastcall sub_104E50(int a1)
{
  int v1; // t2

  v1 = __ROR4__(a1, 16);
  return ((v1 & 0xFF00FF) << 8) | ((v1 & 0xFF00FF00) >> 8);
}

//----- (00104E84) --------------------------------------------------------
__int64 __fastcall sub_104E84(int a1, int a2)
{
  unsigned int v3; // [sp+4h] [bp+4h]
  unsigned int v4; // [sp+8h] [bp+8h]
  __int64 v5; // [sp+8h] [bp+8h]
  unsigned int v6; // [sp+Ch] [bp+Ch]

  v4 = ((a2 & 0xFFFF0000) >> 16) | ((a1 & 0xFFFF0000) << 16) | ((unsigned __int16)a2 << 16);
  v6 = ((a1 & 0xFFFF0000) >> 16) | ((unsigned __int16)a1 << 16);
  v3 = ((v6 & 0xFF00FF) << 8) | ((v4 & 0xFF00FF) >> 24);
  LODWORD(v5) = ((v4 & 0xFF00FF) << 8) | ((v4 & 0xFF00FF00) >> 8) | ((v6 & 0xFF00FF00) << 24);
  HIDWORD(v5) = v3 | ((v6 & 0xFF00FF00) >> 8);
  return v5;
}

//----- (00104F58) --------------------------------------------------------
_BYTE *__fastcall sub_104F58(_BYTE *result, int a2)
{
  *result = HIBYTE(a2);
  result[1] = BYTE2(a2);
  result[2] = BYTE1(a2);
  result[3] = a2;
  return result;
}

//----- (00104F9C) --------------------------------------------------------
unsigned int __fastcall sub_104F9C(unsigned int *a1, int a2)
{
  unsigned int result; // r0

  result = sub_104E50(a2);
  *a1 = result;
  return result;
}

//----- (00104FBC) --------------------------------------------------------
unsigned int __fastcall sub_104FBC(int *a1)
{
  return sub_104E50(*a1);
}

//----- (00104FD8) --------------------------------------------------------
_BYTE *__fastcall sub_104FD8(_BYTE *result, int a2, int a3, int a4)
{
  *result = HIBYTE(a4);
  result[1] = BYTE2(a4);
  result[2] = BYTE1(a4);
  result[3] = a4;
  result[4] = HIBYTE(a3);
  result[5] = BYTE2(a3);
  result[6] = BYTE1(a3);
  result[7] = a3;
  return result;
}

//----- (00105094) --------------------------------------------------------
__int64 __fastcall sub_105094(__int64 *a1, int a2, int a3, int a4)
{
  __int64 result; // r0

  result = sub_104E84(a3, a4);
  *a1 = result;
  return result;
}

//----- (001050BC) --------------------------------------------------------
__int64 __fastcall sub_1050BC(int *a1)
{
  return sub_104E84(*a1, a1[1]);
}

//----- (001050E0) --------------------------------------------------------
void *__fastcall sub_1050E0(_DWORD *a1, const void *a2, const void *a3)
{
  void *result; // r0

  memcpy(a1 + 17, a2, 0x20u);
  result = memcpy(a1 + 25, a3, 0x10u);
  a1[30] = 0;
  a1[29] = a1[30];
  a1[16] = 0;
  return result;
}

//----- (00105124) --------------------------------------------------------
unsigned int __fastcall sub_105124(unsigned int result, char *a2, size_t a3)
{
  size_t n; // [sp+4h] [bp+4h]
  char *src; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  unsigned int v6; // [sp+18h] [bp+18h]
  unsigned int v7; // [sp+1Ch] [bp+1Ch]
  unsigned int v8; // [sp+20h] [bp+20h]
  unsigned int v9; // [sp+24h] [bp+24h]
  unsigned int v10; // [sp+28h] [bp+28h]
  unsigned int v11; // [sp+2Ch] [bp+2Ch]
  unsigned int v12; // [sp+30h] [bp+30h]
  unsigned int v13; // [sp+34h] [bp+34h]
  unsigned int v14; // [sp+38h] [bp+38h]
  unsigned int v15; // [sp+3Ch] [bp+3Ch]
  unsigned int v16; // [sp+40h] [bp+40h]
  unsigned int v17; // [sp+44h] [bp+44h]
  unsigned int v18; // [sp+48h] [bp+48h]
  unsigned int v19; // [sp+4Ch] [bp+4Ch]
  unsigned int v20; // [sp+50h] [bp+50h]
  int v21; // [sp+54h] [bp+54h]
  int v22; // [sp+58h] [bp+58h]
  int v23; // [sp+5Ch] [bp+5Ch]
  int v24; // [sp+60h] [bp+60h]
  int *v25; // [sp+64h] [bp+64h]
  int v26; // [sp+68h] [bp+68h]
  int v27; // [sp+68h] [bp+68h]
  int v28; // [sp+68h] [bp+68h]
  int v29; // [sp+68h] [bp+68h]
  int v30; // [sp+68h] [bp+68h]
  int v31; // [sp+68h] [bp+68h]
  int v32; // [sp+68h] [bp+68h]
  int v33; // [sp+68h] [bp+68h]
  int v34; // [sp+68h] [bp+68h]
  int v35; // [sp+68h] [bp+68h]
  int v36; // [sp+68h] [bp+68h]
  int v37; // [sp+68h] [bp+68h]
  int v38; // [sp+68h] [bp+68h]
  int v39; // [sp+68h] [bp+68h]
  int v40; // [sp+68h] [bp+68h]
  int v41; // [sp+68h] [bp+68h]
  int v42; // [sp+68h] [bp+68h]
  int v43; // [sp+68h] [bp+68h]
  int v44; // [sp+68h] [bp+68h]
  int v45; // [sp+68h] [bp+68h]
  int v46; // [sp+68h] [bp+68h]
  int v47; // [sp+68h] [bp+68h]
  int v48; // [sp+68h] [bp+68h]
  int v49; // [sp+68h] [bp+68h]
  int v50; // [sp+68h] [bp+68h]
  int v51; // [sp+68h] [bp+68h]
  int v52; // [sp+68h] [bp+68h]
  int v53; // [sp+68h] [bp+68h]
  int v54; // [sp+68h] [bp+68h]
  int v55; // [sp+68h] [bp+68h]
  int v56; // [sp+68h] [bp+68h]
  int v57; // [sp+68h] [bp+68h]
  int v58; // [sp+68h] [bp+68h]
  int v59; // [sp+68h] [bp+68h]
  int v60; // [sp+68h] [bp+68h]
  int v61; // [sp+68h] [bp+68h]
  int v62; // [sp+68h] [bp+68h]
  int v63; // [sp+68h] [bp+68h]
  int v64; // [sp+68h] [bp+68h]
  int v65; // [sp+68h] [bp+68h]
  int v66; // [sp+68h] [bp+68h]
  int v67; // [sp+68h] [bp+68h]
  int v68; // [sp+68h] [bp+68h]
  int v69; // [sp+68h] [bp+68h]
  int v70; // [sp+68h] [bp+68h]
  int v71; // [sp+68h] [bp+68h]
  int v72; // [sp+68h] [bp+68h]
  int v73; // [sp+68h] [bp+68h]
  int v74; // [sp+68h] [bp+68h]
  int v75; // [sp+68h] [bp+68h]
  int v76; // [sp+68h] [bp+68h]
  int v77; // [sp+68h] [bp+68h]
  int v78; // [sp+68h] [bp+68h]
  int v79; // [sp+68h] [bp+68h]
  int v80; // [sp+68h] [bp+68h]
  int v81; // [sp+6Ch] [bp+6Ch]
  int v82; // [sp+6Ch] [bp+6Ch]
  int v83; // [sp+6Ch] [bp+6Ch]
  int v84; // [sp+6Ch] [bp+6Ch]
  int v85; // [sp+6Ch] [bp+6Ch]
  int v86; // [sp+6Ch] [bp+6Ch]
  int v87; // [sp+6Ch] [bp+6Ch]
  int v88; // [sp+6Ch] [bp+6Ch]
  int v89; // [sp+6Ch] [bp+6Ch]
  int v90; // [sp+6Ch] [bp+6Ch]
  int v91; // [sp+6Ch] [bp+6Ch]
  int v92; // [sp+6Ch] [bp+6Ch]
  int v93; // [sp+6Ch] [bp+6Ch]
  int v94; // [sp+6Ch] [bp+6Ch]
  int v95; // [sp+6Ch] [bp+6Ch]
  int v96; // [sp+6Ch] [bp+6Ch]
  int v97; // [sp+6Ch] [bp+6Ch]
  int v98; // [sp+6Ch] [bp+6Ch]
  int v99; // [sp+6Ch] [bp+6Ch]
  int v100; // [sp+6Ch] [bp+6Ch]
  int v101; // [sp+6Ch] [bp+6Ch]
  int v102; // [sp+6Ch] [bp+6Ch]
  int v103; // [sp+6Ch] [bp+6Ch]
  int v104; // [sp+6Ch] [bp+6Ch]
  int v105; // [sp+6Ch] [bp+6Ch]
  int v106; // [sp+6Ch] [bp+6Ch]
  int v107; // [sp+6Ch] [bp+6Ch]
  int v108; // [sp+6Ch] [bp+6Ch]
  int v109; // [sp+6Ch] [bp+6Ch]
  int v110; // [sp+6Ch] [bp+6Ch]
  int v111; // [sp+6Ch] [bp+6Ch]
  int v112; // [sp+6Ch] [bp+6Ch]
  int v113; // [sp+6Ch] [bp+6Ch]
  int v114; // [sp+6Ch] [bp+6Ch]
  int v115; // [sp+6Ch] [bp+6Ch]
  int v116; // [sp+6Ch] [bp+6Ch]
  int v117; // [sp+6Ch] [bp+6Ch]
  int v118; // [sp+6Ch] [bp+6Ch]
  int v119; // [sp+6Ch] [bp+6Ch]
  int v120; // [sp+6Ch] [bp+6Ch]
  int v121; // [sp+6Ch] [bp+6Ch]
  int v122; // [sp+6Ch] [bp+6Ch]
  int v123; // [sp+6Ch] [bp+6Ch]
  int v124; // [sp+6Ch] [bp+6Ch]
  int v125; // [sp+6Ch] [bp+6Ch]
  int v126; // [sp+6Ch] [bp+6Ch]
  int v127; // [sp+6Ch] [bp+6Ch]
  int v128; // [sp+6Ch] [bp+6Ch]
  int v129; // [sp+6Ch] [bp+6Ch]
  int v130; // [sp+6Ch] [bp+6Ch]
  int v131; // [sp+6Ch] [bp+6Ch]
  int v132; // [sp+6Ch] [bp+6Ch]
  int v133; // [sp+6Ch] [bp+6Ch]
  int v134; // [sp+6Ch] [bp+6Ch]
  int v135; // [sp+6Ch] [bp+6Ch]
  int v136; // [sp+70h] [bp+70h]
  int v137; // [sp+70h] [bp+70h]
  int v138; // [sp+70h] [bp+70h]
  int v139; // [sp+70h] [bp+70h]
  int v140; // [sp+70h] [bp+70h]
  int v141; // [sp+70h] [bp+70h]
  int v142; // [sp+70h] [bp+70h]
  int v143; // [sp+70h] [bp+70h]
  int v144; // [sp+70h] [bp+70h]
  int v145; // [sp+70h] [bp+70h]
  int v146; // [sp+70h] [bp+70h]
  int v147; // [sp+70h] [bp+70h]
  int v148; // [sp+70h] [bp+70h]
  int v149; // [sp+70h] [bp+70h]
  int v150; // [sp+70h] [bp+70h]
  int v151; // [sp+70h] [bp+70h]
  int v152; // [sp+70h] [bp+70h]
  int v153; // [sp+70h] [bp+70h]
  int v154; // [sp+70h] [bp+70h]
  int v155; // [sp+70h] [bp+70h]
  int v156; // [sp+70h] [bp+70h]
  int v157; // [sp+70h] [bp+70h]
  int v158; // [sp+70h] [bp+70h]
  int v159; // [sp+70h] [bp+70h]
  int v160; // [sp+70h] [bp+70h]
  int v161; // [sp+70h] [bp+70h]
  int v162; // [sp+70h] [bp+70h]
  int v163; // [sp+70h] [bp+70h]
  int v164; // [sp+70h] [bp+70h]
  int v165; // [sp+70h] [bp+70h]
  int v166; // [sp+70h] [bp+70h]
  int v167; // [sp+70h] [bp+70h]
  int v168; // [sp+70h] [bp+70h]
  int v169; // [sp+70h] [bp+70h]
  int v170; // [sp+70h] [bp+70h]
  int v171; // [sp+70h] [bp+70h]
  int v172; // [sp+70h] [bp+70h]
  int v173; // [sp+70h] [bp+70h]
  int v174; // [sp+70h] [bp+70h]
  int v175; // [sp+70h] [bp+70h]
  int v176; // [sp+70h] [bp+70h]
  int v177; // [sp+70h] [bp+70h]
  int v178; // [sp+70h] [bp+70h]
  int v179; // [sp+70h] [bp+70h]
  int v180; // [sp+70h] [bp+70h]
  int v181; // [sp+70h] [bp+70h]
  int v182; // [sp+70h] [bp+70h]
  int v183; // [sp+70h] [bp+70h]
  int v184; // [sp+70h] [bp+70h]
  int v185; // [sp+70h] [bp+70h]
  int v186; // [sp+70h] [bp+70h]
  int v187; // [sp+70h] [bp+70h]
  int v188; // [sp+70h] [bp+70h]
  int v189; // [sp+70h] [bp+70h]
  int v190; // [sp+70h] [bp+70h]
  int v191; // [sp+74h] [bp+74h]
  int v192; // [sp+74h] [bp+74h]
  int v193; // [sp+74h] [bp+74h]
  int v194; // [sp+74h] [bp+74h]
  int v195; // [sp+74h] [bp+74h]
  int v196; // [sp+74h] [bp+74h]
  int v197; // [sp+74h] [bp+74h]
  int v198; // [sp+74h] [bp+74h]
  int v199; // [sp+74h] [bp+74h]
  int v200; // [sp+74h] [bp+74h]
  int v201; // [sp+74h] [bp+74h]
  int v202; // [sp+74h] [bp+74h]
  int v203; // [sp+74h] [bp+74h]
  int v204; // [sp+74h] [bp+74h]
  int v205; // [sp+74h] [bp+74h]
  int v206; // [sp+74h] [bp+74h]
  int v207; // [sp+74h] [bp+74h]
  int v208; // [sp+74h] [bp+74h]
  int v209; // [sp+74h] [bp+74h]
  int v210; // [sp+74h] [bp+74h]
  int v211; // [sp+74h] [bp+74h]
  int v212; // [sp+74h] [bp+74h]
  int v213; // [sp+74h] [bp+74h]
  int v214; // [sp+74h] [bp+74h]
  int v215; // [sp+74h] [bp+74h]
  int v216; // [sp+74h] [bp+74h]
  int v217; // [sp+74h] [bp+74h]
  int v218; // [sp+74h] [bp+74h]
  int v219; // [sp+74h] [bp+74h]
  int v220; // [sp+74h] [bp+74h]
  int v221; // [sp+74h] [bp+74h]
  int v222; // [sp+74h] [bp+74h]
  int v223; // [sp+74h] [bp+74h]
  int v224; // [sp+74h] [bp+74h]
  int v225; // [sp+74h] [bp+74h]
  int v226; // [sp+74h] [bp+74h]
  int v227; // [sp+74h] [bp+74h]
  int v228; // [sp+74h] [bp+74h]
  int v229; // [sp+74h] [bp+74h]
  int v230; // [sp+74h] [bp+74h]
  int v231; // [sp+74h] [bp+74h]
  int v232; // [sp+74h] [bp+74h]
  int v233; // [sp+74h] [bp+74h]
  int v234; // [sp+74h] [bp+74h]
  int v235; // [sp+74h] [bp+74h]
  int v236; // [sp+74h] [bp+74h]
  int v237; // [sp+74h] [bp+74h]
  int v238; // [sp+74h] [bp+74h]
  int v239; // [sp+74h] [bp+74h]
  int v240; // [sp+74h] [bp+74h]
  int v241; // [sp+74h] [bp+74h]
  int v242; // [sp+74h] [bp+74h]
  int v243; // [sp+74h] [bp+74h]
  int v244; // [sp+74h] [bp+74h]
  int v245; // [sp+74h] [bp+74h]
  int v246; // [sp+78h] [bp+78h]
  int v247; // [sp+78h] [bp+78h]
  int v248; // [sp+78h] [bp+78h]
  int v249; // [sp+78h] [bp+78h]
  int v250; // [sp+78h] [bp+78h]
  int v251; // [sp+78h] [bp+78h]
  int v252; // [sp+78h] [bp+78h]
  int v253; // [sp+78h] [bp+78h]
  int v254; // [sp+78h] [bp+78h]
  int v255; // [sp+78h] [bp+78h]
  int v256; // [sp+78h] [bp+78h]
  int v257; // [sp+78h] [bp+78h]
  int v258; // [sp+78h] [bp+78h]
  int v259; // [sp+78h] [bp+78h]
  int v260; // [sp+78h] [bp+78h]
  int v261; // [sp+78h] [bp+78h]
  int v262; // [sp+78h] [bp+78h]
  int v263; // [sp+78h] [bp+78h]
  int v264; // [sp+78h] [bp+78h]
  int v265; // [sp+78h] [bp+78h]
  int v266; // [sp+78h] [bp+78h]
  int v267; // [sp+78h] [bp+78h]
  int v268; // [sp+78h] [bp+78h]
  int v269; // [sp+78h] [bp+78h]
  int v270; // [sp+78h] [bp+78h]
  int v271; // [sp+78h] [bp+78h]
  int v272; // [sp+78h] [bp+78h]
  int v273; // [sp+78h] [bp+78h]
  int v274; // [sp+78h] [bp+78h]
  int v275; // [sp+78h] [bp+78h]
  int v276; // [sp+78h] [bp+78h]
  int v277; // [sp+78h] [bp+78h]
  int v278; // [sp+78h] [bp+78h]
  int v279; // [sp+78h] [bp+78h]
  int v280; // [sp+78h] [bp+78h]
  int v281; // [sp+78h] [bp+78h]
  int v282; // [sp+78h] [bp+78h]
  int v283; // [sp+78h] [bp+78h]
  int v284; // [sp+78h] [bp+78h]
  int v285; // [sp+78h] [bp+78h]
  int v286; // [sp+78h] [bp+78h]
  int v287; // [sp+78h] [bp+78h]
  int v288; // [sp+78h] [bp+78h]
  int v289; // [sp+78h] [bp+78h]
  int v290; // [sp+78h] [bp+78h]
  int v291; // [sp+78h] [bp+78h]
  int v292; // [sp+78h] [bp+78h]
  int v293; // [sp+78h] [bp+78h]
  int v294; // [sp+78h] [bp+78h]
  int v295; // [sp+78h] [bp+78h]
  int v296; // [sp+78h] [bp+78h]
  int v297; // [sp+78h] [bp+78h]
  int v298; // [sp+78h] [bp+78h]
  int v299; // [sp+78h] [bp+78h]
  int v300; // [sp+78h] [bp+78h]
  int v301; // [sp+7Ch] [bp+7Ch]
  int v302; // [sp+7Ch] [bp+7Ch]
  int v303; // [sp+7Ch] [bp+7Ch]
  int v304; // [sp+7Ch] [bp+7Ch]
  int v305; // [sp+7Ch] [bp+7Ch]
  int v306; // [sp+7Ch] [bp+7Ch]
  int v307; // [sp+7Ch] [bp+7Ch]
  int v308; // [sp+7Ch] [bp+7Ch]
  int v309; // [sp+7Ch] [bp+7Ch]
  int v310; // [sp+7Ch] [bp+7Ch]
  int v311; // [sp+7Ch] [bp+7Ch]
  int v312; // [sp+7Ch] [bp+7Ch]
  int v313; // [sp+7Ch] [bp+7Ch]
  int v314; // [sp+7Ch] [bp+7Ch]
  int v315; // [sp+7Ch] [bp+7Ch]
  int v316; // [sp+7Ch] [bp+7Ch]
  int v317; // [sp+7Ch] [bp+7Ch]
  int v318; // [sp+7Ch] [bp+7Ch]
  int v319; // [sp+7Ch] [bp+7Ch]
  int v320; // [sp+7Ch] [bp+7Ch]
  int v321; // [sp+7Ch] [bp+7Ch]
  int v322; // [sp+7Ch] [bp+7Ch]
  int v323; // [sp+7Ch] [bp+7Ch]
  int v324; // [sp+7Ch] [bp+7Ch]
  int v325; // [sp+7Ch] [bp+7Ch]
  int v326; // [sp+7Ch] [bp+7Ch]
  int v327; // [sp+7Ch] [bp+7Ch]
  int v328; // [sp+7Ch] [bp+7Ch]
  int v329; // [sp+7Ch] [bp+7Ch]
  int v330; // [sp+7Ch] [bp+7Ch]
  int v331; // [sp+7Ch] [bp+7Ch]
  int v332; // [sp+7Ch] [bp+7Ch]
  int v333; // [sp+7Ch] [bp+7Ch]
  int v334; // [sp+7Ch] [bp+7Ch]
  int v335; // [sp+7Ch] [bp+7Ch]
  int v336; // [sp+7Ch] [bp+7Ch]
  int v337; // [sp+7Ch] [bp+7Ch]
  int v338; // [sp+7Ch] [bp+7Ch]
  int v339; // [sp+7Ch] [bp+7Ch]
  int v340; // [sp+7Ch] [bp+7Ch]
  int v341; // [sp+7Ch] [bp+7Ch]
  int v342; // [sp+7Ch] [bp+7Ch]
  int v343; // [sp+7Ch] [bp+7Ch]
  int v344; // [sp+7Ch] [bp+7Ch]
  int v345; // [sp+7Ch] [bp+7Ch]
  int v346; // [sp+7Ch] [bp+7Ch]
  int v347; // [sp+7Ch] [bp+7Ch]
  int v348; // [sp+7Ch] [bp+7Ch]
  int v349; // [sp+7Ch] [bp+7Ch]
  int v350; // [sp+7Ch] [bp+7Ch]
  int v351; // [sp+7Ch] [bp+7Ch]
  int v352; // [sp+7Ch] [bp+7Ch]
  int v353; // [sp+7Ch] [bp+7Ch]
  int v354; // [sp+7Ch] [bp+7Ch]
  int v355; // [sp+7Ch] [bp+7Ch]
  int v356; // [sp+80h] [bp+80h]
  int v357; // [sp+80h] [bp+80h]
  int v358; // [sp+80h] [bp+80h]
  int v359; // [sp+80h] [bp+80h]
  int v360; // [sp+80h] [bp+80h]
  int v361; // [sp+80h] [bp+80h]
  int v362; // [sp+80h] [bp+80h]
  int v363; // [sp+80h] [bp+80h]
  int v364; // [sp+80h] [bp+80h]
  int v365; // [sp+80h] [bp+80h]
  int v366; // [sp+80h] [bp+80h]
  int v367; // [sp+80h] [bp+80h]
  int v368; // [sp+80h] [bp+80h]
  int v369; // [sp+80h] [bp+80h]
  int v370; // [sp+80h] [bp+80h]
  int v371; // [sp+80h] [bp+80h]
  int v372; // [sp+80h] [bp+80h]
  int v373; // [sp+80h] [bp+80h]
  int v374; // [sp+80h] [bp+80h]
  int v375; // [sp+80h] [bp+80h]
  int v376; // [sp+80h] [bp+80h]
  int v377; // [sp+80h] [bp+80h]
  int v378; // [sp+80h] [bp+80h]
  int v379; // [sp+80h] [bp+80h]
  int v380; // [sp+80h] [bp+80h]
  int v381; // [sp+80h] [bp+80h]
  int v382; // [sp+80h] [bp+80h]
  int v383; // [sp+80h] [bp+80h]
  int v384; // [sp+80h] [bp+80h]
  int v385; // [sp+80h] [bp+80h]
  int v386; // [sp+80h] [bp+80h]
  int v387; // [sp+80h] [bp+80h]
  int v388; // [sp+80h] [bp+80h]
  int v389; // [sp+80h] [bp+80h]
  int v390; // [sp+80h] [bp+80h]
  int v391; // [sp+80h] [bp+80h]
  int v392; // [sp+80h] [bp+80h]
  int v393; // [sp+80h] [bp+80h]
  int v394; // [sp+80h] [bp+80h]
  int v395; // [sp+80h] [bp+80h]
  int v396; // [sp+80h] [bp+80h]
  int v397; // [sp+80h] [bp+80h]
  int v398; // [sp+80h] [bp+80h]
  int v399; // [sp+80h] [bp+80h]
  int v400; // [sp+80h] [bp+80h]
  int v401; // [sp+80h] [bp+80h]
  int v402; // [sp+80h] [bp+80h]
  int v403; // [sp+80h] [bp+80h]
  int v404; // [sp+80h] [bp+80h]
  int v405; // [sp+80h] [bp+80h]
  int v406; // [sp+80h] [bp+80h]
  int v407; // [sp+80h] [bp+80h]
  int v408; // [sp+80h] [bp+80h]
  int v409; // [sp+80h] [bp+80h]
  int v410; // [sp+80h] [bp+80h]
  int v411; // [sp+84h] [bp+84h]
  int v412; // [sp+84h] [bp+84h]
  int v413; // [sp+84h] [bp+84h]
  int v414; // [sp+84h] [bp+84h]
  int v415; // [sp+84h] [bp+84h]
  int v416; // [sp+84h] [bp+84h]
  int v417; // [sp+84h] [bp+84h]
  int v418; // [sp+84h] [bp+84h]
  int v419; // [sp+84h] [bp+84h]
  int v420; // [sp+84h] [bp+84h]
  int v421; // [sp+84h] [bp+84h]
  int v422; // [sp+84h] [bp+84h]
  int v423; // [sp+84h] [bp+84h]
  int v424; // [sp+84h] [bp+84h]
  int v425; // [sp+84h] [bp+84h]
  int v426; // [sp+84h] [bp+84h]
  int v427; // [sp+84h] [bp+84h]
  int v428; // [sp+84h] [bp+84h]
  int v429; // [sp+84h] [bp+84h]
  int v430; // [sp+84h] [bp+84h]
  int v431; // [sp+84h] [bp+84h]
  int v432; // [sp+84h] [bp+84h]
  int v433; // [sp+84h] [bp+84h]
  int v434; // [sp+84h] [bp+84h]
  int v435; // [sp+84h] [bp+84h]
  int v436; // [sp+84h] [bp+84h]
  int v437; // [sp+84h] [bp+84h]
  int v438; // [sp+84h] [bp+84h]
  int v439; // [sp+84h] [bp+84h]
  int v440; // [sp+84h] [bp+84h]
  int v441; // [sp+84h] [bp+84h]
  int v442; // [sp+84h] [bp+84h]
  int v443; // [sp+84h] [bp+84h]
  int v444; // [sp+84h] [bp+84h]
  int v445; // [sp+84h] [bp+84h]
  int v446; // [sp+84h] [bp+84h]
  int v447; // [sp+84h] [bp+84h]
  int v448; // [sp+84h] [bp+84h]
  int v449; // [sp+84h] [bp+84h]
  int v450; // [sp+84h] [bp+84h]
  int v451; // [sp+84h] [bp+84h]
  int v452; // [sp+84h] [bp+84h]
  int v453; // [sp+84h] [bp+84h]
  int v454; // [sp+84h] [bp+84h]
  int v455; // [sp+84h] [bp+84h]
  int v456; // [sp+84h] [bp+84h]
  int v457; // [sp+84h] [bp+84h]
  int v458; // [sp+84h] [bp+84h]
  int v459; // [sp+84h] [bp+84h]
  int v460; // [sp+84h] [bp+84h]
  int v461; // [sp+84h] [bp+84h]
  int v462; // [sp+84h] [bp+84h]
  int v463; // [sp+84h] [bp+84h]
  int v464; // [sp+84h] [bp+84h]
  int v465; // [sp+84h] [bp+84h]
  int v466; // [sp+88h] [bp+88h]
  int v467; // [sp+88h] [bp+88h]
  int v468; // [sp+88h] [bp+88h]
  int v469; // [sp+88h] [bp+88h]
  int v470; // [sp+88h] [bp+88h]
  int v471; // [sp+88h] [bp+88h]
  int v472; // [sp+88h] [bp+88h]
  int v473; // [sp+88h] [bp+88h]
  int v474; // [sp+88h] [bp+88h]
  int v475; // [sp+88h] [bp+88h]
  int v476; // [sp+88h] [bp+88h]
  int v477; // [sp+88h] [bp+88h]
  int v478; // [sp+88h] [bp+88h]
  int v479; // [sp+88h] [bp+88h]
  int v480; // [sp+88h] [bp+88h]
  int v481; // [sp+88h] [bp+88h]
  int v482; // [sp+88h] [bp+88h]
  int v483; // [sp+88h] [bp+88h]
  int v484; // [sp+88h] [bp+88h]
  int v485; // [sp+88h] [bp+88h]
  int v486; // [sp+88h] [bp+88h]
  int v487; // [sp+88h] [bp+88h]
  int v488; // [sp+88h] [bp+88h]
  int v489; // [sp+88h] [bp+88h]
  int v490; // [sp+88h] [bp+88h]
  int v491; // [sp+88h] [bp+88h]
  int v492; // [sp+88h] [bp+88h]
  int v493; // [sp+88h] [bp+88h]
  int v494; // [sp+88h] [bp+88h]
  int v495; // [sp+88h] [bp+88h]
  int v496; // [sp+88h] [bp+88h]
  int v497; // [sp+88h] [bp+88h]
  int v498; // [sp+88h] [bp+88h]
  int v499; // [sp+88h] [bp+88h]
  int v500; // [sp+88h] [bp+88h]
  int v501; // [sp+88h] [bp+88h]
  int v502; // [sp+88h] [bp+88h]
  int v503; // [sp+88h] [bp+88h]
  int v504; // [sp+88h] [bp+88h]
  int v505; // [sp+88h] [bp+88h]
  int v506; // [sp+88h] [bp+88h]
  int v507; // [sp+88h] [bp+88h]
  int v508; // [sp+88h] [bp+88h]
  int v509; // [sp+88h] [bp+88h]
  int v510; // [sp+88h] [bp+88h]
  int v511; // [sp+88h] [bp+88h]
  int v512; // [sp+88h] [bp+88h]
  int v513; // [sp+88h] [bp+88h]
  int v514; // [sp+88h] [bp+88h]
  int v515; // [sp+88h] [bp+88h]
  int v516; // [sp+88h] [bp+88h]
  int v517; // [sp+88h] [bp+88h]
  int v518; // [sp+88h] [bp+88h]
  int v519; // [sp+88h] [bp+88h]
  int v520; // [sp+88h] [bp+88h]
  int v521; // [sp+8Ch] [bp+8Ch]
  int v522; // [sp+8Ch] [bp+8Ch]
  int v523; // [sp+8Ch] [bp+8Ch]
  int v524; // [sp+8Ch] [bp+8Ch]
  int v525; // [sp+8Ch] [bp+8Ch]
  int v526; // [sp+8Ch] [bp+8Ch]
  int v527; // [sp+8Ch] [bp+8Ch]
  int v528; // [sp+8Ch] [bp+8Ch]
  int v529; // [sp+8Ch] [bp+8Ch]
  int v530; // [sp+8Ch] [bp+8Ch]
  int v531; // [sp+8Ch] [bp+8Ch]
  int v532; // [sp+8Ch] [bp+8Ch]
  int v533; // [sp+8Ch] [bp+8Ch]
  int v534; // [sp+8Ch] [bp+8Ch]
  int v535; // [sp+8Ch] [bp+8Ch]
  int v536; // [sp+8Ch] [bp+8Ch]
  int v537; // [sp+8Ch] [bp+8Ch]
  int v538; // [sp+8Ch] [bp+8Ch]
  int v539; // [sp+8Ch] [bp+8Ch]
  int v540; // [sp+8Ch] [bp+8Ch]
  int v541; // [sp+8Ch] [bp+8Ch]
  int v542; // [sp+8Ch] [bp+8Ch]
  int v543; // [sp+8Ch] [bp+8Ch]
  int v544; // [sp+8Ch] [bp+8Ch]
  int v545; // [sp+8Ch] [bp+8Ch]
  int v546; // [sp+8Ch] [bp+8Ch]
  int v547; // [sp+8Ch] [bp+8Ch]
  int v548; // [sp+8Ch] [bp+8Ch]
  int v549; // [sp+8Ch] [bp+8Ch]
  int v550; // [sp+8Ch] [bp+8Ch]
  int v551; // [sp+8Ch] [bp+8Ch]
  int v552; // [sp+8Ch] [bp+8Ch]
  int v553; // [sp+8Ch] [bp+8Ch]
  int v554; // [sp+8Ch] [bp+8Ch]
  int v555; // [sp+8Ch] [bp+8Ch]
  int v556; // [sp+8Ch] [bp+8Ch]
  int v557; // [sp+8Ch] [bp+8Ch]
  int v558; // [sp+8Ch] [bp+8Ch]
  int v559; // [sp+8Ch] [bp+8Ch]
  int v560; // [sp+8Ch] [bp+8Ch]
  int v561; // [sp+8Ch] [bp+8Ch]
  int v562; // [sp+8Ch] [bp+8Ch]
  int v563; // [sp+8Ch] [bp+8Ch]
  int v564; // [sp+8Ch] [bp+8Ch]
  int v565; // [sp+8Ch] [bp+8Ch]
  int v566; // [sp+8Ch] [bp+8Ch]
  int v567; // [sp+8Ch] [bp+8Ch]
  int v568; // [sp+8Ch] [bp+8Ch]
  int v569; // [sp+8Ch] [bp+8Ch]
  int v570; // [sp+8Ch] [bp+8Ch]
  int v571; // [sp+8Ch] [bp+8Ch]
  int v572; // [sp+8Ch] [bp+8Ch]
  int v573; // [sp+8Ch] [bp+8Ch]
  int v574; // [sp+8Ch] [bp+8Ch]
  int v575; // [sp+8Ch] [bp+8Ch]
  int v576; // [sp+90h] [bp+90h]
  int v577; // [sp+90h] [bp+90h]
  int v578; // [sp+90h] [bp+90h]
  int v579; // [sp+90h] [bp+90h]
  int v580; // [sp+90h] [bp+90h]
  int v581; // [sp+90h] [bp+90h]
  int v582; // [sp+90h] [bp+90h]
  int v583; // [sp+90h] [bp+90h]
  int v584; // [sp+90h] [bp+90h]
  int v585; // [sp+90h] [bp+90h]
  int v586; // [sp+90h] [bp+90h]
  int v587; // [sp+90h] [bp+90h]
  int v588; // [sp+90h] [bp+90h]
  int v589; // [sp+90h] [bp+90h]
  int v590; // [sp+90h] [bp+90h]
  int v591; // [sp+90h] [bp+90h]
  int v592; // [sp+90h] [bp+90h]
  int v593; // [sp+90h] [bp+90h]
  int v594; // [sp+90h] [bp+90h]
  int v595; // [sp+90h] [bp+90h]
  int v596; // [sp+90h] [bp+90h]
  int v597; // [sp+90h] [bp+90h]
  int v598; // [sp+90h] [bp+90h]
  int v599; // [sp+90h] [bp+90h]
  int v600; // [sp+90h] [bp+90h]
  int v601; // [sp+90h] [bp+90h]
  int v602; // [sp+90h] [bp+90h]
  int v603; // [sp+90h] [bp+90h]
  int v604; // [sp+90h] [bp+90h]
  int v605; // [sp+90h] [bp+90h]
  int v606; // [sp+90h] [bp+90h]
  int v607; // [sp+90h] [bp+90h]
  int v608; // [sp+90h] [bp+90h]
  int v609; // [sp+90h] [bp+90h]
  int v610; // [sp+90h] [bp+90h]
  int v611; // [sp+90h] [bp+90h]
  int v612; // [sp+90h] [bp+90h]
  int v613; // [sp+90h] [bp+90h]
  int v614; // [sp+90h] [bp+90h]
  int v615; // [sp+90h] [bp+90h]
  int v616; // [sp+90h] [bp+90h]
  int v617; // [sp+90h] [bp+90h]
  int v618; // [sp+90h] [bp+90h]
  int v619; // [sp+90h] [bp+90h]
  int v620; // [sp+90h] [bp+90h]
  int v621; // [sp+90h] [bp+90h]
  int v622; // [sp+90h] [bp+90h]
  int v623; // [sp+90h] [bp+90h]
  int v624; // [sp+90h] [bp+90h]
  int v625; // [sp+90h] [bp+90h]
  int v626; // [sp+90h] [bp+90h]
  int v627; // [sp+90h] [bp+90h]
  int v628; // [sp+90h] [bp+90h]
  int v629; // [sp+90h] [bp+90h]
  int v630; // [sp+90h] [bp+90h]
  int v631; // [sp+94h] [bp+94h]
  int v632; // [sp+94h] [bp+94h]
  int v633; // [sp+94h] [bp+94h]
  int v634; // [sp+94h] [bp+94h]
  int v635; // [sp+94h] [bp+94h]
  int v636; // [sp+94h] [bp+94h]
  int v637; // [sp+94h] [bp+94h]
  int v638; // [sp+94h] [bp+94h]
  int v639; // [sp+94h] [bp+94h]
  int v640; // [sp+94h] [bp+94h]
  int v641; // [sp+94h] [bp+94h]
  int v642; // [sp+94h] [bp+94h]
  int v643; // [sp+94h] [bp+94h]
  int v644; // [sp+94h] [bp+94h]
  int v645; // [sp+94h] [bp+94h]
  int v646; // [sp+94h] [bp+94h]
  int v647; // [sp+94h] [bp+94h]
  int v648; // [sp+94h] [bp+94h]
  int v649; // [sp+94h] [bp+94h]
  int v650; // [sp+94h] [bp+94h]
  int v651; // [sp+94h] [bp+94h]
  int v652; // [sp+94h] [bp+94h]
  int v653; // [sp+94h] [bp+94h]
  int v654; // [sp+94h] [bp+94h]
  int v655; // [sp+94h] [bp+94h]
  int v656; // [sp+94h] [bp+94h]
  int v657; // [sp+94h] [bp+94h]
  int v658; // [sp+94h] [bp+94h]
  int v659; // [sp+94h] [bp+94h]
  int v660; // [sp+94h] [bp+94h]
  int v661; // [sp+94h] [bp+94h]
  int v662; // [sp+94h] [bp+94h]
  int v663; // [sp+94h] [bp+94h]
  int v664; // [sp+94h] [bp+94h]
  int v665; // [sp+94h] [bp+94h]
  int v666; // [sp+94h] [bp+94h]
  int v667; // [sp+94h] [bp+94h]
  int v668; // [sp+94h] [bp+94h]
  int v669; // [sp+94h] [bp+94h]
  int v670; // [sp+94h] [bp+94h]
  int v671; // [sp+94h] [bp+94h]
  int v672; // [sp+94h] [bp+94h]
  int v673; // [sp+94h] [bp+94h]
  int v674; // [sp+94h] [bp+94h]
  int v675; // [sp+94h] [bp+94h]
  int v676; // [sp+94h] [bp+94h]
  int v677; // [sp+94h] [bp+94h]
  int v678; // [sp+94h] [bp+94h]
  int v679; // [sp+94h] [bp+94h]
  int v680; // [sp+94h] [bp+94h]
  int v681; // [sp+94h] [bp+94h]
  int v682; // [sp+94h] [bp+94h]
  int v683; // [sp+94h] [bp+94h]
  int v684; // [sp+94h] [bp+94h]
  int v685; // [sp+94h] [bp+94h]
  unsigned int v686; // [sp+98h] [bp+98h]
  int v687; // [sp+98h] [bp+98h]
  unsigned int v688; // [sp+98h] [bp+98h]
  int v689; // [sp+98h] [bp+98h]
  int v690; // [sp+98h] [bp+98h]
  unsigned int v691; // [sp+98h] [bp+98h]
  int v692; // [sp+98h] [bp+98h]
  int v693; // [sp+98h] [bp+98h]
  unsigned int v694; // [sp+98h] [bp+98h]
  unsigned int v695; // [sp+98h] [bp+98h]
  unsigned int v696; // [sp+98h] [bp+98h]
  int v697; // [sp+98h] [bp+98h]
  int v698; // [sp+98h] [bp+98h]
  int v699; // [sp+98h] [bp+98h]
  int v700; // [sp+98h] [bp+98h]
  unsigned int v701; // [sp+98h] [bp+98h]
  unsigned int v702; // [sp+98h] [bp+98h]
  unsigned int v703; // [sp+98h] [bp+98h]
  unsigned int v704; // [sp+98h] [bp+98h]
  int v705; // [sp+98h] [bp+98h]
  int v706; // [sp+98h] [bp+98h]
  int v707; // [sp+98h] [bp+98h]
  int v708; // [sp+98h] [bp+98h]
  unsigned int v709; // [sp+98h] [bp+98h]
  unsigned int v710; // [sp+98h] [bp+98h]
  unsigned int v711; // [sp+98h] [bp+98h]
  int v712; // [sp+98h] [bp+98h]
  int v713; // [sp+98h] [bp+98h]
  int v714; // [sp+98h] [bp+98h]
  int v715; // [sp+98h] [bp+98h]
  unsigned int v716; // [sp+98h] [bp+98h]
  int v717; // [sp+98h] [bp+98h]
  int v718; // [sp+98h] [bp+98h]
  int v719; // [sp+98h] [bp+98h]
  int v720; // [sp+98h] [bp+98h]
  unsigned int v721; // [sp+98h] [bp+98h]
  int v722; // [sp+98h] [bp+98h]
  unsigned int v723; // [sp+98h] [bp+98h]
  int v724; // [sp+98h] [bp+98h]
  unsigned int v725; // [sp+98h] [bp+98h]
  unsigned int v726; // [sp+98h] [bp+98h]
  int v727; // [sp+98h] [bp+98h]
  unsigned int v728; // [sp+98h] [bp+98h]
  int v729; // [sp+98h] [bp+98h]
  int v730; // [sp+98h] [bp+98h]
  unsigned int v731; // [sp+98h] [bp+98h]
  int v732; // [sp+98h] [bp+98h]
  int v733; // [sp+98h] [bp+98h]
  unsigned int v734; // [sp+98h] [bp+98h]
  unsigned int v735; // [sp+98h] [bp+98h]
  unsigned int v736; // [sp+98h] [bp+98h]
  int v737; // [sp+98h] [bp+98h]
  int v738; // [sp+98h] [bp+98h]
  int v739; // [sp+98h] [bp+98h]
  int v740; // [sp+98h] [bp+98h]
  int v741; // [sp+9Ch] [bp+9Ch]
  unsigned int v742; // [sp+9Ch] [bp+9Ch]
  unsigned int v743; // [sp+9Ch] [bp+9Ch]
  unsigned int v744; // [sp+9Ch] [bp+9Ch]
  unsigned int v745; // [sp+9Ch] [bp+9Ch]
  int v746; // [sp+9Ch] [bp+9Ch]
  unsigned int v747; // [sp+9Ch] [bp+9Ch]
  int v748; // [sp+9Ch] [bp+9Ch]
  int v749; // [sp+9Ch] [bp+9Ch]
  int v750; // [sp+9Ch] [bp+9Ch]
  unsigned int v751; // [sp+9Ch] [bp+9Ch]
  unsigned int v752; // [sp+9Ch] [bp+9Ch]
  unsigned int v753; // [sp+9Ch] [bp+9Ch]
  unsigned int v754; // [sp+9Ch] [bp+9Ch]
  int v755; // [sp+9Ch] [bp+9Ch]
  unsigned int v756; // [sp+9Ch] [bp+9Ch]
  unsigned int v757; // [sp+9Ch] [bp+9Ch]
  int v758; // [sp+9Ch] [bp+9Ch]
  int v759; // [sp+9Ch] [bp+9Ch]
  int v760; // [sp+9Ch] [bp+9Ch]
  int v761; // [sp+9Ch] [bp+9Ch]
  int v762; // [sp+9Ch] [bp+9Ch]
  int v763; // [sp+9Ch] [bp+9Ch]
  unsigned int v764; // [sp+9Ch] [bp+9Ch]
  unsigned int v765; // [sp+9Ch] [bp+9Ch]
  int v766; // [sp+9Ch] [bp+9Ch]
  int v767; // [sp+9Ch] [bp+9Ch]
  int v768; // [sp+9Ch] [bp+9Ch]
  unsigned int v769; // [sp+9Ch] [bp+9Ch]
  unsigned int v770; // [sp+9Ch] [bp+9Ch]
  int v771; // [sp+9Ch] [bp+9Ch]
  int v772; // [sp+9Ch] [bp+9Ch]
  int v773; // [sp+9Ch] [bp+9Ch]
  int v774; // [sp+9Ch] [bp+9Ch]
  unsigned int v775; // [sp+9Ch] [bp+9Ch]
  unsigned int v776; // [sp+9Ch] [bp+9Ch]
  int v777; // [sp+9Ch] [bp+9Ch]
  unsigned int v778; // [sp+9Ch] [bp+9Ch]
  unsigned int v779; // [sp+9Ch] [bp+9Ch]
  int v780; // [sp+9Ch] [bp+9Ch]
  int v781; // [sp+9Ch] [bp+9Ch]
  unsigned int v782; // [sp+9Ch] [bp+9Ch]
  unsigned int v783; // [sp+9Ch] [bp+9Ch]
  unsigned int v784; // [sp+9Ch] [bp+9Ch]
  unsigned int v785; // [sp+9Ch] [bp+9Ch]
  int v786; // [sp+9Ch] [bp+9Ch]
  unsigned int v787; // [sp+9Ch] [bp+9Ch]
  int v788; // [sp+9Ch] [bp+9Ch]
  int v789; // [sp+9Ch] [bp+9Ch]
  int v790; // [sp+9Ch] [bp+9Ch]
  unsigned int v791; // [sp+9Ch] [bp+9Ch]
  unsigned int v792; // [sp+9Ch] [bp+9Ch]
  unsigned int v793; // [sp+9Ch] [bp+9Ch]
  unsigned int v794; // [sp+9Ch] [bp+9Ch]
  int v795; // [sp+9Ch] [bp+9Ch]
  int v796; // [sp+A0h] [bp+A0h]
  int v797; // [sp+A0h] [bp+A0h]
  int v798; // [sp+A0h] [bp+A0h]
  unsigned int v799; // [sp+A0h] [bp+A0h]
  int v800; // [sp+A0h] [bp+A0h]
  unsigned int v801; // [sp+A0h] [bp+A0h]
  int v802; // [sp+A0h] [bp+A0h]
  int v803; // [sp+A0h] [bp+A0h]
  int v804; // [sp+A0h] [bp+A0h]
  unsigned int v805; // [sp+A0h] [bp+A0h]
  int v806; // [sp+A0h] [bp+A0h]
  int v807; // [sp+A0h] [bp+A0h]
  unsigned int v808; // [sp+A0h] [bp+A0h]
  int v809; // [sp+A0h] [bp+A0h]
  unsigned int v810; // [sp+A0h] [bp+A0h]
  int v811; // [sp+A0h] [bp+A0h]
  unsigned int v812; // [sp+A0h] [bp+A0h]
  int v813; // [sp+A0h] [bp+A0h]
  unsigned int v814; // [sp+A0h] [bp+A0h]
  int v815; // [sp+A0h] [bp+A0h]
  unsigned int v816; // [sp+A0h] [bp+A0h]
  int v817; // [sp+A0h] [bp+A0h]
  int v818; // [sp+A0h] [bp+A0h]
  unsigned int v819; // [sp+A0h] [bp+A0h]
  unsigned int v820; // [sp+A0h] [bp+A0h]
  unsigned int v821; // [sp+A0h] [bp+A0h]
  int v822; // [sp+A0h] [bp+A0h]
  int v823; // [sp+A0h] [bp+A0h]
  int v824; // [sp+A0h] [bp+A0h]
  unsigned int v825; // [sp+A0h] [bp+A0h]
  unsigned int v826; // [sp+A0h] [bp+A0h]
  int v827; // [sp+A0h] [bp+A0h]
  int v828; // [sp+A0h] [bp+A0h]
  int v829; // [sp+A0h] [bp+A0h]
  unsigned int v830; // [sp+A0h] [bp+A0h]
  unsigned int v831; // [sp+A0h] [bp+A0h]
  unsigned int v832; // [sp+A0h] [bp+A0h]
  int v833; // [sp+A0h] [bp+A0h]
  int v834; // [sp+A0h] [bp+A0h]
  int v835; // [sp+A0h] [bp+A0h]
  int v836; // [sp+A0h] [bp+A0h]
  int v837; // [sp+A0h] [bp+A0h]
  int v838; // [sp+A0h] [bp+A0h]
  unsigned int v839; // [sp+A0h] [bp+A0h]
  int v840; // [sp+A0h] [bp+A0h]
  unsigned int v841; // [sp+A0h] [bp+A0h]
  int v842; // [sp+A0h] [bp+A0h]
  int v843; // [sp+A0h] [bp+A0h]
  int v844; // [sp+A0h] [bp+A0h]
  unsigned int v845; // [sp+A0h] [bp+A0h]
  int v846; // [sp+A0h] [bp+A0h]
  int v847; // [sp+A0h] [bp+A0h]
  unsigned int v848; // [sp+A0h] [bp+A0h]
  int v849; // [sp+A0h] [bp+A0h]
  unsigned int v850; // [sp+A0h] [bp+A0h]
  unsigned int v851; // [sp+A4h] [bp+A4h]
  int v852; // [sp+A4h] [bp+A4h]
  int v853; // [sp+A4h] [bp+A4h]
  int v854; // [sp+A4h] [bp+A4h]
  unsigned int v855; // [sp+A4h] [bp+A4h]
  int v856; // [sp+A4h] [bp+A4h]
  unsigned int v857; // [sp+A4h] [bp+A4h]
  unsigned int v858; // [sp+A4h] [bp+A4h]
  int v859; // [sp+A4h] [bp+A4h]
  int v860; // [sp+A4h] [bp+A4h]
  int v861; // [sp+A4h] [bp+A4h]
  unsigned int v862; // [sp+A4h] [bp+A4h]
  int v863; // [sp+A4h] [bp+A4h]
  unsigned int v864; // [sp+A4h] [bp+A4h]
  int v865; // [sp+A4h] [bp+A4h]
  int v866; // [sp+A4h] [bp+A4h]
  int v867; // [sp+A4h] [bp+A4h]
  int v868; // [sp+A4h] [bp+A4h]
  unsigned int v869; // [sp+A4h] [bp+A4h]
  int v870; // [sp+A4h] [bp+A4h]
  unsigned int v871; // [sp+A4h] [bp+A4h]
  int v872; // [sp+A4h] [bp+A4h]
  unsigned int v873; // [sp+A4h] [bp+A4h]
  unsigned int v874; // [sp+A4h] [bp+A4h]
  int v875; // [sp+A4h] [bp+A4h]
  unsigned int v876; // [sp+A4h] [bp+A4h]
  unsigned int v877; // [sp+A4h] [bp+A4h]
  int v878; // [sp+A4h] [bp+A4h]
  int v879; // [sp+A4h] [bp+A4h]
  unsigned int v880; // [sp+A4h] [bp+A4h]
  int v881; // [sp+A4h] [bp+A4h]
  int v882; // [sp+A4h] [bp+A4h]
  unsigned int v883; // [sp+A4h] [bp+A4h]
  int v884; // [sp+A4h] [bp+A4h]
  int v885; // [sp+A4h] [bp+A4h]
  unsigned int v886; // [sp+A4h] [bp+A4h]
  int v887; // [sp+A4h] [bp+A4h]
  unsigned int v888; // [sp+A4h] [bp+A4h]
  int v889; // [sp+A4h] [bp+A4h]
  unsigned int v890; // [sp+A4h] [bp+A4h]
  unsigned int v891; // [sp+A4h] [bp+A4h]
  int v892; // [sp+A4h] [bp+A4h]
  int v893; // [sp+A4h] [bp+A4h]
  int v894; // [sp+A4h] [bp+A4h]
  unsigned int v895; // [sp+A4h] [bp+A4h]
  int v896; // [sp+A4h] [bp+A4h]
  unsigned int v897; // [sp+A4h] [bp+A4h]
  unsigned int v898; // [sp+A4h] [bp+A4h]
  int v899; // [sp+A4h] [bp+A4h]
  int v900; // [sp+A4h] [bp+A4h]
  int v901; // [sp+A4h] [bp+A4h]
  unsigned int v902; // [sp+A4h] [bp+A4h]
  int v903; // [sp+A4h] [bp+A4h]
  unsigned int v904; // [sp+A4h] [bp+A4h]
  int v905; // [sp+A4h] [bp+A4h]
  size_t v906; // [sp+A8h] [bp+A8h]
  int v907; // [sp+ACh] [bp+ACh]
  unsigned int v908; // [sp+B0h] [bp+B0h]
  int v909; // [sp+B4h] [bp+B4h]
  int v910; // [sp+B8h] [bp+B8h]
  int v911; // [sp+BCh] [bp+BCh]
  int v912; // [sp+C0h] [bp+C0h]
  int v913; // [sp+C4h] [bp+C4h]
  int v914; // [sp+C8h] [bp+C8h]
  int v915; // [sp+CCh] [bp+CCh]
  int v916; // [sp+D0h] [bp+D0h]
  int v917; // [sp+D4h] [bp+D4h]

  v5 = (_DWORD *)result;
  src = a2;
  n = a3;
  v25 = (int *)result;
  v917 = *(_DWORD *)(result + 64);
  if ( 64 - v917 <= a3 )
  {
    v916 = *(_DWORD *)(result + 68);
    v915 = *(_DWORD *)(result + 72);
    v914 = *(_DWORD *)(result + 76);
    v913 = *(_DWORD *)(result + 80);
    v912 = *(_DWORD *)(result + 84);
    v911 = *(_DWORD *)(result + 88);
    v910 = *(_DWORD *)(result + 92);
    v909 = *(_DWORD *)(result + 96);
    v24 = *(_DWORD *)(result + 100);
    v23 = *(_DWORD *)(result + 104);
    v22 = *(_DWORD *)(result + 108);
    v21 = *(_DWORD *)(result + 112);
    v908 = *(_DWORD *)(result + 116);
    v907 = *(_DWORD *)(result + 120);
    while ( n )
    {
      v906 = 64 - v917;
      if ( 64 - v917 > n )
        v906 = n;
      result = (unsigned int)memcpy((char *)v25 + v917, src, v906);
      v917 += v906;
      src += v906;
      n -= v906;
      if ( v917 == 64 )
      {
        v908 += 512;
        if ( v908 < 0x200 )
          ++v907;
        v20 = sub_104FBC(v25);
        v19 = sub_104FBC(v25 + 1);
        v18 = sub_104FBC(v25 + 2);
        v17 = sub_104FBC(v25 + 3);
        v16 = sub_104FBC(v25 + 4);
        v15 = sub_104FBC(v25 + 5);
        v14 = sub_104FBC(v25 + 6);
        v13 = sub_104FBC(v25 + 7);
        v12 = sub_104FBC(v25 + 8);
        v11 = sub_104FBC(v25 + 9);
        v10 = sub_104FBC(v25 + 10);
        v9 = sub_104FBC(v25 + 11);
        v8 = sub_104FBC(v25 + 12);
        v7 = sub_104FBC(v25 + 13);
        v6 = sub_104FBC(v25 + 14);
        result = sub_104FBC(v25 + 15);
        v851 = (v20 ^ 0x85A308D3) + v916 + v912;
        v191 = __ROR4__(v851 ^ v908 ^ 0xA4093822, 16);
        v411 = v191 + (v24 ^ 0x243F6A88);
        v631 = __ROR4__(v411 ^ v912, 12);
        v852 = (v19 ^ 0x243F6A88) + v851 + v631;
        v192 = __ROR4__(v852 ^ v191, 8);
        v412 = v192 + v411;
        v632 = __ROR4__(v412 ^ v631, 7);
        v796 = (v18 ^ 0x3707344) + v915 + v911;
        v136 = __ROR4__(v796 ^ v908 ^ 0x299F31D0, 16);
        v356 = v136 + (v23 ^ 0x85A308D3);
        v576 = __ROR4__(v356 ^ v911, 12);
        v797 = (v17 ^ 0x13198A2E) + v796 + v576;
        v137 = __ROR4__(v797 ^ v136, 8);
        v357 = v137 + v356;
        v577 = __ROR4__(v357 ^ v576, 7);
        v741 = (v16 ^ 0x299F31D0) + v914 + v910;
        v81 = __ROR4__(v741 ^ v907 ^ 0x82EFA98, 16);
        v301 = v81 + (v22 ^ 0x13198A2E);
        v521 = __ROR4__(v301 ^ v910, 12);
        v742 = (v15 ^ 0xA4093822) + v741 + v521;
        v82 = __ROR4__(v742 ^ v81, 8);
        v302 = v82 + v301;
        v522 = __ROR4__(v302 ^ v521, 7);
        v686 = (v14 ^ 0xEC4E6C89) + v913 + v909;
        v26 = __ROR4__(v686 ^ v907 ^ 0xEC4E6C89, 16);
        v246 = v26 + (v21 ^ 0x3707344);
        v466 = __ROR4__(v246 ^ v909, 12);
        v687 = (v13 ^ 0x82EFA98) + v686 + v466;
        v27 = __ROR4__(v687 ^ v26, 8);
        v247 = v27 + v246;
        v467 = __ROR4__(v247 ^ v466, 7);
        v853 = (v12 ^ 0x38D01377) + v852 + v577;
        v28 = __ROR4__(v853 ^ v27, 16);
        v303 = v28 + v302;
        v578 = __ROR4__(v303 ^ v577, 12);
        v854 = (v11 ^ 0x452821E6) + v853 + v578;
        v29 = __ROR4__(v854 ^ v28, 8);
        v304 = v29 + v303;
        v579 = __ROR4__(v304 ^ v578, 7);
        v798 = (v10 ^ 0x34E90C6C) + v797 + v522;
        v193 = __ROR4__(v798 ^ v192, 16);
        v248 = v193 + v247;
        v523 = __ROR4__(v248 ^ v522, 12);
        v799 = (v9 ^ 0xBE5466CF) + v798 + v523;
        v194 = __ROR4__(v799 ^ v193, 8);
        v249 = v194 + v248;
        v524 = __ROR4__(v249 ^ v523, 7);
        v743 = (v8 ^ 0xC97C50DD) + v742 + v467;
        v138 = __ROR4__(v743 ^ v137, 16);
        v413 = v138 + v412;
        v468 = __ROR4__(v413 ^ v467, 12);
        v744 = (v7 ^ 0xC0AC29B7) + v743 + v468;
        v139 = __ROR4__(v744 ^ v138, 8);
        v414 = v139 + v413;
        v469 = __ROR4__(v414 ^ v468, 7);
        v688 = (v6 ^ 0xB5470917) + v687 + v632;
        v83 = __ROR4__(v688 ^ v82, 16);
        v358 = v83 + v357;
        v633 = __ROR4__(v358 ^ v632, 12);
        v689 = (result ^ 0x3F84D5B5) + v688 + v633;
        v84 = __ROR4__(v689 ^ v83, 8);
        v359 = v84 + v358;
        v634 = __ROR4__(v359 ^ v633, 7);
        v855 = (v6 ^ 0xBE5466CF) + v854 + v634;
        v195 = __ROR4__(v855 ^ v194, 16);
        v415 = v195 + v414;
        v635 = __ROR4__(v415 ^ v634, 12);
        v856 = (v10 ^ 0x3F84D5B5) + v855 + v635;
        v196 = __ROR4__(v856 ^ v195, 8);
        v416 = v196 + v415;
        v636 = __ROR4__(v416 ^ v635, 7);
        v800 = (v16 ^ 0x452821E6) + v799 + v579;
        v140 = __ROR4__(v800 ^ v139, 16);
        v360 = v140 + v359;
        v580 = __ROR4__(v360 ^ v579, 12);
        v801 = (v12 ^ 0xA4093822) + v800 + v580;
        v141 = __ROR4__(v801 ^ v140, 8);
        v361 = v141 + v360;
        v581 = __ROR4__(v361 ^ v580, 7);
        v745 = (v11 ^ 0xB5470917) + v744 + v524;
        v85 = __ROR4__(v745 ^ v84, 16);
        v305 = v85 + v304;
        v525 = __ROR4__(v305 ^ v524, 12);
        v746 = (result ^ 0x38D01377) + v745 + v525;
        v86 = __ROR4__(v746 ^ v85, 8);
        v306 = v86 + v305;
        v526 = __ROR4__(v306 ^ v525, 7);
        v690 = (v7 ^ 0x82EFA98) + v689 + v469;
        v30 = __ROR4__(v690 ^ v29, 16);
        v250 = v30 + v249;
        v470 = __ROR4__(v250 ^ v469, 12);
        v691 = (v14 ^ 0xC97C50DD) + v690 + v470;
        v31 = __ROR4__(v691 ^ v30, 8);
        v251 = v31 + v250;
        v471 = __ROR4__(v251 ^ v470, 7);
        v857 = (v19 ^ 0xC0AC29B7) + v856 + v581;
        v32 = __ROR4__(v857 ^ v31, 16);
        v307 = v32 + v306;
        v582 = __ROR4__(v307 ^ v581, 12);
        v858 = (v8 ^ 0x85A308D3) + v857 + v582;
        v33 = __ROR4__(v858 ^ v32, 8);
        v308 = v33 + v307;
        v583 = __ROR4__(v308 ^ v582, 7);
        v802 = (v20 ^ 0x13198A2E) + v801 + v526;
        v197 = __ROR4__(v802 ^ v196, 16);
        v252 = v197 + v251;
        v527 = __ROR4__(v252 ^ v526, 12);
        v803 = (v18 ^ 0x243F6A88) + v802 + v527;
        v198 = __ROR4__(v803 ^ v197, 8);
        v253 = v198 + v252;
        v528 = __ROR4__(v253 ^ v527, 7);
        v747 = (v9 ^ 0xEC4E6C89) + v746 + v471;
        v142 = __ROR4__(v747 ^ v141, 16);
        v417 = v142 + v416;
        v472 = __ROR4__(v417 ^ v471, 12);
        v748 = (v13 ^ 0x34E90C6C) + v747 + v472;
        v143 = __ROR4__(v748 ^ v142, 8);
        v418 = v143 + v417;
        v473 = __ROR4__(v418 ^ v472, 7);
        v692 = (v15 ^ 0x3707344) + v691 + v636;
        v87 = __ROR4__(v692 ^ v86, 16);
        v362 = v87 + v361;
        v637 = __ROR4__(v362 ^ v636, 12);
        v693 = (v17 ^ 0x299F31D0) + v692 + v637;
        v88 = __ROR4__(v693 ^ v87, 8);
        v363 = v88 + v362;
        v638 = __ROR4__(v363 ^ v637, 7);
        v859 = (v9 ^ 0x452821E6) + v858 + v638;
        v199 = __ROR4__(v859 ^ v198, 16);
        v419 = v199 + v418;
        v639 = __ROR4__(v419 ^ v638, 12);
        v860 = (v12 ^ 0x34E90C6C) + v859 + v639;
        v200 = __ROR4__(v860 ^ v199, 8);
        v420 = v200 + v419;
        v640 = __ROR4__(v420 ^ v639, 7);
        v804 = (v8 ^ 0x243F6A88) + v803 + v583;
        v144 = __ROR4__(v804 ^ v143, 16);
        v364 = v144 + v363;
        v584 = __ROR4__(v364 ^ v583, 12);
        v805 = (v20 ^ 0xC0AC29B7) + v804 + v584;
        v145 = __ROR4__(v805 ^ v144, 8);
        v365 = v145 + v364;
        v585 = __ROR4__(v365 ^ v584, 7);
        v749 = (v15 ^ 0x13198A2E) + v748 + v528;
        v89 = __ROR4__(v749 ^ v88, 16);
        v309 = v89 + v308;
        v529 = __ROR4__(v309 ^ v528, 12);
        v750 = (v18 ^ 0x299F31D0) + v749 + v529;
        v90 = __ROR4__(v750 ^ v89, 8);
        v310 = v90 + v309;
        v530 = __ROR4__(v310 ^ v529, 7);
        v694 = (result ^ 0xC97C50DD) + v693 + v473;
        v34 = __ROR4__(v694 ^ v33, 16);
        v254 = v34 + v253;
        v474 = __ROR4__(v254 ^ v473, 12);
        v695 = (v7 ^ 0xB5470917) + v694 + v474;
        v35 = __ROR4__(v695 ^ v34, 8);
        v255 = v35 + v254;
        v475 = __ROR4__(v255 ^ v474, 7);
        v861 = (v10 ^ 0x3F84D5B5) + v860 + v585;
        v36 = __ROR4__(v861 ^ v35, 16);
        v311 = v36 + v310;
        v586 = __ROR4__(v311 ^ v585, 12);
        v862 = (v6 ^ 0xBE5466CF) + v861 + v586;
        v37 = __ROR4__(v862 ^ v36, 8);
        v312 = v37 + v311;
        v587 = __ROR4__(v312 ^ v586, 7);
        v806 = (v17 ^ 0x82EFA98) + v805 + v530;
        v201 = __ROR4__(v806 ^ v200, 16);
        v256 = v201 + v255;
        v531 = __ROR4__(v256 ^ v530, 12);
        v807 = (v14 ^ 0x3707344) + v806 + v531;
        v202 = __ROR4__(v807 ^ v201, 8);
        v257 = v202 + v256;
        v532 = __ROR4__(v257 ^ v531, 7);
        v751 = (v13 ^ 0x85A308D3) + v750 + v475;
        v146 = __ROR4__(v751 ^ v145, 16);
        v421 = v146 + v420;
        v476 = __ROR4__(v421 ^ v475, 12);
        v752 = (v19 ^ 0xEC4E6C89) + v751 + v476;
        v147 = __ROR4__(v752 ^ v146, 8);
        v422 = v147 + v421;
        v477 = __ROR4__(v422 ^ v476, 7);
        v696 = (v11 ^ 0xA4093822) + v695 + v640;
        v91 = __ROR4__(v696 ^ v90, 16);
        v366 = v91 + v365;
        v641 = __ROR4__(v366 ^ v640, 12);
        v697 = (v16 ^ 0x38D01377) + v696 + v641;
        v92 = __ROR4__(v697 ^ v91, 8);
        v367 = v92 + v366;
        v642 = __ROR4__(v367 ^ v641, 7);
        v863 = (v13 ^ 0x38D01377) + v862 + v642;
        v203 = __ROR4__(v863 ^ v202, 16);
        v423 = v203 + v422;
        v643 = __ROR4__(v423 ^ v642, 12);
        v864 = (v11 ^ 0xEC4E6C89) + v863 + v643;
        v204 = __ROR4__(v864 ^ v203, 8);
        v424 = v204 + v423;
        v644 = __ROR4__(v424 ^ v643, 7);
        v808 = (v17 ^ 0x85A308D3) + v807 + v587;
        v148 = __ROR4__(v808 ^ v147, 16);
        v368 = v148 + v367;
        v588 = __ROR4__(v368 ^ v587, 12);
        v809 = (v19 ^ 0x3707344) + v808 + v588;
        v149 = __ROR4__(v809 ^ v148, 8);
        v369 = v149 + v368;
        v589 = __ROR4__(v369 ^ v588, 7);
        v753 = (v7 ^ 0xC0AC29B7) + v752 + v532;
        v93 = __ROR4__(v753 ^ v92, 16);
        v313 = v93 + v312;
        v533 = __ROR4__(v313 ^ v532, 12);
        v754 = (v8 ^ 0xC97C50DD) + v753 + v533;
        v94 = __ROR4__(v754 ^ v93, 8);
        v314 = v94 + v313;
        v534 = __ROR4__(v314 ^ v533, 7);
        v698 = (v9 ^ 0x3F84D5B5) + v697 + v477;
        v38 = __ROR4__(v698 ^ v37, 16);
        v258 = v38 + v257;
        v478 = __ROR4__(v258 ^ v477, 12);
        v699 = (v6 ^ 0x34E90C6C) + v698 + v478;
        v39 = __ROR4__(v699 ^ v38, 8);
        v259 = v39 + v258;
        v479 = __ROR4__(v259 ^ v478, 7);
        v865 = (v18 ^ 0x82EFA98) + v864 + v589;
        v40 = __ROR4__(v865 ^ v39, 16);
        v315 = v40 + v314;
        v590 = __ROR4__(v315 ^ v589, 12);
        v866 = (v14 ^ 0x13198A2E) + v865 + v590;
        v41 = __ROR4__(v866 ^ v40, 8);
        v316 = v41 + v315;
        v591 = __ROR4__(v316 ^ v590, 7);
        v810 = (v15 ^ 0xBE5466CF) + v809 + v534;
        v205 = __ROR4__(v810 ^ v204, 16);
        v260 = v205 + v259;
        v535 = __ROR4__(v260 ^ v534, 12);
        v811 = (v10 ^ 0x299F31D0) + v810 + v535;
        v206 = __ROR4__(v811 ^ v205, 8);
        v261 = v206 + v260;
        v536 = __ROR4__(v261 ^ v535, 7);
        v755 = (v16 ^ 0x243F6A88) + v754 + v479;
        v150 = __ROR4__(v755 ^ v149, 16);
        v425 = v150 + v424;
        v480 = __ROR4__(v425 ^ v479, 12);
        v756 = (v20 ^ 0xA4093822) + v755 + v480;
        v151 = __ROR4__(v756 ^ v150, 8);
        v426 = v151 + v425;
        v481 = __ROR4__(v426 ^ v480, 7);
        v700 = (result ^ 0x452821E6) + v699 + v644;
        v95 = __ROR4__(v700 ^ v94, 16);
        v370 = v95 + v369;
        v645 = __ROR4__(v370 ^ v644, 12);
        v701 = (v12 ^ 0xB5470917) + v700 + v645;
        v96 = __ROR4__(v701 ^ v95, 8);
        v371 = v96 + v370;
        v646 = __ROR4__(v371 ^ v645, 7);
        v867 = (v11 ^ 0x243F6A88) + v866 + v646;
        v207 = __ROR4__(v867 ^ v206, 16);
        v427 = v207 + v426;
        v647 = __ROR4__(v427 ^ v646, 12);
        v868 = (v20 ^ 0x38D01377) + v867 + v647;
        v208 = __ROR4__(v868 ^ v207, 8);
        v428 = v208 + v427;
        v648 = __ROR4__(v428 ^ v647, 7);
        v812 = (v15 ^ 0xEC4E6C89) + v811 + v591;
        v152 = __ROR4__(v812 ^ v151, 16);
        v372 = v152 + v371;
        v592 = __ROR4__(v372 ^ v591, 12);
        v813 = (v13 ^ 0x299F31D0) + v812 + v592;
        v153 = __ROR4__(v813 ^ v152, 8);
        v373 = v153 + v372;
        v593 = __ROR4__(v373 ^ v592, 7);
        v757 = (v18 ^ 0xA4093822) + v756 + v536;
        v97 = __ROR4__(v757 ^ v96, 16);
        v317 = v97 + v316;
        v537 = __ROR4__(v317 ^ v536, 12);
        v758 = (v16 ^ 0x13198A2E) + v757 + v537;
        v98 = __ROR4__(v758 ^ v97, 8);
        v318 = v98 + v317;
        v538 = __ROR4__(v318 ^ v537, 7);
        v702 = (v10 ^ 0xB5470917) + v701 + v481;
        v42 = __ROR4__(v702 ^ v41, 16);
        v262 = v42 + v261;
        v482 = __ROR4__(v262 ^ v481, 12);
        v703 = (result ^ 0xBE5466CF) + v702 + v482;
        v43 = __ROR4__(v703 ^ v42, 8);
        v263 = v43 + v262;
        v483 = __ROR4__(v263 ^ v482, 7);
        v869 = (v6 ^ 0x85A308D3) + v868 + v593;
        v44 = __ROR4__(v869 ^ v43, 16);
        v319 = v44 + v318;
        v594 = __ROR4__(v319 ^ v593, 12);
        v870 = (v19 ^ 0x3F84D5B5) + v869 + v594;
        v45 = __ROR4__(v870 ^ v44, 8);
        v320 = v45 + v319;
        v595 = __ROR4__(v320 ^ v594, 7);
        v814 = (v9 ^ 0xC0AC29B7) + v813 + v538;
        v209 = __ROR4__(v814 ^ v208, 16);
        v264 = v209 + v263;
        v539 = __ROR4__(v264 ^ v538, 12);
        v815 = (v8 ^ 0x34E90C6C) + v814 + v539;
        v210 = __ROR4__(v815 ^ v209, 8);
        v265 = v210 + v264;
        v540 = __ROR4__(v265 ^ v539, 7);
        v759 = (v14 ^ 0x452821E6) + v758 + v483;
        v154 = __ROR4__(v759 ^ v153, 16);
        v429 = v154 + v428;
        v484 = __ROR4__(v429 ^ v483, 12);
        v760 = (v12 ^ 0x82EFA98) + v759 + v484;
        v155 = __ROR4__(v760 ^ v154, 8);
        v430 = v155 + v429;
        v485 = __ROR4__(v430 ^ v484, 7);
        v704 = (v17 ^ 0xC97C50DD) + v703 + v648;
        v99 = __ROR4__(v704 ^ v98, 16);
        v374 = v99 + v373;
        v649 = __ROR4__(v374 ^ v648, 12);
        v705 = (v7 ^ 0x3707344) + v704 + v649;
        v100 = __ROR4__(v705 ^ v99, 8);
        v375 = v100 + v374;
        v650 = __ROR4__(v375 ^ v649, 7);
        v871 = (v18 ^ 0xC0AC29B7) + v870 + v650;
        v211 = __ROR4__(v871 ^ v210, 16);
        v431 = v211 + v430;
        v651 = __ROR4__(v431 ^ v650, 12);
        v872 = (v8 ^ 0x13198A2E) + v871 + v651;
        v212 = __ROR4__(v872 ^ v211, 8);
        v432 = v212 + v431;
        v652 = __ROR4__(v432 ^ v651, 7);
        v816 = (v14 ^ 0xBE5466CF) + v815 + v595;
        v156 = __ROR4__(v816 ^ v155, 16);
        v376 = v156 + v375;
        v596 = __ROR4__(v376 ^ v595, 12);
        v817 = (v10 ^ 0x82EFA98) + v816 + v596;
        v157 = __ROR4__(v817 ^ v156, 8);
        v377 = v157 + v376;
        v597 = __ROR4__(v377 ^ v596, 7);
        v761 = (v20 ^ 0x34E90C6C) + v760 + v540;
        v101 = __ROR4__(v761 ^ v100, 16);
        v321 = v101 + v320;
        v541 = __ROR4__(v321 ^ v540, 12);
        v762 = (v9 ^ 0x243F6A88) + v761 + v541;
        v102 = __ROR4__(v762 ^ v101, 8);
        v322 = v102 + v321;
        v542 = __ROR4__(v322 ^ v541, 7);
        v706 = (v12 ^ 0x3707344) + v705 + v485;
        v46 = __ROR4__(v706 ^ v45, 16);
        v266 = v46 + v265;
        v486 = __ROR4__(v266 ^ v485, 12);
        v707 = (v17 ^ 0x452821E6) + v706 + v486;
        v47 = __ROR4__(v707 ^ v46, 8);
        v267 = v47 + v266;
        v487 = __ROR4__(v267 ^ v486, 7);
        v873 = (v16 ^ 0xC97C50DD) + v872 + v597;
        v48 = __ROR4__(v873 ^ v47, 16);
        v323 = v48 + v322;
        v598 = __ROR4__(v323 ^ v597, 12);
        v874 = (v7 ^ 0xA4093822) + v873 + v598;
        v49 = __ROR4__(v874 ^ v48, 8);
        v324 = v49 + v323;
        v599 = __ROR4__(v324 ^ v598, 7);
        v818 = (v13 ^ 0x299F31D0) + v817 + v542;
        v213 = __ROR4__(v818 ^ v212, 16);
        v268 = v213 + v267;
        v543 = __ROR4__(v268 ^ v542, 12);
        v819 = (v15 ^ 0xEC4E6C89) + v818 + v543;
        v214 = __ROR4__(v819 ^ v213, 8);
        v269 = v214 + v268;
        v544 = __ROR4__(v269 ^ v543, 7);
        v763 = (result ^ 0x3F84D5B5) + v762 + v487;
        v158 = __ROR4__(v763 ^ v157, 16);
        v433 = v158 + v432;
        v488 = __ROR4__(v433 ^ v487, 12);
        v764 = (v6 ^ 0xB5470917) + v763 + v488;
        v159 = __ROR4__(v764 ^ v158, 8);
        v434 = v159 + v433;
        v489 = __ROR4__(v434 ^ v488, 7);
        v708 = (v19 ^ 0x38D01377) + v707 + v652;
        v103 = __ROR4__(v708 ^ v102, 16);
        v378 = v103 + v377;
        v653 = __ROR4__(v378 ^ v652, 12);
        v709 = (v11 ^ 0x85A308D3) + v708 + v653;
        v104 = __ROR4__(v709 ^ v103, 8);
        v379 = v104 + v378;
        v654 = __ROR4__(v379 ^ v653, 7);
        v875 = (v8 ^ 0x299F31D0) + v874 + v654;
        v215 = __ROR4__(v875 ^ v214, 16);
        v435 = v215 + v434;
        v655 = __ROR4__(v435 ^ v654, 12);
        v876 = (v15 ^ 0xC0AC29B7) + v875 + v655;
        v216 = __ROR4__(v876 ^ v215, 8);
        v436 = v216 + v435;
        v656 = __ROR4__(v436 ^ v655, 7);
        v820 = (v19 ^ 0xB5470917) + v819 + v599;
        v160 = __ROR4__(v820 ^ v159, 16);
        v380 = v160 + v379;
        v600 = __ROR4__(v380 ^ v599, 12);
        v821 = (result ^ 0x85A308D3) + v820 + v600;
        v161 = __ROR4__(v821 ^ v160, 8);
        v381 = v161 + v380;
        v601 = __ROR4__(v381 ^ v600, 7);
        v765 = (v6 ^ 0xC97C50DD) + v764 + v544;
        v105 = __ROR4__(v765 ^ v104, 16);
        v325 = v105 + v324;
        v545 = __ROR4__(v325 ^ v544, 12);
        v766 = (v7 ^ 0x3F84D5B5) + v765 + v545;
        v106 = __ROR4__(v766 ^ v105, 8);
        v326 = v106 + v325;
        v546 = __ROR4__(v326 ^ v545, 7);
        v710 = (v16 ^ 0xBE5466CF) + v709 + v489;
        v50 = __ROR4__(v710 ^ v49, 16);
        v270 = v50 + v269;
        v490 = __ROR4__(v270 ^ v489, 12);
        v711 = (v10 ^ 0xA4093822) + v710 + v490;
        v51 = __ROR4__(v711 ^ v50, 8);
        v271 = v51 + v270;
        v491 = __ROR4__(v271 ^ v490, 7);
        v877 = (v20 ^ 0xEC4E6C89) + v876 + v601;
        v52 = __ROR4__(v877 ^ v51, 16);
        v327 = v52 + v326;
        v602 = __ROR4__(v327 ^ v601, 12);
        v878 = (v13 ^ 0x243F6A88) + v877 + v602;
        v53 = __ROR4__(v878 ^ v52, 8);
        v328 = v53 + v327;
        v603 = __ROR4__(v328 ^ v602, 7);
        v822 = (v14 ^ 0x3707344) + v821 + v546;
        v217 = __ROR4__(v822 ^ v216, 16);
        v272 = v217 + v271;
        v547 = __ROR4__(v272 ^ v546, 12);
        v823 = (v17 ^ 0x82EFA98) + v822 + v547;
        v218 = __ROR4__(v823 ^ v217, 8);
        v273 = v218 + v272;
        v548 = __ROR4__(v273 ^ v547, 7);
        v767 = (v11 ^ 0x13198A2E) + v766 + v491;
        v162 = __ROR4__(v767 ^ v161, 16);
        v437 = v162 + v436;
        v492 = __ROR4__(v437 ^ v491, 12);
        v768 = (v18 ^ 0x38D01377) + v767 + v492;
        v163 = __ROR4__(v768 ^ v162, 8);
        v438 = v163 + v437;
        v493 = __ROR4__(v438 ^ v492, 7);
        v712 = (v12 ^ 0x34E90C6C) + v711 + v656;
        v107 = __ROR4__(v712 ^ v106, 16);
        v382 = v107 + v381;
        v657 = __ROR4__(v382 ^ v656, 12);
        v713 = (v9 ^ 0x452821E6) + v712 + v657;
        v108 = __ROR4__(v713 ^ v107, 8);
        v383 = v108 + v382;
        v658 = __ROR4__(v383 ^ v657, 7);
        v879 = (v7 ^ 0x34E90C6C) + v878 + v658;
        v219 = __ROR4__(v879 ^ v218, 16);
        v439 = v219 + v438;
        v659 = __ROR4__(v439 ^ v658, 12);
        v880 = (v9 ^ 0xC97C50DD) + v879 + v659;
        v220 = __ROR4__(v880 ^ v219, 8);
        v440 = v220 + v439;
        v660 = __ROR4__(v440 ^ v659, 7);
        v824 = (v13 ^ 0x3F84D5B5) + v823 + v603;
        v164 = __ROR4__(v824 ^ v163, 16);
        v384 = v164 + v383;
        v604 = __ROR4__(v384 ^ v603, 12);
        v825 = (v6 ^ 0xEC4E6C89) + v824 + v604;
        v165 = __ROR4__(v825 ^ v164, 8);
        v385 = v165 + v384;
        v605 = __ROR4__(v385 ^ v604, 7);
        v769 = (v8 ^ 0x85A308D3) + v768 + v548;
        v109 = __ROR4__(v769 ^ v108, 16);
        v329 = v109 + v328;
        v549 = __ROR4__(v329 ^ v548, 12);
        v770 = (v19 ^ 0xC0AC29B7) + v769 + v549;
        v110 = __ROR4__(v770 ^ v109, 8);
        v330 = v110 + v329;
        v550 = __ROR4__(v330 ^ v549, 7);
        v714 = (v17 ^ 0x38D01377) + v713 + v493;
        v54 = __ROR4__(v714 ^ v53, 16);
        v274 = v54 + v273;
        v494 = __ROR4__(v274 ^ v493, 12);
        v715 = (v11 ^ 0x3707344) + v714 + v494;
        v55 = __ROR4__(v715 ^ v54, 8);
        v275 = v55 + v274;
        v495 = __ROR4__(v275 ^ v494, 7);
        v881 = (v15 ^ 0x243F6A88) + v880 + v605;
        v56 = __ROR4__(v881 ^ v55, 16);
        v331 = v56 + v330;
        v606 = __ROR4__(v331 ^ v605, 12);
        v882 = (v20 ^ 0x299F31D0) + v881 + v606;
        v57 = __ROR4__(v882 ^ v56, 8);
        v332 = v57 + v331;
        v607 = __ROR4__(v332 ^ v606, 7);
        v826 = (result ^ 0xA4093822) + v825 + v550;
        v221 = __ROR4__(v826 ^ v220, 16);
        v276 = v221 + v275;
        v551 = __ROR4__(v276 ^ v550, 12);
        v827 = (v16 ^ 0xB5470917) + v826 + v551;
        v222 = __ROR4__(v827 ^ v221, 8);
        v277 = v222 + v276;
        v552 = __ROR4__(v277 ^ v551, 7);
        v771 = (v12 ^ 0x82EFA98) + v770 + v495;
        v166 = __ROR4__(v771 ^ v165, 16);
        v441 = v166 + v440;
        v496 = __ROR4__(v441 ^ v495, 12);
        v772 = (v14 ^ 0x452821E6) + v771 + v496;
        v167 = __ROR4__(v772 ^ v166, 8);
        v442 = v167 + v441;
        v497 = __ROR4__(v442 ^ v496, 7);
        v716 = (v18 ^ 0xBE5466CF) + v715 + v660;
        v111 = __ROR4__(v716 ^ v110, 16);
        v386 = v111 + v385;
        v661 = __ROR4__(v386 ^ v660, 12);
        v717 = (v10 ^ 0x13198A2E) + v716 + v661;
        v112 = __ROR4__(v717 ^ v111, 8);
        v387 = v112 + v386;
        v662 = __ROR4__(v387 ^ v661, 7);
        if ( blake256_rounds == 14 )
        {
          v883 = (v14 ^ 0xB5470917) + v882 + v662;
          v223 = __ROR4__(v883 ^ v222, 16);
          v443 = v223 + v442;
          v663 = __ROR4__(v443 ^ v662, 12);
          v884 = (result ^ 0x82EFA98) + v883 + v663;
          v224 = __ROR4__(v884 ^ v223, 8);
          v444 = v224 + v443;
          v664 = __ROR4__(v444 ^ v663, 7);
          v828 = (v6 ^ 0x38D01377) + v827 + v607;
          v168 = __ROR4__(v828 ^ v167, 16);
          v388 = v168 + v387;
          v608 = __ROR4__(v388 ^ v607, 12);
          v829 = (v11 ^ 0x3F84D5B5) + v828 + v608;
          v169 = __ROR4__(v829 ^ v168, 8);
          v389 = v169 + v388;
          v609 = __ROR4__(v389 ^ v608, 7);
          v773 = (v9 ^ 0x3707344) + v772 + v552;
          v113 = __ROR4__(v773 ^ v112, 16);
          v333 = v113 + v332;
          v553 = __ROR4__(v333 ^ v552, 12);
          v774 = (v17 ^ 0x34E90C6C) + v773 + v553;
          v114 = __ROR4__(v774 ^ v113, 8);
          v334 = v114 + v333;
          v554 = __ROR4__(v334 ^ v553, 7);
          v718 = (v20 ^ 0x452821E6) + v717 + v497;
          v58 = __ROR4__(v718 ^ v57, 16);
          v278 = v58 + v277;
          v498 = __ROR4__(v278 ^ v497, 12);
          v719 = (v12 ^ 0x243F6A88) + v718 + v498;
          v59 = __ROR4__(v719 ^ v58, 8);
          v279 = v59 + v278;
          v499 = __ROR4__(v279 ^ v498, 7);
          v885 = (v8 ^ 0x13198A2E) + v884 + v609;
          v60 = __ROR4__(v885 ^ v59, 16);
          v335 = v60 + v334;
          v610 = __ROR4__(v335 ^ v609, 12);
          v886 = (v18 ^ 0xC0AC29B7) + v885 + v610;
          v61 = __ROR4__(v886 ^ v60, 8);
          v336 = v61 + v335;
          v611 = __ROR4__(v336 ^ v610, 7);
          v830 = (v7 ^ 0xEC4E6C89) + v829 + v554;
          v225 = __ROR4__(v830 ^ v224, 16);
          v280 = v225 + v279;
          v555 = __ROR4__(v280 ^ v554, 12);
          v831 = (v13 ^ 0xC97C50DD) + v830 + v555;
          v226 = __ROR4__(v831 ^ v225, 8);
          v281 = v226 + v280;
          v556 = __ROR4__(v281 ^ v555, 7);
          v775 = (v19 ^ 0xA4093822) + v774 + v499;
          v170 = __ROR4__(v775 ^ v169, 16);
          v445 = v170 + v444;
          v500 = __ROR4__(v445 ^ v499, 12);
          v776 = (v16 ^ 0x85A308D3) + v775 + v500;
          v171 = __ROR4__(v776 ^ v170, 8);
          v446 = v171 + v445;
          v501 = __ROR4__(v446 ^ v500, 7);
          v720 = (v10 ^ 0x299F31D0) + v719 + v664;
          v115 = __ROR4__(v720 ^ v114, 16);
          v390 = v115 + v389;
          v665 = __ROR4__(v390 ^ v664, 12);
          v721 = (v15 ^ 0xBE5466CF) + v720 + v665;
          v116 = __ROR4__(v721 ^ v115, 8);
          v391 = v116 + v390;
          v666 = __ROR4__(v391 ^ v665, 7);
          v887 = (v10 ^ 0x13198A2E) + v886 + v666;
          v227 = __ROR4__(v887 ^ v226, 16);
          v447 = v227 + v446;
          v667 = __ROR4__(v447 ^ v666, 12);
          v888 = (v18 ^ 0xBE5466CF) + v887 + v667;
          v228 = __ROR4__(v888 ^ v227, 8);
          v448 = v228 + v447;
          v668 = __ROR4__(v448 ^ v667, 7);
          v832 = (v12 ^ 0xA4093822) + v831 + v611;
          v172 = __ROR4__(v832 ^ v171, 16);
          v392 = v172 + v391;
          v612 = __ROR4__(v392 ^ v611, 12);
          v833 = (v16 ^ 0x452821E6) + v832 + v612;
          v173 = __ROR4__(v833 ^ v172, 8);
          v393 = v173 + v392;
          v613 = __ROR4__(v393 ^ v612, 7);
          v777 = (v13 ^ 0x82EFA98) + v776 + v556;
          v117 = __ROR4__(v777 ^ v116, 16);
          v337 = v117 + v336;
          v557 = __ROR4__(v337 ^ v556, 12);
          v778 = (v14 ^ 0xEC4E6C89) + v777 + v557;
          v118 = __ROR4__(v778 ^ v117, 8);
          v338 = v118 + v337;
          v558 = __ROR4__(v338 ^ v557, 7);
          v722 = (v19 ^ 0x299F31D0) + v721 + v501;
          v62 = __ROR4__(v722 ^ v61, 16);
          v282 = v62 + v281;
          v502 = __ROR4__(v282 ^ v501, 12);
          v723 = (v15 ^ 0x85A308D3) + v722 + v502;
          v63 = __ROR4__(v723 ^ v62, 8);
          v283 = v63 + v282;
          v503 = __ROR4__(v283 ^ v502, 7);
          v889 = (result ^ 0x34E90C6C) + v888 + v613;
          v64 = __ROR4__(v889 ^ v63, 16);
          v339 = v64 + v338;
          v614 = __ROR4__(v339 ^ v613, 12);
          v890 = (v9 ^ 0xB5470917) + v889 + v614;
          v65 = __ROR4__(v890 ^ v64, 8);
          v340 = v65 + v339;
          v615 = __ROR4__(v340 ^ v614, 7);
          v834 = (v11 ^ 0x3F84D5B5) + v833 + v558;
          v229 = __ROR4__(v834 ^ v228, 16);
          v284 = v229 + v283;
          v559 = __ROR4__(v284 ^ v558, 12);
          v835 = (v6 ^ 0x38D01377) + v834 + v559;
          v230 = __ROR4__(v835 ^ v229, 8);
          v285 = v230 + v284;
          v560 = __ROR4__(v285 ^ v559, 7);
          v779 = (v17 ^ 0xC0AC29B7) + v778 + v503;
          v174 = __ROR4__(v779 ^ v173, 16);
          v449 = v174 + v448;
          v504 = __ROR4__(v449 ^ v503, 12);
          v780 = (v8 ^ 0x3707344) + v779 + v504;
          v175 = __ROR4__(v780 ^ v174, 8);
          v450 = v175 + v449;
          v505 = __ROR4__(v450 ^ v504, 7);
          v724 = (v7 ^ 0x243F6A88) + v723 + v668;
          v119 = __ROR4__(v724 ^ v118, 16);
          v394 = v119 + v393;
          v669 = __ROR4__(v394 ^ v668, 12);
          v725 = (v20 ^ 0xC97C50DD) + v724 + v669;
          v120 = __ROR4__(v725 ^ v119, 8);
          v395 = v120 + v394;
          v670 = __ROR4__(v395 ^ v669, 7);
          v891 = (v20 ^ 0x85A308D3) + v890 + v670;
          v231 = __ROR4__(v891 ^ v230, 16);
          v451 = v231 + v450;
          v671 = __ROR4__(v451 ^ v670, 12);
          v892 = (v19 ^ 0x243F6A88) + v891 + v671;
          v232 = __ROR4__(v892 ^ v231, 8);
          v452 = v232 + v451;
          v672 = __ROR4__(v452 ^ v671, 7);
          v836 = (v18 ^ 0x3707344) + v835 + v615;
          v176 = __ROR4__(v836 ^ v175, 16);
          v396 = v176 + v395;
          v616 = __ROR4__(v396 ^ v615, 12);
          v837 = (v17 ^ 0x13198A2E) + v836 + v616;
          v177 = __ROR4__(v837 ^ v176, 8);
          v397 = v177 + v396;
          v617 = __ROR4__(v397 ^ v616, 7);
          v781 = (v16 ^ 0x299F31D0) + v780 + v560;
          v121 = __ROR4__(v781 ^ v120, 16);
          v341 = v121 + v340;
          v561 = __ROR4__(v341 ^ v560, 12);
          v782 = (v15 ^ 0xA4093822) + v781 + v561;
          v122 = __ROR4__(v782 ^ v121, 8);
          v342 = v122 + v341;
          v562 = __ROR4__(v342 ^ v561, 7);
          v726 = (v14 ^ 0xEC4E6C89) + v725 + v505;
          v66 = __ROR4__(v726 ^ v65, 16);
          v286 = v66 + v285;
          v506 = __ROR4__(v286 ^ v505, 12);
          v727 = (v13 ^ 0x82EFA98) + v726 + v506;
          v67 = __ROR4__(v727 ^ v66, 8);
          v287 = v67 + v286;
          v507 = __ROR4__(v287 ^ v506, 7);
          v893 = (v12 ^ 0x38D01377) + v892 + v617;
          v68 = __ROR4__(v893 ^ v67, 16);
          v343 = v68 + v342;
          v618 = __ROR4__(v343 ^ v617, 12);
          v894 = (v11 ^ 0x452821E6) + v893 + v618;
          v69 = __ROR4__(v894 ^ v68, 8);
          v344 = v69 + v343;
          v619 = __ROR4__(v344 ^ v618, 7);
          v838 = (v10 ^ 0x34E90C6C) + v837 + v562;
          v233 = __ROR4__(v838 ^ v232, 16);
          v288 = v233 + v287;
          v563 = __ROR4__(v288 ^ v562, 12);
          v839 = (v9 ^ 0xBE5466CF) + v838 + v563;
          v234 = __ROR4__(v839 ^ v233, 8);
          v289 = v234 + v288;
          v564 = __ROR4__(v289 ^ v563, 7);
          v783 = (v8 ^ 0xC97C50DD) + v782 + v507;
          v178 = __ROR4__(v783 ^ v177, 16);
          v453 = v178 + v452;
          v508 = __ROR4__(v453 ^ v507, 12);
          v784 = (v7 ^ 0xC0AC29B7) + v783 + v508;
          v179 = __ROR4__(v784 ^ v178, 8);
          v454 = v179 + v453;
          v509 = __ROR4__(v454 ^ v508, 7);
          v728 = (v6 ^ 0xB5470917) + v727 + v672;
          v123 = __ROR4__(v728 ^ v122, 16);
          v398 = v123 + v397;
          v673 = __ROR4__(v398 ^ v672, 12);
          v729 = (result ^ 0x3F84D5B5) + v728 + v673;
          v124 = __ROR4__(v729 ^ v123, 8);
          v399 = v124 + v398;
          v674 = __ROR4__(v399 ^ v673, 7);
          v895 = (v6 ^ 0xBE5466CF) + v894 + v674;
          v235 = __ROR4__(v895 ^ v234, 16);
          v455 = v235 + v454;
          v675 = __ROR4__(v455 ^ v674, 12);
          v896 = (v10 ^ 0x3F84D5B5) + v895 + v675;
          v236 = __ROR4__(v896 ^ v235, 8);
          v456 = v236 + v455;
          v676 = __ROR4__(v456 ^ v675, 7);
          v840 = (v16 ^ 0x452821E6) + v839 + v619;
          v180 = __ROR4__(v840 ^ v179, 16);
          v400 = v180 + v399;
          v620 = __ROR4__(v400 ^ v619, 12);
          v841 = (v12 ^ 0xA4093822) + v840 + v620;
          v181 = __ROR4__(v841 ^ v180, 8);
          v401 = v181 + v400;
          v621 = __ROR4__(v401 ^ v620, 7);
          v785 = (v11 ^ 0xB5470917) + v784 + v564;
          v125 = __ROR4__(v785 ^ v124, 16);
          v345 = v125 + v344;
          v565 = __ROR4__(v345 ^ v564, 12);
          v786 = (result ^ 0x38D01377) + v785 + v565;
          v126 = __ROR4__(v786 ^ v125, 8);
          v346 = v126 + v345;
          v566 = __ROR4__(v346 ^ v565, 7);
          v730 = (v7 ^ 0x82EFA98) + v729 + v509;
          v70 = __ROR4__(v730 ^ v69, 16);
          v290 = v70 + v289;
          v510 = __ROR4__(v290 ^ v509, 12);
          v731 = (v14 ^ 0xC97C50DD) + v730 + v510;
          v71 = __ROR4__(v731 ^ v70, 8);
          v291 = v71 + v290;
          v511 = __ROR4__(v291 ^ v510, 7);
          v897 = (v19 ^ 0xC0AC29B7) + v896 + v621;
          v72 = __ROR4__(v897 ^ v71, 16);
          v347 = v72 + v346;
          v622 = __ROR4__(v347 ^ v621, 12);
          v898 = (v8 ^ 0x85A308D3) + v897 + v622;
          v73 = __ROR4__(v898 ^ v72, 8);
          v348 = v73 + v347;
          v623 = __ROR4__(v348 ^ v622, 7);
          v842 = (v20 ^ 0x13198A2E) + v841 + v566;
          v237 = __ROR4__(v842 ^ v236, 16);
          v292 = v237 + v291;
          v567 = __ROR4__(v292 ^ v566, 12);
          v843 = (v18 ^ 0x243F6A88) + v842 + v567;
          v238 = __ROR4__(v843 ^ v237, 8);
          v293 = v238 + v292;
          v568 = __ROR4__(v293 ^ v567, 7);
          v787 = (v9 ^ 0xEC4E6C89) + v786 + v511;
          v182 = __ROR4__(v787 ^ v181, 16);
          v457 = v182 + v456;
          v512 = __ROR4__(v457 ^ v511, 12);
          v788 = (v13 ^ 0x34E90C6C) + v787 + v512;
          v183 = __ROR4__(v788 ^ v182, 8);
          v458 = v183 + v457;
          v513 = __ROR4__(v458 ^ v512, 7);
          v732 = (v15 ^ 0x3707344) + v731 + v676;
          v127 = __ROR4__(v732 ^ v126, 16);
          v402 = v127 + v401;
          v677 = __ROR4__(v402 ^ v676, 12);
          v733 = (v17 ^ 0x299F31D0) + v732 + v677;
          v128 = __ROR4__(v733 ^ v127, 8);
          v403 = v128 + v402;
          v678 = __ROR4__(v403 ^ v677, 7);
          v899 = (v9 ^ 0x452821E6) + v898 + v678;
          v239 = __ROR4__(v899 ^ v238, 16);
          v459 = v239 + v458;
          v679 = __ROR4__(v459 ^ v678, 12);
          v900 = (v12 ^ 0x34E90C6C) + v899 + v679;
          v240 = __ROR4__(v900 ^ v239, 8);
          v460 = v240 + v459;
          v680 = __ROR4__(v460 ^ v679, 7);
          v844 = (v8 ^ 0x243F6A88) + v843 + v623;
          v184 = __ROR4__(v844 ^ v183, 16);
          v404 = v184 + v403;
          v624 = __ROR4__(v404 ^ v623, 12);
          v845 = (v20 ^ 0xC0AC29B7) + v844 + v624;
          v185 = __ROR4__(v845 ^ v184, 8);
          v405 = v185 + v404;
          v625 = __ROR4__(v405 ^ v624, 7);
          v789 = (v15 ^ 0x13198A2E) + v788 + v568;
          v129 = __ROR4__(v789 ^ v128, 16);
          v349 = v129 + v348;
          v569 = __ROR4__(v349 ^ v568, 12);
          v790 = (v18 ^ 0x299F31D0) + v789 + v569;
          v130 = __ROR4__(v790 ^ v129, 8);
          v350 = v130 + v349;
          v570 = __ROR4__(v350 ^ v569, 7);
          v734 = (result ^ 0xC97C50DD) + v733 + v513;
          v74 = __ROR4__(v734 ^ v73, 16);
          v294 = v74 + v293;
          v514 = __ROR4__(v294 ^ v513, 12);
          v735 = (v7 ^ 0xB5470917) + v734 + v514;
          v75 = __ROR4__(v735 ^ v74, 8);
          v295 = v75 + v294;
          v515 = __ROR4__(v295 ^ v514, 7);
          v901 = (v10 ^ 0x3F84D5B5) + v900 + v625;
          v76 = __ROR4__(v901 ^ v75, 16);
          v351 = v76 + v350;
          v626 = __ROR4__(v351 ^ v625, 12);
          v902 = (v6 ^ 0xBE5466CF) + v901 + v626;
          v77 = __ROR4__(v902 ^ v76, 8);
          v352 = v77 + v351;
          v627 = __ROR4__(v352 ^ v626, 7);
          v846 = (v17 ^ 0x82EFA98) + v845 + v570;
          v241 = __ROR4__(v846 ^ v240, 16);
          v296 = v241 + v295;
          v571 = __ROR4__(v296 ^ v570, 12);
          v847 = (v14 ^ 0x3707344) + v846 + v571;
          v242 = __ROR4__(v847 ^ v241, 8);
          v297 = v242 + v296;
          v572 = __ROR4__(v297 ^ v571, 7);
          v791 = (v13 ^ 0x85A308D3) + v790 + v515;
          v186 = __ROR4__(v791 ^ v185, 16);
          v461 = v186 + v460;
          v516 = __ROR4__(v461 ^ v515, 12);
          v792 = (v19 ^ 0xEC4E6C89) + v791 + v516;
          v187 = __ROR4__(v792 ^ v186, 8);
          v462 = v187 + v461;
          v517 = __ROR4__(v462 ^ v516, 7);
          v736 = (v11 ^ 0xA4093822) + v735 + v680;
          v131 = __ROR4__(v736 ^ v130, 16);
          v406 = v131 + v405;
          v681 = __ROR4__(v406 ^ v680, 12);
          v737 = (v16 ^ 0x38D01377) + v736 + v681;
          v132 = __ROR4__(v737 ^ v131, 8);
          v407 = v132 + v406;
          v682 = __ROR4__(v407 ^ v681, 7);
          v903 = (v13 ^ 0x38D01377) + v902 + v682;
          v243 = __ROR4__(v903 ^ v242, 16);
          v463 = v243 + v462;
          v683 = __ROR4__(v463 ^ v682, 12);
          v904 = (v11 ^ 0xEC4E6C89) + v903 + v683;
          v244 = __ROR4__(v904 ^ v243, 8);
          v464 = v244 + v463;
          v684 = __ROR4__(v464 ^ v683, 7);
          v848 = (v17 ^ 0x85A308D3) + v847 + v627;
          v188 = __ROR4__(v848 ^ v187, 16);
          v408 = v188 + v407;
          v628 = __ROR4__(v408 ^ v627, 12);
          v849 = (v19 ^ 0x3707344) + v848 + v628;
          v189 = __ROR4__(v849 ^ v188, 8);
          v409 = v189 + v408;
          v629 = __ROR4__(v409 ^ v628, 7);
          v793 = (v7 ^ 0xC0AC29B7) + v792 + v572;
          v133 = __ROR4__(v793 ^ v132, 16);
          v353 = v133 + v352;
          v573 = __ROR4__(v353 ^ v572, 12);
          v794 = (v8 ^ 0xC97C50DD) + v793 + v573;
          v134 = __ROR4__(v794 ^ v133, 8);
          v354 = v134 + v353;
          v574 = __ROR4__(v354 ^ v573, 7);
          v738 = (v9 ^ 0x3F84D5B5) + v737 + v517;
          v78 = __ROR4__(v738 ^ v77, 16);
          v298 = v78 + v297;
          v518 = __ROR4__(v298 ^ v517, 12);
          v739 = (v6 ^ 0x34E90C6C) + v738 + v518;
          v79 = __ROR4__(v739 ^ v78, 8);
          v299 = v79 + v298;
          v519 = __ROR4__(v299 ^ v518, 7);
          v905 = (v18 ^ 0x82EFA98) + v904 + v629;
          v80 = __ROR4__(v905 ^ v79, 16);
          v355 = v80 + v354;
          v630 = __ROR4__(v355 ^ v629, 12);
          v882 = (v14 ^ 0x13198A2E) + v905 + v630;
          v57 = __ROR4__(v882 ^ v80, 8);
          v332 = v57 + v355;
          v607 = __ROR4__(v332 ^ v630, 7);
          v850 = (v15 ^ 0xBE5466CF) + v849 + v574;
          v245 = __ROR4__(v850 ^ v244, 16);
          v300 = v245 + v299;
          v575 = __ROR4__(v300 ^ v574, 12);
          v827 = (v10 ^ 0x299F31D0) + v850 + v575;
          v222 = __ROR4__(v827 ^ v245, 8);
          v277 = v222 + v300;
          v552 = __ROR4__(v277 ^ v575, 7);
          v795 = (v16 ^ 0x243F6A88) + v794 + v519;
          v190 = __ROR4__(v795 ^ v189, 16);
          v465 = v190 + v464;
          v520 = __ROR4__(v465 ^ v519, 12);
          v772 = (v20 ^ 0xA4093822) + v795 + v520;
          v167 = __ROR4__(v772 ^ v190, 8);
          v442 = v167 + v465;
          v497 = __ROR4__(v442 ^ v520, 7);
          v740 = (result ^ 0x452821E6) + v739 + v684;
          v135 = __ROR4__(v740 ^ v134, 16);
          v410 = v135 + v409;
          v685 = __ROR4__(v410 ^ v684, 12);
          v717 = (v12 ^ 0xB5470917) + v740 + v685;
          v112 = __ROR4__(v717 ^ v135, 8);
          v387 = v112 + v410;
          v662 = __ROR4__(v387 ^ v685, 7);
        }
        v916 ^= v442 ^ v24 ^ v882;
        v915 ^= v387 ^ v23 ^ v827;
        v914 ^= v332 ^ v22 ^ v772;
        v913 ^= v277 ^ v21 ^ v717;
        v912 ^= v222 ^ v24 ^ v662;
        v911 ^= v167 ^ v23 ^ v607;
        v910 ^= v112 ^ v22 ^ v552;
        v909 ^= v57 ^ v21 ^ v497;
        v917 = 0;
      }
    }
    v5[17] = v916;
    v5[18] = v915;
    v5[19] = v914;
    v5[20] = v913;
    v5[21] = v912;
    v5[22] = v911;
    v5[23] = v910;
    v5[24] = v909;
    v5[25] = v24;
    v5[26] = v23;
    v5[27] = v22;
    v5[28] = v21;
    v5[29] = v908;
    v5[30] = v907;
    v5[16] = v917;
  }
  else
  {
    result = (unsigned int)memcpy((void *)(v917 + result), a2, a3);
    v5[16] = n + v917;
  }
  return result;
}
// 1F0C40: using guessed type int blake256_rounds;

//----- (0010917C) --------------------------------------------------------
unsigned int __fastcall sub_10917C(_DWORD *a1, char a2, int a3, int a4, unsigned int a5)
{
  unsigned int result; // r0
  char s[56]; // [sp+14h] [bp+14h] BYREF
  unsigned int v9; // [sp+4Ch] [bp+4Ch] BYREF
  unsigned int v10; // [sp+50h] [bp+50h] BYREF
  int v11; // [sp+54h] [bp+54h]
  int v12; // [sp+58h] [bp+58h]
  int v13; // [sp+5Ch] [bp+5Ch]
  int v14; // [sp+60h] [bp+60h]
  unsigned int v15; // [sp+64h] [bp+64h]
  int v16; // [sp+68h] [bp+68h]
  unsigned int i; // [sp+6Ch] [bp+6Ch]

  v16 = a1[16];
  v15 = a3 + 8 * v16;
  v14 = 128 >> a3;
  s[v16] = (128 >> a3) | a2 & -(128 >> a3);
  v13 = v15 + a1[29];
  v12 = a1[30];
  if ( v16 || a3 )
  {
    if ( a1[29] )
    {
      a1[29] = v15 + a1[29] - 512;
    }
    else
    {
      a1[29] = v15 - 512;
      --a1[30];
    }
  }
  else
  {
    a1[29] = -512;
    a1[30] = -1;
  }
  if ( v15 > 0x1BE )
  {
    memset(&s[v16 + 1], 0, 63 - v16);
    sub_105124((unsigned int)a1, &s[v16], 64 - v16);
    a1[29] = -512;
    a1[30] = -1;
    memset(s, 0, sizeof(s));
    if ( a5 == 8 )
      s[55] = 1;
    sub_104F9C(&v9, v12);
    sub_104F9C(&v10, v13);
    result = sub_105124((unsigned int)a1, s, 0x40u);
  }
  else
  {
    memset(&s[v16 + 1], 0, 55 - v16);
    if ( a5 == 8 )
      s[55] |= 1u;
    sub_104F9C(&v9, v12);
    sub_104F9C(&v10, v13);
    result = sub_105124((unsigned int)a1, &s[v16], 64 - v16);
  }
  v11 = a4;
  for ( i = 0; i < a5; ++i )
    result = (unsigned int)sub_104F58((_BYTE *)(v11 + 4 * i), a1[i + 17]);
  return result;
}

//----- (00109350) --------------------------------------------------------
void *__fastcall sub_109350(int a1, const void *a2, const void *a3)
{
  void *result; // r0

  memcpy((void *)(a1 + 136), a2, 0x40u);
  result = memcpy((void *)(a1 + 200), a3, 0x20u);
  *(_DWORD *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 244) = 0;
  *(_QWORD *)(a1 + 232) = *(_QWORD *)(a1 + 240);
  *(_DWORD *)(a1 + 128) = 0;
  return result;
}

//----- (001093A4) --------------------------------------------------------
int __fastcall sub_1093A4(__int64 a1, size_t a2)
{
  unsigned __int64 v2; // r10
  __int64 v3; // r8
  __int64 v5; // [sp+0h] [bp+0h]
  unsigned __int64 v6; // [sp+8h] [bp+8h]
  __int64 v7; // [sp+10h] [bp+10h]
  unsigned __int64 v8; // [sp+18h] [bp+18h]
  __int64 v9; // [sp+20h] [bp+20h]
  unsigned __int64 v10; // [sp+28h] [bp+28h]
  __int64 v11; // [sp+30h] [bp+30h]
  unsigned __int64 v12; // [sp+38h] [bp+38h]
  __int64 v13; // [sp+40h] [bp+40h]
  unsigned __int64 v14; // [sp+48h] [bp+48h]
  __int64 v15; // [sp+50h] [bp+50h]
  unsigned __int64 v16; // [sp+58h] [bp+58h]
  __int64 v17; // [sp+60h] [bp+60h]
  unsigned __int64 v18; // [sp+68h] [bp+68h]
  __int64 v19; // [sp+70h] [bp+70h]
  unsigned __int64 v20; // [sp+78h] [bp+78h]
  __int64 v21; // [sp+80h] [bp+80h]
  unsigned __int64 v22; // [sp+88h] [bp+88h]
  __int64 v23; // [sp+90h] [bp+90h]
  unsigned __int64 v24; // [sp+98h] [bp+98h]
  __int64 v25; // [sp+A0h] [bp+A0h]
  unsigned __int64 v26; // [sp+A8h] [bp+A8h]
  __int64 v27; // [sp+B0h] [bp+B0h]
  unsigned __int64 v28; // [sp+B8h] [bp+B8h]
  __int64 v29; // [sp+C0h] [bp+C0h]
  unsigned __int64 v30; // [sp+C8h] [bp+C8h]
  __int64 v31; // [sp+D0h] [bp+D0h]
  unsigned __int64 v32; // [sp+D8h] [bp+D8h]
  __int64 v33; // [sp+E0h] [bp+E0h]
  unsigned __int64 v34; // [sp+E8h] [bp+E8h]
  size_t v35; // [sp+F4h] [bp+F4h]
  char *v36; // [sp+F8h] [bp+F8h]
  int v37; // [sp+FCh] [bp+FCh]
  _QWORD v38[16]; // [sp+100h] [bp+100h] BYREF
  __int64 v39; // [sp+180h] [bp+180h]
  __int64 v40; // [sp+188h] [bp+188h]
  __int64 v41; // [sp+190h] [bp+190h]
  __int64 v42; // [sp+198h] [bp+198h]
  int *v43; // [sp+1A0h] [bp+1A0h]
  unsigned int i; // [sp+1A4h] [bp+1A4h]
  unsigned __int64 v45; // [sp+1A8h] [bp+1A8h]
  unsigned __int64 v46; // [sp+1B0h] [bp+1B0h]
  unsigned __int64 v47; // [sp+1B8h] [bp+1B8h]
  unsigned __int64 v48; // [sp+1C0h] [bp+1C0h]
  unsigned __int64 v49; // [sp+1C8h] [bp+1C8h]
  unsigned __int64 v50; // [sp+1D0h] [bp+1D0h]
  unsigned __int64 v51; // [sp+1D8h] [bp+1D8h]
  unsigned __int64 v52; // [sp+1E0h] [bp+1E0h]
  __int64 v53; // [sp+1E8h] [bp+1E8h]
  __int64 v54; // [sp+1F0h] [bp+1F0h]
  __int64 v55; // [sp+1F8h] [bp+1F8h]
  __int64 v56; // [sp+200h] [bp+200h]
  __int64 v57; // [sp+208h] [bp+208h]
  __int64 v58; // [sp+210h] [bp+210h]
  __int64 v59; // [sp+218h] [bp+218h]
  __int64 v60; // [sp+220h] [bp+220h]
  size_t n; // [sp+22Ch] [bp+22Ch]
  __int64 v62; // [sp+230h] [bp+230h]
  unsigned __int64 v63; // [sp+238h] [bp+238h]
  __int64 v64; // [sp+240h] [bp+240h]
  __int64 v65; // [sp+248h] [bp+248h]
  __int64 v66; // [sp+250h] [bp+250h]
  __int64 v67; // [sp+258h] [bp+258h]
  __int64 v68; // [sp+260h] [bp+260h]
  __int64 v69; // [sp+268h] [bp+268h]
  __int64 v70; // [sp+270h] [bp+270h]
  __int64 v71; // [sp+278h] [bp+278h]
  int v72; // [sp+284h] [bp+284h]

  v36 = (char *)HIDWORD(a1);
  v37 = a1;
  v35 = a2;
  v43 = (int *)a1;
  v72 = *(_DWORD *)(a1 + 128);
  if ( 128 - v72 <= a2 )
  {
    v71 = *(_QWORD *)(a1 + 136);
    v70 = *(_QWORD *)(a1 + 144);
    v69 = *(_QWORD *)(a1 + 152);
    v68 = *(_QWORD *)(a1 + 160);
    v67 = *(_QWORD *)(a1 + 168);
    v66 = *(_QWORD *)(a1 + 176);
    v65 = *(_QWORD *)(a1 + 184);
    v64 = *(_QWORD *)(a1 + 192);
    v42 = *(_QWORD *)(a1 + 200);
    v41 = *(_QWORD *)(a1 + 208);
    v40 = *(_QWORD *)(a1 + 216);
    v39 = *(_QWORD *)(a1 + 224);
    v63 = *(_QWORD *)(a1 + 232);
    v62 = *(_QWORD *)(a1 + 240);
    while ( v35 )
    {
      n = 128 - v72;
      if ( 128 - v72 > v35 )
        n = v35;
      LODWORD(a1) = memcpy((char *)v43 + v72, v36, n);
      v72 += n;
      v36 += n;
      v35 -= n;
      if ( v72 == 128 )
      {
        v63 += 1024LL;
        if ( v63 <= 0x3FF )
          ++v62;
        v60 = v71;
        v59 = v70;
        v58 = v69;
        v57 = v68;
        v56 = v67;
        v55 = v66;
        v54 = v65;
        v53 = v64;
        v52 = __PAIR64__(loc_1098E4, loc_1098E0) ^ v42;
        v51 = __PAIR64__(loc_1098EC, loc_1098E8) ^ v41;
        v50 = __PAIR64__(loc_1098F4, loc_1098F0) ^ v40;
        v49 = __PAIR64__(*(unsigned int *)((char *)&loc_1098FA + 2), loc_1098F8) ^ v39;
        v48 = __PAIR64__(loc_109904, loc_109900) ^ v63;
        v47 = __PAIR64__(loc_10990C, loc_109908) ^ v63;
        v46 = __PAIR64__(loc_109914, loc_109910) ^ v62;
        v45 = __PAIR64__(loc_10991C, loc_109918) ^ v62;
        v38[0] = sub_1050BC(v43);
        v38[1] = sub_1050BC(v43 + 2);
        v38[2] = sub_1050BC(v43 + 4);
        v38[3] = sub_1050BC(v43 + 6);
        v38[4] = sub_1050BC(v43 + 8);
        v38[5] = sub_1050BC(v43 + 10);
        v38[6] = sub_1050BC(v43 + 12);
        v38[7] = sub_1050BC(v43 + 14);
        v38[8] = sub_1050BC(v43 + 16);
        v38[9] = sub_1050BC(v43 + 18);
        v38[10] = sub_1050BC(v43 + 20);
        v38[11] = sub_1050BC(v43 + 22);
        v38[12] = sub_1050BC(v43 + 24);
        v38[13] = sub_1050BC(v43 + 26);
        v38[14] = sub_1050BC(v43 + 28);
        a1 = sub_1050BC(v43 + 30);
        v38[15] = a1;
        for ( i = 0; i <= 0xF; ++i )
        {
          v60 += (qword_1D45A0[dword_1D41A0[16 * i + 1]] ^ v38[dword_1D41A0[16 * i]]) + v56;
          LODWORD(v34) = HIDWORD(v60) ^ HIDWORD(v48);
          HIDWORD(v34) = v60 ^ v48;
          v48 = v34;
          v52 += v34;
          LODWORD(v33) = (__int64)(v52 ^ v56) >> 25;
          HIDWORD(v33) = ((unsigned int)(HIDWORD(v52) ^ HIDWORD(v56)) >> 25)
                       | (((unsigned int)v52 ^ (unsigned int)v56) << 7);
          v56 = v33;
          v60 += (qword_1D45A0[dword_1D41A0[16 * i]] ^ v38[dword_1D41A0[16 * i + 1]]) + v33;
          LODWORD(v32) = (__int64)(v60 ^ v34) >> 16;
          HIDWORD(v32) = ((unsigned int)(HIDWORD(v60) ^ HIDWORD(v34)) >> 16)
                       | (((unsigned int)v60 ^ (unsigned int)v34) << 16);
          v48 = v32;
          v52 += v32;
          LODWORD(v31) = (__int64)(v52 ^ v33) >> 11;
          HIDWORD(v31) = ((unsigned int)(HIDWORD(v52) ^ HIDWORD(v33)) >> 11)
                       | (((unsigned int)v52 ^ (unsigned int)v33) << 21);
          v56 = v31;
          v59 += (qword_1D45A0[dword_1D41A0[16 * i + 3]] ^ v38[dword_1D41A0[16 * i + 2]]) + v55;
          LODWORD(v30) = HIDWORD(v59) ^ HIDWORD(v47);
          HIDWORD(v30) = v59 ^ v47;
          v47 = v30;
          v51 += v30;
          LODWORD(v29) = (__int64)(v51 ^ v55) >> 25;
          HIDWORD(v29) = ((unsigned int)(HIDWORD(v51) ^ HIDWORD(v55)) >> 25)
                       | (((unsigned int)v51 ^ (unsigned int)v55) << 7);
          v55 = v29;
          v59 += (qword_1D45A0[dword_1D41A0[16 * i + 2]] ^ v38[dword_1D41A0[16 * i + 3]]) + v29;
          LODWORD(v28) = (__int64)(v59 ^ v30) >> 16;
          HIDWORD(v28) = ((unsigned int)(HIDWORD(v59) ^ HIDWORD(v30)) >> 16)
                       | (((unsigned int)v59 ^ (unsigned int)v30) << 16);
          v47 = v28;
          v51 += v28;
          LODWORD(v27) = (__int64)(v51 ^ v29) >> 11;
          HIDWORD(v27) = ((unsigned int)(HIDWORD(v51) ^ HIDWORD(v29)) >> 11)
                       | (((unsigned int)v51 ^ (unsigned int)v29) << 21);
          v55 = v27;
          v58 += (qword_1D45A0[dword_1D41A0[16 * i + 5]] ^ v38[dword_1D41A0[16 * i + 4]]) + v54;
          LODWORD(v26) = HIDWORD(v58) ^ HIDWORD(v46);
          HIDWORD(v26) = v58 ^ v46;
          v46 = v26;
          v50 += v26;
          LODWORD(v25) = (__int64)(v50 ^ v54) >> 25;
          HIDWORD(v25) = ((unsigned int)(HIDWORD(v50) ^ HIDWORD(v54)) >> 25)
                       | (((unsigned int)v50 ^ (unsigned int)v54) << 7);
          v54 = v25;
          v58 += (qword_1D45A0[dword_1D41A0[16 * i + 4]] ^ v38[dword_1D41A0[16 * i + 5]]) + v25;
          LODWORD(v24) = (__int64)(v58 ^ v26) >> 16;
          HIDWORD(v24) = ((unsigned int)(HIDWORD(v58) ^ HIDWORD(v26)) >> 16)
                       | (((unsigned int)v58 ^ (unsigned int)v26) << 16);
          v46 = v24;
          v50 += v24;
          LODWORD(v23) = (__int64)(v50 ^ v25) >> 11;
          HIDWORD(v23) = ((unsigned int)(HIDWORD(v50) ^ HIDWORD(v25)) >> 11)
                       | (((unsigned int)v50 ^ (unsigned int)v25) << 21);
          v54 = v23;
          v57 += (qword_1D45A0[dword_1D41A0[16 * i + 7]] ^ v38[dword_1D41A0[16 * i + 6]]) + v53;
          LODWORD(v22) = HIDWORD(v57) ^ HIDWORD(v45);
          HIDWORD(v22) = v57 ^ v45;
          v45 = v22;
          v49 += v22;
          LODWORD(v21) = (__int64)(v49 ^ v53) >> 25;
          HIDWORD(v21) = ((unsigned int)(HIDWORD(v49) ^ HIDWORD(v53)) >> 25)
                       | (((unsigned int)v49 ^ (unsigned int)v53) << 7);
          v53 = v21;
          v57 += (qword_1D45A0[dword_1D41A0[16 * i + 6]] ^ v38[dword_1D41A0[16 * i + 7]]) + v21;
          LODWORD(v20) = (__int64)(v57 ^ v22) >> 16;
          HIDWORD(v20) = ((unsigned int)(HIDWORD(v57) ^ HIDWORD(v22)) >> 16)
                       | (((unsigned int)v57 ^ (unsigned int)v22) << 16);
          v45 = v20;
          v49 += v20;
          LODWORD(v19) = (__int64)(v49 ^ v21) >> 11;
          HIDWORD(v19) = ((unsigned int)(HIDWORD(v49) ^ HIDWORD(v21)) >> 11)
                       | (((unsigned int)v49 ^ (unsigned int)v21) << 21);
          v53 = v19;
          v60 += (qword_1D45A0[dword_1D41A0[16 * i + 9]] ^ v38[dword_1D41A0[16 * i + 8]]) + v27;
          LODWORD(v18) = HIDWORD(v60) ^ HIDWORD(v20);
          HIDWORD(v18) = v60 ^ v20;
          v45 = v18;
          v50 += v18;
          LODWORD(v17) = (__int64)(v50 ^ v27) >> 25;
          HIDWORD(v17) = ((unsigned int)(HIDWORD(v50) ^ HIDWORD(v27)) >> 25)
                       | (((unsigned int)v50 ^ (unsigned int)v27) << 7);
          v55 = v17;
          v60 += (qword_1D45A0[dword_1D41A0[16 * i + 8]] ^ v38[dword_1D41A0[16 * i + 9]]) + v17;
          LODWORD(v16) = (__int64)(v60 ^ v18) >> 16;
          HIDWORD(v16) = ((unsigned int)(HIDWORD(v60) ^ HIDWORD(v18)) >> 16)
                       | (((unsigned int)v60 ^ (unsigned int)v18) << 16);
          v45 = v16;
          v50 += v16;
          LODWORD(v15) = (__int64)(v50 ^ v17) >> 11;
          HIDWORD(v15) = ((unsigned int)(HIDWORD(v50) ^ HIDWORD(v17)) >> 11)
                       | (((unsigned int)v50 ^ (unsigned int)v17) << 21);
          v55 = v15;
          v59 += (qword_1D45A0[dword_1D41A0[16 * i + 11]] ^ v38[dword_1D41A0[16 * i + 10]]) + v23;
          LODWORD(v14) = HIDWORD(v59) ^ HIDWORD(v32);
          HIDWORD(v14) = v59 ^ v32;
          v48 = v14;
          v49 += v14;
          LODWORD(v13) = (__int64)(v49 ^ v23) >> 25;
          HIDWORD(v13) = ((unsigned int)(HIDWORD(v49) ^ HIDWORD(v23)) >> 25)
                       | (((unsigned int)v49 ^ (unsigned int)v23) << 7);
          v54 = v13;
          v59 += (qword_1D45A0[dword_1D41A0[16 * i + 10]] ^ v38[dword_1D41A0[16 * i + 11]]) + v13;
          LODWORD(v12) = (__int64)(v59 ^ v14) >> 16;
          HIDWORD(v12) = ((unsigned int)(HIDWORD(v59) ^ HIDWORD(v14)) >> 16)
                       | (((unsigned int)v59 ^ (unsigned int)v14) << 16);
          v48 = v12;
          v49 += v12;
          LODWORD(v11) = (__int64)(v49 ^ v13) >> 11;
          HIDWORD(v11) = ((unsigned int)(HIDWORD(v49) ^ HIDWORD(v13)) >> 11)
                       | (((unsigned int)v49 ^ (unsigned int)v13) << 21);
          v54 = v11;
          v58 += (qword_1D45A0[dword_1D41A0[16 * i + 13]] ^ v38[dword_1D41A0[16 * i + 12]]) + v19;
          LODWORD(v10) = HIDWORD(v58) ^ HIDWORD(v28);
          HIDWORD(v10) = v58 ^ v28;
          v47 = v10;
          v52 += v10;
          LODWORD(v9) = (__int64)(v52 ^ v19) >> 25;
          HIDWORD(v9) = ((unsigned int)(HIDWORD(v52) ^ HIDWORD(v19)) >> 25)
                      | (((unsigned int)v52 ^ (unsigned int)v19) << 7);
          v53 = v9;
          v58 += (qword_1D45A0[dword_1D41A0[16 * i + 12]] ^ v38[dword_1D41A0[16 * i + 13]]) + v9;
          LODWORD(v8) = (__int64)(v58 ^ v10) >> 16;
          HIDWORD(v8) = ((unsigned int)(HIDWORD(v58) ^ HIDWORD(v10)) >> 16)
                      | (((unsigned int)v58 ^ (unsigned int)v10) << 16);
          v47 = v8;
          v52 += v8;
          LODWORD(v7) = (__int64)(v52 ^ v9) >> 11;
          HIDWORD(v7) = ((unsigned int)(HIDWORD(v52) ^ HIDWORD(v9)) >> 11)
                      | (((unsigned int)v52 ^ (unsigned int)v9) << 21);
          v53 = v7;
          v57 += (qword_1D45A0[dword_1D41A0[16 * i + 15]] ^ v38[dword_1D41A0[16 * i + 14]]) + v31;
          LODWORD(v6) = HIDWORD(v57) ^ HIDWORD(v24);
          HIDWORD(v6) = v57 ^ v24;
          v46 = v6;
          v51 += v6;
          LODWORD(v5) = (__int64)(v51 ^ v31) >> 25;
          HIDWORD(v5) = ((unsigned int)(HIDWORD(v51) ^ HIDWORD(v31)) >> 25)
                      | (((unsigned int)v51 ^ (unsigned int)v31) << 7);
          v56 = v5;
          a1 = v38[dword_1D41A0[16 * i + 15]];
          v57 += (qword_1D45A0[dword_1D41A0[16 * i + 14]] ^ a1) + v5;
          LODWORD(v2) = (__int64)(v57 ^ v6) >> 16;
          HIDWORD(v2) = (((unsigned int)v57 ^ (unsigned int)v6) << 16)
                      | ((unsigned int)(HIDWORD(v57) ^ HIDWORD(v6)) >> 16);
          v46 = v2;
          v51 += v2;
          LODWORD(v3) = (__int64)(v51 ^ v5) >> 11;
          HIDWORD(v3) = (((unsigned int)v51 ^ (unsigned int)v5) << 21)
                      | ((unsigned int)(HIDWORD(v51) ^ HIDWORD(v5)) >> 11);
          v56 = v3;
        }
        v71 ^= v42 ^ v60 ^ v52;
        v70 ^= v41 ^ v59 ^ v51;
        v69 ^= v40 ^ v58 ^ v50;
        v68 ^= v39 ^ v57 ^ v49;
        v67 ^= v42 ^ v56 ^ v48;
        v66 ^= v41 ^ v55 ^ v47;
        v65 ^= v40 ^ v54 ^ v46;
        v64 ^= v39 ^ v53 ^ v45;
        v72 = 0;
      }
    }
    *(_QWORD *)(v37 + 136) = v71;
    *(_QWORD *)(v37 + 144) = v70;
    *(_QWORD *)(v37 + 152) = v69;
    *(_QWORD *)(v37 + 160) = v68;
    *(_QWORD *)(v37 + 168) = v67;
    *(_QWORD *)(v37 + 176) = v66;
    *(_QWORD *)(v37 + 184) = v65;
    *(_QWORD *)(v37 + 192) = v64;
    *(_QWORD *)(v37 + 200) = v42;
    *(_QWORD *)(v37 + 208) = v41;
    *(_QWORD *)(v37 + 216) = v40;
    *(_QWORD *)(v37 + 224) = v39;
    *(_QWORD *)(v37 + 232) = v63;
    *(_QWORD *)(v37 + 240) = v62;
    *(_DWORD *)(v37 + 128) = v72;
  }
  else
  {
    LODWORD(a1) = memcpy((char *)v43 + v72, (const void *)HIDWORD(a1), a2);
    *(_DWORD *)(v37 + 128) = v35 + v72;
  }
  return a1;
}
// 1D41A0: using guessed type _DWORD dword_1D41A0[256];
// 1D45A0: using guessed type _QWORD qword_1D45A0[16];

//----- (0010AB88) --------------------------------------------------------
_BYTE *__fastcall sub_10AB88(unsigned int a1, char a2, int a3, int a4, unsigned int a5)
{
  unsigned int v5; // r3
  __int64 v6; // kr00_8
  __int64 v7; // r0
  _BYTE *result; // r0
  __int64 v9; // r0
  _BYTE s[112]; // [sp+10h] [bp+10h] BYREF
  __int64 v13; // [sp+80h] [bp+80h] BYREF
  __int64 v14; // [sp+88h] [bp+88h] BYREF
  int v15; // [sp+94h] [bp+94h]
  __int64 v16; // [sp+98h] [bp+98h]
  __int64 v17; // [sp+A0h] [bp+A0h]
  int v18; // [sp+A8h] [bp+A8h]
  unsigned int v19; // [sp+ACh] [bp+ACh]
  int v20; // [sp+B0h] [bp+B0h]
  unsigned int i; // [sp+B4h] [bp+B4h]

  v20 = *(_DWORD *)(a1 + 128);
  v19 = a3 + 8 * v20;
  v18 = 128 >> a3;
  s[v20] = (128 >> a3) | a2 & -(128 >> a3);
  v17 = v19 + *(_QWORD *)(a1 + 232);
  v16 = *(_QWORD *)(a1 + 240);
  if ( v20 || a3 )
  {
    if ( *(_QWORD *)(a1 + 232) )
    {
      *(_QWORD *)(a1 + 232) -= 1024 - v19;
    }
    else
    {
      v5 = v19;
      *(_DWORD *)(a1 + 232) = v19 - 1024;
      *(_DWORD *)(a1 + 236) = (v5 >= 0x400) - 1;
      v6 = *(_QWORD *)(a1 + 240);
      *(_DWORD *)(a1 + 240) = v6 - 1;
      *(_DWORD *)(a1 + 244) = ((_DWORD)v6 != 0) + HIDWORD(v6) - 1;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 232) = -1024;
    *(_DWORD *)(a1 + 236) = -1;
    *(_DWORD *)(a1 + 240) = -1;
    *(_DWORD *)(a1 + 244) = -1;
  }
  if ( v19 > 0x37E )
  {
    memset(&s[v20 + 1], 0, 127 - v20);
    HIDWORD(v9) = &s[v20];
    LODWORD(v9) = a1;
    sub_1093A4(v9, 128 - v20);
    *(_DWORD *)(a1 + 232) = -1024;
    *(_DWORD *)(a1 + 236) = -1;
    *(_DWORD *)(a1 + 240) = -1;
    *(_DWORD *)(a1 + 244) = -1;
    memset(s, 0, sizeof(s));
    if ( a5 == 8 )
      s[111] = 1;
    sub_105094(&v13, (int)&v13, v16, SHIDWORD(v16));
    sub_105094(&v14, (int)&v14, v17, SHIDWORD(v17));
    result = (_BYTE *)sub_1093A4(__SPAIR64__(s, a1), 0x80u);
  }
  else
  {
    memset(&s[v20 + 1], 0, 111 - v20);
    if ( a5 == 8 )
      s[111] |= 1u;
    sub_105094(&v13, (int)&v13, v16, SHIDWORD(v16));
    sub_105094(&v14, (int)&v14, v17, SHIDWORD(v17));
    HIDWORD(v7) = &s[v20];
    LODWORD(v7) = a1;
    result = (_BYTE *)sub_1093A4(v7, 128 - v20);
  }
  v15 = a4;
  for ( i = 0; i < a5; ++i )
    result = sub_104FD8(
               (_BYTE *)(v15 + 8 * i),
               v15 + 8 * i,
               *(_DWORD *)(8 * (i + 17) + a1),
               *(_DWORD *)(8 * (i + 17) + a1 + 4));
  return result;
}

//----- (0010ADF8) --------------------------------------------------------
void *__fastcall sph_blake224_init(_DWORD *a1)
{
  return sub_1050E0(a1, &unk_1D40E0, &unk_1D4620);
}

//----- (0010AE20) --------------------------------------------------------
unsigned int __fastcall sph_blake224(unsigned int a1, char *a2, size_t a3)
{
  return sub_105124(a1, a2, a3);
}

//----- (0010AE40) --------------------------------------------------------
void *__fastcall sph_blake224_close(_DWORD *a1, int a2)
{
  return sph_blake224_addbits_and_close(a1, 0, 0, a2);
}

//----- (0010AE60) --------------------------------------------------------
void *__fastcall sph_blake224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_10917C(a1, a2, a3, a4, 7u);
  return sph_blake224_init(a1);
}

//----- (0010AE8C) --------------------------------------------------------
void *__fastcall sph_blake256_init(_DWORD *a1)
{
  return sub_1050E0(a1, &unk_1D4100, &unk_1D4620);
}

//----- (0010AEB4) --------------------------------------------------------
unsigned int __fastcall sph_blake256(unsigned int a1, char *a2, size_t a3)
{
  return sub_105124(a1, a2, a3);
}

//----- (0010AED4) --------------------------------------------------------
void *__fastcall sph_blake256_close(_DWORD *a1, int a2)
{
  return sph_blake256_addbits_and_close(a1, 0, 0, a2);
}

//----- (0010AEF4) --------------------------------------------------------
void *__fastcall sph_blake256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_10917C(a1, a2, a3, a4, 8u);
  return sph_blake256_init(a1);
}

//----- (0010AF20) --------------------------------------------------------
int __fastcall set_total_hash_rate(int result)
{
  blake256_rounds = result;
  return result;
}
// 10AF20: invalid function type 'void __cdecl set_total_hash_rate(STATUS_CODE err)' has been ignored
// 1F0C40: using guessed type int blake256_rounds;

//----- (0010AF40) --------------------------------------------------------
void *__fastcall sph_blake384_init(int a1)
{
  return sub_109350(a1, &unk_1D4120, &unk_1D4630);
}

//----- (0010AF68) --------------------------------------------------------
int __fastcall sph_blake384(__int64 a1, size_t a2)
{
  return sub_1093A4(a1, a2);
}

//----- (0010AF88) --------------------------------------------------------
void *__fastcall sph_blake384_close(unsigned int a1, int a2)
{
  return sph_blake384_addbits_and_close(a1, 0, 0, a2);
}

//----- (0010AFA8) --------------------------------------------------------
void *__fastcall sph_blake384_addbits_and_close(unsigned int a1, char a2, int a3, int a4)
{
  sub_10AB88(a1, a2, a3, a4, 6u);
  return sph_blake384_init(a1);
}

//----- (0010AFD4) --------------------------------------------------------
void *__fastcall sph_blake512_init(int a1)
{
  return sub_109350(a1, &unk_1D4160, &unk_1D4630);
}

//----- (0010AFFC) --------------------------------------------------------
int __fastcall sph_blake512(__int64 a1, size_t a2)
{
  return sub_1093A4(a1, a2);
}

//----- (0010B01C) --------------------------------------------------------
void *__fastcall sph_blake512_close(unsigned int a1, int a2)
{
  return sph_blake512_addbits_and_close(a1, 0, 0, a2);
}

//----- (0010B03C) --------------------------------------------------------
void *__fastcall sph_blake512_addbits_and_close(unsigned int a1, char a2, int a3, int a4)
{
  sub_10AB88(a1, a2, a3, a4, 8u);
  return sph_blake512_init(a1);
}

//----- (0010B068) --------------------------------------------------------
void *__fastcall decred_hash(int a1, char *a2)
{
  _DWORD v5[31]; // [sp+Ch] [bp+Ch] BYREF

  set_total_hash_rate(14);
  sph_blake256_init(v5);
  sph_blake256((unsigned int)v5, a2, 0xB4u);
  return sph_blake256_close(v5, a1);
}

//----- (0010B0A8) --------------------------------------------------------
__int64 __fastcall sub_10B0A8(int a1, int a2)
{
  unsigned int v3; // [sp+4h] [bp+4h]
  unsigned int v4; // [sp+8h] [bp+8h]
  __int64 v5; // [sp+8h] [bp+8h]
  unsigned int v6; // [sp+Ch] [bp+Ch]

  v4 = ((a2 & 0xFFFF0000) >> 16) | ((a1 & 0xFFFF0000) << 16) | ((unsigned __int16)a2 << 16);
  v6 = ((a1 & 0xFFFF0000) >> 16) | ((unsigned __int16)a1 << 16);
  v3 = ((v6 & 0xFF00FF) << 8) | ((v4 & 0xFF00FF) >> 24);
  LODWORD(v5) = ((v4 & 0xFF00FF) << 8) | ((v4 & 0xFF00FF00) >> 8) | ((v6 & 0xFF00FF00) << 24);
  HIDWORD(v5) = v3 | ((v6 & 0xFF00FF00) >> 8);
  return v5;
}

//----- (0010B180) --------------------------------------------------------
_BYTE *__fastcall sub_10B180(_BYTE *result, int a2, int a3, int a4)
{
  *result = HIBYTE(a4);
  result[1] = BYTE2(a4);
  result[2] = BYTE1(a4);
  result[3] = a4;
  result[4] = HIBYTE(a3);
  result[5] = BYTE2(a3);
  result[6] = BYTE1(a3);
  result[7] = a3;
  return result;
}

//----- (0010B23C) --------------------------------------------------------
__int64 __fastcall sub_10B23C(__int64 *a1, int a2, int a3, int a4)
{
  __int64 result; // r0

  result = sub_10B0A8(a3, a4);
  *a1 = result;
  return result;
}

//----- (0010B264) --------------------------------------------------------
__int64 __fastcall sub_10B264(int *a1)
{
  return sub_10B0A8(*a1, a1[1]);
}

//----- (0010B288) --------------------------------------------------------
int __fastcall sub_10B288(int result, int a2, unsigned int a3, int a4)
{
  *(_BYTE *)result = a3;
  *(_WORD *)(result + 1) = a3 >> 8;
  *(_BYTE *)(result + 3) = HIBYTE(a3);
  *(_DWORD *)(result + 4) = a4;
  return result;
}

//----- (0010B344) --------------------------------------------------------
_QWORD *__fastcall sub_10B344(_QWORD *result, __int64 a2)
{
  *result = a2;
  return result;
}

//----- (0010B364) --------------------------------------------------------
__int64 __fastcall sub_10B364(int a1)
{
  return *(_QWORD *)a1;
}

//----- (0010B380) --------------------------------------------------------
_QWORD *__fastcall sub_10B380(int a1, int a2, int a3)
{
  __int64 v3; // r0
  __int64 v4; // kr00_8
  __int64 v5; // kr08_8
  __int64 v6; // kr10_8
  __int64 v7; // kr18_8
  unsigned __int64 v8; // r10
  __int64 v9; // r0
  __int64 v10; // kr20_8
  __int64 v11; // kr28_8
  __int64 v12; // kr30_8
  __int64 v13; // kr38_8
  __int64 v14; // r8
  __int64 v15; // r0
  __int64 v16; // kr40_8
  __int64 v17; // kr48_8
  __int64 v18; // kr50_8
  __int64 v19; // kr58_8
  __int64 v20; // r0
  __int64 v21; // kr60_8
  __int64 v22; // kr68_8
  __int64 v23; // kr70_8
  __int64 v24; // kr78_8
  __int64 v25; // r0
  __int64 v26; // kr80_8
  __int64 v27; // kr88_8
  __int64 v28; // kr90_8
  __int64 v29; // kr98_8
  __int64 v30; // r0
  __int64 v31; // krA0_8
  __int64 v32; // krA8_8
  __int64 v33; // krB0_8
  __int64 v34; // krB8_8
  unsigned __int64 v35; // krC0_8
  __int64 v36; // r0
  __int64 v37; // krD0_8
  __int64 v38; // krD8_8
  __int64 v39; // krE0_8
  __int64 v40; // krE8_8
  unsigned __int64 v41; // r8
  __int64 v42; // r0
  __int64 v43; // krF0_8
  __int64 v44; // krF8_8
  __int64 v45; // kr100_8
  __int64 v46; // kr108_8
  unsigned __int64 v47; // r8
  __int64 v48; // r0
  __int64 v49; // kr110_8
  __int64 v50; // kr118_8
  __int64 v51; // kr120_8
  __int64 v52; // kr128_8
  __int64 v53; // r0
  __int64 v54; // kr130_8
  __int64 v55; // kr138_8
  __int64 v56; // kr140_8
  __int64 v57; // kr148_8
  __int64 v58; // r0
  __int64 v59; // kr150_8
  __int64 v60; // kr158_8
  __int64 v61; // kr160_8
  __int64 v62; // kr168_8
  __int64 v63; // r0
  __int64 v64; // kr170_8
  __int64 v65; // kr178_8
  __int64 v66; // kr180_8
  __int64 v67; // kr188_8
  unsigned __int64 v68; // kr190_8
  __int64 v69; // r0
  unsigned int v70; // r5
  int v71; // r6
  unsigned __int64 v72; // kr1A0_8
  unsigned __int64 v73; // kr1A8_8
  unsigned __int64 v74; // kr1B0_8
  __int64 v75; // r0
  unsigned int v76; // r5
  int v77; // r6
  unsigned __int64 v78; // kr1B8_8
  unsigned __int64 v79; // kr1C0_8
  unsigned __int64 v80; // kr1C8_8
  __int64 v81; // r8
  __int64 v82; // r0
  unsigned int v83; // r5
  int v84; // r6
  unsigned __int64 v85; // kr1D0_8
  unsigned __int64 v86; // kr1D8_8
  unsigned __int64 v87; // kr1E0_8
  __int64 v88; // r0
  unsigned int v89; // r5
  int v90; // r6
  unsigned __int64 v91; // kr1E8_8
  unsigned __int64 v92; // kr1F0_8
  unsigned __int64 v93; // kr1F8_8
  __int64 v94; // r0
  unsigned int v95; // r5
  int v96; // r6
  unsigned __int64 v97; // kr200_8
  unsigned __int64 v98; // kr208_8
  unsigned __int64 v99; // kr210_8
  __int64 v100; // r0
  unsigned int v101; // r5
  int v102; // r6
  unsigned __int64 v103; // kr218_8
  unsigned __int64 v104; // kr220_8
  unsigned __int64 v105; // kr228_8
  unsigned __int64 v106; // kr230_8
  __int64 v107; // r0
  unsigned int v108; // r5
  int v109; // r6
  unsigned __int64 v110; // kr240_8
  unsigned __int64 v111; // kr248_8
  unsigned __int64 v112; // kr250_8
  __int64 v113; // r0
  unsigned int v114; // r5
  int v115; // r6
  unsigned __int64 v116; // kr258_8
  unsigned __int64 v117; // kr260_8
  unsigned __int64 v118; // kr268_8
  __int64 v119; // r0
  unsigned int v120; // r5
  int v121; // r6
  unsigned __int64 v122; // kr270_8
  unsigned __int64 v123; // kr278_8
  unsigned __int64 v124; // kr280_8
  __int64 v125; // r0
  unsigned int v126; // r5
  int v127; // r6
  unsigned __int64 v128; // kr288_8
  unsigned __int64 v129; // kr290_8
  unsigned __int64 v130; // kr298_8
  __int64 v131; // r0
  unsigned int v132; // r5
  int v133; // r6
  unsigned __int64 v134; // kr2A0_8
  unsigned __int64 v135; // kr2A8_8
  unsigned __int64 v136; // kr2B0_8
  __int64 v137; // r0
  unsigned int v138; // r5
  int v139; // r6
  unsigned __int64 v140; // kr2B8_8
  unsigned __int64 v141; // kr2C0_8
  unsigned __int64 v142; // kr2C8_8
  unsigned __int64 v143; // kr2D0_8
  __int64 v144; // r0
  __int64 v145; // kr2E0_8
  __int64 v146; // kr2E8_8
  __int64 v147; // kr2F0_8
  __int64 v148; // kr2F8_8
  unsigned __int64 v149; // r8
  __int64 v150; // r0
  __int64 v151; // kr300_8
  __int64 v152; // kr308_8
  __int64 v153; // kr310_8
  __int64 v154; // kr318_8
  __int64 v155; // r0
  __int64 v156; // kr328_8
  __int64 v157; // kr330_8
  __int64 v158; // kr338_8
  __int64 v159; // kr340_8
  unsigned __int64 v160; // r8
  __int64 v161; // r0
  __int64 v162; // kr348_8
  __int64 v163; // kr350_8
  __int64 v164; // kr358_8
  __int64 v165; // kr360_8
  unsigned __int64 v166; // r8
  __int64 v167; // r0
  __int64 v168; // kr368_8
  __int64 v169; // kr370_8
  __int64 v170; // kr378_8
  __int64 v171; // kr380_8
  __int64 v172; // r0
  __int64 v173; // kr388_8
  __int64 v174; // kr390_8
  __int64 v175; // kr398_8
  __int64 v176; // kr3A0_8
  __int64 v177; // r0
  __int64 v178; // kr3A8_8
  __int64 v179; // kr3B0_8
  __int64 v180; // kr3B8_8
  __int64 v181; // kr3C0_8
  __int64 v182; // r0
  __int64 v183; // kr3C8_8
  __int64 v184; // kr3D0_8
  __int64 v185; // kr3D8_8
  __int64 v186; // kr3E0_8
  unsigned __int64 v187; // kr3E8_8
  __int64 v188; // r0
  __int64 v189; // kr3F8_8
  __int64 v190; // kr400_8
  __int64 v191; // kr408_8
  __int64 v192; // kr410_8
  unsigned __int64 v193; // r8
  __int64 v194; // r0
  __int64 v195; // kr418_8
  __int64 v196; // kr420_8
  __int64 v197; // kr428_8
  __int64 v198; // kr430_8
  unsigned __int64 v199; // r8
  __int64 v200; // r0
  __int64 v201; // kr438_8
  __int64 v202; // kr440_8
  __int64 v203; // kr448_8
  __int64 v204; // kr450_8
  __int64 v205; // r0
  __int64 v206; // kr458_8
  __int64 v207; // kr460_8
  __int64 v208; // kr468_8
  __int64 v209; // kr470_8
  __int64 v210; // r0
  __int64 v211; // kr478_8
  __int64 v212; // kr480_8
  __int64 v213; // kr488_8
  __int64 v214; // kr490_8
  __int64 v215; // r0
  __int64 v216; // kr498_8
  __int64 v217; // kr4A0_8
  __int64 v218; // kr4A8_8
  __int64 v219; // kr4B0_8
  unsigned __int64 v220; // kr4B8_8
  __int64 v221; // r0
  __int64 v222; // kr4C8_8
  __int64 v223; // kr4D0_8
  __int64 v224; // kr4D8_8
  __int64 v225; // kr4E0_8
  __int64 v226; // r0
  __int64 v227; // kr4E8_8
  __int64 v228; // kr4F0_8
  __int64 v229; // kr4F8_8
  __int64 v230; // kr500_8
  __int64 v231; // r8
  __int64 v232; // r0
  __int64 v233; // kr508_8
  __int64 v234; // kr510_8
  __int64 v235; // kr518_8
  __int64 v236; // kr520_8
  __int64 v237; // r0
  __int64 v238; // kr528_8
  __int64 v239; // kr530_8
  __int64 v240; // kr538_8
  __int64 v241; // kr540_8
  __int64 v242; // r0
  __int64 v243; // kr548_8
  __int64 v244; // kr550_8
  __int64 v245; // kr558_8
  __int64 v246; // kr560_8
  __int64 v247; // r0
  __int64 v248; // kr568_8
  __int64 v249; // kr570_8
  __int64 v250; // kr578_8
  __int64 v251; // kr580_8
  unsigned __int64 v252; // kr588_8
  __int64 v253; // r0
  __int64 v254; // kr598_8
  __int64 v255; // kr5A0_8
  __int64 v256; // kr5A8_8
  __int64 v257; // kr5B0_8
  __int64 v258; // r0
  __int64 v259; // kr5B8_8
  __int64 v260; // kr5C0_8
  __int64 v261; // kr5C8_8
  __int64 v262; // kr5D0_8
  __int64 v263; // r0
  __int64 v264; // kr5D8_8
  __int64 v265; // kr5E0_8
  __int64 v266; // kr5E8_8
  __int64 v267; // kr5F0_8
  __int64 v268; // r0
  __int64 v269; // kr5F8_8
  __int64 v270; // kr600_8
  __int64 v271; // kr608_8
  __int64 v272; // kr610_8
  __int64 v273; // r0
  __int64 v274; // kr618_8
  __int64 v275; // kr620_8
  __int64 v276; // kr628_8
  __int64 v277; // kr630_8
  __int64 v278; // r0
  __int64 v279; // kr638_8
  __int64 v280; // kr640_8
  __int64 v281; // kr648_8
  __int64 v282; // kr650_8
  unsigned __int64 v283; // kr658_8
  __int64 v284; // r0
  unsigned int v285; // r5
  int v286; // r6
  unsigned __int64 v287; // kr668_8
  unsigned __int64 v288; // kr670_8
  unsigned __int64 v289; // kr678_8
  unsigned __int64 v290; // r8
  __int64 v291; // r0
  unsigned int v292; // r5
  int v293; // r6
  unsigned __int64 v294; // kr680_8
  unsigned __int64 v295; // kr688_8
  unsigned __int64 v296; // kr690_8
  __int64 v297; // r0
  __int64 v298; // kr6A0_8
  __int64 v299; // kr6A8_8
  __int64 v300; // kr6B0_8
  __int64 v301; // kr6B8_8
  unsigned __int64 v302; // r8
  __int64 v303; // r0
  __int64 v304; // kr6C0_8
  __int64 v305; // kr6C8_8
  __int64 v306; // kr6D0_8
  __int64 v307; // kr6D8_8
  unsigned __int64 v308; // r8
  __int64 v309; // r0
  __int64 v310; // kr6E0_8
  __int64 v311; // kr6E8_8
  __int64 v312; // kr6F0_8
  __int64 v313; // kr6F8_8
  __int64 v314; // r0
  __int64 v315; // kr700_8
  __int64 v316; // kr708_8
  __int64 v317; // kr710_8
  __int64 v318; // kr718_8
  __int64 v319; // r0
  __int64 v320; // kr720_8
  __int64 v321; // kr728_8
  __int64 v322; // kr730_8
  __int64 v323; // kr738_8
  __int64 v324; // r0
  __int64 v325; // kr740_8
  __int64 v326; // kr748_8
  __int64 v327; // kr750_8
  __int64 v328; // kr758_8
  unsigned __int64 v329; // kr760_8
  __int64 v330; // r0
  __int64 v331; // kr770_8
  __int64 v332; // kr778_8
  __int64 v333; // kr780_8
  __int64 v334; // kr788_8
  unsigned __int64 v335; // r8
  __int64 v336; // r0
  __int64 v337; // kr790_8
  __int64 v338; // kr798_8
  __int64 v339; // kr7A0_8
  __int64 v340; // kr7A8_8
  unsigned __int64 v341; // r8
  __int64 v342; // r0
  __int64 v343; // kr7B0_8
  __int64 v344; // kr7B8_8
  __int64 v345; // kr7C0_8
  __int64 v346; // kr7C8_8
  __int64 v347; // r0
  __int64 v348; // kr7D0_8
  __int64 v349; // kr7D8_8
  __int64 v350; // kr7E0_8
  __int64 v351; // kr7E8_8
  __int64 v352; // r0
  __int64 v353; // kr7F0_8
  __int64 v354; // kr7F8_8
  __int64 v355; // kr800_8
  __int64 v356; // kr808_8
  __int64 v357; // r0
  __int64 v358; // kr810_8
  __int64 v359; // kr818_8
  __int64 v360; // kr820_8
  __int64 v361; // kr828_8
  unsigned __int64 v362; // kr830_8
  __int64 v363; // r0
  __int64 v364; // kr840_8
  __int64 v365; // kr848_8
  __int64 v366; // kr850_8
  __int64 v367; // kr858_8
  __int64 v368; // r0
  __int64 v369; // kr860_8
  __int64 v370; // kr868_8
  __int64 v371; // kr870_8
  __int64 v372; // kr878_8
  __int64 v373; // r8
  __int64 v374; // r0
  __int64 v375; // kr880_8
  __int64 v376; // kr888_8
  __int64 v377; // kr890_8
  __int64 v378; // kr898_8
  __int64 v379; // r0
  __int64 v380; // kr8A0_8
  __int64 v381; // kr8A8_8
  __int64 v382; // kr8B0_8
  __int64 v383; // kr8B8_8
  __int64 v384; // r0
  __int64 v385; // kr8C0_8
  __int64 v386; // kr8C8_8
  __int64 v387; // kr8D0_8
  __int64 v388; // kr8D8_8
  __int64 v389; // r0
  __int64 v390; // kr8E0_8
  __int64 v391; // kr8E8_8
  __int64 v392; // kr8F0_8
  __int64 v393; // kr8F8_8
  unsigned __int64 v394; // kr900_8
  __int64 v395; // r0
  __int64 v396; // kr910_8
  __int64 v397; // kr918_8
  __int64 v398; // kr920_8
  __int64 v399; // kr928_8
  __int64 v400; // r0
  __int64 v401; // kr930_8
  __int64 v402; // kr938_8
  __int64 v403; // kr940_8
  __int64 v404; // kr948_8
  __int64 v405; // r0
  __int64 v406; // kr950_8
  __int64 v407; // kr958_8
  __int64 v408; // kr960_8
  __int64 v409; // kr968_8
  __int64 v410; // r0
  __int64 v411; // kr970_8
  __int64 v412; // kr978_8
  __int64 v413; // kr980_8
  __int64 v414; // kr988_8
  __int64 v415; // r0
  __int64 v416; // kr990_8
  __int64 v417; // kr998_8
  __int64 v418; // kr9A0_8
  __int64 v419; // kr9A8_8
  __int64 v420; // r0
  __int64 v421; // kr9B0_8
  __int64 v422; // kr9B8_8
  __int64 v423; // kr9C0_8
  __int64 v424; // kr9C8_8
  unsigned __int64 v425; // kr9D0_8
  __int64 v426; // r0
  __int64 v427; // kr9E0_8
  __int64 v428; // kr9E8_8
  __int64 v429; // kr9F0_8
  __int64 v430; // kr9F8_8
  unsigned __int64 v431; // r8
  __int64 v432; // r0
  __int64 v433; // krA00_8
  __int64 v434; // krA08_8
  __int64 v435; // krA10_8
  __int64 v436; // krA18_8
  __int64 v437; // r0
  __int64 v438; // krA28_8
  __int64 v439; // krA30_8
  __int64 v440; // krA38_8
  __int64 v441; // krA40_8
  unsigned __int64 v442; // r8
  __int64 v443; // r0
  __int64 v444; // krA48_8
  __int64 v445; // krA50_8
  __int64 v446; // krA58_8
  __int64 v447; // krA60_8
  unsigned __int64 v448; // r8
  __int64 v449; // r0
  __int64 v450; // krA68_8
  __int64 v451; // krA70_8
  __int64 v452; // krA78_8
  __int64 v453; // krA80_8
  __int64 v454; // r0
  __int64 v455; // krA88_8
  __int64 v456; // krA90_8
  __int64 v457; // krA98_8
  __int64 v458; // krAA0_8
  __int64 v459; // r0
  __int64 v460; // krAA8_8
  __int64 v461; // krAB0_8
  __int64 v462; // krAB8_8
  __int64 v463; // krAC0_8
  __int64 v464; // r0
  __int64 v465; // krAC8_8
  __int64 v466; // krAD0_8
  __int64 v467; // krAD8_8
  __int64 v468; // krAE0_8
  unsigned __int64 v469; // r8
  unsigned __int64 v470; // r0
  unsigned int v471; // r6
  unsigned int v472; // r5
  unsigned __int64 v473; // krAE8_8
  unsigned __int64 v474; // r8
  unsigned int v475; // r5
  unsigned __int64 v476; // krAF8_8
  unsigned int v477; // r5
  unsigned __int64 v478; // krB20_8
  __int64 v479; // r0
  unsigned int v480; // r5
  unsigned __int64 v481; // krB48_8
  unsigned int v482; // r5
  unsigned __int64 v483; // krB70_8
  unsigned int v484; // r5
  unsigned __int64 v485; // krB98_8
  unsigned int v486; // r5
  unsigned __int64 v487; // r8
  __int64 v488; // r0
  unsigned int v489; // r5
  unsigned __int64 v490; // krBE0_8
  unsigned int v491; // r5
  unsigned __int64 v492; // krC08_8
  unsigned int v493; // r5
  unsigned __int64 v494; // krC30_8
  unsigned int v495; // r5
  unsigned __int64 v496; // krC58_8
  unsigned int v497; // r5
  unsigned __int64 v498; // krC80_8
  unsigned int v499; // r5
  unsigned __int64 v500; // krCA8_8
  __int64 v501; // r8
  __int64 v502; // r0
  __int64 v503; // krCD0_8
  unsigned int v504; // r5
  unsigned __int64 v505; // krCF8_8
  unsigned int v506; // r5
  unsigned __int64 v507; // krD20_8
  __int64 v508; // r0
  __int64 v510; // [sp+0h] [bp+0h]
  __int64 v511; // [sp+8h] [bp+8h]
  __int64 v512; // [sp+10h] [bp+10h]
  __int64 v513; // [sp+18h] [bp+18h]
  __int64 v514; // [sp+20h] [bp+20h]
  __int64 v515; // [sp+28h] [bp+28h]
  __int64 v516; // [sp+30h] [bp+30h]
  __int64 v517; // [sp+38h] [bp+38h]
  __int64 v518; // [sp+58h] [bp+58h]
  __int64 v519; // [sp+60h] [bp+60h]
  __int64 v520; // [sp+68h] [bp+68h]
  __int64 v521; // [sp+78h] [bp+78h]
  __int64 v522; // [sp+A8h] [bp+A8h]
  __int64 v523; // [sp+B0h] [bp+B0h]
  __int64 v524; // [sp+B8h] [bp+B8h]
  __int64 v525; // [sp+C8h] [bp+C8h]
  __int64 v526; // [sp+F8h] [bp+F8h]
  __int64 v527; // [sp+100h] [bp+100h]
  __int64 v528; // [sp+108h] [bp+108h]
  __int64 v529; // [sp+118h] [bp+118h]
  __int64 v530; // [sp+148h] [bp+148h]
  __int64 v531; // [sp+150h] [bp+150h]
  __int64 v532; // [sp+158h] [bp+158h]
  __int64 v533; // [sp+168h] [bp+168h]
  __int64 v534; // [sp+198h] [bp+198h]
  __int64 v535; // [sp+1A0h] [bp+1A0h]
  __int64 v536; // [sp+1A8h] [bp+1A8h]
  __int64 v537; // [sp+1B8h] [bp+1B8h]
  __int64 v538; // [sp+1E8h] [bp+1E8h]
  __int64 v539; // [sp+1F0h] [bp+1F0h]
  __int64 v540; // [sp+1F8h] [bp+1F8h]
  __int64 v541; // [sp+238h] [bp+238h]
  __int64 v542; // [sp+240h] [bp+240h]
  __int64 v543; // [sp+248h] [bp+248h]
  __int64 v544; // [sp+260h] [bp+260h]
  __int64 v545; // [sp+268h] [bp+268h]
  __int64 v546; // [sp+288h] [bp+288h]
  __int64 v547; // [sp+290h] [bp+290h]
  __int64 v548; // [sp+298h] [bp+298h]
  __int64 v549; // [sp+2A8h] [bp+2A8h]
  __int64 v550; // [sp+2B0h] [bp+2B0h]
  __int64 v551; // [sp+2B8h] [bp+2B8h]
  __int64 v552; // [sp+2D8h] [bp+2D8h]
  __int64 v553; // [sp+2E0h] [bp+2E0h]
  __int64 v554; // [sp+2E8h] [bp+2E8h]
  __int64 v555; // [sp+2F8h] [bp+2F8h]
  __int64 v556; // [sp+300h] [bp+300h]
  __int64 v557; // [sp+328h] [bp+328h]
  __int64 v558; // [sp+330h] [bp+330h]
  __int64 v559; // [sp+338h] [bp+338h]
  __int64 v560; // [sp+360h] [bp+360h]
  __int64 v561; // [sp+378h] [bp+378h]
  __int64 v562; // [sp+380h] [bp+380h]
  __int64 v563; // [sp+388h] [bp+388h]
  __int64 v564; // [sp+3A8h] [bp+3A8h]
  __int64 v565; // [sp+3C8h] [bp+3C8h]
  __int64 v566; // [sp+3D0h] [bp+3D0h]
  __int64 v567; // [sp+3D8h] [bp+3D8h]
  __int64 v568; // [sp+3E8h] [bp+3E8h]
  __int64 v569; // [sp+3F0h] [bp+3F0h]
  __int64 v570; // [sp+3F8h] [bp+3F8h]
  __int64 v571; // [sp+418h] [bp+418h]
  __int64 v572; // [sp+420h] [bp+420h]
  __int64 v573; // [sp+438h] [bp+438h]
  __int64 v574; // [sp+440h] [bp+440h]
  __int64 v575; // [sp+468h] [bp+468h]
  __int64 v576; // [sp+470h] [bp+470h]
  __int64 v577; // [sp+4C8h] [bp+4C8h]
  __int64 v578; // [sp+4D0h] [bp+4D0h]
  __int64 v579; // [sp+4D8h] [bp+4D8h]
  __int64 v580; // [sp+4E0h] [bp+4E0h]
  int v581; // [sp+4ECh] [bp+4ECh]
  int v582; // [sp+4F0h] [bp+4F0h]
  int v583; // [sp+4F4h] [bp+4F4h]
  __int64 v584; // [sp+4F8h] [bp+4F8h]
  int v585; // [sp+500h] [bp+500h]
  int v586; // [sp+504h] [bp+504h]
  __int64 v587; // [sp+508h] [bp+508h]
  __int64 v588; // [sp+510h] [bp+510h]
  __int64 v589; // [sp+518h] [bp+518h]
  __int64 v590; // [sp+520h] [bp+520h]
  unsigned int v591; // [sp+528h] [bp+528h]
  int v592; // [sp+52Ch] [bp+52Ch]
  int v593; // [sp+530h] [bp+530h]
  int v594; // [sp+534h] [bp+534h]
  unsigned int v595; // [sp+538h] [bp+538h]
  unsigned int v596; // [sp+53Ch] [bp+53Ch]
  int v597; // [sp+540h] [bp+540h]
  int v598; // [sp+544h] [bp+544h]
  __int64 v599; // [sp+548h] [bp+548h]
  __int64 v600; // [sp+550h] [bp+550h]
  __int64 v601; // [sp+558h] [bp+558h]
  __int64 v602; // [sp+560h] [bp+560h]
  unsigned int v603; // [sp+568h] [bp+568h]
  int v604; // [sp+56Ch] [bp+56Ch]
  int v605; // [sp+570h] [bp+570h]
  int v606; // [sp+574h] [bp+574h]
  unsigned int v607; // [sp+578h] [bp+578h]
  unsigned int v608; // [sp+57Ch] [bp+57Ch]
  int v609; // [sp+580h] [bp+580h]
  int v610; // [sp+584h] [bp+584h]
  __int64 v611; // [sp+588h] [bp+588h]
  __int64 v612; // [sp+590h] [bp+590h]
  __int64 v613; // [sp+598h] [bp+598h]
  __int64 v614; // [sp+5A0h] [bp+5A0h]
  __int64 v615; // [sp+5E0h] [bp+5E0h]
  __int64 v616; // [sp+5E8h] [bp+5E8h]
  __int64 v617; // [sp+5F0h] [bp+5F0h]
  __int64 v618; // [sp+5F8h] [bp+5F8h]
  int v619; // [sp+604h] [bp+604h]
  int v620; // [sp+608h] [bp+608h]
  int v621; // [sp+60Ch] [bp+60Ch]
  __int64 v622; // [sp+610h] [bp+610h]
  int v623; // [sp+618h] [bp+618h]
  int v624; // [sp+61Ch] [bp+61Ch]
  __int64 v625; // [sp+620h] [bp+620h]
  __int64 v626; // [sp+628h] [bp+628h]
  __int64 v627; // [sp+630h] [bp+630h]
  __int64 v628; // [sp+638h] [bp+638h]
  unsigned int v629; // [sp+640h] [bp+640h]
  int v630; // [sp+644h] [bp+644h]
  int v631; // [sp+648h] [bp+648h]
  int v632; // [sp+64Ch] [bp+64Ch]
  unsigned int v633; // [sp+650h] [bp+650h]
  unsigned int v634; // [sp+654h] [bp+654h]
  int v635; // [sp+658h] [bp+658h]
  int v636; // [sp+65Ch] [bp+65Ch]
  __int64 v637; // [sp+660h] [bp+660h]
  __int64 v638; // [sp+668h] [bp+668h]
  __int64 v639; // [sp+670h] [bp+670h]
  __int64 v640; // [sp+678h] [bp+678h]
  int v641; // [sp+680h] [bp+680h]
  int v642; // [sp+684h] [bp+684h]
  int v643; // [sp+688h] [bp+688h]
  int v644; // [sp+68Ch] [bp+68Ch]
  unsigned int v645; // [sp+690h] [bp+690h]
  unsigned int v646; // [sp+694h] [bp+694h]
  int v647; // [sp+698h] [bp+698h]
  int v648; // [sp+69Ch] [bp+69Ch]
  __int64 v649; // [sp+6A0h] [bp+6A0h]
  __int64 v650; // [sp+6A8h] [bp+6A8h]
  __int64 v651; // [sp+6B0h] [bp+6B0h]
  __int64 v652; // [sp+6B8h] [bp+6B8h]
  __int64 v653; // [sp+6D0h] [bp+6D0h]
  unsigned int v654; // [sp+6E4h] [bp+6E4h]
  unsigned int v655; // [sp+6F4h] [bp+6F4h]
  unsigned int v656; // [sp+704h] [bp+704h]
  unsigned int v657; // [sp+714h] [bp+714h]
  unsigned int v658; // [sp+724h] [bp+724h]
  unsigned int v659; // [sp+734h] [bp+734h]
  unsigned int v660; // [sp+744h] [bp+744h]
  unsigned int v661; // [sp+754h] [bp+754h]
  unsigned int v662; // [sp+764h] [bp+764h]
  unsigned int v663; // [sp+774h] [bp+774h]
  unsigned int v664; // [sp+784h] [bp+784h]
  unsigned int v665; // [sp+794h] [bp+794h]
  _QWORD v666[22]; // [sp+7A0h] [bp+7A0h] BYREF
  __int64 v667; // [sp+850h] [bp+850h]
  __int64 v668; // [sp+858h] [bp+858h]
  __int64 v669; // [sp+860h] [bp+860h]
  unsigned __int64 v670; // [sp+868h] [bp+868h]
  __int64 v671; // [sp+870h] [bp+870h]
  __int64 v672; // [sp+878h] [bp+878h]
  __int64 v673; // [sp+880h] [bp+880h]
  unsigned __int64 v674; // [sp+888h] [bp+888h]
  __int64 v675; // [sp+890h] [bp+890h]
  __int64 v676; // [sp+898h] [bp+898h]
  unsigned __int64 v677; // [sp+8A0h] [bp+8A0h]
  __int64 v678; // [sp+8A8h] [bp+8A8h]
  __int64 v679; // [sp+8B0h] [bp+8B0h]
  __int64 v680; // [sp+8B8h] [bp+8B8h]
  unsigned __int64 v681; // [sp+8C0h] [bp+8C0h]
  __int64 v682; // [sp+8C8h] [bp+8C8h]
  __int64 v683; // [sp+8D0h] [bp+8D0h]
  __int64 v684; // [sp+8D8h] [bp+8D8h]
  unsigned __int64 v685; // [sp+8E0h] [bp+8E0h]
  __int64 v686; // [sp+8E8h] [bp+8E8h]
  __int64 v687; // [sp+8F0h] [bp+8F0h]
  __int64 v688; // [sp+8F8h] [bp+8F8h]
  unsigned __int64 v689; // [sp+900h] [bp+900h]
  __int64 v690; // [sp+908h] [bp+908h]
  __int64 v691; // [sp+910h] [bp+910h]
  __int64 v692; // [sp+918h] [bp+918h]
  unsigned __int64 v693; // [sp+920h] [bp+920h]
  __int64 v694; // [sp+928h] [bp+928h]
  __int64 v695; // [sp+930h] [bp+930h]
  __int64 v696; // [sp+938h] [bp+938h]
  unsigned __int64 v697; // [sp+940h] [bp+940h]
  __int64 v698; // [sp+948h] [bp+948h]
  __int64 v699; // [sp+950h] [bp+950h]
  __int64 v700; // [sp+958h] [bp+958h]
  unsigned __int64 v701; // [sp+960h] [bp+960h]
  __int64 v702; // [sp+968h] [bp+968h]
  __int64 v703; // [sp+970h] [bp+970h]
  unsigned __int64 v704; // [sp+978h] [bp+978h]
  __int64 v705; // [sp+980h] [bp+980h]
  __int64 v706; // [sp+988h] [bp+988h]
  __int64 v707; // [sp+990h] [bp+990h]
  unsigned __int64 v708; // [sp+998h] [bp+998h]
  __int64 v709; // [sp+9A0h] [bp+9A0h]
  __int64 v710; // [sp+9A8h] [bp+9A8h]
  __int64 v711; // [sp+9B0h] [bp+9B0h]
  unsigned __int64 v712; // [sp+9B8h] [bp+9B8h]
  __int64 v713; // [sp+9C0h] [bp+9C0h]
  __int64 v714; // [sp+9C8h] [bp+9C8h]
  __int64 v715; // [sp+9D0h] [bp+9D0h]
  unsigned __int64 v716; // [sp+9D8h] [bp+9D8h]
  __int64 v717; // [sp+9E0h] [bp+9E0h]
  __int64 v718; // [sp+9E8h] [bp+9E8h]
  __int64 v719; // [sp+9F0h] [bp+9F0h]
  unsigned __int64 v720; // [sp+9F8h] [bp+9F8h]
  __int64 v721; // [sp+A00h] [bp+A00h]
  __int64 v722; // [sp+A08h] [bp+A08h]
  __int64 v723; // [sp+A10h] [bp+A10h]
  __int64 v724; // [sp+A18h] [bp+A18h]
  __int64 v725; // [sp+A20h] [bp+A20h]
  unsigned __int64 v726; // [sp+A28h] [bp+A28h]
  unsigned __int64 v727; // [sp+A30h] [bp+A30h]
  __int64 v728; // [sp+A38h] [bp+A38h]
  __int64 v729; // [sp+A40h] [bp+A40h]
  __int64 v730; // [sp+A48h] [bp+A48h]
  unsigned __int64 v731; // [sp+A50h] [bp+A50h]
  unsigned __int64 v732; // [sp+A58h] [bp+A58h]
  __int64 v733; // [sp+A60h] [bp+A60h]
  __int64 v734; // [sp+A68h] [bp+A68h]
  __int64 v735; // [sp+A70h] [bp+A70h]
  unsigned __int64 v736; // [sp+A78h] [bp+A78h]
  unsigned __int64 v737; // [sp+A80h] [bp+A80h]
  __int64 v738; // [sp+A88h] [bp+A88h]
  __int64 v739; // [sp+A90h] [bp+A90h]
  __int64 v740; // [sp+A98h] [bp+A98h]
  unsigned __int64 v741; // [sp+AA0h] [bp+AA0h]
  unsigned __int64 v742; // [sp+AA8h] [bp+AA8h]
  __int64 v743; // [sp+AB0h] [bp+AB0h]
  __int64 v744; // [sp+AB8h] [bp+AB8h]
  __int64 v745; // [sp+AC0h] [bp+AC0h]
  __int64 v746; // [sp+AC8h] [bp+AC8h]
  __int64 v747; // [sp+AD0h] [bp+AD0h]
  unsigned __int64 v748; // [sp+AD8h] [bp+AD8h]
  unsigned __int64 v749; // [sp+AE0h] [bp+AE0h]
  __int64 v750; // [sp+AE8h] [bp+AE8h]
  __int64 v751; // [sp+AF0h] [bp+AF0h]
  __int64 v752; // [sp+AF8h] [bp+AF8h]
  unsigned __int64 v753; // [sp+B00h] [bp+B00h]
  unsigned __int64 v754; // [sp+B08h] [bp+B08h]
  __int64 v755; // [sp+B10h] [bp+B10h]
  __int64 v756; // [sp+B18h] [bp+B18h]
  __int64 v757; // [sp+B20h] [bp+B20h]
  unsigned __int64 v758; // [sp+B28h] [bp+B28h]
  unsigned __int64 v759; // [sp+B30h] [bp+B30h]
  __int64 v760; // [sp+B38h] [bp+B38h]
  __int64 v761; // [sp+B40h] [bp+B40h]
  __int64 v762; // [sp+B48h] [bp+B48h]
  unsigned __int64 v763; // [sp+B50h] [bp+B50h]
  unsigned __int64 v764; // [sp+B58h] [bp+B58h]
  __int64 v765; // [sp+B60h] [bp+B60h]
  unsigned __int64 v766; // [sp+B68h] [bp+B68h]
  __int64 v767; // [sp+B70h] [bp+B70h]
  __int64 v768; // [sp+B78h] [bp+B78h]
  unsigned __int64 v769; // [sp+B80h] [bp+B80h]
  __int64 v770; // [sp+B88h] [bp+B88h]
  __int64 v771; // [sp+B90h] [bp+B90h]
  unsigned __int64 v772; // [sp+B98h] [bp+B98h]
  unsigned __int64 v773; // [sp+BA0h] [bp+BA0h]
  __int64 v774; // [sp+BA8h] [bp+BA8h]
  unsigned __int64 v775; // [sp+BB0h] [bp+BB0h]
  unsigned __int64 v776; // [sp+BB8h] [bp+BB8h]
  __int64 v777; // [sp+BC0h] [bp+BC0h]
  __int64 v778; // [sp+BC8h] [bp+BC8h]
  unsigned __int64 v779; // [sp+BD0h] [bp+BD0h]
  __int64 v780; // [sp+BD8h] [bp+BD8h]
  __int64 v781; // [sp+BE0h] [bp+BE0h]
  unsigned __int64 v782; // [sp+BE8h] [bp+BE8h]
  __int64 v783; // [sp+BF0h] [bp+BF0h]
  __int64 v784; // [sp+BF8h] [bp+BF8h]
  unsigned __int64 v785; // [sp+C00h] [bp+C00h]
  unsigned __int64 v786; // [sp+C08h] [bp+C08h]
  __int64 v787; // [sp+C10h] [bp+C10h]
  unsigned __int64 v788; // [sp+C18h] [bp+C18h]
  unsigned __int64 v789; // [sp+C20h] [bp+C20h]
  __int64 v790; // [sp+C28h] [bp+C28h]
  __int64 v791; // [sp+C30h] [bp+C30h]
  unsigned __int64 v792; // [sp+C38h] [bp+C38h]
  __int64 v793; // [sp+C40h] [bp+C40h]
  __int64 v794; // [sp+C48h] [bp+C48h]
  unsigned __int64 v795; // [sp+C50h] [bp+C50h]
  __int64 v796; // [sp+C58h] [bp+C58h]
  __int64 v797; // [sp+C60h] [bp+C60h]
  unsigned __int64 v798; // [sp+C68h] [bp+C68h]
  unsigned __int64 v799; // [sp+C70h] [bp+C70h]
  __int64 v800; // [sp+C78h] [bp+C78h]
  unsigned __int64 v801; // [sp+C80h] [bp+C80h]
  unsigned __int64 v802; // [sp+C88h] [bp+C88h]
  __int64 v803; // [sp+C90h] [bp+C90h]
  __int64 v804; // [sp+C98h] [bp+C98h]
  unsigned __int64 v805; // [sp+CA0h] [bp+CA0h]
  __int64 v806; // [sp+CA8h] [bp+CA8h]
  int v807; // [sp+CB4h] [bp+CB4h]
  int v808; // [sp+CB8h] [bp+CB8h]
  int v809; // [sp+CBCh] [bp+CBCh]
  signed __int64 v810; // [sp+CC0h] [bp+CC0h]
  signed __int64 v811; // [sp+CC8h] [bp+CC8h]
  signed __int64 v812; // [sp+CD0h] [bp+CD0h]
  signed __int64 v813; // [sp+CD8h] [bp+CD8h]
  __int64 v814; // [sp+CE0h] [bp+CE0h]
  signed __int64 v815; // [sp+CE8h] [bp+CE8h]
  signed __int64 v816; // [sp+CF0h] [bp+CF0h]
  signed __int64 v817; // [sp+CF8h] [bp+CF8h]
  signed __int64 v818; // [sp+D00h] [bp+D00h]
  __int64 v819; // [sp+D08h] [bp+D08h]
  signed __int64 v820; // [sp+D10h] [bp+D10h]
  signed __int64 v821; // [sp+D18h] [bp+D18h]
  signed __int64 v822; // [sp+D20h] [bp+D20h]
  signed __int64 v823; // [sp+D28h] [bp+D28h]
  __int64 v824; // [sp+D30h] [bp+D30h]
  __int64 v825; // [sp+D38h] [bp+D38h]
  signed __int64 v826; // [sp+D40h] [bp+D40h]
  signed __int64 v827; // [sp+D48h] [bp+D48h]
  signed __int64 v828; // [sp+D50h] [bp+D50h]
  signed __int64 v829; // [sp+D58h] [bp+D58h]
  signed __int64 v830; // [sp+D60h] [bp+D60h]
  signed __int64 v831; // [sp+D68h] [bp+D68h]
  signed __int64 v832; // [sp+D70h] [bp+D70h]
  signed __int64 v833; // [sp+D78h] [bp+D78h]
  signed __int64 v834; // [sp+D80h] [bp+D80h]
  signed __int64 v835; // [sp+D88h] [bp+D88h]
  signed __int64 v836; // [sp+D90h] [bp+D90h]
  signed __int64 v837; // [sp+D98h] [bp+D98h]
  signed __int64 v838; // [sp+DA0h] [bp+DA0h]
  unsigned __int64 v839; // [sp+DA8h] [bp+DA8h]
  unsigned __int64 v840; // [sp+DB0h] [bp+DB0h]
  unsigned __int64 v841; // [sp+DB8h] [bp+DB8h]
  unsigned __int64 v842; // [sp+DC0h] [bp+DC0h]
  unsigned __int64 v843; // [sp+DC8h] [bp+DC8h]

  v809 = a1;
  v808 = a2;
  v807 = a3;
  v3 = sub_10B364(a1 + 40);
  v4 = *(_QWORD *)(v808 + 40);
  v5 = (v3 ^ v4) - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v6 = v5 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v7 = v6 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v8 = ((*(_QWORD *)(v808 + 112) ^ (unsigned __int64)sub_10B364(v809 + 112)) + v7) >> 1;
  v9 = sub_10B364(v809 + 40);
  v10 = *(_QWORD *)(v808 + 40);
  v11 = (v9 ^ v10) - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v12 = v11 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v13 = v12 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v14 = (8 * ((*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112)) + v13)) ^ v8;
  v15 = sub_10B364(v809 + 40);
  v16 = *(_QWORD *)(v808 + 40);
  v17 = (v15 ^ v16) - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v18 = v17 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v19 = v18 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v806 = 16 * ((*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112)) + v19);
  v20 = sub_10B364(v809 + 40);
  v21 = *(_QWORD *)(v808 + 40);
  v22 = (v20 ^ v21) - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v23 = v22 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v24 = v23 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  LODWORD(v14) = v14
               ^ (v806
                | ((unsigned int)(((*(_QWORD *)(v808 + 112) ^ (unsigned __int64)sub_10B364(v809 + 112)) + v24) >> 32) >> 28));
  v25 = sub_10B364(v809 + 40);
  v26 = *(_QWORD *)(v808 + 40);
  v27 = (v25 ^ v26) - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v28 = v27 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v29 = v28 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v665 = 32 * ((*(_DWORD *)(v808 + 112) ^ sub_10B364(v809 + 112)) + v29);
  v30 = sub_10B364(v809 + 40);
  v31 = *(_QWORD *)(v808 + 40);
  v32 = (v30 ^ v31) - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v33 = v32 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v34 = v33 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v35 = (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112)) + v34;
  v805 = v35 >> 27;
  v810 = __PAIR64__(
           HIDWORD(v14) ^ HIDWORD(v806) ^ (v665 | (HIDWORD(v35) >> 27)),
           (unsigned int)v14 ^ (unsigned int)(v35 >> 27))
       + *(_QWORD *)(v808 + 8);
  v36 = sub_10B364(v809 + 48);
  v37 = *(_QWORD *)(v808 + 48);
  v38 = (v36 ^ v37) - (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v39 = v38 + (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v40 = v39 + (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112));
  v41 = (v40 - (*(_QWORD *)(v808 + 120) ^ (unsigned __int64)sub_10B364(v809 + 120))) >> 1;
  v42 = sub_10B364(v809 + 48);
  v43 = *(_QWORD *)(v808 + 48);
  v44 = (v42 ^ v43) - (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v45 = v44 + (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v46 = v45 + (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112));
  v804 = 4 * (v46 - (*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)));
  v47 = v804 ^ v41;
  v48 = sub_10B364(v809 + 48);
  v49 = *(_QWORD *)(v808 + 48);
  v50 = (v48 ^ v49) - (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v51 = v50 + (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v52 = v51 + (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112));
  v803 = (v52 - (*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120))) << 13;
  v53 = sub_10B364(v809 + 48);
  v54 = *(_QWORD *)(v808 + 48);
  v55 = (v53 ^ v54) - (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v56 = v55 + (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v57 = v56 + (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112));
  LODWORD(v47) = v47
               ^ (v803
                | ((unsigned int)((v57 - (*(_QWORD *)(v808 + 120) ^ (unsigned __int64)sub_10B364(v809 + 120))) >> 32) >> 19));
  v58 = sub_10B364(v809 + 48);
  v59 = *(_QWORD *)(v808 + 48);
  v60 = (v58 ^ v59) - (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v61 = v60 + (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v62 = v61 + (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112));
  v664 = ((_DWORD)v62 - (*(_DWORD *)(v808 + 120) ^ (unsigned int)sub_10B364(v809 + 120))) << 11;
  v63 = sub_10B364(v809 + 48);
  v64 = *(_QWORD *)(v808 + 48);
  v65 = (v63 ^ v64) - (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v66 = v65 + (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v67 = v66 + (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112));
  v68 = v67 - (*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120));
  v802 = v68 >> 21;
  v811 = __PAIR64__(
           HIDWORD(v47) ^ HIDWORD(v803) ^ (v664 | (HIDWORD(v68) >> 21)),
           (unsigned int)v47 ^ (unsigned int)(v68 >> 21))
       + *(_QWORD *)(v808 + 16);
  v69 = sub_10B364(v809);
  v70 = v69 ^ *(_DWORD *)v808;
  v71 = HIDWORD(v69) ^ *(_DWORD *)(v808 + 4);
  v72 = __PAIR64__(v71, v70) + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v73 = v72 + (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v74 = v73 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v801 = ((*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v74) >> 2;
  v75 = sub_10B364(v809);
  v76 = v75 ^ *(_DWORD *)v808;
  v77 = HIDWORD(v75) ^ *(_DWORD *)(v808 + 4);
  v78 = __PAIR64__(v77, v76) + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v79 = v78 + (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v80 = v79 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v81 = v801 ^ (2 * ((*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v80));
  v82 = sub_10B364(v809);
  v83 = v82 ^ *(_DWORD *)v808;
  v84 = HIDWORD(v82) ^ *(_DWORD *)(v808 + 4);
  v85 = __PAIR64__(v84, v83) + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v86 = v85 + (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v87 = v86 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v800 = ((*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v87) << 19;
  v88 = sub_10B364(v809);
  v89 = v88 ^ *(_DWORD *)v808;
  v90 = HIDWORD(v88) ^ *(_DWORD *)(v808 + 4);
  v91 = __PAIR64__(v90, v89) + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v92 = v91 + (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v93 = v92 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  LODWORD(v81) = v81 ^ (v800 | ((unsigned int)(((*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v93) >> 32) >> 13));
  v94 = sub_10B364(v809);
  v95 = v94 ^ *(_DWORD *)v808;
  v96 = HIDWORD(v94) ^ *(_DWORD *)(v808 + 4);
  v97 = __PAIR64__(v96, v95) + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v98 = v97 + (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v99 = v98 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v663 = ((*(_DWORD *)(v808 + 120) ^ (unsigned int)sub_10B364(v809 + 120)) + (_DWORD)v99) << 21;
  v100 = sub_10B364(v809);
  v101 = v100 ^ *(_DWORD *)v808;
  v102 = HIDWORD(v100) ^ *(_DWORD *)(v808 + 4);
  v103 = __PAIR64__(v102, v101) + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v104 = v103 + (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v105 = v104 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v106 = (*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v105;
  v799 = v106 >> 11;
  v812 = __PAIR64__(
           HIDWORD(v81) ^ HIDWORD(v800) ^ (v663 | (HIDWORD(v106) >> 11)),
           (unsigned int)v81 ^ (unsigned int)(v106 >> 11))
       + *(_QWORD *)(v808 + 24);
  v107 = sub_10B364(v809);
  v108 = v107 ^ *(_DWORD *)v808;
  v109 = HIDWORD(v107) ^ *(_DWORD *)(v808 + 4);
  v110 = __PAIR64__(v109, v108) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v111 = v110 + (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v112 = v111 - (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v798 = ((*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v112) >> 2;
  v113 = sub_10B364(v809);
  v114 = v113 ^ *(_DWORD *)v808;
  v115 = HIDWORD(v113) ^ *(_DWORD *)(v808 + 4);
  v116 = __PAIR64__(v115, v114) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v117 = v116 + (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v118 = v117 - (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v797 = 4 * ((*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v118);
  v119 = sub_10B364(v809);
  v120 = v119 ^ *(_DWORD *)v808;
  v121 = HIDWORD(v119) ^ *(_DWORD *)(v808 + 4);
  v122 = __PAIR64__(v121, v120) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v123 = v122 + (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v124 = v123 - (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v796 = ((*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v124) << 28;
  v125 = sub_10B364(v809);
  v126 = v125 ^ *(_DWORD *)v808;
  v127 = HIDWORD(v125) ^ *(_DWORD *)(v808 + 4);
  v128 = __PAIR64__(v127, v126) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v129 = v128 + (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v130 = v129 - (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  LODWORD(v81) = v798
               ^ v797
               ^ (v796 | ((unsigned int)(((*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v130) >> 32) >> 4));
  v131 = sub_10B364(v809);
  v132 = v131 ^ *(_DWORD *)v808;
  v133 = HIDWORD(v131) ^ *(_DWORD *)(v808 + 4);
  v134 = __PAIR64__(v133, v132) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v135 = v134 + (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v136 = v135 - (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v662 = ((*(_DWORD *)(v808 + 104) ^ (unsigned int)sub_10B364(v809 + 104)) + (_DWORD)v136) << 27;
  v137 = sub_10B364(v809);
  v138 = v137 ^ *(_DWORD *)v808;
  v139 = HIDWORD(v137) ^ *(_DWORD *)(v808 + 4);
  v140 = __PAIR64__(v139, v138) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v141 = v140 + (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v142 = v141 - (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v143 = (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v142;
  v795 = v143 >> 5;
  v813 = __PAIR64__(
           ((v798 ^ v797) >> 32) ^ HIDWORD(v796) ^ (v662 | (HIDWORD(v143) >> 5)),
           (unsigned int)v81 ^ (unsigned int)(v143 >> 5))
       + *(_QWORD *)(v808 + 32);
  v144 = sub_10B364(v809 + 8);
  v145 = *(_QWORD *)(v808 + 8);
  v146 = (v144 ^ v145) + (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v147 = v146 + (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v148 = v147 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v149 = (v148 - (*(_QWORD *)(v808 + 112) ^ (unsigned __int64)sub_10B364(v809 + 112))) >> 1;
  v150 = sub_10B364(v809 + 8);
  v151 = *(_QWORD *)(v808 + 8);
  v152 = (v150 ^ v151) + (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v153 = v152 + (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v154 = v153 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v814 = (v149 ^ (v154 - (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112)))) + *(_QWORD *)(v808 + 40);
  v155 = sub_10B364(v809 + 24);
  v156 = *(_QWORD *)(v808 + 24);
  v157 = (v155 ^ v156) - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v158 = v157 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v159 = v158 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v160 = ((*(_QWORD *)(v808 + 120) ^ (unsigned __int64)sub_10B364(v809 + 120)) + v159) >> 1;
  v161 = sub_10B364(v809 + 24);
  v162 = *(_QWORD *)(v808 + 24);
  v163 = (v161 ^ v162) - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v164 = v163 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v165 = v164 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v794 = 8 * ((*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v165);
  v166 = v794 ^ v160;
  v167 = sub_10B364(v809 + 24);
  v168 = *(_QWORD *)(v808 + 24);
  v169 = (v167 ^ v168) - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v170 = v169 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v171 = v170 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v793 = 16 * ((*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v171);
  v172 = sub_10B364(v809 + 24);
  v173 = *(_QWORD *)(v808 + 24);
  v174 = (v172 ^ v173) - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v175 = v174 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v176 = v175 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  LODWORD(v166) = v166
                ^ (v793
                 | ((unsigned int)(((*(_QWORD *)(v808 + 120) ^ (unsigned __int64)sub_10B364(v809 + 120)) + v176) >> 32) >> 28));
  v177 = sub_10B364(v809 + 24);
  v178 = *(_QWORD *)(v808 + 24);
  v179 = (v177 ^ v178) - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v180 = v179 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v181 = v180 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v661 = 32 * ((*(_DWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v181);
  v182 = sub_10B364(v809 + 24);
  v183 = *(_QWORD *)(v808 + 24);
  v184 = (v182 ^ v183) - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v185 = v184 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v186 = v185 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v187 = (*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v186;
  v792 = v187 >> 27;
  v815 = __PAIR64__(
           HIDWORD(v166) ^ HIDWORD(v793) ^ (v661 | (HIDWORD(v187) >> 27)),
           (unsigned int)v166 ^ (unsigned int)(v187 >> 27))
       + *(_QWORD *)(v808 + 48);
  v188 = sub_10B364(v809 + 32);
  v189 = *(_QWORD *)(v808 + 32);
  v190 = (v188 ^ v189) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v191 = v190 - (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v192 = v191 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v193 = ((*(_QWORD *)(v808 + 104) ^ (unsigned __int64)sub_10B364(v809 + 104)) + v192) >> 1;
  v194 = sub_10B364(v809 + 32);
  v195 = *(_QWORD *)(v808 + 32);
  v196 = (v194 ^ v195) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v197 = v196 - (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v198 = v197 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v791 = 4 * ((*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v198);
  v199 = v791 ^ v193;
  v200 = sub_10B364(v809 + 32);
  v201 = *(_QWORD *)(v808 + 32);
  v202 = (v200 ^ v201) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v203 = v202 - (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v204 = v203 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v790 = ((*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v204) << 13;
  v205 = sub_10B364(v809 + 32);
  v206 = *(_QWORD *)(v808 + 32);
  v207 = (v205 ^ v206) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v208 = v207 - (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v209 = v208 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  LODWORD(v199) = v199
                ^ (v790
                 | ((unsigned int)(((*(_QWORD *)(v808 + 104) ^ (unsigned __int64)sub_10B364(v809 + 104)) + v209) >> 32) >> 19));
  v210 = sub_10B364(v809 + 32);
  v211 = *(_QWORD *)(v808 + 32);
  v212 = (v210 ^ v211) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v213 = v212 - (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v214 = v213 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v660 = ((*(_DWORD *)(v808 + 104) ^ (unsigned int)sub_10B364(v809 + 104)) + (_DWORD)v214) << 11;
  v215 = sub_10B364(v809 + 32);
  v216 = *(_QWORD *)(v808 + 32);
  v217 = (v215 ^ v216) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v218 = v217 - (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v219 = v218 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v220 = (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v219;
  v789 = v220 >> 21;
  v816 = __PAIR64__(
           HIDWORD(v199) ^ HIDWORD(v790) ^ (v660 | (HIDWORD(v220) >> 21)),
           (unsigned int)v199 ^ (unsigned int)(v220 >> 21))
       + *(_QWORD *)(v808 + 56);
  v221 = sub_10B364(v809 + 8);
  v222 = *(_QWORD *)(v808 + 8);
  v223 = (v221 ^ v222) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v224 = v223 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v225 = v224 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v788 = (v225 - (*(_QWORD *)(v808 + 112) ^ (unsigned __int64)sub_10B364(v809 + 112))) >> 2;
  v226 = sub_10B364(v809 + 8);
  v227 = *(_QWORD *)(v808 + 8);
  v228 = (v226 ^ v227) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v229 = v228 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v230 = v229 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v231 = v788 ^ (2 * (v230 - (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112))));
  v232 = sub_10B364(v809 + 8);
  v233 = *(_QWORD *)(v808 + 8);
  v234 = (v232 ^ v233) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v235 = v234 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v236 = v235 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v787 = (v236 - (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112))) << 19;
  v237 = sub_10B364(v809 + 8);
  v238 = *(_QWORD *)(v808 + 8);
  v239 = (v237 ^ v238) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v240 = v239 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v241 = v240 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  LODWORD(v231) = v231
                ^ (v787
                 | ((unsigned int)((v241 - (*(_QWORD *)(v808 + 112) ^ (unsigned __int64)sub_10B364(v809 + 112))) >> 32) >> 13));
  v242 = sub_10B364(v809 + 8);
  v243 = *(_QWORD *)(v808 + 8);
  v244 = (v242 ^ v243) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v245 = v244 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v246 = v245 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v659 = ((_DWORD)v246 - (*(_DWORD *)(v808 + 112) ^ (unsigned int)sub_10B364(v809 + 112))) << 21;
  v247 = sub_10B364(v809 + 8);
  v248 = *(_QWORD *)(v808 + 8);
  v249 = (v247 ^ v248) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v250 = v249 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v251 = v250 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96));
  v252 = v251 - (*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112));
  v786 = v252 >> 11;
  v817 = __PAIR64__(
           HIDWORD(v231) ^ HIDWORD(v787) ^ (v659 | (HIDWORD(v252) >> 11)),
           (unsigned int)v231 ^ (unsigned int)(v252 >> 11))
       + *(_QWORD *)(v808 + 64);
  v253 = sub_10B364(v809 + 16);
  v254 = *(_QWORD *)(v808 + 16);
  v255 = (v253 ^ v254) - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v256 = v255 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v257 = v256 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v785 = (v257 - (*(_QWORD *)(v808 + 120) ^ (unsigned __int64)sub_10B364(v809 + 120))) >> 2;
  v258 = sub_10B364(v809 + 16);
  v259 = *(_QWORD *)(v808 + 16);
  v260 = (v258 ^ v259) - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v261 = v260 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v262 = v261 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v784 = 4 * (v262 - (*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)));
  v263 = sub_10B364(v809 + 16);
  v264 = *(_QWORD *)(v808 + 16);
  v265 = (v263 ^ v264) - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v266 = v265 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v267 = v266 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v783 = (v267 - (*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120))) << 28;
  v268 = sub_10B364(v809 + 16);
  v269 = *(_QWORD *)(v808 + 16);
  v270 = (v268 ^ v269) - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v271 = v270 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v272 = v271 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  LODWORD(v231) = v785
                ^ v784
                ^ (v783
                 | ((unsigned int)((v272 - (*(_QWORD *)(v808 + 120) ^ (unsigned __int64)sub_10B364(v809 + 120))) >> 32) >> 4));
  v273 = sub_10B364(v809 + 16);
  v274 = *(_QWORD *)(v808 + 16);
  v275 = (v273 ^ v274) - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v276 = v275 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v277 = v276 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v658 = ((_DWORD)v277 - (*(_DWORD *)(v808 + 120) ^ (unsigned int)sub_10B364(v809 + 120))) << 27;
  v278 = sub_10B364(v809 + 16);
  v279 = *(_QWORD *)(v808 + 16);
  v280 = (v278 ^ v279) - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v281 = v280 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v282 = v281 + (*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104));
  v283 = v282 - (*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120));
  v782 = v283 >> 5;
  v818 = __PAIR64__(
           ((v785 ^ v784) >> 32) ^ HIDWORD(v783) ^ (v658 | (HIDWORD(v283) >> 5)),
           (unsigned int)v231 ^ (unsigned int)(v283 >> 5))
       + *(_QWORD *)(v808 + 72);
  v284 = sub_10B364(v809);
  v285 = v284 ^ *(_DWORD *)v808;
  v286 = HIDWORD(v284) ^ *(_DWORD *)(v808 + 4);
  v287 = __PAIR64__(v286, v285) - (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v288 = v287 + (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v289 = v288 - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v290 = ((*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112)) + v289) >> 1;
  v291 = sub_10B364(v809);
  v292 = v291 ^ *(_DWORD *)v808;
  v293 = HIDWORD(v291) ^ *(_DWORD *)(v808 + 4);
  v294 = __PAIR64__(v293, v292) - (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v295 = v294 + (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v296 = v295 - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v819 = (v290 ^ ((*(_QWORD *)(v808 + 112) ^ sub_10B364(v809 + 112)) + v296)) + *(_QWORD *)(v808 + 80);
  v297 = sub_10B364(v809 + 64);
  v298 = *(_QWORD *)(v808 + 64);
  v299 = (v297 ^ v298) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v300 = v299 - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v301 = v300 - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v302 = ((*(_QWORD *)(v808 + 120) ^ (unsigned __int64)sub_10B364(v809 + 120)) + v301) >> 1;
  v303 = sub_10B364(v809 + 64);
  v304 = *(_QWORD *)(v808 + 64);
  v305 = (v303 ^ v304) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v306 = v305 - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v307 = v306 - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v781 = 8 * ((*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v307);
  v308 = v781 ^ v302;
  v309 = sub_10B364(v809 + 64);
  v310 = *(_QWORD *)(v808 + 64);
  v311 = (v309 ^ v310) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v312 = v311 - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v313 = v312 - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v780 = 16 * ((*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v313);
  v314 = sub_10B364(v809 + 64);
  v315 = *(_QWORD *)(v808 + 64);
  v316 = (v314 ^ v315) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v317 = v316 - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v318 = v317 - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  LODWORD(v308) = v308
                ^ (v780
                 | ((unsigned int)(((*(_QWORD *)(v808 + 120) ^ (unsigned __int64)sub_10B364(v809 + 120)) + v318) >> 32) >> 28));
  v319 = sub_10B364(v809 + 64);
  v320 = *(_QWORD *)(v808 + 64);
  v321 = (v319 ^ v320) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v322 = v321 - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v323 = v322 - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v657 = 32 * ((*(_DWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v323);
  v324 = sub_10B364(v809 + 64);
  v325 = *(_QWORD *)(v808 + 64);
  v326 = (v324 ^ v325) - (*(_QWORD *)(v808 + 8) ^ sub_10B364(v809 + 8));
  v327 = v326 - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v328 = v327 - (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v329 = (*(_QWORD *)(v808 + 120) ^ sub_10B364(v809 + 120)) + v328;
  v779 = v329 >> 27;
  v820 = __PAIR64__(
           HIDWORD(v308) ^ HIDWORD(v780) ^ (v657 | (HIDWORD(v329) >> 27)),
           (unsigned int)v308 ^ (unsigned int)(v329 >> 27))
       + *(_QWORD *)(v808 + 88);
  v330 = sub_10B364(v809 + 64);
  v331 = *(_QWORD *)(v808 + 64);
  v332 = (v330 ^ v331) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v333 = v332 - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v334 = v333 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v335 = ((*(_QWORD *)(v808 + 72) ^ (unsigned __int64)sub_10B364(v809 + 72)) + v334) >> 1;
  v336 = sub_10B364(v809 + 64);
  v337 = *(_QWORD *)(v808 + 64);
  v338 = (v336 ^ v337) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v339 = v338 - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v340 = v339 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v778 = 4 * ((*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72)) + v340);
  v341 = v778 ^ v335;
  v342 = sub_10B364(v809 + 64);
  v343 = *(_QWORD *)(v808 + 64);
  v344 = (v342 ^ v343) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v345 = v344 - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v346 = v345 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v777 = ((*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72)) + v346) << 13;
  v347 = sub_10B364(v809 + 64);
  v348 = *(_QWORD *)(v808 + 64);
  v349 = (v347 ^ v348) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v350 = v349 - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v351 = v350 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  LODWORD(v341) = v341
                ^ (v777
                 | ((unsigned int)(((*(_QWORD *)(v808 + 72) ^ (unsigned __int64)sub_10B364(v809 + 72)) + v351) >> 32) >> 19));
  v352 = sub_10B364(v809 + 64);
  v353 = *(_QWORD *)(v808 + 64);
  v354 = (v352 ^ v353) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v355 = v354 - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v356 = v355 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v656 = ((*(_DWORD *)(v808 + 72) ^ (unsigned int)sub_10B364(v809 + 72)) + (_DWORD)v356) << 11;
  v357 = sub_10B364(v809 + 64);
  v358 = *(_QWORD *)(v808 + 64);
  v359 = (v357 ^ v358) - (*(_QWORD *)v808 ^ sub_10B364(v809));
  v360 = v359 - (*(_QWORD *)(v808 + 16) ^ sub_10B364(v809 + 16));
  v361 = v360 - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v362 = (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72)) + v361;
  v776 = v362 >> 21;
  v821 = __PAIR64__(
           HIDWORD(v341) ^ HIDWORD(v777) ^ (v656 | (HIDWORD(v362) >> 21)),
           (unsigned int)v341 ^ (unsigned int)(v362 >> 21))
       + *(_QWORD *)(v808 + 96);
  v363 = sub_10B364(v809 + 8);
  v364 = *(_QWORD *)(v808 + 8);
  v365 = (v363 ^ v364) + (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v366 = v365 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v367 = v366 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v775 = ((*(_QWORD *)(v808 + 80) ^ (unsigned __int64)sub_10B364(v809 + 80)) + v367) >> 2;
  v368 = sub_10B364(v809 + 8);
  v369 = *(_QWORD *)(v808 + 8);
  v370 = (v368 ^ v369) + (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v371 = v370 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v372 = v371 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v373 = v775 ^ (2 * ((*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80)) + v372));
  v374 = sub_10B364(v809 + 8);
  v375 = *(_QWORD *)(v808 + 8);
  v376 = (v374 ^ v375) + (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v377 = v376 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v378 = v377 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v774 = ((*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80)) + v378) << 19;
  v379 = sub_10B364(v809 + 8);
  v380 = *(_QWORD *)(v808 + 8);
  v381 = (v379 ^ v380) + (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v382 = v381 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v383 = v382 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  LODWORD(v373) = v373
                ^ (v774
                 | ((unsigned int)(((*(_QWORD *)(v808 + 80) ^ (unsigned __int64)sub_10B364(v809 + 80)) + v383) >> 32) >> 13));
  v384 = sub_10B364(v809 + 8);
  v385 = *(_QWORD *)(v808 + 8);
  v386 = (v384 ^ v385) + (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v387 = v386 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v388 = v387 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v655 = ((*(_DWORD *)(v808 + 80) ^ (unsigned int)sub_10B364(v809 + 80)) + (_DWORD)v388) << 21;
  v389 = sub_10B364(v809 + 8);
  v390 = *(_QWORD *)(v808 + 8);
  v391 = (v389 ^ v390) + (*(_QWORD *)(v808 + 24) ^ sub_10B364(v809 + 24));
  v392 = v391 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v393 = v392 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v394 = (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80)) + v393;
  v773 = v394 >> 11;
  v822 = __PAIR64__(
           HIDWORD(v373) ^ HIDWORD(v774) ^ (v655 | (HIDWORD(v394) >> 11)),
           (unsigned int)v373 ^ (unsigned int)(v394 >> 11))
       + *(_QWORD *)(v808 + 104);
  v395 = sub_10B364(v809 + 16);
  v396 = *(_QWORD *)(v808 + 16);
  v397 = (v395 ^ v396) + (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v398 = v397 + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v399 = v398 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v772 = ((*(_QWORD *)(v808 + 88) ^ (unsigned __int64)sub_10B364(v809 + 88)) + v399) >> 2;
  v400 = sub_10B364(v809 + 16);
  v401 = *(_QWORD *)(v808 + 16);
  v402 = (v400 ^ v401) + (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v403 = v402 + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v404 = v403 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v771 = 4 * ((*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88)) + v404);
  v405 = sub_10B364(v809 + 16);
  v406 = *(_QWORD *)(v808 + 16);
  v407 = (v405 ^ v406) + (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v408 = v407 + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v409 = v408 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v770 = ((*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88)) + v409) << 28;
  v410 = sub_10B364(v809 + 16);
  v411 = *(_QWORD *)(v808 + 16);
  v412 = (v410 ^ v411) + (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v413 = v412 + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v414 = v413 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  LODWORD(v373) = v772
                ^ v771
                ^ (v770
                 | ((unsigned int)(((*(_QWORD *)(v808 + 88) ^ (unsigned __int64)sub_10B364(v809 + 88)) + v414) >> 32) >> 4));
  v415 = sub_10B364(v809 + 16);
  v416 = *(_QWORD *)(v808 + 16);
  v417 = (v415 ^ v416) + (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v418 = v417 + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v419 = v418 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v654 = ((*(_DWORD *)(v808 + 88) ^ (unsigned int)sub_10B364(v809 + 88)) + (_DWORD)v419) << 27;
  v420 = sub_10B364(v809 + 16);
  v421 = *(_QWORD *)(v808 + 16);
  v422 = (v420 ^ v421) + (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v423 = v422 + (*(_QWORD *)(v808 + 56) ^ sub_10B364(v809 + 56));
  v424 = v423 + (*(_QWORD *)(v808 + 80) ^ sub_10B364(v809 + 80));
  v425 = (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88)) + v424;
  v769 = v425 >> 5;
  v823 = __PAIR64__(
           ((v772 ^ v771) >> 32) ^ HIDWORD(v770) ^ (v654 | (HIDWORD(v425) >> 5)),
           (unsigned int)v373 ^ (unsigned int)(v425 >> 5))
       + *(_QWORD *)(v808 + 112);
  v426 = sub_10B364(v809 + 24);
  v427 = *(_QWORD *)(v808 + 24);
  v428 = (v426 ^ v427) - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v429 = v428 + (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v430 = v429 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v431 = (v430 - (*(_QWORD *)(v808 + 96) ^ (unsigned __int64)sub_10B364(v809 + 96))) >> 1;
  v432 = sub_10B364(v809 + 24);
  v433 = *(_QWORD *)(v808 + 24);
  v434 = (v432 ^ v433) - (*(_QWORD *)(v808 + 40) ^ sub_10B364(v809 + 40));
  v435 = v434 + (*(_QWORD *)(v808 + 64) ^ sub_10B364(v809 + 64));
  v436 = v435 - (*(_QWORD *)(v808 + 88) ^ sub_10B364(v809 + 88));
  v824 = (v431 ^ (v436 - (*(_QWORD *)(v808 + 96) ^ sub_10B364(v809 + 96)))) + *(_QWORD *)(v808 + 120);
  v437 = sub_10B364(v809 + 96);
  v438 = *(_QWORD *)(v808 + 96);
  v439 = (v437 ^ v438) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v440 = v439 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v441 = v440 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v442 = ((*(_QWORD *)(v808 + 104) ^ (unsigned __int64)sub_10B364(v809 + 104)) + v441) >> 1;
  v443 = sub_10B364(v809 + 96);
  v444 = *(_QWORD *)(v808 + 96);
  v445 = (v443 ^ v444) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v446 = v445 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v447 = v446 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v768 = 8 * ((*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v447);
  v448 = v768 ^ v442;
  v449 = sub_10B364(v809 + 96);
  v450 = *(_QWORD *)(v808 + 96);
  v451 = (v449 ^ v450) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v452 = v451 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v453 = v452 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v767 = 16 * ((*(_QWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v453);
  v454 = sub_10B364(v809 + 96);
  v455 = *(_QWORD *)(v808 + 96);
  v456 = (v454 ^ v455) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v457 = v456 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v458 = v457 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  LODWORD(v448) = v448
                ^ (v767
                 | ((unsigned int)(((*(_QWORD *)(v808 + 104) ^ (unsigned __int64)sub_10B364(v809 + 104)) + v458) >> 32) >> 28));
  HIDWORD(v448) ^= HIDWORD(v767);
  v459 = sub_10B364(v809 + 96);
  v460 = *(_QWORD *)(v808 + 96);
  v461 = (v459 ^ v460) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v462 = v461 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v463 = v462 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  HIDWORD(v653) = 32 * ((*(_DWORD *)(v808 + 104) ^ sub_10B364(v809 + 104)) + v463);
  LODWORD(v653) = 0;
  v464 = sub_10B364(v809 + 96);
  v465 = *(_QWORD *)(v808 + 96);
  v466 = (v464 ^ v465) - (*(_QWORD *)(v808 + 32) ^ sub_10B364(v809 + 32));
  v467 = v466 - (*(_QWORD *)(v808 + 48) ^ sub_10B364(v809 + 48));
  v468 = v467 - (*(_QWORD *)(v808 + 72) ^ sub_10B364(v809 + 72));
  v766 = ((*(_QWORD *)(v808 + 104) ^ (unsigned __int64)sub_10B364(v809 + 104)) + v468) >> 27;
  v825 = (v448 ^ (v653 | v766)) + *(_QWORD *)v808;
  v765 = 4 * v810;
  LODWORD(v448) = (v810 >> 21) ^ (((_DWORD)v810 << 13) | (HIDWORD(v810) >> 19)) ^ (4 * v810) ^ (v810 >> 1);
  HIDWORD(v448) = ((HIDWORD(v810) >> 21) | ((_DWORD)v810 << 11))
                ^ (v810 >> 19)
                ^ ((unsigned __int64)v810 >> 30)
                ^ (HIDWORD(v810) >> 1);
  v764 = (unsigned __int64)v811 >> 2;
  HIDWORD(v652) = v811 >> 13;
  LODWORD(v652) = ((_DWORD)v811 << 19) | (HIDWORD(v811) >> 13);
  LODWORD(v651) = v811 >> 11;
  HIDWORD(v651) = (HIDWORD(v811) >> 11) | ((_DWORD)v811 << 21);
  v763 = (unsigned __int64)v812 >> 2;
  v762 = 4 * v812;
  HIDWORD(v650) = v812 >> 4;
  LODWORD(v650) = ((_DWORD)v812 << 28) | (HIDWORD(v812) >> 4);
  LODWORD(v649) = v812 >> 5;
  HIDWORD(v649) = (HIDWORD(v812) >> 5) | ((_DWORD)v812 << 27);
  v761 = 8 * v813;
  v648 = v813 >> 28;
  v647 = (16 * v813) | (HIDWORD(v813) >> 28);
  v645 = v813 >> 27;
  v646 = (HIDWORD(v813) >> 27) | (32 * v813);
  v760 = 4 * v814;
  v644 = v814 >> 19;
  v643 = ((_DWORD)v814 << 13) | (HIDWORD(v814) >> 19);
  v641 = v814 >> 21;
  v642 = (HIDWORD(v814) >> 21) | ((_DWORD)v814 << 11);
  v759 = (unsigned __int64)v815 >> 2;
  HIDWORD(v640) = v815 >> 13;
  LODWORD(v640) = ((_DWORD)v815 << 19) | (HIDWORD(v815) >> 13);
  LODWORD(v639) = v815 >> 11;
  HIDWORD(v639) = (HIDWORD(v815) >> 11) | ((_DWORD)v815 << 21);
  v758 = (unsigned __int64)v816 >> 2;
  v757 = 4 * v816;
  HIDWORD(v638) = v816 >> 4;
  LODWORD(v638) = ((_DWORD)v816 << 28) | (HIDWORD(v816) >> 4);
  LODWORD(v637) = v816 >> 5;
  HIDWORD(v637) = (HIDWORD(v816) >> 5) | ((_DWORD)v816 << 27);
  v756 = 8 * v817;
  v636 = v817 >> 28;
  v635 = (16 * v817) | (HIDWORD(v817) >> 28);
  v633 = v817 >> 27;
  v634 = (HIDWORD(v817) >> 27) | (32 * v817);
  v755 = 4 * v818;
  v632 = v818 >> 19;
  v631 = ((_DWORD)v818 << 13) | (HIDWORD(v818) >> 19);
  v629 = v818 >> 21;
  v630 = (HIDWORD(v818) >> 21) | ((_DWORD)v818 << 11);
  v754 = (unsigned __int64)v819 >> 2;
  HIDWORD(v628) = v819 >> 13;
  LODWORD(v628) = ((_DWORD)v819 << 19) | (HIDWORD(v819) >> 13);
  LODWORD(v627) = v819 >> 11;
  HIDWORD(v627) = (HIDWORD(v819) >> 11) | ((_DWORD)v819 << 21);
  v753 = (unsigned __int64)v820 >> 2;
  v752 = 4 * v820;
  HIDWORD(v626) = v820 >> 4;
  LODWORD(v626) = ((_DWORD)v820 << 28) | (HIDWORD(v820) >> 4);
  LODWORD(v625) = v820 >> 5;
  HIDWORD(v625) = (HIDWORD(v820) >> 5) | ((_DWORD)v820 << 27);
  v751 = 8 * v821;
  v624 = v821 >> 28;
  v623 = (16 * v821) | (HIDWORD(v821) >> 28);
  LODWORD(v622) = v821 >> 27;
  HIDWORD(v622) = (HIDWORD(v821) >> 27) | (32 * v821);
  v750 = 4 * v822;
  v621 = v822 >> 19;
  v620 = ((_DWORD)v822 << 13) | (HIDWORD(v822) >> 19);
  v619 = (HIDWORD(v822) >> 21) | ((_DWORD)v822 << 11);
  v749 = (unsigned __int64)v823 >> 2;
  HIDWORD(v618) = v823 >> 13;
  LODWORD(v618) = ((_DWORD)v823 << 19) | (HIDWORD(v823) >> 13);
  LODWORD(v617) = v823 >> 11;
  HIDWORD(v617) = (HIDWORD(v823) >> 11) | ((_DWORD)v823 << 21);
  v748 = (unsigned __int64)v824 >> 2;
  v747 = 4 * v824;
  HIDWORD(v616) = v824 >> 4;
  LODWORD(v616) = ((_DWORD)v824 << 28) | (HIDWORD(v824) >> 4);
  LODWORD(v615) = v824 >> 5;
  HIDWORD(v615) = (HIDWORD(v824) >> 5) | ((_DWORD)v824 << 27);
  v469 = v448
       + (v651 ^ v652 ^ ((unsigned __int64)v811 >> 2) ^ (2 * v811))
       + (v649 ^ v650 ^ ((unsigned __int64)v812 >> 2) ^ (4 * v812))
       + __PAIR64__(
           v646 ^ v648 ^ ((unsigned __int64)v813 >> 29) ^ (HIDWORD(v813) >> 1),
           v645 ^ v647 ^ (8 * v813) ^ (v813 >> 1))
       + __PAIR64__(
           v642 ^ v644 ^ (unsigned int)((unsigned __int64)v814 >> 30) ^ (HIDWORD(v814) >> 1),
           v641 ^ v643 ^ (4 * v814) ^ (v814 >> 1))
       + (v639 ^ v640 ^ ((unsigned __int64)v815 >> 2) ^ (2 * v815))
       + (v637 ^ v638 ^ ((unsigned __int64)v816 >> 2) ^ (4 * v816))
       + __PAIR64__(
           v634 ^ v636 ^ ((unsigned __int64)v817 >> 29) ^ (HIDWORD(v817) >> 1),
           v633 ^ v635 ^ (8 * v817) ^ (v817 >> 1))
       + __PAIR64__(
           v630 ^ v632 ^ (unsigned int)((unsigned __int64)v818 >> 30) ^ (HIDWORD(v818) >> 1),
           v629 ^ v631 ^ (4 * v818) ^ (v818 >> 1))
       + (v627 ^ v628 ^ ((unsigned __int64)v819 >> 2) ^ (2 * v819))
       + (v625 ^ v626 ^ ((unsigned __int64)v820 >> 2) ^ (4 * v820))
       + __PAIR64__(
           HIDWORD(v622) ^ v624 ^ (unsigned int)((unsigned __int64)v821 >> 29) ^ (HIDWORD(v821) >> 1),
           v622 ^ v623 ^ (8 * v821) ^ (v821 >> 1))
       + __PAIR64__(
           v619 ^ v621 ^ (unsigned int)((unsigned __int64)v822 >> 30) ^ (HIDWORD(v822) >> 1),
           (v822 >> 21) ^ v620 ^ (4 * v822) ^ (v822 >> 1))
       + (v617 ^ v618 ^ ((unsigned __int64)v823 >> 2) ^ (2 * v823))
       + (v615 ^ v616 ^ ((unsigned __int64)v824 >> 2) ^ (4 * v824));
  v746 = 8 * v825;
  v470 = sub_10B364(v809);
  v471 = v470 >> 31;
  v472 = ((unsigned int)((unsigned __int64)sub_10B364(v809) >> 32) >> 31) | (2 * v470);
  v745 = 16 * sub_10B364(v809 + 24);
  v473 = __PAIR64__(v471, v472) + (v745 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 24) >> 32) >> 28));
  v744 = sub_10B364(v809 + 80) << 11;
  v826 = v469
       + __PAIR64__(
           ((HIDWORD(v825) >> 27) | (32 * v825)) ^ (v825 >> 28) ^ ((unsigned __int64)v825 >> 29) ^ (HIDWORD(v825) >> 1),
           (v825 >> 27) ^ ((16 * v825) | (HIDWORD(v825) >> 28)) ^ (8 * v825) ^ (v825 >> 1))
       + (*(_QWORD *)(v808 + 56)
        ^ (v473 - (v744 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 80) >> 32) >> 21)) + 0x5555555555555550LL));
  v743 = 4 * v811;
  LODWORD(v469) = (v811 >> 21) ^ (((_DWORD)v811 << 13) | (HIDWORD(v811) >> 19)) ^ (4 * v811) ^ (v811 >> 1);
  HIDWORD(v469) = ((HIDWORD(v811) >> 21) | ((_DWORD)v811 << 11))
                ^ (v811 >> 19)
                ^ ((unsigned __int64)v811 >> 30)
                ^ (HIDWORD(v811) >> 1);
  v742 = (unsigned __int64)v812 >> 2;
  HIDWORD(v614) = v812 >> 13;
  LODWORD(v614) = ((_DWORD)v812 << 19) | (HIDWORD(v812) >> 13);
  LODWORD(v613) = v812 >> 11;
  HIDWORD(v613) = (HIDWORD(v812) >> 11) | ((_DWORD)v812 << 21);
  v741 = (unsigned __int64)v813 >> 2;
  v740 = 4 * v813;
  HIDWORD(v612) = v813 >> 4;
  LODWORD(v612) = ((_DWORD)v813 << 28) | (HIDWORD(v813) >> 4);
  LODWORD(v611) = v813 >> 5;
  HIDWORD(v611) = (HIDWORD(v813) >> 5) | ((_DWORD)v813 << 27);
  v739 = 8 * v814;
  v610 = v814 >> 28;
  v609 = (16 * v814) | (HIDWORD(v814) >> 28);
  v607 = v814 >> 27;
  v608 = (HIDWORD(v814) >> 27) | (32 * v814);
  v738 = 4 * v815;
  v606 = v815 >> 19;
  v605 = ((_DWORD)v815 << 13) | (HIDWORD(v815) >> 19);
  v603 = v815 >> 21;
  v604 = (HIDWORD(v815) >> 21) | ((_DWORD)v815 << 11);
  v737 = (unsigned __int64)v816 >> 2;
  HIDWORD(v602) = v816 >> 13;
  LODWORD(v602) = ((_DWORD)v816 << 19) | (HIDWORD(v816) >> 13);
  LODWORD(v601) = v816 >> 11;
  HIDWORD(v601) = (HIDWORD(v816) >> 11) | ((_DWORD)v816 << 21);
  v736 = (unsigned __int64)v817 >> 2;
  v735 = 4 * v817;
  HIDWORD(v600) = v817 >> 4;
  LODWORD(v600) = ((_DWORD)v817 << 28) | (HIDWORD(v817) >> 4);
  LODWORD(v599) = v817 >> 5;
  HIDWORD(v599) = (HIDWORD(v817) >> 5) | ((_DWORD)v817 << 27);
  v734 = 8 * v818;
  v598 = v818 >> 28;
  v597 = (16 * v818) | (HIDWORD(v818) >> 28);
  v595 = v818 >> 27;
  v596 = (HIDWORD(v818) >> 27) | (32 * v818);
  v733 = 4 * v819;
  v594 = v819 >> 19;
  v593 = ((_DWORD)v819 << 13) | (HIDWORD(v819) >> 19);
  v591 = v819 >> 21;
  v592 = (HIDWORD(v819) >> 21) | ((_DWORD)v819 << 11);
  v732 = (unsigned __int64)v820 >> 2;
  HIDWORD(v590) = v820 >> 13;
  LODWORD(v590) = ((_DWORD)v820 << 19) | (HIDWORD(v820) >> 13);
  LODWORD(v589) = v820 >> 11;
  HIDWORD(v589) = (HIDWORD(v820) >> 11) | ((_DWORD)v820 << 21);
  v731 = (unsigned __int64)v821 >> 2;
  v730 = 4 * v821;
  HIDWORD(v588) = v821 >> 4;
  LODWORD(v588) = ((_DWORD)v821 << 28) | (HIDWORD(v821) >> 4);
  LODWORD(v587) = v821 >> 5;
  HIDWORD(v587) = (HIDWORD(v821) >> 5) | ((_DWORD)v821 << 27);
  v729 = 8 * v822;
  v586 = v822 >> 28;
  v585 = (16 * v822) | (HIDWORD(v822) >> 28);
  LODWORD(v584) = v822 >> 27;
  HIDWORD(v584) = (HIDWORD(v822) >> 27) | (32 * v822);
  v728 = 4 * v823;
  v583 = v823 >> 19;
  v582 = ((_DWORD)v823 << 13) | (HIDWORD(v823) >> 19);
  v581 = (HIDWORD(v823) >> 21) | ((_DWORD)v823 << 11);
  v727 = (unsigned __int64)v824 >> 2;
  HIDWORD(v580) = v824 >> 13;
  LODWORD(v580) = ((_DWORD)v824 << 19) | (HIDWORD(v824) >> 13);
  LODWORD(v579) = v824 >> 11;
  HIDWORD(v579) = (HIDWORD(v824) >> 11) | ((_DWORD)v824 << 21);
  v726 = (unsigned __int64)v825 >> 2;
  v725 = 4 * v825;
  HIDWORD(v578) = v825 >> 4;
  LODWORD(v578) = ((_DWORD)v825 << 28) | (HIDWORD(v825) >> 4);
  LODWORD(v577) = v825 >> 5;
  HIDWORD(v577) = (HIDWORD(v825) >> 5) | ((_DWORD)v825 << 27);
  v474 = v469
       + (v613 ^ v614 ^ ((unsigned __int64)v812 >> 2) ^ (2 * v812))
       + (v611 ^ v612 ^ ((unsigned __int64)v813 >> 2) ^ (4 * v813))
       + __PAIR64__(
           v608 ^ v610 ^ ((unsigned __int64)v814 >> 29) ^ (HIDWORD(v814) >> 1),
           v607 ^ v609 ^ (8 * v814) ^ (v814 >> 1))
       + __PAIR64__(
           v604 ^ v606 ^ (unsigned int)((unsigned __int64)v815 >> 30) ^ (HIDWORD(v815) >> 1),
           v603 ^ v605 ^ (4 * v815) ^ (v815 >> 1))
       + (v601 ^ v602 ^ ((unsigned __int64)v816 >> 2) ^ (2 * v816))
       + (v599 ^ v600 ^ ((unsigned __int64)v817 >> 2) ^ (4 * v817))
       + __PAIR64__(
           v596 ^ v598 ^ ((unsigned __int64)v818 >> 29) ^ (HIDWORD(v818) >> 1),
           v595 ^ v597 ^ (8 * v818) ^ (v818 >> 1))
       + __PAIR64__(
           v592 ^ v594 ^ (unsigned int)((unsigned __int64)v819 >> 30) ^ (HIDWORD(v819) >> 1),
           v591 ^ v593 ^ (4 * v819) ^ (v819 >> 1))
       + (v589 ^ v590 ^ ((unsigned __int64)v820 >> 2) ^ (2 * v820))
       + (v587 ^ v588 ^ ((unsigned __int64)v821 >> 2) ^ (4 * v821))
       + __PAIR64__(
           HIDWORD(v584) ^ v586 ^ (unsigned int)((unsigned __int64)v822 >> 29) ^ (HIDWORD(v822) >> 1),
           v584 ^ v585 ^ (8 * v822) ^ (v822 >> 1))
       + __PAIR64__(
           v581 ^ v583 ^ (unsigned int)((unsigned __int64)v823 >> 30) ^ (HIDWORD(v823) >> 1),
           (v823 >> 21) ^ v582 ^ (4 * v823) ^ (v823 >> 1))
       + (v579 ^ v580 ^ ((unsigned __int64)v824 >> 2) ^ (2 * v824))
       + (v577 ^ v578 ^ ((unsigned __int64)v825 >> 2) ^ (4 * v825));
  v724 = 8 * v826;
  v723 = 4 * sub_10B364(v809 + 8);
  v475 = v723 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 8) >> 32) >> 30);
  v722 = 32 * sub_10B364(v809 + 32);
  v476 = __PAIR64__(HIDWORD(v723), v475)
       + (v722 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 32) >> 32) >> 27));
  v721 = sub_10B364(v809 + 88) << 12;
  v827 = v474
       + __PAIR64__(
           ((HIDWORD(v826) >> 27) | (32 * v826)) ^ (v826 >> 28) ^ ((unsigned __int64)v826 >> 29) ^ (HIDWORD(v826) >> 1),
           (v826 >> 27) ^ ((16 * v826) | (HIDWORD(v826) >> 28)) ^ (8 * v826) ^ (v826 >> 1))
       + (*(_QWORD *)(v808 + 64)
        ^ (loc_112928 + v476 - (v721 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 88) >> 32) >> 20))));
  LODWORD(v576) = v823 >> 21;
  HIDWORD(v576) = v581;
  LODWORD(v575) = v825 >> 11;
  HIDWORD(v575) = (HIDWORD(v825) >> 11) | ((_DWORD)v825 << 21);
  v720 = (unsigned __int64)v827 >> 2;
  v719 = 8 * sub_10B364(v809 + 16);
  v477 = v719 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 16) >> 32) >> 29);
  v718 = sub_10B364(v809 + 40) << 6;
  v478 = __PAIR64__(HIDWORD(v719), v477)
       + (v718 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 40) >> 32) >> 26));
  v717 = sub_10B364(v809 + 96) << 13;
  v479 = sub_10B364(v809 + 96);
  v828 = v575
       + v576
       + v622
       + __PAIR64__(v819, HIDWORD(v819))
       + __PAIR64__(v599, HIDWORD(v599))
       + __PAIR64__(v603, v604)
       + __PAIR64__(v645, v646)
       + v812
       + v814
       + v816
       + v818
       + v820
       + v822
       + v824
       + __PAIR64__(HIDWORD(v826) ^ (HIDWORD(v826) >> 1), (unsigned int)v826 ^ (unsigned int)(v826 >> 1))
       + (((unsigned __int64)v827 >> 2) ^ v827)
       + __PAIR64__(
           *(_DWORD *)(v808 + 76)
         ^ (unsigned int)(((v478 - (v717 | (HIDWORD(v479) >> 19))) >> 32)
                        - (((unsigned int)v478 - ((unsigned int)v717 | (HIDWORD(v479) >> 19)) < 6)
                         - 1610612736)),
           *(_DWORD *)(v808 + 72) ^ (v478 - (v717 | (HIDWORD(v479) >> 19)) - 6));
  HIDWORD(v574) = v816 >> 21;
  LODWORD(v574) = ((_DWORD)v816 << 11) | (HIDWORD(v816) >> 21);
  HIDWORD(v573) = v818 >> 5;
  LODWORD(v573) = ((_DWORD)v818 << 27) | (HIDWORD(v818) >> 5);
  LODWORD(v572) = v824 >> 21;
  HIDWORD(v572) = (HIDWORD(v824) >> 21) | ((_DWORD)v824 << 11);
  LODWORD(v571) = v826 >> 11;
  HIDWORD(v571) = (HIDWORD(v826) >> 11) | ((_DWORD)v826 << 21);
  v716 = (unsigned __int64)v828 >> 2;
  v715 = 16 * sub_10B364(v809 + 24);
  v480 = v715 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 24) >> 32) >> 28);
  v714 = sub_10B364(v809 + 48) << 7;
  v481 = __PAIR64__(HIDWORD(v715), v480)
       + (v714 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 48) >> 32) >> 25));
  v713 = sub_10B364(v809 + 104) << 14;
  v829 = v571
       + v572
       + v584
       + __PAIR64__(v820, HIDWORD(v820))
       + v573
       + v574
       + __PAIR64__(v607, v608)
       + v813
       + v815
       + v817
       + v819
       + v821
       + v823
       + v825
       + __PAIR64__(HIDWORD(v827) ^ (HIDWORD(v827) >> 1), (unsigned int)v827 ^ (unsigned int)(v827 >> 1))
       + (((unsigned __int64)v828 >> 2) ^ v828)
       + (*(_QWORD *)(v808 + 80)
        ^ (loc_112930 + v481 - (v713 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 104) >> 32) >> 18))));
  HIDWORD(v570) = v815 >> 27;
  LODWORD(v570) = (32 * v815) | (HIDWORD(v815) >> 27);
  HIDWORD(v569) = v817 >> 21;
  LODWORD(v569) = ((_DWORD)v817 << 11) | (HIDWORD(v817) >> 21);
  HIDWORD(v568) = v819 >> 5;
  LODWORD(v568) = ((_DWORD)v819 << 27) | (HIDWORD(v819) >> 5);
  LODWORD(v567) = v823 >> 27;
  HIDWORD(v567) = (HIDWORD(v823) >> 27) | (32 * v823);
  LODWORD(v566) = v825 >> 21;
  HIDWORD(v566) = (HIDWORD(v825) >> 21) | ((_DWORD)v825 << 11);
  LODWORD(v565) = v827 >> 11;
  HIDWORD(v565) = (HIDWORD(v827) >> 11) | ((_DWORD)v827 << 21);
  v712 = (unsigned __int64)v829 >> 2;
  v711 = 32 * sub_10B364(v809 + 32);
  v482 = v711 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 32) >> 32) >> 27);
  v710 = sub_10B364(v809 + 56) << 8;
  v483 = __PAIR64__(HIDWORD(v711), v482)
       + (v710 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 56) >> 32) >> 24));
  v709 = sub_10B364(v809 + 112) << 15;
  v830 = v565
       + v566
       + v567
       + __PAIR64__(v821, HIDWORD(v821))
       + v568
       + v569
       + v570
       + v814
       + v816
       + v818
       + v820
       + v822
       + v824
       + v826
       + __PAIR64__(HIDWORD(v828) ^ (HIDWORD(v828) >> 1), (unsigned int)v828 ^ (unsigned int)(v828 >> 1))
       + (((unsigned __int64)v829 >> 2) ^ v829)
       + (*(_QWORD *)(v808 + 88)
        ^ (loc_112938 + v483 - (v709 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 112) >> 32) >> 17))));
  HIDWORD(v564) = v816 >> 27;
  LODWORD(v564) = (32 * v816) | (HIDWORD(v816) >> 27);
  LODWORD(v563) = v824 >> 27;
  HIDWORD(v563) = (HIDWORD(v824) >> 27) | (32 * v824);
  LODWORD(v562) = v826 >> 21;
  HIDWORD(v562) = (HIDWORD(v826) >> 21) | ((_DWORD)v826 << 11);
  LODWORD(v561) = v828 >> 11;
  HIDWORD(v561) = (HIDWORD(v828) >> 11) | ((_DWORD)v828 << 21);
  v708 = (unsigned __int64)v830 >> 2;
  v707 = sub_10B364(v809 + 40) << 6;
  v484 = v707 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 40) >> 32) >> 26);
  v706 = sub_10B364(v809 + 64) << 9;
  v485 = __PAIR64__(HIDWORD(v707), v484)
       + (v706 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 64) >> 32) >> 23));
  v705 = sub_10B364(v809 + 120) << 16;
  v560 = (unsigned int)((unsigned __int64)sub_10B364(v809 + 120) >> 32) >> 16;
  v831 = v561
       + v562
       + v563
       + __PAIR64__(v822, HIDWORD(v822))
       + __PAIR64__(v625, HIDWORD(v625))
       + __PAIR64__(v629, v630)
       + v564
       + v815
       + v817
       + v819
       + v821
       + v823
       + v825
       + v827
       + __PAIR64__(HIDWORD(v829) ^ (HIDWORD(v829) >> 1), (unsigned int)v829 ^ (unsigned int)(v829 >> 1))
       + (((unsigned __int64)v830 >> 2) ^ v830)
       + __PAIR64__(
           *(_DWORD *)(v808 + 100)
         ^ (unsigned int)(((v485 - (v705 | v560)) >> 32)
                        - (((unsigned int)v485 - ((unsigned int)v705 | (unsigned int)v560) < 7)
                         - 1879048192)),
           *(_DWORD *)(v808 + 96) ^ (v485 - (v705 | v560) - 7));
  LODWORD(v559) = v825 >> 27;
  HIDWORD(v559) = (HIDWORD(v825) >> 27) | (32 * v825);
  LODWORD(v558) = v827 >> 21;
  HIDWORD(v558) = (HIDWORD(v827) >> 21) | ((_DWORD)v827 << 11);
  LODWORD(v557) = v829 >> 11;
  HIDWORD(v557) = (HIDWORD(v829) >> 11) | ((_DWORD)v829 << 21);
  v704 = (unsigned __int64)v831 >> 2;
  v703 = sub_10B364(v809 + 48) << 7;
  v486 = v703 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 48) >> 32) >> 25);
  v702 = sub_10B364(v809 + 72) << 10;
  v487 = __PAIR64__(HIDWORD(v703), v486)
       + (v702 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 72) >> 32) >> 22));
  v488 = sub_10B364(v809);
  v832 = v557
       + v558
       + v559
       + __PAIR64__(v823, HIDWORD(v823))
       + __PAIR64__(v587, HIDWORD(v587))
       + __PAIR64__(v591, v592)
       + __PAIR64__(v633, v634)
       + v816
       + v818
       + v820
       + v822
       + v824
       + v826
       + v828
       + __PAIR64__(HIDWORD(v830) ^ (HIDWORD(v830) >> 1), (unsigned int)v830 ^ (unsigned int)(v830 >> 1))
       + (((unsigned __int64)v831 >> 2) ^ v831)
       + (*(_QWORD *)(v808 + 104)
        ^ (loc_113968 + v487 - ((2 * v488) | ((unsigned int)((unsigned __int64)sub_10B364(v809) >> 32) >> 31))));
  HIDWORD(v556) = v820 >> 21;
  LODWORD(v556) = ((_DWORD)v820 << 11) | (HIDWORD(v820) >> 21);
  HIDWORD(v555) = v822 >> 5;
  LODWORD(v555) = ((_DWORD)v822 << 27) | (HIDWORD(v822) >> 5);
  LODWORD(v554) = v826 >> 27;
  HIDWORD(v554) = (HIDWORD(v826) >> 27) | (32 * v826);
  LODWORD(v553) = v828 >> 21;
  HIDWORD(v553) = (HIDWORD(v828) >> 21) | ((_DWORD)v828 << 11);
  LODWORD(v552) = v830 >> 11;
  HIDWORD(v552) = (HIDWORD(v830) >> 11) | ((_DWORD)v830 << 21);
  v701 = (unsigned __int64)v832 >> 2;
  v700 = sub_10B364(v809 + 56) << 8;
  v489 = v700 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 56) >> 32) >> 24);
  v699 = sub_10B364(v809 + 80) << 11;
  v490 = __PAIR64__(HIDWORD(v700), v489)
       + (v699 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 80) >> 32) >> 21));
  v698 = 4 * sub_10B364(v809 + 8);
  v833 = v552
       + v553
       + v554
       + __PAIR64__(v824, HIDWORD(v824))
       + v555
       + v556
       + __PAIR64__(v595, v596)
       + v817
       + v819
       + v821
       + v823
       + v825
       + v827
       + v829
       + __PAIR64__(HIDWORD(v831) ^ (HIDWORD(v831) >> 1), (unsigned int)v831 ^ (unsigned int)(v831 >> 1))
       + (((unsigned __int64)v832 >> 2) ^ v832)
       + (*(_QWORD *)(v808 + 112)
        ^ (loc_113970 + v490 - (v698 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 8) >> 32) >> 30))));
  HIDWORD(v551) = v819 >> 27;
  LODWORD(v551) = (32 * v819) | (HIDWORD(v819) >> 27);
  HIDWORD(v550) = v821 >> 21;
  LODWORD(v550) = ((_DWORD)v821 << 11) | (HIDWORD(v821) >> 21);
  HIDWORD(v549) = v823 >> 5;
  LODWORD(v549) = ((_DWORD)v823 << 27) | (HIDWORD(v823) >> 5);
  LODWORD(v548) = v827 >> 27;
  HIDWORD(v548) = (HIDWORD(v827) >> 27) | (32 * v827);
  LODWORD(v547) = v829 >> 21;
  HIDWORD(v547) = (HIDWORD(v829) >> 21) | ((_DWORD)v829 << 11);
  LODWORD(v546) = v831 >> 11;
  HIDWORD(v546) = (HIDWORD(v831) >> 11) | ((_DWORD)v831 << 21);
  v697 = (unsigned __int64)v833 >> 2;
  v696 = sub_10B364(v809 + 64) << 9;
  v491 = v696 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 64) >> 32) >> 23);
  v695 = sub_10B364(v809 + 88) << 12;
  v492 = __PAIR64__(HIDWORD(v696), v491)
       + (v695 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 88) >> 32) >> 20));
  v694 = 8 * sub_10B364(v809 + 16);
  v834 = v546
       + v547
       + v548
       + __PAIR64__(v825, HIDWORD(v825))
       + v549
       + v550
       + v551
       + v818
       + v820
       + v822
       + v824
       + v826
       + v828
       + v830
       + __PAIR64__(HIDWORD(v832) ^ (HIDWORD(v832) >> 1), (unsigned int)v832 ^ (unsigned int)(v832 >> 1))
       + (((unsigned __int64)v833 >> 2) ^ v833)
       + (*(_QWORD *)(v808 + 120)
        ^ (v492 - (v694 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 16) >> 32) >> 29)) + 0x7FFFFFFFFFFFFFF8LL));
  HIDWORD(v545) = v820 >> 27;
  LODWORD(v545) = (32 * v820) | (HIDWORD(v820) >> 27);
  HIDWORD(v544) = v822 >> 21;
  LODWORD(v544) = v619;
  LODWORD(v543) = v828 >> 27;
  HIDWORD(v543) = (HIDWORD(v828) >> 27) | (32 * v828);
  LODWORD(v542) = v830 >> 21;
  HIDWORD(v542) = (HIDWORD(v830) >> 21) | ((_DWORD)v830 << 11);
  LODWORD(v541) = v832 >> 11;
  HIDWORD(v541) = (HIDWORD(v832) >> 11) | ((_DWORD)v832 << 21);
  v693 = (unsigned __int64)v834 >> 2;
  v692 = sub_10B364(v809 + 72) << 10;
  v493 = v692 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 72) >> 32) >> 22);
  v691 = sub_10B364(v809 + 96) << 13;
  v494 = __PAIR64__(HIDWORD(v692), v493)
       + (v691 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 96) >> 32) >> 19));
  v690 = 16 * sub_10B364(v809 + 24);
  v835 = v541
       + v542
       + v543
       + __PAIR64__(v826, HIDWORD(v826))
       + __PAIR64__(v615, HIDWORD(v615))
       + v544
       + v545
       + v819
       + v821
       + v823
       + v825
       + v827
       + v829
       + v831
       + __PAIR64__(HIDWORD(v833) ^ (HIDWORD(v833) >> 1), (unsigned int)v833 ^ (unsigned int)(v833 >> 1))
       + (((unsigned __int64)v834 >> 2) ^ v834)
       + (*(_QWORD *)v808
        ^ (loc_113978 + v494 - (v690 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 24) >> 32) >> 28))));
  LODWORD(v540) = v829 >> 27;
  HIDWORD(v540) = (HIDWORD(v829) >> 27) | (32 * v829);
  LODWORD(v539) = v831 >> 21;
  HIDWORD(v539) = (HIDWORD(v831) >> 21) | ((_DWORD)v831 << 11);
  LODWORD(v538) = v833 >> 11;
  HIDWORD(v538) = (HIDWORD(v833) >> 11) | ((_DWORD)v833 << 21);
  v689 = (unsigned __int64)v835 >> 2;
  v688 = sub_10B364(v809 + 80) << 11;
  v495 = v688 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 80) >> 32) >> 21);
  v687 = sub_10B364(v809 + 104) << 14;
  v496 = __PAIR64__(HIDWORD(v688), v495)
       + (v687 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 104) >> 32) >> 18));
  v686 = 32 * sub_10B364(v809 + 32);
  v836 = v538
       + v539
       + v540
       + __PAIR64__(v827, HIDWORD(v827))
       + __PAIR64__(v577, HIDWORD(v577))
       + __PAIR64__(v576, v581)
       + __PAIR64__(v622, HIDWORD(v622))
       + v820
       + v822
       + v824
       + v826
       + v828
       + v830
       + v832
       + __PAIR64__(HIDWORD(v834) ^ (HIDWORD(v834) >> 1), (unsigned int)v834 ^ (unsigned int)(v834 >> 1))
       + (((unsigned __int64)v835 >> 2) ^ v835)
       + (*(_QWORD *)(v808 + 8)
        ^ (loc_114688 + v496 - (v686 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 32) >> 32) >> 27))));
  HIDWORD(v537) = v826 >> 5;
  LODWORD(v537) = ((_DWORD)v826 << 27) | (HIDWORD(v826) >> 5);
  LODWORD(v536) = v830 >> 27;
  HIDWORD(v536) = (HIDWORD(v830) >> 27) | (32 * v830);
  LODWORD(v535) = v832 >> 21;
  HIDWORD(v535) = (HIDWORD(v832) >> 21) | ((_DWORD)v832 << 11);
  LODWORD(v534) = v834 >> 11;
  HIDWORD(v534) = (HIDWORD(v834) >> 11) | ((_DWORD)v834 << 21);
  v685 = (unsigned __int64)v836 >> 2;
  v684 = sub_10B364(v809 + 88) << 12;
  v497 = v684 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 88) >> 32) >> 20);
  v683 = sub_10B364(v809 + 112) << 15;
  v498 = __PAIR64__(HIDWORD(v684), v497)
       + (v683 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 112) >> 32) >> 17));
  v682 = sub_10B364(v809 + 40) << 6;
  v837 = v534
       + v535
       + v536
       + __PAIR64__(v828, HIDWORD(v828))
       + v537
       + __PAIR64__(v572, HIDWORD(v572))
       + __PAIR64__(v584, HIDWORD(v584))
       + v821
       + v823
       + v825
       + v827
       + v829
       + v831
       + v833
       + __PAIR64__(HIDWORD(v835) ^ (HIDWORD(v835) >> 1), (unsigned int)v835 ^ (unsigned int)(v835 >> 1))
       + (((unsigned __int64)v836 >> 2) ^ v836)
       + (*(_QWORD *)(v808 + 16)
        ^ (v498 - (v682 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 40) >> 32) >> 26)) - 0x7000000000000009LL));
  HIDWORD(v533) = v827 >> 5;
  LODWORD(v533) = ((_DWORD)v827 << 27) | (HIDWORD(v827) >> 5);
  LODWORD(v532) = v831 >> 27;
  HIDWORD(v532) = (HIDWORD(v831) >> 27) | (32 * v831);
  LODWORD(v531) = v833 >> 21;
  HIDWORD(v531) = (HIDWORD(v833) >> 21) | ((_DWORD)v833 << 11);
  LODWORD(v530) = v835 >> 11;
  HIDWORD(v530) = (HIDWORD(v835) >> 11) | ((_DWORD)v835 << 21);
  v681 = (unsigned __int64)v837 >> 2;
  v680 = sub_10B364(v809 + 96) << 13;
  v499 = v680 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 96) >> 32) >> 19);
  v679 = sub_10B364(v809 + 120) << 16;
  v500 = __PAIR64__(HIDWORD(v680), v499)
       + (v679 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 120) >> 32) >> 16));
  v678 = sub_10B364(v809 + 48) << 7;
  v838 = v530
       + v531
       + v532
       + __PAIR64__(v829, HIDWORD(v829))
       + v533
       + __PAIR64__(v566, HIDWORD(v566))
       + __PAIR64__(v567, HIDWORD(v567))
       + v822
       + v824
       + v826
       + v828
       + v830
       + v832
       + v834
       + __PAIR64__(HIDWORD(v836) ^ (HIDWORD(v836) >> 1), (unsigned int)v836 ^ (unsigned int)(v836 >> 1))
       + (((unsigned __int64)v837 >> 2) ^ v837)
       + (*(_QWORD *)(v808 + 24)
        ^ (loc_114690 + v500 - (v678 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 48) >> 32) >> 25))));
  HIDWORD(v529) = v828 >> 5;
  LODWORD(v529) = ((_DWORD)v828 << 27) | (HIDWORD(v828) >> 5);
  LODWORD(v528) = v832 >> 27;
  HIDWORD(v528) = (HIDWORD(v832) >> 27) | (32 * v832);
  LODWORD(v527) = v834 >> 21;
  HIDWORD(v527) = (HIDWORD(v834) >> 21) | ((_DWORD)v834 << 11);
  LODWORD(v526) = v836 >> 11;
  HIDWORD(v526) = (HIDWORD(v836) >> 11) | ((_DWORD)v836 << 21);
  v677 = (unsigned __int64)v838 >> 2;
  v676 = sub_10B364(v809 + 104) << 14;
  v501 = v676 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 104) >> 32) >> 18);
  v502 = sub_10B364(v809);
  v503 = v501 + ((2 * v502) | ((unsigned int)((unsigned __int64)sub_10B364(v809) >> 32) >> 31));
  v675 = sub_10B364(v809 + 56) << 8;
  v839 = v526
       + v527
       + v528
       + __PAIR64__(v830, HIDWORD(v830))
       + v529
       + __PAIR64__(v562, HIDWORD(v562))
       + __PAIR64__(v563, HIDWORD(v563))
       + v823
       + v825
       + v827
       + v829
       + v831
       + v833
       + v835
       + __PAIR64__(HIDWORD(v837) ^ (HIDWORD(v837) >> 1), (unsigned int)v837 ^ (unsigned int)(v837 >> 1))
       + (((unsigned __int64)v838 >> 2) ^ v838)
       + (*(_QWORD *)(v808 + 32)
        ^ (loc_114698 + v503 - (v675 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 56) >> 32) >> 24))));
  HIDWORD(v525) = v829 >> 5;
  LODWORD(v525) = ((_DWORD)v829 << 27) | (HIDWORD(v829) >> 5);
  LODWORD(v524) = v833 >> 27;
  HIDWORD(v524) = (HIDWORD(v833) >> 27) | (32 * v833);
  LODWORD(v523) = v835 >> 21;
  HIDWORD(v523) = (HIDWORD(v835) >> 21) | ((_DWORD)v835 << 11);
  LODWORD(v522) = v837 >> 11;
  HIDWORD(v522) = (HIDWORD(v837) >> 11) | ((_DWORD)v837 << 21);
  v674 = v839 >> 2;
  v673 = sub_10B364(v809 + 112) << 15;
  v504 = v673 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 112) >> 32) >> 17);
  v672 = 4 * sub_10B364(v809 + 8);
  v505 = __PAIR64__(HIDWORD(v673), v504) + (v672 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 8) >> 32) >> 30));
  v671 = sub_10B364(v809 + 64) << 9;
  v840 = v522
       + v523
       + v524
       + __PAIR64__(v831, HIDWORD(v831))
       + v525
       + __PAIR64__(v558, HIDWORD(v558))
       + __PAIR64__(v559, HIDWORD(v559))
       + v824
       + v826
       + v828
       + v830
       + v832
       + v834
       + v836
       + __PAIR64__(HIDWORD(v838) ^ (HIDWORD(v838) >> 1), (unsigned int)v838 ^ (unsigned int)(v838 >> 1))
       + ((v839 >> 2) ^ v839)
       + (*(_QWORD *)(v808 + 40)
        ^ (v505 - (v671 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 64) >> 32) >> 23)) - 0x600000000000000ALL));
  HIDWORD(v521) = v830 >> 5;
  LODWORD(v521) = ((_DWORD)v830 << 27) | (HIDWORD(v830) >> 5);
  LODWORD(v520) = v834 >> 27;
  HIDWORD(v520) = (HIDWORD(v834) >> 27) | (32 * v834);
  LODWORD(v519) = v836 >> 21;
  HIDWORD(v519) = (HIDWORD(v836) >> 21) | ((_DWORD)v836 << 11);
  LODWORD(v518) = v838 >> 11;
  HIDWORD(v518) = (HIDWORD(v838) >> 11) | ((_DWORD)v838 << 21);
  v670 = v840 >> 2;
  v669 = sub_10B364(v809 + 120) << 16;
  v506 = v669 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 120) >> 32) >> 16);
  v668 = 8 * sub_10B364(v809 + 16);
  v507 = __PAIR64__(HIDWORD(v669), v506)
       + (v668 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 16) >> 32) >> 29));
  v667 = sub_10B364(v809 + 72) << 10;
  v841 = v518
       + v519
       + v520
       + __PAIR64__(v832, HIDWORD(v832))
       + v521
       + __PAIR64__(v553, HIDWORD(v553))
       + __PAIR64__(v554, HIDWORD(v554))
       + v825
       + v827
       + v829
       + v831
       + v833
       + v835
       + v837
       + __PAIR64__(HIDWORD(v839) ^ (HIDWORD(v839) >> 1), (unsigned int)v839 ^ (unsigned int)((__int64)v839 >> 1))
       + ((v840 >> 2) ^ v840)
       + (*(_QWORD *)(v808 + 48)
        ^ (v507 - (v667 | ((unsigned int)((unsigned __int64)sub_10B364(v809 + 72) >> 32) >> 22)) - 0x5AAAAAAAAAAAAAB5LL));
  v843 = v833 ^ v826 ^ v827 ^ v828 ^ v829 ^ v830 ^ v831 ^ v832;
  v842 = v841 ^ v834 ^ v843 ^ v835 ^ v836 ^ v837 ^ v838 ^ v839 ^ v840;
  v666[21] = 32 * v842;
  v666[20] = (unsigned __int64)v826 >> 5;
  *(_QWORD *)v807 = ((32 * v842) ^ ((unsigned __int64)v826 >> 5) ^ sub_10B364(v809)) + (v810 ^ v834 ^ v843);
  v666[19] = v842 >> 7;
  v666[18] = v827 << 8;
  *(_QWORD *)(v807 + 8) = (v811 ^ v835 ^ v843) + ((v842 >> 7) ^ (v827 << 8) ^ sub_10B364(v809 + 8));
  v666[17] = v842 >> 5;
  v666[16] = 32 * v828;
  *(_QWORD *)(v807 + 16) = (v812 ^ v836 ^ v843) + ((v842 >> 5) ^ (32 * v828) ^ sub_10B364(v809 + 16));
  v666[15] = 32 * v829;
  v508 = sub_10B364(v809 + 24);
  *(_QWORD *)(v807 + 24) = (v813 ^ v837 ^ v843)
                         + __PAIR64__(
                             (unsigned int)((unsigned __int64)v829 >> 27) ^ (HIDWORD(v842) >> 1) ^ HIDWORD(v508),
                             (32 * v829) ^ ((__int64)v842 >> 1) ^ v508);
  v666[14] = v842 >> 3;
  *(_QWORD *)(v807 + 32) = (v814 ^ v838 ^ v843) + ((v842 >> 3) ^ v830 ^ sub_10B364(v809 + 32));
  v666[13] = v842 << 6;
  v666[12] = (unsigned __int64)v831 >> 6;
  *(_QWORD *)(v807 + 40) = (v815 ^ v839 ^ v843) + ((v842 << 6) ^ ((unsigned __int64)v831 >> 6) ^ sub_10B364(v809 + 40));
  v666[11] = v842 >> 4;
  v666[10] = v832 << 6;
  *(_QWORD *)(v807 + 48) = (v816 ^ v840 ^ v843) + ((v842 >> 4) ^ (v832 << 6) ^ sub_10B364(v809 + 48));
  v666[9] = v842 >> 11;
  v666[8] = 4 * v833;
  *(_QWORD *)(v807 + 56) = (v817 ^ v841 ^ v843) + ((v842 >> 11) ^ (4 * v833) ^ sub_10B364(v809 + 56));
  HIDWORD(v517) = *(__int64 *)(v807 + 32) >> 23;
  LODWORD(v517) = __SPAIR64__(*(_DWORD *)(v807 + 32), *(_DWORD *)(v807 + 36)) >> 23;
  v666[7] = v843 << 8;
  *(_QWORD *)(v807 + 64) = (v818 ^ (v843 << 8) ^ v833) + v517 + (sub_10B364(v809 + 64) ^ v834 ^ v842);
  HIDWORD(v516) = *(__int64 *)(v807 + 40) >> 22;
  LODWORD(v516) = __SPAIR64__(*(_DWORD *)(v807 + 40), *(_DWORD *)(v807 + 44)) >> 22;
  v666[6] = v843 >> 6;
  *(_QWORD *)(v807 + 72) = (v819 ^ (v843 >> 6) ^ v826) + v516 + (sub_10B364(v809 + 72) ^ v835 ^ v842);
  HIDWORD(v515) = *(__int64 *)(v807 + 48) >> 21;
  LODWORD(v515) = __SPAIR64__(*(_DWORD *)(v807 + 48), *(_DWORD *)(v807 + 52)) >> 21;
  v666[5] = v843 << 6;
  *(_QWORD *)(v807 + 80) = (v820 ^ (v843 << 6) ^ v827) + v515 + (sub_10B364(v809 + 80) ^ v836 ^ v842);
  HIDWORD(v514) = *(__int64 *)(v807 + 56) >> 20;
  LODWORD(v514) = __SPAIR64__(*(_DWORD *)(v807 + 56), *(_DWORD *)(v807 + 60)) >> 20;
  v666[4] = 16 * v843;
  *(_QWORD *)(v807 + 88) = (v821 ^ (16 * v843) ^ v828) + v514 + (sub_10B364(v809 + 88) ^ v837 ^ v842);
  HIDWORD(v513) = *(__int64 *)v807 >> 19;
  LODWORD(v513) = (*(_DWORD *)v807 << 13) | (*(_DWORD *)(v807 + 4) >> 19);
  v666[3] = v843 >> 3;
  *(_QWORD *)(v807 + 96) = (v822 ^ (v843 >> 3) ^ v829) + v513 + (sub_10B364(v809 + 96) ^ v838 ^ v842);
  HIDWORD(v512) = *(__int64 *)(v807 + 8) >> 18;
  LODWORD(v512) = __SPAIR64__(*(_DWORD *)(v807 + 8), *(_DWORD *)(v807 + 12)) >> 18;
  v666[2] = v843 >> 4;
  *(_QWORD *)(v807 + 104) = (v823 ^ (v843 >> 4) ^ v830) + v512 + (sub_10B364(v809 + 104) ^ v839 ^ v842);
  HIDWORD(v511) = *(__int64 *)(v807 + 16) >> 17;
  LODWORD(v511) = __SPAIR64__(*(_DWORD *)(v807 + 16), *(_DWORD *)(v807 + 20)) >> 17;
  v666[1] = v843 >> 7;
  *(_QWORD *)(v807 + 112) = (v824 ^ (v843 >> 7) ^ v831) + v511 + (sub_10B364(v809 + 112) ^ v840 ^ v842);
  HIDWORD(v510) = *(__int64 *)(v807 + 24) >> 16;
  LODWORD(v510) = __SPAIR64__(*(_DWORD *)(v807 + 24), *(_DWORD *)(v807 + 28)) >> 16;
  v666[0] = v843 >> 2;
  *(_QWORD *)(v807 + 120) = (v825 ^ (v843 >> 2) ^ v832) + v510 + (v841 ^ v842 ^ sub_10B364(v809 + 120));
  return v666;
}
// 115536: returning address of temporary local variable '%var_634'

//----- (00115578) --------------------------------------------------------
_DWORD *__fastcall sub_115578(char *a1, void *a2)
{
  _DWORD v5[68]; // [sp+8h] [bp+8h] BYREF

  sph_groestl512_init(v5);
  sph_groestl512((int)v5, a1, 0x40u);
  return sph_groestl512_close((int)v5, a2);
}

//----- (001155B8) --------------------------------------------------------
void *__fastcall sub_1155B8(char *a1, void *a2)
{
  _DWORD v5[52]; // [sp+8h] [bp+8h] BYREF

  sph_jh512_init(v5);
  sph_jh512((int)v5, a1, 0x40u);
  return sph_jh512_close((int)v5, a2);
}

//----- (001155F0) --------------------------------------------------------
void *__fastcall sub_1155F0(char *a1, _BYTE *a2)
{
  int v5[49]; // [sp+Ch] [bp+Ch] BYREF

  sph_luffa512_init((int)v5);
  sph_luffa512((unsigned int)v5, a1, 0x40u);
  return sph_luffa512_close(v5, a2);
}

//----- (00115628) --------------------------------------------------------
_DWORD *__fastcall sub_115628(char *a1, void *a2)
{
  _DWORD v5[70]; // [sp+8h] [bp+8h] BYREF

  sph_echo512_init(v5);
  sph_echo512(v5, a1, 0x40u);
  return sph_echo512_close(v5, a2);
}

//----- (00115668) --------------------------------------------------------
void *__fastcall sub_115668(char *a1, int a2)
{
  _DWORD v5[41]; // [sp+Ch] [bp+Ch] BYREF

  sph_cubehash512_init((int)v5);
  sph_cubehash512((int)v5, a1, 0x40u);
  return sph_cubehash512_close(v5, a2);
}

//----- (001156A0) --------------------------------------------------------
void *__fastcall sub_1156A0(char *a1, int a2)
{
  _DWORD v5[67]; // [sp+Ch] [bp+Ch] BYREF

  sph_simd512_init(v5);
  sph_simd512((unsigned __int8 *)v5, a1, 0x40u);
  return sph_simd512_close(v5, a2);
}

//----- (001156E0) --------------------------------------------------------
#error "1156E0: too big function (funcsize=0)"

//----- (0012DEE8) --------------------------------------------------------
#error "12DEE8: too big function (funcsize=0)"

//----- (00140D50) --------------------------------------------------------
FILE *__fastcall x11_log_work(int a1, int a2, int a3)
{
  FILE *result; // r0
  size_t v4; // r0
  int v6; // [sp+8h] [bp+8h] BYREF
  int v7; // [sp+Ch] [bp+Ch]
  char s[256]; // [sp+14h] [bp+14h] BYREF
  int v9; // [sp+114h] [bp+114h]
  int *v10; // [sp+118h] [bp+118h]
  int v11; // [sp+11Ch] [bp+11Ch]

  v7 = a1;
  v6 = a2;
  memset(s, 0, sizeof(s));
  v11 = v7;
  v10 = &v6;
  v9 = a3;
  result = fopen("/tmp/x11_dump_file.log", "a");
  g_logwork_file = (int)result;
  if ( result )
  {
    v4 = strlen(s);
    fwrite(s, v4, 1u, (FILE *)g_logwork_file);
    fwrite("\n", 1u, 1u, (FILE *)g_logwork_file);
    return (FILE *)fflush((FILE *)g_logwork_file);
  }
  return result;
}
// 47BE28: using guessed type int g_logwork_file;

//----- (00140E14) --------------------------------------------------------
void doOneTestData()
{
  ;
}

//----- (00140E28) --------------------------------------------------------
void doOneGoldenData()
{
  ;
}

//----- (00140E3C) --------------------------------------------------------
int __fastcall dohash_X11(int a1, int a2, int a3, int a4)
{
  return a4;
}

//----- (00140E58) --------------------------------------------------------
int __fastcall sub_140E58(int result, unsigned int a2)
{
  *(_BYTE *)result = a2;
  *(_WORD *)(result + 1) = a2 >> 8;
  *(_BYTE *)(result + 3) = HIBYTE(a2);
  return result;
}

//----- (00140E9C) --------------------------------------------------------
int __fastcall sub_140E9C(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00140EB4) --------------------------------------------------------
unsigned __int8 *__fastcall sub_140EB4(unsigned __int8 *result, int a2, int *a3)
{
  int v3; // [sp+10h] [bp+10h]
  int v4; // [sp+10h] [bp+10h]
  int v5; // [sp+10h] [bp+10h]
  int v6; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int v9; // [sp+18h] [bp+18h]
  int v10; // [sp+18h] [bp+18h]
  int v11; // [sp+18h] [bp+18h]
  int v12; // [sp+18h] [bp+18h]
  int v13; // [sp+1Ch] [bp+1Ch]
  int v14; // [sp+1Ch] [bp+1Ch]
  int v15; // [sp+1Ch] [bp+1Ch]
  int v16; // [sp+1Ch] [bp+1Ch]
  int v17; // [sp+20h] [bp+20h]
  int v18; // [sp+24h] [bp+24h]
  int v19; // [sp+24h] [bp+24h]
  int v20; // [sp+24h] [bp+24h]
  int v21; // [sp+24h] [bp+24h]
  int v22; // [sp+24h] [bp+24h]
  int v23; // [sp+2Ch] [bp+2Ch]
  int v24; // [sp+34h] [bp+34h]
  int v25; // [sp+3Ch] [bp+3Ch]
  int v26; // [sp+44h] [bp+44h]
  int v27; // [sp+48h] [bp+48h]
  int v28; // [sp+4Ch] [bp+4Ch]
  int v29; // [sp+50h] [bp+50h]
  int v30; // [sp+58h] [bp+58h]
  int v31; // [sp+60h] [bp+60h]
  int v32; // [sp+68h] [bp+68h]
  int v33; // [sp+6Ch] [bp+6Ch]
  int v34; // [sp+70h] [bp+70h]
  int v35; // [sp+74h] [bp+74h]
  int v36; // [sp+7Ch] [bp+7Ch]
  int v37; // [sp+84h] [bp+84h]
  int v38; // [sp+8Ch] [bp+8Ch]
  int v39; // [sp+94h] [bp+94h]
  int v40; // [sp+98h] [bp+98h]
  int v41; // [sp+9Ch] [bp+9Ch]
  int v42; // [sp+A0h] [bp+A0h]
  int v43; // [sp+A8h] [bp+A8h]
  int v44; // [sp+B0h] [bp+B0h]
  int v45; // [sp+B8h] [bp+B8h]
  int v46; // [sp+BCh] [bp+BCh]
  int v47; // [sp+C0h] [bp+C0h]
  int v48; // [sp+C4h] [bp+C4h]
  int v49; // [sp+CCh] [bp+CCh]
  int v50; // [sp+D4h] [bp+D4h]
  int v51; // [sp+DCh] [bp+DCh]
  int v52; // [sp+E4h] [bp+E4h]
  int v53; // [sp+E8h] [bp+E8h]
  int v54; // [sp+ECh] [bp+ECh]
  int v55; // [sp+F0h] [bp+F0h]
  int v56; // [sp+F8h] [bp+F8h]
  int v57; // [sp+100h] [bp+100h]
  int v58; // [sp+108h] [bp+108h]
  int v59; // [sp+10Ch] [bp+10Ch]
  int v60; // [sp+110h] [bp+110h]
  int v61; // [sp+114h] [bp+114h]
  int v62; // [sp+11Ch] [bp+11Ch]
  int v63; // [sp+124h] [bp+124h]
  int v64; // [sp+12Ch] [bp+12Ch]
  int v65; // [sp+134h] [bp+134h]
  int v66; // [sp+138h] [bp+138h]
  int v67; // [sp+13Ch] [bp+13Ch]
  int v68; // [sp+140h] [bp+140h]
  int v69; // [sp+148h] [bp+148h]
  int v70; // [sp+150h] [bp+150h]
  int v71; // [sp+158h] [bp+158h]
  int v72; // [sp+15Ch] [bp+15Ch]
  int v73; // [sp+160h] [bp+160h]
  int v74; // [sp+164h] [bp+164h]
  int v75; // [sp+168h] [bp+168h]
  int v76; // [sp+168h] [bp+168h]
  int v77; // [sp+168h] [bp+168h]
  int v78; // [sp+168h] [bp+168h]
  int v79; // [sp+16Ch] [bp+16Ch]
  int v80; // [sp+170h] [bp+170h]
  int v81; // [sp+170h] [bp+170h]
  int v82; // [sp+170h] [bp+170h]
  int v83; // [sp+170h] [bp+170h]
  int v84; // [sp+170h] [bp+170h]
  int v85; // [sp+178h] [bp+178h]
  int v86; // [sp+180h] [bp+180h]
  int v87; // [sp+188h] [bp+188h]
  int v88; // [sp+190h] [bp+190h]
  int v89; // [sp+194h] [bp+194h]
  int v90; // [sp+198h] [bp+198h]
  int v91; // [sp+19Ch] [bp+19Ch]
  int v92; // [sp+1A4h] [bp+1A4h]
  int v93; // [sp+1ACh] [bp+1ACh]
  int v94; // [sp+1B4h] [bp+1B4h]
  int v95; // [sp+1B8h] [bp+1B8h]
  int v96; // [sp+1BCh] [bp+1BCh]
  int v97; // [sp+1C0h] [bp+1C0h]
  int v98; // [sp+1C8h] [bp+1C8h]
  int v99; // [sp+1D0h] [bp+1D0h]
  int v100; // [sp+1D8h] [bp+1D8h]
  int v101; // [sp+1E0h] [bp+1E0h]
  int v102; // [sp+1E4h] [bp+1E4h]
  int v103; // [sp+1E8h] [bp+1E8h]
  int v104; // [sp+1ECh] [bp+1ECh]
  int v105; // [sp+1F4h] [bp+1F4h]
  int v106; // [sp+1FCh] [bp+1FCh]
  int v107; // [sp+204h] [bp+204h]
  int v108; // [sp+208h] [bp+208h]
  int v109; // [sp+20Ch] [bp+20Ch]
  int v110; // [sp+210h] [bp+210h]
  int v111; // [sp+218h] [bp+218h]
  int v112; // [sp+220h] [bp+220h]
  int v113; // [sp+228h] [bp+228h]
  int v114; // [sp+230h] [bp+230h]
  int v115; // [sp+234h] [bp+234h]
  int v116; // [sp+238h] [bp+238h]
  int v117; // [sp+23Ch] [bp+23Ch]
  int v118; // [sp+244h] [bp+244h]
  int v119; // [sp+24Ch] [bp+24Ch]
  int v120; // [sp+254h] [bp+254h]
  int v121; // [sp+258h] [bp+258h]
  int v122; // [sp+25Ch] [bp+25Ch]
  int v123; // [sp+260h] [bp+260h]
  int v124; // [sp+268h] [bp+268h]
  int v125; // [sp+270h] [bp+270h]
  int v126; // [sp+278h] [bp+278h]
  int v127; // [sp+280h] [bp+280h]
  int v128; // [sp+284h] [bp+284h]
  int v129; // [sp+288h] [bp+288h]
  int v130; // [sp+28Ch] [bp+28Ch]
  int v131; // [sp+294h] [bp+294h]
  int v132; // [sp+29Ch] [bp+29Ch]
  int v133; // [sp+2A4h] [bp+2A4h]
  int v134; // [sp+2A8h] [bp+2A8h]
  int v135; // [sp+2ACh] [bp+2ACh]
  int v136; // [sp+2B0h] [bp+2B0h]
  int v137; // [sp+2B8h] [bp+2B8h]
  unsigned int k; // [sp+2BCh] [bp+2BCh]
  int v139; // [sp+2C0h] [bp+2C0h]
  unsigned int j; // [sp+2C4h] [bp+2C4h]
  int v141; // [sp+2C8h] [bp+2C8h]
  unsigned int i; // [sp+2CCh] [bp+2CCh]

  v136 = *result;
  v135 = result[8 * a2];
  v134 = result[16 * a2];
  v133 = result[24 * a2];
  v132 = v136 + 16 * v134;
  v131 = v136 - 16 * v134;
  v130 = (unsigned __int8)(((_BYTE)v133 << 6) + 4 * v135) - (((v133 << 6) + 4 * v135) >> 8);
  v129 = 16 * v135 - 16 * v133;
  v128 = (unsigned __int8)(4 * v133 + ((_BYTE)v135 << 6)) - ((4 * v133 + (v135 << 6)) >> 8);
  v127 = v133 + v135 + v134 + v136;
  v126 = v129 + v136 - v134;
  v125 = v134 + v136 - (v133 + v135);
  v124 = v136 - v134 - v129;
  v123 = result[4 * a2];
  v122 = result[12 * a2];
  v121 = result[20 * a2];
  v120 = result[28 * a2];
  v119 = v123 + 16 * v121;
  v118 = v123 - 16 * v121;
  v117 = (unsigned __int8)(((_BYTE)v120 << 6) + 4 * v122) - (((v120 << 6) + 4 * v122) >> 8);
  v116 = 16 * v122 - 16 * v120;
  v115 = (unsigned __int8)(4 * v120 + ((_BYTE)v122 << 6)) - ((4 * v120 + (v122 << 6)) >> 8);
  v114 = v120 + v122 + v121 + v123;
  v113 = v116 + v123 - v121;
  v112 = v121 + v123 - (v120 + v122);
  v111 = v123 - v121 - v116;
  *a3 = v127 + v114;
  a3[1] = v130 + v132 + 2 * (v117 + v119);
  a3[2] = v126 + 4 * v113;
  a3[3] = v128 + v131 + 8 * (v115 + v118);
  a3[4] = v125 + 16 * v112;
  a3[5] = v132 - v130 + 32 * (v119 - v117);
  a3[6] = v124 + (v111 << 6);
  a3[7] = v131 - v128 + ((v118 - v115) << 7);
  a3[8] = v127 - v114;
  a3[9] = v130 + v132 - 2 * (v117 + v119);
  a3[10] = v126 - 4 * v113;
  a3[11] = v128 + v131 - 8 * (v115 + v118);
  a3[12] = v125 - 16 * v112;
  a3[13] = v132 - v130 - 32 * (v119 - v117);
  a3[14] = v124 - (v111 << 6);
  a3[15] = v131 - v128 - ((v118 - v115) << 7);
  v110 = result[2 * a2];
  v109 = result[10 * a2];
  v108 = result[18 * a2];
  v107 = result[26 * a2];
  v106 = v110 + 16 * v108;
  v105 = v110 - 16 * v108;
  v104 = (unsigned __int8)(((_BYTE)v107 << 6) + 4 * v109) - (((v107 << 6) + 4 * v109) >> 8);
  v103 = 16 * v109 - 16 * v107;
  v102 = (unsigned __int8)(4 * v107 + ((_BYTE)v109 << 6)) - ((4 * v107 + (v109 << 6)) >> 8);
  v101 = v107 + v109 + v108 + v110;
  v100 = v103 + v110 - v108;
  v99 = v108 + v110 - (v107 + v109);
  v98 = v110 - v108 - v103;
  v97 = result[6 * a2];
  v96 = result[14 * a2];
  v95 = result[22 * a2];
  v94 = result[30 * a2];
  v93 = v97 + 16 * v95;
  v92 = v97 - 16 * v95;
  v91 = (unsigned __int8)(((_BYTE)v94 << 6) + 4 * v96) - (((v94 << 6) + 4 * v96) >> 8);
  v90 = 16 * v96 - 16 * v94;
  v89 = (unsigned __int8)(4 * v94 + ((_BYTE)v96 << 6)) - ((4 * v94 + (v96 << 6)) >> 8);
  v88 = v94 + v96 + v95 + v97;
  v87 = v90 + v97 - v95;
  v86 = v95 + v97 - (v94 + v96);
  v85 = v97 - v95 - v90;
  a3[16] = v88 + v101;
  a3[17] = v104 + v106 + 2 * (v91 + v93);
  a3[18] = v100 + 4 * v87;
  a3[19] = v102 + v105 + 8 * (v89 + v92);
  a3[20] = v99 + 16 * v86;
  a3[21] = v106 - v104 + 32 * (v93 - v91);
  a3[22] = v98 + (v85 << 6);
  a3[23] = v105 - v102 + ((v92 - v89) << 7);
  a3[24] = v101 - v88;
  a3[25] = v104 + v106 - 2 * (v91 + v93);
  a3[26] = v100 - 4 * v87;
  a3[27] = v102 + v105 - 8 * (v89 + v92);
  a3[28] = v99 - 16 * v86;
  a3[29] = v106 - v104 - 32 * (v93 - v91);
  a3[30] = v98 - (v85 << 6);
  a3[31] = v105 - v102 - ((v92 - v89) << 7);
  v80 = *a3;
  v79 = a3[16];
  *a3 += v79;
  a3[16] = v80 - v79;
  v141 = 0;
  for ( i = 0; ; a3[i + 16] = v81 - v75 )
  {
    v82 = a3[i + 1];
    v76 = ((a3[i + 17] * dword_1D48C8[v141 + 8]) >> 16) + (unsigned __int16)(a3[i + 17] * dword_1D48C8[v141 + 8]);
    a3[i + 1] = v76 + v82;
    a3[i + 17] = v82 - v76;
    v83 = a3[i + 2];
    v77 = ((a3[i + 18] * dword_1D48C8[v141 + 16]) >> 16) + (unsigned __int16)(a3[i + 18] * dword_1D48C8[v141 + 16]);
    a3[i + 2] = v77 + v83;
    a3[i + 18] = v83 - v77;
    v84 = a3[i + 3];
    v78 = ((a3[i + 19] * dword_1D48C8[v141 + 24]) >> 16) + (unsigned __int16)(a3[i + 19] * dword_1D48C8[v141 + 24]);
    a3[i + 3] = v78 + v84;
    a3[i + 19] = v84 - v78;
    i += 4;
    v141 += 32;
    if ( i > 0xF )
      break;
    v81 = a3[i];
    v75 = ((a3[i + 16] * dword_1D48C8[v141]) >> 16) + (unsigned __int16)(a3[i + 16] * dword_1D48C8[v141]);
    a3[i] = v75 + v81;
  }
  v74 = result[a2];
  v73 = result[9 * a2];
  v72 = result[17 * a2];
  v71 = result[25 * a2];
  v70 = v74 + 16 * v72;
  v69 = v74 - 16 * v72;
  v68 = (unsigned __int8)(((_BYTE)v71 << 6) + 4 * v73) - (((v71 << 6) + 4 * v73) >> 8);
  v67 = 16 * v73 - 16 * v71;
  v66 = (unsigned __int8)(4 * v71 + ((_BYTE)v73 << 6)) - ((4 * v71 + (v73 << 6)) >> 8);
  v65 = v71 + v73 + v72 + v74;
  v64 = v67 + v74 - v72;
  v63 = v72 + v74 - (v71 + v73);
  v62 = v74 - v72 - v67;
  v61 = result[5 * a2];
  v60 = result[13 * a2];
  v59 = result[21 * a2];
  v58 = result[29 * a2];
  v57 = v61 + 16 * v59;
  v56 = v61 - 16 * v59;
  v55 = (unsigned __int8)(((_BYTE)v58 << 6) + 4 * v60) - (((v58 << 6) + 4 * v60) >> 8);
  v54 = 16 * v60 - 16 * v58;
  v53 = (unsigned __int8)(4 * v58 + ((_BYTE)v60 << 6)) - ((4 * v58 + (v60 << 6)) >> 8);
  v52 = v58 + v60 + v59 + v61;
  v51 = v54 + v61 - v59;
  v50 = v59 + v61 - (v58 + v60);
  v49 = v61 - v59 - v54;
  a3[32] = v52 + v65;
  a3[33] = v68 + v70 + 2 * (v55 + v57);
  a3[34] = v64 + 4 * v51;
  a3[35] = v66 + v69 + 8 * (v53 + v56);
  a3[36] = v63 + 16 * v50;
  a3[37] = v70 - v68 + 32 * (v57 - v55);
  a3[38] = v62 + (v49 << 6);
  a3[39] = v69 - v66 + ((v56 - v53) << 7);
  a3[40] = v65 - v52;
  a3[41] = v68 + v70 - 2 * (v55 + v57);
  a3[42] = v64 - 4 * v51;
  a3[43] = v66 + v69 - 8 * (v53 + v56);
  a3[44] = v63 - 16 * v50;
  a3[45] = v70 - v68 - 32 * (v57 - v55);
  a3[46] = v62 - (v49 << 6);
  a3[47] = v69 - v66 - ((v56 - v53) << 7);
  v48 = result[3 * a2];
  v47 = result[11 * a2];
  v46 = result[19 * a2];
  v45 = result[27 * a2];
  v44 = v48 + 16 * v46;
  v43 = v48 - 16 * v46;
  v42 = (unsigned __int8)(((_BYTE)v45 << 6) + 4 * v47) - (((v45 << 6) + 4 * v47) >> 8);
  v41 = 16 * v47 - 16 * v45;
  v40 = (unsigned __int8)(4 * v45 + ((_BYTE)v47 << 6)) - ((4 * v45 + (v47 << 6)) >> 8);
  v39 = v45 + v47 + v46 + v48;
  v38 = v41 + v48 - v46;
  v37 = v46 + v48 - (v45 + v47);
  v36 = v48 - v46 - v41;
  v35 = result[7 * a2];
  v34 = result[15 * a2];
  v33 = result[23 * a2];
  v32 = result[31 * a2];
  v31 = v35 + 16 * v33;
  v30 = v35 - 16 * v33;
  v29 = (unsigned __int8)(((_BYTE)v32 << 6) + 4 * v34) - (((v32 << 6) + 4 * v34) >> 8);
  v28 = 16 * v34 - 16 * v32;
  v27 = (unsigned __int8)(4 * v32 + ((_BYTE)v34 << 6)) - ((4 * v32 + (v34 << 6)) >> 8);
  v26 = v32 + v34 + v33 + v35;
  v25 = v28 + v35 - v33;
  v24 = v33 + v35 - (v32 + v34);
  v23 = v35 - v33 - v28;
  a3[48] = v26 + v39;
  a3[49] = v42 + v44 + 2 * (v29 + v31);
  a3[50] = v38 + 4 * v25;
  a3[51] = v40 + v43 + 8 * (v27 + v30);
  a3[52] = v37 + 16 * v24;
  a3[53] = v44 - v42 + 32 * (v31 - v29);
  a3[54] = v36 + (v23 << 6);
  a3[55] = v43 - v40 + ((v30 - v27) << 7);
  a3[56] = v39 - v26;
  a3[57] = v42 + v44 - 2 * (v29 + v31);
  a3[58] = v38 - 4 * v25;
  a3[59] = v40 + v43 - 8 * (v27 + v30);
  a3[60] = v37 - 16 * v24;
  a3[61] = v44 - v42 - 32 * (v31 - v29);
  a3[62] = v36 - (v23 << 6);
  a3[63] = v43 - v40 - ((v30 - v27) << 7);
  v18 = a3[32];
  v17 = a3[48];
  a3[32] = v17 + v18;
  a3[48] = v18 - v17;
  v139 = 0;
  for ( j = 0; ; a3[j + 48] = v19 - v13 )
  {
    v20 = a3[j + 33];
    v14 = ((a3[j + 49] * dword_1D48C8[v139 + 8]) >> 16) + (unsigned __int16)(a3[j + 49] * dword_1D48C8[v139 + 8]);
    a3[j + 33] = v14 + v20;
    a3[j + 49] = v20 - v14;
    v21 = a3[j + 34];
    v15 = ((a3[j + 50] * dword_1D48C8[v139 + 16]) >> 16) + (unsigned __int16)(a3[j + 50] * dword_1D48C8[v139 + 16]);
    a3[j + 34] = v15 + v21;
    a3[j + 50] = v21 - v15;
    v22 = a3[j + 35];
    v16 = ((a3[j + 51] * dword_1D48C8[v139 + 24]) >> 16) + (unsigned __int16)(a3[j + 51] * dword_1D48C8[v139 + 24]);
    a3[j + 35] = v16 + v22;
    a3[j + 51] = v22 - v16;
    j += 4;
    v139 += 32;
    if ( j > 0xF )
      break;
    v19 = a3[j + 32];
    v13 = ((a3[j + 48] * dword_1D48C8[v139]) >> 16) + (unsigned __int16)(a3[j + 48] * dword_1D48C8[v139]);
    a3[j + 32] = v13 + v19;
  }
  v8 = *a3;
  v7 = a3[32];
  *a3 += v7;
  a3[32] = v8 - v7;
  v137 = 0;
  for ( k = 0; ; a3[k + 32] = v9 - v3 )
  {
    v10 = a3[k + 1];
    v4 = ((a3[k + 33] * dword_1D48C8[v137 + 4]) >> 16) + (unsigned __int16)(a3[k + 33] * dword_1D48C8[v137 + 4]);
    a3[k + 1] = v4 + v10;
    a3[k + 33] = v10 - v4;
    v11 = a3[k + 2];
    v5 = ((a3[k + 34] * dword_1D48C8[v137 + 8]) >> 16) + (unsigned __int16)(a3[k + 34] * dword_1D48C8[v137 + 8]);
    a3[k + 2] = v5 + v11;
    a3[k + 34] = v11 - v5;
    v12 = a3[k + 3];
    v6 = ((a3[k + 35] * dword_1D48C8[v137 + 12]) >> 16) + (unsigned __int16)(a3[k + 35] * dword_1D48C8[v137 + 12]);
    a3[k + 3] = v6 + v12;
    a3[k + 35] = v12 - v6;
    k += 4;
    v137 += 16;
    if ( k > 0x1F )
      break;
    v9 = a3[k];
    v3 = ((a3[k + 32] * dword_1D48C8[v137]) >> 16) + (unsigned __int16)(a3[k + 32] * dword_1D48C8[v137]);
    a3[k] = v3 + v9;
  }
  return result;
}
// 1D48C8: using guessed type _DWORD dword_1D48C8[256];

//----- (00142CC0) --------------------------------------------------------
int __fastcall sub_142CC0(unsigned __int8 *a1, int a2)
{
  int v2; // r3
  int v3; // r3
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  int v19; // r0
  int result; // r0
  int v22; // [sp+Ch] [bp+Ch]
  int v23; // [sp+10h] [bp+10h]
  int v24; // [sp+14h] [bp+14h]
  int v25; // [sp+18h] [bp+18h]
  int v26; // [sp+1Ch] [bp+1Ch]
  int v27; // [sp+20h] [bp+20h]
  int v28; // [sp+24h] [bp+24h]
  int v29; // [sp+28h] [bp+28h]
  int v30; // [sp+2Ch] [bp+2Ch]
  int v31; // [sp+30h] [bp+30h]
  int v32; // [sp+34h] [bp+34h]
  int v33; // [sp+38h] [bp+38h]
  int v34; // [sp+3Ch] [bp+3Ch]
  int v35; // [sp+40h] [bp+40h]
  int v36; // [sp+44h] [bp+44h]
  int v37; // [sp+48h] [bp+48h]
  int v38; // [sp+4Ch] [bp+4Ch]
  int v39; // [sp+50h] [bp+50h]
  int v40; // [sp+54h] [bp+54h]
  int v41; // [sp+58h] [bp+58h]
  int v42; // [sp+5Ch] [bp+5Ch]
  int v43; // [sp+60h] [bp+60h]
  int v44; // [sp+64h] [bp+64h]
  int v45; // [sp+68h] [bp+68h]
  int v46; // [sp+6Ch] [bp+6Ch]
  int v47; // [sp+70h] [bp+70h]
  int v48; // [sp+74h] [bp+74h]
  int v49; // [sp+78h] [bp+78h]
  int v50; // [sp+7Ch] [bp+7Ch]
  int v51; // [sp+80h] [bp+80h]
  int v52; // [sp+84h] [bp+84h]
  int v53; // [sp+88h] [bp+88h]
  int v54; // [sp+8Ch] [bp+8Ch]
  int v55; // [sp+90h] [bp+90h]
  int v56; // [sp+94h] [bp+94h]
  int v57; // [sp+98h] [bp+98h]
  int v58; // [sp+9Ch] [bp+9Ch]
  int v59; // [sp+A0h] [bp+A0h]
  int v60; // [sp+A4h] [bp+A4h]
  int v61; // [sp+A8h] [bp+A8h]
  int v62; // [sp+ACh] [bp+ACh]
  int v63; // [sp+B0h] [bp+B0h]
  int v64; // [sp+B4h] [bp+B4h]
  int v65; // [sp+B8h] [bp+B8h]
  int v66; // [sp+BCh] [bp+BCh]
  int v67; // [sp+C0h] [bp+C0h]
  int v68; // [sp+C4h] [bp+C4h]
  int v69; // [sp+C8h] [bp+C8h]
  int v70; // [sp+CCh] [bp+CCh]
  int v71; // [sp+D0h] [bp+D0h]
  int v72; // [sp+D4h] [bp+D4h]
  int v73; // [sp+D8h] [bp+D8h]
  int v74; // [sp+DCh] [bp+DCh]
  int v75; // [sp+E0h] [bp+E0h]
  int v76; // [sp+E4h] [bp+E4h]
  int v77; // [sp+E8h] [bp+E8h]
  int v78; // [sp+ECh] [bp+ECh]
  int v79; // [sp+F0h] [bp+F0h]
  int v80; // [sp+F4h] [bp+F4h]
  int v81; // [sp+F8h] [bp+F8h]
  int v82; // [sp+FCh] [bp+FCh]
  int v83; // [sp+100h] [bp+100h]
  int v84; // [sp+104h] [bp+104h]
  int v85; // [sp+108h] [bp+108h]
  int v86; // [sp+10Ch] [bp+10Ch]
  int v87; // [sp+110h] [bp+110h]
  int v88; // [sp+114h] [bp+114h]
  int v89; // [sp+118h] [bp+118h]
  int v90; // [sp+11Ch] [bp+11Ch]
  int v91; // [sp+120h] [bp+120h]
  int v92; // [sp+124h] [bp+124h]
  int v93; // [sp+128h] [bp+128h]
  int v94; // [sp+12Ch] [bp+12Ch]
  int v95; // [sp+130h] [bp+130h]
  int v96; // [sp+134h] [bp+134h]
  int v97; // [sp+138h] [bp+138h]
  int v98; // [sp+13Ch] [bp+13Ch]
  int v99; // [sp+140h] [bp+140h]
  int v100; // [sp+144h] [bp+144h]
  int v101; // [sp+148h] [bp+148h]
  int v102; // [sp+14Ch] [bp+14Ch]
  int v103; // [sp+150h] [bp+150h]
  int v104; // [sp+154h] [bp+154h]
  int v105; // [sp+158h] [bp+158h]
  int v106; // [sp+15Ch] [bp+15Ch]
  int v107; // [sp+160h] [bp+160h]
  int v108; // [sp+164h] [bp+164h]
  int v109; // [sp+168h] [bp+168h]
  int v110; // [sp+16Ch] [bp+16Ch]
  int v111; // [sp+170h] [bp+170h]
  int v112; // [sp+174h] [bp+174h]
  int v113; // [sp+178h] [bp+178h]
  int v114; // [sp+17Ch] [bp+17Ch]
  int v115; // [sp+180h] [bp+180h]
  int v116; // [sp+184h] [bp+184h]
  int v117; // [sp+188h] [bp+188h]
  int v118; // [sp+18Ch] [bp+18Ch]
  int v119; // [sp+190h] [bp+190h]
  int v120; // [sp+194h] [bp+194h]
  int v121; // [sp+198h] [bp+198h]
  int v122; // [sp+19Ch] [bp+19Ch]
  int v123; // [sp+1A0h] [bp+1A0h]
  int v124; // [sp+1A4h] [bp+1A4h]
  int v125; // [sp+1A8h] [bp+1A8h]
  int v126; // [sp+1ACh] [bp+1ACh]
  int v127; // [sp+1B0h] [bp+1B0h]
  int v128; // [sp+1B4h] [bp+1B4h]
  int v129; // [sp+1B8h] [bp+1B8h]
  int v130; // [sp+1BCh] [bp+1BCh]
  int v131; // [sp+1C0h] [bp+1C0h]
  int v132; // [sp+1C4h] [bp+1C4h]
  int v133; // [sp+1C8h] [bp+1C8h]
  int v134; // [sp+1CCh] [bp+1CCh]
  int v135; // [sp+1D0h] [bp+1D0h]
  int v136; // [sp+1D4h] [bp+1D4h]
  int v137; // [sp+1D8h] [bp+1D8h]
  int v138; // [sp+1DCh] [bp+1DCh]
  int v139; // [sp+1E0h] [bp+1E0h]
  int v140; // [sp+1E4h] [bp+1E4h]
  int v141; // [sp+1E8h] [bp+1E8h]
  int v142; // [sp+1ECh] [bp+1ECh]
  int v143; // [sp+1F0h] [bp+1F0h]
  int v144; // [sp+1F4h] [bp+1F4h]
  int v145; // [sp+1F8h] [bp+1F8h]
  int v146; // [sp+1FCh] [bp+1FCh]
  int v147; // [sp+200h] [bp+200h]
  int v148; // [sp+204h] [bp+204h]
  int v149; // [sp+208h] [bp+208h]
  int v150; // [sp+20Ch] [bp+20Ch]
  int v151; // [sp+210h] [bp+210h]
  int v152; // [sp+214h] [bp+214h]
  int v153; // [sp+218h] [bp+218h]
  int v154; // [sp+21Ch] [bp+21Ch]
  int v155; // [sp+220h] [bp+220h]
  int v156; // [sp+224h] [bp+224h]
  int v157; // [sp+228h] [bp+228h]
  int v158; // [sp+22Ch] [bp+22Ch]
  int v159; // [sp+230h] [bp+230h]
  int v160; // [sp+234h] [bp+234h]
  int v161; // [sp+238h] [bp+238h]
  int v162; // [sp+23Ch] [bp+23Ch]
  int v163; // [sp+240h] [bp+240h]
  int v164; // [sp+244h] [bp+244h]
  int v165; // [sp+248h] [bp+248h]
  int v166; // [sp+24Ch] [bp+24Ch]
  int v167; // [sp+250h] [bp+250h]
  int v168; // [sp+254h] [bp+254h]
  int v169; // [sp+258h] [bp+258h]
  int v170; // [sp+25Ch] [bp+25Ch]
  int v171; // [sp+260h] [bp+260h]
  int v172; // [sp+264h] [bp+264h]
  int v173; // [sp+268h] [bp+268h]
  int v174; // [sp+26Ch] [bp+26Ch]
  int v175; // [sp+270h] [bp+270h]
  int v176; // [sp+274h] [bp+274h]
  int v177; // [sp+278h] [bp+278h]
  int v178; // [sp+27Ch] [bp+27Ch]
  int v179; // [sp+280h] [bp+280h]
  int v180; // [sp+284h] [bp+284h]
  int v181; // [sp+288h] [bp+288h]
  int v182; // [sp+28Ch] [bp+28Ch]
  int v183; // [sp+290h] [bp+290h]
  int v184; // [sp+294h] [bp+294h]
  int v185; // [sp+298h] [bp+298h]
  int v186; // [sp+29Ch] [bp+29Ch]
  int v187; // [sp+2A0h] [bp+2A0h]
  int v188; // [sp+2A4h] [bp+2A4h]
  int v189; // [sp+2A8h] [bp+2A8h]
  int v190; // [sp+2ACh] [bp+2ACh]
  int v191; // [sp+2B0h] [bp+2B0h]
  int v192; // [sp+2B4h] [bp+2B4h]
  int v193; // [sp+2B8h] [bp+2B8h]
  int v194; // [sp+2BCh] [bp+2BCh]
  int v195; // [sp+2C0h] [bp+2C0h]
  int v196; // [sp+2C4h] [bp+2C4h]
  int v197; // [sp+2C8h] [bp+2C8h]
  int v198; // [sp+2CCh] [bp+2CCh]
  int v199; // [sp+2D0h] [bp+2D0h]
  int v200; // [sp+2D4h] [bp+2D4h]
  int v201; // [sp+2D8h] [bp+2D8h]
  int v202; // [sp+2DCh] [bp+2DCh]
  int v203; // [sp+2E0h] [bp+2E0h]
  int v204; // [sp+2E4h] [bp+2E4h]
  int v205; // [sp+2E8h] [bp+2E8h]
  int v206; // [sp+2ECh] [bp+2ECh]
  int v207; // [sp+2F0h] [bp+2F0h]
  int v208; // [sp+2F4h] [bp+2F4h]
  int v209; // [sp+2F8h] [bp+2F8h]
  int v210; // [sp+2FCh] [bp+2FCh]
  int v211; // [sp+300h] [bp+300h]
  int v212; // [sp+304h] [bp+304h]
  int v213; // [sp+308h] [bp+308h]
  int v214; // [sp+30Ch] [bp+30Ch]
  int v215; // [sp+310h] [bp+310h]
  int v216; // [sp+314h] [bp+314h]
  int v217; // [sp+318h] [bp+318h]
  int v218; // [sp+31Ch] [bp+31Ch]
  int v219; // [sp+320h] [bp+320h]
  int v220; // [sp+324h] [bp+324h]
  int v221; // [sp+328h] [bp+328h]
  int v222; // [sp+32Ch] [bp+32Ch]
  int v223; // [sp+330h] [bp+330h]
  int v224; // [sp+334h] [bp+334h]
  int v225; // [sp+338h] [bp+338h]
  int v226; // [sp+33Ch] [bp+33Ch]
  int v227; // [sp+340h] [bp+340h]
  int v228; // [sp+344h] [bp+344h]
  int v229; // [sp+348h] [bp+348h]
  int v230; // [sp+34Ch] [bp+34Ch]
  int v231; // [sp+350h] [bp+350h]
  int v232; // [sp+354h] [bp+354h]
  int v233; // [sp+358h] [bp+358h]
  int v234; // [sp+35Ch] [bp+35Ch]
  int v235; // [sp+360h] [bp+360h]
  int v236; // [sp+364h] [bp+364h]
  int v237; // [sp+368h] [bp+368h]
  int v238; // [sp+36Ch] [bp+36Ch]
  int v239; // [sp+370h] [bp+370h]
  int v240; // [sp+374h] [bp+374h]
  int v241; // [sp+378h] [bp+378h]
  int v242; // [sp+37Ch] [bp+37Ch]
  int v243; // [sp+380h] [bp+380h]
  int v244; // [sp+384h] [bp+384h]
  int v245; // [sp+388h] [bp+388h]
  int v246; // [sp+38Ch] [bp+38Ch]
  int v247; // [sp+390h] [bp+390h]
  int v248; // [sp+394h] [bp+394h]
  int v249; // [sp+398h] [bp+398h]
  int v250; // [sp+39Ch] [bp+39Ch]
  int v251; // [sp+3A0h] [bp+3A0h]
  int v252; // [sp+3A4h] [bp+3A4h]
  int v253; // [sp+3A8h] [bp+3A8h]
  int v254; // [sp+3ACh] [bp+3ACh]
  int v255; // [sp+3B0h] [bp+3B0h]
  int v256; // [sp+3B4h] [bp+3B4h]
  int v257; // [sp+3B8h] [bp+3B8h]
  int v258; // [sp+3BCh] [bp+3BCh]
  int v259; // [sp+3C0h] [bp+3C0h]
  int v260; // [sp+3C4h] [bp+3C4h]
  int v261; // [sp+3C8h] [bp+3C8h]
  int v262; // [sp+3CCh] [bp+3CCh]
  int v263; // [sp+3D0h] [bp+3D0h]
  int v264; // [sp+3D4h] [bp+3D4h]
  int v265; // [sp+3D8h] [bp+3D8h]
  int v266; // [sp+3DCh] [bp+3DCh]
  int v267; // [sp+3E0h] [bp+3E0h]
  int v268; // [sp+3E4h] [bp+3E4h]
  int v269; // [sp+3E8h] [bp+3E8h]
  int v270; // [sp+3ECh] [bp+3ECh]
  int v271; // [sp+3F0h] [bp+3F0h]
  int v272; // [sp+3F4h] [bp+3F4h]
  int v273; // [sp+3F8h] [bp+3F8h]
  int v274; // [sp+3FCh] [bp+3FCh]
  int v275; // [sp+400h] [bp+400h]
  int v276; // [sp+404h] [bp+404h]
  int v277; // [sp+408h] [bp+408h]
  int v278; // [sp+40Ch] [bp+40Ch]
  int v279; // [sp+410h] [bp+410h]
  int v280; // [sp+414h] [bp+414h]
  int v281; // [sp+418h] [bp+418h]
  int v282; // [sp+41Ch] [bp+41Ch]
  int v283; // [sp+420h] [bp+420h]
  int v284; // [sp+424h] [bp+424h]
  int v285; // [sp+428h] [bp+428h]
  int v286; // [sp+42Ch] [bp+42Ch]
  int v287; // [sp+430h] [bp+430h]
  int v288; // [sp+434h] [bp+434h]
  int v289; // [sp+438h] [bp+438h]
  int v290; // [sp+43Ch] [bp+43Ch]
  int v291; // [sp+440h] [bp+440h]
  int v292; // [sp+444h] [bp+444h]
  int v293; // [sp+448h] [bp+448h]
  int v294; // [sp+44Ch] [bp+44Ch]
  int v295; // [sp+450h] [bp+450h]
  int v296; // [sp+454h] [bp+454h]
  int v297; // [sp+458h] [bp+458h]
  int v298; // [sp+45Ch] [bp+45Ch]
  int v299; // [sp+460h] [bp+460h]
  int v300; // [sp+464h] [bp+464h]
  int v301; // [sp+468h] [bp+468h]
  int v302; // [sp+46Ch] [bp+46Ch]
  int v303; // [sp+470h] [bp+470h]
  int v304; // [sp+474h] [bp+474h]
  int v305; // [sp+478h] [bp+478h]
  int v306; // [sp+47Ch] [bp+47Ch]
  int v307; // [sp+480h] [bp+480h]
  int v308; // [sp+484h] [bp+484h]
  int v309; // [sp+488h] [bp+488h]
  int v310; // [sp+48Ch] [bp+48Ch]
  int v311; // [sp+490h] [bp+490h]
  int v312; // [sp+494h] [bp+494h]
  int v313; // [sp+498h] [bp+498h]
  int v314; // [sp+49Ch] [bp+49Ch]
  int v315; // [sp+4A0h] [bp+4A0h]
  int v316; // [sp+4A4h] [bp+4A4h]
  int v317; // [sp+4A8h] [bp+4A8h]
  int v318; // [sp+4ACh] [bp+4ACh]
  int v319; // [sp+4B0h] [bp+4B0h]
  int v320; // [sp+4B4h] [bp+4B4h]
  int v321; // [sp+4B8h] [bp+4B8h]
  int v322; // [sp+4BCh] [bp+4BCh]
  int v323; // [sp+4C0h] [bp+4C0h]
  int v324; // [sp+4C4h] [bp+4C4h]
  int v325; // [sp+4C8h] [bp+4C8h]
  int v326; // [sp+4CCh] [bp+4CCh]
  int v327; // [sp+4D0h] [bp+4D0h]
  int v328; // [sp+4D4h] [bp+4D4h]
  int v329; // [sp+4D8h] [bp+4D8h]
  int v330; // [sp+4DCh] [bp+4DCh]
  int v331; // [sp+4E0h] [bp+4E0h]
  int v332; // [sp+4E4h] [bp+4E4h]
  int v333; // [sp+4E8h] [bp+4E8h]
  int v334; // [sp+4ECh] [bp+4ECh]
  int v335; // [sp+4F0h] [bp+4F0h]
  int v336; // [sp+4F4h] [bp+4F4h]
  int v337; // [sp+4F8h] [bp+4F8h]
  int v338; // [sp+4FCh] [bp+4FCh]
  int v339; // [sp+500h] [bp+500h]
  int v340; // [sp+504h] [bp+504h]
  int v341; // [sp+508h] [bp+508h]
  int v342; // [sp+50Ch] [bp+50Ch]
  int v343; // [sp+510h] [bp+510h]
  int v344; // [sp+514h] [bp+514h]
  int v345; // [sp+518h] [bp+518h]
  int v346; // [sp+51Ch] [bp+51Ch]
  int v347; // [sp+520h] [bp+520h]
  int v348; // [sp+524h] [bp+524h]
  int v349; // [sp+528h] [bp+528h]
  int v350; // [sp+52Ch] [bp+52Ch]
  int v351; // [sp+530h] [bp+530h]
  int v352; // [sp+534h] [bp+534h]
  int v353; // [sp+538h] [bp+538h]
  int v354; // [sp+53Ch] [bp+53Ch]
  int v355; // [sp+540h] [bp+540h]
  int v356; // [sp+544h] [bp+544h]
  int v357; // [sp+548h] [bp+548h]
  int v358; // [sp+54Ch] [bp+54Ch]
  int v359; // [sp+550h] [bp+550h]
  int v360; // [sp+554h] [bp+554h]
  int v361; // [sp+558h] [bp+558h]
  int v362; // [sp+55Ch] [bp+55Ch]
  int v363; // [sp+560h] [bp+560h]
  int v364; // [sp+564h] [bp+564h]
  int v365; // [sp+568h] [bp+568h]
  int v366; // [sp+56Ch] [bp+56Ch]
  int v367; // [sp+570h] [bp+570h]
  int v368; // [sp+574h] [bp+574h]
  int v369; // [sp+578h] [bp+578h]
  int v370; // [sp+57Ch] [bp+57Ch]
  int v371; // [sp+580h] [bp+580h]
  int v372; // [sp+584h] [bp+584h]
  int v373; // [sp+588h] [bp+588h]
  int v374; // [sp+58Ch] [bp+58Ch]
  int v375; // [sp+590h] [bp+590h]
  int v376; // [sp+594h] [bp+594h]
  int v377; // [sp+598h] [bp+598h]
  int v378; // [sp+59Ch] [bp+59Ch]
  int v379; // [sp+5A0h] [bp+5A0h]
  int v380; // [sp+5A4h] [bp+5A4h]
  int v381; // [sp+5A8h] [bp+5A8h]
  int v382; // [sp+5ACh] [bp+5ACh]
  int v383; // [sp+5B0h] [bp+5B0h]
  int v384; // [sp+5B4h] [bp+5B4h]
  int v385; // [sp+5B8h] [bp+5B8h]
  int v386; // [sp+5BCh] [bp+5BCh]
  int v387; // [sp+5C0h] [bp+5C0h]
  int v388; // [sp+5C4h] [bp+5C4h]
  int v389; // [sp+5C8h] [bp+5C8h]
  int v390; // [sp+5CCh] [bp+5CCh]
  int v391; // [sp+5D0h] [bp+5D0h]
  int v392; // [sp+5D4h] [bp+5D4h]
  int v393; // [sp+5D8h] [bp+5D8h]
  int v394; // [sp+5DCh] [bp+5DCh]
  int v395; // [sp+5E0h] [bp+5E0h]
  int v396; // [sp+5E4h] [bp+5E4h]
  int v397; // [sp+5E8h] [bp+5E8h]
  int v398; // [sp+5ECh] [bp+5ECh]
  int v399; // [sp+5F0h] [bp+5F0h]
  int v400; // [sp+5F4h] [bp+5F4h]
  int v401; // [sp+5F8h] [bp+5F8h]
  int v402; // [sp+5FCh] [bp+5FCh]
  int v403; // [sp+600h] [bp+600h]
  int v404; // [sp+604h] [bp+604h]
  int v405; // [sp+608h] [bp+608h]
  int v406; // [sp+60Ch] [bp+60Ch]
  int v407; // [sp+610h] [bp+610h]
  int v408; // [sp+614h] [bp+614h]
  int v409; // [sp+618h] [bp+618h]
  int v410; // [sp+61Ch] [bp+61Ch]
  int v411; // [sp+620h] [bp+620h]
  int v412; // [sp+624h] [bp+624h]
  int v413; // [sp+628h] [bp+628h]
  int v414; // [sp+62Ch] [bp+62Ch]
  int v415; // [sp+630h] [bp+630h]
  int v416; // [sp+634h] [bp+634h]
  int v417; // [sp+638h] [bp+638h]
  int v418; // [sp+63Ch] [bp+63Ch]
  int v419; // [sp+640h] [bp+640h]
  int v420; // [sp+644h] [bp+644h]
  int v421; // [sp+648h] [bp+648h]
  int v422; // [sp+64Ch] [bp+64Ch]
  int v423; // [sp+650h] [bp+650h]
  int v424; // [sp+654h] [bp+654h]
  int v425; // [sp+658h] [bp+658h]
  int v426; // [sp+65Ch] [bp+65Ch]
  int v427; // [sp+660h] [bp+660h]
  int v428; // [sp+664h] [bp+664h]
  int v429; // [sp+668h] [bp+668h]
  int v430; // [sp+66Ch] [bp+66Ch]
  int v431; // [sp+670h] [bp+670h]
  int v432; // [sp+674h] [bp+674h]
  int v433; // [sp+678h] [bp+678h]
  int v434; // [sp+67Ch] [bp+67Ch]
  int v435; // [sp+680h] [bp+680h]
  int v436; // [sp+684h] [bp+684h]
  int v437; // [sp+688h] [bp+688h]
  int v438; // [sp+68Ch] [bp+68Ch]
  int v439; // [sp+690h] [bp+690h]
  int v440; // [sp+694h] [bp+694h]
  int v441; // [sp+698h] [bp+698h]
  int v442; // [sp+69Ch] [bp+69Ch]
  int v443; // [sp+6A0h] [bp+6A0h]
  int v444; // [sp+6A4h] [bp+6A4h]
  int v445; // [sp+6A8h] [bp+6A8h]
  int v446; // [sp+6ACh] [bp+6ACh]
  int v447; // [sp+6B0h] [bp+6B0h]
  int v448; // [sp+6B4h] [bp+6B4h]
  int v449; // [sp+6B8h] [bp+6B8h]
  int v450; // [sp+6BCh] [bp+6BCh]
  int v451; // [sp+6C0h] [bp+6C0h]
  int v452; // [sp+6C4h] [bp+6C4h]
  int v453; // [sp+6C8h] [bp+6C8h]
  int v454; // [sp+6CCh] [bp+6CCh]
  int v455; // [sp+6D0h] [bp+6D0h]
  int v456; // [sp+6D4h] [bp+6D4h]
  int v457; // [sp+6D8h] [bp+6D8h]
  int v458; // [sp+6DCh] [bp+6DCh]
  int v459; // [sp+6E0h] [bp+6E0h]
  int v460; // [sp+6E4h] [bp+6E4h]
  int v461; // [sp+6E8h] [bp+6E8h]
  int v462; // [sp+6ECh] [bp+6ECh]
  int v463; // [sp+6F0h] [bp+6F0h]
  int v464; // [sp+6F4h] [bp+6F4h]
  int v465; // [sp+6F8h] [bp+6F8h]
  int v466; // [sp+6FCh] [bp+6FCh]
  int v467; // [sp+700h] [bp+700h]
  int v468; // [sp+704h] [bp+704h]
  int v469; // [sp+708h] [bp+708h]
  int v470; // [sp+70Ch] [bp+70Ch]
  int v471; // [sp+710h] [bp+710h]
  int v472; // [sp+714h] [bp+714h]
  int v473; // [sp+718h] [bp+718h]
  int v474; // [sp+71Ch] [bp+71Ch]
  int v475; // [sp+720h] [bp+720h]
  int v476; // [sp+724h] [bp+724h]
  int v477; // [sp+728h] [bp+728h]
  int v478; // [sp+72Ch] [bp+72Ch]
  int v479; // [sp+730h] [bp+730h]
  int v480; // [sp+734h] [bp+734h]
  int v481; // [sp+738h] [bp+738h]
  int v482; // [sp+73Ch] [bp+73Ch]
  int v483; // [sp+740h] [bp+740h]
  int v484; // [sp+744h] [bp+744h]
  int v485; // [sp+748h] [bp+748h]
  int v486; // [sp+74Ch] [bp+74Ch]
  int v487; // [sp+750h] [bp+750h]
  int v488; // [sp+754h] [bp+754h]
  int v489; // [sp+758h] [bp+758h]
  int v490; // [sp+75Ch] [bp+75Ch]
  int v491; // [sp+760h] [bp+760h]
  int v492; // [sp+764h] [bp+764h]
  int v493; // [sp+768h] [bp+768h]
  int v494; // [sp+76Ch] [bp+76Ch]
  int v495; // [sp+770h] [bp+770h]
  int v496; // [sp+774h] [bp+774h]
  int v497; // [sp+778h] [bp+778h]
  int v498; // [sp+77Ch] [bp+77Ch]
  int v499; // [sp+780h] [bp+780h]
  int v500; // [sp+784h] [bp+784h]
  int v501; // [sp+788h] [bp+788h]
  int v502; // [sp+78Ch] [bp+78Ch]
  int v503; // [sp+790h] [bp+790h]
  int v504; // [sp+794h] [bp+794h]
  int v505; // [sp+798h] [bp+798h]
  int v506; // [sp+79Ch] [bp+79Ch]
  int v507; // [sp+7A0h] [bp+7A0h]
  int v508; // [sp+7A4h] [bp+7A4h]
  int v509; // [sp+7A8h] [bp+7A8h]
  int v510; // [sp+7ACh] [bp+7ACh]
  int v511; // [sp+7B0h] [bp+7B0h]
  int v512; // [sp+7B4h] [bp+7B4h]
  int v513; // [sp+7B8h] [bp+7B8h]
  int v514; // [sp+7BCh] [bp+7BCh]
  int v515; // [sp+7C0h] [bp+7C0h]
  int v516; // [sp+7C4h] [bp+7C4h]
  int v517; // [sp+7C8h] [bp+7C8h]
  int v518; // [sp+7CCh] [bp+7CCh]
  int v519; // [sp+7D0h] [bp+7D0h]
  int v520; // [sp+7D4h] [bp+7D4h]
  int v521; // [sp+7D8h] [bp+7D8h]
  int v522; // [sp+7DCh] [bp+7DCh]
  int v523; // [sp+7E0h] [bp+7E0h]
  int v524; // [sp+7E4h] [bp+7E4h]
  int v525; // [sp+7E8h] [bp+7E8h]
  int v526; // [sp+7ECh] [bp+7ECh]
  int v527; // [sp+7F0h] [bp+7F0h]
  int v528; // [sp+7F4h] [bp+7F4h]
  int v529; // [sp+7F8h] [bp+7F8h]
  int v530; // [sp+7FCh] [bp+7FCh]
  int v531; // [sp+800h] [bp+800h]
  int v532; // [sp+804h] [bp+804h]
  int v533; // [sp+808h] [bp+808h]
  int v534; // [sp+80Ch] [bp+80Ch]
  int v535; // [sp+810h] [bp+810h]
  int v536; // [sp+814h] [bp+814h]
  int v537; // [sp+818h] [bp+818h]
  int v538; // [sp+81Ch] [bp+81Ch]
  int v539; // [sp+820h] [bp+820h]
  int v540; // [sp+824h] [bp+824h]
  int v541; // [sp+828h] [bp+828h]
  int v542; // [sp+82Ch] [bp+82Ch]
  int v543; // [sp+830h] [bp+830h]
  int v544; // [sp+834h] [bp+834h]
  int v545; // [sp+838h] [bp+838h]
  int v546; // [sp+83Ch] [bp+83Ch]
  int v547; // [sp+840h] [bp+840h]
  int v548; // [sp+844h] [bp+844h]
  int v549; // [sp+848h] [bp+848h]
  int v550; // [sp+84Ch] [bp+84Ch]
  int v551; // [sp+850h] [bp+850h]
  int v552; // [sp+854h] [bp+854h]
  int v553; // [sp+858h] [bp+858h]
  int v554; // [sp+85Ch] [bp+85Ch]
  int v555; // [sp+860h] [bp+860h]
  int v556; // [sp+864h] [bp+864h]
  int v557; // [sp+868h] [bp+868h]
  int v558; // [sp+86Ch] [bp+86Ch]
  int v559; // [sp+870h] [bp+870h]
  int v560; // [sp+874h] [bp+874h]
  int v561; // [sp+878h] [bp+878h]
  int v562; // [sp+87Ch] [bp+87Ch]
  int v563; // [sp+880h] [bp+880h]
  int v564; // [sp+884h] [bp+884h]
  int v565; // [sp+888h] [bp+888h]
  int v566; // [sp+88Ch] [bp+88Ch]
  int v567; // [sp+890h] [bp+890h]
  int v568; // [sp+894h] [bp+894h]
  int v569; // [sp+898h] [bp+898h]
  int v570; // [sp+89Ch] [bp+89Ch]
  int v571; // [sp+8A0h] [bp+8A0h]
  int v572; // [sp+8A4h] [bp+8A4h]
  int v573; // [sp+8A8h] [bp+8A8h]
  int v574; // [sp+8ACh] [bp+8ACh]
  int v575; // [sp+8B0h] [bp+8B0h]
  int v576; // [sp+8B4h] [bp+8B4h]
  int v577; // [sp+8B8h] [bp+8B8h]
  int v578; // [sp+8BCh] [bp+8BCh]
  int v579; // [sp+8C0h] [bp+8C0h]
  int v580; // [sp+8C4h] [bp+8C4h]
  int v581; // [sp+8C8h] [bp+8C8h]
  int v582; // [sp+8CCh] [bp+8CCh]
  int v583; // [sp+8D0h] [bp+8D0h]
  int v584; // [sp+8D4h] [bp+8D4h]
  int v585; // [sp+8D8h] [bp+8D8h]
  int v586; // [sp+8DCh] [bp+8DCh]
  int v587; // [sp+8E0h] [bp+8E0h]
  int v588; // [sp+8E4h] [bp+8E4h]
  int v589; // [sp+8E8h] [bp+8E8h]
  int v590; // [sp+8ECh] [bp+8ECh]
  int v591; // [sp+8F0h] [bp+8F0h]
  int v592; // [sp+8F4h] [bp+8F4h]
  int v593; // [sp+8F8h] [bp+8F8h]
  int v594; // [sp+8FCh] [bp+8FCh]
  int v595; // [sp+900h] [bp+900h]
  int v596; // [sp+904h] [bp+904h]
  int v597; // [sp+908h] [bp+908h]
  int v598; // [sp+90Ch] [bp+90Ch]
  int v599; // [sp+910h] [bp+910h]
  int v600; // [sp+914h] [bp+914h]
  int v601; // [sp+918h] [bp+918h]
  int v602; // [sp+91Ch] [bp+91Ch]
  int v603; // [sp+920h] [bp+920h]
  int v604; // [sp+924h] [bp+924h]
  int v605; // [sp+928h] [bp+928h]
  int v606; // [sp+92Ch] [bp+92Ch]
  int v607; // [sp+930h] [bp+930h]
  int v608; // [sp+934h] [bp+934h]
  int v609; // [sp+938h] [bp+938h]
  int v610; // [sp+93Ch] [bp+93Ch]
  int v611; // [sp+940h] [bp+940h]
  int v612; // [sp+944h] [bp+944h]
  int v613; // [sp+948h] [bp+948h]
  int v614; // [sp+94Ch] [bp+94Ch]
  int v615; // [sp+950h] [bp+950h]
  int v616; // [sp+954h] [bp+954h]
  int v617; // [sp+958h] [bp+958h]
  int v618; // [sp+95Ch] [bp+95Ch]
  int v619; // [sp+960h] [bp+960h]
  int v620; // [sp+964h] [bp+964h]
  int v621; // [sp+968h] [bp+968h]
  int v622; // [sp+96Ch] [bp+96Ch]
  int v623; // [sp+970h] [bp+970h]
  int v624; // [sp+974h] [bp+974h]
  int v625; // [sp+978h] [bp+978h]
  int v626; // [sp+97Ch] [bp+97Ch]
  int v627; // [sp+980h] [bp+980h]
  int v628; // [sp+984h] [bp+984h]
  int v629; // [sp+988h] [bp+988h]
  int v630; // [sp+98Ch] [bp+98Ch]
  int v631; // [sp+990h] [bp+990h]
  int v632; // [sp+994h] [bp+994h]
  int v633; // [sp+998h] [bp+998h]
  int v634; // [sp+99Ch] [bp+99Ch]
  int v635; // [sp+9A0h] [bp+9A0h]
  int v636; // [sp+9A4h] [bp+9A4h]
  int v637; // [sp+9A8h] [bp+9A8h]
  int v638; // [sp+9ACh] [bp+9ACh]
  int v639; // [sp+9B0h] [bp+9B0h]
  int v640; // [sp+9B4h] [bp+9B4h]
  int v641; // [sp+9B8h] [bp+9B8h]
  int v642; // [sp+9BCh] [bp+9BCh]
  int v643; // [sp+9C0h] [bp+9C0h]
  int v644; // [sp+9C4h] [bp+9C4h]
  int v645; // [sp+9C8h] [bp+9C8h]
  int v646; // [sp+9CCh] [bp+9CCh]
  int v647; // [sp+9D0h] [bp+9D0h]
  int v648; // [sp+9D4h] [bp+9D4h]
  int v649; // [sp+9D8h] [bp+9D8h]
  int v650; // [sp+9DCh] [bp+9DCh]
  int v651; // [sp+9E0h] [bp+9E0h]
  int v652; // [sp+9E4h] [bp+9E4h]
  int v653; // [sp+9E8h] [bp+9E8h]
  int v654; // [sp+9ECh] [bp+9ECh]
  int v655; // [sp+9F0h] [bp+9F0h]
  int v656; // [sp+9F4h] [bp+9F4h]
  int v657; // [sp+9F8h] [bp+9F8h]
  int v658; // [sp+9FCh] [bp+9FCh]
  int v659; // [sp+A00h] [bp+A00h]
  int v660; // [sp+A04h] [bp+A04h]
  int v661; // [sp+A08h] [bp+A08h]
  int v662; // [sp+A0Ch] [bp+A0Ch]
  int v663; // [sp+A10h] [bp+A10h]
  int v664; // [sp+A14h] [bp+A14h]
  int v665; // [sp+A18h] [bp+A18h]
  int v666; // [sp+A1Ch] [bp+A1Ch]
  int v667; // [sp+A20h] [bp+A20h]
  int v668; // [sp+A24h] [bp+A24h]
  int v669; // [sp+A28h] [bp+A28h]
  int v670; // [sp+A2Ch] [bp+A2Ch]
  int v671; // [sp+A30h] [bp+A30h]
  int v672; // [sp+A34h] [bp+A34h]
  int v673; // [sp+A38h] [bp+A38h]
  int v674; // [sp+A3Ch] [bp+A3Ch]
  int v675; // [sp+A40h] [bp+A40h]
  int v676; // [sp+A44h] [bp+A44h]
  int v677; // [sp+A48h] [bp+A48h]
  int v678; // [sp+A4Ch] [bp+A4Ch]
  int v679; // [sp+A50h] [bp+A50h]
  int v680; // [sp+A54h] [bp+A54h]
  int v681; // [sp+A58h] [bp+A58h]
  int v682; // [sp+A5Ch] [bp+A5Ch]
  int v683; // [sp+A60h] [bp+A60h]
  int v684; // [sp+A64h] [bp+A64h]
  int v685; // [sp+A68h] [bp+A68h]
  int v686; // [sp+A6Ch] [bp+A6Ch]
  int v687; // [sp+A70h] [bp+A70h]
  int v688; // [sp+A74h] [bp+A74h]
  int v689; // [sp+A78h] [bp+A78h]
  int v690; // [sp+A7Ch] [bp+A7Ch]
  int v691; // [sp+A80h] [bp+A80h]
  int v692; // [sp+A84h] [bp+A84h]
  int v693; // [sp+A88h] [bp+A88h]
  int v694; // [sp+A8Ch] [bp+A8Ch]
  int v695; // [sp+A90h] [bp+A90h]
  int v696; // [sp+A94h] [bp+A94h]
  int v697; // [sp+A98h] [bp+A98h]
  int v698; // [sp+A9Ch] [bp+A9Ch]
  int v699; // [sp+AA0h] [bp+AA0h]
  int v700; // [sp+AA4h] [bp+AA4h]
  int v701; // [sp+AA8h] [bp+AA8h]
  int v702; // [sp+AACh] [bp+AACh]
  int v703; // [sp+AB0h] [bp+AB0h]
  int v704; // [sp+AB4h] [bp+AB4h]
  int v705; // [sp+AB8h] [bp+AB8h]
  int v706; // [sp+ABCh] [bp+ABCh]
  int v707; // [sp+AC0h] [bp+AC0h]
  int v708; // [sp+AC4h] [bp+AC4h]
  int v709; // [sp+AC8h] [bp+AC8h]
  int v710; // [sp+ACCh] [bp+ACCh]
  int v711; // [sp+AD0h] [bp+AD0h]
  int v712; // [sp+AD4h] [bp+AD4h]
  int v713; // [sp+AD8h] [bp+AD8h]
  int v714; // [sp+ADCh] [bp+ADCh]
  int v715; // [sp+AE0h] [bp+AE0h]
  int v716; // [sp+AE4h] [bp+AE4h]
  int v717; // [sp+AE8h] [bp+AE8h]
  int v718; // [sp+AECh] [bp+AECh]
  int v719; // [sp+AF0h] [bp+AF0h]
  int v720; // [sp+AF4h] [bp+AF4h]
  int v721; // [sp+AF8h] [bp+AF8h]
  int v722; // [sp+AFCh] [bp+AFCh]
  int v723; // [sp+B00h] [bp+B00h]
  int v724; // [sp+B04h] [bp+B04h]
  int v725; // [sp+B08h] [bp+B08h]
  int v726; // [sp+B0Ch] [bp+B0Ch]
  int v727; // [sp+B10h] [bp+B10h]
  int v728; // [sp+B14h] [bp+B14h]
  int v729; // [sp+B18h] [bp+B18h]
  int v730; // [sp+B1Ch] [bp+B1Ch]
  int v731; // [sp+B20h] [bp+B20h]
  int v732; // [sp+B24h] [bp+B24h]
  int v733; // [sp+B28h] [bp+B28h]
  int v734; // [sp+B2Ch] [bp+B2Ch]
  int v735; // [sp+B30h] [bp+B30h]
  int v736; // [sp+B34h] [bp+B34h]
  int v737; // [sp+B38h] [bp+B38h]
  int v738; // [sp+B3Ch] [bp+B3Ch]
  int v739; // [sp+B40h] [bp+B40h]
  int v740; // [sp+B44h] [bp+B44h]
  int v741; // [sp+B48h] [bp+B48h]
  int v742; // [sp+B4Ch] [bp+B4Ch]
  int v743; // [sp+B50h] [bp+B50h]
  int v744; // [sp+B54h] [bp+B54h]
  int v745; // [sp+B58h] [bp+B58h]
  int v746; // [sp+B5Ch] [bp+B5Ch]
  int v747; // [sp+B60h] [bp+B60h]
  int v748; // [sp+B64h] [bp+B64h]
  int v749; // [sp+B68h] [bp+B68h]
  int v750; // [sp+B6Ch] [bp+B6Ch]
  int v751; // [sp+B70h] [bp+B70h]
  int v752; // [sp+B74h] [bp+B74h]
  int v753; // [sp+B78h] [bp+B78h]
  int v754; // [sp+B7Ch] [bp+B7Ch]
  int v755; // [sp+B80h] [bp+B80h]
  int v756; // [sp+B84h] [bp+B84h]
  int v757; // [sp+B88h] [bp+B88h]
  int v758; // [sp+B8Ch] [bp+B8Ch]
  int v759; // [sp+B90h] [bp+B90h]
  int v760; // [sp+B94h] [bp+B94h]
  int v761; // [sp+B98h] [bp+B98h]
  int v762; // [sp+B9Ch] [bp+B9Ch]
  int v763; // [sp+BA0h] [bp+BA0h]
  int v764; // [sp+BA4h] [bp+BA4h]
  int v765; // [sp+BA8h] [bp+BA8h]
  int v766; // [sp+BACh] [bp+BACh]
  int v767; // [sp+BB0h] [bp+BB0h]
  int v768; // [sp+BB4h] [bp+BB4h]
  int v769; // [sp+BB8h] [bp+BB8h]
  int v770; // [sp+BBCh] [bp+BBCh]
  int v771; // [sp+BC0h] [bp+BC0h]
  int v772; // [sp+BC4h] [bp+BC4h]
  int v773; // [sp+BC8h] [bp+BC8h]
  int v774; // [sp+BCCh] [bp+BCCh]
  int v775; // [sp+BD0h] [bp+BD0h]
  int v776; // [sp+BD4h] [bp+BD4h]
  int v777; // [sp+BD8h] [bp+BD8h]
  int v778; // [sp+BDCh] [bp+BDCh]
  int v779; // [sp+BE0h] [bp+BE0h]
  int v780; // [sp+BE4h] [bp+BE4h]
  int v781; // [sp+BE8h] [bp+BE8h]
  int v782; // [sp+BECh] [bp+BECh]
  int v783; // [sp+BF0h] [bp+BF0h]
  int v784; // [sp+BF4h] [bp+BF4h]
  int v785; // [sp+BF8h] [bp+BF8h]
  int v786; // [sp+BFCh] [bp+BFCh]
  int v787; // [sp+C00h] [bp+C00h]
  int v788; // [sp+C04h] [bp+C04h]
  int v789; // [sp+C08h] [bp+C08h]
  int v790; // [sp+C0Ch] [bp+C0Ch]
  int v791; // [sp+C10h] [bp+C10h]
  int v792; // [sp+C14h] [bp+C14h]
  int v793; // [sp+C18h] [bp+C18h]
  int v794; // [sp+C1Ch] [bp+C1Ch]
  int v795; // [sp+C20h] [bp+C20h]
  int v796; // [sp+C24h] [bp+C24h]
  unsigned __int8 *v797; // [sp+C28h] [bp+C28h]
  int v798; // [sp+C2Ch] [bp+C2Ch]
  unsigned int jj; // [sp+C30h] [bp+C30h]
  int v800; // [sp+C34h] [bp+C34h]
  unsigned int ii; // [sp+C38h] [bp+C38h]
  int v802; // [sp+C3Ch] [bp+C3Ch]
  unsigned int n; // [sp+C40h] [bp+C40h]
  int v804; // [sp+C44h] [bp+C44h]
  unsigned int m; // [sp+C48h] [bp+C48h]
  int v806; // [sp+C4Ch] [bp+C4Ch]
  unsigned int k; // [sp+C50h] [bp+C50h]
  int v808; // [sp+C54h] [bp+C54h]
  unsigned int j; // [sp+C58h] [bp+C58h]
  int v810; // [sp+C5Ch] [bp+C5Ch]
  unsigned int i; // [sp+C60h] [bp+C60h]
  int kk; // [sp+C64h] [bp+C64h]

  v797 = a1;
  v796 = *a1;
  v795 = a1[16];
  v794 = a1[32];
  v793 = a1[48];
  v792 = v794 + v796;
  v791 = v796 + 16 * v794;
  v790 = v796 - v794;
  v789 = v796 - 16 * v794;
  v788 = v793 + v795;
  v787 = (unsigned __int8)(((_BYTE)v793 << 6) + 4 * v795) - (((v793 << 6) + 4 * v795) >> 8);
  v786 = 16 * v795 - 16 * v793;
  v785 = (unsigned __int8)(4 * v793 + ((_BYTE)v795 << 6)) - ((4 * v793 + (v795 << 6)) >> 8);
  v784 = v793 + v795 + v794 + v796;
  v783 = v787 + v791;
  v782 = v786 + v796 - v794;
  v781 = v785 + v789;
  v780 = v794 + v796 - (v793 + v795);
  v779 = v791 - v787;
  v778 = v796 - v794 - v786;
  v777 = v789 - v785;
  v776 = a1[8];
  v775 = a1[24];
  v774 = a1[40];
  v773 = a1[56];
  v772 = v774 + v776;
  v771 = v776 + 16 * v774;
  v770 = v776 - v774;
  v769 = v776 - 16 * v774;
  v768 = v773 + v775;
  v767 = (unsigned __int8)(((_BYTE)v773 << 6) + 4 * v775) - (((v773 << 6) + 4 * v775) >> 8);
  v766 = 16 * v775 - 16 * v773;
  v765 = (unsigned __int8)(4 * v773 + ((_BYTE)v775 << 6)) - ((4 * v773 + (v775 << 6)) >> 8);
  v764 = v773 + v775 + v774 + v776;
  v763 = v767 + v771;
  v762 = v766 + v776 - v774;
  v761 = v765 + v769;
  v760 = v774 + v776 - (v773 + v775);
  v759 = v771 - v767;
  v758 = v776 - v774 - v766;
  v757 = v769 - v765;
  v22 = v784 + v764;
  v23 = 2 * (v767 + v771) + v787 + v791;
  v24 = 4 * v762 + v782;
  v25 = 8 * (v765 + v769) + v785 + v789;
  v26 = 16 * v760 + v780;
  v27 = 32 * (v771 - v767) + v791 - v787;
  v28 = (v758 << 6) + v778;
  v29 = ((v769 - v765) << 7) + v789 - v785;
  v30 = v784 - v764;
  v31 = v787 + v791 - 2 * (v767 + v771);
  v32 = v782 - 4 * v762;
  v33 = v785 + v789 - 8 * (v765 + v769);
  v34 = v780 - 16 * v760;
  v35 = v791 - v787 - 32 * (v771 - v767);
  v36 = v778 - (v758 << 6);
  v37 = v789 - v785 - ((v769 - v765) << 7);
  v756 = a1[4];
  v755 = a1[20];
  v754 = a1[36];
  v753 = a1[52];
  v752 = v754 + v756;
  v751 = v756 + 16 * v754;
  v750 = v756 - v754;
  v749 = v756 - 16 * v754;
  v748 = v753 + v755;
  v747 = (unsigned __int8)(((_BYTE)v753 << 6) + 4 * v755) - (((v753 << 6) + 4 * v755) >> 8);
  v746 = 16 * v755 - 16 * v753;
  v745 = (unsigned __int8)(4 * v753 + ((_BYTE)v755 << 6)) - ((4 * v753 + (v755 << 6)) >> 8);
  v744 = v753 + v755 + v754 + v756;
  v743 = v747 + v751;
  v742 = v746 + v756 - v754;
  v741 = v745 + v749;
  v740 = v754 + v756 - (v753 + v755);
  v739 = v751 - v747;
  v738 = v756 - v754 - v746;
  v737 = v749 - v745;
  v736 = a1[12];
  v735 = a1[28];
  v734 = a1[44];
  v733 = a1[60];
  v732 = v734 + v736;
  v731 = v736 + 16 * v734;
  v730 = v736 - v734;
  v729 = v736 - 16 * v734;
  v728 = v733 + v735;
  v727 = (unsigned __int8)(((_BYTE)v733 << 6) + 4 * v735) - (((v733 << 6) + 4 * v735) >> 8);
  v726 = 16 * v735 - 16 * v733;
  v725 = (unsigned __int8)(4 * v733 + ((_BYTE)v735 << 6)) - ((4 * v733 + (v735 << 6)) >> 8);
  v724 = v733 + v735 + v734 + v736;
  v723 = v727 + v731;
  v722 = v726 + v736 - v734;
  v721 = v725 + v729;
  v720 = v734 + v736 - (v733 + v735);
  v719 = v731 - v727;
  v718 = v736 - v734 - v726;
  v717 = v729 - v725;
  v39 = 2 * (v727 + v731) + v747 + v751;
  v40 = 4 * v722 + v742;
  v41 = 8 * (v725 + v729) + v745 + v749;
  v42 = 16 * v720 + v740;
  v43 = 32 * (v731 - v727) + v751 - v747;
  v44 = (v718 << 6) + v738;
  v45 = ((v729 - v725) << 7) + v749 - v745;
  v46 = v744 - v724;
  v47 = v747 + v751 - 2 * (v727 + v731);
  v48 = v742 - 4 * v722;
  v49 = v745 + v749 - 8 * (v725 + v729);
  v50 = v740 - 16 * v720;
  v51 = v751 - v747 - 32 * (v731 - v727);
  v52 = v738 - (v718 << 6);
  v53 = v749 - v745 - ((v729 - v725) << 7);
  v716 = v784 + v764;
  v715 = v744 + v724;
  v22 = v784 + v764 + v744 + v724;
  v38 = v784 + v764 - (v744 + v724);
  v810 = 0;
  for ( i = 0; ; *(&v22 + i + 16) = v716 - v714 )
  {
    v716 = *(&v22 + i + 1);
    v715 = *(&v22 + i + 17);
    v714 = ((v715 * dword_1D48C8[v810 + 8]) >> 16) + (unsigned __int16)(v715 * dword_1D48C8[v810 + 8]);
    *(&v22 + i + 1) = v716 + v714;
    *(&v22 + i + 17) = v716 - v714;
    v716 = *(&v22 + i + 2);
    v715 = *(&v22 + i + 18);
    v714 = ((v715 * dword_1D48C8[v810 + 16]) >> 16) + (unsigned __int16)(v715 * dword_1D48C8[v810 + 16]);
    *(&v22 + i + 2) = v716 + v714;
    *(&v22 + i + 18) = v716 - v714;
    v716 = *(&v22 + i + 3);
    v715 = *(&v22 + i + 19);
    v714 = ((v715 * dword_1D48C8[v810 + 24]) >> 16) + (unsigned __int16)(v715 * dword_1D48C8[v810 + 24]);
    *(&v22 + i + 3) = v716 + v714;
    *(&v22 + i + 19) = v716 - v714;
    i += 4;
    v810 += 32;
    if ( i > 0xF )
      break;
    v716 = *(&v22 + i);
    v715 = *(&v22 + i + 16);
    v714 = ((v715 * dword_1D48C8[v810]) >> 16) + (unsigned __int16)(v715 * dword_1D48C8[v810]);
    *(&v22 + i) = v716 + v714;
  }
  v713 = v797[2];
  v712 = v797[18];
  v711 = v797[34];
  v710 = v797[50];
  v709 = v711 + v713;
  v708 = v713 + 16 * v711;
  v707 = v713 - v711;
  v706 = v713 - 16 * v711;
  v705 = v710 + v712;
  v704 = (unsigned __int8)(((_BYTE)v710 << 6) + 4 * v712) - (((v710 << 6) + 4 * v712) >> 8);
  v703 = 16 * v712 - 16 * v710;
  v702 = (unsigned __int8)(4 * v710 + ((_BYTE)v712 << 6)) - ((4 * v710 + (v712 << 6)) >> 8);
  v701 = v710 + v712 + v711 + v713;
  v700 = v704 + v708;
  v699 = v703 + v713 - v711;
  v698 = v702 + v706;
  v697 = v711 + v713 - (v710 + v712);
  v696 = v708 - v704;
  v695 = v713 - v711 - v703;
  v694 = v706 - v702;
  v693 = v797[10];
  v692 = v797[26];
  v691 = v797[42];
  v690 = v797[58];
  v689 = v691 + v693;
  v688 = v693 + 16 * v691;
  v687 = v693 - v691;
  v686 = v693 - 16 * v691;
  v685 = v690 + v692;
  v684 = (unsigned __int8)(((_BYTE)v690 << 6) + 4 * v692) - (((v690 << 6) + 4 * v692) >> 8);
  v683 = 16 * v692 - 16 * v690;
  v682 = (unsigned __int8)(4 * v690 + ((_BYTE)v692 << 6)) - ((4 * v690 + (v692 << 6)) >> 8);
  v681 = v690 + v692 + v691 + v693;
  v680 = v684 + v688;
  v679 = v683 + v693 - v691;
  v678 = v682 + v686;
  v677 = v691 + v693 - (v690 + v692);
  v676 = v688 - v684;
  v675 = v693 - v691 - v683;
  v674 = v686 - v682;
  v54 = v701 + v681;
  v55 = 2 * (v684 + v688) + v704 + v708;
  v56 = 4 * v679 + v699;
  v57 = 8 * (v682 + v686) + v702 + v706;
  v58 = 16 * v677 + v697;
  v59 = 32 * (v688 - v684) + v708 - v704;
  v60 = (v675 << 6) + v695;
  v61 = ((v686 - v682) << 7) + v706 - v702;
  v62 = v701 - v681;
  v63 = v704 + v708 - 2 * (v684 + v688);
  v64 = v699 - 4 * v679;
  v65 = v702 + v706 - 8 * (v682 + v686);
  v66 = v697 - 16 * v677;
  v67 = v708 - v704 - 32 * (v688 - v684);
  v68 = v695 - (v675 << 6);
  v69 = v706 - v702 - ((v686 - v682) << 7);
  v673 = v797[6];
  v672 = v797[22];
  v671 = v797[38];
  v670 = v797[54];
  v669 = v671 + v673;
  v668 = v673 + 16 * v671;
  v667 = v673 - v671;
  v666 = v673 - 16 * v671;
  v665 = v670 + v672;
  v664 = (unsigned __int8)(((_BYTE)v670 << 6) + 4 * v672) - (((v670 << 6) + 4 * v672) >> 8);
  v663 = 16 * v672 - 16 * v670;
  v662 = (unsigned __int8)(4 * v670 + ((_BYTE)v672 << 6)) - ((4 * v670 + (v672 << 6)) >> 8);
  v661 = v670 + v672 + v671 + v673;
  v660 = v664 + v668;
  v659 = v663 + v673 - v671;
  v658 = v662 + v666;
  v657 = v671 + v673 - (v670 + v672);
  v656 = v668 - v664;
  v655 = v673 - v671 - v663;
  v654 = v666 - v662;
  v653 = v797[14];
  v652 = v797[30];
  v651 = v797[46];
  v650 = v797[62];
  v649 = v651 + v653;
  v648 = v653 + 16 * v651;
  v647 = v653 - v651;
  v646 = v653 - 16 * v651;
  v645 = v650 + v652;
  v644 = (unsigned __int8)(((_BYTE)v650 << 6) + 4 * v652) - (((v650 << 6) + 4 * v652) >> 8);
  v643 = 16 * v652 - 16 * v650;
  v642 = (unsigned __int8)(4 * v650 + ((_BYTE)v652 << 6)) - ((4 * v650 + (v652 << 6)) >> 8);
  v641 = v650 + v652 + v651 + v653;
  v640 = v644 + v648;
  v639 = v643 + v653 - v651;
  v638 = v642 + v646;
  v637 = v651 + v653 - (v650 + v652);
  v636 = v648 - v644;
  v635 = v653 - v651 - v643;
  v634 = v646 - v642;
  v71 = 2 * (v644 + v648) + v664 + v668;
  v72 = 4 * v639 + v659;
  v73 = 8 * (v642 + v646) + v662 + v666;
  v74 = 16 * v637 + v657;
  v75 = 32 * (v648 - v644) + v668 - v664;
  v76 = (v635 << 6) + v655;
  v77 = ((v646 - v642) << 7) + v666 - v662;
  v78 = v661 - v641;
  v79 = v664 + v668 - 2 * (v644 + v648);
  v80 = v659 - 4 * v639;
  v81 = v662 + v666 - 8 * (v642 + v646);
  v82 = v657 - 16 * v637;
  v83 = v668 - v664 - 32 * (v648 - v644);
  v84 = v655 - (v635 << 6);
  v85 = v666 - v662 - ((v646 - v642) << 7);
  v633 = v701 + v681;
  v632 = v661 + v641;
  v54 = v701 + v681 + v661 + v641;
  v70 = v701 + v681 - (v661 + v641);
  v808 = 0;
  for ( j = 0; ; *(&v22 + j + 48) = v633 - v631 )
  {
    v633 = *(&v22 + j + 33);
    v632 = *(&v22 + j + 49);
    v631 = ((v632 * dword_1D48C8[v808 + 8]) >> 16) + (unsigned __int16)(v632 * dword_1D48C8[v808 + 8]);
    *(&v22 + j + 33) = v633 + v631;
    *(&v22 + j + 49) = v633 - v631;
    v633 = *(&v22 + j + 34);
    v632 = *(&v22 + j + 50);
    v631 = ((v632 * dword_1D48C8[v808 + 16]) >> 16) + (unsigned __int16)(v632 * dword_1D48C8[v808 + 16]);
    *(&v22 + j + 34) = v633 + v631;
    *(&v22 + j + 50) = v633 - v631;
    v633 = *(&v22 + j + 35);
    v632 = *(&v22 + j + 51);
    v631 = ((v632 * dword_1D48C8[v808 + 24]) >> 16) + (unsigned __int16)(v632 * dword_1D48C8[v808 + 24]);
    *(&v22 + j + 35) = v633 + v631;
    *(&v22 + j + 51) = v633 - v631;
    j += 4;
    v808 += 32;
    if ( j > 0xF )
      break;
    v633 = *(&v22 + j + 32);
    v632 = *(&v22 + j + 48);
    v631 = ((v632 * dword_1D48C8[v808]) >> 16) + (unsigned __int16)(v632 * dword_1D48C8[v808]);
    *(&v22 + j + 32) = v633 + v631;
  }
  v630 = v22;
  v629 = v54;
  v22 += v54;
  v54 = v630 - v54;
  v806 = 0;
  for ( k = 0; ; *(&v22 + k + 32) = v630 - v628 )
  {
    v630 = *(&v22 + k + 1);
    v629 = *(&v22 + k + 33);
    v628 = ((v629 * dword_1D48C8[v806 + 4]) >> 16) + (unsigned __int16)(v629 * dword_1D48C8[v806 + 4]);
    *(&v22 + k + 1) = v630 + v628;
    *(&v22 + k + 33) = v630 - v628;
    v630 = *(&v22 + k + 2);
    v629 = *(&v22 + k + 34);
    v628 = ((v629 * dword_1D48C8[v806 + 8]) >> 16) + (unsigned __int16)(v629 * dword_1D48C8[v806 + 8]);
    *(&v22 + k + 2) = v630 + v628;
    *(&v22 + k + 34) = v630 - v628;
    v630 = *(&v22 + k + 3);
    v629 = *(&v22 + k + 35);
    v628 = ((v629 * dword_1D48C8[v806 + 12]) >> 16) + (unsigned __int16)(v629 * dword_1D48C8[v806 + 12]);
    *(&v22 + k + 3) = v630 + v628;
    *(&v22 + k + 35) = v630 - v628;
    k += 4;
    v806 += 16;
    if ( k > 0x1F )
      break;
    v630 = *(&v22 + k);
    v629 = *(&v22 + k + 32);
    v628 = ((v629 * dword_1D48C8[v806]) >> 16) + (unsigned __int16)(v629 * dword_1D48C8[v806]);
    *(&v22 + k) = v630 + v628;
  }
  v627 = v797[1];
  v626 = v797[17];
  v625 = v797[33];
  v624 = v797[49];
  v623 = v625 + v627;
  v622 = v627 + 16 * v625;
  v621 = v627 - v625;
  v620 = v627 - 16 * v625;
  v619 = v624 + v626;
  v618 = (unsigned __int8)(((_BYTE)v624 << 6) + 4 * v626) - (((v624 << 6) + 4 * v626) >> 8);
  v617 = 16 * v626 - 16 * v624;
  v616 = (unsigned __int8)(4 * v624 + ((_BYTE)v626 << 6)) - ((4 * v624 + (v626 << 6)) >> 8);
  v615 = v624 + v626 + v625 + v627;
  v614 = v618 + v622;
  v613 = v617 + v627 - v625;
  v612 = v616 + v620;
  v611 = v625 + v627 - (v624 + v626);
  v610 = v622 - v618;
  v609 = v627 - v625 - v617;
  v608 = v620 - v616;
  v607 = v797[9];
  v606 = v797[25];
  v605 = v797[41];
  v604 = v797[57];
  v603 = v605 + v607;
  v602 = v607 + 16 * v605;
  v601 = v607 - v605;
  v600 = v607 - 16 * v605;
  v599 = v604 + v606;
  v598 = (unsigned __int8)(((_BYTE)v604 << 6) + 4 * v606) - (((v604 << 6) + 4 * v606) >> 8);
  v597 = 16 * v606 - 16 * v604;
  v596 = (unsigned __int8)(4 * v604 + ((_BYTE)v606 << 6)) - ((4 * v604 + (v606 << 6)) >> 8);
  v595 = v604 + v606 + v605 + v607;
  v594 = v598 + v602;
  v593 = v597 + v607 - v605;
  v592 = v596 + v600;
  v591 = v605 + v607 - (v604 + v606);
  v590 = v602 - v598;
  v589 = v607 - v605 - v597;
  v588 = v600 - v596;
  v86 = v615 + v595;
  v87 = 2 * (v598 + v602) + v618 + v622;
  v88 = 4 * v593 + v613;
  v89 = 8 * (v596 + v600) + v616 + v620;
  v90 = 16 * v591 + v611;
  v91 = 32 * (v602 - v598) + v622 - v618;
  v92 = (v589 << 6) + v609;
  v93 = ((v600 - v596) << 7) + v620 - v616;
  v94 = v615 - v595;
  v95 = v618 + v622 - 2 * (v598 + v602);
  v96 = v613 - 4 * v593;
  v97 = v616 + v620 - 8 * (v596 + v600);
  v98 = v611 - 16 * v591;
  v99 = v622 - v618 - 32 * (v602 - v598);
  v100 = v609 - (v589 << 6);
  v101 = v620 - v616 - ((v600 - v596) << 7);
  v587 = v797[5];
  v586 = v797[21];
  v585 = v797[37];
  v584 = v797[53];
  v583 = v585 + v587;
  v582 = v587 + 16 * v585;
  v581 = v587 - v585;
  v580 = v587 - 16 * v585;
  v579 = v584 + v586;
  v578 = (unsigned __int8)(((_BYTE)v584 << 6) + 4 * v586) - (((v584 << 6) + 4 * v586) >> 8);
  v577 = 16 * v586 - 16 * v584;
  v576 = (unsigned __int8)(4 * v584 + ((_BYTE)v586 << 6)) - ((4 * v584 + (v586 << 6)) >> 8);
  v575 = v584 + v586 + v585 + v587;
  v574 = v578 + v582;
  v573 = v577 + v587 - v585;
  v572 = v576 + v580;
  v571 = v585 + v587 - (v584 + v586);
  v570 = v582 - v578;
  v569 = v587 - v585 - v577;
  v568 = v580 - v576;
  v567 = v797[13];
  v566 = v797[29];
  v565 = v797[45];
  v564 = v797[61];
  v563 = v565 + v567;
  v562 = v567 + 16 * v565;
  v561 = v567 - v565;
  v560 = v567 - 16 * v565;
  v559 = v564 + v566;
  v558 = (unsigned __int8)(((_BYTE)v564 << 6) + 4 * v566) - (((v564 << 6) + 4 * v566) >> 8);
  v557 = 16 * v566 - 16 * v564;
  v556 = (unsigned __int8)(4 * v564 + ((_BYTE)v566 << 6)) - ((4 * v564 + (v566 << 6)) >> 8);
  v555 = v564 + v566 + v565 + v567;
  v554 = v558 + v562;
  v553 = v557 + v567 - v565;
  v552 = v556 + v560;
  v551 = v565 + v567 - (v564 + v566);
  v550 = v562 - v558;
  v549 = v567 - v565 - v557;
  v548 = v560 - v556;
  v103 = 2 * (v558 + v562) + v578 + v582;
  v104 = 4 * v553 + v573;
  v105 = 8 * (v556 + v560) + v576 + v580;
  v106 = 16 * v551 + v571;
  v107 = 32 * (v562 - v558) + v582 - v578;
  v108 = (v549 << 6) + v569;
  v109 = ((v560 - v556) << 7) + v580 - v576;
  v110 = v575 - v555;
  v111 = v578 + v582 - 2 * (v558 + v562);
  v112 = v573 - 4 * v553;
  v113 = v576 + v580 - 8 * (v556 + v560);
  v114 = v571 - 16 * v551;
  v115 = v582 - v578 - 32 * (v562 - v558);
  v116 = v569 - (v549 << 6);
  v117 = v580 - v576 - ((v560 - v556) << 7);
  v547 = v615 + v595;
  v546 = v575 + v555;
  v86 = v615 + v595 + v575 + v555;
  v102 = v615 + v595 - (v575 + v555);
  v804 = 0;
  for ( m = 0; ; *(&v22 + m + 80) = v547 - v545 )
  {
    v547 = *(&v22 + m + 65);
    v546 = *(&v22 + m + 81);
    v545 = ((v546 * dword_1D48C8[v804 + 8]) >> 16) + (unsigned __int16)(v546 * dword_1D48C8[v804 + 8]);
    *(&v22 + m + 65) = v547 + v545;
    *(&v22 + m + 81) = v547 - v545;
    v547 = *(&v22 + m + 66);
    v546 = *(&v22 + m + 82);
    v545 = ((v546 * dword_1D48C8[v804 + 16]) >> 16) + (unsigned __int16)(v546 * dword_1D48C8[v804 + 16]);
    *(&v22 + m + 66) = v547 + v545;
    *(&v22 + m + 82) = v547 - v545;
    v547 = *(&v22 + m + 67);
    v546 = *(&v22 + m + 83);
    v545 = ((v546 * dword_1D48C8[v804 + 24]) >> 16) + (unsigned __int16)(v546 * dword_1D48C8[v804 + 24]);
    *(&v22 + m + 67) = v547 + v545;
    *(&v22 + m + 83) = v547 - v545;
    m += 4;
    v804 += 32;
    if ( m > 0xF )
      break;
    v547 = *(&v22 + m + 64);
    v546 = *(&v22 + m + 80);
    v545 = ((v546 * dword_1D48C8[v804]) >> 16) + (unsigned __int16)(v546 * dword_1D48C8[v804]);
    *(&v22 + m + 64) = v547 + v545;
  }
  v544 = v797[3];
  v543 = v797[19];
  v542 = v797[35];
  v541 = v797[51];
  v540 = v542 + v544;
  v539 = v544 + 16 * v542;
  v538 = v544 - v542;
  v537 = v544 - 16 * v542;
  v536 = v541 + v543;
  v535 = (unsigned __int8)(((_BYTE)v541 << 6) + 4 * v543) - (((v541 << 6) + 4 * v543) >> 8);
  v534 = 16 * v543 - 16 * v541;
  v533 = (unsigned __int8)(4 * v541 + ((_BYTE)v543 << 6)) - ((4 * v541 + (v543 << 6)) >> 8);
  v532 = v541 + v543 + v542 + v544;
  v531 = v535 + v539;
  v530 = v534 + v544 - v542;
  v529 = v533 + v537;
  v528 = v542 + v544 - (v541 + v543);
  v527 = v539 - v535;
  v526 = v544 - v542 - v534;
  v525 = v537 - v533;
  v524 = v797[11];
  v523 = v797[27];
  v522 = v797[43];
  v521 = v797[59];
  v520 = v522 + v524;
  v519 = v524 + 16 * v522;
  v518 = v524 - v522;
  v517 = v524 - 16 * v522;
  v516 = v521 + v523;
  v515 = (unsigned __int8)(((_BYTE)v521 << 6) + 4 * v523) - (((v521 << 6) + 4 * v523) >> 8);
  v514 = 16 * v523 - 16 * v521;
  v513 = (unsigned __int8)(4 * v521 + ((_BYTE)v523 << 6)) - ((4 * v521 + (v523 << 6)) >> 8);
  v512 = v521 + v523 + v522 + v524;
  v511 = v515 + v519;
  v510 = v514 + v524 - v522;
  v509 = v513 + v517;
  v508 = v522 + v524 - (v521 + v523);
  v507 = v519 - v515;
  v506 = v524 - v522 - v514;
  v505 = v517 - v513;
  v118 = v532 + v512;
  v119 = 2 * (v515 + v519) + v535 + v539;
  v120 = 4 * v510 + v530;
  v121 = 8 * (v513 + v517) + v533 + v537;
  v122 = 16 * v508 + v528;
  v123 = 32 * (v519 - v515) + v539 - v535;
  v124 = (v506 << 6) + v526;
  v125 = ((v517 - v513) << 7) + v537 - v533;
  v126 = v532 - v512;
  v127 = v535 + v539 - 2 * (v515 + v519);
  v128 = v530 - 4 * v510;
  v129 = v533 + v537 - 8 * (v513 + v517);
  v130 = v528 - 16 * v508;
  v131 = v539 - v535 - 32 * (v519 - v515);
  v132 = v526 - (v506 << 6);
  v133 = v537 - v533 - ((v517 - v513) << 7);
  v504 = v797[7];
  v503 = v797[23];
  v502 = v797[39];
  v501 = v797[55];
  v500 = v502 + v504;
  v499 = v504 + 16 * v502;
  v498 = v504 - v502;
  v497 = v504 - 16 * v502;
  v496 = v501 + v503;
  v495 = (unsigned __int8)(((_BYTE)v501 << 6) + 4 * v503) - (((v501 << 6) + 4 * v503) >> 8);
  v494 = 16 * v503 - 16 * v501;
  v493 = (unsigned __int8)(4 * v501 + ((_BYTE)v503 << 6)) - ((4 * v501 + (v503 << 6)) >> 8);
  v492 = v501 + v503 + v502 + v504;
  v491 = v495 + v499;
  v490 = v494 + v504 - v502;
  v489 = v493 + v497;
  v488 = v502 + v504 - (v501 + v503);
  v487 = v499 - v495;
  v486 = v504 - v502 - v494;
  v485 = v497 - v493;
  v484 = v797[15];
  v483 = v797[31];
  v482 = v797[47];
  v481 = v797[63];
  v480 = v482 + v484;
  v479 = v484 + 16 * v482;
  v478 = v484 - v482;
  v477 = v484 - 16 * v482;
  v476 = v481 + v483;
  v475 = (unsigned __int8)(((_BYTE)v481 << 6) + 4 * v483) - (((v481 << 6) + 4 * v483) >> 8);
  v474 = 16 * v483 - 16 * v481;
  v473 = (unsigned __int8)(4 * v481 + ((_BYTE)v483 << 6)) - ((4 * v481 + (v483 << 6)) >> 8);
  v472 = v481 + v483 + v482 + v484;
  v471 = v475 + v479;
  v470 = v474 + v484 - v482;
  v469 = v473 + v477;
  v468 = v482 + v484 - (v481 + v483);
  v467 = v479 - v475;
  v466 = v484 - v482 - v474;
  v465 = v477 - v473;
  v135 = 2 * (v475 + v479) + v495 + v499;
  v136 = 4 * v470 + v490;
  v137 = 8 * (v473 + v477) + v493 + v497;
  v138 = 16 * v468 + v488;
  v139 = 32 * (v479 - v475) + v499 - v495;
  v140 = (v466 << 6) + v486;
  v141 = ((v477 - v473) << 7) + v497 - v493;
  v142 = v492 - v472;
  v143 = v495 + v499 - 2 * (v475 + v479);
  v144 = v490 - 4 * v470;
  v145 = v493 + v497 - 8 * (v473 + v477);
  v146 = v488 - 16 * v468;
  v147 = v499 - v495 - 32 * (v479 - v475);
  v148 = v486 - (v466 << 6);
  v149 = v497 - v493 - ((v477 - v473) << 7);
  v464 = v532 + v512;
  v463 = v492 + v472;
  v118 = v532 + v512 + v492 + v472;
  v134 = v532 + v512 - (v492 + v472);
  v802 = 0;
  for ( n = 0; ; *(&v22 + n + 112) = v464 - v462 )
  {
    v464 = *(&v22 + n + 97);
    v463 = *(&v22 + n + 113);
    v462 = ((v463 * dword_1D48C8[v802 + 8]) >> 16) + (unsigned __int16)(v463 * dword_1D48C8[v802 + 8]);
    *(&v22 + n + 97) = v464 + v462;
    *(&v22 + n + 113) = v464 - v462;
    v464 = *(&v22 + n + 98);
    v463 = *(&v22 + n + 114);
    v462 = ((v463 * dword_1D48C8[v802 + 16]) >> 16) + (unsigned __int16)(v463 * dword_1D48C8[v802 + 16]);
    *(&v22 + n + 98) = v464 + v462;
    *(&v22 + n + 114) = v464 - v462;
    v464 = *(&v22 + n + 99);
    v463 = *(&v22 + n + 115);
    v462 = ((v463 * dword_1D48C8[v802 + 24]) >> 16) + (unsigned __int16)(v463 * dword_1D48C8[v802 + 24]);
    *(&v22 + n + 99) = v464 + v462;
    *(&v22 + n + 115) = v464 - v462;
    n += 4;
    v802 += 32;
    if ( n > 0xF )
      break;
    v464 = *(&v22 + n + 96);
    v463 = *(&v22 + n + 112);
    v462 = ((v463 * dword_1D48C8[v802]) >> 16) + (unsigned __int16)(v463 * dword_1D48C8[v802]);
    *(&v22 + n + 96) = v464 + v462;
  }
  v461 = v86;
  v460 = v118;
  v86 += v118;
  v118 = v461 - v118;
  v800 = 0;
  for ( ii = 0; ; *(&v22 + ii + 96) = v461 - v459 )
  {
    v461 = *(&v22 + ii + 65);
    v460 = *(&v22 + ii + 97);
    v459 = ((v460 * dword_1D48C8[v800 + 4]) >> 16) + (unsigned __int16)(v460 * dword_1D48C8[v800 + 4]);
    *(&v22 + ii + 65) = v461 + v459;
    *(&v22 + ii + 97) = v461 - v459;
    v461 = *(&v22 + ii + 66);
    v460 = *(&v22 + ii + 98);
    v459 = ((v460 * dword_1D48C8[v800 + 8]) >> 16) + (unsigned __int16)(v460 * dword_1D48C8[v800 + 8]);
    *(&v22 + ii + 66) = v461 + v459;
    *(&v22 + ii + 98) = v461 - v459;
    v461 = *(&v22 + ii + 67);
    v460 = *(&v22 + ii + 99);
    v459 = ((v460 * dword_1D48C8[v800 + 12]) >> 16) + (unsigned __int16)(v460 * dword_1D48C8[v800 + 12]);
    *(&v22 + ii + 67) = v461 + v459;
    *(&v22 + ii + 99) = v461 - v459;
    ii += 4;
    v800 += 16;
    if ( ii > 0x1F )
      break;
    v461 = *(&v22 + ii + 64);
    v460 = *(&v22 + ii + 96);
    v459 = ((v460 * dword_1D48C8[v800]) >> 16) + (unsigned __int16)(v460 * dword_1D48C8[v800]);
    *(&v22 + ii + 64) = v461 + v459;
  }
  v458 = v22;
  v457 = v86;
  v22 += v86;
  v86 = v458 - v86;
  v798 = 0;
  for ( jj = 0; ; *(&v22 + jj + 64) = v458 - v456 )
  {
    v458 = *(&v22 + jj + 1);
    v457 = *(&v22 + jj + 65);
    v456 = ((v457 * dword_1D48C8[v798 + 2]) >> 16) + (unsigned __int16)(v457 * dword_1D48C8[v798 + 2]);
    *(&v22 + jj + 1) = v458 + v456;
    *(&v22 + jj + 65) = v458 - v456;
    v458 = *(&v22 + jj + 2);
    v457 = *(&v22 + jj + 66);
    v456 = ((v457 * dword_1D48C8[v798 + 4]) >> 16) + (unsigned __int16)(v457 * dword_1D48C8[v798 + 4]);
    *(&v22 + jj + 2) = v458 + v456;
    *(&v22 + jj + 66) = v458 - v456;
    v458 = *(&v22 + jj + 3);
    v457 = *(&v22 + jj + 67);
    v456 = ((v457 * dword_1D48C8[v798 + 6]) >> 16) + (unsigned __int16)(v457 * dword_1D48C8[v798 + 6]);
    *(&v22 + jj + 3) = v458 + v456;
    *(&v22 + jj + 67) = v458 - v456;
    jj += 4;
    v798 += 8;
    if ( jj > 0x3F )
      break;
    v458 = *(&v22 + jj);
    v457 = *(&v22 + jj + 64);
    v456 = ((v457 * dword_1D48C8[v798]) >> 16) + (unsigned __int16)(v457 * dword_1D48C8[v798]);
    *(&v22 + jj) = v458 + v456;
  }
  if ( a2 )
  {
    for ( kk = 0; kk <= 127; ++kk )
    {
      v455 = *(&v22 + kk) + word_1D4DC8[kk];
      v455 = (v455 >> 16) + (unsigned __int16)v455;
      v455 = (unsigned __int8)v455 - (v455 >> 8);
      v455 = (unsigned __int8)v455 - (v455 >> 8);
      if ( v455 <= 128 )
        v2 = v455;
      else
        v2 = v455 - 257;
      *(&v22 + kk) = v2;
    }
  }
  else
  {
    for ( kk = 0; kk <= 127; ++kk )
    {
      v454 = *(&v22 + kk) + word_1D4CC8[kk];
      v454 = (v454 >> 16) + (unsigned __int16)v454;
      v454 = (unsigned __int8)v454 - (v454 >> 8);
      v454 = (unsigned __int8)v454 - (v454 >> 8);
      if ( v454 <= 128 )
        v3 = v454;
      else
        v3 = v454 - 257;
      *(&v22 + kk) = v3;
    }
  }
  v453 = *((_DWORD *)a1 + 17);
  v452 = *((_DWORD *)a1 + 18);
  v451 = *((_DWORD *)a1 + 19);
  v450 = *((_DWORD *)a1 + 20);
  v449 = *((_DWORD *)a1 + 21);
  v448 = *((_DWORD *)a1 + 22);
  v447 = *((_DWORD *)a1 + 23);
  v446 = *((_DWORD *)a1 + 24);
  v445 = *((_DWORD *)a1 + 25);
  v444 = *((_DWORD *)a1 + 26);
  v443 = *((_DWORD *)a1 + 27);
  v442 = *((_DWORD *)a1 + 28);
  v441 = *((_DWORD *)a1 + 29);
  v440 = *((_DWORD *)a1 + 30);
  v439 = *((_DWORD *)a1 + 31);
  v438 = *((_DWORD *)a1 + 32);
  v4 = sub_140E9C((int)v797);
  v453 ^= v4;
  v5 = sub_140E9C((int)(v797 + 4));
  v452 ^= v5;
  v6 = sub_140E9C((int)(v797 + 8));
  v451 ^= v6;
  v7 = sub_140E9C((int)(v797 + 12));
  v450 ^= v7;
  v8 = sub_140E9C((int)(v797 + 16));
  v449 ^= v8;
  v9 = sub_140E9C((int)(v797 + 20));
  v448 ^= v9;
  v10 = sub_140E9C((int)(v797 + 24));
  v447 ^= v10;
  v11 = sub_140E9C((int)(v797 + 28));
  v446 ^= v11;
  v12 = sub_140E9C((int)(v797 + 32));
  v445 ^= v12;
  v13 = sub_140E9C((int)(v797 + 36));
  v444 ^= v13;
  v14 = sub_140E9C((int)(v797 + 40));
  v443 ^= v14;
  v15 = sub_140E9C((int)(v797 + 44));
  v442 ^= v15;
  v16 = sub_140E9C((int)(v797 + 48));
  v441 ^= v16;
  v17 = sub_140E9C((int)(v797 + 52));
  v440 ^= v17;
  v18 = sub_140E9C((int)(v797 + 56));
  v439 ^= v18;
  v19 = sub_140E9C((int)(v797 + 60));
  v438 ^= v19;
  v437 = __ROR4__(v453, 29);
  v436 = __ROR4__(v452, 29);
  v435 = __ROR4__(v451, 29);
  v434 = __ROR4__(v450, 29);
  v433 = ((v449 ^ v445) & v453 ^ v445) + (unsigned __int16)(185 * v54) + 12124160 * v55 + v441;
  v453 = v436 + __ROR4__(v433, 9);
  v441 = v445;
  v445 = v449;
  v432 = ((v448 ^ v444) & v452 ^ v444) + (unsigned __int16)(185 * v56) + 12124160 * v57 + v440;
  v452 = v437 + __ROR4__(v432, 9);
  v440 = v444;
  v444 = v448;
  v431 = ((v447 ^ v443) & v451 ^ v443) + (unsigned __int16)(185 * v58) + 12124160 * v59 + v439;
  v451 = v434 + __ROR4__(v431, 9);
  v439 = v443;
  v443 = v447;
  v430 = ((v446 ^ v442) & v450 ^ v442) + (unsigned __int16)(185 * v60) + 12124160 * v61 + v438;
  v450 = v435 + __ROR4__(v430, 9);
  v438 = v442;
  v442 = v446;
  v429 = __ROR4__(v453, 9);
  v428 = __ROR4__(v452, 9);
  v427 = __ROR4__(v451, 9);
  v426 = __ROR4__(v450, 9);
  v425 = ((v437 ^ v445) & v453 ^ v445) + (unsigned __int16)(185 * v70) + 12124160 * v71 + v441;
  v453 = v427 + __ROR4__(v425, 15);
  v445 = v437;
  v424 = ((v436 ^ v444) & v452 ^ v444) + (unsigned __int16)(185 * v72) + 12124160 * v73 + v440;
  v452 = v426 + __ROR4__(v424, 15);
  v444 = v436;
  v423 = ((v435 ^ v443) & v451 ^ v443) + (unsigned __int16)(185 * v74) + 12124160 * v75 + v439;
  v451 = v429 + __ROR4__(v423, 15);
  v443 = v435;
  v422 = ((v434 ^ v442) & v450 ^ v442) + (unsigned __int16)(185 * v76) + 12124160 * v77 + v438;
  v450 = v428 + __ROR4__(v422, 15);
  v442 = v434;
  v421 = __ROR4__(v453, 15);
  v420 = __ROR4__(v452, 15);
  v419 = __ROR4__(v451, 15);
  v418 = __ROR4__(v450, 15);
  v417 = ((v429 ^ v445) & v453 ^ v445) + (unsigned __int16)(185 * v22) + 12124160 * v23 + v449;
  v453 = v418 + __ROR4__(v417, 5);
  v445 = v429;
  v416 = ((v428 ^ v444) & v452 ^ v444) + (unsigned __int16)(185 * v24) + 12124160 * v25 + v448;
  v452 = v419 + __ROR4__(v416, 5);
  v444 = v428;
  v415 = ((v427 ^ v443) & v451 ^ v443) + (unsigned __int16)(185 * v26) + 12124160 * v27 + v447;
  v451 = v420 + __ROR4__(v415, 5);
  v443 = v427;
  v414 = ((v426 ^ v442) & v450 ^ v442) + (unsigned __int16)(185 * v28) + 12124160 * v29 + v446;
  v450 = v421 + __ROR4__(v414, 5);
  v442 = v426;
  v413 = __ROR4__(v453, 5);
  v412 = __ROR4__(v452, 5);
  v411 = __ROR4__(v451, 5);
  v410 = __ROR4__(v450, 5);
  v409 = ((v421 ^ v445) & v453 ^ v445) + (unsigned __int16)(185 * v38) + 12124160 * v39 + v437;
  v453 = v412 + __ROR4__(v409, 29);
  v449 = v413;
  v408 = ((v420 ^ v444) & v452 ^ v444) + (unsigned __int16)(185 * v40) + 12124160 * v41 + v436;
  v452 = v413 + __ROR4__(v408, 29);
  v448 = v412;
  v407 = ((v419 ^ v443) & v451 ^ v443) + (unsigned __int16)(185 * v42) + 12124160 * v43 + v435;
  v451 = v410 + __ROR4__(v407, 29);
  v447 = v411;
  v406 = ((v418 ^ v442) & v450 ^ v442) + (unsigned __int16)(185 * v44) + 12124160 * v45 + v434;
  v450 = v411 + __ROR4__(v406, 29);
  v446 = v410;
  v405 = __ROR4__(v453, 29);
  v404 = __ROR4__(v452, 29);
  v403 = __ROR4__(v451, 29);
  v402 = __ROR4__(v450, 29);
  v401 = (v453 & v449 | v421 & (v453 | v449)) + (unsigned __int16)(185 * v78) + 12124160 * v79 + v429;
  v453 = v403 + __ROR4__(v401, 9);
  v449 = v405;
  v400 = (v452 & v448 | v420 & (v452 | v448)) + (unsigned __int16)(185 * v80) + 12124160 * v81 + v428;
  v452 = v402 + __ROR4__(v400, 9);
  v448 = v404;
  v399 = (v451 & v447 | v419 & (v451 | v447)) + (unsigned __int16)(185 * v82) + 12124160 * v83 + v427;
  v451 = v405 + __ROR4__(v399, 9);
  v447 = v403;
  v398 = (v450 & v446 | v418 & (v450 | v446)) + (unsigned __int16)(185 * v84) + 12124160 * v85 + v426;
  v450 = v404 + __ROR4__(v398, 9);
  v446 = v402;
  v397 = __ROR4__(v453, 9);
  v396 = __ROR4__(v452, 9);
  v395 = __ROR4__(v451, 9);
  v394 = __ROR4__(v450, 9);
  v393 = (v453 & v449 | v413 & (v453 | v449)) + (unsigned __int16)(185 * v62) + 12124160 * v63 + v421;
  v453 = v394 + __ROR4__(v393, 15);
  v449 = v397;
  v392 = (v452 & v448 | v412 & (v452 | v448)) + (unsigned __int16)(185 * v64) + 12124160 * v65 + v420;
  v452 = v395 + __ROR4__(v392, 15);
  v448 = v396;
  v391 = (v451 & v447 | v411 & (v451 | v447)) + (unsigned __int16)(185 * v66) + 12124160 * v67 + v419;
  v451 = v396 + __ROR4__(v391, 15);
  v447 = v395;
  v390 = (v450 & v446 | v410 & (v450 | v446)) + (unsigned __int16)(185 * v68) + 12124160 * v69 + v418;
  v450 = v397 + __ROR4__(v390, 15);
  v446 = v394;
  v389 = __ROR4__(v453, 15);
  v388 = __ROR4__(v452, 15);
  v387 = __ROR4__(v451, 15);
  v386 = __ROR4__(v450, 15);
  v385 = (v453 & v449 | v405 & (v453 | v449)) + (unsigned __int16)(185 * v46) + 12124160 * v47 + v413;
  v453 = v388 + __ROR4__(v385, 5);
  v449 = v389;
  v384 = (v452 & v448 | v404 & (v452 | v448)) + (unsigned __int16)(185 * v48) + 12124160 * v49 + v412;
  v452 = v389 + __ROR4__(v384, 5);
  v448 = v388;
  v383 = (v451 & v447 | v403 & (v451 | v447)) + (unsigned __int16)(185 * v50) + 12124160 * v51 + v411;
  v451 = v386 + __ROR4__(v383, 5);
  v447 = v387;
  v382 = (v450 & v446 | v402 & (v450 | v446)) + (unsigned __int16)(185 * v52) + 12124160 * v53 + v410;
  v450 = v387 + __ROR4__(v382, 5);
  v446 = v386;
  v381 = __ROR4__(v453, 5);
  v380 = __ROR4__(v452, 5);
  v379 = __ROR4__(v451, 5);
  v378 = __ROR4__(v450, 5);
  v377 = (v453 & v449 | v397 & (v453 | v449)) + (unsigned __int16)(185 * v30) + 12124160 * v31 + v405;
  v453 = v379 + __ROR4__(v377, 29);
  v445 = v389;
  v376 = (v452 & v448 | v396 & (v452 | v448)) + (unsigned __int16)(185 * v32) + 12124160 * v33 + v404;
  v452 = v378 + __ROR4__(v376, 29);
  v444 = v388;
  v375 = (v451 & v447 | v395 & (v451 | v447)) + (unsigned __int16)(185 * v34) + 12124160 * v35 + v403;
  v451 = v381 + __ROR4__(v375, 29);
  v443 = v387;
  v374 = (v450 & v446 | v394 & (v450 | v446)) + (unsigned __int16)(185 * v36) + 12124160 * v37 + v402;
  v450 = v380 + __ROR4__(v374, 29);
  v442 = v386;
  v373 = __ROR4__(v453, 4);
  v372 = __ROR4__(v452, 4);
  v371 = __ROR4__(v451, 4);
  v370 = __ROR4__(v450, 4);
  v369 = ((v381 ^ v445) & v453 ^ v445) + (unsigned __int16)(185 * v142) + 12124160 * v143 + v397;
  v453 = v370 + __ROR4__(v369, 13);
  v445 = v381;
  v368 = ((v380 ^ v444) & v452 ^ v444) + (unsigned __int16)(185 * v144) + 12124160 * v145 + v396;
  v452 = v371 + __ROR4__(v368, 13);
  v444 = v380;
  v367 = ((v379 ^ v443) & v451 ^ v443) + (unsigned __int16)(185 * v146) + 12124160 * v147 + v395;
  v451 = v372 + __ROR4__(v367, 13);
  v443 = v379;
  v366 = ((v378 ^ v442) & v450 ^ v442) + (unsigned __int16)(185 * v148) + 12124160 * v149 + v394;
  v450 = v373 + __ROR4__(v366, 13);
  v442 = v378;
  v365 = __ROR4__(v453, 13);
  v364 = __ROR4__(v452, 13);
  v363 = __ROR4__(v451, 13);
  v362 = __ROR4__(v450, 13);
  v361 = ((v373 ^ v445) & v453 ^ v445) + (unsigned __int16)(185 * v110) + 12124160 * v111 + v389;
  v453 = v364 + __ROR4__(v361, 10);
  v445 = v373;
  v360 = ((v372 ^ v444) & v452 ^ v444) + (unsigned __int16)(185 * v112) + 12124160 * v113 + v388;
  v452 = v365 + __ROR4__(v360, 10);
  v444 = v372;
  v359 = ((v371 ^ v443) & v451 ^ v443) + (unsigned __int16)(185 * v114) + 12124160 * v115 + v387;
  v451 = v362 + __ROR4__(v359, 10);
  v443 = v371;
  v358 = ((v370 ^ v442) & v450 ^ v442) + (unsigned __int16)(185 * v116) + 12124160 * v117 + v386;
  v450 = v363 + __ROR4__(v358, 10);
  v442 = v370;
  v357 = __ROR4__(v453, 10);
  v356 = __ROR4__(v452, 10);
  v355 = __ROR4__(v451, 10);
  v354 = __ROR4__(v450, 10);
  v353 = ((v365 ^ v445) & v453 ^ v445) + (unsigned __int16)(185 * v118) + 12124160 * v119 + v381;
  v453 = v355 + __ROR4__(v353, 25);
  v445 = v365;
  v352 = ((v364 ^ v444) & v452 ^ v444) + (unsigned __int16)(185 * v120) + 12124160 * v121 + v380;
  v452 = v354 + __ROR4__(v352, 25);
  v444 = v364;
  v351 = ((v363 ^ v443) & v451 ^ v443) + (unsigned __int16)(185 * v122) + 12124160 * v123 + v379;
  v451 = v357 + __ROR4__(v351, 25);
  v443 = v363;
  v350 = ((v362 ^ v442) & v450 ^ v442) + (unsigned __int16)(185 * v124) + 12124160 * v125 + v378;
  v450 = v356 + __ROR4__(v350, 25);
  v442 = v362;
  v349 = __ROR4__(v453, 25);
  v348 = __ROR4__(v452, 25);
  v347 = __ROR4__(v451, 25);
  v346 = __ROR4__(v450, 25);
  v345 = ((v357 ^ v445) & v453 ^ v445) + (unsigned __int16)(185 * v86) + 12124160 * v87 + v373;
  v453 = v346 + __ROR4__(v345, 4);
  v449 = v349;
  v344 = ((v356 ^ v444) & v452 ^ v444) + (unsigned __int16)(185 * v88) + 12124160 * v89 + v372;
  v452 = v347 + __ROR4__(v344, 4);
  v448 = v348;
  v343 = ((v355 ^ v443) & v451 ^ v443) + (unsigned __int16)(185 * v90) + 12124160 * v91 + v371;
  v451 = v348 + __ROR4__(v343, 4);
  v447 = v347;
  v342 = ((v354 ^ v442) & v450 ^ v442) + (unsigned __int16)(185 * v92) + 12124160 * v93 + v370;
  v450 = v349 + __ROR4__(v342, 4);
  v446 = v346;
  v341 = __ROR4__(v453, 4);
  v340 = __ROR4__(v452, 4);
  v339 = __ROR4__(v451, 4);
  v338 = __ROR4__(v450, 4);
  v337 = (v453 & v449 | v357 & (v453 | v449)) + (unsigned __int16)(185 * v94) + 12124160 * v95 + v365;
  v453 = v340 + __ROR4__(v337, 13);
  v449 = v341;
  v336 = (v452 & v448 | v356 & (v452 | v448)) + (unsigned __int16)(185 * v96) + 12124160 * v97 + v364;
  v452 = v341 + __ROR4__(v336, 13);
  v448 = v340;
  v335 = (v451 & v447 | v355 & (v451 | v447)) + (unsigned __int16)(185 * v98) + 12124160 * v99 + v363;
  v451 = v338 + __ROR4__(v335, 13);
  v447 = v339;
  v334 = (v450 & v446 | v354 & (v450 | v446)) + (unsigned __int16)(185 * v100) + 12124160 * v101 + v362;
  v450 = v339 + __ROR4__(v334, 13);
  v446 = v338;
  v333 = __ROR4__(v453, 13);
  v332 = __ROR4__(v452, 13);
  v331 = __ROR4__(v451, 13);
  v330 = __ROR4__(v450, 13);
  v329 = (v453 & v449 | v349 & (v453 | v449)) + (unsigned __int16)(185 * v126) + 12124160 * v127 + v357;
  v453 = v331 + __ROR4__(v329, 10);
  v449 = v333;
  v328 = (v452 & v448 | v348 & (v452 | v448)) + (unsigned __int16)(185 * v128) + 12124160 * v129 + v356;
  v452 = v330 + __ROR4__(v328, 10);
  v448 = v332;
  v327 = (v451 & v447 | v347 & (v451 | v447)) + (unsigned __int16)(185 * v130) + 12124160 * v131 + v355;
  v451 = v333 + __ROR4__(v327, 10);
  v447 = v331;
  v326 = (v450 & v446 | v346 & (v450 | v446)) + (unsigned __int16)(185 * v132) + 12124160 * v133 + v354;
  v450 = v332 + __ROR4__(v326, 10);
  v446 = v330;
  v325 = __ROR4__(v453, 10);
  v324 = __ROR4__(v452, 10);
  v323 = __ROR4__(v451, 10);
  v322 = __ROR4__(v450, 10);
  v321 = (v453 & v449 | v341 & (v453 | v449)) + (unsigned __int16)(185 * v102) + 12124160 * v103 + v349;
  v453 = v322 + __ROR4__(v321, 25);
  v449 = v325;
  v320 = (v452 & v448 | v340 & (v452 | v448)) + (unsigned __int16)(185 * v104) + 12124160 * v105 + v348;
  v452 = v323 + __ROR4__(v320, 25);
  v448 = v324;
  v319 = (v451 & v447 | v339 & (v451 | v447)) + (unsigned __int16)(185 * v106) + 12124160 * v107 + v347;
  v451 = v324 + __ROR4__(v319, 25);
  v447 = v323;
  v318 = (v450 & v446 | v338 & (v450 | v446)) + (unsigned __int16)(185 * v108) + 12124160 * v109 + v346;
  v450 = v325 + __ROR4__(v318, 25);
  v446 = v322;
  v317 = __ROR4__(v453, 25);
  v316 = __ROR4__(v452, 25);
  v315 = __ROR4__(v451, 25);
  v314 = __ROR4__(v450, 25);
  v313 = (v453 & v449 | v333 & (v453 | v449)) + (unsigned __int16)(185 * v134) + 12124160 * v135 + v341;
  v453 = v316 + __ROR4__(v313, 4);
  v445 = v325;
  v312 = (v452 & v448 | v332 & (v452 | v448)) + (unsigned __int16)(185 * v136) + 12124160 * v137 + v340;
  v452 = v317 + __ROR4__(v312, 4);
  v444 = v324;
  v311 = (v451 & v447 | v331 & (v451 | v447)) + (unsigned __int16)(185 * v138) + 12124160 * v139 + v339;
  v451 = v314 + __ROR4__(v311, 4);
  v443 = v323;
  v310 = (v450 & v446 | v330 & (v450 | v446)) + (unsigned __int16)(185 * v140) + 12124160 * v141 + v338;
  v450 = v315 + __ROR4__(v310, 4);
  v442 = v322;
  v309 = __ROR4__(v453, 3);
  v308 = __ROR4__(v452, 3);
  v307 = __ROR4__(v451, 3);
  v306 = __ROR4__(v450, 3);
  v305 = ((v317 ^ v445) & v453 ^ v445) + (unsigned __int16)(233 * v30) + 15269888 * v94 + v333;
  v453 = v307 + __ROR4__(v305, 23);
  v445 = v317;
  v304 = ((v316 ^ v444) & v452 ^ v444) + (unsigned __int16)(233 * v32) + 15269888 * v96 + v332;
  v452 = v306 + __ROR4__(v304, 23);
  v444 = v316;
  v303 = ((v315 ^ v443) & v451 ^ v443) + (unsigned __int16)(233 * v34) + 15269888 * v98 + v331;
  v451 = v309 + __ROR4__(v303, 23);
  v443 = v315;
  v302 = ((v314 ^ v442) & v450 ^ v442) + (unsigned __int16)(233 * v36) + 15269888 * v100 + v330;
  v450 = v308 + __ROR4__(v302, 23);
  v442 = v314;
  v301 = __ROR4__(v453, 23);
  v300 = __ROR4__(v452, 23);
  v299 = __ROR4__(v451, 23);
  v298 = __ROR4__(v450, 23);
  v297 = ((v309 ^ v445) & v453 ^ v445) + (unsigned __int16)(233 * v38) + 15269888 * v102 + v325;
  v453 = v298 + __ROR4__(v297, 17);
  v445 = v309;
  v296 = ((v308 ^ v444) & v452 ^ v444) + (unsigned __int16)(233 * v40) + 15269888 * v104 + v324;
  v452 = v299 + __ROR4__(v296, 17);
  v444 = v308;
  v295 = ((v307 ^ v443) & v451 ^ v443) + (unsigned __int16)(233 * v42) + 15269888 * v106 + v323;
  v451 = v300 + __ROR4__(v295, 17);
  v443 = v307;
  v294 = ((v306 ^ v442) & v450 ^ v442) + (unsigned __int16)(233 * v44) + 15269888 * v108 + v322;
  v450 = v301 + __ROR4__(v294, 17);
  v442 = v306;
  v293 = __ROR4__(v453, 17);
  v292 = __ROR4__(v452, 17);
  v291 = __ROR4__(v451, 17);
  v290 = __ROR4__(v450, 17);
  v289 = ((v301 ^ v445) & v453 ^ v445) + (unsigned __int16)(233 * v78) + 15269888 * v142 + v317;
  v453 = v292 + __ROR4__(v289, 27);
  v445 = v301;
  v288 = ((v300 ^ v444) & v452 ^ v444) + (unsigned __int16)(233 * v80) + 15269888 * v144 + v316;
  v452 = v293 + __ROR4__(v288, 27);
  v444 = v300;
  v287 = ((v299 ^ v443) & v451 ^ v443) + (unsigned __int16)(233 * v82) + 15269888 * v146 + v315;
  v451 = v290 + __ROR4__(v287, 27);
  v443 = v299;
  v286 = ((v298 ^ v442) & v450 ^ v442) + (unsigned __int16)(233 * v84) + 15269888 * v148 + v314;
  v450 = v291 + __ROR4__(v286, 27);
  v442 = v298;
  v285 = __ROR4__(v453, 27);
  v284 = __ROR4__(v452, 27);
  v283 = __ROR4__(v451, 27);
  v282 = __ROR4__(v450, 27);
  v281 = ((v293 ^ v445) & v453 ^ v445) + (unsigned __int16)(233 * v54) + 15269888 * v118 + v309;
  v453 = v283 + __ROR4__(v281, 3);
  v449 = v285;
  v280 = ((v292 ^ v444) & v452 ^ v444) + (unsigned __int16)(233 * v56) + 15269888 * v120 + v308;
  v452 = v282 + __ROR4__(v280, 3);
  v448 = v284;
  v279 = ((v291 ^ v443) & v451 ^ v443) + (unsigned __int16)(233 * v58) + 15269888 * v122 + v307;
  v451 = v285 + __ROR4__(v279, 3);
  v447 = v283;
  v278 = ((v290 ^ v442) & v450 ^ v442) + (unsigned __int16)(233 * v60) + 15269888 * v124 + v306;
  v450 = v284 + __ROR4__(v278, 3);
  v446 = v282;
  v277 = __ROR4__(v453, 3);
  v276 = __ROR4__(v452, 3);
  v275 = __ROR4__(v451, 3);
  v274 = __ROR4__(v450, 3);
  v273 = (v453 & v449 | v293 & (v453 | v449)) + (unsigned __int16)(233 * v70) + 15269888 * v134 + v301;
  v453 = v274 + __ROR4__(v273, 23);
  v449 = v277;
  v272 = (v452 & v448 | v292 & (v452 | v448)) + (unsigned __int16)(233 * v72) + 15269888 * v136 + v300;
  v452 = v275 + __ROR4__(v272, 23);
  v448 = v276;
  v271 = (v451 & v447 | v291 & (v451 | v447)) + (unsigned __int16)(233 * v74) + 15269888 * v138 + v299;
  v451 = v276 + __ROR4__(v271, 23);
  v447 = v275;
  v270 = (v450 & v446 | v290 & (v450 | v446)) + (unsigned __int16)(233 * v76) + 15269888 * v140 + v298;
  v450 = v277 + __ROR4__(v270, 23);
  v446 = v274;
  v269 = __ROR4__(v453, 23);
  v268 = __ROR4__(v452, 23);
  v267 = __ROR4__(v451, 23);
  v266 = __ROR4__(v450, 23);
  v265 = (v453 & v449 | v285 & (v453 | v449)) + (unsigned __int16)(233 * v62) + 15269888 * v126 + v293;
  v453 = v268 + __ROR4__(v265, 17);
  v449 = v269;
  v264 = (v452 & v448 | v284 & (v452 | v448)) + (unsigned __int16)(233 * v64) + 15269888 * v128 + v292;
  v452 = v269 + __ROR4__(v264, 17);
  v448 = v268;
  v263 = (v451 & v447 | v283 & (v451 | v447)) + (unsigned __int16)(233 * v66) + 15269888 * v130 + v291;
  v451 = v266 + __ROR4__(v263, 17);
  v447 = v267;
  v262 = (v450 & v446 | v282 & (v450 | v446)) + (unsigned __int16)(233 * v68) + 15269888 * v132 + v290;
  v450 = v267 + __ROR4__(v262, 17);
  v446 = v266;
  v261 = __ROR4__(v453, 17);
  v260 = __ROR4__(v452, 17);
  v259 = __ROR4__(v451, 17);
  v258 = __ROR4__(v450, 17);
  v257 = (v453 & v449 | v277 & (v453 | v449)) + (unsigned __int16)(233 * v22) + 15269888 * v86 + v285;
  v453 = v259 + __ROR4__(v257, 27);
  v449 = v261;
  v256 = (v452 & v448 | v276 & (v452 | v448)) + (unsigned __int16)(233 * v24) + 15269888 * v88 + v284;
  v452 = v258 + __ROR4__(v256, 27);
  v448 = v260;
  v255 = (v451 & v447 | v275 & (v451 | v447)) + (unsigned __int16)(233 * v26) + 15269888 * v90 + v283;
  v451 = v261 + __ROR4__(v255, 27);
  v447 = v259;
  v254 = (v450 & v446 | v274 & (v450 | v446)) + (unsigned __int16)(233 * v28) + 15269888 * v92 + v282;
  v450 = v260 + __ROR4__(v254, 27);
  v446 = v258;
  v253 = __ROR4__(v453, 27);
  v252 = __ROR4__(v452, 27);
  v251 = __ROR4__(v451, 27);
  v250 = __ROR4__(v450, 27);
  v249 = (v453 & v449 | v269 & (v453 | v449)) + (unsigned __int16)(233 * v46) + 15269888 * v110 + v277;
  v453 = v250 + __ROR4__(v249, 3);
  v445 = v261;
  v248 = (v452 & v448 | v268 & (v452 | v448)) + (unsigned __int16)(233 * v48) + 15269888 * v112 + v276;
  v452 = v251 + __ROR4__(v248, 3);
  v444 = v260;
  v247 = (v451 & v447 | v267 & (v451 | v447)) + (unsigned __int16)(233 * v50) + 15269888 * v114 + v275;
  v451 = v252 + __ROR4__(v247, 3);
  v443 = v259;
  v246 = (v450 & v446 | v266 & (v450 | v446)) + (unsigned __int16)(233 * v52) + 15269888 * v116 + v274;
  v450 = v253 + __ROR4__(v246, 3);
  v442 = v258;
  v245 = __ROR4__(v453, 28);
  v244 = __ROR4__(v452, 28);
  v243 = __ROR4__(v451, 28);
  v242 = __ROR4__(v450, 28);
  v241 = ((v253 ^ v445) & v453 ^ v445) + (unsigned __int16)(233 * v71) + 15269888 * v135 + v269;
  v453 = v244 + __ROR4__(v241, 19);
  v445 = v253;
  v240 = ((v252 ^ v444) & v452 ^ v444) + (unsigned __int16)(233 * v73) + 15269888 * v137 + v268;
  v452 = v245 + __ROR4__(v240, 19);
  v444 = v252;
  v239 = ((v251 ^ v443) & v451 ^ v443) + (unsigned __int16)(233 * v75) + 15269888 * v139 + v267;
  v451 = v242 + __ROR4__(v239, 19);
  v443 = v251;
  v238 = ((v250 ^ v442) & v450 ^ v442) + (unsigned __int16)(233 * v77) + 15269888 * v141 + v266;
  v450 = v243 + __ROR4__(v238, 19);
  v442 = v250;
  v237 = __ROR4__(v453, 19);
  v236 = __ROR4__(v452, 19);
  v235 = __ROR4__(v451, 19);
  v234 = __ROR4__(v450, 19);
  v233 = ((v245 ^ v445) & v453 ^ v445) + (unsigned __int16)(233 * v23) + 15269888 * v87 + v261;
  v453 = v235 + __ROR4__(v233, 22);
  v445 = v245;
  v232 = ((v244 ^ v444) & v452 ^ v444) + (unsigned __int16)(233 * v25) + 15269888 * v89 + v260;
  v452 = v234 + __ROR4__(v232, 22);
  v444 = v244;
  v231 = ((v243 ^ v443) & v451 ^ v443) + (unsigned __int16)(233 * v27) + 15269888 * v91 + v259;
  v451 = v237 + __ROR4__(v231, 22);
  v443 = v243;
  v230 = ((v242 ^ v442) & v450 ^ v442) + (unsigned __int16)(233 * v29) + 15269888 * v93 + v258;
  v450 = v236 + __ROR4__(v230, 22);
  v442 = v242;
  v229 = __ROR4__(v453, 22);
  v228 = __ROR4__(v452, 22);
  v227 = __ROR4__(v451, 22);
  v226 = __ROR4__(v450, 22);
  v225 = ((v237 ^ v445) & v453 ^ v445) + (unsigned __int16)(233 * v31) + 15269888 * v95 + v253;
  v453 = v226 + __ROR4__(v225, 7);
  v445 = v237;
  v224 = ((v236 ^ v444) & v452 ^ v444) + (unsigned __int16)(233 * v33) + 15269888 * v97 + v252;
  v452 = v227 + __ROR4__(v224, 7);
  v444 = v236;
  v223 = ((v235 ^ v443) & v451 ^ v443) + (unsigned __int16)(233 * v35) + 15269888 * v99 + v251;
  v451 = v228 + __ROR4__(v223, 7);
  v443 = v235;
  v222 = ((v234 ^ v442) & v450 ^ v442) + (unsigned __int16)(233 * v37) + 15269888 * v101 + v250;
  v450 = v229 + __ROR4__(v222, 7);
  v442 = v234;
  v221 = __ROR4__(v453, 7);
  v220 = __ROR4__(v452, 7);
  v219 = __ROR4__(v451, 7);
  v218 = __ROR4__(v450, 7);
  v217 = ((v229 ^ v445) & v453 ^ v445) + (unsigned __int16)(233 * v79) + 15269888 * v143 + v245;
  v453 = v220 + __ROR4__(v217, 28);
  v449 = v221;
  v216 = ((v228 ^ v444) & v452 ^ v444) + (unsigned __int16)(233 * v81) + 15269888 * v145 + v244;
  v452 = v221 + __ROR4__(v216, 28);
  v448 = v220;
  v215 = ((v227 ^ v443) & v451 ^ v443) + (unsigned __int16)(233 * v83) + 15269888 * v147 + v243;
  v451 = v218 + __ROR4__(v215, 28);
  v447 = v219;
  v214 = ((v226 ^ v442) & v450 ^ v442) + (unsigned __int16)(233 * v85) + 15269888 * v149 + v242;
  v450 = v219 + __ROR4__(v214, 28);
  v446 = v218;
  v213 = __ROR4__(v453, 28);
  v212 = __ROR4__(v452, 28);
  v211 = __ROR4__(v451, 28);
  v210 = __ROR4__(v450, 28);
  v209 = (v453 & v449 | v229 & (v453 | v449)) + (unsigned __int16)(233 * v47) + 15269888 * v111 + v237;
  v453 = v211 + __ROR4__(v209, 19);
  v449 = v213;
  v208 = (v452 & v448 | v228 & (v452 | v448)) + (unsigned __int16)(233 * v49) + 15269888 * v113 + v236;
  v452 = v210 + __ROR4__(v208, 19);
  v448 = v212;
  v207 = (v451 & v447 | v227 & (v451 | v447)) + (unsigned __int16)(233 * v51) + 15269888 * v115 + v235;
  v451 = v213 + __ROR4__(v207, 19);
  v447 = v211;
  v206 = (v450 & v446 | v226 & (v450 | v446)) + (unsigned __int16)(233 * v53) + 15269888 * v117 + v234;
  v450 = v212 + __ROR4__(v206, 19);
  v446 = v210;
  v205 = __ROR4__(v453, 19);
  v204 = __ROR4__(v452, 19);
  v203 = __ROR4__(v451, 19);
  v202 = __ROR4__(v450, 19);
  v201 = (v453 & v449 | v221 & (v453 | v449)) + (unsigned __int16)(233 * v63) + 15269888 * v127 + v229;
  v453 = v202 + __ROR4__(v201, 22);
  v449 = v205;
  v200 = (v452 & v448 | v220 & (v452 | v448)) + (unsigned __int16)(233 * v65) + 15269888 * v129 + v228;
  v452 = v203 + __ROR4__(v200, 22);
  v448 = v204;
  v199 = (v451 & v447 | v219 & (v451 | v447)) + (unsigned __int16)(233 * v67) + 15269888 * v131 + v227;
  v451 = v204 + __ROR4__(v199, 22);
  v447 = v203;
  v198 = (v450 & v446 | v218 & (v450 | v446)) + (unsigned __int16)(233 * v69) + 15269888 * v133 + v226;
  v450 = v205 + __ROR4__(v198, 22);
  v446 = v202;
  v197 = __ROR4__(v453, 22);
  v196 = __ROR4__(v452, 22);
  v195 = __ROR4__(v451, 22);
  v194 = __ROR4__(v450, 22);
  v193 = (v453 & v449 | v213 & (v453 | v449)) + (unsigned __int16)(233 * v55) + 15269888 * v119 + v221;
  v453 = v196 + __ROR4__(v193, 7);
  v449 = v197;
  v192 = (v452 & v448 | v212 & (v452 | v448)) + (unsigned __int16)(233 * v57) + 15269888 * v121 + v220;
  v452 = v197 + __ROR4__(v192, 7);
  v448 = v196;
  v191 = (v451 & v447 | v211 & (v451 | v447)) + (unsigned __int16)(233 * v59) + 15269888 * v123 + v219;
  v451 = v194 + __ROR4__(v191, 7);
  v447 = v195;
  v190 = (v450 & v446 | v210 & (v450 | v446)) + (unsigned __int16)(233 * v61) + 15269888 * v125 + v218;
  v450 = v195 + __ROR4__(v190, 7);
  v189 = __ROR4__(v453, 7);
  v188 = __ROR4__(v452, 7);
  v187 = __ROR4__(v451, 7);
  v186 = __ROR4__(v450, 7);
  v185 = (v453 & v449 | v205 & (v453 | v449)) + (unsigned __int16)(233 * v39) + 15269888 * v103 + v213;
  v453 = v187 + __ROR4__(v185, 28);
  v441 = v205;
  v445 = v197;
  v449 = v189;
  v184 = (v452 & v448 | v204 & (v452 | v448)) + (unsigned __int16)(233 * v41) + 15269888 * v105 + v212;
  v452 = v186 + __ROR4__(v184, 28);
  v440 = v204;
  v444 = v196;
  v448 = v188;
  v183 = (v451 & v447 | v203 & (v451 | v447)) + (unsigned __int16)(233 * v43) + 15269888 * v107 + v211;
  v451 = v189 + __ROR4__(v183, 28);
  v439 = v203;
  v443 = v195;
  v447 = v187;
  result = v450 | v194;
  v182 = (v450 & v194 | v202 & (v450 | v194)) + (unsigned __int16)(233 * v45) + 15269888 * v109 + v210;
  v450 = v188 + __ROR4__(v182, 28);
  v438 = v202;
  v442 = v194;
  v446 = v186;
  v181 = __ROR4__(v453, 28);
  v180 = __ROR4__(v452, 28);
  v179 = __ROR4__(v451, 28);
  v178 = __ROR4__(v450, 28);
  v177 = ((v189 ^ v445) & v453 ^ v445) + *((_DWORD *)a1 + 17) + v205;
  v453 = v178 + __ROR4__(v177, 19);
  v441 = v197;
  v445 = v189;
  v449 = v181;
  v176 = ((v188 ^ v444) & v452 ^ v444) + *((_DWORD *)a1 + 18) + v204;
  v452 = v179 + __ROR4__(v176, 19);
  v440 = v196;
  v444 = v188;
  v448 = v180;
  v175 = ((v187 ^ v443) & v451 ^ v443) + *((_DWORD *)a1 + 19) + v203;
  v451 = v180 + __ROR4__(v175, 19);
  v439 = v195;
  v443 = v187;
  v447 = v179;
  v174 = ((v186 ^ v442) & v450 ^ v442) + *((_DWORD *)a1 + 20) + v202;
  v450 = v181 + __ROR4__(v174, 19);
  v438 = v194;
  v442 = v186;
  v446 = v178;
  v173 = __ROR4__(v453, 19);
  v172 = __ROR4__(v452, 19);
  v171 = __ROR4__(v451, 19);
  v170 = __ROR4__(v450, 19);
  v169 = ((v181 ^ v445) & v453 ^ v445) + *((_DWORD *)a1 + 21) + v197;
  v453 = v172 + __ROR4__(v169, 22);
  v441 = v189;
  v445 = v181;
  v449 = v173;
  v168 = ((v180 ^ v444) & v452 ^ v444) + *((_DWORD *)a1 + 22) + v196;
  v452 = v173 + __ROR4__(v168, 22);
  v440 = v188;
  v444 = v180;
  v448 = v172;
  v167 = ((v179 ^ v443) & v451 ^ v443) + *((_DWORD *)a1 + 23) + v195;
  v451 = v170 + __ROR4__(v167, 22);
  v439 = v187;
  v443 = v179;
  v447 = v171;
  v166 = ((v178 ^ v442) & v450 ^ v442) + *((_DWORD *)a1 + 24) + v194;
  v450 = v171 + __ROR4__(v166, 22);
  v438 = v186;
  v442 = v178;
  v446 = v170;
  v165 = __ROR4__(v453, 22);
  v164 = __ROR4__(v452, 22);
  v163 = __ROR4__(v451, 22);
  v162 = __ROR4__(v450, 22);
  v161 = ((v173 ^ v445) & v453 ^ v445) + *((_DWORD *)a1 + 25) + v189;
  v453 = v163 + __ROR4__(v161, 7);
  v441 = v181;
  v445 = v173;
  v449 = v165;
  v160 = ((v172 ^ v444) & v452 ^ v444) + *((_DWORD *)a1 + 26) + v188;
  v452 = v162 + __ROR4__(v160, 7);
  v440 = v180;
  v444 = v172;
  v448 = v164;
  v159 = ((v171 ^ v443) & v451 ^ v443) + *((_DWORD *)a1 + 27) + v187;
  v451 = v165 + __ROR4__(v159, 7);
  v439 = v179;
  v443 = v171;
  v447 = v163;
  v158 = ((v170 ^ v442) & v450 ^ v442) + *((_DWORD *)a1 + 28) + v186;
  v450 = v164 + __ROR4__(v158, 7);
  v438 = v178;
  v442 = v170;
  v446 = v162;
  v157 = __ROR4__(v453, 7);
  v156 = __ROR4__(v452, 7);
  v155 = __ROR4__(v451, 7);
  v154 = __ROR4__(v450, 7);
  v153 = ((v165 ^ v445) & v453 ^ v445) + *((_DWORD *)a1 + 29) + v181;
  v453 = v154 + __ROR4__(v153, 28);
  v441 = v173;
  v445 = v165;
  v449 = v157;
  v152 = ((v164 ^ v444) & v452 ^ v444) + *((_DWORD *)a1 + 30) + v180;
  v452 = v155 + __ROR4__(v152, 28);
  v440 = v172;
  v444 = v164;
  v448 = v156;
  v151 = ((v163 ^ v443) & v451 ^ v443) + *((_DWORD *)a1 + 31) + v179;
  v451 = v156 + __ROR4__(v151, 28);
  v439 = v171;
  v443 = v163;
  v447 = v155;
  v150 = ((v162 ^ v442) & v450 ^ v442) + *((_DWORD *)a1 + 32) + v178;
  v450 = v157 + __ROR4__(v150, 28);
  v438 = v170;
  v442 = v162;
  v446 = v154;
  *((_DWORD *)a1 + 17) = v453;
  *((_DWORD *)a1 + 18) = v452;
  *((_DWORD *)a1 + 19) = v451;
  *((_DWORD *)a1 + 20) = v450;
  *((_DWORD *)a1 + 21) = v449;
  *((_DWORD *)a1 + 22) = v448;
  *((_DWORD *)a1 + 23) = v447;
  *((_DWORD *)a1 + 24) = v446;
  *((_DWORD *)a1 + 25) = v445;
  *((_DWORD *)a1 + 26) = v444;
  *((_DWORD *)a1 + 27) = v443;
  *((_DWORD *)a1 + 28) = v442;
  *((_DWORD *)a1 + 29) = v441;
  *((_DWORD *)a1 + 30) = v440;
  *((_DWORD *)a1 + 31) = v439;
  *((_DWORD *)a1 + 32) = v438;
  return result;
}
// 1D48C8: using guessed type _DWORD dword_1D48C8[256];
// 1D4CC8: using guessed type unsigned __int16 word_1D4CC8[128];
// 1D4DC8: using guessed type unsigned __int16 word_1D4DC8[128];

//----- (0014C4AC) --------------------------------------------------------
int __fastcall sub_14C4AC(unsigned __int8 *a1, int a2)
{
  int v2; // r3
  int v3; // r3
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24; // r0
  int v25; // r0
  int v26; // r0
  int v27; // r0
  int v28; // r0
  int v29; // r0
  int v30; // r0
  int v31; // r0
  int v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int result; // r0
  int v39; // [sp+Ch] [bp+Ch] BYREF
  int v40; // [sp+10h] [bp+10h]
  __int16 v41; // [sp+14h] [bp+14h]
  int v42; // [sp+18h] [bp+18h]
  __int16 v43; // [sp+1Ch] [bp+1Ch]
  int v44; // [sp+20h] [bp+20h]
  __int16 v45; // [sp+24h] [bp+24h]
  int v46; // [sp+28h] [bp+28h]
  __int16 v47; // [sp+2Ch] [bp+2Ch]
  int v48; // [sp+30h] [bp+30h]
  __int16 v49; // [sp+34h] [bp+34h]
  int v50; // [sp+38h] [bp+38h]
  __int16 v51; // [sp+3Ch] [bp+3Ch]
  int v52; // [sp+40h] [bp+40h]
  __int16 v53; // [sp+44h] [bp+44h]
  int v54; // [sp+48h] [bp+48h]
  __int16 v55; // [sp+4Ch] [bp+4Ch]
  int v56; // [sp+50h] [bp+50h]
  __int16 v57; // [sp+54h] [bp+54h]
  int v58; // [sp+58h] [bp+58h]
  __int16 v59; // [sp+5Ch] [bp+5Ch]
  int v60; // [sp+60h] [bp+60h]
  __int16 v61; // [sp+64h] [bp+64h]
  int v62; // [sp+68h] [bp+68h]
  __int16 v63; // [sp+6Ch] [bp+6Ch]
  int v64; // [sp+70h] [bp+70h]
  __int16 v65; // [sp+74h] [bp+74h]
  int v66; // [sp+78h] [bp+78h]
  __int16 v67; // [sp+7Ch] [bp+7Ch]
  int v68; // [sp+80h] [bp+80h]
  __int16 v69; // [sp+84h] [bp+84h]
  int v70; // [sp+88h] [bp+88h]
  __int16 v71; // [sp+8Ch] [bp+8Ch]
  int v72; // [sp+90h] [bp+90h]
  __int16 v73; // [sp+94h] [bp+94h]
  int v74; // [sp+98h] [bp+98h]
  __int16 v75; // [sp+9Ch] [bp+9Ch]
  int v76; // [sp+A0h] [bp+A0h]
  __int16 v77; // [sp+A4h] [bp+A4h]
  int v78; // [sp+A8h] [bp+A8h]
  __int16 v79; // [sp+ACh] [bp+ACh]
  int v80; // [sp+B0h] [bp+B0h]
  __int16 v81; // [sp+B4h] [bp+B4h]
  int v82; // [sp+B8h] [bp+B8h]
  __int16 v83; // [sp+BCh] [bp+BCh]
  int v84; // [sp+C0h] [bp+C0h]
  __int16 v85; // [sp+C4h] [bp+C4h]
  int v86; // [sp+C8h] [bp+C8h]
  __int16 v87; // [sp+CCh] [bp+CCh]
  int v88; // [sp+D0h] [bp+D0h]
  __int16 v89; // [sp+D4h] [bp+D4h]
  int v90; // [sp+D8h] [bp+D8h]
  __int16 v91; // [sp+DCh] [bp+DCh]
  int v92; // [sp+E0h] [bp+E0h]
  __int16 v93; // [sp+E4h] [bp+E4h]
  int v94; // [sp+E8h] [bp+E8h]
  __int16 v95; // [sp+ECh] [bp+ECh]
  int v96; // [sp+F0h] [bp+F0h]
  __int16 v97; // [sp+F4h] [bp+F4h]
  int v98; // [sp+F8h] [bp+F8h]
  __int16 v99; // [sp+FCh] [bp+FCh]
  int v100; // [sp+100h] [bp+100h]
  __int16 v101; // [sp+104h] [bp+104h]
  int v102; // [sp+108h] [bp+108h]
  int v103; // [sp+10Ch] [bp+10Ch] BYREF
  int v104; // [sp+110h] [bp+110h]
  __int16 v105; // [sp+114h] [bp+114h]
  int v106; // [sp+118h] [bp+118h]
  __int16 v107; // [sp+11Ch] [bp+11Ch]
  int v108; // [sp+120h] [bp+120h]
  __int16 v109; // [sp+124h] [bp+124h]
  int v110; // [sp+128h] [bp+128h]
  __int16 v111; // [sp+12Ch] [bp+12Ch]
  int v112; // [sp+130h] [bp+130h]
  __int16 v113; // [sp+134h] [bp+134h]
  int v114; // [sp+138h] [bp+138h]
  __int16 v115; // [sp+13Ch] [bp+13Ch]
  int v116; // [sp+140h] [bp+140h]
  __int16 v117; // [sp+144h] [bp+144h]
  int v118; // [sp+148h] [bp+148h]
  __int16 v119; // [sp+14Ch] [bp+14Ch]
  int v120; // [sp+150h] [bp+150h]
  __int16 v121; // [sp+154h] [bp+154h]
  int v122; // [sp+158h] [bp+158h]
  __int16 v123; // [sp+15Ch] [bp+15Ch]
  int v124; // [sp+160h] [bp+160h]
  __int16 v125; // [sp+164h] [bp+164h]
  int v126; // [sp+168h] [bp+168h]
  __int16 v127; // [sp+16Ch] [bp+16Ch]
  int v128; // [sp+170h] [bp+170h]
  __int16 v129; // [sp+174h] [bp+174h]
  int v130; // [sp+178h] [bp+178h]
  __int16 v131; // [sp+17Ch] [bp+17Ch]
  int v132; // [sp+180h] [bp+180h]
  __int16 v133; // [sp+184h] [bp+184h]
  int v134; // [sp+188h] [bp+188h]
  __int16 v135; // [sp+18Ch] [bp+18Ch]
  int v136; // [sp+190h] [bp+190h]
  __int16 v137; // [sp+194h] [bp+194h]
  int v138; // [sp+198h] [bp+198h]
  __int16 v139; // [sp+19Ch] [bp+19Ch]
  int v140; // [sp+1A0h] [bp+1A0h]
  __int16 v141; // [sp+1A4h] [bp+1A4h]
  int v142; // [sp+1A8h] [bp+1A8h]
  __int16 v143; // [sp+1ACh] [bp+1ACh]
  int v144; // [sp+1B0h] [bp+1B0h]
  __int16 v145; // [sp+1B4h] [bp+1B4h]
  int v146; // [sp+1B8h] [bp+1B8h]
  __int16 v147; // [sp+1BCh] [bp+1BCh]
  int v148; // [sp+1C0h] [bp+1C0h]
  __int16 v149; // [sp+1C4h] [bp+1C4h]
  int v150; // [sp+1C8h] [bp+1C8h]
  __int16 v151; // [sp+1CCh] [bp+1CCh]
  int v152; // [sp+1D0h] [bp+1D0h]
  __int16 v153; // [sp+1D4h] [bp+1D4h]
  int v154; // [sp+1D8h] [bp+1D8h]
  __int16 v155; // [sp+1DCh] [bp+1DCh]
  int v156; // [sp+1E0h] [bp+1E0h]
  __int16 v157; // [sp+1E4h] [bp+1E4h]
  int v158; // [sp+1E8h] [bp+1E8h]
  __int16 v159; // [sp+1ECh] [bp+1ECh]
  int v160; // [sp+1F0h] [bp+1F0h]
  __int16 v161; // [sp+1F4h] [bp+1F4h]
  int v162; // [sp+1F8h] [bp+1F8h]
  __int16 v163; // [sp+1FCh] [bp+1FCh]
  int v164; // [sp+200h] [bp+200h]
  __int16 v165; // [sp+204h] [bp+204h]
  int v166; // [sp+208h] [bp+208h]
  int v167; // [sp+20Ch] [bp+20Ch] BYREF
  int v168; // [sp+210h] [bp+210h]
  int v169; // [sp+214h] [bp+214h]
  int v170; // [sp+218h] [bp+218h]
  int v171; // [sp+21Ch] [bp+21Ch]
  int v172; // [sp+220h] [bp+220h]
  int v173; // [sp+224h] [bp+224h]
  int v174; // [sp+228h] [bp+228h]
  int v175; // [sp+22Ch] [bp+22Ch]
  int v176; // [sp+230h] [bp+230h]
  int v177; // [sp+234h] [bp+234h]
  int v178; // [sp+238h] [bp+238h]
  int v179; // [sp+23Ch] [bp+23Ch]
  int v180; // [sp+240h] [bp+240h]
  int v181; // [sp+244h] [bp+244h]
  int v182; // [sp+248h] [bp+248h]
  int v183; // [sp+24Ch] [bp+24Ch]
  int v184; // [sp+250h] [bp+250h]
  int v185; // [sp+254h] [bp+254h]
  int v186; // [sp+258h] [bp+258h]
  int v187; // [sp+25Ch] [bp+25Ch]
  int v188; // [sp+260h] [bp+260h]
  int v189; // [sp+264h] [bp+264h]
  int v190; // [sp+268h] [bp+268h]
  int v191; // [sp+26Ch] [bp+26Ch]
  int v192; // [sp+270h] [bp+270h]
  int v193; // [sp+274h] [bp+274h]
  int v194; // [sp+278h] [bp+278h]
  int v195; // [sp+27Ch] [bp+27Ch]
  int v196; // [sp+280h] [bp+280h]
  int v197; // [sp+284h] [bp+284h]
  int v198; // [sp+288h] [bp+288h]
  int v199; // [sp+28Ch] [bp+28Ch]
  int v200; // [sp+290h] [bp+290h]
  int v201; // [sp+294h] [bp+294h]
  int v202; // [sp+298h] [bp+298h]
  int v203; // [sp+29Ch] [bp+29Ch]
  int v204; // [sp+2A0h] [bp+2A0h]
  int v205; // [sp+2A4h] [bp+2A4h]
  int v206; // [sp+2A8h] [bp+2A8h]
  int v207; // [sp+2ACh] [bp+2ACh]
  int v208; // [sp+2B0h] [bp+2B0h]
  int v209; // [sp+2B4h] [bp+2B4h]
  int v210; // [sp+2B8h] [bp+2B8h]
  int v211; // [sp+2BCh] [bp+2BCh]
  int v212; // [sp+2C0h] [bp+2C0h]
  int v213; // [sp+2C4h] [bp+2C4h]
  int v214; // [sp+2C8h] [bp+2C8h]
  int v215; // [sp+2CCh] [bp+2CCh]
  int v216; // [sp+2D0h] [bp+2D0h]
  int v217; // [sp+2D4h] [bp+2D4h]
  int v218; // [sp+2D8h] [bp+2D8h]
  int v219; // [sp+2DCh] [bp+2DCh]
  int v220; // [sp+2E0h] [bp+2E0h]
  int v221; // [sp+2E4h] [bp+2E4h]
  int v222; // [sp+2E8h] [bp+2E8h]
  int v223; // [sp+2ECh] [bp+2ECh]
  int v224; // [sp+2F0h] [bp+2F0h]
  int v225; // [sp+2F4h] [bp+2F4h]
  int v226; // [sp+2F8h] [bp+2F8h]
  int v227; // [sp+2FCh] [bp+2FCh]
  int v228; // [sp+300h] [bp+300h]
  int v229; // [sp+304h] [bp+304h]
  int v230; // [sp+308h] [bp+308h]
  int v231; // [sp+30Ch] [bp+30Ch] BYREF
  int v232; // [sp+310h] [bp+310h]
  int v233; // [sp+314h] [bp+314h]
  int v234; // [sp+318h] [bp+318h]
  int v235; // [sp+31Ch] [bp+31Ch]
  int v236; // [sp+320h] [bp+320h]
  int v237; // [sp+324h] [bp+324h]
  int v238; // [sp+328h] [bp+328h]
  int v239; // [sp+32Ch] [bp+32Ch]
  int v240; // [sp+330h] [bp+330h]
  int v241; // [sp+334h] [bp+334h]
  int v242; // [sp+338h] [bp+338h]
  int v243; // [sp+33Ch] [bp+33Ch]
  int v244; // [sp+340h] [bp+340h]
  int v245; // [sp+344h] [bp+344h]
  int v246; // [sp+348h] [bp+348h]
  int v247; // [sp+34Ch] [bp+34Ch]
  int v248; // [sp+350h] [bp+350h]
  int v249; // [sp+354h] [bp+354h]
  int v250; // [sp+358h] [bp+358h]
  int v251; // [sp+35Ch] [bp+35Ch]
  int v252; // [sp+360h] [bp+360h]
  int v253; // [sp+364h] [bp+364h]
  int v254; // [sp+368h] [bp+368h]
  int v255; // [sp+36Ch] [bp+36Ch]
  int v256; // [sp+370h] [bp+370h]
  int v257; // [sp+374h] [bp+374h]
  int v258; // [sp+378h] [bp+378h]
  int v259; // [sp+37Ch] [bp+37Ch]
  int v260; // [sp+380h] [bp+380h]
  int v261; // [sp+384h] [bp+384h]
  int v262; // [sp+388h] [bp+388h]
  int v263; // [sp+38Ch] [bp+38Ch]
  int v264; // [sp+390h] [bp+390h]
  int v265; // [sp+394h] [bp+394h]
  int v266; // [sp+398h] [bp+398h]
  int v267; // [sp+39Ch] [bp+39Ch]
  int v268; // [sp+3A0h] [bp+3A0h]
  int v269; // [sp+3A4h] [bp+3A4h]
  int v270; // [sp+3A8h] [bp+3A8h]
  int v271; // [sp+3ACh] [bp+3ACh]
  int v272; // [sp+3B0h] [bp+3B0h]
  int v273; // [sp+3B4h] [bp+3B4h]
  int v274; // [sp+3B8h] [bp+3B8h]
  int v275; // [sp+3BCh] [bp+3BCh]
  int v276; // [sp+3C0h] [bp+3C0h]
  int v277; // [sp+3C4h] [bp+3C4h]
  int v278; // [sp+3C8h] [bp+3C8h]
  int v279; // [sp+3CCh] [bp+3CCh]
  int v280; // [sp+3D0h] [bp+3D0h]
  int v281; // [sp+3D4h] [bp+3D4h]
  int v282; // [sp+3D8h] [bp+3D8h]
  int v283; // [sp+3DCh] [bp+3DCh]
  int v284; // [sp+3E0h] [bp+3E0h]
  int v285; // [sp+3E4h] [bp+3E4h]
  int v286; // [sp+3E8h] [bp+3E8h]
  int v287; // [sp+3ECh] [bp+3ECh]
  int v288; // [sp+3F0h] [bp+3F0h]
  int v289; // [sp+3F4h] [bp+3F4h]
  int v290; // [sp+3F8h] [bp+3F8h]
  int v291; // [sp+3FCh] [bp+3FCh]
  int v292; // [sp+400h] [bp+400h]
  int v293; // [sp+404h] [bp+404h]
  int v294; // [sp+408h] [bp+408h]
  int v295; // [sp+40Ch] [bp+40Ch]
  int v296; // [sp+410h] [bp+410h]
  int v297; // [sp+414h] [bp+414h]
  int v298; // [sp+418h] [bp+418h]
  int v299; // [sp+41Ch] [bp+41Ch]
  int v300; // [sp+420h] [bp+420h]
  int v301; // [sp+424h] [bp+424h]
  int v302; // [sp+428h] [bp+428h]
  int v303; // [sp+42Ch] [bp+42Ch]
  int v304; // [sp+430h] [bp+430h]
  int v305; // [sp+434h] [bp+434h]
  int v306; // [sp+438h] [bp+438h]
  int v307; // [sp+43Ch] [bp+43Ch]
  int v308; // [sp+440h] [bp+440h]
  int v309; // [sp+444h] [bp+444h]
  int v310; // [sp+448h] [bp+448h]
  int v311; // [sp+44Ch] [bp+44Ch]
  int v312; // [sp+450h] [bp+450h]
  int v313; // [sp+454h] [bp+454h]
  int v314; // [sp+458h] [bp+458h]
  int v315; // [sp+45Ch] [bp+45Ch]
  int v316; // [sp+460h] [bp+460h]
  int v317; // [sp+464h] [bp+464h]
  int v318; // [sp+468h] [bp+468h]
  int v319; // [sp+46Ch] [bp+46Ch]
  int v320; // [sp+470h] [bp+470h]
  int v321; // [sp+474h] [bp+474h]
  int v322; // [sp+478h] [bp+478h]
  int v323; // [sp+47Ch] [bp+47Ch]
  int v324; // [sp+480h] [bp+480h]
  int v325; // [sp+484h] [bp+484h]
  int v326; // [sp+488h] [bp+488h]
  int v327; // [sp+48Ch] [bp+48Ch]
  int v328; // [sp+490h] [bp+490h]
  int v329; // [sp+494h] [bp+494h]
  int v330; // [sp+498h] [bp+498h]
  int v331; // [sp+49Ch] [bp+49Ch]
  int v332; // [sp+4A0h] [bp+4A0h]
  int v333; // [sp+4A4h] [bp+4A4h]
  int v334; // [sp+4A8h] [bp+4A8h]
  int v335; // [sp+4ACh] [bp+4ACh]
  int v336; // [sp+4B0h] [bp+4B0h]
  int v337; // [sp+4B4h] [bp+4B4h]
  int v338; // [sp+4B8h] [bp+4B8h]
  int v339; // [sp+4BCh] [bp+4BCh]
  int v340; // [sp+4C0h] [bp+4C0h]
  int v341; // [sp+4C4h] [bp+4C4h]
  int v342; // [sp+4C8h] [bp+4C8h]
  int v343; // [sp+4CCh] [bp+4CCh]
  int v344; // [sp+4D0h] [bp+4D0h]
  int v345; // [sp+4D4h] [bp+4D4h]
  int v346; // [sp+4D8h] [bp+4D8h]
  int v347; // [sp+4DCh] [bp+4DCh]
  int v348; // [sp+4E0h] [bp+4E0h]
  int v349; // [sp+4E4h] [bp+4E4h]
  int v350; // [sp+4E8h] [bp+4E8h]
  int v351; // [sp+4ECh] [bp+4ECh]
  int v352; // [sp+4F0h] [bp+4F0h]
  int v353; // [sp+4F4h] [bp+4F4h]
  int v354; // [sp+4F8h] [bp+4F8h]
  int v355; // [sp+4FCh] [bp+4FCh]
  int v356; // [sp+500h] [bp+500h]
  int v357; // [sp+504h] [bp+504h]
  int v358; // [sp+508h] [bp+508h]
  int v359; // [sp+50Ch] [bp+50Ch]
  int v360; // [sp+510h] [bp+510h]
  int v361; // [sp+514h] [bp+514h]
  int v362; // [sp+518h] [bp+518h]
  int v363; // [sp+51Ch] [bp+51Ch]
  int v364; // [sp+520h] [bp+520h]
  int v365; // [sp+524h] [bp+524h]
  int v366; // [sp+528h] [bp+528h]
  int v367; // [sp+52Ch] [bp+52Ch]
  int v368; // [sp+530h] [bp+530h]
  int v369; // [sp+534h] [bp+534h]
  int v370; // [sp+538h] [bp+538h]
  int v371; // [sp+53Ch] [bp+53Ch]
  int v372; // [sp+540h] [bp+540h]
  int v373; // [sp+544h] [bp+544h]
  int v374; // [sp+548h] [bp+548h]
  int v375; // [sp+54Ch] [bp+54Ch]
  int v376; // [sp+550h] [bp+550h]
  int v377; // [sp+554h] [bp+554h]
  int v378; // [sp+558h] [bp+558h]
  int v379; // [sp+55Ch] [bp+55Ch]
  int v380; // [sp+560h] [bp+560h]
  int v381; // [sp+564h] [bp+564h]
  int v382; // [sp+568h] [bp+568h]
  int v383; // [sp+56Ch] [bp+56Ch]
  int v384; // [sp+570h] [bp+570h]
  int v385; // [sp+574h] [bp+574h]
  int v386; // [sp+578h] [bp+578h]
  int v387; // [sp+57Ch] [bp+57Ch]
  int v388; // [sp+580h] [bp+580h]
  int v389; // [sp+584h] [bp+584h]
  int v390; // [sp+588h] [bp+588h]
  int v391; // [sp+58Ch] [bp+58Ch]
  int v392; // [sp+590h] [bp+590h]
  int v393; // [sp+594h] [bp+594h]
  int v394; // [sp+598h] [bp+598h]
  int v395; // [sp+59Ch] [bp+59Ch]
  int v396; // [sp+5A0h] [bp+5A0h]
  int v397; // [sp+5A4h] [bp+5A4h]
  int v398; // [sp+5A8h] [bp+5A8h]
  int v399; // [sp+5ACh] [bp+5ACh]
  int v400; // [sp+5B0h] [bp+5B0h]
  int v401; // [sp+5B4h] [bp+5B4h]
  int v402; // [sp+5B8h] [bp+5B8h]
  int v403; // [sp+5BCh] [bp+5BCh]
  int v404; // [sp+5C0h] [bp+5C0h]
  int v405; // [sp+5C4h] [bp+5C4h]
  int v406; // [sp+5C8h] [bp+5C8h]
  int v407; // [sp+5CCh] [bp+5CCh]
  int v408; // [sp+5D0h] [bp+5D0h]
  int v409; // [sp+5D4h] [bp+5D4h]
  int v410; // [sp+5D8h] [bp+5D8h]
  int v411; // [sp+5DCh] [bp+5DCh]
  int v412; // [sp+5E0h] [bp+5E0h]
  int v413; // [sp+5E4h] [bp+5E4h]
  int v414; // [sp+5E8h] [bp+5E8h]
  int v415; // [sp+5ECh] [bp+5ECh]
  int v416; // [sp+5F0h] [bp+5F0h]
  int v417; // [sp+5F4h] [bp+5F4h]
  int v418; // [sp+5F8h] [bp+5F8h]
  int v419; // [sp+5FCh] [bp+5FCh]
  int v420; // [sp+600h] [bp+600h]
  int v421; // [sp+604h] [bp+604h]
  int v422; // [sp+608h] [bp+608h]
  int v423; // [sp+60Ch] [bp+60Ch]
  int v424; // [sp+610h] [bp+610h]
  int v425; // [sp+614h] [bp+614h]
  int v426; // [sp+618h] [bp+618h]
  int v427; // [sp+61Ch] [bp+61Ch]
  int v428; // [sp+620h] [bp+620h]
  int v429; // [sp+624h] [bp+624h]
  int v430; // [sp+628h] [bp+628h]
  int v431; // [sp+62Ch] [bp+62Ch]
  int v432; // [sp+630h] [bp+630h]
  int v433; // [sp+634h] [bp+634h]
  int v434; // [sp+638h] [bp+638h]
  int v435; // [sp+63Ch] [bp+63Ch]
  int v436; // [sp+640h] [bp+640h]
  int v437; // [sp+644h] [bp+644h]
  int v438; // [sp+648h] [bp+648h]
  int v439; // [sp+64Ch] [bp+64Ch]
  int v440; // [sp+650h] [bp+650h]
  int v441; // [sp+654h] [bp+654h]
  int v442; // [sp+658h] [bp+658h]
  int v443; // [sp+65Ch] [bp+65Ch]
  int v444; // [sp+660h] [bp+660h]
  int v445; // [sp+664h] [bp+664h]
  int v446; // [sp+668h] [bp+668h]
  int v447; // [sp+66Ch] [bp+66Ch]
  int v448; // [sp+670h] [bp+670h]
  int v449; // [sp+674h] [bp+674h]
  int v450; // [sp+678h] [bp+678h]
  int v451; // [sp+67Ch] [bp+67Ch]
  int v452; // [sp+680h] [bp+680h]
  int v453; // [sp+684h] [bp+684h]
  int v454; // [sp+688h] [bp+688h]
  int v455; // [sp+68Ch] [bp+68Ch]
  int v456; // [sp+690h] [bp+690h]
  int v457; // [sp+694h] [bp+694h]
  int v458; // [sp+698h] [bp+698h]
  int v459; // [sp+69Ch] [bp+69Ch]
  int v460; // [sp+6A0h] [bp+6A0h]
  int v461; // [sp+6A4h] [bp+6A4h]
  int v462; // [sp+6A8h] [bp+6A8h]
  int v463; // [sp+6ACh] [bp+6ACh]
  int v464; // [sp+6B0h] [bp+6B0h]
  int v465; // [sp+6B4h] [bp+6B4h]
  int v466; // [sp+6B8h] [bp+6B8h]
  int v467; // [sp+6BCh] [bp+6BCh]
  int v468; // [sp+6C0h] [bp+6C0h]
  int v469; // [sp+6C4h] [bp+6C4h]
  int v470; // [sp+6C8h] [bp+6C8h]
  int v471; // [sp+6CCh] [bp+6CCh]
  int v472; // [sp+6D0h] [bp+6D0h]
  int v473; // [sp+6D4h] [bp+6D4h]
  int v474; // [sp+6D8h] [bp+6D8h]
  int v475; // [sp+6DCh] [bp+6DCh]
  int v476; // [sp+6E0h] [bp+6E0h]
  int v477; // [sp+6E4h] [bp+6E4h]
  int v478; // [sp+6E8h] [bp+6E8h]
  int v479; // [sp+6ECh] [bp+6ECh]
  int v480; // [sp+6F0h] [bp+6F0h]
  int v481; // [sp+6F4h] [bp+6F4h]
  int v482; // [sp+6F8h] [bp+6F8h]
  int v483; // [sp+6FCh] [bp+6FCh]
  int v484; // [sp+700h] [bp+700h]
  int v485; // [sp+704h] [bp+704h]
  int v486; // [sp+708h] [bp+708h]
  int v487; // [sp+70Ch] [bp+70Ch]
  int v488; // [sp+710h] [bp+710h]
  int v489; // [sp+714h] [bp+714h]
  int v490; // [sp+718h] [bp+718h]
  int v491; // [sp+71Ch] [bp+71Ch]
  int v492; // [sp+720h] [bp+720h]
  int v493; // [sp+724h] [bp+724h]
  int v494; // [sp+728h] [bp+728h]
  int v495; // [sp+72Ch] [bp+72Ch]
  int v496; // [sp+730h] [bp+730h]
  int v497; // [sp+734h] [bp+734h]
  int v498; // [sp+738h] [bp+738h]
  int v499; // [sp+73Ch] [bp+73Ch]
  int v500; // [sp+740h] [bp+740h]
  int v501; // [sp+744h] [bp+744h]
  int v502; // [sp+748h] [bp+748h]
  int v503; // [sp+74Ch] [bp+74Ch]
  int v504; // [sp+750h] [bp+750h]
  int v505; // [sp+754h] [bp+754h]
  int v506; // [sp+758h] [bp+758h]
  int v507; // [sp+75Ch] [bp+75Ch]
  int v508; // [sp+760h] [bp+760h]
  int v509; // [sp+764h] [bp+764h]
  int v510; // [sp+768h] [bp+768h]
  int v511; // [sp+76Ch] [bp+76Ch]
  int v512; // [sp+770h] [bp+770h]
  int v513; // [sp+774h] [bp+774h]
  int v514; // [sp+778h] [bp+778h]
  int v515; // [sp+77Ch] [bp+77Ch]
  int v516; // [sp+780h] [bp+780h]
  int v517; // [sp+784h] [bp+784h]
  int v518; // [sp+788h] [bp+788h]
  int v519; // [sp+78Ch] [bp+78Ch]
  int v520; // [sp+790h] [bp+790h]
  int v521; // [sp+794h] [bp+794h]
  int v522; // [sp+798h] [bp+798h]
  int v523; // [sp+79Ch] [bp+79Ch]
  int v524; // [sp+7A0h] [bp+7A0h]
  int v525; // [sp+7A4h] [bp+7A4h]
  int v526; // [sp+7A8h] [bp+7A8h]
  int v527; // [sp+7ACh] [bp+7ACh]
  int v528; // [sp+7B0h] [bp+7B0h]
  int v529; // [sp+7B4h] [bp+7B4h]
  int v530; // [sp+7B8h] [bp+7B8h]
  int v531; // [sp+7BCh] [bp+7BCh]
  int v532; // [sp+7C0h] [bp+7C0h]
  int v533; // [sp+7C4h] [bp+7C4h]
  int v534; // [sp+7C8h] [bp+7C8h]
  int v535; // [sp+7CCh] [bp+7CCh]
  int v536; // [sp+7D0h] [bp+7D0h]
  int v537; // [sp+7D4h] [bp+7D4h]
  int v538; // [sp+7D8h] [bp+7D8h]
  int v539; // [sp+7DCh] [bp+7DCh]
  int v540; // [sp+7E0h] [bp+7E0h]
  int v541; // [sp+7E4h] [bp+7E4h]
  int v542; // [sp+7E8h] [bp+7E8h]
  int v543; // [sp+7ECh] [bp+7ECh]
  int v544; // [sp+7F0h] [bp+7F0h]
  int v545; // [sp+7F4h] [bp+7F4h]
  int v546; // [sp+7F8h] [bp+7F8h]
  int v547; // [sp+7FCh] [bp+7FCh]
  int v548; // [sp+800h] [bp+800h]
  int v549; // [sp+804h] [bp+804h]
  int v550; // [sp+808h] [bp+808h]
  int v551; // [sp+80Ch] [bp+80Ch]
  int v552; // [sp+810h] [bp+810h]
  int v553; // [sp+814h] [bp+814h]
  int v554; // [sp+818h] [bp+818h]
  int v555; // [sp+81Ch] [bp+81Ch]
  int v556; // [sp+820h] [bp+820h]
  int v557; // [sp+824h] [bp+824h]
  int v558; // [sp+828h] [bp+828h]
  int v559; // [sp+82Ch] [bp+82Ch]
  int v560; // [sp+830h] [bp+830h]
  int v561; // [sp+834h] [bp+834h]
  int v562; // [sp+838h] [bp+838h]
  int v563; // [sp+83Ch] [bp+83Ch]
  int v564; // [sp+840h] [bp+840h]
  int v565; // [sp+844h] [bp+844h]
  int v566; // [sp+848h] [bp+848h]
  int v567; // [sp+84Ch] [bp+84Ch]
  int v568; // [sp+850h] [bp+850h]
  int v569; // [sp+854h] [bp+854h]
  int v570; // [sp+858h] [bp+858h]
  int v571; // [sp+85Ch] [bp+85Ch]
  int v572; // [sp+860h] [bp+860h]
  int v573; // [sp+864h] [bp+864h]
  int v574; // [sp+868h] [bp+868h]
  int v575; // [sp+86Ch] [bp+86Ch]
  int v576; // [sp+870h] [bp+870h]
  int v577; // [sp+874h] [bp+874h]
  int v578; // [sp+878h] [bp+878h]
  int v579; // [sp+87Ch] [bp+87Ch]
  int v580; // [sp+880h] [bp+880h]
  int v581; // [sp+884h] [bp+884h]
  int v582; // [sp+888h] [bp+888h]
  int v583; // [sp+88Ch] [bp+88Ch]
  int v584; // [sp+890h] [bp+890h]
  int v585; // [sp+894h] [bp+894h]
  int v586; // [sp+898h] [bp+898h]
  int v587; // [sp+89Ch] [bp+89Ch]
  int v588; // [sp+8A0h] [bp+8A0h]
  int v589; // [sp+8A4h] [bp+8A4h]
  int v590; // [sp+8A8h] [bp+8A8h]
  int v591; // [sp+8ACh] [bp+8ACh]
  int v592; // [sp+8B0h] [bp+8B0h]
  int v593; // [sp+8B4h] [bp+8B4h]
  int v594; // [sp+8B8h] [bp+8B8h]
  int v595; // [sp+8BCh] [bp+8BCh]
  int v596; // [sp+8C0h] [bp+8C0h]
  int v597; // [sp+8C4h] [bp+8C4h]
  int v598; // [sp+8C8h] [bp+8C8h]
  int v599; // [sp+8CCh] [bp+8CCh]
  int v600; // [sp+8D0h] [bp+8D0h]
  int v601; // [sp+8D4h] [bp+8D4h]
  int v602; // [sp+8D8h] [bp+8D8h]
  int v603; // [sp+8DCh] [bp+8DCh]
  int v604; // [sp+8E0h] [bp+8E0h]
  int v605; // [sp+8E4h] [bp+8E4h]
  int v606; // [sp+8E8h] [bp+8E8h]
  int v607; // [sp+8ECh] [bp+8ECh]
  int v608; // [sp+8F0h] [bp+8F0h]
  int v609; // [sp+8F4h] [bp+8F4h]
  int v610; // [sp+8F8h] [bp+8F8h]
  int v611; // [sp+8FCh] [bp+8FCh]
  int v612; // [sp+900h] [bp+900h]
  int v613; // [sp+904h] [bp+904h]
  int v614; // [sp+908h] [bp+908h]
  int v615; // [sp+90Ch] [bp+90Ch]
  int v616; // [sp+910h] [bp+910h]
  int v617; // [sp+914h] [bp+914h]
  int v618; // [sp+918h] [bp+918h]
  int v619; // [sp+91Ch] [bp+91Ch]
  int v620; // [sp+920h] [bp+920h]
  int v621; // [sp+924h] [bp+924h]
  int v622; // [sp+928h] [bp+928h]
  int v623; // [sp+92Ch] [bp+92Ch]
  int v624; // [sp+930h] [bp+930h]
  int v625; // [sp+934h] [bp+934h]
  int v626; // [sp+938h] [bp+938h]
  int v627; // [sp+93Ch] [bp+93Ch]
  int v628; // [sp+940h] [bp+940h]
  int v629; // [sp+944h] [bp+944h]
  int v630; // [sp+948h] [bp+948h]
  int v631; // [sp+94Ch] [bp+94Ch]
  int v632; // [sp+950h] [bp+950h]
  int v633; // [sp+954h] [bp+954h]
  int v634; // [sp+958h] [bp+958h]
  int v635; // [sp+95Ch] [bp+95Ch]
  int v636; // [sp+960h] [bp+960h]
  int v637; // [sp+964h] [bp+964h]
  int v638; // [sp+968h] [bp+968h]
  int v639; // [sp+96Ch] [bp+96Ch]
  int v640; // [sp+970h] [bp+970h]
  int v641; // [sp+974h] [bp+974h]
  int v642; // [sp+978h] [bp+978h]
  int v643; // [sp+97Ch] [bp+97Ch]
  int v644; // [sp+980h] [bp+980h]
  int v645; // [sp+984h] [bp+984h]
  int v646; // [sp+988h] [bp+988h]
  int v647; // [sp+98Ch] [bp+98Ch]
  int v648; // [sp+990h] [bp+990h]
  int v649; // [sp+994h] [bp+994h]
  int v650; // [sp+998h] [bp+998h]
  int v651; // [sp+99Ch] [bp+99Ch]
  int v652; // [sp+9A0h] [bp+9A0h]
  int v653; // [sp+9A4h] [bp+9A4h]
  int v654; // [sp+9A8h] [bp+9A8h]
  int v655; // [sp+9ACh] [bp+9ACh]
  int v656; // [sp+9B0h] [bp+9B0h]
  int v657; // [sp+9B4h] [bp+9B4h]
  int v658; // [sp+9B8h] [bp+9B8h]
  int v659; // [sp+9BCh] [bp+9BCh]
  int v660; // [sp+9C0h] [bp+9C0h]
  int v661; // [sp+9C4h] [bp+9C4h]
  int v662; // [sp+9C8h] [bp+9C8h]
  int v663; // [sp+9CCh] [bp+9CCh]
  int v664; // [sp+9D0h] [bp+9D0h]
  int v665; // [sp+9D4h] [bp+9D4h]
  int v666; // [sp+9D8h] [bp+9D8h]
  int v667; // [sp+9DCh] [bp+9DCh]
  int v668; // [sp+9E0h] [bp+9E0h]
  int v669; // [sp+9E4h] [bp+9E4h]
  int v670; // [sp+9E8h] [bp+9E8h]
  int v671; // [sp+9ECh] [bp+9ECh]
  int v672; // [sp+9F0h] [bp+9F0h]
  int v673; // [sp+9F4h] [bp+9F4h]
  int v674; // [sp+9F8h] [bp+9F8h]
  int v675; // [sp+9FCh] [bp+9FCh]
  int v676; // [sp+A00h] [bp+A00h]
  int v677; // [sp+A04h] [bp+A04h]
  int v678; // [sp+A08h] [bp+A08h]
  int v679; // [sp+A0Ch] [bp+A0Ch]
  int v680; // [sp+A10h] [bp+A10h]
  int v681; // [sp+A14h] [bp+A14h]
  int v682; // [sp+A18h] [bp+A18h]
  int v683; // [sp+A1Ch] [bp+A1Ch]
  int v684; // [sp+A20h] [bp+A20h]
  int v685; // [sp+A24h] [bp+A24h]
  int v686; // [sp+A28h] [bp+A28h]
  int v687; // [sp+A2Ch] [bp+A2Ch]
  int v688; // [sp+A30h] [bp+A30h]
  int v689; // [sp+A34h] [bp+A34h]
  int v690; // [sp+A38h] [bp+A38h]
  int v691; // [sp+A3Ch] [bp+A3Ch]
  int v692; // [sp+A40h] [bp+A40h]
  int v693; // [sp+A44h] [bp+A44h]
  int v694; // [sp+A48h] [bp+A48h]
  int v695; // [sp+A4Ch] [bp+A4Ch]
  int v696; // [sp+A50h] [bp+A50h]
  int v697; // [sp+A54h] [bp+A54h]
  int v698; // [sp+A58h] [bp+A58h]
  int v699; // [sp+A5Ch] [bp+A5Ch]
  int v700; // [sp+A60h] [bp+A60h]
  int v701; // [sp+A64h] [bp+A64h]
  int v702; // [sp+A68h] [bp+A68h]
  int v703; // [sp+A6Ch] [bp+A6Ch]
  int v704; // [sp+A70h] [bp+A70h]
  int v705; // [sp+A74h] [bp+A74h]
  int v706; // [sp+A78h] [bp+A78h]
  int v707; // [sp+A7Ch] [bp+A7Ch]
  int v708; // [sp+A80h] [bp+A80h]
  int v709; // [sp+A84h] [bp+A84h]
  int v710; // [sp+A88h] [bp+A88h]
  int v711; // [sp+A8Ch] [bp+A8Ch]
  int v712; // [sp+A90h] [bp+A90h]
  int v713; // [sp+A94h] [bp+A94h]
  int v714; // [sp+A98h] [bp+A98h]
  int v715; // [sp+A9Ch] [bp+A9Ch]
  int v716; // [sp+AA0h] [bp+AA0h]
  int v717; // [sp+AA4h] [bp+AA4h]
  int v718; // [sp+AA8h] [bp+AA8h]
  int v719; // [sp+AACh] [bp+AACh]
  int v720; // [sp+AB0h] [bp+AB0h]
  int v721; // [sp+AB4h] [bp+AB4h]
  int v722; // [sp+AB8h] [bp+AB8h]
  int v723; // [sp+ABCh] [bp+ABCh]
  int v724; // [sp+AC0h] [bp+AC0h]
  int v725; // [sp+AC4h] [bp+AC4h]
  int v726; // [sp+AC8h] [bp+AC8h]
  int v727; // [sp+ACCh] [bp+ACCh]
  int v728; // [sp+AD0h] [bp+AD0h]
  int v729; // [sp+AD4h] [bp+AD4h]
  int v730; // [sp+AD8h] [bp+AD8h]
  int v731; // [sp+ADCh] [bp+ADCh]
  int v732; // [sp+AE0h] [bp+AE0h]
  int v733; // [sp+AE4h] [bp+AE4h]
  int v734; // [sp+AE8h] [bp+AE8h]
  int v735; // [sp+AECh] [bp+AECh]
  int v736; // [sp+AF0h] [bp+AF0h]
  int v737; // [sp+AF4h] [bp+AF4h]
  int v738; // [sp+AF8h] [bp+AF8h]
  int v739; // [sp+AFCh] [bp+AFCh]
  int v740; // [sp+B00h] [bp+B00h]
  int v741; // [sp+B04h] [bp+B04h]
  int v742; // [sp+B08h] [bp+B08h]
  int v743; // [sp+B0Ch] [bp+B0Ch]
  int v744; // [sp+B10h] [bp+B10h]
  int v745; // [sp+B14h] [bp+B14h]
  int v746; // [sp+B18h] [bp+B18h]
  int v747; // [sp+B1Ch] [bp+B1Ch]
  int v748; // [sp+B20h] [bp+B20h]
  int v749; // [sp+B24h] [bp+B24h]
  int v750; // [sp+B28h] [bp+B28h]
  int v751; // [sp+B2Ch] [bp+B2Ch]
  int v752; // [sp+B30h] [bp+B30h]
  int v753; // [sp+B34h] [bp+B34h]
  int v754; // [sp+B38h] [bp+B38h]
  int v755; // [sp+B3Ch] [bp+B3Ch]
  int v756; // [sp+B40h] [bp+B40h]
  int v757; // [sp+B44h] [bp+B44h]
  int v758; // [sp+B48h] [bp+B48h]
  int v759; // [sp+B4Ch] [bp+B4Ch]
  int v760; // [sp+B50h] [bp+B50h]
  int v761; // [sp+B54h] [bp+B54h]
  int v762; // [sp+B58h] [bp+B58h]
  int v763; // [sp+B5Ch] [bp+B5Ch]
  int v764; // [sp+B60h] [bp+B60h]
  int v765; // [sp+B64h] [bp+B64h]
  int v766; // [sp+B68h] [bp+B68h]
  int v767; // [sp+B6Ch] [bp+B6Ch]
  int v768; // [sp+B70h] [bp+B70h]
  int v769; // [sp+B74h] [bp+B74h]
  int v770; // [sp+B78h] [bp+B78h]
  int v771; // [sp+B7Ch] [bp+B7Ch]
  int v772; // [sp+B80h] [bp+B80h]
  int v773; // [sp+B84h] [bp+B84h]
  int v774; // [sp+B88h] [bp+B88h]
  int v775; // [sp+B8Ch] [bp+B8Ch]
  int v776; // [sp+B90h] [bp+B90h]
  int v777; // [sp+B94h] [bp+B94h]
  int v778; // [sp+B98h] [bp+B98h]
  int v779; // [sp+B9Ch] [bp+B9Ch]
  int v780; // [sp+BA0h] [bp+BA0h]
  int v781; // [sp+BA4h] [bp+BA4h]
  int v782; // [sp+BA8h] [bp+BA8h]
  int v783; // [sp+BACh] [bp+BACh]
  int v784; // [sp+BB0h] [bp+BB0h]
  int v785; // [sp+BB4h] [bp+BB4h]
  int v786; // [sp+BB8h] [bp+BB8h]
  int v787; // [sp+BBCh] [bp+BBCh]
  int v788; // [sp+BC0h] [bp+BC0h]
  int v789; // [sp+BC4h] [bp+BC4h]
  int v790; // [sp+BC8h] [bp+BC8h]
  int v791; // [sp+BCCh] [bp+BCCh]
  int v792; // [sp+BD0h] [bp+BD0h]
  int v793; // [sp+BD4h] [bp+BD4h]
  int v794; // [sp+BD8h] [bp+BD8h]
  int v795; // [sp+BDCh] [bp+BDCh]
  int v796; // [sp+BE0h] [bp+BE0h]
  int v797; // [sp+BE4h] [bp+BE4h]
  int v798; // [sp+BE8h] [bp+BE8h]
  int v799; // [sp+BECh] [bp+BECh]
  int v800; // [sp+BF0h] [bp+BF0h]
  int v801; // [sp+BF4h] [bp+BF4h]
  int v802; // [sp+BF8h] [bp+BF8h]
  int v803; // [sp+BFCh] [bp+BFCh]
  int v804; // [sp+C00h] [bp+C00h]
  int v805; // [sp+C04h] [bp+C04h]
  int v806; // [sp+C08h] [bp+C08h]
  int v807; // [sp+C0Ch] [bp+C0Ch]
  int v808; // [sp+C10h] [bp+C10h]
  int v809; // [sp+C14h] [bp+C14h]
  int v810; // [sp+C18h] [bp+C18h]
  int v811; // [sp+C1Ch] [bp+C1Ch]
  int v812; // [sp+C20h] [bp+C20h]
  int v813; // [sp+C24h] [bp+C24h]
  int v814; // [sp+C28h] [bp+C28h]
  int v815; // [sp+C2Ch] [bp+C2Ch]
  int v816; // [sp+C30h] [bp+C30h]
  int v817; // [sp+C34h] [bp+C34h]
  int v818; // [sp+C38h] [bp+C38h]
  int v819; // [sp+C3Ch] [bp+C3Ch]
  int v820; // [sp+C40h] [bp+C40h]
  int v821; // [sp+C44h] [bp+C44h]
  int v822; // [sp+C48h] [bp+C48h]
  int v823; // [sp+C4Ch] [bp+C4Ch]
  int v824; // [sp+C50h] [bp+C50h]
  int v825; // [sp+C54h] [bp+C54h]
  int v826; // [sp+C58h] [bp+C58h]
  int v827; // [sp+C5Ch] [bp+C5Ch]
  int v828; // [sp+C60h] [bp+C60h]
  int v829; // [sp+C64h] [bp+C64h]
  int v830; // [sp+C68h] [bp+C68h]
  int v831; // [sp+C6Ch] [bp+C6Ch]
  int v832; // [sp+C70h] [bp+C70h]
  int v833; // [sp+C74h] [bp+C74h]
  int v834; // [sp+C78h] [bp+C78h]
  int v835; // [sp+C7Ch] [bp+C7Ch]
  int v836; // [sp+C80h] [bp+C80h]
  int v837; // [sp+C84h] [bp+C84h]
  int v838; // [sp+C88h] [bp+C88h]
  int v839; // [sp+C8Ch] [bp+C8Ch]
  int v840; // [sp+C90h] [bp+C90h]
  int v841; // [sp+C94h] [bp+C94h]
  int v842; // [sp+C98h] [bp+C98h]
  int v843; // [sp+C9Ch] [bp+C9Ch]
  int v844; // [sp+CA0h] [bp+CA0h]
  int v845; // [sp+CA4h] [bp+CA4h]
  int v846; // [sp+CA8h] [bp+CA8h]
  int v847; // [sp+CACh] [bp+CACh]
  int v848; // [sp+CB0h] [bp+CB0h]
  int v849; // [sp+CB4h] [bp+CB4h]
  int v850; // [sp+CB8h] [bp+CB8h]
  int v851; // [sp+CBCh] [bp+CBCh]
  int v852; // [sp+CC0h] [bp+CC0h]
  int v853; // [sp+CC4h] [bp+CC4h]
  int v854; // [sp+CC8h] [bp+CC8h]
  int v855; // [sp+CCCh] [bp+CCCh]
  int v856; // [sp+CD0h] [bp+CD0h]
  int v857; // [sp+CD4h] [bp+CD4h]
  int v858; // [sp+CD8h] [bp+CD8h]
  int v859; // [sp+CDCh] [bp+CDCh]
  int v860; // [sp+CE0h] [bp+CE0h]
  int v861; // [sp+CE4h] [bp+CE4h]
  int v862; // [sp+CE8h] [bp+CE8h]
  int v863; // [sp+CECh] [bp+CECh]
  int v864; // [sp+CF0h] [bp+CF0h]
  int v865; // [sp+CF4h] [bp+CF4h]
  int v866; // [sp+CF8h] [bp+CF8h]
  int v867; // [sp+CFCh] [bp+CFCh]
  int v868; // [sp+D00h] [bp+D00h]
  int v869; // [sp+D04h] [bp+D04h]
  int v870; // [sp+D08h] [bp+D08h]
  int v871; // [sp+D0Ch] [bp+D0Ch]
  int v872; // [sp+D10h] [bp+D10h]
  int v873; // [sp+D14h] [bp+D14h]
  int v874; // [sp+D18h] [bp+D18h]
  int v875; // [sp+D1Ch] [bp+D1Ch]
  int v876; // [sp+D20h] [bp+D20h]
  int v877; // [sp+D24h] [bp+D24h]
  int v878; // [sp+D28h] [bp+D28h]
  int v879; // [sp+D2Ch] [bp+D2Ch]
  int v880; // [sp+D30h] [bp+D30h]
  int v881; // [sp+D34h] [bp+D34h]
  int v882; // [sp+D38h] [bp+D38h]
  int v883; // [sp+D3Ch] [bp+D3Ch]
  int v884; // [sp+D40h] [bp+D40h]
  int v885; // [sp+D44h] [bp+D44h]
  int v886; // [sp+D48h] [bp+D48h]
  int v887; // [sp+D4Ch] [bp+D4Ch]
  int v888; // [sp+D50h] [bp+D50h]
  int v889; // [sp+D54h] [bp+D54h]
  int v890; // [sp+D58h] [bp+D58h]
  int v891; // [sp+D5Ch] [bp+D5Ch]
  int v892; // [sp+D60h] [bp+D60h]
  int v893; // [sp+D64h] [bp+D64h]
  int v894; // [sp+D68h] [bp+D68h]
  int v895; // [sp+D6Ch] [bp+D6Ch]
  int v896; // [sp+D70h] [bp+D70h]
  int v897; // [sp+D74h] [bp+D74h]
  int v898; // [sp+D78h] [bp+D78h]
  int v899; // [sp+D7Ch] [bp+D7Ch]
  int v900; // [sp+D80h] [bp+D80h]
  int v901; // [sp+D84h] [bp+D84h]
  int v902; // [sp+D88h] [bp+D88h]
  int v903; // [sp+D8Ch] [bp+D8Ch]
  int v904; // [sp+D90h] [bp+D90h]
  int v905; // [sp+D94h] [bp+D94h]
  int v906; // [sp+D98h] [bp+D98h]
  int v907; // [sp+D9Ch] [bp+D9Ch]
  int v908; // [sp+DA0h] [bp+DA0h]
  int v909; // [sp+DA4h] [bp+DA4h]
  int v910; // [sp+DA8h] [bp+DA8h]
  int v911; // [sp+DACh] [bp+DACh]
  int v912; // [sp+DB0h] [bp+DB0h]
  int v913; // [sp+DB4h] [bp+DB4h]
  unsigned __int8 *v914; // [sp+DB8h] [bp+DB8h]
  int v915; // [sp+DBCh] [bp+DBCh]
  unsigned int k; // [sp+DC0h] [bp+DC0h]
  int v917; // [sp+DC4h] [bp+DC4h]
  unsigned int j; // [sp+DC8h] [bp+DC8h]
  int v919; // [sp+DCCh] [bp+DCCh]
  unsigned int i; // [sp+DD0h] [bp+DD0h]
  int m; // [sp+DD4h] [bp+DD4h]

  v914 = a1;
  sub_140EB4(a1, 4, &v39);
  sub_140EB4(v914 + 2, 4, &v103);
  v913 = v39;
  v912 = v103;
  v39 += v103;
  v103 = v913 - v103;
  v919 = 0;
  for ( i = 0; ; *(&v39 + i + 64) = v913 - v911 )
  {
    v913 = *(&v39 + i + 1);
    v912 = *(&v39 + i + 65);
    v911 = ((v912 * dword_1D48C8[v919 + 2]) >> 16) + (unsigned __int16)(v912 * dword_1D48C8[v919 + 2]);
    *(&v39 + i + 1) = v913 + v911;
    *(&v39 + i + 65) = v913 - v911;
    v913 = *(&v39 + i + 2);
    v912 = *(&v39 + i + 66);
    v911 = ((v912 * dword_1D48C8[v919 + 4]) >> 16) + (unsigned __int16)(v912 * dword_1D48C8[v919 + 4]);
    *(&v39 + i + 2) = v913 + v911;
    *(&v39 + i + 66) = v913 - v911;
    v913 = *(&v39 + i + 3);
    v912 = *(&v39 + i + 67);
    v911 = ((v912 * dword_1D48C8[v919 + 6]) >> 16) + (unsigned __int16)(v912 * dword_1D48C8[v919 + 6]);
    *(&v39 + i + 3) = v913 + v911;
    *(&v39 + i + 67) = v913 - v911;
    i += 4;
    v919 += 8;
    if ( i > 0x3F )
      break;
    v913 = *(&v39 + i);
    v912 = *(&v39 + i + 64);
    v911 = ((v912 * dword_1D48C8[v919]) >> 16) + (unsigned __int16)(v912 * dword_1D48C8[v919]);
    *(&v39 + i) = v913 + v911;
  }
  sub_140EB4(v914 + 1, 4, &v167);
  sub_140EB4(v914 + 3, 4, &v231);
  v910 = v167;
  v909 = v231;
  v167 += v231;
  v231 = v910 - v231;
  v917 = 0;
  for ( j = 0; ; *(&v39 + j + 192) = v910 - v908 )
  {
    v910 = *(&v39 + j + 129);
    v909 = *(&v39 + j + 193);
    v908 = ((v909 * dword_1D48C8[v917 + 2]) >> 16) + (unsigned __int16)(v909 * dword_1D48C8[v917 + 2]);
    *(&v39 + j + 129) = v910 + v908;
    *(&v39 + j + 193) = v910 - v908;
    v910 = *(&v39 + j + 130);
    v909 = *(&v39 + j + 194);
    v908 = ((v909 * dword_1D48C8[v917 + 4]) >> 16) + (unsigned __int16)(v909 * dword_1D48C8[v917 + 4]);
    *(&v39 + j + 130) = v910 + v908;
    *(&v39 + j + 194) = v910 - v908;
    v910 = *(&v39 + j + 131);
    v909 = *(&v39 + j + 195);
    v908 = ((v909 * dword_1D48C8[v917 + 6]) >> 16) + (unsigned __int16)(v909 * dword_1D48C8[v917 + 6]);
    *(&v39 + j + 131) = v910 + v908;
    *(&v39 + j + 195) = v910 - v908;
    j += 4;
    v917 += 8;
    if ( j > 0x3F )
      break;
    v910 = *(&v39 + j + 128);
    v909 = *(&v39 + j + 192);
    v908 = ((v909 * dword_1D48C8[v917]) >> 16) + (unsigned __int16)(v909 * dword_1D48C8[v917]);
    *(&v39 + j + 128) = v910 + v908;
  }
  v907 = v39;
  v906 = v167;
  v39 += v167;
  v167 = v907 - v167;
  v915 = 0;
  for ( k = 0; ; *(&v39 + k + 128) = v907 - v905 )
  {
    v907 = *(&v39 + k + 1);
    v906 = *(&v39 + k + 129);
    v905 = ((v906 * dword_1D48C8[v915 + 1]) >> 16) + (unsigned __int16)(v906 * dword_1D48C8[v915 + 1]);
    *(&v39 + k + 1) = v907 + v905;
    *(&v39 + k + 129) = v907 - v905;
    v907 = *(&v39 + k + 2);
    v906 = *(&v39 + k + 130);
    v905 = ((v906 * dword_1D48C8[v915 + 2]) >> 16) + (unsigned __int16)(v906 * dword_1D48C8[v915 + 2]);
    *(&v39 + k + 2) = v907 + v905;
    *(&v39 + k + 130) = v907 - v905;
    v907 = *(&v39 + k + 3);
    v906 = *(&v39 + k + 131);
    v905 = ((v906 * dword_1D48C8[v915 + 3]) >> 16) + (unsigned __int16)(v906 * dword_1D48C8[v915 + 3]);
    *(&v39 + k + 3) = v907 + v905;
    *(&v39 + k + 131) = v907 - v905;
    k += 4;
    v915 += 4;
    if ( k > 0x7F )
      break;
    v907 = *(&v39 + k);
    v906 = *(&v39 + k + 128);
    v905 = ((v906 * dword_1D48C8[v915]) >> 16) + (unsigned __int16)(v906 * dword_1D48C8[v915]);
    *(&v39 + k) = v907 + v905;
  }
  if ( a2 )
  {
    for ( m = 0; m <= 255; ++m )
    {
      v904 = word_1D50C8[m] + *(&v39 + m);
      v904 = (v904 >> 16) + (unsigned __int16)v904;
      v904 = (unsigned __int8)v904 - (v904 >> 8);
      v904 = (unsigned __int8)v904 - (v904 >> 8);
      if ( v904 <= 128 )
        v2 = v904;
      else
        v2 = v904 - 257;
      *(&v39 + m) = v2;
    }
  }
  else
  {
    for ( m = 0; m <= 255; ++m )
    {
      v903 = word_1D4EC8[m] + *(&v39 + m);
      v903 = (v903 >> 16) + (unsigned __int16)v903;
      v903 = (unsigned __int8)v903 - (v903 >> 8);
      v903 = (unsigned __int8)v903 - (v903 >> 8);
      if ( v903 <= 128 )
        v3 = v903;
      else
        v3 = v903 - 257;
      *(&v39 + m) = v3;
    }
  }
  v902 = *((_DWORD *)a1 + 33);
  v901 = *((_DWORD *)a1 + 34);
  v900 = *((_DWORD *)a1 + 35);
  v899 = *((_DWORD *)a1 + 36);
  v898 = *((_DWORD *)a1 + 37);
  v897 = *((_DWORD *)a1 + 38);
  v896 = *((_DWORD *)a1 + 39);
  v895 = *((_DWORD *)a1 + 40);
  v894 = *((_DWORD *)a1 + 41);
  v893 = *((_DWORD *)a1 + 42);
  v892 = *((_DWORD *)a1 + 43);
  v891 = *((_DWORD *)a1 + 44);
  v890 = *((_DWORD *)a1 + 45);
  v889 = *((_DWORD *)a1 + 46);
  v888 = *((_DWORD *)a1 + 47);
  v887 = *((_DWORD *)a1 + 48);
  v886 = *((_DWORD *)a1 + 49);
  v885 = *((_DWORD *)a1 + 50);
  v884 = *((_DWORD *)a1 + 51);
  v883 = *((_DWORD *)a1 + 52);
  v882 = *((_DWORD *)a1 + 53);
  v881 = *((_DWORD *)a1 + 54);
  v880 = *((_DWORD *)a1 + 55);
  v879 = *((_DWORD *)a1 + 56);
  v878 = *((_DWORD *)a1 + 57);
  v877 = *((_DWORD *)a1 + 58);
  v876 = *((_DWORD *)a1 + 59);
  v875 = *((_DWORD *)a1 + 60);
  v874 = *((_DWORD *)a1 + 61);
  v873 = *((_DWORD *)a1 + 62);
  v872 = *((_DWORD *)a1 + 63);
  v871 = *((_DWORD *)a1 + 64);
  v4 = sub_140E9C((int)v914);
  v902 ^= v4;
  v5 = sub_140E9C((int)(v914 + 4));
  v901 ^= v5;
  v6 = sub_140E9C((int)(v914 + 8));
  v900 ^= v6;
  v7 = sub_140E9C((int)(v914 + 12));
  v899 ^= v7;
  v8 = sub_140E9C((int)(v914 + 16));
  v898 ^= v8;
  v9 = sub_140E9C((int)(v914 + 20));
  v897 ^= v9;
  v10 = sub_140E9C((int)(v914 + 24));
  v896 ^= v10;
  v11 = sub_140E9C((int)(v914 + 28));
  v895 ^= v11;
  v12 = sub_140E9C((int)(v914 + 32));
  v894 ^= v12;
  v13 = sub_140E9C((int)(v914 + 36));
  v893 ^= v13;
  v14 = sub_140E9C((int)(v914 + 40));
  v892 ^= v14;
  v15 = sub_140E9C((int)(v914 + 44));
  v891 ^= v15;
  v16 = sub_140E9C((int)(v914 + 48));
  v890 ^= v16;
  v17 = sub_140E9C((int)(v914 + 52));
  v889 ^= v17;
  v18 = sub_140E9C((int)(v914 + 56));
  v888 ^= v18;
  v19 = sub_140E9C((int)(v914 + 60));
  v887 ^= v19;
  v20 = sub_140E9C((int)(v914 + 64));
  v886 ^= v20;
  v21 = sub_140E9C((int)(v914 + 68));
  v885 ^= v21;
  v22 = sub_140E9C((int)(v914 + 72));
  v884 ^= v22;
  v23 = sub_140E9C((int)(v914 + 76));
  v883 ^= v23;
  v24 = sub_140E9C((int)(v914 + 80));
  v882 ^= v24;
  v25 = sub_140E9C((int)(v914 + 84));
  v881 ^= v25;
  v26 = sub_140E9C((int)(v914 + 88));
  v880 ^= v26;
  v27 = sub_140E9C((int)(v914 + 92));
  v879 ^= v27;
  v28 = sub_140E9C((int)(v914 + 96));
  v878 ^= v28;
  v29 = sub_140E9C((int)(v914 + 100));
  v877 ^= v29;
  v30 = sub_140E9C((int)(v914 + 104));
  v876 ^= v30;
  v31 = sub_140E9C((int)(v914 + 108));
  v875 ^= v31;
  v32 = sub_140E9C((int)(v914 + 112));
  v874 ^= v32;
  v33 = sub_140E9C((int)(v914 + 116));
  v873 ^= v33;
  v34 = sub_140E9C((int)(v914 + 120));
  v872 ^= v34;
  v35 = sub_140E9C((int)(v914 + 124));
  v871 ^= v35;
  v870 = __ROR4__(v902, 29);
  v869 = __ROR4__(v901, 29);
  v868 = __ROR4__(v900, 29);
  v867 = __ROR4__(v899, 29);
  v866 = __ROR4__(v898, 29);
  v865 = __ROR4__(v897, 29);
  v864 = __ROR4__(v896, 29);
  v863 = __ROR4__(v895, 29);
  v862 = (v886 ^ (v894 ^ v886) & v902) + (unsigned __int16)(185 * v103) + 12124160 * v104 + v878;
  v902 = v869 + __ROR4__(v862, 9);
  v878 = v886;
  v886 = v894;
  v861 = (v885 ^ (v893 ^ v885) & v901) + (unsigned __int16)(185 * v105) + 12124160 * v106 + v877;
  v901 = v870 + __ROR4__(v861, 9);
  v877 = v885;
  v885 = v893;
  v860 = (v884 ^ (v892 ^ v884) & v900) + (unsigned __int16)(185 * v107) + 12124160 * v108 + v876;
  v900 = v867 + __ROR4__(v860, 9);
  v876 = v884;
  v884 = v892;
  v859 = (v883 ^ (v891 ^ v883) & v899) + (unsigned __int16)(185 * v109) + 12124160 * v110 + v875;
  v899 = v868 + __ROR4__(v859, 9);
  v875 = v883;
  v883 = v891;
  v858 = ((v890 ^ v882) & v898 ^ v882) + (unsigned __int16)(185 * v111) + 12124160 * v112 + v874;
  v898 = v865 + __ROR4__(v858, 9);
  v874 = v882;
  v882 = v890;
  v857 = ((v889 ^ v881) & v897 ^ v881) + (unsigned __int16)(185 * v113) + 12124160 * v114 + v873;
  v897 = v866 + __ROR4__(v857, 9);
  v873 = v881;
  v881 = v889;
  v856 = ((v888 ^ v880) & v896 ^ v880) + (unsigned __int16)(185 * v115) + 12124160 * v116 + v872;
  v896 = v863 + __ROR4__(v856, 9);
  v872 = v880;
  v880 = v888;
  v855 = ((v887 ^ v879) & v895 ^ v879) + (unsigned __int16)(185 * v117) + 12124160 * v118 + v871;
  v895 = v864 + __ROR4__(v855, 9);
  v871 = v879;
  v879 = v887;
  v854 = __ROR4__(v902, 9);
  v853 = __ROR4__(v901, 9);
  v852 = __ROR4__(v900, 9);
  v851 = __ROR4__(v899, 9);
  v850 = __ROR4__(v898, 9);
  v849 = __ROR4__(v897, 9);
  v848 = __ROR4__(v896, 9);
  v847 = __ROR4__(v895, 9);
  v846 = ((v870 ^ v886) & v902 ^ v886) + (unsigned __int16)(185 * v135) + 12124160 * v136 + v878;
  v902 = v848 + __ROR4__(v846, 15);
  v886 = v870;
  v845 = ((v869 ^ v885) & v901 ^ v885) + (unsigned __int16)(185 * v137) + 12124160 * v138 + v877;
  v901 = v847 + __ROR4__(v845, 15);
  v885 = v869;
  v844 = ((v868 ^ v884) & v900 ^ v884) + (unsigned __int16)(185 * v139) + 12124160 * v140 + v876;
  v900 = v850 + __ROR4__(v844, 15);
  v884 = v868;
  v843 = ((v867 ^ v883) & v899 ^ v883) + (unsigned __int16)(185 * v141) + 12124160 * v142 + v875;
  v899 = v849 + __ROR4__(v843, 15);
  v883 = v867;
  v842 = ((v866 ^ v882) & v898 ^ v882) + (unsigned __int16)(185 * v143) + 12124160 * v144 + v874;
  v898 = v852 + __ROR4__(v842, 15);
  v882 = v866;
  v841 = ((v865 ^ v881) & v897 ^ v881) + (unsigned __int16)(185 * v145) + 12124160 * v146 + v873;
  v897 = v851 + __ROR4__(v841, 15);
  v881 = v865;
  v840 = ((v864 ^ v880) & v896 ^ v880) + (unsigned __int16)(185 * v147) + 12124160 * v148 + v872;
  v896 = v854 + __ROR4__(v840, 15);
  v880 = v864;
  v839 = ((v863 ^ v879) & v895 ^ v879) + (unsigned __int16)(185 * v149) + 12124160 * v150 + v871;
  v895 = v853 + __ROR4__(v839, 15);
  v879 = v863;
  v838 = __ROR4__(v902, 15);
  v837 = __ROR4__(v901, 15);
  v836 = __ROR4__(v900, 15);
  v835 = __ROR4__(v899, 15);
  v834 = __ROR4__(v898, 15);
  v833 = __ROR4__(v897, 15);
  v832 = __ROR4__(v896, 15);
  v831 = __ROR4__(v895, 15);
  v830 = ((v854 ^ v886) & v902 ^ v886) + (unsigned __int16)(185 * v39) + 12124160 * v40 + v894;
  v902 = v836 + __ROR4__(v830, 5);
  v886 = v854;
  v829 = ((v853 ^ v885) & v901 ^ v885) + (unsigned __int16)(185 * v41) + 12124160 * v42 + v893;
  v901 = v835 + __ROR4__(v829, 5);
  v885 = v853;
  v828 = ((v852 ^ v884) & v900 ^ v884) + (unsigned __int16)(185 * v43) + 12124160 * v44 + v892;
  v900 = v838 + __ROR4__(v828, 5);
  v884 = v852;
  v827 = ((v851 ^ v883) & v899 ^ v883) + (unsigned __int16)(185 * v45) + 12124160 * v46 + v891;
  v899 = v837 + __ROR4__(v827, 5);
  v883 = v851;
  v826 = ((v850 ^ v882) & v898 ^ v882) + (unsigned __int16)(185 * v47) + 12124160 * v48 + v890;
  v898 = v832 + __ROR4__(v826, 5);
  v882 = v850;
  v825 = ((v849 ^ v881) & v897 ^ v881) + (unsigned __int16)(185 * v49) + 12124160 * v50 + v889;
  v897 = v831 + __ROR4__(v825, 5);
  v881 = v849;
  v824 = ((v848 ^ v880) & v896 ^ v880) + (unsigned __int16)(185 * v51) + 12124160 * v52 + v888;
  v896 = v834 + __ROR4__(v824, 5);
  v880 = v848;
  v823 = ((v847 ^ v879) & v895 ^ v879) + (unsigned __int16)(185 * v53) + 12124160 * v54 + v887;
  v895 = v833 + __ROR4__(v823, 5);
  v879 = v847;
  v822 = __ROR4__(v902, 5);
  v821 = __ROR4__(v901, 5);
  v820 = __ROR4__(v900, 5);
  v819 = __ROR4__(v899, 5);
  v818 = __ROR4__(v898, 5);
  v817 = __ROR4__(v897, 5);
  v816 = __ROR4__(v896, 5);
  v815 = __ROR4__(v895, 5);
  v814 = ((v838 ^ v886) & v902 ^ v886) + (unsigned __int16)(185 * v71) + 12124160 * v72 + v870;
  v902 = v819 + __ROR4__(v814, 29);
  v894 = v822;
  v813 = ((v837 ^ v885) & v901 ^ v885) + (unsigned __int16)(185 * v73) + 12124160 * v74 + v869;
  v901 = v820 + __ROR4__(v813, 29);
  v893 = v821;
  v812 = ((v836 ^ v884) & v900 ^ v884) + (unsigned __int16)(185 * v75) + 12124160 * v76 + v868;
  v900 = v821 + __ROR4__(v812, 29);
  v892 = v820;
  v811 = ((v835 ^ v883) & v899 ^ v883) + (unsigned __int16)(185 * v77) + 12124160 * v78 + v867;
  v899 = v822 + __ROR4__(v811, 29);
  v891 = v819;
  v810 = ((v834 ^ v882) & v898 ^ v882) + (unsigned __int16)(185 * v79) + 12124160 * v80 + v866;
  v898 = v815 + __ROR4__(v810, 29);
  v890 = v818;
  v809 = ((v833 ^ v881) & v897 ^ v881) + (unsigned __int16)(185 * v81) + 12124160 * v82 + v865;
  v897 = v816 + __ROR4__(v809, 29);
  v889 = v817;
  v808 = ((v832 ^ v880) & v896 ^ v880) + (unsigned __int16)(185 * v83) + 12124160 * v84 + v864;
  v896 = v817 + __ROR4__(v808, 29);
  v888 = v816;
  v807 = ((v831 ^ v879) & v895 ^ v879) + (unsigned __int16)(185 * v85) + 12124160 * v86 + v863;
  v895 = v818 + __ROR4__(v807, 29);
  v887 = v815;
  v806 = __ROR4__(v902, 29);
  v805 = __ROR4__(v901, 29);
  v804 = __ROR4__(v900, 29);
  v803 = __ROR4__(v899, 29);
  v802 = __ROR4__(v898, 29);
  v801 = __ROR4__(v897, 29);
  v800 = __ROR4__(v896, 29);
  v799 = __ROR4__(v895, 29);
  v798 = (v902 & v894 | v838 & (v902 | v894)) + (unsigned __int16)(185 * v151) + 12124160 * v152 + v854;
  v902 = v801 + __ROR4__(v798, 9);
  v894 = v806;
  v797 = (v901 & v893 | v837 & (v901 | v893)) + (unsigned __int16)(185 * v153) + 12124160 * v154 + v853;
  v901 = v802 + __ROR4__(v797, 9);
  v893 = v805;
  v796 = (v900 & v892 | v836 & (v900 | v892)) + (unsigned __int16)(185 * v155) + 12124160 * v156 + v852;
  v900 = v799 + __ROR4__(v796, 9);
  v892 = v804;
  v795 = (v899 & v891 | v835 & (v899 | v891)) + (unsigned __int16)(185 * v157) + 12124160 * v158 + v851;
  v899 = v800 + __ROR4__(v795, 9);
  v891 = v803;
  v794 = (v898 & v890 | v834 & (v898 | v890)) + (unsigned __int16)(185 * v159) + 12124160 * v160 + v850;
  v898 = v805 + __ROR4__(v794, 9);
  v890 = v802;
  v793 = (v897 & v889 | v833 & (v897 | v889)) + (unsigned __int16)(185 * v161) + 12124160 * v162 + v849;
  v897 = v806 + __ROR4__(v793, 9);
  v889 = v801;
  v792 = (v896 & v888 | v832 & (v896 | v888)) + (unsigned __int16)(185 * v163) + 12124160 * v164 + v848;
  v896 = v803 + __ROR4__(v792, 9);
  v888 = v800;
  v791 = (v895 & v887 | v831 & (v895 | v887)) + (unsigned __int16)(185 * v165) + 12124160 * v166 + v847;
  v895 = v804 + __ROR4__(v791, 9);
  v887 = v799;
  v790 = __ROR4__(v902, 9);
  v789 = __ROR4__(v901, 9);
  v788 = __ROR4__(v900, 9);
  v787 = __ROR4__(v899, 9);
  v786 = __ROR4__(v898, 9);
  v785 = __ROR4__(v897, 9);
  v784 = __ROR4__(v896, 9);
  v783 = __ROR4__(v895, 9);
  v782 = (v902 & v894 | v822 & (v902 | v894)) + (unsigned __int16)(185 * v119) + 12124160 * v120 + v838;
  v902 = v783 + __ROR4__(v782, 15);
  v894 = v790;
  v781 = (v901 & v893 | v821 & (v901 | v893)) + (unsigned __int16)(185 * v121) + 12124160 * v122 + v837;
  v901 = v784 + __ROR4__(v781, 15);
  v893 = v789;
  v780 = (v900 & v892 | v820 & (v900 | v892)) + (unsigned __int16)(185 * v123) + 12124160 * v124 + v836;
  v900 = v785 + __ROR4__(v780, 15);
  v892 = v788;
  v779 = (v899 & v891 | v819 & (v899 | v891)) + (unsigned __int16)(185 * v125) + 12124160 * v126 + v835;
  v899 = v786 + __ROR4__(v779, 15);
  v891 = v787;
  v778 = (v898 & v890 | v818 & (v898 | v890)) + (unsigned __int16)(185 * v127) + 12124160 * v128 + v834;
  v898 = v787 + __ROR4__(v778, 15);
  v890 = v786;
  v777 = (v897 & v889 | v817 & (v897 | v889)) + (unsigned __int16)(185 * v129) + 12124160 * v130 + v833;
  v897 = v788 + __ROR4__(v777, 15);
  v889 = v785;
  v776 = (v896 & v888 | v816 & (v896 | v888)) + (unsigned __int16)(185 * v131) + 12124160 * v132 + v832;
  v896 = v789 + __ROR4__(v776, 15);
  v888 = v784;
  v775 = (v895 & v887 | v815 & (v895 | v887)) + (unsigned __int16)(185 * v133) + 12124160 * v134 + v831;
  v895 = v790 + __ROR4__(v775, 15);
  v887 = v783;
  v774 = __ROR4__(v902, 15);
  v773 = __ROR4__(v901, 15);
  v772 = __ROR4__(v900, 15);
  v771 = __ROR4__(v899, 15);
  v770 = __ROR4__(v898, 15);
  v769 = __ROR4__(v897, 15);
  v768 = __ROR4__(v896, 15);
  v767 = __ROR4__(v895, 15);
  v766 = (v902 & v894 | v806 & (v902 | v894)) + (unsigned __int16)(185 * v87) + 12124160 * v88 + v822;
  v902 = v770 + __ROR4__(v766, 5);
  v894 = v774;
  v765 = (v901 & v893 | v805 & (v901 | v893)) + (unsigned __int16)(185 * v89) + 12124160 * v90 + v821;
  v901 = v769 + __ROR4__(v765, 5);
  v893 = v773;
  v764 = (v900 & v892 | v804 & (v900 | v892)) + (unsigned __int16)(185 * v91) + 12124160 * v92 + v820;
  v900 = v768 + __ROR4__(v764, 5);
  v892 = v772;
  v763 = (v899 & v891 | v803 & (v899 | v891)) + (unsigned __int16)(185 * v93) + 12124160 * v94 + v819;
  v899 = v767 + __ROR4__(v763, 5);
  v891 = v771;
  v762 = (v898 & v890 | v802 & (v898 | v890)) + (unsigned __int16)(185 * v95) + 12124160 * v96 + v818;
  v898 = v774 + __ROR4__(v762, 5);
  v890 = v770;
  v761 = (v897 & v889 | v801 & (v897 | v889)) + (unsigned __int16)(185 * v97) + 12124160 * v98 + v817;
  v897 = v773 + __ROR4__(v761, 5);
  v889 = v769;
  v760 = (v896 & v888 | v800 & (v896 | v888)) + (unsigned __int16)(185 * v99) + 12124160 * v100 + v816;
  v896 = v772 + __ROR4__(v760, 5);
  v888 = v768;
  v759 = (v895 & v887 | v799 & (v895 | v887)) + (unsigned __int16)(185 * v101) + 12124160 * v102 + v815;
  v895 = v771 + __ROR4__(v759, 5);
  v887 = v767;
  v758 = __ROR4__(v902, 5);
  v757 = __ROR4__(v901, 5);
  v756 = __ROR4__(v900, 5);
  v755 = __ROR4__(v899, 5);
  v754 = __ROR4__(v898, 5);
  v753 = __ROR4__(v897, 5);
  v752 = __ROR4__(v896, 5);
  v751 = __ROR4__(v895, 5);
  v750 = (v902 & v894 | v790 & (v902 | v894)) + (unsigned __int16)(185 * v55) + 12124160 * v56 + v806;
  v902 = v757 + __ROR4__(v750, 29);
  v886 = v774;
  v749 = (v901 & v893 | v789 & (v901 | v893)) + (unsigned __int16)(185 * v57) + 12124160 * v58 + v805;
  v901 = v758 + __ROR4__(v749, 29);
  v885 = v773;
  v748 = (v900 & v892 | v788 & (v900 | v892)) + (unsigned __int16)(185 * v59) + 12124160 * v60 + v804;
  v900 = v755 + __ROR4__(v748, 29);
  v884 = v772;
  v747 = (v899 & v891 | v787 & (v899 | v891)) + (unsigned __int16)(185 * v61) + 12124160 * v62 + v803;
  v899 = v756 + __ROR4__(v747, 29);
  v883 = v771;
  v746 = (v898 & v890 | v786 & (v898 | v890)) + (unsigned __int16)(185 * v63) + 12124160 * v64 + v802;
  v898 = v753 + __ROR4__(v746, 29);
  v882 = v770;
  v745 = (v897 & v889 | v785 & (v897 | v889)) + (unsigned __int16)(185 * v65) + 12124160 * v66 + v801;
  v897 = v754 + __ROR4__(v745, 29);
  v881 = v769;
  v744 = (v896 & v888 | v784 & (v896 | v888)) + (unsigned __int16)(185 * v67) + 12124160 * v68 + v800;
  v896 = v751 + __ROR4__(v744, 29);
  v880 = v768;
  v743 = (v895 & v887 | v783 & (v895 | v887)) + (unsigned __int16)(185 * v69) + 12124160 * v70 + v799;
  v895 = v752 + __ROR4__(v743, 29);
  v879 = v767;
  v742 = __ROR4__(v902, 4);
  v741 = __ROR4__(v901, 4);
  v740 = __ROR4__(v900, 4);
  v739 = __ROR4__(v899, 4);
  v738 = __ROR4__(v898, 4);
  v737 = __ROR4__(v897, 4);
  v736 = __ROR4__(v896, 4);
  v735 = __ROR4__(v895, 4);
  v734 = ((v758 ^ v886) & v902 ^ v886) + (unsigned __int16)(185 * v279) + 12124160 * v280 + v790;
  v902 = v736 + __ROR4__(v734, 13);
  v886 = v758;
  v733 = ((v757 ^ v885) & v901 ^ v885) + (unsigned __int16)(185 * v281) + 12124160 * v282 + v789;
  v901 = v735 + __ROR4__(v733, 13);
  v885 = v757;
  v732 = ((v756 ^ v884) & v900 ^ v884) + (unsigned __int16)(185 * v283) + 12124160 * v284 + v788;
  v900 = v738 + __ROR4__(v732, 13);
  v884 = v756;
  v731 = ((v755 ^ v883) & v899 ^ v883) + (unsigned __int16)(185 * v285) + 12124160 * v286 + v787;
  v899 = v737 + __ROR4__(v731, 13);
  v883 = v755;
  v730 = ((v754 ^ v882) & v898 ^ v882) + (unsigned __int16)(185 * v287) + 12124160 * v288 + v786;
  v898 = v740 + __ROR4__(v730, 13);
  v882 = v754;
  v729 = ((v753 ^ v881) & v897 ^ v881) + (unsigned __int16)(185 * v289) + 12124160 * v290 + v785;
  v897 = v739 + __ROR4__(v729, 13);
  v881 = v753;
  v728 = ((v752 ^ v880) & v896 ^ v880) + (unsigned __int16)(185 * v291) + 12124160 * v292 + v784;
  v896 = v742 + __ROR4__(v728, 13);
  v880 = v752;
  v727 = ((v751 ^ v879) & v895 ^ v879) + (unsigned __int16)(185 * v293) + 12124160 * v294 + v783;
  v895 = v741 + __ROR4__(v727, 13);
  v879 = v751;
  v726 = __ROR4__(v902, 13);
  v725 = __ROR4__(v901, 13);
  v724 = __ROR4__(v900, 13);
  v723 = __ROR4__(v899, 13);
  v722 = __ROR4__(v898, 13);
  v721 = __ROR4__(v897, 13);
  v720 = __ROR4__(v896, 13);
  v719 = __ROR4__(v895, 13);
  v718 = ((v742 ^ v886) & v902 ^ v886) + (unsigned __int16)(185 * v215) + 12124160 * v216 + v774;
  v902 = v724 + __ROR4__(v718, 10);
  v886 = v742;
  v717 = ((v741 ^ v885) & v901 ^ v885) + (unsigned __int16)(185 * v217) + 12124160 * v218 + v773;
  v901 = v723 + __ROR4__(v717, 10);
  v885 = v741;
  v716 = ((v740 ^ v884) & v900 ^ v884) + (unsigned __int16)(185 * v219) + 12124160 * v220 + v772;
  v900 = v726 + __ROR4__(v716, 10);
  v884 = v740;
  v715 = ((v739 ^ v883) & v899 ^ v883) + (unsigned __int16)(185 * v221) + 12124160 * v222 + v771;
  v899 = v725 + __ROR4__(v715, 10);
  v883 = v739;
  v714 = ((v738 ^ v882) & v898 ^ v882) + (unsigned __int16)(185 * v223) + 12124160 * v224 + v770;
  v898 = v720 + __ROR4__(v714, 10);
  v882 = v738;
  v713 = ((v737 ^ v881) & v897 ^ v881) + (unsigned __int16)(185 * v225) + 12124160 * v226 + v769;
  v897 = v719 + __ROR4__(v713, 10);
  v881 = v737;
  v712 = ((v736 ^ v880) & v896 ^ v880) + (unsigned __int16)(185 * v227) + 12124160 * v228 + v768;
  v896 = v722 + __ROR4__(v712, 10);
  v880 = v736;
  v711 = ((v735 ^ v879) & v895 ^ v879) + (unsigned __int16)(185 * v229) + 12124160 * v230 + v767;
  v895 = v721 + __ROR4__(v711, 10);
  v879 = v735;
  v710 = __ROR4__(v902, 10);
  v709 = __ROR4__(v901, 10);
  v708 = __ROR4__(v900, 10);
  v707 = __ROR4__(v899, 10);
  v706 = __ROR4__(v898, 10);
  v705 = __ROR4__(v897, 10);
  v704 = __ROR4__(v896, 10);
  v703 = __ROR4__(v895, 10);
  v702 = ((v726 ^ v886) & v902 ^ v886) + (unsigned __int16)(185 * v231) + 12124160 * v232 + v758;
  v902 = v707 + __ROR4__(v702, 25);
  v886 = v726;
  v701 = ((v725 ^ v885) & v901 ^ v885) + (unsigned __int16)(185 * v233) + 12124160 * v234 + v757;
  v901 = v708 + __ROR4__(v701, 25);
  v885 = v725;
  v700 = ((v724 ^ v884) & v900 ^ v884) + (unsigned __int16)(185 * v235) + 12124160 * v236 + v756;
  v900 = v709 + __ROR4__(v700, 25);
  v884 = v724;
  v699 = ((v723 ^ v883) & v899 ^ v883) + (unsigned __int16)(185 * v237) + 12124160 * v238 + v755;
  v899 = v710 + __ROR4__(v699, 25);
  v883 = v723;
  v698 = ((v722 ^ v882) & v898 ^ v882) + (unsigned __int16)(185 * v239) + 12124160 * v240 + v754;
  v898 = v703 + __ROR4__(v698, 25);
  v882 = v722;
  v697 = ((v721 ^ v881) & v897 ^ v881) + (unsigned __int16)(185 * v241) + 12124160 * v242 + v753;
  v897 = v704 + __ROR4__(v697, 25);
  v881 = v721;
  v696 = ((v720 ^ v880) & v896 ^ v880) + (unsigned __int16)(185 * v243) + 12124160 * v244 + v752;
  v896 = v705 + __ROR4__(v696, 25);
  v880 = v720;
  v695 = ((v719 ^ v879) & v895 ^ v879) + (unsigned __int16)(185 * v245) + 12124160 * v246 + v751;
  v895 = v706 + __ROR4__(v695, 25);
  v879 = v719;
  v694 = __ROR4__(v902, 25);
  v693 = __ROR4__(v901, 25);
  v692 = __ROR4__(v900, 25);
  v691 = __ROR4__(v899, 25);
  v690 = __ROR4__(v898, 25);
  v689 = __ROR4__(v897, 25);
  v688 = __ROR4__(v896, 25);
  v687 = __ROR4__(v895, 25);
  v686 = ((v710 ^ v886) & v902 ^ v886) + (unsigned __int16)(185 * v167) + 12124160 * v168 + v742;
  v902 = v689 + __ROR4__(v686, 4);
  v894 = v694;
  v685 = ((v709 ^ v885) & v901 ^ v885) + (unsigned __int16)(185 * v169) + 12124160 * v170 + v741;
  v901 = v690 + __ROR4__(v685, 4);
  v893 = v693;
  v684 = ((v708 ^ v884) & v900 ^ v884) + (unsigned __int16)(185 * v171) + 12124160 * v172 + v740;
  v900 = v687 + __ROR4__(v684, 4);
  v892 = v692;
  v683 = ((v707 ^ v883) & v899 ^ v883) + (unsigned __int16)(185 * v173) + 12124160 * v174 + v739;
  v899 = v688 + __ROR4__(v683, 4);
  v891 = v691;
  v682 = ((v706 ^ v882) & v898 ^ v882) + (unsigned __int16)(185 * v175) + 12124160 * v176 + v738;
  v898 = v693 + __ROR4__(v682, 4);
  v890 = v690;
  v681 = ((v705 ^ v881) & v897 ^ v881) + (unsigned __int16)(185 * v177) + 12124160 * v178 + v737;
  v897 = v694 + __ROR4__(v681, 4);
  v889 = v689;
  v680 = ((v704 ^ v880) & v896 ^ v880) + (unsigned __int16)(185 * v179) + 12124160 * v180 + v736;
  v896 = v691 + __ROR4__(v680, 4);
  v888 = v688;
  v679 = ((v703 ^ v879) & v895 ^ v879) + (unsigned __int16)(185 * v181) + 12124160 * v182 + v735;
  v895 = v692 + __ROR4__(v679, 4);
  v887 = v687;
  v678 = __ROR4__(v902, 4);
  v677 = __ROR4__(v901, 4);
  v676 = __ROR4__(v900, 4);
  v675 = __ROR4__(v899, 4);
  v674 = __ROR4__(v898, 4);
  v673 = __ROR4__(v897, 4);
  v672 = __ROR4__(v896, 4);
  v671 = __ROR4__(v895, 4);
  v670 = (v902 & v894 | v710 & (v902 | v894)) + (unsigned __int16)(185 * v183) + 12124160 * v184 + v726;
  v902 = v671 + __ROR4__(v670, 13);
  v894 = v678;
  v669 = (v901 & v893 | v709 & (v901 | v893)) + (unsigned __int16)(185 * v185) + 12124160 * v186 + v725;
  v901 = v672 + __ROR4__(v669, 13);
  v893 = v677;
  v668 = (v900 & v892 | v708 & (v900 | v892)) + (unsigned __int16)(185 * v187) + 12124160 * v188 + v724;
  v900 = v673 + __ROR4__(v668, 13);
  v892 = v676;
  v667 = (v899 & v891 | v707 & (v899 | v891)) + (unsigned __int16)(185 * v189) + 12124160 * v190 + v723;
  v899 = v674 + __ROR4__(v667, 13);
  v891 = v675;
  v666 = (v898 & v890 | v706 & (v898 | v890)) + (unsigned __int16)(185 * v191) + 12124160 * v192 + v722;
  v898 = v675 + __ROR4__(v666, 13);
  v890 = v674;
  v665 = (v897 & v889 | v705 & (v897 | v889)) + (unsigned __int16)(185 * v193) + 12124160 * v194 + v721;
  v897 = v676 + __ROR4__(v665, 13);
  v889 = v673;
  v664 = (v896 & v888 | v704 & (v896 | v888)) + (unsigned __int16)(185 * v195) + 12124160 * v196 + v720;
  v896 = v677 + __ROR4__(v664, 13);
  v888 = v672;
  v663 = (v895 & v887 | v703 & (v895 | v887)) + (unsigned __int16)(185 * v197) + 12124160 * v198 + v719;
  v895 = v678 + __ROR4__(v663, 13);
  v887 = v671;
  v662 = __ROR4__(v902, 13);
  v661 = __ROR4__(v901, 13);
  v660 = __ROR4__(v900, 13);
  v659 = __ROR4__(v899, 13);
  v658 = __ROR4__(v898, 13);
  v657 = __ROR4__(v897, 13);
  v656 = __ROR4__(v896, 13);
  v655 = __ROR4__(v895, 13);
  v654 = (v902 & v894 | v694 & (v902 | v894)) + (unsigned __int16)(185 * v247) + 12124160 * v248 + v710;
  v902 = v658 + __ROR4__(v654, 10);
  v894 = v662;
  v653 = (v901 & v893 | v693 & (v901 | v893)) + (unsigned __int16)(185 * v249) + 12124160 * v250 + v709;
  v901 = v657 + __ROR4__(v653, 10);
  v893 = v661;
  v652 = (v900 & v892 | v692 & (v900 | v892)) + (unsigned __int16)(185 * v251) + 12124160 * v252 + v708;
  v900 = v656 + __ROR4__(v652, 10);
  v892 = v660;
  v651 = (v899 & v891 | v691 & (v899 | v891)) + (unsigned __int16)(185 * v253) + 12124160 * v254 + v707;
  v899 = v655 + __ROR4__(v651, 10);
  v891 = v659;
  v650 = (v898 & v890 | v690 & (v898 | v890)) + (unsigned __int16)(185 * v255) + 12124160 * v256 + v706;
  v898 = v662 + __ROR4__(v650, 10);
  v890 = v658;
  v649 = (v897 & v889 | v689 & (v897 | v889)) + (unsigned __int16)(185 * v257) + 12124160 * v258 + v705;
  v897 = v661 + __ROR4__(v649, 10);
  v889 = v657;
  v648 = (v896 & v888 | v688 & (v896 | v888)) + (unsigned __int16)(185 * v259) + 12124160 * v260 + v704;
  v896 = v660 + __ROR4__(v648, 10);
  v888 = v656;
  v647 = (v895 & v887 | v687 & (v895 | v887)) + (unsigned __int16)(185 * v261) + 12124160 * v262 + v703;
  v895 = v659 + __ROR4__(v647, 10);
  v887 = v655;
  v646 = __ROR4__(v902, 10);
  v645 = __ROR4__(v901, 10);
  v644 = __ROR4__(v900, 10);
  v643 = __ROR4__(v899, 10);
  v642 = __ROR4__(v898, 10);
  v641 = __ROR4__(v897, 10);
  v640 = __ROR4__(v896, 10);
  v639 = __ROR4__(v895, 10);
  v638 = (v902 & v894 | v678 & (v902 | v894)) + (unsigned __int16)(185 * v199) + 12124160 * v200 + v694;
  v902 = v645 + __ROR4__(v638, 25);
  v894 = v646;
  v637 = (v901 & v893 | v677 & (v901 | v893)) + (unsigned __int16)(185 * v201) + 12124160 * v202 + v693;
  v901 = v646 + __ROR4__(v637, 25);
  v893 = v645;
  v636 = (v900 & v892 | v676 & (v900 | v892)) + (unsigned __int16)(185 * v203) + 12124160 * v204 + v692;
  v900 = v643 + __ROR4__(v636, 25);
  v892 = v644;
  v635 = (v899 & v891 | v675 & (v899 | v891)) + (unsigned __int16)(185 * v205) + 12124160 * v206 + v691;
  v899 = v644 + __ROR4__(v635, 25);
  v891 = v643;
  v634 = (v898 & v890 | v674 & (v898 | v890)) + (unsigned __int16)(185 * v207) + 12124160 * v208 + v690;
  v898 = v641 + __ROR4__(v634, 25);
  v890 = v642;
  v633 = (v897 & v889 | v673 & (v897 | v889)) + (unsigned __int16)(185 * v209) + 12124160 * v210 + v689;
  v897 = v642 + __ROR4__(v633, 25);
  v889 = v641;
  v632 = (v896 & v888 | v672 & (v896 | v888)) + (unsigned __int16)(185 * v211) + 12124160 * v212 + v688;
  v896 = v639 + __ROR4__(v632, 25);
  v888 = v640;
  v631 = (v895 & v887 | v671 & (v895 | v887)) + (unsigned __int16)(185 * v213) + 12124160 * v214 + v687;
  v895 = v640 + __ROR4__(v631, 25);
  v887 = v639;
  v630 = __ROR4__(v902, 25);
  v629 = __ROR4__(v901, 25);
  v628 = __ROR4__(v900, 25);
  v627 = __ROR4__(v899, 25);
  v626 = __ROR4__(v898, 25);
  v625 = __ROR4__(v897, 25);
  v624 = __ROR4__(v896, 25);
  v623 = __ROR4__(v895, 25);
  v622 = (v902 & v894 | v662 & (v902 | v894)) + (unsigned __int16)(185 * v263) + 12124160 * v264 + v678;
  v902 = v624 + __ROR4__(v622, 4);
  v886 = v646;
  v621 = (v901 & v893 | v661 & (v901 | v893)) + (unsigned __int16)(185 * v265) + 12124160 * v266 + v677;
  v901 = v623 + __ROR4__(v621, 4);
  v885 = v645;
  v620 = (v900 & v892 | v660 & (v900 | v892)) + (unsigned __int16)(185 * v267) + 12124160 * v268 + v676;
  v900 = v626 + __ROR4__(v620, 4);
  v884 = v644;
  v619 = (v899 & v891 | v659 & (v899 | v891)) + (unsigned __int16)(185 * v269) + 12124160 * v270 + v675;
  v899 = v625 + __ROR4__(v619, 4);
  v883 = v643;
  v618 = (v898 & v890 | v658 & (v898 | v890)) + (unsigned __int16)(185 * v271) + 12124160 * v272 + v674;
  v898 = v628 + __ROR4__(v618, 4);
  v882 = v642;
  v617 = (v897 & v889 | v657 & (v897 | v889)) + (unsigned __int16)(185 * v273) + 12124160 * v274 + v673;
  v897 = v627 + __ROR4__(v617, 4);
  v881 = v641;
  v616 = (v896 & v888 | v656 & (v896 | v888)) + (unsigned __int16)(185 * v275) + 12124160 * v276 + v672;
  v896 = v630 + __ROR4__(v616, 4);
  v880 = v640;
  v615 = (v895 & v887 | v655 & (v895 | v887)) + (unsigned __int16)(185 * v277) + 12124160 * v278 + v671;
  v895 = v629 + __ROR4__(v615, 4);
  v879 = v639;
  v614 = __ROR4__(v902, 3);
  v613 = __ROR4__(v901, 3);
  v612 = __ROR4__(v900, 3);
  v611 = __ROR4__(v899, 3);
  v610 = __ROR4__(v898, 3);
  v609 = __ROR4__(v897, 3);
  v608 = __ROR4__(v896, 3);
  v607 = __ROR4__(v895, 3);
  v606 = ((v630 ^ v886) & v902 ^ v886) + (unsigned __int16)(233 * v55) + 15269888 * v183 + v662;
  v902 = v612 + __ROR4__(v606, 23);
  v886 = v630;
  v605 = ((v629 ^ v885) & v901 ^ v885) + (unsigned __int16)(233 * v57) + 15269888 * v185 + v661;
  v901 = v611 + __ROR4__(v605, 23);
  v885 = v629;
  v604 = ((v628 ^ v884) & v900 ^ v884) + (unsigned __int16)(233 * v59) + 15269888 * v187 + v660;
  v900 = v614 + __ROR4__(v604, 23);
  v884 = v628;
  v603 = ((v627 ^ v883) & v899 ^ v883) + (unsigned __int16)(233 * v61) + 15269888 * v189 + v659;
  v899 = v613 + __ROR4__(v603, 23);
  v883 = v627;
  v602 = ((v626 ^ v882) & v898 ^ v882) + (unsigned __int16)(233 * v63) + 15269888 * v191 + v658;
  v898 = v608 + __ROR4__(v602, 23);
  v882 = v626;
  v601 = ((v625 ^ v881) & v897 ^ v881) + (unsigned __int16)(233 * v65) + 15269888 * v193 + v657;
  v897 = v607 + __ROR4__(v601, 23);
  v881 = v625;
  v600 = ((v624 ^ v880) & v896 ^ v880) + (unsigned __int16)(233 * v67) + 15269888 * v195 + v656;
  v896 = v610 + __ROR4__(v600, 23);
  v880 = v624;
  v599 = ((v623 ^ v879) & v895 ^ v879) + (unsigned __int16)(233 * v69) + 15269888 * v197 + v655;
  v895 = v609 + __ROR4__(v599, 23);
  v879 = v623;
  v598 = __ROR4__(v902, 23);
  v597 = __ROR4__(v901, 23);
  v596 = __ROR4__(v900, 23);
  v595 = __ROR4__(v899, 23);
  v594 = __ROR4__(v898, 23);
  v593 = __ROR4__(v897, 23);
  v592 = __ROR4__(v896, 23);
  v591 = __ROR4__(v895, 23);
  v590 = ((v614 ^ v886) & v902 ^ v886) + (unsigned __int16)(233 * v71) + 15269888 * v199 + v646;
  v902 = v595 + __ROR4__(v590, 17);
  v886 = v614;
  v589 = ((v613 ^ v885) & v901 ^ v885) + (unsigned __int16)(233 * v73) + 15269888 * v201 + v645;
  v901 = v596 + __ROR4__(v589, 17);
  v885 = v613;
  v588 = ((v612 ^ v884) & v900 ^ v884) + (unsigned __int16)(233 * v75) + 15269888 * v203 + v644;
  v900 = v597 + __ROR4__(v588, 17);
  v884 = v612;
  v587 = ((v611 ^ v883) & v899 ^ v883) + (unsigned __int16)(233 * v77) + 15269888 * v205 + v643;
  v899 = v598 + __ROR4__(v587, 17);
  v883 = v611;
  v586 = ((v610 ^ v882) & v898 ^ v882) + (unsigned __int16)(233 * v79) + 15269888 * v207 + v642;
  v898 = v591 + __ROR4__(v586, 17);
  v882 = v610;
  v585 = ((v609 ^ v881) & v897 ^ v881) + (unsigned __int16)(233 * v81) + 15269888 * v209 + v641;
  v897 = v592 + __ROR4__(v585, 17);
  v881 = v609;
  v584 = ((v608 ^ v880) & v896 ^ v880) + (unsigned __int16)(233 * v83) + 15269888 * v211 + v640;
  v896 = v593 + __ROR4__(v584, 17);
  v880 = v608;
  v583 = ((v607 ^ v879) & v895 ^ v879) + (unsigned __int16)(233 * v85) + 15269888 * v213 + v639;
  v895 = v594 + __ROR4__(v583, 17);
  v879 = v607;
  v582 = __ROR4__(v902, 17);
  v581 = __ROR4__(v901, 17);
  v580 = __ROR4__(v900, 17);
  v579 = __ROR4__(v899, 17);
  v578 = __ROR4__(v898, 17);
  v577 = __ROR4__(v897, 17);
  v576 = __ROR4__(v896, 17);
  v575 = __ROR4__(v895, 17);
  v574 = ((v598 ^ v886) & v902 ^ v886) + (unsigned __int16)(233 * v151) + 15269888 * v279 + v630;
  v902 = v577 + __ROR4__(v574, 27);
  v886 = v598;
  v573 = ((v597 ^ v885) & v901 ^ v885) + (unsigned __int16)(233 * v153) + 15269888 * v281 + v629;
  v901 = v578 + __ROR4__(v573, 27);
  v885 = v597;
  v572 = ((v596 ^ v884) & v900 ^ v884) + (unsigned __int16)(233 * v155) + 15269888 * v283 + v628;
  v900 = v575 + __ROR4__(v572, 27);
  v884 = v596;
  v571 = ((v595 ^ v883) & v899 ^ v883) + (unsigned __int16)(233 * v157) + 15269888 * v285 + v627;
  v899 = v576 + __ROR4__(v571, 27);
  v883 = v595;
  v570 = ((v594 ^ v882) & v898 ^ v882) + (unsigned __int16)(233 * v159) + 15269888 * v287 + v626;
  v898 = v581 + __ROR4__(v570, 27);
  v882 = v594;
  v569 = ((v593 ^ v881) & v897 ^ v881) + (unsigned __int16)(233 * v161) + 15269888 * v289 + v625;
  v897 = v582 + __ROR4__(v569, 27);
  v881 = v593;
  v568 = ((v592 ^ v880) & v896 ^ v880) + (unsigned __int16)(233 * v163) + 15269888 * v291 + v624;
  v896 = v579 + __ROR4__(v568, 27);
  v880 = v592;
  v567 = ((v591 ^ v879) & v895 ^ v879) + (unsigned __int16)(233 * v165) + 15269888 * v293 + v623;
  v895 = v580 + __ROR4__(v567, 27);
  v879 = v591;
  v566 = __ROR4__(v902, 27);
  v565 = __ROR4__(v901, 27);
  v564 = __ROR4__(v900, 27);
  v563 = __ROR4__(v899, 27);
  v562 = __ROR4__(v898, 27);
  v561 = __ROR4__(v897, 27);
  v560 = __ROR4__(v896, 27);
  v559 = __ROR4__(v895, 27);
  v558 = ((v582 ^ v886) & v902 ^ v886) + (unsigned __int16)(233 * v103) + 15269888 * v231 + v614;
  v902 = v559 + __ROR4__(v558, 3);
  v894 = v566;
  v557 = ((v581 ^ v885) & v901 ^ v885) + (unsigned __int16)(233 * v105) + 15269888 * v233 + v613;
  v901 = v560 + __ROR4__(v557, 3);
  v893 = v565;
  v556 = ((v580 ^ v884) & v900 ^ v884) + (unsigned __int16)(233 * v107) + 15269888 * v235 + v612;
  v900 = v561 + __ROR4__(v556, 3);
  v892 = v564;
  v555 = ((v579 ^ v883) & v899 ^ v883) + (unsigned __int16)(233 * v109) + 15269888 * v237 + v611;
  v899 = v562 + __ROR4__(v555, 3);
  v891 = v563;
  v554 = ((v578 ^ v882) & v898 ^ v882) + (unsigned __int16)(233 * v111) + 15269888 * v239 + v610;
  v898 = v563 + __ROR4__(v554, 3);
  v890 = v562;
  v553 = ((v577 ^ v881) & v897 ^ v881) + (unsigned __int16)(233 * v113) + 15269888 * v241 + v609;
  v897 = v564 + __ROR4__(v553, 3);
  v889 = v561;
  v552 = ((v576 ^ v880) & v896 ^ v880) + (unsigned __int16)(233 * v115) + 15269888 * v243 + v608;
  v896 = v565 + __ROR4__(v552, 3);
  v888 = v560;
  v551 = ((v575 ^ v879) & v895 ^ v879) + (unsigned __int16)(233 * v117) + 15269888 * v245 + v607;
  v895 = v566 + __ROR4__(v551, 3);
  v887 = v559;
  v550 = __ROR4__(v902, 3);
  v549 = __ROR4__(v901, 3);
  v548 = __ROR4__(v900, 3);
  v547 = __ROR4__(v899, 3);
  v546 = __ROR4__(v898, 3);
  v545 = __ROR4__(v897, 3);
  v544 = __ROR4__(v896, 3);
  v543 = __ROR4__(v895, 3);
  v542 = (v902 & v894 | v582 & (v902 | v894)) + (unsigned __int16)(233 * v135) + 15269888 * v263 + v598;
  v902 = v546 + __ROR4__(v542, 23);
  v894 = v550;
  v541 = (v901 & v893 | v581 & (v901 | v893)) + (unsigned __int16)(233 * v137) + 15269888 * v265 + v597;
  v901 = v545 + __ROR4__(v541, 23);
  v893 = v549;
  v540 = (v900 & v892 | v580 & (v900 | v892)) + (unsigned __int16)(233 * v139) + 15269888 * v267 + v596;
  v900 = v544 + __ROR4__(v540, 23);
  v892 = v548;
  v539 = (v899 & v891 | v579 & (v899 | v891)) + (unsigned __int16)(233 * v141) + 15269888 * v269 + v595;
  v899 = v543 + __ROR4__(v539, 23);
  v891 = v547;
  v538 = (v898 & v890 | v578 & (v898 | v890)) + (unsigned __int16)(233 * v143) + 15269888 * v271 + v594;
  v898 = v550 + __ROR4__(v538, 23);
  v890 = v546;
  v537 = (v897 & v889 | v577 & (v897 | v889)) + (unsigned __int16)(233 * v145) + 15269888 * v273 + v593;
  v897 = v549 + __ROR4__(v537, 23);
  v889 = v545;
  v536 = (v896 & v888 | v576 & (v896 | v888)) + (unsigned __int16)(233 * v147) + 15269888 * v275 + v592;
  v896 = v548 + __ROR4__(v536, 23);
  v888 = v544;
  v535 = (v895 & v887 | v575 & (v895 | v887)) + (unsigned __int16)(233 * v149) + 15269888 * v277 + v591;
  v895 = v547 + __ROR4__(v535, 23);
  v887 = v543;
  v534 = __ROR4__(v902, 23);
  v533 = __ROR4__(v901, 23);
  v532 = __ROR4__(v900, 23);
  v531 = __ROR4__(v899, 23);
  v530 = __ROR4__(v898, 23);
  v529 = __ROR4__(v897, 23);
  v528 = __ROR4__(v896, 23);
  v527 = __ROR4__(v895, 23);
  v526 = (v902 & v894 | v566 & (v902 | v894)) + (unsigned __int16)(233 * v119) + 15269888 * v247 + v582;
  v902 = v533 + __ROR4__(v526, 17);
  v894 = v534;
  v525 = (v901 & v893 | v565 & (v901 | v893)) + (unsigned __int16)(233 * v121) + 15269888 * v249 + v581;
  v901 = v534 + __ROR4__(v525, 17);
  v893 = v533;
  v524 = (v900 & v892 | v564 & (v900 | v892)) + (unsigned __int16)(233 * v123) + 15269888 * v251 + v580;
  v900 = v531 + __ROR4__(v524, 17);
  v892 = v532;
  v523 = (v899 & v891 | v563 & (v899 | v891)) + (unsigned __int16)(233 * v125) + 15269888 * v253 + v579;
  v899 = v532 + __ROR4__(v523, 17);
  v891 = v531;
  v522 = (v898 & v890 | v562 & (v898 | v890)) + (unsigned __int16)(233 * v127) + 15269888 * v255 + v578;
  v898 = v529 + __ROR4__(v522, 17);
  v890 = v530;
  v521 = (v897 & v889 | v561 & (v897 | v889)) + (unsigned __int16)(233 * v129) + 15269888 * v257 + v577;
  v897 = v530 + __ROR4__(v521, 17);
  v889 = v529;
  v520 = (v896 & v888 | v560 & (v896 | v888)) + (unsigned __int16)(233 * v131) + 15269888 * v259 + v576;
  v896 = v527 + __ROR4__(v520, 17);
  v888 = v528;
  v519 = (v895 & v887 | v559 & (v895 | v887)) + (unsigned __int16)(233 * v133) + 15269888 * v261 + v575;
  v895 = v528 + __ROR4__(v519, 17);
  v887 = v527;
  v518 = __ROR4__(v902, 17);
  v517 = __ROR4__(v901, 17);
  v516 = __ROR4__(v900, 17);
  v515 = __ROR4__(v899, 17);
  v514 = __ROR4__(v898, 17);
  v513 = __ROR4__(v897, 17);
  v512 = __ROR4__(v896, 17);
  v511 = __ROR4__(v895, 17);
  v510 = (v902 & v894 | v550 & (v902 | v894)) + (unsigned __int16)(233 * v39) + 15269888 * v167 + v566;
  v902 = v512 + __ROR4__(v510, 27);
  v894 = v518;
  v509 = (v901 & v893 | v549 & (v901 | v893)) + (unsigned __int16)(233 * v41) + 15269888 * v169 + v565;
  v901 = v511 + __ROR4__(v509, 27);
  v893 = v517;
  v508 = (v900 & v892 | v548 & (v900 | v892)) + (unsigned __int16)(233 * v43) + 15269888 * v171 + v564;
  v900 = v514 + __ROR4__(v508, 27);
  v892 = v516;
  v507 = (v899 & v891 | v547 & (v899 | v891)) + (unsigned __int16)(233 * v45) + 15269888 * v173 + v563;
  v899 = v513 + __ROR4__(v507, 27);
  v891 = v515;
  v506 = (v898 & v890 | v546 & (v898 | v890)) + (unsigned __int16)(233 * v47) + 15269888 * v175 + v562;
  v898 = v516 + __ROR4__(v506, 27);
  v890 = v514;
  v505 = (v897 & v889 | v545 & (v897 | v889)) + (unsigned __int16)(233 * v49) + 15269888 * v177 + v561;
  v897 = v515 + __ROR4__(v505, 27);
  v889 = v513;
  v504 = (v896 & v888 | v544 & (v896 | v888)) + (unsigned __int16)(233 * v51) + 15269888 * v179 + v560;
  v896 = v518 + __ROR4__(v504, 27);
  v888 = v512;
  v503 = (v895 & v887 | v543 & (v895 | v887)) + (unsigned __int16)(233 * v53) + 15269888 * v181 + v559;
  v895 = v517 + __ROR4__(v503, 27);
  v887 = v511;
  v502 = __ROR4__(v902, 27);
  v501 = __ROR4__(v901, 27);
  v500 = __ROR4__(v900, 27);
  v499 = __ROR4__(v899, 27);
  v498 = __ROR4__(v898, 27);
  v497 = __ROR4__(v897, 27);
  v496 = __ROR4__(v896, 27);
  v495 = __ROR4__(v895, 27);
  v494 = (v902 & v894 | v534 & (v902 | v894)) + (unsigned __int16)(233 * v87) + 15269888 * v215 + v550;
  v902 = v500 + __ROR4__(v494, 3);
  v886 = v518;
  v493 = (v901 & v893 | v533 & (v901 | v893)) + (unsigned __int16)(233 * v89) + 15269888 * v217 + v549;
  v901 = v499 + __ROR4__(v493, 3);
  v885 = v517;
  v492 = (v900 & v892 | v532 & (v900 | v892)) + (unsigned __int16)(233 * v91) + 15269888 * v219 + v548;
  v900 = v502 + __ROR4__(v492, 3);
  v884 = v516;
  v491 = (v899 & v891 | v531 & (v899 | v891)) + (unsigned __int16)(233 * v93) + 15269888 * v221 + v547;
  v899 = v501 + __ROR4__(v491, 3);
  v883 = v515;
  v490 = (v898 & v890 | v530 & (v898 | v890)) + (unsigned __int16)(233 * v95) + 15269888 * v223 + v546;
  v898 = v496 + __ROR4__(v490, 3);
  v882 = v514;
  v489 = (v897 & v889 | v529 & (v897 | v889)) + (unsigned __int16)(233 * v97) + 15269888 * v225 + v545;
  v897 = v495 + __ROR4__(v489, 3);
  v881 = v513;
  v488 = (v896 & v888 | v528 & (v896 | v888)) + (unsigned __int16)(233 * v99) + 15269888 * v227 + v544;
  v896 = v498 + __ROR4__(v488, 3);
  v880 = v512;
  v487 = (v895 & v887 | v527 & (v895 | v887)) + (unsigned __int16)(233 * v101) + 15269888 * v229 + v543;
  v895 = v497 + __ROR4__(v487, 3);
  v879 = v511;
  v486 = __ROR4__(v902, 28);
  v485 = __ROR4__(v901, 28);
  v484 = __ROR4__(v900, 28);
  v483 = __ROR4__(v899, 28);
  v482 = __ROR4__(v898, 28);
  v481 = __ROR4__(v897, 28);
  v480 = __ROR4__(v896, 28);
  v479 = __ROR4__(v895, 28);
  v478 = ((v502 ^ v886) & v902 ^ v886) + (unsigned __int16)(233 * v136) + 15269888 * v264 + v534;
  v902 = v483 + __ROR4__(v478, 19);
  v886 = v502;
  v477 = ((v501 ^ v885) & v901 ^ v885) + (unsigned __int16)(233 * v138) + 15269888 * v266 + v533;
  v901 = v484 + __ROR4__(v477, 19);
  v885 = v501;
  v476 = ((v500 ^ v884) & v900 ^ v884) + (unsigned __int16)(233 * v140) + 15269888 * v268 + v532;
  v900 = v485 + __ROR4__(v476, 19);
  v884 = v500;
  v475 = ((v499 ^ v883) & v899 ^ v883) + (unsigned __int16)(233 * v142) + 15269888 * v270 + v531;
  v899 = v486 + __ROR4__(v475, 19);
  v883 = v499;
  v474 = ((v498 ^ v882) & v898 ^ v882) + (unsigned __int16)(233 * v144) + 15269888 * v272 + v530;
  v898 = v479 + __ROR4__(v474, 19);
  v882 = v498;
  v473 = ((v497 ^ v881) & v897 ^ v881) + (unsigned __int16)(233 * v146) + 15269888 * v274 + v529;
  v897 = v480 + __ROR4__(v473, 19);
  v881 = v497;
  v472 = ((v496 ^ v880) & v896 ^ v880) + (unsigned __int16)(233 * v148) + 15269888 * v276 + v528;
  v896 = v481 + __ROR4__(v472, 19);
  v880 = v496;
  v471 = ((v495 ^ v879) & v895 ^ v879) + (unsigned __int16)(233 * v150) + 15269888 * v278 + v527;
  v895 = v482 + __ROR4__(v471, 19);
  v879 = v495;
  v470 = __ROR4__(v902, 19);
  v469 = __ROR4__(v901, 19);
  v468 = __ROR4__(v900, 19);
  v467 = __ROR4__(v899, 19);
  v466 = __ROR4__(v898, 19);
  v465 = __ROR4__(v897, 19);
  v464 = __ROR4__(v896, 19);
  v463 = __ROR4__(v895, 19);
  v462 = ((v486 ^ v886) & v902 ^ v886) + (unsigned __int16)(233 * v40) + 15269888 * v168 + v518;
  v902 = v465 + __ROR4__(v462, 22);
  v886 = v486;
  v461 = ((v485 ^ v885) & v901 ^ v885) + (unsigned __int16)(233 * v42) + 15269888 * v170 + v517;
  v901 = v466 + __ROR4__(v461, 22);
  v885 = v485;
  v460 = ((v484 ^ v884) & v900 ^ v884) + (unsigned __int16)(233 * v44) + 15269888 * v172 + v516;
  v900 = v463 + __ROR4__(v460, 22);
  v884 = v484;
  v459 = ((v483 ^ v883) & v899 ^ v883) + (unsigned __int16)(233 * v46) + 15269888 * v174 + v515;
  v899 = v464 + __ROR4__(v459, 22);
  v883 = v483;
  v458 = ((v482 ^ v882) & v898 ^ v882) + (unsigned __int16)(233 * v48) + 15269888 * v176 + v514;
  v898 = v469 + __ROR4__(v458, 22);
  v882 = v482;
  v457 = ((v481 ^ v881) & v897 ^ v881) + (unsigned __int16)(233 * v50) + 15269888 * v178 + v513;
  v897 = v470 + __ROR4__(v457, 22);
  v881 = v481;
  v456 = ((v480 ^ v880) & v896 ^ v880) + (unsigned __int16)(233 * v52) + 15269888 * v180 + v512;
  v896 = v467 + __ROR4__(v456, 22);
  v880 = v480;
  v455 = ((v479 ^ v879) & v895 ^ v879) + (unsigned __int16)(233 * v54) + 15269888 * v182 + v511;
  v895 = v468 + __ROR4__(v455, 22);
  v879 = v479;
  v454 = __ROR4__(v902, 22);
  v453 = __ROR4__(v901, 22);
  v452 = __ROR4__(v900, 22);
  v451 = __ROR4__(v899, 22);
  v450 = __ROR4__(v898, 22);
  v449 = __ROR4__(v897, 22);
  v448 = __ROR4__(v896, 22);
  v447 = __ROR4__(v895, 22);
  v446 = ((v470 ^ v886) & v902 ^ v886) + (unsigned __int16)(233 * v56) + 15269888 * v184 + v502;
  v902 = v447 + __ROR4__(v446, 7);
  v886 = v470;
  v445 = ((v469 ^ v885) & v901 ^ v885) + (unsigned __int16)(233 * v58) + 15269888 * v186 + v501;
  v901 = v448 + __ROR4__(v445, 7);
  v885 = v469;
  v444 = ((v468 ^ v884) & v900 ^ v884) + (unsigned __int16)(233 * v60) + 15269888 * v188 + v500;
  v900 = v449 + __ROR4__(v444, 7);
  v884 = v468;
  v443 = ((v467 ^ v883) & v899 ^ v883) + (unsigned __int16)(233 * v62) + 15269888 * v190 + v499;
  v899 = v450 + __ROR4__(v443, 7);
  v883 = v467;
  v442 = ((v466 ^ v882) & v898 ^ v882) + (unsigned __int16)(233 * v64) + 15269888 * v192 + v498;
  v898 = v451 + __ROR4__(v442, 7);
  v882 = v466;
  v441 = ((v465 ^ v881) & v897 ^ v881) + (unsigned __int16)(233 * v66) + 15269888 * v194 + v497;
  v897 = v452 + __ROR4__(v441, 7);
  v881 = v465;
  v440 = ((v464 ^ v880) & v896 ^ v880) + (unsigned __int16)(233 * v68) + 15269888 * v196 + v496;
  v896 = v453 + __ROR4__(v440, 7);
  v880 = v464;
  v439 = ((v463 ^ v879) & v895 ^ v879) + (unsigned __int16)(233 * v70) + 15269888 * v198 + v495;
  v895 = v454 + __ROR4__(v439, 7);
  v879 = v463;
  v438 = __ROR4__(v902, 7);
  v437 = __ROR4__(v901, 7);
  v436 = __ROR4__(v900, 7);
  v435 = __ROR4__(v899, 7);
  v434 = __ROR4__(v898, 7);
  v433 = __ROR4__(v897, 7);
  v432 = __ROR4__(v896, 7);
  v431 = __ROR4__(v895, 7);
  v430 = ((v454 ^ v886) & v902 ^ v886) + (unsigned __int16)(233 * v152) + 15269888 * v280 + v486;
  v902 = v434 + __ROR4__(v430, 28);
  v894 = v438;
  v429 = ((v453 ^ v885) & v901 ^ v885) + (unsigned __int16)(233 * v154) + 15269888 * v282 + v485;
  v901 = v433 + __ROR4__(v429, 28);
  v893 = v437;
  v428 = ((v452 ^ v884) & v900 ^ v884) + (unsigned __int16)(233 * v156) + 15269888 * v284 + v484;
  v900 = v432 + __ROR4__(v428, 28);
  v892 = v436;
  v427 = ((v451 ^ v883) & v899 ^ v883) + (unsigned __int16)(233 * v158) + 15269888 * v286 + v483;
  v899 = v431 + __ROR4__(v427, 28);
  v891 = v435;
  v426 = ((v450 ^ v882) & v898 ^ v882) + (unsigned __int16)(233 * v160) + 15269888 * v288 + v482;
  v898 = v438 + __ROR4__(v426, 28);
  v890 = v434;
  v425 = ((v449 ^ v881) & v897 ^ v881) + (unsigned __int16)(233 * v162) + 15269888 * v290 + v481;
  v897 = v437 + __ROR4__(v425, 28);
  v889 = v433;
  v424 = ((v448 ^ v880) & v896 ^ v880) + (unsigned __int16)(233 * v164) + 15269888 * v292 + v480;
  v896 = v436 + __ROR4__(v424, 28);
  v888 = v432;
  v423 = ((v447 ^ v879) & v895 ^ v879) + (unsigned __int16)(233 * v166) + 15269888 * v294 + v479;
  v895 = v435 + __ROR4__(v423, 28);
  v887 = v431;
  v422 = __ROR4__(v902, 28);
  v421 = __ROR4__(v901, 28);
  v420 = __ROR4__(v900, 28);
  v419 = __ROR4__(v899, 28);
  v418 = __ROR4__(v898, 28);
  v417 = __ROR4__(v897, 28);
  v416 = __ROR4__(v896, 28);
  v415 = __ROR4__(v895, 28);
  v414 = (v902 & v894 | v454 & (v902 | v894)) + (unsigned __int16)(233 * v88) + 15269888 * v216 + v470;
  v902 = v421 + __ROR4__(v414, 19);
  v894 = v422;
  v413 = (v901 & v893 | v453 & (v901 | v893)) + (unsigned __int16)(233 * v90) + 15269888 * v218 + v469;
  v901 = v422 + __ROR4__(v413, 19);
  v893 = v421;
  v412 = (v900 & v892 | v452 & (v900 | v892)) + (unsigned __int16)(233 * v92) + 15269888 * v220 + v468;
  v900 = v419 + __ROR4__(v412, 19);
  v892 = v420;
  v411 = (v899 & v891 | v451 & (v899 | v891)) + (unsigned __int16)(233 * v94) + 15269888 * v222 + v467;
  v899 = v420 + __ROR4__(v411, 19);
  v891 = v419;
  v410 = (v898 & v890 | v450 & (v898 | v890)) + (unsigned __int16)(233 * v96) + 15269888 * v224 + v466;
  v898 = v417 + __ROR4__(v410, 19);
  v890 = v418;
  v409 = (v897 & v889 | v449 & (v897 | v889)) + (unsigned __int16)(233 * v98) + 15269888 * v226 + v465;
  v897 = v418 + __ROR4__(v409, 19);
  v889 = v417;
  v408 = (v896 & v888 | v448 & (v896 | v888)) + (unsigned __int16)(233 * v100) + 15269888 * v228 + v464;
  v896 = v415 + __ROR4__(v408, 19);
  v888 = v416;
  v407 = (v895 & v887 | v447 & (v895 | v887)) + (unsigned __int16)(233 * v102) + 15269888 * v230 + v463;
  v895 = v416 + __ROR4__(v407, 19);
  v887 = v415;
  v406 = __ROR4__(v902, 19);
  v405 = __ROR4__(v901, 19);
  v404 = __ROR4__(v900, 19);
  v403 = __ROR4__(v899, 19);
  v402 = __ROR4__(v898, 19);
  v401 = __ROR4__(v897, 19);
  v400 = __ROR4__(v896, 19);
  v399 = __ROR4__(v895, 19);
  v398 = (v902 & v894 | v438 & (v902 | v894)) + (unsigned __int16)(233 * v120) + 15269888 * v248 + v454;
  v902 = v400 + __ROR4__(v398, 22);
  v894 = v406;
  v397 = (v901 & v893 | v437 & (v901 | v893)) + (unsigned __int16)(233 * v122) + 15269888 * v250 + v453;
  v901 = v399 + __ROR4__(v397, 22);
  v893 = v405;
  v396 = (v900 & v892 | v436 & (v900 | v892)) + (unsigned __int16)(233 * v124) + 15269888 * v252 + v452;
  v900 = v402 + __ROR4__(v396, 22);
  v892 = v404;
  v395 = (v899 & v891 | v435 & (v899 | v891)) + (unsigned __int16)(233 * v126) + 15269888 * v254 + v451;
  v899 = v401 + __ROR4__(v395, 22);
  v891 = v403;
  v394 = (v898 & v890 | v434 & (v898 | v890)) + (unsigned __int16)(233 * v128) + 15269888 * v256 + v450;
  v898 = v404 + __ROR4__(v394, 22);
  v890 = v402;
  v393 = (v897 & v889 | v433 & (v897 | v889)) + (unsigned __int16)(233 * v130) + 15269888 * v258 + v449;
  v897 = v403 + __ROR4__(v393, 22);
  v889 = v401;
  v392 = (v896 & v888 | v432 & (v896 | v888)) + (unsigned __int16)(233 * v132) + 15269888 * v260 + v448;
  v896 = v406 + __ROR4__(v392, 22);
  v888 = v400;
  v391 = (v895 & v887 | v431 & (v895 | v887)) + (unsigned __int16)(233 * v134) + 15269888 * v262 + v447;
  v895 = v405 + __ROR4__(v391, 22);
  v887 = v399;
  v390 = __ROR4__(v902, 22);
  v389 = __ROR4__(v901, 22);
  v388 = __ROR4__(v900, 22);
  v387 = __ROR4__(v899, 22);
  v386 = __ROR4__(v898, 22);
  v385 = __ROR4__(v897, 22);
  v384 = __ROR4__(v896, 22);
  v383 = __ROR4__(v895, 22);
  v382 = (v902 & v894 | v422 & (v902 | v894)) + (unsigned __int16)(233 * v104) + 15269888 * v232 + v438;
  v902 = v388 + __ROR4__(v382, 7);
  v894 = v390;
  v381 = (v901 & v893 | v421 & (v901 | v893)) + (unsigned __int16)(233 * v106) + 15269888 * v234 + v437;
  v901 = v387 + __ROR4__(v381, 7);
  v893 = v389;
  v380 = (v900 & v892 | v420 & (v900 | v892)) + (unsigned __int16)(233 * v108) + 15269888 * v236 + v436;
  v900 = v390 + __ROR4__(v380, 7);
  v892 = v388;
  v379 = (v899 & v891 | v419 & (v899 | v891)) + (unsigned __int16)(233 * v110) + 15269888 * v238 + v435;
  v899 = v389 + __ROR4__(v379, 7);
  v891 = v387;
  v378 = (v898 & v890 | v418 & (v898 | v890)) + (unsigned __int16)(233 * v112) + 15269888 * v240 + v434;
  v898 = v384 + __ROR4__(v378, 7);
  v890 = v386;
  v377 = (v897 & v889 | v417 & (v897 | v889)) + (unsigned __int16)(233 * v114) + 15269888 * v242 + v433;
  v897 = v383 + __ROR4__(v377, 7);
  v889 = v385;
  v376 = (v896 & v888 | v416 & (v896 | v888)) + (unsigned __int16)(233 * v116) + 15269888 * v244 + v432;
  v896 = v386 + __ROR4__(v376, 7);
  v888 = v384;
  v375 = (v895 & v887 | v415 & (v895 | v887)) + (unsigned __int16)(233 * v118) + 15269888 * v246 + v431;
  v895 = v385 + __ROR4__(v375, 7);
  v374 = __ROR4__(v902, 7);
  v373 = __ROR4__(v901, 7);
  v372 = __ROR4__(v900, 7);
  v371 = __ROR4__(v899, 7);
  v370 = __ROR4__(v898, 7);
  v369 = __ROR4__(v897, 7);
  v368 = __ROR4__(v896, 7);
  v367 = __ROR4__(v895, 7);
  v366 = (v902 & v894 | v406 & (v902 | v894)) + (unsigned __int16)(233 * v72) + 15269888 * v200 + v422;
  v902 = v371 + __ROR4__(v366, 28);
  v878 = v406;
  v886 = v390;
  v894 = v374;
  v365 = (v901 & v893 | v405 & (v901 | v893)) + (unsigned __int16)(233 * v74) + 15269888 * v202 + v421;
  v901 = v372 + __ROR4__(v365, 28);
  v877 = v405;
  v885 = v389;
  v893 = v373;
  v364 = (v900 & v892 | v404 & (v900 | v892)) + (unsigned __int16)(233 * v76) + 15269888 * v204 + v420;
  v900 = v373 + __ROR4__(v364, 28);
  v876 = v404;
  v884 = v388;
  v892 = v372;
  v363 = (v899 & v891 | v403 & (v899 | v891)) + (unsigned __int16)(233 * v78) + 15269888 * v206 + v419;
  v899 = v374 + __ROR4__(v363, 28);
  v875 = v403;
  v883 = v387;
  v891 = v371;
  v362 = (v898 & v890 | v402 & (v898 | v890)) + (unsigned __int16)(233 * v80) + 15269888 * v208 + v418;
  v898 = v367 + __ROR4__(v362, 28);
  v874 = v402;
  v882 = v386;
  v890 = v370;
  v361 = (v897 & v889 | v401 & (v897 | v889)) + (unsigned __int16)(233 * v82) + 15269888 * v210 + v417;
  v897 = v368 + __ROR4__(v361, 28);
  v873 = v401;
  v881 = v385;
  v889 = v369;
  v360 = (v896 & v888 | v400 & (v896 | v888)) + (unsigned __int16)(233 * v84) + 15269888 * v212 + v416;
  v896 = v369 + __ROR4__(v360, 28);
  v872 = v400;
  v880 = v384;
  v888 = v368;
  result = v895 | v383;
  v359 = (v895 & v383 | v399 & (v895 | v383)) + (unsigned __int16)(233 * v86) + 15269888 * v214 + v415;
  v895 = v370 + __ROR4__(v359, 28);
  v871 = v399;
  v879 = v383;
  v887 = v367;
  v358 = __ROR4__(v902, 28);
  v357 = __ROR4__(v901, 28);
  v356 = __ROR4__(v900, 28);
  v355 = __ROR4__(v899, 28);
  v354 = __ROR4__(v898, 28);
  v353 = __ROR4__(v897, 28);
  v352 = __ROR4__(v896, 28);
  v351 = __ROR4__(v895, 28);
  v350 = ((v374 ^ v886) & v902 ^ v886) + *((_DWORD *)a1 + 33) + v406;
  v902 = v353 + __ROR4__(v350, 19);
  v878 = v390;
  v886 = v374;
  v894 = v358;
  v349 = ((v373 ^ v885) & v901 ^ v885) + *((_DWORD *)a1 + 34) + v405;
  v901 = v354 + __ROR4__(v349, 19);
  v877 = v389;
  v885 = v373;
  v893 = v357;
  v348 = ((v372 ^ v884) & v900 ^ v884) + *((_DWORD *)a1 + 35) + v404;
  v900 = v351 + __ROR4__(v348, 19);
  v876 = v388;
  v884 = v372;
  v892 = v356;
  v347 = ((v371 ^ v883) & v899 ^ v883) + *((_DWORD *)a1 + 36) + v403;
  v899 = v352 + __ROR4__(v347, 19);
  v875 = v387;
  v883 = v371;
  v891 = v355;
  v346 = ((v370 ^ v882) & v898 ^ v882) + *((_DWORD *)a1 + 37) + v402;
  v898 = v357 + __ROR4__(v346, 19);
  v874 = v386;
  v882 = v370;
  v890 = v354;
  v345 = ((v369 ^ v881) & v897 ^ v881) + *((_DWORD *)a1 + 38) + v401;
  v897 = v358 + __ROR4__(v345, 19);
  v873 = v385;
  v881 = v369;
  v889 = v353;
  v344 = ((v368 ^ v880) & v896 ^ v880) + *((_DWORD *)a1 + 39) + v400;
  v896 = v355 + __ROR4__(v344, 19);
  v872 = v384;
  v880 = v368;
  v888 = v352;
  v343 = ((v367 ^ v879) & v895 ^ v879) + *((_DWORD *)a1 + 40) + v399;
  v895 = v356 + __ROR4__(v343, 19);
  v871 = v383;
  v879 = v367;
  v887 = v351;
  v342 = __ROR4__(v902, 19);
  v341 = __ROR4__(v901, 19);
  v340 = __ROR4__(v900, 19);
  v339 = __ROR4__(v899, 19);
  v338 = __ROR4__(v898, 19);
  v337 = __ROR4__(v897, 19);
  v336 = __ROR4__(v896, 19);
  v335 = __ROR4__(v895, 19);
  v334 = ((v358 ^ v886) & v902 ^ v886) + *((_DWORD *)a1 + 41) + v390;
  v902 = v335 + __ROR4__(v334, 22);
  v878 = v374;
  v886 = v358;
  v894 = v342;
  v333 = ((v357 ^ v885) & v901 ^ v885) + *((_DWORD *)a1 + 42) + v389;
  v901 = v336 + __ROR4__(v333, 22);
  v877 = v373;
  v885 = v357;
  v893 = v341;
  v332 = ((v356 ^ v884) & v900 ^ v884) + *((_DWORD *)a1 + 43) + v388;
  v900 = v337 + __ROR4__(v332, 22);
  v876 = v372;
  v884 = v356;
  v892 = v340;
  v331 = ((v355 ^ v883) & v899 ^ v883) + *((_DWORD *)a1 + 44) + v387;
  v899 = v338 + __ROR4__(v331, 22);
  v875 = v371;
  v883 = v355;
  v891 = v339;
  v330 = ((v354 ^ v882) & v898 ^ v882) + *((_DWORD *)a1 + 45) + v386;
  v898 = v339 + __ROR4__(v330, 22);
  v874 = v370;
  v882 = v354;
  v890 = v338;
  v329 = ((v353 ^ v881) & v897 ^ v881) + *((_DWORD *)a1 + 46) + v385;
  v897 = v340 + __ROR4__(v329, 22);
  v873 = v369;
  v881 = v353;
  v889 = v337;
  v328 = ((v352 ^ v880) & v896 ^ v880) + *((_DWORD *)a1 + 47) + v384;
  v896 = v341 + __ROR4__(v328, 22);
  v872 = v368;
  v880 = v352;
  v888 = v336;
  v327 = ((v351 ^ v879) & v895 ^ v879) + *((_DWORD *)a1 + 48) + v383;
  v895 = v342 + __ROR4__(v327, 22);
  v871 = v367;
  v879 = v351;
  v887 = v335;
  v326 = __ROR4__(v902, 22);
  v325 = __ROR4__(v901, 22);
  v324 = __ROR4__(v900, 22);
  v323 = __ROR4__(v899, 22);
  v322 = __ROR4__(v898, 22);
  v321 = __ROR4__(v897, 22);
  v320 = __ROR4__(v896, 22);
  v319 = __ROR4__(v895, 22);
  v318 = ((v342 ^ v886) & v902 ^ v886) + *((_DWORD *)a1 + 49) + v374;
  v902 = v322 + __ROR4__(v318, 7);
  v878 = v358;
  v886 = v342;
  v894 = v326;
  v317 = ((v341 ^ v885) & v901 ^ v885) + *((_DWORD *)a1 + 50) + v373;
  v901 = v321 + __ROR4__(v317, 7);
  v877 = v357;
  v885 = v341;
  v893 = v325;
  v316 = ((v340 ^ v884) & v900 ^ v884) + *((_DWORD *)a1 + 51) + v372;
  v900 = v320 + __ROR4__(v316, 7);
  v876 = v356;
  v884 = v340;
  v892 = v324;
  v315 = ((v339 ^ v883) & v899 ^ v883) + *((_DWORD *)a1 + 52) + v371;
  v899 = v319 + __ROR4__(v315, 7);
  v875 = v355;
  v883 = v339;
  v891 = v323;
  v314 = ((v338 ^ v882) & v898 ^ v882) + *((_DWORD *)a1 + 53) + v370;
  v898 = v326 + __ROR4__(v314, 7);
  v874 = v354;
  v882 = v338;
  v890 = v322;
  v313 = ((v337 ^ v881) & v897 ^ v881) + *((_DWORD *)a1 + 54) + v369;
  v897 = v325 + __ROR4__(v313, 7);
  v873 = v353;
  v881 = v337;
  v889 = v321;
  v312 = ((v336 ^ v880) & v896 ^ v880) + *((_DWORD *)a1 + 55) + v368;
  v896 = v324 + __ROR4__(v312, 7);
  v872 = v352;
  v880 = v336;
  v888 = v320;
  v311 = ((v335 ^ v879) & v895 ^ v879) + *((_DWORD *)a1 + 56) + v367;
  v895 = v323 + __ROR4__(v311, 7);
  v871 = v351;
  v879 = v335;
  v887 = v319;
  v310 = __ROR4__(v902, 7);
  v309 = __ROR4__(v901, 7);
  v308 = __ROR4__(v900, 7);
  v307 = __ROR4__(v899, 7);
  v306 = __ROR4__(v898, 7);
  v305 = __ROR4__(v897, 7);
  v304 = __ROR4__(v896, 7);
  v303 = __ROR4__(v895, 7);
  v302 = ((v326 ^ v886) & v902 ^ v886) + *((_DWORD *)a1 + 57) + v358;
  v902 = v309 + __ROR4__(v302, 28);
  v878 = v342;
  v886 = v326;
  v894 = v310;
  v301 = ((v325 ^ v885) & v901 ^ v885) + *((_DWORD *)a1 + 58) + v357;
  v901 = v310 + __ROR4__(v301, 28);
  v877 = v341;
  v885 = v325;
  v893 = v309;
  v300 = ((v324 ^ v884) & v900 ^ v884) + *((_DWORD *)a1 + 59) + v356;
  v900 = v307 + __ROR4__(v300, 28);
  v876 = v340;
  v884 = v324;
  v892 = v308;
  v299 = ((v323 ^ v883) & v899 ^ v883) + *((_DWORD *)a1 + 60) + v355;
  v899 = v308 + __ROR4__(v299, 28);
  v875 = v339;
  v883 = v323;
  v891 = v307;
  v298 = ((v322 ^ v882) & v898 ^ v882) + *((_DWORD *)a1 + 61) + v354;
  v898 = v305 + __ROR4__(v298, 28);
  v874 = v338;
  v882 = v322;
  v890 = v306;
  v297 = ((v321 ^ v881) & v897 ^ v881) + *((_DWORD *)a1 + 62) + v353;
  v897 = v306 + __ROR4__(v297, 28);
  v873 = v337;
  v881 = v321;
  v889 = v305;
  v296 = ((v320 ^ v880) & v896 ^ v880) + *((_DWORD *)a1 + 63) + v352;
  v896 = v303 + __ROR4__(v296, 28);
  v872 = v336;
  v880 = v320;
  v888 = v304;
  v295 = ((v319 ^ v879) & v895 ^ v879) + *((_DWORD *)a1 + 64) + v351;
  v895 = v304 + __ROR4__(v295, 28);
  v871 = v335;
  v879 = v319;
  v887 = v303;
  *((_DWORD *)a1 + 33) = v902;
  *((_DWORD *)a1 + 34) = v901;
  *((_DWORD *)a1 + 35) = v900;
  *((_DWORD *)a1 + 36) = v899;
  *((_DWORD *)a1 + 37) = v898;
  *((_DWORD *)a1 + 38) = v897;
  *((_DWORD *)a1 + 39) = v896;
  *((_DWORD *)a1 + 40) = v895;
  *((_DWORD *)a1 + 41) = v894;
  *((_DWORD *)a1 + 42) = v893;
  *((_DWORD *)a1 + 43) = v892;
  *((_DWORD *)a1 + 44) = v891;
  *((_DWORD *)a1 + 45) = v890;
  *((_DWORD *)a1 + 46) = v889;
  *((_DWORD *)a1 + 47) = v888;
  *((_DWORD *)a1 + 48) = v887;
  *((_DWORD *)a1 + 49) = v886;
  *((_DWORD *)a1 + 50) = v885;
  *((_DWORD *)a1 + 51) = v884;
  *((_DWORD *)a1 + 52) = v883;
  *((_DWORD *)a1 + 53) = v882;
  *((_DWORD *)a1 + 54) = v881;
  *((_DWORD *)a1 + 55) = v880;
  *((_DWORD *)a1 + 56) = v879;
  *((_DWORD *)a1 + 57) = v878;
  *((_DWORD *)a1 + 58) = v877;
  *((_DWORD *)a1 + 59) = v876;
  *((_DWORD *)a1 + 60) = v875;
  *((_DWORD *)a1 + 61) = v874;
  *((_DWORD *)a1 + 62) = v873;
  *((_DWORD *)a1 + 63) = v872;
  *((_DWORD *)a1 + 64) = v871;
  return result;
}
// 1D48C8: using guessed type _DWORD dword_1D48C8[256];
// 1D4EC8: using guessed type unsigned __int16 word_1D4EC8[256];
// 1D50C8: using guessed type unsigned __int16 word_1D50C8[256];

//----- (00156808) --------------------------------------------------------
void *__fastcall sub_156808(_DWORD *a1, const void *a2)
{
  void *result; // r0

  result = memcpy(a1 + 17, a2, 0x40u);
  a1[34] = 0;
  a1[33] = a1[34];
  a1[16] = 0;
  return result;
}

//----- (00156848) --------------------------------------------------------
void *__fastcall sub_156848(_DWORD *a1, const void *a2)
{
  void *result; // r0

  result = memcpy(a1 + 33, a2, 0x80u);
  a1[66] = 0;
  a1[65] = a1[66];
  a1[32] = 0;
  return result;
}

//----- (00156888) --------------------------------------------------------
unsigned __int8 *__fastcall sub_156888(unsigned __int8 *result, char *a2, unsigned int a3)
{
  unsigned __int8 *v5; // [sp+10h] [bp+10h]
  unsigned int n; // [sp+14h] [bp+14h]

  v5 = result;
  while ( a3 )
  {
    n = 64 - *((_DWORD *)v5 + 16);
    if ( n > a3 )
      n = a3;
    result = (unsigned __int8 *)memcpy(&v5[*((_DWORD *)v5 + 16)], a2, n);
    a2 += n;
    a3 -= n;
    *((_DWORD *)v5 + 16) += n;
    if ( *((_DWORD *)v5 + 16) == 64 )
    {
      result = (unsigned __int8 *)sub_142CC0(v5, 0);
      *((_DWORD *)v5 + 16) = 0;
      if ( !++*((_DWORD *)v5 + 33) )
        ++*((_DWORD *)v5 + 34);
    }
  }
  return result;
}

//----- (00156928) --------------------------------------------------------
unsigned __int8 *__fastcall sub_156928(unsigned __int8 *result, char *a2, unsigned int a3)
{
  unsigned __int8 *v5; // [sp+10h] [bp+10h]
  unsigned int n; // [sp+14h] [bp+14h]

  v5 = result;
  while ( a3 )
  {
    n = 128 - *((_DWORD *)v5 + 32);
    if ( n > a3 )
      n = a3;
    result = (unsigned __int8 *)memcpy(&v5[*((_DWORD *)v5 + 32)], a2, n);
    a2 += n;
    a3 -= n;
    *((_DWORD *)v5 + 32) += n;
    if ( *((_DWORD *)v5 + 32) == 128 )
    {
      result = (unsigned __int8 *)sub_14C4AC(v5, 0);
      *((_DWORD *)v5 + 32) = 0;
      if ( !++*((_DWORD *)v5 + 65) )
        ++*((_DWORD *)v5 + 66);
    }
  }
  return result;
}

//----- (001569D4) --------------------------------------------------------
int __fastcall sub_1569D4(int a1, int a2, int a3, int a4, int a5)
{
  unsigned int v6; // [sp+4h] [bp+4h]

  v6 = ((unsigned int)(a2 << 9) >> 23) + (a3 << 9);
  sub_140E58(a1, a5 + 8 * a4 + (a2 << 9));
  return sub_140E58(a1 + 4, v6);
}

//----- (00156A20) --------------------------------------------------------
int __fastcall sub_156A20(int a1, int a2, int a3, int a4, int a5)
{
  unsigned int v6; // [sp+4h] [bp+4h]

  v6 = ((unsigned int)(a2 << 10) >> 22) + (a3 << 10);
  sub_140E58(a1, a5 + 8 * a4 + (a2 << 10));
  return sub_140E58(a1 + 4, v6);
}

//----- (00156A6C) --------------------------------------------------------
int __fastcall sub_156A6C(int a1, char a2, int a3, int a4, unsigned int a5)
{
  int result; // r0
  unsigned int i; // [sp+24h] [bp+1Ch]

  if ( *(_DWORD *)(a1 + 64) || a3 )
  {
    memset((void *)(a1 + *(_DWORD *)(a1 + 64)), 0, 64 - *(_DWORD *)(a1 + 64));
    *(_BYTE *)(a1 + *(_DWORD *)(a1 + 64)) = a2 & (255 << (8 - a3));
    sub_142CC0((unsigned __int8 *)a1, 0);
  }
  memset((void *)a1, 0, 0x40u);
  sub_1569D4(a1, *(_DWORD *)(a1 + 132), *(_DWORD *)(a1 + 136), *(_DWORD *)(a1 + 64), a3);
  result = sub_142CC0((unsigned __int8 *)a1, 1);
  for ( i = 0; i < a5; ++i )
    result = sub_140E58(a4 + 4 * i, *(_DWORD *)(4 * (i + 16) + a1 + 4));
  return result;
}

//----- (00156B38) --------------------------------------------------------
int __fastcall sub_156B38(int a1, char a2, int a3, int a4, unsigned int a5)
{
  int result; // r0
  unsigned int i; // [sp+24h] [bp+1Ch]

  if ( *(_DWORD *)(a1 + 128) || a3 )
  {
    memset((void *)(a1 + *(_DWORD *)(a1 + 128)), 0, 128 - *(_DWORD *)(a1 + 128));
    *(_BYTE *)(a1 + *(_DWORD *)(a1 + 128)) = a2 & (255 << (8 - a3));
    sub_14C4AC((unsigned __int8 *)a1, 0);
  }
  memset((void *)a1, 0, 0x80u);
  sub_156A20(a1, *(_DWORD *)(a1 + 260), *(_DWORD *)(a1 + 264), *(_DWORD *)(a1 + 128), a3);
  result = sub_14C4AC((unsigned __int8 *)a1, 1);
  for ( i = 0; i < a5; ++i )
    result = sub_140E58(a4 + 4 * i, *(_DWORD *)(4 * (i + 32) + a1 + 4));
  return result;
}

//----- (00156C10) --------------------------------------------------------
void *__fastcall sph_simd224_init(_DWORD *a1)
{
  return sub_156808(a1, &unk_1D52C8);
}

//----- (00156C30) --------------------------------------------------------
unsigned __int8 *__fastcall sph_simd224(unsigned __int8 *a1, char *a2, unsigned int a3)
{
  return sub_156888(a1, a2, a3);
}

//----- (00156C50) --------------------------------------------------------
void *__fastcall sph_simd224_close(_DWORD *a1, int a2)
{
  return sph_simd224_addbits_and_close(a1, 0, 0, a2);
}

//----- (00156C70) --------------------------------------------------------
void *__fastcall sph_simd224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_156A6C((int)a1, a2, a3, a4, 7u);
  return sph_simd224_init(a1);
}

//----- (00156C9C) --------------------------------------------------------
void *__fastcall sph_simd256_init(_DWORD *a1)
{
  return sub_156808(a1, &unk_1D5308);
}

//----- (00156CBC) --------------------------------------------------------
unsigned __int8 *__fastcall sph_simd256(unsigned __int8 *a1, char *a2, unsigned int a3)
{
  return sub_156888(a1, a2, a3);
}

//----- (00156CDC) --------------------------------------------------------
void *__fastcall sph_simd256_close(_DWORD *a1, int a2)
{
  return sph_simd256_addbits_and_close(a1, 0, 0, a2);
}

//----- (00156CFC) --------------------------------------------------------
void *__fastcall sph_simd256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_156A6C((int)a1, a2, a3, a4, 8u);
  return sph_simd256_init(a1);
}

//----- (00156D28) --------------------------------------------------------
void *__fastcall sph_simd384_init(_DWORD *a1)
{
  return sub_156848(a1, &unk_1D5348);
}

//----- (00156D48) --------------------------------------------------------
unsigned __int8 *__fastcall sph_simd384(unsigned __int8 *a1, char *a2, unsigned int a3)
{
  return sub_156928(a1, a2, a3);
}

//----- (00156D68) --------------------------------------------------------
void *__fastcall sph_simd384_close(_DWORD *a1, int a2)
{
  return sph_simd384_addbits_and_close(a1, 0, 0, a2);
}

//----- (00156D88) --------------------------------------------------------
void *__fastcall sph_simd384_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_156B38((int)a1, a2, a3, a4, 0xCu);
  return sph_simd384_init(a1);
}

//----- (00156DB4) --------------------------------------------------------
void *__fastcall sph_simd512_init(_DWORD *a1)
{
  return sub_156848(a1, &unk_1D53C8);
}

//----- (00156DD4) --------------------------------------------------------
unsigned __int8 *__fastcall sph_simd512(unsigned __int8 *a1, char *a2, unsigned int a3)
{
  return sub_156928(a1, a2, a3);
}

//----- (00156DF4) --------------------------------------------------------
void *__fastcall sph_simd512_close(_DWORD *a1, int a2)
{
  return sph_simd512_addbits_and_close(a1, 0, 0, a2);
}

//----- (00156E14) --------------------------------------------------------
void *__fastcall sph_simd512_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_156B38((int)a1, a2, a3, a4, 0x10u);
  return sph_simd512_init(a1);
}

//----- (00156E40) --------------------------------------------------------
int __fastcall sub_156E40(int result, unsigned int a2)
{
  *(_BYTE *)result = a2;
  *(_WORD *)(result + 1) = a2 >> 8;
  *(_BYTE *)(result + 3) = HIBYTE(a2);
  return result;
}

//----- (00156E84) --------------------------------------------------------
int __fastcall sub_156E84(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00156E9C) --------------------------------------------------------
_BYTE *__fastcall sub_156E9C(_BYTE *result, int a2, int a3, int a4)
{
  *result = HIBYTE(a4);
  result[1] = BYTE2(a4);
  result[2] = BYTE1(a4);
  result[3] = a4;
  result[4] = HIBYTE(a3);
  result[5] = BYTE2(a3);
  result[6] = BYTE1(a3);
  result[7] = a3;
  return result;
}

//----- (00156F58) --------------------------------------------------------
void *__fastcall sub_156F58(_DWORD *a1, const void *a2)
{
  void *result; // r0

  a1[16] = 0;
  result = memcpy(a1 + 18, a2, 0x80u);
  a1[50] = 0;
  a1[51] = 0;
  return result;
}

//----- (00156F8C) --------------------------------------------------------
int __fastcall sub_156F8C(int result, char *a2, size_t a3)
{
  int v3; // r1
  unsigned int v4; // [sp+4h] [bp+4h]
  char *v5; // [sp+8h] [bp+8h]
  int v6; // [sp+Ch] [bp+Ch]
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+14h] [bp+14h]
  int v9; // [sp+18h] [bp+18h]
  int v10; // [sp+18h] [bp+18h]
  int v11; // [sp+1Ch] [bp+1Ch]
  int v12; // [sp+1Ch] [bp+1Ch]
  int v13; // [sp+20h] [bp+20h]
  int v14; // [sp+20h] [bp+20h]
  int v15; // [sp+24h] [bp+24h]
  int v16; // [sp+24h] [bp+24h]
  int v17; // [sp+28h] [bp+28h]
  int v18; // [sp+28h] [bp+28h]
  int v19; // [sp+2Ch] [bp+2Ch]
  int v20; // [sp+2Ch] [bp+2Ch]
  int v21; // [sp+30h] [bp+30h]
  int v22; // [sp+30h] [bp+30h]
  int v23; // [sp+84h] [bp+84h]
  int v24; // [sp+84h] [bp+84h]
  int v25; // [sp+84h] [bp+84h]
  int v26; // [sp+84h] [bp+84h]
  int v27; // [sp+84h] [bp+84h]
  int v28; // [sp+84h] [bp+84h]
  int v29; // [sp+84h] [bp+84h]
  int v30; // [sp+84h] [bp+84h]
  int v31; // [sp+84h] [bp+84h]
  int v32; // [sp+84h] [bp+84h]
  int v33; // [sp+84h] [bp+84h]
  int v34; // [sp+84h] [bp+84h]
  int v35; // [sp+84h] [bp+84h]
  int v36; // [sp+84h] [bp+84h]
  int v37; // [sp+84h] [bp+84h]
  int v38; // [sp+84h] [bp+84h]
  int v39; // [sp+84h] [bp+84h]
  int v40; // [sp+84h] [bp+84h]
  int v41; // [sp+84h] [bp+84h]
  int v42; // [sp+84h] [bp+84h]
  int v43; // [sp+84h] [bp+84h]
  int v44; // [sp+84h] [bp+84h]
  int v45; // [sp+84h] [bp+84h]
  int v46; // [sp+84h] [bp+84h]
  int v47; // [sp+84h] [bp+84h]
  int v48; // [sp+84h] [bp+84h]
  int v49; // [sp+84h] [bp+84h]
  int v50; // [sp+84h] [bp+84h]
  int v51; // [sp+84h] [bp+84h]
  int v52; // [sp+84h] [bp+84h]
  int v53; // [sp+84h] [bp+84h]
  int v54; // [sp+84h] [bp+84h]
  int v55; // [sp+84h] [bp+84h]
  int v56; // [sp+84h] [bp+84h]
  int v57; // [sp+84h] [bp+84h]
  int v58; // [sp+84h] [bp+84h]
  int v59; // [sp+84h] [bp+84h]
  int v60; // [sp+84h] [bp+84h]
  int v61; // [sp+84h] [bp+84h]
  int v62; // [sp+84h] [bp+84h]
  int v63; // [sp+84h] [bp+84h]
  int v64; // [sp+84h] [bp+84h]
  int v65; // [sp+84h] [bp+84h]
  int v66; // [sp+84h] [bp+84h]
  int v67; // [sp+84h] [bp+84h]
  int v68; // [sp+84h] [bp+84h]
  int v69; // [sp+84h] [bp+84h]
  int v70; // [sp+84h] [bp+84h]
  int v71; // [sp+84h] [bp+84h]
  int v72; // [sp+84h] [bp+84h]
  int v73; // [sp+84h] [bp+84h]
  int v74; // [sp+84h] [bp+84h]
  int v75; // [sp+84h] [bp+84h]
  int v76; // [sp+84h] [bp+84h]
  int v77; // [sp+84h] [bp+84h]
  int v78; // [sp+84h] [bp+84h]
  int v79; // [sp+8Ch] [bp+8Ch]
  int v80; // [sp+90h] [bp+90h]
  int v81; // [sp+94h] [bp+94h]
  int v82; // [sp+98h] [bp+98h]
  int v83; // [sp+9Ch] [bp+9Ch]
  int v84; // [sp+A0h] [bp+A0h]
  int v85; // [sp+A4h] [bp+A4h]
  int v86; // [sp+A8h] [bp+A8h]
  int v87; // [sp+ACh] [bp+ACh]
  int v88; // [sp+B0h] [bp+B0h]
  int v89; // [sp+B4h] [bp+B4h]
  int v90; // [sp+B8h] [bp+B8h]
  int v91; // [sp+BCh] [bp+BCh]
  int v92; // [sp+C0h] [bp+C0h]
  int v93; // [sp+C4h] [bp+C4h]
  int v94; // [sp+C8h] [bp+C8h]
  unsigned int i; // [sp+CCh] [bp+CCh]
  size_t n; // [sp+D0h] [bp+D0h]
  int v97; // [sp+D4h] [bp+D4h]
  int v98; // [sp+D4h] [bp+D4h]
  int v99; // [sp+D4h] [bp+D4h]
  int v100; // [sp+D4h] [bp+D4h]
  unsigned int v101; // [sp+D4h] [bp+D4h]
  int v102; // [sp+D4h] [bp+D4h]
  int v103; // [sp+D4h] [bp+D4h]
  int v104; // [sp+D4h] [bp+D4h]
  unsigned int v105; // [sp+D4h] [bp+D4h]
  int v106; // [sp+D4h] [bp+D4h]
  int v107; // [sp+D4h] [bp+D4h]
  int v108; // [sp+D4h] [bp+D4h]
  unsigned int v109; // [sp+D4h] [bp+D4h]
  int v110; // [sp+D4h] [bp+D4h]
  int v111; // [sp+D4h] [bp+D4h]
  int v112; // [sp+D4h] [bp+D4h]
  unsigned int v113; // [sp+D4h] [bp+D4h]
  int v114; // [sp+D4h] [bp+D4h]
  int v115; // [sp+D4h] [bp+D4h]
  int v116; // [sp+D4h] [bp+D4h]
  unsigned int v117; // [sp+D4h] [bp+D4h]
  int v118; // [sp+D4h] [bp+D4h]
  int v119; // [sp+D4h] [bp+D4h]
  int v120; // [sp+D4h] [bp+D4h]
  int v121; // [sp+D4h] [bp+D4h]
  int v122; // [sp+D4h] [bp+D4h]
  int v123; // [sp+D4h] [bp+D4h]
  int v124; // [sp+D4h] [bp+D4h]
  int v125; // [sp+D8h] [bp+D8h]
  int v126; // [sp+D8h] [bp+D8h]
  int v127; // [sp+D8h] [bp+D8h]
  int v128; // [sp+D8h] [bp+D8h]
  unsigned int v129; // [sp+D8h] [bp+D8h]
  int v130; // [sp+D8h] [bp+D8h]
  int v131; // [sp+D8h] [bp+D8h]
  int v132; // [sp+D8h] [bp+D8h]
  unsigned int v133; // [sp+D8h] [bp+D8h]
  int v134; // [sp+D8h] [bp+D8h]
  int v135; // [sp+D8h] [bp+D8h]
  int v136; // [sp+D8h] [bp+D8h]
  unsigned int v137; // [sp+D8h] [bp+D8h]
  int v138; // [sp+D8h] [bp+D8h]
  int v139; // [sp+D8h] [bp+D8h]
  int v140; // [sp+D8h] [bp+D8h]
  unsigned int v141; // [sp+D8h] [bp+D8h]
  int v142; // [sp+D8h] [bp+D8h]
  int v143; // [sp+D8h] [bp+D8h]
  int v144; // [sp+D8h] [bp+D8h]
  unsigned int v145; // [sp+D8h] [bp+D8h]
  int v146; // [sp+D8h] [bp+D8h]
  int v147; // [sp+D8h] [bp+D8h]
  int v148; // [sp+D8h] [bp+D8h]
  int v149; // [sp+D8h] [bp+D8h]
  int v150; // [sp+D8h] [bp+D8h]
  int v151; // [sp+D8h] [bp+D8h]
  int v152; // [sp+D8h] [bp+D8h]
  int v153; // [sp+DCh] [bp+DCh]
  int v154; // [sp+DCh] [bp+DCh]
  int v155; // [sp+DCh] [bp+DCh]
  int v156; // [sp+DCh] [bp+DCh]
  unsigned int v157; // [sp+DCh] [bp+DCh]
  int v158; // [sp+DCh] [bp+DCh]
  int v159; // [sp+DCh] [bp+DCh]
  int v160; // [sp+DCh] [bp+DCh]
  unsigned int v161; // [sp+DCh] [bp+DCh]
  int v162; // [sp+DCh] [bp+DCh]
  int v163; // [sp+DCh] [bp+DCh]
  int v164; // [sp+DCh] [bp+DCh]
  unsigned int v165; // [sp+DCh] [bp+DCh]
  int v166; // [sp+DCh] [bp+DCh]
  int v167; // [sp+DCh] [bp+DCh]
  int v168; // [sp+DCh] [bp+DCh]
  unsigned int v169; // [sp+DCh] [bp+DCh]
  int v170; // [sp+DCh] [bp+DCh]
  int v171; // [sp+DCh] [bp+DCh]
  int v172; // [sp+DCh] [bp+DCh]
  unsigned int v173; // [sp+DCh] [bp+DCh]
  int v174; // [sp+DCh] [bp+DCh]
  int v175; // [sp+DCh] [bp+DCh]
  int v176; // [sp+DCh] [bp+DCh]
  int v177; // [sp+DCh] [bp+DCh]
  int v178; // [sp+DCh] [bp+DCh]
  int v179; // [sp+DCh] [bp+DCh]
  int v180; // [sp+DCh] [bp+DCh]
  int v181; // [sp+DCh] [bp+DCh]
  int v182; // [sp+DCh] [bp+DCh]
  int v183; // [sp+E0h] [bp+E0h]
  int v184; // [sp+E0h] [bp+E0h]
  int v185; // [sp+E0h] [bp+E0h]
  int v186; // [sp+E0h] [bp+E0h]
  unsigned int v187; // [sp+E0h] [bp+E0h]
  int v188; // [sp+E0h] [bp+E0h]
  int v189; // [sp+E0h] [bp+E0h]
  int v190; // [sp+E0h] [bp+E0h]
  unsigned int v191; // [sp+E0h] [bp+E0h]
  int v192; // [sp+E0h] [bp+E0h]
  int v193; // [sp+E0h] [bp+E0h]
  int v194; // [sp+E0h] [bp+E0h]
  unsigned int v195; // [sp+E0h] [bp+E0h]
  int v196; // [sp+E0h] [bp+E0h]
  int v197; // [sp+E0h] [bp+E0h]
  int v198; // [sp+E0h] [bp+E0h]
  unsigned int v199; // [sp+E0h] [bp+E0h]
  int v200; // [sp+E0h] [bp+E0h]
  int v201; // [sp+E0h] [bp+E0h]
  int v202; // [sp+E0h] [bp+E0h]
  unsigned int v203; // [sp+E0h] [bp+E0h]
  int v204; // [sp+E0h] [bp+E0h]
  int v205; // [sp+E0h] [bp+E0h]
  int v206; // [sp+E0h] [bp+E0h]
  int v207; // [sp+E0h] [bp+E0h]
  int v208; // [sp+E0h] [bp+E0h]
  int v209; // [sp+E0h] [bp+E0h]
  int v210; // [sp+E0h] [bp+E0h]
  int v211; // [sp+E0h] [bp+E0h]
  int v212; // [sp+E0h] [bp+E0h]
  int v213; // [sp+E4h] [bp+E4h]
  int v214; // [sp+E4h] [bp+E4h]
  int v215; // [sp+E4h] [bp+E4h]
  int v216; // [sp+E4h] [bp+E4h]
  int v217; // [sp+E4h] [bp+E4h]
  int v218; // [sp+E4h] [bp+E4h]
  int v219; // [sp+E4h] [bp+E4h]
  int v220; // [sp+E4h] [bp+E4h]
  int v221; // [sp+E4h] [bp+E4h]
  int v222; // [sp+E4h] [bp+E4h]
  int v223; // [sp+E4h] [bp+E4h]
  int v224; // [sp+E4h] [bp+E4h]
  int v225; // [sp+E4h] [bp+E4h]
  int v226; // [sp+E4h] [bp+E4h]
  int v227; // [sp+E4h] [bp+E4h]
  int v228; // [sp+E4h] [bp+E4h]
  int v229; // [sp+E4h] [bp+E4h]
  int v230; // [sp+E4h] [bp+E4h]
  int v231; // [sp+E4h] [bp+E4h]
  int v232; // [sp+E4h] [bp+E4h]
  int v233; // [sp+E4h] [bp+E4h]
  int v234; // [sp+E4h] [bp+E4h]
  int v235; // [sp+E8h] [bp+E8h]
  int v236; // [sp+E8h] [bp+E8h]
  int v237; // [sp+E8h] [bp+E8h]
  int v238; // [sp+E8h] [bp+E8h]
  int v239; // [sp+E8h] [bp+E8h]
  int v240; // [sp+E8h] [bp+E8h]
  int v241; // [sp+E8h] [bp+E8h]
  int v242; // [sp+E8h] [bp+E8h]
  int v243; // [sp+E8h] [bp+E8h]
  int v244; // [sp+E8h] [bp+E8h]
  int v245; // [sp+E8h] [bp+E8h]
  int v246; // [sp+E8h] [bp+E8h]
  int v247; // [sp+E8h] [bp+E8h]
  int v248; // [sp+E8h] [bp+E8h]
  int v249; // [sp+E8h] [bp+E8h]
  int v250; // [sp+E8h] [bp+E8h]
  int v251; // [sp+E8h] [bp+E8h]
  int v252; // [sp+E8h] [bp+E8h]
  int v253; // [sp+E8h] [bp+E8h]
  int v254; // [sp+E8h] [bp+E8h]
  int v255; // [sp+E8h] [bp+E8h]
  int v256; // [sp+E8h] [bp+E8h]
  int v257; // [sp+ECh] [bp+ECh]
  int v258; // [sp+ECh] [bp+ECh]
  int v259; // [sp+ECh] [bp+ECh]
  int v260; // [sp+ECh] [bp+ECh]
  int v261; // [sp+ECh] [bp+ECh]
  int v262; // [sp+ECh] [bp+ECh]
  int v263; // [sp+ECh] [bp+ECh]
  int v264; // [sp+ECh] [bp+ECh]
  int v265; // [sp+ECh] [bp+ECh]
  int v266; // [sp+ECh] [bp+ECh]
  int v267; // [sp+ECh] [bp+ECh]
  int v268; // [sp+ECh] [bp+ECh]
  int v269; // [sp+ECh] [bp+ECh]
  int v270; // [sp+ECh] [bp+ECh]
  int v271; // [sp+ECh] [bp+ECh]
  int v272; // [sp+ECh] [bp+ECh]
  int v273; // [sp+ECh] [bp+ECh]
  int v274; // [sp+ECh] [bp+ECh]
  int v275; // [sp+ECh] [bp+ECh]
  int v276; // [sp+ECh] [bp+ECh]
  int v277; // [sp+ECh] [bp+ECh]
  int v278; // [sp+ECh] [bp+ECh]
  int v279; // [sp+ECh] [bp+ECh]
  int v280; // [sp+F0h] [bp+F0h]
  int v281; // [sp+F0h] [bp+F0h]
  int v282; // [sp+F0h] [bp+F0h]
  int v283; // [sp+F0h] [bp+F0h]
  int v284; // [sp+F0h] [bp+F0h]
  int v285; // [sp+F0h] [bp+F0h]
  int v286; // [sp+F0h] [bp+F0h]
  int v287; // [sp+F0h] [bp+F0h]
  int v288; // [sp+F0h] [bp+F0h]
  int v289; // [sp+F0h] [bp+F0h]
  int v290; // [sp+F0h] [bp+F0h]
  int v291; // [sp+F0h] [bp+F0h]
  int v292; // [sp+F0h] [bp+F0h]
  int v293; // [sp+F0h] [bp+F0h]
  int v294; // [sp+F0h] [bp+F0h]
  int v295; // [sp+F0h] [bp+F0h]
  int v296; // [sp+F0h] [bp+F0h]
  int v297; // [sp+F0h] [bp+F0h]
  int v298; // [sp+F0h] [bp+F0h]
  int v299; // [sp+F0h] [bp+F0h]
  int v300; // [sp+F0h] [bp+F0h]
  int v301; // [sp+F0h] [bp+F0h]
  int v302; // [sp+F0h] [bp+F0h]
  int v303; // [sp+F4h] [bp+F4h]
  int v304; // [sp+F4h] [bp+F4h]
  unsigned int v305; // [sp+F4h] [bp+F4h]
  int v306; // [sp+F4h] [bp+F4h]
  int v307; // [sp+F4h] [bp+F4h]
  unsigned int v308; // [sp+F4h] [bp+F4h]
  int v309; // [sp+F4h] [bp+F4h]
  int v310; // [sp+F4h] [bp+F4h]
  unsigned int v311; // [sp+F4h] [bp+F4h]
  int v312; // [sp+F4h] [bp+F4h]
  int v313; // [sp+F4h] [bp+F4h]
  unsigned int v314; // [sp+F4h] [bp+F4h]
  int v315; // [sp+F4h] [bp+F4h]
  int v316; // [sp+F4h] [bp+F4h]
  unsigned int v317; // [sp+F4h] [bp+F4h]
  int v318; // [sp+F4h] [bp+F4h]
  int v319; // [sp+F4h] [bp+F4h]
  int v320; // [sp+F4h] [bp+F4h]
  int v321; // [sp+F4h] [bp+F4h]
  int v322; // [sp+F4h] [bp+F4h]
  int v323; // [sp+F8h] [bp+F8h]
  int v324; // [sp+F8h] [bp+F8h]
  int v325; // [sp+F8h] [bp+F8h]
  unsigned int v326; // [sp+F8h] [bp+F8h]
  int v327; // [sp+F8h] [bp+F8h]
  int v328; // [sp+F8h] [bp+F8h]
  int v329; // [sp+F8h] [bp+F8h]
  unsigned int v330; // [sp+F8h] [bp+F8h]
  int v331; // [sp+F8h] [bp+F8h]
  int v332; // [sp+F8h] [bp+F8h]
  int v333; // [sp+F8h] [bp+F8h]
  unsigned int v334; // [sp+F8h] [bp+F8h]
  int v335; // [sp+F8h] [bp+F8h]
  int v336; // [sp+F8h] [bp+F8h]
  int v337; // [sp+F8h] [bp+F8h]
  unsigned int v338; // [sp+F8h] [bp+F8h]
  int v339; // [sp+F8h] [bp+F8h]
  int v340; // [sp+F8h] [bp+F8h]
  int v341; // [sp+F8h] [bp+F8h]
  unsigned int v342; // [sp+F8h] [bp+F8h]
  int v343; // [sp+F8h] [bp+F8h]
  int v344; // [sp+F8h] [bp+F8h]
  int v345; // [sp+F8h] [bp+F8h]
  int v346; // [sp+F8h] [bp+F8h]
  int v347; // [sp+F8h] [bp+F8h]
  int v348; // [sp+F8h] [bp+F8h]
  int v349; // [sp+F8h] [bp+F8h]
  int v350; // [sp+FCh] [bp+FCh]
  int v351; // [sp+FCh] [bp+FCh]
  int v352; // [sp+FCh] [bp+FCh]
  unsigned int v353; // [sp+FCh] [bp+FCh]
  int v354; // [sp+FCh] [bp+FCh]
  int v355; // [sp+FCh] [bp+FCh]
  int v356; // [sp+FCh] [bp+FCh]
  unsigned int v357; // [sp+FCh] [bp+FCh]
  int v358; // [sp+FCh] [bp+FCh]
  int v359; // [sp+FCh] [bp+FCh]
  int v360; // [sp+FCh] [bp+FCh]
  unsigned int v361; // [sp+FCh] [bp+FCh]
  int v362; // [sp+FCh] [bp+FCh]
  int v363; // [sp+FCh] [bp+FCh]
  int v364; // [sp+FCh] [bp+FCh]
  unsigned int v365; // [sp+FCh] [bp+FCh]
  int v366; // [sp+FCh] [bp+FCh]
  int v367; // [sp+FCh] [bp+FCh]
  int v368; // [sp+FCh] [bp+FCh]
  unsigned int v369; // [sp+FCh] [bp+FCh]
  int v370; // [sp+FCh] [bp+FCh]
  int v371; // [sp+FCh] [bp+FCh]
  int v372; // [sp+FCh] [bp+FCh]
  int v373; // [sp+FCh] [bp+FCh]
  int v374; // [sp+FCh] [bp+FCh]
  int v375; // [sp+FCh] [bp+FCh]
  int v376; // [sp+FCh] [bp+FCh]
  int v377; // [sp+FCh] [bp+FCh]
  int v378; // [sp+100h] [bp+100h]
  int v379; // [sp+100h] [bp+100h]
  int v380; // [sp+100h] [bp+100h]
  unsigned int v381; // [sp+100h] [bp+100h]
  int v382; // [sp+100h] [bp+100h]
  int v383; // [sp+100h] [bp+100h]
  int v384; // [sp+100h] [bp+100h]
  unsigned int v385; // [sp+100h] [bp+100h]
  int v386; // [sp+100h] [bp+100h]
  int v387; // [sp+100h] [bp+100h]
  int v388; // [sp+100h] [bp+100h]
  unsigned int v389; // [sp+100h] [bp+100h]
  int v390; // [sp+100h] [bp+100h]
  int v391; // [sp+100h] [bp+100h]
  int v392; // [sp+100h] [bp+100h]
  unsigned int v393; // [sp+100h] [bp+100h]
  int v394; // [sp+100h] [bp+100h]
  int v395; // [sp+100h] [bp+100h]
  int v396; // [sp+100h] [bp+100h]
  unsigned int v397; // [sp+100h] [bp+100h]
  int v398; // [sp+100h] [bp+100h]
  int v399; // [sp+100h] [bp+100h]
  int v400; // [sp+100h] [bp+100h]
  int v401; // [sp+100h] [bp+100h]
  int v402; // [sp+100h] [bp+100h]
  int v403; // [sp+100h] [bp+100h]
  int v404; // [sp+100h] [bp+100h]
  int v405; // [sp+100h] [bp+100h]
  int v406; // [sp+104h] [bp+104h]
  int v407; // [sp+104h] [bp+104h]
  int v408; // [sp+104h] [bp+104h]
  int v409; // [sp+104h] [bp+104h]
  int v410; // [sp+104h] [bp+104h]
  int v411; // [sp+104h] [bp+104h]
  int v412; // [sp+104h] [bp+104h]
  int v413; // [sp+104h] [bp+104h]
  int v414; // [sp+104h] [bp+104h]
  int v415; // [sp+104h] [bp+104h]
  int v416; // [sp+104h] [bp+104h]
  int v417; // [sp+104h] [bp+104h]
  int v418; // [sp+104h] [bp+104h]
  int v419; // [sp+104h] [bp+104h]
  int v420; // [sp+104h] [bp+104h]
  int v421; // [sp+104h] [bp+104h]
  int v422; // [sp+104h] [bp+104h]
  int v423; // [sp+104h] [bp+104h]
  int v424; // [sp+104h] [bp+104h]
  int v425; // [sp+104h] [bp+104h]
  int v426; // [sp+104h] [bp+104h]
  int v427; // [sp+108h] [bp+108h]
  int v428; // [sp+108h] [bp+108h]
  int v429; // [sp+108h] [bp+108h]
  int v430; // [sp+108h] [bp+108h]
  int v431; // [sp+108h] [bp+108h]
  int v432; // [sp+108h] [bp+108h]
  int v433; // [sp+108h] [bp+108h]
  int v434; // [sp+108h] [bp+108h]
  int v435; // [sp+108h] [bp+108h]
  int v436; // [sp+108h] [bp+108h]
  int v437; // [sp+108h] [bp+108h]
  int v438; // [sp+108h] [bp+108h]
  int v439; // [sp+108h] [bp+108h]
  int v440; // [sp+108h] [bp+108h]
  int v441; // [sp+108h] [bp+108h]
  int v442; // [sp+108h] [bp+108h]
  int v443; // [sp+108h] [bp+108h]
  int v444; // [sp+108h] [bp+108h]
  int v445; // [sp+108h] [bp+108h]
  int v446; // [sp+108h] [bp+108h]
  int v447; // [sp+108h] [bp+108h]
  int v448; // [sp+10Ch] [bp+10Ch]
  int v449; // [sp+10Ch] [bp+10Ch]
  int v450; // [sp+10Ch] [bp+10Ch]
  int v451; // [sp+10Ch] [bp+10Ch]
  int v452; // [sp+10Ch] [bp+10Ch]
  int v453; // [sp+10Ch] [bp+10Ch]
  int v454; // [sp+10Ch] [bp+10Ch]
  int v455; // [sp+10Ch] [bp+10Ch]
  int v456; // [sp+10Ch] [bp+10Ch]
  int v457; // [sp+10Ch] [bp+10Ch]
  int v458; // [sp+10Ch] [bp+10Ch]
  int v459; // [sp+10Ch] [bp+10Ch]
  int v460; // [sp+10Ch] [bp+10Ch]
  int v461; // [sp+10Ch] [bp+10Ch]
  int v462; // [sp+10Ch] [bp+10Ch]
  int v463; // [sp+10Ch] [bp+10Ch]
  int v464; // [sp+10Ch] [bp+10Ch]
  int v465; // [sp+10Ch] [bp+10Ch]
  int v466; // [sp+10Ch] [bp+10Ch]
  int v467; // [sp+10Ch] [bp+10Ch]
  int v468; // [sp+10Ch] [bp+10Ch]
  int v469; // [sp+110h] [bp+110h]
  int v470; // [sp+110h] [bp+110h]
  int v471; // [sp+110h] [bp+110h]
  int v472; // [sp+110h] [bp+110h]
  int v473; // [sp+110h] [bp+110h]
  int v474; // [sp+110h] [bp+110h]
  int v475; // [sp+110h] [bp+110h]
  int v476; // [sp+110h] [bp+110h]
  int v477; // [sp+110h] [bp+110h]
  int v478; // [sp+110h] [bp+110h]
  int v479; // [sp+110h] [bp+110h]
  int v480; // [sp+110h] [bp+110h]
  int v481; // [sp+110h] [bp+110h]
  int v482; // [sp+110h] [bp+110h]
  int v483; // [sp+110h] [bp+110h]
  int v484; // [sp+110h] [bp+110h]
  int v485; // [sp+110h] [bp+110h]
  int v486; // [sp+110h] [bp+110h]
  int v487; // [sp+110h] [bp+110h]
  int v488; // [sp+110h] [bp+110h]
  int v489; // [sp+110h] [bp+110h]
  int v490; // [sp+114h] [bp+114h]
  int v491; // [sp+114h] [bp+114h]
  int v492; // [sp+114h] [bp+114h]
  unsigned int v493; // [sp+114h] [bp+114h]
  int v494; // [sp+114h] [bp+114h]
  int v495; // [sp+114h] [bp+114h]
  int v496; // [sp+114h] [bp+114h]
  unsigned int v497; // [sp+114h] [bp+114h]
  int v498; // [sp+114h] [bp+114h]
  int v499; // [sp+114h] [bp+114h]
  int v500; // [sp+114h] [bp+114h]
  unsigned int v501; // [sp+114h] [bp+114h]
  int v502; // [sp+114h] [bp+114h]
  int v503; // [sp+114h] [bp+114h]
  int v504; // [sp+114h] [bp+114h]
  unsigned int v505; // [sp+114h] [bp+114h]
  int v506; // [sp+114h] [bp+114h]
  int v507; // [sp+114h] [bp+114h]
  int v508; // [sp+114h] [bp+114h]
  unsigned int v509; // [sp+114h] [bp+114h]
  int v510; // [sp+114h] [bp+114h]
  int v511; // [sp+114h] [bp+114h]
  int v512; // [sp+114h] [bp+114h]
  int v513; // [sp+114h] [bp+114h]
  int v514; // [sp+114h] [bp+114h]
  int v515; // [sp+114h] [bp+114h]
  int v516; // [sp+114h] [bp+114h]
  int v517; // [sp+118h] [bp+118h]
  int v518; // [sp+118h] [bp+118h]
  int v519; // [sp+118h] [bp+118h]
  unsigned int v520; // [sp+118h] [bp+118h]
  int v521; // [sp+118h] [bp+118h]
  int v522; // [sp+118h] [bp+118h]
  int v523; // [sp+118h] [bp+118h]
  unsigned int v524; // [sp+118h] [bp+118h]
  int v525; // [sp+118h] [bp+118h]
  int v526; // [sp+118h] [bp+118h]
  int v527; // [sp+118h] [bp+118h]
  unsigned int v528; // [sp+118h] [bp+118h]
  int v529; // [sp+118h] [bp+118h]
  int v530; // [sp+118h] [bp+118h]
  int v531; // [sp+118h] [bp+118h]
  unsigned int v532; // [sp+118h] [bp+118h]
  int v533; // [sp+118h] [bp+118h]
  int v534; // [sp+118h] [bp+118h]
  int v535; // [sp+118h] [bp+118h]
  unsigned int v536; // [sp+118h] [bp+118h]
  int v537; // [sp+118h] [bp+118h]
  int v538; // [sp+118h] [bp+118h]
  int v539; // [sp+118h] [bp+118h]
  int v540; // [sp+118h] [bp+118h]
  int v541; // [sp+118h] [bp+118h]
  int v542; // [sp+118h] [bp+118h]
  int v543; // [sp+118h] [bp+118h]
  int v544; // [sp+11Ch] [bp+11Ch]
  int v545; // [sp+11Ch] [bp+11Ch]
  int v546; // [sp+11Ch] [bp+11Ch]
  unsigned int v547; // [sp+11Ch] [bp+11Ch]
  int v548; // [sp+11Ch] [bp+11Ch]
  int v549; // [sp+11Ch] [bp+11Ch]
  int v550; // [sp+11Ch] [bp+11Ch]
  unsigned int v551; // [sp+11Ch] [bp+11Ch]
  int v552; // [sp+11Ch] [bp+11Ch]
  int v553; // [sp+11Ch] [bp+11Ch]
  int v554; // [sp+11Ch] [bp+11Ch]
  unsigned int v555; // [sp+11Ch] [bp+11Ch]
  int v556; // [sp+11Ch] [bp+11Ch]
  int v557; // [sp+11Ch] [bp+11Ch]
  int v558; // [sp+11Ch] [bp+11Ch]
  unsigned int v559; // [sp+11Ch] [bp+11Ch]
  int v560; // [sp+11Ch] [bp+11Ch]
  int v561; // [sp+11Ch] [bp+11Ch]
  int v562; // [sp+11Ch] [bp+11Ch]
  unsigned int v563; // [sp+11Ch] [bp+11Ch]
  int v564; // [sp+11Ch] [bp+11Ch]
  int v565; // [sp+11Ch] [bp+11Ch]
  int v566; // [sp+11Ch] [bp+11Ch]
  int v567; // [sp+11Ch] [bp+11Ch]
  int v568; // [sp+11Ch] [bp+11Ch]
  int v569; // [sp+11Ch] [bp+11Ch]
  int v570; // [sp+11Ch] [bp+11Ch]
  int v571; // [sp+11Ch] [bp+11Ch]
  int v572; // [sp+120h] [bp+120h]
  int v573; // [sp+120h] [bp+120h]
  int v574; // [sp+120h] [bp+120h]
  unsigned int v575; // [sp+120h] [bp+120h]
  int v576; // [sp+120h] [bp+120h]
  int v577; // [sp+120h] [bp+120h]
  int v578; // [sp+120h] [bp+120h]
  unsigned int v579; // [sp+120h] [bp+120h]
  int v580; // [sp+120h] [bp+120h]
  int v581; // [sp+120h] [bp+120h]
  int v582; // [sp+120h] [bp+120h]
  unsigned int v583; // [sp+120h] [bp+120h]
  int v584; // [sp+120h] [bp+120h]
  int v585; // [sp+120h] [bp+120h]
  int v586; // [sp+120h] [bp+120h]
  unsigned int v587; // [sp+120h] [bp+120h]
  int v588; // [sp+120h] [bp+120h]
  int v589; // [sp+120h] [bp+120h]
  int v590; // [sp+120h] [bp+120h]
  unsigned int v591; // [sp+120h] [bp+120h]
  int v592; // [sp+120h] [bp+120h]
  int v593; // [sp+120h] [bp+120h]
  int v594; // [sp+120h] [bp+120h]
  int v595; // [sp+120h] [bp+120h]
  int v596; // [sp+120h] [bp+120h]
  int v597; // [sp+120h] [bp+120h]
  int v598; // [sp+120h] [bp+120h]
  int v599; // [sp+120h] [bp+120h]
  int v600; // [sp+124h] [bp+124h]
  int v601; // [sp+124h] [bp+124h]
  int v602; // [sp+124h] [bp+124h]
  int v603; // [sp+124h] [bp+124h]
  int v604; // [sp+124h] [bp+124h]
  int v605; // [sp+124h] [bp+124h]
  int v606; // [sp+124h] [bp+124h]
  int v607; // [sp+124h] [bp+124h]
  int v608; // [sp+124h] [bp+124h]
  int v609; // [sp+124h] [bp+124h]
  int v610; // [sp+124h] [bp+124h]
  int v611; // [sp+124h] [bp+124h]
  int v612; // [sp+124h] [bp+124h]
  int v613; // [sp+124h] [bp+124h]
  int v614; // [sp+124h] [bp+124h]
  int v615; // [sp+124h] [bp+124h]
  int v616; // [sp+124h] [bp+124h]
  int v617; // [sp+124h] [bp+124h]
  int v618; // [sp+124h] [bp+124h]
  int v619; // [sp+124h] [bp+124h]
  int v620; // [sp+124h] [bp+124h]
  int v621; // [sp+128h] [bp+128h]
  int v622; // [sp+128h] [bp+128h]
  int v623; // [sp+128h] [bp+128h]
  int v624; // [sp+128h] [bp+128h]
  int v625; // [sp+128h] [bp+128h]
  int v626; // [sp+128h] [bp+128h]
  int v627; // [sp+128h] [bp+128h]
  int v628; // [sp+128h] [bp+128h]
  int v629; // [sp+128h] [bp+128h]
  int v630; // [sp+128h] [bp+128h]
  int v631; // [sp+128h] [bp+128h]
  int v632; // [sp+128h] [bp+128h]
  int v633; // [sp+128h] [bp+128h]
  int v634; // [sp+128h] [bp+128h]
  int v635; // [sp+128h] [bp+128h]
  int v636; // [sp+128h] [bp+128h]
  int v637; // [sp+128h] [bp+128h]
  int v638; // [sp+128h] [bp+128h]
  int v639; // [sp+128h] [bp+128h]
  int v640; // [sp+128h] [bp+128h]
  int v641; // [sp+128h] [bp+128h]
  int v642; // [sp+12Ch] [bp+12Ch]
  int v643; // [sp+12Ch] [bp+12Ch]
  int v644; // [sp+12Ch] [bp+12Ch]
  int v645; // [sp+12Ch] [bp+12Ch]
  int v646; // [sp+12Ch] [bp+12Ch]
  int v647; // [sp+12Ch] [bp+12Ch]
  int v648; // [sp+12Ch] [bp+12Ch]
  int v649; // [sp+12Ch] [bp+12Ch]
  int v650; // [sp+12Ch] [bp+12Ch]
  int v651; // [sp+12Ch] [bp+12Ch]
  int v652; // [sp+12Ch] [bp+12Ch]
  int v653; // [sp+12Ch] [bp+12Ch]
  int v654; // [sp+12Ch] [bp+12Ch]
  int v655; // [sp+12Ch] [bp+12Ch]
  int v656; // [sp+12Ch] [bp+12Ch]
  int v657; // [sp+12Ch] [bp+12Ch]
  int v658; // [sp+12Ch] [bp+12Ch]
  int v659; // [sp+12Ch] [bp+12Ch]
  int v660; // [sp+12Ch] [bp+12Ch]
  int v661; // [sp+12Ch] [bp+12Ch]
  int v662; // [sp+12Ch] [bp+12Ch]
  int v663; // [sp+130h] [bp+130h]
  int v664; // [sp+130h] [bp+130h]
  int v665; // [sp+130h] [bp+130h]
  int v666; // [sp+130h] [bp+130h]
  int v667; // [sp+130h] [bp+130h]
  int v668; // [sp+130h] [bp+130h]
  int v669; // [sp+130h] [bp+130h]
  int v670; // [sp+130h] [bp+130h]
  int v671; // [sp+130h] [bp+130h]
  int v672; // [sp+130h] [bp+130h]
  int v673; // [sp+130h] [bp+130h]
  int v674; // [sp+130h] [bp+130h]
  int v675; // [sp+130h] [bp+130h]
  int v676; // [sp+130h] [bp+130h]
  int v677; // [sp+130h] [bp+130h]
  int v678; // [sp+130h] [bp+130h]
  int v679; // [sp+130h] [bp+130h]
  int v680; // [sp+130h] [bp+130h]
  int v681; // [sp+130h] [bp+130h]
  int v682; // [sp+130h] [bp+130h]
  int v683; // [sp+130h] [bp+130h]
  int v684; // [sp+134h] [bp+134h]
  int v685; // [sp+134h] [bp+134h]
  int v686; // [sp+134h] [bp+134h]
  int v687; // [sp+134h] [bp+134h]
  unsigned int v688; // [sp+134h] [bp+134h]
  int v689; // [sp+134h] [bp+134h]
  int v690; // [sp+134h] [bp+134h]
  int v691; // [sp+134h] [bp+134h]
  unsigned int v692; // [sp+134h] [bp+134h]
  int v693; // [sp+134h] [bp+134h]
  int v694; // [sp+134h] [bp+134h]
  int v695; // [sp+134h] [bp+134h]
  unsigned int v696; // [sp+134h] [bp+134h]
  int v697; // [sp+134h] [bp+134h]
  int v698; // [sp+134h] [bp+134h]
  int v699; // [sp+134h] [bp+134h]
  unsigned int v700; // [sp+134h] [bp+134h]
  int v701; // [sp+134h] [bp+134h]
  int v702; // [sp+134h] [bp+134h]
  int v703; // [sp+134h] [bp+134h]
  unsigned int v704; // [sp+134h] [bp+134h]
  int v705; // [sp+134h] [bp+134h]
  int v706; // [sp+134h] [bp+134h]
  int v707; // [sp+134h] [bp+134h]
  int v708; // [sp+134h] [bp+134h]
  int v709; // [sp+134h] [bp+134h]
  int v710; // [sp+134h] [bp+134h]
  int v711; // [sp+134h] [bp+134h]
  int v712; // [sp+138h] [bp+138h]
  int v713; // [sp+138h] [bp+138h]
  int v714; // [sp+138h] [bp+138h]
  int v715; // [sp+138h] [bp+138h]
  unsigned int v716; // [sp+138h] [bp+138h]
  int v717; // [sp+138h] [bp+138h]
  int v718; // [sp+138h] [bp+138h]
  int v719; // [sp+138h] [bp+138h]
  unsigned int v720; // [sp+138h] [bp+138h]
  int v721; // [sp+138h] [bp+138h]
  int v722; // [sp+138h] [bp+138h]
  int v723; // [sp+138h] [bp+138h]
  unsigned int v724; // [sp+138h] [bp+138h]
  int v725; // [sp+138h] [bp+138h]
  int v726; // [sp+138h] [bp+138h]
  int v727; // [sp+138h] [bp+138h]
  unsigned int v728; // [sp+138h] [bp+138h]
  int v729; // [sp+138h] [bp+138h]
  int v730; // [sp+138h] [bp+138h]
  int v731; // [sp+138h] [bp+138h]
  unsigned int v732; // [sp+138h] [bp+138h]
  int v733; // [sp+138h] [bp+138h]
  int v734; // [sp+138h] [bp+138h]
  int v735; // [sp+138h] [bp+138h]
  int v736; // [sp+138h] [bp+138h]
  int v737; // [sp+138h] [bp+138h]
  int v738; // [sp+138h] [bp+138h]
  int v739; // [sp+138h] [bp+138h]
  int v740; // [sp+138h] [bp+138h]
  int v741; // [sp+13Ch] [bp+13Ch]
  int v742; // [sp+13Ch] [bp+13Ch]
  int v743; // [sp+13Ch] [bp+13Ch]
  int v744; // [sp+13Ch] [bp+13Ch]
  unsigned int v745; // [sp+13Ch] [bp+13Ch]
  int v746; // [sp+13Ch] [bp+13Ch]
  int v747; // [sp+13Ch] [bp+13Ch]
  int v748; // [sp+13Ch] [bp+13Ch]
  unsigned int v749; // [sp+13Ch] [bp+13Ch]
  int v750; // [sp+13Ch] [bp+13Ch]
  int v751; // [sp+13Ch] [bp+13Ch]
  int v752; // [sp+13Ch] [bp+13Ch]
  unsigned int v753; // [sp+13Ch] [bp+13Ch]
  int v754; // [sp+13Ch] [bp+13Ch]
  int v755; // [sp+13Ch] [bp+13Ch]
  int v756; // [sp+13Ch] [bp+13Ch]
  unsigned int v757; // [sp+13Ch] [bp+13Ch]
  int v758; // [sp+13Ch] [bp+13Ch]
  int v759; // [sp+13Ch] [bp+13Ch]
  int v760; // [sp+13Ch] [bp+13Ch]
  unsigned int v761; // [sp+13Ch] [bp+13Ch]
  int v762; // [sp+13Ch] [bp+13Ch]
  int v763; // [sp+13Ch] [bp+13Ch]
  int v764; // [sp+13Ch] [bp+13Ch]
  int v765; // [sp+13Ch] [bp+13Ch]
  int v766; // [sp+13Ch] [bp+13Ch]
  int v767; // [sp+13Ch] [bp+13Ch]
  int v768; // [sp+13Ch] [bp+13Ch]
  int v769; // [sp+13Ch] [bp+13Ch]
  int v770; // [sp+13Ch] [bp+13Ch]
  int v771; // [sp+140h] [bp+140h]
  int v772; // [sp+140h] [bp+140h]
  int v773; // [sp+140h] [bp+140h]
  int v774; // [sp+140h] [bp+140h]
  unsigned int v775; // [sp+140h] [bp+140h]
  int v776; // [sp+140h] [bp+140h]
  int v777; // [sp+140h] [bp+140h]
  int v778; // [sp+140h] [bp+140h]
  unsigned int v779; // [sp+140h] [bp+140h]
  int v780; // [sp+140h] [bp+140h]
  int v781; // [sp+140h] [bp+140h]
  int v782; // [sp+140h] [bp+140h]
  unsigned int v783; // [sp+140h] [bp+140h]
  int v784; // [sp+140h] [bp+140h]
  int v785; // [sp+140h] [bp+140h]
  int v786; // [sp+140h] [bp+140h]
  unsigned int v787; // [sp+140h] [bp+140h]
  int v788; // [sp+140h] [bp+140h]
  int v789; // [sp+140h] [bp+140h]
  int v790; // [sp+140h] [bp+140h]
  unsigned int v791; // [sp+140h] [bp+140h]
  int v792; // [sp+140h] [bp+140h]
  int v793; // [sp+140h] [bp+140h]
  int v794; // [sp+140h] [bp+140h]
  int v795; // [sp+140h] [bp+140h]
  int v796; // [sp+140h] [bp+140h]
  int v797; // [sp+140h] [bp+140h]
  int v798; // [sp+140h] [bp+140h]
  int v799; // [sp+140h] [bp+140h]
  int v800; // [sp+140h] [bp+140h]
  int v801; // [sp+144h] [bp+144h]
  int v802; // [sp+144h] [bp+144h]
  int v803; // [sp+144h] [bp+144h]
  int v804; // [sp+144h] [bp+144h]
  int v805; // [sp+144h] [bp+144h]
  int v806; // [sp+144h] [bp+144h]
  int v807; // [sp+144h] [bp+144h]
  int v808; // [sp+144h] [bp+144h]
  int v809; // [sp+144h] [bp+144h]
  int v810; // [sp+144h] [bp+144h]
  int v811; // [sp+144h] [bp+144h]
  int v812; // [sp+144h] [bp+144h]
  int v813; // [sp+144h] [bp+144h]
  int v814; // [sp+144h] [bp+144h]
  int v815; // [sp+144h] [bp+144h]
  int v816; // [sp+144h] [bp+144h]
  int v817; // [sp+144h] [bp+144h]
  int v818; // [sp+144h] [bp+144h]
  int v819; // [sp+144h] [bp+144h]
  int v820; // [sp+144h] [bp+144h]
  int v821; // [sp+144h] [bp+144h]
  int v822; // [sp+144h] [bp+144h]
  int v823; // [sp+144h] [bp+144h]
  int v824; // [sp+144h] [bp+144h]
  int v825; // [sp+144h] [bp+144h]
  int v826; // [sp+144h] [bp+144h]
  int v827; // [sp+144h] [bp+144h]
  int v828; // [sp+148h] [bp+148h]
  int v829; // [sp+148h] [bp+148h]
  int v830; // [sp+148h] [bp+148h]
  int v831; // [sp+148h] [bp+148h]
  int v832; // [sp+148h] [bp+148h]
  int v833; // [sp+148h] [bp+148h]
  int v834; // [sp+148h] [bp+148h]
  int v835; // [sp+148h] [bp+148h]
  int v836; // [sp+148h] [bp+148h]
  int v837; // [sp+148h] [bp+148h]
  int v838; // [sp+148h] [bp+148h]
  int v839; // [sp+148h] [bp+148h]
  int v840; // [sp+148h] [bp+148h]
  int v841; // [sp+148h] [bp+148h]
  int v842; // [sp+148h] [bp+148h]
  int v843; // [sp+148h] [bp+148h]
  int v844; // [sp+148h] [bp+148h]
  int v845; // [sp+148h] [bp+148h]
  int v846; // [sp+148h] [bp+148h]
  int v847; // [sp+148h] [bp+148h]
  int v848; // [sp+148h] [bp+148h]
  int v849; // [sp+148h] [bp+148h]
  int v850; // [sp+148h] [bp+148h]
  int v851; // [sp+148h] [bp+148h]
  int v852; // [sp+148h] [bp+148h]
  int v853; // [sp+148h] [bp+148h]
  int v854; // [sp+148h] [bp+148h]
  int v855; // [sp+14Ch] [bp+14Ch]
  int v856; // [sp+14Ch] [bp+14Ch]
  int v857; // [sp+14Ch] [bp+14Ch]
  int v858; // [sp+14Ch] [bp+14Ch]
  int v859; // [sp+14Ch] [bp+14Ch]
  int v860; // [sp+14Ch] [bp+14Ch]
  int v861; // [sp+14Ch] [bp+14Ch]
  int v862; // [sp+14Ch] [bp+14Ch]
  int v863; // [sp+14Ch] [bp+14Ch]
  int v864; // [sp+14Ch] [bp+14Ch]
  int v865; // [sp+14Ch] [bp+14Ch]
  int v866; // [sp+14Ch] [bp+14Ch]
  int v867; // [sp+14Ch] [bp+14Ch]
  int v868; // [sp+14Ch] [bp+14Ch]
  int v869; // [sp+14Ch] [bp+14Ch]
  int v870; // [sp+14Ch] [bp+14Ch]
  int v871; // [sp+14Ch] [bp+14Ch]
  int v872; // [sp+14Ch] [bp+14Ch]
  int v873; // [sp+14Ch] [bp+14Ch]
  int v874; // [sp+14Ch] [bp+14Ch]
  int v875; // [sp+14Ch] [bp+14Ch]
  int v876; // [sp+14Ch] [bp+14Ch]
  int v877; // [sp+14Ch] [bp+14Ch]
  int v878; // [sp+14Ch] [bp+14Ch]
  int v879; // [sp+14Ch] [bp+14Ch]
  int v880; // [sp+14Ch] [bp+14Ch]
  int v881; // [sp+14Ch] [bp+14Ch]
  int v882; // [sp+14Ch] [bp+14Ch]
  int v883; // [sp+150h] [bp+150h]
  int v884; // [sp+150h] [bp+150h]
  int v885; // [sp+150h] [bp+150h]
  int v886; // [sp+150h] [bp+150h]
  int v887; // [sp+150h] [bp+150h]
  int v888; // [sp+150h] [bp+150h]
  int v889; // [sp+150h] [bp+150h]
  int v890; // [sp+150h] [bp+150h]
  int v891; // [sp+150h] [bp+150h]
  int v892; // [sp+150h] [bp+150h]
  int v893; // [sp+150h] [bp+150h]
  int v894; // [sp+150h] [bp+150h]
  int v895; // [sp+150h] [bp+150h]
  int v896; // [sp+150h] [bp+150h]
  int v897; // [sp+150h] [bp+150h]
  int v898; // [sp+150h] [bp+150h]
  int v899; // [sp+150h] [bp+150h]
  int v900; // [sp+150h] [bp+150h]
  int v901; // [sp+150h] [bp+150h]
  int v902; // [sp+150h] [bp+150h]
  int v903; // [sp+150h] [bp+150h]
  int v904; // [sp+150h] [bp+150h]
  int v905; // [sp+150h] [bp+150h]
  int v906; // [sp+150h] [bp+150h]
  int v907; // [sp+150h] [bp+150h]
  int v908; // [sp+150h] [bp+150h]
  int v909; // [sp+150h] [bp+150h]
  int v910; // [sp+150h] [bp+150h]
  int v911; // [sp+154h] [bp+154h]

  v6 = result;
  v5 = a2;
  v4 = a3;
  v94 = result;
  v911 = *(_DWORD *)(result + 64);
  if ( 64 - v911 <= a3 )
  {
    v883 = *(_DWORD *)(result + 72);
    v855 = *(_DWORD *)(result + 76);
    v828 = *(_DWORD *)(result + 80);
    v801 = *(_DWORD *)(result + 84);
    v771 = *(_DWORD *)(result + 88);
    v741 = *(_DWORD *)(result + 92);
    v712 = *(_DWORD *)(result + 96);
    v684 = *(_DWORD *)(result + 100);
    v663 = *(_DWORD *)(result + 104);
    v642 = *(_DWORD *)(result + 108);
    v621 = *(_DWORD *)(result + 112);
    v600 = *(_DWORD *)(result + 116);
    v572 = *(_DWORD *)(result + 120);
    v544 = *(_DWORD *)(result + 124);
    v517 = *(_DWORD *)(result + 128);
    v490 = *(_DWORD *)(result + 132);
    v469 = *(_DWORD *)(result + 136);
    v448 = *(_DWORD *)(result + 140);
    v427 = *(_DWORD *)(result + 144);
    v406 = *(_DWORD *)(result + 148);
    v378 = *(_DWORD *)(result + 152);
    v350 = *(_DWORD *)(result + 156);
    v323 = *(_DWORD *)(result + 160);
    v303 = *(_DWORD *)(result + 164);
    v280 = *(_DWORD *)(result + 168);
    v257 = *(_DWORD *)(result + 172);
    v235 = *(_DWORD *)(result + 176);
    v213 = *(_DWORD *)(result + 180);
    v183 = *(_DWORD *)(result + 184);
    v153 = *(_DWORD *)(result + 188);
    v125 = *(_DWORD *)(result + 192);
    v97 = *(_DWORD *)(result + 196);
    while ( v4 )
    {
      n = 64 - v911;
      if ( 64 - v911 > v4 )
        n = v4;
      result = (int)memcpy((void *)(v94 + v911), v5, n);
      v911 += n;
      v5 += n;
      v4 -= n;
      if ( v911 == 64 )
      {
        v93 = sub_156E84(v94);
        v92 = sub_156E84(v94 + 4);
        v91 = sub_156E84(v94 + 8);
        v90 = sub_156E84(v94 + 12);
        v89 = sub_156E84(v94 + 16);
        v88 = sub_156E84(v94 + 20);
        v87 = sub_156E84(v94 + 24);
        v86 = sub_156E84(v94 + 28);
        v85 = sub_156E84(v94 + 32);
        v84 = sub_156E84(v94 + 36);
        v83 = sub_156E84(v94 + 40);
        v82 = sub_156E84(v94 + 44);
        v81 = sub_156E84(v94 + 48);
        v80 = sub_156E84(v94 + 52);
        v79 = sub_156E84(v94 + 56);
        result = sub_156E84(v94 + 60);
        v883 ^= v93;
        v855 ^= v92;
        v828 ^= v91;
        v801 ^= v90;
        v771 ^= v89;
        v741 ^= v88;
        v712 ^= v87;
        v684 ^= v86;
        v663 ^= v85;
        v642 ^= v84;
        v621 ^= v83;
        v600 ^= v82;
        v572 ^= v81;
        v544 ^= v80;
        v517 ^= v79;
        v490 ^= result;
        for ( i = 0; i <= 0x29; i += 7 )
        {
          v281 = ~v280;
          v884 = ~v469 & dword_1D5448[8 * i] ^ v883;
          v23 = v663 & v884 ^ dword_1D5448[8 * i];
          v885 = v281 & v469 ^ v884;
          v282 = v469 & ~v663 ^ v281;
          v664 = v469 & v885 ^ v663;
          v470 = v885 & ~v282 ^ v469;
          v886 = (v282 | v664) ^ v885;
          v283 = v470 & v664 ^ v282;
          v665 = v886 & v23 ^ v664;
          v471 = v23 ^ v470;
          v258 = ~v257;
          v856 = ~v448 & dword_1D5448[8 * i + 1] ^ v855;
          v24 = v642 & v856 ^ dword_1D5448[8 * i + 1];
          v857 = v258 & v448 ^ v856;
          v259 = v448 & ~v642 ^ v258;
          v643 = v448 & v857 ^ v642;
          v449 = v857 & ~v259 ^ v448;
          v858 = (v259 | v643) ^ v857;
          v260 = v449 & v643 ^ v259;
          v644 = v858 & v24 ^ v643;
          v450 = v24 ^ v449;
          v236 = ~v235;
          v829 = ~v427 & dword_1D5448[8 * i + 2] ^ v828;
          v25 = v621 & v829 ^ dword_1D5448[8 * i + 2];
          v830 = v236 & v427 ^ v829;
          v237 = v427 & ~v621 ^ v236;
          v622 = v427 & v830 ^ v621;
          v428 = v830 & ~v237 ^ v427;
          v831 = (v237 | v622) ^ v830;
          v238 = v428 & v622 ^ v237;
          v623 = v831 & v25 ^ v622;
          v429 = v25 ^ v428;
          v214 = ~v213;
          v802 = ~v406 & dword_1D5448[8 * i + 3] ^ v801;
          v26 = v600 & v802 ^ dword_1D5448[8 * i + 3];
          v803 = v214 & v406 ^ v802;
          v215 = v406 & ~v600 ^ v214;
          v601 = v406 & v803 ^ v600;
          v407 = v803 & ~v215 ^ v406;
          v804 = (v215 | v601) ^ v803;
          v216 = v407 & v601 ^ v215;
          v602 = v804 & v26 ^ v601;
          v408 = v26 ^ v407;
          v184 = ~v183;
          v772 = ~v378 & dword_1D5448[8 * i + 4] ^ v771;
          v27 = v572 & v772 ^ dword_1D5448[8 * i + 4];
          v773 = v184 & v378 ^ v772;
          v185 = v378 & ~v572 ^ v184;
          v573 = v378 & v773 ^ v572;
          v379 = v773 & ~v185 ^ v378;
          v774 = (v185 | v573) ^ v773;
          v186 = v379 & v573 ^ v185;
          v574 = v774 & v27 ^ v573;
          v380 = v27 ^ v379;
          v154 = ~v153;
          v742 = ~v350 & dword_1D5448[8 * i + 5] ^ v741;
          v28 = v544 & v742 ^ dword_1D5448[8 * i + 5];
          v743 = v154 & v350 ^ v742;
          v155 = v350 & ~v544 ^ v154;
          v545 = v350 & v743 ^ v544;
          v351 = v743 & ~v155 ^ v350;
          v744 = (v155 | v545) ^ v743;
          v156 = v351 & v545 ^ v155;
          v546 = v744 & v28 ^ v545;
          v352 = v28 ^ v351;
          v126 = ~v125;
          v713 = ~v323 & dword_1D5448[8 * i + 6] ^ v712;
          v29 = v517 & v713 ^ dword_1D5448[8 * i + 6];
          v714 = v126 & v323 ^ v713;
          v127 = v323 & ~v517 ^ v126;
          v518 = v323 & v714 ^ v517;
          v324 = v714 & ~v127 ^ v323;
          v715 = (v127 | v518) ^ v714;
          v128 = v324 & v518 ^ v127;
          v519 = v715 & v29 ^ v518;
          v325 = v29 ^ v324;
          v98 = ~v97;
          v685 = ~v303 & dword_1D5448[8 * i + 7] ^ v684;
          v30 = v490 & v685 ^ dword_1D5448[8 * i + 7];
          v686 = v98 & v303 ^ v685;
          v99 = v303 & ~v490 ^ v98;
          v491 = v303 & v686 ^ v490;
          v304 = v686 & ~v99 ^ v303;
          v687 = (v99 | v491) ^ v686;
          v100 = v304 & v491 ^ v99;
          v492 = v687 & v30 ^ v491;
          v775 = v665 ^ v774;
          v575 = v471 ^ v574;
          v381 = v886 ^ v283 ^ v380;
          v187 = v886 ^ v186;
          v887 = v575 ^ v886;
          v666 = v381 ^ v665;
          v472 = v775 ^ v187 ^ v471;
          v745 = v644 ^ v744;
          v547 = v450 ^ v546;
          v353 = v858 ^ v260 ^ v352;
          v157 = v858 ^ v156;
          v859 = v547 ^ v858;
          v645 = v353 ^ v644;
          v451 = v745 ^ v157 ^ v450;
          v716 = v623 ^ v715;
          v520 = v429 ^ v519;
          v326 = v831 ^ v238 ^ v325;
          v129 = v831 ^ v128;
          v832 = v520 ^ v831;
          v624 = v326 ^ v623;
          v430 = v716 ^ v129 ^ v429;
          v688 = v602 ^ v687;
          v493 = v408 ^ v492;
          v305 = v804 ^ v216 ^ v30 ^ v304;
          v101 = v804 ^ v100;
          v805 = v493 ^ v804;
          v603 = v305 ^ v602;
          v409 = v688 ^ v101 ^ v408;
          v576 = (2 * (v575 & 0x55555555)) | (v575 >> 1) & 0x55555555;
          v548 = (2 * (v547 & 0x55555555)) | (v547 >> 1) & 0x55555555;
          v521 = (2 * (v520 & 0x55555555)) | (v520 >> 1) & 0x55555555;
          v494 = (2 * (v493 & 0x55555555)) | (v493 >> 1) & 0x55555555;
          v382 = (2 * (v381 & 0x55555555)) | (v381 >> 1) & 0x55555555;
          v354 = (2 * (v353 & 0x55555555)) | (v353 >> 1) & 0x55555555;
          v327 = (2 * (v326 & 0x55555555)) | (v326 >> 1) & 0x55555555;
          v306 = (2 * (v305 & 0x55555555)) | (v305 >> 1) & 0x55555555;
          v284 = ~(v775 ^ v283);
          v888 = ~v472 & dword_1D5448[8 * i + 8] ^ v887;
          v31 = v666 & v888 ^ dword_1D5448[8 * i + 8];
          v889 = v284 & v472 ^ v888;
          v285 = v472 & ~v666 ^ v284;
          v667 = v472 & v889 ^ v666;
          v473 = v889 & ~v285 ^ v472;
          v890 = (v285 | v667) ^ v889;
          v286 = v473 & v667 ^ v285;
          v668 = v890 & v31 ^ v667;
          v474 = v31 ^ v473;
          v261 = ~(v745 ^ v260);
          v860 = ~v451 & dword_1D5448[8 * i + 9] ^ v859;
          v32 = v645 & v860 ^ dword_1D5448[8 * i + 9];
          v861 = v261 & v451 ^ v860;
          v262 = v451 & ~v645 ^ v261;
          v646 = v451 & v861 ^ v645;
          v452 = v861 & ~v262 ^ v451;
          v862 = (v262 | v646) ^ v861;
          v263 = v452 & v646 ^ v262;
          v647 = v862 & v32 ^ v646;
          v453 = v32 ^ v452;
          v239 = ~(v716 ^ v238);
          v833 = ~v430 & dword_1D5448[8 * i + 10] ^ v832;
          v33 = v624 & v833 ^ dword_1D5448[8 * i + 10];
          v834 = v239 & v430 ^ v833;
          v240 = v430 & ~v624 ^ v239;
          v625 = v430 & v834 ^ v624;
          v431 = v834 & ~v240 ^ v430;
          v835 = (v240 | v625) ^ v834;
          v241 = v431 & v625 ^ v240;
          v626 = v835 & v33 ^ v625;
          v432 = v33 ^ v431;
          v217 = ~(v688 ^ v216);
          v806 = ~v409 & dword_1D5448[8 * i + 11] ^ v805;
          v34 = v603 & v806 ^ dword_1D5448[8 * i + 11];
          v807 = v217 & v409 ^ v806;
          v218 = v409 & ~v603 ^ v217;
          v604 = v409 & v807 ^ v603;
          v410 = v807 & ~v218 ^ v409;
          v808 = (v218 | v604) ^ v807;
          v219 = v410 & v604 ^ v218;
          v605 = v808 & v34 ^ v604;
          v411 = v34 ^ v410;
          v188 = ~((2 * (v187 & 0x55555555)) | (v187 >> 1) & 0x55555555);
          v776 = ~v382 & dword_1D5448[8 * i + 12] ^ ((2 * (v775 & 0x55555555)) | (v775 >> 1) & 0x55555555);
          v35 = v576 & v776 ^ dword_1D5448[8 * i + 12];
          v777 = v188 & v382 ^ v776;
          v189 = v382 & ~v576 ^ v188;
          v577 = v382 & v777 ^ v576;
          v383 = v777 & ~v189 ^ v382;
          v778 = (v189 | v577) ^ v777;
          v190 = v383 & v577 ^ v189;
          v578 = v778 & v35 ^ v577;
          v384 = v35 ^ v383;
          v158 = ~((2 * (v157 & 0x55555555)) | (v157 >> 1) & 0x55555555);
          v746 = ~v354 & dword_1D5448[8 * i + 13] ^ ((2 * (v745 & 0x55555555)) | (v745 >> 1) & 0x55555555);
          v36 = v548 & v746 ^ dword_1D5448[8 * i + 13];
          v747 = v158 & v354 ^ v746;
          v159 = v354 & ~v548 ^ v158;
          v549 = v354 & v747 ^ v548;
          v355 = v747 & ~v159 ^ v354;
          v748 = (v159 | v549) ^ v747;
          v160 = v355 & v549 ^ v159;
          v550 = v748 & v36 ^ v549;
          v356 = v36 ^ v355;
          v130 = ~((2 * (v129 & 0x55555555)) | (v129 >> 1) & 0x55555555);
          v717 = ~v327 & dword_1D5448[8 * i + 14] ^ ((2 * (v716 & 0x55555555)) | (v716 >> 1) & 0x55555555);
          v37 = v521 & v717 ^ dword_1D5448[8 * i + 14];
          v718 = v130 & v327 ^ v717;
          v131 = v327 & ~v521 ^ v130;
          v522 = v327 & v718 ^ v521;
          v328 = v718 & ~v131 ^ v327;
          v719 = (v131 | v522) ^ v718;
          v132 = v328 & v522 ^ v131;
          v523 = v719 & v37 ^ v522;
          v329 = v37 ^ v328;
          v102 = ~((2 * (v101 & 0x55555555)) | (v101 >> 1) & 0x55555555);
          v689 = ~v306 & dword_1D5448[8 * i + 15] ^ ((2 * (v688 & 0x55555555)) | (v688 >> 1) & 0x55555555);
          v38 = v494 & v689 ^ dword_1D5448[8 * i + 15];
          v690 = v102 & v306 ^ v689;
          v103 = v306 & ~v494 ^ v102;
          v495 = v306 & v690 ^ v494;
          v307 = v690 & ~v103 ^ v306;
          v691 = (v103 | v495) ^ v690;
          v104 = v307 & v495 ^ v103;
          v496 = v691 & v38 ^ v495;
          v779 = v668 ^ v778;
          v579 = v474 ^ v578;
          v385 = v890 ^ v286 ^ v384;
          v191 = v890 ^ v190;
          v891 = v579 ^ v890;
          v669 = v385 ^ v668;
          v475 = v779 ^ v191 ^ v474;
          v749 = v647 ^ v748;
          v551 = v453 ^ v550;
          v357 = v862 ^ v263 ^ v356;
          v161 = v862 ^ v160;
          v863 = v551 ^ v862;
          v648 = v357 ^ v647;
          v454 = v749 ^ v161 ^ v453;
          v720 = v626 ^ v719;
          v524 = v432 ^ v523;
          v330 = v835 ^ v241 ^ v329;
          v133 = v835 ^ v132;
          v836 = v524 ^ v835;
          v627 = v330 ^ v626;
          v433 = v720 ^ v133 ^ v432;
          v692 = v605 ^ v691;
          v497 = v411 ^ v496;
          v308 = v808 ^ v219 ^ v38 ^ v307;
          v105 = v808 ^ v104;
          v809 = v497 ^ v808;
          v606 = v308 ^ v605;
          v412 = v692 ^ v105 ^ v411;
          v580 = (4 * (v579 & 0x33333333)) | (v579 >> 2) & 0x33333333;
          v552 = (4 * (v551 & 0x33333333)) | (v551 >> 2) & 0x33333333;
          v525 = (4 * (v524 & 0x33333333)) | (v524 >> 2) & 0x33333333;
          v498 = (4 * (v497 & 0x33333333)) | (v497 >> 2) & 0x33333333;
          v386 = (4 * (v385 & 0x33333333)) | (v385 >> 2) & 0x33333333;
          v358 = (4 * (v357 & 0x33333333)) | (v357 >> 2) & 0x33333333;
          v331 = (4 * (v330 & 0x33333333)) | (v330 >> 2) & 0x33333333;
          v309 = (4 * (v308 & 0x33333333)) | (v308 >> 2) & 0x33333333;
          v287 = ~(v779 ^ v286);
          v892 = ~v475 & dword_1D5448[8 * i + 16] ^ v891;
          v39 = v669 & v892 ^ dword_1D5448[8 * i + 16];
          v893 = v287 & v475 ^ v892;
          v288 = v475 & ~v669 ^ v287;
          v670 = v475 & v893 ^ v669;
          v476 = v893 & ~v288 ^ v475;
          v894 = (v288 | v670) ^ v893;
          v289 = v476 & v670 ^ v288;
          v671 = v894 & v39 ^ v670;
          v477 = v39 ^ v476;
          v264 = ~(v749 ^ v263);
          v864 = ~v454 & dword_1D5448[8 * i + 17] ^ v863;
          v40 = v648 & v864 ^ dword_1D5448[8 * i + 17];
          v865 = v264 & v454 ^ v864;
          v265 = v454 & ~v648 ^ v264;
          v649 = v454 & v865 ^ v648;
          v455 = v865 & ~v265 ^ v454;
          v866 = (v265 | v649) ^ v865;
          v266 = v455 & v649 ^ v265;
          v650 = v866 & v40 ^ v649;
          v456 = v40 ^ v455;
          v242 = ~(v720 ^ v241);
          v837 = ~v433 & dword_1D5448[8 * i + 18] ^ v836;
          v41 = v627 & v837 ^ dword_1D5448[8 * i + 18];
          v838 = v242 & v433 ^ v837;
          v243 = v433 & ~v627 ^ v242;
          v628 = v433 & v838 ^ v627;
          v434 = v838 & ~v243 ^ v433;
          v839 = (v243 | v628) ^ v838;
          v244 = v434 & v628 ^ v243;
          v629 = v839 & v41 ^ v628;
          v435 = v41 ^ v434;
          v220 = ~(v692 ^ v219);
          v810 = ~v412 & dword_1D5448[8 * i + 19] ^ v809;
          v42 = v606 & v810 ^ dword_1D5448[8 * i + 19];
          v811 = v220 & v412 ^ v810;
          v221 = v412 & ~v606 ^ v220;
          v607 = v412 & v811 ^ v606;
          v413 = v811 & ~v221 ^ v412;
          v812 = (v221 | v607) ^ v811;
          v222 = v413 & v607 ^ v221;
          v608 = v812 & v42 ^ v607;
          v414 = v42 ^ v413;
          v192 = ~((4 * (v191 & 0x33333333)) | (v191 >> 2) & 0x33333333);
          v780 = ~v386 & dword_1D5448[8 * i + 20] ^ ((4 * (v779 & 0x33333333)) | (v779 >> 2) & 0x33333333);
          v43 = v580 & v780 ^ dword_1D5448[8 * i + 20];
          v781 = v192 & v386 ^ v780;
          v193 = v386 & ~v580 ^ v192;
          v581 = v386 & v781 ^ v580;
          v387 = v781 & ~v193 ^ v386;
          v782 = (v193 | v581) ^ v781;
          v194 = v387 & v581 ^ v193;
          v582 = v782 & v43 ^ v581;
          v388 = v43 ^ v387;
          v162 = ~((4 * (v161 & 0x33333333)) | (v161 >> 2) & 0x33333333);
          v750 = ~v358 & dword_1D5448[8 * i + 21] ^ ((4 * (v749 & 0x33333333)) | (v749 >> 2) & 0x33333333);
          v44 = v552 & v750 ^ dword_1D5448[8 * i + 21];
          v751 = v162 & v358 ^ v750;
          v163 = v358 & ~v552 ^ v162;
          v553 = v358 & v751 ^ v552;
          v359 = v751 & ~v163 ^ v358;
          v752 = (v163 | v553) ^ v751;
          v164 = v359 & v553 ^ v163;
          v554 = v752 & v44 ^ v553;
          v360 = v44 ^ v359;
          v134 = ~((4 * (v133 & 0x33333333)) | (v133 >> 2) & 0x33333333);
          v721 = ~v331 & dword_1D5448[8 * i + 22] ^ ((4 * (v720 & 0x33333333)) | (v720 >> 2) & 0x33333333);
          v45 = v525 & v721 ^ dword_1D5448[8 * i + 22];
          v722 = v134 & v331 ^ v721;
          v135 = v331 & ~v525 ^ v134;
          v526 = v331 & v722 ^ v525;
          v332 = v722 & ~v135 ^ v331;
          v723 = (v135 | v526) ^ v722;
          v136 = v332 & v526 ^ v135;
          v527 = v723 & v45 ^ v526;
          v333 = v45 ^ v332;
          v106 = ~((4 * (v105 & 0x33333333)) | (v105 >> 2) & 0x33333333);
          v693 = ~v309 & dword_1D5448[8 * i + 23] ^ ((4 * (v692 & 0x33333333)) | (v692 >> 2) & 0x33333333);
          v46 = v498 & v693 ^ dword_1D5448[8 * i + 23];
          v694 = v106 & v309 ^ v693;
          v107 = v309 & ~v498 ^ v106;
          v499 = v309 & v694 ^ v498;
          v310 = v694 & ~v107 ^ v309;
          v695 = (v107 | v499) ^ v694;
          v108 = v310 & v499 ^ v107;
          v500 = v695 & v46 ^ v499;
          v783 = v671 ^ v782;
          v583 = v477 ^ v582;
          v389 = v894 ^ v289 ^ v388;
          v195 = v894 ^ v194;
          v895 = v583 ^ v894;
          v672 = v389 ^ v671;
          v478 = v783 ^ v195 ^ v477;
          v753 = v650 ^ v752;
          v555 = v456 ^ v554;
          v361 = v866 ^ v266 ^ v360;
          v165 = v866 ^ v164;
          v867 = v555 ^ v866;
          v651 = v361 ^ v650;
          v457 = v753 ^ v165 ^ v456;
          v724 = v629 ^ v723;
          v528 = v435 ^ v527;
          v334 = v839 ^ v244 ^ v333;
          v137 = v839 ^ v136;
          v840 = v528 ^ v839;
          v630 = v334 ^ v629;
          v436 = v724 ^ v137 ^ v435;
          v696 = v608 ^ v695;
          v501 = v414 ^ v500;
          v311 = v812 ^ v222 ^ v46 ^ v310;
          v109 = v812 ^ v108;
          v813 = v501 ^ v812;
          v609 = v311 ^ v608;
          v415 = v696 ^ v109 ^ v414;
          v584 = (16 * (v583 & 0xF0F0F0F)) | (v583 >> 4) & 0xF0F0F0F;
          v556 = (16 * (v555 & 0xF0F0F0F)) | (v555 >> 4) & 0xF0F0F0F;
          v529 = (16 * (v528 & 0xF0F0F0F)) | (v528 >> 4) & 0xF0F0F0F;
          v502 = (16 * (v501 & 0xF0F0F0F)) | (v501 >> 4) & 0xF0F0F0F;
          v390 = (16 * (v389 & 0xF0F0F0F)) | (v389 >> 4) & 0xF0F0F0F;
          v362 = (16 * (v361 & 0xF0F0F0F)) | (v361 >> 4) & 0xF0F0F0F;
          v335 = (16 * (v334 & 0xF0F0F0F)) | (v334 >> 4) & 0xF0F0F0F;
          v312 = (16 * (v311 & 0xF0F0F0F)) | (v311 >> 4) & 0xF0F0F0F;
          v290 = ~(v783 ^ v289);
          v896 = ~v478 & dword_1D5448[8 * i + 24] ^ v895;
          v47 = v672 & v896 ^ dword_1D5448[8 * i + 24];
          v897 = v290 & v478 ^ v896;
          v291 = v478 & ~v672 ^ v290;
          v673 = v478 & v897 ^ v672;
          v479 = v897 & ~v291 ^ v478;
          v898 = (v291 | v673) ^ v897;
          v292 = v479 & v673 ^ v291;
          v674 = v898 & v47 ^ v673;
          v480 = v47 ^ v479;
          v267 = ~(v753 ^ v266);
          v868 = ~v457 & dword_1D5448[8 * i + 25] ^ v867;
          v48 = v651 & v868 ^ dword_1D5448[8 * i + 25];
          v869 = v267 & v457 ^ v868;
          v268 = v457 & ~v651 ^ v267;
          v652 = v457 & v869 ^ v651;
          v458 = v869 & ~v268 ^ v457;
          v870 = (v268 | v652) ^ v869;
          v269 = v458 & v652 ^ v268;
          v653 = v870 & v48 ^ v652;
          v459 = v48 ^ v458;
          v245 = ~(v724 ^ v244);
          v841 = ~v436 & dword_1D5448[8 * i + 26] ^ v840;
          v49 = v630 & v841 ^ dword_1D5448[8 * i + 26];
          v842 = v245 & v436 ^ v841;
          v246 = v436 & ~v630 ^ v245;
          v631 = v436 & v842 ^ v630;
          v437 = v842 & ~v246 ^ v436;
          v843 = (v246 | v631) ^ v842;
          v247 = v437 & v631 ^ v246;
          v632 = v843 & v49 ^ v631;
          v438 = v49 ^ v437;
          v223 = ~(v696 ^ v222);
          v814 = ~v415 & dword_1D5448[8 * i + 27] ^ v813;
          v50 = v609 & v814 ^ dword_1D5448[8 * i + 27];
          v815 = v223 & v415 ^ v814;
          v224 = v415 & ~v609 ^ v223;
          v610 = v415 & v815 ^ v609;
          v416 = v815 & ~v224 ^ v415;
          v816 = (v224 | v610) ^ v815;
          v225 = v416 & v610 ^ v224;
          v611 = v816 & v50 ^ v610;
          v417 = v50 ^ v416;
          v196 = ~((16 * (v195 & 0xF0F0F0F)) | (v195 >> 4) & 0xF0F0F0F);
          v784 = ~v390 & dword_1D5448[8 * i + 28] ^ ((16 * (v783 & 0xF0F0F0F)) | (v783 >> 4) & 0xF0F0F0F);
          v51 = v584 & v784 ^ dword_1D5448[8 * i + 28];
          v785 = v196 & v390 ^ v784;
          v197 = v390 & ~v584 ^ v196;
          v585 = v390 & v785 ^ v584;
          v391 = v785 & ~v197 ^ v390;
          v786 = (v197 | v585) ^ v785;
          v198 = v391 & v585 ^ v197;
          v586 = v786 & v51 ^ v585;
          v392 = v51 ^ v391;
          v166 = ~((16 * (v165 & 0xF0F0F0F)) | (v165 >> 4) & 0xF0F0F0F);
          v754 = ~v362 & dword_1D5448[8 * i + 29] ^ ((16 * (v753 & 0xF0F0F0F)) | (v753 >> 4) & 0xF0F0F0F);
          v52 = v556 & v754 ^ dword_1D5448[8 * i + 29];
          v755 = v166 & v362 ^ v754;
          v167 = v362 & ~v556 ^ v166;
          v557 = v362 & v755 ^ v556;
          v363 = v755 & ~v167 ^ v362;
          v756 = (v167 | v557) ^ v755;
          v168 = v363 & v557 ^ v167;
          v558 = v756 & v52 ^ v557;
          v364 = v52 ^ v363;
          v138 = ~((16 * (v137 & 0xF0F0F0F)) | (v137 >> 4) & 0xF0F0F0F);
          v725 = ~v335 & dword_1D5448[8 * i + 30] ^ ((16 * (v724 & 0xF0F0F0F)) | (v724 >> 4) & 0xF0F0F0F);
          v53 = v529 & v725 ^ dword_1D5448[8 * i + 30];
          v726 = v138 & v335 ^ v725;
          v139 = v335 & ~v529 ^ v138;
          v530 = v335 & v726 ^ v529;
          v336 = v726 & ~v139 ^ v335;
          v727 = (v139 | v530) ^ v726;
          v140 = v336 & v530 ^ v139;
          v531 = v727 & v53 ^ v530;
          v337 = v53 ^ v336;
          v110 = ~((16 * (v109 & 0xF0F0F0F)) | (v109 >> 4) & 0xF0F0F0F);
          v697 = ~v312 & dword_1D5448[8 * i + 31] ^ ((16 * (v696 & 0xF0F0F0F)) | (v696 >> 4) & 0xF0F0F0F);
          v54 = v502 & v697 ^ dword_1D5448[8 * i + 31];
          v698 = v110 & v312 ^ v697;
          v111 = v312 & ~v502 ^ v110;
          v503 = v312 & v698 ^ v502;
          v313 = v698 & ~v111 ^ v312;
          v699 = (v111 | v503) ^ v698;
          v112 = v313 & v503 ^ v111;
          v504 = v699 & v54 ^ v503;
          v787 = v674 ^ v786;
          v587 = v480 ^ v586;
          v393 = v898 ^ v292 ^ v392;
          v199 = v898 ^ v198;
          v899 = v587 ^ v898;
          v675 = v393 ^ v674;
          v481 = v787 ^ v199 ^ v480;
          v757 = v653 ^ v756;
          v559 = v459 ^ v558;
          v365 = v870 ^ v269 ^ v364;
          v169 = v870 ^ v168;
          v871 = v559 ^ v870;
          v654 = v365 ^ v653;
          v460 = v757 ^ v169 ^ v459;
          v728 = v632 ^ v727;
          v532 = v438 ^ v531;
          v338 = v843 ^ v247 ^ v337;
          v141 = v843 ^ v140;
          v844 = v532 ^ v843;
          v633 = v338 ^ v632;
          v439 = v728 ^ v141 ^ v438;
          v700 = v611 ^ v699;
          v505 = v417 ^ v504;
          v314 = v816 ^ v225 ^ v54 ^ v313;
          v113 = v816 ^ v112;
          v817 = v505 ^ v816;
          v612 = v314 ^ v611;
          v418 = v700 ^ v113 ^ v417;
          v588 = ((v587 & 0xFF00FF) << 8) | (v587 >> 8) & 0xFF00FF;
          v560 = ((v559 & 0xFF00FF) << 8) | (v559 >> 8) & 0xFF00FF;
          v533 = ((v532 & 0xFF00FF) << 8) | (v532 >> 8) & 0xFF00FF;
          v506 = ((v505 & 0xFF00FF) << 8) | (v505 >> 8) & 0xFF00FF;
          v394 = ((v393 & 0xFF00FF) << 8) | (v393 >> 8) & 0xFF00FF;
          v366 = ((v365 & 0xFF00FF) << 8) | (v365 >> 8) & 0xFF00FF;
          v339 = ((v338 & 0xFF00FF) << 8) | (v338 >> 8) & 0xFF00FF;
          v315 = ((v314 & 0xFF00FF) << 8) | (v314 >> 8) & 0xFF00FF;
          v293 = ~(v787 ^ v292);
          v900 = ~v481 & dword_1D5448[8 * i + 32] ^ v899;
          v55 = v675 & v900 ^ dword_1D5448[8 * i + 32];
          v901 = v293 & v481 ^ v900;
          v294 = v481 & ~v675 ^ v293;
          v676 = v481 & v901 ^ v675;
          v482 = v901 & ~v294 ^ v481;
          v902 = (v294 | v676) ^ v901;
          v295 = v482 & v676 ^ v294;
          v677 = v902 & v55 ^ v676;
          v483 = v55 ^ v482;
          v270 = ~(v757 ^ v269);
          v872 = ~v460 & dword_1D5448[8 * i + 33] ^ v871;
          v56 = v654 & v872 ^ dword_1D5448[8 * i + 33];
          v873 = v270 & v460 ^ v872;
          v271 = v460 & ~v654 ^ v270;
          v655 = v460 & v873 ^ v654;
          v461 = v873 & ~v271 ^ v460;
          v874 = (v271 | v655) ^ v873;
          v272 = v461 & v655 ^ v271;
          v656 = v874 & v56 ^ v655;
          v462 = v56 ^ v461;
          v248 = ~(v728 ^ v247);
          v845 = ~v439 & dword_1D5448[8 * i + 34] ^ v844;
          v57 = v633 & v845 ^ dword_1D5448[8 * i + 34];
          v846 = v248 & v439 ^ v845;
          v249 = v439 & ~v633 ^ v248;
          v634 = v439 & v846 ^ v633;
          v440 = v846 & ~v249 ^ v439;
          v847 = (v249 | v634) ^ v846;
          v250 = v440 & v634 ^ v249;
          v635 = v847 & v57 ^ v634;
          v441 = v57 ^ v440;
          v226 = ~(v700 ^ v225);
          v818 = ~v418 & dword_1D5448[8 * i + 35] ^ v817;
          v58 = v612 & v818 ^ dword_1D5448[8 * i + 35];
          v819 = v226 & v418 ^ v818;
          v227 = v418 & ~v612 ^ v226;
          v613 = v418 & v819 ^ v612;
          v419 = v819 & ~v227 ^ v418;
          v820 = (v227 | v613) ^ v819;
          v228 = v419 & v613 ^ v227;
          v614 = v820 & v58 ^ v613;
          v420 = v58 ^ v419;
          v200 = ~(((v199 & 0xFF00FF) << 8) | (v199 >> 8) & 0xFF00FF);
          v788 = ~v394 & dword_1D5448[8 * i + 36] ^ (((v787 & 0xFF00FF) << 8) | (v787 >> 8) & 0xFF00FF);
          v59 = v588 & v788 ^ dword_1D5448[8 * i + 36];
          v789 = v200 & v394 ^ v788;
          v201 = v394 & ~v588 ^ v200;
          v589 = v394 & v789 ^ v588;
          v395 = v789 & ~v201 ^ v394;
          v790 = (v201 | v589) ^ v789;
          v202 = v395 & v589 ^ v201;
          v590 = v790 & v59 ^ v589;
          v396 = v59 ^ v395;
          v170 = ~(((v169 & 0xFF00FF) << 8) | (v169 >> 8) & 0xFF00FF);
          v758 = ~v366 & dword_1D5448[8 * i + 37] ^ (((v757 & 0xFF00FF) << 8) | (v757 >> 8) & 0xFF00FF);
          v60 = v560 & v758 ^ dword_1D5448[8 * i + 37];
          v759 = v170 & v366 ^ v758;
          v171 = v366 & ~v560 ^ v170;
          v561 = v366 & v759 ^ v560;
          v367 = v759 & ~v171 ^ v366;
          v760 = (v171 | v561) ^ v759;
          v172 = v367 & v561 ^ v171;
          v562 = v760 & v60 ^ v561;
          v368 = v60 ^ v367;
          v142 = ~(((v141 & 0xFF00FF) << 8) | (v141 >> 8) & 0xFF00FF);
          v729 = ~v339 & dword_1D5448[8 * i + 38] ^ (((v728 & 0xFF00FF) << 8) | (v728 >> 8) & 0xFF00FF);
          v61 = v533 & v729 ^ dword_1D5448[8 * i + 38];
          v730 = v142 & v339 ^ v729;
          v143 = v339 & ~v533 ^ v142;
          v534 = v339 & v730 ^ v533;
          v340 = v730 & ~v143 ^ v339;
          v731 = (v143 | v534) ^ v730;
          v144 = v340 & v534 ^ v143;
          v535 = v731 & v61 ^ v534;
          v341 = v61 ^ v340;
          v114 = ~(((v113 & 0xFF00FF) << 8) | (v113 >> 8) & 0xFF00FF);
          v701 = ~v315 & dword_1D5448[8 * i + 39] ^ (((v700 & 0xFF00FF) << 8) | (v700 >> 8) & 0xFF00FF);
          v62 = v506 & v701 ^ dword_1D5448[8 * i + 39];
          v702 = v114 & v315 ^ v701;
          v115 = v315 & ~v506 ^ v114;
          v507 = v315 & v702 ^ v506;
          v316 = v702 & ~v115 ^ v315;
          v703 = (v115 | v507) ^ v702;
          v116 = v316 & v507 ^ v115;
          v508 = v703 & v62 ^ v507;
          v791 = v677 ^ v790;
          v591 = v483 ^ v590;
          v397 = v902 ^ v295 ^ v396;
          v203 = v902 ^ v202;
          v903 = v591 ^ v902;
          v678 = v397 ^ v677;
          v484 = v791 ^ v203 ^ v483;
          v761 = v656 ^ v760;
          v563 = v462 ^ v562;
          v369 = v874 ^ v272 ^ v368;
          v173 = v874 ^ v172;
          v875 = v563 ^ v874;
          v657 = v369 ^ v656;
          v463 = v761 ^ v173 ^ v462;
          v732 = v635 ^ v731;
          v536 = v441 ^ v535;
          v342 = v847 ^ v250 ^ v341;
          v145 = v847 ^ v144;
          v848 = v536 ^ v847;
          v636 = v342 ^ v635;
          v442 = v732 ^ v145 ^ v441;
          v704 = v614 ^ v703;
          v509 = v420 ^ v508;
          v317 = v820 ^ v228 ^ v62 ^ v316;
          v117 = v820 ^ v116;
          v821 = v509 ^ v820;
          v615 = v317 ^ v614;
          v421 = v704 ^ v117 ^ v420;
          v592 = (v591 << 16) | HIWORD(v591);
          v564 = (v563 << 16) | HIWORD(v563);
          v537 = (v536 << 16) | HIWORD(v536);
          v510 = (v509 << 16) | HIWORD(v509);
          v398 = (v397 << 16) | HIWORD(v397);
          v370 = (v369 << 16) | HIWORD(v369);
          v343 = (v342 << 16) | HIWORD(v342);
          v318 = (v317 << 16) | HIWORD(v317);
          v296 = ~(v791 ^ v295);
          v904 = ~v484 & dword_1D5448[8 * i + 40] ^ v903;
          v63 = v678 & v904 ^ dword_1D5448[8 * i + 40];
          v905 = v296 & v484 ^ v904;
          v297 = v484 & ~v678 ^ v296;
          v679 = v484 & v905 ^ v678;
          v485 = v905 & ~v297 ^ v484;
          v906 = (v297 | v679) ^ v905;
          v298 = v485 & v679 ^ v297;
          v680 = v906 & v63 ^ v679;
          v486 = v63 ^ v485;
          v273 = ~(v761 ^ v272);
          v876 = ~v463 & dword_1D5448[8 * i + 41] ^ v875;
          v64 = v657 & v876 ^ dword_1D5448[8 * i + 41];
          v877 = v273 & v463 ^ v876;
          v274 = v463 & ~v657 ^ v273;
          v658 = v463 & v877 ^ v657;
          v464 = v877 & ~v274 ^ v463;
          v878 = (v274 | v658) ^ v877;
          v275 = v464 & v658 ^ v274;
          v659 = v878 & v64 ^ v658;
          v465 = v64 ^ v464;
          v251 = ~(v732 ^ v250);
          v849 = ~v442 & dword_1D5448[8 * i + 42] ^ v848;
          v65 = v636 & v849 ^ dword_1D5448[8 * i + 42];
          v850 = v251 & v442 ^ v849;
          v252 = v442 & ~v636 ^ v251;
          v637 = v442 & v850 ^ v636;
          v443 = v850 & ~v252 ^ v442;
          v851 = (v252 | v637) ^ v850;
          v253 = v443 & v637 ^ v252;
          v638 = v851 & v65 ^ v637;
          v444 = v65 ^ v443;
          v229 = ~(v704 ^ v228);
          v822 = ~v421 & dword_1D5448[8 * i + 43] ^ v821;
          v66 = v615 & v822 ^ dword_1D5448[8 * i + 43];
          v823 = v229 & v421 ^ v822;
          v230 = v421 & ~v615 ^ v229;
          v616 = v421 & v823 ^ v615;
          v422 = v823 & ~v230 ^ v421;
          v824 = (v230 | v616) ^ v823;
          v231 = v422 & v616 ^ v230;
          v617 = v824 & v66 ^ v616;
          v423 = v66 ^ v422;
          v204 = ~((v203 << 16) | HIWORD(v203));
          v792 = ~v398 & dword_1D5448[8 * i + 44] ^ ((v791 << 16) | HIWORD(v791));
          v67 = v592 & v792 ^ dword_1D5448[8 * i + 44];
          v793 = v204 & v398 ^ v792;
          v205 = v398 & ~v592 ^ v204;
          v593 = v398 & v793 ^ v592;
          v399 = v793 & ~v205 ^ v398;
          v794 = (v205 | v593) ^ v793;
          v206 = v399 & v593 ^ v205;
          v594 = v794 & v67 ^ v593;
          v400 = v67 ^ v399;
          v174 = ~((v173 << 16) | HIWORD(v173));
          v762 = ~v370 & dword_1D5448[8 * i + 45] ^ ((v761 << 16) | HIWORD(v761));
          v68 = v564 & v762 ^ dword_1D5448[8 * i + 45];
          v763 = v174 & v370 ^ v762;
          v175 = v370 & ~v564 ^ v174;
          v565 = v370 & v763 ^ v564;
          v371 = v763 & ~v175 ^ v370;
          v764 = (v175 | v565) ^ v763;
          v176 = v371 & v565 ^ v175;
          v566 = v764 & v68 ^ v565;
          v372 = v68 ^ v371;
          v146 = ~((v145 << 16) | HIWORD(v145));
          v733 = ~v343 & dword_1D5448[8 * i + 46] ^ ((v732 << 16) | HIWORD(v732));
          v69 = v537 & v733 ^ dword_1D5448[8 * i + 46];
          v734 = v146 & v343 ^ v733;
          v147 = v343 & ~v537 ^ v146;
          v538 = v343 & v734 ^ v537;
          v344 = v734 & ~v147 ^ v343;
          v735 = (v147 | v538) ^ v734;
          v148 = v344 & v538 ^ v147;
          v539 = v735 & v69 ^ v538;
          v345 = v69 ^ v344;
          v118 = ~((v117 << 16) | HIWORD(v117));
          v705 = ~v318 & dword_1D5448[8 * i + 47] ^ ((v704 << 16) | HIWORD(v704));
          v70 = v510 & v705 ^ dword_1D5448[8 * i + 47];
          v706 = v118 & v318 ^ v705;
          v119 = v318 & ~v510 ^ v118;
          v511 = v318 & v706 ^ v510;
          v319 = v706 & ~v119 ^ v318;
          v707 = (v119 | v511) ^ v706;
          v120 = v319 & v511 ^ v119;
          v512 = v707 & v70 ^ v511;
          v795 = v680 ^ v794;
          v595 = v486 ^ v594;
          v401 = v906 ^ v298 ^ v400;
          v207 = v906 ^ v206;
          v907 = v595 ^ v906;
          v681 = v401 ^ v680;
          v487 = v795 ^ v207 ^ v486;
          v299 = v795 ^ v298;
          v765 = v659 ^ v764;
          v567 = v465 ^ v566;
          v373 = v878 ^ v275 ^ v372;
          v177 = v878 ^ v176;
          v879 = v567 ^ v878;
          v660 = v373 ^ v659;
          v466 = v765 ^ v177 ^ v465;
          v276 = v765 ^ v275;
          v736 = v638 ^ v735;
          v540 = v444 ^ v539;
          v346 = v851 ^ v253 ^ v345;
          v149 = v851 ^ v148;
          v639 = v346 ^ v638;
          v445 = v736 ^ v149 ^ v444;
          v708 = v617 ^ v707;
          v513 = v423 ^ v512;
          v320 = v824 ^ v231 ^ v70 ^ v319;
          v121 = v824 ^ v120;
          v618 = v320 ^ v617;
          v424 = v708 ^ v121 ^ v423;
          v21 = v795;
          v796 = v765;
          v766 = v21;
          v22 = v736;
          v19 = v595;
          v596 = v567;
          v568 = v19;
          v20 = v540;
          v17 = v401;
          v402 = v373;
          v374 = v17;
          v18 = v346;
          v15 = v207;
          v208 = v177;
          v178 = v15;
          v16 = v149;
          v300 = ~v299;
          v908 = ~v487 & dword_1D5448[8 * i + 48] ^ v907;
          v71 = v681 & v908 ^ dword_1D5448[8 * i + 48];
          v909 = v300 & v487 ^ v908;
          v301 = v487 & ~v681 ^ v300;
          v682 = v487 & v909 ^ v681;
          v488 = v909 & ~v301 ^ v487;
          v910 = (v301 | v682) ^ v909;
          v302 = v488 & v682 ^ v301;
          v683 = v910 & v71 ^ v682;
          v489 = v71 ^ v488;
          v277 = ~v276;
          v880 = ~v466 & dword_1D5448[8 * i + 49] ^ v879;
          v72 = v660 & v880 ^ dword_1D5448[8 * i + 49];
          v881 = v277 & v466 ^ v880;
          v278 = v466 & ~v660 ^ v277;
          v661 = v466 & v881 ^ v660;
          v467 = v881 & ~v278 ^ v466;
          v882 = (v278 | v661) ^ v881;
          v279 = v467 & v661 ^ v278;
          v662 = v882 & v72 ^ v661;
          v468 = v72 ^ v467;
          v254 = ~(v736 ^ v253);
          v852 = ~v445 & dword_1D5448[8 * i + 50] ^ v540 ^ v851;
          v73 = v639 & v852 ^ dword_1D5448[8 * i + 50];
          v853 = v254 & v445 ^ v852;
          v255 = v445 & ~v639 ^ v254;
          v640 = v445 & v853 ^ v639;
          v446 = v853 & ~v255 ^ v445;
          v854 = (v255 | v640) ^ v853;
          v256 = v446 & v640 ^ v255;
          v641 = v854 & v73 ^ v640;
          v447 = v73 ^ v446;
          v232 = ~(v708 ^ v231);
          v825 = ~v424 & dword_1D5448[8 * i + 51] ^ v513 ^ v824;
          v74 = v618 & v825 ^ dword_1D5448[8 * i + 51];
          v826 = v232 & v424 ^ v825;
          v233 = v424 & ~v618 ^ v232;
          v619 = v424 & v826 ^ v618;
          v425 = v826 & ~v233 ^ v424;
          v827 = (v233 | v619) ^ v826;
          v234 = v425 & v619 ^ v233;
          v620 = v827 & v74 ^ v619;
          v426 = v74 ^ v425;
          v209 = ~v208;
          v797 = ~v402 & dword_1D5448[8 * i + 52] ^ v796;
          v75 = v596 & v797 ^ dword_1D5448[8 * i + 52];
          v798 = v209 & v402 ^ v797;
          v210 = v402 & ~v596 ^ v209;
          v597 = v402 & v798 ^ v596;
          v403 = v798 & ~v210 ^ v402;
          v799 = (v210 | v597) ^ v798;
          v211 = v403 & v597 ^ v210;
          v598 = v799 & v75 ^ v597;
          v404 = v75 ^ v403;
          v179 = ~v178;
          v767 = ~v374 & dword_1D5448[8 * i + 53] ^ v766;
          v76 = v568 & v767 ^ dword_1D5448[8 * i + 53];
          v768 = v179 & v374 ^ v767;
          v180 = v374 & ~v568 ^ v179;
          v569 = v374 & v768 ^ v568;
          v375 = v768 & ~v180 ^ v374;
          v769 = (v180 | v569) ^ v768;
          v181 = v375 & v569 ^ v180;
          v570 = v769 & v76 ^ v569;
          v376 = v76 ^ v375;
          v737 = ~v320 & dword_1D5448[8 * i + 54] ^ v708;
          v77 = v513 & v737 ^ dword_1D5448[8 * i + 54];
          v738 = ~v121 & v320 ^ v737;
          v150 = v320 & ~v513 ^ ~v121;
          v541 = v320 & v738 ^ v513;
          v347 = v738 & ~v150 ^ v320;
          v739 = (v150 | v541) ^ v738;
          v151 = v347 & v541 ^ v150;
          v542 = v739 & v77 ^ v541;
          v348 = v77 ^ v347;
          v3 = ~v18 & dword_1D5448[8 * i + 55] ^ v22;
          v78 = v20 & v3 ^ dword_1D5448[8 * i + 55];
          v709 = ~v16 & v18 ^ v3;
          v122 = v18 & ~v20 ^ ~v16;
          v514 = v18 & v709 ^ v20;
          v321 = v709 & ~v122 ^ v18;
          v710 = (v122 | v514) ^ v709;
          v123 = v321 & v514 ^ v122;
          v515 = v710 & v78 ^ v514;
          v800 = v683 ^ v799;
          v599 = v489 ^ v598;
          v405 = v910 ^ v302 ^ v404;
          v212 = v910 ^ v211;
          v883 = v599 ^ v910;
          v663 = v405 ^ v683;
          v469 = v800 ^ v212 ^ v489;
          v280 = v800 ^ v302;
          v770 = v662 ^ v769;
          v571 = v468 ^ v570;
          v377 = v882 ^ v279 ^ v376;
          v182 = v882 ^ v181;
          v855 = v571 ^ v882;
          v642 = v377 ^ v662;
          v448 = v770 ^ v182 ^ v468;
          v257 = v770 ^ v279;
          v740 = v641 ^ v739;
          v543 = v447 ^ v542;
          v349 = v854 ^ v256 ^ v348;
          v152 = v854 ^ v151;
          v828 = v543 ^ v854;
          v621 = v349 ^ v641;
          v427 = v740 ^ v152 ^ v447;
          v235 = v740 ^ v256;
          v711 = v620 ^ v710;
          v516 = v426 ^ v515;
          v322 = v827 ^ v234 ^ v78 ^ v321;
          v124 = v827 ^ v123;
          v801 = v516 ^ v827;
          v600 = v322 ^ v620;
          v406 = v711 ^ v124 ^ v426;
          v213 = v711 ^ v234;
          v13 = v800;
          v771 = v740;
          v712 = v13;
          v14 = v770;
          v741 = v711;
          v684 = v14;
          v11 = v599;
          v572 = v543;
          v517 = v11;
          v12 = v571;
          v544 = v516;
          v490 = v12;
          v9 = v405;
          v378 = v349;
          v323 = v9;
          v10 = v377;
          v350 = v322;
          v303 = v10;
          v7 = v212;
          v183 = v152;
          v125 = v7;
          v8 = v182;
          v153 = v124;
          v97 = v8;
        }
        v469 ^= v93;
        v448 ^= v92;
        v427 ^= v91;
        v406 ^= v90;
        v378 ^= v89;
        v350 ^= v88;
        v323 ^= v87;
        v303 ^= v86;
        v280 ^= v85;
        v257 ^= v84;
        v235 ^= v83;
        v213 ^= v82;
        v183 ^= v81;
        v153 ^= v80;
        v125 ^= v79;
        v97 ^= result;
        ++*(_QWORD *)(v6 + 200);
        v911 = 0;
      }
    }
    *(_DWORD *)(v6 + 72) = v883;
    *(_DWORD *)(v6 + 76) = v855;
    *(_DWORD *)(v6 + 80) = v828;
    *(_DWORD *)(v6 + 84) = v801;
    *(_DWORD *)(v6 + 88) = v771;
    *(_DWORD *)(v6 + 92) = v741;
    *(_DWORD *)(v6 + 96) = v712;
    *(_DWORD *)(v6 + 100) = v684;
    *(_DWORD *)(v6 + 104) = v663;
    *(_DWORD *)(v6 + 108) = v642;
    *(_DWORD *)(v6 + 112) = v621;
    *(_DWORD *)(v6 + 116) = v600;
    *(_DWORD *)(v6 + 120) = v572;
    *(_DWORD *)(v6 + 124) = v544;
    *(_DWORD *)(v6 + 128) = v517;
    *(_DWORD *)(v6 + 132) = v490;
    *(_DWORD *)(v6 + 136) = v469;
    *(_DWORD *)(v6 + 140) = v448;
    *(_DWORD *)(v6 + 144) = v427;
    *(_DWORD *)(v6 + 148) = v406;
    *(_DWORD *)(v6 + 152) = v378;
    *(_DWORD *)(v6 + 156) = v350;
    *(_DWORD *)(v6 + 160) = v323;
    *(_DWORD *)(v6 + 164) = v303;
    *(_DWORD *)(v6 + 168) = v280;
    *(_DWORD *)(v6 + 172) = v257;
    *(_DWORD *)(v6 + 176) = v235;
    *(_DWORD *)(v6 + 180) = v213;
    *(_DWORD *)(v6 + 184) = v183;
    *(_DWORD *)(v6 + 188) = v153;
    *(_DWORD *)(v6 + 192) = v125;
    *(_DWORD *)(v6 + 196) = v97;
    *(_DWORD *)(v6 + 64) = v911;
  }
  else
  {
    result = (int)memcpy((void *)(result + v911), a2, a3);
    *(_DWORD *)(v6 + 64) = v4 + v911;
  }
  return result;
}
// 1D5448: using guessed type _DWORD dword_1D5448[336];

//----- (0015C5E8) --------------------------------------------------------
void *__fastcall sub_15C5E8(int a1, char a2, unsigned int a3, void *a4, size_t a5, const void *a6)
{
  char v10[128]; // [sp+10h] [bp+10h] BYREF
  __int64 v11; // [sp+90h] [bp+90h]
  __int64 v12; // [sp+98h] [bp+98h]
  int v13; // [sp+A4h] [bp+A4h]
  unsigned int i; // [sp+A8h] [bp+A8h]
  size_t n; // [sp+ACh] [bp+ACh]

  v13 = 128 >> a3;
  v10[0] = (128 >> a3) | a2 & -(128 >> a3);
  if ( *(_DWORD *)(a1 + 64) || a3 )
    n = 111 - *(_DWORD *)(a1 + 64);
  else
    n = 47;
  memset(&v10[1], 0, n);
  v12 = a3 + (*(_QWORD *)(a1 + 200) << 9) + (unsigned int)(8 * *(_DWORD *)(a1 + 64));
  v11 = *(_DWORD *)(a1 + 204) >> 23;
  sub_156E9C(&v10[n + 1], (int)&v10[n + 1], v11, SHIDWORD(v11));
  sub_156E9C(&v10[n + 9], (int)&v10[n + 9], v12, SHIDWORD(v12));
  sub_156F8C(a1, v10, n + 17);
  for ( i = 0; i <= 0xF; ++i )
    sub_156E40((int)&v10[4 * i], *(_DWORD *)(a1 + 4 * (i + 34)));
  memcpy(a4, &v10[4 * (16 - a5)], 4 * a5);
  return sub_156F58((_DWORD *)a1, a6);
}

//----- (0015C74C) --------------------------------------------------------
void *__fastcall sph_jh224_init(_DWORD *a1)
{
  return sub_156F58(a1, &unk_1D5988);
}

//----- (0015C76C) --------------------------------------------------------
int __fastcall sph_jh224(int a1, char *a2, size_t a3)
{
  return sub_156F8C(a1, a2, a3);
}

//----- (0015C78C) --------------------------------------------------------
void *__fastcall sph_jh224_close(int a1, void *a2)
{
  return sub_15C5E8(a1, 0, 0, a2, 7u, &unk_1D5988);
}

//----- (0015C7B8) --------------------------------------------------------
void *__fastcall sph_jh224_addbits_and_close(int a1, char a2, unsigned int a3, void *a4)
{
  return sub_15C5E8(a1, a2, a3, a4, 7u, &unk_1D5988);
}

//----- (0015C7E8) --------------------------------------------------------
void *__fastcall sph_jh256_init(_DWORD *a1)
{
  return sub_156F58(a1, &unk_1D5A08);
}

//----- (0015C808) --------------------------------------------------------
int __fastcall sph_jh256(int a1, char *a2, size_t a3)
{
  return sub_156F8C(a1, a2, a3);
}

//----- (0015C828) --------------------------------------------------------
void *__fastcall sph_jh256_close(int a1, void *a2)
{
  return sub_15C5E8(a1, 0, 0, a2, 8u, &unk_1D5A08);
}

//----- (0015C854) --------------------------------------------------------
void *__fastcall sph_jh256_addbits_and_close(int a1, char a2, unsigned int a3, void *a4)
{
  return sub_15C5E8(a1, a2, a3, a4, 8u, &unk_1D5A08);
}

//----- (0015C884) --------------------------------------------------------
void *__fastcall sph_jh384_init(_DWORD *a1)
{
  return sub_156F58(a1, &unk_1D5A88);
}

//----- (0015C8A4) --------------------------------------------------------
int __fastcall sph_jh384(int a1, char *a2, size_t a3)
{
  return sub_156F8C(a1, a2, a3);
}

//----- (0015C8C4) --------------------------------------------------------
void *__fastcall sph_jh384_close(int a1, void *a2)
{
  return sub_15C5E8(a1, 0, 0, a2, 0xCu, &unk_1D5A88);
}

//----- (0015C8F0) --------------------------------------------------------
void *__fastcall sph_jh384_addbits_and_close(int a1, char a2, unsigned int a3, void *a4)
{
  return sub_15C5E8(a1, a2, a3, a4, 0xCu, &unk_1D5A88);
}

//----- (0015C920) --------------------------------------------------------
void *__fastcall sph_jh512_init(_DWORD *a1)
{
  return sub_156F58(a1, &unk_1D5B08);
}

//----- (0015C940) --------------------------------------------------------
int __fastcall sph_jh512(int a1, char *a2, size_t a3)
{
  return sub_156F8C(a1, a2, a3);
}

//----- (0015C960) --------------------------------------------------------
void *__fastcall sph_jh512_close(int a1, void *a2)
{
  return sub_15C5E8(a1, 0, 0, a2, 0x10u, &unk_1D5B08);
}

//----- (0015C98C) --------------------------------------------------------
void *__fastcall sph_jh512_addbits_and_close(int a1, char a2, unsigned int a3, void *a4)
{
  return sub_15C5E8(a1, a2, a3, a4, 0x10u, &unk_1D5B08);
}

//----- (0015C9BC) --------------------------------------------------------
unsigned int __fastcall sub_15C9BC(int a1)
{
  int v1; // t2

  v1 = __ROR4__(a1, 16);
  return ((v1 & 0xFF00FF) << 8) | ((v1 & 0xFF00FF00) >> 8);
}

//----- (0015C9F0) --------------------------------------------------------
_BYTE *__fastcall sub_15C9F0(_BYTE *result, int a2)
{
  *result = HIBYTE(a2);
  result[1] = BYTE2(a2);
  result[2] = BYTE1(a2);
  result[3] = a2;
  return result;
}

//----- (0015CA34) --------------------------------------------------------
unsigned int __fastcall sub_15CA34(int *a1)
{
  return sub_15C9BC(*a1);
}

//----- (0015CA50) --------------------------------------------------------
unsigned int __fastcall sub_15CA50(unsigned int result, char *a2, size_t a3)
{
  size_t n; // [sp+4h] [bp+4h]
  char *src; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+14h] [bp+14h]
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int v9; // [sp+18h] [bp+18h]
  int v10; // [sp+1Ch] [bp+1Ch]
  int v11; // [sp+1Ch] [bp+1Ch]
  int v12; // [sp+20h] [bp+20h]
  int v13; // [sp+20h] [bp+20h]
  int v14; // [sp+24h] [bp+24h]
  int v15; // [sp+24h] [bp+24h]
  int v16; // [sp+28h] [bp+28h]
  int v17; // [sp+28h] [bp+28h]
  int v18; // [sp+34h] [bp+34h]
  int v19; // [sp+38h] [bp+38h]
  int v20; // [sp+3Ch] [bp+3Ch]
  int v21; // [sp+40h] [bp+40h]
  int v22; // [sp+44h] [bp+44h]
  int v23; // [sp+48h] [bp+48h]
  int v24; // [sp+4Ch] [bp+4Ch]
  int v25; // [sp+50h] [bp+50h]
  unsigned int v26; // [sp+5Ch] [bp+5Ch]
  unsigned int v27; // [sp+60h] [bp+60h]
  unsigned int v28; // [sp+64h] [bp+64h]
  unsigned int v29; // [sp+68h] [bp+68h]
  unsigned int v30; // [sp+6Ch] [bp+6Ch]
  unsigned int v31; // [sp+70h] [bp+70h]
  unsigned int v32; // [sp+74h] [bp+74h]
  int *v33; // [sp+78h] [bp+78h]
  int i; // [sp+7Ch] [bp+7Ch]
  int j; // [sp+7Ch] [bp+7Ch]
  int k; // [sp+7Ch] [bp+7Ch]
  size_t v37; // [sp+80h] [bp+80h]
  int v38; // [sp+84h] [bp+84h]
  int v39; // [sp+84h] [bp+84h]
  int v40; // [sp+84h] [bp+84h]
  int v41; // [sp+84h] [bp+84h]
  int v42; // [sp+84h] [bp+84h]
  int v43; // [sp+84h] [bp+84h]
  int v44; // [sp+88h] [bp+88h]
  int v45; // [sp+88h] [bp+88h]
  int v46; // [sp+88h] [bp+88h]
  int v47; // [sp+88h] [bp+88h]
  int v48; // [sp+88h] [bp+88h]
  int v49; // [sp+88h] [bp+88h]
  int v50; // [sp+8Ch] [bp+8Ch]
  int v51; // [sp+8Ch] [bp+8Ch]
  int v52; // [sp+8Ch] [bp+8Ch]
  int v53; // [sp+8Ch] [bp+8Ch]
  int v54; // [sp+90h] [bp+90h]
  int v55; // [sp+90h] [bp+90h]
  int v56; // [sp+90h] [bp+90h]
  int v57; // [sp+90h] [bp+90h]
  int v58; // [sp+90h] [bp+90h]
  int v59; // [sp+90h] [bp+90h]
  int v60; // [sp+94h] [bp+94h]
  int v61; // [sp+94h] [bp+94h]
  int v62; // [sp+94h] [bp+94h]
  int v63; // [sp+94h] [bp+94h]
  int v64; // [sp+94h] [bp+94h]
  int v65; // [sp+98h] [bp+98h]
  int v66; // [sp+98h] [bp+98h]
  int v67; // [sp+98h] [bp+98h]
  int v68; // [sp+98h] [bp+98h]
  int v69; // [sp+98h] [bp+98h]
  int v70; // [sp+9Ch] [bp+9Ch]
  int v71; // [sp+9Ch] [bp+9Ch]
  int v72; // [sp+9Ch] [bp+9Ch]
  int v73; // [sp+9Ch] [bp+9Ch]
  int v74; // [sp+9Ch] [bp+9Ch]
  int v75; // [sp+A0h] [bp+A0h]
  int v76; // [sp+A0h] [bp+A0h]
  int v77; // [sp+A0h] [bp+A0h]
  int v78; // [sp+A4h] [bp+A4h]
  int v79; // [sp+A4h] [bp+A4h]
  int v80; // [sp+A4h] [bp+A4h]
  int v81; // [sp+A4h] [bp+A4h]
  int v82; // [sp+A4h] [bp+A4h]
  int v83; // [sp+A4h] [bp+A4h]
  int v84; // [sp+A8h] [bp+A8h]
  int v85; // [sp+A8h] [bp+A8h]
  int v86; // [sp+A8h] [bp+A8h]
  int v87; // [sp+A8h] [bp+A8h]
  int v88; // [sp+A8h] [bp+A8h]
  int v89; // [sp+A8h] [bp+A8h]
  int v90; // [sp+ACh] [bp+ACh]
  int v91; // [sp+ACh] [bp+ACh]
  int v92; // [sp+ACh] [bp+ACh]
  int v93; // [sp+ACh] [bp+ACh]
  int v94; // [sp+B0h] [bp+B0h]
  int v95; // [sp+B0h] [bp+B0h]
  int v96; // [sp+B0h] [bp+B0h]
  int v97; // [sp+B0h] [bp+B0h]
  int v98; // [sp+B0h] [bp+B0h]
  int v99; // [sp+B0h] [bp+B0h]
  int v100; // [sp+B4h] [bp+B4h]
  int v101; // [sp+B4h] [bp+B4h]
  int v102; // [sp+B4h] [bp+B4h]
  int v103; // [sp+B4h] [bp+B4h]
  int v104; // [sp+B4h] [bp+B4h]
  int v105; // [sp+B8h] [bp+B8h]
  int v106; // [sp+B8h] [bp+B8h]
  int v107; // [sp+B8h] [bp+B8h]
  int v108; // [sp+B8h] [bp+B8h]
  int v109; // [sp+B8h] [bp+B8h]
  int v110; // [sp+BCh] [bp+BCh]
  int v111; // [sp+BCh] [bp+BCh]
  int v112; // [sp+BCh] [bp+BCh]
  int v113; // [sp+BCh] [bp+BCh]
  int v114; // [sp+BCh] [bp+BCh]
  int v115; // [sp+C0h] [bp+C0h]
  int v116; // [sp+C0h] [bp+C0h]
  int v117; // [sp+C0h] [bp+C0h]
  int v118; // [sp+C4h] [bp+C4h]
  int v119; // [sp+C4h] [bp+C4h]
  int v120; // [sp+C4h] [bp+C4h]
  int v121; // [sp+C4h] [bp+C4h]
  int v122; // [sp+C4h] [bp+C4h]
  int v123; // [sp+C4h] [bp+C4h]
  int v124; // [sp+C8h] [bp+C8h]
  int v125; // [sp+C8h] [bp+C8h]
  int v126; // [sp+C8h] [bp+C8h]
  int v127; // [sp+C8h] [bp+C8h]
  int v128; // [sp+C8h] [bp+C8h]
  int v129; // [sp+C8h] [bp+C8h]
  int v130; // [sp+CCh] [bp+CCh]
  int v131; // [sp+CCh] [bp+CCh]
  int v132; // [sp+CCh] [bp+CCh]
  int v133; // [sp+CCh] [bp+CCh]
  int v134; // [sp+D0h] [bp+D0h]
  int v135; // [sp+D0h] [bp+D0h]
  int v136; // [sp+D0h] [bp+D0h]
  int v137; // [sp+D0h] [bp+D0h]
  int v138; // [sp+D0h] [bp+D0h]
  int v139; // [sp+D0h] [bp+D0h]
  int v140; // [sp+D4h] [bp+D4h]
  int v141; // [sp+D4h] [bp+D4h]
  int v142; // [sp+D4h] [bp+D4h]
  int v143; // [sp+D4h] [bp+D4h]
  int v144; // [sp+D4h] [bp+D4h]
  int v145; // [sp+D8h] [bp+D8h]
  int v146; // [sp+D8h] [bp+D8h]
  int v147; // [sp+D8h] [bp+D8h]
  int v148; // [sp+D8h] [bp+D8h]
  int v149; // [sp+D8h] [bp+D8h]
  int v150; // [sp+DCh] [bp+DCh]
  int v151; // [sp+DCh] [bp+DCh]
  int v152; // [sp+DCh] [bp+DCh]
  int v153; // [sp+DCh] [bp+DCh]
  int v154; // [sp+DCh] [bp+DCh]
  int v155; // [sp+E0h] [bp+E0h]
  int v156; // [sp+E0h] [bp+E0h]
  int v157; // [sp+E0h] [bp+E0h]
  int v158; // [sp+E4h] [bp+E4h]

  v5 = (_DWORD *)result;
  src = a2;
  n = a3;
  v33 = (int *)result;
  v158 = *(_DWORD *)(result + 32);
  if ( 32 - v158 <= a3 )
  {
    v155 = *(_DWORD *)(result + 36);
    v150 = *(_DWORD *)(result + 40);
    v145 = *(_DWORD *)(result + 44);
    v140 = *(_DWORD *)(result + 48);
    v134 = *(_DWORD *)(result + 52);
    v130 = *(_DWORD *)(result + 56);
    v124 = *(_DWORD *)(result + 60);
    v118 = *(_DWORD *)(result + 64);
    v115 = *(_DWORD *)(result + 68);
    v110 = *(_DWORD *)(result + 72);
    v105 = *(_DWORD *)(result + 76);
    v100 = *(_DWORD *)(result + 80);
    v94 = *(_DWORD *)(result + 84);
    v90 = *(_DWORD *)(result + 88);
    v84 = *(_DWORD *)(result + 92);
    v78 = *(_DWORD *)(result + 96);
    v75 = *(_DWORD *)(result + 100);
    v70 = *(_DWORD *)(result + 104);
    v65 = *(_DWORD *)(result + 108);
    v60 = *(_DWORD *)(result + 112);
    v54 = *(_DWORD *)(result + 116);
    v50 = *(_DWORD *)(result + 120);
    v44 = *(_DWORD *)(result + 124);
    v38 = *(_DWORD *)(result + 128);
    while ( n )
    {
      v37 = 32 - v158;
      if ( 32 - v158 > n )
        v37 = n;
      result = (unsigned int)memcpy((char *)v33 + v158, src, v37);
      v158 += v37;
      src += v37;
      n -= v37;
      if ( v158 == 32 )
      {
        v32 = sub_15CA34(v33);
        v31 = sub_15CA34(v33 + 1);
        v30 = sub_15CA34(v33 + 2);
        v29 = sub_15CA34(v33 + 3);
        v28 = sub_15CA34(v33 + 4);
        v27 = sub_15CA34(v33 + 5);
        v26 = sub_15CA34(v33 + 6);
        result = sub_15CA34(v33 + 7);
        v18 = v38 ^ v78 ^ v118;
        v19 = v44 ^ v84 ^ v124;
        v20 = v50 ^ v90 ^ v130;
        v21 = v54 ^ v94 ^ v134;
        v22 = v18 ^ v60 ^ v100 ^ v140;
        v23 = v18 ^ v65 ^ v105 ^ v145;
        v24 = v70 ^ v110 ^ v150;
        v25 = v18 ^ v75 ^ v115 ^ v155;
        v155 ^= v32 ^ v18;
        v150 ^= v31 ^ v25;
        v145 ^= v30 ^ v24;
        v140 ^= v29 ^ v23;
        v134 ^= v28 ^ v22;
        v130 ^= v27 ^ v21;
        v124 ^= v26 ^ v20;
        v118 ^= result ^ v19;
        v115 ^= result ^ v18;
        v110 ^= result ^ v32 ^ v25;
        v105 ^= v31 ^ v24;
        v100 ^= result ^ v30 ^ v23;
        v75 ^= v26 ^ v18;
        v70 ^= v26 ^ result ^ v25;
        v65 ^= result ^ v32 ^ v24;
        v60 ^= v26 ^ v31 ^ v23;
        v94 = __ROR4__(result ^ v29 ^ v22 ^ v94, 31);
        v90 = __ROR4__(v28 ^ v21 ^ v90, 31);
        v84 = __ROR4__(v27 ^ v20 ^ v84, 31);
        v78 = __ROR4__(v26 ^ v19 ^ v78, 31);
        v54 = __ROR4__(v26 ^ result ^ v30 ^ v22 ^ v54, 30);
        v50 = __ROR4__(result ^ v29 ^ v21 ^ v50, 30);
        v44 = __ROR4__(v28 ^ v20 ^ v44, 30);
        v38 = __ROR4__(v27 ^ v19 ^ v38, 30);
        for ( i = 0; i <= 7; ++i )
        {
          v16 = v155;
          v146 = v140 ^ v145;
          v156 = v140 ^ (v150 | v155);
          v141 = v16 & v140;
          v151 = v141 ^ ~v150;
          v142 = v146 ^ v141;
          v147 = v151 ^ v156 & v146;
          v152 = v142 | v151;
          v17 = v152 ^ v16;
          v143 = v147 ^ v142;
          v148 = v152 & v147;
          v153 = ~v156 ^ v152;
          v14 = v130;
          v119 = v134 ^ v118;
          v131 = v134 ^ (v124 | v130);
          v135 = v14 & v134;
          v125 = v135 ^ ~v124;
          v136 = v119 ^ v135;
          v120 = v125 ^ v131 & v119;
          v126 = v136 | v125;
          v15 = v126 ^ v14;
          v137 = v120 ^ v136;
          v121 = v126 & v120;
          v127 = ~v131 ^ v126;
          v138 = v17 ^ v137;
          v157 = v138 ^ __ROR4__(v17, 30);
          v139 = v157 ^ __ROR4__(v138, 18);
          v132 = v153 ^ v15;
          v154 = v153 ^ v15 ^ __ROR4__(v153, 30);
          v133 = v154 ^ __ROR4__(v132, 18);
          v150 = v133 ^ __ROR4__(v154, 22);
          v130 = __ROR4__(v133, 31);
          v128 = v148 ^ v127;
          v149 = v128 ^ __ROR4__(v148, 30);
          v129 = v149 ^ __ROR4__(v128, 18);
          v145 = v129 ^ __ROR4__(v149, 22);
          v124 = __ROR4__(v129, 31);
          v122 = v143 ^ v121;
          v144 = v122 ^ __ROR4__(v143, 30);
          v123 = v144 ^ __ROR4__(v122, 18);
          v140 = v123 ^ __ROR4__(v144, 22);
          v118 = __ROR4__(v123, 31);
          v155 = dword_1D5C28[i] ^ v139 ^ __ROR4__(v157, 22);
          v134 = dword_1D5C48[i] ^ __ROR4__(v139, 31);
        }
        for ( j = 0; j <= 7; ++j )
        {
          v12 = v115;
          v106 = v100 ^ v105;
          v116 = v100 ^ (v110 | v115);
          v101 = v12 & v100;
          v111 = v101 ^ ~v110;
          v102 = v106 ^ v101;
          v107 = v111 ^ v116 & v106;
          v112 = v102 | v111;
          v13 = v112 ^ v12;
          v103 = v107 ^ v102;
          v108 = v112 & v107;
          v113 = ~v116 ^ v112;
          v10 = v90;
          v79 = v94 ^ v78;
          v91 = v94 ^ (v84 | v90);
          v95 = v10 & v94;
          v85 = v95 ^ ~v84;
          v96 = v79 ^ v95;
          v80 = v85 ^ v91 & v79;
          v86 = v96 | v85;
          v11 = v86 ^ v10;
          v97 = v80 ^ v96;
          v81 = v86 & v80;
          v87 = ~v91 ^ v86;
          v98 = v13 ^ v97;
          v117 = v98 ^ __ROR4__(v13, 30);
          v99 = v117 ^ __ROR4__(v98, 18);
          v92 = v113 ^ v11;
          v114 = v113 ^ v11 ^ __ROR4__(v113, 30);
          v93 = v114 ^ __ROR4__(v92, 18);
          v110 = v93 ^ __ROR4__(v114, 22);
          v90 = __ROR4__(v93, 31);
          v88 = v108 ^ v87;
          v109 = v88 ^ __ROR4__(v108, 30);
          v89 = v109 ^ __ROR4__(v88, 18);
          v105 = v89 ^ __ROR4__(v109, 22);
          v84 = __ROR4__(v89, 31);
          v82 = v103 ^ v81;
          v104 = v82 ^ __ROR4__(v103, 30);
          v83 = v104 ^ __ROR4__(v82, 18);
          v100 = v83 ^ __ROR4__(v104, 22);
          v78 = __ROR4__(v83, 31);
          v115 = dword_1D5C68[j] ^ v99 ^ __ROR4__(v117, 22);
          v94 = dword_1D5C88[j] ^ __ROR4__(v99, 31);
        }
        for ( k = 0; k <= 7; ++k )
        {
          v8 = v75;
          v66 = v60 ^ v65;
          v76 = v60 ^ (v70 | v75);
          v61 = v8 & v60;
          v71 = v61 ^ ~v70;
          v62 = v66 ^ v61;
          v67 = v71 ^ v76 & v66;
          v72 = v62 | v71;
          v9 = v72 ^ v8;
          v63 = v67 ^ v62;
          v68 = v72 & v67;
          v73 = ~v76 ^ v72;
          v6 = v50;
          v39 = v54 ^ v38;
          v51 = v54 ^ (v44 | v50);
          v55 = v6 & v54;
          v45 = v55 ^ ~v44;
          v56 = v39 ^ v55;
          v40 = v45 ^ v51 & v39;
          v46 = v56 | v45;
          v7 = v46 ^ v6;
          v57 = v40 ^ v56;
          v41 = v46 & v40;
          v47 = ~v51 ^ v46;
          v58 = v9 ^ v57;
          v77 = v58 ^ __ROR4__(v9, 30);
          v59 = v77 ^ __ROR4__(v58, 18);
          v52 = v73 ^ v7;
          v74 = v73 ^ v7 ^ __ROR4__(v73, 30);
          v53 = v74 ^ __ROR4__(v52, 18);
          v70 = v53 ^ __ROR4__(v74, 22);
          v50 = __ROR4__(v53, 31);
          v48 = v68 ^ v47;
          v69 = v48 ^ __ROR4__(v68, 30);
          v49 = v69 ^ __ROR4__(v48, 18);
          v65 = v49 ^ __ROR4__(v69, 22);
          v44 = __ROR4__(v49, 31);
          v42 = v63 ^ v41;
          v64 = v42 ^ __ROR4__(v63, 30);
          v43 = v64 ^ __ROR4__(v42, 18);
          v60 = v43 ^ __ROR4__(v64, 22);
          v38 = __ROR4__(v43, 31);
          v75 = dword_1D5CA8[k] ^ v59 ^ __ROR4__(v77, 22);
          v54 = dword_1D5CC8[k] ^ __ROR4__(v59, 31);
        }
        v158 = 0;
      }
    }
    v5[9] = v155;
    v5[10] = v150;
    v5[11] = v145;
    v5[12] = v140;
    v5[13] = v134;
    v5[14] = v130;
    v5[15] = v124;
    v5[16] = v118;
    v5[17] = v115;
    v5[18] = v110;
    v5[19] = v105;
    v5[20] = v100;
    v5[21] = v94;
    v5[22] = v90;
    v5[23] = v84;
    v5[24] = v78;
    v5[25] = v75;
    v5[26] = v70;
    v5[27] = v65;
    v5[28] = v60;
    v5[29] = v54;
    v5[30] = v50;
    v5[31] = v44;
    v5[32] = v38;
    v5[8] = v158;
  }
  else
  {
    result = (unsigned int)memcpy((void *)(v158 + result), a2, a3);
    v5[8] = n + v158;
  }
  return result;
}
// 1D5C28: using guessed type _DWORD dword_1D5C28[8];
// 1D5C48: using guessed type _DWORD dword_1D5C48[8];
// 1D5C68: using guessed type _DWORD dword_1D5C68[8];
// 1D5C88: using guessed type _DWORD dword_1D5C88[8];
// 1D5CA8: using guessed type _DWORD dword_1D5CA8[8];
// 1D5CC8: using guessed type _DWORD dword_1D5CC8[8];

//----- (0015DA48) --------------------------------------------------------
_BYTE *__fastcall sub_15DA48(int *a1, char a2, char a3, _BYTE *a4, unsigned int a5)
{
  int v5; // r3
  unsigned int v6; // r0
  _BYTE *result; // r0
  int v10; // [sp+18h] [bp+18h]
  int v11; // [sp+18h] [bp+18h]
  int v12; // [sp+1Ch] [bp+1Ch]
  int v13; // [sp+1Ch] [bp+1Ch]
  int v14; // [sp+20h] [bp+20h]
  int v15; // [sp+20h] [bp+20h]
  int v16; // [sp+24h] [bp+24h]
  int v17; // [sp+24h] [bp+24h]
  int v18; // [sp+28h] [bp+28h]
  int v19; // [sp+28h] [bp+28h]
  int v20; // [sp+2Ch] [bp+2Ch]
  int v21; // [sp+2Ch] [bp+2Ch]
  int v22; // [sp+38h] [bp+38h]
  int v23; // [sp+3Ch] [bp+3Ch]
  int v24; // [sp+40h] [bp+40h]
  int v25; // [sp+44h] [bp+44h]
  int v26; // [sp+48h] [bp+48h]
  int v27; // [sp+4Ch] [bp+4Ch]
  int v28; // [sp+50h] [bp+50h]
  int v29; // [sp+54h] [bp+54h]
  unsigned int v30; // [sp+60h] [bp+60h]
  unsigned int v31; // [sp+64h] [bp+64h]
  unsigned int v32; // [sp+68h] [bp+68h]
  unsigned int v33; // [sp+6Ch] [bp+6Ch]
  unsigned int v34; // [sp+70h] [bp+70h]
  unsigned int v35; // [sp+74h] [bp+74h]
  unsigned int v36; // [sp+78h] [bp+78h]
  int j; // [sp+88h] [bp+88h]
  int k; // [sp+88h] [bp+88h]
  int m; // [sp+88h] [bp+88h]
  int v41; // [sp+8Ch] [bp+8Ch]
  int v42; // [sp+8Ch] [bp+8Ch]
  int v43; // [sp+8Ch] [bp+8Ch]
  int v44; // [sp+8Ch] [bp+8Ch]
  int v45; // [sp+8Ch] [bp+8Ch]
  int v46; // [sp+8Ch] [bp+8Ch]
  int v47; // [sp+90h] [bp+90h]
  int v48; // [sp+90h] [bp+90h]
  int v49; // [sp+90h] [bp+90h]
  int v50; // [sp+90h] [bp+90h]
  int v51; // [sp+90h] [bp+90h]
  int v52; // [sp+90h] [bp+90h]
  int v53; // [sp+94h] [bp+94h]
  int v54; // [sp+94h] [bp+94h]
  int v55; // [sp+94h] [bp+94h]
  int v56; // [sp+94h] [bp+94h]
  int v57; // [sp+98h] [bp+98h]
  int v58; // [sp+98h] [bp+98h]
  int v59; // [sp+98h] [bp+98h]
  int v60; // [sp+98h] [bp+98h]
  int v61; // [sp+98h] [bp+98h]
  int v62; // [sp+98h] [bp+98h]
  int v63; // [sp+9Ch] [bp+9Ch]
  int v64; // [sp+9Ch] [bp+9Ch]
  int v65; // [sp+9Ch] [bp+9Ch]
  int v66; // [sp+9Ch] [bp+9Ch]
  int v67; // [sp+9Ch] [bp+9Ch]
  int v68; // [sp+A0h] [bp+A0h]
  int v69; // [sp+A0h] [bp+A0h]
  int v70; // [sp+A0h] [bp+A0h]
  int v71; // [sp+A0h] [bp+A0h]
  int v72; // [sp+A0h] [bp+A0h]
  int v73; // [sp+A4h] [bp+A4h]
  int v74; // [sp+A4h] [bp+A4h]
  int v75; // [sp+A4h] [bp+A4h]
  int v76; // [sp+A4h] [bp+A4h]
  int v77; // [sp+A4h] [bp+A4h]
  int v78; // [sp+A8h] [bp+A8h]
  int v79; // [sp+A8h] [bp+A8h]
  int v80; // [sp+A8h] [bp+A8h]
  int v81; // [sp+ACh] [bp+ACh]
  int v82; // [sp+ACh] [bp+ACh]
  int v83; // [sp+ACh] [bp+ACh]
  int v84; // [sp+ACh] [bp+ACh]
  int v85; // [sp+ACh] [bp+ACh]
  int v86; // [sp+ACh] [bp+ACh]
  int v87; // [sp+B0h] [bp+B0h]
  int v88; // [sp+B0h] [bp+B0h]
  int v89; // [sp+B0h] [bp+B0h]
  int v90; // [sp+B0h] [bp+B0h]
  int v91; // [sp+B0h] [bp+B0h]
  int v92; // [sp+B0h] [bp+B0h]
  int v93; // [sp+B4h] [bp+B4h]
  int v94; // [sp+B4h] [bp+B4h]
  int v95; // [sp+B4h] [bp+B4h]
  int v96; // [sp+B4h] [bp+B4h]
  int v97; // [sp+B8h] [bp+B8h]
  int v98; // [sp+B8h] [bp+B8h]
  int v99; // [sp+B8h] [bp+B8h]
  int v100; // [sp+B8h] [bp+B8h]
  int v101; // [sp+B8h] [bp+B8h]
  int v102; // [sp+B8h] [bp+B8h]
  int v103; // [sp+BCh] [bp+BCh]
  int v104; // [sp+BCh] [bp+BCh]
  int v105; // [sp+BCh] [bp+BCh]
  int v106; // [sp+BCh] [bp+BCh]
  int v107; // [sp+BCh] [bp+BCh]
  int v108; // [sp+C0h] [bp+C0h]
  int v109; // [sp+C0h] [bp+C0h]
  int v110; // [sp+C0h] [bp+C0h]
  int v111; // [sp+C0h] [bp+C0h]
  int v112; // [sp+C0h] [bp+C0h]
  int v113; // [sp+C4h] [bp+C4h]
  int v114; // [sp+C4h] [bp+C4h]
  int v115; // [sp+C4h] [bp+C4h]
  int v116; // [sp+C4h] [bp+C4h]
  int v117; // [sp+C4h] [bp+C4h]
  int v118; // [sp+C8h] [bp+C8h]
  int v119; // [sp+C8h] [bp+C8h]
  int v120; // [sp+C8h] [bp+C8h]
  int v121; // [sp+CCh] [bp+CCh]
  int v122; // [sp+CCh] [bp+CCh]
  int v123; // [sp+CCh] [bp+CCh]
  int v124; // [sp+CCh] [bp+CCh]
  int v125; // [sp+CCh] [bp+CCh]
  int v126; // [sp+CCh] [bp+CCh]
  int v127; // [sp+D0h] [bp+D0h]
  int v128; // [sp+D0h] [bp+D0h]
  int v129; // [sp+D0h] [bp+D0h]
  int v130; // [sp+D0h] [bp+D0h]
  int v131; // [sp+D0h] [bp+D0h]
  int v132; // [sp+D0h] [bp+D0h]
  int v133; // [sp+D4h] [bp+D4h]
  int v134; // [sp+D4h] [bp+D4h]
  int v135; // [sp+D4h] [bp+D4h]
  int v136; // [sp+D4h] [bp+D4h]
  int v137; // [sp+D8h] [bp+D8h]
  int v138; // [sp+D8h] [bp+D8h]
  int v139; // [sp+D8h] [bp+D8h]
  int v140; // [sp+D8h] [bp+D8h]
  int v141; // [sp+D8h] [bp+D8h]
  int v142; // [sp+D8h] [bp+D8h]
  int v143; // [sp+DCh] [bp+DCh]
  int v144; // [sp+DCh] [bp+DCh]
  int v145; // [sp+DCh] [bp+DCh]
  int v146; // [sp+DCh] [bp+DCh]
  int v147; // [sp+DCh] [bp+DCh]
  int v148; // [sp+E0h] [bp+E0h]
  int v149; // [sp+E0h] [bp+E0h]
  int v150; // [sp+E0h] [bp+E0h]
  int v151; // [sp+E0h] [bp+E0h]
  int v152; // [sp+E0h] [bp+E0h]
  int v153; // [sp+E4h] [bp+E4h]
  int v154; // [sp+E4h] [bp+E4h]
  int v155; // [sp+E4h] [bp+E4h]
  int v156; // [sp+E4h] [bp+E4h]
  int v157; // [sp+E4h] [bp+E4h]
  int v158; // [sp+E8h] [bp+E8h]
  int v159; // [sp+E8h] [bp+E8h]
  int v160; // [sp+E8h] [bp+E8h]
  int i; // [sp+ECh] [bp+ECh]

  v5 = a1[8];
  *((_BYTE *)a1 + v5) = (128 >> a3) | a2 & -(128 >> a3);
  memset((char *)a1 + v5 + 1, 0, 31 - v5);
  v158 = a1[9];
  v153 = a1[10];
  v148 = a1[11];
  v143 = a1[12];
  v137 = a1[13];
  v133 = a1[14];
  v127 = a1[15];
  v121 = a1[16];
  v118 = a1[17];
  v113 = a1[18];
  v108 = a1[19];
  v103 = a1[20];
  v97 = a1[21];
  v93 = a1[22];
  v87 = a1[23];
  v81 = a1[24];
  v78 = a1[25];
  v73 = a1[26];
  v68 = a1[27];
  v63 = a1[28];
  v57 = a1[29];
  v53 = a1[30];
  v47 = a1[31];
  v41 = a1[32];
  for ( i = 0; i <= 1; ++i )
  {
    v36 = sub_15CA34(a1);
    v35 = sub_15CA34(a1 + 1);
    v34 = sub_15CA34(a1 + 2);
    v33 = sub_15CA34(a1 + 3);
    v32 = sub_15CA34(a1 + 4);
    v31 = sub_15CA34(a1 + 5);
    v30 = sub_15CA34(a1 + 6);
    v6 = sub_15CA34(a1 + 7);
    v22 = v41 ^ v81 ^ v121;
    v23 = v47 ^ v87 ^ v127;
    v24 = v53 ^ v93 ^ v133;
    v25 = v57 ^ v97 ^ v137;
    v26 = v22 ^ v63 ^ v103 ^ v143;
    v27 = v22 ^ v68 ^ v108 ^ v148;
    v28 = v73 ^ v113 ^ v153;
    v29 = v22 ^ v78 ^ v118 ^ v158;
    v158 ^= v36 ^ v22;
    v153 ^= v35 ^ v29;
    v148 ^= v34 ^ v28;
    v143 ^= v33 ^ v27;
    v137 ^= v32 ^ v26;
    v133 ^= v31 ^ v25;
    v127 ^= v30 ^ v24;
    v121 ^= v6 ^ v23;
    v118 ^= v6 ^ v22;
    v113 ^= v6 ^ v36 ^ v29;
    v108 ^= v35 ^ v28;
    v103 ^= v6 ^ v34 ^ v27;
    v78 ^= v30 ^ v22;
    v73 ^= v30 ^ v6 ^ v29;
    v68 ^= v6 ^ v36 ^ v28;
    v63 ^= v30 ^ v35 ^ v27;
    v97 = __ROR4__(v6 ^ v33 ^ v26 ^ v97, 31);
    v93 = __ROR4__(v32 ^ v25 ^ v93, 31);
    v87 = __ROR4__(v31 ^ v24 ^ v87, 31);
    v81 = __ROR4__(v30 ^ v23 ^ v81, 31);
    v57 = __ROR4__(v30 ^ v6 ^ v34 ^ v26 ^ v57, 30);
    v53 = __ROR4__(v6 ^ v33 ^ v25 ^ v53, 30);
    v47 = __ROR4__(v32 ^ v24 ^ v47, 30);
    v41 = __ROR4__(v31 ^ v23 ^ v41, 30);
    for ( j = 0; j <= 7; ++j )
    {
      v20 = v158;
      v149 = v143 ^ v148;
      v159 = v143 ^ (v153 | v158);
      v144 = v20 & v143;
      v154 = v144 ^ ~v153;
      v145 = v149 ^ v144;
      v150 = v154 ^ v159 & v149;
      v155 = v145 | v154;
      v21 = v155 ^ v20;
      v146 = v150 ^ v145;
      v151 = v155 & v150;
      v156 = ~v159 ^ v155;
      v18 = v133;
      v122 = v137 ^ v121;
      v134 = v137 ^ (v127 | v133);
      v138 = v18 & v137;
      v128 = v138 ^ ~v127;
      v139 = v122 ^ v138;
      v123 = v128 ^ v134 & v122;
      v129 = v139 | v128;
      v19 = v129 ^ v18;
      v140 = v123 ^ v139;
      v124 = v129 & v123;
      v130 = ~v134 ^ v129;
      v141 = v21 ^ v140;
      v160 = v141 ^ __ROR4__(v21, 30);
      v142 = v160 ^ __ROR4__(v141, 18);
      v135 = v156 ^ v19;
      v157 = v156 ^ v19 ^ __ROR4__(v156, 30);
      v136 = v157 ^ __ROR4__(v135, 18);
      v153 = v136 ^ __ROR4__(v157, 22);
      v133 = __ROR4__(v136, 31);
      v131 = v151 ^ v130;
      v152 = v131 ^ __ROR4__(v151, 30);
      v132 = v152 ^ __ROR4__(v131, 18);
      v148 = v132 ^ __ROR4__(v152, 22);
      v127 = __ROR4__(v132, 31);
      v125 = v146 ^ v124;
      v147 = v125 ^ __ROR4__(v146, 30);
      v126 = v147 ^ __ROR4__(v125, 18);
      v143 = v126 ^ __ROR4__(v147, 22);
      v121 = __ROR4__(v126, 31);
      v158 = dword_1D5C28[j] ^ v142 ^ __ROR4__(v160, 22);
      v137 = dword_1D5C48[j] ^ __ROR4__(v142, 31);
    }
    for ( k = 0; k <= 7; ++k )
    {
      v16 = v118;
      v109 = v103 ^ v108;
      v119 = v103 ^ (v113 | v118);
      v104 = v16 & v103;
      v114 = v104 ^ ~v113;
      v105 = v109 ^ v104;
      v110 = v114 ^ v119 & v109;
      v115 = v105 | v114;
      v17 = v115 ^ v16;
      v106 = v110 ^ v105;
      v111 = v115 & v110;
      v116 = ~v119 ^ v115;
      v14 = v93;
      v82 = v97 ^ v81;
      v94 = v97 ^ (v87 | v93);
      v98 = v14 & v97;
      v88 = v98 ^ ~v87;
      v99 = v82 ^ v98;
      v83 = v88 ^ v94 & v82;
      v89 = v99 | v88;
      v15 = v89 ^ v14;
      v100 = v83 ^ v99;
      v84 = v89 & v83;
      v90 = ~v94 ^ v89;
      v101 = v17 ^ v100;
      v120 = v101 ^ __ROR4__(v17, 30);
      v102 = v120 ^ __ROR4__(v101, 18);
      v95 = v116 ^ v15;
      v117 = v116 ^ v15 ^ __ROR4__(v116, 30);
      v96 = v117 ^ __ROR4__(v95, 18);
      v113 = v96 ^ __ROR4__(v117, 22);
      v93 = __ROR4__(v96, 31);
      v91 = v111 ^ v90;
      v112 = v91 ^ __ROR4__(v111, 30);
      v92 = v112 ^ __ROR4__(v91, 18);
      v108 = v92 ^ __ROR4__(v112, 22);
      v87 = __ROR4__(v92, 31);
      v85 = v106 ^ v84;
      v107 = v85 ^ __ROR4__(v106, 30);
      v86 = v107 ^ __ROR4__(v85, 18);
      v103 = v86 ^ __ROR4__(v107, 22);
      v81 = __ROR4__(v86, 31);
      v118 = dword_1D5C68[k] ^ v102 ^ __ROR4__(v120, 22);
      v97 = dword_1D5C88[k] ^ __ROR4__(v102, 31);
    }
    for ( m = 0; m <= 7; ++m )
    {
      v12 = v78;
      v69 = v63 ^ v68;
      v79 = v63 ^ (v73 | v78);
      v64 = v12 & v63;
      v74 = v64 ^ ~v73;
      v65 = v69 ^ v64;
      v70 = v74 ^ v79 & v69;
      v75 = v65 | v74;
      v13 = v75 ^ v12;
      v66 = v70 ^ v65;
      v71 = v75 & v70;
      v76 = ~v79 ^ v75;
      v10 = v53;
      v42 = v57 ^ v41;
      v54 = v57 ^ (v47 | v53);
      v58 = v10 & v57;
      v48 = v58 ^ ~v47;
      v59 = v42 ^ v58;
      v43 = v48 ^ v54 & v42;
      v49 = v59 | v48;
      v11 = v49 ^ v10;
      v60 = v43 ^ v59;
      v44 = v49 & v43;
      v50 = ~v54 ^ v49;
      v61 = v13 ^ v60;
      v80 = v61 ^ __ROR4__(v13, 30);
      v62 = v80 ^ __ROR4__(v61, 18);
      v55 = v76 ^ v11;
      v77 = v76 ^ v11 ^ __ROR4__(v76, 30);
      v56 = v77 ^ __ROR4__(v55, 18);
      v73 = v56 ^ __ROR4__(v77, 22);
      v53 = __ROR4__(v56, 31);
      v51 = v71 ^ v50;
      v72 = v51 ^ __ROR4__(v71, 30);
      v52 = v72 ^ __ROR4__(v51, 18);
      v68 = v52 ^ __ROR4__(v72, 22);
      v47 = __ROR4__(v52, 31);
      v45 = v66 ^ v44;
      v67 = v45 ^ __ROR4__(v66, 30);
      v46 = v67 ^ __ROR4__(v45, 18);
      v63 = v46 ^ __ROR4__(v67, 22);
      v41 = __ROR4__(v46, 31);
      v78 = dword_1D5CA8[m] ^ v62 ^ __ROR4__(v80, 22);
      v57 = dword_1D5CC8[m] ^ __ROR4__(v62, 31);
    }
    memset(a1, 0, 0x20u);
  }
  sub_15C9F0(a4, v78 ^ v158 ^ v118);
  sub_15C9F0(a4 + 4, v73 ^ v153 ^ v113);
  sub_15C9F0(a4 + 8, v68 ^ v148 ^ v108);
  sub_15C9F0(a4 + 12, v63 ^ v143 ^ v103);
  sub_15C9F0(a4 + 16, v57 ^ v137 ^ v97);
  sub_15C9F0(a4 + 20, v53 ^ v133 ^ v93);
  result = sub_15C9F0(a4 + 24, v47 ^ v127 ^ v87);
  if ( a5 > 7 )
    return sub_15C9F0(a4 + 28, v41 ^ v121 ^ v81);
  return result;
}
// 1D5C28: using guessed type _DWORD dword_1D5C28[8];
// 1D5C48: using guessed type _DWORD dword_1D5C48[8];
// 1D5C68: using guessed type _DWORD dword_1D5C68[8];
// 1D5C88: using guessed type _DWORD dword_1D5C88[8];
// 1D5CA8: using guessed type _DWORD dword_1D5CA8[8];
// 1D5CC8: using guessed type _DWORD dword_1D5CC8[8];

//----- (0015EA68) --------------------------------------------------------
unsigned int __fastcall sub_15EA68(unsigned int result, char *a2, size_t a3)
{
  unsigned int v3; // [sp+4h] [bp+4h]
  char *v4; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+10h] [bp+10h]
  int v7; // [sp+10h] [bp+10h]
  int v8; // [sp+14h] [bp+14h]
  int v9; // [sp+14h] [bp+14h]
  int v10; // [sp+18h] [bp+18h]
  int v11; // [sp+18h] [bp+18h]
  int v12; // [sp+1Ch] [bp+1Ch]
  int v13; // [sp+1Ch] [bp+1Ch]
  int v14; // [sp+20h] [bp+20h]
  int v15; // [sp+20h] [bp+20h]
  int v16; // [sp+24h] [bp+24h]
  int v17; // [sp+24h] [bp+24h]
  int v18; // [sp+28h] [bp+28h]
  int v19; // [sp+28h] [bp+28h]
  int v20; // [sp+2Ch] [bp+2Ch]
  int v21; // [sp+2Ch] [bp+2Ch]
  int v22; // [sp+3Ch] [bp+3Ch]
  int v23; // [sp+40h] [bp+40h]
  int v24; // [sp+44h] [bp+44h]
  int v25; // [sp+4Ch] [bp+4Ch]
  int v26; // [sp+50h] [bp+50h]
  int v27; // [sp+54h] [bp+54h]
  int v28; // [sp+58h] [bp+58h]
  int v29; // [sp+5Ch] [bp+5Ch]
  int v30; // [sp+60h] [bp+60h]
  int v31; // [sp+64h] [bp+64h]
  int v32; // [sp+68h] [bp+68h]
  int v33; // [sp+6Ch] [bp+6Ch]
  int v34; // [sp+70h] [bp+70h]
  int v35; // [sp+74h] [bp+74h]
  int v36; // [sp+78h] [bp+78h]
  int v37; // [sp+7Ch] [bp+7Ch]
  int v38; // [sp+80h] [bp+80h]
  int v39; // [sp+84h] [bp+84h]
  int v40; // [sp+88h] [bp+88h]
  unsigned int v41; // [sp+94h] [bp+94h]
  unsigned int v42; // [sp+98h] [bp+98h]
  unsigned int v43; // [sp+9Ch] [bp+9Ch]
  unsigned int v44; // [sp+A0h] [bp+A0h]
  unsigned int v45; // [sp+A4h] [bp+A4h]
  unsigned int v46; // [sp+A8h] [bp+A8h]
  unsigned int v47; // [sp+ACh] [bp+ACh]
  int *v48; // [sp+B0h] [bp+B0h]
  int i; // [sp+B4h] [bp+B4h]
  int j; // [sp+B4h] [bp+B4h]
  int k; // [sp+B4h] [bp+B4h]
  int m; // [sp+B4h] [bp+B4h]
  size_t n; // [sp+B8h] [bp+B8h]
  int v54; // [sp+BCh] [bp+BCh]
  int v55; // [sp+BCh] [bp+BCh]
  int v56; // [sp+BCh] [bp+BCh]
  int v57; // [sp+BCh] [bp+BCh]
  int v58; // [sp+BCh] [bp+BCh]
  int v59; // [sp+BCh] [bp+BCh]
  int v60; // [sp+BCh] [bp+BCh]
  int v61; // [sp+BCh] [bp+BCh]
  int v62; // [sp+BCh] [bp+BCh]
  int v63; // [sp+C0h] [bp+C0h]
  int v64; // [sp+C0h] [bp+C0h]
  int v65; // [sp+C0h] [bp+C0h]
  int v66; // [sp+C0h] [bp+C0h]
  int v67; // [sp+C0h] [bp+C0h]
  int v68; // [sp+C0h] [bp+C0h]
  int v69; // [sp+C0h] [bp+C0h]
  int v70; // [sp+C0h] [bp+C0h]
  int v71; // [sp+C0h] [bp+C0h]
  int v72; // [sp+C4h] [bp+C4h]
  int v73; // [sp+C4h] [bp+C4h]
  int v74; // [sp+C4h] [bp+C4h]
  int v75; // [sp+C4h] [bp+C4h]
  int v76; // [sp+C4h] [bp+C4h]
  int v77; // [sp+C4h] [bp+C4h]
  int v78; // [sp+C4h] [bp+C4h]
  int v79; // [sp+C8h] [bp+C8h]
  int v80; // [sp+C8h] [bp+C8h]
  int v81; // [sp+C8h] [bp+C8h]
  int v82; // [sp+C8h] [bp+C8h]
  int v83; // [sp+C8h] [bp+C8h]
  int v84; // [sp+C8h] [bp+C8h]
  int v85; // [sp+C8h] [bp+C8h]
  int v86; // [sp+C8h] [bp+C8h]
  int v87; // [sp+C8h] [bp+C8h]
  int v88; // [sp+CCh] [bp+CCh]
  int v89; // [sp+CCh] [bp+CCh]
  int v90; // [sp+CCh] [bp+CCh]
  int v91; // [sp+CCh] [bp+CCh]
  int v92; // [sp+CCh] [bp+CCh]
  int v93; // [sp+CCh] [bp+CCh]
  int v94; // [sp+CCh] [bp+CCh]
  int v95; // [sp+CCh] [bp+CCh]
  int v96; // [sp+D0h] [bp+D0h]
  int v97; // [sp+D0h] [bp+D0h]
  int v98; // [sp+D0h] [bp+D0h]
  int v99; // [sp+D0h] [bp+D0h]
  int v100; // [sp+D0h] [bp+D0h]
  int v101; // [sp+D0h] [bp+D0h]
  int v102; // [sp+D0h] [bp+D0h]
  int v103; // [sp+D0h] [bp+D0h]
  int v104; // [sp+D4h] [bp+D4h]
  int v105; // [sp+D4h] [bp+D4h]
  int v106; // [sp+D4h] [bp+D4h]
  int v107; // [sp+D4h] [bp+D4h]
  int v108; // [sp+D4h] [bp+D4h]
  int v109; // [sp+D4h] [bp+D4h]
  int v110; // [sp+D4h] [bp+D4h]
  int v111; // [sp+D4h] [bp+D4h]
  int v112; // [sp+D8h] [bp+D8h]
  int v113; // [sp+D8h] [bp+D8h]
  int v114; // [sp+D8h] [bp+D8h]
  int v115; // [sp+D8h] [bp+D8h]
  int v116; // [sp+D8h] [bp+D8h]
  int v117; // [sp+DCh] [bp+DCh]
  int v118; // [sp+DCh] [bp+DCh]
  int v119; // [sp+DCh] [bp+DCh]
  int v120; // [sp+DCh] [bp+DCh]
  int v121; // [sp+DCh] [bp+DCh]
  int v122; // [sp+DCh] [bp+DCh]
  int v123; // [sp+DCh] [bp+DCh]
  int v124; // [sp+DCh] [bp+DCh]
  int v125; // [sp+DCh] [bp+DCh]
  int v126; // [sp+E0h] [bp+E0h]
  int v127; // [sp+E0h] [bp+E0h]
  int v128; // [sp+E0h] [bp+E0h]
  int v129; // [sp+E0h] [bp+E0h]
  int v130; // [sp+E0h] [bp+E0h]
  int v131; // [sp+E0h] [bp+E0h]
  int v132; // [sp+E0h] [bp+E0h]
  int v133; // [sp+E0h] [bp+E0h]
  int v134; // [sp+E0h] [bp+E0h]
  int v135; // [sp+E4h] [bp+E4h]
  int v136; // [sp+E4h] [bp+E4h]
  int v137; // [sp+E4h] [bp+E4h]
  int v138; // [sp+E4h] [bp+E4h]
  int v139; // [sp+E4h] [bp+E4h]
  int v140; // [sp+E4h] [bp+E4h]
  int v141; // [sp+E4h] [bp+E4h]
  int v142; // [sp+E8h] [bp+E8h]
  int v143; // [sp+E8h] [bp+E8h]
  int v144; // [sp+E8h] [bp+E8h]
  int v145; // [sp+E8h] [bp+E8h]
  int v146; // [sp+E8h] [bp+E8h]
  int v147; // [sp+E8h] [bp+E8h]
  int v148; // [sp+E8h] [bp+E8h]
  int v149; // [sp+E8h] [bp+E8h]
  int v150; // [sp+E8h] [bp+E8h]
  int v151; // [sp+ECh] [bp+ECh]
  int v152; // [sp+ECh] [bp+ECh]
  int v153; // [sp+ECh] [bp+ECh]
  int v154; // [sp+ECh] [bp+ECh]
  int v155; // [sp+ECh] [bp+ECh]
  int v156; // [sp+ECh] [bp+ECh]
  int v157; // [sp+ECh] [bp+ECh]
  int v158; // [sp+ECh] [bp+ECh]
  int v159; // [sp+F0h] [bp+F0h]
  int v160; // [sp+F0h] [bp+F0h]
  int v161; // [sp+F0h] [bp+F0h]
  int v162; // [sp+F0h] [bp+F0h]
  int v163; // [sp+F0h] [bp+F0h]
  int v164; // [sp+F0h] [bp+F0h]
  int v165; // [sp+F0h] [bp+F0h]
  int v166; // [sp+F0h] [bp+F0h]
  int v167; // [sp+F4h] [bp+F4h]
  int v168; // [sp+F4h] [bp+F4h]
  int v169; // [sp+F4h] [bp+F4h]
  int v170; // [sp+F4h] [bp+F4h]
  int v171; // [sp+F4h] [bp+F4h]
  int v172; // [sp+F4h] [bp+F4h]
  int v173; // [sp+F4h] [bp+F4h]
  int v174; // [sp+F4h] [bp+F4h]
  int v175; // [sp+F8h] [bp+F8h]
  int v176; // [sp+F8h] [bp+F8h]
  int v177; // [sp+F8h] [bp+F8h]
  int v178; // [sp+F8h] [bp+F8h]
  int v179; // [sp+F8h] [bp+F8h]
  int v180; // [sp+FCh] [bp+FCh]
  int v181; // [sp+FCh] [bp+FCh]
  int v182; // [sp+FCh] [bp+FCh]
  int v183; // [sp+FCh] [bp+FCh]
  int v184; // [sp+FCh] [bp+FCh]
  int v185; // [sp+FCh] [bp+FCh]
  int v186; // [sp+FCh] [bp+FCh]
  int v187; // [sp+FCh] [bp+FCh]
  int v188; // [sp+FCh] [bp+FCh]
  int v189; // [sp+100h] [bp+100h]
  int v190; // [sp+100h] [bp+100h]
  int v191; // [sp+100h] [bp+100h]
  int v192; // [sp+100h] [bp+100h]
  int v193; // [sp+100h] [bp+100h]
  int v194; // [sp+100h] [bp+100h]
  int v195; // [sp+100h] [bp+100h]
  int v196; // [sp+100h] [bp+100h]
  int v197; // [sp+100h] [bp+100h]
  int v198; // [sp+104h] [bp+104h]
  int v199; // [sp+104h] [bp+104h]
  int v200; // [sp+104h] [bp+104h]
  int v201; // [sp+104h] [bp+104h]
  int v202; // [sp+104h] [bp+104h]
  int v203; // [sp+104h] [bp+104h]
  int v204; // [sp+104h] [bp+104h]
  int v205; // [sp+108h] [bp+108h]
  int v206; // [sp+108h] [bp+108h]
  int v207; // [sp+108h] [bp+108h]
  int v208; // [sp+108h] [bp+108h]
  int v209; // [sp+108h] [bp+108h]
  int v210; // [sp+108h] [bp+108h]
  int v211; // [sp+108h] [bp+108h]
  int v212; // [sp+108h] [bp+108h]
  int v213; // [sp+108h] [bp+108h]
  int v214; // [sp+10Ch] [bp+10Ch]
  int v215; // [sp+10Ch] [bp+10Ch]
  int v216; // [sp+10Ch] [bp+10Ch]
  int v217; // [sp+10Ch] [bp+10Ch]
  int v218; // [sp+10Ch] [bp+10Ch]
  int v219; // [sp+10Ch] [bp+10Ch]
  int v220; // [sp+10Ch] [bp+10Ch]
  int v221; // [sp+10Ch] [bp+10Ch]
  int v222; // [sp+110h] [bp+110h]
  int v223; // [sp+110h] [bp+110h]
  int v224; // [sp+110h] [bp+110h]
  int v225; // [sp+110h] [bp+110h]
  int v226; // [sp+110h] [bp+110h]
  int v227; // [sp+110h] [bp+110h]
  int v228; // [sp+110h] [bp+110h]
  int v229; // [sp+110h] [bp+110h]
  int v230; // [sp+114h] [bp+114h]
  int v231; // [sp+114h] [bp+114h]
  int v232; // [sp+114h] [bp+114h]
  int v233; // [sp+114h] [bp+114h]
  int v234; // [sp+114h] [bp+114h]
  int v235; // [sp+114h] [bp+114h]
  int v236; // [sp+114h] [bp+114h]
  int v237; // [sp+114h] [bp+114h]
  int v238; // [sp+118h] [bp+118h]
  int v239; // [sp+118h] [bp+118h]
  int v240; // [sp+118h] [bp+118h]
  int v241; // [sp+118h] [bp+118h]
  int v242; // [sp+118h] [bp+118h]
  int v243; // [sp+11Ch] [bp+11Ch]
  int v244; // [sp+11Ch] [bp+11Ch]
  int v245; // [sp+11Ch] [bp+11Ch]
  int v246; // [sp+11Ch] [bp+11Ch]
  int v247; // [sp+11Ch] [bp+11Ch]
  int v248; // [sp+11Ch] [bp+11Ch]
  int v249; // [sp+120h] [bp+120h]
  int v250; // [sp+120h] [bp+120h]
  int v251; // [sp+120h] [bp+120h]
  int v252; // [sp+120h] [bp+120h]
  int v253; // [sp+120h] [bp+120h]
  int v254; // [sp+120h] [bp+120h]
  int v255; // [sp+120h] [bp+120h]
  int v256; // [sp+124h] [bp+124h]
  int v257; // [sp+124h] [bp+124h]
  int v258; // [sp+124h] [bp+124h]
  int v259; // [sp+124h] [bp+124h]
  int v260; // [sp+124h] [bp+124h]
  int v261; // [sp+128h] [bp+128h]
  int v262; // [sp+128h] [bp+128h]
  int v263; // [sp+128h] [bp+128h]
  int v264; // [sp+128h] [bp+128h]
  int v265; // [sp+128h] [bp+128h]
  int v266; // [sp+128h] [bp+128h]
  int v267; // [sp+128h] [bp+128h]
  int v268; // [sp+12Ch] [bp+12Ch]
  int v269; // [sp+12Ch] [bp+12Ch]
  int v270; // [sp+12Ch] [bp+12Ch]
  int v271; // [sp+12Ch] [bp+12Ch]
  int v272; // [sp+12Ch] [bp+12Ch]
  int v273; // [sp+12Ch] [bp+12Ch]
  int v274; // [sp+130h] [bp+130h]
  int v275; // [sp+130h] [bp+130h]
  int v276; // [sp+130h] [bp+130h]
  int v277; // [sp+130h] [bp+130h]
  int v278; // [sp+130h] [bp+130h]
  int v279; // [sp+130h] [bp+130h]
  int v280; // [sp+134h] [bp+134h]
  int v281; // [sp+134h] [bp+134h]
  int v282; // [sp+134h] [bp+134h]
  int v283; // [sp+134h] [bp+134h]
  int v284; // [sp+134h] [bp+134h]
  int v285; // [sp+134h] [bp+134h]
  int v286; // [sp+138h] [bp+138h]
  int v287; // [sp+138h] [bp+138h]
  int v288; // [sp+138h] [bp+138h]
  int v289; // [sp+138h] [bp+138h]
  int v290; // [sp+13Ch] [bp+13Ch]

  v5 = (_DWORD *)result;
  v4 = a2;
  v3 = a3;
  v48 = (int *)result;
  v290 = *(_DWORD *)(result + 32);
  if ( 32 - v290 <= a3 )
  {
    v286 = *(_DWORD *)(result + 36);
    v280 = *(_DWORD *)(result + 40);
    v274 = *(_DWORD *)(result + 44);
    v268 = *(_DWORD *)(result + 48);
    v261 = *(_DWORD *)(result + 52);
    v256 = *(_DWORD *)(result + 56);
    v249 = *(_DWORD *)(result + 60);
    v243 = *(_DWORD *)(result + 64);
    v238 = *(_DWORD *)(result + 68);
    v230 = *(_DWORD *)(result + 72);
    v222 = *(_DWORD *)(result + 76);
    v214 = *(_DWORD *)(result + 80);
    v205 = *(_DWORD *)(result + 84);
    v198 = *(_DWORD *)(result + 88);
    v189 = *(_DWORD *)(result + 92);
    v180 = *(_DWORD *)(result + 96);
    v175 = *(_DWORD *)(result + 100);
    v167 = *(_DWORD *)(result + 104);
    v159 = *(_DWORD *)(result + 108);
    v151 = *(_DWORD *)(result + 112);
    v142 = *(_DWORD *)(result + 116);
    v135 = *(_DWORD *)(result + 120);
    v126 = *(_DWORD *)(result + 124);
    v117 = *(_DWORD *)(result + 128);
    v112 = *(_DWORD *)(result + 132);
    v104 = *(_DWORD *)(result + 136);
    v96 = *(_DWORD *)(result + 140);
    v88 = *(_DWORD *)(result + 144);
    v79 = *(_DWORD *)(result + 148);
    v72 = *(_DWORD *)(result + 152);
    v63 = *(_DWORD *)(result + 156);
    v54 = *(_DWORD *)(result + 160);
    while ( v3 )
    {
      n = 32 - v290;
      if ( 32 - v290 > v3 )
        n = v3;
      result = (unsigned int)memcpy((char *)v48 + v290, v4, n);
      v290 += n;
      v4 += n;
      v3 -= n;
      if ( v290 == 32 )
      {
        v47 = sub_15CA34(v48);
        v46 = sub_15CA34(v48 + 1);
        v45 = sub_15CA34(v48 + 2);
        v44 = sub_15CA34(v48 + 3);
        v43 = sub_15CA34(v48 + 4);
        v42 = sub_15CA34(v48 + 5);
        v41 = sub_15CA34(v48 + 6);
        result = sub_15CA34(v48 + 7);
        v25 = v54 ^ v117 ^ v180 ^ v243;
        v34 = v63 ^ v126 ^ v189 ^ v249;
        v35 = v72 ^ v135 ^ v198 ^ v256;
        v36 = v79 ^ v142 ^ v205 ^ v261;
        v37 = v25 ^ v88 ^ v151 ^ v214 ^ v268;
        v38 = v25 ^ v96 ^ v159 ^ v222 ^ v274;
        v39 = v104 ^ v167 ^ v230 ^ v280;
        v40 = v25 ^ v112 ^ v175 ^ v238 ^ v286;
        v287 = v25 ^ v286;
        v281 = v40 ^ v280;
        v275 = v39 ^ v274;
        v269 = v38 ^ v268;
        v262 = v37 ^ v261;
        v257 = v36 ^ v256;
        v250 = v35 ^ v249;
        v239 = v25 ^ v238;
        v231 = v40 ^ v230;
        v223 = v39 ^ v222;
        v215 = v38 ^ v214;
        v206 = v37 ^ v205;
        v199 = v36 ^ v198;
        v190 = v35 ^ v189;
        v181 = v34 ^ v180;
        v176 = v25 ^ v175;
        v168 = v40 ^ v167;
        v160 = v39 ^ v159;
        v152 = v38 ^ v151;
        v143 = v37 ^ v142;
        v136 = v36 ^ v135;
        v127 = v35 ^ v126;
        v118 = v34 ^ v117;
        v113 = v25 ^ v112;
        v105 = v40 ^ v104;
        v97 = v39 ^ v96;
        v89 = v38 ^ v88;
        v80 = v37 ^ v79;
        v73 = v36 ^ v72;
        v64 = v35 ^ v63;
        v55 = v34 ^ v54;
        v33 = v113 ^ v34 ^ v243;
        v32 = v105 ^ v34 ^ v243 ^ v287;
        v31 = v97 ^ v281;
        v30 = v89 ^ v34 ^ v243 ^ v275;
        v29 = v80 ^ v34 ^ v243 ^ v269;
        v28 = v73 ^ v262;
        v27 = v64 ^ v257;
        v26 = v55 ^ v250;
        v24 = v55;
        v56 = v64;
        v65 = v73;
        v74 = v80;
        v81 = v24 ^ v89;
        v90 = v24 ^ v97;
        v98 = v105;
        v106 = v24 ^ v113;
        v114 = v176 ^ v24;
        v107 = v168 ^ v106;
        v99 = v160 ^ v98;
        v91 = v152 ^ v90;
        v82 = v143 ^ v81;
        v75 = v136 ^ v74;
        v66 = v127 ^ v65;
        v57 = v118 ^ v56;
        v23 = v118;
        v119 = v127;
        v128 = v136;
        v137 = v143;
        v144 = v23 ^ v152;
        v153 = v23 ^ v160;
        v161 = v168;
        v169 = v23 ^ v176;
        v177 = v239 ^ v23;
        v170 = v231 ^ v169;
        v162 = v223 ^ v161;
        v154 = v215 ^ v153;
        v145 = v206 ^ v144;
        v138 = v199 ^ v137;
        v129 = v190 ^ v128;
        v120 = v181 ^ v119;
        v22 = v181;
        v182 = v190;
        v191 = v199;
        v200 = v206;
        v207 = v22 ^ v215;
        v216 = v22 ^ v223;
        v224 = v231;
        v232 = v22 ^ v239;
        v240 = v287 ^ v22;
        v233 = v281 ^ v232;
        v225 = v275 ^ v224;
        v217 = v269 ^ v216;
        v208 = v262 ^ v207;
        v201 = v257 ^ v200;
        v192 = v250 ^ v191;
        v183 = v34 ^ v243 ^ v182;
        v286 = v47 ^ v33;
        v280 = v46 ^ v32;
        v274 = v45 ^ v31;
        v268 = v44 ^ v30;
        v261 = v43 ^ v29;
        v256 = v42 ^ v28;
        v249 = v41 ^ v27;
        v243 = result ^ v26;
        v238 = result ^ v240;
        v230 = result ^ v47 ^ v233;
        v222 = v46 ^ v225;
        v214 = result ^ v45 ^ v217;
        v175 = v41 ^ v177;
        v167 = v41 ^ result ^ v170;
        v159 = result ^ v47 ^ v162;
        v151 = v41 ^ v46 ^ v154;
        v112 = v42 ^ v114;
        v104 = v42 ^ v41 ^ v107;
        v96 = v41 ^ result ^ v99;
        v88 = v42 ^ result ^ v47 ^ v91;
        v205 = __ROR4__(result ^ v44 ^ v208, 31);
        v198 = __ROR4__(v43 ^ v201, 31);
        v189 = __ROR4__(v42 ^ v192, 31);
        v180 = __ROR4__(v41 ^ v183, 31);
        v142 = __ROR4__(v41 ^ result ^ v45 ^ v145, 30);
        v135 = __ROR4__(result ^ v44 ^ v138, 30);
        v126 = __ROR4__(v43 ^ v129, 30);
        v117 = __ROR4__(v42 ^ v120, 30);
        v79 = __ROR4__(v42 ^ v41 ^ v46 ^ v82, 29);
        v72 = __ROR4__(v41 ^ result ^ v45 ^ v75, 29);
        v63 = __ROR4__(result ^ v44 ^ v66, 29);
        v54 = __ROR4__(v43 ^ v57, 29);
        for ( i = 0; i <= 7; ++i )
        {
          v20 = v286;
          v276 = v268 ^ v274;
          v288 = v268 ^ (v280 | v286);
          v270 = v20 & v268;
          v282 = v270 ^ ~v280;
          v271 = v276 ^ v270;
          v277 = v282 ^ v288 & v276;
          v283 = v271 | v282;
          v21 = v283 ^ v20;
          v272 = v277 ^ v271;
          v278 = v283 & v277;
          v284 = ~v288 ^ v283;
          v18 = v256;
          v244 = v261 ^ v243;
          v258 = v261 ^ (v249 | v256);
          v263 = v18 & v261;
          v251 = v263 ^ ~v249;
          v264 = v244 ^ v263;
          v245 = v251 ^ v258 & v244;
          v252 = v264 | v251;
          v19 = v252 ^ v18;
          v265 = v245 ^ v264;
          v246 = v252 & v245;
          v253 = ~v258 ^ v252;
          v266 = v21 ^ v265;
          v289 = v266 ^ __ROR4__(v21, 30);
          v267 = v289 ^ __ROR4__(v266, 18);
          v259 = v284 ^ v19;
          v285 = v284 ^ v19 ^ __ROR4__(v284, 30);
          v260 = v285 ^ __ROR4__(v259, 18);
          v280 = v260 ^ __ROR4__(v285, 22);
          v256 = __ROR4__(v260, 31);
          v254 = v278 ^ v253;
          v279 = v254 ^ __ROR4__(v278, 30);
          v255 = v279 ^ __ROR4__(v254, 18);
          v274 = v255 ^ __ROR4__(v279, 22);
          v249 = __ROR4__(v255, 31);
          v247 = v272 ^ v246;
          v273 = v247 ^ __ROR4__(v272, 30);
          v248 = v273 ^ __ROR4__(v247, 18);
          v268 = v248 ^ __ROR4__(v273, 22);
          v243 = __ROR4__(v248, 31);
          v286 = dword_1D5C28[i] ^ v267 ^ __ROR4__(v289, 22);
          v261 = dword_1D5C48[i] ^ __ROR4__(v267, 31);
        }
        for ( j = 0; j <= 7; ++j )
        {
          v16 = v238;
          v226 = v214 ^ v222;
          v241 = v214 ^ (v230 | v238);
          v218 = v16 & v214;
          v234 = v218 ^ ~v230;
          v219 = v226 ^ v218;
          v227 = v234 ^ v241 & v226;
          v235 = v219 | v234;
          v17 = v235 ^ v16;
          v220 = v227 ^ v219;
          v228 = v235 & v227;
          v236 = ~v241 ^ v235;
          v14 = v198;
          v184 = v205 ^ v180;
          v202 = v205 ^ (v189 | v198);
          v209 = v14 & v205;
          v193 = v209 ^ ~v189;
          v210 = v184 ^ v209;
          v185 = v193 ^ v202 & v184;
          v194 = v210 | v193;
          v15 = v194 ^ v14;
          v211 = v185 ^ v210;
          v186 = v194 & v185;
          v195 = ~v202 ^ v194;
          v212 = v17 ^ v211;
          v242 = v212 ^ __ROR4__(v17, 30);
          v213 = v242 ^ __ROR4__(v212, 18);
          v203 = v236 ^ v15;
          v237 = v236 ^ v15 ^ __ROR4__(v236, 30);
          v204 = v237 ^ __ROR4__(v203, 18);
          v230 = v204 ^ __ROR4__(v237, 22);
          v198 = __ROR4__(v204, 31);
          v196 = v228 ^ v195;
          v229 = v196 ^ __ROR4__(v228, 30);
          v197 = v229 ^ __ROR4__(v196, 18);
          v222 = v197 ^ __ROR4__(v229, 22);
          v189 = __ROR4__(v197, 31);
          v187 = v220 ^ v186;
          v221 = v187 ^ __ROR4__(v220, 30);
          v188 = v221 ^ __ROR4__(v187, 18);
          v214 = v188 ^ __ROR4__(v221, 22);
          v180 = __ROR4__(v188, 31);
          v238 = dword_1D5C68[j] ^ v213 ^ __ROR4__(v242, 22);
          v205 = dword_1D5C88[j] ^ __ROR4__(v213, 31);
        }
        for ( k = 0; k <= 7; ++k )
        {
          v12 = v175;
          v163 = v151 ^ v159;
          v178 = v151 ^ (v167 | v175);
          v155 = v12 & v151;
          v171 = v155 ^ ~v167;
          v156 = v163 ^ v155;
          v164 = v171 ^ v178 & v163;
          v172 = v156 | v171;
          v13 = v172 ^ v12;
          v157 = v164 ^ v156;
          v165 = v172 & v164;
          v173 = ~v178 ^ v172;
          v10 = v135;
          v121 = v142 ^ v117;
          v139 = v142 ^ (v126 | v135);
          v146 = v10 & v142;
          v130 = v146 ^ ~v126;
          v147 = v121 ^ v146;
          v122 = v130 ^ v139 & v121;
          v131 = v147 | v130;
          v11 = v131 ^ v10;
          v148 = v122 ^ v147;
          v123 = v131 & v122;
          v132 = ~v139 ^ v131;
          v149 = v13 ^ v148;
          v179 = v149 ^ __ROR4__(v13, 30);
          v150 = v179 ^ __ROR4__(v149, 18);
          v140 = v173 ^ v11;
          v174 = v173 ^ v11 ^ __ROR4__(v173, 30);
          v141 = v174 ^ __ROR4__(v140, 18);
          v167 = v141 ^ __ROR4__(v174, 22);
          v135 = __ROR4__(v141, 31);
          v133 = v165 ^ v132;
          v166 = v133 ^ __ROR4__(v165, 30);
          v134 = v166 ^ __ROR4__(v133, 18);
          v159 = v134 ^ __ROR4__(v166, 22);
          v126 = __ROR4__(v134, 31);
          v124 = v157 ^ v123;
          v158 = v124 ^ __ROR4__(v157, 30);
          v125 = v158 ^ __ROR4__(v124, 18);
          v151 = v125 ^ __ROR4__(v158, 22);
          v117 = __ROR4__(v125, 31);
          v175 = dword_1D5CA8[k] ^ v150 ^ __ROR4__(v179, 22);
          v142 = dword_1D5CC8[k] ^ __ROR4__(v150, 31);
        }
        for ( m = 0; m <= 7; ++m )
        {
          v8 = v112;
          v100 = v88 ^ v96;
          v115 = v88 ^ (v104 | v112);
          v92 = v8 & v88;
          v108 = v92 ^ ~v104;
          v93 = v100 ^ v92;
          v101 = v108 ^ v115 & v100;
          v109 = v93 | v108;
          v9 = v109 ^ v8;
          v94 = v101 ^ v93;
          v102 = v109 & v101;
          v110 = ~v115 ^ v109;
          v6 = v72;
          v58 = v79 ^ v54;
          v76 = v79 ^ (v63 | v72);
          v83 = v6 & v79;
          v67 = v83 ^ ~v63;
          v84 = v58 ^ v83;
          v59 = v67 ^ v76 & v58;
          v68 = v84 | v67;
          v7 = v68 ^ v6;
          v85 = v59 ^ v84;
          v60 = v68 & v59;
          v69 = ~v76 ^ v68;
          v86 = v9 ^ v85;
          v116 = v86 ^ __ROR4__(v9, 30);
          v87 = v116 ^ __ROR4__(v86, 18);
          v77 = v110 ^ v7;
          v111 = v110 ^ v7 ^ __ROR4__(v110, 30);
          v78 = v111 ^ __ROR4__(v77, 18);
          v104 = v78 ^ __ROR4__(v111, 22);
          v72 = __ROR4__(v78, 31);
          v70 = v102 ^ v69;
          v103 = v70 ^ __ROR4__(v102, 30);
          v71 = v103 ^ __ROR4__(v70, 18);
          v96 = v71 ^ __ROR4__(v103, 22);
          v63 = __ROR4__(v71, 31);
          v61 = v94 ^ v60;
          v95 = v61 ^ __ROR4__(v94, 30);
          v62 = v95 ^ __ROR4__(v61, 18);
          v88 = v62 ^ __ROR4__(v95, 22);
          v54 = __ROR4__(v62, 31);
          v112 = dword_1D5CE8[m] ^ v87 ^ __ROR4__(v116, 22);
          v79 = dword_1D5D08[m] ^ __ROR4__(v87, 31);
        }
        v290 = 0;
      }
    }
    v5[9] = v286;
    v5[10] = v280;
    v5[11] = v274;
    v5[12] = v268;
    v5[13] = v261;
    v5[14] = v256;
    v5[15] = v249;
    v5[16] = v243;
    v5[17] = v238;
    v5[18] = v230;
    v5[19] = v222;
    v5[20] = v214;
    v5[21] = v205;
    v5[22] = v198;
    v5[23] = v189;
    v5[24] = v180;
    v5[25] = v175;
    v5[26] = v167;
    v5[27] = v159;
    v5[28] = v151;
    v5[29] = v142;
    v5[30] = v135;
    v5[31] = v126;
    v5[32] = v117;
    v5[33] = v112;
    v5[34] = v104;
    v5[35] = v96;
    v5[36] = v88;
    v5[37] = v79;
    v5[38] = v72;
    v5[39] = v63;
    v5[40] = v54;
    v5[8] = v290;
  }
  else
  {
    result = (unsigned int)memcpy((void *)(result + v290), a2, a3);
    v5[8] = v3 + v290;
  }
  return result;
}
// 1D5C28: using guessed type _DWORD dword_1D5C28[8];
// 1D5C48: using guessed type _DWORD dword_1D5C48[8];
// 1D5C68: using guessed type _DWORD dword_1D5C68[8];
// 1D5C88: using guessed type _DWORD dword_1D5C88[8];
// 1D5CA8: using guessed type _DWORD dword_1D5CA8[8];
// 1D5CC8: using guessed type _DWORD dword_1D5CC8[8];
// 1D5CE8: using guessed type _DWORD dword_1D5CE8[8];
// 1D5D08: using guessed type _DWORD dword_1D5D08[8];

//----- (001605D0) --------------------------------------------------------
unsigned int __fastcall sub_1605D0(int *a1, char a2, char a3, _BYTE *a4)
{
  int v4; // r3
  unsigned int result; // r0
  int v7; // [sp+10h] [bp+10h]
  int v8; // [sp+10h] [bp+10h]
  int v9; // [sp+14h] [bp+14h]
  int v10; // [sp+14h] [bp+14h]
  int v11; // [sp+18h] [bp+18h]
  int v12; // [sp+18h] [bp+18h]
  int v13; // [sp+1Ch] [bp+1Ch]
  int v14; // [sp+1Ch] [bp+1Ch]
  int v15; // [sp+20h] [bp+20h]
  int v16; // [sp+20h] [bp+20h]
  int v17; // [sp+24h] [bp+24h]
  int v18; // [sp+24h] [bp+24h]
  int v19; // [sp+28h] [bp+28h]
  int v20; // [sp+28h] [bp+28h]
  int v21; // [sp+2Ch] [bp+2Ch]
  int v22; // [sp+2Ch] [bp+2Ch]
  int v23; // [sp+3Ch] [bp+3Ch]
  int v24; // [sp+40h] [bp+40h]
  int v25; // [sp+44h] [bp+44h]
  int v26; // [sp+4Ch] [bp+4Ch]
  int v27; // [sp+50h] [bp+50h]
  int v28; // [sp+54h] [bp+54h]
  int v29; // [sp+58h] [bp+58h]
  int v30; // [sp+5Ch] [bp+5Ch]
  int v31; // [sp+60h] [bp+60h]
  int v32; // [sp+64h] [bp+64h]
  int v33; // [sp+68h] [bp+68h]
  int v34; // [sp+6Ch] [bp+6Ch]
  int v35; // [sp+70h] [bp+70h]
  int v36; // [sp+74h] [bp+74h]
  int v37; // [sp+78h] [bp+78h]
  int v38; // [sp+7Ch] [bp+7Ch]
  int v39; // [sp+80h] [bp+80h]
  int v40; // [sp+84h] [bp+84h]
  int v41; // [sp+88h] [bp+88h]
  unsigned int v42; // [sp+94h] [bp+94h]
  unsigned int v43; // [sp+98h] [bp+98h]
  unsigned int v44; // [sp+9Ch] [bp+9Ch]
  unsigned int v45; // [sp+A0h] [bp+A0h]
  unsigned int v46; // [sp+A4h] [bp+A4h]
  unsigned int v47; // [sp+A8h] [bp+A8h]
  unsigned int v48; // [sp+ACh] [bp+ACh]
  int j; // [sp+C0h] [bp+C0h]
  int k; // [sp+C0h] [bp+C0h]
  int m; // [sp+C0h] [bp+C0h]
  int n; // [sp+C0h] [bp+C0h]
  int v55; // [sp+C4h] [bp+C4h]
  int v56; // [sp+C4h] [bp+C4h]
  int v57; // [sp+C4h] [bp+C4h]
  int v58; // [sp+C4h] [bp+C4h]
  int v59; // [sp+C4h] [bp+C4h]
  int v60; // [sp+C4h] [bp+C4h]
  int v61; // [sp+C4h] [bp+C4h]
  int v62; // [sp+C4h] [bp+C4h]
  int v63; // [sp+C4h] [bp+C4h]
  int v64; // [sp+C8h] [bp+C8h]
  int v65; // [sp+C8h] [bp+C8h]
  int v66; // [sp+C8h] [bp+C8h]
  int v67; // [sp+C8h] [bp+C8h]
  int v68; // [sp+C8h] [bp+C8h]
  int v69; // [sp+C8h] [bp+C8h]
  int v70; // [sp+C8h] [bp+C8h]
  int v71; // [sp+C8h] [bp+C8h]
  int v72; // [sp+C8h] [bp+C8h]
  int v73; // [sp+CCh] [bp+CCh]
  int v74; // [sp+CCh] [bp+CCh]
  int v75; // [sp+CCh] [bp+CCh]
  int v76; // [sp+CCh] [bp+CCh]
  int v77; // [sp+CCh] [bp+CCh]
  int v78; // [sp+CCh] [bp+CCh]
  int v79; // [sp+CCh] [bp+CCh]
  int v80; // [sp+D0h] [bp+D0h]
  int v81; // [sp+D0h] [bp+D0h]
  int v82; // [sp+D0h] [bp+D0h]
  int v83; // [sp+D0h] [bp+D0h]
  int v84; // [sp+D0h] [bp+D0h]
  int v85; // [sp+D0h] [bp+D0h]
  int v86; // [sp+D0h] [bp+D0h]
  int v87; // [sp+D0h] [bp+D0h]
  int v88; // [sp+D0h] [bp+D0h]
  int v89; // [sp+D4h] [bp+D4h]
  int v90; // [sp+D4h] [bp+D4h]
  int v91; // [sp+D4h] [bp+D4h]
  int v92; // [sp+D4h] [bp+D4h]
  int v93; // [sp+D4h] [bp+D4h]
  int v94; // [sp+D4h] [bp+D4h]
  int v95; // [sp+D4h] [bp+D4h]
  int v96; // [sp+D4h] [bp+D4h]
  int v97; // [sp+D8h] [bp+D8h]
  int v98; // [sp+D8h] [bp+D8h]
  int v99; // [sp+D8h] [bp+D8h]
  int v100; // [sp+D8h] [bp+D8h]
  int v101; // [sp+D8h] [bp+D8h]
  int v102; // [sp+D8h] [bp+D8h]
  int v103; // [sp+D8h] [bp+D8h]
  int v104; // [sp+D8h] [bp+D8h]
  int v105; // [sp+DCh] [bp+DCh]
  int v106; // [sp+DCh] [bp+DCh]
  int v107; // [sp+DCh] [bp+DCh]
  int v108; // [sp+DCh] [bp+DCh]
  int v109; // [sp+DCh] [bp+DCh]
  int v110; // [sp+DCh] [bp+DCh]
  int v111; // [sp+DCh] [bp+DCh]
  int v112; // [sp+DCh] [bp+DCh]
  int v113; // [sp+E0h] [bp+E0h]
  int v114; // [sp+E0h] [bp+E0h]
  int v115; // [sp+E0h] [bp+E0h]
  int v116; // [sp+E0h] [bp+E0h]
  int v117; // [sp+E0h] [bp+E0h]
  int v118; // [sp+E4h] [bp+E4h]
  int v119; // [sp+E4h] [bp+E4h]
  int v120; // [sp+E4h] [bp+E4h]
  int v121; // [sp+E4h] [bp+E4h]
  int v122; // [sp+E4h] [bp+E4h]
  int v123; // [sp+E4h] [bp+E4h]
  int v124; // [sp+E4h] [bp+E4h]
  int v125; // [sp+E4h] [bp+E4h]
  int v126; // [sp+E4h] [bp+E4h]
  int v127; // [sp+E8h] [bp+E8h]
  int v128; // [sp+E8h] [bp+E8h]
  int v129; // [sp+E8h] [bp+E8h]
  int v130; // [sp+E8h] [bp+E8h]
  int v131; // [sp+E8h] [bp+E8h]
  int v132; // [sp+E8h] [bp+E8h]
  int v133; // [sp+E8h] [bp+E8h]
  int v134; // [sp+E8h] [bp+E8h]
  int v135; // [sp+E8h] [bp+E8h]
  int v136; // [sp+ECh] [bp+ECh]
  int v137; // [sp+ECh] [bp+ECh]
  int v138; // [sp+ECh] [bp+ECh]
  int v139; // [sp+ECh] [bp+ECh]
  int v140; // [sp+ECh] [bp+ECh]
  int v141; // [sp+ECh] [bp+ECh]
  int v142; // [sp+ECh] [bp+ECh]
  int v143; // [sp+F0h] [bp+F0h]
  int v144; // [sp+F0h] [bp+F0h]
  int v145; // [sp+F0h] [bp+F0h]
  int v146; // [sp+F0h] [bp+F0h]
  int v147; // [sp+F0h] [bp+F0h]
  int v148; // [sp+F0h] [bp+F0h]
  int v149; // [sp+F0h] [bp+F0h]
  int v150; // [sp+F0h] [bp+F0h]
  int v151; // [sp+F0h] [bp+F0h]
  int v152; // [sp+F4h] [bp+F4h]
  int v153; // [sp+F4h] [bp+F4h]
  int v154; // [sp+F4h] [bp+F4h]
  int v155; // [sp+F4h] [bp+F4h]
  int v156; // [sp+F4h] [bp+F4h]
  int v157; // [sp+F4h] [bp+F4h]
  int v158; // [sp+F4h] [bp+F4h]
  int v159; // [sp+F4h] [bp+F4h]
  int v160; // [sp+F8h] [bp+F8h]
  int v161; // [sp+F8h] [bp+F8h]
  int v162; // [sp+F8h] [bp+F8h]
  int v163; // [sp+F8h] [bp+F8h]
  int v164; // [sp+F8h] [bp+F8h]
  int v165; // [sp+F8h] [bp+F8h]
  int v166; // [sp+F8h] [bp+F8h]
  int v167; // [sp+F8h] [bp+F8h]
  int v168; // [sp+FCh] [bp+FCh]
  int v169; // [sp+FCh] [bp+FCh]
  int v170; // [sp+FCh] [bp+FCh]
  int v171; // [sp+FCh] [bp+FCh]
  int v172; // [sp+FCh] [bp+FCh]
  int v173; // [sp+FCh] [bp+FCh]
  int v174; // [sp+FCh] [bp+FCh]
  int v175; // [sp+FCh] [bp+FCh]
  int v176; // [sp+100h] [bp+100h]
  int v177; // [sp+100h] [bp+100h]
  int v178; // [sp+100h] [bp+100h]
  int v179; // [sp+100h] [bp+100h]
  int v180; // [sp+100h] [bp+100h]
  int v181; // [sp+104h] [bp+104h]
  int v182; // [sp+104h] [bp+104h]
  int v183; // [sp+104h] [bp+104h]
  int v184; // [sp+104h] [bp+104h]
  int v185; // [sp+104h] [bp+104h]
  int v186; // [sp+104h] [bp+104h]
  int v187; // [sp+104h] [bp+104h]
  int v188; // [sp+104h] [bp+104h]
  int v189; // [sp+104h] [bp+104h]
  int v190; // [sp+108h] [bp+108h]
  int v191; // [sp+108h] [bp+108h]
  int v192; // [sp+108h] [bp+108h]
  int v193; // [sp+108h] [bp+108h]
  int v194; // [sp+108h] [bp+108h]
  int v195; // [sp+108h] [bp+108h]
  int v196; // [sp+108h] [bp+108h]
  int v197; // [sp+108h] [bp+108h]
  int v198; // [sp+108h] [bp+108h]
  int v199; // [sp+10Ch] [bp+10Ch]
  int v200; // [sp+10Ch] [bp+10Ch]
  int v201; // [sp+10Ch] [bp+10Ch]
  int v202; // [sp+10Ch] [bp+10Ch]
  int v203; // [sp+10Ch] [bp+10Ch]
  int v204; // [sp+10Ch] [bp+10Ch]
  int v205; // [sp+10Ch] [bp+10Ch]
  int v206; // [sp+110h] [bp+110h]
  int v207; // [sp+110h] [bp+110h]
  int v208; // [sp+110h] [bp+110h]
  int v209; // [sp+110h] [bp+110h]
  int v210; // [sp+110h] [bp+110h]
  int v211; // [sp+110h] [bp+110h]
  int v212; // [sp+110h] [bp+110h]
  int v213; // [sp+110h] [bp+110h]
  int v214; // [sp+110h] [bp+110h]
  int v215; // [sp+114h] [bp+114h]
  int v216; // [sp+114h] [bp+114h]
  int v217; // [sp+114h] [bp+114h]
  int v218; // [sp+114h] [bp+114h]
  int v219; // [sp+114h] [bp+114h]
  int v220; // [sp+114h] [bp+114h]
  int v221; // [sp+114h] [bp+114h]
  int v222; // [sp+114h] [bp+114h]
  int v223; // [sp+118h] [bp+118h]
  int v224; // [sp+118h] [bp+118h]
  int v225; // [sp+118h] [bp+118h]
  int v226; // [sp+118h] [bp+118h]
  int v227; // [sp+118h] [bp+118h]
  int v228; // [sp+118h] [bp+118h]
  int v229; // [sp+118h] [bp+118h]
  int v230; // [sp+118h] [bp+118h]
  int v231; // [sp+11Ch] [bp+11Ch]
  int v232; // [sp+11Ch] [bp+11Ch]
  int v233; // [sp+11Ch] [bp+11Ch]
  int v234; // [sp+11Ch] [bp+11Ch]
  int v235; // [sp+11Ch] [bp+11Ch]
  int v236; // [sp+11Ch] [bp+11Ch]
  int v237; // [sp+11Ch] [bp+11Ch]
  int v238; // [sp+11Ch] [bp+11Ch]
  int v239; // [sp+120h] [bp+120h]
  int v240; // [sp+120h] [bp+120h]
  int v241; // [sp+120h] [bp+120h]
  int v242; // [sp+120h] [bp+120h]
  int v243; // [sp+120h] [bp+120h]
  int v244; // [sp+124h] [bp+124h]
  int v245; // [sp+124h] [bp+124h]
  int v246; // [sp+124h] [bp+124h]
  int v247; // [sp+124h] [bp+124h]
  int v248; // [sp+124h] [bp+124h]
  int v249; // [sp+124h] [bp+124h]
  int v250; // [sp+128h] [bp+128h]
  int v251; // [sp+128h] [bp+128h]
  int v252; // [sp+128h] [bp+128h]
  int v253; // [sp+128h] [bp+128h]
  int v254; // [sp+128h] [bp+128h]
  int v255; // [sp+128h] [bp+128h]
  int v256; // [sp+128h] [bp+128h]
  int v257; // [sp+12Ch] [bp+12Ch]
  int v258; // [sp+12Ch] [bp+12Ch]
  int v259; // [sp+12Ch] [bp+12Ch]
  int v260; // [sp+12Ch] [bp+12Ch]
  int v261; // [sp+12Ch] [bp+12Ch]
  int v262; // [sp+130h] [bp+130h]
  int v263; // [sp+130h] [bp+130h]
  int v264; // [sp+130h] [bp+130h]
  int v265; // [sp+130h] [bp+130h]
  int v266; // [sp+130h] [bp+130h]
  int v267; // [sp+130h] [bp+130h]
  int v268; // [sp+130h] [bp+130h]
  int v269; // [sp+134h] [bp+134h]
  int v270; // [sp+134h] [bp+134h]
  int v271; // [sp+134h] [bp+134h]
  int v272; // [sp+134h] [bp+134h]
  int v273; // [sp+134h] [bp+134h]
  int v274; // [sp+134h] [bp+134h]
  int v275; // [sp+138h] [bp+138h]
  int v276; // [sp+138h] [bp+138h]
  int v277; // [sp+138h] [bp+138h]
  int v278; // [sp+138h] [bp+138h]
  int v279; // [sp+138h] [bp+138h]
  int v280; // [sp+138h] [bp+138h]
  int v281; // [sp+13Ch] [bp+13Ch]
  int v282; // [sp+13Ch] [bp+13Ch]
  int v283; // [sp+13Ch] [bp+13Ch]
  int v284; // [sp+13Ch] [bp+13Ch]
  int v285; // [sp+13Ch] [bp+13Ch]
  int v286; // [sp+13Ch] [bp+13Ch]
  int v287; // [sp+140h] [bp+140h]
  int v288; // [sp+140h] [bp+140h]
  int v289; // [sp+140h] [bp+140h]
  int v290; // [sp+140h] [bp+140h]
  int i; // [sp+144h] [bp+144h]

  v4 = a1[8];
  *((_BYTE *)a1 + v4) = (128 >> a3) | a2 & -(128 >> a3);
  result = (unsigned int)memset((char *)a1 + v4 + 1, 0, 31 - v4);
  v287 = a1[9];
  v281 = a1[10];
  v275 = a1[11];
  v269 = a1[12];
  v262 = a1[13];
  v257 = a1[14];
  v250 = a1[15];
  v244 = a1[16];
  v239 = a1[17];
  v231 = a1[18];
  v223 = a1[19];
  v215 = a1[20];
  v206 = a1[21];
  v199 = a1[22];
  v190 = a1[23];
  v181 = a1[24];
  v176 = a1[25];
  v168 = a1[26];
  v160 = a1[27];
  v152 = a1[28];
  v143 = a1[29];
  v136 = a1[30];
  v127 = a1[31];
  v118 = a1[32];
  v113 = a1[33];
  v105 = a1[34];
  v97 = a1[35];
  v89 = a1[36];
  v80 = a1[37];
  v73 = a1[38];
  v64 = a1[39];
  v55 = a1[40];
  for ( i = 0; i <= 2; ++i )
  {
    v48 = sub_15CA34(a1);
    v47 = sub_15CA34(a1 + 1);
    v46 = sub_15CA34(a1 + 2);
    v45 = sub_15CA34(a1 + 3);
    v44 = sub_15CA34(a1 + 4);
    v43 = sub_15CA34(a1 + 5);
    v42 = sub_15CA34(a1 + 6);
    result = sub_15CA34(a1 + 7);
    v26 = v55 ^ v118 ^ v181 ^ v244;
    v35 = v64 ^ v127 ^ v190 ^ v250;
    v36 = v73 ^ v136 ^ v199 ^ v257;
    v37 = v80 ^ v143 ^ v206 ^ v262;
    v38 = v26 ^ v89 ^ v152 ^ v215 ^ v269;
    v39 = v26 ^ v97 ^ v160 ^ v223 ^ v275;
    v40 = v105 ^ v168 ^ v231 ^ v281;
    v41 = v26 ^ v113 ^ v176 ^ v239 ^ v287;
    v288 = v26 ^ v287;
    v282 = v41 ^ v281;
    v276 = v40 ^ v275;
    v270 = v39 ^ v269;
    v263 = v38 ^ v262;
    v258 = v37 ^ v257;
    v251 = v36 ^ v250;
    v240 = v26 ^ v239;
    v232 = v41 ^ v231;
    v224 = v40 ^ v223;
    v216 = v39 ^ v215;
    v207 = v38 ^ v206;
    v200 = v37 ^ v199;
    v191 = v36 ^ v190;
    v182 = v35 ^ v181;
    v177 = v26 ^ v176;
    v169 = v41 ^ v168;
    v161 = v40 ^ v160;
    v153 = v39 ^ v152;
    v144 = v38 ^ v143;
    v137 = v37 ^ v136;
    v128 = v36 ^ v127;
    v119 = v35 ^ v118;
    v114 = v26 ^ v113;
    v106 = v41 ^ v105;
    v98 = v40 ^ v97;
    v90 = v39 ^ v89;
    v81 = v38 ^ v80;
    v74 = v37 ^ v73;
    v65 = v36 ^ v64;
    v56 = v35 ^ v55;
    v34 = v114 ^ v35 ^ v244;
    v33 = v106 ^ v35 ^ v244 ^ v288;
    v32 = v98 ^ v282;
    v31 = v90 ^ v35 ^ v244 ^ v276;
    v30 = v81 ^ v35 ^ v244 ^ v270;
    v29 = v74 ^ v263;
    v28 = v65 ^ v258;
    v27 = v56 ^ v251;
    v25 = v56;
    v57 = v65;
    v66 = v74;
    v75 = v81;
    v82 = v25 ^ v90;
    v91 = v25 ^ v98;
    v99 = v106;
    v107 = v25 ^ v114;
    v115 = v177 ^ v25;
    v108 = v169 ^ v107;
    v100 = v161 ^ v99;
    v92 = v153 ^ v91;
    v83 = v144 ^ v82;
    v76 = v137 ^ v75;
    v67 = v128 ^ v66;
    v58 = v119 ^ v57;
    v24 = v119;
    v120 = v128;
    v129 = v137;
    v138 = v144;
    v145 = v24 ^ v153;
    v154 = v24 ^ v161;
    v162 = v169;
    v170 = v24 ^ v177;
    v178 = v240 ^ v24;
    v171 = v232 ^ v170;
    v163 = v224 ^ v162;
    v155 = v216 ^ v154;
    v146 = v207 ^ v145;
    v139 = v200 ^ v138;
    v130 = v191 ^ v129;
    v121 = v182 ^ v120;
    v23 = v182;
    v183 = v191;
    v192 = v200;
    v201 = v207;
    v208 = v23 ^ v216;
    v217 = v23 ^ v224;
    v225 = v232;
    v233 = v23 ^ v240;
    v241 = v288 ^ v23;
    v234 = v282 ^ v233;
    v226 = v276 ^ v225;
    v218 = v270 ^ v217;
    v209 = v263 ^ v208;
    v202 = v258 ^ v201;
    v193 = v251 ^ v192;
    v184 = v35 ^ v244 ^ v183;
    v287 = v48 ^ v34;
    v281 = v47 ^ v33;
    v275 = v46 ^ v32;
    v269 = v45 ^ v31;
    v262 = v44 ^ v30;
    v257 = v43 ^ v29;
    v250 = v42 ^ v28;
    v244 = result ^ v27;
    v239 = result ^ v241;
    v231 = result ^ v48 ^ v234;
    v223 = v47 ^ v226;
    v215 = result ^ v46 ^ v218;
    v176 = v42 ^ v178;
    v168 = v42 ^ result ^ v171;
    v160 = result ^ v48 ^ v163;
    v152 = v42 ^ v47 ^ v155;
    v113 = v43 ^ v115;
    v105 = v43 ^ v42 ^ v108;
    v97 = v42 ^ result ^ v100;
    v89 = v43 ^ result ^ v48 ^ v92;
    v206 = __ROR4__(result ^ v45 ^ v209, 31);
    v199 = __ROR4__(v44 ^ v202, 31);
    v190 = __ROR4__(v43 ^ v193, 31);
    v181 = __ROR4__(v42 ^ v184, 31);
    v143 = __ROR4__(v42 ^ result ^ v46 ^ v146, 30);
    v136 = __ROR4__(result ^ v45 ^ v139, 30);
    v127 = __ROR4__(v44 ^ v130, 30);
    v118 = __ROR4__(v43 ^ v121, 30);
    v80 = __ROR4__(v43 ^ v42 ^ v47 ^ v83, 29);
    v73 = __ROR4__(v42 ^ result ^ v46 ^ v76, 29);
    v64 = __ROR4__(result ^ v45 ^ v67, 29);
    v55 = __ROR4__(v44 ^ v58, 29);
    for ( j = 0; j <= 7; ++j )
    {
      v21 = v287;
      v277 = v269 ^ v275;
      v289 = v269 ^ (v281 | v287);
      v271 = v21 & v269;
      v283 = v271 ^ ~v281;
      v272 = v277 ^ v271;
      v278 = v283 ^ v289 & v277;
      v284 = v272 | v283;
      v22 = v284 ^ v21;
      v273 = v278 ^ v272;
      v279 = v284 & v278;
      v285 = ~v289 ^ v284;
      v19 = v257;
      v245 = v262 ^ v244;
      v259 = v262 ^ (v250 | v257);
      v264 = v19 & v262;
      v252 = v264 ^ ~v250;
      v265 = v245 ^ v264;
      v246 = v252 ^ v259 & v245;
      v253 = v265 | v252;
      v20 = v253 ^ v19;
      v266 = v246 ^ v265;
      v247 = v253 & v246;
      v254 = ~v259 ^ v253;
      v267 = v22 ^ v266;
      v290 = v267 ^ __ROR4__(v22, 30);
      v268 = v290 ^ __ROR4__(v267, 18);
      v260 = v285 ^ v20;
      v286 = v285 ^ v20 ^ __ROR4__(v285, 30);
      v261 = v286 ^ __ROR4__(v260, 18);
      v281 = v261 ^ __ROR4__(v286, 22);
      v257 = __ROR4__(v261, 31);
      v255 = v279 ^ v254;
      v280 = v255 ^ __ROR4__(v279, 30);
      v256 = v280 ^ __ROR4__(v255, 18);
      v275 = v256 ^ __ROR4__(v280, 22);
      v250 = __ROR4__(v256, 31);
      v248 = v273 ^ v247;
      v274 = v248 ^ __ROR4__(v273, 30);
      v249 = v274 ^ __ROR4__(v248, 18);
      v269 = v249 ^ __ROR4__(v274, 22);
      v244 = __ROR4__(v249, 31);
      v287 = dword_1D5C28[j] ^ v268 ^ __ROR4__(v290, 22);
      v262 = dword_1D5C48[j] ^ __ROR4__(v268, 31);
    }
    for ( k = 0; k <= 7; ++k )
    {
      v17 = v239;
      v227 = v215 ^ v223;
      v242 = v215 ^ (v231 | v239);
      v219 = v17 & v215;
      v235 = v219 ^ ~v231;
      v220 = v227 ^ v219;
      v228 = v235 ^ v242 & v227;
      v236 = v220 | v235;
      v18 = v236 ^ v17;
      v221 = v228 ^ v220;
      v229 = v236 & v228;
      v237 = ~v242 ^ v236;
      v15 = v199;
      v185 = v206 ^ v181;
      v203 = v206 ^ (v190 | v199);
      v210 = v15 & v206;
      v194 = v210 ^ ~v190;
      v211 = v185 ^ v210;
      v186 = v194 ^ v203 & v185;
      v195 = v211 | v194;
      v16 = v195 ^ v15;
      v212 = v186 ^ v211;
      v187 = v195 & v186;
      v196 = ~v203 ^ v195;
      v213 = v18 ^ v212;
      v243 = v213 ^ __ROR4__(v18, 30);
      v214 = v243 ^ __ROR4__(v213, 18);
      v204 = v237 ^ v16;
      v238 = v237 ^ v16 ^ __ROR4__(v237, 30);
      v205 = v238 ^ __ROR4__(v204, 18);
      v231 = v205 ^ __ROR4__(v238, 22);
      v199 = __ROR4__(v205, 31);
      v197 = v229 ^ v196;
      v230 = v197 ^ __ROR4__(v229, 30);
      v198 = v230 ^ __ROR4__(v197, 18);
      v223 = v198 ^ __ROR4__(v230, 22);
      v190 = __ROR4__(v198, 31);
      v188 = v221 ^ v187;
      v222 = v188 ^ __ROR4__(v221, 30);
      v189 = v222 ^ __ROR4__(v188, 18);
      v215 = v189 ^ __ROR4__(v222, 22);
      v181 = __ROR4__(v189, 31);
      v239 = dword_1D5C68[k] ^ v214 ^ __ROR4__(v243, 22);
      v206 = dword_1D5C88[k] ^ __ROR4__(v214, 31);
    }
    for ( m = 0; m <= 7; ++m )
    {
      v13 = v176;
      v164 = v152 ^ v160;
      v179 = v152 ^ (v168 | v176);
      v156 = v13 & v152;
      v172 = v156 ^ ~v168;
      v157 = v164 ^ v156;
      v165 = v172 ^ v179 & v164;
      v173 = v157 | v172;
      v14 = v173 ^ v13;
      v158 = v165 ^ v157;
      v166 = v173 & v165;
      v174 = ~v179 ^ v173;
      v11 = v136;
      v122 = v143 ^ v118;
      v140 = v143 ^ (v127 | v136);
      v147 = v11 & v143;
      v131 = v147 ^ ~v127;
      v148 = v122 ^ v147;
      v123 = v131 ^ v140 & v122;
      v132 = v148 | v131;
      v12 = v132 ^ v11;
      v149 = v123 ^ v148;
      v124 = v132 & v123;
      v133 = ~v140 ^ v132;
      v150 = v14 ^ v149;
      v180 = v150 ^ __ROR4__(v14, 30);
      v151 = v180 ^ __ROR4__(v150, 18);
      v141 = v174 ^ v12;
      v175 = v174 ^ v12 ^ __ROR4__(v174, 30);
      v142 = v175 ^ __ROR4__(v141, 18);
      v168 = v142 ^ __ROR4__(v175, 22);
      v136 = __ROR4__(v142, 31);
      v134 = v166 ^ v133;
      v167 = v134 ^ __ROR4__(v166, 30);
      v135 = v167 ^ __ROR4__(v134, 18);
      v160 = v135 ^ __ROR4__(v167, 22);
      v127 = __ROR4__(v135, 31);
      v125 = v158 ^ v124;
      v159 = v125 ^ __ROR4__(v158, 30);
      v126 = v159 ^ __ROR4__(v125, 18);
      v152 = v126 ^ __ROR4__(v159, 22);
      v118 = __ROR4__(v126, 31);
      v176 = dword_1D5CA8[m] ^ v151 ^ __ROR4__(v180, 22);
      v143 = dword_1D5CC8[m] ^ __ROR4__(v151, 31);
    }
    for ( n = 0; n <= 7; ++n )
    {
      v9 = v113;
      v101 = v89 ^ v97;
      v116 = v89 ^ (v105 | v113);
      v93 = v9 & v89;
      v109 = v93 ^ ~v105;
      v94 = v101 ^ v93;
      v102 = v109 ^ v116 & v101;
      v110 = v94 | v109;
      v10 = v110 ^ v9;
      v95 = v102 ^ v94;
      v103 = v110 & v102;
      v111 = ~v116 ^ v110;
      v7 = v73;
      v59 = v80 ^ v55;
      v77 = v80 ^ (v64 | v73);
      v84 = v7 & v80;
      v68 = v84 ^ ~v64;
      v85 = v59 ^ v84;
      v60 = v68 ^ v77 & v59;
      v69 = v85 | v68;
      v8 = v69 ^ v7;
      v86 = v60 ^ v85;
      v61 = v69 & v60;
      v70 = ~v77 ^ v69;
      v87 = v10 ^ v86;
      v117 = v87 ^ __ROR4__(v10, 30);
      v88 = v117 ^ __ROR4__(v87, 18);
      v78 = v111 ^ v8;
      v112 = v111 ^ v8 ^ __ROR4__(v111, 30);
      v79 = v112 ^ __ROR4__(v78, 18);
      v105 = v79 ^ __ROR4__(v112, 22);
      v73 = __ROR4__(v79, 31);
      v71 = v103 ^ v70;
      v104 = v71 ^ __ROR4__(v103, 30);
      v72 = v104 ^ __ROR4__(v71, 18);
      v97 = v72 ^ __ROR4__(v104, 22);
      v64 = __ROR4__(v72, 31);
      v62 = v95 ^ v61;
      v96 = v62 ^ __ROR4__(v95, 30);
      v63 = v96 ^ __ROR4__(v62, 18);
      v89 = v63 ^ __ROR4__(v96, 22);
      v55 = __ROR4__(v63, 31);
      v113 = dword_1D5CE8[n] ^ v88 ^ __ROR4__(v117, 22);
      v80 = dword_1D5D08[n] ^ __ROR4__(v88, 31);
    }
    switch ( i )
    {
      case 1:
        sub_15C9F0(a4, v113 ^ v287 ^ v239 ^ v176);
        sub_15C9F0(a4 + 4, v105 ^ v281 ^ v231 ^ v168);
        sub_15C9F0(a4 + 8, v97 ^ v275 ^ v223 ^ v160);
        sub_15C9F0(a4 + 12, v89 ^ v269 ^ v215 ^ v152);
        sub_15C9F0(a4 + 16, v80 ^ v262 ^ v206 ^ v143);
        sub_15C9F0(a4 + 20, v73 ^ v257 ^ v199 ^ v136);
        sub_15C9F0(a4 + 24, v64 ^ v250 ^ v190 ^ v127);
        result = (unsigned int)sub_15C9F0(a4 + 28, v55 ^ v244 ^ v181 ^ v118);
        break;
      case 2:
        sub_15C9F0(a4 + 32, v113 ^ v287 ^ v239 ^ v176);
        sub_15C9F0(a4 + 36, v105 ^ v281 ^ v231 ^ v168);
        sub_15C9F0(a4 + 40, v97 ^ v275 ^ v223 ^ v160);
        result = (unsigned int)sub_15C9F0(a4 + 44, v89 ^ v269 ^ v215 ^ v152);
        break;
      case 0:
        result = (unsigned int)memset(a1, 0, 0x20u);
        break;
    }
  }
  return result;
}
// 1D5C28: using guessed type _DWORD dword_1D5C28[8];
// 1D5C48: using guessed type _DWORD dword_1D5C48[8];
// 1D5C68: using guessed type _DWORD dword_1D5C68[8];
// 1D5C88: using guessed type _DWORD dword_1D5C88[8];
// 1D5CA8: using guessed type _DWORD dword_1D5CA8[8];
// 1D5CC8: using guessed type _DWORD dword_1D5CC8[8];
// 1D5CE8: using guessed type _DWORD dword_1D5CE8[8];
// 1D5D08: using guessed type _DWORD dword_1D5D08[8];

//----- (0016214C) --------------------------------------------------------
unsigned int __fastcall sub_16214C(unsigned int result, char *a2, size_t a3)
{
  unsigned int v3; // [sp+4h] [bp+4h]
  char *v4; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+14h] [bp+14h]
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int v9; // [sp+18h] [bp+18h]
  int v10; // [sp+1Ch] [bp+1Ch]
  int v11; // [sp+1Ch] [bp+1Ch]
  int v12; // [sp+20h] [bp+20h]
  int v13; // [sp+20h] [bp+20h]
  int v14; // [sp+24h] [bp+24h]
  int v15; // [sp+24h] [bp+24h]
  int v16; // [sp+28h] [bp+28h]
  int v17; // [sp+28h] [bp+28h]
  int v18; // [sp+2Ch] [bp+2Ch]
  int v19; // [sp+2Ch] [bp+2Ch]
  int v20; // [sp+30h] [bp+30h]
  int v21; // [sp+30h] [bp+30h]
  int v22; // [sp+34h] [bp+34h]
  int v23; // [sp+34h] [bp+34h]
  int v24; // [sp+38h] [bp+38h]
  int v25; // [sp+38h] [bp+38h]
  unsigned int v26; // [sp+44h] [bp+44h]
  int v27; // [sp+4Ch] [bp+4Ch]
  int v28; // [sp+50h] [bp+50h]
  int v29; // [sp+54h] [bp+54h]
  int v30; // [sp+58h] [bp+58h]
  int v31; // [sp+60h] [bp+60h]
  int v32; // [sp+64h] [bp+64h]
  int v33; // [sp+68h] [bp+68h]
  int v34; // [sp+6Ch] [bp+6Ch]
  int v35; // [sp+74h] [bp+74h]
  int v36; // [sp+78h] [bp+78h]
  int v37; // [sp+7Ch] [bp+7Ch]
  int v38; // [sp+80h] [bp+80h]
  int v39; // [sp+84h] [bp+84h]
  int v40; // [sp+88h] [bp+88h]
  int v41; // [sp+8Ch] [bp+8Ch]
  int v42; // [sp+90h] [bp+90h]
  int v43; // [sp+94h] [bp+94h]
  int v44; // [sp+98h] [bp+98h]
  int v45; // [sp+9Ch] [bp+9Ch]
  int v46; // [sp+A0h] [bp+A0h]
  int v47; // [sp+A4h] [bp+A4h]
  int v48; // [sp+A8h] [bp+A8h]
  int v49; // [sp+ACh] [bp+ACh]
  int v50; // [sp+B0h] [bp+B0h]
  unsigned int v51; // [sp+BCh] [bp+BCh]
  int v52; // [sp+BCh] [bp+BCh]
  unsigned int v53; // [sp+C0h] [bp+C0h]
  unsigned int v54; // [sp+C4h] [bp+C4h]
  unsigned int v55; // [sp+C8h] [bp+C8h]
  int v56; // [sp+C8h] [bp+C8h]
  unsigned int v57; // [sp+CCh] [bp+CCh]
  unsigned int v58; // [sp+D0h] [bp+D0h]
  unsigned int v59; // [sp+D4h] [bp+D4h]
  int *v60; // [sp+D8h] [bp+D8h]
  int i; // [sp+DCh] [bp+DCh]
  int j; // [sp+DCh] [bp+DCh]
  int k; // [sp+DCh] [bp+DCh]
  int m; // [sp+DCh] [bp+DCh]
  int ii; // [sp+DCh] [bp+DCh]
  size_t n; // [sp+E0h] [bp+E0h]
  int v67; // [sp+E4h] [bp+E4h]
  int v68; // [sp+E4h] [bp+E4h]
  int v69; // [sp+E4h] [bp+E4h]
  int v70; // [sp+E4h] [bp+E4h]
  int v71; // [sp+E4h] [bp+E4h]
  int v72; // [sp+E4h] [bp+E4h]
  int v73; // [sp+E4h] [bp+E4h]
  int v74; // [sp+E4h] [bp+E4h]
  int v75; // [sp+E4h] [bp+E4h]
  int v76; // [sp+E4h] [bp+E4h]
  int v77; // [sp+E4h] [bp+E4h]
  int v78; // [sp+E8h] [bp+E8h]
  int v79; // [sp+E8h] [bp+E8h]
  int v80; // [sp+E8h] [bp+E8h]
  int v81; // [sp+E8h] [bp+E8h]
  int v82; // [sp+E8h] [bp+E8h]
  int v83; // [sp+E8h] [bp+E8h]
  int v84; // [sp+E8h] [bp+E8h]
  int v85; // [sp+E8h] [bp+E8h]
  int v86; // [sp+E8h] [bp+E8h]
  int v87; // [sp+E8h] [bp+E8h]
  int v88; // [sp+E8h] [bp+E8h]
  int v89; // [sp+ECh] [bp+ECh]
  int v90; // [sp+ECh] [bp+ECh]
  int v91; // [sp+ECh] [bp+ECh]
  int v92; // [sp+ECh] [bp+ECh]
  int v93; // [sp+ECh] [bp+ECh]
  int v94; // [sp+ECh] [bp+ECh]
  int v95; // [sp+ECh] [bp+ECh]
  int v96; // [sp+ECh] [bp+ECh]
  int v97; // [sp+ECh] [bp+ECh]
  int v98; // [sp+F0h] [bp+F0h]
  int v99; // [sp+F0h] [bp+F0h]
  int v100; // [sp+F0h] [bp+F0h]
  int v101; // [sp+F0h] [bp+F0h]
  int v102; // [sp+F0h] [bp+F0h]
  int v103; // [sp+F0h] [bp+F0h]
  int v104; // [sp+F0h] [bp+F0h]
  int v105; // [sp+F0h] [bp+F0h]
  int v106; // [sp+F0h] [bp+F0h]
  int v107; // [sp+F0h] [bp+F0h]
  int v108; // [sp+F0h] [bp+F0h]
  int v109; // [sp+F4h] [bp+F4h]
  int v110; // [sp+F4h] [bp+F4h]
  int v111; // [sp+F4h] [bp+F4h]
  int v112; // [sp+F4h] [bp+F4h]
  int v113; // [sp+F4h] [bp+F4h]
  int v114; // [sp+F4h] [bp+F4h]
  int v115; // [sp+F4h] [bp+F4h]
  int v116; // [sp+F4h] [bp+F4h]
  int v117; // [sp+F4h] [bp+F4h]
  int v118; // [sp+F4h] [bp+F4h]
  int v119; // [sp+F8h] [bp+F8h]
  int v120; // [sp+F8h] [bp+F8h]
  int v121; // [sp+F8h] [bp+F8h]
  int v122; // [sp+F8h] [bp+F8h]
  int v123; // [sp+F8h] [bp+F8h]
  int v124; // [sp+F8h] [bp+F8h]
  int v125; // [sp+F8h] [bp+F8h]
  int v126; // [sp+F8h] [bp+F8h]
  int v127; // [sp+F8h] [bp+F8h]
  int v128; // [sp+F8h] [bp+F8h]
  int v129; // [sp+FCh] [bp+FCh]
  int v130; // [sp+FCh] [bp+FCh]
  int v131; // [sp+FCh] [bp+FCh]
  int v132; // [sp+FCh] [bp+FCh]
  int v133; // [sp+FCh] [bp+FCh]
  int v134; // [sp+FCh] [bp+FCh]
  int v135; // [sp+FCh] [bp+FCh]
  int v136; // [sp+FCh] [bp+FCh]
  int v137; // [sp+100h] [bp+100h]
  int v138; // [sp+100h] [bp+100h]
  int v139; // [sp+100h] [bp+100h]
  int v140; // [sp+100h] [bp+100h]
  int v141; // [sp+104h] [bp+104h]
  int v142; // [sp+104h] [bp+104h]
  int v143; // [sp+104h] [bp+104h]
  int v144; // [sp+104h] [bp+104h]
  int v145; // [sp+104h] [bp+104h]
  int v146; // [sp+104h] [bp+104h]
  int v147; // [sp+104h] [bp+104h]
  int v148; // [sp+104h] [bp+104h]
  int v149; // [sp+104h] [bp+104h]
  int v150; // [sp+104h] [bp+104h]
  int v151; // [sp+104h] [bp+104h]
  int v152; // [sp+108h] [bp+108h]
  int v153; // [sp+108h] [bp+108h]
  int v154; // [sp+108h] [bp+108h]
  int v155; // [sp+108h] [bp+108h]
  int v156; // [sp+108h] [bp+108h]
  int v157; // [sp+108h] [bp+108h]
  int v158; // [sp+108h] [bp+108h]
  int v159; // [sp+108h] [bp+108h]
  int v160; // [sp+108h] [bp+108h]
  int v161; // [sp+108h] [bp+108h]
  int v162; // [sp+108h] [bp+108h]
  int v163; // [sp+10Ch] [bp+10Ch]
  int v164; // [sp+10Ch] [bp+10Ch]
  int v165; // [sp+10Ch] [bp+10Ch]
  int v166; // [sp+10Ch] [bp+10Ch]
  int v167; // [sp+10Ch] [bp+10Ch]
  int v168; // [sp+10Ch] [bp+10Ch]
  int v169; // [sp+10Ch] [bp+10Ch]
  int v170; // [sp+10Ch] [bp+10Ch]
  int v171; // [sp+10Ch] [bp+10Ch]
  int v172; // [sp+110h] [bp+110h]
  int v173; // [sp+110h] [bp+110h]
  int v174; // [sp+110h] [bp+110h]
  int v175; // [sp+110h] [bp+110h]
  int v176; // [sp+110h] [bp+110h]
  int v177; // [sp+110h] [bp+110h]
  int v178; // [sp+110h] [bp+110h]
  int v179; // [sp+110h] [bp+110h]
  int v180; // [sp+110h] [bp+110h]
  int v181; // [sp+110h] [bp+110h]
  int v182; // [sp+110h] [bp+110h]
  int v183; // [sp+114h] [bp+114h]
  int v184; // [sp+114h] [bp+114h]
  int v185; // [sp+114h] [bp+114h]
  int v186; // [sp+114h] [bp+114h]
  int v187; // [sp+114h] [bp+114h]
  int v188; // [sp+114h] [bp+114h]
  int v189; // [sp+114h] [bp+114h]
  int v190; // [sp+114h] [bp+114h]
  int v191; // [sp+114h] [bp+114h]
  int v192; // [sp+114h] [bp+114h]
  int v193; // [sp+118h] [bp+118h]
  int v194; // [sp+118h] [bp+118h]
  int v195; // [sp+118h] [bp+118h]
  int v196; // [sp+118h] [bp+118h]
  int v197; // [sp+118h] [bp+118h]
  int v198; // [sp+118h] [bp+118h]
  int v199; // [sp+118h] [bp+118h]
  int v200; // [sp+118h] [bp+118h]
  int v201; // [sp+118h] [bp+118h]
  int v202; // [sp+118h] [bp+118h]
  int v203; // [sp+11Ch] [bp+11Ch]
  int v204; // [sp+11Ch] [bp+11Ch]
  int v205; // [sp+11Ch] [bp+11Ch]
  int v206; // [sp+11Ch] [bp+11Ch]
  int v207; // [sp+11Ch] [bp+11Ch]
  int v208; // [sp+11Ch] [bp+11Ch]
  int v209; // [sp+11Ch] [bp+11Ch]
  int v210; // [sp+11Ch] [bp+11Ch]
  int v211; // [sp+120h] [bp+120h]
  int v212; // [sp+120h] [bp+120h]
  int v213; // [sp+120h] [bp+120h]
  int v214; // [sp+120h] [bp+120h]
  int v215; // [sp+124h] [bp+124h]
  int v216; // [sp+124h] [bp+124h]
  int v217; // [sp+124h] [bp+124h]
  int v218; // [sp+124h] [bp+124h]
  int v219; // [sp+124h] [bp+124h]
  int v220; // [sp+124h] [bp+124h]
  int v221; // [sp+124h] [bp+124h]
  int v222; // [sp+124h] [bp+124h]
  int v223; // [sp+124h] [bp+124h]
  int v224; // [sp+124h] [bp+124h]
  int v225; // [sp+124h] [bp+124h]
  int v226; // [sp+128h] [bp+128h]
  int v227; // [sp+128h] [bp+128h]
  int v228; // [sp+128h] [bp+128h]
  int v229; // [sp+128h] [bp+128h]
  int v230; // [sp+128h] [bp+128h]
  int v231; // [sp+128h] [bp+128h]
  int v232; // [sp+128h] [bp+128h]
  int v233; // [sp+128h] [bp+128h]
  int v234; // [sp+128h] [bp+128h]
  int v235; // [sp+128h] [bp+128h]
  int v236; // [sp+128h] [bp+128h]
  int v237; // [sp+12Ch] [bp+12Ch]
  int v238; // [sp+12Ch] [bp+12Ch]
  int v239; // [sp+12Ch] [bp+12Ch]
  int v240; // [sp+12Ch] [bp+12Ch]
  int v241; // [sp+12Ch] [bp+12Ch]
  int v242; // [sp+12Ch] [bp+12Ch]
  int v243; // [sp+12Ch] [bp+12Ch]
  int v244; // [sp+12Ch] [bp+12Ch]
  int v245; // [sp+12Ch] [bp+12Ch]
  int v246; // [sp+12Ch] [bp+12Ch]
  int v247; // [sp+130h] [bp+130h]
  int v248; // [sp+130h] [bp+130h]
  int v249; // [sp+130h] [bp+130h]
  int v250; // [sp+130h] [bp+130h]
  int v251; // [sp+130h] [bp+130h]
  int v252; // [sp+130h] [bp+130h]
  int v253; // [sp+130h] [bp+130h]
  int v254; // [sp+130h] [bp+130h]
  int v255; // [sp+130h] [bp+130h]
  int v256; // [sp+130h] [bp+130h]
  int v257; // [sp+130h] [bp+130h]
  int v258; // [sp+130h] [bp+130h]
  int v259; // [sp+134h] [bp+134h]
  int v260; // [sp+134h] [bp+134h]
  int v261; // [sp+134h] [bp+134h]
  int v262; // [sp+134h] [bp+134h]
  int v263; // [sp+134h] [bp+134h]
  int v264; // [sp+134h] [bp+134h]
  int v265; // [sp+134h] [bp+134h]
  int v266; // [sp+134h] [bp+134h]
  int v267; // [sp+134h] [bp+134h]
  int v268; // [sp+134h] [bp+134h]
  int v269; // [sp+138h] [bp+138h]
  int v270; // [sp+138h] [bp+138h]
  int v271; // [sp+138h] [bp+138h]
  int v272; // [sp+138h] [bp+138h]
  int v273; // [sp+138h] [bp+138h]
  int v274; // [sp+138h] [bp+138h]
  int v275; // [sp+138h] [bp+138h]
  int v276; // [sp+138h] [bp+138h]
  int v277; // [sp+138h] [bp+138h]
  int v278; // [sp+138h] [bp+138h]
  int v279; // [sp+13Ch] [bp+13Ch]
  int v280; // [sp+13Ch] [bp+13Ch]
  int v281; // [sp+13Ch] [bp+13Ch]
  int v282; // [sp+13Ch] [bp+13Ch]
  int v283; // [sp+13Ch] [bp+13Ch]
  int v284; // [sp+13Ch] [bp+13Ch]
  int v285; // [sp+13Ch] [bp+13Ch]
  int v286; // [sp+13Ch] [bp+13Ch]
  int v287; // [sp+140h] [bp+140h]
  int v288; // [sp+140h] [bp+140h]
  int v289; // [sp+140h] [bp+140h]
  int v290; // [sp+140h] [bp+140h]
  int v291; // [sp+144h] [bp+144h]
  int v292; // [sp+144h] [bp+144h]
  int v293; // [sp+144h] [bp+144h]
  int v294; // [sp+144h] [bp+144h]
  int v295; // [sp+144h] [bp+144h]
  int v296; // [sp+144h] [bp+144h]
  int v297; // [sp+144h] [bp+144h]
  int v298; // [sp+144h] [bp+144h]
  int v299; // [sp+144h] [bp+144h]
  int v300; // [sp+144h] [bp+144h]
  int v301; // [sp+144h] [bp+144h]
  int v302; // [sp+148h] [bp+148h]
  int v303; // [sp+148h] [bp+148h]
  int v304; // [sp+148h] [bp+148h]
  int v305; // [sp+148h] [bp+148h]
  int v306; // [sp+148h] [bp+148h]
  int v307; // [sp+148h] [bp+148h]
  int v308; // [sp+148h] [bp+148h]
  int v309; // [sp+148h] [bp+148h]
  int v310; // [sp+148h] [bp+148h]
  int v311; // [sp+148h] [bp+148h]
  int v312; // [sp+14Ch] [bp+14Ch]
  int v313; // [sp+14Ch] [bp+14Ch]
  int v314; // [sp+14Ch] [bp+14Ch]
  int v315; // [sp+14Ch] [bp+14Ch]
  int v316; // [sp+14Ch] [bp+14Ch]
  int v317; // [sp+14Ch] [bp+14Ch]
  int v318; // [sp+14Ch] [bp+14Ch]
  int v319; // [sp+14Ch] [bp+14Ch]
  int v320; // [sp+150h] [bp+150h]
  int v321; // [sp+150h] [bp+150h]
  int v322; // [sp+150h] [bp+150h]
  int v323; // [sp+150h] [bp+150h]
  int v324; // [sp+150h] [bp+150h]
  int v325; // [sp+150h] [bp+150h]
  int v326; // [sp+150h] [bp+150h]
  int v327; // [sp+150h] [bp+150h]
  int v328; // [sp+150h] [bp+150h]
  int v329; // [sp+150h] [bp+150h]
  int v330; // [sp+150h] [bp+150h]
  int v331; // [sp+154h] [bp+154h]
  int v332; // [sp+154h] [bp+154h]
  int v333; // [sp+154h] [bp+154h]
  int v334; // [sp+154h] [bp+154h]
  int v335; // [sp+154h] [bp+154h]
  int v336; // [sp+154h] [bp+154h]
  int v337; // [sp+154h] [bp+154h]
  int v338; // [sp+154h] [bp+154h]
  int v339; // [sp+154h] [bp+154h]
  int v340; // [sp+158h] [bp+158h]
  int v341; // [sp+158h] [bp+158h]
  int v342; // [sp+158h] [bp+158h]
  int v343; // [sp+158h] [bp+158h]
  int v344; // [sp+158h] [bp+158h]
  int v345; // [sp+158h] [bp+158h]
  int v346; // [sp+158h] [bp+158h]
  int v347; // [sp+158h] [bp+158h]
  int v348; // [sp+158h] [bp+158h]
  int v349; // [sp+15Ch] [bp+15Ch]
  int v350; // [sp+15Ch] [bp+15Ch]
  int v351; // [sp+15Ch] [bp+15Ch]
  int v352; // [sp+15Ch] [bp+15Ch]
  int v353; // [sp+15Ch] [bp+15Ch]
  int v354; // [sp+15Ch] [bp+15Ch]
  int v355; // [sp+15Ch] [bp+15Ch]
  int v356; // [sp+160h] [bp+160h]
  int v357; // [sp+160h] [bp+160h]
  int v358; // [sp+160h] [bp+160h]
  int v359; // [sp+160h] [bp+160h]
  int v360; // [sp+164h] [bp+164h]
  int v361; // [sp+164h] [bp+164h]
  int v362; // [sp+164h] [bp+164h]
  int v363; // [sp+164h] [bp+164h]
  int v364; // [sp+164h] [bp+164h]
  int v365; // [sp+164h] [bp+164h]
  int v366; // [sp+164h] [bp+164h]
  int v367; // [sp+168h] [bp+168h]
  int v368; // [sp+168h] [bp+168h]
  int v369; // [sp+168h] [bp+168h]
  int v370; // [sp+168h] [bp+168h]
  int v371; // [sp+168h] [bp+168h]
  int v372; // [sp+168h] [bp+168h]
  int v373; // [sp+168h] [bp+168h]
  int v374; // [sp+16Ch] [bp+16Ch]
  int v375; // [sp+16Ch] [bp+16Ch]
  int v376; // [sp+16Ch] [bp+16Ch]
  int v377; // [sp+16Ch] [bp+16Ch]
  int v378; // [sp+16Ch] [bp+16Ch]
  int v379; // [sp+16Ch] [bp+16Ch]
  int v380; // [sp+170h] [bp+170h]
  int v381; // [sp+170h] [bp+170h]
  int v382; // [sp+170h] [bp+170h]
  int v383; // [sp+170h] [bp+170h]
  int v384; // [sp+170h] [bp+170h]
  int v385; // [sp+170h] [bp+170h]
  int v386; // [sp+170h] [bp+170h]
  int v387; // [sp+170h] [bp+170h]
  int v388; // [sp+174h] [bp+174h]
  int v389; // [sp+174h] [bp+174h]
  int v390; // [sp+174h] [bp+174h]
  int v391; // [sp+174h] [bp+174h]
  int v392; // [sp+174h] [bp+174h]
  int v393; // [sp+174h] [bp+174h]
  int v394; // [sp+174h] [bp+174h]
  int v395; // [sp+178h] [bp+178h]
  int v396; // [sp+178h] [bp+178h]
  int v397; // [sp+178h] [bp+178h]
  int v398; // [sp+178h] [bp+178h]
  int v399; // [sp+178h] [bp+178h]
  int v400; // [sp+178h] [bp+178h]
  int v401; // [sp+178h] [bp+178h]
  int v402; // [sp+17Ch] [bp+17Ch]
  int v403; // [sp+17Ch] [bp+17Ch]
  int v404; // [sp+17Ch] [bp+17Ch]
  int v405; // [sp+17Ch] [bp+17Ch]
  int v406; // [sp+17Ch] [bp+17Ch]
  int v407; // [sp+17Ch] [bp+17Ch]
  int v408; // [sp+17Ch] [bp+17Ch]
  int v409; // [sp+180h] [bp+180h]
  int v410; // [sp+180h] [bp+180h]
  int v411; // [sp+180h] [bp+180h]
  int v412; // [sp+180h] [bp+180h]
  int v413; // [sp+184h] [bp+184h]

  v5 = (_DWORD *)result;
  v4 = a2;
  v3 = a3;
  v60 = (int *)result;
  v413 = *(_DWORD *)(result + 32);
  if ( 32 - v413 <= a3 )
  {
    v409 = *(_DWORD *)(result + 36);
    v402 = *(_DWORD *)(result + 40);
    v395 = *(_DWORD *)(result + 44);
    v388 = *(_DWORD *)(result + 48);
    v380 = *(_DWORD *)(result + 52);
    v374 = *(_DWORD *)(result + 56);
    v367 = *(_DWORD *)(result + 60);
    v360 = *(_DWORD *)(result + 64);
    v356 = *(_DWORD *)(result + 68);
    v349 = *(_DWORD *)(result + 72);
    v340 = *(_DWORD *)(result + 76);
    v331 = *(_DWORD *)(result + 80);
    v320 = *(_DWORD *)(result + 84);
    v312 = *(_DWORD *)(result + 88);
    v302 = *(_DWORD *)(result + 92);
    v291 = *(_DWORD *)(result + 96);
    v287 = *(_DWORD *)(result + 100);
    v279 = *(_DWORD *)(result + 104);
    v269 = *(_DWORD *)(result + 108);
    v259 = *(_DWORD *)(result + 112);
    v247 = *(_DWORD *)(result + 116);
    v237 = *(_DWORD *)(result + 120);
    v226 = *(_DWORD *)(result + 124);
    v215 = *(_DWORD *)(result + 128);
    v211 = *(_DWORD *)(result + 132);
    v203 = *(_DWORD *)(result + 136);
    v193 = *(_DWORD *)(result + 140);
    v183 = *(_DWORD *)(result + 144);
    v172 = *(_DWORD *)(result + 148);
    v163 = *(_DWORD *)(result + 152);
    v152 = *(_DWORD *)(result + 156);
    v141 = *(_DWORD *)(result + 160);
    v137 = *(_DWORD *)(result + 164);
    v129 = *(_DWORD *)(result + 168);
    v119 = *(_DWORD *)(result + 172);
    v109 = *(_DWORD *)(result + 176);
    v98 = *(_DWORD *)(result + 180);
    v89 = *(_DWORD *)(result + 184);
    v78 = *(_DWORD *)(result + 188);
    v67 = *(_DWORD *)(result + 192);
    while ( v3 )
    {
      n = 32 - v413;
      if ( 32 - v413 > v3 )
        n = v3;
      result = (unsigned int)memcpy((char *)v60 + v413, v4, n);
      v413 += n;
      v4 += n;
      v3 -= n;
      if ( v413 == 32 )
      {
        v59 = sub_15CA34(v60);
        v58 = sub_15CA34(v60 + 1);
        v57 = sub_15CA34(v60 + 2);
        v55 = sub_15CA34(v60 + 3);
        v54 = sub_15CA34(v60 + 4);
        v53 = sub_15CA34(v60 + 5);
        v51 = sub_15CA34(v60 + 6);
        result = sub_15CA34(v60 + 7);
        v35 = v67 ^ v141 ^ v215 ^ v291 ^ v360;
        v44 = v78 ^ v152 ^ v226 ^ v302 ^ v367;
        v45 = v89 ^ v163 ^ v237 ^ v312 ^ v374;
        v46 = v98 ^ v172 ^ v247 ^ v320 ^ v380;
        v47 = v35 ^ v109 ^ v183 ^ v259 ^ v331 ^ v388;
        v48 = v35 ^ v119 ^ v193 ^ v269 ^ v340 ^ v395;
        v49 = v129 ^ v203 ^ v279 ^ v349 ^ v402;
        v50 = v35 ^ v137 ^ v211 ^ v287 ^ v356 ^ v409;
        v410 = v35 ^ v409;
        v403 = v50 ^ v402;
        v396 = v49 ^ v395;
        v389 = v48 ^ v388;
        v381 = v47 ^ v380;
        v375 = v46 ^ v374;
        v357 = v35 ^ v356;
        v350 = v50 ^ v349;
        v341 = v49 ^ v340;
        v332 = v48 ^ v331;
        v321 = v47 ^ v320;
        v313 = v46 ^ v312;
        v303 = v45 ^ v302;
        v292 = v44 ^ v291;
        v288 = v35 ^ v287;
        v280 = v50 ^ v279;
        v270 = v49 ^ v269;
        v260 = v48 ^ v259;
        v248 = v47 ^ v247;
        v238 = v46 ^ v237;
        v227 = v45 ^ v226;
        v216 = v44 ^ v215;
        v212 = v35 ^ v211;
        v204 = v50 ^ v203;
        v194 = v49 ^ v193;
        v184 = v48 ^ v183;
        v173 = v47 ^ v172;
        v164 = v46 ^ v163;
        v153 = v45 ^ v152;
        v142 = v44 ^ v141;
        v138 = v35 ^ v137;
        v130 = v50 ^ v129;
        v120 = v49 ^ v119;
        v110 = v48 ^ v109;
        v99 = v47 ^ v98;
        v90 = v46 ^ v89;
        v79 = v45 ^ v78;
        v68 = v44 ^ v67;
        v43 = v357 ^ v44 ^ v360;
        v42 = v350 ^ v44 ^ v360 ^ v410;
        v41 = v341 ^ v403;
        v40 = v332 ^ v44 ^ v360 ^ v396;
        v39 = v321 ^ v44 ^ v360 ^ v389;
        v38 = v313 ^ v381;
        v37 = v303 ^ v375;
        v36 = v292 ^ v45 ^ v367;
        v34 = v292;
        v293 = v303;
        v304 = v313;
        v314 = v321;
        v322 = v34 ^ v332;
        v333 = v34 ^ v341;
        v342 = v350;
        v351 = v280 ^ v34 ^ v357;
        v343 = v270 ^ v342;
        v334 = v260 ^ v333;
        v323 = v248 ^ v322;
        v315 = v238 ^ v314;
        v305 = v227 ^ v304;
        v294 = v216 ^ v293;
        v33 = v216;
        v217 = v227;
        v228 = v238;
        v239 = v248;
        v249 = v33 ^ v260;
        v261 = v33 ^ v270;
        v271 = v280;
        v281 = v204 ^ v33 ^ v288;
        v272 = v194 ^ v271;
        v262 = v184 ^ v261;
        v250 = v173 ^ v249;
        v240 = v164 ^ v239;
        v229 = v153 ^ v228;
        v218 = v142 ^ v217;
        v32 = v142;
        v143 = v153;
        v154 = v164;
        v165 = v173;
        v174 = v32 ^ v184;
        v185 = v32 ^ v194;
        v195 = v204;
        v205 = v130 ^ v32 ^ v212;
        v196 = v120 ^ v195;
        v186 = v110 ^ v185;
        v175 = v99 ^ v174;
        v166 = v90 ^ v165;
        v155 = v79 ^ v154;
        v144 = v68 ^ v143;
        v31 = v68;
        v69 = v79;
        v80 = v90;
        v91 = v99;
        v100 = v31 ^ v110;
        v111 = v31 ^ v120;
        v121 = v130;
        v131 = v403 ^ v31 ^ v138;
        v122 = v396 ^ v121;
        v112 = v389 ^ v111;
        v101 = v381 ^ v100;
        v92 = v375 ^ v91;
        v81 = v45 ^ v367 ^ v80;
        v70 = v44 ^ v360 ^ v69;
        v404 = v131 ^ v36 ^ v43;
        v397 = v122 ^ v42;
        v390 = v112 ^ v36 ^ v41;
        v382 = v101 ^ v36 ^ v40;
        v376 = v92 ^ v39;
        v368 = v81 ^ v38;
        v361 = v70 ^ v37;
        v30 = v70;
        v71 = v81;
        v82 = v92;
        v93 = v101;
        v102 = v30 ^ v112;
        v113 = v30 ^ v122;
        v123 = v131;
        v132 = v205 ^ v30 ^ v410 ^ v31;
        v124 = v196 ^ v123;
        v114 = v186 ^ v113;
        v103 = v175 ^ v102;
        v94 = v166 ^ v93;
        v83 = v155 ^ v82;
        v72 = v144 ^ v71;
        v29 = v144;
        v145 = v155;
        v156 = v166;
        v167 = v175;
        v176 = v29 ^ v186;
        v187 = v29 ^ v196;
        v197 = v205;
        v206 = v281 ^ v29 ^ v138 ^ v32;
        v198 = v272 ^ v197;
        v188 = v262 ^ v187;
        v177 = v250 ^ v176;
        v168 = v240 ^ v167;
        v157 = v229 ^ v156;
        v146 = v218 ^ v145;
        v28 = v218;
        v219 = v229;
        v230 = v240;
        v241 = v250;
        v251 = v28 ^ v262;
        v263 = v28 ^ v272;
        v273 = v281;
        v282 = v351 ^ v28 ^ v212 ^ v33;
        v274 = v343 ^ v273;
        v264 = v334 ^ v263;
        v252 = v323 ^ v251;
        v242 = v315 ^ v241;
        v231 = v305 ^ v230;
        v220 = v294 ^ v219;
        v27 = v294;
        v295 = v305;
        v306 = v315;
        v316 = v323;
        v324 = v27 ^ v334;
        v335 = v27 ^ v343;
        v344 = v351;
        v409 = v59 ^ v410 ^ v31 ^ v36;
        v402 = v58 ^ v404;
        v395 = v57 ^ v397;
        v388 = v55 ^ v390;
        v380 = v54 ^ v382;
        v374 = v53 ^ v376;
        v367 = v51 ^ v368;
        v360 = result ^ v361;
        v356 = result ^ v43 ^ v27;
        v349 = result ^ v59 ^ v42 ^ v27 ^ v288 ^ v34;
        v340 = v58 ^ v41 ^ v344;
        v331 = result ^ v57 ^ v40 ^ v335;
        v325 = result ^ v55 ^ v39 ^ v324;
        v296 = v51 ^ v36 ^ v295;
        v26 = v51;
        v287 = v51 ^ v288 ^ v34 ^ v28;
        v279 = v51 ^ result ^ v282;
        v269 = result ^ v59 ^ v274;
        v259 = v51 ^ v58 ^ v264;
        v253 = v51 ^ result ^ v57 ^ v252;
        v243 = result ^ v55 ^ v242;
        v52 = result ^ v55;
        v56 = v53 ^ result ^ v59;
        v211 = v53 ^ v212 ^ v33 ^ v29;
        v203 = v53 ^ v26 ^ v206;
        v193 = v26 ^ result ^ v198;
        v183 = v56 ^ v188;
        v137 = v54 ^ v138 ^ v32 ^ v30;
        v129 = v54 ^ v53 ^ v132;
        v119 = v53 ^ v26 ^ v124;
        v109 = v54 ^ v26 ^ result ^ v114;
        v320 = __ROR4__(v325, 31);
        v312 = __ROR4__(v54 ^ v38 ^ v316, 31);
        v302 = __ROR4__(v53 ^ v37 ^ v306, 31);
        v291 = __ROR4__(v296, 31);
        v247 = __ROR4__(v253, 30);
        v237 = __ROR4__(v243, 30);
        v226 = __ROR4__(v54 ^ v231, 30);
        v215 = __ROR4__(v53 ^ v220, 30);
        v172 = __ROR4__(v53 ^ v26 ^ v58 ^ v177, 29);
        v163 = __ROR4__(v26 ^ result ^ v57 ^ v168, 29);
        v152 = __ROR4__(v52 ^ v157, 29);
        v141 = __ROR4__(v54 ^ v146, 29);
        v98 = __ROR4__(v54 ^ v56 ^ v103, 28);
        v89 = __ROR4__(v53 ^ v26 ^ v58 ^ v94, 28);
        v78 = __ROR4__(v26 ^ result ^ v57 ^ v83, 28);
        v67 = __ROR4__(v52 ^ v72, 28);
        for ( i = 0; i <= 7; ++i )
        {
          v24 = v409;
          v398 = v388 ^ v395;
          v411 = v388 ^ (v402 | v409);
          v391 = v24 & v388;
          v405 = v391 ^ ~v402;
          v392 = v398 ^ v391;
          v399 = v405 ^ v411 & v398;
          v406 = v392 | v405;
          v25 = v406 ^ v24;
          v393 = v399 ^ v392;
          v400 = v406 & v399;
          v407 = ~v411 ^ v406;
          v22 = v374;
          v362 = v380 ^ v360;
          v377 = v380 ^ (v367 | v374);
          v383 = v22 & v380;
          v369 = v383 ^ ~v367;
          v384 = v362 ^ v383;
          v363 = v369 ^ v377 & v362;
          v370 = v384 | v369;
          v23 = v370 ^ v22;
          v385 = v363 ^ v384;
          v364 = v370 & v363;
          v371 = ~v377 ^ v370;
          v386 = v25 ^ v385;
          v412 = v386 ^ __ROR4__(v25, 30);
          v387 = v412 ^ __ROR4__(v386, 18);
          v378 = v407 ^ v23;
          v408 = v407 ^ v23 ^ __ROR4__(v407, 30);
          v379 = v408 ^ __ROR4__(v378, 18);
          v402 = v379 ^ __ROR4__(v408, 22);
          v374 = __ROR4__(v379, 31);
          v372 = v400 ^ v371;
          v401 = v372 ^ __ROR4__(v400, 30);
          v373 = v401 ^ __ROR4__(v372, 18);
          v395 = v373 ^ __ROR4__(v401, 22);
          v367 = __ROR4__(v373, 31);
          v365 = v393 ^ v364;
          v394 = v365 ^ __ROR4__(v393, 30);
          v366 = v394 ^ __ROR4__(v365, 18);
          v388 = v366 ^ __ROR4__(v394, 22);
          v360 = __ROR4__(v366, 31);
          v409 = dword_1D5C28[i] ^ v387 ^ __ROR4__(v412, 22);
          v380 = dword_1D5C48[i] ^ __ROR4__(v387, 31);
        }
        for ( j = 0; j <= 7; ++j )
        {
          v20 = v356;
          v345 = v331 ^ v340;
          v358 = v331 ^ (v349 | v356);
          v336 = v20 & v331;
          v352 = v336 ^ ~v349;
          v337 = v345 ^ v336;
          v346 = v352 ^ v358 & v345;
          v353 = v337 | v352;
          v21 = v353 ^ v20;
          v338 = v346 ^ v337;
          v347 = v353 & v346;
          v354 = ~v358 ^ v353;
          v18 = v312;
          v297 = v320 ^ v291;
          v317 = v320 ^ (v302 | v312);
          v326 = v18 & v320;
          v307 = v326 ^ ~v302;
          v327 = v297 ^ v326;
          v298 = v307 ^ v317 & v297;
          v308 = v327 | v307;
          v19 = v308 ^ v18;
          v328 = v298 ^ v327;
          v299 = v308 & v298;
          v309 = ~v317 ^ v308;
          v329 = v21 ^ v328;
          v359 = v329 ^ __ROR4__(v21, 30);
          v330 = v359 ^ __ROR4__(v329, 18);
          v318 = v354 ^ v19;
          v355 = v354 ^ v19 ^ __ROR4__(v354, 30);
          v319 = v355 ^ __ROR4__(v318, 18);
          v349 = v319 ^ __ROR4__(v355, 22);
          v312 = __ROR4__(v319, 31);
          v310 = v347 ^ v309;
          v348 = v310 ^ __ROR4__(v347, 30);
          v311 = v348 ^ __ROR4__(v310, 18);
          v340 = v311 ^ __ROR4__(v348, 22);
          v302 = __ROR4__(v311, 31);
          v300 = v338 ^ v299;
          v339 = v300 ^ __ROR4__(v338, 30);
          v301 = v339 ^ __ROR4__(v300, 18);
          v331 = v301 ^ __ROR4__(v339, 22);
          v291 = __ROR4__(v301, 31);
          v356 = dword_1D5C68[j] ^ v330 ^ __ROR4__(v359, 22);
          v320 = dword_1D5C88[j] ^ __ROR4__(v330, 31);
        }
        for ( k = 0; k <= 7; ++k )
        {
          v16 = v287;
          v275 = v259 ^ v269;
          v289 = v259 ^ (v279 | v287);
          v265 = v16 & v259;
          v283 = v265 ^ ~v279;
          v266 = v275 ^ v265;
          v276 = v283 ^ v289 & v275;
          v284 = v266 | v283;
          v17 = v284 ^ v16;
          v267 = v276 ^ v266;
          v277 = v284 & v276;
          v285 = ~v289 ^ v284;
          v14 = v237;
          v221 = v247 ^ v215;
          v244 = v247 ^ (v226 | v237);
          v254 = v14 & v247;
          v232 = v254 ^ ~v226;
          v255 = v221 ^ v254;
          v222 = v232 ^ v244 & v221;
          v233 = v255 | v232;
          v15 = v233 ^ v14;
          v256 = v222 ^ v255;
          v223 = v233 & v222;
          v234 = ~v244 ^ v233;
          v257 = v17 ^ v256;
          v290 = v257 ^ __ROR4__(v17, 30);
          v258 = v290 ^ __ROR4__(v257, 18);
          v245 = v285 ^ v15;
          v286 = v285 ^ v15 ^ __ROR4__(v285, 30);
          v246 = v286 ^ __ROR4__(v245, 18);
          v279 = v246 ^ __ROR4__(v286, 22);
          v237 = __ROR4__(v246, 31);
          v235 = v277 ^ v234;
          v278 = v235 ^ __ROR4__(v277, 30);
          v236 = v278 ^ __ROR4__(v235, 18);
          v269 = v236 ^ __ROR4__(v278, 22);
          v226 = __ROR4__(v236, 31);
          v224 = v267 ^ v223;
          v268 = v224 ^ __ROR4__(v267, 30);
          v225 = v268 ^ __ROR4__(v224, 18);
          v259 = v225 ^ __ROR4__(v268, 22);
          v215 = __ROR4__(v225, 31);
          v287 = dword_1D5CA8[k] ^ v258 ^ __ROR4__(v290, 22);
          v247 = dword_1D5CC8[k] ^ __ROR4__(v258, 31);
        }
        for ( m = 0; m <= 7; ++m )
        {
          v12 = v211;
          v199 = v183 ^ v193;
          v213 = v183 ^ (v203 | v211);
          v189 = v12 & v183;
          v207 = v189 ^ ~v203;
          v190 = v199 ^ v189;
          v200 = v207 ^ v213 & v199;
          v208 = v190 | v207;
          v13 = v208 ^ v12;
          v191 = v200 ^ v190;
          v201 = v208 & v200;
          v209 = ~v213 ^ v208;
          v10 = v163;
          v147 = v172 ^ v141;
          v169 = v172 ^ (v152 | v163);
          v178 = v10 & v172;
          v158 = v178 ^ ~v152;
          v179 = v147 ^ v178;
          v148 = v158 ^ v169 & v147;
          v159 = v179 | v158;
          v11 = v159 ^ v10;
          v180 = v148 ^ v179;
          v149 = v159 & v148;
          v160 = ~v169 ^ v159;
          v181 = v13 ^ v180;
          v214 = v181 ^ __ROR4__(v13, 30);
          v182 = v214 ^ __ROR4__(v181, 18);
          v170 = v209 ^ v11;
          v210 = v209 ^ v11 ^ __ROR4__(v209, 30);
          v171 = v210 ^ __ROR4__(v170, 18);
          v203 = v171 ^ __ROR4__(v210, 22);
          v163 = __ROR4__(v171, 31);
          v161 = v201 ^ v160;
          v202 = v161 ^ __ROR4__(v201, 30);
          v162 = v202 ^ __ROR4__(v161, 18);
          v193 = v162 ^ __ROR4__(v202, 22);
          v152 = __ROR4__(v162, 31);
          v150 = v191 ^ v149;
          v192 = v150 ^ __ROR4__(v191, 30);
          v151 = v192 ^ __ROR4__(v150, 18);
          v183 = v151 ^ __ROR4__(v192, 22);
          v141 = __ROR4__(v151, 31);
          v211 = dword_1D5CE8[m] ^ v182 ^ __ROR4__(v214, 22);
          v172 = dword_1D5D08[m] ^ __ROR4__(v182, 31);
        }
        for ( ii = 0; ii <= 7; ++ii )
        {
          v8 = v137;
          v125 = v109 ^ v119;
          v139 = v109 ^ (v129 | v137);
          v115 = v8 & v109;
          v133 = v115 ^ ~v129;
          v116 = v125 ^ v115;
          v126 = v133 ^ v139 & v125;
          v134 = v116 | v133;
          v9 = v134 ^ v8;
          v117 = v126 ^ v116;
          v127 = v134 & v126;
          v135 = ~v139 ^ v134;
          v6 = v89;
          v73 = v98 ^ v67;
          v95 = v98 ^ (v78 | v89);
          v104 = v6 & v98;
          v84 = v104 ^ ~v78;
          v105 = v73 ^ v104;
          v74 = v84 ^ v95 & v73;
          v85 = v105 | v84;
          v7 = v85 ^ v6;
          v106 = v74 ^ v105;
          v75 = v85 & v74;
          v86 = ~v95 ^ v85;
          v107 = v9 ^ v106;
          v140 = v107 ^ __ROR4__(v9, 30);
          v108 = v140 ^ __ROR4__(v107, 18);
          v96 = v135 ^ v7;
          v136 = v135 ^ v7 ^ __ROR4__(v135, 30);
          v97 = v136 ^ __ROR4__(v96, 18);
          v129 = v97 ^ __ROR4__(v136, 22);
          v89 = __ROR4__(v97, 31);
          v87 = v127 ^ v86;
          v128 = v87 ^ __ROR4__(v127, 30);
          v88 = v128 ^ __ROR4__(v87, 18);
          v119 = v88 ^ __ROR4__(v128, 22);
          v78 = __ROR4__(v88, 31);
          v76 = v117 ^ v75;
          v118 = v76 ^ __ROR4__(v117, 30);
          v77 = v118 ^ __ROR4__(v76, 18);
          v109 = v77 ^ __ROR4__(v118, 22);
          v67 = __ROR4__(v77, 31);
          v137 = dword_1D5D28[ii] ^ v108 ^ __ROR4__(v140, 22);
          v98 = dword_1D5D48[ii] ^ __ROR4__(v108, 31);
        }
        v413 = 0;
      }
    }
    v5[9] = v409;
    v5[10] = v402;
    v5[11] = v395;
    v5[12] = v388;
    v5[13] = v380;
    v5[14] = v374;
    v5[15] = v367;
    v5[16] = v360;
    v5[17] = v356;
    v5[18] = v349;
    v5[19] = v340;
    v5[20] = v331;
    v5[21] = v320;
    v5[22] = v312;
    v5[23] = v302;
    v5[24] = v291;
    v5[25] = v287;
    v5[26] = v279;
    v5[27] = v269;
    v5[28] = v259;
    v5[29] = v247;
    v5[30] = v237;
    v5[31] = v226;
    v5[32] = v215;
    v5[33] = v211;
    v5[34] = v203;
    v5[35] = v193;
    v5[36] = v183;
    v5[37] = v172;
    v5[38] = v163;
    v5[39] = v152;
    v5[40] = v141;
    v5[41] = v137;
    v5[42] = v129;
    v5[43] = v119;
    v5[44] = v109;
    v5[45] = v98;
    v5[46] = v89;
    v5[47] = v78;
    v5[48] = v67;
    v5[8] = v413;
  }
  else
  {
    result = (unsigned int)memcpy((void *)(result + v413), a2, a3);
    v5[8] = v3 + v413;
  }
  return result;
}
// 1D5C28: using guessed type _DWORD dword_1D5C28[8];
// 1D5C48: using guessed type _DWORD dword_1D5C48[8];
// 1D5C68: using guessed type _DWORD dword_1D5C68[8];
// 1D5C88: using guessed type _DWORD dword_1D5C88[8];
// 1D5CA8: using guessed type _DWORD dword_1D5CA8[8];
// 1D5CC8: using guessed type _DWORD dword_1D5CC8[8];
// 1D5CE8: using guessed type _DWORD dword_1D5CE8[8];
// 1D5D08: using guessed type _DWORD dword_1D5D08[8];
// 1D5D28: using guessed type _DWORD dword_1D5D28[8];
// 1D5D48: using guessed type _DWORD dword_1D5D48[8];

//----- (001648F0) --------------------------------------------------------
unsigned int __fastcall sub_1648F0(int *a1, char a2, char a3, _BYTE *a4)
{
  int v4; // r3
  unsigned int result; // r0
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+14h] [bp+14h]
  int v9; // [sp+18h] [bp+18h]
  int v10; // [sp+18h] [bp+18h]
  int v11; // [sp+1Ch] [bp+1Ch]
  int v12; // [sp+1Ch] [bp+1Ch]
  int v13; // [sp+20h] [bp+20h]
  int v14; // [sp+20h] [bp+20h]
  int v15; // [sp+24h] [bp+24h]
  int v16; // [sp+24h] [bp+24h]
  int v17; // [sp+28h] [bp+28h]
  int v18; // [sp+28h] [bp+28h]
  int v19; // [sp+2Ch] [bp+2Ch]
  int v20; // [sp+2Ch] [bp+2Ch]
  int v21; // [sp+30h] [bp+30h]
  int v22; // [sp+30h] [bp+30h]
  int v23; // [sp+34h] [bp+34h]
  int v24; // [sp+34h] [bp+34h]
  int v25; // [sp+38h] [bp+38h]
  int v26; // [sp+38h] [bp+38h]
  unsigned int v27; // [sp+44h] [bp+44h]
  int v28; // [sp+4Ch] [bp+4Ch]
  int v29; // [sp+50h] [bp+50h]
  int v30; // [sp+54h] [bp+54h]
  int v31; // [sp+58h] [bp+58h]
  int v32; // [sp+60h] [bp+60h]
  int v33; // [sp+64h] [bp+64h]
  int v34; // [sp+68h] [bp+68h]
  int v35; // [sp+6Ch] [bp+6Ch]
  int v36; // [sp+74h] [bp+74h]
  int v37; // [sp+78h] [bp+78h]
  int v38; // [sp+7Ch] [bp+7Ch]
  int v39; // [sp+80h] [bp+80h]
  int v40; // [sp+84h] [bp+84h]
  int v41; // [sp+88h] [bp+88h]
  int v42; // [sp+8Ch] [bp+8Ch]
  int v43; // [sp+90h] [bp+90h]
  int v44; // [sp+94h] [bp+94h]
  int v45; // [sp+98h] [bp+98h]
  int v46; // [sp+9Ch] [bp+9Ch]
  int v47; // [sp+A0h] [bp+A0h]
  int v48; // [sp+A4h] [bp+A4h]
  int v49; // [sp+A8h] [bp+A8h]
  int v50; // [sp+ACh] [bp+ACh]
  int v51; // [sp+B0h] [bp+B0h]
  unsigned int v52; // [sp+BCh] [bp+BCh]
  int v53; // [sp+BCh] [bp+BCh]
  unsigned int v54; // [sp+C0h] [bp+C0h]
  unsigned int v55; // [sp+C4h] [bp+C4h]
  unsigned int v56; // [sp+C8h] [bp+C8h]
  int v57; // [sp+C8h] [bp+C8h]
  unsigned int v58; // [sp+CCh] [bp+CCh]
  unsigned int v59; // [sp+D0h] [bp+D0h]
  unsigned int v60; // [sp+D4h] [bp+D4h]
  int j; // [sp+E8h] [bp+E8h]
  int k; // [sp+E8h] [bp+E8h]
  int m; // [sp+E8h] [bp+E8h]
  int n; // [sp+E8h] [bp+E8h]
  int ii; // [sp+E8h] [bp+E8h]
  int v68; // [sp+ECh] [bp+ECh]
  int v69; // [sp+ECh] [bp+ECh]
  int v70; // [sp+ECh] [bp+ECh]
  int v71; // [sp+ECh] [bp+ECh]
  int v72; // [sp+ECh] [bp+ECh]
  int v73; // [sp+ECh] [bp+ECh]
  int v74; // [sp+ECh] [bp+ECh]
  int v75; // [sp+ECh] [bp+ECh]
  int v76; // [sp+ECh] [bp+ECh]
  int v77; // [sp+ECh] [bp+ECh]
  int v78; // [sp+ECh] [bp+ECh]
  int v79; // [sp+F0h] [bp+F0h]
  int v80; // [sp+F0h] [bp+F0h]
  int v81; // [sp+F0h] [bp+F0h]
  int v82; // [sp+F0h] [bp+F0h]
  int v83; // [sp+F0h] [bp+F0h]
  int v84; // [sp+F0h] [bp+F0h]
  int v85; // [sp+F0h] [bp+F0h]
  int v86; // [sp+F0h] [bp+F0h]
  int v87; // [sp+F0h] [bp+F0h]
  int v88; // [sp+F0h] [bp+F0h]
  int v89; // [sp+F0h] [bp+F0h]
  int v90; // [sp+F4h] [bp+F4h]
  int v91; // [sp+F4h] [bp+F4h]
  int v92; // [sp+F4h] [bp+F4h]
  int v93; // [sp+F4h] [bp+F4h]
  int v94; // [sp+F4h] [bp+F4h]
  int v95; // [sp+F4h] [bp+F4h]
  int v96; // [sp+F4h] [bp+F4h]
  int v97; // [sp+F4h] [bp+F4h]
  int v98; // [sp+F4h] [bp+F4h]
  int v99; // [sp+F8h] [bp+F8h]
  int v100; // [sp+F8h] [bp+F8h]
  int v101; // [sp+F8h] [bp+F8h]
  int v102; // [sp+F8h] [bp+F8h]
  int v103; // [sp+F8h] [bp+F8h]
  int v104; // [sp+F8h] [bp+F8h]
  int v105; // [sp+F8h] [bp+F8h]
  int v106; // [sp+F8h] [bp+F8h]
  int v107; // [sp+F8h] [bp+F8h]
  int v108; // [sp+F8h] [bp+F8h]
  int v109; // [sp+F8h] [bp+F8h]
  int v110; // [sp+FCh] [bp+FCh]
  int v111; // [sp+FCh] [bp+FCh]
  int v112; // [sp+FCh] [bp+FCh]
  int v113; // [sp+FCh] [bp+FCh]
  int v114; // [sp+FCh] [bp+FCh]
  int v115; // [sp+FCh] [bp+FCh]
  int v116; // [sp+FCh] [bp+FCh]
  int v117; // [sp+FCh] [bp+FCh]
  int v118; // [sp+FCh] [bp+FCh]
  int v119; // [sp+FCh] [bp+FCh]
  int v120; // [sp+100h] [bp+100h]
  int v121; // [sp+100h] [bp+100h]
  int v122; // [sp+100h] [bp+100h]
  int v123; // [sp+100h] [bp+100h]
  int v124; // [sp+100h] [bp+100h]
  int v125; // [sp+100h] [bp+100h]
  int v126; // [sp+100h] [bp+100h]
  int v127; // [sp+100h] [bp+100h]
  int v128; // [sp+100h] [bp+100h]
  int v129; // [sp+100h] [bp+100h]
  int v130; // [sp+104h] [bp+104h]
  int v131; // [sp+104h] [bp+104h]
  int v132; // [sp+104h] [bp+104h]
  int v133; // [sp+104h] [bp+104h]
  int v134; // [sp+104h] [bp+104h]
  int v135; // [sp+104h] [bp+104h]
  int v136; // [sp+104h] [bp+104h]
  int v137; // [sp+104h] [bp+104h]
  int v138; // [sp+108h] [bp+108h]
  int v139; // [sp+108h] [bp+108h]
  int v140; // [sp+108h] [bp+108h]
  int v141; // [sp+108h] [bp+108h]
  int v142; // [sp+10Ch] [bp+10Ch]
  int v143; // [sp+10Ch] [bp+10Ch]
  int v144; // [sp+10Ch] [bp+10Ch]
  int v145; // [sp+10Ch] [bp+10Ch]
  int v146; // [sp+10Ch] [bp+10Ch]
  int v147; // [sp+10Ch] [bp+10Ch]
  int v148; // [sp+10Ch] [bp+10Ch]
  int v149; // [sp+10Ch] [bp+10Ch]
  int v150; // [sp+10Ch] [bp+10Ch]
  int v151; // [sp+10Ch] [bp+10Ch]
  int v152; // [sp+10Ch] [bp+10Ch]
  int v153; // [sp+110h] [bp+110h]
  int v154; // [sp+110h] [bp+110h]
  int v155; // [sp+110h] [bp+110h]
  int v156; // [sp+110h] [bp+110h]
  int v157; // [sp+110h] [bp+110h]
  int v158; // [sp+110h] [bp+110h]
  int v159; // [sp+110h] [bp+110h]
  int v160; // [sp+110h] [bp+110h]
  int v161; // [sp+110h] [bp+110h]
  int v162; // [sp+110h] [bp+110h]
  int v163; // [sp+110h] [bp+110h]
  int v164; // [sp+114h] [bp+114h]
  int v165; // [sp+114h] [bp+114h]
  int v166; // [sp+114h] [bp+114h]
  int v167; // [sp+114h] [bp+114h]
  int v168; // [sp+114h] [bp+114h]
  int v169; // [sp+114h] [bp+114h]
  int v170; // [sp+114h] [bp+114h]
  int v171; // [sp+114h] [bp+114h]
  int v172; // [sp+114h] [bp+114h]
  int v173; // [sp+118h] [bp+118h]
  int v174; // [sp+118h] [bp+118h]
  int v175; // [sp+118h] [bp+118h]
  int v176; // [sp+118h] [bp+118h]
  int v177; // [sp+118h] [bp+118h]
  int v178; // [sp+118h] [bp+118h]
  int v179; // [sp+118h] [bp+118h]
  int v180; // [sp+118h] [bp+118h]
  int v181; // [sp+118h] [bp+118h]
  int v182; // [sp+118h] [bp+118h]
  int v183; // [sp+118h] [bp+118h]
  int v184; // [sp+11Ch] [bp+11Ch]
  int v185; // [sp+11Ch] [bp+11Ch]
  int v186; // [sp+11Ch] [bp+11Ch]
  int v187; // [sp+11Ch] [bp+11Ch]
  int v188; // [sp+11Ch] [bp+11Ch]
  int v189; // [sp+11Ch] [bp+11Ch]
  int v190; // [sp+11Ch] [bp+11Ch]
  int v191; // [sp+11Ch] [bp+11Ch]
  int v192; // [sp+11Ch] [bp+11Ch]
  int v193; // [sp+11Ch] [bp+11Ch]
  int v194; // [sp+120h] [bp+120h]
  int v195; // [sp+120h] [bp+120h]
  int v196; // [sp+120h] [bp+120h]
  int v197; // [sp+120h] [bp+120h]
  int v198; // [sp+120h] [bp+120h]
  int v199; // [sp+120h] [bp+120h]
  int v200; // [sp+120h] [bp+120h]
  int v201; // [sp+120h] [bp+120h]
  int v202; // [sp+120h] [bp+120h]
  int v203; // [sp+120h] [bp+120h]
  int v204; // [sp+124h] [bp+124h]
  int v205; // [sp+124h] [bp+124h]
  int v206; // [sp+124h] [bp+124h]
  int v207; // [sp+124h] [bp+124h]
  int v208; // [sp+124h] [bp+124h]
  int v209; // [sp+124h] [bp+124h]
  int v210; // [sp+124h] [bp+124h]
  int v211; // [sp+124h] [bp+124h]
  int v212; // [sp+128h] [bp+128h]
  int v213; // [sp+128h] [bp+128h]
  int v214; // [sp+128h] [bp+128h]
  int v215; // [sp+128h] [bp+128h]
  int v216; // [sp+12Ch] [bp+12Ch]
  int v217; // [sp+12Ch] [bp+12Ch]
  int v218; // [sp+12Ch] [bp+12Ch]
  int v219; // [sp+12Ch] [bp+12Ch]
  int v220; // [sp+12Ch] [bp+12Ch]
  int v221; // [sp+12Ch] [bp+12Ch]
  int v222; // [sp+12Ch] [bp+12Ch]
  int v223; // [sp+12Ch] [bp+12Ch]
  int v224; // [sp+12Ch] [bp+12Ch]
  int v225; // [sp+12Ch] [bp+12Ch]
  int v226; // [sp+12Ch] [bp+12Ch]
  int v227; // [sp+130h] [bp+130h]
  int v228; // [sp+130h] [bp+130h]
  int v229; // [sp+130h] [bp+130h]
  int v230; // [sp+130h] [bp+130h]
  int v231; // [sp+130h] [bp+130h]
  int v232; // [sp+130h] [bp+130h]
  int v233; // [sp+130h] [bp+130h]
  int v234; // [sp+130h] [bp+130h]
  int v235; // [sp+130h] [bp+130h]
  int v236; // [sp+130h] [bp+130h]
  int v237; // [sp+130h] [bp+130h]
  int v238; // [sp+134h] [bp+134h]
  int v239; // [sp+134h] [bp+134h]
  int v240; // [sp+134h] [bp+134h]
  int v241; // [sp+134h] [bp+134h]
  int v242; // [sp+134h] [bp+134h]
  int v243; // [sp+134h] [bp+134h]
  int v244; // [sp+134h] [bp+134h]
  int v245; // [sp+134h] [bp+134h]
  int v246; // [sp+134h] [bp+134h]
  int v247; // [sp+134h] [bp+134h]
  int v248; // [sp+138h] [bp+138h]
  int v249; // [sp+138h] [bp+138h]
  int v250; // [sp+138h] [bp+138h]
  int v251; // [sp+138h] [bp+138h]
  int v252; // [sp+138h] [bp+138h]
  int v253; // [sp+138h] [bp+138h]
  int v254; // [sp+138h] [bp+138h]
  int v255; // [sp+138h] [bp+138h]
  int v256; // [sp+138h] [bp+138h]
  int v257; // [sp+138h] [bp+138h]
  int v258; // [sp+138h] [bp+138h]
  int v259; // [sp+138h] [bp+138h]
  int v260; // [sp+13Ch] [bp+13Ch]
  int v261; // [sp+13Ch] [bp+13Ch]
  int v262; // [sp+13Ch] [bp+13Ch]
  int v263; // [sp+13Ch] [bp+13Ch]
  int v264; // [sp+13Ch] [bp+13Ch]
  int v265; // [sp+13Ch] [bp+13Ch]
  int v266; // [sp+13Ch] [bp+13Ch]
  int v267; // [sp+13Ch] [bp+13Ch]
  int v268; // [sp+13Ch] [bp+13Ch]
  int v269; // [sp+13Ch] [bp+13Ch]
  int v270; // [sp+140h] [bp+140h]
  int v271; // [sp+140h] [bp+140h]
  int v272; // [sp+140h] [bp+140h]
  int v273; // [sp+140h] [bp+140h]
  int v274; // [sp+140h] [bp+140h]
  int v275; // [sp+140h] [bp+140h]
  int v276; // [sp+140h] [bp+140h]
  int v277; // [sp+140h] [bp+140h]
  int v278; // [sp+140h] [bp+140h]
  int v279; // [sp+140h] [bp+140h]
  int v280; // [sp+144h] [bp+144h]
  int v281; // [sp+144h] [bp+144h]
  int v282; // [sp+144h] [bp+144h]
  int v283; // [sp+144h] [bp+144h]
  int v284; // [sp+144h] [bp+144h]
  int v285; // [sp+144h] [bp+144h]
  int v286; // [sp+144h] [bp+144h]
  int v287; // [sp+144h] [bp+144h]
  int v288; // [sp+148h] [bp+148h]
  int v289; // [sp+148h] [bp+148h]
  int v290; // [sp+148h] [bp+148h]
  int v291; // [sp+148h] [bp+148h]
  int v292; // [sp+14Ch] [bp+14Ch]
  int v293; // [sp+14Ch] [bp+14Ch]
  int v294; // [sp+14Ch] [bp+14Ch]
  int v295; // [sp+14Ch] [bp+14Ch]
  int v296; // [sp+14Ch] [bp+14Ch]
  int v297; // [sp+14Ch] [bp+14Ch]
  int v298; // [sp+14Ch] [bp+14Ch]
  int v299; // [sp+14Ch] [bp+14Ch]
  int v300; // [sp+14Ch] [bp+14Ch]
  int v301; // [sp+14Ch] [bp+14Ch]
  int v302; // [sp+14Ch] [bp+14Ch]
  int v303; // [sp+150h] [bp+150h]
  int v304; // [sp+150h] [bp+150h]
  int v305; // [sp+150h] [bp+150h]
  int v306; // [sp+150h] [bp+150h]
  int v307; // [sp+150h] [bp+150h]
  int v308; // [sp+150h] [bp+150h]
  int v309; // [sp+150h] [bp+150h]
  int v310; // [sp+150h] [bp+150h]
  int v311; // [sp+150h] [bp+150h]
  int v312; // [sp+150h] [bp+150h]
  int v313; // [sp+154h] [bp+154h]
  int v314; // [sp+154h] [bp+154h]
  int v315; // [sp+154h] [bp+154h]
  int v316; // [sp+154h] [bp+154h]
  int v317; // [sp+154h] [bp+154h]
  int v318; // [sp+154h] [bp+154h]
  int v319; // [sp+154h] [bp+154h]
  int v320; // [sp+154h] [bp+154h]
  int v321; // [sp+158h] [bp+158h]
  int v322; // [sp+158h] [bp+158h]
  int v323; // [sp+158h] [bp+158h]
  int v324; // [sp+158h] [bp+158h]
  int v325; // [sp+158h] [bp+158h]
  int v326; // [sp+158h] [bp+158h]
  int v327; // [sp+158h] [bp+158h]
  int v328; // [sp+158h] [bp+158h]
  int v329; // [sp+158h] [bp+158h]
  int v330; // [sp+158h] [bp+158h]
  int v331; // [sp+158h] [bp+158h]
  int v332; // [sp+15Ch] [bp+15Ch]
  int v333; // [sp+15Ch] [bp+15Ch]
  int v334; // [sp+15Ch] [bp+15Ch]
  int v335; // [sp+15Ch] [bp+15Ch]
  int v336; // [sp+15Ch] [bp+15Ch]
  int v337; // [sp+15Ch] [bp+15Ch]
  int v338; // [sp+15Ch] [bp+15Ch]
  int v339; // [sp+15Ch] [bp+15Ch]
  int v340; // [sp+15Ch] [bp+15Ch]
  int v341; // [sp+160h] [bp+160h]
  int v342; // [sp+160h] [bp+160h]
  int v343; // [sp+160h] [bp+160h]
  int v344; // [sp+160h] [bp+160h]
  int v345; // [sp+160h] [bp+160h]
  int v346; // [sp+160h] [bp+160h]
  int v347; // [sp+160h] [bp+160h]
  int v348; // [sp+160h] [bp+160h]
  int v349; // [sp+160h] [bp+160h]
  int v350; // [sp+164h] [bp+164h]
  int v351; // [sp+164h] [bp+164h]
  int v352; // [sp+164h] [bp+164h]
  int v353; // [sp+164h] [bp+164h]
  int v354; // [sp+164h] [bp+164h]
  int v355; // [sp+164h] [bp+164h]
  int v356; // [sp+164h] [bp+164h]
  int v357; // [sp+168h] [bp+168h]
  int v358; // [sp+168h] [bp+168h]
  int v359; // [sp+168h] [bp+168h]
  int v360; // [sp+168h] [bp+168h]
  int v361; // [sp+16Ch] [bp+16Ch]
  int v362; // [sp+16Ch] [bp+16Ch]
  int v363; // [sp+16Ch] [bp+16Ch]
  int v364; // [sp+16Ch] [bp+16Ch]
  int v365; // [sp+16Ch] [bp+16Ch]
  int v366; // [sp+16Ch] [bp+16Ch]
  int v367; // [sp+16Ch] [bp+16Ch]
  int v368; // [sp+170h] [bp+170h]
  int v369; // [sp+170h] [bp+170h]
  int v370; // [sp+170h] [bp+170h]
  int v371; // [sp+170h] [bp+170h]
  int v372; // [sp+170h] [bp+170h]
  int v373; // [sp+170h] [bp+170h]
  int v374; // [sp+170h] [bp+170h]
  int v375; // [sp+174h] [bp+174h]
  int v376; // [sp+174h] [bp+174h]
  int v377; // [sp+174h] [bp+174h]
  int v378; // [sp+174h] [bp+174h]
  int v379; // [sp+174h] [bp+174h]
  int v380; // [sp+174h] [bp+174h]
  int v381; // [sp+178h] [bp+178h]
  int v382; // [sp+178h] [bp+178h]
  int v383; // [sp+178h] [bp+178h]
  int v384; // [sp+178h] [bp+178h]
  int v385; // [sp+178h] [bp+178h]
  int v386; // [sp+178h] [bp+178h]
  int v387; // [sp+178h] [bp+178h]
  int v388; // [sp+178h] [bp+178h]
  int v389; // [sp+17Ch] [bp+17Ch]
  int v390; // [sp+17Ch] [bp+17Ch]
  int v391; // [sp+17Ch] [bp+17Ch]
  int v392; // [sp+17Ch] [bp+17Ch]
  int v393; // [sp+17Ch] [bp+17Ch]
  int v394; // [sp+17Ch] [bp+17Ch]
  int v395; // [sp+17Ch] [bp+17Ch]
  int v396; // [sp+180h] [bp+180h]
  int v397; // [sp+180h] [bp+180h]
  int v398; // [sp+180h] [bp+180h]
  int v399; // [sp+180h] [bp+180h]
  int v400; // [sp+180h] [bp+180h]
  int v401; // [sp+180h] [bp+180h]
  int v402; // [sp+180h] [bp+180h]
  int v403; // [sp+184h] [bp+184h]
  int v404; // [sp+184h] [bp+184h]
  int v405; // [sp+184h] [bp+184h]
  int v406; // [sp+184h] [bp+184h]
  int v407; // [sp+184h] [bp+184h]
  int v408; // [sp+184h] [bp+184h]
  int v409; // [sp+184h] [bp+184h]
  int v410; // [sp+188h] [bp+188h]
  int v411; // [sp+188h] [bp+188h]
  int v412; // [sp+188h] [bp+188h]
  int v413; // [sp+188h] [bp+188h]
  int i; // [sp+18Ch] [bp+18Ch]

  v4 = a1[8];
  *((_BYTE *)a1 + v4) = (128 >> a3) | a2 & -(128 >> a3);
  result = (unsigned int)memset((char *)a1 + v4 + 1, 0, 31 - v4);
  v410 = a1[9];
  v403 = a1[10];
  v396 = a1[11];
  v389 = a1[12];
  v381 = a1[13];
  v375 = a1[14];
  v368 = a1[15];
  v361 = a1[16];
  v357 = a1[17];
  v350 = a1[18];
  v341 = a1[19];
  v332 = a1[20];
  v321 = a1[21];
  v313 = a1[22];
  v303 = a1[23];
  v292 = a1[24];
  v288 = a1[25];
  v280 = a1[26];
  v270 = a1[27];
  v260 = a1[28];
  v248 = a1[29];
  v238 = a1[30];
  v227 = a1[31];
  v216 = a1[32];
  v212 = a1[33];
  v204 = a1[34];
  v194 = a1[35];
  v184 = a1[36];
  v173 = a1[37];
  v164 = a1[38];
  v153 = a1[39];
  v142 = a1[40];
  v138 = a1[41];
  v130 = a1[42];
  v120 = a1[43];
  v110 = a1[44];
  v99 = a1[45];
  v90 = a1[46];
  v79 = a1[47];
  v68 = a1[48];
  for ( i = 0; i <= 2; ++i )
  {
    v60 = sub_15CA34(a1);
    v59 = sub_15CA34(a1 + 1);
    v58 = sub_15CA34(a1 + 2);
    v56 = sub_15CA34(a1 + 3);
    v55 = sub_15CA34(a1 + 4);
    v54 = sub_15CA34(a1 + 5);
    v52 = sub_15CA34(a1 + 6);
    result = sub_15CA34(a1 + 7);
    v36 = v68 ^ v142 ^ v216 ^ v292 ^ v361;
    v45 = v79 ^ v153 ^ v227 ^ v303 ^ v368;
    v46 = v90 ^ v164 ^ v238 ^ v313 ^ v375;
    v47 = v99 ^ v173 ^ v248 ^ v321 ^ v381;
    v48 = v36 ^ v110 ^ v184 ^ v260 ^ v332 ^ v389;
    v49 = v36 ^ v120 ^ v194 ^ v270 ^ v341 ^ v396;
    v50 = v130 ^ v204 ^ v280 ^ v350 ^ v403;
    v51 = v36 ^ v138 ^ v212 ^ v288 ^ v357 ^ v410;
    v411 = v36 ^ v410;
    v404 = v51 ^ v403;
    v397 = v50 ^ v396;
    v390 = v49 ^ v389;
    v382 = v48 ^ v381;
    v376 = v47 ^ v375;
    v358 = v36 ^ v357;
    v351 = v51 ^ v350;
    v342 = v50 ^ v341;
    v333 = v49 ^ v332;
    v322 = v48 ^ v321;
    v314 = v47 ^ v313;
    v304 = v46 ^ v303;
    v293 = v45 ^ v292;
    v289 = v36 ^ v288;
    v281 = v51 ^ v280;
    v271 = v50 ^ v270;
    v261 = v49 ^ v260;
    v249 = v48 ^ v248;
    v239 = v47 ^ v238;
    v228 = v46 ^ v227;
    v217 = v45 ^ v216;
    v213 = v36 ^ v212;
    v205 = v51 ^ v204;
    v195 = v50 ^ v194;
    v185 = v49 ^ v184;
    v174 = v48 ^ v173;
    v165 = v47 ^ v164;
    v154 = v46 ^ v153;
    v143 = v45 ^ v142;
    v139 = v36 ^ v138;
    v131 = v51 ^ v130;
    v121 = v50 ^ v120;
    v111 = v49 ^ v110;
    v100 = v48 ^ v99;
    v91 = v47 ^ v90;
    v80 = v46 ^ v79;
    v69 = v45 ^ v68;
    v44 = v358 ^ v45 ^ v361;
    v43 = v351 ^ v45 ^ v361 ^ v411;
    v42 = v342 ^ v404;
    v41 = v333 ^ v45 ^ v361 ^ v397;
    v40 = v322 ^ v45 ^ v361 ^ v390;
    v39 = v314 ^ v382;
    v38 = v304 ^ v376;
    v37 = v293 ^ v46 ^ v368;
    v35 = v293;
    v294 = v304;
    v305 = v314;
    v315 = v322;
    v323 = v35 ^ v333;
    v334 = v35 ^ v342;
    v343 = v351;
    v352 = v281 ^ v35 ^ v358;
    v344 = v271 ^ v343;
    v335 = v261 ^ v334;
    v324 = v249 ^ v323;
    v316 = v239 ^ v315;
    v306 = v228 ^ v305;
    v295 = v217 ^ v294;
    v34 = v217;
    v218 = v228;
    v229 = v239;
    v240 = v249;
    v250 = v34 ^ v261;
    v262 = v34 ^ v271;
    v272 = v281;
    v282 = v205 ^ v34 ^ v289;
    v273 = v195 ^ v272;
    v263 = v185 ^ v262;
    v251 = v174 ^ v250;
    v241 = v165 ^ v240;
    v230 = v154 ^ v229;
    v219 = v143 ^ v218;
    v33 = v143;
    v144 = v154;
    v155 = v165;
    v166 = v174;
    v175 = v33 ^ v185;
    v186 = v33 ^ v195;
    v196 = v205;
    v206 = v131 ^ v33 ^ v213;
    v197 = v121 ^ v196;
    v187 = v111 ^ v186;
    v176 = v100 ^ v175;
    v167 = v91 ^ v166;
    v156 = v80 ^ v155;
    v145 = v69 ^ v144;
    v32 = v69;
    v70 = v80;
    v81 = v91;
    v92 = v100;
    v101 = v32 ^ v111;
    v112 = v32 ^ v121;
    v122 = v131;
    v132 = v404 ^ v32 ^ v139;
    v123 = v397 ^ v122;
    v113 = v390 ^ v112;
    v102 = v382 ^ v101;
    v93 = v376 ^ v92;
    v82 = v46 ^ v368 ^ v81;
    v71 = v45 ^ v361 ^ v70;
    v405 = v132 ^ v37 ^ v44;
    v398 = v123 ^ v43;
    v391 = v113 ^ v37 ^ v42;
    v383 = v102 ^ v37 ^ v41;
    v377 = v93 ^ v40;
    v369 = v82 ^ v39;
    v362 = v71 ^ v38;
    v31 = v71;
    v72 = v82;
    v83 = v93;
    v94 = v102;
    v103 = v31 ^ v113;
    v114 = v31 ^ v123;
    v124 = v132;
    v133 = v206 ^ v31 ^ v411 ^ v32;
    v125 = v197 ^ v124;
    v115 = v187 ^ v114;
    v104 = v176 ^ v103;
    v95 = v167 ^ v94;
    v84 = v156 ^ v83;
    v73 = v145 ^ v72;
    v30 = v145;
    v146 = v156;
    v157 = v167;
    v168 = v176;
    v177 = v30 ^ v187;
    v188 = v30 ^ v197;
    v198 = v206;
    v207 = v282 ^ v30 ^ v139 ^ v33;
    v199 = v273 ^ v198;
    v189 = v263 ^ v188;
    v178 = v251 ^ v177;
    v169 = v241 ^ v168;
    v158 = v230 ^ v157;
    v147 = v219 ^ v146;
    v29 = v219;
    v220 = v230;
    v231 = v241;
    v242 = v251;
    v252 = v29 ^ v263;
    v264 = v29 ^ v273;
    v274 = v282;
    v283 = v352 ^ v29 ^ v213 ^ v34;
    v275 = v344 ^ v274;
    v265 = v335 ^ v264;
    v253 = v324 ^ v252;
    v243 = v316 ^ v242;
    v232 = v306 ^ v231;
    v221 = v295 ^ v220;
    v28 = v295;
    v296 = v306;
    v307 = v316;
    v317 = v324;
    v325 = v28 ^ v335;
    v336 = v28 ^ v344;
    v345 = v352;
    v410 = v60 ^ v411 ^ v32 ^ v37;
    v403 = v59 ^ v405;
    v396 = v58 ^ v398;
    v389 = v56 ^ v391;
    v381 = v55 ^ v383;
    v375 = v54 ^ v377;
    v368 = v52 ^ v369;
    v361 = result ^ v362;
    v357 = result ^ v44 ^ v28;
    v350 = result ^ v60 ^ v43 ^ v28 ^ v289 ^ v35;
    v341 = v59 ^ v42 ^ v345;
    v332 = result ^ v58 ^ v41 ^ v336;
    v326 = result ^ v56 ^ v40 ^ v325;
    v297 = v52 ^ v37 ^ v296;
    v27 = v52;
    v288 = v52 ^ v289 ^ v35 ^ v29;
    v280 = v52 ^ result ^ v283;
    v270 = result ^ v60 ^ v275;
    v260 = v52 ^ v59 ^ v265;
    v254 = v52 ^ result ^ v58 ^ v253;
    v244 = result ^ v56 ^ v243;
    v53 = result ^ v56;
    v57 = v54 ^ result ^ v60;
    v212 = v54 ^ v213 ^ v34 ^ v30;
    v204 = v54 ^ v27 ^ v207;
    v194 = v27 ^ result ^ v199;
    v184 = v57 ^ v189;
    v138 = v55 ^ v139 ^ v33 ^ v31;
    v130 = v55 ^ v54 ^ v133;
    v120 = v54 ^ v27 ^ v125;
    v110 = v55 ^ v27 ^ result ^ v115;
    v321 = __ROR4__(v326, 31);
    v313 = __ROR4__(v55 ^ v39 ^ v317, 31);
    v303 = __ROR4__(v54 ^ v38 ^ v307, 31);
    v292 = __ROR4__(v297, 31);
    v248 = __ROR4__(v254, 30);
    v238 = __ROR4__(v244, 30);
    v227 = __ROR4__(v55 ^ v232, 30);
    v216 = __ROR4__(v54 ^ v221, 30);
    v173 = __ROR4__(v54 ^ v27 ^ v59 ^ v178, 29);
    v164 = __ROR4__(v27 ^ result ^ v58 ^ v169, 29);
    v153 = __ROR4__(v53 ^ v158, 29);
    v142 = __ROR4__(v55 ^ v147, 29);
    v99 = __ROR4__(v55 ^ v57 ^ v104, 28);
    v90 = __ROR4__(v54 ^ v27 ^ v59 ^ v95, 28);
    v79 = __ROR4__(v27 ^ result ^ v58 ^ v84, 28);
    v68 = __ROR4__(v53 ^ v73, 28);
    for ( j = 0; j <= 7; ++j )
    {
      v25 = v410;
      v399 = v389 ^ v396;
      v412 = v389 ^ (v403 | v410);
      v392 = v25 & v389;
      v406 = v392 ^ ~v403;
      v393 = v399 ^ v392;
      v400 = v406 ^ v412 & v399;
      v407 = v393 | v406;
      v26 = v407 ^ v25;
      v394 = v400 ^ v393;
      v401 = v407 & v400;
      v408 = ~v412 ^ v407;
      v23 = v375;
      v363 = v381 ^ v361;
      v378 = v381 ^ (v368 | v375);
      v384 = v23 & v381;
      v370 = v384 ^ ~v368;
      v385 = v363 ^ v384;
      v364 = v370 ^ v378 & v363;
      v371 = v385 | v370;
      v24 = v371 ^ v23;
      v386 = v364 ^ v385;
      v365 = v371 & v364;
      v372 = ~v378 ^ v371;
      v387 = v26 ^ v386;
      v413 = v387 ^ __ROR4__(v26, 30);
      v388 = v413 ^ __ROR4__(v387, 18);
      v379 = v408 ^ v24;
      v409 = v408 ^ v24 ^ __ROR4__(v408, 30);
      v380 = v409 ^ __ROR4__(v379, 18);
      v403 = v380 ^ __ROR4__(v409, 22);
      v375 = __ROR4__(v380, 31);
      v373 = v401 ^ v372;
      v402 = v373 ^ __ROR4__(v401, 30);
      v374 = v402 ^ __ROR4__(v373, 18);
      v396 = v374 ^ __ROR4__(v402, 22);
      v368 = __ROR4__(v374, 31);
      v366 = v394 ^ v365;
      v395 = v366 ^ __ROR4__(v394, 30);
      v367 = v395 ^ __ROR4__(v366, 18);
      v389 = v367 ^ __ROR4__(v395, 22);
      v361 = __ROR4__(v367, 31);
      v410 = dword_1D5C28[j] ^ v388 ^ __ROR4__(v413, 22);
      v381 = dword_1D5C48[j] ^ __ROR4__(v388, 31);
    }
    for ( k = 0; k <= 7; ++k )
    {
      v21 = v357;
      v346 = v332 ^ v341;
      v359 = v332 ^ (v350 | v357);
      v337 = v21 & v332;
      v353 = v337 ^ ~v350;
      v338 = v346 ^ v337;
      v347 = v353 ^ v359 & v346;
      v354 = v338 | v353;
      v22 = v354 ^ v21;
      v339 = v347 ^ v338;
      v348 = v354 & v347;
      v355 = ~v359 ^ v354;
      v19 = v313;
      v298 = v321 ^ v292;
      v318 = v321 ^ (v303 | v313);
      v327 = v19 & v321;
      v308 = v327 ^ ~v303;
      v328 = v298 ^ v327;
      v299 = v308 ^ v318 & v298;
      v309 = v328 | v308;
      v20 = v309 ^ v19;
      v329 = v299 ^ v328;
      v300 = v309 & v299;
      v310 = ~v318 ^ v309;
      v330 = v22 ^ v329;
      v360 = v330 ^ __ROR4__(v22, 30);
      v331 = v360 ^ __ROR4__(v330, 18);
      v319 = v355 ^ v20;
      v356 = v355 ^ v20 ^ __ROR4__(v355, 30);
      v320 = v356 ^ __ROR4__(v319, 18);
      v350 = v320 ^ __ROR4__(v356, 22);
      v313 = __ROR4__(v320, 31);
      v311 = v348 ^ v310;
      v349 = v311 ^ __ROR4__(v348, 30);
      v312 = v349 ^ __ROR4__(v311, 18);
      v341 = v312 ^ __ROR4__(v349, 22);
      v303 = __ROR4__(v312, 31);
      v301 = v339 ^ v300;
      v340 = v301 ^ __ROR4__(v339, 30);
      v302 = v340 ^ __ROR4__(v301, 18);
      v332 = v302 ^ __ROR4__(v340, 22);
      v292 = __ROR4__(v302, 31);
      v357 = dword_1D5C68[k] ^ v331 ^ __ROR4__(v360, 22);
      v321 = dword_1D5C88[k] ^ __ROR4__(v331, 31);
    }
    for ( m = 0; m <= 7; ++m )
    {
      v17 = v288;
      v276 = v260 ^ v270;
      v290 = v260 ^ (v280 | v288);
      v266 = v17 & v260;
      v284 = v266 ^ ~v280;
      v267 = v276 ^ v266;
      v277 = v284 ^ v290 & v276;
      v285 = v267 | v284;
      v18 = v285 ^ v17;
      v268 = v277 ^ v267;
      v278 = v285 & v277;
      v286 = ~v290 ^ v285;
      v15 = v238;
      v222 = v248 ^ v216;
      v245 = v248 ^ (v227 | v238);
      v255 = v15 & v248;
      v233 = v255 ^ ~v227;
      v256 = v222 ^ v255;
      v223 = v233 ^ v245 & v222;
      v234 = v256 | v233;
      v16 = v234 ^ v15;
      v257 = v223 ^ v256;
      v224 = v234 & v223;
      v235 = ~v245 ^ v234;
      v258 = v18 ^ v257;
      v291 = v258 ^ __ROR4__(v18, 30);
      v259 = v291 ^ __ROR4__(v258, 18);
      v246 = v286 ^ v16;
      v287 = v286 ^ v16 ^ __ROR4__(v286, 30);
      v247 = v287 ^ __ROR4__(v246, 18);
      v280 = v247 ^ __ROR4__(v287, 22);
      v238 = __ROR4__(v247, 31);
      v236 = v278 ^ v235;
      v279 = v236 ^ __ROR4__(v278, 30);
      v237 = v279 ^ __ROR4__(v236, 18);
      v270 = v237 ^ __ROR4__(v279, 22);
      v227 = __ROR4__(v237, 31);
      v225 = v268 ^ v224;
      v269 = v225 ^ __ROR4__(v268, 30);
      v226 = v269 ^ __ROR4__(v225, 18);
      v260 = v226 ^ __ROR4__(v269, 22);
      v216 = __ROR4__(v226, 31);
      v288 = dword_1D5CA8[m] ^ v259 ^ __ROR4__(v291, 22);
      v248 = dword_1D5CC8[m] ^ __ROR4__(v259, 31);
    }
    for ( n = 0; n <= 7; ++n )
    {
      v13 = v212;
      v200 = v184 ^ v194;
      v214 = v184 ^ (v204 | v212);
      v190 = v13 & v184;
      v208 = v190 ^ ~v204;
      v191 = v200 ^ v190;
      v201 = v208 ^ v214 & v200;
      v209 = v191 | v208;
      v14 = v209 ^ v13;
      v192 = v201 ^ v191;
      v202 = v209 & v201;
      v210 = ~v214 ^ v209;
      v11 = v164;
      v148 = v173 ^ v142;
      v170 = v173 ^ (v153 | v164);
      v179 = v11 & v173;
      v159 = v179 ^ ~v153;
      v180 = v148 ^ v179;
      v149 = v159 ^ v170 & v148;
      v160 = v180 | v159;
      v12 = v160 ^ v11;
      v181 = v149 ^ v180;
      v150 = v160 & v149;
      v161 = ~v170 ^ v160;
      v182 = v14 ^ v181;
      v215 = v182 ^ __ROR4__(v14, 30);
      v183 = v215 ^ __ROR4__(v182, 18);
      v171 = v210 ^ v12;
      v211 = v210 ^ v12 ^ __ROR4__(v210, 30);
      v172 = v211 ^ __ROR4__(v171, 18);
      v204 = v172 ^ __ROR4__(v211, 22);
      v164 = __ROR4__(v172, 31);
      v162 = v202 ^ v161;
      v203 = v162 ^ __ROR4__(v202, 30);
      v163 = v203 ^ __ROR4__(v162, 18);
      v194 = v163 ^ __ROR4__(v203, 22);
      v153 = __ROR4__(v163, 31);
      v151 = v192 ^ v150;
      v193 = v151 ^ __ROR4__(v192, 30);
      v152 = v193 ^ __ROR4__(v151, 18);
      v184 = v152 ^ __ROR4__(v193, 22);
      v142 = __ROR4__(v152, 31);
      v212 = dword_1D5CE8[n] ^ v183 ^ __ROR4__(v215, 22);
      v173 = dword_1D5D08[n] ^ __ROR4__(v183, 31);
    }
    for ( ii = 0; ii <= 7; ++ii )
    {
      v9 = v138;
      v126 = v110 ^ v120;
      v140 = v110 ^ (v130 | v138);
      v116 = v9 & v110;
      v134 = v116 ^ ~v130;
      v117 = v126 ^ v116;
      v127 = v134 ^ v140 & v126;
      v135 = v117 | v134;
      v10 = v135 ^ v9;
      v118 = v127 ^ v117;
      v128 = v135 & v127;
      v136 = ~v140 ^ v135;
      v7 = v90;
      v74 = v99 ^ v68;
      v96 = v99 ^ (v79 | v90);
      v105 = v7 & v99;
      v85 = v105 ^ ~v79;
      v106 = v74 ^ v105;
      v75 = v85 ^ v96 & v74;
      v86 = v106 | v85;
      v8 = v86 ^ v7;
      v107 = v75 ^ v106;
      v76 = v86 & v75;
      v87 = ~v96 ^ v86;
      v108 = v10 ^ v107;
      v141 = v108 ^ __ROR4__(v10, 30);
      v109 = v141 ^ __ROR4__(v108, 18);
      v97 = v136 ^ v8;
      v137 = v136 ^ v8 ^ __ROR4__(v136, 30);
      v98 = v137 ^ __ROR4__(v97, 18);
      v130 = v98 ^ __ROR4__(v137, 22);
      v90 = __ROR4__(v98, 31);
      v88 = v128 ^ v87;
      v129 = v88 ^ __ROR4__(v128, 30);
      v89 = v129 ^ __ROR4__(v88, 18);
      v120 = v89 ^ __ROR4__(v129, 22);
      v79 = __ROR4__(v89, 31);
      v77 = v118 ^ v76;
      v119 = v77 ^ __ROR4__(v118, 30);
      v78 = v119 ^ __ROR4__(v77, 18);
      v110 = v78 ^ __ROR4__(v119, 22);
      v68 = __ROR4__(v78, 31);
      v138 = dword_1D5D28[ii] ^ v109 ^ __ROR4__(v141, 22);
      v99 = dword_1D5D48[ii] ^ __ROR4__(v109, 31);
    }
    switch ( i )
    {
      case 1:
        sub_15C9F0(a4, v138 ^ v410 ^ v357 ^ v288 ^ v212);
        sub_15C9F0(a4 + 4, v130 ^ v403 ^ v350 ^ v280 ^ v204);
        sub_15C9F0(a4 + 8, v120 ^ v396 ^ v341 ^ v270 ^ v194);
        sub_15C9F0(a4 + 12, v110 ^ v389 ^ v332 ^ v260 ^ v184);
        sub_15C9F0(a4 + 16, v99 ^ v381 ^ v321 ^ v248 ^ v173);
        sub_15C9F0(a4 + 20, v90 ^ v375 ^ v313 ^ v238 ^ v164);
        sub_15C9F0(a4 + 24, v79 ^ v368 ^ v303 ^ v227 ^ v153);
        result = (unsigned int)sub_15C9F0(a4 + 28, v68 ^ v361 ^ v292 ^ v216 ^ v142);
        break;
      case 2:
        sub_15C9F0(a4 + 32, v138 ^ v410 ^ v357 ^ v288 ^ v212);
        sub_15C9F0(a4 + 36, v130 ^ v403 ^ v350 ^ v280 ^ v204);
        sub_15C9F0(a4 + 40, v120 ^ v396 ^ v341 ^ v270 ^ v194);
        sub_15C9F0(a4 + 44, v110 ^ v389 ^ v332 ^ v260 ^ v184);
        sub_15C9F0(a4 + 48, v99 ^ v381 ^ v321 ^ v248 ^ v173);
        sub_15C9F0(a4 + 52, v90 ^ v375 ^ v313 ^ v238 ^ v164);
        sub_15C9F0(a4 + 56, v79 ^ v368 ^ v303 ^ v227 ^ v153);
        result = (unsigned int)sub_15C9F0(a4 + 60, v68 ^ v361 ^ v292 ^ v216 ^ v142);
        break;
      case 0:
        result = (unsigned int)memset(a1, 0, 0x20u);
        break;
    }
  }
  return result;
}
// 1D5C28: using guessed type _DWORD dword_1D5C28[8];
// 1D5C48: using guessed type _DWORD dword_1D5C48[8];
// 1D5C68: using guessed type _DWORD dword_1D5C68[8];
// 1D5C88: using guessed type _DWORD dword_1D5C88[8];
// 1D5CA8: using guessed type _DWORD dword_1D5CA8[8];
// 1D5CC8: using guessed type _DWORD dword_1D5CC8[8];
// 1D5CE8: using guessed type _DWORD dword_1D5CE8[8];
// 1D5D08: using guessed type _DWORD dword_1D5D08[8];
// 1D5D28: using guessed type _DWORD dword_1D5D28[8];
// 1D5D48: using guessed type _DWORD dword_1D5D48[8];

//----- (00167120) --------------------------------------------------------
void *__fastcall sph_luffa224_init(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_1D5B88, 0x60u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (00167150) --------------------------------------------------------
unsigned int __fastcall sph_luffa224(unsigned int a1, char *a2, size_t a3)
{
  return sub_15CA50(a1, a2, a3);
}

//----- (00167170) --------------------------------------------------------
void *__fastcall sph_luffa224_close(int *a1, _BYTE *a2)
{
  return sph_luffa224_addbits_and_close(a1, 0, 0, a2);
}

//----- (00167190) --------------------------------------------------------
void *__fastcall sph_luffa224_addbits_and_close(int *a1, char a2, char a3, _BYTE *a4)
{
  sub_15DA48(a1, a2, a3, a4, 7u);
  return sph_luffa224_init((int)a1);
}

//----- (001671BC) --------------------------------------------------------
void *__fastcall sph_luffa256_init(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_1D5B88, 0x60u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (001671EC) --------------------------------------------------------
unsigned int __fastcall sph_luffa256(unsigned int a1, char *a2, size_t a3)
{
  return sub_15CA50(a1, a2, a3);
}

//----- (0016720C) --------------------------------------------------------
void *__fastcall sph_luffa256_close(int *a1, _BYTE *a2)
{
  return sph_luffa256_addbits_and_close(a1, 0, 0, a2);
}

//----- (0016722C) --------------------------------------------------------
void *__fastcall sph_luffa256_addbits_and_close(int *a1, char a2, char a3, _BYTE *a4)
{
  sub_15DA48(a1, a2, a3, a4, 8u);
  return sph_luffa256_init((int)a1);
}

//----- (00167258) --------------------------------------------------------
void *__fastcall sph_luffa384_init(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_1D5B88, 0x80u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (00167288) --------------------------------------------------------
unsigned int __fastcall sph_luffa384(unsigned int a1, char *a2, size_t a3)
{
  return sub_15EA68(a1, a2, a3);
}

//----- (001672A8) --------------------------------------------------------
void *__fastcall sph_luffa384_close(int *a1, _BYTE *a2)
{
  return sph_luffa384_addbits_and_close(a1, 0, 0, a2);
}

//----- (001672C8) --------------------------------------------------------
void *__fastcall sph_luffa384_addbits_and_close(int *a1, char a2, char a3, _BYTE *a4)
{
  sub_1605D0(a1, a2, a3, a4);
  return sph_luffa384_init((int)a1);
}

//----- (001672F0) --------------------------------------------------------
void *__fastcall sph_luffa512_init(int a1)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), &unk_1D5B88, 0xA0u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (00167320) --------------------------------------------------------
unsigned int __fastcall sph_luffa512(unsigned int a1, char *a2, size_t a3)
{
  return sub_16214C(a1, a2, a3);
}

//----- (00167340) --------------------------------------------------------
void *__fastcall sph_luffa512_close(int *a1, _BYTE *a2)
{
  return sph_luffa512_addbits_and_close(a1, 0, 0, a2);
}

//----- (00167360) --------------------------------------------------------
void *__fastcall sph_luffa512_addbits_and_close(int *a1, char a2, char a3, _BYTE *a4)
{
  sub_1648F0(a1, a2, a3, a4);
  return sph_luffa512_init((int)a1);
}

//----- (00167388) --------------------------------------------------------
_WORD *__fastcall sub_167388(_WORD *result, __int16 a2)
{
  *result = a2;
  return result;
}

//----- (001673B4) --------------------------------------------------------
_DWORD *__fastcall sub_1673B4(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

//----- (001673D0) --------------------------------------------------------
int __fastcall sub_1673D0(int a1)
{
  return *(_DWORD *)a1;
}

//----- (001673E8) --------------------------------------------------------
_DWORD *__fastcall sub_1673E8(_DWORD *result, int a2)
{
  result[50] = a2;
  result[53] = 0;
  result[52] = result[53];
  result[51] = result[52];
  result[54] = a2;
  result[57] = 0;
  result[56] = result[57];
  result[55] = result[56];
  result[58] = a2;
  result[61] = 0;
  result[60] = result[61];
  result[59] = result[60];
  result[62] = a2;
  result[65] = 0;
  result[64] = result[65];
  result[63] = result[64];
  result[48] = 0;
  result[69] = 0;
  result[68] = result[69];
  result[67] = result[68];
  result[66] = result[67];
  return result;
}

//----- (001674D4) --------------------------------------------------------
_DWORD *__fastcall sub_1674D4(_DWORD *result, int a2)
{
  result[34] = a2;
  result[37] = 0;
  result[36] = result[37];
  result[35] = result[36];
  result[38] = a2;
  result[41] = 0;
  result[40] = result[41];
  result[39] = result[40];
  result[42] = a2;
  result[45] = 0;
  result[44] = result[45];
  result[43] = result[44];
  result[46] = a2;
  result[49] = 0;
  result[48] = result[49];
  result[47] = result[48];
  result[50] = a2;
  result[53] = 0;
  result[52] = result[53];
  result[51] = result[52];
  result[54] = a2;
  result[57] = 0;
  result[56] = result[57];
  result[55] = result[56];
  result[58] = a2;
  result[61] = 0;
  result[60] = result[61];
  result[59] = result[60];
  result[62] = a2;
  result[65] = 0;
  result[64] = result[65];
  result[63] = result[64];
  result[32] = 0;
  result[69] = 0;
  result[68] = result[69];
  result[67] = result[68];
  result[66] = result[67];
  return result;
}

//----- (00167660) --------------------------------------------------------
void *__fastcall sub_167660(_DWORD *a1)
{
  void *result; // r0
  unsigned int v2; // r4
  unsigned int v3; // r4
  unsigned int v4; // r4
  unsigned int v5; // r4
  int v6; // r4
  int v7; // r4
  int v8; // r0
  int v9; // r2
  _OWORD dest[4]; // [sp+8h] [bp+8h] BYREF
  unsigned int v12; // [sp+48h] [bp+48h]
  unsigned int v13; // [sp+4Ch] [bp+4Ch]
  unsigned int v14; // [sp+50h] [bp+50h]
  unsigned int v15; // [sp+54h] [bp+54h]
  unsigned int v16; // [sp+58h] [bp+58h]
  unsigned int v17; // [sp+5Ch] [bp+5Ch]
  unsigned int v18; // [sp+60h] [bp+60h]
  unsigned int v19; // [sp+64h] [bp+64h]
  unsigned int v20; // [sp+68h] [bp+68h]
  unsigned int v21; // [sp+6Ch] [bp+6Ch]
  unsigned int v22; // [sp+70h] [bp+70h]
  unsigned int v23; // [sp+74h] [bp+74h]
  unsigned int v24; // [sp+78h] [bp+78h]
  unsigned int v25; // [sp+7Ch] [bp+7Ch]
  unsigned int v26; // [sp+80h] [bp+80h]
  unsigned int v27; // [sp+84h] [bp+84h]
  unsigned int v28; // [sp+88h] [bp+88h]
  unsigned int v29; // [sp+8Ch] [bp+8Ch]
  unsigned int v30; // [sp+90h] [bp+90h]
  unsigned int v31; // [sp+94h] [bp+94h]
  unsigned int v32; // [sp+98h] [bp+98h]
  unsigned int v33; // [sp+9Ch] [bp+9Ch]
  unsigned int v34; // [sp+A0h] [bp+A0h]
  unsigned int v35; // [sp+A4h] [bp+A4h]
  unsigned int v36; // [sp+A8h] [bp+A8h]
  unsigned int v37; // [sp+ACh] [bp+ACh]
  unsigned int v38; // [sp+B0h] [bp+B0h]
  unsigned int v39; // [sp+B4h] [bp+B4h]
  unsigned int v40; // [sp+B8h] [bp+B8h]
  unsigned int v41; // [sp+BCh] [bp+BCh]
  unsigned int v42; // [sp+C0h] [bp+C0h]
  unsigned int v43; // [sp+C4h] [bp+C4h]
  unsigned int v44; // [sp+C8h] [bp+C8h]
  unsigned int v45; // [sp+CCh] [bp+CCh]
  unsigned int v46; // [sp+D0h] [bp+D0h]
  unsigned int v47; // [sp+D4h] [bp+D4h]
  unsigned int v48; // [sp+D8h] [bp+D8h]
  unsigned int v49; // [sp+DCh] [bp+DCh]
  unsigned int v50; // [sp+E0h] [bp+E0h]
  unsigned int v51; // [sp+E4h] [bp+E4h]
  unsigned int v52; // [sp+E8h] [bp+E8h]
  unsigned int v53; // [sp+ECh] [bp+ECh]
  unsigned int v54; // [sp+F0h] [bp+F0h]
  unsigned int v55; // [sp+F4h] [bp+F4h]
  unsigned int v56; // [sp+F8h] [bp+F8h]
  unsigned int v57; // [sp+FCh] [bp+FCh]
  unsigned int v58; // [sp+100h] [bp+100h]
  unsigned int v59; // [sp+104h] [bp+104h]
  _OWORD *v60; // [sp+108h] [bp+108h]
  _DWORD *v61; // [sp+10Ch] [bp+10Ch]
  unsigned int v62; // [sp+110h] [bp+110h]
  unsigned int v63; // [sp+114h] [bp+114h]
  unsigned int v64; // [sp+118h] [bp+118h]
  int v65; // [sp+11Ch] [bp+11Ch]
  int v66; // [sp+120h] [bp+120h]
  int v67; // [sp+124h] [bp+124h]
  unsigned int v68; // [sp+128h] [bp+128h]
  unsigned int v69; // [sp+12Ch] [bp+12Ch]
  unsigned int v70; // [sp+130h] [bp+130h]
  unsigned int v71; // [sp+134h] [bp+134h]
  unsigned int v72; // [sp+138h] [bp+138h]
  unsigned int v73; // [sp+13Ch] [bp+13Ch]
  unsigned int v74; // [sp+140h] [bp+140h]
  int v75; // [sp+144h] [bp+144h]
  int v76; // [sp+148h] [bp+148h]
  int v77; // [sp+14Ch] [bp+14Ch]
  unsigned int v78; // [sp+150h] [bp+150h]
  unsigned int v79; // [sp+154h] [bp+154h]
  unsigned int v80; // [sp+158h] [bp+158h]
  unsigned int v81; // [sp+15Ch] [bp+15Ch]
  unsigned int v82; // [sp+160h] [bp+160h]
  unsigned int v83; // [sp+164h] [bp+164h]
  unsigned int v84; // [sp+168h] [bp+168h]
  int v85; // [sp+16Ch] [bp+16Ch]
  int v86; // [sp+170h] [bp+170h]
  int v87; // [sp+174h] [bp+174h]
  unsigned int v88; // [sp+178h] [bp+178h]
  unsigned int v89; // [sp+17Ch] [bp+17Ch]
  unsigned int v90; // [sp+180h] [bp+180h]
  unsigned int v91; // [sp+184h] [bp+184h]
  unsigned int v92; // [sp+188h] [bp+188h]
  unsigned int v93; // [sp+18Ch] [bp+18Ch]
  unsigned int v94; // [sp+190h] [bp+190h]
  int v95; // [sp+194h] [bp+194h]
  int v96; // [sp+198h] [bp+198h]
  int v97; // [sp+19Ch] [bp+19Ch]
  unsigned int v98; // [sp+1A0h] [bp+1A0h]
  unsigned int v99; // [sp+1A4h] [bp+1A4h]
  unsigned int v100; // [sp+1A8h] [bp+1A8h]
  unsigned int v101; // [sp+1ACh] [bp+1ACh]
  unsigned int v102; // [sp+1B0h] [bp+1B0h]
  unsigned int v103; // [sp+1B4h] [bp+1B4h]
  unsigned int v104; // [sp+1B8h] [bp+1B8h]
  int v105; // [sp+1BCh] [bp+1BCh]
  int v106; // [sp+1C0h] [bp+1C0h]
  int v107; // [sp+1C4h] [bp+1C4h]
  unsigned int v108; // [sp+1C8h] [bp+1C8h]
  unsigned int v109; // [sp+1CCh] [bp+1CCh]
  unsigned int v110; // [sp+1D0h] [bp+1D0h]
  unsigned int v111; // [sp+1D4h] [bp+1D4h]
  unsigned int v112; // [sp+1D8h] [bp+1D8h]
  unsigned int v113; // [sp+1DCh] [bp+1DCh]
  unsigned int v114; // [sp+1E0h] [bp+1E0h]
  int v115; // [sp+1E4h] [bp+1E4h]
  int v116; // [sp+1E8h] [bp+1E8h]
  int v117; // [sp+1ECh] [bp+1ECh]
  unsigned int v118; // [sp+1F0h] [bp+1F0h]
  unsigned int v119; // [sp+1F4h] [bp+1F4h]
  unsigned int v120; // [sp+1F8h] [bp+1F8h]
  unsigned int v121; // [sp+1FCh] [bp+1FCh]
  unsigned int v122; // [sp+200h] [bp+200h]
  unsigned int v123; // [sp+204h] [bp+204h]
  unsigned int v124; // [sp+208h] [bp+208h]
  int v125; // [sp+20Ch] [bp+20Ch]
  int v126; // [sp+210h] [bp+210h]
  int v127; // [sp+214h] [bp+214h]
  unsigned int v128; // [sp+218h] [bp+218h]
  unsigned int v129; // [sp+21Ch] [bp+21Ch]
  unsigned int v130; // [sp+220h] [bp+220h]
  unsigned int v131; // [sp+224h] [bp+224h]
  unsigned int v132; // [sp+228h] [bp+228h]
  unsigned int v133; // [sp+22Ch] [bp+22Ch]
  unsigned int v134; // [sp+230h] [bp+230h]
  int v135; // [sp+234h] [bp+234h]
  int v136; // [sp+238h] [bp+238h]
  int v137; // [sp+23Ch] [bp+23Ch]
  unsigned int v138; // [sp+240h] [bp+240h]
  unsigned int v139; // [sp+244h] [bp+244h]
  unsigned int v140; // [sp+248h] [bp+248h]
  unsigned int v141; // [sp+24Ch] [bp+24Ch]
  unsigned int v142; // [sp+250h] [bp+250h]
  unsigned int v143; // [sp+254h] [bp+254h]
  unsigned int v144; // [sp+258h] [bp+258h]
  int v145; // [sp+25Ch] [bp+25Ch]
  int v146; // [sp+260h] [bp+260h]
  int v147; // [sp+264h] [bp+264h]
  unsigned int v148; // [sp+268h] [bp+268h]
  unsigned int v149; // [sp+26Ch] [bp+26Ch]
  unsigned int v150; // [sp+270h] [bp+270h]
  unsigned int v151; // [sp+274h] [bp+274h]
  unsigned int v152; // [sp+278h] [bp+278h]
  unsigned int v153; // [sp+27Ch] [bp+27Ch]
  unsigned int v154; // [sp+280h] [bp+280h]
  int v155; // [sp+284h] [bp+284h]
  int v156; // [sp+288h] [bp+288h]
  int v157; // [sp+28Ch] [bp+28Ch]
  unsigned int v158; // [sp+290h] [bp+290h]
  unsigned int v159; // [sp+294h] [bp+294h]
  unsigned int v160; // [sp+298h] [bp+298h]
  unsigned int v161; // [sp+29Ch] [bp+29Ch]
  unsigned int v162; // [sp+2A0h] [bp+2A0h]
  unsigned int v163; // [sp+2A4h] [bp+2A4h]
  unsigned int v164; // [sp+2A8h] [bp+2A8h]
  int v165; // [sp+2ACh] [bp+2ACh]
  int v166; // [sp+2B0h] [bp+2B0h]
  int v167; // [sp+2B4h] [bp+2B4h]
  unsigned int v168; // [sp+2B8h] [bp+2B8h]
  unsigned int v169; // [sp+2BCh] [bp+2BCh]
  unsigned int v170; // [sp+2C0h] [bp+2C0h]
  unsigned int v171; // [sp+2C4h] [bp+2C4h]
  unsigned int v172; // [sp+2C8h] [bp+2C8h]
  unsigned int v173; // [sp+2CCh] [bp+2CCh]
  unsigned int v174; // [sp+2D0h] [bp+2D0h]
  int v175; // [sp+2D4h] [bp+2D4h]
  int v176; // [sp+2D8h] [bp+2D8h]
  int v177; // [sp+2DCh] [bp+2DCh]
  unsigned int v178; // [sp+2E0h] [bp+2E0h]
  unsigned int v179; // [sp+2E4h] [bp+2E4h]
  unsigned int v180; // [sp+2E8h] [bp+2E8h]
  unsigned int v181; // [sp+2ECh] [bp+2ECh]
  unsigned int v182; // [sp+2F0h] [bp+2F0h]
  unsigned int v183; // [sp+2F4h] [bp+2F4h]
  unsigned int v184; // [sp+2F8h] [bp+2F8h]
  int v185; // [sp+2FCh] [bp+2FCh]
  int v186; // [sp+300h] [bp+300h]
  int v187; // [sp+304h] [bp+304h]
  unsigned int v188; // [sp+308h] [bp+308h]
  int v189; // [sp+30Ch] [bp+30Ch]
  unsigned int v190; // [sp+310h] [bp+310h]
  int v191; // [sp+314h] [bp+314h]
  unsigned int v192; // [sp+318h] [bp+318h]
  unsigned int v193; // [sp+31Ch] [bp+31Ch]
  unsigned int v194; // [sp+320h] [bp+320h]
  int v195; // [sp+324h] [bp+324h]
  int v196; // [sp+328h] [bp+328h]
  int v197; // [sp+32Ch] [bp+32Ch]
  int v198; // [sp+330h] [bp+330h]
  int v199; // [sp+334h] [bp+334h]
  int v200; // [sp+338h] [bp+338h]
  int v201; // [sp+33Ch] [bp+33Ch]
  unsigned int v202; // [sp+340h] [bp+340h]
  unsigned int v203; // [sp+344h] [bp+344h]
  unsigned int v204; // [sp+348h] [bp+348h]
  int v205; // [sp+34Ch] [bp+34Ch]
  int v206; // [sp+350h] [bp+350h]
  int v207; // [sp+354h] [bp+354h]
  int v208; // [sp+358h] [bp+358h]
  int v209; // [sp+35Ch] [bp+35Ch]
  int v210; // [sp+360h] [bp+360h]
  int v211; // [sp+364h] [bp+364h]
  unsigned int v212; // [sp+368h] [bp+368h]
  unsigned int v213; // [sp+36Ch] [bp+36Ch]
  unsigned int v214; // [sp+370h] [bp+370h]
  int v215; // [sp+374h] [bp+374h]
  int v216; // [sp+378h] [bp+378h]
  int v217; // [sp+37Ch] [bp+37Ch]
  int v218; // [sp+380h] [bp+380h]
  int v219; // [sp+384h] [bp+384h]
  int v220; // [sp+388h] [bp+388h]
  int v221; // [sp+38Ch] [bp+38Ch]
  unsigned int v222; // [sp+390h] [bp+390h]
  unsigned int v223; // [sp+394h] [bp+394h]
  unsigned int v224; // [sp+398h] [bp+398h]
  unsigned int v225; // [sp+39Ch] [bp+39Ch]
  unsigned int v226; // [sp+3A0h] [bp+3A0h]
  unsigned int v227; // [sp+3A4h] [bp+3A4h]
  unsigned int v228; // [sp+3A8h] [bp+3A8h]
  unsigned int v229; // [sp+3ACh] [bp+3ACh]
  unsigned int v230; // [sp+3B0h] [bp+3B0h]
  unsigned int v231; // [sp+3B4h] [bp+3B4h]
  unsigned int v232; // [sp+3B8h] [bp+3B8h]
  unsigned int v233; // [sp+3BCh] [bp+3BCh]
  unsigned int v234; // [sp+3C0h] [bp+3C0h]
  unsigned int v235; // [sp+3C4h] [bp+3C4h]
  unsigned int v236; // [sp+3C8h] [bp+3C8h]
  unsigned int v237; // [sp+3CCh] [bp+3CCh]
  unsigned int v238; // [sp+3D0h] [bp+3D0h]
  unsigned int v239; // [sp+3D4h] [bp+3D4h]
  unsigned int v240; // [sp+3D8h] [bp+3D8h]
  unsigned int v241; // [sp+3DCh] [bp+3DCh]
  unsigned int v242; // [sp+3E0h] [bp+3E0h]
  unsigned int v243; // [sp+3E4h] [bp+3E4h]
  unsigned int v244; // [sp+3E8h] [bp+3E8h]
  unsigned int v245; // [sp+3ECh] [bp+3ECh]
  unsigned int v246; // [sp+3F0h] [bp+3F0h]
  unsigned int v247; // [sp+3F4h] [bp+3F4h]
  unsigned int v248; // [sp+3F8h] [bp+3F8h]
  unsigned int v249; // [sp+3FCh] [bp+3FCh]
  unsigned int v250; // [sp+400h] [bp+400h]
  unsigned int v251; // [sp+404h] [bp+404h]
  unsigned int v252; // [sp+408h] [bp+408h]
  unsigned int v253; // [sp+40Ch] [bp+40Ch]
  unsigned int v254; // [sp+410h] [bp+410h]
  unsigned int v255; // [sp+414h] [bp+414h]
  unsigned int v256; // [sp+418h] [bp+418h]
  unsigned int v257; // [sp+41Ch] [bp+41Ch]
  unsigned int v258; // [sp+420h] [bp+420h]
  unsigned int v259; // [sp+424h] [bp+424h]
  unsigned int v260; // [sp+428h] [bp+428h]
  unsigned int v261; // [sp+42Ch] [bp+42Ch]
  unsigned int v262; // [sp+430h] [bp+430h]
  unsigned int v263; // [sp+434h] [bp+434h]
  unsigned int v264; // [sp+438h] [bp+438h]
  unsigned int v265; // [sp+43Ch] [bp+43Ch]
  unsigned int v266; // [sp+440h] [bp+440h]
  unsigned int v267; // [sp+444h] [bp+444h]
  unsigned int v268; // [sp+448h] [bp+448h]
  unsigned int v269; // [sp+44Ch] [bp+44Ch]
  unsigned int v270; // [sp+450h] [bp+450h]
  unsigned int v271; // [sp+454h] [bp+454h]
  unsigned int v272; // [sp+458h] [bp+458h]
  unsigned int v273; // [sp+45Ch] [bp+45Ch]
  unsigned int v274; // [sp+460h] [bp+460h]
  unsigned int v275; // [sp+464h] [bp+464h]
  unsigned int v276; // [sp+468h] [bp+468h]
  unsigned int v277; // [sp+46Ch] [bp+46Ch]
  unsigned int v278; // [sp+470h] [bp+470h]
  unsigned int v279; // [sp+474h] [bp+474h]
  unsigned int v280; // [sp+478h] [bp+478h]
  unsigned int v281; // [sp+47Ch] [bp+47Ch]
  unsigned int v282; // [sp+480h] [bp+480h]
  unsigned int v283; // [sp+484h] [bp+484h]
  unsigned int v284; // [sp+488h] [bp+488h]
  unsigned int v285; // [sp+48Ch] [bp+48Ch]
  unsigned int v286; // [sp+490h] [bp+490h]
  unsigned int v287; // [sp+494h] [bp+494h]
  unsigned int v288; // [sp+498h] [bp+498h]
  unsigned int k; // [sp+49Ch] [bp+49Ch]
  unsigned int i; // [sp+4A0h] [bp+4A0h]
  unsigned int j; // [sp+4A4h] [bp+4A4h]
  int v292; // [sp+4A8h] [bp+4A8h]
  int v293; // [sp+4ACh] [bp+4ACh]
  int v294; // [sp+4B0h] [bp+4B0h]
  int v295; // [sp+4B4h] [bp+4B4h]

  v295 = a1[66];
  v294 = a1[67];
  v293 = a1[68];
  v292 = a1[69];
  result = memcpy(dest, a1 + 50, sizeof(dest));
  for ( i = 0; i <= 0xB; ++i )
  {
    v2 = i + 4;
    LODWORD(dest[v2]) = sub_1673D0((int)&a1[4 * i]);
    v3 = i + 4;
    DWORD1(dest[v3]) = sub_1673D0((int)&a1[4 * i + 1]);
    v4 = i + 4;
    DWORD2(dest[v4]) = sub_1673D0((int)&a1[4 * i + 2]);
    v5 = i + 4;
    result = (void *)sub_1673D0((int)&a1[4 * i + 3]);
    HIDWORD(dest[v5]) = result;
  }
  for ( j = 0; j <= 7; ++j )
  {
    v288 = v295
         ^ dword_1D5D68[LOBYTE(dest[0])]
         ^ dword_1D6168[BYTE5(dest[0])]
         ^ dword_1D6568[BYTE10(dest[0])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[0]))];
    v287 = v294
         ^ dword_1D5D68[BYTE4(dest[0])]
         ^ dword_1D6168[BYTE9(dest[0])]
         ^ dword_1D6568[BYTE14(dest[0])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[0]))];
    v286 = v293
         ^ dword_1D5D68[BYTE8(dest[0])]
         ^ dword_1D6168[BYTE13(dest[0])]
         ^ dword_1D6568[BYTE2(dest[0])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[0]))];
    v285 = v292
         ^ dword_1D5D68[BYTE12(dest[0])]
         ^ dword_1D6168[BYTE1(dest[0])]
         ^ dword_1D6568[BYTE6(dest[0])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[0]))];
    LODWORD(dest[0]) = dword_1D5D68[(unsigned __int8)v288]
                     ^ dword_1D6168[BYTE1(v287)]
                     ^ dword_1D6568[BYTE2(v286)]
                     ^ dword_1D6968[HIBYTE(v285)];
    DWORD1(dest[0]) = dword_1D5D68[(unsigned __int8)v287]
                    ^ dword_1D6168[BYTE1(v286)]
                    ^ dword_1D6568[BYTE2(v285)]
                    ^ dword_1D6968[HIBYTE(v288)];
    DWORD2(dest[0]) = dword_1D5D68[(unsigned __int8)v286]
                    ^ dword_1D6168[BYTE1(v285)]
                    ^ dword_1D6568[BYTE2(v288)]
                    ^ dword_1D6968[HIBYTE(v287)];
    HIDWORD(dest[0]) = dword_1D5D68[(unsigned __int8)v285]
                     ^ dword_1D6168[BYTE1(v288)]
                     ^ dword_1D6568[BYTE2(v287)]
                     ^ dword_1D6968[HIBYTE(v286)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v284 = v295
         ^ dword_1D5D68[LOBYTE(dest[1])]
         ^ dword_1D6168[BYTE5(dest[1])]
         ^ dword_1D6568[BYTE10(dest[1])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[1]))];
    v283 = v294
         ^ dword_1D5D68[BYTE4(dest[1])]
         ^ dword_1D6168[BYTE9(dest[1])]
         ^ dword_1D6568[BYTE14(dest[1])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[1]))];
    v282 = v293
         ^ dword_1D5D68[BYTE8(dest[1])]
         ^ dword_1D6168[BYTE13(dest[1])]
         ^ dword_1D6568[BYTE2(dest[1])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[1]))];
    v281 = v292
         ^ dword_1D5D68[BYTE12(dest[1])]
         ^ dword_1D6168[BYTE1(dest[1])]
         ^ dword_1D6568[BYTE6(dest[1])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[1]))];
    LODWORD(dest[1]) = dword_1D5D68[(unsigned __int8)v284]
                     ^ dword_1D6168[BYTE1(v283)]
                     ^ dword_1D6568[BYTE2(v282)]
                     ^ dword_1D6968[HIBYTE(v281)];
    DWORD1(dest[1]) = dword_1D5D68[(unsigned __int8)v283]
                    ^ dword_1D6168[BYTE1(v282)]
                    ^ dword_1D6568[BYTE2(v281)]
                    ^ dword_1D6968[HIBYTE(v284)];
    DWORD2(dest[1]) = dword_1D5D68[(unsigned __int8)v282]
                    ^ dword_1D6168[BYTE1(v281)]
                    ^ dword_1D6568[BYTE2(v284)]
                    ^ dword_1D6968[HIBYTE(v283)];
    HIDWORD(dest[1]) = dword_1D5D68[(unsigned __int8)v281]
                     ^ dword_1D6168[BYTE1(v284)]
                     ^ dword_1D6568[BYTE2(v283)]
                     ^ dword_1D6968[HIBYTE(v282)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v280 = v295
         ^ dword_1D5D68[LOBYTE(dest[2])]
         ^ dword_1D6168[BYTE5(dest[2])]
         ^ dword_1D6568[BYTE10(dest[2])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[2]))];
    v279 = v294
         ^ dword_1D5D68[BYTE4(dest[2])]
         ^ dword_1D6168[BYTE9(dest[2])]
         ^ dword_1D6568[BYTE14(dest[2])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[2]))];
    v278 = v293
         ^ dword_1D5D68[BYTE8(dest[2])]
         ^ dword_1D6168[BYTE13(dest[2])]
         ^ dword_1D6568[BYTE2(dest[2])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[2]))];
    v277 = v292
         ^ dword_1D5D68[BYTE12(dest[2])]
         ^ dword_1D6168[BYTE1(dest[2])]
         ^ dword_1D6568[BYTE6(dest[2])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[2]))];
    LODWORD(dest[2]) = dword_1D5D68[(unsigned __int8)v280]
                     ^ dword_1D6168[BYTE1(v279)]
                     ^ dword_1D6568[BYTE2(v278)]
                     ^ dword_1D6968[HIBYTE(v277)];
    DWORD1(dest[2]) = dword_1D5D68[(unsigned __int8)v279]
                    ^ dword_1D6168[BYTE1(v278)]
                    ^ dword_1D6568[BYTE2(v277)]
                    ^ dword_1D6968[HIBYTE(v280)];
    DWORD2(dest[2]) = dword_1D5D68[(unsigned __int8)v278]
                    ^ dword_1D6168[BYTE1(v277)]
                    ^ dword_1D6568[BYTE2(v280)]
                    ^ dword_1D6968[HIBYTE(v279)];
    HIDWORD(dest[2]) = dword_1D5D68[(unsigned __int8)v277]
                     ^ dword_1D6168[BYTE1(v280)]
                     ^ dword_1D6568[BYTE2(v279)]
                     ^ dword_1D6968[HIBYTE(v278)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v276 = v295
         ^ dword_1D5D68[LOBYTE(dest[3])]
         ^ dword_1D6168[BYTE5(dest[3])]
         ^ dword_1D6568[BYTE10(dest[3])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[3]))];
    v275 = v294
         ^ dword_1D5D68[BYTE4(dest[3])]
         ^ dword_1D6168[BYTE9(dest[3])]
         ^ dword_1D6568[BYTE14(dest[3])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[3]))];
    v274 = v293
         ^ dword_1D5D68[BYTE8(dest[3])]
         ^ dword_1D6168[BYTE13(dest[3])]
         ^ dword_1D6568[BYTE2(dest[3])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[3]))];
    v273 = v292
         ^ dword_1D5D68[BYTE12(dest[3])]
         ^ dword_1D6168[BYTE1(dest[3])]
         ^ dword_1D6568[BYTE6(dest[3])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[3]))];
    LODWORD(dest[3]) = dword_1D5D68[(unsigned __int8)v276]
                     ^ dword_1D6168[BYTE1(v275)]
                     ^ dword_1D6568[BYTE2(v274)]
                     ^ dword_1D6968[HIBYTE(v273)];
    DWORD1(dest[3]) = dword_1D5D68[(unsigned __int8)v275]
                    ^ dword_1D6168[BYTE1(v274)]
                    ^ dword_1D6568[BYTE2(v273)]
                    ^ dword_1D6968[HIBYTE(v276)];
    DWORD2(dest[3]) = dword_1D5D68[(unsigned __int8)v274]
                    ^ dword_1D6168[BYTE1(v273)]
                    ^ dword_1D6568[BYTE2(v276)]
                    ^ dword_1D6968[HIBYTE(v275)];
    HIDWORD(dest[3]) = dword_1D5D68[(unsigned __int8)v273]
                     ^ dword_1D6168[BYTE1(v276)]
                     ^ dword_1D6568[BYTE2(v275)]
                     ^ dword_1D6968[HIBYTE(v274)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v272 = v295
         ^ dword_1D5D68[(unsigned __int8)v12]
         ^ dword_1D6168[BYTE1(v13)]
         ^ dword_1D6568[BYTE2(v14)]
         ^ dword_1D6968[HIBYTE(v15)];
    v271 = v294
         ^ dword_1D5D68[(unsigned __int8)v13]
         ^ dword_1D6168[BYTE1(v14)]
         ^ dword_1D6568[BYTE2(v15)]
         ^ dword_1D6968[HIBYTE(v12)];
    v270 = v293
         ^ dword_1D5D68[(unsigned __int8)v14]
         ^ dword_1D6168[BYTE1(v15)]
         ^ dword_1D6568[BYTE2(v12)]
         ^ dword_1D6968[HIBYTE(v13)];
    v269 = v292
         ^ dword_1D5D68[(unsigned __int8)v15]
         ^ dword_1D6168[BYTE1(v12)]
         ^ dword_1D6568[BYTE2(v13)]
         ^ dword_1D6968[HIBYTE(v14)];
    v12 = dword_1D5D68[(unsigned __int8)v272]
        ^ dword_1D6168[BYTE1(v271)]
        ^ dword_1D6568[BYTE2(v270)]
        ^ dword_1D6968[HIBYTE(v269)];
    v13 = dword_1D5D68[(unsigned __int8)v271]
        ^ dword_1D6168[BYTE1(v270)]
        ^ dword_1D6568[BYTE2(v269)]
        ^ dword_1D6968[HIBYTE(v272)];
    v14 = dword_1D5D68[(unsigned __int8)v270]
        ^ dword_1D6168[BYTE1(v269)]
        ^ dword_1D6568[BYTE2(v272)]
        ^ dword_1D6968[HIBYTE(v271)];
    v15 = dword_1D5D68[(unsigned __int8)v269]
        ^ dword_1D6168[BYTE1(v272)]
        ^ dword_1D6568[BYTE2(v271)]
        ^ dword_1D6968[HIBYTE(v270)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v268 = v295
         ^ dword_1D5D68[(unsigned __int8)v16]
         ^ dword_1D6168[BYTE1(v17)]
         ^ dword_1D6568[BYTE2(v18)]
         ^ dword_1D6968[HIBYTE(v19)];
    v267 = v294
         ^ dword_1D5D68[(unsigned __int8)v17]
         ^ dword_1D6168[BYTE1(v18)]
         ^ dword_1D6568[BYTE2(v19)]
         ^ dword_1D6968[HIBYTE(v16)];
    v266 = v293
         ^ dword_1D5D68[(unsigned __int8)v18]
         ^ dword_1D6168[BYTE1(v19)]
         ^ dword_1D6568[BYTE2(v16)]
         ^ dword_1D6968[HIBYTE(v17)];
    v265 = v292
         ^ dword_1D5D68[(unsigned __int8)v19]
         ^ dword_1D6168[BYTE1(v16)]
         ^ dword_1D6568[BYTE2(v17)]
         ^ dword_1D6968[HIBYTE(v18)];
    v16 = dword_1D5D68[(unsigned __int8)v268]
        ^ dword_1D6168[BYTE1(v267)]
        ^ dword_1D6568[BYTE2(v266)]
        ^ dword_1D6968[HIBYTE(v265)];
    v17 = dword_1D5D68[(unsigned __int8)v267]
        ^ dword_1D6168[BYTE1(v266)]
        ^ dword_1D6568[BYTE2(v265)]
        ^ dword_1D6968[HIBYTE(v268)];
    v18 = dword_1D5D68[(unsigned __int8)v266]
        ^ dword_1D6168[BYTE1(v265)]
        ^ dword_1D6568[BYTE2(v268)]
        ^ dword_1D6968[HIBYTE(v267)];
    v19 = dword_1D5D68[(unsigned __int8)v265]
        ^ dword_1D6168[BYTE1(v268)]
        ^ dword_1D6568[BYTE2(v267)]
        ^ dword_1D6968[HIBYTE(v266)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v264 = v295
         ^ dword_1D5D68[(unsigned __int8)v20]
         ^ dword_1D6168[BYTE1(v21)]
         ^ dword_1D6568[BYTE2(v22)]
         ^ dword_1D6968[HIBYTE(v23)];
    v263 = v294
         ^ dword_1D5D68[(unsigned __int8)v21]
         ^ dword_1D6168[BYTE1(v22)]
         ^ dword_1D6568[BYTE2(v23)]
         ^ dword_1D6968[HIBYTE(v20)];
    v262 = v293
         ^ dword_1D5D68[(unsigned __int8)v22]
         ^ dword_1D6168[BYTE1(v23)]
         ^ dword_1D6568[BYTE2(v20)]
         ^ dword_1D6968[HIBYTE(v21)];
    v261 = v292
         ^ dword_1D5D68[(unsigned __int8)v23]
         ^ dword_1D6168[BYTE1(v20)]
         ^ dword_1D6568[BYTE2(v21)]
         ^ dword_1D6968[HIBYTE(v22)];
    v20 = dword_1D5D68[(unsigned __int8)v264]
        ^ dword_1D6168[BYTE1(v263)]
        ^ dword_1D6568[BYTE2(v262)]
        ^ dword_1D6968[HIBYTE(v261)];
    v21 = dword_1D5D68[(unsigned __int8)v263]
        ^ dword_1D6168[BYTE1(v262)]
        ^ dword_1D6568[BYTE2(v261)]
        ^ dword_1D6968[HIBYTE(v264)];
    v22 = dword_1D5D68[(unsigned __int8)v262]
        ^ dword_1D6168[BYTE1(v261)]
        ^ dword_1D6568[BYTE2(v264)]
        ^ dword_1D6968[HIBYTE(v263)];
    v23 = dword_1D5D68[(unsigned __int8)v261]
        ^ dword_1D6168[BYTE1(v264)]
        ^ dword_1D6568[BYTE2(v263)]
        ^ dword_1D6968[HIBYTE(v262)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v260 = v295
         ^ dword_1D5D68[(unsigned __int8)v24]
         ^ dword_1D6168[BYTE1(v25)]
         ^ dword_1D6568[BYTE2(v26)]
         ^ dword_1D6968[HIBYTE(v27)];
    v259 = v294
         ^ dword_1D5D68[(unsigned __int8)v25]
         ^ dword_1D6168[BYTE1(v26)]
         ^ dword_1D6568[BYTE2(v27)]
         ^ dword_1D6968[HIBYTE(v24)];
    v258 = v293
         ^ dword_1D5D68[(unsigned __int8)v26]
         ^ dword_1D6168[BYTE1(v27)]
         ^ dword_1D6568[BYTE2(v24)]
         ^ dword_1D6968[HIBYTE(v25)];
    v257 = v292
         ^ dword_1D5D68[(unsigned __int8)v27]
         ^ dword_1D6168[BYTE1(v24)]
         ^ dword_1D6568[BYTE2(v25)]
         ^ dword_1D6968[HIBYTE(v26)];
    v24 = dword_1D5D68[(unsigned __int8)v260]
        ^ dword_1D6168[BYTE1(v259)]
        ^ dword_1D6568[BYTE2(v258)]
        ^ dword_1D6968[HIBYTE(v257)];
    v25 = dword_1D5D68[(unsigned __int8)v259]
        ^ dword_1D6168[BYTE1(v258)]
        ^ dword_1D6568[BYTE2(v257)]
        ^ dword_1D6968[HIBYTE(v260)];
    v26 = dword_1D5D68[(unsigned __int8)v258]
        ^ dword_1D6168[BYTE1(v257)]
        ^ dword_1D6568[BYTE2(v260)]
        ^ dword_1D6968[HIBYTE(v259)];
    v27 = dword_1D5D68[(unsigned __int8)v257]
        ^ dword_1D6168[BYTE1(v260)]
        ^ dword_1D6568[BYTE2(v259)]
        ^ dword_1D6968[HIBYTE(v258)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v256 = v295
         ^ dword_1D5D68[(unsigned __int8)v28]
         ^ dword_1D6168[BYTE1(v29)]
         ^ dword_1D6568[BYTE2(v30)]
         ^ dword_1D6968[HIBYTE(v31)];
    v255 = v294
         ^ dword_1D5D68[(unsigned __int8)v29]
         ^ dword_1D6168[BYTE1(v30)]
         ^ dword_1D6568[BYTE2(v31)]
         ^ dword_1D6968[HIBYTE(v28)];
    v254 = v293
         ^ dword_1D5D68[(unsigned __int8)v30]
         ^ dword_1D6168[BYTE1(v31)]
         ^ dword_1D6568[BYTE2(v28)]
         ^ dword_1D6968[HIBYTE(v29)];
    v253 = v292
         ^ dword_1D5D68[(unsigned __int8)v31]
         ^ dword_1D6168[BYTE1(v28)]
         ^ dword_1D6568[BYTE2(v29)]
         ^ dword_1D6968[HIBYTE(v30)];
    v28 = dword_1D5D68[(unsigned __int8)v256]
        ^ dword_1D6168[BYTE1(v255)]
        ^ dword_1D6568[BYTE2(v254)]
        ^ dword_1D6968[HIBYTE(v253)];
    v29 = dword_1D5D68[(unsigned __int8)v255]
        ^ dword_1D6168[BYTE1(v254)]
        ^ dword_1D6568[BYTE2(v253)]
        ^ dword_1D6968[HIBYTE(v256)];
    v30 = dword_1D5D68[(unsigned __int8)v254]
        ^ dword_1D6168[BYTE1(v253)]
        ^ dword_1D6568[BYTE2(v256)]
        ^ dword_1D6968[HIBYTE(v255)];
    v31 = dword_1D5D68[(unsigned __int8)v253]
        ^ dword_1D6168[BYTE1(v256)]
        ^ dword_1D6568[BYTE2(v255)]
        ^ dword_1D6968[HIBYTE(v254)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v252 = v295
         ^ dword_1D5D68[(unsigned __int8)v32]
         ^ dword_1D6168[BYTE1(v33)]
         ^ dword_1D6568[BYTE2(v34)]
         ^ dword_1D6968[HIBYTE(v35)];
    v251 = v294
         ^ dword_1D5D68[(unsigned __int8)v33]
         ^ dword_1D6168[BYTE1(v34)]
         ^ dword_1D6568[BYTE2(v35)]
         ^ dword_1D6968[HIBYTE(v32)];
    v250 = v293
         ^ dword_1D5D68[(unsigned __int8)v34]
         ^ dword_1D6168[BYTE1(v35)]
         ^ dword_1D6568[BYTE2(v32)]
         ^ dword_1D6968[HIBYTE(v33)];
    v249 = v292
         ^ dword_1D5D68[(unsigned __int8)v35]
         ^ dword_1D6168[BYTE1(v32)]
         ^ dword_1D6568[BYTE2(v33)]
         ^ dword_1D6968[HIBYTE(v34)];
    v32 = dword_1D5D68[(unsigned __int8)v252]
        ^ dword_1D6168[BYTE1(v251)]
        ^ dword_1D6568[BYTE2(v250)]
        ^ dword_1D6968[HIBYTE(v249)];
    v33 = dword_1D5D68[(unsigned __int8)v251]
        ^ dword_1D6168[BYTE1(v250)]
        ^ dword_1D6568[BYTE2(v249)]
        ^ dword_1D6968[HIBYTE(v252)];
    v34 = dword_1D5D68[(unsigned __int8)v250]
        ^ dword_1D6168[BYTE1(v249)]
        ^ dword_1D6568[BYTE2(v252)]
        ^ dword_1D6968[HIBYTE(v251)];
    v35 = dword_1D5D68[(unsigned __int8)v249]
        ^ dword_1D6168[BYTE1(v252)]
        ^ dword_1D6568[BYTE2(v251)]
        ^ dword_1D6968[HIBYTE(v250)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v248 = v295
         ^ dword_1D5D68[(unsigned __int8)v36]
         ^ dword_1D6168[BYTE1(v37)]
         ^ dword_1D6568[BYTE2(v38)]
         ^ dword_1D6968[HIBYTE(v39)];
    v247 = v294
         ^ dword_1D5D68[(unsigned __int8)v37]
         ^ dword_1D6168[BYTE1(v38)]
         ^ dword_1D6568[BYTE2(v39)]
         ^ dword_1D6968[HIBYTE(v36)];
    v246 = v293
         ^ dword_1D5D68[(unsigned __int8)v38]
         ^ dword_1D6168[BYTE1(v39)]
         ^ dword_1D6568[BYTE2(v36)]
         ^ dword_1D6968[HIBYTE(v37)];
    v245 = v292
         ^ dword_1D5D68[(unsigned __int8)v39]
         ^ dword_1D6168[BYTE1(v36)]
         ^ dword_1D6568[BYTE2(v37)]
         ^ dword_1D6968[HIBYTE(v38)];
    v36 = dword_1D5D68[(unsigned __int8)v248]
        ^ dword_1D6168[BYTE1(v247)]
        ^ dword_1D6568[BYTE2(v246)]
        ^ dword_1D6968[HIBYTE(v245)];
    v37 = dword_1D5D68[(unsigned __int8)v247]
        ^ dword_1D6168[BYTE1(v246)]
        ^ dword_1D6568[BYTE2(v245)]
        ^ dword_1D6968[HIBYTE(v248)];
    v38 = dword_1D5D68[(unsigned __int8)v246]
        ^ dword_1D6168[BYTE1(v245)]
        ^ dword_1D6568[BYTE2(v248)]
        ^ dword_1D6968[HIBYTE(v247)];
    v39 = dword_1D5D68[(unsigned __int8)v245]
        ^ dword_1D6168[BYTE1(v248)]
        ^ dword_1D6568[BYTE2(v247)]
        ^ dword_1D6968[HIBYTE(v246)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v244 = v295
         ^ dword_1D5D68[(unsigned __int8)v40]
         ^ dword_1D6168[BYTE1(v41)]
         ^ dword_1D6568[BYTE2(v42)]
         ^ dword_1D6968[HIBYTE(v43)];
    v243 = v294
         ^ dword_1D5D68[(unsigned __int8)v41]
         ^ dword_1D6168[BYTE1(v42)]
         ^ dword_1D6568[BYTE2(v43)]
         ^ dword_1D6968[HIBYTE(v40)];
    v242 = v293
         ^ dword_1D5D68[(unsigned __int8)v42]
         ^ dword_1D6168[BYTE1(v43)]
         ^ dword_1D6568[BYTE2(v40)]
         ^ dword_1D6968[HIBYTE(v41)];
    v241 = v292
         ^ dword_1D5D68[(unsigned __int8)v43]
         ^ dword_1D6168[BYTE1(v40)]
         ^ dword_1D6568[BYTE2(v41)]
         ^ dword_1D6968[HIBYTE(v42)];
    v40 = dword_1D5D68[(unsigned __int8)v244]
        ^ dword_1D6168[BYTE1(v243)]
        ^ dword_1D6568[BYTE2(v242)]
        ^ dword_1D6968[HIBYTE(v241)];
    v41 = dword_1D5D68[(unsigned __int8)v243]
        ^ dword_1D6168[BYTE1(v242)]
        ^ dword_1D6568[BYTE2(v241)]
        ^ dword_1D6968[HIBYTE(v244)];
    v42 = dword_1D5D68[(unsigned __int8)v242]
        ^ dword_1D6168[BYTE1(v241)]
        ^ dword_1D6568[BYTE2(v244)]
        ^ dword_1D6968[HIBYTE(v243)];
    v43 = dword_1D5D68[(unsigned __int8)v241]
        ^ dword_1D6168[BYTE1(v244)]
        ^ dword_1D6568[BYTE2(v243)]
        ^ dword_1D6968[HIBYTE(v242)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v240 = v295
         ^ dword_1D5D68[(unsigned __int8)v44]
         ^ dword_1D6168[BYTE1(v45)]
         ^ dword_1D6568[BYTE2(v46)]
         ^ dword_1D6968[HIBYTE(v47)];
    v239 = v294
         ^ dword_1D5D68[(unsigned __int8)v45]
         ^ dword_1D6168[BYTE1(v46)]
         ^ dword_1D6568[BYTE2(v47)]
         ^ dword_1D6968[HIBYTE(v44)];
    v238 = v293
         ^ dword_1D5D68[(unsigned __int8)v46]
         ^ dword_1D6168[BYTE1(v47)]
         ^ dword_1D6568[BYTE2(v44)]
         ^ dword_1D6968[HIBYTE(v45)];
    v237 = v292
         ^ dword_1D5D68[(unsigned __int8)v47]
         ^ dword_1D6168[BYTE1(v44)]
         ^ dword_1D6568[BYTE2(v45)]
         ^ dword_1D6968[HIBYTE(v46)];
    v44 = dword_1D5D68[(unsigned __int8)v240]
        ^ dword_1D6168[BYTE1(v239)]
        ^ dword_1D6568[BYTE2(v238)]
        ^ dword_1D6968[HIBYTE(v237)];
    v45 = dword_1D5D68[(unsigned __int8)v239]
        ^ dword_1D6168[BYTE1(v238)]
        ^ dword_1D6568[BYTE2(v237)]
        ^ dword_1D6968[HIBYTE(v240)];
    v46 = dword_1D5D68[(unsigned __int8)v238]
        ^ dword_1D6168[BYTE1(v237)]
        ^ dword_1D6568[BYTE2(v240)]
        ^ dword_1D6968[HIBYTE(v239)];
    v47 = dword_1D5D68[(unsigned __int8)v237]
        ^ dword_1D6168[BYTE1(v240)]
        ^ dword_1D6568[BYTE2(v239)]
        ^ dword_1D6968[HIBYTE(v238)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v236 = v295
         ^ dword_1D5D68[(unsigned __int8)v48]
         ^ dword_1D6168[BYTE1(v49)]
         ^ dword_1D6568[BYTE2(v50)]
         ^ dword_1D6968[HIBYTE(v51)];
    v235 = v294
         ^ dword_1D5D68[(unsigned __int8)v49]
         ^ dword_1D6168[BYTE1(v50)]
         ^ dword_1D6568[BYTE2(v51)]
         ^ dword_1D6968[HIBYTE(v48)];
    v234 = v293
         ^ dword_1D5D68[(unsigned __int8)v50]
         ^ dword_1D6168[BYTE1(v51)]
         ^ dword_1D6568[BYTE2(v48)]
         ^ dword_1D6968[HIBYTE(v49)];
    v233 = v292
         ^ dword_1D5D68[(unsigned __int8)v51]
         ^ dword_1D6168[BYTE1(v48)]
         ^ dword_1D6568[BYTE2(v49)]
         ^ dword_1D6968[HIBYTE(v50)];
    v48 = dword_1D5D68[(unsigned __int8)v236]
        ^ dword_1D6168[BYTE1(v235)]
        ^ dword_1D6568[BYTE2(v234)]
        ^ dword_1D6968[HIBYTE(v233)];
    v49 = dword_1D5D68[(unsigned __int8)v235]
        ^ dword_1D6168[BYTE1(v234)]
        ^ dword_1D6568[BYTE2(v233)]
        ^ dword_1D6968[HIBYTE(v236)];
    v50 = dword_1D5D68[(unsigned __int8)v234]
        ^ dword_1D6168[BYTE1(v233)]
        ^ dword_1D6568[BYTE2(v236)]
        ^ dword_1D6968[HIBYTE(v235)];
    v51 = dword_1D5D68[(unsigned __int8)v233]
        ^ dword_1D6168[BYTE1(v236)]
        ^ dword_1D6568[BYTE2(v235)]
        ^ dword_1D6968[HIBYTE(v234)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v232 = v295
         ^ dword_1D5D68[(unsigned __int8)v52]
         ^ dword_1D6168[BYTE1(v53)]
         ^ dword_1D6568[BYTE2(v54)]
         ^ dword_1D6968[HIBYTE(v55)];
    v231 = v294
         ^ dword_1D5D68[(unsigned __int8)v53]
         ^ dword_1D6168[BYTE1(v54)]
         ^ dword_1D6568[BYTE2(v55)]
         ^ dword_1D6968[HIBYTE(v52)];
    v230 = v293
         ^ dword_1D5D68[(unsigned __int8)v54]
         ^ dword_1D6168[BYTE1(v55)]
         ^ dword_1D6568[BYTE2(v52)]
         ^ dword_1D6968[HIBYTE(v53)];
    v229 = v292
         ^ dword_1D5D68[(unsigned __int8)v55]
         ^ dword_1D6168[BYTE1(v52)]
         ^ dword_1D6568[BYTE2(v53)]
         ^ dword_1D6968[HIBYTE(v54)];
    v52 = dword_1D5D68[(unsigned __int8)v232]
        ^ dword_1D6168[BYTE1(v231)]
        ^ dword_1D6568[BYTE2(v230)]
        ^ dword_1D6968[HIBYTE(v229)];
    v53 = dword_1D5D68[(unsigned __int8)v231]
        ^ dword_1D6168[BYTE1(v230)]
        ^ dword_1D6568[BYTE2(v229)]
        ^ dword_1D6968[HIBYTE(v232)];
    v54 = dword_1D5D68[(unsigned __int8)v230]
        ^ dword_1D6168[BYTE1(v229)]
        ^ dword_1D6568[BYTE2(v232)]
        ^ dword_1D6968[HIBYTE(v231)];
    v55 = dword_1D5D68[(unsigned __int8)v229]
        ^ dword_1D6168[BYTE1(v232)]
        ^ dword_1D6568[BYTE2(v231)]
        ^ dword_1D6968[HIBYTE(v230)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v228 = v295
         ^ dword_1D5D68[(unsigned __int8)v56]
         ^ dword_1D6168[BYTE1(v57)]
         ^ dword_1D6568[BYTE2(v58)]
         ^ dword_1D6968[HIBYTE(v59)];
    v227 = v294
         ^ dword_1D5D68[(unsigned __int8)v57]
         ^ dword_1D6168[BYTE1(v58)]
         ^ dword_1D6568[BYTE2(v59)]
         ^ dword_1D6968[HIBYTE(v56)];
    v226 = v293
         ^ dword_1D5D68[(unsigned __int8)v58]
         ^ dword_1D6168[BYTE1(v59)]
         ^ dword_1D6568[BYTE2(v56)]
         ^ dword_1D6968[HIBYTE(v57)];
    v225 = v292
         ^ dword_1D5D68[(unsigned __int8)v59]
         ^ dword_1D6168[BYTE1(v56)]
         ^ dword_1D6568[BYTE2(v57)]
         ^ dword_1D6968[HIBYTE(v58)];
    v56 = dword_1D5D68[(unsigned __int8)v228]
        ^ dword_1D6168[BYTE1(v227)]
        ^ dword_1D6568[BYTE2(v226)]
        ^ dword_1D6968[HIBYTE(v225)];
    v57 = dword_1D5D68[(unsigned __int8)v227]
        ^ dword_1D6168[BYTE1(v226)]
        ^ dword_1D6568[BYTE2(v225)]
        ^ dword_1D6968[HIBYTE(v228)];
    v58 = dword_1D5D68[(unsigned __int8)v226]
        ^ dword_1D6168[BYTE1(v225)]
        ^ dword_1D6568[BYTE2(v228)]
        ^ dword_1D6968[HIBYTE(v227)];
    v59 = dword_1D5D68[(unsigned __int8)v225]
        ^ dword_1D6168[BYTE1(v228)]
        ^ dword_1D6568[BYTE2(v227)]
        ^ dword_1D6968[HIBYTE(v226)];
    if ( !++v295 && !++v294 && !++v293 )
      ++v292;
    v224 = dest[1];
    LODWORD(dest[1]) = v16;
    v16 = v32;
    v32 = v48;
    v48 = v224;
    v224 = DWORD1(dest[1]);
    DWORD1(dest[1]) = v17;
    v17 = v33;
    v33 = v49;
    v49 = v224;
    v224 = DWORD2(dest[1]);
    DWORD2(dest[1]) = v18;
    v18 = v34;
    v34 = v50;
    v50 = v224;
    v224 = HIDWORD(dest[1]);
    v223 = dest[2];
    LODWORD(dest[2]) = v36;
    v36 = v223;
    v223 = v20;
    v20 = v52;
    v52 = v223;
    v223 = DWORD1(dest[2]);
    DWORD1(dest[2]) = v37;
    v37 = v223;
    v223 = v21;
    v21 = v53;
    v53 = v223;
    v223 = DWORD2(dest[2]);
    DWORD2(dest[2]) = v38;
    v38 = v223;
    v223 = v22;
    v22 = v54;
    v54 = v223;
    v223 = HIDWORD(dest[2]);
    HIDWORD(dest[2]) = v39;
    v39 = v223;
    v223 = v23;
    v222 = v56;
    v56 = v40;
    v40 = v24;
    v24 = dest[3];
    LODWORD(dest[3]) = v222;
    v222 = v57;
    v57 = v41;
    v41 = v25;
    v25 = DWORD1(dest[3]);
    DWORD1(dest[3]) = v222;
    v222 = v58;
    v58 = v42;
    v42 = v26;
    v26 = DWORD2(dest[3]);
    DWORD2(dest[3]) = v222;
    v222 = v59;
    v59 = v43;
    v43 = v27;
    v27 = HIDWORD(dest[3]);
    v221 = dest[0];
    v220 = dest[1];
    v219 = dest[2];
    v218 = dest[3];
    v217 = LODWORD(dest[1]) ^ LODWORD(dest[0]);
    v216 = LODWORD(dest[2]) ^ LODWORD(dest[1]);
    v215 = LODWORD(dest[3]) ^ LODWORD(dest[2]);
    v214 = (2 * (v217 & 0x7F7F7F7F)) ^ (27 * ((v217 & 0x80808080) >> 7));
    v213 = (2 * (v216 & 0x7F7F7F7F)) ^ (27 * ((v216 & 0x80808080) >> 7));
    v212 = (2 * (v215 & 0x7F7F7F7F)) ^ (27 * ((v215 & 0x80808080) >> 7));
    LODWORD(dest[0]) = v214 ^ LODWORD(dest[2]) ^ LODWORD(dest[1]) ^ LODWORD(dest[3]);
    LODWORD(dest[1]) = v213 ^ v221 ^ LODWORD(dest[3]) ^ LODWORD(dest[2]);
    LODWORD(dest[2]) = v212 ^ v217 ^ LODWORD(dest[3]);
    LODWORD(dest[3]) = v214 ^ v213 ^ v212 ^ v217 ^ v219;
    v211 = DWORD1(dest[0]);
    v210 = DWORD1(dest[1]);
    v209 = DWORD1(dest[2]);
    v208 = DWORD1(dest[3]);
    v207 = DWORD1(dest[1]) ^ DWORD1(dest[0]);
    v206 = DWORD1(dest[2]) ^ DWORD1(dest[1]);
    v205 = DWORD1(dest[3]) ^ DWORD1(dest[2]);
    v204 = (2 * (v207 & 0x7F7F7F7F)) ^ (27 * ((v207 & 0x80808080) >> 7));
    v203 = (2 * (v206 & 0x7F7F7F7F)) ^ (27 * ((v206 & 0x80808080) >> 7));
    v202 = (2 * (v205 & 0x7F7F7F7F)) ^ (27 * ((v205 & 0x80808080) >> 7));
    DWORD1(dest[0]) = v204 ^ DWORD1(dest[2]) ^ DWORD1(dest[1]) ^ DWORD1(dest[3]);
    DWORD1(dest[1]) = v203 ^ v211 ^ DWORD1(dest[3]) ^ DWORD1(dest[2]);
    DWORD1(dest[2]) = v202 ^ v207 ^ DWORD1(dest[3]);
    DWORD1(dest[3]) = v204 ^ v203 ^ v202 ^ v207 ^ v209;
    v201 = DWORD2(dest[0]);
    v200 = DWORD2(dest[1]);
    v199 = DWORD2(dest[2]);
    v198 = DWORD2(dest[3]);
    v197 = DWORD2(dest[1]) ^ DWORD2(dest[0]);
    v196 = DWORD2(dest[2]) ^ DWORD2(dest[1]);
    v195 = DWORD2(dest[3]) ^ DWORD2(dest[2]);
    v194 = (2 * (v197 & 0x7F7F7F7F)) ^ (27 * ((v197 & 0x80808080) >> 7));
    v193 = (2 * (v196 & 0x7F7F7F7F)) ^ (27 * ((v196 & 0x80808080) >> 7));
    v192 = (2 * (v195 & 0x7F7F7F7F)) ^ (27 * ((v195 & 0x80808080) >> 7));
    DWORD2(dest[0]) = v194 ^ DWORD2(dest[2]) ^ DWORD2(dest[1]) ^ DWORD2(dest[3]);
    DWORD2(dest[1]) = v193 ^ v201 ^ DWORD2(dest[3]) ^ DWORD2(dest[2]);
    DWORD2(dest[2]) = v192 ^ v197 ^ DWORD2(dest[3]);
    DWORD2(dest[3]) = v194 ^ v193 ^ v192 ^ v197 ^ v199;
    v191 = HIDWORD(dest[0]);
    v190 = v19;
    v189 = HIDWORD(dest[2]);
    v188 = v222;
    v187 = v19 ^ HIDWORD(dest[0]);
    v186 = HIDWORD(dest[2]) ^ v19;
    v185 = v222 ^ HIDWORD(dest[2]);
    v184 = (2 * (v187 & 0x7F7F7F7F)) ^ (27 * ((v187 & 0x80808080) >> 7));
    v183 = (2 * (v186 & 0x7F7F7F7F)) ^ (27 * ((v186 & 0x80808080) >> 7));
    v182 = (2 * (v185 & 0x7F7F7F7F)) ^ (27 * ((v185 & 0x80808080) >> 7));
    HIDWORD(dest[0]) = v184 ^ HIDWORD(dest[2]) ^ v19 ^ v222;
    HIDWORD(dest[1]) = v183 ^ v191 ^ v222 ^ HIDWORD(dest[2]);
    HIDWORD(dest[2]) = v182 ^ v187 ^ v222;
    HIDWORD(dest[3]) = v184 ^ v183 ^ v182 ^ v187 ^ v189;
    v181 = v12;
    v180 = v16;
    v179 = v20;
    v178 = v24;
    v177 = v16 ^ v12;
    v176 = v20 ^ v16;
    v175 = v24 ^ v20;
    v174 = (2 * (v177 & 0x7F7F7F7F)) ^ (27 * ((v177 & 0x80808080) >> 7));
    v173 = (2 * (v176 & 0x7F7F7F7F)) ^ (27 * ((v176 & 0x80808080) >> 7));
    v172 = (2 * (v175 & 0x7F7F7F7F)) ^ (27 * ((v175 & 0x80808080) >> 7));
    v12 = v174 ^ v20 ^ v16 ^ v24;
    v16 = v173 ^ v181 ^ v24 ^ v20;
    v20 = v172 ^ v177 ^ v24;
    v24 = v174 ^ v173 ^ v172 ^ v177 ^ v179;
    v171 = v13;
    v170 = v17;
    v169 = v21;
    v168 = v25;
    v167 = v17 ^ v13;
    v166 = v21 ^ v17;
    v165 = v25 ^ v21;
    v164 = (2 * (v167 & 0x7F7F7F7F)) ^ (27 * ((v167 & 0x80808080) >> 7));
    v163 = (2 * (v166 & 0x7F7F7F7F)) ^ (27 * ((v166 & 0x80808080) >> 7));
    v162 = (2 * (v165 & 0x7F7F7F7F)) ^ (27 * ((v165 & 0x80808080) >> 7));
    v13 = v164 ^ v21 ^ v17 ^ v25;
    v17 = v163 ^ v171 ^ v25 ^ v21;
    v21 = v162 ^ v167 ^ v25;
    v25 = v164 ^ v163 ^ v162 ^ v167 ^ v169;
    v161 = v14;
    v160 = v18;
    v159 = v22;
    v158 = v26;
    v157 = v18 ^ v14;
    v156 = v22 ^ v18;
    v155 = v26 ^ v22;
    v154 = (2 * (v157 & 0x7F7F7F7F)) ^ (27 * ((v157 & 0x80808080) >> 7));
    v153 = (2 * (v156 & 0x7F7F7F7F)) ^ (27 * ((v156 & 0x80808080) >> 7));
    v152 = (2 * (v155 & 0x7F7F7F7F)) ^ (27 * ((v155 & 0x80808080) >> 7));
    v14 = v154 ^ v22 ^ v18 ^ v26;
    v18 = v153 ^ v161 ^ v26 ^ v22;
    v22 = v152 ^ v157 ^ v26;
    v26 = v154 ^ v153 ^ v152 ^ v157 ^ v159;
    v151 = v15;
    v150 = v35;
    v149 = v55;
    v148 = v27;
    v147 = v35 ^ v15;
    v146 = v55 ^ v35;
    v145 = v27 ^ v55;
    v144 = (2 * (v147 & 0x7F7F7F7F)) ^ (27 * ((v147 & 0x80808080) >> 7));
    v143 = (2 * (v146 & 0x7F7F7F7F)) ^ (27 * ((v146 & 0x80808080) >> 7));
    v142 = (2 * (v145 & 0x7F7F7F7F)) ^ (27 * ((v145 & 0x80808080) >> 7));
    v15 = v144 ^ v55 ^ v35 ^ v27;
    v19 = v143 ^ v151 ^ v27 ^ v55;
    v23 = v142 ^ v147 ^ v27;
    v27 = v144 ^ v143 ^ v142 ^ v147 ^ v55;
    v141 = v28;
    v140 = v32;
    v139 = v36;
    v138 = v40;
    v137 = v32 ^ v28;
    v136 = v36 ^ v32;
    v135 = v40 ^ v36;
    v134 = (2 * (v137 & 0x7F7F7F7F)) ^ (27 * ((v137 & 0x80808080) >> 7));
    v133 = (2 * (v136 & 0x7F7F7F7F)) ^ (27 * ((v136 & 0x80808080) >> 7));
    v132 = (2 * (v135 & 0x7F7F7F7F)) ^ (27 * ((v135 & 0x80808080) >> 7));
    v28 = v134 ^ v36 ^ v32 ^ v40;
    v32 = v133 ^ v141 ^ v40 ^ v36;
    v36 = v132 ^ v137 ^ v40;
    v40 = v134 ^ v133 ^ v132 ^ v137 ^ v139;
    v131 = v29;
    v130 = v33;
    v129 = v37;
    v128 = v41;
    v127 = v33 ^ v29;
    v126 = v37 ^ v33;
    v125 = v41 ^ v37;
    v124 = (2 * (v127 & 0x7F7F7F7F)) ^ (27 * ((v127 & 0x80808080) >> 7));
    v123 = (2 * (v126 & 0x7F7F7F7F)) ^ (27 * ((v126 & 0x80808080) >> 7));
    v122 = (2 * (v125 & 0x7F7F7F7F)) ^ (27 * ((v125 & 0x80808080) >> 7));
    v29 = v124 ^ v37 ^ v33 ^ v41;
    v33 = v123 ^ v131 ^ v41 ^ v37;
    v37 = v122 ^ v127 ^ v41;
    v41 = v124 ^ v123 ^ v122 ^ v127 ^ v129;
    v121 = v30;
    v120 = v34;
    v119 = v38;
    v118 = v42;
    v117 = v34 ^ v30;
    v116 = v38 ^ v34;
    v115 = v42 ^ v38;
    v114 = (2 * (v117 & 0x7F7F7F7F)) ^ (27 * ((v117 & 0x80808080) >> 7));
    v113 = (2 * (v116 & 0x7F7F7F7F)) ^ (27 * ((v116 & 0x80808080) >> 7));
    v112 = (2 * (v115 & 0x7F7F7F7F)) ^ (27 * ((v115 & 0x80808080) >> 7));
    v30 = v114 ^ v38 ^ v34 ^ v42;
    v34 = v113 ^ v121 ^ v42 ^ v38;
    v38 = v112 ^ v117 ^ v42;
    v42 = v114 ^ v113 ^ v112 ^ v117 ^ v119;
    v111 = v31;
    v110 = v51;
    v109 = v39;
    v108 = v43;
    v107 = v51 ^ v31;
    v106 = v39 ^ v51;
    v105 = v43 ^ v39;
    v104 = (2 * (v107 & 0x7F7F7F7F)) ^ (27 * ((v107 & 0x80808080) >> 7));
    v103 = (2 * (v106 & 0x7F7F7F7F)) ^ (27 * ((v106 & 0x80808080) >> 7));
    v102 = (2 * (v105 & 0x7F7F7F7F)) ^ (27 * ((v105 & 0x80808080) >> 7));
    v31 = v104 ^ v39 ^ v51 ^ v43;
    v35 = v103 ^ v111 ^ v43 ^ v39;
    v39 = v102 ^ v107 ^ v43;
    v43 = v104 ^ v103 ^ v102 ^ v107 ^ v109;
    v101 = v44;
    v100 = v48;
    v99 = v52;
    v98 = v56;
    v97 = v48 ^ v44;
    v96 = v52 ^ v48;
    v95 = v56 ^ v52;
    v94 = (2 * (v97 & 0x7F7F7F7F)) ^ (27 * ((v97 & 0x80808080) >> 7));
    v93 = (2 * (v96 & 0x7F7F7F7F)) ^ (27 * ((v96 & 0x80808080) >> 7));
    v92 = (2 * (v95 & 0x7F7F7F7F)) ^ (27 * ((v95 & 0x80808080) >> 7));
    v44 = v94 ^ v52 ^ v48 ^ v56;
    v48 = v93 ^ v101 ^ v56 ^ v52;
    v52 = v92 ^ v97 ^ v56;
    v56 = v94 ^ v93 ^ v92 ^ v97 ^ v99;
    v91 = v45;
    v90 = v49;
    v89 = v53;
    v88 = v57;
    v87 = v49 ^ v45;
    v86 = v53 ^ v49;
    v85 = v57 ^ v53;
    v84 = (2 * (v87 & 0x7F7F7F7F)) ^ (27 * ((v87 & 0x80808080) >> 7));
    v83 = (2 * (v86 & 0x7F7F7F7F)) ^ (27 * ((v86 & 0x80808080) >> 7));
    v82 = (2 * (v85 & 0x7F7F7F7F)) ^ (27 * ((v85 & 0x80808080) >> 7));
    v45 = v84 ^ v53 ^ v49 ^ v57;
    v49 = v83 ^ v91 ^ v57 ^ v53;
    v53 = v82 ^ v87 ^ v57;
    v57 = v84 ^ v83 ^ v82 ^ v87 ^ v89;
    v81 = v46;
    v80 = v50;
    v79 = v54;
    v78 = v58;
    v77 = v50 ^ v46;
    v76 = v54 ^ v50;
    v75 = v58 ^ v54;
    v74 = (2 * (v77 & 0x7F7F7F7F)) ^ (27 * ((v77 & 0x80808080) >> 7));
    v73 = (2 * (v76 & 0x7F7F7F7F)) ^ (27 * ((v76 & 0x80808080) >> 7));
    v72 = (2 * (v75 & 0x7F7F7F7F)) ^ (27 * ((v75 & 0x80808080) >> 7));
    v46 = v74 ^ v54 ^ v50 ^ v58;
    v50 = v73 ^ v81 ^ v58 ^ v54;
    v54 = v72 ^ v77 ^ v58;
    v58 = v74 ^ v73 ^ v72 ^ v77 ^ v79;
    v71 = v47;
    v70 = v224;
    v69 = v223;
    v68 = v59;
    v67 = v224 ^ v47;
    v66 = v223 ^ v224;
    v65 = v59 ^ v223;
    v64 = (2 * (v67 & 0x7F7F7F7F)) ^ (27 * ((v67 & 0x80808080) >> 7));
    v63 = (2 * (v66 & 0x7F7F7F7F)) ^ (27 * ((v66 & 0x80808080) >> 7));
    v62 = (2 * ((v59 ^ v223) & 0x7F7F7F7F)) ^ (27 * (((v59 ^ v223) & 0x80808080) >> 7));
    v47 = v64 ^ v223 ^ v224 ^ v59;
    v51 = v63 ^ v71 ^ v59 ^ v223;
    v55 = v62 ^ v67 ^ v59;
    v59 = v64 ^ v63 ^ v62 ^ v67 ^ v223;
  }
  v61 = a1 + 50;
  v60 = dest;
  for ( k = 0; k <= 0xF; ++k )
  {
    v6 = sub_1673D0((int)&a1[k]);
    v7 = v6 ^ sub_1673D0((int)&a1[k + 16]);
    v8 = sub_1673D0((int)&a1[k + 32]);
    v9 = v7
       ^ v8
       ^ *((_DWORD *)v60 + k)
       ^ *((_DWORD *)v60 + k + 16)
       ^ *((_DWORD *)v60 + k + 32)
       ^ *((_DWORD *)v60 + k + 48);
    result = v61;
    v61[k] ^= v9;
  }
  return result;
}
// 1D5D68: using guessed type _DWORD dword_1D5D68[256];
// 1D6168: using guessed type _DWORD dword_1D6168[256];
// 1D6568: using guessed type _DWORD dword_1D6568[256];
// 1D6968: using guessed type _DWORD dword_1D6968[256];

//----- (0016C794) --------------------------------------------------------
void *__fastcall sub_16C794(_DWORD *a1)
{
  void *result; // r0
  unsigned int v2; // r4
  unsigned int v3; // r4
  unsigned int v4; // r4
  unsigned int v5; // r4
  int v6; // r0
  int v7; // r2
  _OWORD dest[8]; // [sp+8h] [bp+8h] BYREF
  unsigned int v10; // [sp+88h] [bp+88h]
  unsigned int v11; // [sp+8Ch] [bp+8Ch]
  unsigned int v12; // [sp+90h] [bp+90h]
  unsigned int v13; // [sp+94h] [bp+94h]
  unsigned int v14; // [sp+98h] [bp+98h]
  unsigned int v15; // [sp+9Ch] [bp+9Ch]
  unsigned int v16; // [sp+A0h] [bp+A0h]
  unsigned int v17; // [sp+A4h] [bp+A4h]
  unsigned int v18; // [sp+A8h] [bp+A8h]
  unsigned int v19; // [sp+ACh] [bp+ACh]
  unsigned int v20; // [sp+B0h] [bp+B0h]
  unsigned int v21; // [sp+B4h] [bp+B4h]
  unsigned int v22; // [sp+B8h] [bp+B8h]
  unsigned int v23; // [sp+BCh] [bp+BCh]
  unsigned int v24; // [sp+C0h] [bp+C0h]
  unsigned int v25; // [sp+C4h] [bp+C4h]
  unsigned int v26; // [sp+C8h] [bp+C8h]
  unsigned int v27; // [sp+CCh] [bp+CCh]
  unsigned int v28; // [sp+D0h] [bp+D0h]
  unsigned int v29; // [sp+D4h] [bp+D4h]
  unsigned int v30; // [sp+D8h] [bp+D8h]
  unsigned int v31; // [sp+DCh] [bp+DCh]
  unsigned int v32; // [sp+E0h] [bp+E0h]
  unsigned int v33; // [sp+E4h] [bp+E4h]
  unsigned int v34; // [sp+E8h] [bp+E8h]
  unsigned int v35; // [sp+ECh] [bp+ECh]
  unsigned int v36; // [sp+F0h] [bp+F0h]
  unsigned int v37; // [sp+F4h] [bp+F4h]
  unsigned int v38; // [sp+F8h] [bp+F8h]
  unsigned int v39; // [sp+FCh] [bp+FCh]
  unsigned int v40; // [sp+100h] [bp+100h]
  unsigned int v41; // [sp+104h] [bp+104h]
  _OWORD *v42; // [sp+108h] [bp+108h]
  _DWORD *v43; // [sp+10Ch] [bp+10Ch]
  unsigned int v44; // [sp+110h] [bp+110h]
  unsigned int v45; // [sp+114h] [bp+114h]
  unsigned int v46; // [sp+118h] [bp+118h]
  int v47; // [sp+11Ch] [bp+11Ch]
  int v48; // [sp+120h] [bp+120h]
  int v49; // [sp+124h] [bp+124h]
  unsigned int v50; // [sp+128h] [bp+128h]
  unsigned int v51; // [sp+12Ch] [bp+12Ch]
  unsigned int v52; // [sp+130h] [bp+130h]
  unsigned int v53; // [sp+134h] [bp+134h]
  unsigned int v54; // [sp+138h] [bp+138h]
  unsigned int v55; // [sp+13Ch] [bp+13Ch]
  unsigned int v56; // [sp+140h] [bp+140h]
  int v57; // [sp+144h] [bp+144h]
  int v58; // [sp+148h] [bp+148h]
  int v59; // [sp+14Ch] [bp+14Ch]
  unsigned int v60; // [sp+150h] [bp+150h]
  unsigned int v61; // [sp+154h] [bp+154h]
  unsigned int v62; // [sp+158h] [bp+158h]
  unsigned int v63; // [sp+15Ch] [bp+15Ch]
  unsigned int v64; // [sp+160h] [bp+160h]
  unsigned int v65; // [sp+164h] [bp+164h]
  unsigned int v66; // [sp+168h] [bp+168h]
  int v67; // [sp+16Ch] [bp+16Ch]
  int v68; // [sp+170h] [bp+170h]
  int v69; // [sp+174h] [bp+174h]
  unsigned int v70; // [sp+178h] [bp+178h]
  unsigned int v71; // [sp+17Ch] [bp+17Ch]
  unsigned int v72; // [sp+180h] [bp+180h]
  unsigned int v73; // [sp+184h] [bp+184h]
  unsigned int v74; // [sp+188h] [bp+188h]
  unsigned int v75; // [sp+18Ch] [bp+18Ch]
  unsigned int v76; // [sp+190h] [bp+190h]
  int v77; // [sp+194h] [bp+194h]
  int v78; // [sp+198h] [bp+198h]
  int v79; // [sp+19Ch] [bp+19Ch]
  unsigned int v80; // [sp+1A0h] [bp+1A0h]
  unsigned int v81; // [sp+1A4h] [bp+1A4h]
  unsigned int v82; // [sp+1A8h] [bp+1A8h]
  unsigned int v83; // [sp+1ACh] [bp+1ACh]
  unsigned int v84; // [sp+1B0h] [bp+1B0h]
  unsigned int v85; // [sp+1B4h] [bp+1B4h]
  unsigned int v86; // [sp+1B8h] [bp+1B8h]
  int v87; // [sp+1BCh] [bp+1BCh]
  int v88; // [sp+1C0h] [bp+1C0h]
  int v89; // [sp+1C4h] [bp+1C4h]
  unsigned int v90; // [sp+1C8h] [bp+1C8h]
  unsigned int v91; // [sp+1CCh] [bp+1CCh]
  unsigned int v92; // [sp+1D0h] [bp+1D0h]
  unsigned int v93; // [sp+1D4h] [bp+1D4h]
  unsigned int v94; // [sp+1D8h] [bp+1D8h]
  unsigned int v95; // [sp+1DCh] [bp+1DCh]
  unsigned int v96; // [sp+1E0h] [bp+1E0h]
  int v97; // [sp+1E4h] [bp+1E4h]
  int v98; // [sp+1E8h] [bp+1E8h]
  int v99; // [sp+1ECh] [bp+1ECh]
  unsigned int v100; // [sp+1F0h] [bp+1F0h]
  unsigned int v101; // [sp+1F4h] [bp+1F4h]
  unsigned int v102; // [sp+1F8h] [bp+1F8h]
  unsigned int v103; // [sp+1FCh] [bp+1FCh]
  unsigned int v104; // [sp+200h] [bp+200h]
  unsigned int v105; // [sp+204h] [bp+204h]
  unsigned int v106; // [sp+208h] [bp+208h]
  int v107; // [sp+20Ch] [bp+20Ch]
  int v108; // [sp+210h] [bp+210h]
  int v109; // [sp+214h] [bp+214h]
  unsigned int v110; // [sp+218h] [bp+218h]
  unsigned int v111; // [sp+21Ch] [bp+21Ch]
  unsigned int v112; // [sp+220h] [bp+220h]
  unsigned int v113; // [sp+224h] [bp+224h]
  unsigned int v114; // [sp+228h] [bp+228h]
  unsigned int v115; // [sp+22Ch] [bp+22Ch]
  unsigned int v116; // [sp+230h] [bp+230h]
  int v117; // [sp+234h] [bp+234h]
  int v118; // [sp+238h] [bp+238h]
  int v119; // [sp+23Ch] [bp+23Ch]
  unsigned int v120; // [sp+240h] [bp+240h]
  unsigned int v121; // [sp+244h] [bp+244h]
  unsigned int v122; // [sp+248h] [bp+248h]
  unsigned int v123; // [sp+24Ch] [bp+24Ch]
  unsigned int v124; // [sp+250h] [bp+250h]
  unsigned int v125; // [sp+254h] [bp+254h]
  unsigned int v126; // [sp+258h] [bp+258h]
  int v127; // [sp+25Ch] [bp+25Ch]
  int v128; // [sp+260h] [bp+260h]
  int v129; // [sp+264h] [bp+264h]
  int v130; // [sp+268h] [bp+268h]
  unsigned int v131; // [sp+26Ch] [bp+26Ch]
  unsigned int v132; // [sp+270h] [bp+270h]
  int v133; // [sp+274h] [bp+274h]
  unsigned int v134; // [sp+278h] [bp+278h]
  unsigned int v135; // [sp+27Ch] [bp+27Ch]
  unsigned int v136; // [sp+280h] [bp+280h]
  int v137; // [sp+284h] [bp+284h]
  int v138; // [sp+288h] [bp+288h]
  int v139; // [sp+28Ch] [bp+28Ch]
  int v140; // [sp+290h] [bp+290h]
  int v141; // [sp+294h] [bp+294h]
  int v142; // [sp+298h] [bp+298h]
  int v143; // [sp+29Ch] [bp+29Ch]
  unsigned int v144; // [sp+2A0h] [bp+2A0h]
  unsigned int v145; // [sp+2A4h] [bp+2A4h]
  unsigned int v146; // [sp+2A8h] [bp+2A8h]
  int v147; // [sp+2ACh] [bp+2ACh]
  int v148; // [sp+2B0h] [bp+2B0h]
  int v149; // [sp+2B4h] [bp+2B4h]
  int v150; // [sp+2B8h] [bp+2B8h]
  int v151; // [sp+2BCh] [bp+2BCh]
  int v152; // [sp+2C0h] [bp+2C0h]
  int v153; // [sp+2C4h] [bp+2C4h]
  unsigned int v154; // [sp+2C8h] [bp+2C8h]
  unsigned int v155; // [sp+2CCh] [bp+2CCh]
  unsigned int v156; // [sp+2D0h] [bp+2D0h]
  int v157; // [sp+2D4h] [bp+2D4h]
  int v158; // [sp+2D8h] [bp+2D8h]
  int v159; // [sp+2DCh] [bp+2DCh]
  int v160; // [sp+2E0h] [bp+2E0h]
  int v161; // [sp+2E4h] [bp+2E4h]
  int v162; // [sp+2E8h] [bp+2E8h]
  int v163; // [sp+2ECh] [bp+2ECh]
  unsigned int v164; // [sp+2F0h] [bp+2F0h]
  unsigned int v165; // [sp+2F4h] [bp+2F4h]
  unsigned int v166; // [sp+2F8h] [bp+2F8h]
  int v167; // [sp+2FCh] [bp+2FCh]
  int v168; // [sp+300h] [bp+300h]
  int v169; // [sp+304h] [bp+304h]
  unsigned int v170; // [sp+308h] [bp+308h]
  int v171; // [sp+30Ch] [bp+30Ch]
  int v172; // [sp+310h] [bp+310h]
  int v173; // [sp+314h] [bp+314h]
  unsigned int v174; // [sp+318h] [bp+318h]
  unsigned int v175; // [sp+31Ch] [bp+31Ch]
  unsigned int v176; // [sp+320h] [bp+320h]
  int v177; // [sp+324h] [bp+324h]
  int v178; // [sp+328h] [bp+328h]
  int v179; // [sp+32Ch] [bp+32Ch]
  int v180; // [sp+330h] [bp+330h]
  int v181; // [sp+334h] [bp+334h]
  int v182; // [sp+338h] [bp+338h]
  int v183; // [sp+33Ch] [bp+33Ch]
  unsigned int v184; // [sp+340h] [bp+340h]
  unsigned int v185; // [sp+344h] [bp+344h]
  unsigned int v186; // [sp+348h] [bp+348h]
  int v187; // [sp+34Ch] [bp+34Ch]
  int v188; // [sp+350h] [bp+350h]
  int v189; // [sp+354h] [bp+354h]
  int v190; // [sp+358h] [bp+358h]
  int v191; // [sp+35Ch] [bp+35Ch]
  int v192; // [sp+360h] [bp+360h]
  int v193; // [sp+364h] [bp+364h]
  unsigned int v194; // [sp+368h] [bp+368h]
  unsigned int v195; // [sp+36Ch] [bp+36Ch]
  unsigned int v196; // [sp+370h] [bp+370h]
  int v197; // [sp+374h] [bp+374h]
  int v198; // [sp+378h] [bp+378h]
  int v199; // [sp+37Ch] [bp+37Ch]
  int v200; // [sp+380h] [bp+380h]
  int v201; // [sp+384h] [bp+384h]
  int v202; // [sp+388h] [bp+388h]
  int v203; // [sp+38Ch] [bp+38Ch]
  unsigned int v204; // [sp+390h] [bp+390h]
  unsigned int v205; // [sp+394h] [bp+394h]
  unsigned int v206; // [sp+398h] [bp+398h]
  unsigned int v207; // [sp+39Ch] [bp+39Ch]
  unsigned int v208; // [sp+3A0h] [bp+3A0h]
  unsigned int v209; // [sp+3A4h] [bp+3A4h]
  unsigned int v210; // [sp+3A8h] [bp+3A8h]
  unsigned int v211; // [sp+3ACh] [bp+3ACh]
  unsigned int v212; // [sp+3B0h] [bp+3B0h]
  unsigned int v213; // [sp+3B4h] [bp+3B4h]
  unsigned int v214; // [sp+3B8h] [bp+3B8h]
  unsigned int v215; // [sp+3BCh] [bp+3BCh]
  unsigned int v216; // [sp+3C0h] [bp+3C0h]
  unsigned int v217; // [sp+3C4h] [bp+3C4h]
  unsigned int v218; // [sp+3C8h] [bp+3C8h]
  unsigned int v219; // [sp+3CCh] [bp+3CCh]
  unsigned int v220; // [sp+3D0h] [bp+3D0h]
  unsigned int v221; // [sp+3D4h] [bp+3D4h]
  unsigned int v222; // [sp+3D8h] [bp+3D8h]
  unsigned int v223; // [sp+3DCh] [bp+3DCh]
  unsigned int v224; // [sp+3E0h] [bp+3E0h]
  unsigned int v225; // [sp+3E4h] [bp+3E4h]
  unsigned int v226; // [sp+3E8h] [bp+3E8h]
  unsigned int v227; // [sp+3ECh] [bp+3ECh]
  unsigned int v228; // [sp+3F0h] [bp+3F0h]
  unsigned int v229; // [sp+3F4h] [bp+3F4h]
  unsigned int v230; // [sp+3F8h] [bp+3F8h]
  unsigned int v231; // [sp+3FCh] [bp+3FCh]
  unsigned int v232; // [sp+400h] [bp+400h]
  unsigned int v233; // [sp+404h] [bp+404h]
  unsigned int v234; // [sp+408h] [bp+408h]
  unsigned int v235; // [sp+40Ch] [bp+40Ch]
  unsigned int v236; // [sp+410h] [bp+410h]
  unsigned int v237; // [sp+414h] [bp+414h]
  unsigned int v238; // [sp+418h] [bp+418h]
  unsigned int v239; // [sp+41Ch] [bp+41Ch]
  unsigned int v240; // [sp+420h] [bp+420h]
  unsigned int v241; // [sp+424h] [bp+424h]
  unsigned int v242; // [sp+428h] [bp+428h]
  unsigned int v243; // [sp+42Ch] [bp+42Ch]
  unsigned int v244; // [sp+430h] [bp+430h]
  unsigned int v245; // [sp+434h] [bp+434h]
  unsigned int v246; // [sp+438h] [bp+438h]
  unsigned int v247; // [sp+43Ch] [bp+43Ch]
  unsigned int v248; // [sp+440h] [bp+440h]
  unsigned int v249; // [sp+444h] [bp+444h]
  unsigned int v250; // [sp+448h] [bp+448h]
  unsigned int v251; // [sp+44Ch] [bp+44Ch]
  unsigned int v252; // [sp+450h] [bp+450h]
  unsigned int v253; // [sp+454h] [bp+454h]
  unsigned int v254; // [sp+458h] [bp+458h]
  unsigned int v255; // [sp+45Ch] [bp+45Ch]
  unsigned int v256; // [sp+460h] [bp+460h]
  unsigned int v257; // [sp+464h] [bp+464h]
  unsigned int v258; // [sp+468h] [bp+468h]
  unsigned int v259; // [sp+46Ch] [bp+46Ch]
  unsigned int v260; // [sp+470h] [bp+470h]
  unsigned int v261; // [sp+474h] [bp+474h]
  unsigned int v262; // [sp+478h] [bp+478h]
  unsigned int v263; // [sp+47Ch] [bp+47Ch]
  unsigned int v264; // [sp+480h] [bp+480h]
  unsigned int v265; // [sp+484h] [bp+484h]
  unsigned int v266; // [sp+488h] [bp+488h]
  unsigned int v267; // [sp+48Ch] [bp+48Ch]
  unsigned int v268; // [sp+490h] [bp+490h]
  unsigned int v269; // [sp+494h] [bp+494h]
  unsigned int v270; // [sp+498h] [bp+498h]
  unsigned int k; // [sp+49Ch] [bp+49Ch]
  unsigned int i; // [sp+4A0h] [bp+4A0h]
  unsigned int j; // [sp+4A4h] [bp+4A4h]
  int v274; // [sp+4A8h] [bp+4A8h]
  int v275; // [sp+4ACh] [bp+4ACh]
  int v276; // [sp+4B0h] [bp+4B0h]
  int v277; // [sp+4B4h] [bp+4B4h]

  v277 = a1[66];
  v276 = a1[67];
  v275 = a1[68];
  v274 = a1[69];
  result = memcpy(dest, a1 + 34, sizeof(dest));
  for ( i = 0; i <= 7; ++i )
  {
    v2 = i + 8;
    LODWORD(dest[v2]) = sub_1673D0((int)&a1[4 * i]);
    v3 = i + 8;
    DWORD1(dest[v3]) = sub_1673D0((int)&a1[4 * i + 1]);
    v4 = i + 8;
    DWORD2(dest[v4]) = sub_1673D0((int)&a1[4 * i + 2]);
    v5 = i + 8;
    result = (void *)sub_1673D0((int)&a1[4 * i + 3]);
    HIDWORD(dest[v5]) = result;
  }
  for ( j = 0; j <= 9; ++j )
  {
    v270 = v277
         ^ dword_1D5D68[LOBYTE(dest[0])]
         ^ dword_1D6168[BYTE5(dest[0])]
         ^ dword_1D6568[BYTE10(dest[0])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[0]))];
    v269 = v276
         ^ dword_1D5D68[BYTE4(dest[0])]
         ^ dword_1D6168[BYTE9(dest[0])]
         ^ dword_1D6568[BYTE14(dest[0])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[0]))];
    v268 = v275
         ^ dword_1D5D68[BYTE8(dest[0])]
         ^ dword_1D6168[BYTE13(dest[0])]
         ^ dword_1D6568[BYTE2(dest[0])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[0]))];
    v267 = v274
         ^ dword_1D5D68[BYTE12(dest[0])]
         ^ dword_1D6168[BYTE1(dest[0])]
         ^ dword_1D6568[BYTE6(dest[0])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[0]))];
    LODWORD(dest[0]) = dword_1D5D68[(unsigned __int8)v270]
                     ^ dword_1D6168[BYTE1(v269)]
                     ^ dword_1D6568[BYTE2(v268)]
                     ^ dword_1D6968[HIBYTE(v267)];
    DWORD1(dest[0]) = dword_1D5D68[(unsigned __int8)v269]
                    ^ dword_1D6168[BYTE1(v268)]
                    ^ dword_1D6568[BYTE2(v267)]
                    ^ dword_1D6968[HIBYTE(v270)];
    DWORD2(dest[0]) = dword_1D5D68[(unsigned __int8)v268]
                    ^ dword_1D6168[BYTE1(v267)]
                    ^ dword_1D6568[BYTE2(v270)]
                    ^ dword_1D6968[HIBYTE(v269)];
    HIDWORD(dest[0]) = dword_1D5D68[(unsigned __int8)v267]
                     ^ dword_1D6168[BYTE1(v270)]
                     ^ dword_1D6568[BYTE2(v269)]
                     ^ dword_1D6968[HIBYTE(v268)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v266 = v277
         ^ dword_1D5D68[LOBYTE(dest[1])]
         ^ dword_1D6168[BYTE5(dest[1])]
         ^ dword_1D6568[BYTE10(dest[1])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[1]))];
    v265 = v276
         ^ dword_1D5D68[BYTE4(dest[1])]
         ^ dword_1D6168[BYTE9(dest[1])]
         ^ dword_1D6568[BYTE14(dest[1])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[1]))];
    v264 = v275
         ^ dword_1D5D68[BYTE8(dest[1])]
         ^ dword_1D6168[BYTE13(dest[1])]
         ^ dword_1D6568[BYTE2(dest[1])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[1]))];
    v263 = v274
         ^ dword_1D5D68[BYTE12(dest[1])]
         ^ dword_1D6168[BYTE1(dest[1])]
         ^ dword_1D6568[BYTE6(dest[1])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[1]))];
    LODWORD(dest[1]) = dword_1D5D68[(unsigned __int8)v266]
                     ^ dword_1D6168[BYTE1(v265)]
                     ^ dword_1D6568[BYTE2(v264)]
                     ^ dword_1D6968[HIBYTE(v263)];
    DWORD1(dest[1]) = dword_1D5D68[(unsigned __int8)v265]
                    ^ dword_1D6168[BYTE1(v264)]
                    ^ dword_1D6568[BYTE2(v263)]
                    ^ dword_1D6968[HIBYTE(v266)];
    DWORD2(dest[1]) = dword_1D5D68[(unsigned __int8)v264]
                    ^ dword_1D6168[BYTE1(v263)]
                    ^ dword_1D6568[BYTE2(v266)]
                    ^ dword_1D6968[HIBYTE(v265)];
    HIDWORD(dest[1]) = dword_1D5D68[(unsigned __int8)v263]
                     ^ dword_1D6168[BYTE1(v266)]
                     ^ dword_1D6568[BYTE2(v265)]
                     ^ dword_1D6968[HIBYTE(v264)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v262 = v277
         ^ dword_1D5D68[LOBYTE(dest[2])]
         ^ dword_1D6168[BYTE5(dest[2])]
         ^ dword_1D6568[BYTE10(dest[2])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[2]))];
    v261 = v276
         ^ dword_1D5D68[BYTE4(dest[2])]
         ^ dword_1D6168[BYTE9(dest[2])]
         ^ dword_1D6568[BYTE14(dest[2])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[2]))];
    v260 = v275
         ^ dword_1D5D68[BYTE8(dest[2])]
         ^ dword_1D6168[BYTE13(dest[2])]
         ^ dword_1D6568[BYTE2(dest[2])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[2]))];
    v259 = v274
         ^ dword_1D5D68[BYTE12(dest[2])]
         ^ dword_1D6168[BYTE1(dest[2])]
         ^ dword_1D6568[BYTE6(dest[2])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[2]))];
    LODWORD(dest[2]) = dword_1D5D68[(unsigned __int8)v262]
                     ^ dword_1D6168[BYTE1(v261)]
                     ^ dword_1D6568[BYTE2(v260)]
                     ^ dword_1D6968[HIBYTE(v259)];
    DWORD1(dest[2]) = dword_1D5D68[(unsigned __int8)v261]
                    ^ dword_1D6168[BYTE1(v260)]
                    ^ dword_1D6568[BYTE2(v259)]
                    ^ dword_1D6968[HIBYTE(v262)];
    DWORD2(dest[2]) = dword_1D5D68[(unsigned __int8)v260]
                    ^ dword_1D6168[BYTE1(v259)]
                    ^ dword_1D6568[BYTE2(v262)]
                    ^ dword_1D6968[HIBYTE(v261)];
    HIDWORD(dest[2]) = dword_1D5D68[(unsigned __int8)v259]
                     ^ dword_1D6168[BYTE1(v262)]
                     ^ dword_1D6568[BYTE2(v261)]
                     ^ dword_1D6968[HIBYTE(v260)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v258 = v277
         ^ dword_1D5D68[LOBYTE(dest[3])]
         ^ dword_1D6168[BYTE5(dest[3])]
         ^ dword_1D6568[BYTE10(dest[3])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[3]))];
    v257 = v276
         ^ dword_1D5D68[BYTE4(dest[3])]
         ^ dword_1D6168[BYTE9(dest[3])]
         ^ dword_1D6568[BYTE14(dest[3])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[3]))];
    v256 = v275
         ^ dword_1D5D68[BYTE8(dest[3])]
         ^ dword_1D6168[BYTE13(dest[3])]
         ^ dword_1D6568[BYTE2(dest[3])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[3]))];
    v255 = v274
         ^ dword_1D5D68[BYTE12(dest[3])]
         ^ dword_1D6168[BYTE1(dest[3])]
         ^ dword_1D6568[BYTE6(dest[3])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[3]))];
    LODWORD(dest[3]) = dword_1D5D68[(unsigned __int8)v258]
                     ^ dword_1D6168[BYTE1(v257)]
                     ^ dword_1D6568[BYTE2(v256)]
                     ^ dword_1D6968[HIBYTE(v255)];
    DWORD1(dest[3]) = dword_1D5D68[(unsigned __int8)v257]
                    ^ dword_1D6168[BYTE1(v256)]
                    ^ dword_1D6568[BYTE2(v255)]
                    ^ dword_1D6968[HIBYTE(v258)];
    DWORD2(dest[3]) = dword_1D5D68[(unsigned __int8)v256]
                    ^ dword_1D6168[BYTE1(v255)]
                    ^ dword_1D6568[BYTE2(v258)]
                    ^ dword_1D6968[HIBYTE(v257)];
    HIDWORD(dest[3]) = dword_1D5D68[(unsigned __int8)v255]
                     ^ dword_1D6168[BYTE1(v258)]
                     ^ dword_1D6568[BYTE2(v257)]
                     ^ dword_1D6968[HIBYTE(v256)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v254 = v277
         ^ dword_1D5D68[LOBYTE(dest[4])]
         ^ dword_1D6168[BYTE5(dest[4])]
         ^ dword_1D6568[BYTE10(dest[4])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[4]))];
    v253 = v276
         ^ dword_1D5D68[BYTE4(dest[4])]
         ^ dword_1D6168[BYTE9(dest[4])]
         ^ dword_1D6568[BYTE14(dest[4])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[4]))];
    v252 = v275
         ^ dword_1D5D68[BYTE8(dest[4])]
         ^ dword_1D6168[BYTE13(dest[4])]
         ^ dword_1D6568[BYTE2(dest[4])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[4]))];
    v251 = v274
         ^ dword_1D5D68[BYTE12(dest[4])]
         ^ dword_1D6168[BYTE1(dest[4])]
         ^ dword_1D6568[BYTE6(dest[4])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[4]))];
    LODWORD(dest[4]) = dword_1D5D68[(unsigned __int8)v254]
                     ^ dword_1D6168[BYTE1(v253)]
                     ^ dword_1D6568[BYTE2(v252)]
                     ^ dword_1D6968[HIBYTE(v251)];
    DWORD1(dest[4]) = dword_1D5D68[(unsigned __int8)v253]
                    ^ dword_1D6168[BYTE1(v252)]
                    ^ dword_1D6568[BYTE2(v251)]
                    ^ dword_1D6968[HIBYTE(v254)];
    DWORD2(dest[4]) = dword_1D5D68[(unsigned __int8)v252]
                    ^ dword_1D6168[BYTE1(v251)]
                    ^ dword_1D6568[BYTE2(v254)]
                    ^ dword_1D6968[HIBYTE(v253)];
    HIDWORD(dest[4]) = dword_1D5D68[(unsigned __int8)v251]
                     ^ dword_1D6168[BYTE1(v254)]
                     ^ dword_1D6568[BYTE2(v253)]
                     ^ dword_1D6968[HIBYTE(v252)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v250 = v277
         ^ dword_1D5D68[LOBYTE(dest[5])]
         ^ dword_1D6168[BYTE5(dest[5])]
         ^ dword_1D6568[BYTE10(dest[5])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[5]))];
    v249 = v276
         ^ dword_1D5D68[BYTE4(dest[5])]
         ^ dword_1D6168[BYTE9(dest[5])]
         ^ dword_1D6568[BYTE14(dest[5])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[5]))];
    v248 = v275
         ^ dword_1D5D68[BYTE8(dest[5])]
         ^ dword_1D6168[BYTE13(dest[5])]
         ^ dword_1D6568[BYTE2(dest[5])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[5]))];
    v247 = v274
         ^ dword_1D5D68[BYTE12(dest[5])]
         ^ dword_1D6168[BYTE1(dest[5])]
         ^ dword_1D6568[BYTE6(dest[5])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[5]))];
    LODWORD(dest[5]) = dword_1D5D68[(unsigned __int8)v250]
                     ^ dword_1D6168[BYTE1(v249)]
                     ^ dword_1D6568[BYTE2(v248)]
                     ^ dword_1D6968[HIBYTE(v247)];
    DWORD1(dest[5]) = dword_1D5D68[(unsigned __int8)v249]
                    ^ dword_1D6168[BYTE1(v248)]
                    ^ dword_1D6568[BYTE2(v247)]
                    ^ dword_1D6968[HIBYTE(v250)];
    DWORD2(dest[5]) = dword_1D5D68[(unsigned __int8)v248]
                    ^ dword_1D6168[BYTE1(v247)]
                    ^ dword_1D6568[BYTE2(v250)]
                    ^ dword_1D6968[HIBYTE(v249)];
    HIDWORD(dest[5]) = dword_1D5D68[(unsigned __int8)v247]
                     ^ dword_1D6168[BYTE1(v250)]
                     ^ dword_1D6568[BYTE2(v249)]
                     ^ dword_1D6968[HIBYTE(v248)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v246 = v277
         ^ dword_1D5D68[LOBYTE(dest[6])]
         ^ dword_1D6168[BYTE5(dest[6])]
         ^ dword_1D6568[BYTE10(dest[6])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[6]))];
    v245 = v276
         ^ dword_1D5D68[BYTE4(dest[6])]
         ^ dword_1D6168[BYTE9(dest[6])]
         ^ dword_1D6568[BYTE14(dest[6])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[6]))];
    v244 = v275
         ^ dword_1D5D68[BYTE8(dest[6])]
         ^ dword_1D6168[BYTE13(dest[6])]
         ^ dword_1D6568[BYTE2(dest[6])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[6]))];
    v243 = v274
         ^ dword_1D5D68[BYTE12(dest[6])]
         ^ dword_1D6168[BYTE1(dest[6])]
         ^ dword_1D6568[BYTE6(dest[6])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[6]))];
    LODWORD(dest[6]) = dword_1D5D68[(unsigned __int8)v246]
                     ^ dword_1D6168[BYTE1(v245)]
                     ^ dword_1D6568[BYTE2(v244)]
                     ^ dword_1D6968[HIBYTE(v243)];
    DWORD1(dest[6]) = dword_1D5D68[(unsigned __int8)v245]
                    ^ dword_1D6168[BYTE1(v244)]
                    ^ dword_1D6568[BYTE2(v243)]
                    ^ dword_1D6968[HIBYTE(v246)];
    DWORD2(dest[6]) = dword_1D5D68[(unsigned __int8)v244]
                    ^ dword_1D6168[BYTE1(v243)]
                    ^ dword_1D6568[BYTE2(v246)]
                    ^ dword_1D6968[HIBYTE(v245)];
    HIDWORD(dest[6]) = dword_1D5D68[(unsigned __int8)v243]
                     ^ dword_1D6168[BYTE1(v246)]
                     ^ dword_1D6568[BYTE2(v245)]
                     ^ dword_1D6968[HIBYTE(v244)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v242 = v277
         ^ dword_1D5D68[LOBYTE(dest[7])]
         ^ dword_1D6168[BYTE5(dest[7])]
         ^ dword_1D6568[BYTE10(dest[7])]
         ^ dword_1D6968[HIBYTE(HIDWORD(dest[7]))];
    v241 = v276
         ^ dword_1D5D68[BYTE4(dest[7])]
         ^ dword_1D6168[BYTE9(dest[7])]
         ^ dword_1D6568[BYTE14(dest[7])]
         ^ dword_1D6968[HIBYTE(LODWORD(dest[7]))];
    v240 = v275
         ^ dword_1D5D68[BYTE8(dest[7])]
         ^ dword_1D6168[BYTE13(dest[7])]
         ^ dword_1D6568[BYTE2(dest[7])]
         ^ dword_1D6968[HIBYTE(DWORD1(dest[7]))];
    v239 = v274
         ^ dword_1D5D68[BYTE12(dest[7])]
         ^ dword_1D6168[BYTE1(dest[7])]
         ^ dword_1D6568[BYTE6(dest[7])]
         ^ dword_1D6968[HIBYTE(DWORD2(dest[7]))];
    LODWORD(dest[7]) = dword_1D5D68[(unsigned __int8)v242]
                     ^ dword_1D6168[BYTE1(v241)]
                     ^ dword_1D6568[BYTE2(v240)]
                     ^ dword_1D6968[HIBYTE(v239)];
    DWORD1(dest[7]) = dword_1D5D68[(unsigned __int8)v241]
                    ^ dword_1D6168[BYTE1(v240)]
                    ^ dword_1D6568[BYTE2(v239)]
                    ^ dword_1D6968[HIBYTE(v242)];
    DWORD2(dest[7]) = dword_1D5D68[(unsigned __int8)v240]
                    ^ dword_1D6168[BYTE1(v239)]
                    ^ dword_1D6568[BYTE2(v242)]
                    ^ dword_1D6968[HIBYTE(v241)];
    HIDWORD(dest[7]) = dword_1D5D68[(unsigned __int8)v239]
                     ^ dword_1D6168[BYTE1(v242)]
                     ^ dword_1D6568[BYTE2(v241)]
                     ^ dword_1D6968[HIBYTE(v240)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v238 = v277
         ^ dword_1D5D68[(unsigned __int8)v10]
         ^ dword_1D6168[BYTE1(v11)]
         ^ dword_1D6568[BYTE2(v12)]
         ^ dword_1D6968[HIBYTE(v13)];
    v237 = v276
         ^ dword_1D5D68[(unsigned __int8)v11]
         ^ dword_1D6168[BYTE1(v12)]
         ^ dword_1D6568[BYTE2(v13)]
         ^ dword_1D6968[HIBYTE(v10)];
    v236 = v275
         ^ dword_1D5D68[(unsigned __int8)v12]
         ^ dword_1D6168[BYTE1(v13)]
         ^ dword_1D6568[BYTE2(v10)]
         ^ dword_1D6968[HIBYTE(v11)];
    v235 = v274
         ^ dword_1D5D68[(unsigned __int8)v13]
         ^ dword_1D6168[BYTE1(v10)]
         ^ dword_1D6568[BYTE2(v11)]
         ^ dword_1D6968[HIBYTE(v12)];
    v10 = dword_1D5D68[(unsigned __int8)v238]
        ^ dword_1D6168[BYTE1(v237)]
        ^ dword_1D6568[BYTE2(v236)]
        ^ dword_1D6968[HIBYTE(v235)];
    v11 = dword_1D5D68[(unsigned __int8)v237]
        ^ dword_1D6168[BYTE1(v236)]
        ^ dword_1D6568[BYTE2(v235)]
        ^ dword_1D6968[HIBYTE(v238)];
    v12 = dword_1D5D68[(unsigned __int8)v236]
        ^ dword_1D6168[BYTE1(v235)]
        ^ dword_1D6568[BYTE2(v238)]
        ^ dword_1D6968[HIBYTE(v237)];
    v13 = dword_1D5D68[(unsigned __int8)v235]
        ^ dword_1D6168[BYTE1(v238)]
        ^ dword_1D6568[BYTE2(v237)]
        ^ dword_1D6968[HIBYTE(v236)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v234 = v277
         ^ dword_1D5D68[(unsigned __int8)v14]
         ^ dword_1D6168[BYTE1(v15)]
         ^ dword_1D6568[BYTE2(v16)]
         ^ dword_1D6968[HIBYTE(v17)];
    v233 = v276
         ^ dword_1D5D68[(unsigned __int8)v15]
         ^ dword_1D6168[BYTE1(v16)]
         ^ dword_1D6568[BYTE2(v17)]
         ^ dword_1D6968[HIBYTE(v14)];
    v232 = v275
         ^ dword_1D5D68[(unsigned __int8)v16]
         ^ dword_1D6168[BYTE1(v17)]
         ^ dword_1D6568[BYTE2(v14)]
         ^ dword_1D6968[HIBYTE(v15)];
    v231 = v274
         ^ dword_1D5D68[(unsigned __int8)v17]
         ^ dword_1D6168[BYTE1(v14)]
         ^ dword_1D6568[BYTE2(v15)]
         ^ dword_1D6968[HIBYTE(v16)];
    v14 = dword_1D5D68[(unsigned __int8)v234]
        ^ dword_1D6168[BYTE1(v233)]
        ^ dword_1D6568[BYTE2(v232)]
        ^ dword_1D6968[HIBYTE(v231)];
    v15 = dword_1D5D68[(unsigned __int8)v233]
        ^ dword_1D6168[BYTE1(v232)]
        ^ dword_1D6568[BYTE2(v231)]
        ^ dword_1D6968[HIBYTE(v234)];
    v16 = dword_1D5D68[(unsigned __int8)v232]
        ^ dword_1D6168[BYTE1(v231)]
        ^ dword_1D6568[BYTE2(v234)]
        ^ dword_1D6968[HIBYTE(v233)];
    v17 = dword_1D5D68[(unsigned __int8)v231]
        ^ dword_1D6168[BYTE1(v234)]
        ^ dword_1D6568[BYTE2(v233)]
        ^ dword_1D6968[HIBYTE(v232)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v230 = v277
         ^ dword_1D5D68[(unsigned __int8)v18]
         ^ dword_1D6168[BYTE1(v19)]
         ^ dword_1D6568[BYTE2(v20)]
         ^ dword_1D6968[HIBYTE(v21)];
    v229 = v276
         ^ dword_1D5D68[(unsigned __int8)v19]
         ^ dword_1D6168[BYTE1(v20)]
         ^ dword_1D6568[BYTE2(v21)]
         ^ dword_1D6968[HIBYTE(v18)];
    v228 = v275
         ^ dword_1D5D68[(unsigned __int8)v20]
         ^ dword_1D6168[BYTE1(v21)]
         ^ dword_1D6568[BYTE2(v18)]
         ^ dword_1D6968[HIBYTE(v19)];
    v227 = v274
         ^ dword_1D5D68[(unsigned __int8)v21]
         ^ dword_1D6168[BYTE1(v18)]
         ^ dword_1D6568[BYTE2(v19)]
         ^ dword_1D6968[HIBYTE(v20)];
    v18 = dword_1D5D68[(unsigned __int8)v230]
        ^ dword_1D6168[BYTE1(v229)]
        ^ dword_1D6568[BYTE2(v228)]
        ^ dword_1D6968[HIBYTE(v227)];
    v19 = dword_1D5D68[(unsigned __int8)v229]
        ^ dword_1D6168[BYTE1(v228)]
        ^ dword_1D6568[BYTE2(v227)]
        ^ dword_1D6968[HIBYTE(v230)];
    v20 = dword_1D5D68[(unsigned __int8)v228]
        ^ dword_1D6168[BYTE1(v227)]
        ^ dword_1D6568[BYTE2(v230)]
        ^ dword_1D6968[HIBYTE(v229)];
    v21 = dword_1D5D68[(unsigned __int8)v227]
        ^ dword_1D6168[BYTE1(v230)]
        ^ dword_1D6568[BYTE2(v229)]
        ^ dword_1D6968[HIBYTE(v228)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v226 = v277
         ^ dword_1D5D68[(unsigned __int8)v22]
         ^ dword_1D6168[BYTE1(v23)]
         ^ dword_1D6568[BYTE2(v24)]
         ^ dword_1D6968[HIBYTE(v25)];
    v225 = v276
         ^ dword_1D5D68[(unsigned __int8)v23]
         ^ dword_1D6168[BYTE1(v24)]
         ^ dword_1D6568[BYTE2(v25)]
         ^ dword_1D6968[HIBYTE(v22)];
    v224 = v275
         ^ dword_1D5D68[(unsigned __int8)v24]
         ^ dword_1D6168[BYTE1(v25)]
         ^ dword_1D6568[BYTE2(v22)]
         ^ dword_1D6968[HIBYTE(v23)];
    v223 = v274
         ^ dword_1D5D68[(unsigned __int8)v25]
         ^ dword_1D6168[BYTE1(v22)]
         ^ dword_1D6568[BYTE2(v23)]
         ^ dword_1D6968[HIBYTE(v24)];
    v22 = dword_1D5D68[(unsigned __int8)v226]
        ^ dword_1D6168[BYTE1(v225)]
        ^ dword_1D6568[BYTE2(v224)]
        ^ dword_1D6968[HIBYTE(v223)];
    v23 = dword_1D5D68[(unsigned __int8)v225]
        ^ dword_1D6168[BYTE1(v224)]
        ^ dword_1D6568[BYTE2(v223)]
        ^ dword_1D6968[HIBYTE(v226)];
    v24 = dword_1D5D68[(unsigned __int8)v224]
        ^ dword_1D6168[BYTE1(v223)]
        ^ dword_1D6568[BYTE2(v226)]
        ^ dword_1D6968[HIBYTE(v225)];
    v25 = dword_1D5D68[(unsigned __int8)v223]
        ^ dword_1D6168[BYTE1(v226)]
        ^ dword_1D6568[BYTE2(v225)]
        ^ dword_1D6968[HIBYTE(v224)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v222 = v277
         ^ dword_1D5D68[(unsigned __int8)v26]
         ^ dword_1D6168[BYTE1(v27)]
         ^ dword_1D6568[BYTE2(v28)]
         ^ dword_1D6968[HIBYTE(v29)];
    v221 = v276
         ^ dword_1D5D68[(unsigned __int8)v27]
         ^ dword_1D6168[BYTE1(v28)]
         ^ dword_1D6568[BYTE2(v29)]
         ^ dword_1D6968[HIBYTE(v26)];
    v220 = v275
         ^ dword_1D5D68[(unsigned __int8)v28]
         ^ dword_1D6168[BYTE1(v29)]
         ^ dword_1D6568[BYTE2(v26)]
         ^ dword_1D6968[HIBYTE(v27)];
    v219 = v274
         ^ dword_1D5D68[(unsigned __int8)v29]
         ^ dword_1D6168[BYTE1(v26)]
         ^ dword_1D6568[BYTE2(v27)]
         ^ dword_1D6968[HIBYTE(v28)];
    v26 = dword_1D5D68[(unsigned __int8)v222]
        ^ dword_1D6168[BYTE1(v221)]
        ^ dword_1D6568[BYTE2(v220)]
        ^ dword_1D6968[HIBYTE(v219)];
    v27 = dword_1D5D68[(unsigned __int8)v221]
        ^ dword_1D6168[BYTE1(v220)]
        ^ dword_1D6568[BYTE2(v219)]
        ^ dword_1D6968[HIBYTE(v222)];
    v28 = dword_1D5D68[(unsigned __int8)v220]
        ^ dword_1D6168[BYTE1(v219)]
        ^ dword_1D6568[BYTE2(v222)]
        ^ dword_1D6968[HIBYTE(v221)];
    v29 = dword_1D5D68[(unsigned __int8)v219]
        ^ dword_1D6168[BYTE1(v222)]
        ^ dword_1D6568[BYTE2(v221)]
        ^ dword_1D6968[HIBYTE(v220)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v218 = v277
         ^ dword_1D5D68[(unsigned __int8)v30]
         ^ dword_1D6168[BYTE1(v31)]
         ^ dword_1D6568[BYTE2(v32)]
         ^ dword_1D6968[HIBYTE(v33)];
    v217 = v276
         ^ dword_1D5D68[(unsigned __int8)v31]
         ^ dword_1D6168[BYTE1(v32)]
         ^ dword_1D6568[BYTE2(v33)]
         ^ dword_1D6968[HIBYTE(v30)];
    v216 = v275
         ^ dword_1D5D68[(unsigned __int8)v32]
         ^ dword_1D6168[BYTE1(v33)]
         ^ dword_1D6568[BYTE2(v30)]
         ^ dword_1D6968[HIBYTE(v31)];
    v215 = v274
         ^ dword_1D5D68[(unsigned __int8)v33]
         ^ dword_1D6168[BYTE1(v30)]
         ^ dword_1D6568[BYTE2(v31)]
         ^ dword_1D6968[HIBYTE(v32)];
    v30 = dword_1D5D68[(unsigned __int8)v218]
        ^ dword_1D6168[BYTE1(v217)]
        ^ dword_1D6568[BYTE2(v216)]
        ^ dword_1D6968[HIBYTE(v215)];
    v31 = dword_1D5D68[(unsigned __int8)v217]
        ^ dword_1D6168[BYTE1(v216)]
        ^ dword_1D6568[BYTE2(v215)]
        ^ dword_1D6968[HIBYTE(v218)];
    v32 = dword_1D5D68[(unsigned __int8)v216]
        ^ dword_1D6168[BYTE1(v215)]
        ^ dword_1D6568[BYTE2(v218)]
        ^ dword_1D6968[HIBYTE(v217)];
    v33 = dword_1D5D68[(unsigned __int8)v215]
        ^ dword_1D6168[BYTE1(v218)]
        ^ dword_1D6568[BYTE2(v217)]
        ^ dword_1D6968[HIBYTE(v216)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v214 = v277
         ^ dword_1D5D68[(unsigned __int8)v34]
         ^ dword_1D6168[BYTE1(v35)]
         ^ dword_1D6568[BYTE2(v36)]
         ^ dword_1D6968[HIBYTE(v37)];
    v213 = v276
         ^ dword_1D5D68[(unsigned __int8)v35]
         ^ dword_1D6168[BYTE1(v36)]
         ^ dword_1D6568[BYTE2(v37)]
         ^ dword_1D6968[HIBYTE(v34)];
    v212 = v275
         ^ dword_1D5D68[(unsigned __int8)v36]
         ^ dword_1D6168[BYTE1(v37)]
         ^ dword_1D6568[BYTE2(v34)]
         ^ dword_1D6968[HIBYTE(v35)];
    v211 = v274
         ^ dword_1D5D68[(unsigned __int8)v37]
         ^ dword_1D6168[BYTE1(v34)]
         ^ dword_1D6568[BYTE2(v35)]
         ^ dword_1D6968[HIBYTE(v36)];
    v34 = dword_1D5D68[(unsigned __int8)v214]
        ^ dword_1D6168[BYTE1(v213)]
        ^ dword_1D6568[BYTE2(v212)]
        ^ dword_1D6968[HIBYTE(v211)];
    v35 = dword_1D5D68[(unsigned __int8)v213]
        ^ dword_1D6168[BYTE1(v212)]
        ^ dword_1D6568[BYTE2(v211)]
        ^ dword_1D6968[HIBYTE(v214)];
    v36 = dword_1D5D68[(unsigned __int8)v212]
        ^ dword_1D6168[BYTE1(v211)]
        ^ dword_1D6568[BYTE2(v214)]
        ^ dword_1D6968[HIBYTE(v213)];
    v37 = dword_1D5D68[(unsigned __int8)v211]
        ^ dword_1D6168[BYTE1(v214)]
        ^ dword_1D6568[BYTE2(v213)]
        ^ dword_1D6968[HIBYTE(v212)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v210 = v277
         ^ dword_1D5D68[(unsigned __int8)v38]
         ^ dword_1D6168[BYTE1(v39)]
         ^ dword_1D6568[BYTE2(v40)]
         ^ dword_1D6968[HIBYTE(v41)];
    v209 = v276
         ^ dword_1D5D68[(unsigned __int8)v39]
         ^ dword_1D6168[BYTE1(v40)]
         ^ dword_1D6568[BYTE2(v41)]
         ^ dword_1D6968[HIBYTE(v38)];
    v208 = v275
         ^ dword_1D5D68[(unsigned __int8)v40]
         ^ dword_1D6168[BYTE1(v41)]
         ^ dword_1D6568[BYTE2(v38)]
         ^ dword_1D6968[HIBYTE(v39)];
    v207 = v274
         ^ dword_1D5D68[(unsigned __int8)v41]
         ^ dword_1D6168[BYTE1(v38)]
         ^ dword_1D6568[BYTE2(v39)]
         ^ dword_1D6968[HIBYTE(v40)];
    v38 = dword_1D5D68[(unsigned __int8)v210]
        ^ dword_1D6168[BYTE1(v209)]
        ^ dword_1D6568[BYTE2(v208)]
        ^ dword_1D6968[HIBYTE(v207)];
    v39 = dword_1D5D68[(unsigned __int8)v209]
        ^ dword_1D6168[BYTE1(v208)]
        ^ dword_1D6568[BYTE2(v207)]
        ^ dword_1D6968[HIBYTE(v210)];
    v40 = dword_1D5D68[(unsigned __int8)v208]
        ^ dword_1D6168[BYTE1(v207)]
        ^ dword_1D6568[BYTE2(v210)]
        ^ dword_1D6968[HIBYTE(v209)];
    v41 = dword_1D5D68[(unsigned __int8)v207]
        ^ dword_1D6168[BYTE1(v210)]
        ^ dword_1D6568[BYTE2(v209)]
        ^ dword_1D6968[HIBYTE(v208)];
    if ( !++v277 && !++v276 && !++v275 )
      ++v274;
    v206 = dest[1];
    LODWORD(dest[1]) = dest[5];
    LODWORD(dest[5]) = v14;
    v14 = v30;
    v30 = v206;
    v206 = DWORD1(dest[1]);
    DWORD1(dest[1]) = DWORD1(dest[5]);
    DWORD1(dest[5]) = v15;
    v15 = v31;
    v31 = v206;
    v206 = DWORD2(dest[1]);
    DWORD2(dest[1]) = DWORD2(dest[5]);
    DWORD2(dest[5]) = v16;
    v16 = v32;
    v32 = v206;
    v206 = HIDWORD(dest[1]);
    v205 = dest[2];
    LODWORD(dest[2]) = v18;
    v18 = v205;
    v205 = dest[6];
    LODWORD(dest[6]) = v34;
    v34 = v205;
    v205 = DWORD1(dest[2]);
    DWORD1(dest[2]) = v19;
    v19 = v205;
    v205 = DWORD1(dest[6]);
    DWORD1(dest[6]) = v35;
    v35 = v205;
    v205 = DWORD2(dest[2]);
    DWORD2(dest[2]) = v20;
    v20 = v205;
    v205 = DWORD2(dest[6]);
    DWORD2(dest[6]) = v36;
    v36 = v205;
    v205 = HIDWORD(dest[2]);
    HIDWORD(dest[2]) = v21;
    v21 = v205;
    v205 = HIDWORD(dest[6]);
    v204 = v38;
    v38 = v22;
    v22 = dest[7];
    LODWORD(dest[7]) = dest[3];
    LODWORD(dest[3]) = v204;
    v204 = v39;
    v39 = v23;
    v23 = DWORD1(dest[7]);
    DWORD1(dest[7]) = DWORD1(dest[3]);
    DWORD1(dest[3]) = v204;
    v204 = v40;
    v40 = v24;
    v24 = DWORD2(dest[7]);
    DWORD2(dest[7]) = DWORD2(dest[3]);
    DWORD2(dest[3]) = v204;
    v204 = v41;
    v41 = v25;
    v25 = HIDWORD(dest[7]);
    HIDWORD(dest[7]) = HIDWORD(dest[3]);
    v203 = dest[0];
    v202 = dest[1];
    v201 = dest[2];
    v200 = dest[3];
    v199 = LODWORD(dest[1]) ^ LODWORD(dest[0]);
    v198 = LODWORD(dest[2]) ^ LODWORD(dest[1]);
    v197 = LODWORD(dest[3]) ^ LODWORD(dest[2]);
    v196 = (2 * (v199 & 0x7F7F7F7F)) ^ (27 * ((v199 & 0x80808080) >> 7));
    v195 = (2 * (v198 & 0x7F7F7F7F)) ^ (27 * ((v198 & 0x80808080) >> 7));
    v194 = (2 * (v197 & 0x7F7F7F7F)) ^ (27 * ((v197 & 0x80808080) >> 7));
    LODWORD(dest[0]) = v196 ^ LODWORD(dest[2]) ^ LODWORD(dest[1]) ^ LODWORD(dest[3]);
    LODWORD(dest[1]) = v195 ^ v203 ^ LODWORD(dest[3]) ^ LODWORD(dest[2]);
    LODWORD(dest[2]) = v194 ^ v199 ^ LODWORD(dest[3]);
    LODWORD(dest[3]) = v196 ^ v195 ^ v194 ^ v199 ^ v201;
    v193 = DWORD1(dest[0]);
    v192 = DWORD1(dest[1]);
    v191 = DWORD1(dest[2]);
    v190 = DWORD1(dest[3]);
    v189 = DWORD1(dest[1]) ^ DWORD1(dest[0]);
    v188 = DWORD1(dest[2]) ^ DWORD1(dest[1]);
    v187 = DWORD1(dest[3]) ^ DWORD1(dest[2]);
    v186 = (2 * (v189 & 0x7F7F7F7F)) ^ (27 * ((v189 & 0x80808080) >> 7));
    v185 = (2 * (v188 & 0x7F7F7F7F)) ^ (27 * ((v188 & 0x80808080) >> 7));
    v184 = (2 * (v187 & 0x7F7F7F7F)) ^ (27 * ((v187 & 0x80808080) >> 7));
    DWORD1(dest[0]) = v186 ^ DWORD1(dest[2]) ^ DWORD1(dest[1]) ^ DWORD1(dest[3]);
    DWORD1(dest[1]) = v185 ^ v193 ^ DWORD1(dest[3]) ^ DWORD1(dest[2]);
    DWORD1(dest[2]) = v184 ^ v189 ^ DWORD1(dest[3]);
    DWORD1(dest[3]) = v186 ^ v185 ^ v184 ^ v189 ^ v191;
    v183 = DWORD2(dest[0]);
    v182 = DWORD2(dest[1]);
    v181 = DWORD2(dest[2]);
    v180 = DWORD2(dest[3]);
    v179 = DWORD2(dest[1]) ^ DWORD2(dest[0]);
    v178 = DWORD2(dest[2]) ^ DWORD2(dest[1]);
    v177 = DWORD2(dest[3]) ^ DWORD2(dest[2]);
    v176 = (2 * (v179 & 0x7F7F7F7F)) ^ (27 * ((v179 & 0x80808080) >> 7));
    v175 = (2 * (v178 & 0x7F7F7F7F)) ^ (27 * ((v178 & 0x80808080) >> 7));
    v174 = (2 * (v177 & 0x7F7F7F7F)) ^ (27 * ((v177 & 0x80808080) >> 7));
    DWORD2(dest[0]) = v176 ^ DWORD2(dest[2]) ^ DWORD2(dest[1]) ^ DWORD2(dest[3]);
    DWORD2(dest[1]) = v175 ^ v183 ^ DWORD2(dest[3]) ^ DWORD2(dest[2]);
    DWORD2(dest[2]) = v174 ^ v179 ^ DWORD2(dest[3]);
    DWORD2(dest[3]) = v176 ^ v175 ^ v174 ^ v179 ^ v181;
    v173 = HIDWORD(dest[0]);
    v172 = HIDWORD(dest[5]);
    v171 = HIDWORD(dest[2]);
    v170 = v204;
    v169 = HIDWORD(dest[5]) ^ HIDWORD(dest[0]);
    v168 = HIDWORD(dest[2]) ^ HIDWORD(dest[5]);
    v167 = v204 ^ HIDWORD(dest[2]);
    v166 = (2 * (v169 & 0x7F7F7F7F)) ^ (27 * ((v169 & 0x80808080) >> 7));
    v165 = (2 * (v168 & 0x7F7F7F7F)) ^ (27 * ((v168 & 0x80808080) >> 7));
    v164 = (2 * (v167 & 0x7F7F7F7F)) ^ (27 * ((v167 & 0x80808080) >> 7));
    HIDWORD(dest[0]) = v166 ^ HIDWORD(dest[2]) ^ HIDWORD(dest[5]) ^ v204;
    HIDWORD(dest[1]) = v165 ^ v173 ^ v204 ^ HIDWORD(dest[2]);
    HIDWORD(dest[2]) = v164 ^ v169 ^ v204;
    HIDWORD(dest[3]) = v166 ^ v165 ^ v164 ^ v169 ^ v171;
    v163 = dest[4];
    v162 = dest[5];
    v161 = dest[6];
    v160 = dest[7];
    v159 = LODWORD(dest[5]) ^ LODWORD(dest[4]);
    v158 = LODWORD(dest[6]) ^ LODWORD(dest[5]);
    v157 = LODWORD(dest[7]) ^ LODWORD(dest[6]);
    v156 = (2 * (v159 & 0x7F7F7F7F)) ^ (27 * ((v159 & 0x80808080) >> 7));
    v155 = (2 * (v158 & 0x7F7F7F7F)) ^ (27 * ((v158 & 0x80808080) >> 7));
    v154 = (2 * (v157 & 0x7F7F7F7F)) ^ (27 * ((v157 & 0x80808080) >> 7));
    LODWORD(dest[4]) = v156 ^ LODWORD(dest[6]) ^ LODWORD(dest[5]) ^ LODWORD(dest[7]);
    LODWORD(dest[5]) = v155 ^ v163 ^ LODWORD(dest[7]) ^ LODWORD(dest[6]);
    LODWORD(dest[6]) = v154 ^ v159 ^ LODWORD(dest[7]);
    LODWORD(dest[7]) = v156 ^ v155 ^ v154 ^ v159 ^ v161;
    v153 = DWORD1(dest[4]);
    v152 = DWORD1(dest[5]);
    v151 = DWORD1(dest[6]);
    v150 = DWORD1(dest[7]);
    v149 = DWORD1(dest[5]) ^ DWORD1(dest[4]);
    v148 = DWORD1(dest[6]) ^ DWORD1(dest[5]);
    v147 = DWORD1(dest[7]) ^ DWORD1(dest[6]);
    v146 = (2 * (v149 & 0x7F7F7F7F)) ^ (27 * ((v149 & 0x80808080) >> 7));
    v145 = (2 * (v148 & 0x7F7F7F7F)) ^ (27 * ((v148 & 0x80808080) >> 7));
    v144 = (2 * (v147 & 0x7F7F7F7F)) ^ (27 * ((v147 & 0x80808080) >> 7));
    DWORD1(dest[4]) = v146 ^ DWORD1(dest[6]) ^ DWORD1(dest[5]) ^ DWORD1(dest[7]);
    DWORD1(dest[5]) = v145 ^ v153 ^ DWORD1(dest[7]) ^ DWORD1(dest[6]);
    DWORD1(dest[6]) = v144 ^ v149 ^ DWORD1(dest[7]);
    DWORD1(dest[7]) = v146 ^ v145 ^ v144 ^ v149 ^ v151;
    v143 = DWORD2(dest[4]);
    v142 = DWORD2(dest[5]);
    v141 = DWORD2(dest[6]);
    v140 = DWORD2(dest[7]);
    v139 = DWORD2(dest[5]) ^ DWORD2(dest[4]);
    v138 = DWORD2(dest[6]) ^ DWORD2(dest[5]);
    v137 = DWORD2(dest[7]) ^ DWORD2(dest[6]);
    v136 = (2 * (v139 & 0x7F7F7F7F)) ^ (27 * ((v139 & 0x80808080) >> 7));
    v135 = (2 * (v138 & 0x7F7F7F7F)) ^ (27 * ((v138 & 0x80808080) >> 7));
    v134 = (2 * (v137 & 0x7F7F7F7F)) ^ (27 * ((v137 & 0x80808080) >> 7));
    DWORD2(dest[4]) = v136 ^ DWORD2(dest[6]) ^ DWORD2(dest[5]) ^ DWORD2(dest[7]);
    DWORD2(dest[5]) = v135 ^ v143 ^ DWORD2(dest[7]) ^ DWORD2(dest[6]);
    DWORD2(dest[6]) = v134 ^ v139 ^ DWORD2(dest[7]);
    DWORD2(dest[7]) = v136 ^ v135 ^ v134 ^ v139 ^ v141;
    v133 = HIDWORD(dest[4]);
    v132 = v17;
    v131 = v37;
    v130 = HIDWORD(dest[7]);
    v129 = v17 ^ HIDWORD(dest[4]);
    v128 = v37 ^ v17;
    v127 = HIDWORD(dest[7]) ^ v37;
    v126 = (2 * (v129 & 0x7F7F7F7F)) ^ (27 * ((v129 & 0x80808080) >> 7));
    v125 = (2 * (v128 & 0x7F7F7F7F)) ^ (27 * ((v128 & 0x80808080) >> 7));
    v124 = (2 * (v127 & 0x7F7F7F7F)) ^ (27 * ((v127 & 0x80808080) >> 7));
    HIDWORD(dest[4]) = v126 ^ v37 ^ v17 ^ HIDWORD(dest[7]);
    HIDWORD(dest[5]) = v125 ^ v133 ^ HIDWORD(dest[7]) ^ v37;
    HIDWORD(dest[6]) = v124 ^ v129 ^ HIDWORD(dest[7]);
    HIDWORD(dest[7]) = v126 ^ v125 ^ v124 ^ v129 ^ v37;
    v123 = v10;
    v122 = v14;
    v121 = v18;
    v120 = v22;
    v119 = v14 ^ v10;
    v118 = v18 ^ v14;
    v117 = v22 ^ v18;
    v116 = (2 * (v119 & 0x7F7F7F7F)) ^ (27 * ((v119 & 0x80808080) >> 7));
    v115 = (2 * (v118 & 0x7F7F7F7F)) ^ (27 * ((v118 & 0x80808080) >> 7));
    v114 = (2 * (v117 & 0x7F7F7F7F)) ^ (27 * ((v117 & 0x80808080) >> 7));
    v10 = v116 ^ v18 ^ v14 ^ v22;
    v14 = v115 ^ v123 ^ v22 ^ v18;
    v18 = v114 ^ v119 ^ v22;
    v22 = v116 ^ v115 ^ v114 ^ v119 ^ v121;
    v113 = v11;
    v112 = v15;
    v111 = v19;
    v110 = v23;
    v109 = v15 ^ v11;
    v108 = v19 ^ v15;
    v107 = v23 ^ v19;
    v106 = (2 * (v109 & 0x7F7F7F7F)) ^ (27 * ((v109 & 0x80808080) >> 7));
    v105 = (2 * (v108 & 0x7F7F7F7F)) ^ (27 * ((v108 & 0x80808080) >> 7));
    v104 = (2 * (v107 & 0x7F7F7F7F)) ^ (27 * ((v107 & 0x80808080) >> 7));
    v11 = v106 ^ v19 ^ v15 ^ v23;
    v15 = v105 ^ v113 ^ v23 ^ v19;
    v19 = v104 ^ v109 ^ v23;
    v23 = v106 ^ v105 ^ v104 ^ v109 ^ v111;
    v103 = v12;
    v102 = v16;
    v101 = v20;
    v100 = v24;
    v99 = v16 ^ v12;
    v98 = v20 ^ v16;
    v97 = v24 ^ v20;
    v96 = (2 * (v99 & 0x7F7F7F7F)) ^ (27 * ((v99 & 0x80808080) >> 7));
    v95 = (2 * (v98 & 0x7F7F7F7F)) ^ (27 * ((v98 & 0x80808080) >> 7));
    v94 = (2 * (v97 & 0x7F7F7F7F)) ^ (27 * ((v97 & 0x80808080) >> 7));
    v12 = v96 ^ v20 ^ v16 ^ v24;
    v16 = v95 ^ v103 ^ v24 ^ v20;
    v20 = v94 ^ v99 ^ v24;
    v24 = v96 ^ v95 ^ v94 ^ v99 ^ v101;
    v93 = v13;
    v92 = v33;
    v91 = v21;
    v90 = v25;
    v89 = v33 ^ v13;
    v88 = v21 ^ v33;
    v87 = v25 ^ v21;
    v86 = (2 * (v89 & 0x7F7F7F7F)) ^ (27 * ((v89 & 0x80808080) >> 7));
    v85 = (2 * (v88 & 0x7F7F7F7F)) ^ (27 * ((v88 & 0x80808080) >> 7));
    v84 = (2 * (v87 & 0x7F7F7F7F)) ^ (27 * ((v87 & 0x80808080) >> 7));
    v13 = v86 ^ v21 ^ v33 ^ v25;
    v17 = v85 ^ v93 ^ v25 ^ v21;
    v21 = v84 ^ v89 ^ v25;
    v25 = v86 ^ v85 ^ v84 ^ v89 ^ v91;
    v83 = v26;
    v82 = v30;
    v81 = v34;
    v80 = v38;
    v79 = v30 ^ v26;
    v78 = v34 ^ v30;
    v77 = v38 ^ v34;
    v76 = (2 * (v79 & 0x7F7F7F7F)) ^ (27 * ((v79 & 0x80808080) >> 7));
    v75 = (2 * (v78 & 0x7F7F7F7F)) ^ (27 * ((v78 & 0x80808080) >> 7));
    v74 = (2 * (v77 & 0x7F7F7F7F)) ^ (27 * ((v77 & 0x80808080) >> 7));
    v26 = v76 ^ v34 ^ v30 ^ v38;
    v30 = v75 ^ v83 ^ v38 ^ v34;
    v34 = v74 ^ v79 ^ v38;
    v38 = v76 ^ v75 ^ v74 ^ v79 ^ v81;
    v73 = v27;
    v72 = v31;
    v71 = v35;
    v70 = v39;
    v69 = v31 ^ v27;
    v68 = v35 ^ v31;
    v67 = v39 ^ v35;
    v66 = (2 * (v69 & 0x7F7F7F7F)) ^ (27 * ((v69 & 0x80808080) >> 7));
    v65 = (2 * (v68 & 0x7F7F7F7F)) ^ (27 * ((v68 & 0x80808080) >> 7));
    v64 = (2 * (v67 & 0x7F7F7F7F)) ^ (27 * ((v67 & 0x80808080) >> 7));
    v27 = v66 ^ v35 ^ v31 ^ v39;
    v31 = v65 ^ v73 ^ v39 ^ v35;
    v35 = v64 ^ v69 ^ v39;
    v39 = v66 ^ v65 ^ v64 ^ v69 ^ v71;
    v63 = v28;
    v62 = v32;
    v61 = v36;
    v60 = v40;
    v59 = v32 ^ v28;
    v58 = v36 ^ v32;
    v57 = v40 ^ v36;
    v56 = (2 * (v59 & 0x7F7F7F7F)) ^ (27 * ((v59 & 0x80808080) >> 7));
    v55 = (2 * (v58 & 0x7F7F7F7F)) ^ (27 * ((v58 & 0x80808080) >> 7));
    v54 = (2 * (v57 & 0x7F7F7F7F)) ^ (27 * ((v57 & 0x80808080) >> 7));
    v28 = v56 ^ v36 ^ v32 ^ v40;
    v32 = v55 ^ v63 ^ v40 ^ v36;
    v36 = v54 ^ v59 ^ v40;
    v40 = v56 ^ v55 ^ v54 ^ v59 ^ v61;
    v53 = v29;
    v52 = v206;
    v51 = v205;
    v50 = v41;
    v49 = v206 ^ v29;
    v48 = v205 ^ v206;
    v47 = v41 ^ v205;
    v46 = (2 * (v49 & 0x7F7F7F7F)) ^ (27 * ((v49 & 0x80808080) >> 7));
    v45 = (2 * (v48 & 0x7F7F7F7F)) ^ (27 * ((v48 & 0x80808080) >> 7));
    v44 = (2 * ((v41 ^ v205) & 0x7F7F7F7F)) ^ (27 * (((v41 ^ v205) & 0x80808080) >> 7));
    v29 = v46 ^ v205 ^ v206 ^ v41;
    v33 = v45 ^ v53 ^ v41 ^ v205;
    v37 = v44 ^ v49 ^ v41;
    v41 = v46 ^ v45 ^ v44 ^ v49 ^ v205;
  }
  v43 = a1 + 34;
  v42 = dest;
  for ( k = 0; k <= 0x1F; ++k )
  {
    v6 = sub_1673D0((int)&a1[k]);
    v7 = v6 ^ *((_DWORD *)v42 + k) ^ *((_DWORD *)v42 + k + 32);
    result = v43;
    v43[k] ^= v7;
  }
  return result;
}
// 1D5D68: using guessed type _DWORD dword_1D5D68[256];
// 1D6168: using guessed type _DWORD dword_1D6168[256];
// 1D6568: using guessed type _DWORD dword_1D6568[256];
// 1D6968: using guessed type _DWORD dword_1D6968[256];

//----- (00171878) --------------------------------------------------------
_DWORD *__fastcall sub_171878(_DWORD *result, char *a2, size_t a3)
{
  size_t n; // [sp+4h] [bp+4h]
  char *src; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  _DWORD *v6; // [sp+14h] [bp+14h]
  size_t v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]

  v5 = result;
  src = a2;
  n = a3;
  v6 = result;
  v8 = result[48];
  if ( 192 - v8 <= a3 )
  {
    while ( n )
    {
      v7 = 192 - v8;
      if ( 192 - v8 > n )
        v7 = n;
      result = memcpy((char *)v6 + v8, src, v7);
      v8 += v7;
      src += v7;
      n -= v7;
      if ( v8 == 192 )
      {
        v5[66] += 1536;
        if ( v5[66] < 0x600u && !++v5[67] && !++v5[68] )
          ++v5[69];
        result = sub_167660(v5);
        v8 = 0;
      }
    }
    v5[48] = v8;
  }
  else
  {
    result = memcpy((char *)result + v8, a2, a3);
    v5[48] = n + v8;
  }
  return result;
}

//----- (00171978) --------------------------------------------------------
_DWORD *__fastcall sub_171978(_DWORD *result, char *a2, size_t a3)
{
  size_t n; // [sp+4h] [bp+4h]
  char *src; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  _DWORD *v6; // [sp+14h] [bp+14h]
  size_t v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]

  v5 = result;
  src = a2;
  n = a3;
  v6 = result;
  v8 = result[32];
  if ( 128 - v8 <= a3 )
  {
    while ( n )
    {
      v7 = 128 - v8;
      if ( 128 - v8 > n )
        v7 = n;
      result = memcpy((char *)v6 + v8, src, v7);
      v8 += v7;
      src += v7;
      n -= v7;
      if ( v8 == 128 )
      {
        v5[66] += 1024;
        if ( v5[66] < 0x400u && !++v5[67] && !++v5[68] )
          ++v5[69];
        result = sub_16C794(v5);
        v8 = 0;
      }
    }
    v5[32] = v8;
  }
  else
  {
    result = memcpy((char *)result + v8, a2, a3);
    v5[32] = n + v8;
  }
  return result;
}

//----- (00171A78) --------------------------------------------------------
_DWORD *__fastcall sub_171A78(_DWORD *a1, char a2, int a3, void *a4, unsigned int a5)
{
  unsigned int v5; // r3
  char v8; // [sp+4h] [bp+4h]
  _DWORD src[8]; // [sp+10h] [bp+10h] BYREF
  _DWORD *v12; // [sp+30h] [bp+30h]
  int v13; // [sp+34h] [bp+34h]
  unsigned int v14; // [sp+38h] [bp+38h]
  unsigned int v15; // [sp+3Ch] [bp+3Ch]
  void *s; // [sp+40h] [bp+40h]
  unsigned int i; // [sp+44h] [bp+44h]

  v8 = a3;
  s = a1;
  v15 = a1[48];
  v14 = a3 + 8 * v15;
  a1[66] += v14;
  if ( a1[66] < v14 && !++a1[67] && !++a1[68] )
    ++a1[69];
  sub_1673B4(src, a1[66]);
  sub_1673B4(&src[1], a1[67]);
  sub_1673B4(&src[2], a1[68]);
  sub_1673B4(&src[3], a1[69]);
  if ( !v14 )
  {
    a1[69] = 0;
    a1[68] = a1[69];
    a1[67] = a1[68];
    a1[66] = a1[67];
  }
  v13 = 128 >> v8;
  v5 = v15++;
  *((_BYTE *)s + v5) = (128 >> v8) | a2 & -(128 >> v8);
  memset((char *)s + v15, 0, 192 - v15);
  if ( v15 > 0xAE )
  {
    sub_167660(a1);
    a1[69] = 0;
    a1[68] = a1[69];
    a1[67] = a1[68];
    a1[66] = a1[67];
    memset(s, 0, 0xC0u);
  }
  sub_167388((_WORD *)s + 87, 32 * a5);
  memcpy((char *)s + 176, src, 0x10u);
  sub_167660(a1);
  v12 = a1 + 50;
  for ( i = 0; i < a5; ++i )
    sub_1673B4(&src[i], v12[i]);
  memcpy(a4, src, 4 * a5);
  return sub_1673E8(a1, 32 * a5);
}

//----- (00171C7C) --------------------------------------------------------
_DWORD *__fastcall sub_171C7C(_DWORD *a1, char a2, int a3, void *a4, unsigned int a5)
{
  unsigned int v5; // r3
  char v8; // [sp+4h] [bp+4h]
  _DWORD src[16]; // [sp+10h] [bp+10h] BYREF
  _DWORD *v12; // [sp+50h] [bp+50h]
  int v13; // [sp+54h] [bp+54h]
  unsigned int v14; // [sp+58h] [bp+58h]
  unsigned int v15; // [sp+5Ch] [bp+5Ch]
  void *s; // [sp+60h] [bp+60h]
  unsigned int i; // [sp+64h] [bp+64h]

  v8 = a3;
  s = a1;
  v15 = a1[32];
  v14 = a3 + 8 * v15;
  a1[66] += v14;
  if ( a1[66] < v14 && !++a1[67] && !++a1[68] )
    ++a1[69];
  sub_1673B4(src, a1[66]);
  sub_1673B4(&src[1], a1[67]);
  sub_1673B4(&src[2], a1[68]);
  sub_1673B4(&src[3], a1[69]);
  if ( !v14 )
  {
    a1[69] = 0;
    a1[68] = a1[69];
    a1[67] = a1[68];
    a1[66] = a1[67];
  }
  v13 = 128 >> v8;
  v5 = v15++;
  *((_BYTE *)s + v5) = (128 >> v8) | a2 & -(128 >> v8);
  memset((char *)s + v15, 0, 128 - v15);
  if ( v15 > 0x6E )
  {
    sub_16C794(a1);
    a1[69] = 0;
    a1[68] = a1[69];
    a1[67] = a1[68];
    a1[66] = a1[67];
    memset(s, 0, 0x80u);
  }
  sub_167388((_WORD *)s + 55, 32 * a5);
  memcpy((char *)s + 112, src, 0x10u);
  sub_16C794(a1);
  v12 = a1 + 34;
  for ( i = 0; i < a5; ++i )
    sub_1673B4(&src[i], v12[i]);
  memcpy(a4, src, 4 * a5);
  return sub_1674D4(a1, 32 * a5);
}

//----- (00171E80) --------------------------------------------------------
_DWORD *__fastcall sph_echo224_init(_DWORD *a1)
{
  return sub_1673E8(a1, 224);
}

//----- (00171E98) --------------------------------------------------------
_DWORD *__fastcall sph_echo224(_DWORD *a1, char *a2, size_t a3)
{
  return sub_171878(a1, a2, a3);
}

//----- (00171EB8) --------------------------------------------------------
_DWORD *__fastcall sph_echo224_close(_DWORD *a1, void *a2)
{
  return sub_171A78(a1, 0, 0, a2, 7u);
}

//----- (00171EDC) --------------------------------------------------------
_DWORD *__fastcall sph_echo224_addbits_and_close(_DWORD *a1, char a2, int a3, void *a4)
{
  return sub_171A78(a1, a2, a3, a4, 7u);
}

//----- (00171F04) --------------------------------------------------------
_DWORD *__fastcall sph_echo256_init(_DWORD *a1)
{
  return sub_1673E8(a1, 256);
}

//----- (00171F20) --------------------------------------------------------
_DWORD *__fastcall sph_echo256(_DWORD *a1, char *a2, size_t a3)
{
  return sub_171878(a1, a2, a3);
}

//----- (00171F40) --------------------------------------------------------
_DWORD *__fastcall sph_echo256_close(_DWORD *a1, void *a2)
{
  return sub_171A78(a1, 0, 0, a2, 8u);
}

//----- (00171F64) --------------------------------------------------------
_DWORD *__fastcall sph_echo256_addbits_and_close(_DWORD *a1, char a2, int a3, void *a4)
{
  return sub_171A78(a1, a2, a3, a4, 8u);
}

//----- (00171F8C) --------------------------------------------------------
_DWORD *__fastcall sph_echo384_init(_DWORD *a1)
{
  return sub_1674D4(a1, 384);
}

//----- (00171FA8) --------------------------------------------------------
_DWORD *__fastcall sph_echo384(_DWORD *a1, char *a2, size_t a3)
{
  return sub_171978(a1, a2, a3);
}

//----- (00171FC8) --------------------------------------------------------
_DWORD *__fastcall sph_echo384_close(_DWORD *a1, void *a2)
{
  return sub_171C7C(a1, 0, 0, a2, 0xCu);
}

//----- (00171FEC) --------------------------------------------------------
_DWORD *__fastcall sph_echo384_addbits_and_close(_DWORD *a1, char a2, int a3, void *a4)
{
  return sub_171C7C(a1, a2, a3, a4, 0xCu);
}

//----- (00172014) --------------------------------------------------------
_DWORD *__fastcall sph_echo512_init(_DWORD *a1)
{
  return sub_1674D4(a1, 512);
}

//----- (00172030) --------------------------------------------------------
_DWORD *__fastcall sph_echo512(_DWORD *a1, char *a2, size_t a3)
{
  return sub_171978(a1, a2, a3);
}

//----- (00172050) --------------------------------------------------------
_DWORD *__fastcall sph_echo512_close(_DWORD *a1, void *a2)
{
  return sub_171C7C(a1, 0, 0, a2, 0x10u);
}

//----- (00172074) --------------------------------------------------------
_DWORD *__fastcall sph_echo512_addbits_and_close(_DWORD *a1, char a2, int a3, void *a4)
{
  return sub_171C7C(a1, a2, a3, a4, 0x10u);
}

//----- (0017209C) --------------------------------------------------------
_BYTE *__fastcall sub_17209C(_BYTE *result, int a2, int a3, int a4)
{
  *result = HIBYTE(a4);
  result[1] = BYTE2(a4);
  result[2] = BYTE1(a4);
  result[3] = a4;
  result[4] = HIBYTE(a3);
  result[5] = BYTE2(a3);
  result[6] = BYTE1(a3);
  result[7] = a3;
  return result;
}

//----- (00172158) --------------------------------------------------------
int __fastcall sub_172158(int result, int a2, unsigned int a3, int a4)
{
  *(_BYTE *)result = a3;
  *(_WORD *)(result + 1) = a3 >> 8;
  *(_BYTE *)(result + 3) = HIBYTE(a3);
  *(_DWORD *)(result + 4) = a4;
  return result;
}

//----- (00172214) --------------------------------------------------------
__int64 __fastcall sub_172214(int a1)
{
  return *(_QWORD *)a1;
}

//----- (00172230) --------------------------------------------------------
_DWORD *__fastcall sub_172230(_DWORD *result, int a2)
{
  _DWORD *v2; // [sp+4h] [bp+4h]
  unsigned int i; // [sp+Ch] [bp+Ch]

  v2 = result;
  result[16] = 0;
  for ( i = 0; i <= 6; ++i )
  {
    result = &v2[2 * i + 18];
    *result = 0;
    result[1] = 0;
  }
  v2[32] = 0;
  v2[33] = ((a2 & 0xFF00) << 8) | (a2 << 24);
  v2[34] = 0;
  v2[35] = 0;
  return result;
}

//----- (001722BC) --------------------------------------------------------
void *__fastcall sub_1722BC(int a1, char *a2, size_t a3)
{
  void *result; // r0
  __int64 v4; // r0
  __int16 v5; // r2
  size_t v6; // [sp+774h] [bp+774h]
  char *v7; // [sp+778h] [bp+778h]
  __int64 v9; // [sp+780h] [bp+780h] BYREF
  __int64 v10; // [sp+788h] [bp+788h]
  __int64 v11; // [sp+790h] [bp+790h]
  __int64 v12; // [sp+798h] [bp+798h]
  __int64 v13; // [sp+7A0h] [bp+7A0h]
  __int64 v14; // [sp+7A8h] [bp+7A8h]
  __int64 v15; // [sp+7B0h] [bp+7B0h]
  __int64 v16; // [sp+7B8h] [bp+7B8h]
  __int64 v17; // [sp+7C0h] [bp+7C0h]
  __int64 v18; // [sp+7C8h] [bp+7C8h]
  __int64 v19; // [sp+7D0h] [bp+7D0h]
  __int64 v20; // [sp+7D8h] [bp+7D8h]
  __int64 v21; // [sp+7E0h] [bp+7E0h]
  __int64 v22; // [sp+7E8h] [bp+7E8h]
  __int64 v23; // [sp+7F0h] [bp+7F0h]
  __int64 v24; // [sp+7F8h] [bp+7F8h]
  __int64 v25; // [sp+800h] [bp+800h]
  __int64 v26; // [sp+808h] [bp+808h]
  __int64 v27; // [sp+810h] [bp+810h]
  __int64 v28; // [sp+818h] [bp+818h]
  __int64 v29; // [sp+820h] [bp+820h]
  __int64 v30; // [sp+828h] [bp+828h]
  __int64 v31; // [sp+830h] [bp+830h]
  __int64 v32; // [sp+838h] [bp+838h]
  _BYTE dest[64]; // [sp+840h] [bp+840h] BYREF
  int v34; // [sp+880h] [bp+880h]
  int k; // [sp+884h] [bp+884h]
  int j; // [sp+888h] [bp+888h]
  unsigned int i; // [sp+88Ch] [bp+88Ch]
  size_t n; // [sp+890h] [bp+890h]
  int v39; // [sp+894h] [bp+894h]
  _BYTE v40[4]; // [sp+898h] [bp+898h] BYREF

  v7 = a2;
  v6 = a3;
  v34 = a1;
  v39 = *(_DWORD *)(a1 + 64);
  if ( 64 - v39 <= a3 )
  {
    memcpy(dest, (const void *)(a1 + 72), sizeof(dest));
    while ( v6 )
    {
      n = 64 - v39;
      if ( 64 - v39 > v6 )
        n = v6;
      memcpy((void *)(v34 + v39), v7, n);
      v39 += n;
      v7 += n;
      v6 -= n;
      if ( v39 == 64 )
      {
        for ( i = 0; i <= 7; ++i )
        {
          v4 = sub_172214(v34 + 8 * i);
          *(_QWORD *)&v40[8 * i - 216] = v4;
          *(&v9 + i) = *(_QWORD *)&v40[8 * i - 216] ^ *(_QWORD *)&v40[8 * i - 88];
        }
        for ( j = 0; j <= 9; j += 2 )
        {
          v9 ^= j;
          v10 ^= j + 16;
          v11 ^= j + 32;
          v12 ^= j + 48;
          v13 ^= j + 64;
          v14 ^= j + 80;
          v15 ^= j + 96;
          v16 ^= j + 112;
          v25 = qword_1DA568[HIBYTE(HIDWORD(v16))]
              ^ qword_1D6D68[(unsigned __int8)v9]
              ^ qword_1D7568[BYTE1(v10)]
              ^ qword_1D7D68[BYTE2(v11)]
              ^ qword_1D8568[BYTE3(v12)]
              ^ qword_1D8D68[BYTE4(v13)]
              ^ qword_1D9568[BYTE5(v14)]
              ^ qword_1D9D68[BYTE6(v15)];
          v26 = qword_1DA568[HIBYTE(HIDWORD(v9))]
              ^ qword_1D6D68[(unsigned __int8)v10]
              ^ qword_1D7568[BYTE1(v11)]
              ^ qword_1D7D68[BYTE2(v12)]
              ^ qword_1D8568[BYTE3(v13)]
              ^ qword_1D8D68[BYTE4(v14)]
              ^ qword_1D9568[BYTE5(v15)]
              ^ qword_1D9D68[BYTE6(v16)];
          v27 = qword_1DA568[HIBYTE(HIDWORD(v10))]
              ^ qword_1D6D68[(unsigned __int8)v11]
              ^ qword_1D7568[BYTE1(v12)]
              ^ qword_1D7D68[BYTE2(v13)]
              ^ qword_1D8568[BYTE3(v14)]
              ^ qword_1D8D68[BYTE4(v15)]
              ^ qword_1D9568[BYTE5(v16)]
              ^ qword_1D9D68[BYTE6(v9)];
          v28 = qword_1DA568[HIBYTE(HIDWORD(v11))]
              ^ qword_1D6D68[(unsigned __int8)v12]
              ^ qword_1D7568[BYTE1(v13)]
              ^ qword_1D7D68[BYTE2(v14)]
              ^ qword_1D8568[BYTE3(v15)]
              ^ qword_1D8D68[BYTE4(v16)]
              ^ qword_1D9568[BYTE5(v9)]
              ^ qword_1D9D68[BYTE6(v10)];
          v29 = qword_1DA568[HIBYTE(HIDWORD(v12))]
              ^ qword_1D6D68[(unsigned __int8)v13]
              ^ qword_1D7568[BYTE1(v14)]
              ^ qword_1D7D68[BYTE2(v15)]
              ^ qword_1D8568[BYTE3(v16)]
              ^ qword_1D8D68[BYTE4(v9)]
              ^ qword_1D9568[BYTE5(v10)]
              ^ qword_1D9D68[BYTE6(v11)];
          v30 = qword_1DA568[HIBYTE(HIDWORD(v13))]
              ^ qword_1D6D68[(unsigned __int8)v14]
              ^ qword_1D7568[BYTE1(v15)]
              ^ qword_1D7D68[BYTE2(v16)]
              ^ qword_1D8568[BYTE3(v9)]
              ^ qword_1D8D68[BYTE4(v10)]
              ^ qword_1D9568[BYTE5(v11)]
              ^ qword_1D9D68[BYTE6(v12)];
          v31 = qword_1DA568[HIBYTE(HIDWORD(v14))]
              ^ qword_1D6D68[(unsigned __int8)v15]
              ^ qword_1D7568[BYTE1(v16)]
              ^ qword_1D7D68[BYTE2(v9)]
              ^ qword_1D8568[BYTE3(v10)]
              ^ qword_1D8D68[BYTE4(v11)]
              ^ qword_1D9568[BYTE5(v12)]
              ^ qword_1D9D68[BYTE6(v13)];
          v32 = qword_1DA568[HIBYTE(HIDWORD(v15))]
              ^ qword_1D6D68[(unsigned __int8)v16]
              ^ qword_1D7568[BYTE1(v9)]
              ^ qword_1D7D68[BYTE2(v10)]
              ^ qword_1D8568[BYTE3(v11)]
              ^ qword_1D8D68[BYTE4(v12)]
              ^ qword_1D9568[BYTE5(v13)]
              ^ qword_1D9D68[BYTE6(v14)];
          v9 = v25 ^ (j + 1);
          v10 = v26 ^ (j + 17);
          v11 = v27 ^ (j + 33);
          v12 = v28 ^ (j + 49);
          v13 = v29 ^ (j + 65);
          v14 = v30 ^ (j + 81);
          v15 = v31 ^ (j + 97);
          v16 = v32 ^ (j + 113);
          v25 = qword_1DA568[HIBYTE(HIDWORD(v16))]
              ^ qword_1D6D68[(unsigned __int8)v9]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v26 ^ (j + 17)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v27 ^ (j + 33)) >> 16)]
              ^ qword_1D8568[((unsigned int)v28 ^ (j + 49)) >> 24]
              ^ qword_1D8D68[BYTE4(v13)]
              ^ qword_1D9568[BYTE5(v14)]
              ^ qword_1D9D68[BYTE6(v15)];
          v26 = qword_1DA568[HIBYTE(HIDWORD(v9))]
              ^ qword_1D6D68[(unsigned __int8)v10]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v27 ^ (j + 33)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v28 ^ (j + 49)) >> 16)]
              ^ qword_1D8568[((unsigned int)v29 ^ (j + 65)) >> 24]
              ^ qword_1D8D68[BYTE4(v14)]
              ^ qword_1D9568[BYTE5(v15)]
              ^ qword_1D9D68[BYTE6(v16)];
          v27 = qword_1DA568[HIBYTE(HIDWORD(v10))]
              ^ qword_1D6D68[(unsigned __int8)v11]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v28 ^ (j + 49)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v29 ^ (j + 65)) >> 16)]
              ^ qword_1D8568[((unsigned int)v30 ^ (j + 81)) >> 24]
              ^ qword_1D8D68[BYTE4(v15)]
              ^ qword_1D9568[BYTE5(v16)]
              ^ qword_1D9D68[BYTE6(v9)];
          v28 = qword_1DA568[HIBYTE(HIDWORD(v11))]
              ^ qword_1D6D68[(unsigned __int8)v12]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v29 ^ (j + 65)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v30 ^ (j + 81)) >> 16)]
              ^ qword_1D8568[((unsigned int)v31 ^ (j + 97)) >> 24]
              ^ qword_1D8D68[BYTE4(v16)]
              ^ qword_1D9568[BYTE5(v9)]
              ^ qword_1D9D68[BYTE6(v10)];
          v29 = qword_1DA568[HIBYTE(HIDWORD(v12))]
              ^ qword_1D6D68[(unsigned __int8)v13]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v30 ^ (j + 81)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v31 ^ (j + 97)) >> 16)]
              ^ qword_1D8568[((unsigned int)v32 ^ (j + 113)) >> 24]
              ^ qword_1D8D68[BYTE4(v9)]
              ^ qword_1D9568[BYTE5(v10)]
              ^ qword_1D9D68[BYTE6(v11)];
          v30 = qword_1DA568[HIBYTE(HIDWORD(v13))]
              ^ qword_1D6D68[(unsigned __int8)v14]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v31 ^ (j + 97)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v32 ^ (j + 113)) >> 16)]
              ^ qword_1D8568[BYTE3(v9)]
              ^ qword_1D8D68[BYTE4(v10)]
              ^ qword_1D9568[BYTE5(v11)]
              ^ qword_1D9D68[BYTE6(v12)];
          v31 = qword_1DA568[HIBYTE(HIDWORD(v14))]
              ^ qword_1D6D68[(unsigned __int8)v15]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v32 ^ (j + 113)) >> 8)]
              ^ qword_1D7D68[BYTE2(v9)]
              ^ qword_1D8568[BYTE3(v10)]
              ^ qword_1D8D68[BYTE4(v11)]
              ^ qword_1D9568[BYTE5(v12)]
              ^ qword_1D9D68[BYTE6(v13)];
          v32 = qword_1DA568[HIBYTE(HIDWORD(v15))]
              ^ qword_1D6D68[(unsigned __int8)v16]
              ^ qword_1D7568[BYTE1(v9)]
              ^ qword_1D7D68[BYTE2(v10)]
              ^ qword_1D8568[BYTE3(v11)]
              ^ qword_1D8D68[BYTE4(v12)]
              ^ qword_1D9568[BYTE5(v13)]
              ^ qword_1D9D68[BYTE6(v14)];
          v9 = v25;
          v10 = v26;
          v11 = v27;
          v12 = v28;
          v13 = v29;
          v14 = v30;
          v15 = v31;
          v16 = v32;
        }
        for ( k = 0; k <= 9; k += 2 )
        {
          LODWORD(v17) = ~(_DWORD)v17;
          HIDWORD(v17) ^= ~(k << 24);
          LODWORD(v18) = ~(_DWORD)v18;
          HIDWORD(v18) ^= (k << 24) ^ 0xEFFFFFFF;
          LODWORD(v19) = ~(_DWORD)v19;
          HIDWORD(v19) ^= (k << 24) ^ 0xDFFFFFFF;
          LODWORD(v20) = ~(_DWORD)v20;
          HIDWORD(v20) ^= (k << 24) ^ 0xCFFFFFFF;
          LODWORD(v21) = ~(_DWORD)v21;
          HIDWORD(v21) ^= (k << 24) ^ 0xBFFFFFFF;
          LODWORD(v22) = ~(_DWORD)v22;
          HIDWORD(v22) ^= (k << 24) ^ 0xAFFFFFFF;
          LODWORD(v23) = ~(_DWORD)v23;
          HIDWORD(v23) ^= (k << 24) ^ 0x9FFFFFFF;
          v5 = WORD2(v24);
          LODWORD(v24) = ~(_DWORD)v24;
          HIDWORD(v24) ^= (k << 24) ^ 0x8FFFFFFF;
          v25 = qword_1DA568[HIBYTE(HIDWORD(v23))]
              ^ qword_1D6D68[(unsigned __int8)v18]
              ^ qword_1D7568[BYTE1(v20)]
              ^ qword_1D7D68[BYTE2(v22)]
              ^ qword_1D8568[BYTE3(v24)]
              ^ qword_1D8D68[BYTE4(v17)]
              ^ qword_1D9568[BYTE5(v19)]
              ^ qword_1D9D68[BYTE6(v21)];
          v26 = qword_1DA568[HIBYTE(HIDWORD(v24))]
              ^ qword_1D6D68[(unsigned __int8)v19]
              ^ qword_1D7568[BYTE1(v21)]
              ^ qword_1D7D68[BYTE2(v23)]
              ^ qword_1D8568[BYTE3(v17)]
              ^ qword_1D8D68[BYTE4(v18)]
              ^ qword_1D9568[BYTE5(v20)]
              ^ qword_1D9D68[BYTE6(v22)];
          v27 = qword_1DA568[HIBYTE(HIDWORD(v17))]
              ^ qword_1D6D68[(unsigned __int8)v20]
              ^ qword_1D7568[BYTE1(v22)]
              ^ qword_1D7D68[BYTE2(v24)]
              ^ qword_1D8568[BYTE3(v18)]
              ^ qword_1D8D68[BYTE4(v19)]
              ^ qword_1D9568[BYTE5(v21)]
              ^ qword_1D9D68[BYTE6(v23)];
          v28 = qword_1DA568[HIBYTE(HIDWORD(v18))]
              ^ qword_1D6D68[(unsigned __int8)v21]
              ^ qword_1D7568[BYTE1(v23)]
              ^ qword_1D7D68[BYTE2(v17)]
              ^ qword_1D8568[BYTE3(v19)]
              ^ qword_1D8D68[BYTE4(v20)]
              ^ qword_1D9568[BYTE5(v22)]
              ^ qword_1D9D68[BYTE6(v24)];
          v29 = qword_1DA568[HIBYTE(HIDWORD(v19))]
              ^ qword_1D6D68[(unsigned __int8)v22]
              ^ qword_1D7568[BYTE1(v24)]
              ^ qword_1D7D68[BYTE2(v18)]
              ^ qword_1D8568[BYTE3(v20)]
              ^ qword_1D8D68[BYTE4(v21)]
              ^ qword_1D9568[BYTE5(v23)]
              ^ qword_1D9D68[BYTE6(v17)];
          v30 = qword_1DA568[HIBYTE(HIDWORD(v20))]
              ^ qword_1D6D68[(unsigned __int8)v23]
              ^ qword_1D7568[BYTE1(v17)]
              ^ qword_1D7D68[BYTE2(v19)]
              ^ qword_1D8568[BYTE3(v21)]
              ^ qword_1D8D68[BYTE4(v22)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~v5 >> 8)]
              ^ qword_1D9D68[BYTE6(v18)];
          v31 = qword_1DA568[HIBYTE(HIDWORD(v21))]
              ^ qword_1D6D68[(unsigned __int8)v24]
              ^ qword_1D7568[BYTE1(v18)]
              ^ qword_1D7D68[BYTE2(v20)]
              ^ qword_1D8568[BYTE3(v22)]
              ^ qword_1D8D68[BYTE4(v23)]
              ^ qword_1D9568[BYTE5(v17)]
              ^ qword_1D9D68[BYTE6(v19)];
          v32 = qword_1DA568[HIBYTE(HIDWORD(v22))]
              ^ qword_1D6D68[(unsigned __int8)v17]
              ^ qword_1D7568[BYTE1(v19)]
              ^ qword_1D7D68[BYTE2(v21)]
              ^ qword_1D8568[BYTE3(v23)]
              ^ qword_1D8D68[(unsigned __int8)~(_BYTE)v5]
              ^ qword_1D9568[BYTE5(v18)]
              ^ qword_1D9D68[BYTE6(v20)];
          LODWORD(v17) = ~(_DWORD)v25;
          HIDWORD(v17) = ~((k + 1) << 24) ^ HIDWORD(v25);
          LODWORD(v18) = ~(_DWORD)v26;
          HIDWORD(v18) = ((k + 1) << 24) ^ HIDWORD(v26) ^ 0xEFFFFFFF;
          LODWORD(v19) = ~(_DWORD)v27;
          HIDWORD(v19) = ((k + 1) << 24) ^ HIDWORD(v27) ^ 0xDFFFFFFF;
          LODWORD(v20) = ~(_DWORD)v28;
          HIDWORD(v20) = ((k + 1) << 24) ^ HIDWORD(v28) ^ 0xCFFFFFFF;
          LODWORD(v21) = ~(_DWORD)v29;
          HIDWORD(v21) = ((k + 1) << 24) ^ HIDWORD(v29) ^ 0xBFFFFFFF;
          LODWORD(v22) = ~(_DWORD)v30;
          HIDWORD(v22) = ((k + 1) << 24) ^ HIDWORD(v30) ^ 0xAFFFFFFF;
          LODWORD(v23) = ~(_DWORD)v31;
          HIDWORD(v23) = ((k + 1) << 24) ^ HIDWORD(v31) ^ 0x9FFFFFFF;
          LODWORD(v24) = ~(_DWORD)v32;
          HIDWORD(v24) = ((k + 1) << 24) ^ HIDWORD(v32) ^ 0x8FFFFFFF;
          v25 = qword_1DA568[HIBYTE(HIDWORD(v23))]
              ^ qword_1D6D68[(unsigned __int8)~(_BYTE)v26]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v28 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v30 >> 16)]
              ^ qword_1D8568[(unsigned int)~(_DWORD)v32 >> 24]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v25)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v27) >> 8)]
              ^ qword_1D9D68[BYTE6(v21)];
          v26 = qword_1DA568[HIBYTE(HIDWORD(v24))]
              ^ qword_1D6D68[(unsigned __int8)~(_BYTE)v27]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v29 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v31 >> 16)]
              ^ qword_1D8568[BYTE3(v17)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v26)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v28) >> 8)]
              ^ qword_1D9D68[BYTE6(v22)];
          v27 = qword_1DA568[HIBYTE(HIDWORD(v17))]
              ^ qword_1D6D68[(unsigned __int8)~(_BYTE)v28]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v30 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v32 >> 16)]
              ^ qword_1D8568[BYTE3(v18)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v27)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v29) >> 8)]
              ^ qword_1D9D68[BYTE6(v23)];
          v28 = qword_1DA568[HIBYTE(HIDWORD(v18))]
              ^ qword_1D6D68[(unsigned __int8)~(_BYTE)v29]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v31 >> 8)]
              ^ qword_1D7D68[BYTE2(v17)]
              ^ qword_1D8568[BYTE3(v19)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v28)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v30) >> 8)]
              ^ qword_1D9D68[BYTE6(v24)];
          v29 = qword_1DA568[HIBYTE(HIDWORD(v19))]
              ^ qword_1D6D68[(unsigned __int8)~(_BYTE)v30]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v32 >> 8)]
              ^ qword_1D7D68[BYTE2(v18)]
              ^ qword_1D8568[BYTE3(v20)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v29)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v31) >> 8)]
              ^ qword_1D9D68[BYTE6(v17)];
          v30 = qword_1DA568[HIBYTE(HIDWORD(v20))]
              ^ qword_1D6D68[(unsigned __int8)~(_BYTE)v31]
              ^ qword_1D7568[BYTE1(v17)]
              ^ qword_1D7D68[BYTE2(v19)]
              ^ qword_1D8568[BYTE3(v21)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v30)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v32) >> 8)]
              ^ qword_1D9D68[BYTE6(v18)];
          v31 = qword_1DA568[HIBYTE(HIDWORD(v21))]
              ^ qword_1D6D68[(unsigned __int8)~(_BYTE)v32]
              ^ qword_1D7568[BYTE1(v18)]
              ^ qword_1D7D68[BYTE2(v20)]
              ^ qword_1D8568[BYTE3(v22)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v31)]
              ^ qword_1D9568[BYTE5(v17)]
              ^ qword_1D9D68[BYTE6(v19)];
          v32 = qword_1DA568[HIBYTE(HIDWORD(v22))]
              ^ qword_1D6D68[(unsigned __int8)v17]
              ^ qword_1D7568[BYTE1(v19)]
              ^ qword_1D7D68[BYTE2(v21)]
              ^ qword_1D8568[BYTE3(v23)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v32)]
              ^ qword_1D9568[BYTE5(v18)]
              ^ qword_1D9D68[BYTE6(v20)];
          v17 = v25;
          v18 = v26;
          v19 = v27;
          v20 = v28;
          v21 = v29;
          v22 = v30;
          v23 = v31;
          v24 = v32;
        }
        for ( i = 0; i <= 7; ++i )
          *(_QWORD *)&v40[8 * i - 88] ^= *(_QWORD *)&v40[8 * i - 216] ^ *(&v9 + i);
        ++*(_QWORD *)(a1 + 136);
        v39 = 0;
      }
    }
    result = memcpy((void *)(a1 + 72), dest, 0x40u);
    *(_DWORD *)(a1 + 64) = v39;
  }
  else
  {
    result = memcpy((void *)(v34 + v39), a2, a3);
    *(_DWORD *)(a1 + 64) = v6 + v39;
  }
  return result;
}
// 1D6D68: using guessed type _QWORD qword_1D6D68[256];
// 1D7568: using guessed type _QWORD qword_1D7568[256];
// 1D7D68: using guessed type _QWORD qword_1D7D68[256];
// 1D8568: using guessed type _QWORD qword_1D8568[256];
// 1D8D68: using guessed type _QWORD qword_1D8D68[256];
// 1D9568: using guessed type _QWORD qword_1D9568[256];
// 1D9D68: using guessed type _QWORD qword_1D9D68[256];
// 1DA568: using guessed type _QWORD qword_1DA568[256];

//----- (0017738C) --------------------------------------------------------
_DWORD *__fastcall sub_17738C(int a1, char a2, char a3, void *a4, size_t n)
{
  __int64 v5; // kr70_8
  __int64 v9; // [sp+380h] [bp+380h] BYREF
  __int64 v10; // [sp+388h] [bp+388h]
  __int64 v11; // [sp+390h] [bp+390h]
  __int64 v12; // [sp+398h] [bp+398h]
  __int64 v13; // [sp+3A0h] [bp+3A0h]
  __int64 v14; // [sp+3A8h] [bp+3A8h]
  __int64 v15; // [sp+3B0h] [bp+3B0h]
  __int64 v16; // [sp+3B8h] [bp+3B8h]
  __int64 v17; // [sp+3C0h] [bp+3C0h]
  __int64 v18; // [sp+3C8h] [bp+3C8h]
  __int64 v19; // [sp+3D0h] [bp+3D0h]
  __int64 v20; // [sp+3D8h] [bp+3D8h]
  __int64 v21; // [sp+3E0h] [bp+3E0h]
  __int64 v22; // [sp+3E8h] [bp+3E8h]
  __int64 v23; // [sp+3F0h] [bp+3F0h]
  __int64 v24; // [sp+3F8h] [bp+3F8h]
  _QWORD dest[8]; // [sp+400h] [bp+400h] BYREF
  char v26[72]; // [sp+444h] [bp+444h] BYREF
  int v27; // [sp+48Ch] [bp+48Ch]
  unsigned int v28; // [sp+490h] [bp+490h]
  int v29; // [sp+494h] [bp+494h]
  int i; // [sp+498h] [bp+498h]
  unsigned int j; // [sp+49Ch] [bp+49Ch]
  __int64 v32; // [sp+4A0h] [bp+4A0h]
  size_t v33; // [sp+4A8h] [bp+4A8h]
  unsigned int k; // [sp+4ACh] [bp+4ACh]
  _BYTE v35[4]; // [sp+4B0h] [bp+4B0h] BYREF

  v29 = a1;
  v28 = *(_DWORD *)(a1 + 64);
  v27 = 128 >> a3;
  v26[0] = (128 >> a3) | a2 & -(128 >> a3);
  if ( v28 > 0x37 )
  {
    v33 = 128 - v28;
    v32 = *(_QWORD *)(a1 + 136) + 2LL;
  }
  else
  {
    v33 = 64 - v28;
    v32 = *(_QWORD *)(a1 + 136) + 1LL;
  }
  memset(&v26[1], 0, v33 - 9);
  sub_17209C(&v26[v33 - 8], (int)&v26[v33 - 8], v32, SHIDWORD(v32));
  sub_1722BC(a1, v26, v33);
  memcpy(dest, (const void *)(a1 + 72), sizeof(dest));
  v9 = dest[0];
  v10 = dest[1];
  v11 = dest[2];
  v12 = dest[3];
  v13 = dest[4];
  v14 = dest[5];
  v15 = dest[6];
  v16 = dest[7];
  for ( i = 0; i <= 9; i += 2 )
  {
    v9 ^= i;
    v10 ^= i + 16;
    v11 ^= i + 32;
    v12 ^= i + 48;
    v13 ^= i + 64;
    v14 ^= i + 80;
    v15 ^= i + 96;
    v16 ^= i + 112;
    v17 = qword_1DA568[HIBYTE(HIDWORD(v16))]
        ^ qword_1D6D68[(unsigned __int8)v9]
        ^ qword_1D7568[BYTE1(v10)]
        ^ qword_1D7D68[BYTE2(v11)]
        ^ qword_1D8568[BYTE3(v12)]
        ^ qword_1D8D68[BYTE4(v13)]
        ^ qword_1D9568[BYTE5(v14)]
        ^ qword_1D9D68[BYTE6(v15)];
    v18 = qword_1DA568[HIBYTE(HIDWORD(v9))]
        ^ qword_1D6D68[(unsigned __int8)v10]
        ^ qword_1D7568[BYTE1(v11)]
        ^ qword_1D7D68[BYTE2(v12)]
        ^ qword_1D8568[BYTE3(v13)]
        ^ qword_1D8D68[BYTE4(v14)]
        ^ qword_1D9568[BYTE5(v15)]
        ^ qword_1D9D68[BYTE6(v16)];
    v19 = qword_1DA568[HIBYTE(HIDWORD(v10))]
        ^ qword_1D6D68[(unsigned __int8)v11]
        ^ qword_1D7568[BYTE1(v12)]
        ^ qword_1D7D68[BYTE2(v13)]
        ^ qword_1D8568[BYTE3(v14)]
        ^ qword_1D8D68[BYTE4(v15)]
        ^ qword_1D9568[BYTE5(v16)]
        ^ qword_1D9D68[BYTE6(v9)];
    v20 = qword_1DA568[HIBYTE(HIDWORD(v11))]
        ^ qword_1D6D68[(unsigned __int8)v12]
        ^ qword_1D7568[BYTE1(v13)]
        ^ qword_1D7D68[BYTE2(v14)]
        ^ qword_1D8568[BYTE3(v15)]
        ^ qword_1D8D68[BYTE4(v16)]
        ^ qword_1D9568[BYTE5(v9)]
        ^ qword_1D9D68[BYTE6(v10)];
    v21 = qword_1DA568[HIBYTE(HIDWORD(v12))]
        ^ qword_1D6D68[(unsigned __int8)v13]
        ^ qword_1D7568[BYTE1(v14)]
        ^ qword_1D7D68[BYTE2(v15)]
        ^ qword_1D8568[BYTE3(v16)]
        ^ qword_1D8D68[BYTE4(v9)]
        ^ qword_1D9568[BYTE5(v10)]
        ^ qword_1D9D68[BYTE6(v11)];
    v22 = qword_1DA568[HIBYTE(HIDWORD(v13))]
        ^ qword_1D6D68[(unsigned __int8)v14]
        ^ qword_1D7568[BYTE1(v15)]
        ^ qword_1D7D68[BYTE2(v16)]
        ^ qword_1D8568[BYTE3(v9)]
        ^ qword_1D8D68[BYTE4(v10)]
        ^ qword_1D9568[BYTE5(v11)]
        ^ qword_1D9D68[BYTE6(v12)];
    v23 = qword_1DA568[HIBYTE(HIDWORD(v14))]
        ^ qword_1D6D68[(unsigned __int8)v15]
        ^ qword_1D7568[BYTE1(v16)]
        ^ qword_1D7D68[BYTE2(v9)]
        ^ qword_1D8568[BYTE3(v10)]
        ^ qword_1D8D68[BYTE4(v11)]
        ^ qword_1D9568[BYTE5(v12)]
        ^ qword_1D9D68[BYTE6(v13)];
    v24 = qword_1DA568[HIBYTE(HIDWORD(v15))]
        ^ qword_1D6D68[(unsigned __int8)v16]
        ^ qword_1D7568[BYTE1(v9)]
        ^ qword_1D7D68[BYTE2(v10)]
        ^ qword_1D8568[BYTE3(v11)]
        ^ qword_1D8D68[BYTE4(v12)]
        ^ qword_1D9568[BYTE5(v13)]
        ^ qword_1D9D68[BYTE6(v14)];
    v9 = v17 ^ (i + 1);
    v10 = v18 ^ (i + 17);
    v11 = v19 ^ (i + 33);
    v12 = v20 ^ (i + 49);
    v13 = v21 ^ (i + 65);
    v14 = v22 ^ (i + 81);
    v15 = v23 ^ (i + 97);
    v16 = v24 ^ (i + 113);
    v17 = qword_1DA568[HIBYTE(HIDWORD(v16))]
        ^ qword_1D6D68[(unsigned __int8)v9]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v18 ^ (i + 17)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v19 ^ (i + 33)) >> 16)]
        ^ qword_1D8568[((unsigned int)v20 ^ (i + 49)) >> 24]
        ^ qword_1D8D68[BYTE4(v13)]
        ^ qword_1D9568[BYTE5(v14)]
        ^ qword_1D9D68[BYTE6(v15)];
    v18 = qword_1DA568[HIBYTE(HIDWORD(v9))]
        ^ qword_1D6D68[(unsigned __int8)v10]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v19 ^ (i + 33)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v20 ^ (i + 49)) >> 16)]
        ^ qword_1D8568[((unsigned int)v21 ^ (i + 65)) >> 24]
        ^ qword_1D8D68[BYTE4(v14)]
        ^ qword_1D9568[BYTE5(v15)]
        ^ qword_1D9D68[BYTE6(v16)];
    v19 = qword_1DA568[HIBYTE(HIDWORD(v10))]
        ^ qword_1D6D68[(unsigned __int8)v11]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v20 ^ (i + 49)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v21 ^ (i + 65)) >> 16)]
        ^ qword_1D8568[((unsigned int)v22 ^ (i + 81)) >> 24]
        ^ qword_1D8D68[BYTE4(v15)]
        ^ qword_1D9568[BYTE5(v16)]
        ^ qword_1D9D68[BYTE6(v9)];
    v20 = qword_1DA568[HIBYTE(HIDWORD(v11))]
        ^ qword_1D6D68[(unsigned __int8)v12]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v21 ^ (i + 65)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v22 ^ (i + 81)) >> 16)]
        ^ qword_1D8568[((unsigned int)v23 ^ (i + 97)) >> 24]
        ^ qword_1D8D68[BYTE4(v16)]
        ^ qword_1D9568[BYTE5(v9)]
        ^ qword_1D9D68[BYTE6(v10)];
    v21 = qword_1DA568[HIBYTE(HIDWORD(v12))]
        ^ qword_1D6D68[(unsigned __int8)v13]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v22 ^ (i + 81)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v23 ^ (i + 97)) >> 16)]
        ^ qword_1D8568[((unsigned int)v24 ^ (i + 113)) >> 24]
        ^ qword_1D8D68[BYTE4(v9)]
        ^ qword_1D9568[BYTE5(v10)]
        ^ qword_1D9D68[BYTE6(v11)];
    v22 = qword_1DA568[HIBYTE(HIDWORD(v13))]
        ^ qword_1D6D68[(unsigned __int8)v14]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v23 ^ (i + 97)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v24 ^ (i + 113)) >> 16)]
        ^ qword_1D8568[BYTE3(v9)]
        ^ qword_1D8D68[BYTE4(v10)]
        ^ qword_1D9568[BYTE5(v11)]
        ^ qword_1D9D68[BYTE6(v12)];
    v23 = qword_1DA568[HIBYTE(HIDWORD(v14))]
        ^ qword_1D6D68[(unsigned __int8)v15]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v24 ^ (i + 113)) >> 8)]
        ^ qword_1D7D68[BYTE2(v9)]
        ^ qword_1D8568[BYTE3(v10)]
        ^ qword_1D8D68[BYTE4(v11)]
        ^ qword_1D9568[BYTE5(v12)]
        ^ qword_1D9D68[BYTE6(v13)];
    v24 = qword_1DA568[HIBYTE(HIDWORD(v15))]
        ^ qword_1D6D68[(unsigned __int8)v16]
        ^ qword_1D7568[BYTE1(v9)]
        ^ qword_1D7D68[BYTE2(v10)]
        ^ qword_1D8568[BYTE3(v11)]
        ^ qword_1D8D68[BYTE4(v12)]
        ^ qword_1D9568[BYTE5(v13)]
        ^ qword_1D9D68[BYTE6(v14)];
    v9 = v17;
    v10 = v18;
    v11 = v19;
    v12 = v20;
    v13 = v21;
    v14 = v22;
    v15 = v23;
    v16 = v24;
  }
  for ( j = 0; j <= 7; ++j )
    *(_QWORD *)&v35[8 * j - 176] ^= *(&v9 + j);
  for ( k = 0; k <= 3; ++k )
  {
    v5 = *(_QWORD *)&v35[8 * k - 144];
    sub_172158((int)&v26[8 * k], (int)&v26[8 * k], v5, SHIDWORD(v5));
  }
  memcpy(a4, &v26[32 - n], n);
  return sub_172230((_DWORD *)a1, 8 * n);
}
// 1D6D68: using guessed type _QWORD qword_1D6D68[256];
// 1D7568: using guessed type _QWORD qword_1D7568[256];
// 1D7D68: using guessed type _QWORD qword_1D7D68[256];
// 1D8568: using guessed type _QWORD qword_1D8568[256];
// 1D8D68: using guessed type _QWORD qword_1D8D68[256];
// 1D9568: using guessed type _QWORD qword_1D9568[256];
// 1D9D68: using guessed type _QWORD qword_1D9D68[256];
// 1DA568: using guessed type _QWORD qword_1DA568[256];

//----- (00179B38) --------------------------------------------------------
_DWORD *__fastcall sub_179B38(_DWORD *result, int a2)
{
  _DWORD *v2; // [sp+4h] [bp+4h]
  unsigned int i; // [sp+Ch] [bp+Ch]

  v2 = result;
  result[32] = 0;
  for ( i = 0; i <= 0xE; ++i )
  {
    result = &v2[2 * i + 34];
    *result = 0;
    result[1] = 0;
  }
  v2[64] = 0;
  v2[65] = ((a2 & 0xFF00) << 8) | (a2 << 24);
  v2[66] = 0;
  v2[67] = 0;
  return result;
}

//----- (00179BCC) --------------------------------------------------------
void *__fastcall sub_179BCC(int a1, char *a2, size_t a3)
{
  void *result; // r0
  __int64 v4; // r0
  __int16 v5; // r2
  unsigned int v6; // [sp+EF4h] [bp+EF4h]
  char *v7; // [sp+EF8h] [bp+EF8h]
  __int64 v9; // [sp+F00h] [bp+F00h] BYREF
  __int64 v10; // [sp+F08h] [bp+F08h]
  __int64 v11; // [sp+F10h] [bp+F10h]
  __int64 v12; // [sp+F18h] [bp+F18h]
  __int64 v13; // [sp+F20h] [bp+F20h]
  __int64 v14; // [sp+F28h] [bp+F28h]
  __int64 v15; // [sp+F30h] [bp+F30h]
  __int64 v16; // [sp+F38h] [bp+F38h]
  __int64 v17; // [sp+F40h] [bp+F40h]
  __int64 v18; // [sp+F48h] [bp+F48h]
  __int64 v19; // [sp+F50h] [bp+F50h]
  __int64 v20; // [sp+F58h] [bp+F58h]
  __int64 v21; // [sp+F60h] [bp+F60h]
  __int64 v22; // [sp+F68h] [bp+F68h]
  __int64 v23; // [sp+F70h] [bp+F70h]
  __int64 v24; // [sp+F78h] [bp+F78h]
  __int64 v25; // [sp+F80h] [bp+F80h] BYREF
  __int64 v26; // [sp+F88h] [bp+F88h]
  __int64 v27; // [sp+F90h] [bp+F90h]
  __int64 v28; // [sp+F98h] [bp+F98h]
  __int64 v29; // [sp+FA0h] [bp+FA0h]
  __int64 v30; // [sp+FA8h] [bp+FA8h]
  __int64 v31; // [sp+FB0h] [bp+FB0h]
  __int64 v32; // [sp+FB8h] [bp+FB8h]
  __int64 v33; // [sp+FC0h] [bp+FC0h]
  __int64 v34; // [sp+FC8h] [bp+FC8h]
  __int64 v35; // [sp+FD0h] [bp+FD0h]
  __int64 v36; // [sp+FD8h] [bp+FD8h]
  __int64 v37; // [sp+FE0h] [bp+FE0h]
  __int64 v38; // [sp+FE8h] [bp+FE8h]
  __int64 v39; // [sp+FF0h] [bp+FF0h]
  __int64 v40; // [sp+FF8h] [bp+FF8h]
  __int64 v41; // [sp+1000h] [bp+1000h]
  __int64 v42; // [sp+1008h] [bp+1008h]
  __int64 v43; // [sp+1010h] [bp+1010h]
  __int64 v44; // [sp+1018h] [bp+1018h]
  __int64 v45; // [sp+1020h] [bp+1020h]
  __int64 v46; // [sp+1028h] [bp+1028h]
  __int64 v47; // [sp+1030h] [bp+1030h]
  __int64 v48; // [sp+1038h] [bp+1038h]
  __int64 v49; // [sp+1040h] [bp+1040h]
  __int64 v50; // [sp+1048h] [bp+1048h]
  __int64 v51; // [sp+1050h] [bp+1050h]
  __int64 v52; // [sp+1058h] [bp+1058h]
  __int64 v53; // [sp+1060h] [bp+1060h]
  __int64 v54; // [sp+1068h] [bp+1068h]
  __int64 v55; // [sp+1070h] [bp+1070h]
  __int64 v56; // [sp+1078h] [bp+1078h]
  _BYTE dest[128]; // [sp+1080h] [bp+1080h] BYREF
  int v58; // [sp+1100h] [bp+1100h]
  int k; // [sp+1104h] [bp+1104h]
  int j; // [sp+1108h] [bp+1108h]
  unsigned int i; // [sp+110Ch] [bp+110Ch]
  size_t v62; // [sp+1110h] [bp+1110h]
  int v63; // [sp+1114h] [bp+1114h]
  int v64; // [sp+1118h] [bp+1118h] BYREF

  v7 = a2;
  v6 = a3;
  v58 = a1;
  v63 = *(_DWORD *)(a1 + 128);
  if ( 128 - v63 <= a3 )
  {
    memcpy(dest, (const void *)(a1 + 136), sizeof(dest));
    while ( v6 )
    {
      v62 = 128 - v63;
      if ( 128 - v63 > v6 )
        v62 = v6;
      memcpy((void *)(v58 + v63), v7, v62);
      v63 += v62;
      v7 += v62;
      v6 -= v62;
      if ( v63 == 128 )
      {
        for ( i = 0; i <= 0xF; ++i )
        {
          v4 = sub_172214(v58 + 8 * i);
          *(&v25 + i) = v4;
          *(&v9 + i) = *(&v25 + i) ^ *((_QWORD *)&v64 + i - 19);
        }
        for ( j = 0; j <= 13; j += 2 )
        {
          v9 ^= j;
          v10 ^= j + 16;
          v11 ^= j + 32;
          v12 ^= j + 48;
          v13 ^= j + 64;
          v14 ^= j + 80;
          v15 ^= j + 96;
          v16 ^= j + 112;
          v17 ^= j + 128;
          v18 ^= j + 144;
          v19 ^= j + 160;
          v20 ^= j + 176;
          v21 ^= j + 192;
          v22 ^= j + 208;
          v23 ^= j + 224;
          v24 ^= j + 240;
          v41 = qword_1D6D68[(unsigned __int8)v9]
              ^ qword_1D7568[BYTE1(v10)]
              ^ qword_1D7D68[BYTE2(v11)]
              ^ qword_1D8568[BYTE3(v12)]
              ^ qword_1D8D68[BYTE4(v13)]
              ^ qword_1D9568[BYTE5(v14)]
              ^ qword_1D9D68[BYTE6(v15)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v20))];
          v42 = qword_1D6D68[(unsigned __int8)v10]
              ^ qword_1D7568[BYTE1(v11)]
              ^ qword_1D7D68[BYTE2(v12)]
              ^ qword_1D8568[BYTE3(v13)]
              ^ qword_1D8D68[BYTE4(v14)]
              ^ qword_1D9568[BYTE5(v15)]
              ^ qword_1D9D68[BYTE6(v16)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v21))];
          v43 = qword_1D6D68[(unsigned __int8)v11]
              ^ qword_1D7568[BYTE1(v12)]
              ^ qword_1D7D68[BYTE2(v13)]
              ^ qword_1D8568[BYTE3(v14)]
              ^ qword_1D8D68[BYTE4(v15)]
              ^ qword_1D9568[BYTE5(v16)]
              ^ qword_1D9D68[BYTE6(v17)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v22))];
          v44 = qword_1D6D68[(unsigned __int8)v12]
              ^ qword_1D7568[BYTE1(v13)]
              ^ qword_1D7D68[BYTE2(v14)]
              ^ qword_1D8568[BYTE3(v15)]
              ^ qword_1D8D68[BYTE4(v16)]
              ^ qword_1D9568[BYTE5(v17)]
              ^ qword_1D9D68[BYTE6(v18)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v23))];
          v45 = qword_1D6D68[(unsigned __int8)v13]
              ^ qword_1D7568[BYTE1(v14)]
              ^ qword_1D7D68[BYTE2(v15)]
              ^ qword_1D8568[BYTE3(v16)]
              ^ qword_1D8D68[BYTE4(v17)]
              ^ qword_1D9568[BYTE5(v18)]
              ^ qword_1D9D68[BYTE6(v19)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v24))];
          v46 = qword_1D6D68[(unsigned __int8)v14]
              ^ qword_1D7568[BYTE1(v15)]
              ^ qword_1D7D68[BYTE2(v16)]
              ^ qword_1D8568[BYTE3(v17)]
              ^ qword_1D8D68[BYTE4(v18)]
              ^ qword_1D9568[BYTE5(v19)]
              ^ qword_1D9D68[BYTE6(v20)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v9))];
          v47 = qword_1D6D68[(unsigned __int8)v15]
              ^ qword_1D7568[BYTE1(v16)]
              ^ qword_1D7D68[BYTE2(v17)]
              ^ qword_1D8568[BYTE3(v18)]
              ^ qword_1D8D68[BYTE4(v19)]
              ^ qword_1D9568[BYTE5(v20)]
              ^ qword_1D9D68[BYTE6(v21)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v10))];
          v48 = qword_1D6D68[(unsigned __int8)v16]
              ^ qword_1D7568[BYTE1(v17)]
              ^ qword_1D7D68[BYTE2(v18)]
              ^ qword_1D8568[BYTE3(v19)]
              ^ qword_1D8D68[BYTE4(v20)]
              ^ qword_1D9568[BYTE5(v21)]
              ^ qword_1D9D68[BYTE6(v22)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v11))];
          v49 = qword_1D6D68[(unsigned __int8)v17]
              ^ qword_1D7568[BYTE1(v18)]
              ^ qword_1D7D68[BYTE2(v19)]
              ^ qword_1D8568[BYTE3(v20)]
              ^ qword_1D8D68[BYTE4(v21)]
              ^ qword_1D9568[BYTE5(v22)]
              ^ qword_1D9D68[BYTE6(v23)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v12))];
          v50 = qword_1D6D68[(unsigned __int8)v18]
              ^ qword_1D7568[BYTE1(v19)]
              ^ qword_1D7D68[BYTE2(v20)]
              ^ qword_1D8568[BYTE3(v21)]
              ^ qword_1D8D68[BYTE4(v22)]
              ^ qword_1D9568[BYTE5(v23)]
              ^ qword_1D9D68[BYTE6(v24)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v13))];
          v51 = qword_1D6D68[(unsigned __int8)v19]
              ^ qword_1D7568[BYTE1(v20)]
              ^ qword_1D7D68[BYTE2(v21)]
              ^ qword_1D8568[BYTE3(v22)]
              ^ qword_1D8D68[BYTE4(v23)]
              ^ qword_1D9568[BYTE5(v24)]
              ^ qword_1D9D68[BYTE6(v9)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v14))];
          v52 = qword_1D6D68[(unsigned __int8)v20]
              ^ qword_1D7568[BYTE1(v21)]
              ^ qword_1D7D68[BYTE2(v22)]
              ^ qword_1D8568[BYTE3(v23)]
              ^ qword_1D8D68[BYTE4(v24)]
              ^ qword_1D9568[BYTE5(v9)]
              ^ qword_1D9D68[BYTE6(v10)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v15))];
          v53 = qword_1D6D68[(unsigned __int8)v21]
              ^ qword_1D7568[BYTE1(v22)]
              ^ qword_1D7D68[BYTE2(v23)]
              ^ qword_1D8568[BYTE3(v24)]
              ^ qword_1D8D68[BYTE4(v9)]
              ^ qword_1D9568[BYTE5(v10)]
              ^ qword_1D9D68[BYTE6(v11)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v16))];
          v54 = qword_1D6D68[(unsigned __int8)v22]
              ^ qword_1D7568[BYTE1(v23)]
              ^ qword_1D7D68[BYTE2(v24)]
              ^ qword_1D8568[BYTE3(v9)]
              ^ qword_1D8D68[BYTE4(v10)]
              ^ qword_1D9568[BYTE5(v11)]
              ^ qword_1D9D68[BYTE6(v12)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v17))];
          v55 = qword_1D6D68[(unsigned __int8)v23]
              ^ qword_1D7568[BYTE1(v24)]
              ^ qword_1D7D68[BYTE2(v9)]
              ^ qword_1D8568[BYTE3(v10)]
              ^ qword_1D8D68[BYTE4(v11)]
              ^ qword_1D9568[BYTE5(v12)]
              ^ qword_1D9D68[BYTE6(v13)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v18))];
          v56 = qword_1D6D68[(unsigned __int8)v24]
              ^ qword_1D7568[BYTE1(v9)]
              ^ qword_1D7D68[BYTE2(v10)]
              ^ qword_1D8568[BYTE3(v11)]
              ^ qword_1D8D68[BYTE4(v12)]
              ^ qword_1D9568[BYTE5(v13)]
              ^ qword_1D9D68[BYTE6(v14)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v19))];
          v9 = v41 ^ (j + 1);
          v10 = v42 ^ (j + 17);
          v11 = v43 ^ (j + 33);
          v12 = v44 ^ (j + 49);
          v13 = v45 ^ (j + 65);
          v14 = v46 ^ (j + 81);
          v15 = v47 ^ (j + 97);
          v16 = v48 ^ (j + 113);
          v17 = v49 ^ (j + 129);
          v18 = v50 ^ (j + 145);
          v19 = v51 ^ (j + 161);
          v20 = v52 ^ (j + 177);
          v21 = v53 ^ (j + 193);
          v22 = v54 ^ (j + 209);
          v23 = v55 ^ (j + 225);
          v24 = v56 ^ (j + 241);
          v41 = qword_1D6D68[(unsigned __int8)v9]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v42 ^ (j + 17)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v43 ^ (j + 33)) >> 16)]
              ^ qword_1D8568[((unsigned int)v44 ^ (j + 49)) >> 24]
              ^ qword_1D8D68[BYTE4(v13)]
              ^ qword_1D9568[BYTE5(v14)]
              ^ qword_1D9D68[BYTE6(v15)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v20))];
          v42 = qword_1D6D68[(unsigned __int8)v10]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v43 ^ (j + 33)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v44 ^ (j + 49)) >> 16)]
              ^ qword_1D8568[((unsigned int)v45 ^ (j + 65)) >> 24]
              ^ qword_1D8D68[BYTE4(v14)]
              ^ qword_1D9568[BYTE5(v15)]
              ^ qword_1D9D68[BYTE6(v16)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v21))];
          v43 = qword_1D6D68[(unsigned __int8)v11]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v44 ^ (j + 49)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v45 ^ (j + 65)) >> 16)]
              ^ qword_1D8568[((unsigned int)v46 ^ (j + 81)) >> 24]
              ^ qword_1D8D68[BYTE4(v15)]
              ^ qword_1D9568[BYTE5(v16)]
              ^ qword_1D9D68[BYTE6(v17)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v22))];
          v44 = qword_1D6D68[(unsigned __int8)v12]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v45 ^ (j + 65)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v46 ^ (j + 81)) >> 16)]
              ^ qword_1D8568[((unsigned int)v47 ^ (j + 97)) >> 24]
              ^ qword_1D8D68[BYTE4(v16)]
              ^ qword_1D9568[BYTE5(v17)]
              ^ qword_1D9D68[BYTE6(v18)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v23))];
          v45 = qword_1D6D68[(unsigned __int8)v13]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v46 ^ (j + 81)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v47 ^ (j + 97)) >> 16)]
              ^ qword_1D8568[((unsigned int)v48 ^ (j + 113)) >> 24]
              ^ qword_1D8D68[BYTE4(v17)]
              ^ qword_1D9568[BYTE5(v18)]
              ^ qword_1D9D68[BYTE6(v19)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v24))];
          v46 = qword_1D6D68[(unsigned __int8)v14]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v47 ^ (j + 97)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v48 ^ (j + 113)) >> 16)]
              ^ qword_1D8568[((unsigned int)v49 ^ (j + 129)) >> 24]
              ^ qword_1D8D68[BYTE4(v18)]
              ^ qword_1D9568[BYTE5(v19)]
              ^ qword_1D9D68[BYTE6(v20)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v9))];
          v47 = qword_1D6D68[(unsigned __int8)v15]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v48 ^ (j + 113)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v49 ^ (j + 129)) >> 16)]
              ^ qword_1D8568[((unsigned int)v50 ^ (j + 145)) >> 24]
              ^ qword_1D8D68[BYTE4(v19)]
              ^ qword_1D9568[BYTE5(v20)]
              ^ qword_1D9D68[BYTE6(v21)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v10))];
          v48 = qword_1D6D68[(unsigned __int8)v16]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v49 ^ (j + 129)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v50 ^ (j + 145)) >> 16)]
              ^ qword_1D8568[((unsigned int)v51 ^ (j + 161)) >> 24]
              ^ qword_1D8D68[BYTE4(v20)]
              ^ qword_1D9568[BYTE5(v21)]
              ^ qword_1D9D68[BYTE6(v22)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v11))];
          v49 = qword_1D6D68[(unsigned __int8)v17]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v50 ^ (j + 145)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v51 ^ (j + 161)) >> 16)]
              ^ qword_1D8568[((unsigned int)v52 ^ (j + 177)) >> 24]
              ^ qword_1D8D68[BYTE4(v21)]
              ^ qword_1D9568[BYTE5(v22)]
              ^ qword_1D9D68[BYTE6(v23)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v12))];
          v50 = qword_1D6D68[(unsigned __int8)v18]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v51 ^ (j + 161)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v52 ^ (j + 177)) >> 16)]
              ^ qword_1D8568[((unsigned int)v53 ^ (j + 193)) >> 24]
              ^ qword_1D8D68[BYTE4(v22)]
              ^ qword_1D9568[BYTE5(v23)]
              ^ qword_1D9D68[BYTE6(v24)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v13))];
          v51 = qword_1D6D68[(unsigned __int8)v19]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v52 ^ (j + 177)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v53 ^ (j + 193)) >> 16)]
              ^ qword_1D8568[((unsigned int)v54 ^ (j + 209)) >> 24]
              ^ qword_1D8D68[BYTE4(v23)]
              ^ qword_1D9568[BYTE5(v24)]
              ^ qword_1D9D68[BYTE6(v9)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v14))];
          v52 = qword_1D6D68[(unsigned __int8)v20]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v53 ^ (j + 193)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v54 ^ (j + 209)) >> 16)]
              ^ qword_1D8568[((unsigned int)v55 ^ (j + 225)) >> 24]
              ^ qword_1D8D68[BYTE4(v24)]
              ^ qword_1D9568[BYTE5(v9)]
              ^ qword_1D9D68[BYTE6(v10)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v15))];
          v53 = qword_1D6D68[(unsigned __int8)v21]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v54 ^ (j + 209)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v55 ^ (j + 225)) >> 16)]
              ^ qword_1D8568[((unsigned int)v56 ^ (j + 241)) >> 24]
              ^ qword_1D8D68[BYTE4(v9)]
              ^ qword_1D9568[BYTE5(v10)]
              ^ qword_1D9D68[BYTE6(v11)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v16))];
          v54 = qword_1D6D68[(unsigned __int8)v22]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v55 ^ (j + 225)) >> 8)]
              ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v56 ^ (j + 241)) >> 16)]
              ^ qword_1D8568[BYTE3(v9)]
              ^ qword_1D8D68[BYTE4(v10)]
              ^ qword_1D9568[BYTE5(v11)]
              ^ qword_1D9D68[BYTE6(v12)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v17))];
          v55 = qword_1D6D68[(unsigned __int8)v23]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v56 ^ (j + 241)) >> 8)]
              ^ qword_1D7D68[BYTE2(v9)]
              ^ qword_1D8568[BYTE3(v10)]
              ^ qword_1D8D68[BYTE4(v11)]
              ^ qword_1D9568[BYTE5(v12)]
              ^ qword_1D9D68[BYTE6(v13)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v18))];
          v56 = qword_1D6D68[(unsigned __int8)v24]
              ^ qword_1D7568[BYTE1(v9)]
              ^ qword_1D7D68[BYTE2(v10)]
              ^ qword_1D8568[BYTE3(v11)]
              ^ qword_1D8D68[BYTE4(v12)]
              ^ qword_1D9568[BYTE5(v13)]
              ^ qword_1D9D68[BYTE6(v14)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v19))];
          v9 = v41;
          v10 = v42;
          v11 = v43;
          v12 = v44;
          v13 = v45;
          v14 = v46;
          v15 = v47;
          v16 = v48;
          v17 = v49;
          v18 = v50;
          v19 = v51;
          v20 = v52;
          v21 = v53;
          v22 = v54;
          v23 = v55;
          v24 = v56;
        }
        for ( k = 0; k <= 13; k += 2 )
        {
          LODWORD(v25) = ~(_DWORD)v25;
          HIDWORD(v25) ^= ~(k << 24);
          LODWORD(v26) = ~(_DWORD)v26;
          HIDWORD(v26) ^= (k << 24) ^ 0xEFFFFFFF;
          LODWORD(v27) = ~(_DWORD)v27;
          HIDWORD(v27) ^= (k << 24) ^ 0xDFFFFFFF;
          LODWORD(v28) = ~(_DWORD)v28;
          HIDWORD(v28) ^= (k << 24) ^ 0xCFFFFFFF;
          LODWORD(v29) = ~(_DWORD)v29;
          HIDWORD(v29) ^= (k << 24) ^ 0xBFFFFFFF;
          LODWORD(v30) = ~(_DWORD)v30;
          HIDWORD(v30) ^= (k << 24) ^ 0xAFFFFFFF;
          LODWORD(v31) = ~(_DWORD)v31;
          HIDWORD(v31) ^= (k << 24) ^ 0x9FFFFFFF;
          LODWORD(v32) = ~(_DWORD)v32;
          HIDWORD(v32) ^= (k << 24) ^ 0x8FFFFFFF;
          LODWORD(v33) = ~(_DWORD)v33;
          HIDWORD(v33) ^= (k << 24) ^ 0x7FFFFFFF;
          LODWORD(v34) = ~(_DWORD)v34;
          HIDWORD(v34) ^= (k << 24) ^ 0x6FFFFFFF;
          LODWORD(v35) = ~(_DWORD)v35;
          HIDWORD(v35) ^= (k << 24) ^ 0x5FFFFFFF;
          LODWORD(v36) = ~(_DWORD)v36;
          HIDWORD(v36) ^= (k << 24) ^ 0x4FFFFFFF;
          LODWORD(v37) = ~(_DWORD)v37;
          HIDWORD(v37) ^= (k << 24) ^ 0x3FFFFFFF;
          LODWORD(v38) = ~(_DWORD)v38;
          HIDWORD(v38) ^= (k << 24) ^ 0x2FFFFFFF;
          LODWORD(v39) = ~(_DWORD)v39;
          HIDWORD(v39) ^= (k << 24) ^ 0x1FFFFFFF;
          v5 = WORD2(v40);
          LODWORD(v40) = ~(_DWORD)v40;
          HIDWORD(v40) ^= (k << 24) ^ 0xFFFFFFF;
          v41 = qword_1D6D68[(unsigned __int8)v26]
              ^ qword_1D7568[BYTE1(v28)]
              ^ qword_1D7D68[BYTE2(v30)]
              ^ qword_1D8568[BYTE3(v36)]
              ^ qword_1D8D68[BYTE4(v25)]
              ^ qword_1D9568[BYTE5(v27)]
              ^ qword_1D9D68[BYTE6(v29)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v31))];
          v42 = qword_1D6D68[(unsigned __int8)v27]
              ^ qword_1D7568[BYTE1(v29)]
              ^ qword_1D7D68[BYTE2(v31)]
              ^ qword_1D8568[BYTE3(v37)]
              ^ qword_1D8D68[BYTE4(v26)]
              ^ qword_1D9568[BYTE5(v28)]
              ^ qword_1D9D68[BYTE6(v30)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v32))];
          v43 = qword_1D6D68[(unsigned __int8)v28]
              ^ qword_1D7568[BYTE1(v30)]
              ^ qword_1D7D68[BYTE2(v32)]
              ^ qword_1D8568[BYTE3(v38)]
              ^ qword_1D8D68[BYTE4(v27)]
              ^ qword_1D9568[BYTE5(v29)]
              ^ qword_1D9D68[BYTE6(v31)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v33))];
          v44 = qword_1D6D68[(unsigned __int8)v29]
              ^ qword_1D7568[BYTE1(v31)]
              ^ qword_1D7D68[BYTE2(v33)]
              ^ qword_1D8568[BYTE3(v39)]
              ^ qword_1D8D68[BYTE4(v28)]
              ^ qword_1D9568[BYTE5(v30)]
              ^ qword_1D9D68[BYTE6(v32)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v34))];
          v45 = qword_1D6D68[(unsigned __int8)v30]
              ^ qword_1D7568[BYTE1(v32)]
              ^ qword_1D7D68[BYTE2(v34)]
              ^ qword_1D8568[BYTE3(v40)]
              ^ qword_1D8D68[BYTE4(v29)]
              ^ qword_1D9568[BYTE5(v31)]
              ^ qword_1D9D68[BYTE6(v33)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v35))];
          v46 = qword_1D6D68[(unsigned __int8)v31]
              ^ qword_1D7568[BYTE1(v33)]
              ^ qword_1D7D68[BYTE2(v35)]
              ^ qword_1D8568[BYTE3(v25)]
              ^ qword_1D8D68[BYTE4(v30)]
              ^ qword_1D9568[BYTE5(v32)]
              ^ qword_1D9D68[BYTE6(v34)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v36))];
          v47 = qword_1D6D68[(unsigned __int8)v32]
              ^ qword_1D7568[BYTE1(v34)]
              ^ qword_1D7D68[BYTE2(v36)]
              ^ qword_1D8568[BYTE3(v26)]
              ^ qword_1D8D68[BYTE4(v31)]
              ^ qword_1D9568[BYTE5(v33)]
              ^ qword_1D9D68[BYTE6(v35)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v37))];
          v48 = qword_1D6D68[(unsigned __int8)v33]
              ^ qword_1D7568[BYTE1(v35)]
              ^ qword_1D7D68[BYTE2(v37)]
              ^ qword_1D8568[BYTE3(v27)]
              ^ qword_1D8D68[BYTE4(v32)]
              ^ qword_1D9568[BYTE5(v34)]
              ^ qword_1D9D68[BYTE6(v36)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v38))];
          v49 = qword_1D6D68[(unsigned __int8)v34]
              ^ qword_1D7568[BYTE1(v36)]
              ^ qword_1D7D68[BYTE2(v38)]
              ^ qword_1D8568[BYTE3(v28)]
              ^ qword_1D8D68[BYTE4(v33)]
              ^ qword_1D9568[BYTE5(v35)]
              ^ qword_1D9D68[BYTE6(v37)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v39))];
          v50 = qword_1D6D68[(unsigned __int8)v35]
              ^ qword_1D7568[BYTE1(v37)]
              ^ qword_1D7D68[BYTE2(v39)]
              ^ qword_1D8568[BYTE3(v29)]
              ^ qword_1D8D68[BYTE4(v34)]
              ^ qword_1D9568[BYTE5(v36)]
              ^ qword_1D9D68[BYTE6(v38)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v40))];
          v51 = qword_1D6D68[(unsigned __int8)v36]
              ^ qword_1D7568[BYTE1(v38)]
              ^ qword_1D7D68[BYTE2(v40)]
              ^ qword_1D8568[BYTE3(v30)]
              ^ qword_1D8D68[BYTE4(v35)]
              ^ qword_1D9568[BYTE5(v37)]
              ^ qword_1D9D68[BYTE6(v39)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v25))];
          v52 = qword_1D6D68[(unsigned __int8)v37]
              ^ qword_1D7568[BYTE1(v39)]
              ^ qword_1D7D68[BYTE2(v25)]
              ^ qword_1D8568[BYTE3(v31)]
              ^ qword_1D8D68[BYTE4(v36)]
              ^ qword_1D9568[BYTE5(v38)]
              ^ qword_1D9D68[BYTE6(v40)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v26))];
          v53 = qword_1D6D68[(unsigned __int8)v38]
              ^ qword_1D7568[BYTE1(v40)]
              ^ qword_1D7D68[BYTE2(v26)]
              ^ qword_1D8568[BYTE3(v32)]
              ^ qword_1D8D68[BYTE4(v37)]
              ^ qword_1D9568[BYTE5(v39)]
              ^ qword_1D9D68[BYTE6(v25)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v27))];
          v54 = qword_1D6D68[(unsigned __int8)v39]
              ^ qword_1D7568[BYTE1(v25)]
              ^ qword_1D7D68[BYTE2(v27)]
              ^ qword_1D8568[BYTE3(v33)]
              ^ qword_1D8D68[BYTE4(v38)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~v5 >> 8)]
              ^ qword_1D9D68[BYTE6(v26)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v28))];
          v55 = qword_1D6D68[(unsigned __int8)v40]
              ^ qword_1D7568[BYTE1(v26)]
              ^ qword_1D7D68[BYTE2(v28)]
              ^ qword_1D8568[BYTE3(v34)]
              ^ qword_1D8D68[BYTE4(v39)]
              ^ qword_1D9568[BYTE5(v25)]
              ^ qword_1D9D68[BYTE6(v27)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v29))];
          v56 = qword_1D6D68[(unsigned __int8)v25]
              ^ qword_1D7568[BYTE1(v27)]
              ^ qword_1D7D68[BYTE2(v29)]
              ^ qword_1D8568[BYTE3(v35)]
              ^ qword_1D8D68[(unsigned __int8)~(_BYTE)v5]
              ^ qword_1D9568[BYTE5(v26)]
              ^ qword_1D9D68[BYTE6(v28)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v30))];
          LODWORD(v25) = ~(_DWORD)v41;
          HIDWORD(v25) = HIDWORD(v41) ^ ~((k + 1) << 24);
          LODWORD(v26) = ~(_DWORD)v42;
          HIDWORD(v26) = ((k + 1) << 24) ^ HIDWORD(v42) ^ 0xEFFFFFFF;
          LODWORD(v27) = ~(_DWORD)v43;
          HIDWORD(v27) = ((k + 1) << 24) ^ HIDWORD(v43) ^ 0xDFFFFFFF;
          LODWORD(v28) = ~(_DWORD)v44;
          HIDWORD(v28) = ((k + 1) << 24) ^ HIDWORD(v44) ^ 0xCFFFFFFF;
          LODWORD(v29) = ~(_DWORD)v45;
          HIDWORD(v29) = ((k + 1) << 24) ^ HIDWORD(v45) ^ 0xBFFFFFFF;
          LODWORD(v30) = ~(_DWORD)v46;
          HIDWORD(v30) = ((k + 1) << 24) ^ HIDWORD(v46) ^ 0xAFFFFFFF;
          LODWORD(v31) = ~(_DWORD)v47;
          HIDWORD(v31) = ((k + 1) << 24) ^ HIDWORD(v47) ^ 0x9FFFFFFF;
          LODWORD(v32) = ~(_DWORD)v48;
          HIDWORD(v32) = ((k + 1) << 24) ^ HIDWORD(v48) ^ 0x8FFFFFFF;
          LODWORD(v33) = ~(_DWORD)v49;
          HIDWORD(v33) = ((k + 1) << 24) ^ HIDWORD(v49) ^ 0x7FFFFFFF;
          LODWORD(v34) = ~(_DWORD)v50;
          HIDWORD(v34) = ((k + 1) << 24) ^ HIDWORD(v50) ^ 0x6FFFFFFF;
          LODWORD(v35) = ~(_DWORD)v51;
          HIDWORD(v35) = ((k + 1) << 24) ^ HIDWORD(v51) ^ 0x5FFFFFFF;
          LODWORD(v36) = ~(_DWORD)v52;
          HIDWORD(v36) = ((k + 1) << 24) ^ HIDWORD(v52) ^ 0x4FFFFFFF;
          LODWORD(v37) = ~(_DWORD)v53;
          HIDWORD(v37) = ((k + 1) << 24) ^ HIDWORD(v53) ^ 0x3FFFFFFF;
          LODWORD(v38) = ~(_DWORD)v54;
          HIDWORD(v38) = ((k + 1) << 24) ^ HIDWORD(v54) ^ 0x2FFFFFFF;
          LODWORD(v39) = ~(_DWORD)v55;
          HIDWORD(v39) = ((k + 1) << 24) ^ HIDWORD(v55) ^ 0x1FFFFFFF;
          LODWORD(v40) = ~(_DWORD)v56;
          HIDWORD(v40) = ((k + 1) << 24) ^ HIDWORD(v56) ^ 0xFFFFFFF;
          v41 = qword_1D6D68[(unsigned __int8)~(_BYTE)v42]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v44 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v46 >> 16)]
              ^ qword_1D8568[(unsigned int)~(_DWORD)v52 >> 24]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v41)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v43) >> 8)]
              ^ qword_1D9D68[BYTE6(v29)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v31))];
          v42 = qword_1D6D68[(unsigned __int8)~(_BYTE)v43]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v45 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v47 >> 16)]
              ^ qword_1D8568[(unsigned int)~(_DWORD)v53 >> 24]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v42)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v44) >> 8)]
              ^ qword_1D9D68[BYTE6(v30)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v32))];
          v43 = qword_1D6D68[(unsigned __int8)~(_BYTE)v44]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v46 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v48 >> 16)]
              ^ qword_1D8568[(unsigned int)~(_DWORD)v54 >> 24]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v43)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v45) >> 8)]
              ^ qword_1D9D68[BYTE6(v31)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v33))];
          v44 = qword_1D6D68[(unsigned __int8)~(_BYTE)v45]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v47 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v49 >> 16)]
              ^ qword_1D8568[(unsigned int)~(_DWORD)v55 >> 24]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v44)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v46) >> 8)]
              ^ qword_1D9D68[BYTE6(v32)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v34))];
          v45 = qword_1D6D68[(unsigned __int8)~(_BYTE)v46]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v48 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v50 >> 16)]
              ^ qword_1D8568[(unsigned int)~(_DWORD)v56 >> 24]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v45)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v47) >> 8)]
              ^ qword_1D9D68[BYTE6(v33)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v35))];
          v46 = qword_1D6D68[(unsigned __int8)~(_BYTE)v47]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v49 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v51 >> 16)]
              ^ qword_1D8568[BYTE3(v25)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v46)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v48) >> 8)]
              ^ qword_1D9D68[BYTE6(v34)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v36))];
          v47 = qword_1D6D68[(unsigned __int8)~(_BYTE)v48]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v50 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v52 >> 16)]
              ^ qword_1D8568[BYTE3(v26)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v47)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v49) >> 8)]
              ^ qword_1D9D68[BYTE6(v35)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v37))];
          v48 = qword_1D6D68[(unsigned __int8)~(_BYTE)v49]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v51 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v53 >> 16)]
              ^ qword_1D8568[BYTE3(v27)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v48)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v50) >> 8)]
              ^ qword_1D9D68[BYTE6(v36)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v38))];
          v49 = qword_1D6D68[(unsigned __int8)~(_BYTE)v50]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v52 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v54 >> 16)]
              ^ qword_1D8568[BYTE3(v28)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v49)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v51) >> 8)]
              ^ qword_1D9D68[BYTE6(v37)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v39))];
          v50 = qword_1D6D68[(unsigned __int8)~(_BYTE)v51]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v53 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v55 >> 16)]
              ^ qword_1D8568[BYTE3(v29)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v50)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v52) >> 8)]
              ^ qword_1D9D68[BYTE6(v38)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v40))];
          v51 = qword_1D6D68[(unsigned __int8)~(_BYTE)v52]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v54 >> 8)]
              ^ qword_1D7D68[(unsigned __int8)((unsigned int)~(_DWORD)v56 >> 16)]
              ^ qword_1D8568[BYTE3(v30)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v51)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v53) >> 8)]
              ^ qword_1D9D68[BYTE6(v39)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v25))];
          v52 = qword_1D6D68[(unsigned __int8)~(_BYTE)v53]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v55 >> 8)]
              ^ qword_1D7D68[BYTE2(v25)]
              ^ qword_1D8568[BYTE3(v31)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v52)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v54) >> 8)]
              ^ qword_1D9D68[BYTE6(v40)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v26))];
          v53 = qword_1D6D68[(unsigned __int8)~(_BYTE)v54]
              ^ qword_1D7568[(unsigned __int8)((unsigned __int16)~(_WORD)v56 >> 8)]
              ^ qword_1D7D68[BYTE2(v26)]
              ^ qword_1D8568[BYTE3(v32)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v53)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v55) >> 8)]
              ^ qword_1D9D68[BYTE6(v25)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v27))];
          v54 = qword_1D6D68[(unsigned __int8)~(_BYTE)v55]
              ^ qword_1D7568[BYTE1(v25)]
              ^ qword_1D7D68[BYTE2(v27)]
              ^ qword_1D8568[BYTE3(v33)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v54)]
              ^ qword_1D9568[(unsigned __int8)((unsigned __int16)~WORD2(v56) >> 8)]
              ^ qword_1D9D68[BYTE6(v26)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v28))];
          v55 = qword_1D6D68[(unsigned __int8)~(_BYTE)v56]
              ^ qword_1D7568[BYTE1(v26)]
              ^ qword_1D7D68[BYTE2(v28)]
              ^ qword_1D8568[BYTE3(v34)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v55)]
              ^ qword_1D9568[BYTE5(v25)]
              ^ qword_1D9D68[BYTE6(v27)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v29))];
          v56 = qword_1D6D68[(unsigned __int8)v25]
              ^ qword_1D7568[BYTE1(v27)]
              ^ qword_1D7D68[BYTE2(v29)]
              ^ qword_1D8568[BYTE3(v35)]
              ^ qword_1D8D68[(unsigned __int8)~BYTE4(v56)]
              ^ qword_1D9568[BYTE5(v26)]
              ^ qword_1D9D68[BYTE6(v28)]
              ^ qword_1DA568[HIBYTE(HIDWORD(v30))];
          v25 = v41;
          v26 = v42;
          v27 = v43;
          v28 = v44;
          v29 = v45;
          v30 = v46;
          v31 = v47;
          v32 = v48;
          v33 = v49;
          v34 = v50;
          v35 = v51;
          v36 = v52;
          v37 = v53;
          v38 = v54;
          v39 = v55;
          v40 = v56;
        }
        for ( i = 0; i <= 0xF; ++i )
          *((_QWORD *)&v64 + i - 19) ^= *(&v25 + i) ^ *(&v9 + i);
        ++*(_QWORD *)(a1 + 264);
        v63 = 0;
      }
    }
    result = memcpy((void *)(a1 + 136), dest, 0x80u);
    *(_DWORD *)(a1 + 128) = v63;
  }
  else
  {
    result = memcpy((void *)(v58 + v63), a2, a3);
    *(_DWORD *)(a1 + 128) = v6 + v63;
  }
  return result;
}
// 1D6D68: using guessed type _QWORD qword_1D6D68[256];
// 1D7568: using guessed type _QWORD qword_1D7568[256];
// 1D7D68: using guessed type _QWORD qword_1D7D68[256];
// 1D8568: using guessed type _QWORD qword_1D8568[256];
// 1D8D68: using guessed type _QWORD qword_1D8D68[256];
// 1D9568: using guessed type _QWORD qword_1D9568[256];
// 1D9D68: using guessed type _QWORD qword_1D9D68[256];
// 1DA568: using guessed type _QWORD qword_1DA568[256];

//----- (00183F74) --------------------------------------------------------
_DWORD *__fastcall sub_183F74(int a1, char a2, char a3, void *a4, size_t n)
{
  _QWORD v8[16]; // [sp+700h] [bp+700h] BYREF
  __int64 v9; // [sp+780h] [bp+780h]
  __int64 v10; // [sp+788h] [bp+788h]
  __int64 v11; // [sp+790h] [bp+790h]
  __int64 v12; // [sp+798h] [bp+798h]
  __int64 v13; // [sp+7A0h] [bp+7A0h]
  __int64 v14; // [sp+7A8h] [bp+7A8h]
  __int64 v15; // [sp+7B0h] [bp+7B0h]
  __int64 v16; // [sp+7B8h] [bp+7B8h]
  __int64 v17; // [sp+7C0h] [bp+7C0h]
  __int64 v18; // [sp+7C8h] [bp+7C8h]
  __int64 v19; // [sp+7D0h] [bp+7D0h]
  __int64 v20; // [sp+7D8h] [bp+7D8h]
  __int64 v21; // [sp+7E0h] [bp+7E0h]
  __int64 v22; // [sp+7E8h] [bp+7E8h]
  __int64 v23; // [sp+7F0h] [bp+7F0h]
  __int64 v24; // [sp+7F8h] [bp+7F8h]
  _QWORD dest[16]; // [sp+800h] [bp+800h] BYREF
  char v26[136]; // [sp+884h] [bp+884h] BYREF
  int v27; // [sp+90Ch] [bp+90Ch]
  unsigned int v28; // [sp+910h] [bp+910h]
  int v29; // [sp+914h] [bp+914h]
  int i; // [sp+918h] [bp+918h]
  unsigned int j; // [sp+91Ch] [bp+91Ch]
  __int64 v32; // [sp+920h] [bp+920h]
  unsigned int k; // [sp+928h] [bp+928h]
  size_t v34; // [sp+92Ch] [bp+92Ch]

  v29 = a1;
  v28 = *(_DWORD *)(a1 + 128);
  v27 = 128 >> a3;
  v26[0] = (128 >> a3) | a2 & -(128 >> a3);
  if ( v28 > 0x77 )
  {
    v34 = 256 - v28;
    v32 = *(_QWORD *)(a1 + 264) + 2LL;
  }
  else
  {
    v34 = 128 - v28;
    v32 = *(_QWORD *)(a1 + 264) + 1LL;
  }
  memset(&v26[1], 0, v34 - 9);
  sub_17209C(&v26[v34 - 8], (int)&v26[v34 - 8], v32, SHIDWORD(v32));
  sub_179BCC(a1, v26, v34);
  memcpy(dest, (const void *)(a1 + 136), sizeof(dest));
  memcpy(v8, dest, sizeof(v8));
  for ( i = 0; i <= 13; i += 2 )
  {
    v8[0] ^= i;
    v8[1] ^= i + 16;
    v8[2] ^= i + 32;
    v8[3] ^= i + 48;
    v8[4] ^= i + 64;
    v8[5] ^= i + 80;
    v8[6] ^= i + 96;
    v8[7] ^= i + 112;
    v8[8] ^= i + 128;
    v8[9] ^= i + 144;
    v8[10] ^= i + 160;
    v8[11] ^= i + 176;
    v8[12] ^= i + 192;
    v8[13] ^= i + 208;
    v8[14] ^= i + 224;
    v8[15] ^= i + 240;
    v9 = qword_1D6D68[LOBYTE(v8[0])]
       ^ qword_1D7568[BYTE1(v8[1])]
       ^ qword_1D7D68[BYTE2(v8[2])]
       ^ qword_1D8568[BYTE3(v8[3])]
       ^ qword_1D8D68[BYTE4(v8[4])]
       ^ qword_1D9568[BYTE5(v8[5])]
       ^ qword_1D9D68[BYTE6(v8[6])]
       ^ qword_1DA568[HIBYTE(HIDWORD(v8[11]))];
    v10 = qword_1D6D68[LOBYTE(v8[1])]
        ^ qword_1D7568[BYTE1(v8[2])]
        ^ qword_1D7D68[BYTE2(v8[3])]
        ^ qword_1D8568[BYTE3(v8[4])]
        ^ qword_1D8D68[BYTE4(v8[5])]
        ^ qword_1D9568[BYTE5(v8[6])]
        ^ qword_1D9D68[BYTE6(v8[7])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[12]))];
    v11 = qword_1D6D68[LOBYTE(v8[2])]
        ^ qword_1D7568[BYTE1(v8[3])]
        ^ qword_1D7D68[BYTE2(v8[4])]
        ^ qword_1D8568[BYTE3(v8[5])]
        ^ qword_1D8D68[BYTE4(v8[6])]
        ^ qword_1D9568[BYTE5(v8[7])]
        ^ qword_1D9D68[BYTE6(v8[8])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[13]))];
    v12 = qword_1D6D68[LOBYTE(v8[3])]
        ^ qword_1D7568[BYTE1(v8[4])]
        ^ qword_1D7D68[BYTE2(v8[5])]
        ^ qword_1D8568[BYTE3(v8[6])]
        ^ qword_1D8D68[BYTE4(v8[7])]
        ^ qword_1D9568[BYTE5(v8[8])]
        ^ qword_1D9D68[BYTE6(v8[9])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[14]))];
    v13 = qword_1D6D68[LOBYTE(v8[4])]
        ^ qword_1D7568[BYTE1(v8[5])]
        ^ qword_1D7D68[BYTE2(v8[6])]
        ^ qword_1D8568[BYTE3(v8[7])]
        ^ qword_1D8D68[BYTE4(v8[8])]
        ^ qword_1D9568[BYTE5(v8[9])]
        ^ qword_1D9D68[BYTE6(v8[10])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[15]))];
    v14 = qword_1D6D68[LOBYTE(v8[5])]
        ^ qword_1D7568[BYTE1(v8[6])]
        ^ qword_1D7D68[BYTE2(v8[7])]
        ^ qword_1D8568[BYTE3(v8[8])]
        ^ qword_1D8D68[BYTE4(v8[9])]
        ^ qword_1D9568[BYTE5(v8[10])]
        ^ qword_1D9D68[BYTE6(v8[11])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[0]))];
    v15 = qword_1D6D68[LOBYTE(v8[6])]
        ^ qword_1D7568[BYTE1(v8[7])]
        ^ qword_1D7D68[BYTE2(v8[8])]
        ^ qword_1D8568[BYTE3(v8[9])]
        ^ qword_1D8D68[BYTE4(v8[10])]
        ^ qword_1D9568[BYTE5(v8[11])]
        ^ qword_1D9D68[BYTE6(v8[12])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[1]))];
    v16 = qword_1D6D68[LOBYTE(v8[7])]
        ^ qword_1D7568[BYTE1(v8[8])]
        ^ qword_1D7D68[BYTE2(v8[9])]
        ^ qword_1D8568[BYTE3(v8[10])]
        ^ qword_1D8D68[BYTE4(v8[11])]
        ^ qword_1D9568[BYTE5(v8[12])]
        ^ qword_1D9D68[BYTE6(v8[13])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[2]))];
    v17 = qword_1D6D68[LOBYTE(v8[8])]
        ^ qword_1D7568[BYTE1(v8[9])]
        ^ qword_1D7D68[BYTE2(v8[10])]
        ^ qword_1D8568[BYTE3(v8[11])]
        ^ qword_1D8D68[BYTE4(v8[12])]
        ^ qword_1D9568[BYTE5(v8[13])]
        ^ qword_1D9D68[BYTE6(v8[14])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[3]))];
    v18 = qword_1D6D68[LOBYTE(v8[9])]
        ^ qword_1D7568[BYTE1(v8[10])]
        ^ qword_1D7D68[BYTE2(v8[11])]
        ^ qword_1D8568[BYTE3(v8[12])]
        ^ qword_1D8D68[BYTE4(v8[13])]
        ^ qword_1D9568[BYTE5(v8[14])]
        ^ qword_1D9D68[BYTE6(v8[15])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[4]))];
    v19 = qword_1D6D68[LOBYTE(v8[10])]
        ^ qword_1D7568[BYTE1(v8[11])]
        ^ qword_1D7D68[BYTE2(v8[12])]
        ^ qword_1D8568[BYTE3(v8[13])]
        ^ qword_1D8D68[BYTE4(v8[14])]
        ^ qword_1D9568[BYTE5(v8[15])]
        ^ qword_1D9D68[BYTE6(v8[0])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[5]))];
    v20 = qword_1D6D68[LOBYTE(v8[11])]
        ^ qword_1D7568[BYTE1(v8[12])]
        ^ qword_1D7D68[BYTE2(v8[13])]
        ^ qword_1D8568[BYTE3(v8[14])]
        ^ qword_1D8D68[BYTE4(v8[15])]
        ^ qword_1D9568[BYTE5(v8[0])]
        ^ qword_1D9D68[BYTE6(v8[1])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[6]))];
    v21 = qword_1D6D68[LOBYTE(v8[12])]
        ^ qword_1D7568[BYTE1(v8[13])]
        ^ qword_1D7D68[BYTE2(v8[14])]
        ^ qword_1D8568[BYTE3(v8[15])]
        ^ qword_1D8D68[BYTE4(v8[0])]
        ^ qword_1D9568[BYTE5(v8[1])]
        ^ qword_1D9D68[BYTE6(v8[2])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[7]))];
    v22 = qword_1D6D68[LOBYTE(v8[13])]
        ^ qword_1D7568[BYTE1(v8[14])]
        ^ qword_1D7D68[BYTE2(v8[15])]
        ^ qword_1D8568[BYTE3(v8[0])]
        ^ qword_1D8D68[BYTE4(v8[1])]
        ^ qword_1D9568[BYTE5(v8[2])]
        ^ qword_1D9D68[BYTE6(v8[3])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[8]))];
    v23 = qword_1D6D68[LOBYTE(v8[14])]
        ^ qword_1D7568[BYTE1(v8[15])]
        ^ qword_1D7D68[BYTE2(v8[0])]
        ^ qword_1D8568[BYTE3(v8[1])]
        ^ qword_1D8D68[BYTE4(v8[2])]
        ^ qword_1D9568[BYTE5(v8[3])]
        ^ qword_1D9D68[BYTE6(v8[4])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[9]))];
    v24 = qword_1D6D68[LOBYTE(v8[15])]
        ^ qword_1D7568[BYTE1(v8[0])]
        ^ qword_1D7D68[BYTE2(v8[1])]
        ^ qword_1D8568[BYTE3(v8[2])]
        ^ qword_1D8D68[BYTE4(v8[3])]
        ^ qword_1D9568[BYTE5(v8[4])]
        ^ qword_1D9D68[BYTE6(v8[5])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[10]))];
    v8[0] = v9 ^ (i + 1);
    v8[1] = v10 ^ (i + 17);
    v8[2] = v11 ^ (i + 33);
    v8[3] = v12 ^ (i + 49);
    v8[4] = v13 ^ (i + 65);
    v8[5] = v14 ^ (i + 81);
    v8[6] = v15 ^ (i + 97);
    v8[7] = v16 ^ (i + 113);
    v8[8] = v17 ^ (i + 129);
    v8[9] = v18 ^ (i + 145);
    v8[10] = v19 ^ (i + 161);
    v8[11] = v20 ^ (i + 177);
    v8[12] = v21 ^ (i + 193);
    v8[13] = v22 ^ (i + 209);
    v8[14] = v23 ^ (i + 225);
    v8[15] = v24 ^ (i + 241);
    v9 = qword_1D6D68[LOBYTE(v8[0])]
       ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v10 ^ (i + 17)) >> 8)]
       ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v11 ^ (i + 33)) >> 16)]
       ^ qword_1D8568[((unsigned int)v12 ^ (i + 49)) >> 24]
       ^ qword_1D8D68[BYTE4(v8[4])]
       ^ qword_1D9568[BYTE5(v8[5])]
       ^ qword_1D9D68[BYTE6(v8[6])]
       ^ qword_1DA568[HIBYTE(HIDWORD(v8[11]))];
    v10 = qword_1D6D68[LOBYTE(v8[1])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v11 ^ (i + 33)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v12 ^ (i + 49)) >> 16)]
        ^ qword_1D8568[((unsigned int)v13 ^ (i + 65)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[5])]
        ^ qword_1D9568[BYTE5(v8[6])]
        ^ qword_1D9D68[BYTE6(v8[7])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[12]))];
    v11 = qword_1D6D68[LOBYTE(v8[2])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v12 ^ (i + 49)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v13 ^ (i + 65)) >> 16)]
        ^ qword_1D8568[((unsigned int)v14 ^ (i + 81)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[6])]
        ^ qword_1D9568[BYTE5(v8[7])]
        ^ qword_1D9D68[BYTE6(v8[8])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[13]))];
    v12 = qword_1D6D68[LOBYTE(v8[3])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v13 ^ (i + 65)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v14 ^ (i + 81)) >> 16)]
        ^ qword_1D8568[((unsigned int)v15 ^ (i + 97)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[7])]
        ^ qword_1D9568[BYTE5(v8[8])]
        ^ qword_1D9D68[BYTE6(v8[9])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[14]))];
    v13 = qword_1D6D68[LOBYTE(v8[4])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v14 ^ (i + 81)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v15 ^ (i + 97)) >> 16)]
        ^ qword_1D8568[((unsigned int)v16 ^ (i + 113)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[8])]
        ^ qword_1D9568[BYTE5(v8[9])]
        ^ qword_1D9D68[BYTE6(v8[10])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[15]))];
    v14 = qword_1D6D68[LOBYTE(v8[5])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v15 ^ (i + 97)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v16 ^ (i + 113)) >> 16)]
        ^ qword_1D8568[((unsigned int)v17 ^ (i + 129)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[9])]
        ^ qword_1D9568[BYTE5(v8[10])]
        ^ qword_1D9D68[BYTE6(v8[11])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[0]))];
    v15 = qword_1D6D68[LOBYTE(v8[6])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v16 ^ (i + 113)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v17 ^ (i + 129)) >> 16)]
        ^ qword_1D8568[((unsigned int)v18 ^ (i + 145)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[10])]
        ^ qword_1D9568[BYTE5(v8[11])]
        ^ qword_1D9D68[BYTE6(v8[12])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[1]))];
    v16 = qword_1D6D68[LOBYTE(v8[7])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v17 ^ (i + 129)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v18 ^ (i + 145)) >> 16)]
        ^ qword_1D8568[((unsigned int)v19 ^ (i + 161)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[11])]
        ^ qword_1D9568[BYTE5(v8[12])]
        ^ qword_1D9D68[BYTE6(v8[13])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[2]))];
    v17 = qword_1D6D68[LOBYTE(v8[8])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v18 ^ (i + 145)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v19 ^ (i + 161)) >> 16)]
        ^ qword_1D8568[((unsigned int)v20 ^ (i + 177)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[12])]
        ^ qword_1D9568[BYTE5(v8[13])]
        ^ qword_1D9D68[BYTE6(v8[14])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[3]))];
    v18 = qword_1D6D68[LOBYTE(v8[9])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v19 ^ (i + 161)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v20 ^ (i + 177)) >> 16)]
        ^ qword_1D8568[((unsigned int)v21 ^ (i + 193)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[13])]
        ^ qword_1D9568[BYTE5(v8[14])]
        ^ qword_1D9D68[BYTE6(v8[15])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[4]))];
    v19 = qword_1D6D68[LOBYTE(v8[10])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v20 ^ (i + 177)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v21 ^ (i + 193)) >> 16)]
        ^ qword_1D8568[((unsigned int)v22 ^ (i + 209)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[14])]
        ^ qword_1D9568[BYTE5(v8[15])]
        ^ qword_1D9D68[BYTE6(v8[0])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[5]))];
    v20 = qword_1D6D68[LOBYTE(v8[11])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v21 ^ (i + 193)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v22 ^ (i + 209)) >> 16)]
        ^ qword_1D8568[((unsigned int)v23 ^ (i + 225)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[15])]
        ^ qword_1D9568[BYTE5(v8[0])]
        ^ qword_1D9D68[BYTE6(v8[1])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[6]))];
    v21 = qword_1D6D68[LOBYTE(v8[12])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v22 ^ (i + 209)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v23 ^ (i + 225)) >> 16)]
        ^ qword_1D8568[((unsigned int)v24 ^ (i + 241)) >> 24]
        ^ qword_1D8D68[BYTE4(v8[0])]
        ^ qword_1D9568[BYTE5(v8[1])]
        ^ qword_1D9D68[BYTE6(v8[2])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[7]))];
    v22 = qword_1D6D68[LOBYTE(v8[13])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v23 ^ (i + 225)) >> 8)]
        ^ qword_1D7D68[(unsigned __int8)(((unsigned int)v24 ^ (i + 241)) >> 16)]
        ^ qword_1D8568[BYTE3(v8[0])]
        ^ qword_1D8D68[BYTE4(v8[1])]
        ^ qword_1D9568[BYTE5(v8[2])]
        ^ qword_1D9D68[BYTE6(v8[3])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[8]))];
    v23 = qword_1D6D68[LOBYTE(v8[14])]
        ^ qword_1D7568[(unsigned __int8)((unsigned __int16)(v24 ^ (i + 241)) >> 8)]
        ^ qword_1D7D68[BYTE2(v8[0])]
        ^ qword_1D8568[BYTE3(v8[1])]
        ^ qword_1D8D68[BYTE4(v8[2])]
        ^ qword_1D9568[BYTE5(v8[3])]
        ^ qword_1D9D68[BYTE6(v8[4])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[9]))];
    v24 = qword_1D6D68[LOBYTE(v8[15])]
        ^ qword_1D7568[BYTE1(v8[0])]
        ^ qword_1D7D68[BYTE2(v8[1])]
        ^ qword_1D8568[BYTE3(v8[2])]
        ^ qword_1D8D68[BYTE4(v8[3])]
        ^ qword_1D9568[BYTE5(v8[4])]
        ^ qword_1D9D68[BYTE6(v8[5])]
        ^ qword_1DA568[HIBYTE(HIDWORD(v8[10]))];
    v8[0] = v9;
    v8[1] = v10;
    v8[2] = v11;
    v8[3] = v12;
    v8[4] = v13;
    v8[5] = v14;
    v8[6] = v15;
    v8[7] = v16;
    v8[8] = v17;
    v8[9] = v18;
    v8[10] = v19;
    v8[11] = v20;
    v8[12] = v21;
    v8[13] = v22;
    v8[14] = v23;
    v8[15] = v24;
  }
  for ( j = 0; j <= 0xF; ++j )
    dest[j] ^= v8[j];
  for ( k = 0; k <= 7; ++k )
    sub_172158((int)&v26[8 * k], (int)&v26[8 * k], dest[k + 8], HIDWORD(dest[k + 8]));
  memcpy(a4, &v26[64 - n], n);
  return sub_179B38((_DWORD *)a1, 8 * n);
}
// 1D6D68: using guessed type _QWORD qword_1D6D68[256];
// 1D7568: using guessed type _QWORD qword_1D7568[256];
// 1D7D68: using guessed type _QWORD qword_1D7D68[256];
// 1D8568: using guessed type _QWORD qword_1D8568[256];
// 1D8D68: using guessed type _QWORD qword_1D8D68[256];
// 1D9568: using guessed type _QWORD qword_1D9568[256];
// 1D9D68: using guessed type _QWORD qword_1D9D68[256];
// 1DA568: using guessed type _QWORD qword_1DA568[256];

//----- (00188FF0) --------------------------------------------------------
_DWORD *__fastcall sph_groestl224_init(_DWORD *a1)
{
  return sub_172230(a1, 224);
}

//----- (00189008) --------------------------------------------------------
void *__fastcall sph_groestl224(int a1, char *a2, size_t a3)
{
  return sub_1722BC(a1, a2, a3);
}

//----- (00189028) --------------------------------------------------------
_DWORD *__fastcall sph_groestl224_close(int a1, void *a2)
{
  return sub_17738C(a1, 0, 0, a2, 0x1Cu);
}

//----- (0018904C) --------------------------------------------------------
_DWORD *__fastcall sph_groestl224_addbits_and_close(int a1, char a2, char a3, void *a4)
{
  return sub_17738C(a1, a2, a3, a4, 0x1Cu);
}

//----- (00189074) --------------------------------------------------------
_DWORD *__fastcall sph_groestl256_init(_DWORD *a1)
{
  return sub_172230(a1, 256);
}

//----- (00189090) --------------------------------------------------------
void *__fastcall sph_groestl256(int a1, char *a2, size_t a3)
{
  return sub_1722BC(a1, a2, a3);
}

//----- (001890B0) --------------------------------------------------------
_DWORD *__fastcall sph_groestl256_close(int a1, void *a2)
{
  return sub_17738C(a1, 0, 0, a2, 0x20u);
}

//----- (001890D4) --------------------------------------------------------
_DWORD *__fastcall sph_groestl256_addbits_and_close(int a1, char a2, char a3, void *a4)
{
  return sub_17738C(a1, a2, a3, a4, 0x20u);
}

//----- (001890FC) --------------------------------------------------------
_DWORD *__fastcall sph_groestl384_init(_DWORD *a1)
{
  return sub_179B38(a1, 384);
}

//----- (00189118) --------------------------------------------------------
void *__fastcall sph_groestl384(int a1, char *a2, size_t a3)
{
  return sub_179BCC(a1, a2, a3);
}

//----- (00189138) --------------------------------------------------------
_DWORD *__fastcall sph_groestl384_close(int a1, void *a2)
{
  return sub_183F74(a1, 0, 0, a2, 0x30u);
}

//----- (0018915C) --------------------------------------------------------
_DWORD *__fastcall sph_groestl384_addbits_and_close(int a1, char a2, char a3, void *a4)
{
  return sub_183F74(a1, a2, a3, a4, 0x30u);
}

//----- (00189184) --------------------------------------------------------
_DWORD *__fastcall sph_groestl512_init(_DWORD *a1)
{
  return sub_179B38(a1, 512);
}

//----- (001891A0) --------------------------------------------------------
void *__fastcall sph_groestl512(int a1, char *a2, size_t a3)
{
  return sub_179BCC(a1, a2, a3);
}

//----- (001891C0) --------------------------------------------------------
_DWORD *__fastcall sph_groestl512_close(int a1, void *a2)
{
  return sub_183F74(a1, 0, 0, a2, 0x40u);
}

//----- (001891E4) --------------------------------------------------------
_DWORD *__fastcall sph_groestl512_addbits_and_close(int a1, char a2, char a3, void *a4)
{
  return sub_183F74(a1, a2, a3, a4, 0x40u);
}

//----- (0018920C) --------------------------------------------------------
int __fastcall sub_18920C(int result, unsigned int a2)
{
  *(_BYTE *)result = a2;
  *(_WORD *)(result + 1) = a2 >> 8;
  *(_BYTE *)(result + 3) = HIBYTE(a2);
  return result;
}

//----- (00189250) --------------------------------------------------------
int __fastcall sub_189250(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00189268) --------------------------------------------------------
unsigned int __fastcall sub_189268(_DWORD *a1, int a2)
{
  unsigned int result; // r0
  unsigned int v5; // [sp+8h] [bp+8h]
  unsigned int v6; // [sp+Ch] [bp+Ch]
  unsigned int v7; // [sp+10h] [bp+10h]
  unsigned int v8; // [sp+14h] [bp+14h]
  unsigned int v9; // [sp+18h] [bp+18h]
  unsigned int v10; // [sp+1Ch] [bp+1Ch]
  unsigned int v11; // [sp+20h] [bp+20h]
  unsigned int v12; // [sp+24h] [bp+24h]
  unsigned int v13; // [sp+38h] [bp+38h]
  unsigned int v14; // [sp+3Ch] [bp+3Ch]
  unsigned int v15; // [sp+40h] [bp+40h]
  unsigned int v16; // [sp+44h] [bp+44h]
  unsigned int v17; // [sp+48h] [bp+48h]
  unsigned int v18; // [sp+4Ch] [bp+4Ch]
  unsigned int v19; // [sp+50h] [bp+50h]
  unsigned int v20; // [sp+54h] [bp+54h]
  int v21; // [sp+58h] [bp+58h]
  unsigned int v22; // [sp+60h] [bp+60h]
  unsigned int v23; // [sp+64h] [bp+64h]
  unsigned int v24; // [sp+68h] [bp+68h]
  unsigned int v25; // [sp+6Ch] [bp+6Ch]
  int v26; // [sp+7Ch] [bp+7Ch]
  unsigned int v27; // [sp+84h] [bp+84h]
  unsigned int v28; // [sp+88h] [bp+88h]
  unsigned int v29; // [sp+8Ch] [bp+8Ch]
  unsigned int v30; // [sp+90h] [bp+90h]
  unsigned int v31; // [sp+94h] [bp+94h]
  unsigned int v32; // [sp+98h] [bp+98h]
  unsigned int v33; // [sp+9Ch] [bp+9Ch]
  int v34; // [sp+A0h] [bp+A0h]
  unsigned int v35; // [sp+A8h] [bp+A8h]
  unsigned int v36; // [sp+ACh] [bp+ACh]
  unsigned int v37; // [sp+B0h] [bp+B0h]
  unsigned int v38; // [sp+B4h] [bp+B4h]
  unsigned int v39; // [sp+B8h] [bp+B8h]
  unsigned int v40; // [sp+BCh] [bp+BCh]
  unsigned int v41; // [sp+C0h] [bp+C0h]
  int v42; // [sp+C4h] [bp+C4h]
  unsigned int v43; // [sp+CCh] [bp+CCh]
  unsigned int v44; // [sp+D0h] [bp+D0h]
  unsigned int v45; // [sp+D4h] [bp+D4h]
  unsigned int v46; // [sp+E8h] [bp+E8h]
  unsigned int v47; // [sp+ECh] [bp+ECh]
  unsigned int v48; // [sp+F0h] [bp+F0h]
  unsigned int v49; // [sp+F4h] [bp+F4h]
  unsigned int v50; // [sp+F8h] [bp+F8h]
  unsigned int v51; // [sp+FCh] [bp+FCh]
  unsigned int v52; // [sp+100h] [bp+100h]
  unsigned int v53; // [sp+104h] [bp+104h]
  unsigned int v54; // [sp+118h] [bp+118h]
  unsigned int v55; // [sp+11Ch] [bp+11Ch]
  unsigned int v56; // [sp+120h] [bp+120h]
  unsigned int v57; // [sp+124h] [bp+124h]
  int v58; // [sp+128h] [bp+128h]
  unsigned int v59; // [sp+130h] [bp+130h]
  unsigned int v60; // [sp+134h] [bp+134h]
  unsigned int v61; // [sp+138h] [bp+138h]
  unsigned int v62; // [sp+13Ch] [bp+13Ch]
  unsigned int v63; // [sp+140h] [bp+140h]
  unsigned int v64; // [sp+144h] [bp+144h]
  unsigned int v65; // [sp+148h] [bp+148h]
  int v66; // [sp+14Ch] [bp+14Ch]
  unsigned int v67; // [sp+154h] [bp+154h]
  unsigned int v68; // [sp+158h] [bp+158h]
  unsigned int v69; // [sp+15Ch] [bp+15Ch]
  int v70; // [sp+170h] [bp+170h]
  unsigned int v71; // [sp+178h] [bp+178h]
  unsigned int v72; // [sp+17Ch] [bp+17Ch]
  unsigned int v73; // [sp+180h] [bp+180h]
  unsigned int v74; // [sp+184h] [bp+184h]
  unsigned int v75; // [sp+188h] [bp+188h]
  unsigned int v76; // [sp+18Ch] [bp+18Ch]
  unsigned int v77; // [sp+190h] [bp+190h]
  int v78; // [sp+194h] [bp+194h]
  unsigned int v79; // [sp+19Ch] [bp+19Ch]
  unsigned int v80; // [sp+1A0h] [bp+1A0h]
  unsigned int v81; // [sp+1A4h] [bp+1A4h]
  unsigned int v82; // [sp+1A8h] [bp+1A8h]
  unsigned int v83; // [sp+1ACh] [bp+1ACh]
  unsigned int v84; // [sp+1B0h] [bp+1B0h]
  unsigned int v85; // [sp+1B4h] [bp+1B4h]
  unsigned int v86; // [sp+1C8h] [bp+1C8h]
  unsigned int v87; // [sp+1CCh] [bp+1CCh]
  unsigned int v88; // [sp+1D0h] [bp+1D0h]
  unsigned int v89; // [sp+1D4h] [bp+1D4h]
  unsigned int v90; // [sp+1D8h] [bp+1D8h]
  unsigned int v91; // [sp+1DCh] [bp+1DCh]
  unsigned int v92; // [sp+1E0h] [bp+1E0h]
  unsigned int v93; // [sp+1E4h] [bp+1E4h]
  int v94; // [sp+1F8h] [bp+1F8h]
  unsigned int v95; // [sp+200h] [bp+200h]
  unsigned int v96; // [sp+204h] [bp+204h]
  unsigned int v97; // [sp+208h] [bp+208h]
  unsigned int v98; // [sp+20Ch] [bp+20Ch]
  unsigned int v99; // [sp+210h] [bp+210h]
  unsigned int v100; // [sp+214h] [bp+214h]
  unsigned int v101; // [sp+218h] [bp+218h]
  int v102; // [sp+21Ch] [bp+21Ch]
  unsigned int v103; // [sp+224h] [bp+224h]
  unsigned int v104; // [sp+228h] [bp+228h]
  unsigned int v105; // [sp+22Ch] [bp+22Ch]
  unsigned int v106; // [sp+230h] [bp+230h]
  unsigned int v107; // [sp+234h] [bp+234h]
  unsigned int v108; // [sp+238h] [bp+238h]
  unsigned int v109; // [sp+23Ch] [bp+23Ch]
  int v110; // [sp+240h] [bp+240h]
  unsigned int v111; // [sp+248h] [bp+248h]
  unsigned int v112; // [sp+24Ch] [bp+24Ch]
  unsigned int v113; // [sp+250h] [bp+250h]
  unsigned int v114; // [sp+254h] [bp+254h]
  int v115; // [sp+264h] [bp+264h]
  unsigned int v116; // [sp+26Ch] [bp+26Ch]
  unsigned int v117; // [sp+270h] [bp+270h]
  unsigned int v118; // [sp+274h] [bp+274h]
  unsigned int v119; // [sp+278h] [bp+278h]
  unsigned int v120; // [sp+27Ch] [bp+27Ch]
  unsigned int v121; // [sp+280h] [bp+280h]
  unsigned int v122; // [sp+284h] [bp+284h]
  unsigned int v123; // [sp+288h] [bp+288h]
  unsigned int v124; // [sp+28Ch] [bp+28Ch]
  unsigned int v125; // [sp+290h] [bp+290h]
  unsigned int v126; // [sp+294h] [bp+294h]
  unsigned int v127; // [sp+2A8h] [bp+2A8h]
  unsigned int v128; // [sp+2ACh] [bp+2ACh]
  unsigned int v129; // [sp+2B0h] [bp+2B0h]
  unsigned int v130; // [sp+2B4h] [bp+2B4h]
  unsigned int v131; // [sp+2B8h] [bp+2B8h]
  unsigned int v132; // [sp+2BCh] [bp+2BCh]
  unsigned int v133; // [sp+2C0h] [bp+2C0h]
  unsigned int v134; // [sp+2C4h] [bp+2C4h]
  int v135; // [sp+2C8h] [bp+2C8h]
  unsigned int v136; // [sp+2D4h] [bp+2D4h]
  unsigned int v137; // [sp+2D8h] [bp+2D8h]
  unsigned int v138; // [sp+2DCh] [bp+2DCh]
  int v139; // [sp+2ECh] [bp+2ECh]
  unsigned int v140; // [sp+2F4h] [bp+2F4h]
  unsigned int v141; // [sp+2F8h] [bp+2F8h]
  unsigned int v142; // [sp+2FCh] [bp+2FCh]
  unsigned int v143; // [sp+300h] [bp+300h]
  unsigned int v144; // [sp+304h] [bp+304h]
  unsigned int v145; // [sp+308h] [bp+308h]
  int v146; // [sp+310h] [bp+310h]
  unsigned int v147; // [sp+318h] [bp+318h]
  unsigned int v148; // [sp+31Ch] [bp+31Ch]
  unsigned int v149; // [sp+320h] [bp+320h]
  unsigned int v150; // [sp+324h] [bp+324h]
  unsigned int v151; // [sp+328h] [bp+328h]
  unsigned int v152; // [sp+330h] [bp+330h]
  int v153; // [sp+334h] [bp+334h]
  unsigned int v154; // [sp+33Ch] [bp+33Ch]
  unsigned int v155; // [sp+340h] [bp+340h]
  unsigned int v156; // [sp+344h] [bp+344h]
  int v157; // [sp+358h] [bp+358h]
  int v158; // [sp+358h] [bp+358h]
  int v159; // [sp+358h] [bp+358h]
  int v160; // [sp+358h] [bp+358h]
  int v161; // [sp+358h] [bp+358h]
  int v162; // [sp+358h] [bp+358h]
  int v163; // [sp+358h] [bp+358h]
  int v164; // [sp+358h] [bp+358h]
  int v165; // [sp+358h] [bp+358h]
  int v166; // [sp+358h] [bp+358h]
  int v167; // [sp+358h] [bp+358h]
  int v168; // [sp+35Ch] [bp+35Ch]
  int v169; // [sp+35Ch] [bp+35Ch]
  int v170; // [sp+35Ch] [bp+35Ch]
  int v171; // [sp+35Ch] [bp+35Ch]
  int v172; // [sp+35Ch] [bp+35Ch]
  int v173; // [sp+35Ch] [bp+35Ch]
  int v174; // [sp+35Ch] [bp+35Ch]
  int v175; // [sp+35Ch] [bp+35Ch]
  int v176; // [sp+35Ch] [bp+35Ch]
  int v177; // [sp+35Ch] [bp+35Ch]
  int v178; // [sp+35Ch] [bp+35Ch]
  int v179; // [sp+35Ch] [bp+35Ch]
  int v180; // [sp+360h] [bp+360h]
  int v181; // [sp+360h] [bp+360h]
  int v182; // [sp+360h] [bp+360h]
  int v183; // [sp+360h] [bp+360h]
  int v184; // [sp+360h] [bp+360h]
  int v185; // [sp+360h] [bp+360h]
  int v186; // [sp+360h] [bp+360h]
  int v187; // [sp+360h] [bp+360h]
  int v188; // [sp+360h] [bp+360h]
  int v189; // [sp+360h] [bp+360h]
  int v190; // [sp+360h] [bp+360h]
  int v191; // [sp+360h] [bp+360h]
  unsigned int v192; // [sp+364h] [bp+364h]
  int v193; // [sp+364h] [bp+364h]
  unsigned int v194; // [sp+364h] [bp+364h]
  int v195; // [sp+364h] [bp+364h]
  unsigned int v196; // [sp+364h] [bp+364h]
  int v197; // [sp+364h] [bp+364h]
  unsigned int v198; // [sp+364h] [bp+364h]
  int v199; // [sp+364h] [bp+364h]
  int v200; // [sp+364h] [bp+364h]
  int v201; // [sp+378h] [bp+378h]
  int v202; // [sp+378h] [bp+378h]
  int v203; // [sp+378h] [bp+378h]
  int v204; // [sp+378h] [bp+378h]
  int v205; // [sp+378h] [bp+378h]
  int v206; // [sp+378h] [bp+378h]
  int v207; // [sp+378h] [bp+378h]
  int v208; // [sp+378h] [bp+378h]
  int v209; // [sp+378h] [bp+378h]
  int v210; // [sp+378h] [bp+378h]
  int v211; // [sp+378h] [bp+378h]
  int v212; // [sp+378h] [bp+378h]
  int v213; // [sp+378h] [bp+378h]
  int v214; // [sp+37Ch] [bp+37Ch]
  int v215; // [sp+37Ch] [bp+37Ch]
  int v216; // [sp+37Ch] [bp+37Ch]
  int v217; // [sp+37Ch] [bp+37Ch]
  int v218; // [sp+37Ch] [bp+37Ch]
  int v219; // [sp+37Ch] [bp+37Ch]
  int v220; // [sp+37Ch] [bp+37Ch]
  int v221; // [sp+37Ch] [bp+37Ch]
  int v222; // [sp+37Ch] [bp+37Ch]
  int v223; // [sp+37Ch] [bp+37Ch]
  int v224; // [sp+37Ch] [bp+37Ch]
  int v225; // [sp+37Ch] [bp+37Ch]
  int v226; // [sp+37Ch] [bp+37Ch]
  int v227; // [sp+380h] [bp+380h]
  int v228; // [sp+380h] [bp+380h]
  int v229; // [sp+380h] [bp+380h]
  int v230; // [sp+380h] [bp+380h]
  int v231; // [sp+380h] [bp+380h]
  int v232; // [sp+380h] [bp+380h]
  int v233; // [sp+380h] [bp+380h]
  int v234; // [sp+380h] [bp+380h]
  int v235; // [sp+380h] [bp+380h]
  int v236; // [sp+380h] [bp+380h]
  int v237; // [sp+380h] [bp+380h]
  int v238; // [sp+380h] [bp+380h]
  int v239; // [sp+380h] [bp+380h]
  unsigned int v240; // [sp+384h] [bp+384h]
  int v241; // [sp+384h] [bp+384h]
  unsigned int v242; // [sp+384h] [bp+384h]
  int v243; // [sp+384h] [bp+384h]
  unsigned int v244; // [sp+384h] [bp+384h]
  int v245; // [sp+384h] [bp+384h]
  unsigned int v246; // [sp+384h] [bp+384h]
  int v247; // [sp+384h] [bp+384h]
  int v248; // [sp+384h] [bp+384h]
  unsigned int v249; // [sp+38Ch] [bp+38Ch]
  unsigned int v250; // [sp+390h] [bp+390h]
  unsigned int v251; // [sp+394h] [bp+394h]
  int v252; // [sp+398h] [bp+398h]
  int v253; // [sp+398h] [bp+398h]
  int v254; // [sp+398h] [bp+398h]
  int v255; // [sp+398h] [bp+398h]
  int v256; // [sp+398h] [bp+398h]
  int v257; // [sp+398h] [bp+398h]
  int v258; // [sp+398h] [bp+398h]
  int v259; // [sp+398h] [bp+398h]
  int v260; // [sp+398h] [bp+398h]
  int v261; // [sp+398h] [bp+398h]
  int v262; // [sp+398h] [bp+398h]
  int v263; // [sp+398h] [bp+398h]
  int v264; // [sp+398h] [bp+398h]
  int v265; // [sp+39Ch] [bp+39Ch]
  int v266; // [sp+39Ch] [bp+39Ch]
  int v267; // [sp+39Ch] [bp+39Ch]
  int v268; // [sp+39Ch] [bp+39Ch]
  int v269; // [sp+39Ch] [bp+39Ch]
  int v270; // [sp+39Ch] [bp+39Ch]
  int v271; // [sp+39Ch] [bp+39Ch]
  int v272; // [sp+39Ch] [bp+39Ch]
  int v273; // [sp+39Ch] [bp+39Ch]
  int v274; // [sp+39Ch] [bp+39Ch]
  int v275; // [sp+39Ch] [bp+39Ch]
  int v276; // [sp+39Ch] [bp+39Ch]
  int v277; // [sp+39Ch] [bp+39Ch]
  int v278; // [sp+3A0h] [bp+3A0h]
  int v279; // [sp+3A0h] [bp+3A0h]
  int v280; // [sp+3A0h] [bp+3A0h]
  int v281; // [sp+3A0h] [bp+3A0h]
  int v282; // [sp+3A0h] [bp+3A0h]
  int v283; // [sp+3A0h] [bp+3A0h]
  int v284; // [sp+3A0h] [bp+3A0h]
  int v285; // [sp+3A0h] [bp+3A0h]
  int v286; // [sp+3A0h] [bp+3A0h]
  int v287; // [sp+3A0h] [bp+3A0h]
  int v288; // [sp+3A0h] [bp+3A0h]
  int v289; // [sp+3A0h] [bp+3A0h]
  int v290; // [sp+3A0h] [bp+3A0h]
  unsigned int v291; // [sp+3A4h] [bp+3A4h]
  int v292; // [sp+3A4h] [bp+3A4h]
  unsigned int v293; // [sp+3A4h] [bp+3A4h]
  int v294; // [sp+3A4h] [bp+3A4h]
  unsigned int v295; // [sp+3A4h] [bp+3A4h]
  int v296; // [sp+3A4h] [bp+3A4h]
  unsigned int v297; // [sp+3A4h] [bp+3A4h]
  int v298; // [sp+3A4h] [bp+3A4h]
  int v299; // [sp+3A4h] [bp+3A4h]
  int v300; // [sp+3B8h] [bp+3B8h]
  int v301; // [sp+3B8h] [bp+3B8h]
  int v302; // [sp+3BCh] [bp+3BCh]
  int v303; // [sp+3BCh] [bp+3BCh]
  int v304; // [sp+3BCh] [bp+3BCh]
  int v305; // [sp+3BCh] [bp+3BCh]
  int v306; // [sp+3BCh] [bp+3BCh]
  int v307; // [sp+3BCh] [bp+3BCh]
  int v308; // [sp+3BCh] [bp+3BCh]
  int v309; // [sp+3BCh] [bp+3BCh]
  int v310; // [sp+3BCh] [bp+3BCh]
  int v311; // [sp+3BCh] [bp+3BCh]
  int v312; // [sp+3BCh] [bp+3BCh]
  int v313; // [sp+3BCh] [bp+3BCh]
  int v314; // [sp+3C0h] [bp+3C0h]
  int v315; // [sp+3C0h] [bp+3C0h]
  unsigned int v316; // [sp+3C0h] [bp+3C0h]
  int v317; // [sp+3C4h] [bp+3C4h]
  int v318; // [sp+3C4h] [bp+3C4h]
  int v319; // [sp+3C4h] [bp+3C4h]
  int v320; // [sp+3C4h] [bp+3C4h]
  int v321; // [sp+3C4h] [bp+3C4h]
  int v322; // [sp+3C4h] [bp+3C4h]
  int v323; // [sp+3C4h] [bp+3C4h]
  int v324; // [sp+3C4h] [bp+3C4h]
  int v325; // [sp+3C4h] [bp+3C4h]
  int v326; // [sp+3C4h] [bp+3C4h]
  int v327; // [sp+3C4h] [bp+3C4h]
  int v328; // [sp+3C4h] [bp+3C4h]
  int v329; // [sp+3C4h] [bp+3C4h]
  int v330; // [sp+3C8h] [bp+3C8h]
  int v331; // [sp+3C8h] [bp+3C8h]
  unsigned int v332; // [sp+3C8h] [bp+3C8h]
  int v333; // [sp+3C8h] [bp+3C8h]
  int v334; // [sp+3CCh] [bp+3CCh]
  int v335; // [sp+3CCh] [bp+3CCh]
  int v336; // [sp+3CCh] [bp+3CCh]
  int v337; // [sp+3CCh] [bp+3CCh]
  int v338; // [sp+3CCh] [bp+3CCh]
  int v339; // [sp+3CCh] [bp+3CCh]
  int v340; // [sp+3CCh] [bp+3CCh]
  int v341; // [sp+3CCh] [bp+3CCh]
  int v342; // [sp+3CCh] [bp+3CCh]
  int v343; // [sp+3CCh] [bp+3CCh]
  int v344; // [sp+3CCh] [bp+3CCh]
  int v345; // [sp+3CCh] [bp+3CCh]
  int v346; // [sp+3CCh] [bp+3CCh]
  int v347; // [sp+3D0h] [bp+3D0h]
  int v348; // [sp+3D0h] [bp+3D0h]
  unsigned int v349; // [sp+3D0h] [bp+3D0h]
  int v350; // [sp+3D0h] [bp+3D0h]
  int v351; // [sp+3D0h] [bp+3D0h]
  unsigned int v352; // [sp+3D4h] [bp+3D4h]
  int v353; // [sp+3D4h] [bp+3D4h]
  unsigned int v354; // [sp+3D4h] [bp+3D4h]
  int v355; // [sp+3D4h] [bp+3D4h]
  unsigned int v356; // [sp+3D4h] [bp+3D4h]
  int v357; // [sp+3D4h] [bp+3D4h]
  unsigned int v358; // [sp+3D4h] [bp+3D4h]
  int v359; // [sp+3D4h] [bp+3D4h]
  int v360; // [sp+3D4h] [bp+3D4h]
  unsigned int v361; // [sp+3D8h] [bp+3D8h]
  int v362; // [sp+3D8h] [bp+3D8h]
  int v363; // [sp+3D8h] [bp+3D8h]
  int v364; // [sp+3D8h] [bp+3D8h]
  int v365; // [sp+3D8h] [bp+3D8h]
  int v366; // [sp+3D8h] [bp+3D8h]
  int v367; // [sp+3D8h] [bp+3D8h]
  unsigned int v368; // [sp+3DCh] [bp+3DCh]
  int v369; // [sp+3DCh] [bp+3DCh]
  int v370; // [sp+3DCh] [bp+3DCh]
  int v371; // [sp+3DCh] [bp+3DCh]
  int v372; // [sp+3DCh] [bp+3DCh]
  int v373; // [sp+3DCh] [bp+3DCh]
  int v374; // [sp+3DCh] [bp+3DCh]
  unsigned int v375; // [sp+3E0h] [bp+3E0h]
  int v376; // [sp+3E0h] [bp+3E0h]
  int v377; // [sp+3E0h] [bp+3E0h]
  int v378; // [sp+3E0h] [bp+3E0h]
  int v379; // [sp+3E0h] [bp+3E0h]
  int v380; // [sp+3E0h] [bp+3E0h]
  int v381; // [sp+3E0h] [bp+3E0h]
  int v382; // [sp+3E4h] [bp+3E4h]
  int v383; // [sp+3E4h] [bp+3E4h]
  int v384; // [sp+3E4h] [bp+3E4h]
  int v385; // [sp+3E4h] [bp+3E4h]
  int v386; // [sp+3E4h] [bp+3E4h]
  int v387; // [sp+3E4h] [bp+3E4h]
  int v388; // [sp+3E4h] [bp+3E4h]
  int v389; // [sp+3E8h] [bp+3E8h]
  int v390; // [sp+3E8h] [bp+3E8h]
  int v391; // [sp+3E8h] [bp+3E8h]
  int v392; // [sp+3E8h] [bp+3E8h]
  int v393; // [sp+3E8h] [bp+3E8h]
  int v394; // [sp+3E8h] [bp+3E8h]
  int v395; // [sp+3E8h] [bp+3E8h]
  int v396; // [sp+3ECh] [bp+3ECh]
  int v397; // [sp+3ECh] [bp+3ECh]
  int v398; // [sp+3ECh] [bp+3ECh]
  int v399; // [sp+3ECh] [bp+3ECh]
  int v400; // [sp+3ECh] [bp+3ECh]
  int v401; // [sp+3ECh] [bp+3ECh]
  int v402; // [sp+3ECh] [bp+3ECh]
  int v403; // [sp+3F0h] [bp+3F0h]
  int v404; // [sp+3F0h] [bp+3F0h]
  int v405; // [sp+3F0h] [bp+3F0h]
  int v406; // [sp+3F0h] [bp+3F0h]
  int v407; // [sp+3F0h] [bp+3F0h]
  int v408; // [sp+3F0h] [bp+3F0h]
  int v409; // [sp+3F0h] [bp+3F0h]
  int v410; // [sp+3F4h] [bp+3F4h]
  int v411; // [sp+3F4h] [bp+3F4h]
  int v412; // [sp+3F4h] [bp+3F4h]
  int v413; // [sp+3F4h] [bp+3F4h]
  int v414; // [sp+3F4h] [bp+3F4h]
  int v415; // [sp+3F4h] [bp+3F4h]
  int v416; // [sp+3F4h] [bp+3F4h]

  v410 = a1[17];
  v403 = a1[18];
  v396 = a1[19];
  v389 = a1[20];
  v382 = a1[21];
  v375 = a1[22];
  v368 = a1[23];
  v361 = a1[24];
  v352 = sub_189250(a2);
  v334 = sub_189250(a2 + 4);
  v317 = sub_189250(a2 + 8);
  v302 = sub_189250(a2 + 12);
  v347 = dword_1DB968[(v302 ^ v361) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v352 ^ v382)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v334 ^ v375) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v317 ^ v368) >> 16)];
  v330 = dword_1DB968[(v352 ^ v382) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v334 ^ v375)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v317 ^ v368) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v302 ^ v361) >> 16)];
  v314 = dword_1DB968[(v334 ^ v375) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v317 ^ v368)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v302 ^ v361) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v352 ^ v382) >> 16)];
  v300 = dword_1DB968[(v317 ^ v368) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v302 ^ v361)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v352 ^ v382) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v334 ^ v375) >> 16)];
  v291 = sub_189250(a2 + 16);
  v278 = sub_189250(a2 + 20);
  v265 = sub_189250(a2 + 24);
  v252 = sub_189250(a2 + 28);
  v251 = v291 ^ v347;
  v250 = v278 ^ v330;
  v249 = v265 ^ v314;
  v348 = dword_1DB968[(v252 ^ (unsigned int)v300) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v291 ^ v347)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v278 ^ v330) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v265 ^ (unsigned int)v314) >> 16)];
  v331 = dword_1DB968[HIBYTE(v251)]
       ^ dword_1DAD68[(unsigned __int8)(v278 ^ v330)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v265 ^ v314) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v252 ^ (unsigned int)v300) >> 16)];
  v315 = dword_1DB968[HIBYTE(v250)]
       ^ dword_1DAD68[(unsigned __int8)(v265 ^ v314)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v252 ^ v300) >> 8)]
       ^ dword_1DB568[BYTE2(v251)];
  v301 = dword_1DB968[HIBYTE(v249)]
       ^ dword_1DAD68[(unsigned __int8)(v252 ^ v300)]
       ^ dword_1DB168[BYTE1(v251)]
       ^ dword_1DB568[BYTE2(v250)];
  v240 = sub_189250(a2 + 32);
  v349 = v240 ^ v348;
  v227 = sub_189250(a2 + 36);
  v332 = v227 ^ v331;
  v214 = sub_189250(a2 + 40);
  v316 = v214 ^ v315;
  v201 = sub_189250(a2 + 44);
  v411 = dword_1DB968[(v201 ^ (unsigned int)v301) >> 24]
       ^ dword_1DAD68[(unsigned __int8)v349]
       ^ dword_1DB168[BYTE1(v332)]
       ^ dword_1DB568[BYTE2(v316)]
       ^ v410;
  v404 = dword_1DB968[HIBYTE(v349)]
       ^ dword_1DAD68[(unsigned __int8)v332]
       ^ dword_1DB168[BYTE1(v316)]
       ^ dword_1DB568[(unsigned __int8)((v201 ^ (unsigned int)v301) >> 16)]
       ^ v403;
  v397 = dword_1DB968[HIBYTE(v332)]
       ^ dword_1DAD68[(unsigned __int8)v316]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v201 ^ v301) >> 8)]
       ^ dword_1DB568[BYTE2(v349)]
       ^ v396;
  v390 = dword_1DB968[HIBYTE(v316)]
       ^ dword_1DAD68[(unsigned __int8)(v201 ^ v301)]
       ^ dword_1DB168[BYTE1(v349)]
       ^ dword_1DB568[BYTE2(v332)]
       ^ v389;
  v192 = sub_189250(a2 + 48);
  v180 = sub_189250(a2 + 52);
  v168 = sub_189250(a2 + 56);
  result = sub_189250(a2 + 60);
  v350 = dword_1DB968[(result ^ v390) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v192 ^ v411)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v180 ^ v404) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v168 ^ (unsigned int)v397) >> 16)];
  v333 = dword_1DB968[(v192 ^ v411) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v180 ^ v404)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v168 ^ v397) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((result ^ v390) >> 16)];
  v156 = v334;
  v155 = v317;
  v154 = v302;
  v335 = dword_1DB968[HIBYTE(v352)]
       ^ dword_1DAD68[(unsigned __int8)v334]
       ^ dword_1DB168[BYTE1(v317)]
       ^ dword_1DB568[BYTE2(v302)];
  v318 = dword_1DB968[HIBYTE(v156)]
       ^ dword_1DAD68[(unsigned __int8)v317]
       ^ dword_1DB168[BYTE1(v302)]
       ^ dword_1DB568[BYTE2(v352)];
  v303 = dword_1DB968[HIBYTE(v155)]
       ^ dword_1DAD68[(unsigned __int8)v302]
       ^ dword_1DB168[BYTE1(v352)]
       ^ dword_1DB568[BYTE2(v156)];
  v153 = dword_1DB968[HIBYTE(v154)]
       ^ dword_1DAD68[(unsigned __int8)v352]
       ^ dword_1DB168[BYTE1(v156)]
       ^ dword_1DB568[BYTE2(v155)];
  v353 = v192 ^ a1[25] ^ v335;
  v336 = v180 ^ ~a1[26] ^ v318;
  v319 = v168 ^ v303;
  v152 = v353 ^ v350;
  v151 = v168
       ^ v303
       ^ dword_1DB968[(v180 ^ (unsigned int)v404) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v168 ^ v397)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(result ^ v390) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v192 ^ v411) >> 16)];
  v150 = result
       ^ v153
       ^ dword_1DB968[(v168 ^ (unsigned int)v397) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(result ^ v390)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v192 ^ v411) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v180 ^ (unsigned int)v404) >> 16)];
  v351 = dword_1DB968[HIBYTE(v150)]
       ^ dword_1DAD68[(unsigned __int8)(v353 ^ v350)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v336 ^ v333) >> 8)]
       ^ dword_1DB568[BYTE2(v151)];
  v149 = v278;
  v148 = v265;
  v147 = v252;
  v279 = dword_1DB968[HIBYTE(v291)]
       ^ dword_1DAD68[(unsigned __int8)v278]
       ^ dword_1DB168[BYTE1(v265)]
       ^ dword_1DB568[BYTE2(v252)];
  v266 = dword_1DB968[HIBYTE(v149)]
       ^ dword_1DAD68[(unsigned __int8)v265]
       ^ dword_1DB168[BYTE1(v252)]
       ^ dword_1DB568[BYTE2(v291)];
  v253 = dword_1DB968[HIBYTE(v148)]
       ^ dword_1DAD68[(unsigned __int8)v252]
       ^ dword_1DB168[BYTE1(v291)]
       ^ dword_1DB568[BYTE2(v149)];
  v146 = dword_1DB968[HIBYTE(v147)]
       ^ dword_1DAD68[(unsigned __int8)v291]
       ^ dword_1DB168[BYTE1(v149)]
       ^ dword_1DB568[BYTE2(v148)];
  v292 = v353 ^ v279;
  v280 = v336 ^ v266;
  v267 = v168 ^ v303 ^ v253;
  v254 = result ^ v153 ^ v146;
  v145 = v280
       ^ dword_1DB968[HIBYTE(v152)]
       ^ dword_1DAD68[(unsigned __int8)(v336 ^ v333)]
       ^ dword_1DB168[BYTE1(v151)]
       ^ dword_1DB568[BYTE2(v150)];
  v144 = v267
       ^ dword_1DB968[(v336 ^ (unsigned int)v333) >> 24]
       ^ dword_1DAD68[(unsigned __int8)v151]
       ^ dword_1DB168[BYTE1(v150)]
       ^ dword_1DB568[BYTE2(v152)];
  v143 = v254
       ^ dword_1DB968[HIBYTE(v151)]
       ^ dword_1DAD68[(unsigned __int8)v150]
       ^ dword_1DB168[BYTE1(v152)]
       ^ dword_1DB568[(unsigned __int8)((v336 ^ (unsigned int)v333) >> 16)];
  v383 = dword_1DB968[HIBYTE(v143)]
       ^ dword_1DAD68[(unsigned __int8)(v292 ^ v351)]
       ^ dword_1DB168[BYTE1(v145)]
       ^ dword_1DB568[BYTE2(v144)]
       ^ v382;
  v376 = dword_1DB968[(v292 ^ (unsigned int)v351) >> 24]
       ^ dword_1DAD68[(unsigned __int8)v145]
       ^ dword_1DB168[BYTE1(v144)]
       ^ dword_1DB568[BYTE2(v143)]
       ^ v375;
  v369 = dword_1DB968[HIBYTE(v145)]
       ^ dword_1DAD68[(unsigned __int8)v144]
       ^ dword_1DB168[BYTE1(v143)]
       ^ dword_1DB568[(unsigned __int8)((v292 ^ (unsigned int)v351) >> 16)]
       ^ v368;
  v362 = dword_1DB968[HIBYTE(v144)]
       ^ dword_1DAD68[(unsigned __int8)v143]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v292 ^ v351) >> 8)]
       ^ dword_1DB568[BYTE2(v145)]
       ^ v361;
  v142 = v227;
  v141 = v214;
  v140 = v201;
  v228 = dword_1DB968[HIBYTE(v240)]
       ^ dword_1DAD68[(unsigned __int8)v227]
       ^ dword_1DB168[BYTE1(v214)]
       ^ dword_1DB568[BYTE2(v201)];
  v215 = dword_1DB968[HIBYTE(v142)]
       ^ dword_1DAD68[(unsigned __int8)v214]
       ^ dword_1DB168[BYTE1(v201)]
       ^ dword_1DB568[BYTE2(v240)];
  v202 = dword_1DB968[HIBYTE(v141)]
       ^ dword_1DAD68[(unsigned __int8)v201]
       ^ dword_1DB168[BYTE1(v240)]
       ^ dword_1DB568[BYTE2(v142)];
  v139 = dword_1DB968[HIBYTE(v140)]
       ^ dword_1DAD68[(unsigned __int8)v240]
       ^ dword_1DB168[BYTE1(v142)]
       ^ dword_1DB568[BYTE2(v141)];
  v241 = v292 ^ v228;
  v229 = v280 ^ v215;
  v216 = v267 ^ v202;
  v203 = v254 ^ v139;
  v138 = v254 ^ v139 ^ v362;
  v137 = v180;
  v136 = v168;
  v181 = dword_1DB968[HIBYTE(v192)]
       ^ dword_1DAD68[(unsigned __int8)v180]
       ^ dword_1DB168[BYTE1(v168)]
       ^ dword_1DB568[BYTE2(result)];
  v169 = dword_1DB968[HIBYTE(v137)]
       ^ dword_1DAD68[(unsigned __int8)v168]
       ^ dword_1DB168[BYTE1(result)]
       ^ dword_1DB568[BYTE2(v192)];
  v157 = dword_1DB968[HIBYTE(v136)]
       ^ dword_1DAD68[(unsigned __int8)result]
       ^ dword_1DB168[BYTE1(v192)]
       ^ dword_1DB568[BYTE2(v137)];
  v135 = dword_1DB968[HIBYTE(result)]
       ^ dword_1DAD68[(unsigned __int8)v192]
       ^ dword_1DB168[BYTE1(v137)]
       ^ dword_1DB568[BYTE2(v136)];
  v193 = v241 ^ v181;
  v182 = v229 ^ v169;
  v170 = v216 ^ v157;
  v158 = v254 ^ v139 ^ v135;
  v134 = v193
       ^ dword_1DB968[HIBYTE(v138)]
       ^ dword_1DAD68[(unsigned __int8)(v241 ^ v383)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v229 ^ v376) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v216 ^ (unsigned int)v369) >> 16)];
  v133 = v182
       ^ dword_1DB968[(v241 ^ (unsigned int)v383) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v229 ^ v376)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v216 ^ v369) >> 8)]
       ^ dword_1DB568[BYTE2(v138)];
  v132 = v170
       ^ dword_1DB968[(v229 ^ (unsigned int)v376) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v216 ^ v369)]
       ^ dword_1DB168[BYTE1(v138)]
       ^ dword_1DB568[(unsigned __int8)((v241 ^ (unsigned int)v383) >> 16)];
  v131 = v158
       ^ dword_1DB968[(v216 ^ (unsigned int)v369) >> 24]
       ^ dword_1DAD68[(unsigned __int8)v138]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v241 ^ v383) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v229 ^ (unsigned int)v376) >> 16)];
  v354 = v182 ^ v353;
  v337 = v170 ^ v336;
  v320 = v158 ^ v319;
  v304 = v354 ^ result ^ v153;
  v130 = v354
       ^ dword_1DB968[HIBYTE(v131)]
       ^ dword_1DAD68[(unsigned __int8)v134]
       ^ dword_1DB168[BYTE1(v133)]
       ^ dword_1DB568[BYTE2(v132)];
  v129 = v337
       ^ dword_1DB968[HIBYTE(v134)]
       ^ dword_1DAD68[(unsigned __int8)v133]
       ^ dword_1DB168[BYTE1(v132)]
       ^ dword_1DB568[BYTE2(v131)];
  v128 = v320
       ^ dword_1DB968[HIBYTE(v133)]
       ^ dword_1DAD68[(unsigned __int8)v132]
       ^ dword_1DB168[BYTE1(v131)]
       ^ dword_1DB568[BYTE2(v134)];
  v127 = v304
       ^ dword_1DB968[HIBYTE(v132)]
       ^ dword_1DAD68[(unsigned __int8)v131]
       ^ dword_1DB168[BYTE1(v134)]
       ^ dword_1DB568[BYTE2(v133)];
  v412 = dword_1DB968[HIBYTE(v127)]
       ^ dword_1DAD68[(unsigned __int8)v130]
       ^ dword_1DB168[BYTE1(v129)]
       ^ dword_1DB568[BYTE2(v128)]
       ^ v411;
  v405 = dword_1DB968[HIBYTE(v130)]
       ^ dword_1DAD68[(unsigned __int8)v129]
       ^ dword_1DB168[BYTE1(v128)]
       ^ dword_1DB568[BYTE2(v127)]
       ^ v404;
  v398 = dword_1DB968[HIBYTE(v129)]
       ^ dword_1DAD68[(unsigned __int8)v128]
       ^ dword_1DB168[BYTE1(v127)]
       ^ dword_1DB568[BYTE2(v130)]
       ^ v397;
  v391 = dword_1DB968[HIBYTE(v128)]
       ^ dword_1DAD68[(unsigned __int8)v127]
       ^ dword_1DB168[BYTE1(v130)]
       ^ dword_1DB568[BYTE2(v129)]
       ^ v390;
  v293 = v337 ^ v292;
  v281 = v320 ^ v280;
  v268 = v304 ^ v267;
  v255 = v293 ^ v254;
  v242 = v281 ^ v241;
  v230 = v268 ^ v229;
  v217 = v255 ^ v216;
  v204 = v242 ^ v203;
  v126 = v242
       ^ dword_1DB968[(v255 ^ (unsigned int)v391) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v293 ^ v412)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v281 ^ v405) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v268 ^ (unsigned int)v398) >> 16)];
  v125 = v230
       ^ dword_1DB968[(v293 ^ v412) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v281 ^ v405)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v268 ^ v398) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v255 ^ (unsigned int)v391) >> 16)];
  v124 = v217
       ^ dword_1DB968[(v281 ^ (unsigned int)v405) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v268 ^ v398)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v255 ^ v391) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v293 ^ v412) >> 16)];
  v123 = v204
       ^ dword_1DB968[(v268 ^ (unsigned int)v398) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v255 ^ v391)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v293 ^ v412) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v281 ^ (unsigned int)v405) >> 16)];
  v194 = v230 ^ v193;
  v183 = v217 ^ v182;
  v171 = v204 ^ v170;
  v159 = v194 ^ v158;
  v122 = v194
       ^ dword_1DB968[HIBYTE(v123)]
       ^ dword_1DAD68[(unsigned __int8)v126]
       ^ dword_1DB168[BYTE1(v125)]
       ^ dword_1DB568[BYTE2(v124)];
  v121 = v183
       ^ dword_1DB968[HIBYTE(v126)]
       ^ dword_1DAD68[(unsigned __int8)v125]
       ^ dword_1DB168[BYTE1(v124)]
       ^ dword_1DB568[BYTE2(v123)];
  v120 = v171
       ^ dword_1DB968[HIBYTE(v125)]
       ^ dword_1DAD68[(unsigned __int8)v124]
       ^ dword_1DB168[BYTE1(v123)]
       ^ dword_1DB568[BYTE2(v126)];
  v119 = v159
       ^ dword_1DB968[HIBYTE(v124)]
       ^ dword_1DAD68[(unsigned __int8)v123]
       ^ dword_1DB168[BYTE1(v126)]
       ^ dword_1DB568[BYTE2(v125)];
  v384 = dword_1DB968[HIBYTE(v119)]
       ^ dword_1DAD68[(unsigned __int8)v122]
       ^ dword_1DB168[BYTE1(v121)]
       ^ dword_1DB568[BYTE2(v120)]
       ^ v383;
  v377 = dword_1DB968[HIBYTE(v122)]
       ^ dword_1DAD68[(unsigned __int8)v121]
       ^ dword_1DB168[BYTE1(v120)]
       ^ dword_1DB568[BYTE2(v119)]
       ^ v376;
  v370 = dword_1DB968[HIBYTE(v121)]
       ^ dword_1DAD68[(unsigned __int8)v120]
       ^ dword_1DB168[BYTE1(v119)]
       ^ dword_1DB568[BYTE2(v122)]
       ^ v369;
  v363 = dword_1DB968[HIBYTE(v120)]
       ^ dword_1DAD68[(unsigned __int8)v119]
       ^ dword_1DB168[BYTE1(v122)]
       ^ dword_1DB568[BYTE2(v121)]
       ^ v362;
  v118 = v337;
  v117 = v320;
  v116 = v304;
  v338 = dword_1DB968[HIBYTE(v354)]
       ^ dword_1DAD68[(unsigned __int8)v337]
       ^ dword_1DB168[BYTE1(v320)]
       ^ dword_1DB568[BYTE2(v304)];
  v321 = dword_1DB968[HIBYTE(v118)]
       ^ dword_1DAD68[(unsigned __int8)v320]
       ^ dword_1DB168[BYTE1(v304)]
       ^ dword_1DB568[BYTE2(v354)];
  v305 = dword_1DB968[HIBYTE(v117)]
       ^ dword_1DAD68[(unsigned __int8)v304]
       ^ dword_1DB168[BYTE1(v354)]
       ^ dword_1DB568[BYTE2(v118)];
  v115 = dword_1DB968[HIBYTE(v116)]
       ^ dword_1DAD68[(unsigned __int8)v354]
       ^ dword_1DB168[BYTE1(v118)]
       ^ dword_1DB568[BYTE2(v117)];
  v355 = v194 ^ v338;
  v339 = v183 ^ v321;
  v322 = v171 ^ v305;
  v306 = v159 ^ v115;
  v114 = v159 ^ v115 ^ v363;
  v113 = v281;
  v112 = v268;
  v111 = v255;
  v282 = dword_1DB968[HIBYTE(v293)]
       ^ dword_1DAD68[(unsigned __int8)v281]
       ^ dword_1DB168[BYTE1(v268)]
       ^ dword_1DB568[BYTE2(v255)];
  v269 = dword_1DB968[HIBYTE(v113)]
       ^ dword_1DAD68[(unsigned __int8)v268]
       ^ dword_1DB168[BYTE1(v255)]
       ^ dword_1DB568[BYTE2(v293)];
  v256 = dword_1DB968[HIBYTE(v112)]
       ^ dword_1DAD68[(unsigned __int8)v255]
       ^ dword_1DB168[BYTE1(v293)]
       ^ dword_1DB568[BYTE2(v113)];
  v110 = dword_1DB968[HIBYTE(v111)]
       ^ dword_1DAD68[(unsigned __int8)v293]
       ^ dword_1DB168[BYTE1(v113)]
       ^ dword_1DB568[BYTE2(v112)];
  v294 = v355 ^ v282;
  v283 = v339 ^ v269;
  v270 = v322 ^ v256;
  v257 = v159 ^ v115 ^ v110;
  v109 = v294
       ^ dword_1DB968[HIBYTE(v114)]
       ^ dword_1DAD68[(unsigned __int8)(v355 ^ v384)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v339 ^ v377) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v322 ^ (unsigned int)v370) >> 16)];
  v108 = v283
       ^ dword_1DB968[(v355 ^ (unsigned int)v384) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v339 ^ v377)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v322 ^ v370) >> 8)]
       ^ dword_1DB568[BYTE2(v114)];
  v107 = v270
       ^ dword_1DB968[(v339 ^ (unsigned int)v377) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v322 ^ v370)]
       ^ dword_1DB168[BYTE1(v114)]
       ^ dword_1DB568[(unsigned __int8)((v355 ^ (unsigned int)v384) >> 16)];
  v106 = v257
       ^ dword_1DB968[(v322 ^ (unsigned int)v370) >> 24]
       ^ dword_1DAD68[(unsigned __int8)v114]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v355 ^ v384) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v339 ^ (unsigned int)v377) >> 16)];
  v105 = v230;
  v104 = v217;
  v103 = v204;
  v231 = dword_1DB968[HIBYTE(v242)]
       ^ dword_1DAD68[(unsigned __int8)v230]
       ^ dword_1DB168[BYTE1(v217)]
       ^ dword_1DB568[BYTE2(v204)];
  v218 = dword_1DB968[HIBYTE(v105)]
       ^ dword_1DAD68[(unsigned __int8)v217]
       ^ dword_1DB168[BYTE1(v204)]
       ^ dword_1DB568[BYTE2(v242)];
  v205 = dword_1DB968[HIBYTE(v104)]
       ^ dword_1DAD68[(unsigned __int8)v204]
       ^ dword_1DB168[BYTE1(v242)]
       ^ dword_1DB568[BYTE2(v105)];
  v102 = dword_1DB968[HIBYTE(v103)]
       ^ dword_1DAD68[(unsigned __int8)v242]
       ^ dword_1DB168[BYTE1(v105)]
       ^ dword_1DB568[BYTE2(v104)];
  v243 = v294 ^ v231;
  v232 = v283 ^ a1[26] ^ v218;
  v219 = v270 ^ ~a1[25] ^ v205;
  v206 = v257 ^ v102;
  v101 = v243
       ^ dword_1DB968[HIBYTE(v106)]
       ^ dword_1DAD68[(unsigned __int8)v109]
       ^ dword_1DB168[BYTE1(v108)]
       ^ dword_1DB568[BYTE2(v107)];
  v100 = v232
       ^ dword_1DB968[HIBYTE(v109)]
       ^ dword_1DAD68[(unsigned __int8)v108]
       ^ dword_1DB168[BYTE1(v107)]
       ^ dword_1DB568[BYTE2(v106)];
  v99 = v219
      ^ dword_1DB968[HIBYTE(v108)]
      ^ dword_1DAD68[(unsigned __int8)v107]
      ^ dword_1DB168[BYTE1(v106)]
      ^ dword_1DB568[BYTE2(v109)];
  v98 = v257
      ^ v102
      ^ dword_1DB968[HIBYTE(v107)]
      ^ dword_1DAD68[(unsigned __int8)v106]
      ^ dword_1DB168[BYTE1(v109)]
      ^ dword_1DB568[BYTE2(v108)];
  v413 = dword_1DB968[HIBYTE(v98)]
       ^ dword_1DAD68[(unsigned __int8)v101]
       ^ dword_1DB168[BYTE1(v100)]
       ^ dword_1DB568[BYTE2(v99)]
       ^ v412;
  v406 = dword_1DB968[HIBYTE(v101)]
       ^ dword_1DAD68[(unsigned __int8)v100]
       ^ dword_1DB168[BYTE1(v99)]
       ^ dword_1DB568[BYTE2(v98)]
       ^ v405;
  v399 = dword_1DB968[HIBYTE(v100)]
       ^ dword_1DAD68[(unsigned __int8)v99]
       ^ dword_1DB168[BYTE1(v98)]
       ^ dword_1DB568[BYTE2(v101)]
       ^ v398;
  v392 = dword_1DB968[HIBYTE(v99)]
       ^ dword_1DAD68[(unsigned __int8)v98]
       ^ dword_1DB168[BYTE1(v101)]
       ^ dword_1DB568[BYTE2(v100)]
       ^ v391;
  v97 = v183;
  v96 = v171;
  v95 = v159;
  v184 = dword_1DB968[HIBYTE(v194)]
       ^ dword_1DAD68[(unsigned __int8)v183]
       ^ dword_1DB168[BYTE1(v171)]
       ^ dword_1DB568[BYTE2(v159)];
  v172 = dword_1DB968[HIBYTE(v97)]
       ^ dword_1DAD68[(unsigned __int8)v171]
       ^ dword_1DB168[BYTE1(v159)]
       ^ dword_1DB568[BYTE2(v194)];
  v160 = dword_1DB968[HIBYTE(v96)]
       ^ dword_1DAD68[(unsigned __int8)v159]
       ^ dword_1DB168[BYTE1(v194)]
       ^ dword_1DB568[BYTE2(v97)];
  v94 = dword_1DB968[HIBYTE(v95)]
      ^ dword_1DAD68[(unsigned __int8)v194]
      ^ dword_1DB168[BYTE1(v97)]
      ^ dword_1DB568[BYTE2(v96)];
  v195 = v243 ^ v184;
  v185 = v232 ^ v172;
  v173 = v219 ^ v160;
  v161 = v257 ^ v102 ^ v94;
  v356 = v185 ^ v355;
  v340 = v173 ^ v339;
  v323 = v161 ^ v322;
  v307 = v356 ^ v306;
  v93 = v356
      ^ dword_1DB968[(v161 ^ (unsigned int)v392) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v195 ^ v413)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v185 ^ v406) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v173 ^ (unsigned int)v399) >> 16)];
  v92 = v340
      ^ dword_1DB968[(v195 ^ (unsigned int)v413) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v185 ^ v406)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v173 ^ v399) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v161 ^ (unsigned int)v392) >> 16)];
  v91 = v323
      ^ dword_1DB968[(v185 ^ (unsigned int)v406) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v173 ^ v399)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v161 ^ v392) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v195 ^ (unsigned int)v413) >> 16)];
  v90 = v307
      ^ dword_1DB968[(v173 ^ (unsigned int)v399) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v161 ^ v392)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v195 ^ v413) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v185 ^ (unsigned int)v406) >> 16)];
  v295 = v340 ^ v294;
  v284 = v323 ^ v283;
  v271 = v307 ^ v270;
  v258 = v295 ^ v257;
  v89 = v295
      ^ dword_1DB968[HIBYTE(v90)]
      ^ dword_1DAD68[(unsigned __int8)v93]
      ^ dword_1DB168[BYTE1(v92)]
      ^ dword_1DB568[BYTE2(v91)];
  v88 = v284
      ^ dword_1DB968[HIBYTE(v93)]
      ^ dword_1DAD68[(unsigned __int8)v92]
      ^ dword_1DB168[BYTE1(v91)]
      ^ dword_1DB568[BYTE2(v90)];
  v87 = v271
      ^ dword_1DB968[HIBYTE(v92)]
      ^ dword_1DAD68[(unsigned __int8)v91]
      ^ dword_1DB168[BYTE1(v90)]
      ^ dword_1DB568[BYTE2(v93)];
  v86 = v258
      ^ dword_1DB968[HIBYTE(v91)]
      ^ dword_1DAD68[(unsigned __int8)v90]
      ^ dword_1DB168[BYTE1(v93)]
      ^ dword_1DB568[BYTE2(v92)];
  v385 = dword_1DB968[HIBYTE(v86)]
       ^ dword_1DAD68[(unsigned __int8)v89]
       ^ dword_1DB168[BYTE1(v88)]
       ^ dword_1DB568[BYTE2(v87)]
       ^ v384;
  v378 = dword_1DB968[HIBYTE(v89)]
       ^ dword_1DAD68[(unsigned __int8)v88]
       ^ dword_1DB168[BYTE1(v87)]
       ^ dword_1DB568[BYTE2(v86)]
       ^ v377;
  v371 = dword_1DB968[HIBYTE(v88)]
       ^ dword_1DAD68[(unsigned __int8)v87]
       ^ dword_1DB168[BYTE1(v86)]
       ^ dword_1DB568[BYTE2(v89)]
       ^ v370;
  v364 = dword_1DB968[HIBYTE(v87)]
       ^ dword_1DAD68[(unsigned __int8)v86]
       ^ dword_1DB168[BYTE1(v89)]
       ^ dword_1DB568[BYTE2(v88)]
       ^ v363;
  v244 = v284 ^ v243;
  v233 = v271 ^ v232;
  v220 = v258 ^ v219;
  v207 = v244 ^ v206;
  v196 = v233 ^ v195;
  v186 = v220 ^ v185;
  v174 = v207 ^ v173;
  v162 = v196 ^ v161;
  v85 = v196
      ^ dword_1DB968[(v207 ^ (unsigned int)v364) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v244 ^ v385)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v233 ^ v378) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v220 ^ (unsigned int)v371) >> 16)];
  v84 = v186
      ^ dword_1DB968[(v244 ^ v385) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v233 ^ v378)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v220 ^ v371) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v207 ^ (unsigned int)v364) >> 16)];
  v83 = v174
      ^ dword_1DB968[(v233 ^ (unsigned int)v378) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v220 ^ v371)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v207 ^ v364) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v244 ^ v385) >> 16)];
  v82 = v162
      ^ dword_1DB968[(v220 ^ (unsigned int)v371) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v207 ^ v364)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v244 ^ v385) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v233 ^ (unsigned int)v378) >> 16)];
  v81 = v340;
  v80 = v323;
  v79 = v307;
  v341 = dword_1DB968[HIBYTE(v356)]
       ^ dword_1DAD68[(unsigned __int8)v340]
       ^ dword_1DB168[BYTE1(v323)]
       ^ dword_1DB568[BYTE2(v307)];
  v324 = dword_1DB968[HIBYTE(v81)]
       ^ dword_1DAD68[(unsigned __int8)v323]
       ^ dword_1DB168[BYTE1(v307)]
       ^ dword_1DB568[BYTE2(v356)];
  v308 = dword_1DB968[HIBYTE(v80)]
       ^ dword_1DAD68[(unsigned __int8)v307]
       ^ dword_1DB168[BYTE1(v356)]
       ^ dword_1DB568[BYTE2(v81)];
  v78 = dword_1DB968[HIBYTE(v79)]
      ^ dword_1DAD68[(unsigned __int8)v356]
      ^ dword_1DB168[BYTE1(v81)]
      ^ dword_1DB568[BYTE2(v80)];
  v357 = v196 ^ v341;
  v342 = v186 ^ v324;
  v325 = v174 ^ v308;
  v309 = v162 ^ v78;
  v77 = v357
      ^ dword_1DB968[HIBYTE(v82)]
      ^ dword_1DAD68[(unsigned __int8)v85]
      ^ dword_1DB168[BYTE1(v84)]
      ^ dword_1DB568[BYTE2(v83)];
  v76 = v342
      ^ dword_1DB968[HIBYTE(v85)]
      ^ dword_1DAD68[(unsigned __int8)v84]
      ^ dword_1DB168[BYTE1(v83)]
      ^ dword_1DB568[BYTE2(v82)];
  v75 = v325
      ^ dword_1DB968[HIBYTE(v84)]
      ^ dword_1DAD68[(unsigned __int8)v83]
      ^ dword_1DB168[BYTE1(v82)]
      ^ dword_1DB568[BYTE2(v85)];
  v74 = v162
      ^ v78
      ^ dword_1DB968[HIBYTE(v83)]
      ^ dword_1DAD68[(unsigned __int8)v82]
      ^ dword_1DB168[BYTE1(v85)]
      ^ dword_1DB568[BYTE2(v84)];
  v414 = dword_1DB968[HIBYTE(v74)]
       ^ dword_1DAD68[(unsigned __int8)v77]
       ^ dword_1DB168[BYTE1(v76)]
       ^ dword_1DB568[BYTE2(v75)]
       ^ v413;
  v407 = dword_1DB968[HIBYTE(v77)]
       ^ dword_1DAD68[(unsigned __int8)v76]
       ^ dword_1DB168[BYTE1(v75)]
       ^ dword_1DB568[BYTE2(v74)]
       ^ v406;
  v400 = dword_1DB968[HIBYTE(v76)]
       ^ dword_1DAD68[(unsigned __int8)v75]
       ^ dword_1DB168[BYTE1(v74)]
       ^ dword_1DB568[BYTE2(v77)]
       ^ v399;
  v393 = dword_1DB968[HIBYTE(v75)]
       ^ dword_1DAD68[(unsigned __int8)v74]
       ^ dword_1DB168[BYTE1(v77)]
       ^ dword_1DB568[BYTE2(v76)]
       ^ v392;
  v73 = v284;
  v72 = v271;
  v71 = v258;
  v285 = dword_1DB968[HIBYTE(v295)]
       ^ dword_1DAD68[(unsigned __int8)v284]
       ^ dword_1DB168[BYTE1(v271)]
       ^ dword_1DB568[BYTE2(v258)];
  v272 = dword_1DB968[HIBYTE(v73)]
       ^ dword_1DAD68[(unsigned __int8)v271]
       ^ dword_1DB168[BYTE1(v258)]
       ^ dword_1DB568[BYTE2(v295)];
  v259 = dword_1DB968[HIBYTE(v72)]
       ^ dword_1DAD68[(unsigned __int8)v258]
       ^ dword_1DB168[BYTE1(v295)]
       ^ dword_1DB568[BYTE2(v73)];
  v70 = dword_1DB968[HIBYTE(v71)]
      ^ dword_1DAD68[(unsigned __int8)v295]
      ^ dword_1DB168[BYTE1(v73)]
      ^ dword_1DB568[BYTE2(v72)];
  v296 = v357 ^ v285;
  v286 = v342 ^ v272;
  v273 = v325 ^ a1[26] ^ v259;
  v260 = v162 ^ v78 ^ ~a1[25] ^ v70;
  v69 = v233;
  v68 = v220;
  v67 = v207;
  v234 = dword_1DB968[HIBYTE(v244)]
       ^ dword_1DAD68[(unsigned __int8)v233]
       ^ dword_1DB168[BYTE1(v220)]
       ^ dword_1DB568[BYTE2(v207)];
  v221 = dword_1DB968[HIBYTE(v69)]
       ^ dword_1DAD68[(unsigned __int8)v220]
       ^ dword_1DB168[BYTE1(v207)]
       ^ dword_1DB568[BYTE2(v244)];
  v208 = dword_1DB968[HIBYTE(v68)]
       ^ dword_1DAD68[(unsigned __int8)v207]
       ^ dword_1DB168[BYTE1(v244)]
       ^ dword_1DB568[BYTE2(v69)];
  v66 = dword_1DB968[HIBYTE(v67)]
      ^ dword_1DAD68[(unsigned __int8)v244]
      ^ dword_1DB168[BYTE1(v69)]
      ^ dword_1DB568[BYTE2(v68)];
  v245 = v296 ^ v234;
  v235 = v286 ^ v221;
  v222 = v273 ^ v208;
  v209 = v260 ^ v66;
  v65 = v245
      ^ dword_1DB968[(v260 ^ (unsigned int)v393) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v296 ^ v414)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v286 ^ v407) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v273 ^ (unsigned int)v400) >> 16)];
  v64 = v235
      ^ dword_1DB968[(v296 ^ (unsigned int)v414) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v286 ^ v407)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v273 ^ v400) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v260 ^ (unsigned int)v393) >> 16)];
  v63 = v222
      ^ dword_1DB968[(v286 ^ (unsigned int)v407) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v273 ^ v400)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v260 ^ v393) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v296 ^ (unsigned int)v414) >> 16)];
  v62 = v260
      ^ v66
      ^ dword_1DB968[(v273 ^ (unsigned int)v400) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v260 ^ v393)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v296 ^ v414) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v286 ^ (unsigned int)v407) >> 16)];
  v61 = v186;
  v60 = v174;
  v59 = v162;
  v187 = dword_1DB968[HIBYTE(v196)]
       ^ dword_1DAD68[(unsigned __int8)v186]
       ^ dword_1DB168[BYTE1(v174)]
       ^ dword_1DB568[BYTE2(v162)];
  v175 = dword_1DB968[HIBYTE(v61)]
       ^ dword_1DAD68[(unsigned __int8)v174]
       ^ dword_1DB168[BYTE1(v162)]
       ^ dword_1DB568[BYTE2(v196)];
  v163 = dword_1DB968[HIBYTE(v60)]
       ^ dword_1DAD68[(unsigned __int8)v162]
       ^ dword_1DB168[BYTE1(v196)]
       ^ dword_1DB568[BYTE2(v61)];
  v58 = dword_1DB968[HIBYTE(v59)]
      ^ dword_1DAD68[(unsigned __int8)v196]
      ^ dword_1DB168[BYTE1(v61)]
      ^ dword_1DB568[BYTE2(v60)];
  v197 = v245 ^ v187;
  v188 = v235 ^ v175;
  v176 = v222 ^ v163;
  v164 = v260 ^ v66 ^ v58;
  v57 = v197
      ^ dword_1DB968[HIBYTE(v62)]
      ^ dword_1DAD68[(unsigned __int8)v65]
      ^ dword_1DB168[BYTE1(v64)]
      ^ dword_1DB568[BYTE2(v63)];
  v56 = v188
      ^ dword_1DB968[HIBYTE(v65)]
      ^ dword_1DAD68[(unsigned __int8)v64]
      ^ dword_1DB168[BYTE1(v63)]
      ^ dword_1DB568[BYTE2(v62)];
  v55 = v176
      ^ dword_1DB968[HIBYTE(v64)]
      ^ dword_1DAD68[(unsigned __int8)v63]
      ^ dword_1DB168[BYTE1(v62)]
      ^ dword_1DB568[BYTE2(v65)];
  v54 = v164
      ^ dword_1DB968[HIBYTE(v63)]
      ^ dword_1DAD68[(unsigned __int8)v62]
      ^ dword_1DB168[BYTE1(v65)]
      ^ dword_1DB568[BYTE2(v64)];
  v386 = dword_1DB968[HIBYTE(v54)]
       ^ dword_1DAD68[(unsigned __int8)v57]
       ^ dword_1DB168[BYTE1(v56)]
       ^ dword_1DB568[BYTE2(v55)]
       ^ v385;
  v379 = dword_1DB968[HIBYTE(v57)]
       ^ dword_1DAD68[(unsigned __int8)v56]
       ^ dword_1DB168[BYTE1(v55)]
       ^ dword_1DB568[BYTE2(v54)]
       ^ v378;
  v372 = dword_1DB968[HIBYTE(v56)]
       ^ dword_1DAD68[(unsigned __int8)v55]
       ^ dword_1DB168[BYTE1(v54)]
       ^ dword_1DB568[BYTE2(v57)]
       ^ v371;
  v365 = dword_1DB968[HIBYTE(v55)]
       ^ dword_1DAD68[(unsigned __int8)v54]
       ^ dword_1DB168[BYTE1(v57)]
       ^ dword_1DB568[BYTE2(v56)]
       ^ v364;
  v358 = v188 ^ v357;
  v343 = v176 ^ v342;
  v326 = v164 ^ v325;
  v310 = v358 ^ v309;
  v297 = v343 ^ v296;
  v287 = v326 ^ v286;
  v274 = v310 ^ v273;
  v261 = v297 ^ v260;
  v53 = v297
      ^ dword_1DB968[(v310 ^ (unsigned int)v365) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v358 ^ v386)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v343 ^ v379) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v326 ^ (unsigned int)v372) >> 16)];
  v52 = v287
      ^ dword_1DB968[(v358 ^ v386) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v343 ^ v379)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v326 ^ v372) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v310 ^ (unsigned int)v365) >> 16)];
  v51 = v274
      ^ dword_1DB968[(v343 ^ (unsigned int)v379) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v326 ^ v372)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v310 ^ v365) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v358 ^ v386) >> 16)];
  v50 = v261
      ^ dword_1DB968[(v326 ^ (unsigned int)v372) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v310 ^ v365)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v358 ^ v386) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v343 ^ (unsigned int)v379) >> 16)];
  v246 = v287 ^ v245;
  v236 = v274 ^ v235;
  v223 = v261 ^ v222;
  v210 = v246 ^ v209;
  v49 = v246
      ^ dword_1DB968[HIBYTE(v50)]
      ^ dword_1DAD68[(unsigned __int8)v53]
      ^ dword_1DB168[BYTE1(v52)]
      ^ dword_1DB568[BYTE2(v51)];
  v48 = v236
      ^ dword_1DB968[HIBYTE(v53)]
      ^ dword_1DAD68[(unsigned __int8)v52]
      ^ dword_1DB168[BYTE1(v51)]
      ^ dword_1DB568[BYTE2(v50)];
  v47 = v223
      ^ dword_1DB968[HIBYTE(v52)]
      ^ dword_1DAD68[(unsigned __int8)v51]
      ^ dword_1DB168[BYTE1(v50)]
      ^ dword_1DB568[BYTE2(v53)];
  v46 = v210
      ^ dword_1DB968[HIBYTE(v51)]
      ^ dword_1DAD68[(unsigned __int8)v50]
      ^ dword_1DB168[BYTE1(v53)]
      ^ dword_1DB568[BYTE2(v52)];
  v415 = dword_1DB968[HIBYTE(v46)]
       ^ dword_1DAD68[(unsigned __int8)v49]
       ^ dword_1DB168[BYTE1(v48)]
       ^ dword_1DB568[BYTE2(v47)]
       ^ v414;
  v408 = dword_1DB968[HIBYTE(v49)]
       ^ dword_1DAD68[(unsigned __int8)v48]
       ^ dword_1DB168[BYTE1(v47)]
       ^ dword_1DB568[BYTE2(v46)]
       ^ v407;
  v401 = dword_1DB968[HIBYTE(v48)]
       ^ dword_1DAD68[(unsigned __int8)v47]
       ^ dword_1DB168[BYTE1(v46)]
       ^ dword_1DB568[BYTE2(v49)]
       ^ v400;
  v394 = dword_1DB968[HIBYTE(v47)]
       ^ dword_1DAD68[(unsigned __int8)v46]
       ^ dword_1DB168[BYTE1(v49)]
       ^ dword_1DB568[BYTE2(v48)]
       ^ v393;
  v198 = v236 ^ v197;
  v189 = v223 ^ v188;
  v177 = v210 ^ v176;
  v165 = v198 ^ v164;
  v45 = v343;
  v44 = v326;
  v43 = v310;
  v344 = dword_1DB968[HIBYTE(v358)]
       ^ dword_1DAD68[(unsigned __int8)v343]
       ^ dword_1DB168[BYTE1(v326)]
       ^ dword_1DB568[BYTE2(v310)];
  v327 = dword_1DB968[HIBYTE(v45)]
       ^ dword_1DAD68[(unsigned __int8)v326]
       ^ dword_1DB168[BYTE1(v310)]
       ^ dword_1DB568[BYTE2(v358)];
  v311 = dword_1DB968[HIBYTE(v44)]
       ^ dword_1DAD68[(unsigned __int8)v310]
       ^ dword_1DB168[BYTE1(v358)]
       ^ dword_1DB568[BYTE2(v45)];
  v42 = dword_1DB968[HIBYTE(v43)]
      ^ dword_1DAD68[(unsigned __int8)v358]
      ^ dword_1DB168[BYTE1(v45)]
      ^ dword_1DB568[BYTE2(v44)];
  v359 = v198 ^ v344;
  v345 = v189 ^ v327;
  v328 = v177 ^ v311;
  v312 = v165 ^ v42;
  v41 = v359
      ^ dword_1DB968[(v165 ^ (unsigned int)v394) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v198 ^ v415)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v189 ^ v408) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v177 ^ (unsigned int)v401) >> 16)];
  v40 = v345
      ^ dword_1DB968[(v198 ^ v415) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v189 ^ v408)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v177 ^ v401) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v165 ^ (unsigned int)v394) >> 16)];
  v39 = v328
      ^ dword_1DB968[(v189 ^ (unsigned int)v408) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v177 ^ v401)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v165 ^ v394) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v198 ^ v415) >> 16)];
  v38 = v165
      ^ v42
      ^ dword_1DB968[(v177 ^ (unsigned int)v401) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v165 ^ v394)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v198 ^ v415) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v189 ^ (unsigned int)v408) >> 16)];
  v37 = v287;
  v36 = v274;
  v35 = v261;
  v288 = dword_1DB968[HIBYTE(v297)]
       ^ dword_1DAD68[(unsigned __int8)v287]
       ^ dword_1DB168[BYTE1(v274)]
       ^ dword_1DB568[BYTE2(v261)];
  v275 = dword_1DB968[HIBYTE(v37)]
       ^ dword_1DAD68[(unsigned __int8)v274]
       ^ dword_1DB168[BYTE1(v261)]
       ^ dword_1DB568[BYTE2(v297)];
  v262 = dword_1DB968[HIBYTE(v36)]
       ^ dword_1DAD68[(unsigned __int8)v261]
       ^ dword_1DB168[BYTE1(v297)]
       ^ dword_1DB568[BYTE2(v37)];
  v34 = dword_1DB968[HIBYTE(v35)]
      ^ dword_1DAD68[(unsigned __int8)v297]
      ^ dword_1DB168[BYTE1(v37)]
      ^ dword_1DB568[BYTE2(v36)];
  v298 = v359 ^ v288;
  v289 = v345 ^ v275;
  v276 = v328 ^ v262;
  v263 = v165 ^ v42 ^ v34;
  v33 = v298
      ^ dword_1DB968[HIBYTE(v38)]
      ^ dword_1DAD68[(unsigned __int8)v41]
      ^ dword_1DB168[BYTE1(v40)]
      ^ dword_1DB568[BYTE2(v39)];
  v32 = v289
      ^ dword_1DB968[HIBYTE(v41)]
      ^ dword_1DAD68[(unsigned __int8)v40]
      ^ dword_1DB168[BYTE1(v39)]
      ^ dword_1DB568[BYTE2(v38)];
  v31 = v276
      ^ dword_1DB968[HIBYTE(v40)]
      ^ dword_1DAD68[(unsigned __int8)v39]
      ^ dword_1DB168[BYTE1(v38)]
      ^ dword_1DB568[BYTE2(v41)];
  v30 = v263
      ^ dword_1DB968[HIBYTE(v39)]
      ^ dword_1DAD68[(unsigned __int8)v38]
      ^ dword_1DB168[BYTE1(v41)]
      ^ dword_1DB568[BYTE2(v40)];
  v387 = dword_1DB968[HIBYTE(v30)]
       ^ dword_1DAD68[(unsigned __int8)v33]
       ^ dword_1DB168[BYTE1(v32)]
       ^ dword_1DB568[BYTE2(v31)]
       ^ v386;
  v380 = dword_1DB968[HIBYTE(v33)]
       ^ dword_1DAD68[(unsigned __int8)v32]
       ^ dword_1DB168[BYTE1(v31)]
       ^ dword_1DB568[BYTE2(v30)]
       ^ v379;
  v373 = dword_1DB968[HIBYTE(v32)]
       ^ dword_1DAD68[(unsigned __int8)v31]
       ^ dword_1DB168[BYTE1(v30)]
       ^ dword_1DB568[BYTE2(v33)]
       ^ v372;
  v366 = dword_1DB968[HIBYTE(v31)]
       ^ dword_1DAD68[(unsigned __int8)v30]
       ^ dword_1DB168[BYTE1(v33)]
       ^ dword_1DB568[BYTE2(v32)]
       ^ v365;
  v29 = v236;
  v28 = v223;
  v27 = v210;
  v237 = dword_1DB968[HIBYTE(v246)]
       ^ dword_1DAD68[(unsigned __int8)v236]
       ^ dword_1DB168[BYTE1(v223)]
       ^ dword_1DB568[BYTE2(v210)];
  v224 = dword_1DB968[HIBYTE(v29)]
       ^ dword_1DAD68[(unsigned __int8)v223]
       ^ dword_1DB168[BYTE1(v210)]
       ^ dword_1DB568[BYTE2(v246)];
  v211 = dword_1DB968[HIBYTE(v28)]
       ^ dword_1DAD68[(unsigned __int8)v210]
       ^ dword_1DB168[BYTE1(v246)]
       ^ dword_1DB568[BYTE2(v29)];
  v26 = dword_1DB968[HIBYTE(v27)]
      ^ dword_1DAD68[(unsigned __int8)v246]
      ^ dword_1DB168[BYTE1(v29)]
      ^ dword_1DB568[BYTE2(v28)];
  v247 = v298 ^ v237;
  v238 = v289 ^ v224;
  v225 = v276 ^ v211;
  v212 = v263 ^ v26;
  v25 = v263 ^ v26 ^ v366;
  v24 = v189;
  v23 = v177;
  v22 = v165;
  v190 = dword_1DB968[HIBYTE(v198)]
       ^ dword_1DAD68[(unsigned __int8)v189]
       ^ dword_1DB168[BYTE1(v177)]
       ^ dword_1DB568[BYTE2(v165)];
  v178 = dword_1DB968[HIBYTE(v24)]
       ^ dword_1DAD68[(unsigned __int8)v177]
       ^ dword_1DB168[BYTE1(v165)]
       ^ dword_1DB568[BYTE2(v198)];
  v166 = dword_1DB968[HIBYTE(v23)]
       ^ dword_1DAD68[(unsigned __int8)v165]
       ^ dword_1DB168[BYTE1(v198)]
       ^ dword_1DB568[BYTE2(v24)];
  v21 = dword_1DB968[HIBYTE(v22)]
      ^ dword_1DAD68[(unsigned __int8)v198]
      ^ dword_1DB168[BYTE1(v24)]
      ^ dword_1DB568[BYTE2(v23)];
  v199 = v247 ^ a1[25] ^ v190;
  v191 = v238 ^ v178;
  v179 = v225 ^ v166;
  v167 = v263 ^ v26 ^ ~a1[26] ^ v21;
  v20 = v199
      ^ dword_1DB968[HIBYTE(v25)]
      ^ dword_1DAD68[(unsigned __int8)(v247 ^ v387)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v238 ^ v380) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v225 ^ (unsigned int)v373) >> 16)];
  v19 = v191
      ^ dword_1DB968[(v247 ^ (unsigned int)v387) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v238 ^ v380)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v225 ^ v373) >> 8)]
      ^ dword_1DB568[BYTE2(v25)];
  v18 = v179
      ^ dword_1DB968[(v238 ^ (unsigned int)v380) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v225 ^ v373)]
      ^ dword_1DB168[BYTE1(v25)]
      ^ dword_1DB568[(unsigned __int8)((v247 ^ (unsigned int)v387) >> 16)];
  v17 = v167
      ^ dword_1DB968[(v225 ^ (unsigned int)v373) >> 24]
      ^ dword_1DAD68[(unsigned __int8)v25]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v247 ^ v387) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v238 ^ (unsigned int)v380) >> 16)];
  v360 = v191 ^ v359;
  v346 = v179 ^ v345;
  v329 = v167 ^ v328;
  v313 = v360 ^ v312;
  v16 = v360
      ^ dword_1DB968[HIBYTE(v17)]
      ^ dword_1DAD68[(unsigned __int8)v20]
      ^ dword_1DB168[BYTE1(v19)]
      ^ dword_1DB568[BYTE2(v18)];
  v15 = v346
      ^ dword_1DB968[HIBYTE(v20)]
      ^ dword_1DAD68[(unsigned __int8)v19]
      ^ dword_1DB168[BYTE1(v18)]
      ^ dword_1DB568[BYTE2(v17)];
  v14 = v329
      ^ dword_1DB968[HIBYTE(v19)]
      ^ dword_1DAD68[(unsigned __int8)v18]
      ^ dword_1DB168[BYTE1(v17)]
      ^ dword_1DB568[BYTE2(v20)];
  v13 = v313
      ^ dword_1DB968[HIBYTE(v18)]
      ^ dword_1DAD68[(unsigned __int8)v17]
      ^ dword_1DB168[BYTE1(v20)]
      ^ dword_1DB568[BYTE2(v19)];
  v416 = dword_1DB968[HIBYTE(v13)]
       ^ dword_1DAD68[(unsigned __int8)v16]
       ^ dword_1DB168[BYTE1(v15)]
       ^ dword_1DB568[BYTE2(v14)]
       ^ v415;
  v409 = dword_1DB968[HIBYTE(v16)]
       ^ dword_1DAD68[(unsigned __int8)v15]
       ^ dword_1DB168[BYTE1(v14)]
       ^ dword_1DB568[BYTE2(v13)]
       ^ v408;
  v402 = dword_1DB968[HIBYTE(v15)]
       ^ dword_1DAD68[(unsigned __int8)v14]
       ^ dword_1DB168[BYTE1(v13)]
       ^ dword_1DB568[BYTE2(v16)]
       ^ v401;
  v395 = dword_1DB968[HIBYTE(v14)]
       ^ dword_1DAD68[(unsigned __int8)v13]
       ^ dword_1DB168[BYTE1(v16)]
       ^ dword_1DB568[BYTE2(v15)]
       ^ v394;
  v299 = v346 ^ v298;
  v290 = v329 ^ v289;
  v277 = v313 ^ v276;
  v264 = v299 ^ v263;
  v248 = v290 ^ v247;
  v239 = v277 ^ v238;
  v226 = v264 ^ v225;
  v213 = v248 ^ v212;
  v12 = v248
      ^ dword_1DB968[(v264 ^ (unsigned int)v395) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v299 ^ v416)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v290 ^ v409) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v277 ^ (unsigned int)v402) >> 16)];
  v11 = v239
      ^ dword_1DB968[(v299 ^ (unsigned int)v416) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v290 ^ v409)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v277 ^ v402) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v264 ^ (unsigned int)v395) >> 16)];
  v10 = v226
      ^ dword_1DB968[(v290 ^ (unsigned int)v409) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v277 ^ v402)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v264 ^ v395) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v299 ^ (unsigned int)v416) >> 16)];
  v9 = v213
     ^ dword_1DB968[(v277 ^ (unsigned int)v402) >> 24]
     ^ dword_1DAD68[(unsigned __int8)(v264 ^ v395)]
     ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v299 ^ v416) >> 8)]
     ^ dword_1DB568[(unsigned __int8)((v290 ^ (unsigned int)v409) >> 16)];
  v200 = v239 ^ v199;
  v8 = v200
     ^ dword_1DB968[HIBYTE(v9)]
     ^ dword_1DAD68[(unsigned __int8)v12]
     ^ dword_1DB168[BYTE1(v11)]
     ^ dword_1DB568[BYTE2(v10)];
  v7 = v226
     ^ v191
     ^ dword_1DB968[HIBYTE(v12)]
     ^ dword_1DAD68[(unsigned __int8)v11]
     ^ dword_1DB168[BYTE1(v10)]
     ^ dword_1DB568[BYTE2(v9)];
  v6 = v213
     ^ v179
     ^ dword_1DB968[HIBYTE(v11)]
     ^ dword_1DAD68[(unsigned __int8)v10]
     ^ dword_1DB168[BYTE1(v9)]
     ^ dword_1DB568[BYTE2(v12)];
  v5 = v200
     ^ v167
     ^ dword_1DB968[HIBYTE(v10)]
     ^ dword_1DAD68[(unsigned __int8)v9]
     ^ dword_1DB168[BYTE1(v12)]
     ^ dword_1DB568[BYTE2(v11)];
  v388 = dword_1DB968[HIBYTE(v5)]
       ^ dword_1DAD68[(unsigned __int8)v8]
       ^ dword_1DB168[BYTE1(v7)]
       ^ dword_1DB568[BYTE2(v6)]
       ^ v387;
  v381 = dword_1DB968[HIBYTE(v8)]
       ^ dword_1DAD68[(unsigned __int8)v7]
       ^ dword_1DB168[BYTE1(v6)]
       ^ dword_1DB568[BYTE2(v5)]
       ^ v380;
  v374 = dword_1DB968[HIBYTE(v7)]
       ^ dword_1DAD68[(unsigned __int8)v6]
       ^ dword_1DB168[BYTE1(v5)]
       ^ dword_1DB568[BYTE2(v8)]
       ^ v373;
  v367 = dword_1DB968[HIBYTE(v6)]
       ^ dword_1DAD68[(unsigned __int8)v5]
       ^ dword_1DB168[BYTE1(v8)]
       ^ dword_1DB568[BYTE2(v7)]
       ^ v366;
  a1[17] ^= v416;
  a1[18] ^= v409;
  a1[19] ^= v402;
  a1[20] ^= v395;
  a1[21] ^= v388;
  a1[22] ^= v381;
  a1[23] ^= v374;
  a1[24] ^= v367;
  return result;
}
// 1DAD68: using guessed type _DWORD dword_1DAD68[256];
// 1DB168: using guessed type _DWORD dword_1DB168[256];
// 1DB568: using guessed type _DWORD dword_1DB568[256];
// 1DB968: using guessed type _DWORD dword_1DB968[256];

//----- (0018FC14) --------------------------------------------------------
int __fastcall sub_18FC14(_DWORD *a1, int a2)
{
  int result; // r0
  unsigned int v5; // [sp+Ch] [bp+Ch]
  unsigned int v6; // [sp+10h] [bp+10h]
  unsigned int v7; // [sp+14h] [bp+14h]
  unsigned int v8; // [sp+18h] [bp+18h]
  unsigned int v9; // [sp+30h] [bp+30h]
  unsigned int v10; // [sp+34h] [bp+34h]
  unsigned int v11; // [sp+38h] [bp+38h]
  unsigned int v12; // [sp+3Ch] [bp+3Ch]
  int v13; // [sp+40h] [bp+40h]
  unsigned int v14; // [sp+48h] [bp+48h]
  unsigned int v15; // [sp+4Ch] [bp+4Ch]
  unsigned int v16; // [sp+50h] [bp+50h]
  unsigned int v17; // [sp+54h] [bp+54h]
  unsigned int v18; // [sp+58h] [bp+58h]
  unsigned int v19; // [sp+5Ch] [bp+5Ch]
  unsigned int v20; // [sp+60h] [bp+60h]
  int v21; // [sp+64h] [bp+64h]
  unsigned int v22; // [sp+6Ch] [bp+6Ch]
  unsigned int v23; // [sp+70h] [bp+70h]
  unsigned int v24; // [sp+74h] [bp+74h]
  unsigned int v25; // [sp+78h] [bp+78h]
  int v26; // [sp+88h] [bp+88h]
  unsigned int v27; // [sp+90h] [bp+90h]
  unsigned int v28; // [sp+94h] [bp+94h]
  unsigned int v29; // [sp+98h] [bp+98h]
  unsigned int v30; // [sp+9Ch] [bp+9Ch]
  unsigned int v31; // [sp+A0h] [bp+A0h]
  unsigned int v32; // [sp+A4h] [bp+A4h]
  unsigned int v33; // [sp+A8h] [bp+A8h]
  int v34; // [sp+ACh] [bp+ACh]
  unsigned int v35; // [sp+B4h] [bp+B4h]
  unsigned int v36; // [sp+B8h] [bp+B8h]
  unsigned int v37; // [sp+BCh] [bp+BCh]
  unsigned int v38; // [sp+C0h] [bp+C0h]
  unsigned int v39; // [sp+C4h] [bp+C4h]
  unsigned int v40; // [sp+C8h] [bp+C8h]
  unsigned int v41; // [sp+CCh] [bp+CCh]
  int v42; // [sp+D0h] [bp+D0h]
  unsigned int v43; // [sp+D8h] [bp+D8h]
  unsigned int v44; // [sp+DCh] [bp+DCh]
  unsigned int v45; // [sp+E0h] [bp+E0h]
  unsigned int v46; // [sp+E4h] [bp+E4h]
  unsigned int v47; // [sp+E8h] [bp+E8h]
  unsigned int v48; // [sp+ECh] [bp+ECh]
  unsigned int v49; // [sp+F0h] [bp+F0h]
  int v50; // [sp+F4h] [bp+F4h]
  unsigned int v51; // [sp+FCh] [bp+FCh]
  unsigned int v52; // [sp+100h] [bp+100h]
  unsigned int v53; // [sp+104h] [bp+104h]
  unsigned int v54; // [sp+108h] [bp+108h]
  int v55; // [sp+118h] [bp+118h]
  unsigned int v56; // [sp+120h] [bp+120h]
  unsigned int v57; // [sp+124h] [bp+124h]
  unsigned int v58; // [sp+128h] [bp+128h]
  unsigned int v59; // [sp+12Ch] [bp+12Ch]
  unsigned int v60; // [sp+130h] [bp+130h]
  unsigned int v61; // [sp+134h] [bp+134h]
  unsigned int v62; // [sp+138h] [bp+138h]
  unsigned int v63; // [sp+13Ch] [bp+13Ch]
  unsigned int v64; // [sp+140h] [bp+140h]
  unsigned int v65; // [sp+144h] [bp+144h]
  unsigned int v66; // [sp+148h] [bp+148h]
  unsigned int v67; // [sp+14Ch] [bp+14Ch]
  unsigned int v68; // [sp+150h] [bp+150h]
  unsigned int v69; // [sp+154h] [bp+154h]
  unsigned int v70; // [sp+158h] [bp+158h]
  unsigned int v71; // [sp+16Ch] [bp+16Ch]
  unsigned int v72; // [sp+170h] [bp+170h]
  unsigned int v73; // [sp+174h] [bp+174h]
  unsigned int v74; // [sp+178h] [bp+178h]
  unsigned int v75; // [sp+17Ch] [bp+17Ch]
  unsigned int v76; // [sp+180h] [bp+180h]
  unsigned int v77; // [sp+184h] [bp+184h]
  unsigned int v78; // [sp+188h] [bp+188h]
  unsigned int v79; // [sp+18Ch] [bp+18Ch]
  unsigned int v80; // [sp+190h] [bp+190h]
  unsigned int v81; // [sp+194h] [bp+194h]
  unsigned int v82; // [sp+198h] [bp+198h]
  unsigned int v83; // [sp+1ACh] [bp+1ACh]
  unsigned int v84; // [sp+1B0h] [bp+1B0h]
  unsigned int v85; // [sp+1B4h] [bp+1B4h]
  unsigned int v86; // [sp+1B8h] [bp+1B8h]
  int v87; // [sp+1BCh] [bp+1BCh]
  unsigned int v88; // [sp+1C4h] [bp+1C4h]
  unsigned int v89; // [sp+1C8h] [bp+1C8h]
  unsigned int v90; // [sp+1CCh] [bp+1CCh]
  unsigned int v91; // [sp+1D0h] [bp+1D0h]
  unsigned int v92; // [sp+1D4h] [bp+1D4h]
  unsigned int v93; // [sp+1D8h] [bp+1D8h]
  unsigned int v94; // [sp+1DCh] [bp+1DCh]
  int v95; // [sp+1E0h] [bp+1E0h]
  unsigned int v96; // [sp+1E8h] [bp+1E8h]
  unsigned int v97; // [sp+1ECh] [bp+1ECh]
  unsigned int v98; // [sp+1F0h] [bp+1F0h]
  unsigned int v99; // [sp+1F4h] [bp+1F4h]
  unsigned int v100; // [sp+1F8h] [bp+1F8h]
  unsigned int v101; // [sp+1FCh] [bp+1FCh]
  unsigned int v102; // [sp+200h] [bp+200h]
  int v103; // [sp+204h] [bp+204h]
  unsigned int v104; // [sp+20Ch] [bp+20Ch]
  unsigned int v105; // [sp+210h] [bp+210h]
  unsigned int v106; // [sp+214h] [bp+214h]
  unsigned int v107; // [sp+218h] [bp+218h]
  int v108; // [sp+228h] [bp+228h]
  unsigned int v109; // [sp+230h] [bp+230h]
  unsigned int v110; // [sp+234h] [bp+234h]
  unsigned int v111; // [sp+238h] [bp+238h]
  unsigned int v112; // [sp+23Ch] [bp+23Ch]
  unsigned int v113; // [sp+240h] [bp+240h]
  unsigned int v114; // [sp+244h] [bp+244h]
  unsigned int v115; // [sp+248h] [bp+248h]
  int v116; // [sp+24Ch] [bp+24Ch]
  unsigned int v117; // [sp+254h] [bp+254h]
  unsigned int v118; // [sp+258h] [bp+258h]
  unsigned int v119; // [sp+25Ch] [bp+25Ch]
  unsigned int v120; // [sp+260h] [bp+260h]
  unsigned int v121; // [sp+264h] [bp+264h]
  unsigned int v122; // [sp+268h] [bp+268h]
  unsigned int v123; // [sp+26Ch] [bp+26Ch]
  int v124; // [sp+270h] [bp+270h]
  unsigned int v125; // [sp+278h] [bp+278h]
  unsigned int v126; // [sp+27Ch] [bp+27Ch]
  unsigned int v127; // [sp+280h] [bp+280h]
  unsigned int v128; // [sp+284h] [bp+284h]
  unsigned int v129; // [sp+288h] [bp+288h]
  unsigned int v130; // [sp+28Ch] [bp+28Ch]
  unsigned int v131; // [sp+290h] [bp+290h]
  int v132; // [sp+294h] [bp+294h]
  unsigned int v133; // [sp+29Ch] [bp+29Ch]
  unsigned int v134; // [sp+2A0h] [bp+2A0h]
  unsigned int v135; // [sp+2A4h] [bp+2A4h]
  unsigned int v136; // [sp+2A8h] [bp+2A8h]
  int v137; // [sp+2B8h] [bp+2B8h]
  unsigned int v138; // [sp+2C0h] [bp+2C0h]
  unsigned int v139; // [sp+2C4h] [bp+2C4h]
  unsigned int v140; // [sp+2C8h] [bp+2C8h]
  unsigned int v141; // [sp+2CCh] [bp+2CCh]
  unsigned int v142; // [sp+2D0h] [bp+2D0h]
  unsigned int v143; // [sp+2D4h] [bp+2D4h]
  unsigned int v144; // [sp+2D8h] [bp+2D8h]
  unsigned int v145; // [sp+2DCh] [bp+2DCh]
  unsigned int v146; // [sp+2E0h] [bp+2E0h]
  unsigned int v147; // [sp+2E4h] [bp+2E4h]
  unsigned int v148; // [sp+2E8h] [bp+2E8h]
  unsigned int v149; // [sp+2ECh] [bp+2ECh]
  unsigned int v150; // [sp+2F0h] [bp+2F0h]
  unsigned int v151; // [sp+2F4h] [bp+2F4h]
  unsigned int v152; // [sp+2F8h] [bp+2F8h]
  unsigned int v153; // [sp+30Ch] [bp+30Ch]
  unsigned int v154; // [sp+310h] [bp+310h]
  unsigned int v155; // [sp+314h] [bp+314h]
  unsigned int v156; // [sp+318h] [bp+318h]
  unsigned int v157; // [sp+31Ch] [bp+31Ch]
  unsigned int v158; // [sp+320h] [bp+320h]
  unsigned int v159; // [sp+324h] [bp+324h]
  unsigned int v160; // [sp+328h] [bp+328h]
  unsigned int v161; // [sp+32Ch] [bp+32Ch]
  unsigned int v162; // [sp+330h] [bp+330h]
  unsigned int v163; // [sp+334h] [bp+334h]
  unsigned int v164; // [sp+338h] [bp+338h]
  int v165; // [sp+35Ch] [bp+35Ch]
  unsigned int v166; // [sp+364h] [bp+364h]
  unsigned int v167; // [sp+368h] [bp+368h]
  unsigned int v168; // [sp+36Ch] [bp+36Ch]
  unsigned int v169; // [sp+370h] [bp+370h]
  unsigned int v170; // [sp+374h] [bp+374h]
  unsigned int v171; // [sp+378h] [bp+378h]
  unsigned int v172; // [sp+37Ch] [bp+37Ch]
  int v173; // [sp+380h] [bp+380h]
  unsigned int v174; // [sp+388h] [bp+388h]
  unsigned int v175; // [sp+38Ch] [bp+38Ch]
  unsigned int v176; // [sp+390h] [bp+390h]
  unsigned int v177; // [sp+394h] [bp+394h]
  unsigned int v178; // [sp+398h] [bp+398h]
  unsigned int v179; // [sp+39Ch] [bp+39Ch]
  unsigned int v180; // [sp+3A0h] [bp+3A0h]
  int v181; // [sp+3A4h] [bp+3A4h]
  unsigned int v182; // [sp+3ACh] [bp+3ACh]
  unsigned int v183; // [sp+3B0h] [bp+3B0h]
  unsigned int v184; // [sp+3B4h] [bp+3B4h]
  unsigned int v185; // [sp+3B8h] [bp+3B8h]
  int v186; // [sp+3C8h] [bp+3C8h]
  unsigned int v187; // [sp+3D0h] [bp+3D0h]
  unsigned int v188; // [sp+3D4h] [bp+3D4h]
  unsigned int v189; // [sp+3D8h] [bp+3D8h]
  unsigned int v190; // [sp+3DCh] [bp+3DCh]
  unsigned int v191; // [sp+3E0h] [bp+3E0h]
  int v192; // [sp+3ECh] [bp+3ECh]
  unsigned int v193; // [sp+3F4h] [bp+3F4h]
  unsigned int v194; // [sp+3F8h] [bp+3F8h]
  unsigned int v195; // [sp+3FCh] [bp+3FCh]
  unsigned int v196; // [sp+400h] [bp+400h]
  unsigned int v197; // [sp+408h] [bp+408h]
  unsigned int v198; // [sp+40Ch] [bp+40Ch]
  int v199; // [sp+410h] [bp+410h]
  unsigned int v200; // [sp+418h] [bp+418h]
  unsigned int v201; // [sp+41Ch] [bp+41Ch]
  unsigned int v202; // [sp+420h] [bp+420h]
  unsigned int v203; // [sp+428h] [bp+428h]
  unsigned int v204; // [sp+42Ch] [bp+42Ch]
  unsigned int v205; // [sp+430h] [bp+430h]
  int v206; // [sp+434h] [bp+434h]
  unsigned int v207; // [sp+43Ch] [bp+43Ch]
  unsigned int v208; // [sp+440h] [bp+440h]
  unsigned int v209; // [sp+444h] [bp+444h]
  int v210; // [sp+458h] [bp+458h]
  unsigned int v211; // [sp+460h] [bp+460h]
  unsigned int v212; // [sp+464h] [bp+464h]
  unsigned int v213; // [sp+468h] [bp+468h]
  unsigned int v214; // [sp+480h] [bp+480h]
  unsigned int v215; // [sp+484h] [bp+484h]
  unsigned int v216; // [sp+488h] [bp+488h]
  unsigned int v217; // [sp+490h] [bp+490h]
  unsigned int v218; // [sp+494h] [bp+494h]
  unsigned int v219; // [sp+498h] [bp+498h]
  unsigned int v220; // [sp+4C0h] [bp+4C0h]
  unsigned int v221; // [sp+4C4h] [bp+4C4h]
  unsigned int v222; // [sp+4C8h] [bp+4C8h]
  unsigned int v223; // [sp+4D0h] [bp+4D0h]
  unsigned int v224; // [sp+4D4h] [bp+4D4h]
  unsigned int v225; // [sp+4D8h] [bp+4D8h]
  int v226; // [sp+4ECh] [bp+4ECh]
  int v227; // [sp+4ECh] [bp+4ECh]
  int v228; // [sp+4ECh] [bp+4ECh]
  int v229; // [sp+4ECh] [bp+4ECh]
  int v230; // [sp+4ECh] [bp+4ECh]
  int v231; // [sp+4ECh] [bp+4ECh]
  int v232; // [sp+4ECh] [bp+4ECh]
  int v233; // [sp+4ECh] [bp+4ECh]
  int v234; // [sp+4F0h] [bp+4F0h]
  int v235; // [sp+4F0h] [bp+4F0h]
  int v236; // [sp+4F0h] [bp+4F0h]
  unsigned int v237; // [sp+4F0h] [bp+4F0h]
  int v238; // [sp+4F0h] [bp+4F0h]
  int v239; // [sp+4F0h] [bp+4F0h]
  int v240; // [sp+4F0h] [bp+4F0h]
  unsigned int v241; // [sp+4F0h] [bp+4F0h]
  int v242; // [sp+4F0h] [bp+4F0h]
  int v243; // [sp+4F0h] [bp+4F0h]
  int v244; // [sp+4F0h] [bp+4F0h]
  int v245; // [sp+4F4h] [bp+4F4h]
  int v246; // [sp+4F4h] [bp+4F4h]
  int v247; // [sp+4F4h] [bp+4F4h]
  unsigned int v248; // [sp+4F4h] [bp+4F4h]
  int v249; // [sp+4F4h] [bp+4F4h]
  int v250; // [sp+4F4h] [bp+4F4h]
  int v251; // [sp+4F4h] [bp+4F4h]
  unsigned int v252; // [sp+4F4h] [bp+4F4h]
  int v253; // [sp+4F4h] [bp+4F4h]
  int v254; // [sp+4F4h] [bp+4F4h]
  int v255; // [sp+4F4h] [bp+4F4h]
  int v256; // [sp+4F4h] [bp+4F4h]
  int v257; // [sp+4F8h] [bp+4F8h]
  int v258; // [sp+4F8h] [bp+4F8h]
  int v259; // [sp+4F8h] [bp+4F8h]
  unsigned int v260; // [sp+4F8h] [bp+4F8h]
  int v261; // [sp+4F8h] [bp+4F8h]
  int v262; // [sp+4F8h] [bp+4F8h]
  int v263; // [sp+4F8h] [bp+4F8h]
  unsigned int v264; // [sp+4F8h] [bp+4F8h]
  int v265; // [sp+4F8h] [bp+4F8h]
  int v266; // [sp+4F8h] [bp+4F8h]
  int v267; // [sp+4F8h] [bp+4F8h]
  int v268; // [sp+4F8h] [bp+4F8h]
  int i; // [sp+4FCh] [bp+4FCh]
  unsigned int v270; // [sp+500h] [bp+500h]
  int v271; // [sp+500h] [bp+500h]
  int v272; // [sp+500h] [bp+500h]
  int v273; // [sp+500h] [bp+500h]
  int v274; // [sp+500h] [bp+500h]
  int v275; // [sp+500h] [bp+500h]
  unsigned int v276; // [sp+504h] [bp+504h]
  int v277; // [sp+504h] [bp+504h]
  int v278; // [sp+504h] [bp+504h]
  int v279; // [sp+504h] [bp+504h]
  int v280; // [sp+504h] [bp+504h]
  int v281; // [sp+504h] [bp+504h]
  unsigned int v282; // [sp+508h] [bp+508h]
  int v283; // [sp+508h] [bp+508h]
  int v284; // [sp+508h] [bp+508h]
  int v285; // [sp+508h] [bp+508h]
  int v286; // [sp+508h] [bp+508h]
  int v287; // [sp+508h] [bp+508h]
  unsigned int v288; // [sp+50Ch] [bp+50Ch]
  int v289; // [sp+50Ch] [bp+50Ch]
  unsigned int v290; // [sp+50Ch] [bp+50Ch]
  int v291; // [sp+50Ch] [bp+50Ch]
  int v292; // [sp+510h] [bp+510h]
  int v293; // [sp+510h] [bp+510h]
  int v294; // [sp+510h] [bp+510h]
  int v295; // [sp+510h] [bp+510h]
  int v296; // [sp+510h] [bp+510h]
  int v297; // [sp+510h] [bp+510h]
  int v298; // [sp+510h] [bp+510h]
  int v299; // [sp+510h] [bp+510h]
  int v300; // [sp+514h] [bp+514h]
  int v301; // [sp+514h] [bp+514h]
  int v302; // [sp+514h] [bp+514h]
  int v303; // [sp+514h] [bp+514h]
  int v304; // [sp+514h] [bp+514h]
  int v305; // [sp+514h] [bp+514h]
  int v306; // [sp+514h] [bp+514h]
  int v307; // [sp+514h] [bp+514h]
  int v308; // [sp+518h] [bp+518h]
  int v309; // [sp+518h] [bp+518h]
  int v310; // [sp+518h] [bp+518h]
  int v311; // [sp+518h] [bp+518h]
  int v312; // [sp+518h] [bp+518h]
  int v313; // [sp+518h] [bp+518h]
  int v314; // [sp+518h] [bp+518h]
  int v315; // [sp+518h] [bp+518h]
  unsigned int v316; // [sp+51Ch] [bp+51Ch]
  int v317; // [sp+51Ch] [bp+51Ch]
  unsigned int v318; // [sp+51Ch] [bp+51Ch]
  int v319; // [sp+51Ch] [bp+51Ch]
  int v320; // [sp+51Ch] [bp+51Ch]
  int v321; // [sp+520h] [bp+520h]
  int v322; // [sp+520h] [bp+520h]
  int v323; // [sp+520h] [bp+520h]
  int v324; // [sp+520h] [bp+520h]
  int v325; // [sp+520h] [bp+520h]
  int v326; // [sp+520h] [bp+520h]
  int v327; // [sp+520h] [bp+520h]
  int v328; // [sp+520h] [bp+520h]
  int v329; // [sp+524h] [bp+524h]
  int v330; // [sp+524h] [bp+524h]
  int v331; // [sp+524h] [bp+524h]
  int v332; // [sp+524h] [bp+524h]
  int v333; // [sp+524h] [bp+524h]
  int v334; // [sp+524h] [bp+524h]
  int v335; // [sp+524h] [bp+524h]
  int v336; // [sp+524h] [bp+524h]
  int v337; // [sp+528h] [bp+528h]
  int v338; // [sp+528h] [bp+528h]
  int v339; // [sp+528h] [bp+528h]
  int v340; // [sp+528h] [bp+528h]
  int v341; // [sp+528h] [bp+528h]
  int v342; // [sp+528h] [bp+528h]
  int v343; // [sp+528h] [bp+528h]
  int v344; // [sp+528h] [bp+528h]
  unsigned int v345; // [sp+52Ch] [bp+52Ch]
  int v346; // [sp+52Ch] [bp+52Ch]
  unsigned int v347; // [sp+52Ch] [bp+52Ch]
  int v348; // [sp+52Ch] [bp+52Ch]
  int v349; // [sp+52Ch] [bp+52Ch]
  int v350; // [sp+530h] [bp+530h]
  int v351; // [sp+530h] [bp+530h]
  int v352; // [sp+530h] [bp+530h]
  int v353; // [sp+530h] [bp+530h]
  int v354; // [sp+530h] [bp+530h]
  int v355; // [sp+530h] [bp+530h]
  int v356; // [sp+530h] [bp+530h]
  int v357; // [sp+534h] [bp+534h]
  int v358; // [sp+534h] [bp+534h]
  int v359; // [sp+534h] [bp+534h]
  int v360; // [sp+534h] [bp+534h]
  int v361; // [sp+534h] [bp+534h]
  int v362; // [sp+534h] [bp+534h]
  int v363; // [sp+534h] [bp+534h]
  int v364; // [sp+538h] [bp+538h]
  int v365; // [sp+538h] [bp+538h]
  int v366; // [sp+538h] [bp+538h]
  int v367; // [sp+538h] [bp+538h]
  int v368; // [sp+538h] [bp+538h]
  int v369; // [sp+538h] [bp+538h]
  int v370; // [sp+538h] [bp+538h]
  unsigned int v371; // [sp+53Ch] [bp+53Ch]
  int v372; // [sp+53Ch] [bp+53Ch]
  unsigned int v373; // [sp+53Ch] [bp+53Ch]
  int v374; // [sp+53Ch] [bp+53Ch]
  int v375; // [sp+540h] [bp+540h]
  int v376; // [sp+540h] [bp+540h]
  int v377; // [sp+540h] [bp+540h]
  int v378; // [sp+540h] [bp+540h]
  int v379; // [sp+540h] [bp+540h]
  int v380; // [sp+540h] [bp+540h]
  int v381; // [sp+540h] [bp+540h]
  int v382; // [sp+540h] [bp+540h]
  int v383; // [sp+544h] [bp+544h]
  int v384; // [sp+544h] [bp+544h]
  int v385; // [sp+544h] [bp+544h]
  int v386; // [sp+544h] [bp+544h]
  int v387; // [sp+544h] [bp+544h]
  int v388; // [sp+544h] [bp+544h]
  int v389; // [sp+544h] [bp+544h]
  int v390; // [sp+544h] [bp+544h]
  int v391; // [sp+548h] [bp+548h]
  int v392; // [sp+548h] [bp+548h]
  int v393; // [sp+548h] [bp+548h]
  int v394; // [sp+548h] [bp+548h]
  int v395; // [sp+548h] [bp+548h]
  int v396; // [sp+548h] [bp+548h]
  int v397; // [sp+548h] [bp+548h]
  int v398; // [sp+548h] [bp+548h]
  unsigned int v399; // [sp+54Ch] [bp+54Ch]
  int v400; // [sp+54Ch] [bp+54Ch]
  unsigned int v401; // [sp+54Ch] [bp+54Ch]
  int v402; // [sp+54Ch] [bp+54Ch]
  int v403; // [sp+54Ch] [bp+54Ch]
  int v404; // [sp+550h] [bp+550h]
  int v405; // [sp+550h] [bp+550h]
  int v406; // [sp+550h] [bp+550h]
  int v407; // [sp+550h] [bp+550h]
  int v408; // [sp+550h] [bp+550h]
  int v409; // [sp+550h] [bp+550h]
  int v410; // [sp+550h] [bp+550h]
  int v411; // [sp+554h] [bp+554h]
  int v412; // [sp+554h] [bp+554h]
  int v413; // [sp+554h] [bp+554h]
  int v414; // [sp+554h] [bp+554h]
  int v415; // [sp+554h] [bp+554h]
  int v416; // [sp+554h] [bp+554h]
  int v417; // [sp+554h] [bp+554h]
  int v418; // [sp+558h] [bp+558h]
  int v419; // [sp+558h] [bp+558h]
  int v420; // [sp+558h] [bp+558h]
  int v421; // [sp+558h] [bp+558h]
  int v422; // [sp+558h] [bp+558h]
  int v423; // [sp+558h] [bp+558h]
  int v424; // [sp+558h] [bp+558h]
  unsigned int v425; // [sp+55Ch] [bp+55Ch]
  int v426; // [sp+55Ch] [bp+55Ch]
  unsigned int v427; // [sp+55Ch] [bp+55Ch]
  int v428; // [sp+55Ch] [bp+55Ch]
  int v429; // [sp+560h] [bp+560h]
  int v430; // [sp+560h] [bp+560h]
  int v431; // [sp+560h] [bp+560h]
  int v432; // [sp+560h] [bp+560h]
  int v433; // [sp+560h] [bp+560h]
  int v434; // [sp+560h] [bp+560h]
  int v435; // [sp+560h] [bp+560h]
  int v436; // [sp+560h] [bp+560h]
  int v437; // [sp+564h] [bp+564h]
  int v438; // [sp+564h] [bp+564h]
  int v439; // [sp+564h] [bp+564h]
  int v440; // [sp+564h] [bp+564h]
  int v441; // [sp+564h] [bp+564h]
  int v442; // [sp+564h] [bp+564h]
  int v443; // [sp+564h] [bp+564h]
  int v444; // [sp+564h] [bp+564h]
  int v445; // [sp+568h] [bp+568h]
  int v446; // [sp+568h] [bp+568h]
  int v447; // [sp+568h] [bp+568h]
  int v448; // [sp+568h] [bp+568h]
  int v449; // [sp+568h] [bp+568h]
  int v450; // [sp+568h] [bp+568h]
  int v451; // [sp+568h] [bp+568h]
  int v452; // [sp+568h] [bp+568h]
  unsigned int v453; // [sp+56Ch] [bp+56Ch]
  int v454; // [sp+56Ch] [bp+56Ch]
  unsigned int v455; // [sp+56Ch] [bp+56Ch]
  int v456; // [sp+56Ch] [bp+56Ch]
  int v457; // [sp+56Ch] [bp+56Ch]
  int v458; // [sp+570h] [bp+570h]
  int v459; // [sp+570h] [bp+570h]
  int v460; // [sp+570h] [bp+570h]
  int v461; // [sp+570h] [bp+570h]
  int v462; // [sp+570h] [bp+570h]
  int v463; // [sp+570h] [bp+570h]
  int v464; // [sp+570h] [bp+570h]
  int v465; // [sp+574h] [bp+574h]
  int v466; // [sp+574h] [bp+574h]
  int v467; // [sp+574h] [bp+574h]
  int v468; // [sp+574h] [bp+574h]
  int v469; // [sp+574h] [bp+574h]
  int v470; // [sp+574h] [bp+574h]
  int v471; // [sp+574h] [bp+574h]
  int v472; // [sp+578h] [bp+578h]
  int v473; // [sp+578h] [bp+578h]
  int v474; // [sp+578h] [bp+578h]
  int v475; // [sp+578h] [bp+578h]
  int v476; // [sp+578h] [bp+578h]
  int v477; // [sp+578h] [bp+578h]
  int v478; // [sp+578h] [bp+578h]
  unsigned int v479; // [sp+57Ch] [bp+57Ch]
  int v480; // [sp+57Ch] [bp+57Ch]
  unsigned int v481; // [sp+57Ch] [bp+57Ch]
  int v482; // [sp+57Ch] [bp+57Ch]
  int v483; // [sp+580h] [bp+580h]
  int v484; // [sp+580h] [bp+580h]
  int v485; // [sp+580h] [bp+580h]
  int v486; // [sp+584h] [bp+584h]
  int v487; // [sp+584h] [bp+584h]
  int v488; // [sp+584h] [bp+584h]
  int v489; // [sp+588h] [bp+588h]
  int v490; // [sp+588h] [bp+588h]
  int v491; // [sp+588h] [bp+588h]
  int v492; // [sp+58Ch] [bp+58Ch]
  int v493; // [sp+58Ch] [bp+58Ch]
  int v494; // [sp+58Ch] [bp+58Ch]
  int v495; // [sp+590h] [bp+590h]
  int v496; // [sp+590h] [bp+590h]
  int v497; // [sp+590h] [bp+590h]
  int v498; // [sp+594h] [bp+594h]
  int v499; // [sp+594h] [bp+594h]
  int v500; // [sp+594h] [bp+594h]
  int v501; // [sp+598h] [bp+598h]
  int v502; // [sp+598h] [bp+598h]
  int v503; // [sp+598h] [bp+598h]
  int v504; // [sp+59Ch] [bp+59Ch]
  int v505; // [sp+59Ch] [bp+59Ch]
  int v506; // [sp+59Ch] [bp+59Ch]
  int v507; // [sp+5A0h] [bp+5A0h]
  int v508; // [sp+5A0h] [bp+5A0h]
  int v509; // [sp+5A0h] [bp+5A0h]
  int v510; // [sp+5A4h] [bp+5A4h]
  int v511; // [sp+5A4h] [bp+5A4h]
  int v512; // [sp+5A4h] [bp+5A4h]
  int v513; // [sp+5A8h] [bp+5A8h]
  int v514; // [sp+5A8h] [bp+5A8h]
  int v515; // [sp+5A8h] [bp+5A8h]
  int v516; // [sp+5ACh] [bp+5ACh]
  int v517; // [sp+5ACh] [bp+5ACh]
  int v518; // [sp+5ACh] [bp+5ACh]
  int v519; // [sp+5B0h] [bp+5B0h]
  int v520; // [sp+5B0h] [bp+5B0h]
  int v521; // [sp+5B0h] [bp+5B0h]
  int v522; // [sp+5B4h] [bp+5B4h]
  int v523; // [sp+5B4h] [bp+5B4h]
  int v524; // [sp+5B4h] [bp+5B4h]
  int v525; // [sp+5B8h] [bp+5B8h]
  int v526; // [sp+5B8h] [bp+5B8h]
  int v527; // [sp+5B8h] [bp+5B8h]
  int v528; // [sp+5BCh] [bp+5BCh]
  int v529; // [sp+5BCh] [bp+5BCh]
  int v530; // [sp+5BCh] [bp+5BCh]

  v528 = a1[33];
  v525 = a1[34];
  v522 = a1[35];
  v519 = a1[36];
  v516 = a1[37];
  v513 = a1[38];
  v510 = a1[39];
  v507 = a1[40];
  v504 = a1[41];
  v501 = a1[42];
  v498 = a1[43];
  v495 = a1[44];
  v492 = a1[45];
  v489 = a1[46];
  v486 = a1[47];
  v483 = a1[48];
  v479 = sub_189250(a2);
  v472 = sub_189250(a2 + 4);
  v465 = sub_189250(a2 + 8);
  v458 = sub_189250(a2 + 12);
  v257 = dword_1DB968[(v458 ^ (unsigned int)v507) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v479 ^ v516)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v472 ^ v513) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v465 ^ (unsigned int)v510) >> 16)];
  v245 = dword_1DB968[(v479 ^ v516) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v472 ^ v513)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v465 ^ v510) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v458 ^ (unsigned int)v507) >> 16)];
  v234 = dword_1DB968[(v472 ^ (unsigned int)v513) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v465 ^ v510)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v458 ^ v507) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v479 ^ v516) >> 16)];
  v226 = dword_1DB968[(v465 ^ (unsigned int)v510) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v458 ^ v507)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v479 ^ v516) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v472 ^ (unsigned int)v513) >> 16)];
  v453 = sub_189250(a2 + 16);
  v445 = sub_189250(a2 + 20);
  v437 = sub_189250(a2 + 24);
  v429 = sub_189250(a2 + 28);
  v225 = v453 ^ v257;
  v224 = v445 ^ v245;
  v223 = v437 ^ v234;
  v258 = dword_1DB968[(v429 ^ (unsigned int)v226) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v453 ^ v257)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v445 ^ v245) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v437 ^ (unsigned int)v234) >> 16)];
  v246 = dword_1DB968[HIBYTE(v225)]
       ^ dword_1DAD68[(unsigned __int8)(v445 ^ v245)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v437 ^ v234) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v429 ^ (unsigned int)v226) >> 16)];
  v235 = dword_1DB968[HIBYTE(v224)]
       ^ dword_1DAD68[(unsigned __int8)(v437 ^ v234)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v429 ^ v226) >> 8)]
       ^ dword_1DB568[BYTE2(v225)];
  v227 = dword_1DB968[HIBYTE(v223)]
       ^ dword_1DAD68[(unsigned __int8)(v429 ^ v226)]
       ^ dword_1DB168[BYTE1(v225)]
       ^ dword_1DB568[BYTE2(v224)];
  v425 = sub_189250(a2 + 32);
  v418 = sub_189250(a2 + 36);
  v411 = sub_189250(a2 + 40);
  v404 = sub_189250(a2 + 44);
  v222 = v425 ^ v258;
  v221 = v418 ^ v246;
  v220 = v411 ^ v235;
  v259 = dword_1DB968[(v404 ^ (unsigned int)v227) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v425 ^ v258)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v418 ^ v246) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v411 ^ (unsigned int)v235) >> 16)];
  v247 = dword_1DB968[HIBYTE(v222)]
       ^ dword_1DAD68[(unsigned __int8)(v418 ^ v246)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v411 ^ v235) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v404 ^ (unsigned int)v227) >> 16)];
  v236 = dword_1DB968[HIBYTE(v221)]
       ^ dword_1DAD68[(unsigned __int8)(v411 ^ v235)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v404 ^ v227) >> 8)]
       ^ dword_1DB568[BYTE2(v222)];
  v228 = dword_1DB968[HIBYTE(v220)]
       ^ dword_1DAD68[(unsigned __int8)(v404 ^ v227)]
       ^ dword_1DB168[BYTE1(v222)]
       ^ dword_1DB568[BYTE2(v221)];
  v399 = sub_189250(a2 + 48);
  v260 = v399 ^ v259;
  v391 = sub_189250(a2 + 52);
  v248 = v391 ^ v247;
  v383 = sub_189250(a2 + 56);
  v237 = v383 ^ v236;
  v375 = sub_189250(a2 + 60);
  v529 = dword_1DB968[(v375 ^ (unsigned int)v228) >> 24]
       ^ dword_1DAD68[(unsigned __int8)v260]
       ^ dword_1DB168[BYTE1(v248)]
       ^ dword_1DB568[BYTE2(v237)]
       ^ v528;
  v526 = dword_1DB968[HIBYTE(v260)]
       ^ dword_1DAD68[(unsigned __int8)v248]
       ^ dword_1DB168[BYTE1(v237)]
       ^ dword_1DB568[(unsigned __int8)((v375 ^ (unsigned int)v228) >> 16)]
       ^ v525;
  v523 = dword_1DB968[HIBYTE(v248)]
       ^ dword_1DAD68[(unsigned __int8)v237]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v375 ^ v228) >> 8)]
       ^ dword_1DB568[BYTE2(v260)]
       ^ v522;
  v520 = dword_1DB968[HIBYTE(v237)]
       ^ dword_1DAD68[(unsigned __int8)(v375 ^ v228)]
       ^ dword_1DB168[BYTE1(v260)]
       ^ dword_1DB568[BYTE2(v248)]
       ^ v519;
  v371 = sub_189250(a2 + 64);
  v364 = sub_189250(a2 + 68);
  v357 = sub_189250(a2 + 72);
  v350 = sub_189250(a2 + 76);
  v261 = dword_1DB968[(v350 ^ (unsigned int)v483) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v371 ^ v492)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v364 ^ v489) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v357 ^ (unsigned int)v486) >> 16)];
  v249 = dword_1DB968[(v371 ^ v492) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v364 ^ v489)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v357 ^ v486) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v350 ^ (unsigned int)v483) >> 16)];
  v238 = dword_1DB968[(v364 ^ (unsigned int)v489) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v357 ^ v486)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v350 ^ v483) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v371 ^ v492) >> 16)];
  v229 = dword_1DB968[(v357 ^ (unsigned int)v486) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v350 ^ v483)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v371 ^ v492) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v364 ^ (unsigned int)v489) >> 16)];
  v345 = sub_189250(a2 + 80);
  v337 = sub_189250(a2 + 84);
  v329 = sub_189250(a2 + 88);
  v321 = sub_189250(a2 + 92);
  v219 = v345 ^ v261;
  v218 = v337 ^ v249;
  v217 = v329 ^ v238;
  v262 = dword_1DB968[(v321 ^ (unsigned int)v229) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v345 ^ v261)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v337 ^ v249) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v329 ^ (unsigned int)v238) >> 16)];
  v250 = dword_1DB968[HIBYTE(v219)]
       ^ dword_1DAD68[(unsigned __int8)(v337 ^ v249)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v329 ^ v238) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v321 ^ (unsigned int)v229) >> 16)];
  v239 = dword_1DB968[HIBYTE(v218)]
       ^ dword_1DAD68[(unsigned __int8)(v329 ^ v238)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v321 ^ v229) >> 8)]
       ^ dword_1DB568[BYTE2(v219)];
  v230 = dword_1DB968[HIBYTE(v217)]
       ^ dword_1DAD68[(unsigned __int8)(v321 ^ v229)]
       ^ dword_1DB168[BYTE1(v219)]
       ^ dword_1DB568[BYTE2(v218)];
  v316 = sub_189250(a2 + 96);
  v308 = sub_189250(a2 + 100);
  v300 = sub_189250(a2 + 104);
  v292 = sub_189250(a2 + 108);
  v216 = v316 ^ v262;
  v215 = v308 ^ v250;
  v214 = v300 ^ v239;
  v263 = dword_1DB968[(v292 ^ (unsigned int)v230) >> 24]
       ^ dword_1DAD68[(unsigned __int8)(v316 ^ v262)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v308 ^ v250) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v300 ^ (unsigned int)v239) >> 16)];
  v251 = dword_1DB968[HIBYTE(v216)]
       ^ dword_1DAD68[(unsigned __int8)(v308 ^ v250)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v300 ^ v239) >> 8)]
       ^ dword_1DB568[(unsigned __int8)((v292 ^ (unsigned int)v230) >> 16)];
  v240 = dword_1DB968[HIBYTE(v215)]
       ^ dword_1DAD68[(unsigned __int8)(v300 ^ v239)]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v292 ^ v230) >> 8)]
       ^ dword_1DB568[BYTE2(v216)];
  v231 = dword_1DB968[HIBYTE(v214)]
       ^ dword_1DAD68[(unsigned __int8)(v292 ^ v230)]
       ^ dword_1DB168[BYTE1(v216)]
       ^ dword_1DB568[BYTE2(v215)];
  v288 = sub_189250(a2 + 112);
  v264 = v288 ^ v263;
  v282 = sub_189250(a2 + 116);
  v252 = v282 ^ v251;
  v276 = sub_189250(a2 + 120);
  v241 = v276 ^ v240;
  result = sub_189250(a2 + 124);
  v270 = result;
  v505 = dword_1DB968[(result ^ (unsigned int)v231) >> 24]
       ^ dword_1DAD68[(unsigned __int8)v264]
       ^ dword_1DB168[BYTE1(v252)]
       ^ dword_1DB568[BYTE2(v241)]
       ^ v504;
  v502 = dword_1DB968[HIBYTE(v264)]
       ^ dword_1DAD68[(unsigned __int8)v252]
       ^ dword_1DB168[BYTE1(v241)]
       ^ dword_1DB568[(unsigned __int8)((result ^ (unsigned int)v231) >> 16)]
       ^ v501;
  v499 = dword_1DB968[HIBYTE(v252)]
       ^ dword_1DAD68[(unsigned __int8)v241]
       ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(result ^ v231) >> 8)]
       ^ dword_1DB568[BYTE2(v264)]
       ^ v498;
  v496 = dword_1DB968[HIBYTE(v241)]
       ^ dword_1DAD68[(unsigned __int8)(result ^ v231)]
       ^ dword_1DB168[BYTE1(v264)]
       ^ dword_1DB568[BYTE2(v252)]
       ^ v495;
  for ( i = 0; i <= 2; ++i )
  {
    v213 = v472;
    v212 = v465;
    v211 = v458;
    v473 = dword_1DB968[HIBYTE(v479)]
         ^ dword_1DAD68[(unsigned __int8)v472]
         ^ dword_1DB168[BYTE1(v465)]
         ^ dword_1DB568[BYTE2(v458)];
    v466 = dword_1DB968[HIBYTE(v213)]
         ^ dword_1DAD68[(unsigned __int8)v465]
         ^ dword_1DB168[BYTE1(v458)]
         ^ dword_1DB568[BYTE2(v479)];
    v459 = dword_1DB968[HIBYTE(v212)]
         ^ dword_1DAD68[(unsigned __int8)v458]
         ^ dword_1DB168[BYTE1(v479)]
         ^ dword_1DB568[BYTE2(v213)];
    v210 = dword_1DB968[HIBYTE(v211)]
         ^ dword_1DAD68[(unsigned __int8)v479]
         ^ dword_1DB168[BYTE1(v213)]
         ^ dword_1DB568[BYTE2(v212)];
    v480 = v288 ^ v473;
    v474 = v282 ^ v466;
    v467 = v276 ^ v459;
    v460 = v270 ^ v210;
    if ( !i )
    {
      v480 ^= a1[49];
      v474 ^= a1[50];
      v467 ^= a1[51];
      v460 ^= ~a1[52];
    }
    v265 = dword_1DB968[(v460 ^ (unsigned int)v520) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v480 ^ v529)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v474 ^ v526) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v467 ^ (unsigned int)v523) >> 16)];
    v253 = dword_1DB968[(v480 ^ (unsigned int)v529) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v474 ^ v526)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v467 ^ v523) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v460 ^ (unsigned int)v520) >> 16)];
    v242 = dword_1DB968[(v474 ^ (unsigned int)v526) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v467 ^ v523)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v460 ^ v520) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v480 ^ (unsigned int)v529) >> 16)];
    v232 = dword_1DB968[(v467 ^ (unsigned int)v523) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v460 ^ v520)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v480 ^ v529) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v474 ^ (unsigned int)v526) >> 16)];
    v209 = v445;
    v208 = v437;
    v207 = v429;
    v446 = dword_1DB968[HIBYTE(v453)]
         ^ dword_1DAD68[(unsigned __int8)v445]
         ^ dword_1DB168[BYTE1(v437)]
         ^ dword_1DB568[BYTE2(v429)];
    v438 = dword_1DB968[HIBYTE(v209)]
         ^ dword_1DAD68[(unsigned __int8)v437]
         ^ dword_1DB168[BYTE1(v429)]
         ^ dword_1DB568[BYTE2(v453)];
    v430 = dword_1DB968[HIBYTE(v208)]
         ^ dword_1DAD68[(unsigned __int8)v429]
         ^ dword_1DB168[BYTE1(v453)]
         ^ dword_1DB568[BYTE2(v209)];
    v206 = dword_1DB968[HIBYTE(v207)]
         ^ dword_1DAD68[(unsigned __int8)v453]
         ^ dword_1DB168[BYTE1(v209)]
         ^ dword_1DB568[BYTE2(v208)];
    v454 = v480 ^ v446;
    v447 = v474 ^ v438;
    v439 = v467 ^ v430;
    v431 = v460 ^ v206;
    if ( i == 1 )
    {
      v454 ^= a1[52];
      v447 ^= a1[51];
      v439 ^= a1[50];
      v431 ^= ~a1[49];
    }
    v205 = v454 ^ v265;
    v204 = v447 ^ v253;
    v203 = v439 ^ v242;
    v266 = dword_1DB968[(v431 ^ (unsigned int)v232) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v454 ^ v265)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v447 ^ v253) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v439 ^ (unsigned int)v242) >> 16)];
    v254 = dword_1DB968[HIBYTE(v205)]
         ^ dword_1DAD68[(unsigned __int8)(v447 ^ v253)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v439 ^ v242) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v431 ^ (unsigned int)v232) >> 16)];
    v243 = dword_1DB968[HIBYTE(v204)]
         ^ dword_1DAD68[(unsigned __int8)(v439 ^ v242)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v431 ^ v232) >> 8)]
         ^ dword_1DB568[BYTE2(v205)];
    v202 = v418;
    v201 = v411;
    v200 = v404;
    v419 = dword_1DB968[HIBYTE(v425)]
         ^ dword_1DAD68[(unsigned __int8)v418]
         ^ dword_1DB168[BYTE1(v411)]
         ^ dword_1DB568[BYTE2(v404)];
    v412 = dword_1DB968[HIBYTE(v202)]
         ^ dword_1DAD68[(unsigned __int8)v411]
         ^ dword_1DB168[BYTE1(v404)]
         ^ dword_1DB568[BYTE2(v425)];
    v405 = dword_1DB968[HIBYTE(v201)]
         ^ dword_1DAD68[(unsigned __int8)v404]
         ^ dword_1DB168[BYTE1(v425)]
         ^ dword_1DB568[BYTE2(v202)];
    v199 = dword_1DB968[HIBYTE(v200)]
         ^ dword_1DAD68[(unsigned __int8)v425]
         ^ dword_1DB168[BYTE1(v202)]
         ^ dword_1DB568[BYTE2(v201)];
    v426 = v454 ^ v419;
    v420 = v447 ^ v412;
    v413 = v439 ^ v405;
    v406 = v431 ^ v199;
    v198 = v426 ^ v266;
    v197 = v420 ^ v254;
    v196 = v431
         ^ v199
         ^ dword_1DB968[HIBYTE(v203)]
         ^ dword_1DAD68[(unsigned __int8)(v431 ^ v232)]
         ^ dword_1DB168[BYTE1(v205)]
         ^ dword_1DB568[BYTE2(v204)];
    v267 = dword_1DB968[HIBYTE(v196)]
         ^ dword_1DAD68[(unsigned __int8)(v426 ^ v266)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v420 ^ v254) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v413 ^ (unsigned int)v243) >> 16)];
    v255 = dword_1DB968[HIBYTE(v198)]
         ^ dword_1DAD68[(unsigned __int8)(v420 ^ v254)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v413 ^ v243) >> 8)]
         ^ dword_1DB568[BYTE2(v196)];
    v195 = v391;
    v194 = v383;
    v193 = v375;
    v392 = dword_1DB968[HIBYTE(v399)]
         ^ dword_1DAD68[(unsigned __int8)v391]
         ^ dword_1DB168[BYTE1(v383)]
         ^ dword_1DB568[BYTE2(v375)];
    v384 = dword_1DB968[HIBYTE(v195)]
         ^ dword_1DAD68[(unsigned __int8)v383]
         ^ dword_1DB168[BYTE1(v375)]
         ^ dword_1DB568[BYTE2(v399)];
    v376 = dword_1DB968[HIBYTE(v194)]
         ^ dword_1DAD68[(unsigned __int8)v375]
         ^ dword_1DB168[BYTE1(v399)]
         ^ dword_1DB568[BYTE2(v195)];
    v192 = dword_1DB968[HIBYTE(v193)]
         ^ dword_1DAD68[(unsigned __int8)v399]
         ^ dword_1DB168[BYTE1(v195)]
         ^ dword_1DB568[BYTE2(v194)];
    v400 = v426 ^ v392;
    v393 = v420 ^ v384;
    v385 = v413 ^ v376;
    v377 = v431 ^ v199 ^ v192;
    v191 = v385
         ^ dword_1DB968[HIBYTE(v197)]
         ^ dword_1DAD68[(unsigned __int8)(v413 ^ v243)]
         ^ dword_1DB168[BYTE1(v196)]
         ^ dword_1DB568[BYTE2(v198)];
    v190 = v377
         ^ dword_1DB968[(v413 ^ (unsigned int)v243) >> 24]
         ^ dword_1DAD68[(unsigned __int8)v196]
         ^ dword_1DB168[BYTE1(v198)]
         ^ dword_1DB568[BYTE2(v197)];
    v493 = dword_1DB968[HIBYTE(v190)]
         ^ dword_1DAD68[(unsigned __int8)(v400 ^ v267)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v393 ^ v255) >> 8)]
         ^ dword_1DB568[BYTE2(v191)]
         ^ v492;
    v490 = dword_1DB968[(v400 ^ (unsigned int)v267) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v393 ^ v255)]
         ^ dword_1DB168[BYTE1(v191)]
         ^ dword_1DB568[BYTE2(v190)]
         ^ v489;
    v487 = dword_1DB968[(v393 ^ (unsigned int)v255) >> 24]
         ^ dword_1DAD68[(unsigned __int8)v191]
         ^ dword_1DB168[BYTE1(v190)]
         ^ dword_1DB568[(unsigned __int8)((v400 ^ (unsigned int)v267) >> 16)]
         ^ v486;
    v484 = dword_1DB968[HIBYTE(v191)]
         ^ dword_1DAD68[(unsigned __int8)v190]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v400 ^ v267) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v393 ^ (unsigned int)v255) >> 16)]
         ^ v483;
    v189 = v364;
    v188 = v357;
    v187 = v350;
    v365 = dword_1DB968[HIBYTE(v371)]
         ^ dword_1DAD68[(unsigned __int8)v364]
         ^ dword_1DB168[BYTE1(v357)]
         ^ dword_1DB568[BYTE2(v350)];
    v358 = dword_1DB968[HIBYTE(v189)]
         ^ dword_1DAD68[(unsigned __int8)v357]
         ^ dword_1DB168[BYTE1(v350)]
         ^ dword_1DB568[BYTE2(v371)];
    v351 = dword_1DB968[HIBYTE(v188)]
         ^ dword_1DAD68[(unsigned __int8)v350]
         ^ dword_1DB168[BYTE1(v371)]
         ^ dword_1DB568[BYTE2(v189)];
    v186 = dword_1DB968[HIBYTE(v187)]
         ^ dword_1DAD68[(unsigned __int8)v371]
         ^ dword_1DB168[BYTE1(v189)]
         ^ dword_1DB568[BYTE2(v188)];
    v372 = v400 ^ v365;
    v366 = v393 ^ v358;
    v359 = v385 ^ v351;
    v352 = v377 ^ v186;
    v185 = v377 ^ v186 ^ v496;
    v184 = v337;
    v183 = v329;
    v182 = v321;
    v338 = dword_1DB968[HIBYTE(v345)]
         ^ dword_1DAD68[(unsigned __int8)v337]
         ^ dword_1DB168[BYTE1(v329)]
         ^ dword_1DB568[BYTE2(v321)];
    v330 = dword_1DB968[HIBYTE(v184)]
         ^ dword_1DAD68[(unsigned __int8)v329]
         ^ dword_1DB168[BYTE1(v321)]
         ^ dword_1DB568[BYTE2(v345)];
    v322 = dword_1DB968[HIBYTE(v183)]
         ^ dword_1DAD68[(unsigned __int8)v321]
         ^ dword_1DB168[BYTE1(v345)]
         ^ dword_1DB568[BYTE2(v184)];
    v181 = dword_1DB968[HIBYTE(v182)]
         ^ dword_1DAD68[(unsigned __int8)v345]
         ^ dword_1DB168[BYTE1(v184)]
         ^ dword_1DB568[BYTE2(v183)];
    v346 = v372 ^ v338;
    v339 = v366 ^ v330;
    v331 = v359 ^ v322;
    v323 = v377 ^ v186 ^ v181;
    v180 = v346
         ^ dword_1DB968[HIBYTE(v185)]
         ^ dword_1DAD68[(unsigned __int8)(v372 ^ v505)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v366 ^ v502) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v359 ^ (unsigned int)v499) >> 16)];
    v179 = v339
         ^ dword_1DB968[(v372 ^ (unsigned int)v505) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v366 ^ v502)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v359 ^ v499) >> 8)]
         ^ dword_1DB568[BYTE2(v185)];
    v178 = v331
         ^ dword_1DB968[(v366 ^ (unsigned int)v502) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v359 ^ v499)]
         ^ dword_1DB168[BYTE1(v185)]
         ^ dword_1DB568[(unsigned __int8)((v372 ^ (unsigned int)v505) >> 16)];
    v177 = v323
         ^ dword_1DB968[(v359 ^ (unsigned int)v499) >> 24]
         ^ dword_1DAD68[(unsigned __int8)v185]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v372 ^ v505) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v366 ^ (unsigned int)v502) >> 16)];
    v176 = v308;
    v175 = v300;
    v174 = v292;
    v309 = dword_1DB968[HIBYTE(v316)]
         ^ dword_1DAD68[(unsigned __int8)v308]
         ^ dword_1DB168[BYTE1(v300)]
         ^ dword_1DB568[BYTE2(v292)];
    v301 = dword_1DB968[HIBYTE(v176)]
         ^ dword_1DAD68[(unsigned __int8)v300]
         ^ dword_1DB168[BYTE1(v292)]
         ^ dword_1DB568[BYTE2(v316)];
    v293 = dword_1DB968[HIBYTE(v175)]
         ^ dword_1DAD68[(unsigned __int8)v292]
         ^ dword_1DB168[BYTE1(v316)]
         ^ dword_1DB568[BYTE2(v176)];
    v173 = dword_1DB968[HIBYTE(v174)]
         ^ dword_1DAD68[(unsigned __int8)v316]
         ^ dword_1DB168[BYTE1(v176)]
         ^ dword_1DB568[BYTE2(v175)];
    v317 = v346 ^ v309;
    v310 = v339 ^ v301;
    v302 = v331 ^ v293;
    v294 = v323 ^ v173;
    v172 = v317
         ^ dword_1DB968[HIBYTE(v177)]
         ^ dword_1DAD68[(unsigned __int8)v180]
         ^ dword_1DB168[BYTE1(v179)]
         ^ dword_1DB568[BYTE2(v178)];
    v171 = v310
         ^ dword_1DB968[HIBYTE(v180)]
         ^ dword_1DAD68[(unsigned __int8)v179]
         ^ dword_1DB168[BYTE1(v178)]
         ^ dword_1DB568[BYTE2(v177)];
    v170 = v302
         ^ dword_1DB968[HIBYTE(v179)]
         ^ dword_1DAD68[(unsigned __int8)v178]
         ^ dword_1DB168[BYTE1(v177)]
         ^ dword_1DB568[BYTE2(v180)];
    v169 = v323
         ^ v173
         ^ dword_1DB968[HIBYTE(v178)]
         ^ dword_1DAD68[(unsigned __int8)v177]
         ^ dword_1DB168[BYTE1(v180)]
         ^ dword_1DB568[BYTE2(v179)];
    v268 = dword_1DB968[HIBYTE(v169)]
         ^ dword_1DAD68[(unsigned __int8)v172]
         ^ dword_1DB168[BYTE1(v171)]
         ^ dword_1DB568[BYTE2(v170)];
    v256 = dword_1DB968[HIBYTE(v172)]
         ^ dword_1DAD68[(unsigned __int8)v171]
         ^ dword_1DB168[BYTE1(v170)]
         ^ dword_1DB568[BYTE2(v169)];
    v244 = dword_1DB968[HIBYTE(v171)]
         ^ dword_1DAD68[(unsigned __int8)v170]
         ^ dword_1DB168[BYTE1(v169)]
         ^ dword_1DB568[BYTE2(v172)];
    v233 = dword_1DB968[HIBYTE(v170)]
         ^ dword_1DAD68[(unsigned __int8)v169]
         ^ dword_1DB168[BYTE1(v172)]
         ^ dword_1DB568[BYTE2(v171)];
    v168 = v282;
    v167 = v276;
    v166 = v270;
    v283 = dword_1DB968[HIBYTE(v288)]
         ^ dword_1DAD68[(unsigned __int8)v282]
         ^ dword_1DB168[BYTE1(v276)]
         ^ dword_1DB568[BYTE2(v270)];
    v277 = dword_1DB968[HIBYTE(v168)]
         ^ dword_1DAD68[(unsigned __int8)v276]
         ^ dword_1DB168[BYTE1(v270)]
         ^ dword_1DB568[BYTE2(v288)];
    v271 = dword_1DB968[HIBYTE(v167)]
         ^ dword_1DAD68[(unsigned __int8)v270]
         ^ dword_1DB168[BYTE1(v288)]
         ^ dword_1DB568[BYTE2(v168)];
    v165 = dword_1DB968[HIBYTE(v166)]
         ^ dword_1DAD68[(unsigned __int8)v288]
         ^ dword_1DB168[BYTE1(v168)]
         ^ dword_1DB568[BYTE2(v167)];
    v289 = v317 ^ v283;
    v284 = v310 ^ v277;
    v278 = v302 ^ v271;
    v272 = v323 ^ v173 ^ v165;
    if ( i == 2 )
    {
      v289 ^= a1[51];
      v284 ^= a1[52];
      v278 ^= a1[49];
      v272 ^= ~a1[50];
    }
    v517 = dword_1DB968[(v272 ^ (unsigned int)v233) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v289 ^ v268)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v284 ^ v256) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v278 ^ (unsigned int)v244) >> 16)]
         ^ v516;
    v514 = dword_1DB968[(v289 ^ (unsigned int)v268) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v284 ^ v256)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v278 ^ v244) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v272 ^ (unsigned int)v233) >> 16)]
         ^ v513;
    v511 = dword_1DB968[(v284 ^ (unsigned int)v256) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v278 ^ v244)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v272 ^ v233) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v289 ^ (unsigned int)v268) >> 16)]
         ^ v510;
    v508 = dword_1DB968[(v278 ^ (unsigned int)v244) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v272 ^ v233)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v289 ^ v268) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v284 ^ (unsigned int)v256) >> 16)]
         ^ v507;
    v481 = v310 ^ v480;
    v475 = v302 ^ v474;
    v468 = v294 ^ v467;
    v461 = v289 ^ v460;
    v455 = v284 ^ v454;
    v448 = v278 ^ v447;
    v440 = v272 ^ v439;
    v432 = v481 ^ v431;
    v164 = v455
         ^ dword_1DB968[(v461 ^ (unsigned int)v484) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v481 ^ v493)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v475 ^ v490) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v468 ^ (unsigned int)v487) >> 16)];
    v163 = v448
         ^ dword_1DB968[(v481 ^ v493) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v475 ^ v490)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v468 ^ v487) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v461 ^ (unsigned int)v484) >> 16)];
    v162 = v440
         ^ dword_1DB968[(v475 ^ (unsigned int)v490) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v468 ^ v487)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v461 ^ v484) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v481 ^ v493) >> 16)];
    v161 = v432
         ^ dword_1DB968[(v468 ^ (unsigned int)v487) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v461 ^ v484)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v481 ^ v493) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v475 ^ (unsigned int)v490) >> 16)];
    v427 = v475 ^ v426;
    v421 = v468 ^ v420;
    v414 = v461 ^ v413;
    v407 = v455 ^ v406;
    v160 = v427
         ^ dword_1DB968[HIBYTE(v161)]
         ^ dword_1DAD68[(unsigned __int8)v164]
         ^ dword_1DB168[BYTE1(v163)]
         ^ dword_1DB568[BYTE2(v162)];
    v159 = v421
         ^ dword_1DB968[HIBYTE(v164)]
         ^ dword_1DAD68[(unsigned __int8)v163]
         ^ dword_1DB168[BYTE1(v162)]
         ^ dword_1DB568[BYTE2(v161)];
    v158 = v414
         ^ dword_1DB968[HIBYTE(v163)]
         ^ dword_1DAD68[(unsigned __int8)v162]
         ^ dword_1DB168[BYTE1(v161)]
         ^ dword_1DB568[BYTE2(v164)];
    v157 = v407
         ^ dword_1DB968[HIBYTE(v162)]
         ^ dword_1DAD68[(unsigned __int8)v161]
         ^ dword_1DB168[BYTE1(v164)]
         ^ dword_1DB568[BYTE2(v163)];
    v401 = v448 ^ v400;
    v394 = v440 ^ v393;
    v386 = v432 ^ v385;
    v378 = v427 ^ v377;
    v156 = v401
         ^ dword_1DB968[HIBYTE(v157)]
         ^ dword_1DAD68[(unsigned __int8)v160]
         ^ dword_1DB168[BYTE1(v159)]
         ^ dword_1DB568[BYTE2(v158)];
    v155 = v394
         ^ dword_1DB968[HIBYTE(v160)]
         ^ dword_1DAD68[(unsigned __int8)v159]
         ^ dword_1DB168[BYTE1(v158)]
         ^ dword_1DB568[BYTE2(v157)];
    v154 = v386
         ^ dword_1DB968[HIBYTE(v159)]
         ^ dword_1DAD68[(unsigned __int8)v158]
         ^ dword_1DB168[BYTE1(v157)]
         ^ dword_1DB568[BYTE2(v160)];
    v153 = v378
         ^ dword_1DB968[HIBYTE(v158)]
         ^ dword_1DAD68[(unsigned __int8)v157]
         ^ dword_1DB168[BYTE1(v160)]
         ^ dword_1DB568[BYTE2(v159)];
    v506 = dword_1DB968[HIBYTE(v153)]
         ^ dword_1DAD68[(unsigned __int8)v156]
         ^ dword_1DB168[BYTE1(v155)]
         ^ dword_1DB568[BYTE2(v154)]
         ^ v505;
    v503 = dword_1DB968[HIBYTE(v156)]
         ^ dword_1DAD68[(unsigned __int8)v155]
         ^ dword_1DB168[BYTE1(v154)]
         ^ dword_1DB568[BYTE2(v153)]
         ^ v502;
    v500 = dword_1DB968[HIBYTE(v155)]
         ^ dword_1DAD68[(unsigned __int8)v154]
         ^ dword_1DB168[BYTE1(v153)]
         ^ dword_1DB568[BYTE2(v156)]
         ^ v499;
    v497 = dword_1DB968[HIBYTE(v154)]
         ^ dword_1DAD68[(unsigned __int8)v153]
         ^ dword_1DB168[BYTE1(v156)]
         ^ dword_1DB568[BYTE2(v155)]
         ^ v496;
    v373 = v421 ^ v372;
    v367 = v414 ^ v366;
    v360 = v407 ^ v359;
    v353 = v401 ^ v352;
    v347 = v394 ^ v346;
    v340 = v386 ^ v339;
    v332 = v378 ^ v331;
    v324 = v373 ^ v323;
    v152 = v347
         ^ dword_1DB968[(v353 ^ (unsigned int)v508) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v373 ^ v517)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v367 ^ v514) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v360 ^ (unsigned int)v511) >> 16)];
    v151 = v340
         ^ dword_1DB968[(v373 ^ v517) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v367 ^ v514)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v360 ^ v511) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v353 ^ (unsigned int)v508) >> 16)];
    v150 = v332
         ^ dword_1DB968[(v367 ^ (unsigned int)v514) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v360 ^ v511)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v353 ^ v508) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v373 ^ v517) >> 16)];
    v149 = v324
         ^ dword_1DB968[(v360 ^ (unsigned int)v511) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v353 ^ v508)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v373 ^ v517) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v367 ^ (unsigned int)v514) >> 16)];
    v318 = v367 ^ v317;
    v311 = v360 ^ v310;
    v303 = v353 ^ v302;
    v295 = v347 ^ v294;
    v148 = v318
         ^ dword_1DB968[HIBYTE(v149)]
         ^ dword_1DAD68[(unsigned __int8)v152]
         ^ dword_1DB168[BYTE1(v151)]
         ^ dword_1DB568[BYTE2(v150)];
    v147 = v311
         ^ dword_1DB968[HIBYTE(v152)]
         ^ dword_1DAD68[(unsigned __int8)v151]
         ^ dword_1DB168[BYTE1(v150)]
         ^ dword_1DB568[BYTE2(v149)];
    v146 = v303
         ^ dword_1DB968[HIBYTE(v151)]
         ^ dword_1DAD68[(unsigned __int8)v150]
         ^ dword_1DB168[BYTE1(v149)]
         ^ dword_1DB568[BYTE2(v152)];
    v145 = v295
         ^ dword_1DB968[HIBYTE(v150)]
         ^ dword_1DAD68[(unsigned __int8)v149]
         ^ dword_1DB168[BYTE1(v152)]
         ^ dword_1DB568[BYTE2(v151)];
    v290 = v340 ^ v289;
    v285 = v332 ^ v284;
    v279 = v324 ^ v278;
    v273 = v318 ^ v272;
    v144 = v290
         ^ dword_1DB968[HIBYTE(v145)]
         ^ dword_1DAD68[(unsigned __int8)v148]
         ^ dword_1DB168[BYTE1(v147)]
         ^ dword_1DB568[BYTE2(v146)];
    v143 = v285
         ^ dword_1DB968[HIBYTE(v148)]
         ^ dword_1DAD68[(unsigned __int8)v147]
         ^ dword_1DB168[BYTE1(v146)]
         ^ dword_1DB568[BYTE2(v145)];
    v142 = v279
         ^ dword_1DB968[HIBYTE(v147)]
         ^ dword_1DAD68[(unsigned __int8)v146]
         ^ dword_1DB168[BYTE1(v145)]
         ^ dword_1DB568[BYTE2(v148)];
    v141 = v273
         ^ dword_1DB968[HIBYTE(v146)]
         ^ dword_1DAD68[(unsigned __int8)v145]
         ^ dword_1DB168[BYTE1(v148)]
         ^ dword_1DB568[BYTE2(v147)];
    v530 = dword_1DB968[HIBYTE(v141)]
         ^ dword_1DAD68[(unsigned __int8)v144]
         ^ dword_1DB168[BYTE1(v143)]
         ^ dword_1DB568[BYTE2(v142)]
         ^ v529;
    v527 = dword_1DB968[HIBYTE(v144)]
         ^ dword_1DAD68[(unsigned __int8)v143]
         ^ dword_1DB168[BYTE1(v142)]
         ^ dword_1DB568[BYTE2(v141)]
         ^ v526;
    v524 = dword_1DB968[HIBYTE(v143)]
         ^ dword_1DAD68[(unsigned __int8)v142]
         ^ dword_1DB168[BYTE1(v141)]
         ^ dword_1DB568[BYTE2(v144)]
         ^ v523;
    v521 = dword_1DB968[HIBYTE(v142)]
         ^ dword_1DAD68[(unsigned __int8)v141]
         ^ dword_1DB168[BYTE1(v144)]
         ^ dword_1DB568[BYTE2(v143)]
         ^ v520;
    v140 = v475;
    v139 = v468;
    v138 = v461;
    v476 = dword_1DB968[HIBYTE(v481)]
         ^ dword_1DAD68[(unsigned __int8)v475]
         ^ dword_1DB168[BYTE1(v468)]
         ^ dword_1DB568[BYTE2(v461)];
    v469 = dword_1DB968[HIBYTE(v140)]
         ^ dword_1DAD68[(unsigned __int8)v468]
         ^ dword_1DB168[BYTE1(v461)]
         ^ dword_1DB568[BYTE2(v481)];
    v462 = dword_1DB968[HIBYTE(v139)]
         ^ dword_1DAD68[(unsigned __int8)v461]
         ^ dword_1DB168[BYTE1(v481)]
         ^ dword_1DB568[BYTE2(v140)];
    v137 = dword_1DB968[HIBYTE(v138)]
         ^ dword_1DAD68[(unsigned __int8)v481]
         ^ dword_1DB168[BYTE1(v140)]
         ^ dword_1DB568[BYTE2(v139)];
    v482 = v290 ^ v476;
    v477 = v285 ^ v469;
    v470 = v279 ^ v462;
    v463 = v273 ^ v137;
    v136 = v273 ^ v137 ^ v497;
    v135 = v448;
    v134 = v440;
    v133 = v432;
    v449 = dword_1DB968[HIBYTE(v455)]
         ^ dword_1DAD68[(unsigned __int8)v448]
         ^ dword_1DB168[BYTE1(v440)]
         ^ dword_1DB568[BYTE2(v432)];
    v441 = dword_1DB968[HIBYTE(v135)]
         ^ dword_1DAD68[(unsigned __int8)v440]
         ^ dword_1DB168[BYTE1(v432)]
         ^ dword_1DB568[BYTE2(v455)];
    v433 = dword_1DB968[HIBYTE(v134)]
         ^ dword_1DAD68[(unsigned __int8)v432]
         ^ dword_1DB168[BYTE1(v455)]
         ^ dword_1DB568[BYTE2(v135)];
    v132 = dword_1DB968[HIBYTE(v133)]
         ^ dword_1DAD68[(unsigned __int8)v455]
         ^ dword_1DB168[BYTE1(v135)]
         ^ dword_1DB568[BYTE2(v134)];
    v456 = v482 ^ v449;
    v450 = v477 ^ v441;
    v442 = v470 ^ v433;
    v434 = v273 ^ v137 ^ v132;
    v131 = v456
         ^ dword_1DB968[HIBYTE(v136)]
         ^ dword_1DAD68[(unsigned __int8)(v482 ^ v506)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v477 ^ v503) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v470 ^ (unsigned int)v500) >> 16)];
    v130 = v450
         ^ dword_1DB968[(v482 ^ (unsigned int)v506) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v477 ^ v503)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v470 ^ v500) >> 8)]
         ^ dword_1DB568[BYTE2(v136)];
    v129 = v442
         ^ dword_1DB968[(v477 ^ (unsigned int)v503) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v470 ^ v500)]
         ^ dword_1DB168[BYTE1(v136)]
         ^ dword_1DB568[(unsigned __int8)((v482 ^ (unsigned int)v506) >> 16)];
    v128 = v434
         ^ dword_1DB968[(v470 ^ (unsigned int)v500) >> 24]
         ^ dword_1DAD68[(unsigned __int8)v136]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v482 ^ v506) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v477 ^ (unsigned int)v503) >> 16)];
    v127 = v421;
    v126 = v414;
    v125 = v407;
    v422 = dword_1DB968[HIBYTE(v427)]
         ^ dword_1DAD68[(unsigned __int8)v421]
         ^ dword_1DB168[BYTE1(v414)]
         ^ dword_1DB568[BYTE2(v407)];
    v415 = dword_1DB968[HIBYTE(v127)]
         ^ dword_1DAD68[(unsigned __int8)v414]
         ^ dword_1DB168[BYTE1(v407)]
         ^ dword_1DB568[BYTE2(v427)];
    v408 = dword_1DB968[HIBYTE(v126)]
         ^ dword_1DAD68[(unsigned __int8)v407]
         ^ dword_1DB168[BYTE1(v427)]
         ^ dword_1DB568[BYTE2(v127)];
    v124 = dword_1DB968[HIBYTE(v125)]
         ^ dword_1DAD68[(unsigned __int8)v427]
         ^ dword_1DB168[BYTE1(v127)]
         ^ dword_1DB568[BYTE2(v126)];
    v428 = v456 ^ v422;
    v423 = v450 ^ v415;
    v416 = v442 ^ v408;
    v409 = v434 ^ v124;
    v123 = v428
         ^ dword_1DB968[HIBYTE(v128)]
         ^ dword_1DAD68[(unsigned __int8)v131]
         ^ dword_1DB168[BYTE1(v130)]
         ^ dword_1DB568[BYTE2(v129)];
    v122 = v423
         ^ dword_1DB968[HIBYTE(v131)]
         ^ dword_1DAD68[(unsigned __int8)v130]
         ^ dword_1DB168[BYTE1(v129)]
         ^ dword_1DB568[BYTE2(v128)];
    v121 = v416
         ^ dword_1DB968[HIBYTE(v130)]
         ^ dword_1DAD68[(unsigned __int8)v129]
         ^ dword_1DB168[BYTE1(v128)]
         ^ dword_1DB568[BYTE2(v131)];
    v120 = v434
         ^ v124
         ^ dword_1DB968[HIBYTE(v129)]
         ^ dword_1DAD68[(unsigned __int8)v128]
         ^ dword_1DB168[BYTE1(v131)]
         ^ dword_1DB568[BYTE2(v130)];
    v119 = v394;
    v118 = v386;
    v117 = v378;
    v395 = dword_1DB968[HIBYTE(v401)]
         ^ dword_1DAD68[(unsigned __int8)v394]
         ^ dword_1DB168[BYTE1(v386)]
         ^ dword_1DB568[BYTE2(v378)];
    v387 = dword_1DB968[HIBYTE(v119)]
         ^ dword_1DAD68[(unsigned __int8)v386]
         ^ dword_1DB168[BYTE1(v378)]
         ^ dword_1DB568[BYTE2(v401)];
    v379 = dword_1DB968[HIBYTE(v118)]
         ^ dword_1DAD68[(unsigned __int8)v378]
         ^ dword_1DB168[BYTE1(v401)]
         ^ dword_1DB568[BYTE2(v119)];
    v116 = dword_1DB968[HIBYTE(v117)]
         ^ dword_1DAD68[(unsigned __int8)v401]
         ^ dword_1DB168[BYTE1(v119)]
         ^ dword_1DB568[BYTE2(v118)];
    v402 = v428 ^ v395;
    v396 = v423 ^ v387;
    v388 = v416 ^ v379;
    v380 = v434 ^ v124 ^ v116;
    v115 = v402
         ^ dword_1DB968[HIBYTE(v120)]
         ^ dword_1DAD68[(unsigned __int8)v123]
         ^ dword_1DB168[BYTE1(v122)]
         ^ dword_1DB568[BYTE2(v121)];
    v114 = v396
         ^ dword_1DB968[HIBYTE(v123)]
         ^ dword_1DAD68[(unsigned __int8)v122]
         ^ dword_1DB168[BYTE1(v121)]
         ^ dword_1DB568[BYTE2(v120)];
    v113 = v388
         ^ dword_1DB968[HIBYTE(v122)]
         ^ dword_1DAD68[(unsigned __int8)v121]
         ^ dword_1DB168[BYTE1(v120)]
         ^ dword_1DB568[BYTE2(v123)];
    v112 = v380
         ^ dword_1DB968[HIBYTE(v121)]
         ^ dword_1DAD68[(unsigned __int8)v120]
         ^ dword_1DB168[BYTE1(v123)]
         ^ dword_1DB568[BYTE2(v122)];
    v516 = dword_1DB968[HIBYTE(v112)]
         ^ dword_1DAD68[(unsigned __int8)v115]
         ^ dword_1DB168[BYTE1(v114)]
         ^ dword_1DB568[BYTE2(v113)]
         ^ v517;
    v513 = dword_1DB968[HIBYTE(v115)]
         ^ dword_1DAD68[(unsigned __int8)v114]
         ^ dword_1DB168[BYTE1(v113)]
         ^ dword_1DB568[BYTE2(v112)]
         ^ v514;
    v510 = dword_1DB968[HIBYTE(v114)]
         ^ dword_1DAD68[(unsigned __int8)v113]
         ^ dword_1DB168[BYTE1(v112)]
         ^ dword_1DB568[BYTE2(v115)]
         ^ v511;
    v507 = dword_1DB968[HIBYTE(v113)]
         ^ dword_1DAD68[(unsigned __int8)v112]
         ^ dword_1DB168[BYTE1(v115)]
         ^ dword_1DB568[BYTE2(v114)]
         ^ v508;
    v111 = v367;
    v110 = v360;
    v109 = v353;
    v368 = dword_1DB968[HIBYTE(v373)]
         ^ dword_1DAD68[(unsigned __int8)v367]
         ^ dword_1DB168[BYTE1(v360)]
         ^ dword_1DB568[BYTE2(v353)];
    v361 = dword_1DB968[HIBYTE(v111)]
         ^ dword_1DAD68[(unsigned __int8)v360]
         ^ dword_1DB168[BYTE1(v353)]
         ^ dword_1DB568[BYTE2(v373)];
    v354 = dword_1DB968[HIBYTE(v110)]
         ^ dword_1DAD68[(unsigned __int8)v353]
         ^ dword_1DB168[BYTE1(v373)]
         ^ dword_1DB568[BYTE2(v111)];
    v108 = dword_1DB968[HIBYTE(v109)]
         ^ dword_1DAD68[(unsigned __int8)v373]
         ^ dword_1DB168[BYTE1(v111)]
         ^ dword_1DB568[BYTE2(v110)];
    v374 = v402 ^ v368;
    v369 = v396 ^ v361;
    v362 = v388 ^ v354;
    v355 = v380 ^ v108;
    v107 = v380 ^ v108 ^ v521;
    v106 = v340;
    v105 = v332;
    v104 = v324;
    v341 = dword_1DB968[HIBYTE(v347)]
         ^ dword_1DAD68[(unsigned __int8)v340]
         ^ dword_1DB168[BYTE1(v332)]
         ^ dword_1DB568[BYTE2(v324)];
    v333 = dword_1DB968[HIBYTE(v106)]
         ^ dword_1DAD68[(unsigned __int8)v332]
         ^ dword_1DB168[BYTE1(v324)]
         ^ dword_1DB568[BYTE2(v347)];
    v325 = dword_1DB968[HIBYTE(v105)]
         ^ dword_1DAD68[(unsigned __int8)v324]
         ^ dword_1DB168[BYTE1(v347)]
         ^ dword_1DB568[BYTE2(v106)];
    v103 = dword_1DB968[HIBYTE(v104)]
         ^ dword_1DAD68[(unsigned __int8)v347]
         ^ dword_1DB168[BYTE1(v106)]
         ^ dword_1DB568[BYTE2(v105)];
    v348 = v374 ^ v341;
    v342 = v369 ^ v333;
    v334 = v362 ^ v325;
    v326 = v380 ^ v108 ^ v103;
    v102 = v348
         ^ dword_1DB968[HIBYTE(v107)]
         ^ dword_1DAD68[(unsigned __int8)(v374 ^ v530)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v369 ^ v527) >> 8)]
         ^ dword_1DB568[(unsigned __int8)((v362 ^ (unsigned int)v524) >> 16)];
    v101 = v342
         ^ dword_1DB968[(v374 ^ (unsigned int)v530) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v369 ^ v527)]
         ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v362 ^ v524) >> 8)]
         ^ dword_1DB568[BYTE2(v107)];
    v100 = v334
         ^ dword_1DB968[(v369 ^ (unsigned int)v527) >> 24]
         ^ dword_1DAD68[(unsigned __int8)(v362 ^ v524)]
         ^ dword_1DB168[BYTE1(v107)]
         ^ dword_1DB568[(unsigned __int8)((v374 ^ (unsigned int)v530) >> 16)];
    v99 = v326
        ^ dword_1DB968[(v362 ^ (unsigned int)v524) >> 24]
        ^ dword_1DAD68[(unsigned __int8)v107]
        ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v374 ^ v530) >> 8)]
        ^ dword_1DB568[(unsigned __int8)((v369 ^ (unsigned int)v527) >> 16)];
    v98 = v311;
    v97 = v303;
    v96 = v295;
    v312 = dword_1DB968[HIBYTE(v318)]
         ^ dword_1DAD68[(unsigned __int8)v311]
         ^ dword_1DB168[BYTE1(v303)]
         ^ dword_1DB568[BYTE2(v295)];
    v304 = dword_1DB968[HIBYTE(v98)]
         ^ dword_1DAD68[(unsigned __int8)v303]
         ^ dword_1DB168[BYTE1(v295)]
         ^ dword_1DB568[BYTE2(v318)];
    v296 = dword_1DB968[HIBYTE(v97)]
         ^ dword_1DAD68[(unsigned __int8)v295]
         ^ dword_1DB168[BYTE1(v318)]
         ^ dword_1DB568[BYTE2(v98)];
    v95 = dword_1DB968[HIBYTE(v96)]
        ^ dword_1DAD68[(unsigned __int8)v318]
        ^ dword_1DB168[BYTE1(v98)]
        ^ dword_1DB568[BYTE2(v97)];
    v319 = v348 ^ v312;
    v313 = v342 ^ v304;
    v305 = v334 ^ v296;
    v297 = v326 ^ v95;
    v94 = v319
        ^ dword_1DB968[HIBYTE(v99)]
        ^ dword_1DAD68[(unsigned __int8)v102]
        ^ dword_1DB168[BYTE1(v101)]
        ^ dword_1DB568[BYTE2(v100)];
    v93 = v313
        ^ dword_1DB968[HIBYTE(v102)]
        ^ dword_1DAD68[(unsigned __int8)v101]
        ^ dword_1DB168[BYTE1(v100)]
        ^ dword_1DB568[BYTE2(v99)];
    v92 = v305
        ^ dword_1DB968[HIBYTE(v101)]
        ^ dword_1DAD68[(unsigned __int8)v100]
        ^ dword_1DB168[BYTE1(v99)]
        ^ dword_1DB568[BYTE2(v102)];
    v91 = v326
        ^ v95
        ^ dword_1DB968[HIBYTE(v100)]
        ^ dword_1DAD68[(unsigned __int8)v99]
        ^ dword_1DB168[BYTE1(v102)]
        ^ dword_1DB568[BYTE2(v101)];
    v90 = v285;
    v89 = v279;
    v88 = v273;
    v286 = dword_1DB968[HIBYTE(v290)]
         ^ dword_1DAD68[(unsigned __int8)v285]
         ^ dword_1DB168[BYTE1(v279)]
         ^ dword_1DB568[BYTE2(v273)];
    v280 = dword_1DB968[HIBYTE(v90)]
         ^ dword_1DAD68[(unsigned __int8)v279]
         ^ dword_1DB168[BYTE1(v273)]
         ^ dword_1DB568[BYTE2(v290)];
    v274 = dword_1DB968[HIBYTE(v89)]
         ^ dword_1DAD68[(unsigned __int8)v273]
         ^ dword_1DB168[BYTE1(v290)]
         ^ dword_1DB568[BYTE2(v90)];
    v87 = dword_1DB968[HIBYTE(v88)]
        ^ dword_1DAD68[(unsigned __int8)v290]
        ^ dword_1DB168[BYTE1(v90)]
        ^ dword_1DB568[BYTE2(v89)];
    v291 = v319 ^ v286;
    v287 = v313 ^ v280;
    v281 = v305 ^ v274;
    v275 = v326 ^ v95 ^ v87;
    v86 = v291
        ^ dword_1DB968[HIBYTE(v91)]
        ^ dword_1DAD68[(unsigned __int8)v94]
        ^ dword_1DB168[BYTE1(v93)]
        ^ dword_1DB568[BYTE2(v92)];
    v85 = v287
        ^ dword_1DB968[HIBYTE(v94)]
        ^ dword_1DAD68[(unsigned __int8)v93]
        ^ dword_1DB168[BYTE1(v92)]
        ^ dword_1DB568[BYTE2(v91)];
    v84 = v281
        ^ dword_1DB968[HIBYTE(v93)]
        ^ dword_1DAD68[(unsigned __int8)v92]
        ^ dword_1DB168[BYTE1(v91)]
        ^ dword_1DB568[BYTE2(v94)];
    v83 = v275
        ^ dword_1DB968[HIBYTE(v92)]
        ^ dword_1DAD68[(unsigned __int8)v91]
        ^ dword_1DB168[BYTE1(v94)]
        ^ dword_1DB568[BYTE2(v93)];
    v492 = dword_1DB968[HIBYTE(v83)]
         ^ dword_1DAD68[(unsigned __int8)v86]
         ^ dword_1DB168[BYTE1(v85)]
         ^ dword_1DB568[BYTE2(v84)]
         ^ v493;
    v489 = dword_1DB968[HIBYTE(v86)]
         ^ dword_1DAD68[(unsigned __int8)v85]
         ^ dword_1DB168[BYTE1(v84)]
         ^ dword_1DB568[BYTE2(v83)]
         ^ v490;
    v486 = dword_1DB968[HIBYTE(v85)]
         ^ dword_1DAD68[(unsigned __int8)v84]
         ^ dword_1DB168[BYTE1(v83)]
         ^ dword_1DB568[BYTE2(v86)]
         ^ v487;
    v483 = dword_1DB968[HIBYTE(v84)]
         ^ dword_1DAD68[(unsigned __int8)v83]
         ^ dword_1DB168[BYTE1(v86)]
         ^ dword_1DB568[BYTE2(v85)]
         ^ v484;
    v479 = v313 ^ v482;
    v472 = v305 ^ v477;
    v465 = v326 ^ v95 ^ v470;
    v458 = v291 ^ v463;
    v453 = v287 ^ v456;
    v445 = v281 ^ v450;
    v437 = v275 ^ v442;
    v429 = v479 ^ v434;
    v82 = v453
        ^ dword_1DB968[(v458 ^ (unsigned int)v507) >> 24]
        ^ dword_1DAD68[(unsigned __int8)(v479 ^ v516)]
        ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v472 ^ v513) >> 8)]
        ^ dword_1DB568[(unsigned __int8)((v465 ^ (unsigned int)v510) >> 16)];
    v81 = v445
        ^ dword_1DB968[(v479 ^ v516) >> 24]
        ^ dword_1DAD68[(unsigned __int8)(v472 ^ v513)]
        ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v465 ^ v510) >> 8)]
        ^ dword_1DB568[(unsigned __int8)((v458 ^ (unsigned int)v507) >> 16)];
    v80 = v437
        ^ dword_1DB968[(v472 ^ (unsigned int)v513) >> 24]
        ^ dword_1DAD68[(unsigned __int8)(v465 ^ v510)]
        ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v458 ^ v507) >> 8)]
        ^ dword_1DB568[(unsigned __int8)((v479 ^ v516) >> 16)];
    v79 = v429
        ^ dword_1DB968[(v465 ^ (unsigned int)v510) >> 24]
        ^ dword_1DAD68[(unsigned __int8)(v458 ^ v507)]
        ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v479 ^ v516) >> 8)]
        ^ dword_1DB568[(unsigned __int8)((v472 ^ (unsigned int)v513) >> 16)];
    v425 = v472 ^ v428;
    v418 = v465 ^ v423;
    v411 = v458 ^ v416;
    v404 = v453 ^ v409;
    v78 = v425
        ^ dword_1DB968[HIBYTE(v79)]
        ^ dword_1DAD68[(unsigned __int8)v82]
        ^ dword_1DB168[BYTE1(v81)]
        ^ dword_1DB568[BYTE2(v80)];
    v77 = v418
        ^ dword_1DB968[HIBYTE(v82)]
        ^ dword_1DAD68[(unsigned __int8)v81]
        ^ dword_1DB168[BYTE1(v80)]
        ^ dword_1DB568[BYTE2(v79)];
    v76 = v411
        ^ dword_1DB968[HIBYTE(v81)]
        ^ dword_1DAD68[(unsigned __int8)v80]
        ^ dword_1DB168[BYTE1(v79)]
        ^ dword_1DB568[BYTE2(v82)];
    v75 = v404
        ^ dword_1DB968[HIBYTE(v80)]
        ^ dword_1DAD68[(unsigned __int8)v79]
        ^ dword_1DB168[BYTE1(v82)]
        ^ dword_1DB568[BYTE2(v81)];
    v399 = v445 ^ v402;
    v391 = v437 ^ v396;
    v383 = v429 ^ v388;
    v375 = v425 ^ v380;
    v74 = v399
        ^ dword_1DB968[HIBYTE(v75)]
        ^ dword_1DAD68[(unsigned __int8)v78]
        ^ dword_1DB168[BYTE1(v77)]
        ^ dword_1DB568[BYTE2(v76)];
    v73 = v391
        ^ dword_1DB968[HIBYTE(v78)]
        ^ dword_1DAD68[(unsigned __int8)v77]
        ^ dword_1DB168[BYTE1(v76)]
        ^ dword_1DB568[BYTE2(v75)];
    v72 = v383
        ^ dword_1DB968[HIBYTE(v77)]
        ^ dword_1DAD68[(unsigned __int8)v76]
        ^ dword_1DB168[BYTE1(v75)]
        ^ dword_1DB568[BYTE2(v78)];
    v71 = v375
        ^ dword_1DB968[HIBYTE(v76)]
        ^ dword_1DAD68[(unsigned __int8)v75]
        ^ dword_1DB168[BYTE1(v78)]
        ^ dword_1DB568[BYTE2(v77)];
    v529 = dword_1DB968[HIBYTE(v71)]
         ^ dword_1DAD68[(unsigned __int8)v74]
         ^ dword_1DB168[BYTE1(v73)]
         ^ dword_1DB568[BYTE2(v72)]
         ^ v530;
    v526 = dword_1DB968[HIBYTE(v74)]
         ^ dword_1DAD68[(unsigned __int8)v73]
         ^ dword_1DB168[BYTE1(v72)]
         ^ dword_1DB568[BYTE2(v71)]
         ^ v527;
    v523 = dword_1DB968[HIBYTE(v73)]
         ^ dword_1DAD68[(unsigned __int8)v72]
         ^ dword_1DB168[BYTE1(v71)]
         ^ dword_1DB568[BYTE2(v74)]
         ^ v524;
    v520 = dword_1DB968[HIBYTE(v72)]
         ^ dword_1DAD68[(unsigned __int8)v71]
         ^ dword_1DB168[BYTE1(v74)]
         ^ dword_1DB568[BYTE2(v73)]
         ^ v521;
    v371 = v418 ^ v374;
    v364 = v411 ^ v369;
    v357 = v404 ^ v362;
    v350 = v399 ^ v355;
    v345 = v391 ^ v348;
    v337 = v383 ^ v342;
    v329 = v375 ^ v334;
    v321 = v371 ^ v326;
    v70 = v345
        ^ dword_1DB968[(v350 ^ (unsigned int)v483) >> 24]
        ^ dword_1DAD68[(unsigned __int8)(v371 ^ v492)]
        ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v364 ^ v489) >> 8)]
        ^ dword_1DB568[(unsigned __int8)((v357 ^ (unsigned int)v486) >> 16)];
    v69 = v337
        ^ dword_1DB968[(v371 ^ v492) >> 24]
        ^ dword_1DAD68[(unsigned __int8)(v364 ^ v489)]
        ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v357 ^ v486) >> 8)]
        ^ dword_1DB568[(unsigned __int8)((v350 ^ (unsigned int)v483) >> 16)];
    v68 = v329
        ^ dword_1DB968[(v364 ^ (unsigned int)v489) >> 24]
        ^ dword_1DAD68[(unsigned __int8)(v357 ^ v486)]
        ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v350 ^ v483) >> 8)]
        ^ dword_1DB568[(unsigned __int8)((v371 ^ v492) >> 16)];
    v67 = v321
        ^ dword_1DB968[(v357 ^ (unsigned int)v486) >> 24]
        ^ dword_1DAD68[(unsigned __int8)(v350 ^ v483)]
        ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v371 ^ v492) >> 8)]
        ^ dword_1DB568[(unsigned __int8)((v364 ^ (unsigned int)v489) >> 16)];
    v316 = v364 ^ v319;
    v308 = v357 ^ v313;
    v300 = v350 ^ v305;
    v292 = v345 ^ v297;
    v66 = v316
        ^ dword_1DB968[HIBYTE(v67)]
        ^ dword_1DAD68[(unsigned __int8)v70]
        ^ dword_1DB168[BYTE1(v69)]
        ^ dword_1DB568[BYTE2(v68)];
    v65 = v308
        ^ dword_1DB968[HIBYTE(v70)]
        ^ dword_1DAD68[(unsigned __int8)v69]
        ^ dword_1DB168[BYTE1(v68)]
        ^ dword_1DB568[BYTE2(v67)];
    v64 = v300
        ^ dword_1DB968[HIBYTE(v69)]
        ^ dword_1DAD68[(unsigned __int8)v68]
        ^ dword_1DB168[BYTE1(v67)]
        ^ dword_1DB568[BYTE2(v70)];
    v63 = v292
        ^ dword_1DB968[HIBYTE(v68)]
        ^ dword_1DAD68[(unsigned __int8)v67]
        ^ dword_1DB168[BYTE1(v70)]
        ^ dword_1DB568[BYTE2(v69)];
    v288 = v337 ^ v291;
    v282 = v329 ^ v287;
    v276 = v321 ^ v281;
    v270 = v316 ^ v275;
    v62 = v288
        ^ dword_1DB968[HIBYTE(v63)]
        ^ dword_1DAD68[(unsigned __int8)v66]
        ^ dword_1DB168[BYTE1(v65)]
        ^ dword_1DB568[BYTE2(v64)];
    v61 = v282
        ^ dword_1DB968[HIBYTE(v66)]
        ^ dword_1DAD68[(unsigned __int8)v65]
        ^ dword_1DB168[BYTE1(v64)]
        ^ dword_1DB568[BYTE2(v63)];
    v60 = v276
        ^ dword_1DB968[HIBYTE(v65)]
        ^ dword_1DAD68[(unsigned __int8)v64]
        ^ dword_1DB168[BYTE1(v63)]
        ^ dword_1DB568[BYTE2(v66)];
    v59 = v270
        ^ dword_1DB968[HIBYTE(v64)]
        ^ dword_1DAD68[(unsigned __int8)v63]
        ^ dword_1DB168[BYTE1(v66)]
        ^ dword_1DB568[BYTE2(v65)];
    v505 = dword_1DB968[HIBYTE(v59)]
         ^ dword_1DAD68[(unsigned __int8)v62]
         ^ dword_1DB168[BYTE1(v61)]
         ^ dword_1DB568[BYTE2(v60)]
         ^ v506;
    v502 = dword_1DB968[HIBYTE(v62)]
         ^ dword_1DAD68[(unsigned __int8)v61]
         ^ dword_1DB168[BYTE1(v60)]
         ^ dword_1DB568[BYTE2(v59)]
         ^ v503;
    v499 = dword_1DB968[HIBYTE(v61)]
         ^ dword_1DAD68[(unsigned __int8)v60]
         ^ dword_1DB168[BYTE1(v59)]
         ^ dword_1DB568[BYTE2(v62)]
         ^ v500;
    v496 = dword_1DB968[HIBYTE(v60)]
         ^ dword_1DAD68[(unsigned __int8)v59]
         ^ dword_1DB168[BYTE1(v62)]
         ^ dword_1DB568[BYTE2(v61)]
         ^ v497;
  }
  v58 = v472;
  v57 = v465;
  v56 = v458;
  v478 = dword_1DB968[HIBYTE(v479)]
       ^ dword_1DAD68[(unsigned __int8)v472]
       ^ dword_1DB168[BYTE1(v465)]
       ^ dword_1DB568[BYTE2(v458)];
  v471 = dword_1DB968[HIBYTE(v58)]
       ^ dword_1DAD68[(unsigned __int8)v465]
       ^ dword_1DB168[BYTE1(v458)]
       ^ dword_1DB568[BYTE2(v479)];
  v464 = dword_1DB968[HIBYTE(v57)]
       ^ dword_1DAD68[(unsigned __int8)v458]
       ^ dword_1DB168[BYTE1(v479)]
       ^ dword_1DB568[BYTE2(v58)];
  v55 = dword_1DB968[HIBYTE(v56)]
      ^ dword_1DAD68[(unsigned __int8)v479]
      ^ dword_1DB168[BYTE1(v58)]
      ^ dword_1DB568[BYTE2(v57)];
  v54 = v270 ^ v55 ^ v520;
  v53 = v445;
  v52 = v437;
  v51 = v429;
  v451 = dword_1DB968[HIBYTE(v453)]
       ^ dword_1DAD68[(unsigned __int8)v445]
       ^ dword_1DB168[BYTE1(v437)]
       ^ dword_1DB568[BYTE2(v429)];
  v443 = dword_1DB968[HIBYTE(v53)]
       ^ dword_1DAD68[(unsigned __int8)v437]
       ^ dword_1DB168[BYTE1(v429)]
       ^ dword_1DB568[BYTE2(v453)];
  v435 = dword_1DB968[HIBYTE(v52)]
       ^ dword_1DAD68[(unsigned __int8)v429]
       ^ dword_1DB168[BYTE1(v453)]
       ^ dword_1DB568[BYTE2(v53)];
  v50 = dword_1DB968[HIBYTE(v51)]
      ^ dword_1DAD68[(unsigned __int8)v453]
      ^ dword_1DB168[BYTE1(v53)]
      ^ dword_1DB568[BYTE2(v52)];
  v457 = v288 ^ v478 ^ v451;
  v452 = v282 ^ v471 ^ v443;
  v444 = v276 ^ v464 ^ v435;
  v436 = v270 ^ v55 ^ v50;
  v49 = v457
      ^ dword_1DB968[HIBYTE(v54)]
      ^ dword_1DAD68[(unsigned __int8)(v288 ^ v478 ^ v529)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v282 ^ v471 ^ v526) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v276 ^ v464 ^ v523) >> 16)];
  v48 = v452
      ^ dword_1DB968[(v288 ^ v478 ^ v529) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v282 ^ v471 ^ v526)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v276 ^ v464 ^ v523) >> 8)]
      ^ dword_1DB568[BYTE2(v54)];
  v47 = v444
      ^ dword_1DB968[(v282 ^ v471 ^ v526) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v276 ^ v464 ^ v523)]
      ^ dword_1DB168[BYTE1(v54)]
      ^ dword_1DB568[(unsigned __int8)((v288 ^ v478 ^ v529) >> 16)];
  v46 = v436
      ^ dword_1DB968[(v276 ^ v464 ^ v523) >> 24]
      ^ dword_1DAD68[(unsigned __int8)v54]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v288 ^ v478 ^ v529) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v282 ^ v471 ^ v526) >> 16)];
  v45 = v418;
  v44 = v411;
  v43 = v404;
  v424 = dword_1DB968[HIBYTE(v425)]
       ^ dword_1DAD68[(unsigned __int8)v418]
       ^ dword_1DB168[BYTE1(v411)]
       ^ dword_1DB568[BYTE2(v404)];
  v417 = dword_1DB968[HIBYTE(v45)]
       ^ dword_1DAD68[(unsigned __int8)v411]
       ^ dword_1DB168[BYTE1(v404)]
       ^ dword_1DB568[BYTE2(v425)];
  v410 = dword_1DB968[HIBYTE(v44)]
       ^ dword_1DAD68[(unsigned __int8)v404]
       ^ dword_1DB168[BYTE1(v425)]
       ^ dword_1DB568[BYTE2(v45)];
  v42 = dword_1DB968[HIBYTE(v43)]
      ^ dword_1DAD68[(unsigned __int8)v425]
      ^ dword_1DB168[BYTE1(v45)]
      ^ dword_1DB568[BYTE2(v44)];
  v41 = v457
      ^ v424
      ^ dword_1DB968[HIBYTE(v46)]
      ^ dword_1DAD68[(unsigned __int8)v49]
      ^ dword_1DB168[BYTE1(v48)]
      ^ dword_1DB568[BYTE2(v47)];
  v40 = v452
      ^ v417
      ^ dword_1DB968[HIBYTE(v49)]
      ^ dword_1DAD68[(unsigned __int8)v48]
      ^ dword_1DB168[BYTE1(v47)]
      ^ dword_1DB568[BYTE2(v46)];
  v39 = v444
      ^ v410
      ^ dword_1DB968[HIBYTE(v48)]
      ^ dword_1DAD68[(unsigned __int8)v47]
      ^ dword_1DB168[BYTE1(v46)]
      ^ dword_1DB568[BYTE2(v49)];
  v38 = v436
      ^ v42
      ^ dword_1DB968[HIBYTE(v47)]
      ^ dword_1DAD68[(unsigned __int8)v46]
      ^ dword_1DB168[BYTE1(v49)]
      ^ dword_1DB568[BYTE2(v48)];
  v37 = v391;
  v36 = v383;
  v35 = v375;
  v397 = dword_1DB968[HIBYTE(v399)]
       ^ dword_1DAD68[(unsigned __int8)v391]
       ^ dword_1DB168[BYTE1(v383)]
       ^ dword_1DB568[BYTE2(v375)];
  v389 = dword_1DB968[HIBYTE(v37)]
       ^ dword_1DAD68[(unsigned __int8)v383]
       ^ dword_1DB168[BYTE1(v375)]
       ^ dword_1DB568[BYTE2(v399)];
  v381 = dword_1DB968[HIBYTE(v36)]
       ^ dword_1DAD68[(unsigned __int8)v375]
       ^ dword_1DB168[BYTE1(v399)]
       ^ dword_1DB568[BYTE2(v37)];
  v34 = dword_1DB968[HIBYTE(v35)]
      ^ dword_1DAD68[(unsigned __int8)v399]
      ^ dword_1DB168[BYTE1(v37)]
      ^ dword_1DB568[BYTE2(v36)];
  v403 = v457 ^ v424 ^ v397;
  v398 = v452 ^ v417 ^ v389;
  v390 = v444 ^ v410 ^ v381;
  v382 = v436 ^ v42 ^ v34;
  v33 = v403
      ^ dword_1DB968[HIBYTE(v38)]
      ^ dword_1DAD68[(unsigned __int8)v41]
      ^ dword_1DB168[BYTE1(v40)]
      ^ dword_1DB568[BYTE2(v39)];
  v32 = v398
      ^ dword_1DB968[HIBYTE(v41)]
      ^ dword_1DAD68[(unsigned __int8)v40]
      ^ dword_1DB168[BYTE1(v39)]
      ^ dword_1DB568[BYTE2(v38)];
  v31 = v390
      ^ dword_1DB968[HIBYTE(v40)]
      ^ dword_1DAD68[(unsigned __int8)v39]
      ^ dword_1DB168[BYTE1(v38)]
      ^ dword_1DB568[BYTE2(v41)];
  v30 = v382
      ^ dword_1DB968[HIBYTE(v39)]
      ^ dword_1DAD68[(unsigned __int8)v38]
      ^ dword_1DB168[BYTE1(v41)]
      ^ dword_1DB568[BYTE2(v40)];
  v494 = dword_1DB968[HIBYTE(v30)]
       ^ dword_1DAD68[(unsigned __int8)v33]
       ^ dword_1DB168[BYTE1(v32)]
       ^ dword_1DB568[BYTE2(v31)]
       ^ v492;
  v491 = dword_1DB968[HIBYTE(v33)]
       ^ dword_1DAD68[(unsigned __int8)v32]
       ^ dword_1DB168[BYTE1(v31)]
       ^ dword_1DB568[BYTE2(v30)]
       ^ v489;
  v488 = dword_1DB968[HIBYTE(v32)]
       ^ dword_1DAD68[(unsigned __int8)v31]
       ^ dword_1DB168[BYTE1(v30)]
       ^ dword_1DB568[BYTE2(v33)]
       ^ v486;
  v485 = dword_1DB968[HIBYTE(v31)]
       ^ dword_1DAD68[(unsigned __int8)v30]
       ^ dword_1DB168[BYTE1(v33)]
       ^ dword_1DB568[BYTE2(v32)]
       ^ v483;
  v29 = v364;
  v28 = v357;
  v27 = v350;
  v370 = dword_1DB968[HIBYTE(v371)]
       ^ dword_1DAD68[(unsigned __int8)v364]
       ^ dword_1DB168[BYTE1(v357)]
       ^ dword_1DB568[BYTE2(v350)];
  v363 = dword_1DB968[HIBYTE(v29)]
       ^ dword_1DAD68[(unsigned __int8)v357]
       ^ dword_1DB168[BYTE1(v350)]
       ^ dword_1DB568[BYTE2(v371)];
  v356 = dword_1DB968[HIBYTE(v28)]
       ^ dword_1DAD68[(unsigned __int8)v350]
       ^ dword_1DB168[BYTE1(v371)]
       ^ dword_1DB568[BYTE2(v29)];
  v26 = dword_1DB968[HIBYTE(v27)]
      ^ dword_1DAD68[(unsigned __int8)v371]
      ^ dword_1DB168[BYTE1(v29)]
      ^ dword_1DB568[BYTE2(v28)];
  v25 = v382 ^ v26 ^ v496;
  v24 = v337;
  v23 = v329;
  v22 = v321;
  v343 = dword_1DB968[HIBYTE(v345)]
       ^ dword_1DAD68[(unsigned __int8)v337]
       ^ dword_1DB168[BYTE1(v329)]
       ^ dword_1DB568[BYTE2(v321)];
  v335 = dword_1DB968[HIBYTE(v24)]
       ^ dword_1DAD68[(unsigned __int8)v329]
       ^ dword_1DB168[BYTE1(v321)]
       ^ dword_1DB568[BYTE2(v345)];
  v327 = dword_1DB968[HIBYTE(v23)]
       ^ dword_1DAD68[(unsigned __int8)v321]
       ^ dword_1DB168[BYTE1(v345)]
       ^ dword_1DB568[BYTE2(v24)];
  v21 = dword_1DB968[HIBYTE(v22)]
      ^ dword_1DAD68[(unsigned __int8)v345]
      ^ dword_1DB168[BYTE1(v24)]
      ^ dword_1DB568[BYTE2(v23)];
  v349 = v403 ^ v370 ^ v343;
  v344 = v398 ^ v363 ^ v335;
  v336 = v390 ^ v356 ^ v327;
  v328 = v382 ^ v26 ^ v21;
  v20 = v349
      ^ dword_1DB968[HIBYTE(v25)]
      ^ dword_1DAD68[(unsigned __int8)(v403 ^ v370 ^ v505)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v398 ^ v363 ^ v502) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v390 ^ v356 ^ (unsigned int)v499) >> 16)];
  v19 = v344
      ^ dword_1DB968[(v403 ^ v370 ^ (unsigned int)v505) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v398 ^ v363 ^ v502)]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v390 ^ v356 ^ v499) >> 8)]
      ^ dword_1DB568[BYTE2(v25)];
  v18 = v336
      ^ dword_1DB968[(v398 ^ v363 ^ (unsigned int)v502) >> 24]
      ^ dword_1DAD68[(unsigned __int8)(v390 ^ v356 ^ v499)]
      ^ dword_1DB168[BYTE1(v25)]
      ^ dword_1DB568[(unsigned __int8)((v403 ^ v370 ^ (unsigned int)v505) >> 16)];
  v17 = v328
      ^ dword_1DB968[(v390 ^ v356 ^ (unsigned int)v499) >> 24]
      ^ dword_1DAD68[(unsigned __int8)v25]
      ^ dword_1DB168[(unsigned __int8)((unsigned __int16)(v403 ^ v370 ^ v505) >> 8)]
      ^ dword_1DB568[(unsigned __int8)((v398 ^ v363 ^ (unsigned int)v502) >> 16)];
  v16 = v308;
  v15 = v300;
  v14 = v292;
  v314 = dword_1DB968[HIBYTE(v316)]
       ^ dword_1DAD68[(unsigned __int8)v308]
       ^ dword_1DB168[BYTE1(v300)]
       ^ dword_1DB568[BYTE2(v292)];
  v306 = dword_1DB968[HIBYTE(v16)]
       ^ dword_1DAD68[(unsigned __int8)v300]
       ^ dword_1DB168[BYTE1(v292)]
       ^ dword_1DB568[BYTE2(v316)];
  v298 = dword_1DB968[HIBYTE(v15)]
       ^ dword_1DAD68[(unsigned __int8)v292]
       ^ dword_1DB168[BYTE1(v316)]
       ^ dword_1DB568[BYTE2(v16)];
  v13 = dword_1DB968[HIBYTE(v14)]
      ^ dword_1DAD68[(unsigned __int8)v316]
      ^ dword_1DB168[BYTE1(v16)]
      ^ dword_1DB568[BYTE2(v15)];
  v320 = v349 ^ a1[50] ^ v314;
  v315 = v344 ^ a1[49] ^ v306;
  v307 = v336 ^ a1[52] ^ v298;
  v299 = v328 ^ ~a1[51] ^ v13;
  v12 = v320
      ^ dword_1DB968[HIBYTE(v17)]
      ^ dword_1DAD68[(unsigned __int8)v20]
      ^ dword_1DB168[BYTE1(v19)]
      ^ dword_1DB568[BYTE2(v18)];
  v11 = v315
      ^ dword_1DB968[HIBYTE(v20)]
      ^ dword_1DAD68[(unsigned __int8)v19]
      ^ dword_1DB168[BYTE1(v18)]
      ^ dword_1DB568[BYTE2(v17)];
  v10 = v307
      ^ dword_1DB968[HIBYTE(v19)]
      ^ dword_1DAD68[(unsigned __int8)v18]
      ^ dword_1DB168[BYTE1(v17)]
      ^ dword_1DB568[BYTE2(v20)];
  v9 = v299
     ^ dword_1DB968[HIBYTE(v18)]
     ^ dword_1DAD68[(unsigned __int8)v17]
     ^ dword_1DB168[BYTE1(v20)]
     ^ dword_1DB568[BYTE2(v19)];
  v8 = v320
     ^ dword_1DB968[HIBYTE(v288)]
     ^ dword_1DAD68[(unsigned __int8)v282]
     ^ dword_1DB168[BYTE1(v276)]
     ^ dword_1DB568[BYTE2(v270)]
     ^ dword_1DB968[HIBYTE(v9)]
     ^ dword_1DAD68[(unsigned __int8)v12]
     ^ dword_1DB168[BYTE1(v11)]
     ^ dword_1DB568[BYTE2(v10)];
  v7 = v315
     ^ dword_1DB968[HIBYTE(v282)]
     ^ dword_1DAD68[(unsigned __int8)v276]
     ^ dword_1DB168[BYTE1(v270)]
     ^ dword_1DB568[BYTE2(v288)]
     ^ dword_1DB968[HIBYTE(v12)]
     ^ dword_1DAD68[(unsigned __int8)v11]
     ^ dword_1DB168[BYTE1(v10)]
     ^ dword_1DB568[BYTE2(v9)];
  v6 = v307
     ^ dword_1DB968[HIBYTE(v276)]
     ^ dword_1DAD68[(unsigned __int8)v270]
     ^ dword_1DB168[BYTE1(v288)]
     ^ dword_1DB568[BYTE2(v282)]
     ^ dword_1DB968[HIBYTE(v11)]
     ^ dword_1DAD68[(unsigned __int8)v10]
     ^ dword_1DB168[BYTE1(v9)]
     ^ dword_1DB568[BYTE2(v12)];
  v5 = v299
     ^ dword_1DB968[HIBYTE(v270)]
     ^ dword_1DAD68[(unsigned __int8)v288]
     ^ dword_1DB168[BYTE1(v282)]
     ^ dword_1DB568[BYTE2(v276)]
     ^ dword_1DB968[HIBYTE(v10)]
     ^ dword_1DAD68[(unsigned __int8)v9]
     ^ dword_1DB168[BYTE1(v12)]
     ^ dword_1DB568[BYTE2(v11)];
  v518 = dword_1DB968[HIBYTE(v5)]
       ^ dword_1DAD68[(unsigned __int8)v8]
       ^ dword_1DB168[BYTE1(v7)]
       ^ dword_1DB568[BYTE2(v6)]
       ^ v516;
  v515 = dword_1DB968[HIBYTE(v8)]
       ^ dword_1DAD68[(unsigned __int8)v7]
       ^ dword_1DB168[BYTE1(v6)]
       ^ dword_1DB568[BYTE2(v5)]
       ^ v513;
  v512 = dword_1DB968[HIBYTE(v7)]
       ^ dword_1DAD68[(unsigned __int8)v6]
       ^ dword_1DB168[BYTE1(v5)]
       ^ dword_1DB568[BYTE2(v8)]
       ^ v510;
  v509 = dword_1DB968[HIBYTE(v6)]
       ^ dword_1DAD68[(unsigned __int8)v5]
       ^ dword_1DB168[BYTE1(v8)]
       ^ dword_1DB568[BYTE2(v7)]
       ^ v507;
  a1[33] ^= v505;
  a1[34] ^= v502;
  a1[35] ^= v499;
  a1[36] ^= v496;
  a1[37] ^= v494;
  a1[38] ^= v491;
  a1[39] ^= v488;
  a1[40] ^= v485;
  a1[41] ^= v529;
  a1[42] ^= v526;
  a1[43] ^= v523;
  a1[44] ^= v520;
  a1[45] ^= v518;
  a1[46] ^= v515;
  a1[47] ^= v512;
  a1[48] ^= v509;
  return result;
}
// 1DAD68: using guessed type _DWORD dword_1DAD68[256];
// 1DB168: using guessed type _DWORD dword_1DB168[256];
// 1DB568: using guessed type _DWORD dword_1DB568[256];
// 1DB968: using guessed type _DWORD dword_1DB968[256];

//----- (00199024) --------------------------------------------------------
void *__fastcall sub_199024(_DWORD *a1, const void *a2)
{
  void *result; // r0

  result = memcpy(a1 + 17, a2, 0x20u);
  a1[16] = 0;
  a1[25] = 0;
  a1[26] = 0;
  return result;
}

//----- (00199058) --------------------------------------------------------
_DWORD *__fastcall sub_199058(_DWORD *result, char *a2, unsigned int a3)
{
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+14h] [bp+14h]
  size_t n; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]

  v5 = result;
  v6 = (int)result;
  v8 = result[16];
  while ( a3 )
  {
    n = 64 - v8;
    if ( 64 - v8 > a3 )
      n = a3;
    result = memcpy((void *)(v8 + v6), a2, n);
    a2 += n;
    v8 += n;
    a3 -= n;
    if ( v8 == 64 )
    {
      v5[25] += 512;
      if ( !v5[25] )
        ++v5[26];
      result = (_DWORD *)sub_189268(v5, v6);
      v8 = 0;
    }
  }
  v5[16] = v8;
  return result;
}

//----- (001990F0) --------------------------------------------------------
unsigned int __fastcall sub_1990F0(int a1, char a2, int a3, int a4, unsigned int a5)
{
  unsigned int result; // r0
  unsigned int v8; // [sp+14h] [bp+14h]
  unsigned int v9; // [sp+18h] [bp+18h]
  unsigned int v10; // [sp+1Ch] [bp+1Ch]
  unsigned int i; // [sp+24h] [bp+24h]

  v10 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 100) += a3 + 8 * v10;
  v9 = *(_DWORD *)(a1 + 100);
  v8 = *(_DWORD *)(a1 + 104);
  if ( v10 || a3 )
  {
    *(_BYTE *)(v10 + a1) = (128 >> a3) | -(128 >> a3) & a2;
    if ( v10 > 0x35 )
    {
      memset((void *)(a1 + v10 + 1), 0, 63 - v10);
      sub_189268((_DWORD *)a1, a1);
      memset((void *)a1, 0, 0x36u);
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 104);
    }
    else
    {
      memset((void *)(a1 + v10 + 1), 0, 53 - v10);
    }
  }
  else
  {
    *(_BYTE *)a1 = 0x80;
    memset((void *)(a1 + 1), 0, 0x35u);
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 104);
  }
  sub_18920C(a1 + 54, v9);
  sub_18920C(a1 + 58, v8);
  *(_WORD *)(a1 + 62) = __PAIR16__((32 * a5) >> 24, 32 * a5);
  result = sub_189268((_DWORD *)a1, a1);
  for ( i = 0; i < a5; ++i )
    result = sub_18920C(a4 + 4 * i, *(_DWORD *)(4 * (i + 16) + a1 + 4));
  return result;
}

//----- (00199250) --------------------------------------------------------
void *__fastcall sub_199250(_DWORD *a1, const void *a2)
{
  void *result; // r0

  result = memcpy(a1 + 33, a2, 0x40u);
  a1[32] = 0;
  a1[49] = 0;
  a1[50] = 0;
  a1[51] = 0;
  a1[52] = 0;
  return result;
}

//----- (00199298) --------------------------------------------------------
_DWORD *__fastcall sub_199298(_DWORD *result, char *a2, unsigned int a3)
{
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+14h] [bp+14h]
  size_t n; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]

  v5 = result;
  v6 = (int)result;
  v8 = result[32];
  while ( a3 )
  {
    n = 128 - v8;
    if ( 128 - v8 > a3 )
      n = a3;
    result = memcpy((void *)(v8 + v6), a2, n);
    a2 += n;
    v8 += n;
    a3 -= n;
    if ( v8 == 128 )
    {
      v5[49] += 1024;
      if ( !v5[49] && !++v5[50] && !++v5[51] )
        ++v5[52];
      result = (_DWORD *)sub_18FC14(v5, v6);
      v8 = 0;
    }
  }
  v5[32] = v8;
  return result;
}

//----- (00199370) --------------------------------------------------------
int __fastcall sub_199370(int a1, char a2, int a3, int a4, unsigned int a5)
{
  int result; // r0
  unsigned int v8; // [sp+14h] [bp+14h]
  unsigned int v9; // [sp+18h] [bp+18h]
  unsigned int v10; // [sp+1Ch] [bp+1Ch]
  unsigned int v11; // [sp+20h] [bp+20h]
  unsigned int v12; // [sp+24h] [bp+24h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]

  v12 = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 196) += a3 + 8 * v12;
  v11 = *(_DWORD *)(a1 + 196);
  v10 = *(_DWORD *)(a1 + 200);
  v9 = *(_DWORD *)(a1 + 204);
  v8 = *(_DWORD *)(a1 + 208);
  if ( v12 || a3 )
  {
    *(_BYTE *)(v12 + a1) = (128 >> a3) | -(128 >> a3) & a2;
    if ( v12 > 0x6D )
    {
      memset((void *)(a1 + v12 + 1), 0, 127 - v12);
      sub_18FC14((_DWORD *)a1, a1);
      memset((void *)a1, 0, 0x6Eu);
      *(_DWORD *)(a1 + 208) = 0;
      *(_DWORD *)(a1 + 204) = *(_DWORD *)(a1 + 208);
      *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 204);
      *(_DWORD *)(a1 + 196) = *(_DWORD *)(a1 + 200);
    }
    else
    {
      memset((void *)(a1 + v12 + 1), 0, 109 - v12);
    }
  }
  else
  {
    *(_BYTE *)a1 = 0x80;
    memset((void *)(a1 + 1), 0, 0x6Du);
    *(_DWORD *)(a1 + 208) = 0;
    *(_DWORD *)(a1 + 204) = *(_DWORD *)(a1 + 208);
    *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 204);
    *(_DWORD *)(a1 + 196) = *(_DWORD *)(a1 + 200);
  }
  sub_18920C(a1 + 110, v11);
  sub_18920C(a1 + 114, v10);
  sub_18920C(a1 + 118, v9);
  sub_18920C(a1 + 122, v8);
  *(_WORD *)(a1 + 126) = __PAIR16__((32 * a5) >> 24, 32 * a5);
  result = sub_18FC14((_DWORD *)a1, a1);
  for ( i = 0; i < a5; ++i )
    result = sub_18920C(a4 + 4 * i, *(_DWORD *)(4 * (i + 32) + a1 + 4));
  return result;
}

//----- (00199540) --------------------------------------------------------
void *__fastcall sph_shavite224_init(_DWORD *a1)
{
  return sub_199024(a1, &unk_1DBD68);
}

//----- (00199560) --------------------------------------------------------
_DWORD *__fastcall sph_shavite224(_DWORD *a1, char *a2, unsigned int a3)
{
  return sub_199058(a1, a2, a3);
}

//----- (00199580) --------------------------------------------------------
void *__fastcall sph_shavite224_close(_DWORD *a1, int a2)
{
  sub_1990F0((int)a1, 0, 0, a2, 7u);
  return sub_199024(a1, &unk_1DBD68);
}

//----- (001995B0) --------------------------------------------------------
void *__fastcall sph_shavite224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_1990F0((int)a1, a2, a3, a4, 7u);
  return sub_199024(a1, &unk_1DBD68);
}

//----- (001995E4) --------------------------------------------------------
void *__fastcall sph_shavite256_init(_DWORD *a1)
{
  return sub_199024(a1, &unk_1DBD88);
}

//----- (00199604) --------------------------------------------------------
_DWORD *__fastcall sph_shavite256(_DWORD *a1, char *a2, unsigned int a3)
{
  return sub_199058(a1, a2, a3);
}

//----- (00199624) --------------------------------------------------------
void *__fastcall sph_shavite256_close(_DWORD *a1, int a2)
{
  sub_1990F0((int)a1, 0, 0, a2, 8u);
  return sub_199024(a1, &unk_1DBD88);
}

//----- (00199654) --------------------------------------------------------
void *__fastcall sph_shavite256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_1990F0((int)a1, a2, a3, a4, 8u);
  return sub_199024(a1, &unk_1DBD88);
}

//----- (00199688) --------------------------------------------------------
void *__fastcall sph_shavite384_init(_DWORD *a1)
{
  return sub_199250(a1, &unk_1DBDA8);
}

//----- (001996A8) --------------------------------------------------------
_DWORD *__fastcall sph_shavite384(_DWORD *a1, char *a2, unsigned int a3)
{
  return sub_199298(a1, a2, a3);
}

//----- (001996C8) --------------------------------------------------------
void *__fastcall sph_shavite384_close(_DWORD *a1, int a2)
{
  sub_199370((int)a1, 0, 0, a2, 0xCu);
  return sub_199250(a1, &unk_1DBDA8);
}

//----- (001996F8) --------------------------------------------------------
void *__fastcall sph_shavite384_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_199370((int)a1, a2, a3, a4, 0xCu);
  return sub_199250(a1, &unk_1DBDA8);
}

//----- (0019972C) --------------------------------------------------------
void *__fastcall sph_shavite512_init(_DWORD *a1)
{
  return sub_199250(a1, &unk_1DBDE8);
}

//----- (0019974C) --------------------------------------------------------
_DWORD *__fastcall sph_shavite512(_DWORD *a1, char *a2, unsigned int a3)
{
  return sub_199298(a1, a2, a3);
}

//----- (0019976C) --------------------------------------------------------
void *__fastcall sph_shavite512_close(_DWORD *a1, int a2)
{
  sub_199370((int)a1, 0, 0, a2, 0x10u);
  return sub_199250(a1, &unk_1DBDE8);
}

//----- (0019979C) --------------------------------------------------------
void *__fastcall sph_shavite512_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  sub_199370((int)a1, a2, a3, a4, 0x10u);
  return sub_199250(a1, &unk_1DBDE8);
}

//----- (001997D0) --------------------------------------------------------
__int64 *__fastcall sub_1997D0(int a1, int a2)
{
  __int64 *result; // r0
  int v3; // r4
  int *v4; // r3
  __int64 v5; // [sp+0h] [bp+0h]
  __int64 v6; // [sp+8h] [bp+8h]
  __int64 v7; // [sp+10h] [bp+10h]
  __int64 v8; // [sp+18h] [bp+18h]
  __int64 v9; // [sp+20h] [bp+20h]
  __int64 v10; // [sp+28h] [bp+28h]
  __int64 v11; // [sp+30h] [bp+30h]
  __int64 v12; // [sp+38h] [bp+38h]
  __int64 v13; // [sp+40h] [bp+40h]
  __int64 v14; // [sp+48h] [bp+48h]
  __int64 v15; // [sp+50h] [bp+50h]
  __int64 v16; // [sp+58h] [bp+58h]
  __int64 v17; // [sp+60h] [bp+60h]
  __int64 v18; // [sp+68h] [bp+68h]
  __int64 v19; // [sp+70h] [bp+70h]
  __int64 v20; // [sp+78h] [bp+78h]
  __int64 v21; // [sp+80h] [bp+80h]
  __int64 v22; // [sp+88h] [bp+88h]
  __int64 v23; // [sp+90h] [bp+90h]
  __int64 v24; // [sp+98h] [bp+98h]
  __int64 v25; // [sp+A0h] [bp+A0h]
  __int64 v26; // [sp+A8h] [bp+A8h]
  __int64 v27; // [sp+B0h] [bp+B0h]
  __int64 v28; // [sp+B8h] [bp+B8h]
  __int64 v29; // [sp+C0h] [bp+C0h]
  __int64 v30; // [sp+C8h] [bp+C8h]
  __int64 v31; // [sp+D0h] [bp+D0h]
  __int64 v32; // [sp+D8h] [bp+D8h]
  __int64 v33; // [sp+E0h] [bp+E0h]
  __int64 v34; // [sp+E8h] [bp+E8h]
  __int64 v35; // [sp+F0h] [bp+F0h]
  __int64 v36; // [sp+F8h] [bp+F8h]
  __int64 v37; // [sp+108h] [bp+108h]
  __int64 v38; // [sp+110h] [bp+110h]
  __int64 v39; // [sp+118h] [bp+118h]
  _QWORD v42[16]; // [sp+128h] [bp+128h] BYREF
  __int64 v43; // [sp+1A8h] [bp+1A8h] BYREF
  __int64 v44; // [sp+1B0h] [bp+1B0h]
  __int64 v45; // [sp+1B8h] [bp+1B8h]
  __int64 v46; // [sp+1C0h] [bp+1C0h]
  __int64 v47; // [sp+1C8h] [bp+1C8h]
  __int64 v48; // [sp+1D0h] [bp+1D0h]
  __int64 v49; // [sp+1D8h] [bp+1D8h]
  __int64 v50; // [sp+1E0h] [bp+1E0h]
  __int64 v51; // [sp+1E8h] [bp+1E8h]
  __int64 v52; // [sp+1F0h] [bp+1F0h]
  __int64 v53; // [sp+1F8h] [bp+1F8h]
  __int64 v54; // [sp+200h] [bp+200h]
  __int64 v55; // [sp+208h] [bp+208h]
  __int64 v56; // [sp+210h] [bp+210h]
  __int64 v57; // [sp+218h] [bp+218h]
  __int64 v58; // [sp+220h] [bp+220h]
  _BYTE dest[192]; // [sp+22Ch] [bp+22Ch] BYREF
  int i; // [sp+2ECh] [bp+2ECh]
  _BYTE v61[4]; // [sp+2F0h] [bp+2F0h] BYREF

  result = (__int64 *)memcpy(dest, &unk_1DBE68, sizeof(dest));
  for ( i = 0; i <= 7; ++i )
  {
    *(&v43 + i) = *(_QWORD *)(8 * (i + 16) + a1);
    result = &v43;
    *(&v43 + i + 8) = qword_1DBE28[i];
  }
  v55 ^= *(_QWORD *)(a1 + 192);
  v56 ^= *(_QWORD *)(a1 + 200);
  if ( a2 )
    v57 = ~v57;
  for ( i = 0; i <= 15; ++i )
  {
    HIDWORD(v39) = *(unsigned __int8 *)(a1 + 8 * i + 4);
    LODWORD(v39) = 0;
    HIDWORD(v38) = *(unsigned __int8 *)(a1 + 8 * i + 5) << 8;
    LODWORD(v38) = 0;
    HIDWORD(v37) = *(unsigned __int8 *)(a1 + 8 * i + 6) << 16;
    LODWORD(v37) = 0;
    v3 = (*(unsigned __int8 *)(a1 + 8 * i + 7) << 24)
       ^ ((v37
         ^ v38
         ^ v39
         ^ (unsigned __int64)(*(unsigned __int8 *)(a1 + 8 * i)
                            ^ (*(unsigned __int8 *)(a1 + 8 * i + 1) << 8)
                            ^ (*(unsigned __int8 *)(a1 + 8 * i + 2) << 16)
                            ^ (*(unsigned __int8 *)(a1 + 8 * i + 3) << 24))) >> 32);
    result = v42;
    v4 = (int *)&v42[i];
    *v4 = *(unsigned __int8 *)(a1 + 8 * i)
        ^ (*(unsigned __int8 *)(a1 + 8 * i + 1) << 8)
        ^ (*(unsigned __int8 *)(a1 + 8 * i + 2) << 16)
        ^ (*(unsigned __int8 *)(a1 + 8 * i + 3) << 24);
    v4[1] = v3;
  }
  for ( i = 0; i <= 11; ++i )
  {
    v43 += v47 + v42[(unsigned __int8)v61[16 * i - 196]];
    LODWORD(v36) = HIDWORD(v43) ^ HIDWORD(v55);
    HIDWORD(v36) = v43 ^ v55;
    v55 = v36;
    v51 += v36;
    LODWORD(v35) = (v51 ^ v47) >> 24;
    HIDWORD(v35) = ((unsigned int)(HIDWORD(v51) ^ HIDWORD(v47)) >> 24) | (((unsigned int)v51 ^ (unsigned int)v47) << 8);
    v47 = v35;
    v43 += v35 + v42[(unsigned __int8)v61[16 * i - 195]];
    LODWORD(v34) = (v43 ^ v36) >> 16;
    HIDWORD(v34) = ((unsigned int)(HIDWORD(v43) ^ HIDWORD(v36)) >> 16) | (((unsigned int)v43 ^ (unsigned int)v36) << 16);
    v55 = v34;
    v51 += v34;
    HIDWORD(v33) = (v51 ^ v35) >> 31;
    LODWORD(v33) = (2 * (v51 ^ v35)) | ((unsigned int)(HIDWORD(v51) ^ HIDWORD(v35)) >> 31);
    v47 = v33;
    v44 += v48 + v42[(unsigned __int8)v61[16 * i - 194]];
    LODWORD(v32) = HIDWORD(v44) ^ HIDWORD(v56);
    HIDWORD(v32) = v44 ^ v56;
    v56 = v32;
    v52 += v32;
    LODWORD(v31) = (v52 ^ v48) >> 24;
    HIDWORD(v31) = ((unsigned int)(HIDWORD(v52) ^ HIDWORD(v48)) >> 24) | (((unsigned int)v52 ^ (unsigned int)v48) << 8);
    v48 = v31;
    v44 += v31 + v42[(unsigned __int8)v61[16 * i - 193]];
    LODWORD(v30) = (v44 ^ v32) >> 16;
    HIDWORD(v30) = ((unsigned int)(HIDWORD(v44) ^ HIDWORD(v32)) >> 16) | (((unsigned int)v44 ^ (unsigned int)v32) << 16);
    v56 = v30;
    v52 += v30;
    HIDWORD(v29) = (v52 ^ v31) >> 31;
    LODWORD(v29) = (2 * (v52 ^ v31)) | ((unsigned int)(HIDWORD(v52) ^ HIDWORD(v31)) >> 31);
    v48 = v29;
    v45 += v49 + v42[(unsigned __int8)v61[16 * i - 192]];
    LODWORD(v28) = HIDWORD(v45) ^ HIDWORD(v57);
    HIDWORD(v28) = v45 ^ v57;
    v57 = v28;
    v53 += v28;
    LODWORD(v27) = (v53 ^ v49) >> 24;
    HIDWORD(v27) = ((unsigned int)(HIDWORD(v53) ^ HIDWORD(v49)) >> 24) | (((unsigned int)v53 ^ (unsigned int)v49) << 8);
    v49 = v27;
    v45 += v27 + v42[(unsigned __int8)v61[16 * i - 191]];
    LODWORD(v26) = (v45 ^ v28) >> 16;
    HIDWORD(v26) = ((unsigned int)(HIDWORD(v45) ^ HIDWORD(v28)) >> 16) | (((unsigned int)v45 ^ (unsigned int)v28) << 16);
    v57 = v26;
    v53 += v26;
    HIDWORD(v25) = (v53 ^ v27) >> 31;
    LODWORD(v25) = (2 * (v53 ^ v27)) | ((unsigned int)(HIDWORD(v53) ^ HIDWORD(v27)) >> 31);
    v49 = v25;
    v46 += v50 + v42[(unsigned __int8)v61[16 * i - 190]];
    LODWORD(v24) = HIDWORD(v46) ^ HIDWORD(v58);
    HIDWORD(v24) = v46 ^ v58;
    v58 = v24;
    v54 += v24;
    LODWORD(v23) = (v54 ^ v50) >> 24;
    HIDWORD(v23) = ((unsigned int)(HIDWORD(v54) ^ HIDWORD(v50)) >> 24) | (((unsigned int)v54 ^ (unsigned int)v50) << 8);
    v50 = v23;
    v46 += v23 + v42[(unsigned __int8)v61[16 * i - 189]];
    LODWORD(v22) = (v46 ^ v24) >> 16;
    HIDWORD(v22) = ((unsigned int)(HIDWORD(v46) ^ HIDWORD(v24)) >> 16) | (((unsigned int)v46 ^ (unsigned int)v24) << 16);
    v58 = v22;
    v54 += v22;
    HIDWORD(v21) = (v54 ^ v23) >> 31;
    LODWORD(v21) = (2 * (v54 ^ v23)) | ((unsigned int)(HIDWORD(v54) ^ HIDWORD(v23)) >> 31);
    v50 = v21;
    v43 += v29 + v42[(unsigned __int8)v61[16 * i - 188]];
    LODWORD(v20) = HIDWORD(v43) ^ HIDWORD(v22);
    HIDWORD(v20) = v43 ^ v22;
    v58 = v20;
    v53 += v20;
    LODWORD(v19) = (v53 ^ v29) >> 24;
    HIDWORD(v19) = ((unsigned int)(HIDWORD(v53) ^ HIDWORD(v29)) >> 24) | (((unsigned int)v53 ^ (unsigned int)v29) << 8);
    v48 = v19;
    v43 += v19 + v42[(unsigned __int8)v61[16 * i - 187]];
    LODWORD(v18) = (v43 ^ v20) >> 16;
    HIDWORD(v18) = ((unsigned int)(HIDWORD(v43) ^ HIDWORD(v20)) >> 16) | (((unsigned int)v43 ^ (unsigned int)v20) << 16);
    v58 = v18;
    v53 += v18;
    HIDWORD(v17) = (v53 ^ v19) >> 31;
    LODWORD(v17) = (2 * (v53 ^ v19)) | ((unsigned int)(HIDWORD(v53) ^ HIDWORD(v19)) >> 31);
    v48 = v17;
    v44 += v25 + v42[(unsigned __int8)v61[16 * i - 186]];
    LODWORD(v16) = HIDWORD(v44) ^ HIDWORD(v34);
    HIDWORD(v16) = v44 ^ v34;
    v55 = v16;
    v54 += v16;
    LODWORD(v15) = (v54 ^ v25) >> 24;
    HIDWORD(v15) = ((unsigned int)(HIDWORD(v54) ^ HIDWORD(v25)) >> 24) | (((unsigned int)v54 ^ (unsigned int)v25) << 8);
    v49 = v15;
    v44 += v15 + v42[(unsigned __int8)v61[16 * i - 185]];
    LODWORD(v14) = (v44 ^ v16) >> 16;
    HIDWORD(v14) = ((unsigned int)(HIDWORD(v44) ^ HIDWORD(v16)) >> 16) | (((unsigned int)v44 ^ (unsigned int)v16) << 16);
    v55 = v14;
    v54 += v14;
    HIDWORD(v13) = (v54 ^ v15) >> 31;
    LODWORD(v13) = (2 * (v54 ^ v15)) | ((unsigned int)(HIDWORD(v54) ^ HIDWORD(v15)) >> 31);
    v49 = v13;
    v45 += v21 + v42[(unsigned __int8)v61[16 * i - 184]];
    LODWORD(v12) = HIDWORD(v45) ^ HIDWORD(v30);
    HIDWORD(v12) = v45 ^ v30;
    v56 = v12;
    v51 += v12;
    LODWORD(v11) = (v51 ^ v21) >> 24;
    HIDWORD(v11) = ((unsigned int)(HIDWORD(v51) ^ HIDWORD(v21)) >> 24) | (((unsigned int)v51 ^ (unsigned int)v21) << 8);
    v50 = v11;
    v45 += v11 + v42[(unsigned __int8)v61[16 * i - 183]];
    LODWORD(v10) = (v45 ^ v12) >> 16;
    HIDWORD(v10) = ((unsigned int)(HIDWORD(v45) ^ HIDWORD(v12)) >> 16) | (((unsigned int)v45 ^ (unsigned int)v12) << 16);
    v56 = v10;
    v51 += v10;
    HIDWORD(v9) = (v51 ^ v11) >> 31;
    LODWORD(v9) = (2 * (v51 ^ v11)) | ((unsigned int)(HIDWORD(v51) ^ HIDWORD(v11)) >> 31);
    v50 = v9;
    v46 += v33 + v42[(unsigned __int8)v61[16 * i - 182]];
    LODWORD(v8) = HIDWORD(v46) ^ HIDWORD(v26);
    HIDWORD(v8) = v46 ^ v26;
    v57 = v8;
    v52 += v8;
    LODWORD(v7) = (v52 ^ v33) >> 24;
    HIDWORD(v7) = ((unsigned int)(HIDWORD(v52) ^ HIDWORD(v33)) >> 24) | (((unsigned int)v52 ^ (unsigned int)v33) << 8);
    v47 = v7;
    result = (__int64 *)(v46 + v7);
    v46 += v7 + v42[(unsigned __int8)v61[16 * i - 181]];
    LODWORD(v6) = (v46 ^ v8) >> 16;
    HIDWORD(v6) = ((unsigned int)(HIDWORD(v46) ^ HIDWORD(v8)) >> 16) | (((unsigned int)v46 ^ (unsigned int)v8) << 16);
    v57 = v6;
    v52 += v6;
    HIDWORD(v5) = (v52 ^ v7) >> 31;
    LODWORD(v5) = (2 * (v52 ^ v7)) | ((unsigned int)(HIDWORD(v52) ^ HIDWORD(v7)) >> 31);
    v47 = v5;
  }
  for ( i = 0; i <= 7; ++i )
  {
    result = &v43;
    *(_QWORD *)(8 * (i + 16) + a1) ^= *(&v43 + i + 8) ^ *(&v43 + i);
  }
  return result;
}
// 1DBE28: using guessed type _QWORD qword_1DBE28[8];

//----- (0019A7C8) --------------------------------------------------------
int __fastcall blake2b_init(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v5; // r4
  unsigned int i; // [sp+14h] [bp+14h]
  unsigned int j; // [sp+14h] [bp+14h]

  if ( !a2 || a2 > 0x40 || a4 > 0x40 )
    return -1;
  for ( i = 0; i <= 7; ++i )
    *(_QWORD *)(8 * (i + 16) + a1) = qword_1DBE28[i];
  v5 = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a1 + 128) ^= a2 ^ (a4 << 8) ^ 0x1010000;
  *(_DWORD *)(a1 + 132) = v5;
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 196) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 212) = a2;
  for ( j = a4; j <= 0x7F; ++j )
    *(_BYTE *)(j + a1) = 0;
  if ( a4 )
  {
    blake2b_update((__int64 *)a1, a3, a4);
    *(_DWORD *)(a1 + 208) = 128;
  }
  return 0;
}
// 1DBE28: using guessed type _QWORD qword_1DBE28[8];

//----- (0019A8B4) --------------------------------------------------------
__int64 *__fastcall blake2b_update(__int64 *result, int a2, unsigned int a3)
{
  int v3; // r3
  int v6; // [sp+Ch] [bp+Ch]
  unsigned int i; // [sp+14h] [bp+14h]

  v6 = (int)result;
  for ( i = 0; i < a3; ++i )
  {
    if ( *(_DWORD *)(v6 + 208) == 128 )
    {
      *(_QWORD *)(v6 + 192) += *(unsigned int *)(v6 + 208);
      if ( *(_QWORD *)(v6 + 192) < (unsigned __int64)*(unsigned int *)(v6 + 208) )
        ++*(_QWORD *)(v6 + 200);
      result = sub_1997D0(v6, 0);
      *(_DWORD *)(v6 + 208) = 0;
    }
    v3 = *(_DWORD *)(v6 + 208);
    *(_DWORD *)(v6 + 208) = v3 + 1;
    *(_BYTE *)(v6 + v3) = *(_BYTE *)(i + a2);
  }
  return result;
}

//----- (0019A958) --------------------------------------------------------
__int64 *__fastcall blake2b_final(int a1, int a2)
{
  int v2; // r3
  __int64 *result; // r0
  __int64 v4; // r2
  char v5; // r1
  unsigned int i; // [sp+Ch] [bp+Ch]

  *(_QWORD *)(a1 + 192) += *(unsigned int *)(a1 + 208);
  if ( *(_QWORD *)(a1 + 192) < (unsigned __int64)*(unsigned int *)(a1 + 208) )
    ++*(_QWORD *)(a1 + 200);
  while ( *(_DWORD *)(a1 + 208) <= 0x7Fu )
  {
    v2 = *(_DWORD *)(a1 + 208);
    *(_DWORD *)(a1 + 208) = v2 + 1;
    *(_BYTE *)(a1 + v2) = 0;
  }
  result = sub_1997D0(a1, 1);
  for ( i = 0; *(_DWORD *)(a1 + 212) > i; ++i )
  {
    v4 = *(_QWORD *)(8 * ((i >> 3) + 16) + a1);
    v5 = 8 * (i & 7);
    result = (__int64 *)(HIDWORD(v4) >> (v5 - 32));
    *(_BYTE *)(a2 + i) = ((unsigned int)v4 >> v5) | (HIDWORD(v4) << (32 - v5)) | (unsigned __int8)result;
  }
  return result;
}

//----- (0019AA38) --------------------------------------------------------
int __fastcall blake2b(_DWORD *a1, int a2, unsigned int a3)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int result; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  __int64 v13[27]; // [sp+10h] [bp+10h] BYREF
  _DWORD v14[4]; // [sp+E8h] [bp+E8h] BYREF
  int v15; // [sp+F8h] [bp+F8h]
  int v16; // [sp+FCh] [bp+FCh]
  int v17; // [sp+100h] [bp+100h]
  int v18; // [sp+104h] [bp+104h]

  blake2b_init((int)v13, 0x20u, 0, 0);
  blake2b_update(v13, a2, a3);
  blake2b_final((int)v13, (int)v14);
  v3 = v14[1];
  v4 = v14[2];
  v5 = v14[3];
  *a1 = v14[0];
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  result = v15;
  v7 = v16;
  v8 = v17;
  v9 = v18;
  a1[4] = v15;
  a1[5] = v7;
  a1[6] = v8;
  a1[7] = v9;
  return result;
}

//----- (0019AAA0) --------------------------------------------------------
void *__fastcall visited_init(_DWORD *a1, unsigned int a2)
{
  void *result; // r0

  a1[2] = 32;
  a1[1] = a2 / a1[2];
  result = calloc(a1[1], 4u);
  *a1 = result;
  return result;
}

//----- (0019AAE0) --------------------------------------------------------
void __fastcall visited_exit(void **a1)
{
  if ( *a1 )
    free(*a1);
}

//----- (0019AB04) --------------------------------------------------------
void **__fastcall visited_clear(void **result)
{
  if ( *result )
    return (void **)memset(*result, 0, 4 * (_DWORD)result[1]);
  return result;
}

//----- (0019AB30) --------------------------------------------------------
int __fastcall visited_set(_DWORD *a1, unsigned int a2)
{
  int result; // r0
  char v3; // r1
  int v5; // [sp+Ch] [bp+Ch]

  v5 = a2 / a1[2];
  result = sub_1A363C(a2, a1[2]);
  *(_DWORD *)(4 * v5 + *a1) |= 1 << v3;
  return result;
}
// 19AB60: variable 'v3' is possibly undefined

//----- (0019AB88) --------------------------------------------------------
int __fastcall visited_reset(_DWORD *a1, unsigned int a2)
{
  int result; // r0
  char v3; // r1
  int v5; // [sp+Ch] [bp+Ch]

  v5 = a2 / a1[2];
  result = sub_1A363C(a2, a1[2]);
  *(_DWORD *)(4 * v5 + *a1) &= ~(1 << v3);
  return result;
}
// 19ABB8: variable 'v3' is possibly undefined

//----- (0019ABE0) --------------------------------------------------------
int __fastcall visited_test(_DWORD *a1, unsigned int a2)
{
  char v2; // r1
  int v5; // [sp+Ch] [bp+Ch]

  v5 = a2 / a1[2];
  sub_1A363C(a2, a1[2]);
  return (*(_DWORD *)(4 * v5 + *a1) >> v2) & 1;
}
// 19AC1A: variable 'v2' is possibly undefined

//----- (0019AC2C) --------------------------------------------------------
int __fastcall visited_block(_DWORD *a1, unsigned int a2)
{
  return *(_DWORD *)(4 * (a2 / a1[2]) + *a1);
}

//----- (0019AC5C) --------------------------------------------------------
_DWORD *__fastcall new_bitmap(int a1)
{
  _DWORD *v3; // [sp+Ch] [bp+Ch]

  v3 = calloc(1u, 0x24u);
  if ( !v3 )
    puts("bitmap calloc failed!");
  v3[3] = visited_init;
  v3[8] = visited_exit;
  v3[7] = visited_clear;
  v3[5] = visited_set;
  v3[6] = visited_test;
  v3[4] = visited_reset;
  ((void (__fastcall *)(_DWORD *, int))v3[3])(v3, a1);
  ((void (__fastcall *)(_DWORD *))v3[7])(v3);
  return v3;
}
// 19AB30: using guessed type int visited_set();
// 19AB88: using guessed type int visited_reset();
// 19ABE0: using guessed type int visited_test();

//----- (0019ACE8) --------------------------------------------------------
void __fastcall free_bitmap(void (__fastcall **a1)(_DWORD))
{
  a1[8](a1);
  if ( a1 )
    free(a1);
}

//----- (0019AD10) --------------------------------------------------------
unsigned int __fastcall sub_19AD10(int a1, unsigned int a2)
{
  return bswap32(a2);
}

//----- (0019AD38) --------------------------------------------------------
int __fastcall sub_19AD38(__int64 *a1)
{
  sub_1A3C0C(a1[3]);
  sub_1A3C0C(a1[2]);
  sub_1A3C0C(a1[1]);
  return sub_1A3C0C(*a1);
}

//----- (0019AE08) --------------------------------------------------------
int __fastcall le256_target_to_double_diff_base(__int64 *a1)
{
  return sub_19AD38(a1);
}

//----- (0019AE68) --------------------------------------------------------
void *__fastcall diff_to_le256_target_base(void *a1)
{
  double v1; // d0
  double v2; // r0
  double v3; // r0
  double v4; // r0
  double v6; // [sp+10h] [bp+0h]
  _BYTE v8[28]; // [sp+24h] [bp+14h] BYREF
  _QWORD v9[4]; // [sp+1024h] [bp+1014h] BYREF
  _QWORD *v10; // [sp+1044h] [bp+1034h]
  __int64 v11; // [sp+1048h] [bp+1038h]
  double v12; // [sp+1050h] [bp+1040h]
  double v13; // [sp+1058h] [bp+1048h]

  v6 = v1;
  if ( v1 <= 0.0 )
  {
    V_LOCK();
    logfmt_raw(v8, 0x1000u, 0, "Diff zero passed to set_target");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/common/mining/base_common.c",
      77,
      "diff_to_le256_target_base",
      25,
      58,
      20,
      v8);
    v6 = 1.0;
  }
  v13 = 1.15790322e77 / v6;
  v12 = 1.15790322e77 / v6 / 6.27710174e57;
  v11 = (unsigned __int64)v12;
  v10 = &v9[3];
  v9[3] = (unsigned __int64)v12;
  LODWORD(v2) = sub_1A3C0C((unsigned __int64)v12);
  v13 = v13 - v2 * 6.27710174e57;
  v12 = v13 / 3.40282367e38;
  v11 = (unsigned __int64)(v13 / 3.40282367e38);
  v10 = &v9[2];
  v9[2] = v11;
  LODWORD(v3) = sub_1A3C0C(v11);
  v13 = v13 - v3 * 3.40282367e38;
  v12 = v13 / 1.84467441e19;
  v11 = (unsigned __int64)(v13 / 1.84467441e19);
  v10 = &v9[1];
  v9[1] = v11;
  LODWORD(v4) = sub_1A3C0C(v11);
  v9[0] = (unsigned __int64)(v13 - v4 * 1.84467441e19);
  return memcpy(a1, v9, 0x20u);
}
// 19AE80: variable 'v1' is possibly undefined
// 19AFD0: variable 'v2' is possibly undefined
// 19B08E: variable 'v3' is possibly undefined
// 19B14C: variable 'v4' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0019B208) --------------------------------------------------------
int __fastcall le256_target_to_diff_base(int a1)
{
  int j; // [sp+Ch] [bp+Ch]
  int i; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+17h] [bp+17h]

  v5 = 0;
  for ( i = 31; i >= 0; --i )
  {
    for ( j = 7; j >= 0; --j )
    {
      if ( (((int)*(unsigned __int8 *)(i + a1) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (0019B26C) --------------------------------------------------------
int __fastcall sub_19B26C(int a1)
{
  __int64 v1; // r0
  __int64 v2; // r0
  __int64 v3; // r0
  __int64 v4; // r0

  LODWORD(v1) = sub_19AD10(*(_DWORD *)a1, *(_DWORD *)(a1 + 4));
  sub_1A3C0C(v1);
  LODWORD(v2) = sub_19AD10(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  sub_1A3C0C(v2);
  LODWORD(v3) = sub_19AD10(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  sub_1A3C0C(v3);
  LODWORD(v4) = sub_19AD10(*(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 28));
  return sub_1A3C0C(v4);
}
// 19B28E: variable 'v1' is possibly undefined
// 19B2BE: variable 'v2' is possibly undefined
// 19B2F6: variable 'v3' is possibly undefined
// 19B32E: variable 'v4' is possibly undefined

//----- (0019B370) --------------------------------------------------------
int __fastcall be256_target_to_double_diff_base(int a1)
{
  return sub_19B26C(a1);
}

//----- (0019B3D0) --------------------------------------------------------
void *__fastcall diff_to_be256_target_base(void *a1)
{
  double v1; // d0
  unsigned int v2; // r0
  _BYTE *v3; // r2
  int v4; // r1
  double v5; // r0
  unsigned int v6; // r0
  _BYTE *v7; // r2
  int v8; // r1
  double v9; // r0
  unsigned int v10; // r0
  _BYTE *v11; // r2
  int v12; // r1
  double v13; // r0
  unsigned int v14; // r0
  _BYTE *v15; // r2
  int v16; // r1
  double v18; // [sp+10h] [bp+0h]
  _BYTE v20[28]; // [sp+24h] [bp+14h] BYREF
  _BYTE v21[32]; // [sp+1024h] [bp+1014h] BYREF
  _BYTE *v22; // [sp+1044h] [bp+1034h]
  unsigned __int64 v23; // [sp+1048h] [bp+1038h]
  double v24; // [sp+1050h] [bp+1040h]
  double v25; // [sp+1058h] [bp+1048h]

  v18 = v1;
  if ( v1 <= 0.0 )
  {
    V_LOCK();
    logfmt_raw(v20, 0x1000u, 0, "Diff zero passed to set_target");
    V_UNLOCK();
    zlog(
      g_zc,
      "/home/xingfeiwang/work/share-d/code/1489/godminer/common/mining/base_common.c",
      77,
      "diff_to_be256_target_base",
      25,
      170,
      20,
      v20);
    v18 = 1.0;
  }
  v25 = 1.15790322e77 / v18;
  v24 = 1.15790322e77 / v18 / 6.27710174e57;
  v23 = (unsigned __int64)v24;
  v22 = v21;
  v2 = sub_19AD10(v23, HIDWORD(v23));
  v3 = v22;
  *(_DWORD *)v22 = v2;
  *((_DWORD *)v3 + 1) = v4;
  LODWORD(v5) = sub_1A3C0C(v23);
  v25 = v25 - v5 * 6.27710174e57;
  v24 = v25 / 3.40282367e38;
  v23 = (unsigned __int64)(v25 / 3.40282367e38);
  v22 = &v21[8];
  v6 = sub_19AD10(v23, HIDWORD(v23));
  v7 = v22;
  *(_DWORD *)v22 = v6;
  *((_DWORD *)v7 + 1) = v8;
  LODWORD(v9) = sub_1A3C0C(v23);
  v25 = v25 - v9 * 3.40282367e38;
  v24 = v25 / 1.84467441e19;
  v23 = (unsigned __int64)(v25 / 1.84467441e19);
  v22 = &v21[16];
  v10 = sub_19AD10(v23, HIDWORD(v23));
  v11 = v22;
  *(_DWORD *)v22 = v10;
  *((_DWORD *)v11 + 1) = v12;
  LODWORD(v13) = sub_1A3C0C(v23);
  v24 = v13 * 1.84467441e19;
  v25 = v25 - v13 * 1.84467441e19;
  v23 = (unsigned __int64)v25;
  v22 = &v21[24];
  v14 = sub_19AD10(v23, HIDWORD(v23));
  v15 = v22;
  *(_DWORD *)v22 = v14;
  *((_DWORD *)v15 + 1) = v16;
  return memcpy(a1, v21, 0x20u);
}
// 19B3E8: variable 'v1' is possibly undefined
// 19B50A: variable 'v4' is possibly undefined
// 19B53E: variable 'v5' is possibly undefined
// 19B5D0: variable 'v8' is possibly undefined
// 19B604: variable 'v9' is possibly undefined
// 19B696: variable 'v12' is possibly undefined
// 19B6CA: variable 'v13' is possibly undefined
// 19B744: variable 'v16' is possibly undefined
// 20AAC: using guessed type __int64 __fastcall zlog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47BE18: using guessed type int g_zc;

//----- (0019B790) --------------------------------------------------------
int __fastcall be256_target_to_diff_base(int a1)
{
  int j; // [sp+Ch] [bp+Ch]
  int i; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+17h] [bp+17h]

  v5 = 0;
  for ( i = 0; i <= 31; ++i )
  {
    for ( j = 7; j >= 0; --j )
    {
      if ( (((int)*(unsigned __int8 *)(i + a1) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (0019B7F8) --------------------------------------------------------
int __fastcall sub_19B7F8(int result, unsigned int a2)
{
  *(_BYTE *)result = a2;
  *(_WORD *)(result + 1) = a2 >> 8;
  *(_BYTE *)(result + 3) = HIBYTE(a2);
  return result;
}

//----- (0019B83C) --------------------------------------------------------
int __fastcall sub_19B83C(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0019B854) --------------------------------------------------------
void *__fastcall sub_19B854(int a1, const void *a2)
{
  void *result; // r0

  result = memcpy((void *)(a1 + 36), a2, 0x80u);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (0019B87C) --------------------------------------------------------
int __fastcall sub_19B87C(int result, char *a2, size_t a3)
{
  size_t n; // [sp+4h] [bp+4h]
  char *src; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+14h] [bp+14h]
  size_t v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]
  int v9; // [sp+1Ch] [bp+1Ch]
  int v10; // [sp+1Ch] [bp+1Ch]
  int v11; // [sp+1Ch] [bp+1Ch]
  int v12; // [sp+1Ch] [bp+1Ch]
  int v13; // [sp+1Ch] [bp+1Ch]
  int v14; // [sp+1Ch] [bp+1Ch]
  int v15; // [sp+1Ch] [bp+1Ch]
  int v16; // [sp+1Ch] [bp+1Ch]
  int v17; // [sp+1Ch] [bp+1Ch]
  int v18; // [sp+1Ch] [bp+1Ch]
  int v19; // [sp+1Ch] [bp+1Ch]
  int v20; // [sp+1Ch] [bp+1Ch]
  int v21; // [sp+1Ch] [bp+1Ch]
  int v22; // [sp+1Ch] [bp+1Ch]
  int v23; // [sp+1Ch] [bp+1Ch]
  int v24; // [sp+1Ch] [bp+1Ch]
  int v25; // [sp+1Ch] [bp+1Ch]
  int v26; // [sp+1Ch] [bp+1Ch]
  int v27; // [sp+1Ch] [bp+1Ch]
  int v28; // [sp+1Ch] [bp+1Ch]
  int v29; // [sp+1Ch] [bp+1Ch]
  int v30; // [sp+1Ch] [bp+1Ch]
  int v31; // [sp+1Ch] [bp+1Ch]
  int v32; // [sp+1Ch] [bp+1Ch]
  int v33; // [sp+1Ch] [bp+1Ch]
  int v34; // [sp+1Ch] [bp+1Ch]
  int v35; // [sp+1Ch] [bp+1Ch]
  int v36; // [sp+1Ch] [bp+1Ch]
  int v37; // [sp+1Ch] [bp+1Ch]
  int v38; // [sp+1Ch] [bp+1Ch]
  int v39; // [sp+1Ch] [bp+1Ch]
  int v40; // [sp+20h] [bp+20h]
  int v41; // [sp+20h] [bp+20h]
  int v42; // [sp+20h] [bp+20h]
  int v43; // [sp+20h] [bp+20h]
  int v44; // [sp+20h] [bp+20h]
  int v45; // [sp+20h] [bp+20h]
  int v46; // [sp+20h] [bp+20h]
  int v47; // [sp+20h] [bp+20h]
  int v48; // [sp+20h] [bp+20h]
  int v49; // [sp+20h] [bp+20h]
  int v50; // [sp+20h] [bp+20h]
  int v51; // [sp+20h] [bp+20h]
  int v52; // [sp+20h] [bp+20h]
  int v53; // [sp+20h] [bp+20h]
  int v54; // [sp+20h] [bp+20h]
  int v55; // [sp+20h] [bp+20h]
  int v56; // [sp+20h] [bp+20h]
  int v57; // [sp+20h] [bp+20h]
  int v58; // [sp+20h] [bp+20h]
  int v59; // [sp+20h] [bp+20h]
  int v60; // [sp+20h] [bp+20h]
  int v61; // [sp+20h] [bp+20h]
  int v62; // [sp+20h] [bp+20h]
  int v63; // [sp+20h] [bp+20h]
  int v64; // [sp+20h] [bp+20h]
  int v65; // [sp+20h] [bp+20h]
  int v66; // [sp+20h] [bp+20h]
  int v67; // [sp+20h] [bp+20h]
  int v68; // [sp+20h] [bp+20h]
  int v69; // [sp+20h] [bp+20h]
  int v70; // [sp+20h] [bp+20h]
  int v71; // [sp+20h] [bp+20h]
  int v72; // [sp+24h] [bp+24h]
  int v73; // [sp+24h] [bp+24h]
  int v74; // [sp+24h] [bp+24h]
  int v75; // [sp+24h] [bp+24h]
  int v76; // [sp+24h] [bp+24h]
  int v77; // [sp+24h] [bp+24h]
  int v78; // [sp+24h] [bp+24h]
  int v79; // [sp+24h] [bp+24h]
  int v80; // [sp+24h] [bp+24h]
  int v81; // [sp+24h] [bp+24h]
  int v82; // [sp+24h] [bp+24h]
  int v83; // [sp+24h] [bp+24h]
  int v84; // [sp+24h] [bp+24h]
  int v85; // [sp+24h] [bp+24h]
  int v86; // [sp+24h] [bp+24h]
  int v87; // [sp+24h] [bp+24h]
  int v88; // [sp+24h] [bp+24h]
  int v89; // [sp+24h] [bp+24h]
  int v90; // [sp+24h] [bp+24h]
  int v91; // [sp+24h] [bp+24h]
  int v92; // [sp+24h] [bp+24h]
  int v93; // [sp+24h] [bp+24h]
  int v94; // [sp+24h] [bp+24h]
  int v95; // [sp+24h] [bp+24h]
  int v96; // [sp+24h] [bp+24h]
  int v97; // [sp+24h] [bp+24h]
  int v98; // [sp+24h] [bp+24h]
  int v99; // [sp+24h] [bp+24h]
  int v100; // [sp+24h] [bp+24h]
  int v101; // [sp+24h] [bp+24h]
  int v102; // [sp+24h] [bp+24h]
  int v103; // [sp+24h] [bp+24h]
  int v104; // [sp+28h] [bp+28h]
  int v105; // [sp+28h] [bp+28h]
  int v106; // [sp+28h] [bp+28h]
  int v107; // [sp+28h] [bp+28h]
  int v108; // [sp+28h] [bp+28h]
  int v109; // [sp+28h] [bp+28h]
  int v110; // [sp+28h] [bp+28h]
  int v111; // [sp+28h] [bp+28h]
  int v112; // [sp+28h] [bp+28h]
  int v113; // [sp+28h] [bp+28h]
  int v114; // [sp+28h] [bp+28h]
  int v115; // [sp+28h] [bp+28h]
  int v116; // [sp+28h] [bp+28h]
  int v117; // [sp+28h] [bp+28h]
  int v118; // [sp+28h] [bp+28h]
  int v119; // [sp+28h] [bp+28h]
  int v120; // [sp+28h] [bp+28h]
  int v121; // [sp+28h] [bp+28h]
  int v122; // [sp+28h] [bp+28h]
  int v123; // [sp+28h] [bp+28h]
  int v124; // [sp+28h] [bp+28h]
  int v125; // [sp+28h] [bp+28h]
  int v126; // [sp+28h] [bp+28h]
  int v127; // [sp+28h] [bp+28h]
  int v128; // [sp+28h] [bp+28h]
  int v129; // [sp+28h] [bp+28h]
  int v130; // [sp+28h] [bp+28h]
  int v131; // [sp+28h] [bp+28h]
  int v132; // [sp+28h] [bp+28h]
  int v133; // [sp+28h] [bp+28h]
  int v134; // [sp+28h] [bp+28h]
  int v135; // [sp+28h] [bp+28h]
  int v136; // [sp+2Ch] [bp+2Ch]
  int v137; // [sp+2Ch] [bp+2Ch]
  int v138; // [sp+2Ch] [bp+2Ch]
  int v139; // [sp+2Ch] [bp+2Ch]
  int v140; // [sp+2Ch] [bp+2Ch]
  int v141; // [sp+2Ch] [bp+2Ch]
  int v142; // [sp+2Ch] [bp+2Ch]
  int v143; // [sp+2Ch] [bp+2Ch]
  int v144; // [sp+2Ch] [bp+2Ch]
  int v145; // [sp+2Ch] [bp+2Ch]
  int v146; // [sp+2Ch] [bp+2Ch]
  int v147; // [sp+2Ch] [bp+2Ch]
  int v148; // [sp+2Ch] [bp+2Ch]
  int v149; // [sp+2Ch] [bp+2Ch]
  int v150; // [sp+2Ch] [bp+2Ch]
  int v151; // [sp+2Ch] [bp+2Ch]
  int v152; // [sp+2Ch] [bp+2Ch]
  int v153; // [sp+2Ch] [bp+2Ch]
  int v154; // [sp+2Ch] [bp+2Ch]
  int v155; // [sp+2Ch] [bp+2Ch]
  int v156; // [sp+2Ch] [bp+2Ch]
  int v157; // [sp+2Ch] [bp+2Ch]
  int v158; // [sp+2Ch] [bp+2Ch]
  int v159; // [sp+2Ch] [bp+2Ch]
  int v160; // [sp+2Ch] [bp+2Ch]
  int v161; // [sp+2Ch] [bp+2Ch]
  int v162; // [sp+2Ch] [bp+2Ch]
  int v163; // [sp+2Ch] [bp+2Ch]
  int v164; // [sp+2Ch] [bp+2Ch]
  int v165; // [sp+2Ch] [bp+2Ch]
  int v166; // [sp+2Ch] [bp+2Ch]
  int v167; // [sp+2Ch] [bp+2Ch]
  int v168; // [sp+30h] [bp+30h]
  int v169; // [sp+30h] [bp+30h]
  int v170; // [sp+30h] [bp+30h]
  int v171; // [sp+30h] [bp+30h]
  int v172; // [sp+30h] [bp+30h]
  int v173; // [sp+30h] [bp+30h]
  int v174; // [sp+30h] [bp+30h]
  int v175; // [sp+30h] [bp+30h]
  int v176; // [sp+30h] [bp+30h]
  int v177; // [sp+30h] [bp+30h]
  int v178; // [sp+30h] [bp+30h]
  int v179; // [sp+30h] [bp+30h]
  int v180; // [sp+30h] [bp+30h]
  int v181; // [sp+30h] [bp+30h]
  int v182; // [sp+30h] [bp+30h]
  int v183; // [sp+30h] [bp+30h]
  int v184; // [sp+30h] [bp+30h]
  int v185; // [sp+30h] [bp+30h]
  int v186; // [sp+30h] [bp+30h]
  int v187; // [sp+30h] [bp+30h]
  int v188; // [sp+30h] [bp+30h]
  int v189; // [sp+30h] [bp+30h]
  int v190; // [sp+30h] [bp+30h]
  int v191; // [sp+30h] [bp+30h]
  int v192; // [sp+30h] [bp+30h]
  int v193; // [sp+30h] [bp+30h]
  int v194; // [sp+30h] [bp+30h]
  int v195; // [sp+30h] [bp+30h]
  int v196; // [sp+30h] [bp+30h]
  int v197; // [sp+30h] [bp+30h]
  int v198; // [sp+30h] [bp+30h]
  int v199; // [sp+30h] [bp+30h]
  int v200; // [sp+34h] [bp+34h]
  int v201; // [sp+34h] [bp+34h]
  int v202; // [sp+34h] [bp+34h]
  int v203; // [sp+34h] [bp+34h]
  int v204; // [sp+34h] [bp+34h]
  int v205; // [sp+34h] [bp+34h]
  int v206; // [sp+34h] [bp+34h]
  int v207; // [sp+34h] [bp+34h]
  int v208; // [sp+34h] [bp+34h]
  int v209; // [sp+34h] [bp+34h]
  int v210; // [sp+34h] [bp+34h]
  int v211; // [sp+34h] [bp+34h]
  int v212; // [sp+34h] [bp+34h]
  int v213; // [sp+34h] [bp+34h]
  int v214; // [sp+34h] [bp+34h]
  int v215; // [sp+34h] [bp+34h]
  int v216; // [sp+34h] [bp+34h]
  int v217; // [sp+34h] [bp+34h]
  int v218; // [sp+34h] [bp+34h]
  int v219; // [sp+34h] [bp+34h]
  int v220; // [sp+34h] [bp+34h]
  int v221; // [sp+34h] [bp+34h]
  int v222; // [sp+34h] [bp+34h]
  int v223; // [sp+34h] [bp+34h]
  int v224; // [sp+34h] [bp+34h]
  int v225; // [sp+34h] [bp+34h]
  int v226; // [sp+34h] [bp+34h]
  int v227; // [sp+34h] [bp+34h]
  int v228; // [sp+34h] [bp+34h]
  int v229; // [sp+34h] [bp+34h]
  int v230; // [sp+34h] [bp+34h]
  int v231; // [sp+34h] [bp+34h]
  int v232; // [sp+38h] [bp+38h]
  int v233; // [sp+38h] [bp+38h]
  int v234; // [sp+38h] [bp+38h]
  int v235; // [sp+38h] [bp+38h]
  int v236; // [sp+38h] [bp+38h]
  int v237; // [sp+38h] [bp+38h]
  int v238; // [sp+38h] [bp+38h]
  int v239; // [sp+38h] [bp+38h]
  int v240; // [sp+38h] [bp+38h]
  int v241; // [sp+38h] [bp+38h]
  int v242; // [sp+38h] [bp+38h]
  int v243; // [sp+38h] [bp+38h]
  int v244; // [sp+38h] [bp+38h]
  int v245; // [sp+38h] [bp+38h]
  int v246; // [sp+38h] [bp+38h]
  int v247; // [sp+38h] [bp+38h]
  int v248; // [sp+38h] [bp+38h]
  int v249; // [sp+38h] [bp+38h]
  int v250; // [sp+38h] [bp+38h]
  int v251; // [sp+38h] [bp+38h]
  int v252; // [sp+38h] [bp+38h]
  int v253; // [sp+38h] [bp+38h]
  int v254; // [sp+38h] [bp+38h]
  int v255; // [sp+38h] [bp+38h]
  int v256; // [sp+38h] [bp+38h]
  int v257; // [sp+38h] [bp+38h]
  int v258; // [sp+38h] [bp+38h]
  int v259; // [sp+38h] [bp+38h]
  int v260; // [sp+38h] [bp+38h]
  int v261; // [sp+38h] [bp+38h]
  int v262; // [sp+38h] [bp+38h]
  int v263; // [sp+38h] [bp+38h]
  int v264; // [sp+3Ch] [bp+3Ch]
  int v265; // [sp+3Ch] [bp+3Ch]
  int v266; // [sp+3Ch] [bp+3Ch]
  int v267; // [sp+3Ch] [bp+3Ch]
  int v268; // [sp+3Ch] [bp+3Ch]
  int v269; // [sp+3Ch] [bp+3Ch]
  int v270; // [sp+3Ch] [bp+3Ch]
  int v271; // [sp+3Ch] [bp+3Ch]
  int v272; // [sp+3Ch] [bp+3Ch]
  int v273; // [sp+3Ch] [bp+3Ch]
  int v274; // [sp+3Ch] [bp+3Ch]
  int v275; // [sp+3Ch] [bp+3Ch]
  int v276; // [sp+3Ch] [bp+3Ch]
  int v277; // [sp+3Ch] [bp+3Ch]
  int v278; // [sp+3Ch] [bp+3Ch]
  int v279; // [sp+3Ch] [bp+3Ch]
  int v280; // [sp+3Ch] [bp+3Ch]
  int v281; // [sp+3Ch] [bp+3Ch]
  int v282; // [sp+3Ch] [bp+3Ch]
  int v283; // [sp+3Ch] [bp+3Ch]
  int v284; // [sp+3Ch] [bp+3Ch]
  int v285; // [sp+3Ch] [bp+3Ch]
  int v286; // [sp+3Ch] [bp+3Ch]
  int v287; // [sp+3Ch] [bp+3Ch]
  int v288; // [sp+3Ch] [bp+3Ch]
  int v289; // [sp+3Ch] [bp+3Ch]
  int v290; // [sp+3Ch] [bp+3Ch]
  int v291; // [sp+3Ch] [bp+3Ch]
  int v292; // [sp+3Ch] [bp+3Ch]
  int v293; // [sp+3Ch] [bp+3Ch]
  int v294; // [sp+3Ch] [bp+3Ch]
  int v295; // [sp+3Ch] [bp+3Ch]
  int v296; // [sp+40h] [bp+40h]
  int v297; // [sp+40h] [bp+40h]
  int v298; // [sp+40h] [bp+40h]
  int v299; // [sp+40h] [bp+40h]
  int v300; // [sp+40h] [bp+40h]
  int v301; // [sp+40h] [bp+40h]
  int v302; // [sp+40h] [bp+40h]
  int v303; // [sp+40h] [bp+40h]
  int v304; // [sp+40h] [bp+40h]
  int v305; // [sp+40h] [bp+40h]
  int v306; // [sp+40h] [bp+40h]
  int v307; // [sp+40h] [bp+40h]
  int v308; // [sp+40h] [bp+40h]
  int v309; // [sp+40h] [bp+40h]
  int v310; // [sp+40h] [bp+40h]
  int v311; // [sp+40h] [bp+40h]
  int v312; // [sp+40h] [bp+40h]
  int v313; // [sp+40h] [bp+40h]
  int v314; // [sp+40h] [bp+40h]
  int v315; // [sp+40h] [bp+40h]
  int v316; // [sp+40h] [bp+40h]
  int v317; // [sp+40h] [bp+40h]
  int v318; // [sp+40h] [bp+40h]
  int v319; // [sp+40h] [bp+40h]
  int v320; // [sp+40h] [bp+40h]
  int v321; // [sp+40h] [bp+40h]
  int v322; // [sp+40h] [bp+40h]
  int v323; // [sp+40h] [bp+40h]
  int v324; // [sp+40h] [bp+40h]
  int v325; // [sp+40h] [bp+40h]
  int v326; // [sp+40h] [bp+40h]
  int v327; // [sp+40h] [bp+40h]
  int v328; // [sp+44h] [bp+44h]
  int v329; // [sp+44h] [bp+44h]
  int v330; // [sp+44h] [bp+44h]
  int v331; // [sp+44h] [bp+44h]
  int v332; // [sp+44h] [bp+44h]
  int v333; // [sp+44h] [bp+44h]
  int v334; // [sp+44h] [bp+44h]
  int v335; // [sp+44h] [bp+44h]
  int v336; // [sp+44h] [bp+44h]
  int v337; // [sp+44h] [bp+44h]
  int v338; // [sp+44h] [bp+44h]
  int v339; // [sp+44h] [bp+44h]
  int v340; // [sp+44h] [bp+44h]
  int v341; // [sp+44h] [bp+44h]
  int v342; // [sp+44h] [bp+44h]
  int v343; // [sp+44h] [bp+44h]
  int v344; // [sp+44h] [bp+44h]
  int v345; // [sp+44h] [bp+44h]
  int v346; // [sp+44h] [bp+44h]
  int v347; // [sp+44h] [bp+44h]
  int v348; // [sp+44h] [bp+44h]
  int v349; // [sp+44h] [bp+44h]
  int v350; // [sp+44h] [bp+44h]
  int v351; // [sp+44h] [bp+44h]
  int v352; // [sp+44h] [bp+44h]
  int v353; // [sp+44h] [bp+44h]
  int v354; // [sp+44h] [bp+44h]
  int v355; // [sp+44h] [bp+44h]
  int v356; // [sp+44h] [bp+44h]
  int v357; // [sp+44h] [bp+44h]
  int v358; // [sp+44h] [bp+44h]
  int v359; // [sp+44h] [bp+44h]
  int v360; // [sp+48h] [bp+48h]
  int v361; // [sp+48h] [bp+48h]
  int v362; // [sp+48h] [bp+48h]
  int v363; // [sp+48h] [bp+48h]
  int v364; // [sp+48h] [bp+48h]
  int v365; // [sp+48h] [bp+48h]
  int v366; // [sp+48h] [bp+48h]
  int v367; // [sp+48h] [bp+48h]
  int v368; // [sp+48h] [bp+48h]
  int v369; // [sp+48h] [bp+48h]
  int v370; // [sp+48h] [bp+48h]
  int v371; // [sp+48h] [bp+48h]
  int v372; // [sp+48h] [bp+48h]
  int v373; // [sp+48h] [bp+48h]
  int v374; // [sp+48h] [bp+48h]
  int v375; // [sp+48h] [bp+48h]
  int v376; // [sp+48h] [bp+48h]
  int v377; // [sp+48h] [bp+48h]
  int v378; // [sp+48h] [bp+48h]
  int v379; // [sp+48h] [bp+48h]
  int v380; // [sp+48h] [bp+48h]
  int v381; // [sp+48h] [bp+48h]
  int v382; // [sp+48h] [bp+48h]
  int v383; // [sp+48h] [bp+48h]
  int v384; // [sp+48h] [bp+48h]
  int v385; // [sp+48h] [bp+48h]
  int v386; // [sp+48h] [bp+48h]
  int v387; // [sp+48h] [bp+48h]
  int v388; // [sp+48h] [bp+48h]
  int v389; // [sp+48h] [bp+48h]
  int v390; // [sp+48h] [bp+48h]
  int v391; // [sp+48h] [bp+48h]
  int v392; // [sp+4Ch] [bp+4Ch]
  int v393; // [sp+4Ch] [bp+4Ch]
  int v394; // [sp+4Ch] [bp+4Ch]
  int v395; // [sp+4Ch] [bp+4Ch]
  int v396; // [sp+4Ch] [bp+4Ch]
  int v397; // [sp+4Ch] [bp+4Ch]
  int v398; // [sp+4Ch] [bp+4Ch]
  int v399; // [sp+4Ch] [bp+4Ch]
  int v400; // [sp+4Ch] [bp+4Ch]
  int v401; // [sp+4Ch] [bp+4Ch]
  int v402; // [sp+4Ch] [bp+4Ch]
  int v403; // [sp+4Ch] [bp+4Ch]
  int v404; // [sp+4Ch] [bp+4Ch]
  int v405; // [sp+4Ch] [bp+4Ch]
  int v406; // [sp+4Ch] [bp+4Ch]
  int v407; // [sp+4Ch] [bp+4Ch]
  int v408; // [sp+4Ch] [bp+4Ch]
  int v409; // [sp+4Ch] [bp+4Ch]
  int v410; // [sp+4Ch] [bp+4Ch]
  int v411; // [sp+4Ch] [bp+4Ch]
  int v412; // [sp+4Ch] [bp+4Ch]
  int v413; // [sp+4Ch] [bp+4Ch]
  int v414; // [sp+4Ch] [bp+4Ch]
  int v415; // [sp+4Ch] [bp+4Ch]
  int v416; // [sp+4Ch] [bp+4Ch]
  int v417; // [sp+4Ch] [bp+4Ch]
  int v418; // [sp+4Ch] [bp+4Ch]
  int v419; // [sp+4Ch] [bp+4Ch]
  int v420; // [sp+4Ch] [bp+4Ch]
  int v421; // [sp+4Ch] [bp+4Ch]
  int v422; // [sp+4Ch] [bp+4Ch]
  int v423; // [sp+4Ch] [bp+4Ch]
  int v424; // [sp+50h] [bp+50h]
  int v425; // [sp+50h] [bp+50h]
  int v426; // [sp+50h] [bp+50h]
  int v427; // [sp+50h] [bp+50h]
  int v428; // [sp+50h] [bp+50h]
  int v429; // [sp+50h] [bp+50h]
  int v430; // [sp+50h] [bp+50h]
  int v431; // [sp+50h] [bp+50h]
  int v432; // [sp+50h] [bp+50h]
  int v433; // [sp+50h] [bp+50h]
  int v434; // [sp+50h] [bp+50h]
  int v435; // [sp+50h] [bp+50h]
  int v436; // [sp+50h] [bp+50h]
  int v437; // [sp+50h] [bp+50h]
  int v438; // [sp+50h] [bp+50h]
  int v439; // [sp+50h] [bp+50h]
  int v440; // [sp+50h] [bp+50h]
  int v441; // [sp+50h] [bp+50h]
  int v442; // [sp+50h] [bp+50h]
  int v443; // [sp+50h] [bp+50h]
  int v444; // [sp+50h] [bp+50h]
  int v445; // [sp+50h] [bp+50h]
  int v446; // [sp+50h] [bp+50h]
  int v447; // [sp+50h] [bp+50h]
  int v448; // [sp+50h] [bp+50h]
  int v449; // [sp+50h] [bp+50h]
  int v450; // [sp+50h] [bp+50h]
  int v451; // [sp+50h] [bp+50h]
  int v452; // [sp+50h] [bp+50h]
  int v453; // [sp+50h] [bp+50h]
  int v454; // [sp+50h] [bp+50h]
  int v455; // [sp+50h] [bp+50h]
  int v456; // [sp+54h] [bp+54h]
  int v457; // [sp+54h] [bp+54h]
  int v458; // [sp+54h] [bp+54h]
  int v459; // [sp+54h] [bp+54h]
  int v460; // [sp+54h] [bp+54h]
  int v461; // [sp+54h] [bp+54h]
  int v462; // [sp+54h] [bp+54h]
  int v463; // [sp+54h] [bp+54h]
  int v464; // [sp+54h] [bp+54h]
  int v465; // [sp+54h] [bp+54h]
  int v466; // [sp+54h] [bp+54h]
  int v467; // [sp+54h] [bp+54h]
  int v468; // [sp+54h] [bp+54h]
  int v469; // [sp+54h] [bp+54h]
  int v470; // [sp+54h] [bp+54h]
  int v471; // [sp+54h] [bp+54h]
  int v472; // [sp+54h] [bp+54h]
  int v473; // [sp+54h] [bp+54h]
  int v474; // [sp+54h] [bp+54h]
  int v475; // [sp+54h] [bp+54h]
  int v476; // [sp+54h] [bp+54h]
  int v477; // [sp+54h] [bp+54h]
  int v478; // [sp+54h] [bp+54h]
  int v479; // [sp+54h] [bp+54h]
  int v480; // [sp+54h] [bp+54h]
  int v481; // [sp+54h] [bp+54h]
  int v482; // [sp+54h] [bp+54h]
  int v483; // [sp+54h] [bp+54h]
  int v484; // [sp+54h] [bp+54h]
  int v485; // [sp+54h] [bp+54h]
  int v486; // [sp+54h] [bp+54h]
  int v487; // [sp+54h] [bp+54h]
  int v488; // [sp+58h] [bp+58h]
  int v489; // [sp+58h] [bp+58h]
  int v490; // [sp+58h] [bp+58h]
  int v491; // [sp+58h] [bp+58h]
  int v492; // [sp+58h] [bp+58h]
  int v493; // [sp+58h] [bp+58h]
  int v494; // [sp+58h] [bp+58h]
  int v495; // [sp+58h] [bp+58h]
  int v496; // [sp+58h] [bp+58h]
  int v497; // [sp+58h] [bp+58h]
  int v498; // [sp+58h] [bp+58h]
  int v499; // [sp+58h] [bp+58h]
  int v500; // [sp+58h] [bp+58h]
  int v501; // [sp+58h] [bp+58h]
  int v502; // [sp+58h] [bp+58h]
  int v503; // [sp+58h] [bp+58h]
  int v504; // [sp+58h] [bp+58h]
  int v505; // [sp+58h] [bp+58h]
  int v506; // [sp+58h] [bp+58h]
  int v507; // [sp+58h] [bp+58h]
  int v508; // [sp+58h] [bp+58h]
  int v509; // [sp+58h] [bp+58h]
  int v510; // [sp+58h] [bp+58h]
  int v511; // [sp+58h] [bp+58h]
  int v512; // [sp+58h] [bp+58h]
  int v513; // [sp+58h] [bp+58h]
  int v514; // [sp+58h] [bp+58h]
  int v515; // [sp+58h] [bp+58h]
  int v516; // [sp+58h] [bp+58h]
  int v517; // [sp+58h] [bp+58h]
  int v518; // [sp+58h] [bp+58h]
  int v519; // [sp+58h] [bp+58h]
  int v520; // [sp+5Ch] [bp+5Ch]
  int v521; // [sp+5Ch] [bp+5Ch]
  int v522; // [sp+5Ch] [bp+5Ch]
  int v523; // [sp+5Ch] [bp+5Ch]
  int v524; // [sp+5Ch] [bp+5Ch]
  int v525; // [sp+5Ch] [bp+5Ch]
  int v526; // [sp+5Ch] [bp+5Ch]
  int v527; // [sp+5Ch] [bp+5Ch]
  int v528; // [sp+5Ch] [bp+5Ch]
  int v529; // [sp+5Ch] [bp+5Ch]
  int v530; // [sp+5Ch] [bp+5Ch]
  int v531; // [sp+5Ch] [bp+5Ch]
  int v532; // [sp+5Ch] [bp+5Ch]
  int v533; // [sp+5Ch] [bp+5Ch]
  int v534; // [sp+5Ch] [bp+5Ch]
  int v535; // [sp+5Ch] [bp+5Ch]
  int v536; // [sp+5Ch] [bp+5Ch]
  int v537; // [sp+5Ch] [bp+5Ch]
  int v538; // [sp+5Ch] [bp+5Ch]
  int v539; // [sp+5Ch] [bp+5Ch]
  int v540; // [sp+5Ch] [bp+5Ch]
  int v541; // [sp+5Ch] [bp+5Ch]
  int v542; // [sp+5Ch] [bp+5Ch]
  int v543; // [sp+5Ch] [bp+5Ch]
  int v544; // [sp+5Ch] [bp+5Ch]
  int v545; // [sp+5Ch] [bp+5Ch]
  int v546; // [sp+5Ch] [bp+5Ch]
  int v547; // [sp+5Ch] [bp+5Ch]
  int v548; // [sp+5Ch] [bp+5Ch]
  int v549; // [sp+5Ch] [bp+5Ch]
  int v550; // [sp+5Ch] [bp+5Ch]
  int v551; // [sp+5Ch] [bp+5Ch]
  int v552; // [sp+60h] [bp+60h]
  int v553; // [sp+60h] [bp+60h]
  int v554; // [sp+60h] [bp+60h]
  int v555; // [sp+60h] [bp+60h]
  int v556; // [sp+60h] [bp+60h]
  int v557; // [sp+60h] [bp+60h]
  int v558; // [sp+60h] [bp+60h]
  int v559; // [sp+60h] [bp+60h]
  int v560; // [sp+60h] [bp+60h]
  int v561; // [sp+60h] [bp+60h]
  int v562; // [sp+60h] [bp+60h]
  int v563; // [sp+60h] [bp+60h]
  int v564; // [sp+60h] [bp+60h]
  int v565; // [sp+60h] [bp+60h]
  int v566; // [sp+60h] [bp+60h]
  int v567; // [sp+60h] [bp+60h]
  int v568; // [sp+60h] [bp+60h]
  int v569; // [sp+60h] [bp+60h]
  int v570; // [sp+60h] [bp+60h]
  int v571; // [sp+60h] [bp+60h]
  int v572; // [sp+60h] [bp+60h]
  int v573; // [sp+60h] [bp+60h]
  int v574; // [sp+60h] [bp+60h]
  int v575; // [sp+60h] [bp+60h]
  int v576; // [sp+60h] [bp+60h]
  int v577; // [sp+60h] [bp+60h]
  int v578; // [sp+60h] [bp+60h]
  int v579; // [sp+60h] [bp+60h]
  int v580; // [sp+60h] [bp+60h]
  int v581; // [sp+60h] [bp+60h]
  int v582; // [sp+60h] [bp+60h]
  int v583; // [sp+60h] [bp+60h]
  int v584; // [sp+64h] [bp+64h]
  int v585; // [sp+64h] [bp+64h]
  int v586; // [sp+64h] [bp+64h]
  int v587; // [sp+64h] [bp+64h]
  int v588; // [sp+64h] [bp+64h]
  int v589; // [sp+64h] [bp+64h]
  int v590; // [sp+64h] [bp+64h]
  int v591; // [sp+64h] [bp+64h]
  int v592; // [sp+64h] [bp+64h]
  int v593; // [sp+64h] [bp+64h]
  int v594; // [sp+64h] [bp+64h]
  int v595; // [sp+64h] [bp+64h]
  int v596; // [sp+64h] [bp+64h]
  int v597; // [sp+64h] [bp+64h]
  int v598; // [sp+64h] [bp+64h]
  int v599; // [sp+64h] [bp+64h]
  int v600; // [sp+64h] [bp+64h]
  int v601; // [sp+64h] [bp+64h]
  int v602; // [sp+64h] [bp+64h]
  int v603; // [sp+64h] [bp+64h]
  int v604; // [sp+64h] [bp+64h]
  int v605; // [sp+64h] [bp+64h]
  int v606; // [sp+64h] [bp+64h]
  int v607; // [sp+64h] [bp+64h]
  int v608; // [sp+64h] [bp+64h]
  int v609; // [sp+64h] [bp+64h]
  int v610; // [sp+64h] [bp+64h]
  int v611; // [sp+64h] [bp+64h]
  int v612; // [sp+64h] [bp+64h]
  int v613; // [sp+64h] [bp+64h]
  int v614; // [sp+64h] [bp+64h]
  int v615; // [sp+64h] [bp+64h]
  int v616; // [sp+68h] [bp+68h]
  int v617; // [sp+68h] [bp+68h]
  int v618; // [sp+68h] [bp+68h]
  int v619; // [sp+68h] [bp+68h]
  int v620; // [sp+68h] [bp+68h]
  int v621; // [sp+68h] [bp+68h]
  int v622; // [sp+68h] [bp+68h]
  int v623; // [sp+68h] [bp+68h]
  int v624; // [sp+68h] [bp+68h]
  int v625; // [sp+68h] [bp+68h]
  int v626; // [sp+68h] [bp+68h]
  int v627; // [sp+68h] [bp+68h]
  int v628; // [sp+68h] [bp+68h]
  int v629; // [sp+68h] [bp+68h]
  int v630; // [sp+68h] [bp+68h]
  int v631; // [sp+68h] [bp+68h]
  int v632; // [sp+68h] [bp+68h]
  int v633; // [sp+68h] [bp+68h]
  int v634; // [sp+68h] [bp+68h]
  int v635; // [sp+68h] [bp+68h]
  int v636; // [sp+68h] [bp+68h]
  int v637; // [sp+68h] [bp+68h]
  int v638; // [sp+68h] [bp+68h]
  int v639; // [sp+68h] [bp+68h]
  int v640; // [sp+68h] [bp+68h]
  int v641; // [sp+68h] [bp+68h]
  int v642; // [sp+68h] [bp+68h]
  int v643; // [sp+68h] [bp+68h]
  int v644; // [sp+68h] [bp+68h]
  int v645; // [sp+68h] [bp+68h]
  int v646; // [sp+68h] [bp+68h]
  int v647; // [sp+68h] [bp+68h]
  int v648; // [sp+6Ch] [bp+6Ch]
  int v649; // [sp+6Ch] [bp+6Ch]
  int v650; // [sp+6Ch] [bp+6Ch]
  int v651; // [sp+6Ch] [bp+6Ch]
  int v652; // [sp+6Ch] [bp+6Ch]
  int v653; // [sp+6Ch] [bp+6Ch]
  int v654; // [sp+6Ch] [bp+6Ch]
  int v655; // [sp+6Ch] [bp+6Ch]
  int v656; // [sp+6Ch] [bp+6Ch]
  int v657; // [sp+6Ch] [bp+6Ch]
  int v658; // [sp+6Ch] [bp+6Ch]
  int v659; // [sp+6Ch] [bp+6Ch]
  int v660; // [sp+6Ch] [bp+6Ch]
  int v661; // [sp+6Ch] [bp+6Ch]
  int v662; // [sp+6Ch] [bp+6Ch]
  int v663; // [sp+6Ch] [bp+6Ch]
  int v664; // [sp+6Ch] [bp+6Ch]
  int v665; // [sp+6Ch] [bp+6Ch]
  int v666; // [sp+6Ch] [bp+6Ch]
  int v667; // [sp+6Ch] [bp+6Ch]
  int v668; // [sp+6Ch] [bp+6Ch]
  int v669; // [sp+6Ch] [bp+6Ch]
  int v670; // [sp+6Ch] [bp+6Ch]
  int v671; // [sp+6Ch] [bp+6Ch]
  int v672; // [sp+6Ch] [bp+6Ch]
  int v673; // [sp+6Ch] [bp+6Ch]
  int v674; // [sp+6Ch] [bp+6Ch]
  int v675; // [sp+6Ch] [bp+6Ch]
  int v676; // [sp+6Ch] [bp+6Ch]
  int v677; // [sp+6Ch] [bp+6Ch]
  int v678; // [sp+6Ch] [bp+6Ch]
  int v679; // [sp+6Ch] [bp+6Ch]
  int v680; // [sp+70h] [bp+70h]
  int v681; // [sp+70h] [bp+70h]
  int v682; // [sp+70h] [bp+70h]
  int v683; // [sp+70h] [bp+70h]
  int v684; // [sp+70h] [bp+70h]
  int v685; // [sp+70h] [bp+70h]
  int v686; // [sp+70h] [bp+70h]
  int v687; // [sp+70h] [bp+70h]
  int v688; // [sp+70h] [bp+70h]
  int v689; // [sp+70h] [bp+70h]
  int v690; // [sp+70h] [bp+70h]
  int v691; // [sp+70h] [bp+70h]
  int v692; // [sp+70h] [bp+70h]
  int v693; // [sp+70h] [bp+70h]
  int v694; // [sp+70h] [bp+70h]
  int v695; // [sp+70h] [bp+70h]
  int v696; // [sp+70h] [bp+70h]
  int v697; // [sp+70h] [bp+70h]
  int v698; // [sp+70h] [bp+70h]
  int v699; // [sp+70h] [bp+70h]
  int v700; // [sp+70h] [bp+70h]
  int v701; // [sp+70h] [bp+70h]
  int v702; // [sp+70h] [bp+70h]
  int v703; // [sp+70h] [bp+70h]
  int v704; // [sp+70h] [bp+70h]
  int v705; // [sp+70h] [bp+70h]
  int v706; // [sp+70h] [bp+70h]
  int v707; // [sp+70h] [bp+70h]
  int v708; // [sp+70h] [bp+70h]
  int v709; // [sp+70h] [bp+70h]
  int v710; // [sp+70h] [bp+70h]
  int v711; // [sp+70h] [bp+70h]
  int v712; // [sp+74h] [bp+74h]
  int v713; // [sp+74h] [bp+74h]
  int v714; // [sp+74h] [bp+74h]
  int v715; // [sp+74h] [bp+74h]
  int v716; // [sp+74h] [bp+74h]
  int v717; // [sp+74h] [bp+74h]
  int v718; // [sp+74h] [bp+74h]
  int v719; // [sp+74h] [bp+74h]
  int v720; // [sp+74h] [bp+74h]
  int v721; // [sp+74h] [bp+74h]
  int v722; // [sp+74h] [bp+74h]
  int v723; // [sp+74h] [bp+74h]
  int v724; // [sp+74h] [bp+74h]
  int v725; // [sp+74h] [bp+74h]
  int v726; // [sp+74h] [bp+74h]
  int v727; // [sp+74h] [bp+74h]
  int v728; // [sp+74h] [bp+74h]
  int v729; // [sp+74h] [bp+74h]
  int v730; // [sp+74h] [bp+74h]
  int v731; // [sp+74h] [bp+74h]
  int v732; // [sp+74h] [bp+74h]
  int v733; // [sp+74h] [bp+74h]
  int v734; // [sp+74h] [bp+74h]
  int v735; // [sp+74h] [bp+74h]
  int v736; // [sp+74h] [bp+74h]
  int v737; // [sp+74h] [bp+74h]
  int v738; // [sp+74h] [bp+74h]
  int v739; // [sp+74h] [bp+74h]
  int v740; // [sp+74h] [bp+74h]
  int v741; // [sp+74h] [bp+74h]
  int v742; // [sp+74h] [bp+74h]
  int v743; // [sp+74h] [bp+74h]
  int v744; // [sp+78h] [bp+78h]
  int v745; // [sp+78h] [bp+78h]
  int v746; // [sp+78h] [bp+78h]
  int v747; // [sp+78h] [bp+78h]
  int v748; // [sp+78h] [bp+78h]
  int v749; // [sp+78h] [bp+78h]
  int v750; // [sp+78h] [bp+78h]
  int v751; // [sp+78h] [bp+78h]
  int v752; // [sp+78h] [bp+78h]
  int v753; // [sp+78h] [bp+78h]
  int v754; // [sp+78h] [bp+78h]
  int v755; // [sp+78h] [bp+78h]
  int v756; // [sp+78h] [bp+78h]
  int v757; // [sp+78h] [bp+78h]
  int v758; // [sp+78h] [bp+78h]
  int v759; // [sp+78h] [bp+78h]
  int v760; // [sp+78h] [bp+78h]
  int v761; // [sp+78h] [bp+78h]
  int v762; // [sp+78h] [bp+78h]
  int v763; // [sp+78h] [bp+78h]
  int v764; // [sp+78h] [bp+78h]
  int v765; // [sp+78h] [bp+78h]
  int v766; // [sp+78h] [bp+78h]
  int v767; // [sp+78h] [bp+78h]
  int v768; // [sp+78h] [bp+78h]
  int v769; // [sp+78h] [bp+78h]
  int v770; // [sp+78h] [bp+78h]
  int v771; // [sp+78h] [bp+78h]
  int v772; // [sp+78h] [bp+78h]
  int v773; // [sp+78h] [bp+78h]
  int v774; // [sp+78h] [bp+78h]
  int v775; // [sp+78h] [bp+78h]
  int v776; // [sp+7Ch] [bp+7Ch]
  int v777; // [sp+7Ch] [bp+7Ch]
  int v778; // [sp+7Ch] [bp+7Ch]
  int v779; // [sp+7Ch] [bp+7Ch]
  int v780; // [sp+7Ch] [bp+7Ch]
  int v781; // [sp+7Ch] [bp+7Ch]
  int v782; // [sp+7Ch] [bp+7Ch]
  int v783; // [sp+7Ch] [bp+7Ch]
  int v784; // [sp+7Ch] [bp+7Ch]
  int v785; // [sp+7Ch] [bp+7Ch]
  int v786; // [sp+7Ch] [bp+7Ch]
  int v787; // [sp+7Ch] [bp+7Ch]
  int v788; // [sp+7Ch] [bp+7Ch]
  int v789; // [sp+7Ch] [bp+7Ch]
  int v790; // [sp+7Ch] [bp+7Ch]
  int v791; // [sp+7Ch] [bp+7Ch]
  int v792; // [sp+7Ch] [bp+7Ch]
  int v793; // [sp+7Ch] [bp+7Ch]
  int v794; // [sp+7Ch] [bp+7Ch]
  int v795; // [sp+7Ch] [bp+7Ch]
  int v796; // [sp+7Ch] [bp+7Ch]
  int v797; // [sp+7Ch] [bp+7Ch]
  int v798; // [sp+7Ch] [bp+7Ch]
  int v799; // [sp+7Ch] [bp+7Ch]
  int v800; // [sp+7Ch] [bp+7Ch]
  int v801; // [sp+7Ch] [bp+7Ch]
  int v802; // [sp+7Ch] [bp+7Ch]
  int v803; // [sp+7Ch] [bp+7Ch]
  int v804; // [sp+7Ch] [bp+7Ch]
  int v805; // [sp+7Ch] [bp+7Ch]
  int v806; // [sp+7Ch] [bp+7Ch]
  int v807; // [sp+7Ch] [bp+7Ch]
  int v808; // [sp+7Ch] [bp+7Ch]
  int v809; // [sp+80h] [bp+80h]
  int v810; // [sp+80h] [bp+80h]
  int v811; // [sp+80h] [bp+80h]
  int v812; // [sp+80h] [bp+80h]
  int v813; // [sp+80h] [bp+80h]
  int v814; // [sp+80h] [bp+80h]
  int v815; // [sp+80h] [bp+80h]
  int v816; // [sp+80h] [bp+80h]
  int v817; // [sp+80h] [bp+80h]
  int v818; // [sp+80h] [bp+80h]
  int v819; // [sp+80h] [bp+80h]
  int v820; // [sp+80h] [bp+80h]
  int v821; // [sp+80h] [bp+80h]
  int v822; // [sp+80h] [bp+80h]
  int v823; // [sp+80h] [bp+80h]
  int v824; // [sp+80h] [bp+80h]
  int v825; // [sp+80h] [bp+80h]
  int v826; // [sp+80h] [bp+80h]
  int v827; // [sp+80h] [bp+80h]
  int v828; // [sp+80h] [bp+80h]
  int v829; // [sp+80h] [bp+80h]
  int v830; // [sp+80h] [bp+80h]
  int v831; // [sp+80h] [bp+80h]
  int v832; // [sp+80h] [bp+80h]
  int v833; // [sp+80h] [bp+80h]
  int v834; // [sp+80h] [bp+80h]
  int v835; // [sp+80h] [bp+80h]
  int v836; // [sp+80h] [bp+80h]
  int v837; // [sp+80h] [bp+80h]
  int v838; // [sp+80h] [bp+80h]
  int v839; // [sp+80h] [bp+80h]
  int v840; // [sp+80h] [bp+80h]
  int v841; // [sp+80h] [bp+80h]
  int v842; // [sp+84h] [bp+84h]
  int v843; // [sp+84h] [bp+84h]
  int v844; // [sp+84h] [bp+84h]
  int v845; // [sp+84h] [bp+84h]
  int v846; // [sp+84h] [bp+84h]
  int v847; // [sp+84h] [bp+84h]
  int v848; // [sp+84h] [bp+84h]
  int v849; // [sp+84h] [bp+84h]
  int v850; // [sp+84h] [bp+84h]
  int v851; // [sp+84h] [bp+84h]
  int v852; // [sp+84h] [bp+84h]
  int v853; // [sp+84h] [bp+84h]
  int v854; // [sp+84h] [bp+84h]
  int v855; // [sp+84h] [bp+84h]
  int v856; // [sp+84h] [bp+84h]
  int v857; // [sp+84h] [bp+84h]
  int v858; // [sp+84h] [bp+84h]
  int v859; // [sp+84h] [bp+84h]
  int v860; // [sp+84h] [bp+84h]
  int v861; // [sp+84h] [bp+84h]
  int v862; // [sp+84h] [bp+84h]
  int v863; // [sp+84h] [bp+84h]
  int v864; // [sp+84h] [bp+84h]
  int v865; // [sp+84h] [bp+84h]
  int v866; // [sp+84h] [bp+84h]
  int v867; // [sp+84h] [bp+84h]
  int v868; // [sp+84h] [bp+84h]
  int v869; // [sp+84h] [bp+84h]
  int v870; // [sp+84h] [bp+84h]
  int v871; // [sp+84h] [bp+84h]
  int v872; // [sp+84h] [bp+84h]
  int v873; // [sp+84h] [bp+84h]
  int v874; // [sp+84h] [bp+84h]
  int v875; // [sp+88h] [bp+88h]
  int v876; // [sp+88h] [bp+88h]
  int v877; // [sp+88h] [bp+88h]
  int v878; // [sp+88h] [bp+88h]
  int v879; // [sp+88h] [bp+88h]
  int v880; // [sp+88h] [bp+88h]
  int v881; // [sp+88h] [bp+88h]
  int v882; // [sp+88h] [bp+88h]
  int v883; // [sp+88h] [bp+88h]
  int v884; // [sp+88h] [bp+88h]
  int v885; // [sp+88h] [bp+88h]
  int v886; // [sp+88h] [bp+88h]
  int v887; // [sp+88h] [bp+88h]
  int v888; // [sp+88h] [bp+88h]
  int v889; // [sp+88h] [bp+88h]
  int v890; // [sp+88h] [bp+88h]
  int v891; // [sp+88h] [bp+88h]
  int v892; // [sp+88h] [bp+88h]
  int v893; // [sp+88h] [bp+88h]
  int v894; // [sp+88h] [bp+88h]
  int v895; // [sp+88h] [bp+88h]
  int v896; // [sp+88h] [bp+88h]
  int v897; // [sp+88h] [bp+88h]
  int v898; // [sp+88h] [bp+88h]
  int v899; // [sp+88h] [bp+88h]
  int v900; // [sp+88h] [bp+88h]
  int v901; // [sp+88h] [bp+88h]
  int v902; // [sp+88h] [bp+88h]
  int v903; // [sp+88h] [bp+88h]
  int v904; // [sp+88h] [bp+88h]
  int v905; // [sp+88h] [bp+88h]
  int v906; // [sp+88h] [bp+88h]
  int v907; // [sp+88h] [bp+88h]
  int v908; // [sp+8Ch] [bp+8Ch]
  int v909; // [sp+8Ch] [bp+8Ch]
  int v910; // [sp+8Ch] [bp+8Ch]
  int v911; // [sp+8Ch] [bp+8Ch]
  int v912; // [sp+8Ch] [bp+8Ch]
  int v913; // [sp+8Ch] [bp+8Ch]
  int v914; // [sp+8Ch] [bp+8Ch]
  int v915; // [sp+8Ch] [bp+8Ch]
  int v916; // [sp+8Ch] [bp+8Ch]
  int v917; // [sp+8Ch] [bp+8Ch]
  int v918; // [sp+8Ch] [bp+8Ch]
  int v919; // [sp+8Ch] [bp+8Ch]
  int v920; // [sp+8Ch] [bp+8Ch]
  int v921; // [sp+8Ch] [bp+8Ch]
  int v922; // [sp+8Ch] [bp+8Ch]
  int v923; // [sp+8Ch] [bp+8Ch]
  int v924; // [sp+8Ch] [bp+8Ch]
  int v925; // [sp+8Ch] [bp+8Ch]
  int v926; // [sp+8Ch] [bp+8Ch]
  int v927; // [sp+8Ch] [bp+8Ch]
  int v928; // [sp+8Ch] [bp+8Ch]
  int v929; // [sp+8Ch] [bp+8Ch]
  int v930; // [sp+8Ch] [bp+8Ch]
  int v931; // [sp+8Ch] [bp+8Ch]
  int v932; // [sp+8Ch] [bp+8Ch]
  int v933; // [sp+8Ch] [bp+8Ch]
  int v934; // [sp+8Ch] [bp+8Ch]
  int v935; // [sp+8Ch] [bp+8Ch]
  int v936; // [sp+8Ch] [bp+8Ch]
  int v937; // [sp+8Ch] [bp+8Ch]
  int v938; // [sp+8Ch] [bp+8Ch]
  int v939; // [sp+8Ch] [bp+8Ch]
  int v940; // [sp+8Ch] [bp+8Ch]
  int v941; // [sp+90h] [bp+90h]
  int v942; // [sp+90h] [bp+90h]
  int v943; // [sp+90h] [bp+90h]
  int v944; // [sp+90h] [bp+90h]
  int v945; // [sp+90h] [bp+90h]
  int v946; // [sp+90h] [bp+90h]
  int v947; // [sp+90h] [bp+90h]
  int v948; // [sp+90h] [bp+90h]
  int v949; // [sp+90h] [bp+90h]
  int v950; // [sp+90h] [bp+90h]
  int v951; // [sp+90h] [bp+90h]
  int v952; // [sp+90h] [bp+90h]
  int v953; // [sp+90h] [bp+90h]
  int v954; // [sp+90h] [bp+90h]
  int v955; // [sp+90h] [bp+90h]
  int v956; // [sp+90h] [bp+90h]
  int v957; // [sp+90h] [bp+90h]
  int v958; // [sp+90h] [bp+90h]
  int v959; // [sp+90h] [bp+90h]
  int v960; // [sp+90h] [bp+90h]
  int v961; // [sp+90h] [bp+90h]
  int v962; // [sp+90h] [bp+90h]
  int v963; // [sp+90h] [bp+90h]
  int v964; // [sp+90h] [bp+90h]
  int v965; // [sp+90h] [bp+90h]
  int v966; // [sp+90h] [bp+90h]
  int v967; // [sp+90h] [bp+90h]
  int v968; // [sp+90h] [bp+90h]
  int v969; // [sp+90h] [bp+90h]
  int v970; // [sp+90h] [bp+90h]
  int v971; // [sp+90h] [bp+90h]
  int v972; // [sp+90h] [bp+90h]
  int v973; // [sp+90h] [bp+90h]
  int v974; // [sp+94h] [bp+94h]
  int v975; // [sp+94h] [bp+94h]
  int v976; // [sp+94h] [bp+94h]
  int v977; // [sp+94h] [bp+94h]
  int v978; // [sp+94h] [bp+94h]
  int v979; // [sp+94h] [bp+94h]
  int v980; // [sp+94h] [bp+94h]
  int v981; // [sp+94h] [bp+94h]
  int v982; // [sp+94h] [bp+94h]
  int v983; // [sp+94h] [bp+94h]
  int v984; // [sp+94h] [bp+94h]
  int v985; // [sp+94h] [bp+94h]
  int v986; // [sp+94h] [bp+94h]
  int v987; // [sp+94h] [bp+94h]
  int v988; // [sp+94h] [bp+94h]
  int v989; // [sp+94h] [bp+94h]
  int v990; // [sp+94h] [bp+94h]
  int v991; // [sp+94h] [bp+94h]
  int v992; // [sp+94h] [bp+94h]
  int v993; // [sp+94h] [bp+94h]
  int v994; // [sp+94h] [bp+94h]
  int v995; // [sp+94h] [bp+94h]
  int v996; // [sp+94h] [bp+94h]
  int v997; // [sp+94h] [bp+94h]
  int v998; // [sp+94h] [bp+94h]
  int v999; // [sp+94h] [bp+94h]
  int v1000; // [sp+94h] [bp+94h]
  int v1001; // [sp+94h] [bp+94h]
  int v1002; // [sp+94h] [bp+94h]
  int v1003; // [sp+94h] [bp+94h]
  int v1004; // [sp+94h] [bp+94h]
  int v1005; // [sp+94h] [bp+94h]
  int v1006; // [sp+94h] [bp+94h]
  int v1007; // [sp+98h] [bp+98h]
  int v1008; // [sp+98h] [bp+98h]
  int v1009; // [sp+98h] [bp+98h]
  int v1010; // [sp+98h] [bp+98h]
  int v1011; // [sp+98h] [bp+98h]
  int v1012; // [sp+98h] [bp+98h]
  int v1013; // [sp+98h] [bp+98h]
  int v1014; // [sp+98h] [bp+98h]
  int v1015; // [sp+98h] [bp+98h]
  int v1016; // [sp+98h] [bp+98h]
  int v1017; // [sp+98h] [bp+98h]
  int v1018; // [sp+98h] [bp+98h]
  int v1019; // [sp+98h] [bp+98h]
  int v1020; // [sp+98h] [bp+98h]
  int v1021; // [sp+98h] [bp+98h]
  int v1022; // [sp+98h] [bp+98h]
  int v1023; // [sp+98h] [bp+98h]
  int v1024; // [sp+98h] [bp+98h]
  int v1025; // [sp+98h] [bp+98h]
  int v1026; // [sp+98h] [bp+98h]
  int v1027; // [sp+98h] [bp+98h]
  int v1028; // [sp+98h] [bp+98h]
  int v1029; // [sp+98h] [bp+98h]
  int v1030; // [sp+98h] [bp+98h]
  int v1031; // [sp+98h] [bp+98h]
  int v1032; // [sp+98h] [bp+98h]
  int v1033; // [sp+98h] [bp+98h]
  int v1034; // [sp+98h] [bp+98h]
  int v1035; // [sp+98h] [bp+98h]
  int v1036; // [sp+98h] [bp+98h]
  int v1037; // [sp+98h] [bp+98h]
  int v1038; // [sp+98h] [bp+98h]
  int v1039; // [sp+98h] [bp+98h]
  int v1040; // [sp+9Ch] [bp+9Ch]

  v5 = (_DWORD *)result;
  src = a2;
  n = a3;
  v6 = result;
  v1040 = *(_DWORD *)(result + 32);
  if ( 32 - v1040 <= a3 )
  {
    v1007 = *(_DWORD *)(result + 36);
    v974 = *(_DWORD *)(result + 40);
    v941 = *(_DWORD *)(result + 44);
    v908 = *(_DWORD *)(result + 48);
    v875 = *(_DWORD *)(result + 52);
    v842 = *(_DWORD *)(result + 56);
    v809 = *(_DWORD *)(result + 60);
    v776 = *(_DWORD *)(result + 64);
    v744 = *(_DWORD *)(result + 68);
    v712 = *(_DWORD *)(result + 72);
    v680 = *(_DWORD *)(result + 76);
    v648 = *(_DWORD *)(result + 80);
    v616 = *(_DWORD *)(result + 84);
    v584 = *(_DWORD *)(result + 88);
    v552 = *(_DWORD *)(result + 92);
    v520 = *(_DWORD *)(result + 96);
    v488 = *(_DWORD *)(result + 100);
    v456 = *(_DWORD *)(result + 104);
    v424 = *(_DWORD *)(result + 108);
    v392 = *(_DWORD *)(result + 112);
    v360 = *(_DWORD *)(result + 116);
    v328 = *(_DWORD *)(result + 120);
    v296 = *(_DWORD *)(result + 124);
    v264 = *(_DWORD *)(result + 128);
    v232 = *(_DWORD *)(result + 132);
    v200 = *(_DWORD *)(result + 136);
    v168 = *(_DWORD *)(result + 140);
    v136 = *(_DWORD *)(result + 144);
    v104 = *(_DWORD *)(result + 148);
    v72 = *(_DWORD *)(result + 152);
    v40 = *(_DWORD *)(result + 156);
    v8 = *(_DWORD *)(result + 160);
    while ( n )
    {
      v7 = 32 - v1040;
      if ( 32 - v1040 > n )
        v7 = n;
      result = (int)memcpy((void *)(v1040 + v6), src, v7);
      v1040 += v7;
      src += v7;
      n -= v7;
      if ( v1040 == 32 )
      {
        v1008 = v1007 ^ sub_19B83C(v6);
        v975 = v974 ^ sub_19B83C(v6 + 4);
        v942 = v941 ^ sub_19B83C(v6 + 8);
        v909 = v908 ^ sub_19B83C(v6 + 12);
        v876 = v875 ^ sub_19B83C(v6 + 16);
        v843 = v842 ^ sub_19B83C(v6 + 20);
        v810 = v809 ^ sub_19B83C(v6 + 24);
        result = sub_19B83C(v6 + 28);
        v777 = v776 ^ result;
        v489 = v1008 + v488;
        v457 = v975 + v456;
        v425 = v942 + v424;
        v393 = v909 + v392;
        v361 = v876 + v360;
        v329 = v843 + v328;
        v297 = v810 + v296;
        v265 = v777 + v264;
        v233 = v744 + v232;
        v201 = v712 + v200;
        v169 = v680 + v168;
        v137 = v648 + v136;
        v105 = v616 + v104;
        v73 = v584 + v72;
        v41 = v552 + v40;
        v9 = v520 + v8;
        v745 = v489 ^ __ROR4__(v744, 25);
        v713 = v457 ^ __ROR4__(v712, 25);
        v681 = v425 ^ __ROR4__(v680, 25);
        v649 = v393 ^ __ROR4__(v648, 25);
        v617 = v361 ^ __ROR4__(v616, 25);
        v585 = v329 ^ __ROR4__(v584, 25);
        v553 = v297 ^ __ROR4__(v552, 25);
        v521 = v265 ^ __ROR4__(v520, 25);
        v1009 = v233 ^ __ROR4__(v1008, 25);
        v976 = v201 ^ __ROR4__(v975, 25);
        v943 = v169 ^ __ROR4__(v942, 25);
        v910 = v137 ^ __ROR4__(v909, 25);
        v877 = v105 ^ __ROR4__(v876, 25);
        v844 = v73 ^ __ROR4__(v843, 25);
        v811 = v41 ^ __ROR4__(v810, 25);
        v778 = v9 ^ __ROR4__(v777, 25);
        v426 = v745 + v425;
        v394 = v713 + v393;
        v490 = v681 + v489;
        v458 = v649 + v457;
        v298 = v617 + v297;
        v266 = v585 + v265;
        v362 = v553 + v361;
        v330 = v521 + v329;
        v170 = v1009 + v169;
        v138 = v976 + v137;
        v234 = v943 + v233;
        v202 = v910 + v201;
        v42 = v877 + v41;
        v10 = v844 + v9;
        v106 = v811 + v105;
        v74 = v778 + v73;
        v618 = v426 ^ __ROR4__(v617, 21);
        v586 = v394 ^ __ROR4__(v585, 21);
        v554 = v490 ^ __ROR4__(v553, 21);
        v522 = v458 ^ __ROR4__(v521, 21);
        v746 = v298 ^ __ROR4__(v745, 21);
        v714 = v266 ^ __ROR4__(v713, 21);
        v682 = v362 ^ __ROR4__(v681, 21);
        v650 = v330 ^ __ROR4__(v649, 21);
        v878 = v170 ^ __ROR4__(v877, 21);
        v845 = v138 ^ __ROR4__(v844, 21);
        v812 = v234 ^ __ROR4__(v811, 21);
        v779 = v202 ^ __ROR4__(v778, 21);
        v1010 = v42 ^ __ROR4__(v1009, 21);
        v977 = v10 ^ __ROR4__(v976, 21);
        v944 = v106 ^ __ROR4__(v943, 21);
        v911 = v74 ^ __ROR4__(v910, 21);
        v395 = v618 + v394;
        v427 = v586 + v426;
        v459 = v554 + v458;
        v491 = v522 + v490;
        v267 = v746 + v266;
        v299 = v714 + v298;
        v331 = v682 + v330;
        v363 = v650 + v362;
        v139 = v878 + v138;
        v171 = v845 + v170;
        v203 = v812 + v202;
        v235 = v779 + v234;
        v11 = v1010 + v10;
        v43 = v977 + v42;
        v75 = v944 + v74;
        v107 = v911 + v106;
        v879 = v395 ^ __ROR4__(v878, 25);
        v846 = v427 ^ __ROR4__(v845, 25);
        v813 = v459 ^ __ROR4__(v812, 25);
        v780 = v491 ^ __ROR4__(v779, 25);
        v1011 = v267 ^ __ROR4__(v1010, 25);
        v978 = v299 ^ __ROR4__(v977, 25);
        v945 = v331 ^ __ROR4__(v944, 25);
        v912 = v363 ^ __ROR4__(v911, 25);
        v619 = v139 ^ __ROR4__(v618, 25);
        v587 = v171 ^ __ROR4__(v586, 25);
        v555 = v203 ^ __ROR4__(v554, 25);
        v523 = v235 ^ __ROR4__(v522, 25);
        v747 = v11 ^ __ROR4__(v746, 25);
        v715 = v43 ^ __ROR4__(v714, 25);
        v683 = v75 ^ __ROR4__(v682, 25);
        v651 = v107 ^ __ROR4__(v650, 25);
        v460 = v879 + v459;
        v492 = v846 + v491;
        v396 = v813 + v395;
        v428 = v780 + v427;
        v332 = v1011 + v331;
        v364 = v978 + v363;
        v268 = v945 + v267;
        v300 = v912 + v299;
        v204 = v619 + v203;
        v236 = v587 + v235;
        v140 = v555 + v139;
        v172 = v523 + v171;
        v76 = v747 + v75;
        v108 = v715 + v107;
        v12 = v683 + v11;
        v44 = v651 + v43;
        v1012 = v460 ^ __ROR4__(v1011, 21);
        v979 = v492 ^ __ROR4__(v978, 21);
        v946 = v396 ^ __ROR4__(v945, 21);
        v913 = v428 ^ __ROR4__(v912, 21);
        v880 = v332 ^ __ROR4__(v879, 21);
        v847 = v364 ^ __ROR4__(v846, 21);
        v814 = v268 ^ __ROR4__(v813, 21);
        v781 = v300 ^ __ROR4__(v780, 21);
        v748 = v204 ^ __ROR4__(v747, 21);
        v716 = v236 ^ __ROR4__(v715, 21);
        v684 = v140 ^ __ROR4__(v683, 21);
        v652 = v172 ^ __ROR4__(v651, 21);
        v620 = v76 ^ __ROR4__(v619, 21);
        v588 = v108 ^ __ROR4__(v587, 21);
        v556 = v12 ^ __ROR4__(v555, 21);
        v524 = v44 ^ __ROR4__(v523, 21);
        v493 = v1012 + v492;
        v461 = v979 + v460;
        v429 = v946 + v428;
        v397 = v913 + v396;
        v365 = v880 + v364;
        v333 = v847 + v332;
        v301 = v814 + v300;
        v269 = v781 + v268;
        v237 = v748 + v236;
        v205 = v716 + v204;
        v173 = v684 + v172;
        v141 = v652 + v140;
        v109 = v620 + v108;
        v77 = v588 + v76;
        v45 = v556 + v44;
        v13 = v524 + v12;
        v749 = v493 ^ __ROR4__(v748, 25);
        v717 = v461 ^ __ROR4__(v716, 25);
        v685 = v429 ^ __ROR4__(v684, 25);
        v653 = v397 ^ __ROR4__(v652, 25);
        v621 = v365 ^ __ROR4__(v620, 25);
        v589 = v333 ^ __ROR4__(v588, 25);
        v557 = v301 ^ __ROR4__(v556, 25);
        v525 = v269 ^ __ROR4__(v524, 25);
        v1013 = v237 ^ __ROR4__(v1012, 25);
        v980 = v205 ^ __ROR4__(v979, 25);
        v947 = v173 ^ __ROR4__(v946, 25);
        v914 = v141 ^ __ROR4__(v913, 25);
        v881 = v109 ^ __ROR4__(v880, 25);
        v848 = v77 ^ __ROR4__(v847, 25);
        v815 = v45 ^ __ROR4__(v814, 25);
        v782 = v13 ^ __ROR4__(v781, 25);
        v430 = v749 + v429;
        v398 = v717 + v397;
        v494 = v685 + v493;
        v462 = v653 + v461;
        v302 = v621 + v301;
        v270 = v589 + v269;
        v366 = v557 + v365;
        v334 = v525 + v333;
        v174 = v1013 + v173;
        v142 = v980 + v141;
        v238 = v947 + v237;
        v206 = v914 + v205;
        v46 = v881 + v45;
        v14 = v848 + v13;
        v110 = v815 + v109;
        v78 = v782 + v77;
        v622 = v430 ^ __ROR4__(v621, 21);
        v590 = v398 ^ __ROR4__(v589, 21);
        v558 = v494 ^ __ROR4__(v557, 21);
        v526 = v462 ^ __ROR4__(v525, 21);
        v750 = v302 ^ __ROR4__(v749, 21);
        v718 = v270 ^ __ROR4__(v717, 21);
        v686 = v366 ^ __ROR4__(v685, 21);
        v654 = v334 ^ __ROR4__(v653, 21);
        v882 = v174 ^ __ROR4__(v881, 21);
        v849 = v142 ^ __ROR4__(v848, 21);
        v816 = v238 ^ __ROR4__(v815, 21);
        v783 = v206 ^ __ROR4__(v782, 21);
        v1014 = v46 ^ __ROR4__(v1013, 21);
        v981 = v14 ^ __ROR4__(v980, 21);
        v948 = v110 ^ __ROR4__(v947, 21);
        v915 = v78 ^ __ROR4__(v914, 21);
        v399 = v622 + v398;
        v431 = v590 + v430;
        v463 = v558 + v462;
        v495 = v526 + v494;
        v271 = v750 + v270;
        v303 = v718 + v302;
        v335 = v686 + v334;
        v367 = v654 + v366;
        v143 = v882 + v142;
        v175 = v849 + v174;
        v207 = v816 + v206;
        v239 = v783 + v238;
        v15 = v1014 + v14;
        v47 = v981 + v46;
        v79 = v948 + v78;
        v111 = v915 + v110;
        v883 = v399 ^ __ROR4__(v882, 25);
        v850 = v431 ^ __ROR4__(v849, 25);
        v817 = v463 ^ __ROR4__(v816, 25);
        v784 = v495 ^ __ROR4__(v783, 25);
        v1015 = v271 ^ __ROR4__(v1014, 25);
        v982 = v303 ^ __ROR4__(v981, 25);
        v949 = v335 ^ __ROR4__(v948, 25);
        v916 = v367 ^ __ROR4__(v915, 25);
        v623 = v143 ^ __ROR4__(v622, 25);
        v591 = v175 ^ __ROR4__(v590, 25);
        v559 = v207 ^ __ROR4__(v558, 25);
        v527 = v239 ^ __ROR4__(v526, 25);
        v751 = v15 ^ __ROR4__(v750, 25);
        v719 = v47 ^ __ROR4__(v718, 25);
        v687 = v79 ^ __ROR4__(v686, 25);
        v655 = v111 ^ __ROR4__(v654, 25);
        v464 = v883 + v463;
        v496 = v850 + v495;
        v400 = v817 + v399;
        v432 = v784 + v431;
        v336 = v1015 + v335;
        v368 = v982 + v367;
        v272 = v949 + v271;
        v304 = v916 + v303;
        v208 = v623 + v207;
        v240 = v591 + v239;
        v144 = v559 + v143;
        v176 = v527 + v175;
        v80 = v751 + v79;
        v112 = v719 + v111;
        v16 = v687 + v15;
        v48 = v655 + v47;
        v1016 = v464 ^ __ROR4__(v1015, 21);
        v983 = v496 ^ __ROR4__(v982, 21);
        v950 = v400 ^ __ROR4__(v949, 21);
        v917 = v432 ^ __ROR4__(v916, 21);
        v884 = v336 ^ __ROR4__(v883, 21);
        v851 = v368 ^ __ROR4__(v850, 21);
        v818 = v272 ^ __ROR4__(v817, 21);
        v785 = v304 ^ __ROR4__(v784, 21);
        v752 = v208 ^ __ROR4__(v751, 21);
        v720 = v240 ^ __ROR4__(v719, 21);
        v688 = v144 ^ __ROR4__(v687, 21);
        v656 = v176 ^ __ROR4__(v655, 21);
        v624 = v80 ^ __ROR4__(v623, 21);
        v592 = v112 ^ __ROR4__(v591, 21);
        v560 = v16 ^ __ROR4__(v559, 21);
        v528 = v48 ^ __ROR4__(v527, 21);
        v497 = v1016 + v496;
        v465 = v983 + v464;
        v433 = v950 + v432;
        v401 = v917 + v400;
        v369 = v884 + v368;
        v337 = v851 + v336;
        v305 = v818 + v304;
        v273 = v785 + v272;
        v241 = v752 + v240;
        v209 = v720 + v208;
        v177 = v688 + v176;
        v145 = v656 + v144;
        v113 = v624 + v112;
        v81 = v592 + v80;
        v49 = v560 + v48;
        v17 = v528 + v16;
        v753 = v497 ^ __ROR4__(v752, 25);
        v721 = v465 ^ __ROR4__(v720, 25);
        v689 = v433 ^ __ROR4__(v688, 25);
        v657 = v401 ^ __ROR4__(v656, 25);
        v625 = v369 ^ __ROR4__(v624, 25);
        v593 = v337 ^ __ROR4__(v592, 25);
        v561 = v305 ^ __ROR4__(v560, 25);
        v529 = v273 ^ __ROR4__(v528, 25);
        v1017 = v241 ^ __ROR4__(v1016, 25);
        v984 = v209 ^ __ROR4__(v983, 25);
        v951 = v177 ^ __ROR4__(v950, 25);
        v918 = v145 ^ __ROR4__(v917, 25);
        v885 = v113 ^ __ROR4__(v884, 25);
        v852 = v81 ^ __ROR4__(v851, 25);
        v819 = v49 ^ __ROR4__(v818, 25);
        v786 = v17 ^ __ROR4__(v785, 25);
        v434 = v753 + v433;
        v402 = v721 + v401;
        v498 = v689 + v497;
        v466 = v657 + v465;
        v306 = v625 + v305;
        v274 = v593 + v273;
        v370 = v561 + v369;
        v338 = v529 + v337;
        v178 = v1017 + v177;
        v146 = v984 + v145;
        v242 = v951 + v241;
        v210 = v918 + v209;
        v50 = v885 + v49;
        v18 = v852 + v17;
        v114 = v819 + v113;
        v82 = v786 + v81;
        v626 = v434 ^ __ROR4__(v625, 21);
        v594 = v402 ^ __ROR4__(v593, 21);
        v562 = v498 ^ __ROR4__(v561, 21);
        v530 = v466 ^ __ROR4__(v529, 21);
        v754 = v306 ^ __ROR4__(v753, 21);
        v722 = v274 ^ __ROR4__(v721, 21);
        v690 = v370 ^ __ROR4__(v689, 21);
        v658 = v338 ^ __ROR4__(v657, 21);
        v886 = v178 ^ __ROR4__(v885, 21);
        v853 = v146 ^ __ROR4__(v852, 21);
        v820 = v242 ^ __ROR4__(v819, 21);
        v787 = v210 ^ __ROR4__(v786, 21);
        v1018 = v50 ^ __ROR4__(v1017, 21);
        v985 = v18 ^ __ROR4__(v984, 21);
        v952 = v114 ^ __ROR4__(v951, 21);
        v919 = v82 ^ __ROR4__(v918, 21);
        v403 = v626 + v402;
        v435 = v594 + v434;
        v467 = v562 + v466;
        v499 = v530 + v498;
        v275 = v754 + v274;
        v307 = v722 + v306;
        v339 = v690 + v338;
        v371 = v658 + v370;
        v147 = v886 + v146;
        v179 = v853 + v178;
        v211 = v820 + v210;
        v243 = v787 + v242;
        v19 = v1018 + v18;
        v51 = v985 + v50;
        v83 = v952 + v82;
        v115 = v919 + v114;
        v887 = v403 ^ __ROR4__(v886, 25);
        v854 = v435 ^ __ROR4__(v853, 25);
        v821 = v467 ^ __ROR4__(v820, 25);
        v788 = v499 ^ __ROR4__(v787, 25);
        v1019 = v275 ^ __ROR4__(v1018, 25);
        v986 = v307 ^ __ROR4__(v985, 25);
        v953 = v339 ^ __ROR4__(v952, 25);
        v920 = v371 ^ __ROR4__(v919, 25);
        v627 = v147 ^ __ROR4__(v626, 25);
        v595 = v179 ^ __ROR4__(v594, 25);
        v563 = v211 ^ __ROR4__(v562, 25);
        v531 = v243 ^ __ROR4__(v530, 25);
        v755 = v19 ^ __ROR4__(v754, 25);
        v723 = v51 ^ __ROR4__(v722, 25);
        v691 = v83 ^ __ROR4__(v690, 25);
        v659 = v115 ^ __ROR4__(v658, 25);
        v468 = v887 + v467;
        v500 = v854 + v499;
        v404 = v821 + v403;
        v436 = v788 + v435;
        v340 = v1019 + v339;
        v372 = v986 + v371;
        v276 = v953 + v275;
        v308 = v920 + v307;
        v212 = v627 + v211;
        v244 = v595 + v243;
        v148 = v563 + v147;
        v180 = v531 + v179;
        v84 = v755 + v83;
        v116 = v723 + v115;
        v20 = v691 + v19;
        v52 = v659 + v51;
        v1020 = v468 ^ __ROR4__(v1019, 21);
        v987 = v500 ^ __ROR4__(v986, 21);
        v954 = v404 ^ __ROR4__(v953, 21);
        v921 = v436 ^ __ROR4__(v920, 21);
        v888 = v340 ^ __ROR4__(v887, 21);
        v855 = v372 ^ __ROR4__(v854, 21);
        v822 = v276 ^ __ROR4__(v821, 21);
        v789 = v308 ^ __ROR4__(v788, 21);
        v756 = v212 ^ __ROR4__(v755, 21);
        v724 = v244 ^ __ROR4__(v723, 21);
        v692 = v148 ^ __ROR4__(v691, 21);
        v660 = v180 ^ __ROR4__(v659, 21);
        v628 = v84 ^ __ROR4__(v627, 21);
        v596 = v116 ^ __ROR4__(v595, 21);
        v564 = v20 ^ __ROR4__(v563, 21);
        v532 = v52 ^ __ROR4__(v531, 21);
        v501 = v1020 + v500;
        v469 = v987 + v468;
        v437 = v954 + v436;
        v405 = v921 + v404;
        v373 = v888 + v372;
        v341 = v855 + v340;
        v309 = v822 + v308;
        v277 = v789 + v276;
        v245 = v756 + v244;
        v213 = v724 + v212;
        v181 = v692 + v180;
        v149 = v660 + v148;
        v117 = v628 + v116;
        v85 = v596 + v84;
        v53 = v564 + v52;
        v21 = v532 + v20;
        v757 = v501 ^ __ROR4__(v756, 25);
        v725 = v469 ^ __ROR4__(v724, 25);
        v693 = v437 ^ __ROR4__(v692, 25);
        v661 = v405 ^ __ROR4__(v660, 25);
        v629 = v373 ^ __ROR4__(v628, 25);
        v597 = v341 ^ __ROR4__(v596, 25);
        v565 = v309 ^ __ROR4__(v564, 25);
        v533 = v277 ^ __ROR4__(v532, 25);
        v1021 = v245 ^ __ROR4__(v1020, 25);
        v988 = v213 ^ __ROR4__(v987, 25);
        v955 = v181 ^ __ROR4__(v954, 25);
        v922 = v149 ^ __ROR4__(v921, 25);
        v889 = v117 ^ __ROR4__(v888, 25);
        v856 = v85 ^ __ROR4__(v855, 25);
        v823 = v53 ^ __ROR4__(v822, 25);
        v790 = v21 ^ __ROR4__(v789, 25);
        v438 = v757 + v437;
        v406 = v725 + v405;
        v502 = v693 + v501;
        v470 = v661 + v469;
        v310 = v629 + v309;
        v278 = v597 + v277;
        v374 = v565 + v373;
        v342 = v533 + v341;
        v182 = v1021 + v181;
        v150 = v988 + v149;
        v246 = v955 + v245;
        v214 = v922 + v213;
        v54 = v889 + v53;
        v22 = v856 + v21;
        v118 = v823 + v117;
        v86 = v790 + v85;
        v630 = v438 ^ __ROR4__(v629, 21);
        v598 = v406 ^ __ROR4__(v597, 21);
        v566 = v502 ^ __ROR4__(v565, 21);
        v534 = v470 ^ __ROR4__(v533, 21);
        v758 = v310 ^ __ROR4__(v757, 21);
        v726 = v278 ^ __ROR4__(v725, 21);
        v694 = v374 ^ __ROR4__(v693, 21);
        v662 = v342 ^ __ROR4__(v661, 21);
        v890 = v182 ^ __ROR4__(v889, 21);
        v857 = v150 ^ __ROR4__(v856, 21);
        v824 = v246 ^ __ROR4__(v823, 21);
        v791 = v214 ^ __ROR4__(v790, 21);
        v1022 = v54 ^ __ROR4__(v1021, 21);
        v989 = v22 ^ __ROR4__(v988, 21);
        v956 = v118 ^ __ROR4__(v955, 21);
        v923 = v86 ^ __ROR4__(v922, 21);
        v407 = v630 + v406;
        v439 = v598 + v438;
        v471 = v566 + v470;
        v503 = v534 + v502;
        v279 = v758 + v278;
        v311 = v726 + v310;
        v343 = v694 + v342;
        v375 = v662 + v374;
        v151 = v890 + v150;
        v183 = v857 + v182;
        v215 = v824 + v214;
        v247 = v791 + v246;
        v23 = v1022 + v22;
        v55 = v989 + v54;
        v87 = v956 + v86;
        v119 = v923 + v118;
        v891 = v407 ^ __ROR4__(v890, 25);
        v858 = v439 ^ __ROR4__(v857, 25);
        v825 = v471 ^ __ROR4__(v824, 25);
        v792 = v503 ^ __ROR4__(v791, 25);
        v1023 = v279 ^ __ROR4__(v1022, 25);
        v990 = v311 ^ __ROR4__(v989, 25);
        v957 = v343 ^ __ROR4__(v956, 25);
        v924 = v375 ^ __ROR4__(v923, 25);
        v631 = v151 ^ __ROR4__(v630, 25);
        v599 = v183 ^ __ROR4__(v598, 25);
        v567 = v215 ^ __ROR4__(v566, 25);
        v535 = v247 ^ __ROR4__(v534, 25);
        v759 = v23 ^ __ROR4__(v758, 25);
        v727 = v55 ^ __ROR4__(v726, 25);
        v695 = v87 ^ __ROR4__(v694, 25);
        v663 = v119 ^ __ROR4__(v662, 25);
        v472 = v891 + v471;
        v504 = v858 + v503;
        v408 = v825 + v407;
        v440 = v792 + v439;
        v344 = v1023 + v343;
        v376 = v990 + v375;
        v280 = v957 + v279;
        v312 = v924 + v311;
        v216 = v631 + v215;
        v248 = v599 + v247;
        v152 = v567 + v151;
        v184 = v535 + v183;
        v88 = v759 + v87;
        v120 = v727 + v119;
        v24 = v695 + v23;
        v56 = v663 + v55;
        v1024 = v472 ^ __ROR4__(v1023, 21);
        v991 = v504 ^ __ROR4__(v990, 21);
        v958 = v408 ^ __ROR4__(v957, 21);
        v925 = v440 ^ __ROR4__(v924, 21);
        v892 = v344 ^ __ROR4__(v891, 21);
        v859 = v376 ^ __ROR4__(v858, 21);
        v826 = v280 ^ __ROR4__(v825, 21);
        v793 = v312 ^ __ROR4__(v792, 21);
        v760 = v216 ^ __ROR4__(v759, 21);
        v728 = v248 ^ __ROR4__(v727, 21);
        v696 = v152 ^ __ROR4__(v695, 21);
        v664 = v184 ^ __ROR4__(v663, 21);
        v632 = v88 ^ __ROR4__(v631, 21);
        v600 = v120 ^ __ROR4__(v599, 21);
        v568 = v24 ^ __ROR4__(v567, 21);
        v536 = v56 ^ __ROR4__(v535, 21);
        v505 = v1024 + v504;
        v473 = v991 + v472;
        v441 = v958 + v440;
        v409 = v925 + v408;
        v377 = v892 + v376;
        v345 = v859 + v344;
        v313 = v826 + v312;
        v281 = v793 + v280;
        v249 = v760 + v248;
        v217 = v728 + v216;
        v185 = v696 + v184;
        v153 = v664 + v152;
        v121 = v632 + v120;
        v89 = v600 + v88;
        v57 = v568 + v56;
        v25 = v536 + v24;
        v761 = v505 ^ __ROR4__(v760, 25);
        v729 = v473 ^ __ROR4__(v728, 25);
        v697 = v441 ^ __ROR4__(v696, 25);
        v665 = v409 ^ __ROR4__(v664, 25);
        v633 = v377 ^ __ROR4__(v632, 25);
        v601 = v345 ^ __ROR4__(v600, 25);
        v569 = v313 ^ __ROR4__(v568, 25);
        v537 = v281 ^ __ROR4__(v536, 25);
        v1025 = v249 ^ __ROR4__(v1024, 25);
        v992 = v217 ^ __ROR4__(v991, 25);
        v959 = v185 ^ __ROR4__(v958, 25);
        v926 = v153 ^ __ROR4__(v925, 25);
        v893 = v121 ^ __ROR4__(v892, 25);
        v860 = v89 ^ __ROR4__(v859, 25);
        v827 = v57 ^ __ROR4__(v826, 25);
        v794 = v25 ^ __ROR4__(v793, 25);
        v442 = v761 + v441;
        v410 = v729 + v409;
        v506 = v697 + v505;
        v474 = v665 + v473;
        v314 = v633 + v313;
        v282 = v601 + v281;
        v378 = v569 + v377;
        v346 = v537 + v345;
        v186 = v1025 + v185;
        v154 = v992 + v153;
        v250 = v959 + v249;
        v218 = v926 + v217;
        v58 = v893 + v57;
        v26 = v860 + v25;
        v122 = v827 + v121;
        v90 = v794 + v89;
        v634 = v442 ^ __ROR4__(v633, 21);
        v602 = v410 ^ __ROR4__(v601, 21);
        v570 = v506 ^ __ROR4__(v569, 21);
        v538 = v474 ^ __ROR4__(v537, 21);
        v762 = v314 ^ __ROR4__(v761, 21);
        v730 = v282 ^ __ROR4__(v729, 21);
        v698 = v378 ^ __ROR4__(v697, 21);
        v666 = v346 ^ __ROR4__(v665, 21);
        v894 = v186 ^ __ROR4__(v893, 21);
        v861 = v154 ^ __ROR4__(v860, 21);
        v828 = v250 ^ __ROR4__(v827, 21);
        v795 = v218 ^ __ROR4__(v794, 21);
        v1026 = v58 ^ __ROR4__(v1025, 21);
        v993 = v26 ^ __ROR4__(v992, 21);
        v960 = v122 ^ __ROR4__(v959, 21);
        v927 = v90 ^ __ROR4__(v926, 21);
        v411 = v634 + v410;
        v443 = v602 + v442;
        v475 = v570 + v474;
        v507 = v538 + v506;
        v283 = v762 + v282;
        v315 = v730 + v314;
        v347 = v698 + v346;
        v379 = v666 + v378;
        v155 = v894 + v154;
        v187 = v861 + v186;
        v219 = v828 + v218;
        v251 = v795 + v250;
        v27 = v1026 + v26;
        v59 = v993 + v58;
        v91 = v960 + v90;
        v123 = v927 + v122;
        v895 = v411 ^ __ROR4__(v894, 25);
        v862 = v443 ^ __ROR4__(v861, 25);
        v829 = v475 ^ __ROR4__(v828, 25);
        v796 = v507 ^ __ROR4__(v795, 25);
        v1027 = v283 ^ __ROR4__(v1026, 25);
        v994 = v315 ^ __ROR4__(v993, 25);
        v961 = v347 ^ __ROR4__(v960, 25);
        v928 = v379 ^ __ROR4__(v927, 25);
        v635 = v155 ^ __ROR4__(v634, 25);
        v603 = v187 ^ __ROR4__(v602, 25);
        v571 = v219 ^ __ROR4__(v570, 25);
        v539 = v251 ^ __ROR4__(v538, 25);
        v763 = v27 ^ __ROR4__(v762, 25);
        v731 = v59 ^ __ROR4__(v730, 25);
        v699 = v91 ^ __ROR4__(v698, 25);
        v667 = v123 ^ __ROR4__(v666, 25);
        v476 = v895 + v475;
        v508 = v862 + v507;
        v412 = v829 + v411;
        v444 = v796 + v443;
        v348 = v1027 + v347;
        v380 = v994 + v379;
        v284 = v961 + v283;
        v316 = v928 + v315;
        v220 = v635 + v219;
        v252 = v603 + v251;
        v156 = v571 + v155;
        v188 = v539 + v187;
        v92 = v763 + v91;
        v124 = v731 + v123;
        v28 = v699 + v27;
        v60 = v667 + v59;
        v1028 = v476 ^ __ROR4__(v1027, 21);
        v995 = v508 ^ __ROR4__(v994, 21);
        v962 = v412 ^ __ROR4__(v961, 21);
        v929 = v444 ^ __ROR4__(v928, 21);
        v896 = v348 ^ __ROR4__(v895, 21);
        v863 = v380 ^ __ROR4__(v862, 21);
        v830 = v284 ^ __ROR4__(v829, 21);
        v797 = v316 ^ __ROR4__(v796, 21);
        v764 = v220 ^ __ROR4__(v763, 21);
        v732 = v252 ^ __ROR4__(v731, 21);
        v700 = v156 ^ __ROR4__(v699, 21);
        v668 = v188 ^ __ROR4__(v667, 21);
        v636 = v92 ^ __ROR4__(v635, 21);
        v604 = v124 ^ __ROR4__(v603, 21);
        v572 = v28 ^ __ROR4__(v571, 21);
        v540 = v60 ^ __ROR4__(v539, 21);
        v509 = v1028 + v508;
        v477 = v995 + v476;
        v445 = v962 + v444;
        v413 = v929 + v412;
        v381 = v896 + v380;
        v349 = v863 + v348;
        v317 = v830 + v316;
        v285 = v797 + v284;
        v253 = v764 + v252;
        v221 = v732 + v220;
        v189 = v700 + v188;
        v157 = v668 + v156;
        v125 = v636 + v124;
        v93 = v604 + v92;
        v61 = v572 + v60;
        v29 = v540 + v28;
        v765 = v509 ^ __ROR4__(v764, 25);
        v733 = v477 ^ __ROR4__(v732, 25);
        v701 = v445 ^ __ROR4__(v700, 25);
        v669 = v413 ^ __ROR4__(v668, 25);
        v637 = v381 ^ __ROR4__(v636, 25);
        v605 = v349 ^ __ROR4__(v604, 25);
        v573 = v317 ^ __ROR4__(v572, 25);
        v541 = v285 ^ __ROR4__(v540, 25);
        v1029 = v253 ^ __ROR4__(v1028, 25);
        v996 = v221 ^ __ROR4__(v995, 25);
        v963 = v189 ^ __ROR4__(v962, 25);
        v930 = v157 ^ __ROR4__(v929, 25);
        v897 = v125 ^ __ROR4__(v896, 25);
        v864 = v93 ^ __ROR4__(v863, 25);
        v831 = v61 ^ __ROR4__(v830, 25);
        v798 = v29 ^ __ROR4__(v797, 25);
        v446 = v765 + v445;
        v414 = v733 + v413;
        v510 = v701 + v509;
        v478 = v669 + v477;
        v318 = v637 + v317;
        v286 = v605 + v285;
        v382 = v573 + v381;
        v350 = v541 + v349;
        v190 = v1029 + v189;
        v158 = v996 + v157;
        v254 = v963 + v253;
        v222 = v930 + v221;
        v62 = v897 + v61;
        v30 = v864 + v29;
        v126 = v831 + v125;
        v94 = v798 + v93;
        v638 = v446 ^ __ROR4__(v637, 21);
        v606 = v414 ^ __ROR4__(v605, 21);
        v574 = v510 ^ __ROR4__(v573, 21);
        v542 = v478 ^ __ROR4__(v541, 21);
        v766 = v318 ^ __ROR4__(v765, 21);
        v734 = v286 ^ __ROR4__(v733, 21);
        v702 = v382 ^ __ROR4__(v701, 21);
        v670 = v350 ^ __ROR4__(v669, 21);
        v898 = v190 ^ __ROR4__(v897, 21);
        v865 = v158 ^ __ROR4__(v864, 21);
        v832 = v254 ^ __ROR4__(v831, 21);
        v799 = v222 ^ __ROR4__(v798, 21);
        v1030 = v62 ^ __ROR4__(v1029, 21);
        v997 = v30 ^ __ROR4__(v996, 21);
        v964 = v126 ^ __ROR4__(v963, 21);
        v931 = v94 ^ __ROR4__(v930, 21);
        v415 = v638 + v414;
        v447 = v606 + v446;
        v479 = v574 + v478;
        v511 = v542 + v510;
        v287 = v766 + v286;
        v319 = v734 + v318;
        v351 = v702 + v350;
        v383 = v670 + v382;
        v159 = v898 + v158;
        v191 = v865 + v190;
        v223 = v832 + v222;
        v255 = v799 + v254;
        v31 = v1030 + v30;
        v63 = v997 + v62;
        v95 = v964 + v94;
        v127 = v931 + v126;
        v899 = v415 ^ __ROR4__(v898, 25);
        v866 = v447 ^ __ROR4__(v865, 25);
        v833 = v479 ^ __ROR4__(v832, 25);
        v800 = v511 ^ __ROR4__(v799, 25);
        v1031 = v287 ^ __ROR4__(v1030, 25);
        v998 = v319 ^ __ROR4__(v997, 25);
        v965 = v351 ^ __ROR4__(v964, 25);
        v932 = v383 ^ __ROR4__(v931, 25);
        v639 = v159 ^ __ROR4__(v638, 25);
        v607 = v191 ^ __ROR4__(v606, 25);
        v575 = v223 ^ __ROR4__(v574, 25);
        v543 = v255 ^ __ROR4__(v542, 25);
        v767 = v31 ^ __ROR4__(v766, 25);
        v735 = v63 ^ __ROR4__(v734, 25);
        v703 = v95 ^ __ROR4__(v702, 25);
        v671 = v127 ^ __ROR4__(v670, 25);
        v480 = v899 + v479;
        v512 = v866 + v511;
        v416 = v833 + v415;
        v448 = v800 + v447;
        v352 = v1031 + v351;
        v384 = v998 + v383;
        v288 = v965 + v287;
        v320 = v932 + v319;
        v224 = v639 + v223;
        v256 = v607 + v255;
        v160 = v575 + v159;
        v192 = v543 + v191;
        v96 = v767 + v95;
        v128 = v735 + v127;
        v32 = v703 + v31;
        v64 = v671 + v63;
        v1032 = v480 ^ __ROR4__(v1031, 21);
        v999 = v512 ^ __ROR4__(v998, 21);
        v966 = v416 ^ __ROR4__(v965, 21);
        v933 = v448 ^ __ROR4__(v932, 21);
        v900 = v352 ^ __ROR4__(v899, 21);
        v867 = v384 ^ __ROR4__(v866, 21);
        v834 = v288 ^ __ROR4__(v833, 21);
        v801 = v320 ^ __ROR4__(v800, 21);
        v768 = v224 ^ __ROR4__(v767, 21);
        v736 = v256 ^ __ROR4__(v735, 21);
        v704 = v160 ^ __ROR4__(v703, 21);
        v672 = v192 ^ __ROR4__(v671, 21);
        v640 = v96 ^ __ROR4__(v639, 21);
        v608 = v128 ^ __ROR4__(v607, 21);
        v576 = v32 ^ __ROR4__(v575, 21);
        v544 = v64 ^ __ROR4__(v543, 21);
        v513 = v1032 + v512;
        v481 = v999 + v480;
        v449 = v966 + v448;
        v417 = v933 + v416;
        v385 = v900 + v384;
        v353 = v867 + v352;
        v321 = v834 + v320;
        v289 = v801 + v288;
        v257 = v768 + v256;
        v225 = v736 + v224;
        v193 = v704 + v192;
        v161 = v672 + v160;
        v129 = v640 + v128;
        v97 = v608 + v96;
        v65 = v576 + v64;
        v33 = v544 + v32;
        v769 = v513 ^ __ROR4__(v768, 25);
        v737 = v481 ^ __ROR4__(v736, 25);
        v705 = v449 ^ __ROR4__(v704, 25);
        v673 = v417 ^ __ROR4__(v672, 25);
        v641 = v385 ^ __ROR4__(v640, 25);
        v609 = v353 ^ __ROR4__(v608, 25);
        v577 = v321 ^ __ROR4__(v576, 25);
        v545 = v289 ^ __ROR4__(v544, 25);
        v1033 = v257 ^ __ROR4__(v1032, 25);
        v1000 = v225 ^ __ROR4__(v999, 25);
        v967 = v193 ^ __ROR4__(v966, 25);
        v934 = v161 ^ __ROR4__(v933, 25);
        v901 = v129 ^ __ROR4__(v900, 25);
        v868 = v97 ^ __ROR4__(v867, 25);
        v835 = v65 ^ __ROR4__(v834, 25);
        v802 = v33 ^ __ROR4__(v801, 25);
        v450 = v769 + v449;
        v418 = v737 + v417;
        v514 = v705 + v513;
        v482 = v673 + v481;
        v322 = v641 + v321;
        v290 = v609 + v289;
        v386 = v577 + v385;
        v354 = v545 + v353;
        v194 = v1033 + v193;
        v162 = v1000 + v161;
        v258 = v967 + v257;
        v226 = v934 + v225;
        v66 = v901 + v65;
        v34 = v868 + v33;
        v130 = v835 + v129;
        v98 = v802 + v97;
        v642 = v450 ^ __ROR4__(v641, 21);
        v610 = v418 ^ __ROR4__(v609, 21);
        v578 = v514 ^ __ROR4__(v577, 21);
        v546 = v482 ^ __ROR4__(v545, 21);
        v770 = v322 ^ __ROR4__(v769, 21);
        v738 = v290 ^ __ROR4__(v737, 21);
        v706 = v386 ^ __ROR4__(v705, 21);
        v674 = v354 ^ __ROR4__(v673, 21);
        v902 = v194 ^ __ROR4__(v901, 21);
        v869 = v162 ^ __ROR4__(v868, 21);
        v836 = v258 ^ __ROR4__(v835, 21);
        v803 = v226 ^ __ROR4__(v802, 21);
        v1034 = v66 ^ __ROR4__(v1033, 21);
        v1001 = v34 ^ __ROR4__(v1000, 21);
        v968 = v130 ^ __ROR4__(v967, 21);
        v935 = v98 ^ __ROR4__(v934, 21);
        v419 = v642 + v418;
        v451 = v610 + v450;
        v483 = v578 + v482;
        v515 = v546 + v514;
        v291 = v770 + v290;
        v323 = v738 + v322;
        v355 = v706 + v354;
        v387 = v674 + v386;
        v163 = v902 + v162;
        v195 = v869 + v194;
        v227 = v836 + v226;
        v259 = v803 + v258;
        v35 = v1034 + v34;
        v67 = v1001 + v66;
        v99 = v968 + v98;
        v131 = v935 + v130;
        v903 = v419 ^ __ROR4__(v902, 25);
        v870 = v451 ^ __ROR4__(v869, 25);
        v837 = v483 ^ __ROR4__(v836, 25);
        v804 = v515 ^ __ROR4__(v803, 25);
        v1035 = v291 ^ __ROR4__(v1034, 25);
        v1002 = v323 ^ __ROR4__(v1001, 25);
        v969 = v355 ^ __ROR4__(v968, 25);
        v936 = v387 ^ __ROR4__(v935, 25);
        v643 = v163 ^ __ROR4__(v642, 25);
        v611 = v195 ^ __ROR4__(v610, 25);
        v579 = v227 ^ __ROR4__(v578, 25);
        v547 = v259 ^ __ROR4__(v546, 25);
        v771 = v35 ^ __ROR4__(v770, 25);
        v739 = v67 ^ __ROR4__(v738, 25);
        v707 = v99 ^ __ROR4__(v706, 25);
        v675 = v131 ^ __ROR4__(v674, 25);
        v484 = v903 + v483;
        v516 = v870 + v515;
        v420 = v837 + v419;
        v452 = v804 + v451;
        v356 = v1035 + v355;
        v388 = v1002 + v387;
        v292 = v969 + v291;
        v324 = v936 + v323;
        v228 = v643 + v227;
        v260 = v611 + v259;
        v164 = v579 + v163;
        v196 = v547 + v195;
        v100 = v771 + v99;
        v132 = v739 + v131;
        v36 = v707 + v35;
        v68 = v675 + v67;
        v1036 = v484 ^ __ROR4__(v1035, 21);
        v1003 = v516 ^ __ROR4__(v1002, 21);
        v970 = v420 ^ __ROR4__(v969, 21);
        v937 = v452 ^ __ROR4__(v936, 21);
        v904 = v356 ^ __ROR4__(v903, 21);
        v871 = v388 ^ __ROR4__(v870, 21);
        v838 = v292 ^ __ROR4__(v837, 21);
        v805 = v324 ^ __ROR4__(v804, 21);
        v772 = v228 ^ __ROR4__(v771, 21);
        v740 = v260 ^ __ROR4__(v739, 21);
        v708 = v164 ^ __ROR4__(v707, 21);
        v676 = v196 ^ __ROR4__(v675, 21);
        v644 = v100 ^ __ROR4__(v643, 21);
        v612 = v132 ^ __ROR4__(v611, 21);
        v580 = v36 ^ __ROR4__(v579, 21);
        v548 = v68 ^ __ROR4__(v547, 21);
        v517 = v1036 + v516;
        v485 = v1003 + v484;
        v453 = v970 + v452;
        v421 = v937 + v420;
        v389 = v904 + v388;
        v357 = v871 + v356;
        v325 = v838 + v324;
        v293 = v805 + v292;
        v261 = v772 + v260;
        v229 = v740 + v228;
        v197 = v708 + v196;
        v165 = v676 + v164;
        v133 = v644 + v132;
        v101 = v612 + v100;
        v69 = v580 + v68;
        v37 = v548 + v36;
        v773 = v517 ^ __ROR4__(v772, 25);
        v741 = v485 ^ __ROR4__(v740, 25);
        v709 = v453 ^ __ROR4__(v708, 25);
        v677 = v421 ^ __ROR4__(v676, 25);
        v645 = v389 ^ __ROR4__(v644, 25);
        v613 = v357 ^ __ROR4__(v612, 25);
        v581 = v325 ^ __ROR4__(v580, 25);
        v549 = v293 ^ __ROR4__(v548, 25);
        v1037 = v261 ^ __ROR4__(v1036, 25);
        v1004 = v229 ^ __ROR4__(v1003, 25);
        v971 = v197 ^ __ROR4__(v970, 25);
        v938 = v165 ^ __ROR4__(v937, 25);
        v905 = v133 ^ __ROR4__(v904, 25);
        v872 = v101 ^ __ROR4__(v871, 25);
        v839 = v69 ^ __ROR4__(v838, 25);
        v806 = v37 ^ __ROR4__(v805, 25);
        v454 = v773 + v453;
        v422 = v741 + v421;
        v518 = v709 + v517;
        v486 = v677 + v485;
        v326 = v645 + v325;
        v294 = v613 + v293;
        v390 = v581 + v389;
        v358 = v549 + v357;
        v198 = v1037 + v197;
        v166 = v1004 + v165;
        v262 = v971 + v261;
        v230 = v938 + v229;
        v70 = v905 + v69;
        v38 = v872 + v37;
        v134 = v839 + v133;
        v102 = v806 + v101;
        v646 = v454 ^ __ROR4__(v645, 21);
        v614 = v422 ^ __ROR4__(v613, 21);
        v582 = v518 ^ __ROR4__(v581, 21);
        v550 = v486 ^ __ROR4__(v549, 21);
        v774 = v326 ^ __ROR4__(v773, 21);
        v742 = v294 ^ __ROR4__(v741, 21);
        v710 = v390 ^ __ROR4__(v709, 21);
        v678 = v358 ^ __ROR4__(v677, 21);
        v906 = v198 ^ __ROR4__(v905, 21);
        v873 = v166 ^ __ROR4__(v872, 21);
        v840 = v262 ^ __ROR4__(v839, 21);
        v807 = v230 ^ __ROR4__(v806, 21);
        v1038 = v70 ^ __ROR4__(v1037, 21);
        v1005 = v38 ^ __ROR4__(v1004, 21);
        v972 = v134 ^ __ROR4__(v971, 21);
        v939 = v102 ^ __ROR4__(v938, 21);
        v423 = v646 + v422;
        v455 = v614 + v454;
        v487 = v582 + v486;
        v519 = v550 + v518;
        v295 = v774 + v294;
        v327 = v742 + v326;
        v359 = v710 + v358;
        v391 = v678 + v390;
        v167 = v906 + v166;
        v199 = v873 + v198;
        v231 = v840 + v230;
        v263 = v807 + v262;
        v39 = v1038 + v38;
        v71 = v1005 + v70;
        v103 = v972 + v102;
        v135 = v939 + v134;
        v907 = v423 ^ __ROR4__(v906, 25);
        v874 = v455 ^ __ROR4__(v873, 25);
        v841 = v487 ^ __ROR4__(v840, 25);
        v808 = v519 ^ __ROR4__(v807, 25);
        v1039 = v295 ^ __ROR4__(v1038, 25);
        v1006 = v327 ^ __ROR4__(v1005, 25);
        v973 = v359 ^ __ROR4__(v972, 25);
        v940 = v391 ^ __ROR4__(v939, 25);
        v647 = v167 ^ __ROR4__(v646, 25);
        v615 = v199 ^ __ROR4__(v614, 25);
        v583 = v231 ^ __ROR4__(v582, 25);
        v551 = v263 ^ __ROR4__(v550, 25);
        v775 = v39 ^ __ROR4__(v774, 25);
        v743 = v71 ^ __ROR4__(v742, 25);
        v711 = v103 ^ __ROR4__(v710, 25);
        v679 = v135 ^ __ROR4__(v678, 25);
        v456 = v907 + v487;
        v488 = v874 + v519;
        v392 = v841 + v423;
        v424 = v808 + v455;
        v328 = v1039 + v359;
        v360 = v1006 + v391;
        v264 = v973 + v295;
        v296 = v940 + v327;
        v200 = v647 + v231;
        v232 = v615 + v263;
        v136 = v583 + v167;
        v168 = v551 + v199;
        v72 = v775 + v103;
        v104 = v743 + v135;
        v8 = v711 + v39;
        v40 = v679 + v71;
        v1007 = v456 ^ __ROR4__(v1039, 21);
        v974 = v488 ^ __ROR4__(v1006, 21);
        v941 = v392 ^ __ROR4__(v973, 21);
        v908 = v424 ^ __ROR4__(v940, 21);
        v875 = v328 ^ __ROR4__(v907, 21);
        v842 = v360 ^ __ROR4__(v874, 21);
        v809 = v264 ^ __ROR4__(v841, 21);
        v776 = v296 ^ __ROR4__(v808, 21);
        v744 = v200 ^ __ROR4__(v775, 21);
        v712 = v232 ^ __ROR4__(v743, 21);
        v680 = v136 ^ __ROR4__(v711, 21);
        v648 = v168 ^ __ROR4__(v679, 21);
        v616 = v72 ^ __ROR4__(v647, 21);
        v584 = v104 ^ __ROR4__(v615, 21);
        v552 = v8 ^ __ROR4__(v583, 21);
        v520 = v40 ^ __ROR4__(v551, 21);
        v1040 = 0;
      }
    }
    v5[9] = v1007;
    v5[10] = v974;
    v5[11] = v941;
    v5[12] = v908;
    v5[13] = v875;
    v5[14] = v842;
    v5[15] = v809;
    v5[16] = v776;
    v5[17] = v744;
    v5[18] = v712;
    v5[19] = v680;
    v5[20] = v648;
    v5[21] = v616;
    v5[22] = v584;
    v5[23] = v552;
    v5[24] = v520;
    v5[25] = v488;
    v5[26] = v456;
    v5[27] = v424;
    v5[28] = v392;
    v5[29] = v360;
    v5[30] = v328;
    v5[31] = v296;
    v5[32] = v264;
    v5[33] = v232;
    v5[34] = v200;
    v5[35] = v168;
    v5[36] = v136;
    v5[37] = v104;
    v5[38] = v72;
    v5[39] = v40;
    v5[40] = v8;
    v5[8] = v1040;
  }
  else
  {
    result = (int)memcpy((void *)(v1040 + result), a2, a3);
    v5[8] = n + v1040;
  }
  return result;
}

//----- (0019F464) --------------------------------------------------------
int __fastcall sub_19F464(_DWORD *a1, char a2, char a3, int a4, unsigned int a5)
{
  int v5; // r3
  int result; // r0
  int v10; // [sp+20h] [bp+20h]
  int v11; // [sp+20h] [bp+20h]
  int v12; // [sp+20h] [bp+20h]
  int v13; // [sp+20h] [bp+20h]
  int v14; // [sp+20h] [bp+20h]
  int v15; // [sp+20h] [bp+20h]
  int v16; // [sp+20h] [bp+20h]
  int v17; // [sp+20h] [bp+20h]
  int v18; // [sp+20h] [bp+20h]
  int v19; // [sp+20h] [bp+20h]
  int v20; // [sp+20h] [bp+20h]
  int v21; // [sp+20h] [bp+20h]
  int v22; // [sp+20h] [bp+20h]
  int v23; // [sp+20h] [bp+20h]
  int v24; // [sp+20h] [bp+20h]
  int v25; // [sp+20h] [bp+20h]
  int v26; // [sp+20h] [bp+20h]
  int v27; // [sp+20h] [bp+20h]
  int v28; // [sp+20h] [bp+20h]
  int v29; // [sp+20h] [bp+20h]
  int v30; // [sp+20h] [bp+20h]
  int v31; // [sp+20h] [bp+20h]
  int v32; // [sp+20h] [bp+20h]
  int v33; // [sp+20h] [bp+20h]
  int v34; // [sp+20h] [bp+20h]
  int v35; // [sp+20h] [bp+20h]
  int v36; // [sp+20h] [bp+20h]
  int v37; // [sp+20h] [bp+20h]
  int v38; // [sp+20h] [bp+20h]
  int v39; // [sp+20h] [bp+20h]
  int v40; // [sp+20h] [bp+20h]
  int v41; // [sp+20h] [bp+20h]
  int v42; // [sp+24h] [bp+24h]
  int v43; // [sp+24h] [bp+24h]
  int v44; // [sp+24h] [bp+24h]
  int v45; // [sp+24h] [bp+24h]
  int v46; // [sp+24h] [bp+24h]
  int v47; // [sp+24h] [bp+24h]
  int v48; // [sp+24h] [bp+24h]
  int v49; // [sp+24h] [bp+24h]
  int v50; // [sp+24h] [bp+24h]
  int v51; // [sp+24h] [bp+24h]
  int v52; // [sp+24h] [bp+24h]
  int v53; // [sp+24h] [bp+24h]
  int v54; // [sp+24h] [bp+24h]
  int v55; // [sp+24h] [bp+24h]
  int v56; // [sp+24h] [bp+24h]
  int v57; // [sp+24h] [bp+24h]
  int v58; // [sp+24h] [bp+24h]
  int v59; // [sp+24h] [bp+24h]
  int v60; // [sp+24h] [bp+24h]
  int v61; // [sp+24h] [bp+24h]
  int v62; // [sp+24h] [bp+24h]
  int v63; // [sp+24h] [bp+24h]
  int v64; // [sp+24h] [bp+24h]
  int v65; // [sp+24h] [bp+24h]
  int v66; // [sp+24h] [bp+24h]
  int v67; // [sp+24h] [bp+24h]
  int v68; // [sp+24h] [bp+24h]
  int v69; // [sp+24h] [bp+24h]
  int v70; // [sp+24h] [bp+24h]
  int v71; // [sp+24h] [bp+24h]
  int v72; // [sp+24h] [bp+24h]
  int v73; // [sp+24h] [bp+24h]
  int v74; // [sp+28h] [bp+28h]
  int v75; // [sp+28h] [bp+28h]
  int v76; // [sp+28h] [bp+28h]
  int v77; // [sp+28h] [bp+28h]
  int v78; // [sp+28h] [bp+28h]
  int v79; // [sp+28h] [bp+28h]
  int v80; // [sp+28h] [bp+28h]
  int v81; // [sp+28h] [bp+28h]
  int v82; // [sp+28h] [bp+28h]
  int v83; // [sp+28h] [bp+28h]
  int v84; // [sp+28h] [bp+28h]
  int v85; // [sp+28h] [bp+28h]
  int v86; // [sp+28h] [bp+28h]
  int v87; // [sp+28h] [bp+28h]
  int v88; // [sp+28h] [bp+28h]
  int v89; // [sp+28h] [bp+28h]
  int v90; // [sp+28h] [bp+28h]
  int v91; // [sp+28h] [bp+28h]
  int v92; // [sp+28h] [bp+28h]
  int v93; // [sp+28h] [bp+28h]
  int v94; // [sp+28h] [bp+28h]
  int v95; // [sp+28h] [bp+28h]
  int v96; // [sp+28h] [bp+28h]
  int v97; // [sp+28h] [bp+28h]
  int v98; // [sp+28h] [bp+28h]
  int v99; // [sp+28h] [bp+28h]
  int v100; // [sp+28h] [bp+28h]
  int v101; // [sp+28h] [bp+28h]
  int v102; // [sp+28h] [bp+28h]
  int v103; // [sp+28h] [bp+28h]
  int v104; // [sp+28h] [bp+28h]
  int v105; // [sp+28h] [bp+28h]
  int v106; // [sp+2Ch] [bp+2Ch]
  int v107; // [sp+2Ch] [bp+2Ch]
  int v108; // [sp+2Ch] [bp+2Ch]
  int v109; // [sp+2Ch] [bp+2Ch]
  int v110; // [sp+2Ch] [bp+2Ch]
  int v111; // [sp+2Ch] [bp+2Ch]
  int v112; // [sp+2Ch] [bp+2Ch]
  int v113; // [sp+2Ch] [bp+2Ch]
  int v114; // [sp+2Ch] [bp+2Ch]
  int v115; // [sp+2Ch] [bp+2Ch]
  int v116; // [sp+2Ch] [bp+2Ch]
  int v117; // [sp+2Ch] [bp+2Ch]
  int v118; // [sp+2Ch] [bp+2Ch]
  int v119; // [sp+2Ch] [bp+2Ch]
  int v120; // [sp+2Ch] [bp+2Ch]
  int v121; // [sp+2Ch] [bp+2Ch]
  int v122; // [sp+2Ch] [bp+2Ch]
  int v123; // [sp+2Ch] [bp+2Ch]
  int v124; // [sp+2Ch] [bp+2Ch]
  int v125; // [sp+2Ch] [bp+2Ch]
  int v126; // [sp+2Ch] [bp+2Ch]
  int v127; // [sp+2Ch] [bp+2Ch]
  int v128; // [sp+2Ch] [bp+2Ch]
  int v129; // [sp+2Ch] [bp+2Ch]
  int v130; // [sp+2Ch] [bp+2Ch]
  int v131; // [sp+2Ch] [bp+2Ch]
  int v132; // [sp+2Ch] [bp+2Ch]
  int v133; // [sp+2Ch] [bp+2Ch]
  int v134; // [sp+2Ch] [bp+2Ch]
  int v135; // [sp+2Ch] [bp+2Ch]
  int v136; // [sp+2Ch] [bp+2Ch]
  int v137; // [sp+2Ch] [bp+2Ch]
  int v138; // [sp+30h] [bp+30h]
  int v139; // [sp+30h] [bp+30h]
  int v140; // [sp+30h] [bp+30h]
  int v141; // [sp+30h] [bp+30h]
  int v142; // [sp+30h] [bp+30h]
  int v143; // [sp+30h] [bp+30h]
  int v144; // [sp+30h] [bp+30h]
  int v145; // [sp+30h] [bp+30h]
  int v146; // [sp+30h] [bp+30h]
  int v147; // [sp+30h] [bp+30h]
  int v148; // [sp+30h] [bp+30h]
  int v149; // [sp+30h] [bp+30h]
  int v150; // [sp+30h] [bp+30h]
  int v151; // [sp+30h] [bp+30h]
  int v152; // [sp+30h] [bp+30h]
  int v153; // [sp+30h] [bp+30h]
  int v154; // [sp+30h] [bp+30h]
  int v155; // [sp+30h] [bp+30h]
  int v156; // [sp+30h] [bp+30h]
  int v157; // [sp+30h] [bp+30h]
  int v158; // [sp+30h] [bp+30h]
  int v159; // [sp+30h] [bp+30h]
  int v160; // [sp+30h] [bp+30h]
  int v161; // [sp+30h] [bp+30h]
  int v162; // [sp+30h] [bp+30h]
  int v163; // [sp+30h] [bp+30h]
  int v164; // [sp+30h] [bp+30h]
  int v165; // [sp+30h] [bp+30h]
  int v166; // [sp+30h] [bp+30h]
  int v167; // [sp+30h] [bp+30h]
  int v168; // [sp+30h] [bp+30h]
  int v169; // [sp+30h] [bp+30h]
  int v170; // [sp+34h] [bp+34h]
  int v171; // [sp+34h] [bp+34h]
  int v172; // [sp+34h] [bp+34h]
  int v173; // [sp+34h] [bp+34h]
  int v174; // [sp+34h] [bp+34h]
  int v175; // [sp+34h] [bp+34h]
  int v176; // [sp+34h] [bp+34h]
  int v177; // [sp+34h] [bp+34h]
  int v178; // [sp+34h] [bp+34h]
  int v179; // [sp+34h] [bp+34h]
  int v180; // [sp+34h] [bp+34h]
  int v181; // [sp+34h] [bp+34h]
  int v182; // [sp+34h] [bp+34h]
  int v183; // [sp+34h] [bp+34h]
  int v184; // [sp+34h] [bp+34h]
  int v185; // [sp+34h] [bp+34h]
  int v186; // [sp+34h] [bp+34h]
  int v187; // [sp+34h] [bp+34h]
  int v188; // [sp+34h] [bp+34h]
  int v189; // [sp+34h] [bp+34h]
  int v190; // [sp+34h] [bp+34h]
  int v191; // [sp+34h] [bp+34h]
  int v192; // [sp+34h] [bp+34h]
  int v193; // [sp+34h] [bp+34h]
  int v194; // [sp+34h] [bp+34h]
  int v195; // [sp+34h] [bp+34h]
  int v196; // [sp+34h] [bp+34h]
  int v197; // [sp+34h] [bp+34h]
  int v198; // [sp+34h] [bp+34h]
  int v199; // [sp+34h] [bp+34h]
  int v200; // [sp+34h] [bp+34h]
  int v201; // [sp+34h] [bp+34h]
  int v202; // [sp+38h] [bp+38h]
  int v203; // [sp+38h] [bp+38h]
  int v204; // [sp+38h] [bp+38h]
  int v205; // [sp+38h] [bp+38h]
  int v206; // [sp+38h] [bp+38h]
  int v207; // [sp+38h] [bp+38h]
  int v208; // [sp+38h] [bp+38h]
  int v209; // [sp+38h] [bp+38h]
  int v210; // [sp+38h] [bp+38h]
  int v211; // [sp+38h] [bp+38h]
  int v212; // [sp+38h] [bp+38h]
  int v213; // [sp+38h] [bp+38h]
  int v214; // [sp+38h] [bp+38h]
  int v215; // [sp+38h] [bp+38h]
  int v216; // [sp+38h] [bp+38h]
  int v217; // [sp+38h] [bp+38h]
  int v218; // [sp+38h] [bp+38h]
  int v219; // [sp+38h] [bp+38h]
  int v220; // [sp+38h] [bp+38h]
  int v221; // [sp+38h] [bp+38h]
  int v222; // [sp+38h] [bp+38h]
  int v223; // [sp+38h] [bp+38h]
  int v224; // [sp+38h] [bp+38h]
  int v225; // [sp+38h] [bp+38h]
  int v226; // [sp+38h] [bp+38h]
  int v227; // [sp+38h] [bp+38h]
  int v228; // [sp+38h] [bp+38h]
  int v229; // [sp+38h] [bp+38h]
  int v230; // [sp+38h] [bp+38h]
  int v231; // [sp+38h] [bp+38h]
  int v232; // [sp+38h] [bp+38h]
  int v233; // [sp+38h] [bp+38h]
  int v234; // [sp+3Ch] [bp+3Ch]
  int v235; // [sp+3Ch] [bp+3Ch]
  int v236; // [sp+3Ch] [bp+3Ch]
  int v237; // [sp+3Ch] [bp+3Ch]
  int v238; // [sp+3Ch] [bp+3Ch]
  int v239; // [sp+3Ch] [bp+3Ch]
  int v240; // [sp+3Ch] [bp+3Ch]
  int v241; // [sp+3Ch] [bp+3Ch]
  int v242; // [sp+3Ch] [bp+3Ch]
  int v243; // [sp+3Ch] [bp+3Ch]
  int v244; // [sp+3Ch] [bp+3Ch]
  int v245; // [sp+3Ch] [bp+3Ch]
  int v246; // [sp+3Ch] [bp+3Ch]
  int v247; // [sp+3Ch] [bp+3Ch]
  int v248; // [sp+3Ch] [bp+3Ch]
  int v249; // [sp+3Ch] [bp+3Ch]
  int v250; // [sp+3Ch] [bp+3Ch]
  int v251; // [sp+3Ch] [bp+3Ch]
  int v252; // [sp+3Ch] [bp+3Ch]
  int v253; // [sp+3Ch] [bp+3Ch]
  int v254; // [sp+3Ch] [bp+3Ch]
  int v255; // [sp+3Ch] [bp+3Ch]
  int v256; // [sp+3Ch] [bp+3Ch]
  int v257; // [sp+3Ch] [bp+3Ch]
  int v258; // [sp+3Ch] [bp+3Ch]
  int v259; // [sp+3Ch] [bp+3Ch]
  int v260; // [sp+3Ch] [bp+3Ch]
  int v261; // [sp+3Ch] [bp+3Ch]
  int v262; // [sp+3Ch] [bp+3Ch]
  int v263; // [sp+3Ch] [bp+3Ch]
  int v264; // [sp+3Ch] [bp+3Ch]
  int v265; // [sp+3Ch] [bp+3Ch]
  int v266; // [sp+40h] [bp+40h]
  int v267; // [sp+40h] [bp+40h]
  int v268; // [sp+40h] [bp+40h]
  int v269; // [sp+40h] [bp+40h]
  int v270; // [sp+40h] [bp+40h]
  int v271; // [sp+40h] [bp+40h]
  int v272; // [sp+40h] [bp+40h]
  int v273; // [sp+40h] [bp+40h]
  int v274; // [sp+40h] [bp+40h]
  int v275; // [sp+40h] [bp+40h]
  int v276; // [sp+40h] [bp+40h]
  int v277; // [sp+40h] [bp+40h]
  int v278; // [sp+40h] [bp+40h]
  int v279; // [sp+40h] [bp+40h]
  int v280; // [sp+40h] [bp+40h]
  int v281; // [sp+40h] [bp+40h]
  int v282; // [sp+40h] [bp+40h]
  int v283; // [sp+40h] [bp+40h]
  int v284; // [sp+40h] [bp+40h]
  int v285; // [sp+40h] [bp+40h]
  int v286; // [sp+40h] [bp+40h]
  int v287; // [sp+40h] [bp+40h]
  int v288; // [sp+40h] [bp+40h]
  int v289; // [sp+40h] [bp+40h]
  int v290; // [sp+40h] [bp+40h]
  int v291; // [sp+40h] [bp+40h]
  int v292; // [sp+40h] [bp+40h]
  int v293; // [sp+40h] [bp+40h]
  int v294; // [sp+40h] [bp+40h]
  int v295; // [sp+40h] [bp+40h]
  int v296; // [sp+40h] [bp+40h]
  int v297; // [sp+40h] [bp+40h]
  int v298; // [sp+44h] [bp+44h]
  int v299; // [sp+44h] [bp+44h]
  int v300; // [sp+44h] [bp+44h]
  int v301; // [sp+44h] [bp+44h]
  int v302; // [sp+44h] [bp+44h]
  int v303; // [sp+44h] [bp+44h]
  int v304; // [sp+44h] [bp+44h]
  int v305; // [sp+44h] [bp+44h]
  int v306; // [sp+44h] [bp+44h]
  int v307; // [sp+44h] [bp+44h]
  int v308; // [sp+44h] [bp+44h]
  int v309; // [sp+44h] [bp+44h]
  int v310; // [sp+44h] [bp+44h]
  int v311; // [sp+44h] [bp+44h]
  int v312; // [sp+44h] [bp+44h]
  int v313; // [sp+44h] [bp+44h]
  int v314; // [sp+44h] [bp+44h]
  int v315; // [sp+44h] [bp+44h]
  int v316; // [sp+44h] [bp+44h]
  int v317; // [sp+44h] [bp+44h]
  int v318; // [sp+44h] [bp+44h]
  int v319; // [sp+44h] [bp+44h]
  int v320; // [sp+44h] [bp+44h]
  int v321; // [sp+44h] [bp+44h]
  int v322; // [sp+44h] [bp+44h]
  int v323; // [sp+44h] [bp+44h]
  int v324; // [sp+44h] [bp+44h]
  int v325; // [sp+44h] [bp+44h]
  int v326; // [sp+44h] [bp+44h]
  int v327; // [sp+44h] [bp+44h]
  int v328; // [sp+44h] [bp+44h]
  int v329; // [sp+44h] [bp+44h]
  int v330; // [sp+48h] [bp+48h]
  int v331; // [sp+48h] [bp+48h]
  int v332; // [sp+48h] [bp+48h]
  int v333; // [sp+48h] [bp+48h]
  int v334; // [sp+48h] [bp+48h]
  int v335; // [sp+48h] [bp+48h]
  int v336; // [sp+48h] [bp+48h]
  int v337; // [sp+48h] [bp+48h]
  int v338; // [sp+48h] [bp+48h]
  int v339; // [sp+48h] [bp+48h]
  int v340; // [sp+48h] [bp+48h]
  int v341; // [sp+48h] [bp+48h]
  int v342; // [sp+48h] [bp+48h]
  int v343; // [sp+48h] [bp+48h]
  int v344; // [sp+48h] [bp+48h]
  int v345; // [sp+48h] [bp+48h]
  int v346; // [sp+48h] [bp+48h]
  int v347; // [sp+48h] [bp+48h]
  int v348; // [sp+48h] [bp+48h]
  int v349; // [sp+48h] [bp+48h]
  int v350; // [sp+48h] [bp+48h]
  int v351; // [sp+48h] [bp+48h]
  int v352; // [sp+48h] [bp+48h]
  int v353; // [sp+48h] [bp+48h]
  int v354; // [sp+48h] [bp+48h]
  int v355; // [sp+48h] [bp+48h]
  int v356; // [sp+48h] [bp+48h]
  int v357; // [sp+48h] [bp+48h]
  int v358; // [sp+48h] [bp+48h]
  int v359; // [sp+48h] [bp+48h]
  int v360; // [sp+48h] [bp+48h]
  int v361; // [sp+48h] [bp+48h]
  int v362; // [sp+4Ch] [bp+4Ch]
  int v363; // [sp+4Ch] [bp+4Ch]
  int v364; // [sp+4Ch] [bp+4Ch]
  int v365; // [sp+4Ch] [bp+4Ch]
  int v366; // [sp+4Ch] [bp+4Ch]
  int v367; // [sp+4Ch] [bp+4Ch]
  int v368; // [sp+4Ch] [bp+4Ch]
  int v369; // [sp+4Ch] [bp+4Ch]
  int v370; // [sp+4Ch] [bp+4Ch]
  int v371; // [sp+4Ch] [bp+4Ch]
  int v372; // [sp+4Ch] [bp+4Ch]
  int v373; // [sp+4Ch] [bp+4Ch]
  int v374; // [sp+4Ch] [bp+4Ch]
  int v375; // [sp+4Ch] [bp+4Ch]
  int v376; // [sp+4Ch] [bp+4Ch]
  int v377; // [sp+4Ch] [bp+4Ch]
  int v378; // [sp+4Ch] [bp+4Ch]
  int v379; // [sp+4Ch] [bp+4Ch]
  int v380; // [sp+4Ch] [bp+4Ch]
  int v381; // [sp+4Ch] [bp+4Ch]
  int v382; // [sp+4Ch] [bp+4Ch]
  int v383; // [sp+4Ch] [bp+4Ch]
  int v384; // [sp+4Ch] [bp+4Ch]
  int v385; // [sp+4Ch] [bp+4Ch]
  int v386; // [sp+4Ch] [bp+4Ch]
  int v387; // [sp+4Ch] [bp+4Ch]
  int v388; // [sp+4Ch] [bp+4Ch]
  int v389; // [sp+4Ch] [bp+4Ch]
  int v390; // [sp+4Ch] [bp+4Ch]
  int v391; // [sp+4Ch] [bp+4Ch]
  int v392; // [sp+4Ch] [bp+4Ch]
  int v393; // [sp+4Ch] [bp+4Ch]
  int v394; // [sp+50h] [bp+50h]
  int v395; // [sp+50h] [bp+50h]
  int v396; // [sp+50h] [bp+50h]
  int v397; // [sp+50h] [bp+50h]
  int v398; // [sp+50h] [bp+50h]
  int v399; // [sp+50h] [bp+50h]
  int v400; // [sp+50h] [bp+50h]
  int v401; // [sp+50h] [bp+50h]
  int v402; // [sp+50h] [bp+50h]
  int v403; // [sp+50h] [bp+50h]
  int v404; // [sp+50h] [bp+50h]
  int v405; // [sp+50h] [bp+50h]
  int v406; // [sp+50h] [bp+50h]
  int v407; // [sp+50h] [bp+50h]
  int v408; // [sp+50h] [bp+50h]
  int v409; // [sp+50h] [bp+50h]
  int v410; // [sp+50h] [bp+50h]
  int v411; // [sp+50h] [bp+50h]
  int v412; // [sp+50h] [bp+50h]
  int v413; // [sp+50h] [bp+50h]
  int v414; // [sp+50h] [bp+50h]
  int v415; // [sp+50h] [bp+50h]
  int v416; // [sp+50h] [bp+50h]
  int v417; // [sp+50h] [bp+50h]
  int v418; // [sp+50h] [bp+50h]
  int v419; // [sp+50h] [bp+50h]
  int v420; // [sp+50h] [bp+50h]
  int v421; // [sp+50h] [bp+50h]
  int v422; // [sp+50h] [bp+50h]
  int v423; // [sp+50h] [bp+50h]
  int v424; // [sp+50h] [bp+50h]
  int v425; // [sp+50h] [bp+50h]
  int v426; // [sp+54h] [bp+54h]
  int v427; // [sp+54h] [bp+54h]
  int v428; // [sp+54h] [bp+54h]
  int v429; // [sp+54h] [bp+54h]
  int v430; // [sp+54h] [bp+54h]
  int v431; // [sp+54h] [bp+54h]
  int v432; // [sp+54h] [bp+54h]
  int v433; // [sp+54h] [bp+54h]
  int v434; // [sp+54h] [bp+54h]
  int v435; // [sp+54h] [bp+54h]
  int v436; // [sp+54h] [bp+54h]
  int v437; // [sp+54h] [bp+54h]
  int v438; // [sp+54h] [bp+54h]
  int v439; // [sp+54h] [bp+54h]
  int v440; // [sp+54h] [bp+54h]
  int v441; // [sp+54h] [bp+54h]
  int v442; // [sp+54h] [bp+54h]
  int v443; // [sp+54h] [bp+54h]
  int v444; // [sp+54h] [bp+54h]
  int v445; // [sp+54h] [bp+54h]
  int v446; // [sp+54h] [bp+54h]
  int v447; // [sp+54h] [bp+54h]
  int v448; // [sp+54h] [bp+54h]
  int v449; // [sp+54h] [bp+54h]
  int v450; // [sp+54h] [bp+54h]
  int v451; // [sp+54h] [bp+54h]
  int v452; // [sp+54h] [bp+54h]
  int v453; // [sp+54h] [bp+54h]
  int v454; // [sp+54h] [bp+54h]
  int v455; // [sp+54h] [bp+54h]
  int v456; // [sp+54h] [bp+54h]
  int v457; // [sp+54h] [bp+54h]
  int v458; // [sp+58h] [bp+58h]
  int v459; // [sp+58h] [bp+58h]
  int v460; // [sp+58h] [bp+58h]
  int v461; // [sp+58h] [bp+58h]
  int v462; // [sp+58h] [bp+58h]
  int v463; // [sp+58h] [bp+58h]
  int v464; // [sp+58h] [bp+58h]
  int v465; // [sp+58h] [bp+58h]
  int v466; // [sp+58h] [bp+58h]
  int v467; // [sp+58h] [bp+58h]
  int v468; // [sp+58h] [bp+58h]
  int v469; // [sp+58h] [bp+58h]
  int v470; // [sp+58h] [bp+58h]
  int v471; // [sp+58h] [bp+58h]
  int v472; // [sp+58h] [bp+58h]
  int v473; // [sp+58h] [bp+58h]
  int v474; // [sp+58h] [bp+58h]
  int v475; // [sp+58h] [bp+58h]
  int v476; // [sp+58h] [bp+58h]
  int v477; // [sp+58h] [bp+58h]
  int v478; // [sp+58h] [bp+58h]
  int v479; // [sp+58h] [bp+58h]
  int v480; // [sp+58h] [bp+58h]
  int v481; // [sp+58h] [bp+58h]
  int v482; // [sp+58h] [bp+58h]
  int v483; // [sp+58h] [bp+58h]
  int v484; // [sp+58h] [bp+58h]
  int v485; // [sp+58h] [bp+58h]
  int v486; // [sp+58h] [bp+58h]
  int v487; // [sp+58h] [bp+58h]
  int v488; // [sp+58h] [bp+58h]
  int v489; // [sp+58h] [bp+58h]
  int v490; // [sp+5Ch] [bp+5Ch]
  int v491; // [sp+5Ch] [bp+5Ch]
  int v492; // [sp+5Ch] [bp+5Ch]
  int v493; // [sp+5Ch] [bp+5Ch]
  int v494; // [sp+5Ch] [bp+5Ch]
  int v495; // [sp+5Ch] [bp+5Ch]
  int v496; // [sp+5Ch] [bp+5Ch]
  int v497; // [sp+5Ch] [bp+5Ch]
  int v498; // [sp+5Ch] [bp+5Ch]
  int v499; // [sp+5Ch] [bp+5Ch]
  int v500; // [sp+5Ch] [bp+5Ch]
  int v501; // [sp+5Ch] [bp+5Ch]
  int v502; // [sp+5Ch] [bp+5Ch]
  int v503; // [sp+5Ch] [bp+5Ch]
  int v504; // [sp+5Ch] [bp+5Ch]
  int v505; // [sp+5Ch] [bp+5Ch]
  int v506; // [sp+5Ch] [bp+5Ch]
  int v507; // [sp+5Ch] [bp+5Ch]
  int v508; // [sp+5Ch] [bp+5Ch]
  int v509; // [sp+5Ch] [bp+5Ch]
  int v510; // [sp+5Ch] [bp+5Ch]
  int v511; // [sp+5Ch] [bp+5Ch]
  int v512; // [sp+5Ch] [bp+5Ch]
  int v513; // [sp+5Ch] [bp+5Ch]
  int v514; // [sp+5Ch] [bp+5Ch]
  int v515; // [sp+5Ch] [bp+5Ch]
  int v516; // [sp+5Ch] [bp+5Ch]
  int v517; // [sp+5Ch] [bp+5Ch]
  int v518; // [sp+5Ch] [bp+5Ch]
  int v519; // [sp+5Ch] [bp+5Ch]
  int v520; // [sp+5Ch] [bp+5Ch]
  int v521; // [sp+5Ch] [bp+5Ch]
  int v522; // [sp+60h] [bp+60h]
  int v523; // [sp+60h] [bp+60h]
  int v524; // [sp+60h] [bp+60h]
  int v525; // [sp+60h] [bp+60h]
  int v526; // [sp+60h] [bp+60h]
  int v527; // [sp+60h] [bp+60h]
  int v528; // [sp+60h] [bp+60h]
  int v529; // [sp+60h] [bp+60h]
  int v530; // [sp+60h] [bp+60h]
  int v531; // [sp+60h] [bp+60h]
  int v532; // [sp+60h] [bp+60h]
  int v533; // [sp+60h] [bp+60h]
  int v534; // [sp+60h] [bp+60h]
  int v535; // [sp+60h] [bp+60h]
  int v536; // [sp+60h] [bp+60h]
  int v537; // [sp+60h] [bp+60h]
  int v538; // [sp+60h] [bp+60h]
  int v539; // [sp+60h] [bp+60h]
  int v540; // [sp+60h] [bp+60h]
  int v541; // [sp+60h] [bp+60h]
  int v542; // [sp+60h] [bp+60h]
  int v543; // [sp+60h] [bp+60h]
  int v544; // [sp+60h] [bp+60h]
  int v545; // [sp+60h] [bp+60h]
  int v546; // [sp+60h] [bp+60h]
  int v547; // [sp+60h] [bp+60h]
  int v548; // [sp+60h] [bp+60h]
  int v549; // [sp+60h] [bp+60h]
  int v550; // [sp+60h] [bp+60h]
  int v551; // [sp+60h] [bp+60h]
  int v552; // [sp+60h] [bp+60h]
  int v553; // [sp+60h] [bp+60h]
  int v554; // [sp+64h] [bp+64h]
  int v555; // [sp+64h] [bp+64h]
  int v556; // [sp+64h] [bp+64h]
  int v557; // [sp+64h] [bp+64h]
  int v558; // [sp+64h] [bp+64h]
  int v559; // [sp+64h] [bp+64h]
  int v560; // [sp+64h] [bp+64h]
  int v561; // [sp+64h] [bp+64h]
  int v562; // [sp+64h] [bp+64h]
  int v563; // [sp+64h] [bp+64h]
  int v564; // [sp+64h] [bp+64h]
  int v565; // [sp+64h] [bp+64h]
  int v566; // [sp+64h] [bp+64h]
  int v567; // [sp+64h] [bp+64h]
  int v568; // [sp+64h] [bp+64h]
  int v569; // [sp+64h] [bp+64h]
  int v570; // [sp+64h] [bp+64h]
  int v571; // [sp+64h] [bp+64h]
  int v572; // [sp+64h] [bp+64h]
  int v573; // [sp+64h] [bp+64h]
  int v574; // [sp+64h] [bp+64h]
  int v575; // [sp+64h] [bp+64h]
  int v576; // [sp+64h] [bp+64h]
  int v577; // [sp+64h] [bp+64h]
  int v578; // [sp+64h] [bp+64h]
  int v579; // [sp+64h] [bp+64h]
  int v580; // [sp+64h] [bp+64h]
  int v581; // [sp+64h] [bp+64h]
  int v582; // [sp+64h] [bp+64h]
  int v583; // [sp+64h] [bp+64h]
  int v584; // [sp+64h] [bp+64h]
  int v585; // [sp+64h] [bp+64h]
  int v586; // [sp+68h] [bp+68h]
  int v587; // [sp+68h] [bp+68h]
  int v588; // [sp+68h] [bp+68h]
  int v589; // [sp+68h] [bp+68h]
  int v590; // [sp+68h] [bp+68h]
  int v591; // [sp+68h] [bp+68h]
  int v592; // [sp+68h] [bp+68h]
  int v593; // [sp+68h] [bp+68h]
  int v594; // [sp+68h] [bp+68h]
  int v595; // [sp+68h] [bp+68h]
  int v596; // [sp+68h] [bp+68h]
  int v597; // [sp+68h] [bp+68h]
  int v598; // [sp+68h] [bp+68h]
  int v599; // [sp+68h] [bp+68h]
  int v600; // [sp+68h] [bp+68h]
  int v601; // [sp+68h] [bp+68h]
  int v602; // [sp+68h] [bp+68h]
  int v603; // [sp+68h] [bp+68h]
  int v604; // [sp+68h] [bp+68h]
  int v605; // [sp+68h] [bp+68h]
  int v606; // [sp+68h] [bp+68h]
  int v607; // [sp+68h] [bp+68h]
  int v608; // [sp+68h] [bp+68h]
  int v609; // [sp+68h] [bp+68h]
  int v610; // [sp+68h] [bp+68h]
  int v611; // [sp+68h] [bp+68h]
  int v612; // [sp+68h] [bp+68h]
  int v613; // [sp+68h] [bp+68h]
  int v614; // [sp+68h] [bp+68h]
  int v615; // [sp+68h] [bp+68h]
  int v616; // [sp+68h] [bp+68h]
  int v617; // [sp+68h] [bp+68h]
  int v618; // [sp+6Ch] [bp+6Ch]
  int v619; // [sp+6Ch] [bp+6Ch]
  int v620; // [sp+6Ch] [bp+6Ch]
  int v621; // [sp+6Ch] [bp+6Ch]
  int v622; // [sp+6Ch] [bp+6Ch]
  int v623; // [sp+6Ch] [bp+6Ch]
  int v624; // [sp+6Ch] [bp+6Ch]
  int v625; // [sp+6Ch] [bp+6Ch]
  int v626; // [sp+6Ch] [bp+6Ch]
  int v627; // [sp+6Ch] [bp+6Ch]
  int v628; // [sp+6Ch] [bp+6Ch]
  int v629; // [sp+6Ch] [bp+6Ch]
  int v630; // [sp+6Ch] [bp+6Ch]
  int v631; // [sp+6Ch] [bp+6Ch]
  int v632; // [sp+6Ch] [bp+6Ch]
  int v633; // [sp+6Ch] [bp+6Ch]
  int v634; // [sp+6Ch] [bp+6Ch]
  int v635; // [sp+6Ch] [bp+6Ch]
  int v636; // [sp+6Ch] [bp+6Ch]
  int v637; // [sp+6Ch] [bp+6Ch]
  int v638; // [sp+6Ch] [bp+6Ch]
  int v639; // [sp+6Ch] [bp+6Ch]
  int v640; // [sp+6Ch] [bp+6Ch]
  int v641; // [sp+6Ch] [bp+6Ch]
  int v642; // [sp+6Ch] [bp+6Ch]
  int v643; // [sp+6Ch] [bp+6Ch]
  int v644; // [sp+6Ch] [bp+6Ch]
  int v645; // [sp+6Ch] [bp+6Ch]
  int v646; // [sp+6Ch] [bp+6Ch]
  int v647; // [sp+6Ch] [bp+6Ch]
  int v648; // [sp+6Ch] [bp+6Ch]
  int v649; // [sp+6Ch] [bp+6Ch]
  int v650; // [sp+70h] [bp+70h]
  int v651; // [sp+70h] [bp+70h]
  int v652; // [sp+70h] [bp+70h]
  int v653; // [sp+70h] [bp+70h]
  int v654; // [sp+70h] [bp+70h]
  int v655; // [sp+70h] [bp+70h]
  int v656; // [sp+70h] [bp+70h]
  int v657; // [sp+70h] [bp+70h]
  int v658; // [sp+70h] [bp+70h]
  int v659; // [sp+70h] [bp+70h]
  int v660; // [sp+70h] [bp+70h]
  int v661; // [sp+70h] [bp+70h]
  int v662; // [sp+70h] [bp+70h]
  int v663; // [sp+70h] [bp+70h]
  int v664; // [sp+70h] [bp+70h]
  int v665; // [sp+70h] [bp+70h]
  int v666; // [sp+70h] [bp+70h]
  int v667; // [sp+70h] [bp+70h]
  int v668; // [sp+70h] [bp+70h]
  int v669; // [sp+70h] [bp+70h]
  int v670; // [sp+70h] [bp+70h]
  int v671; // [sp+70h] [bp+70h]
  int v672; // [sp+70h] [bp+70h]
  int v673; // [sp+70h] [bp+70h]
  int v674; // [sp+70h] [bp+70h]
  int v675; // [sp+70h] [bp+70h]
  int v676; // [sp+70h] [bp+70h]
  int v677; // [sp+70h] [bp+70h]
  int v678; // [sp+70h] [bp+70h]
  int v679; // [sp+70h] [bp+70h]
  int v680; // [sp+70h] [bp+70h]
  int v681; // [sp+70h] [bp+70h]
  int v682; // [sp+74h] [bp+74h]
  int v683; // [sp+74h] [bp+74h]
  int v684; // [sp+74h] [bp+74h]
  int v685; // [sp+74h] [bp+74h]
  int v686; // [sp+74h] [bp+74h]
  int v687; // [sp+74h] [bp+74h]
  int v688; // [sp+74h] [bp+74h]
  int v689; // [sp+74h] [bp+74h]
  int v690; // [sp+74h] [bp+74h]
  int v691; // [sp+74h] [bp+74h]
  int v692; // [sp+74h] [bp+74h]
  int v693; // [sp+74h] [bp+74h]
  int v694; // [sp+74h] [bp+74h]
  int v695; // [sp+74h] [bp+74h]
  int v696; // [sp+74h] [bp+74h]
  int v697; // [sp+74h] [bp+74h]
  int v698; // [sp+74h] [bp+74h]
  int v699; // [sp+74h] [bp+74h]
  int v700; // [sp+74h] [bp+74h]
  int v701; // [sp+74h] [bp+74h]
  int v702; // [sp+74h] [bp+74h]
  int v703; // [sp+74h] [bp+74h]
  int v704; // [sp+74h] [bp+74h]
  int v705; // [sp+74h] [bp+74h]
  int v706; // [sp+74h] [bp+74h]
  int v707; // [sp+74h] [bp+74h]
  int v708; // [sp+74h] [bp+74h]
  int v709; // [sp+74h] [bp+74h]
  int v710; // [sp+74h] [bp+74h]
  int v711; // [sp+74h] [bp+74h]
  int v712; // [sp+74h] [bp+74h]
  int v713; // [sp+74h] [bp+74h]
  int v714; // [sp+78h] [bp+78h]
  int v715; // [sp+78h] [bp+78h]
  int v716; // [sp+78h] [bp+78h]
  int v717; // [sp+78h] [bp+78h]
  int v718; // [sp+78h] [bp+78h]
  int v719; // [sp+78h] [bp+78h]
  int v720; // [sp+78h] [bp+78h]
  int v721; // [sp+78h] [bp+78h]
  int v722; // [sp+78h] [bp+78h]
  int v723; // [sp+78h] [bp+78h]
  int v724; // [sp+78h] [bp+78h]
  int v725; // [sp+78h] [bp+78h]
  int v726; // [sp+78h] [bp+78h]
  int v727; // [sp+78h] [bp+78h]
  int v728; // [sp+78h] [bp+78h]
  int v729; // [sp+78h] [bp+78h]
  int v730; // [sp+78h] [bp+78h]
  int v731; // [sp+78h] [bp+78h]
  int v732; // [sp+78h] [bp+78h]
  int v733; // [sp+78h] [bp+78h]
  int v734; // [sp+78h] [bp+78h]
  int v735; // [sp+78h] [bp+78h]
  int v736; // [sp+78h] [bp+78h]
  int v737; // [sp+78h] [bp+78h]
  int v738; // [sp+78h] [bp+78h]
  int v739; // [sp+78h] [bp+78h]
  int v740; // [sp+78h] [bp+78h]
  int v741; // [sp+78h] [bp+78h]
  int v742; // [sp+78h] [bp+78h]
  int v743; // [sp+78h] [bp+78h]
  int v744; // [sp+78h] [bp+78h]
  int v745; // [sp+78h] [bp+78h]
  int v746; // [sp+7Ch] [bp+7Ch]
  int v747; // [sp+7Ch] [bp+7Ch]
  int v748; // [sp+7Ch] [bp+7Ch]
  int v749; // [sp+7Ch] [bp+7Ch]
  int v750; // [sp+7Ch] [bp+7Ch]
  int v751; // [sp+7Ch] [bp+7Ch]
  int v752; // [sp+7Ch] [bp+7Ch]
  int v753; // [sp+7Ch] [bp+7Ch]
  int v754; // [sp+7Ch] [bp+7Ch]
  int v755; // [sp+7Ch] [bp+7Ch]
  int v756; // [sp+7Ch] [bp+7Ch]
  int v757; // [sp+7Ch] [bp+7Ch]
  int v758; // [sp+7Ch] [bp+7Ch]
  int v759; // [sp+7Ch] [bp+7Ch]
  int v760; // [sp+7Ch] [bp+7Ch]
  int v761; // [sp+7Ch] [bp+7Ch]
  int v762; // [sp+7Ch] [bp+7Ch]
  int v763; // [sp+7Ch] [bp+7Ch]
  int v764; // [sp+7Ch] [bp+7Ch]
  int v765; // [sp+7Ch] [bp+7Ch]
  int v766; // [sp+7Ch] [bp+7Ch]
  int v767; // [sp+7Ch] [bp+7Ch]
  int v768; // [sp+7Ch] [bp+7Ch]
  int v769; // [sp+7Ch] [bp+7Ch]
  int v770; // [sp+7Ch] [bp+7Ch]
  int v771; // [sp+7Ch] [bp+7Ch]
  int v772; // [sp+7Ch] [bp+7Ch]
  int v773; // [sp+7Ch] [bp+7Ch]
  int v774; // [sp+7Ch] [bp+7Ch]
  int v775; // [sp+7Ch] [bp+7Ch]
  int v776; // [sp+7Ch] [bp+7Ch]
  int v777; // [sp+7Ch] [bp+7Ch]
  int v778; // [sp+80h] [bp+80h]
  int v779; // [sp+80h] [bp+80h]
  int v780; // [sp+80h] [bp+80h]
  int v781; // [sp+80h] [bp+80h]
  int v782; // [sp+80h] [bp+80h]
  int v783; // [sp+80h] [bp+80h]
  int v784; // [sp+80h] [bp+80h]
  int v785; // [sp+80h] [bp+80h]
  int v786; // [sp+80h] [bp+80h]
  int v787; // [sp+80h] [bp+80h]
  int v788; // [sp+80h] [bp+80h]
  int v789; // [sp+80h] [bp+80h]
  int v790; // [sp+80h] [bp+80h]
  int v791; // [sp+80h] [bp+80h]
  int v792; // [sp+80h] [bp+80h]
  int v793; // [sp+80h] [bp+80h]
  int v794; // [sp+80h] [bp+80h]
  int v795; // [sp+80h] [bp+80h]
  int v796; // [sp+80h] [bp+80h]
  int v797; // [sp+80h] [bp+80h]
  int v798; // [sp+80h] [bp+80h]
  int v799; // [sp+80h] [bp+80h]
  int v800; // [sp+80h] [bp+80h]
  int v801; // [sp+80h] [bp+80h]
  int v802; // [sp+80h] [bp+80h]
  int v803; // [sp+80h] [bp+80h]
  int v804; // [sp+80h] [bp+80h]
  int v805; // [sp+80h] [bp+80h]
  int v806; // [sp+80h] [bp+80h]
  int v807; // [sp+80h] [bp+80h]
  int v808; // [sp+80h] [bp+80h]
  int v809; // [sp+80h] [bp+80h]
  int v810; // [sp+80h] [bp+80h]
  int v811; // [sp+84h] [bp+84h]
  int v812; // [sp+84h] [bp+84h]
  int v813; // [sp+84h] [bp+84h]
  int v814; // [sp+84h] [bp+84h]
  int v815; // [sp+84h] [bp+84h]
  int v816; // [sp+84h] [bp+84h]
  int v817; // [sp+84h] [bp+84h]
  int v818; // [sp+84h] [bp+84h]
  int v819; // [sp+84h] [bp+84h]
  int v820; // [sp+84h] [bp+84h]
  int v821; // [sp+84h] [bp+84h]
  int v822; // [sp+84h] [bp+84h]
  int v823; // [sp+84h] [bp+84h]
  int v824; // [sp+84h] [bp+84h]
  int v825; // [sp+84h] [bp+84h]
  int v826; // [sp+84h] [bp+84h]
  int v827; // [sp+84h] [bp+84h]
  int v828; // [sp+84h] [bp+84h]
  int v829; // [sp+84h] [bp+84h]
  int v830; // [sp+84h] [bp+84h]
  int v831; // [sp+84h] [bp+84h]
  int v832; // [sp+84h] [bp+84h]
  int v833; // [sp+84h] [bp+84h]
  int v834; // [sp+84h] [bp+84h]
  int v835; // [sp+84h] [bp+84h]
  int v836; // [sp+84h] [bp+84h]
  int v837; // [sp+84h] [bp+84h]
  int v838; // [sp+84h] [bp+84h]
  int v839; // [sp+84h] [bp+84h]
  int v840; // [sp+84h] [bp+84h]
  int v841; // [sp+84h] [bp+84h]
  int v842; // [sp+84h] [bp+84h]
  int v843; // [sp+84h] [bp+84h]
  int v844; // [sp+88h] [bp+88h]
  int v845; // [sp+88h] [bp+88h]
  int v846; // [sp+88h] [bp+88h]
  int v847; // [sp+88h] [bp+88h]
  int v848; // [sp+88h] [bp+88h]
  int v849; // [sp+88h] [bp+88h]
  int v850; // [sp+88h] [bp+88h]
  int v851; // [sp+88h] [bp+88h]
  int v852; // [sp+88h] [bp+88h]
  int v853; // [sp+88h] [bp+88h]
  int v854; // [sp+88h] [bp+88h]
  int v855; // [sp+88h] [bp+88h]
  int v856; // [sp+88h] [bp+88h]
  int v857; // [sp+88h] [bp+88h]
  int v858; // [sp+88h] [bp+88h]
  int v859; // [sp+88h] [bp+88h]
  int v860; // [sp+88h] [bp+88h]
  int v861; // [sp+88h] [bp+88h]
  int v862; // [sp+88h] [bp+88h]
  int v863; // [sp+88h] [bp+88h]
  int v864; // [sp+88h] [bp+88h]
  int v865; // [sp+88h] [bp+88h]
  int v866; // [sp+88h] [bp+88h]
  int v867; // [sp+88h] [bp+88h]
  int v868; // [sp+88h] [bp+88h]
  int v869; // [sp+88h] [bp+88h]
  int v870; // [sp+88h] [bp+88h]
  int v871; // [sp+88h] [bp+88h]
  int v872; // [sp+88h] [bp+88h]
  int v873; // [sp+88h] [bp+88h]
  int v874; // [sp+88h] [bp+88h]
  int v875; // [sp+88h] [bp+88h]
  int v876; // [sp+88h] [bp+88h]
  int v877; // [sp+8Ch] [bp+8Ch]
  int v878; // [sp+8Ch] [bp+8Ch]
  int v879; // [sp+8Ch] [bp+8Ch]
  int v880; // [sp+8Ch] [bp+8Ch]
  int v881; // [sp+8Ch] [bp+8Ch]
  int v882; // [sp+8Ch] [bp+8Ch]
  int v883; // [sp+8Ch] [bp+8Ch]
  int v884; // [sp+8Ch] [bp+8Ch]
  int v885; // [sp+8Ch] [bp+8Ch]
  int v886; // [sp+8Ch] [bp+8Ch]
  int v887; // [sp+8Ch] [bp+8Ch]
  int v888; // [sp+8Ch] [bp+8Ch]
  int v889; // [sp+8Ch] [bp+8Ch]
  int v890; // [sp+8Ch] [bp+8Ch]
  int v891; // [sp+8Ch] [bp+8Ch]
  int v892; // [sp+8Ch] [bp+8Ch]
  int v893; // [sp+8Ch] [bp+8Ch]
  int v894; // [sp+8Ch] [bp+8Ch]
  int v895; // [sp+8Ch] [bp+8Ch]
  int v896; // [sp+8Ch] [bp+8Ch]
  int v897; // [sp+8Ch] [bp+8Ch]
  int v898; // [sp+8Ch] [bp+8Ch]
  int v899; // [sp+8Ch] [bp+8Ch]
  int v900; // [sp+8Ch] [bp+8Ch]
  int v901; // [sp+8Ch] [bp+8Ch]
  int v902; // [sp+8Ch] [bp+8Ch]
  int v903; // [sp+8Ch] [bp+8Ch]
  int v904; // [sp+8Ch] [bp+8Ch]
  int v905; // [sp+8Ch] [bp+8Ch]
  int v906; // [sp+8Ch] [bp+8Ch]
  int v907; // [sp+8Ch] [bp+8Ch]
  int v908; // [sp+8Ch] [bp+8Ch]
  int v909; // [sp+8Ch] [bp+8Ch]
  int v910; // [sp+90h] [bp+90h]
  int v911; // [sp+90h] [bp+90h]
  int v912; // [sp+90h] [bp+90h]
  int v913; // [sp+90h] [bp+90h]
  int v914; // [sp+90h] [bp+90h]
  int v915; // [sp+90h] [bp+90h]
  int v916; // [sp+90h] [bp+90h]
  int v917; // [sp+90h] [bp+90h]
  int v918; // [sp+90h] [bp+90h]
  int v919; // [sp+90h] [bp+90h]
  int v920; // [sp+90h] [bp+90h]
  int v921; // [sp+90h] [bp+90h]
  int v922; // [sp+90h] [bp+90h]
  int v923; // [sp+90h] [bp+90h]
  int v924; // [sp+90h] [bp+90h]
  int v925; // [sp+90h] [bp+90h]
  int v926; // [sp+90h] [bp+90h]
  int v927; // [sp+90h] [bp+90h]
  int v928; // [sp+90h] [bp+90h]
  int v929; // [sp+90h] [bp+90h]
  int v930; // [sp+90h] [bp+90h]
  int v931; // [sp+90h] [bp+90h]
  int v932; // [sp+90h] [bp+90h]
  int v933; // [sp+90h] [bp+90h]
  int v934; // [sp+90h] [bp+90h]
  int v935; // [sp+90h] [bp+90h]
  int v936; // [sp+90h] [bp+90h]
  int v937; // [sp+90h] [bp+90h]
  int v938; // [sp+90h] [bp+90h]
  int v939; // [sp+90h] [bp+90h]
  int v940; // [sp+90h] [bp+90h]
  int v941; // [sp+90h] [bp+90h]
  int v942; // [sp+90h] [bp+90h]
  int v943; // [sp+94h] [bp+94h]
  int v944; // [sp+94h] [bp+94h]
  int v945; // [sp+94h] [bp+94h]
  int v946; // [sp+94h] [bp+94h]
  int v947; // [sp+94h] [bp+94h]
  int v948; // [sp+94h] [bp+94h]
  int v949; // [sp+94h] [bp+94h]
  int v950; // [sp+94h] [bp+94h]
  int v951; // [sp+94h] [bp+94h]
  int v952; // [sp+94h] [bp+94h]
  int v953; // [sp+94h] [bp+94h]
  int v954; // [sp+94h] [bp+94h]
  int v955; // [sp+94h] [bp+94h]
  int v956; // [sp+94h] [bp+94h]
  int v957; // [sp+94h] [bp+94h]
  int v958; // [sp+94h] [bp+94h]
  int v959; // [sp+94h] [bp+94h]
  int v960; // [sp+94h] [bp+94h]
  int v961; // [sp+94h] [bp+94h]
  int v962; // [sp+94h] [bp+94h]
  int v963; // [sp+94h] [bp+94h]
  int v964; // [sp+94h] [bp+94h]
  int v965; // [sp+94h] [bp+94h]
  int v966; // [sp+94h] [bp+94h]
  int v967; // [sp+94h] [bp+94h]
  int v968; // [sp+94h] [bp+94h]
  int v969; // [sp+94h] [bp+94h]
  int v970; // [sp+94h] [bp+94h]
  int v971; // [sp+94h] [bp+94h]
  int v972; // [sp+94h] [bp+94h]
  int v973; // [sp+94h] [bp+94h]
  int v974; // [sp+94h] [bp+94h]
  int v975; // [sp+94h] [bp+94h]
  int v976; // [sp+98h] [bp+98h]
  int v977; // [sp+98h] [bp+98h]
  int v978; // [sp+98h] [bp+98h]
  int v979; // [sp+98h] [bp+98h]
  int v980; // [sp+98h] [bp+98h]
  int v981; // [sp+98h] [bp+98h]
  int v982; // [sp+98h] [bp+98h]
  int v983; // [sp+98h] [bp+98h]
  int v984; // [sp+98h] [bp+98h]
  int v985; // [sp+98h] [bp+98h]
  int v986; // [sp+98h] [bp+98h]
  int v987; // [sp+98h] [bp+98h]
  int v988; // [sp+98h] [bp+98h]
  int v989; // [sp+98h] [bp+98h]
  int v990; // [sp+98h] [bp+98h]
  int v991; // [sp+98h] [bp+98h]
  int v992; // [sp+98h] [bp+98h]
  int v993; // [sp+98h] [bp+98h]
  int v994; // [sp+98h] [bp+98h]
  int v995; // [sp+98h] [bp+98h]
  int v996; // [sp+98h] [bp+98h]
  int v997; // [sp+98h] [bp+98h]
  int v998; // [sp+98h] [bp+98h]
  int v999; // [sp+98h] [bp+98h]
  int v1000; // [sp+98h] [bp+98h]
  int v1001; // [sp+98h] [bp+98h]
  int v1002; // [sp+98h] [bp+98h]
  int v1003; // [sp+98h] [bp+98h]
  int v1004; // [sp+98h] [bp+98h]
  int v1005; // [sp+98h] [bp+98h]
  int v1006; // [sp+98h] [bp+98h]
  int v1007; // [sp+98h] [bp+98h]
  int v1008; // [sp+98h] [bp+98h]
  int v1009; // [sp+9Ch] [bp+9Ch]
  int v1010; // [sp+9Ch] [bp+9Ch]
  int v1011; // [sp+9Ch] [bp+9Ch]
  int v1012; // [sp+9Ch] [bp+9Ch]
  int v1013; // [sp+9Ch] [bp+9Ch]
  int v1014; // [sp+9Ch] [bp+9Ch]
  int v1015; // [sp+9Ch] [bp+9Ch]
  int v1016; // [sp+9Ch] [bp+9Ch]
  int v1017; // [sp+9Ch] [bp+9Ch]
  int v1018; // [sp+9Ch] [bp+9Ch]
  int v1019; // [sp+9Ch] [bp+9Ch]
  int v1020; // [sp+9Ch] [bp+9Ch]
  int v1021; // [sp+9Ch] [bp+9Ch]
  int v1022; // [sp+9Ch] [bp+9Ch]
  int v1023; // [sp+9Ch] [bp+9Ch]
  int v1024; // [sp+9Ch] [bp+9Ch]
  int v1025; // [sp+9Ch] [bp+9Ch]
  int v1026; // [sp+9Ch] [bp+9Ch]
  int v1027; // [sp+9Ch] [bp+9Ch]
  int v1028; // [sp+9Ch] [bp+9Ch]
  int v1029; // [sp+9Ch] [bp+9Ch]
  int v1030; // [sp+9Ch] [bp+9Ch]
  int v1031; // [sp+9Ch] [bp+9Ch]
  int v1032; // [sp+9Ch] [bp+9Ch]
  int v1033; // [sp+9Ch] [bp+9Ch]
  int v1034; // [sp+9Ch] [bp+9Ch]
  int v1035; // [sp+9Ch] [bp+9Ch]
  int v1036; // [sp+9Ch] [bp+9Ch]
  int v1037; // [sp+9Ch] [bp+9Ch]
  int v1038; // [sp+9Ch] [bp+9Ch]
  int v1039; // [sp+9Ch] [bp+9Ch]
  int v1040; // [sp+9Ch] [bp+9Ch]
  int v1041; // [sp+9Ch] [bp+9Ch]
  int i; // [sp+A0h] [bp+A0h]
  unsigned int j; // [sp+A4h] [bp+A4h]

  v5 = a1[8];
  *((_BYTE *)a1 + v5) = (128 >> a3) | a2 & -(128 >> a3);
  memset((char *)a1 + v5 + 1, 0, 31 - v5);
  v1009 = a1[9];
  v976 = a1[10];
  v943 = a1[11];
  v910 = a1[12];
  v877 = a1[13];
  v844 = a1[14];
  v811 = a1[15];
  v778 = a1[16];
  v746 = a1[17];
  v714 = a1[18];
  v682 = a1[19];
  v650 = a1[20];
  v618 = a1[21];
  v586 = a1[22];
  v554 = a1[23];
  v522 = a1[24];
  v490 = a1[25];
  v458 = a1[26];
  v426 = a1[27];
  v394 = a1[28];
  v362 = a1[29];
  v330 = a1[30];
  v298 = a1[31];
  v266 = a1[32];
  v234 = a1[33];
  v202 = a1[34];
  v170 = a1[35];
  v138 = a1[36];
  v106 = a1[37];
  v74 = a1[38];
  v42 = a1[39];
  v10 = a1[40];
  v1010 = v1009 ^ sub_19B83C((int)a1);
  v977 = v976 ^ sub_19B83C((int)(a1 + 1));
  v944 = v943 ^ sub_19B83C((int)(a1 + 2));
  v911 = v910 ^ sub_19B83C((int)(a1 + 3));
  v878 = v877 ^ sub_19B83C((int)(a1 + 4));
  v845 = v844 ^ sub_19B83C((int)(a1 + 5));
  v812 = v811 ^ sub_19B83C((int)(a1 + 6));
  result = sub_19B83C((int)(a1 + 7));
  v779 = v778 ^ result;
  for ( i = 0; i <= 10; ++i )
  {
    v491 = v1010 + v490;
    v459 = v977 + v458;
    v427 = v944 + v426;
    v395 = v911 + v394;
    v363 = v878 + v362;
    v331 = v845 + v330;
    v299 = v812 + v298;
    v267 = v779 + v266;
    v235 = v746 + v234;
    v203 = v714 + v202;
    v171 = v682 + v170;
    v139 = v650 + v138;
    v107 = v618 + v106;
    v75 = v586 + v74;
    v43 = v554 + v42;
    v11 = v522 + v10;
    v747 = v491 ^ __ROR4__(v746, 25);
    v715 = v459 ^ __ROR4__(v714, 25);
    v683 = v427 ^ __ROR4__(v682, 25);
    v651 = v395 ^ __ROR4__(v650, 25);
    v619 = v363 ^ __ROR4__(v618, 25);
    v587 = v331 ^ __ROR4__(v586, 25);
    v555 = v299 ^ __ROR4__(v554, 25);
    v523 = v267 ^ __ROR4__(v522, 25);
    v1011 = v235 ^ __ROR4__(v1010, 25);
    v978 = v203 ^ __ROR4__(v977, 25);
    v945 = v171 ^ __ROR4__(v944, 25);
    v912 = v139 ^ __ROR4__(v911, 25);
    v879 = v107 ^ __ROR4__(v878, 25);
    v846 = v75 ^ __ROR4__(v845, 25);
    v813 = v43 ^ __ROR4__(v812, 25);
    v780 = v11 ^ __ROR4__(v779, 25);
    v428 = v747 + v427;
    v396 = v715 + v395;
    v492 = v683 + v491;
    v460 = v651 + v459;
    v300 = v619 + v299;
    v268 = v587 + v267;
    v364 = v555 + v363;
    v332 = v523 + v331;
    v172 = v1011 + v171;
    v140 = v978 + v139;
    v236 = v945 + v235;
    v204 = v912 + v203;
    v44 = v879 + v43;
    v12 = v846 + v11;
    v108 = v813 + v107;
    v76 = v780 + v75;
    v620 = v428 ^ __ROR4__(v619, 21);
    v588 = v396 ^ __ROR4__(v587, 21);
    v556 = v492 ^ __ROR4__(v555, 21);
    v524 = v460 ^ __ROR4__(v523, 21);
    v748 = v300 ^ __ROR4__(v747, 21);
    v716 = v268 ^ __ROR4__(v715, 21);
    v684 = v364 ^ __ROR4__(v683, 21);
    v652 = v332 ^ __ROR4__(v651, 21);
    v880 = v172 ^ __ROR4__(v879, 21);
    v847 = v140 ^ __ROR4__(v846, 21);
    v814 = v236 ^ __ROR4__(v813, 21);
    v781 = v204 ^ __ROR4__(v780, 21);
    v1012 = v44 ^ __ROR4__(v1011, 21);
    v979 = v12 ^ __ROR4__(v978, 21);
    v946 = v108 ^ __ROR4__(v945, 21);
    v913 = v76 ^ __ROR4__(v912, 21);
    v397 = v620 + v396;
    v429 = v588 + v428;
    v461 = v556 + v460;
    v493 = v524 + v492;
    v269 = v748 + v268;
    v301 = v716 + v300;
    v333 = v684 + v332;
    v365 = v652 + v364;
    v141 = v880 + v140;
    v173 = v847 + v172;
    v205 = v814 + v204;
    v237 = v781 + v236;
    v13 = v1012 + v12;
    v45 = v979 + v44;
    v77 = v946 + v76;
    v109 = v913 + v108;
    v881 = v397 ^ __ROR4__(v880, 25);
    v848 = v429 ^ __ROR4__(v847, 25);
    v815 = v461 ^ __ROR4__(v814, 25);
    v782 = v493 ^ __ROR4__(v781, 25);
    v1013 = v269 ^ __ROR4__(v1012, 25);
    v980 = v301 ^ __ROR4__(v979, 25);
    v947 = v333 ^ __ROR4__(v946, 25);
    v914 = v365 ^ __ROR4__(v913, 25);
    v621 = v141 ^ __ROR4__(v620, 25);
    v589 = v173 ^ __ROR4__(v588, 25);
    v557 = v205 ^ __ROR4__(v556, 25);
    v525 = v237 ^ __ROR4__(v524, 25);
    v749 = v13 ^ __ROR4__(v748, 25);
    v717 = v45 ^ __ROR4__(v716, 25);
    v685 = v77 ^ __ROR4__(v684, 25);
    v653 = v109 ^ __ROR4__(v652, 25);
    v462 = v881 + v461;
    v494 = v848 + v493;
    v398 = v815 + v397;
    v430 = v782 + v429;
    v334 = v1013 + v333;
    v366 = v980 + v365;
    v270 = v947 + v269;
    v302 = v914 + v301;
    v206 = v621 + v205;
    v238 = v589 + v237;
    v142 = v557 + v141;
    v174 = v525 + v173;
    v78 = v749 + v77;
    v110 = v717 + v109;
    v14 = v685 + v13;
    v46 = v653 + v45;
    v1014 = v462 ^ __ROR4__(v1013, 21);
    v981 = v494 ^ __ROR4__(v980, 21);
    v948 = v398 ^ __ROR4__(v947, 21);
    v915 = v430 ^ __ROR4__(v914, 21);
    v882 = v334 ^ __ROR4__(v881, 21);
    v849 = v366 ^ __ROR4__(v848, 21);
    v816 = v270 ^ __ROR4__(v815, 21);
    v783 = v302 ^ __ROR4__(v782, 21);
    v750 = v206 ^ __ROR4__(v749, 21);
    v718 = v238 ^ __ROR4__(v717, 21);
    v686 = v142 ^ __ROR4__(v685, 21);
    v654 = v174 ^ __ROR4__(v653, 21);
    v622 = v78 ^ __ROR4__(v621, 21);
    v590 = v110 ^ __ROR4__(v589, 21);
    v558 = v14 ^ __ROR4__(v557, 21);
    v526 = v46 ^ __ROR4__(v525, 21);
    v495 = v1014 + v494;
    v463 = v981 + v462;
    v431 = v948 + v430;
    v399 = v915 + v398;
    v367 = v882 + v366;
    v335 = v849 + v334;
    v303 = v816 + v302;
    v271 = v783 + v270;
    v239 = v750 + v238;
    v207 = v718 + v206;
    v175 = v686 + v174;
    v143 = v654 + v142;
    v111 = v622 + v110;
    v79 = v590 + v78;
    v47 = v558 + v46;
    v15 = v526 + v14;
    v751 = v495 ^ __ROR4__(v750, 25);
    v719 = v463 ^ __ROR4__(v718, 25);
    v687 = v431 ^ __ROR4__(v686, 25);
    v655 = v399 ^ __ROR4__(v654, 25);
    v623 = v367 ^ __ROR4__(v622, 25);
    v591 = v335 ^ __ROR4__(v590, 25);
    v559 = v303 ^ __ROR4__(v558, 25);
    v527 = v271 ^ __ROR4__(v526, 25);
    v1015 = v239 ^ __ROR4__(v1014, 25);
    v982 = v207 ^ __ROR4__(v981, 25);
    v949 = v175 ^ __ROR4__(v948, 25);
    v916 = v143 ^ __ROR4__(v915, 25);
    v883 = v111 ^ __ROR4__(v882, 25);
    v850 = v79 ^ __ROR4__(v849, 25);
    v817 = v47 ^ __ROR4__(v816, 25);
    v784 = v15 ^ __ROR4__(v783, 25);
    v432 = v751 + v431;
    v400 = v719 + v399;
    v496 = v687 + v495;
    v464 = v655 + v463;
    v304 = v623 + v303;
    v272 = v591 + v271;
    v368 = v559 + v367;
    v336 = v527 + v335;
    v176 = v1015 + v175;
    v144 = v982 + v143;
    v240 = v949 + v239;
    v208 = v916 + v207;
    v48 = v883 + v47;
    v16 = v850 + v15;
    v112 = v817 + v111;
    v80 = v784 + v79;
    v624 = v432 ^ __ROR4__(v623, 21);
    v592 = v400 ^ __ROR4__(v591, 21);
    v560 = v496 ^ __ROR4__(v559, 21);
    v528 = v464 ^ __ROR4__(v527, 21);
    v752 = v304 ^ __ROR4__(v751, 21);
    v720 = v272 ^ __ROR4__(v719, 21);
    v688 = v368 ^ __ROR4__(v687, 21);
    v656 = v336 ^ __ROR4__(v655, 21);
    v884 = v176 ^ __ROR4__(v883, 21);
    v851 = v144 ^ __ROR4__(v850, 21);
    v818 = v240 ^ __ROR4__(v817, 21);
    v785 = v208 ^ __ROR4__(v784, 21);
    v1016 = v48 ^ __ROR4__(v1015, 21);
    v983 = v16 ^ __ROR4__(v982, 21);
    v950 = v112 ^ __ROR4__(v949, 21);
    v917 = v80 ^ __ROR4__(v916, 21);
    v401 = v624 + v400;
    v433 = v592 + v432;
    v465 = v560 + v464;
    v497 = v528 + v496;
    v273 = v752 + v272;
    v305 = v720 + v304;
    v337 = v688 + v336;
    v369 = v656 + v368;
    v145 = v884 + v144;
    v177 = v851 + v176;
    v209 = v818 + v208;
    v241 = v785 + v240;
    v17 = v1016 + v16;
    v49 = v983 + v48;
    v81 = v950 + v80;
    v113 = v917 + v112;
    v885 = v401 ^ __ROR4__(v884, 25);
    v852 = v433 ^ __ROR4__(v851, 25);
    v819 = v465 ^ __ROR4__(v818, 25);
    v786 = v497 ^ __ROR4__(v785, 25);
    v1017 = v273 ^ __ROR4__(v1016, 25);
    v984 = v305 ^ __ROR4__(v983, 25);
    v951 = v337 ^ __ROR4__(v950, 25);
    v918 = v369 ^ __ROR4__(v917, 25);
    v625 = v145 ^ __ROR4__(v624, 25);
    v593 = v177 ^ __ROR4__(v592, 25);
    v561 = v209 ^ __ROR4__(v560, 25);
    v529 = v241 ^ __ROR4__(v528, 25);
    v753 = v17 ^ __ROR4__(v752, 25);
    v721 = v49 ^ __ROR4__(v720, 25);
    v689 = v81 ^ __ROR4__(v688, 25);
    v657 = v113 ^ __ROR4__(v656, 25);
    v466 = v885 + v465;
    v498 = v852 + v497;
    v402 = v819 + v401;
    v434 = v786 + v433;
    v338 = v1017 + v337;
    v370 = v984 + v369;
    v274 = v951 + v273;
    v306 = v918 + v305;
    v210 = v625 + v209;
    v242 = v593 + v241;
    v146 = v561 + v145;
    v178 = v529 + v177;
    v82 = v753 + v81;
    v114 = v721 + v113;
    v18 = v689 + v17;
    v50 = v657 + v49;
    v1018 = v466 ^ __ROR4__(v1017, 21);
    v985 = v498 ^ __ROR4__(v984, 21);
    v952 = v402 ^ __ROR4__(v951, 21);
    v919 = v434 ^ __ROR4__(v918, 21);
    v886 = v338 ^ __ROR4__(v885, 21);
    v853 = v370 ^ __ROR4__(v852, 21);
    v820 = v274 ^ __ROR4__(v819, 21);
    v787 = v306 ^ __ROR4__(v786, 21);
    v754 = v210 ^ __ROR4__(v753, 21);
    v722 = v242 ^ __ROR4__(v721, 21);
    v690 = v146 ^ __ROR4__(v689, 21);
    v658 = v178 ^ __ROR4__(v657, 21);
    v626 = v82 ^ __ROR4__(v625, 21);
    v594 = v114 ^ __ROR4__(v593, 21);
    v562 = v18 ^ __ROR4__(v561, 21);
    v530 = v50 ^ __ROR4__(v529, 21);
    v499 = v1018 + v498;
    v467 = v985 + v466;
    v435 = v952 + v434;
    v403 = v919 + v402;
    v371 = v886 + v370;
    v339 = v853 + v338;
    v307 = v820 + v306;
    v275 = v787 + v274;
    v243 = v754 + v242;
    v211 = v722 + v210;
    v179 = v690 + v178;
    v147 = v658 + v146;
    v115 = v626 + v114;
    v83 = v594 + v82;
    v51 = v562 + v50;
    v19 = v530 + v18;
    v755 = v499 ^ __ROR4__(v754, 25);
    v723 = v467 ^ __ROR4__(v722, 25);
    v691 = v435 ^ __ROR4__(v690, 25);
    v659 = v403 ^ __ROR4__(v658, 25);
    v627 = v371 ^ __ROR4__(v626, 25);
    v595 = v339 ^ __ROR4__(v594, 25);
    v563 = v307 ^ __ROR4__(v562, 25);
    v531 = v275 ^ __ROR4__(v530, 25);
    v1019 = v243 ^ __ROR4__(v1018, 25);
    v986 = v211 ^ __ROR4__(v985, 25);
    v953 = v179 ^ __ROR4__(v952, 25);
    v920 = v147 ^ __ROR4__(v919, 25);
    v887 = v115 ^ __ROR4__(v886, 25);
    v854 = v83 ^ __ROR4__(v853, 25);
    v821 = v51 ^ __ROR4__(v820, 25);
    v788 = v19 ^ __ROR4__(v787, 25);
    v436 = v755 + v435;
    v404 = v723 + v403;
    v500 = v691 + v499;
    v468 = v659 + v467;
    v308 = v627 + v307;
    v276 = v595 + v275;
    v372 = v563 + v371;
    v340 = v531 + v339;
    v180 = v1019 + v179;
    v148 = v986 + v147;
    v244 = v953 + v243;
    v212 = v920 + v211;
    v52 = v887 + v51;
    v20 = v854 + v19;
    v116 = v821 + v115;
    v84 = v788 + v83;
    v628 = v436 ^ __ROR4__(v627, 21);
    v596 = v404 ^ __ROR4__(v595, 21);
    v564 = v500 ^ __ROR4__(v563, 21);
    v532 = v468 ^ __ROR4__(v531, 21);
    v756 = v308 ^ __ROR4__(v755, 21);
    v724 = v276 ^ __ROR4__(v723, 21);
    v692 = v372 ^ __ROR4__(v691, 21);
    v660 = v340 ^ __ROR4__(v659, 21);
    v888 = v180 ^ __ROR4__(v887, 21);
    v855 = v148 ^ __ROR4__(v854, 21);
    v822 = v244 ^ __ROR4__(v821, 21);
    v789 = v212 ^ __ROR4__(v788, 21);
    v1020 = v52 ^ __ROR4__(v1019, 21);
    v987 = v20 ^ __ROR4__(v986, 21);
    v954 = v116 ^ __ROR4__(v953, 21);
    v921 = v84 ^ __ROR4__(v920, 21);
    v405 = v628 + v404;
    v437 = v596 + v436;
    v469 = v564 + v468;
    v501 = v532 + v500;
    v277 = v756 + v276;
    v309 = v724 + v308;
    v341 = v692 + v340;
    v373 = v660 + v372;
    v149 = v888 + v148;
    v181 = v855 + v180;
    v213 = v822 + v212;
    v245 = v789 + v244;
    v21 = v1020 + v20;
    v53 = v987 + v52;
    v85 = v954 + v84;
    v117 = v921 + v116;
    v889 = v405 ^ __ROR4__(v888, 25);
    v856 = v437 ^ __ROR4__(v855, 25);
    v823 = v469 ^ __ROR4__(v822, 25);
    v790 = v501 ^ __ROR4__(v789, 25);
    v1021 = v277 ^ __ROR4__(v1020, 25);
    v988 = v309 ^ __ROR4__(v987, 25);
    v955 = v341 ^ __ROR4__(v954, 25);
    v922 = v373 ^ __ROR4__(v921, 25);
    v629 = v149 ^ __ROR4__(v628, 25);
    v597 = v181 ^ __ROR4__(v596, 25);
    v565 = v213 ^ __ROR4__(v564, 25);
    v533 = v245 ^ __ROR4__(v532, 25);
    v757 = v21 ^ __ROR4__(v756, 25);
    v725 = v53 ^ __ROR4__(v724, 25);
    v693 = v85 ^ __ROR4__(v692, 25);
    v661 = v117 ^ __ROR4__(v660, 25);
    v470 = v889 + v469;
    v502 = v856 + v501;
    v406 = v823 + v405;
    v438 = v790 + v437;
    v342 = v1021 + v341;
    v374 = v988 + v373;
    v278 = v955 + v277;
    v310 = v922 + v309;
    v214 = v629 + v213;
    v246 = v597 + v245;
    v150 = v565 + v149;
    v182 = v533 + v181;
    v86 = v757 + v85;
    v118 = v725 + v117;
    v22 = v693 + v21;
    v54 = v661 + v53;
    v1022 = v470 ^ __ROR4__(v1021, 21);
    v989 = v502 ^ __ROR4__(v988, 21);
    v956 = v406 ^ __ROR4__(v955, 21);
    v923 = v438 ^ __ROR4__(v922, 21);
    v890 = v342 ^ __ROR4__(v889, 21);
    v857 = v374 ^ __ROR4__(v856, 21);
    v824 = v278 ^ __ROR4__(v823, 21);
    v791 = v310 ^ __ROR4__(v790, 21);
    v758 = v214 ^ __ROR4__(v757, 21);
    v726 = v246 ^ __ROR4__(v725, 21);
    v694 = v150 ^ __ROR4__(v693, 21);
    v662 = v182 ^ __ROR4__(v661, 21);
    v630 = v86 ^ __ROR4__(v629, 21);
    v598 = v118 ^ __ROR4__(v597, 21);
    v566 = v22 ^ __ROR4__(v565, 21);
    v534 = v54 ^ __ROR4__(v533, 21);
    v503 = v1022 + v502;
    v471 = v989 + v470;
    v439 = v956 + v438;
    v407 = v923 + v406;
    v375 = v890 + v374;
    v343 = v857 + v342;
    v311 = v824 + v310;
    v279 = v791 + v278;
    v247 = v758 + v246;
    v215 = v726 + v214;
    v183 = v694 + v182;
    v151 = v662 + v150;
    v119 = v630 + v118;
    v87 = v598 + v86;
    v55 = v566 + v54;
    v23 = v534 + v22;
    v759 = v503 ^ __ROR4__(v758, 25);
    v727 = v471 ^ __ROR4__(v726, 25);
    v695 = v439 ^ __ROR4__(v694, 25);
    v663 = v407 ^ __ROR4__(v662, 25);
    v631 = v375 ^ __ROR4__(v630, 25);
    v599 = v343 ^ __ROR4__(v598, 25);
    v567 = v311 ^ __ROR4__(v566, 25);
    v535 = v279 ^ __ROR4__(v534, 25);
    v1023 = v247 ^ __ROR4__(v1022, 25);
    v990 = v215 ^ __ROR4__(v989, 25);
    v957 = v183 ^ __ROR4__(v956, 25);
    v924 = v151 ^ __ROR4__(v923, 25);
    v891 = v119 ^ __ROR4__(v890, 25);
    v858 = v87 ^ __ROR4__(v857, 25);
    v825 = v55 ^ __ROR4__(v824, 25);
    v792 = v23 ^ __ROR4__(v791, 25);
    v440 = v759 + v439;
    v408 = v727 + v407;
    v504 = v695 + v503;
    v472 = v663 + v471;
    v312 = v631 + v311;
    v280 = v599 + v279;
    v376 = v567 + v375;
    v344 = v535 + v343;
    v184 = v1023 + v183;
    v152 = v990 + v151;
    v248 = v957 + v247;
    v216 = v924 + v215;
    v56 = v891 + v55;
    v24 = v858 + v23;
    v120 = v825 + v119;
    v88 = v792 + v87;
    v632 = v440 ^ __ROR4__(v631, 21);
    v600 = v408 ^ __ROR4__(v599, 21);
    v568 = v504 ^ __ROR4__(v567, 21);
    v536 = v472 ^ __ROR4__(v535, 21);
    v760 = v312 ^ __ROR4__(v759, 21);
    v728 = v280 ^ __ROR4__(v727, 21);
    v696 = v376 ^ __ROR4__(v695, 21);
    v664 = v344 ^ __ROR4__(v663, 21);
    v892 = v184 ^ __ROR4__(v891, 21);
    v859 = v152 ^ __ROR4__(v858, 21);
    v826 = v248 ^ __ROR4__(v825, 21);
    v793 = v216 ^ __ROR4__(v792, 21);
    v1024 = v56 ^ __ROR4__(v1023, 21);
    v991 = v24 ^ __ROR4__(v990, 21);
    v958 = v120 ^ __ROR4__(v957, 21);
    v925 = v88 ^ __ROR4__(v924, 21);
    v409 = v632 + v408;
    v441 = v600 + v440;
    v473 = v568 + v472;
    v505 = v536 + v504;
    v281 = v760 + v280;
    v313 = v728 + v312;
    v345 = v696 + v344;
    v377 = v664 + v376;
    v153 = v892 + v152;
    v185 = v859 + v184;
    v217 = v826 + v216;
    v249 = v793 + v248;
    v25 = v1024 + v24;
    v57 = v991 + v56;
    v89 = v958 + v88;
    v121 = v925 + v120;
    v893 = v409 ^ __ROR4__(v892, 25);
    v860 = v441 ^ __ROR4__(v859, 25);
    v827 = v473 ^ __ROR4__(v826, 25);
    v794 = v505 ^ __ROR4__(v793, 25);
    v1025 = v281 ^ __ROR4__(v1024, 25);
    v992 = v313 ^ __ROR4__(v991, 25);
    v959 = v345 ^ __ROR4__(v958, 25);
    v926 = v377 ^ __ROR4__(v925, 25);
    v633 = v153 ^ __ROR4__(v632, 25);
    v601 = v185 ^ __ROR4__(v600, 25);
    v569 = v217 ^ __ROR4__(v568, 25);
    v537 = v249 ^ __ROR4__(v536, 25);
    v761 = v25 ^ __ROR4__(v760, 25);
    v729 = v57 ^ __ROR4__(v728, 25);
    v697 = v89 ^ __ROR4__(v696, 25);
    v665 = v121 ^ __ROR4__(v664, 25);
    v474 = v893 + v473;
    v506 = v860 + v505;
    v410 = v827 + v409;
    v442 = v794 + v441;
    v346 = v1025 + v345;
    v378 = v992 + v377;
    v282 = v959 + v281;
    v314 = v926 + v313;
    v218 = v633 + v217;
    v250 = v601 + v249;
    v154 = v569 + v153;
    v186 = v537 + v185;
    v90 = v761 + v89;
    v122 = v729 + v121;
    v26 = v697 + v25;
    v58 = v665 + v57;
    v1026 = v474 ^ __ROR4__(v1025, 21);
    v993 = v506 ^ __ROR4__(v992, 21);
    v960 = v410 ^ __ROR4__(v959, 21);
    v927 = v442 ^ __ROR4__(v926, 21);
    v894 = v346 ^ __ROR4__(v893, 21);
    v861 = v378 ^ __ROR4__(v860, 21);
    v828 = v282 ^ __ROR4__(v827, 21);
    v795 = v314 ^ __ROR4__(v794, 21);
    v762 = v218 ^ __ROR4__(v761, 21);
    v730 = v250 ^ __ROR4__(v729, 21);
    v698 = v154 ^ __ROR4__(v697, 21);
    v666 = v186 ^ __ROR4__(v665, 21);
    v634 = v90 ^ __ROR4__(v633, 21);
    v602 = v122 ^ __ROR4__(v601, 21);
    v570 = v26 ^ __ROR4__(v569, 21);
    v538 = v58 ^ __ROR4__(v537, 21);
    v507 = v1026 + v506;
    v475 = v993 + v474;
    v443 = v960 + v442;
    v411 = v927 + v410;
    v379 = v894 + v378;
    v347 = v861 + v346;
    v315 = v828 + v314;
    v283 = v795 + v282;
    v251 = v762 + v250;
    v219 = v730 + v218;
    v187 = v698 + v186;
    v155 = v666 + v154;
    v123 = v634 + v122;
    v91 = v602 + v90;
    v59 = v570 + v58;
    v27 = v538 + v26;
    v763 = v507 ^ __ROR4__(v762, 25);
    v731 = v475 ^ __ROR4__(v730, 25);
    v699 = v443 ^ __ROR4__(v698, 25);
    v667 = v411 ^ __ROR4__(v666, 25);
    v635 = v379 ^ __ROR4__(v634, 25);
    v603 = v347 ^ __ROR4__(v602, 25);
    v571 = v315 ^ __ROR4__(v570, 25);
    v539 = v283 ^ __ROR4__(v538, 25);
    v1027 = v251 ^ __ROR4__(v1026, 25);
    v994 = v219 ^ __ROR4__(v993, 25);
    v961 = v187 ^ __ROR4__(v960, 25);
    v928 = v155 ^ __ROR4__(v927, 25);
    v895 = v123 ^ __ROR4__(v894, 25);
    v862 = v91 ^ __ROR4__(v861, 25);
    v829 = v59 ^ __ROR4__(v828, 25);
    v796 = v27 ^ __ROR4__(v795, 25);
    v444 = v763 + v443;
    v412 = v731 + v411;
    v508 = v699 + v507;
    v476 = v667 + v475;
    v316 = v635 + v315;
    v284 = v603 + v283;
    v380 = v571 + v379;
    v348 = v539 + v347;
    v188 = v1027 + v187;
    v156 = v994 + v155;
    v252 = v961 + v251;
    v220 = v928 + v219;
    v60 = v895 + v59;
    v28 = v862 + v27;
    v124 = v829 + v123;
    v92 = v796 + v91;
    v636 = v444 ^ __ROR4__(v635, 21);
    v604 = v412 ^ __ROR4__(v603, 21);
    v572 = v508 ^ __ROR4__(v571, 21);
    v540 = v476 ^ __ROR4__(v539, 21);
    v764 = v316 ^ __ROR4__(v763, 21);
    v732 = v284 ^ __ROR4__(v731, 21);
    v700 = v380 ^ __ROR4__(v699, 21);
    v668 = v348 ^ __ROR4__(v667, 21);
    v896 = v188 ^ __ROR4__(v895, 21);
    v863 = v156 ^ __ROR4__(v862, 21);
    v830 = v252 ^ __ROR4__(v829, 21);
    v797 = v220 ^ __ROR4__(v796, 21);
    v1028 = v60 ^ __ROR4__(v1027, 21);
    v995 = v28 ^ __ROR4__(v994, 21);
    v962 = v124 ^ __ROR4__(v961, 21);
    v929 = v92 ^ __ROR4__(v928, 21);
    v413 = v636 + v412;
    v445 = v604 + v444;
    v477 = v572 + v476;
    v509 = v540 + v508;
    v285 = v764 + v284;
    v317 = v732 + v316;
    v349 = v700 + v348;
    v381 = v668 + v380;
    v157 = v896 + v156;
    v189 = v863 + v188;
    v221 = v830 + v220;
    v253 = v797 + v252;
    v29 = v1028 + v28;
    v61 = v995 + v60;
    v93 = v962 + v92;
    v125 = v929 + v124;
    v897 = v413 ^ __ROR4__(v896, 25);
    v864 = v445 ^ __ROR4__(v863, 25);
    v831 = v477 ^ __ROR4__(v830, 25);
    v798 = v509 ^ __ROR4__(v797, 25);
    v1029 = v285 ^ __ROR4__(v1028, 25);
    v996 = v317 ^ __ROR4__(v995, 25);
    v963 = v349 ^ __ROR4__(v962, 25);
    v930 = v381 ^ __ROR4__(v929, 25);
    v637 = v157 ^ __ROR4__(v636, 25);
    v605 = v189 ^ __ROR4__(v604, 25);
    v573 = v221 ^ __ROR4__(v572, 25);
    v541 = v253 ^ __ROR4__(v540, 25);
    v765 = v29 ^ __ROR4__(v764, 25);
    v733 = v61 ^ __ROR4__(v732, 25);
    v701 = v93 ^ __ROR4__(v700, 25);
    v669 = v125 ^ __ROR4__(v668, 25);
    v478 = v897 + v477;
    v510 = v864 + v509;
    v414 = v831 + v413;
    v446 = v798 + v445;
    v350 = v1029 + v349;
    v382 = v996 + v381;
    v286 = v963 + v285;
    v318 = v930 + v317;
    v222 = v637 + v221;
    v254 = v605 + v253;
    v158 = v573 + v157;
    v190 = v541 + v189;
    v94 = v765 + v93;
    v126 = v733 + v125;
    v30 = v701 + v29;
    v62 = v669 + v61;
    v1030 = v478 ^ __ROR4__(v1029, 21);
    v997 = v510 ^ __ROR4__(v996, 21);
    v964 = v414 ^ __ROR4__(v963, 21);
    v931 = v446 ^ __ROR4__(v930, 21);
    v898 = v350 ^ __ROR4__(v897, 21);
    v865 = v382 ^ __ROR4__(v864, 21);
    v832 = v286 ^ __ROR4__(v831, 21);
    v799 = v318 ^ __ROR4__(v798, 21);
    v766 = v222 ^ __ROR4__(v765, 21);
    v734 = v254 ^ __ROR4__(v733, 21);
    v702 = v158 ^ __ROR4__(v701, 21);
    v670 = v190 ^ __ROR4__(v669, 21);
    v638 = v94 ^ __ROR4__(v637, 21);
    v606 = v126 ^ __ROR4__(v605, 21);
    v574 = v30 ^ __ROR4__(v573, 21);
    v542 = v62 ^ __ROR4__(v541, 21);
    v511 = v1030 + v510;
    v479 = v997 + v478;
    v447 = v964 + v446;
    v415 = v931 + v414;
    v383 = v898 + v382;
    v351 = v865 + v350;
    v319 = v832 + v318;
    v287 = v799 + v286;
    v255 = v766 + v254;
    v223 = v734 + v222;
    v191 = v702 + v190;
    v159 = v670 + v158;
    v127 = v638 + v126;
    v95 = v606 + v94;
    v63 = v574 + v62;
    v31 = v542 + v30;
    v767 = v511 ^ __ROR4__(v766, 25);
    v735 = v479 ^ __ROR4__(v734, 25);
    v703 = v447 ^ __ROR4__(v702, 25);
    v671 = v415 ^ __ROR4__(v670, 25);
    v639 = v383 ^ __ROR4__(v638, 25);
    v607 = v351 ^ __ROR4__(v606, 25);
    v575 = v319 ^ __ROR4__(v574, 25);
    v543 = v287 ^ __ROR4__(v542, 25);
    v1031 = v255 ^ __ROR4__(v1030, 25);
    v998 = v223 ^ __ROR4__(v997, 25);
    v965 = v191 ^ __ROR4__(v964, 25);
    v932 = v159 ^ __ROR4__(v931, 25);
    v899 = v127 ^ __ROR4__(v898, 25);
    v866 = v95 ^ __ROR4__(v865, 25);
    v833 = v63 ^ __ROR4__(v832, 25);
    v800 = v31 ^ __ROR4__(v799, 25);
    v448 = v767 + v447;
    v416 = v735 + v415;
    v512 = v703 + v511;
    v480 = v671 + v479;
    v320 = v639 + v319;
    v288 = v607 + v287;
    v384 = v575 + v383;
    v352 = v543 + v351;
    v192 = v1031 + v191;
    v160 = v998 + v159;
    v256 = v965 + v255;
    v224 = v932 + v223;
    v64 = v899 + v63;
    v32 = v866 + v31;
    v128 = v833 + v127;
    v96 = v800 + v95;
    v640 = v448 ^ __ROR4__(v639, 21);
    v608 = v416 ^ __ROR4__(v607, 21);
    v576 = v512 ^ __ROR4__(v575, 21);
    v544 = v480 ^ __ROR4__(v543, 21);
    v768 = v320 ^ __ROR4__(v767, 21);
    v736 = v288 ^ __ROR4__(v735, 21);
    v704 = v384 ^ __ROR4__(v703, 21);
    v672 = v352 ^ __ROR4__(v671, 21);
    v900 = v192 ^ __ROR4__(v899, 21);
    v867 = v160 ^ __ROR4__(v866, 21);
    v834 = v256 ^ __ROR4__(v833, 21);
    v801 = v224 ^ __ROR4__(v800, 21);
    v1032 = v64 ^ __ROR4__(v1031, 21);
    v999 = v32 ^ __ROR4__(v998, 21);
    v966 = v128 ^ __ROR4__(v965, 21);
    v933 = v96 ^ __ROR4__(v932, 21);
    v417 = v640 + v416;
    v449 = v608 + v448;
    v481 = v576 + v480;
    v513 = v544 + v512;
    v289 = v768 + v288;
    v321 = v736 + v320;
    v353 = v704 + v352;
    v385 = v672 + v384;
    v161 = v900 + v160;
    v193 = v867 + v192;
    v225 = v834 + v224;
    v257 = v801 + v256;
    v33 = v1032 + v32;
    v65 = v999 + v64;
    v97 = v966 + v96;
    v129 = v933 + v128;
    v901 = v417 ^ __ROR4__(v900, 25);
    v868 = v449 ^ __ROR4__(v867, 25);
    v835 = v481 ^ __ROR4__(v834, 25);
    v802 = v513 ^ __ROR4__(v801, 25);
    v1033 = v289 ^ __ROR4__(v1032, 25);
    v1000 = v321 ^ __ROR4__(v999, 25);
    v967 = v353 ^ __ROR4__(v966, 25);
    v934 = v385 ^ __ROR4__(v933, 25);
    v641 = v161 ^ __ROR4__(v640, 25);
    v609 = v193 ^ __ROR4__(v608, 25);
    v577 = v225 ^ __ROR4__(v576, 25);
    v545 = v257 ^ __ROR4__(v544, 25);
    v769 = v33 ^ __ROR4__(v768, 25);
    v737 = v65 ^ __ROR4__(v736, 25);
    v705 = v97 ^ __ROR4__(v704, 25);
    v673 = v129 ^ __ROR4__(v672, 25);
    v482 = v901 + v481;
    v514 = v868 + v513;
    v418 = v835 + v417;
    v450 = v802 + v449;
    v354 = v1033 + v353;
    v386 = v1000 + v385;
    v290 = v967 + v289;
    v322 = v934 + v321;
    v226 = v641 + v225;
    v258 = v609 + v257;
    v162 = v577 + v161;
    v194 = v545 + v193;
    v98 = v769 + v97;
    v130 = v737 + v129;
    v34 = v705 + v33;
    v66 = v673 + v65;
    v1034 = v482 ^ __ROR4__(v1033, 21);
    v1001 = v514 ^ __ROR4__(v1000, 21);
    v968 = v418 ^ __ROR4__(v967, 21);
    v935 = v450 ^ __ROR4__(v934, 21);
    v902 = v354 ^ __ROR4__(v901, 21);
    v869 = v386 ^ __ROR4__(v868, 21);
    v836 = v290 ^ __ROR4__(v835, 21);
    v803 = v322 ^ __ROR4__(v802, 21);
    v770 = v226 ^ __ROR4__(v769, 21);
    v738 = v258 ^ __ROR4__(v737, 21);
    v706 = v162 ^ __ROR4__(v705, 21);
    v674 = v194 ^ __ROR4__(v673, 21);
    v642 = v98 ^ __ROR4__(v641, 21);
    v610 = v130 ^ __ROR4__(v609, 21);
    v578 = v34 ^ __ROR4__(v577, 21);
    v546 = v66 ^ __ROR4__(v545, 21);
    v515 = v1034 + v514;
    v483 = v1001 + v482;
    v451 = v968 + v450;
    v419 = v935 + v418;
    v387 = v902 + v386;
    v355 = v869 + v354;
    v323 = v836 + v322;
    v291 = v803 + v290;
    v259 = v770 + v258;
    v227 = v738 + v226;
    v195 = v706 + v194;
    v163 = v674 + v162;
    v131 = v642 + v130;
    v99 = v610 + v98;
    v67 = v578 + v66;
    v35 = v546 + v34;
    v771 = v515 ^ __ROR4__(v770, 25);
    v739 = v483 ^ __ROR4__(v738, 25);
    v707 = v451 ^ __ROR4__(v706, 25);
    v675 = v419 ^ __ROR4__(v674, 25);
    v643 = v387 ^ __ROR4__(v642, 25);
    v611 = v355 ^ __ROR4__(v610, 25);
    v579 = v323 ^ __ROR4__(v578, 25);
    v547 = v291 ^ __ROR4__(v546, 25);
    v1035 = v259 ^ __ROR4__(v1034, 25);
    v1002 = v227 ^ __ROR4__(v1001, 25);
    v969 = v195 ^ __ROR4__(v968, 25);
    v936 = v163 ^ __ROR4__(v935, 25);
    v903 = v131 ^ __ROR4__(v902, 25);
    v870 = v99 ^ __ROR4__(v869, 25);
    v837 = v67 ^ __ROR4__(v836, 25);
    v804 = v35 ^ __ROR4__(v803, 25);
    v452 = v771 + v451;
    v420 = v739 + v419;
    v516 = v707 + v515;
    v484 = v675 + v483;
    v324 = v643 + v323;
    v292 = v611 + v291;
    v388 = v579 + v387;
    v356 = v547 + v355;
    v196 = v1035 + v195;
    v164 = v1002 + v163;
    v260 = v969 + v259;
    v228 = v936 + v227;
    v68 = v903 + v67;
    v36 = v870 + v35;
    v132 = v837 + v131;
    v100 = v804 + v99;
    v644 = v452 ^ __ROR4__(v643, 21);
    v612 = v420 ^ __ROR4__(v611, 21);
    v580 = v516 ^ __ROR4__(v579, 21);
    v548 = v484 ^ __ROR4__(v547, 21);
    v772 = v324 ^ __ROR4__(v771, 21);
    v740 = v292 ^ __ROR4__(v739, 21);
    v708 = v388 ^ __ROR4__(v707, 21);
    v676 = v356 ^ __ROR4__(v675, 21);
    v904 = v196 ^ __ROR4__(v903, 21);
    v871 = v164 ^ __ROR4__(v870, 21);
    v838 = v260 ^ __ROR4__(v837, 21);
    v805 = v228 ^ __ROR4__(v804, 21);
    v1036 = v68 ^ __ROR4__(v1035, 21);
    v1003 = v36 ^ __ROR4__(v1002, 21);
    v970 = v132 ^ __ROR4__(v969, 21);
    v937 = v100 ^ __ROR4__(v936, 21);
    v421 = v644 + v420;
    v453 = v612 + v452;
    v485 = v580 + v484;
    v517 = v548 + v516;
    v293 = v772 + v292;
    v325 = v740 + v324;
    v357 = v708 + v356;
    v389 = v676 + v388;
    v165 = v904 + v164;
    v197 = v871 + v196;
    v229 = v838 + v228;
    v261 = v805 + v260;
    v37 = v1036 + v36;
    v69 = v1003 + v68;
    v101 = v970 + v100;
    v133 = v937 + v132;
    v905 = v421 ^ __ROR4__(v904, 25);
    v872 = v453 ^ __ROR4__(v871, 25);
    v839 = v485 ^ __ROR4__(v838, 25);
    v806 = v517 ^ __ROR4__(v805, 25);
    v1037 = v293 ^ __ROR4__(v1036, 25);
    v1004 = v325 ^ __ROR4__(v1003, 25);
    v971 = v357 ^ __ROR4__(v970, 25);
    v938 = v389 ^ __ROR4__(v937, 25);
    v645 = v165 ^ __ROR4__(v644, 25);
    v613 = v197 ^ __ROR4__(v612, 25);
    v581 = v229 ^ __ROR4__(v580, 25);
    v549 = v261 ^ __ROR4__(v548, 25);
    v773 = v37 ^ __ROR4__(v772, 25);
    v741 = v69 ^ __ROR4__(v740, 25);
    v709 = v101 ^ __ROR4__(v708, 25);
    v677 = v133 ^ __ROR4__(v676, 25);
    v486 = v905 + v485;
    v518 = v872 + v517;
    v422 = v839 + v421;
    v454 = v806 + v453;
    v358 = v1037 + v357;
    v390 = v1004 + v389;
    v294 = v971 + v293;
    v326 = v938 + v325;
    v230 = v645 + v229;
    v262 = v613 + v261;
    v166 = v581 + v165;
    v198 = v549 + v197;
    v102 = v773 + v101;
    v134 = v741 + v133;
    v38 = v709 + v37;
    v70 = v677 + v69;
    v1038 = v486 ^ __ROR4__(v1037, 21);
    v1005 = v518 ^ __ROR4__(v1004, 21);
    v972 = v422 ^ __ROR4__(v971, 21);
    v939 = v454 ^ __ROR4__(v938, 21);
    v906 = v358 ^ __ROR4__(v905, 21);
    v873 = v390 ^ __ROR4__(v872, 21);
    v840 = v294 ^ __ROR4__(v839, 21);
    v807 = v326 ^ __ROR4__(v806, 21);
    v774 = v230 ^ __ROR4__(v773, 21);
    v742 = v262 ^ __ROR4__(v741, 21);
    v710 = v166 ^ __ROR4__(v709, 21);
    v678 = v198 ^ __ROR4__(v677, 21);
    v646 = v102 ^ __ROR4__(v645, 21);
    v614 = v134 ^ __ROR4__(v613, 21);
    v582 = v38 ^ __ROR4__(v581, 21);
    v550 = v70 ^ __ROR4__(v549, 21);
    v519 = v1038 + v518;
    v487 = v1005 + v486;
    v455 = v972 + v454;
    v423 = v939 + v422;
    v391 = v906 + v390;
    v359 = v873 + v358;
    v327 = v840 + v326;
    v295 = v807 + v294;
    v263 = v774 + v262;
    v231 = v742 + v230;
    v199 = v710 + v198;
    v167 = v678 + v166;
    v135 = v646 + v134;
    v103 = v614 + v102;
    v71 = v582 + v70;
    v39 = v550 + v38;
    v775 = v519 ^ __ROR4__(v774, 25);
    v743 = v487 ^ __ROR4__(v742, 25);
    v711 = v455 ^ __ROR4__(v710, 25);
    v679 = v423 ^ __ROR4__(v678, 25);
    v647 = v391 ^ __ROR4__(v646, 25);
    v615 = v359 ^ __ROR4__(v614, 25);
    v583 = v327 ^ __ROR4__(v582, 25);
    v551 = v295 ^ __ROR4__(v550, 25);
    v1039 = v263 ^ __ROR4__(v1038, 25);
    v1006 = v231 ^ __ROR4__(v1005, 25);
    v973 = v199 ^ __ROR4__(v972, 25);
    v940 = v167 ^ __ROR4__(v939, 25);
    v907 = v135 ^ __ROR4__(v906, 25);
    v874 = v103 ^ __ROR4__(v873, 25);
    v841 = v71 ^ __ROR4__(v840, 25);
    v808 = v39 ^ __ROR4__(v807, 25);
    v456 = v775 + v455;
    v424 = v743 + v423;
    v520 = v711 + v519;
    v488 = v679 + v487;
    v328 = v647 + v327;
    v296 = v615 + v295;
    v392 = v583 + v391;
    v360 = v551 + v359;
    v200 = v1039 + v199;
    v168 = v1006 + v167;
    v264 = v973 + v263;
    v232 = v940 + v231;
    v72 = v907 + v71;
    v40 = v874 + v39;
    v136 = v841 + v135;
    v104 = v808 + v103;
    v648 = v456 ^ __ROR4__(v647, 21);
    v616 = v424 ^ __ROR4__(v615, 21);
    v584 = v520 ^ __ROR4__(v583, 21);
    v552 = v488 ^ __ROR4__(v551, 21);
    v776 = v328 ^ __ROR4__(v775, 21);
    v744 = v296 ^ __ROR4__(v743, 21);
    v712 = v392 ^ __ROR4__(v711, 21);
    v680 = v360 ^ __ROR4__(v679, 21);
    v908 = v200 ^ __ROR4__(v907, 21);
    v875 = v168 ^ __ROR4__(v874, 21);
    v842 = v264 ^ __ROR4__(v841, 21);
    v809 = v232 ^ __ROR4__(v808, 21);
    v1040 = v72 ^ __ROR4__(v1039, 21);
    v1007 = v40 ^ __ROR4__(v1006, 21);
    v974 = v136 ^ __ROR4__(v973, 21);
    v941 = v104 ^ __ROR4__(v940, 21);
    v425 = v648 + v424;
    v457 = v616 + v456;
    v489 = v584 + v488;
    v521 = v552 + v520;
    v297 = v776 + v296;
    v329 = v744 + v328;
    v361 = v712 + v360;
    v393 = v680 + v392;
    v169 = v908 + v168;
    v201 = v875 + v200;
    v233 = v842 + v232;
    v265 = v809 + v264;
    v41 = v1040 + v40;
    v73 = v1007 + v72;
    v105 = v974 + v104;
    v137 = v941 + v136;
    v909 = v425 ^ __ROR4__(v908, 25);
    v876 = v457 ^ __ROR4__(v875, 25);
    v843 = v489 ^ __ROR4__(v842, 25);
    v810 = v521 ^ __ROR4__(v809, 25);
    v1041 = v297 ^ __ROR4__(v1040, 25);
    v1008 = v329 ^ __ROR4__(v1007, 25);
    v975 = v361 ^ __ROR4__(v974, 25);
    v942 = v393 ^ __ROR4__(v941, 25);
    v649 = v169 ^ __ROR4__(v648, 25);
    v617 = v201 ^ __ROR4__(v616, 25);
    v585 = v233 ^ __ROR4__(v584, 25);
    v553 = v265 ^ __ROR4__(v552, 25);
    v777 = v41 ^ __ROR4__(v776, 25);
    v745 = v73 ^ __ROR4__(v744, 25);
    v713 = v105 ^ __ROR4__(v712, 25);
    v681 = v137 ^ __ROR4__(v680, 25);
    v458 = v909 + v489;
    v490 = v876 + v521;
    v394 = v843 + v425;
    v426 = v810 + v457;
    v330 = v1041 + v361;
    v362 = v1008 + v393;
    v266 = v975 + v297;
    v298 = v942 + v329;
    v202 = v649 + v233;
    v234 = v617 + v265;
    v138 = v585 + v169;
    v170 = v553 + v201;
    v74 = v777 + v105;
    v106 = v745 + v137;
    v10 = v713 + v41;
    v42 = v681 + v73;
    v1010 = v458 ^ __ROR4__(v1041, 21);
    v977 = v490 ^ __ROR4__(v1008, 21);
    v944 = v394 ^ __ROR4__(v975, 21);
    v911 = v426 ^ __ROR4__(v942, 21);
    v878 = v330 ^ __ROR4__(v909, 21);
    v845 = v362 ^ __ROR4__(v876, 21);
    v812 = v266 ^ __ROR4__(v843, 21);
    v779 = v298 ^ __ROR4__(v810, 21);
    v746 = v202 ^ __ROR4__(v777, 21);
    v714 = v234 ^ __ROR4__(v745, 21);
    v682 = v138 ^ __ROR4__(v713, 21);
    v650 = v170 ^ __ROR4__(v681, 21);
    v618 = v74 ^ __ROR4__(v649, 21);
    v586 = v106 ^ __ROR4__(v617, 21);
    v554 = v10 ^ __ROR4__(v585, 21);
    v522 = v42 ^ __ROR4__(v553, 21);
    if ( !i )
      v10 ^= 1u;
  }
  a1[9] = v1010;
  a1[10] = v977;
  a1[11] = v944;
  a1[12] = v911;
  a1[13] = v878;
  a1[14] = v845;
  a1[15] = v812;
  a1[16] = v779;
  a1[17] = v746;
  a1[18] = v714;
  a1[19] = v682;
  a1[20] = v650;
  a1[21] = v618;
  a1[22] = v586;
  a1[23] = v554;
  a1[24] = v522;
  a1[25] = v490;
  a1[26] = v458;
  a1[27] = v426;
  a1[28] = v394;
  a1[29] = v362;
  a1[30] = v330;
  a1[31] = v298;
  a1[32] = v266;
  a1[33] = v234;
  a1[34] = v202;
  a1[35] = v170;
  a1[36] = v138;
  a1[37] = v106;
  a1[38] = v74;
  a1[39] = v42;
  a1[40] = v10;
  for ( j = 0; j < a5; ++j )
    result = sub_19B7F8(a4 + 4 * j, a1[j + 9]);
  return result;
}

//----- (001A31AC) --------------------------------------------------------
void *__fastcall sph_cubehash224_init(int a1)
{
  return sub_19B854(a1, &unk_1DC048);
}

//----- (001A31CC) --------------------------------------------------------
int __fastcall sph_cubehash224(int a1, char *a2, size_t a3)
{
  return sub_19B87C(a1, a2, a3);
}

//----- (001A31EC) --------------------------------------------------------
void *__fastcall sph_cubehash224_close(_DWORD *a1, int a2)
{
  return sph_cubehash224_addbits_and_close(a1, 0, 0, a2);
}

//----- (001A320C) --------------------------------------------------------
void *__fastcall sph_cubehash224_addbits_and_close(_DWORD *a1, char a2, char a3, int a4)
{
  sub_19F464(a1, a2, a3, a4, 7u);
  return sph_cubehash224_init((int)a1);
}

//----- (001A3238) --------------------------------------------------------
void *__fastcall sph_cubehash256_init(int a1)
{
  return sub_19B854(a1, &unk_1DC0C8);
}

//----- (001A3258) --------------------------------------------------------
int __fastcall sph_cubehash256(int a1, char *a2, size_t a3)
{
  return sub_19B87C(a1, a2, a3);
}

//----- (001A3278) --------------------------------------------------------
void *__fastcall sph_cubehash256_close(_DWORD *a1, int a2)
{
  return sph_cubehash256_addbits_and_close(a1, 0, 0, a2);
}

//----- (001A3298) --------------------------------------------------------
void *__fastcall sph_cubehash256_addbits_and_close(_DWORD *a1, char a2, char a3, int a4)
{
  sub_19F464(a1, a2, a3, a4, 8u);
  return sph_cubehash256_init((int)a1);
}

//----- (001A32C4) --------------------------------------------------------
void *__fastcall sph_cubehash384_init(int a1)
{
  return sub_19B854(a1, &unk_1DC148);
}

//----- (001A32E4) --------------------------------------------------------
int __fastcall sph_cubehash384(int a1, char *a2, size_t a3)
{
  return sub_19B87C(a1, a2, a3);
}

//----- (001A3304) --------------------------------------------------------
void *__fastcall sph_cubehash384_close(_DWORD *a1, int a2)
{
  return sph_cubehash384_addbits_and_close(a1, 0, 0, a2);
}

//----- (001A3324) --------------------------------------------------------
void *__fastcall sph_cubehash384_addbits_and_close(_DWORD *a1, char a2, char a3, int a4)
{
  sub_19F464(a1, a2, a3, a4, 0xCu);
  return sph_cubehash384_init((int)a1);
}

//----- (001A3350) --------------------------------------------------------
void *__fastcall sph_cubehash512_init(int a1)
{
  return sub_19B854(a1, &unk_1DC1C8);
}

//----- (001A3370) --------------------------------------------------------
int __fastcall sph_cubehash512(int a1, char *a2, size_t a3)
{
  return sub_19B87C(a1, a2, a3);
}

//----- (001A3390) --------------------------------------------------------
void *__fastcall sph_cubehash512_close(_DWORD *a1, int a2)
{
  return sph_cubehash512_addbits_and_close(a1, 0, 0, a2);
}

//----- (001A33B0) --------------------------------------------------------
void *__fastcall sph_cubehash512_addbits_and_close(_DWORD *a1, char a2, char a3, int a4)
{
  sub_19F464(a1, a2, a3, a4, 0x10u);
  return sph_cubehash512_init((int)a1);
}

//----- (001A363C) --------------------------------------------------------
int __fastcall sub_1A363C(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x1A3632);
  return a1 / a2;
}
// 1A363E: control flows out of bounds to 1A3632

//----- (001A3658) --------------------------------------------------------
int __fastcall sub_1A3658(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x1A3EC4);
  return divsi3_skip_div0_test(a1, a2);
}
// 1A38E8: control flows out of bounds to 1A3EC4

//----- (001A365E) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_1A36A0 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 1A3662: variable 'v2' is possibly undefined

//----- (001A38EC) --------------------------------------------------------
int __fastcall sub_1A38EC(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x1A3EC4);
  return divsi3_skip_div0_test(a1, a2);
}
// 1A38E8: control flows out of bounds to 1A3EC4

//----- (001A3C0C) --------------------------------------------------------
int __fastcall sub_1A3C0C(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x1A3C32);
  return a1;
}
// 1A3C1A: control flows out of bounds to 1A3C32

//----- (001A3C1C) --------------------------------------------------------
int __fastcall sub_1A3C1C(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (001A3E08) --------------------------------------------------------
int __fastcall sub_1A3E08(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x1A3E2C);
  return a1;
}
// 1A3E14: control flows out of bounds to 1A3E2C

//----- (001A3E94) --------------------------------------------------------
int __fastcall sub_1A3E94(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return _udivmoddi4(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (001A3F18) --------------------------------------------------------
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // r4
  int result; // r0
  unsigned int v5; // r6
  unsigned int v6; // r1
  unsigned int v7; // r6
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // r2
  unsigned int v10; // r12
  unsigned __int64 v11; // r4
  int v12; // off
  int v13; // off
  int v14; // kr00_4

  v3 = a1;
  if ( a1 < a2 )
  {
    result = 0;
    goto LABEL_14;
  }
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v3) )
      goto LABEL_5;
    goto LABEL_17;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v3) )
LABEL_17:
    v6 = __clz(a1) + 32;
LABEL_5:
  v7 = v5 - v6;
  v8 = a2 << v7;
  if ( v3 >= a2 << v7 )
  {
    result = 1 << v7;
    v3 -= v8;
  }
  else
  {
    result = 0;
  }
  if ( v7 )
  {
    v9 = v8 >> 1;
    v10 = v7;
    do
    {
      while ( v3 >= v9 )
      {
        v11 = v3 - v9;
        v12 = (v11 + (unsigned int)v11) >> 32;
        LODWORD(v11) = 2 * v11;
        HIDWORD(v11) += v12;
        v3 = v11 + 1;
        if ( !--v10 )
          goto LABEL_13;
      }
      v13 = (v3 + (unsigned int)v3) >> 32;
      LODWORD(v3) = 2 * v3;
      HIDWORD(v3) += v13;
      --v10;
    }
    while ( v10 );
LABEL_13:
    v14 = v3;
    v3 >>= v7;
    result = result + v14 - ((_DWORD)v3 << v7);
  }
LABEL_14:
  if ( a3 )
    *a3 = v3;
  return result;
}
// 1A3F18: invalid function type 'UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp)' has been ignored

//----- (001A402C) --------------------------------------------------------
void __fastcall init(int argc, char **argv, char **envp)
{
  int v6; // r5
  int i; // r4
  void (__fastcall *v8)(int, char **, char **); // r3

  init_proc();
  v6 = &off_1EC258 - &off_1EC254;
  if ( v6 )
  {
    for ( i = 0; i != v6; ++i )
    {
      v8 = (void (__fastcall *)(int, char **, char **))*(&off_1EC254 + i);
      v8(argc, argv, envp);
    }
  }
}
// 1EC254: using guessed type _UNKNOWN *off_1EC254;
// 1EC258: using guessed type _UNKNOWN *off_1EC258;

//----- (001A4074) --------------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=2494 queued=2262 decompiled=2262 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 2262 function(s)"
