/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_11E88();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int sem_wait(sem_t *sem);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int sem_post(sem_t *sem);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// size_t strcspn(const char *s, const char *reject);
// int printf(const char *format, ...);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int inet_pton(int af, const char *cp, void *buf);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// time_t time(time_t *timer);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int ftell(FILE *stream);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *inet_ntoa(struct in_addr in);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// unsigned int sleep(unsigned int seconds);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int pthread_setcancelstate(int state, int *oldstate);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// void *realloc(void *ptr, size_t size);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int strcasecmp(const char *s1, const char *s2);
// void perror(const char *s);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int ioctl(int fd, unsigned int request, ...);
// int __fastcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// double floor(double x);
// int __fastcall strtof(_DWORD, _DWORD); weak
// int __fastcall open64(_DWORD, _DWORD); weak
// char *getenv(const char *name);
// int puts(const char *s);
// int sysinfo(struct sysinfo *info);
// void *malloc(size_t size);
// double log10(double x);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
// int system(const char *command);
// struct tm *localtime(const time_t *timer);
// const __int32_t **_ctype_tolower_loc(void);
// const __int32_t **_ctype_toupper_loc(void);
// int _gmon_start__(void); weak
// int sem_trywait(sem_t *sem);
// int kill(__pid_t pid, int sig);
// const unsigned __int16 **_ctype_b_loc(void);
// void exit(int status);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// int round(void); weak
// char *strchr(const char *s, int c);
// int pthread_setcanceltype(int type, int *oldtype);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int execv(const char *path, char *const argv[]);
// int pthread_attr_init(pthread_attr_t *attr);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// char *_strdup(const char *s);
// int mkdir(const char *path, __mode_t mode);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// void *memset(void *s, int c, size_t n);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// int fgetc(FILE *stream);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// ssize_t write(int fd, const void *buf, size_t n);
// int fileno(FILE *stream);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int access(const char *name, int type);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// char *strtok(char *s, const char *delim);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int shutdown(int fd, int how);
// FILE *popen(const char *command, const char *modes);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// void errx(int status, const char *format, ...);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int listen(int fd, int n);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int pthread_join(pthread_t th, void **thread_return);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __fastcall lldiv(_DWORD); weak
// int fputc(int c, FILE *stream);
// void syslog(int pri, const char *fmt, ...);
// int sscanf(const char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// double exp(double x);
// int remove(const char *filename);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// char *strpbrk(const char *s, const char *accept);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// in_addr_t inet_addr(const char *cp);
// void pthread_testcancel(void);
// struct hostent *gethostbyname(const char *name);
// int fseek(FILE *stream, int off, int whence);
// char *strncat(char *dest, const char *src, size_t n);
// int sem_destroy(sem_t *sem);
// int isatty(int fd);
// int fputs(const char *s, FILE *stream);
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int pclose(FILE *stream);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_13B58();
int deregister_tm_clones();
int register_tm_clones();
int sub_13BCC();
void sub_13BE8();
int __fastcall sub_13C54(unsigned int a1);
void __fastcall sub_13EE8(signed int a1);
int sub_14040();
void sub_1409C();
int sub_14350();
int sub_143B4();
int sub_14420();
int sub_14484();
int __fastcall sub_144E8(int a1, int a2);
int __fastcall sub_14528(int a1, int a2, int a3, int a4, unsigned __int8 *a5);
int __fastcall sub_146C4(int a1);
int __fastcall sub_148B4(pthread_rwlock_t *a1);
void __fastcall sub_14930(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_1493C(pthread_mutex_t *a1);
void __fastcall sub_149B8(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_149C4(pthread_rwlock_t *a1, const char *a2, int a3);
void __fastcall sub_14A34(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_14A40(const char *a1, int a2);
void __fastcall sub_14A98(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_14AA4(const char *a1, int a2);
void __fastcall sub_14AFC(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_14B08(const char *a1, int a2);
void __fastcall sub_14B60(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void sub_14B6C();
void sub_14BF4();
int sub_15C50();
int sub_15DA8();
int sub_15E0C();
void __fastcall sub_15E90(int a1);
int __fastcall sub_1691C(int a1, int a2);
int sub_16940();
int sub_169E4();
int sub_16A8C();
int sub_16B30();
int __fastcall sub_16BD4(int a1);
int __fastcall sub_16C84(int a1);
int __fastcall sub_16D34(int a1);
int __fastcall sub_16DE4(int a1);
int __fastcall sub_16E94(int a1, int a2);
int __fastcall sub_17028(int a1, int a2);
int sub_171C0();
int sub_17264();
int sub_17308();
const char *sub_1758C();
int __fastcall sub_17598(int a1, char a2);
int __fastcall sub_175E4(int result);
_DWORD *__fastcall sub_175F4(_DWORD *result);
void __fastcall sub_17614(int a1, int a2, int a3, int a4);
void sub_1774C();
void sub_177D8();
int sub_1782C();
int __fastcall sub_17968(char *a1, int a2, char *s1, _BYTE *a4, size_t n);
int __fastcall sub_17A14(char *a1, char *a2, size_t n);
void __fastcall sub_17AF8(int a1);
int __fastcall sub_17C28(char a1, _BYTE *a2, _BYTE *a3);
void __fastcall sub_17CE0(unsigned __int16 *a1);
void __fastcall sub_17FF8(int a1);
void __fastcall sub_1823C(int a1, unsigned __int16 *a2);
void sub_182D4();
void __fastcall sub_185FC(int a1);
int sub_18650();
int sub_188CC();
int sub_188E0();
int __fastcall sub_1893C(int a1);
int __fastcall sub_189C8(int a1);
int __fastcall sub_18A54(int a1);
int __fastcall sub_18AE0(int a1);
int __fastcall sub_18B6C(int a1);
int __fastcall sub_18BF8(int a1);
int __fastcall sub_18C84(int a1);
int __fastcall sub_18D10(int a1, int a2, int a3);
int __fastcall sub_18E08(int a1, int a2, _DWORD *a3);
int __fastcall sub_18EE4(int a1, int a2, _DWORD *a3);
int __fastcall sub_18FC0(int a1, int a2);
int __fastcall sub_19098(int a1, int a2, void *src); // idb
int __fastcall sub_19190(int a1, char a2);
int __fastcall sub_19228(int a1, char a2);
int sub_1942C();
int __fastcall sub_19720(unsigned int a1, unsigned int a2);
int sub_19750();
bool __fastcall sub_19780(unsigned int a1);
int __fastcall sub_19798(_DWORD); // weak
int __fastcall sub_1979C(_DWORD); // weak
bool __fastcall sub_197A0(unsigned int a1);
void __fastcall sub_197B8(int a1);
int sub_19868();
int sub_19BB4();
int __fastcall sub_19CA0(int a1);
int __fastcall sub_19D18(int a1, int a2);
unsigned int sub_19E68();
unsigned int sub_19E7C();
int sub_19E90();
void __fastcall sub_1A0F0(int a1);
void __fastcall sub_1A150(int a1);
int sub_1A1B0();
int sub_1A1C0();
int sub_1A1D0();
int sub_1A1E0();
int sub_1A240();
int sub_1A2A0();
int sub_1A300();
int __fastcall sub_1A360(int a1);
int sub_1A3B8();
int sub_1A420();
int sub_1A488();
int __fastcall sub_1A4F0(int a1);
int __fastcall sub_1A79C(int result);
int sub_1A7AC();
int __fastcall sub_1A7C0(int a1);
int sub_1A850();
int __fastcall sub_1A894(unsigned int a1, int a2);
int __fastcall sub_1A89C(unsigned int a1, int a2);
int __fastcall sub_1A8A4(unsigned int a1);
void __fastcall sub_1A8AC(unsigned int a1, int a2);
int __fastcall sub_1A954(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall sub_1A958(int result, int a2, int a3, char a4);
int __fastcall sub_1A9D4(int a1);
int __fastcall sub_1AA2C(_DWORD); // weak
void __fastcall sub_1AA30(int a1, int a2, int a3);
int __fastcall sub_1AC10(unsigned int a1);
unsigned int __fastcall sub_1AC60(__int16 a1);
int sub_1ACE4();
int __fastcall sub_1AD6C(int result, int a2, char a3, char a4);
int __fastcall sub_1ADD4(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, int a4, unsigned __int8 a5, unsigned __int8 a6);
int sub_1AE00();
int __fastcall sub_1AF48(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_1B010(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33);
int __fastcall sub_1B0EC(int a1, char a2);
int __fastcall sub_1B138(int a1, char a2, char a3, char a4);
int sub_1B194();
int __fastcall sub_1B1F4(int result, int a2, int a3, unsigned int a4, int a5, __int16 a6);
void __fastcall sub_1B298(int a1, int a2);
int __fastcall sub_1B2F8(int result);
const char *__fastcall sub_1B340(int a1, char a2);
const char *__fastcall sub_1B358(int a1, char a2);
const char *__fastcall sub_1B370(int a1, char a2);
const char *__fastcall sub_1B394(int a1, char a2);
const char *__fastcall sub_1B3B8(int a1, char a2);
const char *__fastcall sub_1B440(int a1, char a2);
int __fastcall nullsub_2(_DWORD, _DWORD); // weak
const char *__fastcall sub_1B6E0(int a1);
const char *__fastcall sub_1B780(int a1);
const char *__fastcall sub_1B7DC(int a1, char a2);
const char *__fastcall sub_1B7F4(int a1);
const char *__fastcall sub_1B8D0(int a1);
const char *__fastcall sub_1B964(int a1);
const char *__fastcall sub_1BA48(int a1);
const char *__fastcall sub_1BAE8(int a1, char a2);
const char *__fastcall sub_1BB20(int a1);
const char *__fastcall sub_1BBE0(int a1, char a2);
const char *__fastcall sub_1BBF8(int a1, char a2);
const char *__fastcall sub_1BC68(int a1, char a2);
const char *__fastcall sub_1BCD4(int a1, char a2);
const char *__fastcall sub_1BD40(int a1, char a2);
const char *__fastcall sub_1BDA4(const char *a1, char a2);
const char *__fastcall sub_1BED0(const char *a1, char a2);
const char *__fastcall sub_1BF54(const char *a1, char a2);
_DWORD *__fastcall sub_1BFE0(_DWORD *result);
int __fastcall sub_1C054(_DWORD *a1, unsigned int *a2);
int *__fastcall sub_1E4B4(int *result, unsigned int *a2, signed int a3);
int *__fastcall sub_1E580(int *result, unsigned int *a2, signed int a3);
int *__fastcall sub_1E58C(int a1, _BYTE *a2);
int *__fastcall sub_1E740(unsigned int *a1, signed int a2, _BYTE *a3);
int __fastcall sub_1E7E8(char *a1, size_t a2, int a3);
int __fastcall sub_1E884(char *a1);
int __fastcall sub_1E990(int a1, char *a2, size_t a3);
void sub_1EE10();
int __fastcall sub_1EE28(int a1);
int sub_1FA04();
void sub_1FD84();
char *__fastcall sub_1FEA0(const char *a1);
int __fastcall sub_203C8(char *a1);
void __noreturn sub_204A8();
int sub_205BC();
void sub_206E0();
void __noreturn sub_20880();
void __noreturn sub_2090C();
time_t sub_20998();
time_t sub_20A08();
void sub_20A38();
time_t sub_20B28();
int sub_20B48();
void sub_20E60();
int sub_20EC8();
void __noreturn sub_20F90();
int sub_21140();
void __noreturn sub_21478();
int sub_21578();
int sub_21690();
int sub_217A8();
int sub_218C0();
int sub_218C8();
int sub_219E0();
void sub_21AF8();
void sub_21B98();
void sub_21C38();
void sub_21CDC();
void sub_21D7C();
int __fastcall sub_21E78(int a1);
int sub_21F2C();
int __fastcall sub_21F4C(int result);
void __fastcall sub_22088(unsigned int *a1);
void sub_222E8();
char *__fastcall sub_2236C(char *a1, int a2);
void sub_225B4();
int sub_225FC();
int sub_226B0();
void __fastcall sub_226C0(unsigned int a1, const char *a2);
int sub_228FC();
int __fastcall sub_22990(int a1);
int __fastcall sub_22A2C(int a1, int a2);
int __fastcall sub_22A54(int result);
unsigned int sub_22A64();
int __fastcall sub_22A88(int a1);
int sub_22AB8();
int sub_22B10();
int sub_22D34();
int sub_22DD8();
void __fastcall sub_22E9C(unsigned int a1, int a2, int a3);
void sub_23034();
void sub_2306C();
char *sub_23150();
int sub_2321C();
int sub_23298();
int sub_23590();
int sub_239C4();
int sub_23BF0();
int sub_23CC8();
void sub_23D44();
size_t __fastcall sub_23D5C(_DWORD *a1, int a2, int a3);
int __fastcall sub_23FD4(unsigned __int8 *a1);
unsigned int sub_24418();
int __fastcall sub_24434(int result, int a2);
int __fastcall sub_24848(int result);
int sub_24858();
void sub_24904();
int sub_249A8();
int sub_249B0();
int sub_24B88();
int __fastcall sub_25098(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int sub_257E4();
int __fastcall sub_259F4(const void *a1, size_t a2);
int __fastcall sub_25A28(const void *a1, size_t a2);
int sub_25A5C();
int __fastcall sub_25AEC(pthread_rwlock_t *a1, int a2);
void __fastcall __noreturn sub_25B64(int a1);
void __fastcall sub_25BBC(int a1, int a2, int a3, int a4, int a5, int a6);
int __fastcall sub_25BC4(int a1, int a2);
char *__fastcall sub_25BFC(size_t *a1, const char **a2, int a3, char a4);
int __fastcall sub_25DA0(int a1, const char **a2, int a3, char a4);
int __fastcall sub_25E54(const char *a1);
int sub_25FA8();
int __fastcall sub_26080(const char *a1, int a2);
void __fastcall sub_26118(_DWORD *a1, int a2, int a3);
int __fastcall sub_263C0(const void *a1, int a2);
size_t __fastcall sub_26874(int *a1);
char *__fastcall sub_269B8(int a1, size_t *a2);
int __fastcall sub_26B54(int a1, size_t *a2);
void __fastcall sub_26B60(int a1);
const char *__fastcall sub_26BCC(int a1);
int sub_26C30();
int sub_26D7C();
void __fastcall sub_26D84(int a1, const char **a2);
void __fastcall sub_26F38(unsigned int *a1);
void __fastcall sub_270B8(unsigned int *a1);
void __fastcall sub_271F8(unsigned int *a1);
void __fastcall sub_27578(unsigned int *a1);
void __fastcall sub_276F8(int *a1);
void __fastcall sub_277E4(unsigned int *a1);
void __fastcall sub_279A4(unsigned int *a1);
void __fastcall sub_27EE4(unsigned int *a1);
void __fastcall sub_280E4(unsigned int *a1);
void __fastcall sub_28424(unsigned int *a1);
void __fastcall sub_28864(unsigned int *a1);
void __fastcall sub_28BE4(unsigned int *a1);
void __fastcall sub_28F24(unsigned int *a1);
void __fastcall sub_29264(unsigned int *a1);
void __fastcall sub_29724(unsigned int *a1);
void __fastcall sub_29C24(unsigned int *a1);
int __fastcall sub_2A0A4(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_2A248(_BYTE *a1, char a2, char a3);
void *__fastcall sub_2A29C(_DWORD *a1, const void *a2, size_t a3);
int __fastcall sub_2A2D8(int a1, char a2, char a3);
int __fastcall sub_2A324(int a1, int a2, int a3, int a4);
void __fastcall sub_2A3B8(int a1, int a2);
void __fastcall sub_2BBB8(int a1, unsigned int *a2);
void sub_2BC3C();
void __fastcall sub_2BC80(unsigned int *a1);
void __fastcall sub_2BEC8(unsigned int *a1);
void __fastcall sub_2C050(unsigned int *a1);
void __fastcall sub_2C144(unsigned int *a1);
void __fastcall sub_2C2CC(unsigned int *a1);
void __fastcall sub_2C414(unsigned int *a1);
void __fastcall sub_2C508(unsigned int *a1);
void __fastcall sub_2C5FC(unsigned int *a1);
void __fastcall sub_2C844(unsigned int *a1);
void __fastcall sub_2CA8C(unsigned int *a1);
void __fastcall sub_2CBD4(unsigned int *a1);
void __fastcall sub_2CD1C(unsigned int *a1);
void __fastcall sub_2CE10(unsigned int *a1);
void __fastcall sub_2CF58(unsigned int *a1);
void __fastcall sub_2D0E0(unsigned int *a1);
void __fastcall sub_2D2E8(unsigned int *a1);
void __fastcall sub_2D5F0(int a1, unsigned int *a2);
int __fastcall sub_2D700(int result, char a2, char a3);
int __fastcall sub_2D744(int result, char a2);
int __fastcall sub_2D788(int result, char a2, char a3);
void __fastcall sub_2D7C8(int a1, char a2, char a3, int a4);
int __fastcall sub_2D868(int a1, char a2, char a3, char a4);
int __fastcall sub_2D8E4(int a1, char a2, char a3);
int __fastcall sub_2D958(int a1, char a2, char a3, char a4);
void __fastcall sub_2D9CC(int a1, unsigned int *a2);
int __fastcall sub_2DA50(int a1, unsigned int a2, unsigned int a3);
void __fastcall sub_2DB40(int a1, unsigned int a2, int a3);
int __fastcall sub_2DC90(int a1, int a2, int a3);
int __fastcall sub_2DF9C(int a1, int a2);
void __fastcall sub_2E180(int a1, unsigned int a2, int a3);
void __fastcall sub_2E4F8(int a1, unsigned int a2, int a3);
void __fastcall sub_2E6D4(int a1, unsigned int a2);
void __fastcall sub_2E81C(int a1, unsigned int a2, int a3, int a4);
int sub_2E9B8();
int sub_2E9F0();
int __fastcall sub_2EA28(int a1, int a2);
int __fastcall sub_2EC38(int a1, int a2, int a3);
void __fastcall sub_2EE74(int a1);
void __fastcall sub_2F194(int a1);
void sub_2F354();
int __fastcall sub_2F530(int a1, unsigned int a2);
void sub_2F5AC();
char *sub_2F7DC();
void __fastcall sub_2F7EC(int a1, int a2);
void sub_2F930();
void sub_2F984();
int __fastcall sub_3011C(int a1, int a2);
int __fastcall sub_3012C(int a1, int a2);
int __fastcall sub_3013C(_DWORD *a1, _DWORD *a2);
int __fastcall sub_3014C(int a1, _DWORD *a2, int a3, int a4);
int sub_301EC();
int sub_30348();
int sub_3047C();
int __fastcall sub_3050C(int a1, int a2);
int __fastcall sub_30524(int a1, int a2);
int __fastcall sub_30540(int a1, int a2);
int __fastcall sub_3055C(int a1, int a2);
int sub_30578();
int __fastcall sub_30580(int a1);
int sub_305A8();
int __fastcall sub_306F0(int a1, int a2);
void __fastcall sub_30770(int a1, unsigned int a2, int a3, int a4);
unsigned int __fastcall sub_30B64(int a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5, unsigned __int8 a6);
int __fastcall sub_30CAC(int a1, unsigned int a2, unsigned int a3, int a4);
int __fastcall sub_31224(int a1, unsigned int a2, int a3);
unsigned int sub_312D8();
void __fastcall sub_31368(_BYTE *a1);
int __fastcall sub_313F8(int result);
void *__fastcall sub_31408(void *a1);
int __fastcall sub_3142C(int result);
_DWORD *__fastcall sub_3143C(_DWORD *result);
int __fastcall sub_3145C(int a1);
int __fastcall sub_314BC(int a1);
int __fastcall sub_31538(_BYTE *a1, unsigned __int8 *a2, int a3);
unsigned int __fastcall sub_31658(_DWORD *a1, unsigned int a2);
void __fastcall sub_31794(int a1, int a2);
int *sub_31ABC();
int sub_31ACC();
bool __fastcall sub_31B48(int a1);
int __fastcall sub_31BC8(int a1);
int sub_31CE8();
void *sub_31DA8();
void *sub_31E2C();
void sub_31F44();
void sub_31FE0();
int sub_3203C();
void __fastcall sub_321E0(int a1, int a2, unsigned int a3, int a4);
void __fastcall sub_322E4(int a1);
bool __fastcall sub_323A0(int a1);
bool sub_32450();
int __fastcall sub_324A8(int a1, __useconds_t *a2);
char **sub_32B3C();
int sub_32BB0();
bool __fastcall sub_32BC4(int a1);
int __fastcall sub_32C44(int a1);
void *sub_32D48();
int __fastcall sub_32D68(int a1);
unsigned int __fastcall sub_331AC(int a1);
void sub_33428();
void sub_33490();
int __fastcall sub_334A8(FILE **a1, int a2, int a3, int a4);
int __fastcall sub_33618(int a1);
char **sub_33918();
void __noreturn sub_33988();
int sub_33A7C();
void sub_33B7C();
int __fastcall sub_33C2C(int a1, int a2);
int __fastcall sub_33E28(int a1);
int __fastcall sub_3405C(int **a1, int a2, int a3);
int sub_344E0();
int __fastcall sub_34568(int a1);
int __fastcall sub_36B40(int *a1);
int sub_36C34();
int __fastcall sub_36C44(int result);
int __fastcall sub_36C54(int result);
_DWORD *__fastcall sub_36C64(_DWORD *a1);
int __fastcall sub_36CA4(_DWORD *a1, _DWORD *a2);
void __fastcall sub_36CB4(int a1, int a2);
void sub_36E34();
int __fastcall sub_36E78(_DWORD *a1);
int sub_36F30();
void __fastcall sub_36F78(int a1);
void __fastcall sub_3702C(int a1);
int __fastcall sub_371E8(int a1, const char *a2);
void sub_373BC();
void sub_374D4();
void sub_37594();
char *__fastcall sub_3762C(char *result);
void __fastcall sub_376A4(char *a1);
int sub_37770();
int __fastcall sub_37834(int a1);
int sub_378DC();
int __fastcall sub_37994(int a1);
int sub_37A68();
int __fastcall sub_37B2C(int a1);
void __fastcall sub_37BD4(int a1, int a2);
int __fastcall sub_37D44(int a1);
void sub_37E60();
int sub_37EF8();
int sub_37F50();
void __fastcall sub_37FA8(unsigned int a1);
void sub_38064();
int __fastcall sub_3816C(int a1);
int sub_383C0();
int sub_384D8();
int __fastcall sub_385EC(int a1);
void __fastcall sub_3883C(int a1, int a2);
int __fastcall sub_38ECC(int a1);
void __fastcall sub_38EEC(char *a1, int a2, unsigned int a3);
void __fastcall sub_39138(int a1);
int sub_3954C();
int __fastcall sub_39574(int a1, unsigned int a2, int a3, unsigned int a4);
int sub_3997C();
void sub_39AB4();
int __fastcall sub_39B70(int a1);
int __fastcall sub_39B88(int a1);
int __fastcall sub_39BEC(int a1);
void sub_39C04();
int __fastcall sub_39F80(int a1);
unsigned int __fastcall sub_3A3C4(int a1, int a2);
unsigned int __fastcall sub_3A458(int a1, int a2);
unsigned int __fastcall sub_3A520(int a1, int a2);
int __fastcall sub_3A5E8(int a1);
void __fastcall sub_3A79C(int a1, int a2, int a3);
int sub_3AA80();
int __fastcall sub_3AAA8(int a1);
void sub_3B4EC();
int __fastcall sub_3B5A8(int a1);
int __fastcall sub_3B5C4(int a1, int a2);
int __fastcall sub_3B658(int a1);
void sub_3B674();
int __fastcall sub_3BBE8(int a1);
int sub_3BD34();
int __fastcall sub_3C398(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_3C4FC(int a1);
int __fastcall sub_3C620(int a1);
int sub_3C640();
int __fastcall sub_3C6A4(int a1);
int sub_3C6CC();
int __fastcall sub_3C770(unsigned int *a1, char *s);
int __fastcall sub_3C804(int a1, int a2, int a3, int a4);
int __fastcall sub_3C850(int a1, int a2, int a3, int a4);
const char *__fastcall sub_3C89C(const char *s, int a2);
void sub_3CA70();
void __fastcall sub_3CA78(unsigned int *a1, char *s, int a3, _BYTE *a4);
bool __fastcall sub_3CB84(const struct sockaddr *a1, const char **a2, _BYTE *a3);
int sub_3CD2C();
void sub_3D8E4();
int __fastcall sub_3D8EC(int a1);
int __fastcall sub_3D924(int result, int a2);
void *__fastcall sub_3D988(char ***a1, char *s);
void __fastcall sub_3DAA0(const char *a1, int a2, int a3, int a4);
int __fastcall sub_3DFAC(unsigned __int8 **a1, int *a2);
int __fastcall sub_3E02C(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
void __fastcall __noreturn sub_3E12C(const char *a1, int a2);
void __fastcall sub_3E184(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_3E190(const char *a1, int a2);
void __fastcall __noreturn sub_3E1F4(const char *a1, int a2);
void __fastcall __noreturn sub_3E258(const char *a1, int a2);
void __fastcall sub_3E2B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int sub_3E2BC();
int __fastcall sub_3E378(int a1);
int __fastcall sub_3E48C(int *a1);
void __noreturn sub_3E580();
int sub_3E708();
int __fastcall sub_3E88C(unsigned int *a1, char **a2, int a3, int a4);
const char *__fastcall sub_3F3D8(int a1, const char *a2, int a3, const char *a4, char a5);
int __fastcall sub_3F65C(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5);
int __fastcall sub_3FA78(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
void __fastcall sub_3FA8C(unsigned int *a1, int a2, const char *a3, int a4);
int __fastcall sub_3FB70(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_3FD78(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_40328(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_4033C(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_404C8(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_404DC(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_4062C(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4);
void __fastcall sub_406D4(unsigned int *a1, int a2, const char *a3, int a4);
int __fastcall sub_40858(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_4099C(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_40ABC(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5);
int __fastcall sub_40C04(unsigned int *a1, int a2, char *s, int a4);
void __fastcall sub_40E64(unsigned int *a1, int a2, char *a3, int a4);
int __fastcall sub_40F6C(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_41120(int a1, int a2, int a3, int a4);
int __fastcall sub_41200(int a1, int a2, _BYTE *a3, int a4);
int __fastcall sub_415C4(int a1, int a2, const char *a3, int a4, unsigned __int8 a5);
int __fastcall sub_4183C(int a1, int a2, int a3, int a4);
int __fastcall sub_41A18(int a1, int a2, int a3, int a4);
int __fastcall sub_41AEC(int a1, int a2, int a3, int a4);
int __fastcall sub_41E1C(int a1, int a2, int a3, int a4);
int __fastcall sub_41FD4(int a1, int a2, int a3, int a4);
int __fastcall sub_42198(unsigned int *a1, int a2, int a3, int a4);
int __fastcall sub_428AC(int a1, int a2, int a3, int a4);
int __fastcall sub_43158(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6);
int __fastcall sub_433A8(int a1, int a2, int a3, int a4);
int __fastcall sub_434B8(int a1, int a2, int a3, int a4);
int __fastcall sub_436DC(int a1, int a2, int a3, int a4);
const char *__fastcall sub_43D0C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43D2C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43D4C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43D6C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43D8C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43DAC(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43DCC(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43DEC(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43E0C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43E2C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43E4C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43E6C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43E8C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43EAC(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43ECC(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43EEC(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43F0C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43F2C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43F4C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43F6C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43F8C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43FAC(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43FCC(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_43FEC(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_4400C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_4402C(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_4404C(int a1, const char *a2, const char *a3, char a4);
void sub_4406C();
void __fastcall sub_440C0(int *a1);
int __fastcall sub_44518(unsigned int *a1, int a2, int a3, int a4);
int __fastcall sub_44724(int a1, int a2, int a3, int a4);
int sub_447FC();
double sub_448C4();
void sub_4490C();
void *__fastcall sub_46870(const char **a1, const char *a2, const char *a3, int a4);
_DWORD *__fastcall sub_46BAC(int a1);
_BYTE *__fastcall sub_46C54(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8);
int __fastcall sub_46F04(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_46F8C(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_46FB8(int a1, const char *a2, const char *a3, int a4);
const char *__fastcall sub_47080(int a1, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_47154(const char **result, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_472A0(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char **__fastcall sub_473E8(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char *__fastcall sub_4753C(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_47628(const char **a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_47798(const char **a1, int a2, const char *a3, const char *a4, int a5);
int __fastcall sub_47904(const char **a1, const char *a2, const char *a3, int a4);
int __fastcall sub_47A20(const char **ptr, const char *a2, const char *a3, int a4);
void __fastcall sub_47AB4(int a1, const char *a2, int a3);
int __fastcall sub_47C94(int a1);
void __fastcall sub_47D0C(int a1, int a2, int a3, int a4, int a5, int a6);
int sub_47D14();
void __fastcall sub_47D94(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_47DA0(const char *a1, const char *a2, int a3);
void __fastcall sub_47E18(int a1, const char *a2, int a3);
void __fastcall sub_47EC8(int a1, const char *a2, int a3);
__int64 __fastcall sub_480A0(int a1, _QWORD *a2, _QWORD *a3);
int __fastcall sub_484D8(int result, unsigned __int8 *a2, int a3);
_DWORD *__fastcall sub_486D4(_DWORD *result);
void *__fastcall sub_48704(unsigned __int8 *a1, char *a2, size_t n);
int __fastcall sub_487B0(_DWORD *a1, _BYTE *a2);
int __fastcall sub_4889C(char *a1, size_t n, _BYTE *a3);
int sub_48900();
int __fastcall sub_48908(int a1, char *s, int a3);
int __fastcall sub_48B74(const char **a1, int a2, int a3);
int __fastcall sub_49028(int a1);
int __fastcall sub_49068(int a1);
bool __fastcall sub_49090(int a1, int a2);
_DWORD *__fastcall sub_49124(_DWORD *a1, unsigned int a2);
char *__fastcall sub_49188(_DWORD *a1, unsigned int a2);
void __fastcall __noreturn sub_491A0(const void *a1, const char *a2, const char *a3, int a4);
void __fastcall sub_491FC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_49208(const char *a1, const char *a2, int a3);
int __fastcall sub_49358(pthread_rwlock_t *a1, const char *a2, int a3);
void __fastcall sub_493C8(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_493D4(pthread_rwlock_t *a1, const char *a2, int a3);
void __fastcall sub_49444(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_49450(pthread_mutex_t *a1, const char *a2, int a3);
void __fastcall sub_494C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_494CC(const char *a1, int a2);
void __fastcall sub_49524(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_49530(int a1);
int __fastcall sub_495C0(int a1, char a2);
void *__fastcall sub_49624(size_t a1, const char *a2, const char *a3, int a4);
void __fastcall sub_496A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void *__fastcall sub_496AC(size_t a1, size_t a2, const char *a3, const char *a4, int a5);
void __fastcall sub_49730(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void *__fastcall sub_4973C(void *a1, size_t a2, const char *a3, const char *a4, int a5);
void __fastcall sub_497C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
char *__fastcall sub_497D0(char *a1);
_BYTE *__fastcall sub_4981C(_BYTE *result, int a2, int a3);
_BYTE *__fastcall sub_4988C(int a1, int a2);
int __fastcall sub_49940(_BYTE *a1, unsigned __int8 *a2, int a3);
void __fastcall sub_49AE4(int a1, char *s);
size_t __fastcall sub_49C54(_BYTE *a1, char *s);
int __fastcall sub_49D2C(int a1, int a2);
int __fastcall sub_49D78(unsigned int *a1, unsigned int *a2);
char *sub_49F68();
void __fastcall sub_49FC4(char *a1);
int __fastcall sub_4A02C(int a1);
int __fastcall sub_4A034(int a1);
int __fastcall sub_4A03C(int a1, int a2);
int __fastcall sub_4A110(int a1, const struct timespec *a2);
int __fastcall sub_4A1F0(int result);
_DWORD *__fastcall sub_4A22C(_DWORD *result, int *a2);
_DWORD *__fastcall sub_4A260(_DWORD *result, int *a2);
bool __fastcall sub_4A2A4(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_4A2D8(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_4A30C(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_4A33C(_DWORD *result, _DWORD *a2);
int __fastcall sub_4A358(_QWORD *a1);
int __fastcall sub_4A390(_QWORD *a1);
int __fastcall sub_4A3D0(_QWORD *a1);
int __fastcall sub_4A410(_QWORD *a1);
_DWORD *__fastcall sub_4A44C(_DWORD *result, _DWORD *a2);
const char *__fastcall sub_4A5C4(const char **a1, const char *a2);
int __fastcall sub_4A60C(struct timeval *a1);
int __fastcall sub_4A614(_DWORD *a1);
int __fastcall sub_4A644(_DWORD *a1, _DWORD *a2, int *a3);
int __fastcall sub_4A680(struct timespec *a1);
int __fastcall sub_4A68C(int *a1);
int __fastcall sub_4A74C(int *a1);
int sub_4A804();
int sub_4A830();
_DWORD *__fastcall sub_4A864(_DWORD *result, _DWORD *a2);
void sub_4A8FC();
int __fastcall sub_4A940(const char *a1, _DWORD *a2, char **a3);
char *__fastcall sub_4AAB4(char *s1, int a2);
bool __fastcall sub_4AB90(int a1);
void **__fastcall sub_4ABB0(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6);
int __fastcall sub_4AC1C(unsigned int a1, int a2);
int __fastcall sub_4AC60(_DWORD *a1, int a2);
int __fastcall sub_4AFA8(int a1);
int __fastcall sub_4B10C(int a1, char *a2, int a3);
char *__fastcall sub_4B4C0(int a1);
time_t __fastcall sub_4BA2C(_DWORD *a1, int a2);
char *__fastcall sub_4BB1C(char *a1, char *s);
char *__fastcall sub_4BBF0(const char *a1);
int __fastcall sub_4BD10(const char *a1);
int __fastcall sub_4BD50(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_4BDCC(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4);
int __fastcall sub_4BE14(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_4BE4C(int a1);
int __fastcall sub_4BE90(sem_t *sem, const char *a2, const char *a3, int a4);
int __fastcall sub_4BF10(sem_t *a1, int a2, const char *a3, const char *a4, int a5);
void sub_4C044();
int *__fastcall sub_4C04C(sem_t *sem);
bool __fastcall sub_4C084(int a1, int a2, int a3);
void __fastcall sub_4C150(void *a1, const void *a2, size_t a3, int a4, int a5, int a6);
void __fastcall sub_4C460(void *a1, const void *a2);
int __fastcall sub_4C494(int a1, _DWORD *a2);
int __fastcall sub_4D498(const char **a1, int a2, int a3);
int __fastcall sub_4D754(_DWORD *a1);
int __fastcall sub_4F2F8(int a1);
int __fastcall sub_4F374(_DWORD *a1, _DWORD *a2);
int __fastcall sub_4F748(_DWORD *a1, int a2);
int __fastcall sub_50324(_DWORD *a1, int a2);
int __fastcall sub_50338(_DWORD *a1);
int __fastcall sub_50730(_DWORD *a1);
int __fastcall sub_50AE0(int *a1, _DWORD *a2, _DWORD *a3);
_BYTE *__fastcall sub_50B5C(_BYTE *result, int a2);
int __fastcall sub_50B9C(int result, char a2);
void __fastcall sub_50E84(int a1, char *a2, int a3);
void __fastcall sub_514A4(int a1, char *a2, int a3);
void __fastcall sub_514BC(int a1, int a2, int a3);
int __fastcall sub_514F8(int a1, int a2);
int __fastcall sub_51554(_BYTE *a1, unsigned int a2);
int __fastcall sub_5162C(int result, unsigned int *a2, unsigned int a3);
int __fastcall sub_51658(_DWORD *a1);
int __fastcall sub_51668(_DWORD *a1);
int __fastcall sub_51678(_DWORD *a1);
int __fastcall sub_51688(_BYTE *a1);
int sub_516A4();
int nullsub_10(); // weak
int nullsub_3(); // weak
int sub_516B4();
__int64 sub_516BC();
int sub_516C8();
int nullsub_11(); // weak
int sub_516D4();
int __fastcall sub_516DC(int result);
int __fastcall sub_516F8(int a1);
int __fastcall sub_51710(int a1);
int __fastcall sub_51728(int a1);
int __fastcall sub_51740(int a1);
int __fastcall sub_51758(int a1);
int __fastcall sub_51770(int a1);
_BYTE *__fastcall sub_5199C(const char *a1);
void __fastcall __noreturn sub_51A54(const char *a1);
time_t __fastcall sub_51AAC(int a1);
time_t __fastcall sub_51AE4(int a1);
int __fastcall sub_51B18(unsigned __int64 a1, char *s, size_t maxlen, int a4);
int __fastcall sub_51DD0(int a1);
int sub_51E24();
void __noreturn sub_51E38();
int __fastcall sub_51E60(int a1);
int __fastcall sub_51EEC(int a1);
const char *__fastcall sub_51F54(const char *a1);
char *__fastcall sub_51FC0(char *a1);
char *__fastcall sub_520B4(_DWORD *a1, int a2);
char *__fastcall sub_5243C(const char *a1, float *a2);
char *__fastcall sub_52494(const char *a1, float *a2);
int __fastcall sub_524EC(int a1, int a2, int (__fastcall **a3)(int));
char *__fastcall sub_52694(const char *a1);
char *__fastcall sub_526DC(const char *a1, _DWORD *a2);
char *__fastcall sub_5270C(const char *a1, _DWORD *a2);
char *__fastcall sub_52738(const char *a1, _DWORD *a2);
char *__fastcall sub_5276C(const char *a1, _DWORD *a2);
char *__fastcall sub_5279C(const char *a1, _DWORD *a2);
char *__fastcall sub_527CC(const char *a1, _DWORD *a2);
char *__fastcall sub_527FC(const char *a1, _DWORD *a2);
char *__fastcall sub_5282C(const char *a1, _DWORD *a2);
char *__fastcall sub_5285C(const char *a1, _DWORD *a2);
char *__fastcall sub_52888(const char *a1, _DWORD *a2);
char *__fastcall sub_528B4(const char *a1, _DWORD *a2);
char *__fastcall sub_528E0(const char *a1, _DWORD *a2);
char *__fastcall sub_52910(const char *a1, _DWORD *a2);
char *__fastcall sub_5293C(const char *a1, _DWORD *a2);
char *__fastcall sub_5296C(const char *a1, _DWORD *a2);
void __fastcall sub_52998(const char *a1, const char *a2, int a3);
double __fastcall sub_529E0(double a1);
int nullsub_4(); // weak
int nullsub_12(); // weak
int sub_52A30();
int sub_52A38();
int nullsub_13(); // weak
int nullsub_14(); // weak
int nullsub_15(); // weak
const char *__fastcall sub_52A4C(const char *a1);
int __fastcall sub_52AB8(char *a1, size_t a2, time_t *a3);
void __noreturn sub_52B50(const char *a1, ...);
void sub_52B98();
char *__fastcall sub_52D1C(const char *a1, _DWORD *a2, int a3, int a4);
int __fastcall sub_52D68(const char *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_52D98(int a1, const char *a2);
int __fastcall sub_52E08(int a1, char *s1); // idb
const char *__fastcall sub_52EE8(const char *a1);
void *__fastcall sub_52F30(void **a1);
char *__fastcall sub_52F6C(int a1, int a2, int a3);
void __fastcall sub_53084(void ***a1, const char *a2, const char *a3, int a4);
void __fastcall sub_53118(int a1);
void sub_5317C();
void sub_531A4();
void __fastcall sub_531CC(int a1, unsigned int a2);
_BYTE *__fastcall sub_53294(_BYTE *result, unsigned int a2);
unsigned __int64 __fastcall sub_532CC(__int64 *a1);
void __fastcall sub_53380(void ***a1, const char *a2, const char *a3, int a4);
int __fastcall sub_535B8(int result);
void __fastcall sub_53654(FILE *s);
int sub_53C3C();
char *__fastcall sub_53CD4(char *a1);
void sub_53DD0();
void __fastcall sub_53E30(void *a1);
int __fastcall sub_540C4(int a1);
bool __fastcall sub_540DC(int a1, int a2);
bool __fastcall sub_540FC(int a1, int a2);
int __fastcall sub_54148(int a1, int a2);
void __fastcall sub_541EC(int *a1, int a2);
void __fastcall sub_544A0(int *a1, unsigned int a2);
int __fastcall sub_544C8(int *a1, unsigned int a2);
void __fastcall sub_54514(int a1, int a2);
int __fastcall sub_5494C(int a1, void *s2, size_t n, const void *a4, int a5, size_t na);
int __fastcall sub_549BC(int result, int a2);
void __fastcall sub_54A08(int a1, _DWORD *a2);
int __fastcall sub_54B78(int a1);
int __fastcall sub_54CB4(int result);
void __fastcall __noreturn sub_54CCC(int a1, int a2);
void __noreturn sub_54D4C();
int __fastcall sub_54DA8(char *a1, size_t a2, int a3);
void __noreturn sub_54F7C();
int sub_54FC0();
void __fastcall __noreturn sub_55000(const char *a1, int a2);
void __fastcall __noreturn sub_5505C(const char *a1, int a2);
void __fastcall __noreturn sub_550B8(const char *a1, int a2);
void __fastcall __noreturn sub_55114(const char *a1, int a2);
int __fastcall sub_55170(int a1, _BYTE *a2);
int __fastcall sub_551DC(int a1, _BYTE *a2);
int __fastcall sub_55244(_DWORD *a1);
int __fastcall sub_55A28(int a1, int a2);
int sub_55AA4();
int __fastcall sub_55B0C(int a1, unsigned int a2);
void __fastcall __noreturn sub_55C08(const char *a1, int a2);
int sub_55C64();
int __fastcall sub_55D14(int a1);
_DWORD *sub_55E38();
_DWORD *__fastcall sub_55ED0(int a1, int a2);
_DWORD *__fastcall sub_55EF8(int a1);
int __fastcall sub_55F44(pthread_rwlock_t *a1, int a2);
void __fastcall sub_55FB0(pthread_rwlock_t *a1, void **a2);
_DWORD *__fastcall sub_5603C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_560E8(pthread_rwlock_t *a1);
void __fastcall __noreturn sub_561E4(const char *a1, int a2);
_DWORD *__fastcall sub_56240(pthread_rwlock_t *a1, int a2);
_DWORD *__fastcall sub_5630C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_563C8(pthread_rwlock_t *a1, int a2);
int __fastcall sub_5647C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_56518(int a1);
int sub_5658C();
int __fastcall sub_57944(int a1);
void sub_57A6C();
int __fastcall sub_57BAC(int a1);
int __fastcall sub_57C20(int a1);
bool sub_57C34();
bool sub_57F5C();
void sub_57F74();
int sub_58084();
int __fastcall sub_5812C(int a1, int a2, int a3);
int sub_5821C();
void __fastcall sub_582C8(_DWORD *a1);
void __fastcall sub_58400(_DWORD *a1);
void __fastcall sub_58490(int a1);
int __fastcall sub_584B4(int a1);
_BYTE *sub_58548();
const char *__fastcall sub_58794(char *s);
const char *__fastcall sub_58880(int a1);
int sub_588FC();
const char *__fastcall sub_58B64(int a1);
int sub_58BE0();
void __fastcall sub_58CC0(pthread_rwlock_t *a1);
int sub_58E30();
int __fastcall sub_59234(int a1, int a2);
int __fastcall sub_593C8(int a1);
unsigned __int64 __fastcall sub_59550(int a1);
int __fastcall sub_59820(int *a1, int a2);
int __fastcall sub_59A4C(int a1, _DWORD *a2, int a3, _DWORD *a4);
void __fastcall sub_59B44(_DWORD *a1);
int __fastcall sub_59E6C(int a1);
void __fastcall sub_5A31C(int a1);
int *__fastcall sub_5A44C(int a1);
int __fastcall sub_5A7E8(int a1, int a2);
int __fastcall sub_5AFA8(int *a1, int *a2, int a3, int a4, __int64 a5, unsigned int a6);
int __fastcall sub_5B104(_DWORD *a1);
void __fastcall sub_5B390(const char *a1, _DWORD *a2);
int __fastcall sub_5B638(int a1, int a2);
void **__fastcall sub_5BB20(int a1, void *a2);
void **__fastcall sub_5C2CC(int a1, pthread_rwlock_t *a2, void *a3);
void **__fastcall sub_5C2F4(int a1);
void **__fastcall sub_5C374(pthread_rwlock_t *a1);
void sub_5C3E0();
int sub_5C728();
int __fastcall sub_5C898(_DWORD *a1);
void __fastcall sub_5D8CC(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, const char *a5);
void __fastcall sub_5E2EC(int a1, unsigned __int64 a2);
void __fastcall sub_5F3DC(int a1);
int __fastcall sub_5FAA0(_DWORD *a1);
void __fastcall sub_62428(struct timeval *a1);
int __fastcall sub_62B4C(int a1, int a2);
int __fastcall sub_62C38(int a1, int a2, unsigned int a3);
void __fastcall sub_62CCC(int a1);
int __fastcall sub_62CF4(int a1, int a2, int a3);
void __fastcall __noreturn sub_62EC0(int a1);
int __fastcall sub_62ECC(int a1, int a2, char *s1, const char *a4, const char *a5);
int __fastcall sub_63130(int result);
int __fastcall sub_63218(pthread_rwlock_t *a1);
_BYTE *__fastcall sub_63D10(const void *a1);
void sub_63D74();
void sub_63E84();
char *__fastcall sub_64250(const char *a1, const char *a2);
int __fastcall sub_6428C(_BYTE *a1);
int __fastcall sub_6429C(_BYTE *a1);
int __fastcall sub_642AC(_BYTE *a1);
char *__fastcall sub_642BC(const char *a1, _BYTE *a2);
char *__fastcall sub_64350(const char *a1, _BYTE *a2);
int __fastcall sub_64370(int a1, _DWORD *a2);
char *__fastcall sub_6437C(const char *a1, _DWORD *a2);
char *__fastcall sub_64404(const char *a1, int *a2);
char *__fastcall sub_6448C(const char *a1, _DWORD *a2);
int __fastcall sub_64554(_DWORD *a1);
void __fastcall __noreturn sub_6456C(const char *a1);
void __fastcall __noreturn sub_6458C(int a1);
char *__fastcall sub_645CC(char *a1, unsigned __int8 *a2);
char *__fastcall sub_645F0(char *a1, unsigned __int8 *a2);
char *__fastcall sub_64614(_BYTE *a1, const char **a2);
int __fastcall sub_64674(char *a1, _DWORD *a2);
int __fastcall sub_64688(char *a1, float *a2);
int __fastcall sub_646B4(char *a1, _DWORD *a2);
int __fastcall sub_646C8(char *a1, _DWORD *a2);
int __fastcall sub_646DC(char *a1, _DWORD *a2);
const char *__fastcall sub_646F0(unsigned int *a1, size_t *a2);
int __fastcall sub_64790(int a1, size_t *a2);
int __fastcall sub_647D8(int a1, unsigned int *a2, size_t *a3);
int __fastcall sub_64890(const char **a1);
int __fastcall sub_64A04(int *a1);
const char *__fastcall sub_64A68(unsigned int *a1, size_t *a2);
_BYTE *__fastcall sub_64AC0(int a1, unsigned int *a2, size_t *a3);
const char *__fastcall sub_64B18(unsigned int *a1);
_BYTE *__fastcall sub_64B78(int a1, unsigned int *a2);
int __fastcall sub_64BD8(const char *a1, const char *a2, const char *a3, const char *a4, const char *a5, const char *a6, const char *a7);
int __fastcall sub_64C1C(int result, int a2);
bool __fastcall sub_64CF0(_DWORD *a1, const char **a2, void (*a3)(const char *, ...));
void sub_64D4C();
int sub_64D6C(const char *a1, ...);
void __noreturn sub_64DB4(const char *a1, ...);
char *__fastcall sub_64DF4(const char *a1);
void *__fastcall sub_64E24(_DWORD *a1, int a2, int a3);
int __fastcall sub_64E5C(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...));
char *__fastcall sub_6530C(const char *a1, const char *a2);
char *__fastcall memchr(char *result, __int16 a2, unsigned int a3);
unsigned int __fastcall sub_65864(int a1, unsigned int a2, int *a3);
int __fastcall sub_65974(int a1, int a2, char *s1, unsigned int a4);
int __fastcall memmem(char *a1, unsigned int a2, char *a3, unsigned int a4);
void sub_6607C();
int sub_66298();
void sub_663D8();
void *__fastcall sub_66410(void *result);
int sub_66474();
int nullsub_16(void); // weak
int __fastcall sub_66480(int a1);
int sub_66508();
int sub_66510();
int __fastcall sub_66518(int a1);
int __fastcall sub_66564(int a1);
int sub_665B0();
int sub_667A0();
void sub_667C0();
int __fastcall sub_6688C(int a1, _DWORD *a2);
int __fastcall sub_66908(int a1, int a2);
int sub_66980();
int __fastcall sub_669B4(_DWORD *a1, _DWORD *a2);
int sub_669C4();
int __fastcall nullsub_1(_DWORD); // weak
int __fastcall sub_669D0(int a1, unsigned int a2);
int __fastcall sub_66B44(int a1, int a2);
int __fastcall sub_66C5C(int a1);
int __fastcall sub_66FA0(int a1, int a2);
int __fastcall sub_670F0(int a1, _BYTE *a2);
int sub_67258();
int __fastcall sub_6739C(int a1, int a2);
int __fastcall sub_674E4(unsigned int a1);
void __fastcall sub_67584(int a1);
int __fastcall sub_675D4(int a1, unsigned int a2);
int __fastcall sub_67698(int a1, int a2);
int __fastcall sub_67718(int a1, _DWORD *a2, int *a3, int *a4, int *a5);
int __fastcall sub_6793C(int a1);
int __fastcall sub_67B24(int a1);
unsigned int __fastcall sub_67C5C(int a1, int a2, unsigned int a3);
int sub_67EA0();
int nullsub_17(void); // weak
unsigned int __fastcall sub_68150(int a1, int a2, unsigned int a3);
int __fastcall sub_681C4(int a1, int a2, int *a3);
int __fastcall sub_68248(int a1, int a2, _DWORD *a3, int a4);
int __fastcall sub_68300(int a1, int a2, _DWORD *a3);
int __fastcall sub_68388(int a1, int a2, int *a3, int a4);
int __fastcall sub_68444(int a1);
int __fastcall sub_68548(int a1);
int __fastcall sub_6856C(int a1);
int __fastcall sub_6857C(int a1);
int __fastcall sub_6858C(int a1);
int sub_685C8();
int sub_6860C();
int __fastcall sub_68630(_DWORD *a1, _DWORD *a2);
int *__fastcall sub_68640(int *result, int *a2);
int sub_68684();
int __fastcall sub_687C8(int a1);
int sub_68828();
int __fastcall sub_68848(unsigned int a1);
int sub_688C0();
void __fastcall sub_68948(int a1);
void __fastcall sub_68988(int a1, int a2);
int __fastcall sub_689E8(unsigned int a1, int a2);
int sub_68B54();
int __fastcall nullsub_18(_DWORD); // weak
int sub_68BE8();
int sub_68BF4();
int sub_68C00();
int sub_68C38();
int sub_68C44();
int sub_68C50();
int sub_68C88();
int sub_68C94();
int sub_68CA0();
int __fastcall sub_68CD8(int a1);
int __fastcall sub_68DE8(int a1);
void sub_690A0();
int __fastcall sub_69128(int a1);
int __fastcall sub_691EC(int a1, int a2, int a3, unsigned int a4);
int sub_69340();
int __fastcall sub_69348(int a1);
int __fastcall sub_69448(int a1);
int sub_694C4();
int sub_69B54();
int sub_69B70();
int sub_69B8C();
int sub_69BA8();
int __fastcall sub_69BC4(int a1);
int __fastcall sub_69C18(int a1);
int __fastcall sub_69C6C(int a1);
int sub_69CC0();
int __fastcall sub_69D2C(int a1);
int __fastcall sub_69D84(int a1);
int sub_69DD4();
int __fastcall sub_69E18(int a1);
void *__fastcall sub_69E34(int a1, const void *a2, size_t a3);
int *__fastcall sub_69E94(int a1);
_DWORD *__fastcall sub_69ED4(int a1, int a2, int a3);
int __fastcall sub_69F24(int *a1, const void *a2, size_t a3, const void *a4, size_t a5);
int *__fastcall sub_69F3C(int *result, int a2);
int __fastcall sub_69F5C(int *a1, int a2);
int __fastcall sub_69FD4(int *a1, int a2, _DWORD *a3);
int __fastcall sub_6A018(void (__fastcall ***a1)(_DWORD));
_DWORD *__fastcall sub_6A044(int a1);
void j_free(void *ptr);
int **__fastcall sub_6A090(int **result, int *a2);
_DWORD *__fastcall sub_6A0E4(_DWORD *result, _DWORD *a2);
int __fastcall sub_6A138(int result, _DWORD *a2);
int __fastcall sub_6A198(int result, _DWORD *a2);
int __fastcall sub_6A2A0(int result, _DWORD *a2, int a3, _DWORD *a4);
int __fastcall sub_6A330(_DWORD **a1);
_DWORD *__fastcall sub_6A3B0(int a1, int a2, int a3);
_DWORD *__fastcall sub_6A408(int a1, int a2);
int __fastcall sub_6A488(int a1, const void *a2, size_t a3, const void *a4, size_t a5);
int *__fastcall sub_6A6EC(int a1, int a2);
int __fastcall sub_6A9A0(void (__fastcall **ptr)(_DWORD));
_DWORD *__fastcall sub_6AAA8(int a1, _DWORD *a2);
int __fastcall sub_6AAC8(int a1, int a2);
bool __fastcall sub_6AAE8(_DWORD *a1);
int *__fastcall sub_6AAFC(int *a1, int a2);
_DWORD *__fastcall sub_6ABA8(const void *a1, size_t a2);
int __fastcall sub_6AC04(int a1, _DWORD *a2);
void *__fastcall sub_6AC44(void **a1, const void *a2, size_t a3);
void __fastcall destroy_sample_buffer(void **a1);
int __fastcall agt_mk_comp_droids(_DWORD *a1, _DWORD *a2);
int __fastcall sub_6ACC0(void *src, size_t n, const void **a3);
size_t __fastcall sub_6ACD4(const void *a1, size_t a2, FILE *s);
int __fastcall sub_6ACF0(int a1, int a2);
int __fastcall sub_6ACFC(char a1, int a2, int a3, int (__fastcall *a4)(__int16 *, int, int), int a5);
int __fastcall sub_6ADA0(char *a1, int (__fastcall *a2)(char *, int), int a3, unsigned int a4);
int __fastcall sub_6B004(_DWORD *a1, unsigned int a2, int a3, int (__fastcall *a4)(__int16 *, int, int), int a5);
int __fastcall sub_6B69C(_DWORD *a1, int (__fastcall *a2)(__int16 *, int, int), int a3, __int16 a4);
void *__fastcall sub_6B6E8(_DWORD *a1, __int16 a2);
int __fastcall sub_6B754(_DWORD *a1, int a2, __int16 a3);
int __fastcall sub_6B768(_DWORD *a1, int a2, __int16 a3);
int __fastcall sub_6B7C4(int a1, int *a2, char *s2, int a4);
void __fastcall sub_6B840(int a1);
int __fastcall sub_6B8A0(_DWORD *a1);
void __fastcall sub_6B910(int a1);
int __fastcall sub_6B928(int a1, char *a2, int a3, int a4);
int __fastcall sub_6BBAC(int a1, char *a2);
int __fastcall sub_6BC1C(_DWORD *a1, char *a2);
int __fastcall sub_6BD2C(_DWORD *a1);
int __fastcall sub_6BD80(int a1);
int __fastcall sub_6BD98(int a1, char *a2);
int __fastcall sub_6BE08(int a1, int a2);
int __fastcall sub_6BE20(int a1);
int __fastcall sub_6BE28(int a1);
int __fastcall sub_6BE30(int a1);
void __fastcall sub_6BE38(int a1, int a2);
int __fastcall sub_6BE90(_DWORD *a1);
int __fastcall sub_6BEB4(int a1);
int __fastcall sub_6BED8(_DWORD *a1);
int sub_6BF34(int result, _DWORD *a2, const char *a3, ...);
void __fastcall sub_6C054(int a1);
int __fastcall sub_6C088(_BYTE *a1);
_DWORD *__fastcall sub_6C134(_DWORD *result, int a2);
int __fastcall sub_6C1F0(int a1, int a2);
int __fastcall sub_6C368(int a1, int a2);
_DWORD *__fastcall sub_6C3A8(_DWORD *result, int a2);
unsigned int __fastcall sub_6C3F4(int a1, int a2);
double *__fastcall sub_6CBB0(int a1, int a2, int a3);
double *__fastcall sub_6D034(_DWORD *a1, int a2, int a3);
double *__fastcall sub_6D110(int a1, int a2, char *a3);
double *__fastcall sub_6D1D0(int a1, int a2, int a3, char *a4);
double *__fastcall sub_6D29C(int a1, int a2, char *a3);
double *__fastcall sub_6D374(char *a1, int a2, char *a3);
void *__fastcall sub_6D500(void *result);
void __fastcall sub_6D518(void *a1);
void *__fastcall sub_6D530(const char *a1);
int __fastcall sub_6D570(__int64 a1);
int __fastcall sub_6D580(_DWORD *a1);
void __fastcall sub_6D5B4(int a1);
int __fastcall sub_6D5E0(int result);
int __fastcall sub_6D5F4(int a1);
int __fastcall sub_6D5FC(int *a1);
int __fastcall sub_6D610(const void **a1, void *src, size_t n);
int __fastcall sub_6D6DC(const void **a1, char *s);
int __fastcall fh_buffer_putc(const void **a1, char a2);
int __fastcall sub_6D728(int *a1, char a2, int a3);
int __fastcall sub_6D750(int a1, double *a2);
int __fastcall sub_6D818(char *a1, size_t a2);
int __fastcall sub_6D94C(int a1, _BYTE *a2, _DWORD *a3);
int __fastcall sub_6DA38(int a1);
int __fastcall sub_6DAA4(char *a1, int a2, int *a3);
char *__fastcall sub_6DB8C(char *result, _DWORD *a2);
int __fastcall sub_6DBFC(const char *a1, signed int a2);
_QWORD *__fastcall sub_6DC90(int a1);
void *__fastcall sub_6DCDC(_DWORD *a1, int a2, int a3);
bool __fastcall sub_6DD68(int *a1, int a2);
_DWORD *sub_6DF5C();
_DWORD *__fastcall sub_6DFB0(_DWORD *result);
int __fastcall sub_6DFCC(_DWORD *a1, char *a2);
int __fastcall sub_6DFF0(_DWORD *a1, char *a2);
int __fastcall sub_6E014(_DWORD *a1);
int __fastcall sub_6E048(_DWORD *a1);
int __fastcall sub_6E06C(_DWORD *a1, char *a2);
int __fastcall sub_6E094(_DWORD *a1, int a2);
int __fastcall sub_6E0C8(int a1);
int __fastcall sub_6E0D4(int a1);
int __fastcall sub_6E138(int result);
_DWORD *sub_6E144();
_DWORD *__fastcall sub_6E1A8(_DWORD *result);
_DWORD *__fastcall sub_6E1C4(_DWORD *result, unsigned int a2);
int __fastcall sub_6E1F8(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_6E2B0(const char *a1);
_DWORD *__fastcall sub_6E350(_DWORD *result);
int __fastcall sub_6E36C(int a1, const char *a2);
int __fastcall sub_6E3C4(int a1, const char *a2);
_QWORD *__fastcall sub_6E400(__int64 a1);
__int64 __fastcall sub_6E430(int a1);
int __fastcall sub_6E458(int a1, __int64 a2);
double *sub_6E480();
void sub_6E4E0();
int __fastcall sub_6E570(int result);
void *sub_6E5B8();
void *sub_6E5C4();
void *sub_6E5D0();
void __fastcall sub_6E5DC(void **a1);
int __fastcall sub_6E6A8(_DWORD *a1);
int __fastcall sub_6E724(_DWORD *a1, unsigned int a2);
int __fastcall sub_6E7D4(void **a1, unsigned int a2, void **a3);
int __fastcall sub_6E894(_DWORD *a1, char *a2, int a3);
int __fastcall sub_6E91C(_DWORD *a1, _DWORD *a2);
int __fastcall sub_6E9E4(_DWORD *a1, _DWORD *a2);
int __fastcall sub_6EAD8(_DWORD *a1, _DWORD *a2);
int __fastcall sub_6EBD4(_DWORD *a1, char *a2, int a3);
int __fastcall sub_6EC44(void **a1, unsigned int a2, void **a3);
int __fastcall sub_6ED4C(void **a1, void **a2);
bool __fastcall sub_6EDE0(int *a1, int a2);
double *__fastcall sub_6EDF8(int a1);
double *__fastcall sub_6EF88(int a1);
int __fastcall sub_6F0EC(int a1);
int __fastcall sub_6F13C(unsigned int a1);
void __fastcall sub_6F1B8(unsigned int a1);
int __fastcall sub_6F254(unsigned int a1, unsigned __int8 a2, int a3, int a4);
int __fastcall sub_6F3AC(unsigned int a1, unsigned __int8 a2, int a3, int a4);
int sub_6F508();
int __fastcall sub_6F570(int result);
int __fastcall sub_6F610(int a1);
int sub_6F67C();
__int64 __fastcall sub_6F684(int a1);
int __fastcall sub_6F69C(int a1);
int __fastcall sub_6F6B0(int a1);
int __fastcall sub_6F6C8(int a1, int a2, int a3);
unsigned int sub_6F70C();
unsigned int sub_6F754();
int sub_6F79C();
int __fastcall sub_6F7C4(int a1);
int sub_6FB14();
int __fastcall sub_6FB84(char *a1, size_t a2);
int __fastcall sub_6FBE0(int a1);
int sub_6FBEC();
int __fastcall sub_6FC0C(int a1);
int sub_6FC34();
int __fastcall sub_6FC54(int a1);
int __fastcall sub_6FC8C(int a1);
int __fastcall sub_6FCB4(int a1);
int sub_6FCE0();
int __fastcall sub_6FD00(int a1);
int sub_6FD28();
int sub_6FD34();
int sub_6FD40();
int sub_6FD60();
int sub_6FD6C();
__int64 __fastcall sub_6FDC4(_QWORD *a1);
int sub_6FE2C();
int __fastcall sub_6FE4C(int a1);
int sub_6FE74();
int __fastcall sub_6FE94(int a1);
int sub_6FEBC();
int __fastcall sub_6FEDC(int a1);
int sub_6FF04();
int sub_6FF58();
int __fastcall sub_6FF78(int a1, int a2);
int sub_70098();
int __fastcall sub_700B8(int a1);
int sub_700E0();
int __fastcall sub_70100(int a1);
int __fastcall sub_70128(int a1);
int __fastcall sub_70150(int a1);
int __fastcall sub_70240(int *a1);
int __fastcall sub_70284(unsigned __int16 a1);
int sub_702AC();
int __fastcall sub_702CC(int a1);
int sub_702F4();
int __fastcall sub_70330(int a1);
int __fastcall sub_7075C(char a1);
int __fastcall sub_707B0(int a1, int a2);
int __fastcall sub_70808(int *a1, int a2);
int __fastcall sub_708A4(int *a1, unsigned int a2);
int sub_708EC();
int __fastcall sub_7090C(int a1);
int sub_70940();
int __fastcall sub_70968(int a1);
int __fastcall sub_70974(char a1);
int __fastcall sub_709B8(char a1);
int __fastcall sub_709FC(char a1);
int sub_70A20();
unsigned int sub_70A34();
int sub_70AF4();
int sub_70B34();
int sub_70B5C();
int sub_70B9C();
int sub_70C98();
int sub_70CC0();
int __fastcall sub_70CE4(int a1, int a2);
int __fastcall sub_70E58(int a1);
int __fastcall sub_70EA8(int a1);
void __fastcall sub_70EF8(unsigned __int8 *a1, unsigned int a2);
int __fastcall sub_7104C(unsigned int a1);
void __fastcall sub_710EC(unsigned int a1);
int __fastcall sub_711A0(unsigned int a1);
int __fastcall sub_713A4(unsigned int a1);
int __fastcall sub_7157C(unsigned int a1);
int __fastcall sub_71754(unsigned int a1);
int __fastcall sub_71928(unsigned int a1);
int __fastcall sub_71AF4(unsigned int a1);
int __fastcall sub_71CC8(int a1);
void __fastcall sub_71DF8(unsigned __int8 *a1, int a2);
int __fastcall sub_71F68(unsigned int a1, _DWORD *a2, int a3);
int __fastcall sub_721F8(unsigned int a1, __int16 a2, __int16 a3, int a4, int a5);
signed int __fastcall sub_724B8(unsigned int a1, __int16 a2, __int16 a3, void *a4, int a5);
int __fastcall sub_72790(unsigned int a1, const char *a2);
int sub_72DE0();
int sub_72E2C();
int __fastcall sub_72E84(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4);
int __fastcall sub_73100(int a1, __int16 a2);
int sub_7316C();
int sub_73190();
int sub_731E4();
void sub_73380();
int sub_734CC();
int __fastcall sub_73584(__int16 a1);
int sub_73604();
int __fastcall sub_73660(int a1);
void __fastcall sub_73804(int a1);
int __fastcall sub_73874(int a1, _BYTE *a2, int a3);
int __fastcall sub_738FC(int a1, int a2, int a3);
int __fastcall sub_73984(int a1, unsigned __int8 *a2, int a3, int a4, int a5);
int __fastcall sub_73A24(int a1, unsigned __int8 *a2, int a3, int a4, int a5);
int __fastcall sub_73AC4(_DWORD *a1, _DWORD *a2);
unsigned int sub_73AD4();
unsigned int __fastcall sub_73B30(_BYTE *a1);
int sub_73B94();
void __fastcall sub_73C78(int a1);
int __fastcall sub_73DA0(int a1, _BYTE *a2, int a3);
int __fastcall sub_73F8C(int a1, int a2, int a3);
int __fastcall sub_7411C(int a1, unsigned __int8 *a2, int a3, int a4, int a5);
int __fastcall sub_7436C(int a1, unsigned __int8 *a2, int a3, int a4, int a5);
int __fastcall sub_74568(int a1, int a2, int a3);
int __fastcall sub_7467C(int a1, int a2);
char *__fastcall sub_74778(int a1, char *s);
char *__fastcall sub_747D0(char *result, char *a2);
int __fastcall sub_74810(int a1, char *s);
int sub_74820(int result, int a2, int a3, int a4, char *format, ...);
int __fastcall sub_7487C(int result, int a2, int a3, int a4, char *format, __gnuc_va_list arg); // idb
int __fastcall sub_748C0(unsigned int);
int __fastcall sub_748C4(int a1, int a2, int a3, unsigned int a4, int a5);
int __fastcall sub_74950(int a1, int a2, int a3, unsigned int a4, char a5, char a6, char a7, __int16 a8);
int __fastcall sub_749A0(int a1, int a2, int a3, char a4, char a5, char a6);
int __fastcall sub_749EC(int a1);
int __fastcall sub_74A28(int a1, char a2);
int __fastcall sub_74A6C(int a1, int a2, char a3, char a4);
int __fastcall sub_74AB8(int a1);
int __fastcall sub_74AC8(_DWORD); // weak
int __fastcall sub_74ACC(int a1, unsigned int a2);
int __fastcall sub_74B18(unsigned int a1, unsigned int a2);
int __fastcall sub_74D64(int a1, unsigned int a2);
int __fastcall sub_74DD0(int a1, int a2, unsigned __int16 a3);
int __fastcall sub_74E08(int a1, _BYTE *a2, float *a3);
int __fastcall sub_75030(int a1, int a2, int a3, unsigned int a4, float a5);
int __fastcall sub_75094(int a1, unsigned int a2, int a3, __int16 a4);
int __fastcall sub_750D8(int a1, int a2, unsigned int a3, int a4, __int16 a5);
int __fastcall sub_75128(unsigned int a1, int a2, unsigned int a3, char a4, char a5);
int sub_7522C();
int sub_7523C();
int __fastcall sub_7524C(int a1, unsigned __int8 a2, unsigned int a3, float a4);
int __fastcall sub_75270(int a1, unsigned int a2, float a3);
int __fastcall sub_75294(int a1, int a2, char a3);
int __fastcall sub_752C0(int a1, char a2);
int __fastcall sub_752EC(int a1);
int __fastcall sub_752FC(unsigned int a1);
int __fastcall sub_75374(unsigned int a1, int a2, char a3, __int16 a4);
int __fastcall sub_75458(unsigned int a1, int a2);
int __fastcall sub_754BC(unsigned int a1, int a2);
int __fastcall sub_75548(int a1, int a2);
int __fastcall sub_7556C(int a1);
int __fastcall sub_755D8(int a1);
int __fastcall sub_7561C(int a1);
int __fastcall sub_75644(unsigned int a1);
int __fastcall sub_7569C(unsigned int a1);
int __fastcall sub_756F4(int a1, int a2);
int __fastcall sub_75718(int a1, char a2);
int __fastcall sub_7575C(unsigned int a1);
int __fastcall sub_75830(int a1);
int __fastcall sub_75894(int a1);
int __fastcall sub_758A4(int a1);
int sub_758B4();
int __fastcall sub_758BC(unsigned int a1, int a2);
int __fastcall sub_75928(int a1, int a2, unsigned __int8 a3, unsigned __int8 a4);
int __fastcall sub_75974(int a1, int a2, unsigned __int8 a3, int a4, unsigned __int8 a5);
int __fastcall sub_759B8(int a1, int a2, unsigned __int8 a3, int a4, unsigned __int8 a5);
int __fastcall sub_759C4(int a1, unsigned __int8 a2, unsigned __int8 a3);
int __fastcall sub_759F4(int a1, int a2, __int16 a3, char a4, char a5);
int __fastcall sub_75A2C(unsigned int a1, char a2);
int __fastcall sub_75A88(unsigned int a1, int a2, char a3);
int __fastcall sub_75AE8(int a1, int a2);
int __fastcall sub_75B10(int a1);
int __fastcall sub_75B38(int a1, int a2);
int __fastcall sub_75B64(int a1);
int sub_75B90();
int sub_75B98();
int __fastcall sub_75BA0(int a1);
int __fastcall sub_75BB0(int a1, char a2);
int __fastcall sub_75BC0(int a1);
int __fastcall sub_75BD0(int a1);
int __fastcall sub_75BE0(int a1);
int __fastcall sub_75BF0(int a1, char a2);
int __fastcall sub_75C00(int a1, int a2, char a3, char a4);
int __fastcall sub_75C4C(int a1, char a2, char a3);
int __fastcall sub_75C98(int a1, int a2, char a3, char a4, char a5);
int __fastcall sub_75CC4(int a1, char a2, char a3, char a4);
unsigned int __fastcall sub_75CEC(unsigned int a1);
int __fastcall sub_75CF4(unsigned int a1, unsigned int a2);
int __fastcall sub_75D08(unsigned int a1);
int __fastcall sub_75D9C(int a1, unsigned int a2, int a3, unsigned int a4, _DWORD *a5);
int __fastcall sub_75ED0(int a1, unsigned int a2, int a3, unsigned int a4, int a5);
int __fastcall sub_76008(int a1, char a2, char a3, int a4, _BYTE *a5);
int __fastcall sub_760A0(char a1, _BYTE *a2);
int __fastcall sub_760F4(int a1, char a2, char a3, _BYTE *a4);
int __fastcall sub_76164(_BYTE *a1);
int __fastcall sub_761B0(int a1, int a2, unsigned int a3);
int __fastcall sub_76284(_BYTE *a1, unsigned int a2);
int __fastcall sub_763AC(int a1);
int __fastcall sub_76638(int a1);
int __fastcall sub_76964(int a1, int a2);
int __fastcall sub_76C60(int a1);
int __fastcall sub_76F08(int a1, int a2, int a3, int a4);
int __fastcall sub_76F20(int a1, const void *a2, size_t a3, _DWORD *a4);
int __fastcall sub_772CC(unsigned int a1, unsigned int a2);
int __fastcall sub_772E8(int result, unsigned int a2);
int __fastcall sub_778A4(__int64 a1);
int __fastcall sub_778B4(__int64 a1);
int __fastcall sub_77910(unsigned __int64 a1, unsigned __int64 a2);
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
int __fastcall init(int a1, int a2, int a3);
int nullsub_22(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN loc_186A0; // weak
_UNKNOWN loc_1D2C8; // weak
_UNKNOWN loc_1FFFC; // weak
_UNKNOWN loc_20000; // weak
_UNKNOWN loc_24778; // weak
_UNKNOWN loc_26E60; // weak
_UNKNOWN loc_30D40; // weak
_UNKNOWN loc_3A590; // weak
_UNKNOWN loc_3F79C; // weak
_UNKNOWN loc_61A80; // weak
_UNKNOWN loc_74B20; // weak
_UNKNOWN loc_76390; // weak
_UNKNOWN loc_77330; // weak
_UNKNOWN unk_77D51; // weak
unsigned int dword_7901C[16] = { 128u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // weak
char aStatusservicet[45] = "statusServiceThread not support http command"; // weak
char aStatusservicet_1[45] = "statusServiceThread send http response error"; // weak
const char aD02d02d02d02d0_1[] = "[%d-%02d-%02d %02d:%02d:%02d"; // idb
__int16 word_7A848 = 93; // weak
_UNKNOWN unk_7F6F4; // weak
_UNKNOWN unk_7F76D; // weak
const char aSS_1[] = "%s%s"; // idb
int dword_80288 = 28526; // weak
_DWORD dword_81958[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char *off_81D74 = "http:"; // weak
_UNKNOWN unk_82D68; // weak
_UNKNOWN unk_82D9C; // weak
const char aIdDMethodMinin_5[] = "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []"; // idb
__int16 word_836FC = 125; // weak
_UNKNOWN unk_86EC4; // weak
_UNKNOWN unk_86EE8; // weak
_UNKNOWN *off_89BE4 = &unk_203D7C; // weak
_DWORD dword_8A954[29] =
{
  5,
  13,
  23,
  53,
  97,
  193,
  389,
  769,
  1543,
  3079,
  6151,
  12289,
  24593,
  49157,
  98317,
  196613,
  393241,
  786433,
  1572869,
  3145739,
  6291469,
  12582917,
  25165843,
  50331653,
  100663319,
  201326611,
  402653189,
  805306457,
  1610612741
}; // weak
const char aSResetPicError[] = "%s: reset pic error!"; // idb
const char aSSet1704FlashP_0[] = "%s: set 1704 flash pointer err!\n"; // idb
__int16 word_8B454 = 10; // weak
char aDh[5] = "\b`dh"; // weak
_UNKNOWN *off_9BF00 = (_UNKNOWN *)0x13BE5; // weak
_UNKNOWN *off_9BF04 = (_UNKNOWN *)0x13BCD; // weak
int dword_9C290 = -1; // weak
int dword_9C294 = 1; // weak
int dword_9C298 = 5; // weak
char byte_9C29C = '\x01'; // weak
int dword_9C2A0 = -1; // weak
int dword_9C2A4 = 255; // weak
int dword_9C2A8 = 50; // weak
char aBitmainSubmitN[21] = "bitmain_submit_nonce"; // weak
char aBitmainApiStat[19] = "bitmain_api_status"; // weak
int (*off_9C3B8)() = &sub_263C0; // weak
int dword_9C550 = 2; // weak
char *off_9C554 = "/var/log/hash_rate"; // weak
int dword_9C558 = 1730; // weak
int dword_9C55C = 1730; // weak
int dword_9C560 = 70; // weak
char *off_9C564 = "HW Sweep"; // weak
char *off_9C590 = "SW Sweep"; // weak
int dword_9C5BC = 4000; // weak
_UNKNOWN unk_9C5C8; // weak
_UNKNOWN unk_9CA30; // weak
_UNKNOWN unk_9CA34; // weak
_UNKNOWN unk_9CA38; // weak
_UNKNOWN unk_9CA74; // weak
int dword_9CAE0 = 3000; // weak
int dword_9CAE4 = 2000; // weak
_UNKNOWN unk_9CAEC; // weak
_UNKNOWN unk_9CF54; // weak
_UNKNOWN unk_9D014; // weak
_UNKNOWN unk_9D018; // weak
_UNKNOWN unk_9D01C; // weak
_UNKNOWN unk_9D020; // weak
_UNKNOWN unk_9D05C; // weak
_UNKNOWN unk_9D06C; // weak
_UNKNOWN unk_9D4D4; // weak
_UNKNOWN unk_9D714; // weak
_UNKNOWN unk_9D718; // weak
int dword_9D80C[] = { 3 }; // weak
int dword_9D810 = 7; // weak
_UNKNOWN *off_9DD3C = (_UNKNOWN *)0x89954; // weak
int dword_9E31C = 4; // weak
int dword_9E320 = 5; // weak
_DWORD dword_9E324[63] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817
}; // weak
_UNKNOWN unk_9E420; // weak
_UNKNOWN unk_9E440; // weak
int (*off_9E444)() = &sub_48900; // weak
char *off_9E548 = "--version-file"; // weak
int dword_9E54C = 2; // weak
_UNKNOWN unk_9E564; // weak
int dword_9ED60 = 1; // weak
double dbl_9ED68 = 1.0; // weak
char dword_9ED70[] = { '0', '\0', '\0', '\0' }; // idb
int dword_9ED74 = 0; // weak
int dword_9ED78 = 5; // weak
char *off_9ED7C = ":D"; // weak
double dbl_9ED80 = 1.0; // weak
double dbl_9ED88 = 1.0; // weak
double dbl_9ED90 = 1.84467441e19; // weak
int dword_9ED98 = -1; // weak
int dword_9ED9C = 120; // weak
char byte_9EDA0 = '\x01'; // weak
char *off_9EDA4[2] =
{
  "000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000",
  "--config|-c"
}; // weak
char *off_9EDA8 = "--config|-c"; // weak
int dword_9EE34 = 1; // weak
int dword_9EE38 = 2; // weak
int dword_9EE40 = 1800; // weak
int dword_9EE44 = 550; // weak
int dword_9EE48 = 4028; // weak
_UNKNOWN *off_9EE4C = (_UNKNOWN *)0x8B430; // weak
char *off_9EE50[3] = { "FTW", "224.0.0.75", "0.0.0.0" }; // weak
char *off_9EE54[2] = { "224.0.0.75", "0.0.0.0" }; // weak
char *off_9EE58 = "0.0.0.0"; // weak
int dword_9EE5C = 4028; // weak
char *off_9EE60 = "miner_1397 1.0.0"; // weak
char byte_9EE64 = '\x01'; // weak
int dword_9EE6C = 1; // weak
_DWORD dword_9EE84[372] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  16,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  0,
  48,
  49,
  60,
  62,
  63,
  64,
  65,
  66,
  68,
  69,
  70,
  71,
  72,
  73,
  76,
  77,
  78,
  80,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  32,
  33,
  34,
  35,
  36,
  40,
  37,
  38,
  48,
  48,
  49,
  50,
  51,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  76,
  77,
  78,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  284,
  285,
  286,
  287,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_9F454 = -1; // weak
char aFanMax6000Id0N[328] = "{\"fan\": [{\"max\": 6000, \"id\": 0, \"name\": 0}, {\"max\": 4300, \"id\": 1, \"name\": 0}], \"ipreport\": 943, \"reset\": 921, \"chain\": [{\"id\": 0, \"plug\": 0, \"uart\": 0, \"reset\": 0}, {\"id\": 1, \"plug\": 0, \"uart\": 0, \"reset\": 0}, {\"id\": 2, \"plug\": 0, \"uart\": 0, \"reset\": 0}, {\"id\": 3, \"plug\": 0, \"uart\": 0, \"reset\": 0}], \"green\": 942, \"red\": 941}"; // weak
void *(*off_9F5A4)(size_t size) = &malloc; // weak
void (*off_9F5A8)(void *ptr) = &free; // weak
_UNKNOWN unk_9F5AC; // weak
_UNKNOWN unk_9F5B4; // weak
_UNKNOWN unk_9F5BC; // weak
_UNKNOWN unk_9F5C4; // weak
int dword_9F7C4 = 20000; // weak
int stderr; // weak
int stdin; // weak
int stdout; // weak
char byte_9F7D8; // weak
int dword_9F7DC; // weak
int dword_9F7E0; // weak
float flt_9F7E4; // weak
float flt_9F7E8; // weak
float flt_9F7EC; // weak
float flt_9F7F0; // weak
float flt_9F7F4; // weak
float flt_9F7F8; // weak
float flt_9F7FC; // weak
float flt_9F800; // weak
float flt_9F804; // weak
int dword_9F808; // weak
_DWORD dword_9F80C[432]; // weak
pthread_mutex_t mutex; // idb
pthread_rwlock_t stru_9FEE4; // weak
int dword_9FF04; // weak
int dword_9FF08; // weak
int dword_9FF0C; // weak
__int16 word_9FF10[864]; // weak
int dword_A05D0; // weak
int dword_A05D4; // weak
int dword_A05D8; // weak
int dword_A05DC; // weak
int dword_A05E0; // weak
int dword_A05E4; // weak
int dword_A05E8; // weak
int dword_A05EC; // weak
char byte_A05F0; // weak
pthread_mutex_t stru_A05F4; // idb
int dword_A060C; // weak
int dword_A0610; // weak
char byte_A0614; // weak
int dword_A0618; // weak
int dword_A061C; // weak
int dword_A0620; // weak
int dword_A0624; // weak
int dword_A0628; // weak
int dword_A062C; // weak
char byte_A0630; // weak
_UNKNOWN *off_A0634; // weak
_DWORD dword_A0638[32]; // weak
char byte_A06B8; // weak
int dword_A06BC; // weak
__int64 qword_A06C0; // weak
int dword_A06C8; // weak
char byte_A06CC; // weak
int dword_A06D0; // weak
int dword_A06D4; // weak
_DWORD dword_A06D8[32]; // weak
_UNKNOWN unk_A0758; // weak
_QWORD qword_A07D8[176]; // weak
__int64 qword_A0D58; // weak
int dword_A0D60; // weak
int dword_A0D68; // weak
int dword_A0D6C; // weak
int dword_A0D70; // weak
int dword_A0D74; // weak
char byte_A0D78; // weak
char byte_A0D79; // weak
int dword_A0D7C; // weak
int dword_A0D80; // weak
__int64 qword_A0D88; // weak
char byte_A0D90; // weak
char byte_A0D91; // weak
int dword_A0D94; // weak
pthread_mutex_t stru_A0D98; // idb
pthread_mutex_t stru_A0DB0; // idb
_DWORD dword_A0DC8[4096]; // weak
_DWORD dword_A4DC8[74838]; // weak
_UNKNOWN unk_EDF22; // weak
_UNKNOWN unk_F423F; // weak
_UNKNOWN unk_F4240; // weak
_UNKNOWN unk_1371C4; // weak
_UNKNOWN unk_1371C8; // weak
_UNKNOWN unk_1372FC; // weak
_UNKNOWN unk_138544; // weak
pthread_mutex_t stru_138564; // weak
_UNKNOWN unk_138580; // weak
_UNKNOWN unk_1385F8; // weak
_UNKNOWN unk_1385FC; // weak
__int64 qword_138600; // weak
__int64 qword_138608; // weak
__int64 qword_138610; // weak
__int64 qword_138618; // weak
int dword_138620; // weak
int dword_138628; // weak
int dword_13862C; // weak
pthread_mutex_t stru_138630; // weak
char byte_138648[]; // weak
_DWORD dword_13864C[1263]; // weak
_UNKNOWN unk_139A08; // weak
int dword_1AEA10; // weak
int dword_1AEA14; // weak
int dword_1AEA18; // weak
int dword_1AEA1C; // weak
int dword_1AEA20; // weak
int dword_1AEA24[16]; // weak
int dword_1AEA64; // weak
int dword_1AEA68; // weak
int dword_1AEA6C; // weak
int dword_1AEA70; // weak
int dword_1AEA74; // weak
int dword_1AEA78; // weak
int dword_1AEA7C; // weak
int dword_1AEA80; // weak
char byte_1AEA84; // weak
pthread_mutex_t stru_1AEA88; // idb
int dword_1AEAA0; // weak
int dword_1AEAA4; // weak
_UNKNOWN unk_1AEAA8; // weak
_UNKNOWN unk_1AEB68; // weak
char byte_1AEB6C; // weak
char byte_1AEB6D; // weak
char byte_1AEB6E; // weak
int dword_1AEB70; // weak
int dword_1AEB74; // weak
pthread_mutex_t stru_1AEB78; // idb
int dword_1AEB90; // weak
int dword_1AEB94; // weak
int dword_1AEB98; // weak
char byte_1AEB9C; // weak
int dword_1AEBA0; // weak
__int16 word_1AEBA4; // weak
char byte_1AEBC4[256]; // weak
char byte_1AECC4; // weak
char byte_1AECC5; // weak
char byte_1AECC6; // weak
int dword_1AECC8; // weak
_DWORD dword_1AECCC; // weak
int dword_1AECD0; // weak
int dword_1AECD4; // weak
int dword_1AECD8; // weak
int dword_1AECDC; // weak
int dword_1AECE0; // weak
char byte_1AECE4[256]; // weak
int dword_1AEDE4; // weak
int dword_1AEDE8; // weak
char s[200]; // idb
int dword_1AEEB4; // weak
int dword_1AEEB8; // weak
char byte_1AEEBC[512]; // idb
struct timeval stru_1AF0BC; // weak
_UNKNOWN unk_1AF0CC; // weak
__int64 qword_1AF0D0; // weak
int dword_1AF0D8; // weak
int dword_1AF0DC; // weak
char byte_1AF0E0; // weak
int dword_1AF0E4; // weak
int dword_1AF0E8; // weak
int dword_1AF0EC; // weak
int dword_1AF0F0; // weak
int dword_1AF0F4; // weak
int dword_1AF0F8; // weak
char byte_1AF0FC[40]; // weak
int dword_1AF124; // weak
int dword_1AF128; // weak
int dword_1AF12C; // weak
char byte_1AF130; // weak
int dword_1AF134; // weak
int dword_1AF138; // weak
int dword_1AF13C; // weak
int dword_1AF140; // weak
int dword_1AF144; // weak
_BYTE algn_1AF148[8]; // weak
_UNKNOWN unk_1AF150; // weak
double dbl_1AF158[11]; // weak
int dword_1AF1B0; // weak
int dword_1AF1B4; // weak
pthread_mutex_t stru_1AF1B8; // idb
pthread_cond_t cond; // idb
pthread_mutex_t stru_1AF200; // idb
int dword_1AF218; // weak
int dword_1AF21C; // weak
int dword_1AF220; // weak
int dword_1AF224; // weak
char byte_1AF228; // weak
pthread_mutex_t stru_1AF22C; // idb
char byte_1AF244; // weak
_UNKNOWN unk_1AF248; // weak
int dword_1AFC48; // weak
_UNKNOWN unk_1AFC4C; // weak
int dword_1B064C; // weak
double dbl_1B0650; // weak
char byte_1B0658[256]; // weak
_UNKNOWN unk_1B0758; // weak
int dword_1B0778; // weak
char byte_1B077C[4]; // weak
_UNKNOWN unk_1B0784; // weak
char byte_1B07A4[32]; // weak
char dest[8]; // idb
char byte_1B07CC; // weak
int dword_1B07D0; // weak
int dword_1B07D4; // weak
char byte_1B07E4[12]; // weak
char byte_1B08E4[272]; // idb
int dword_1B09F4; // weak
float flt_1B09F8; // weak
int dword_1B09FC; // weak
int dword_1B0A00; // weak
int dword_1B0A04; // weak
int dword_1B0A08; // weak
double dbl_1B0A10; // weak
char byte_1B0A18[256]; // weak
char byte_1B0B18; // weak
char byte_1B0B1A; // weak
int dword_1B0B1C; // weak
int dword_1B0B20; // weak
char byte_1B0B24; // weak
int dword_1B0B28; // weak
_UNKNOWN unk_1B0B2C; // weak
int dword_1B0C30[]; // weak
unsigned __int8 byte_1B0CC0[116]; // weak
int dword_1B0D34; // weak
int dword_1B0D38[73]; // weak
int dword_1B0E5C; // weak
int dword_1B0E60; // weak
int dword_1B0E64; // weak
int dword_1B0E68; // weak
int dword_1B0E6C; // weak
int dword_1B0E70; // weak
int dword_1B0E74; // weak
int dword_1B0E78; // weak
pthread_mutex_t stru_1B0E7C; // idb
int dword_1B0E94; // weak
pthread_mutex_t stru_1B0E98; // idb
int dword_1B0EB0; // weak
_BYTE algn_1B0EB4[4]; // weak
_UNKNOWN unk_1B0EB8; // weak
_UNKNOWN unk_1B1038; // weak
int dword_1B11B8; // weak
int dword_1B11BC[]; // weak
pthread_mutex_t stru_1B11C0; // idb
int dword_1B11D8; // weak
_UNKNOWN *off_1B11DC; // weak
int dword_1B11E0; // weak
int dword_1B11E4; // weak
int dword_1B11E8; // weak
int dword_1B11EC; // weak
pthread_t dword_1B11F0; // weak
int dword_1B11F4; // weak
int dword_1B11F8; // weak
int dword_1B11FC; // weak
int dword_1B1200; // weak
pthread_mutex_t stru_1B1204; // idb
_UNKNOWN unk_1B121C; // weak
_DWORD dword_1B125C[64]; // weak
_UNKNOWN unk_1B135C; // weak
int dword_1B13A4; // weak
int dword_1B13A8; // weak
int dword_1B13AC; // weak
int dword_1B13B0; // weak
int dword_1B13B4; // weak
_DWORD dword_1B13B8[32]; // weak
int dword_1B1438; // weak
int dword_1B143C; // weak
int dword_1B1440; // weak
int dword_1B1444; // weak
int dword_1B1448; // weak
pthread_mutex_t stru_1B144C; // idb
pthread_mutex_t stru_1B1464; // idb
pthread_mutex_t stru_1B147C; // weak
pthread_mutex_t stru_1B1494; // weak
int dword_1B14AC; // weak
int dword_1B14B0; // weak
pthread_mutex_t stru_1B14B4; // weak
int dword_1B14CC; // weak
int dword_1B14D0; // weak
pthread_mutex_t stru_1B14D4; // idb
unsigned __int8 byte_1B14EC[2072]; // weak
unsigned __int8 byte_1B1D04[131072]; // weak
_UNKNOWN unk_1D1D04; // weak
_UNKNOWN unk_1D2C70; // weak
_UNKNOWN unk_202020; // weak
_UNKNOWN unk_20407F; // weak
_UNKNOWN unk_214B4F; // weak
int dword_231D04; // weak
int dword_231D08; // weak
int dword_231D0C; // weak
pthread_mutex_t stru_231D10; // weak
int dword_231D28; // weak
_UNKNOWN unk_231D2C; // weak
_UNKNOWN unk_235D2C; // weak
char s2[17768]; // idb
int dword_23A298; // weak
int dword_23A29C; // weak
int dword_23A2A0; // weak
int dword_23A2A4; // weak
int dword_23A2A8; // weak
int dword_23A2B0[]; // weak
int dword_23A2B4; // weak
int dword_23A2B8; // weak
_QWORD qword_241A80[16]; // weak
char byte_241B00[512]; // weak
char byte_241D00; // weak
char byte_241D04; // weak
char byte_241D05; // weak
_UNKNOWN unk_241D08; // weak
char byte_241D0A; // weak
__int16 word_241D0C; // weak
__int16 word_241D0E; // weak
_UNKNOWN unk_241D10; // weak
__int16 word_241D12; // weak
_UNKNOWN unk_241D14; // weak
_UNKNOWN unk_241D18; // weak
_UNKNOWN unk_241D1C; // weak
__int16 word_241D1E; // weak
int dword_241D20; // weak
char byte_241D24[36]; // weak
double dbl_241D48; // weak
__int64 qword_241D50; // weak
int dword_241D58; // weak
int dword_241D5C; // weak
int dword_241D60; // weak
int dword_241D64; // weak
int dword_241D68[]; // weak
int dword_241D6C; // weak
int dword_241D70; // weak
int dword_242D6C; // weak
int dword_242D70; // weak
_UNKNOWN unk_242D74; // weak
_DWORD dword_242DB4[16]; // weak
_UNKNOWN unk_242DF4; // weak
int dword_242E60; // weak
char byte_242E64; // weak
int dword_242E6C; // weak
int dword_242E70; // weak
__int64 qword_242E98; // weak
int dword_242EA0; // weak
char byte_242EA4[68]; // weak
int dword_242EE8; // weak
double dbl_242EF0; // weak
char byte_242EF8; // weak
__int64 qword_242F00; // weak
char byte_242F08; // weak
double dbl_242F10; // weak
char byte_242F18; // weak
char byte_242F1C; // weak
int dword_242F24; // weak
int dword_242F28; // weak
int dword_242F4C; // weak
int dword_242FDC; // weak
int dword_242FE4; // weak
int dword_242FEC; // weak
int dword_242FF0; // weak
int dword_242FF8; // weak
char byte_242FFC; // weak
char byte_242FFD; // weak
int dword_243000; // weak
char byte_243004[4096]; // weak
int dword_244004; // weak
int dword_24400C; // weak
int dword_244014; // weak
char byte_24401C; // weak
char byte_24401D; // weak
int dword_244020; // weak
int dword_244024; // weak
pthread_rwlock_t stru_244028; // weak
int dword_244048; // weak
pthread_cond_t stru_244050; // weak
char byte_244080; // weak
char byte_244081; // weak
char byte_244082; // weak
pthread_mutex_t stru_244084; // weak
pthread_rwlock_t stru_24409C; // idb
pthread_mutex_t stru_2440BC; // weak
pthread_rwlock_t rwlock; // idb
int dword_2440F8; // weak
char byte_2440FC[4100]; // weak
int dword_245100; // weak
int dword_245104; // weak
int dword_245108; // weak
double dbl_245110; // weak
int dword_245118; // weak
char byte_24511C; // weak
int dword_245140; // weak
int dword_245150; // weak
char byte_245154; // weak
__int64 qword_245158; // weak
int dword_245160; // weak
int dword_245168; // weak
int dword_24516C; // weak
int dword_245170; // weak
int dword_245174; // weak
char byte_245204; // weak
char byte_245205; // weak
double dbl_245208; // weak
double dbl_245210; // weak
double dbl_245218; // weak
double dbl_245228; // weak
char byte_245234[4100]; // weak
double dbl_246238; // weak
int dword_246240; // weak
pthread_mutex_t stru_246244; // weak
int dword_24625C; // weak
char byte_246260; // weak
pthread_mutex_t stru_246264; // weak
pthread_cond_t stru_246280[3]; // weak
char byte_24633C; // weak
pthread_mutex_t stru_246348; // weak
int dword_246360; // weak
__int64 qword_246368; // weak
char byte_246370; // weak
pthread_mutex_t stru_246374; // weak
pthread_rwlock_t stru_24638C; // weak
double dbl_2463B0; // weak
pthread_mutex_t stru_2463B8; // weak
__int64 qword_2463D0; // weak
int dword_2463D8; // weak
int dword_2463DC; // weak
int dword_2463E0; // weak
int dword_2463E4; // weak
int dword_2463E8; // weak
int dword_2463EC; // weak
_UNKNOWN unk_2463F0; // weak
_DWORD dword_246410[32]; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00011E7C) --------------------------------------------------------
int init_proc()
{
  return sub_13B58();
}

//----- (00011E88) --------------------------------------------------------
void sub_11E88()
{
  JUMPOUT(0);
}
// 11E94: control flows out of bounds to 0

//----- (00012608) --------------------------------------------------------
int __fastcall main(int a1, const char **a2, char **a3)
{
  const char *v4; // r8
  FILE *v5; // r6
  char *v6; // r11
  size_t v7; // r0
  FILE *v8; // r0
  size_t v9; // r5
  int v10; // r6
  size_t v11; // r4
  unsigned __int8 *v12; // r7
  const unsigned __int16 **v13; // r0
  int v14; // t1
  int v15; // r3
  void *v16; // r4
  _DWORD *v17; // r5
  _DWORD *v18; // r0
  int v19; // r4
  int v20; // r4
  int v21; // r2
  int v22; // r9
  __int64 v23; // r10
  __int64 v24; // r6
  int v25; // r3
  int *v26; // r8
  int *v27; // r7
  int v28; // r1
  int v29; // r0
  int v30; // r9
  double v31; // r10
  unsigned __int64 v32; // r8
  int v33; // r1
  int v34; // r0
  unsigned __int64 v35; // r2
  unsigned __int64 v36; // r8
  int v37; // r1
  int v38; // r0
  unsigned __int64 v39; // r2
  int v40; // r1
  __int64 v41; // r2
  __int64 v42; // r2
  int v43; // r1
  unsigned int v44; // r1
  char *v45; // r2
  void ***v46; // r1
  unsigned int v47; // t1
  unsigned __int64 v48; // r2
  int *v49; // r3
  unsigned int v51; // r1
  int v52; // r9
  unsigned int v53; // r0
  __int64 v54; // r0
  int *v56; // r0
  int *v57; // r0
  int *v58; // r0
  int *v59; // r0
  char *v61; // [sp+1Ch] [bp-9C8h]
  int v62; // [sp+24h] [bp-9C0h]
  unsigned int v63; // [sp+28h] [bp-9BCh]
  int v64; // [sp+28h] [bp-9BCh]
  __int64 v65; // [sp+30h] [bp-9B4h]
  int *v66; // [sp+38h] [bp-9ACh]
  __int64 v67; // [sp+48h] [bp-99Ch]
  void **v68; // [sp+5Ch] [bp-988h] BYREF
  unsigned int v69[6]; // [sp+60h] [bp-984h] BYREF
  unsigned int v70; // [sp+78h] [bp-96Ch]
  int v71; // [sp+7Ch] [bp-968h] BYREF
  char dest[32]; // [sp+80h] [bp-964h] BYREF
  _BYTE command[64]; // [sp+A0h] [bp-944h] BYREF
  _QWORD s[32]; // [sp+E0h] [bp-904h] BYREF
  char v75[2048]; // [sp+1E0h] [bp-804h] BYREF

  v4 = *a2;
  memset(s, 0, sizeof(s));
  memset(command, 0, sizeof(command));
  snprintf(command, 0x40u, "pidof %s", v4);
  v5 = popen(command, "r");
  if ( !v5 )
  {
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      v6 = v75;
      snprintf(v75, 0x800u, " app-service:%s Not Found!!!", v4);
      sub_47AB4(7, v75, 0);
    }
    else
    {
      v6 = v75;
    }
    goto LABEL_31;
  }
  v6 = v75;
  while ( fgets((char *)s, 256, v5) )
  {
    if ( byte_1AECC5 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
      {
        snprintf(v75, 0x800u, "pidof %s command result is: %s\n", v4, (const char *)s);
        sub_47AB4(7, v75, 0);
        if ( byte_1AECC5 )
        {
          if ( byte_244080 )
            goto LABEL_12;
          goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        if ( byte_1AECC4 || dword_9E320 > 6 )
        {
LABEL_12:
          v7 = strlen((const char *)s);
          snprintf(v75, 0x800u, "strlen is: %d\n", v7);
          sub_47AB4(7, v75, 0);
        }
      }
    }
  }
  v8 = v5;
  v9 = 0;
  v10 = 0;
  pclose(v8);
  v11 = 1;
  v12 = (unsigned __int8 *)s;
  while ( strlen((const char *)s) >= v11 )
  {
    memset(dest, 0, sizeof(dest));
    v13 = _ctype_b_loc();
    v14 = *v12++;
    if ( ((*v13)[v14] & 0x2000) != 0 )
    {
      strncpy(dest, (const char *)s + v9, v11 - v9 - 1);
      v15 = strtol(dest, 0, 10);
      if ( v15 > 0 && (++v10, byte_1AECC5) && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        v9 = v11;
        snprintf(v75, 0x800u, "Parsed proc id is: %d\n", v15);
        sub_47AB4(7, v75, 0);
      }
      else
      {
        v9 = v11;
      }
    }
    ++v11;
  }
  if ( v10 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      snprintf(v75, 0x800u, " %d instance of %s is  already Running on this machine", v10, v4);
      sub_47AB4(3, v75, 0);
    }
    if ( v10 != 1 )
    {
      snprintf(v75, 0x800u, "%s is forbidden to start twice, will exit immediately!", *a2);
      sub_47AB4(3, v75, 1);
      sub_62EC0(-1);
    }
  }
LABEL_31:
  v16 = calloc(1u, 0x1798u);
  dword_241D64 = (int)v16;
  v17 = calloc(1u, 0x188u);
  dword_241D5C = (int)v17;
  v18 = calloc(1u, 0x40u);
  v18[9] = v17;
  v17[5] = v16;
  dword_241D58 = (int)v18;
  sub_26D84(a1, a2);
  sub_25FA8();
  v19 = *(_DWORD *)(*(_DWORD *)(dword_241D58 + 36) + 20);
  if ( pthread_mutex_init((pthread_mutex_t *)(v19 + 420), 0) )
    sub_25B64(309);
  sub_25BC4(v19, 310);
  sub_25BC4(v19 + 692, 311);
  sub_25BC4(v19 + 2540, 312);
  sub_25BC4(v19 + 4388, 313);
  memset(v75, 0, 0x20u);
  *(_WORD *)&v75[2] = 26;
  v75[4] = ~(~((v75[4] & 0xFD | (2 * (byte_1B0B1A & 1u))) << 30) >> 30);
  v75[0] = 81;
  v75[5] = v75[5] & 0xF0 | 7 | (8 * (byte_1B0B18 & 1));
  *(_WORD *)&v75[8] = 13833;
  v75[10] = dword_1B0B1C;
  *(_WORD *)&v75[12] = dword_9EE44;
  *(_WORD *)&v75[14] = dword_9EE40;
  v75[11] = 80;
  *(_WORD *)&v75[16] = 2570;
  *(_WORD *)&v75[26] = 400;
  v75[24] = 4;
  *(_WORD *)&v75[28] = 600;
  *(_WORD *)&v75[30] = sub_514F8((int)v75, 30);
  if ( !sub_25098(
          *(int *)v75,
          *(int *)&v75[4],
          *(int *)&v75[8],
          *(int *)&v75[12],
          *(int *)&v75[16],
          *(int *)&v75[20],
          *(int *)&v75[24],
          *(int *)&v75[28]) )
    sub_226C0(3u, "soc init failed!");
  sub_226C0(0, 0);
  if ( sub_25A5C() )
    sub_226C0(3u, "socket init failed!");
  sub_226C0(1u, 0);
  dword_241D60 = (int)calloc(1u, 0x40u);
  pthread_attr_init((pthread_attr_t *)command);
  pthread_attr_setstacksize((pthread_attr_t *)command, 0x200000u);
  if ( sub_4BDCC(dword_241D60, (const pthread_attr_t *)command, (void *(*)(void *))sub_26C30, (void *)dword_241D60)
    && (byte_244080 || byte_1AECC4 || dword_9E320 > 2) )
  {
    snprintf(v75, 0x800u, "%s: create thread for get api status failed\n", "main");
    sub_47AB4(3, v75, 0);
  }
  pthread_detach(*(_DWORD *)(dword_241D60 + 12));
  sub_23D44();
  while ( 2 )
  {
    v61 = v6;
LABEL_43:
    if ( !*(_BYTE *)(dword_241D5C + 364) )
    {
      v66 = (int *)dword_241D58;
      v20 = *(_DWORD *)(*(_DWORD *)(dword_241D58 + 36) + 20);
      pthread_mutex_lock(&stru_138564);
      if ( pthread_mutex_lock((pthread_mutex_t *)v20) )
      {
        v57 = _errno_location();
        snprintf(
          v61,
          0x800u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v57,
          "bmminer.c",
          "bitmain_c5_scanhash",
          440);
        sub_47AB4(3, v61, 1);
        sub_62EC0(1);
      }
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v20 + 24)) )
      {
        v59 = _errno_location();
        snprintf(
          v61,
          0x800u,
          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v59,
          "bmminer.c",
          "bitmain_c5_scanhash",
          440);
        sub_47AB4(3, v61, 1);
        sub_62EC0(1);
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)v20) )
      {
        v58 = _errno_location();
        snprintf(
          v61,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v58,
          "bmminer.c",
          "bitmain_c5_scanhash",
          440);
        sub_47AB4(3, v61, 1);
        sub_62EC0(1);
      }
      v65 = 0;
LABEL_48:
      if ( !dword_23A2B8 )
      {
LABEL_77:
        qword_241D50 += v65;
        if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v20 + 24)) )
        {
          v56 = _errno_location();
          snprintf(
            v61,
            0x800u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v56,
            "bmminer.c",
            "bitmain_c5_scanhash",
            533);
          sub_47AB4(3, v61, 1);
          sub_62EC0(1);
        }
        off_9E444();
        pthread_mutex_unlock(&stru_138564);
        sub_4A804();
        if ( v65 )
        {
          v67 = 0xFFFFFFFFLL * v65;
          if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
          {
            snprintf(v61, 0x800u, "%s: hashes %llu ...\n", "bitmain_c5_scanhash", v67);
            sub_47AB4(7, v61, 0);
          }
          if ( v67 )
          {
            v6 = v61;
            qword_138600 += v67;
            continue;
          }
        }
        goto LABEL_43;
      }
      while ( 2 )
      {
        v21 = 0;
        LODWORD(v24) = dword_23A2B0[15 * dword_23A2B4 + 8];
        v22 = dword_23A2B0[15 * dword_23A2B4 + 3];
        v23 = *(_QWORD *)&dword_23A2B0[15 * dword_23A2B4 + 6];
        v62 = dword_23A2B0[15 * dword_23A2B4 + 9];
        HIDWORD(v24) = dword_23A2B0[15 * dword_23A2B4 + 4];
        v63 = (dword_23A2B0[15 * dword_23A2B4 + 5] << 24)
            | HIBYTE(dword_23A2B0[15 * dword_23A2B4 + 5])
            | ((unsigned int)dword_23A2B0[15 * dword_23A2B4 + 5] >> 8) & 0xFF00
            | (dword_23A2B0[15 * dword_23A2B4 + 5] << 8) & 0xFF0000;
        do
          ++v21;
        while ( v21 != 32 );
        if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
        {
          snprintf(
            v61,
            0x800u,
            "%s: job_id:0x%x   work_id:0x%x   nonce2:0x%llx nonce3:0x%x   version:0x%x\n",
            "bitmain_c5_scanhash",
            v22,
            HIDWORD(v24),
            v23,
            (_DWORD)v24,
            v63);
          sub_47AB4(7, v61, 0);
        }
        if ( (unsigned int)dword_23A2B4 > 0x1FD )
          v25 = 0;
        else
          v25 = dword_23A2B4;
        v26 = (int *)(v20 + 480);
        if ( (unsigned int)dword_23A2B4 <= 0x1FD )
          ++v25;
        dword_23A2B4 = v25;
        --dword_23A2B8;
        if ( v24 == qword_138608 )
        {
          if ( *(_DWORD *)(dword_A0D68 + 4 * v62 + 4) == 1 )
          {
            if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
            {
              strcpy(v61, "reepat nonce error");
              sub_47AB4(3, v61, 0);
            }
            sub_593C8((int)v66);
            ++*(_DWORD *)(dword_A0D68 + 4 * v62 + 1206);
          }
          goto LABEL_48;
        }
        qword_138608 = v24;
        if ( !byte_1AECC5 )
        {
          v27 = &dword_9C550;
          goto LABEL_87;
        }
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
        {
          snprintf(v61, 0x800u, "%s: Chain ID J%d ...\n", "bitmain_c5_scanhash", v62 + 1);
          LOWORD(v27) = (unsigned __int16)&dword_9C550;
          sub_47AB4(7, v61, 0);
          if ( byte_1AECC5 )
          {
            HIWORD(v27) = (unsigned int)&dword_9C550 >> 16;
            v28 = *v27;
            v29 = *v27 - v22;
            if ( !byte_244080 )
              goto LABEL_68;
            goto LABEL_86;
          }
          HIWORD(v27) = (unsigned int)&dword_9C550 >> 16;
        }
        else
        {
          v27 = &dword_9C550;
          v28 = dword_9C550;
          v29 = dword_9C550 - v22;
LABEL_68:
          if ( !byte_1AECC4 && dword_9E320 <= 6 )
          {
            switch ( v29 )
            {
              case 1:
                goto LABEL_146;
              case 0:
                goto LABEL_91;
              case 2:
LABEL_90:
                v26 = (int *)(v20 + 4176);
                goto LABEL_91;
            }
            goto LABEL_73;
          }
LABEL_86:
          snprintf(v61, 0x800u, "%s: given_id:%d job_id:%d switch:%d  ...\n", "bitmain_c5_scanhash", v28, v22, v29);
          sub_47AB4(7, v61, 0);
        }
LABEL_87:
        v30 = *v27 - v22;
        switch ( v30 )
        {
          case 1:
LABEL_146:
            v26 = (int *)(v20 + 2328);
LABEL_91:
            sub_5AFA8(v66, (int *)&v68, (int)v26, (int)v26, v23, v63);
            HIDWORD(v24) = v68;
            v31 = *((double *)v68 + 39);
            v64 = *v26;
            v32 = (unsigned __int64)v31;
            if ( (unsigned __int64)v31 != qword_138610 )
            {
              v33 = 0;
              qword_138610 = (unsigned __int64)v31;
              v34 = 0;
              if ( v32 )
              {
                v35 = (unsigned __int64)v31;
                while ( 1 )
                {
                  v35 >>= 1;
                  if ( !v35 )
                    break;
                  v34 = (__PAIR64__(v34, v33++) + 1) >> 32;
                }
              }
              else
              {
                v33 = -1;
                v34 = -1;
              }
              LODWORD(qword_138618) = v33;
              HIDWORD(qword_138618) = v34;
              if ( byte_1AECC5 )
              {
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
                {
                  snprintf(
                    v61,
                    0x800u,
                    "%s: pool_diff:%lld work_diff:%f pool_diff_bit:%lld ...\n",
                    "hashtest_submit",
                    v32,
                    v31,
                    __PAIR64__(v34, v33));
                  sub_47AB4(7, v61, 0);
                }
              }
            }
            v36 = (unsigned __int64)dbl_9ED90;
            if ( (unsigned __int64)dbl_9ED90 != *(_QWORD *)&dword_138620 )
            {
              v37 = 0;
              *(_QWORD *)&dword_138620 = (unsigned __int64)dbl_9ED90;
              v38 = 0;
              if ( v36 )
              {
                v39 = (unsigned __int64)dbl_9ED90;
                while ( 1 )
                {
                  v39 >>= 1;
                  if ( !v39 )
                    break;
                  v38 = (__PAIR64__(v38, v37++) + 1) >> 32;
                }
              }
              else
              {
                v37 = -1;
                v38 = -1;
              }
              dword_138628 = v37;
              dword_13862C = v38;
              if ( byte_1AECC5 )
              {
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
                {
                  snprintf(
                    v61,
                    0x800u,
                    "%s:net_diff:%lld current_diff:%f net_diff_bit %lld ...\n",
                    "hashtest_submit",
                    v36,
                    dbl_9ED90,
                    __PAIR64__(v38, v37));
                  sub_47AB4(7, v61, 0);
                }
              }
            }
            v40 = *(_DWORD *)(HIDWORD(v24) + 132);
            v41 = *(_QWORD *)(HIDWORD(v24) + 136);
            LODWORD(s[1]) = *(_DWORD *)(HIDWORD(v24) + 128);
            HIDWORD(s[1]) = v40;
            s[2] = v41;
            v42 = *(_QWORD *)(HIDWORD(v24) + 152);
            v43 = *(_DWORD *)(HIDWORD(v24) + 148);
            LODWORD(s[3]) = *(_DWORD *)(HIDWORD(v24) + 144);
            HIDWORD(s[3]) = v43;
            s[4] = v42;
            s[0] = 80;
            v44 = *(_DWORD *)(HIDWORD(v24) + 68);
            LODWORD(v42) = *(_DWORD *)(HIDWORD(v24) + 72);
            v69[0] = *(_DWORD *)(HIDWORD(v24) + 64);
            v69[1] = v44;
            v69[2] = v42;
            sub_5162C((int)&s[5], v69, 0xCu);
            v69[0] = v24;
            sub_5162C((int)&s[6] + 4, v69, 4u);
            sub_1E58C((int)s, v69);
            memset(s, 0, 0xE8u);
            sub_1E740(v69, 32, dest);
            v45 = (char *)&v71;
            v46 = &v68;
            do
            {
              v47 = *((_DWORD *)v45 + 1);
              v45 += 4;
              v46[1] = (void **)bswap32(v47);
              ++v46;
            }
            while ( &dest[28] != v45 );
            LODWORD(v48) = v71;
            if ( v71 )
            {
              if ( *(_DWORD *)(dword_A0D68 + 4 * v62 + 4) == 1 )
              {
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
                {
                  strcpy(v61, "hash2_32 error");
                  sub_47AB4(3, v61, 0);
                }
                sub_593C8((int)v66);
                ++*(_DWORD *)(dword_A0D68 + 4 * v62 + 1206);
              }
              if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
              {
                snprintf(v61, 0x800u, "%s: HASH2_32[7] != 0", "hashtest_submit");
                sub_47AB4(7, v61, 0);
              }
            }
            else
            {
              v49 = &v71;
              while ( !*--v49 )
              {
                LODWORD(v48) = v48 + 1;
                if ( (_DWORD)v48 == 7 )
                {
                  v48 = 7;
                  goto LABEL_129;
                }
              }
              v48 = (int)v48;
LABEL_129:
              if ( (unsigned __int64)qword_138618 >> 5 <= v48 )
              {
                v51 = *(unsigned __int8 *)(dword_A0D68 + 12954);
                if ( !*(_BYTE *)(dword_A0D68 + 12954) )
                  v51 = 3;
                v52 = sub_75CF4(v24, v51);
                v53 = sub_75CEC(v24);
                if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
                {
                  snprintf(
                    v61,
                    0x800u,
                    "%s: chain %d which_asic_nonce %d which_core_nonce %d",
                    "hashtest_submit",
                    v62,
                    v52,
                    v53);
                  sub_47AB4(7, v61, 0);
                }
                v54 = qword_138618;
                ++*(_QWORD *)(dword_A0D68 + 8 * (v52 + 78 * v62) + 1270);
                if ( bswap32(*(&v70 - (v54 >> 5))) < 0xFFFFFFFF >> (v54 & 0x1F) )
                {
                  qword_241A80[v62] += 256LL;
                  sub_25DA0((int)v66, (const char **)HIDWORD(v24), v24, v64);
                  v65 += 256;
                }
                else if ( bswap32(v70) <= 0xFFFFFE )
                {
                  qword_241A80[v62] += 256LL;
                  v65 += 256;
                }
              }
            }
            sub_53084(&v68, "bmminer.c", "bitmain_c5_scanhash", 530);
            goto LABEL_48;
          case 0:
            goto LABEL_91;
          case 2:
            goto LABEL_90;
        }
        if ( byte_244080 || byte_1AECC4 )
        {
LABEL_74:
          snprintf(v61, 0x800u, "%s: job_id non't found ...\n", "bitmain_c5_scanhash");
          sub_47AB4(3, v61, 0);
        }
        else
        {
LABEL_73:
          if ( dword_9E320 > 2 )
            goto LABEL_74;
        }
        if ( *(_DWORD *)(dword_A0D68 + 4 * v62 + 4) != 1 )
          goto LABEL_48;
        sub_593C8((int)v66);
        ++*(_DWORD *)(dword_A0D68 + 4 * v62 + 1206);
        if ( !dword_23A2B8 )
          goto LABEL_77;
        continue;
      }
    }
    return 0;
  }
}
// 9C550: using guessed type int dword_9C550;
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9ED90: using guessed type double dbl_9ED90;
// 9EE40: using guessed type int dword_9EE40;
// 9EE44: using guessed type int dword_9EE44;
// A0D68: using guessed type int dword_A0D68;
// 138564: using guessed type pthread_mutex_t stru_138564;
// 138600: using guessed type __int64 qword_138600;
// 138608: using guessed type __int64 qword_138608;
// 138610: using guessed type __int64 qword_138610;
// 138618: using guessed type __int64 qword_138618;
// 138620: using guessed type int dword_138620;
// 138628: using guessed type int dword_138628;
// 13862C: using guessed type int dword_13862C;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1B0B18: using guessed type char byte_1B0B18;
// 1B0B1A: using guessed type char byte_1B0B1A;
// 1B0B1C: using guessed type int dword_1B0B1C;
// 23A2B0: using guessed type int dword_23A2B0[];
// 23A2B4: using guessed type int dword_23A2B4;
// 23A2B8: using guessed type int dword_23A2B8;
// 241A80: using guessed type _QWORD qword_241A80[16];
// 241D50: using guessed type __int64 qword_241D50;
// 241D58: using guessed type int dword_241D58;
// 241D5C: using guessed type int dword_241D5C;
// 241D60: using guessed type int dword_241D60;
// 241D64: using guessed type int dword_241D64;
// 244080: using guessed type char byte_244080;

//----- (00013B28) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_22,
    a1,
    va);
  abort();
}
// 13B32: positive sp value 4 has been found
// 13B44: variable 'v4' is possibly undefined
// 77AC8: using guessed type int init();
// 77B04: using guessed type int nullsub_22();

//----- (00013B58) --------------------------------------------------------
int sub_13B58()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 12214: using guessed type int _gmon_start__(void);

//----- (00013B7C) --------------------------------------------------------
int deregister_tm_clones()
{
  return 653256;
}

//----- (00013BA0) --------------------------------------------------------
int register_tm_clones()
{
  return 653256;
}

//----- (00013BCC) --------------------------------------------------------
int sub_13BCC()
{
  int result; // r0

  if ( !byte_9F7D8 )
  {
    result = deregister_tm_clones();
    byte_9F7D8 = 1;
  }
  return result;
}
// 9F7D8: using guessed type char byte_9F7D8;

//----- (00013BE8) --------------------------------------------------------
void sub_13BE8()
{
  flt_9F804 = flt_9F800;
  flt_9F7FC = flt_9F7E4 - flt_9F7E8;
  flt_9F800 = flt_9F7E4 - flt_9F7E8;
}
// 9F7E4: using guessed type float flt_9F7E4;
// 9F7E8: using guessed type float flt_9F7E8;
// 9F7FC: using guessed type float flt_9F7FC;
// 9F800: using guessed type float flt_9F800;
// 9F804: using guessed type float flt_9F804;

//----- (00013C54) --------------------------------------------------------
int __fastcall sub_13C54(unsigned int a1)
{
  int v2; // r10
  int v3; // r4
  int v4; // r0
  int v5; // r3
  int v6; // r5
  int v7; // r1
  int v8; // r2
  unsigned int v9; // r3
  unsigned int v11; // r2
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v2 = 10;
  do
  {
    v3 = 0;
    sub_70CC0();
    do
    {
      while ( 1 )
      {
        v4 = sub_66480(v3);
        if ( v4 >= 0 )
        {
          v5 = dword_A0D68;
          v6 = 4 * (v3 + 3204);
          *(_DWORD *)(dword_A0D68 + v6 + 6) = v4;
          if ( (unsigned int)dword_9E31C > 4 )
          {
            snprintf(s, 0x800u, "fan[%u] speed[%u]\n", v3, v4);
            sub_47AB4(4, s, 0);
            if ( (unsigned int)dword_9E31C > 4 )
            {
              snprintf(s, 0x800u, "fan_id = %d, fan_speed = %d\n", v3, *(_DWORD *)(dword_A0D68 + v6 + 6));
              sub_47AB4(4, s, 0);
            }
            v5 = dword_A0D68;
            v4 = *(_DWORD *)(dword_A0D68 + v6 + 6);
          }
          v7 = v5 + v3;
          if ( a1 > v4 )
          {
            if ( *(_BYTE *)(v5 + v3 + 12814) == 1 )
            {
              *(_BYTE *)(v7 + 12814) = 0;
              --*(_BYTE *)(v5 + 12936);
              *(_DWORD *)(v5 + 76) &= ~(1 << v3);
            }
            goto LABEL_5;
          }
          if ( !*(_BYTE *)(v5 + v3 + 12814) )
            break;
        }
LABEL_5:
        if ( ++v3 == 8 )
          goto LABEL_11;
      }
      *(_BYTE *)(v7 + 12814) = 1;
      ++*(_BYTE *)(v5 + 12936);
      v8 = *(_DWORD *)(v5 + 76) | (1 << v3++);
      *(_DWORD *)(v5 + 76) = v8;
    }
    while ( v3 != 8 );
LABEL_11:
    if ( *(unsigned __int8 *)(dword_A0D68 + 12936) > 3u )
      return 0;
    sub_4A804();
    --v2;
  }
  while ( v2 );
  v9 = *(unsigned __int8 *)(dword_A0D68 + 12936);
  if ( v9 > 3 )
    return 0;
  v11 = dword_9E31C;
  if ( (unsigned int)dword_9E31C > 1 )
  {
    snprintf(s, 0x800u, "Error, fan lost, only find %d (< %d)\n", v9, 4);
    sub_47AB4(1, s, 0);
    v11 = dword_9E31C;
  }
  while ( 1 )
  {
    if ( v11 > 3 )
    {
      snprintf(s, 0x800u, "fan_id = %d, fan_speed = %d\n", v2, *(_DWORD *)(dword_A0D68 + 4 * (v2 + 3204) + 6));
      sub_47AB4(3, s, 0);
    }
    if ( ++v2 == 8 )
      break;
    v11 = dword_9E31C;
  }
  sub_31794(10, 255);
  sub_226C0(6u, "fan lost");
  return -1;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00013EE8) --------------------------------------------------------
void __fastcall sub_13EE8(signed int a1)
{
  int v2; // r0
  char v3[2052]; // [sp+0h] [bp-804h] BYREF

  sub_1758C();
  v2 = dword_9F808;
  if ( !dword_9F808 )
  {
    v2 = sub_674E4(0);
    dword_9F808 = v2;
  }
  if ( v2 < 0 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      strcpy(v3, "pwm for fan init error");
      sub_47AB4(3, v3, 0);
    }
  }
  else
  {
    if ( a1 >= 100 )
      a1 = 100;
    if ( a1 < 5 )
      a1 = 5;
    if ( (unsigned int)dword_9E31C > 4 )
    {
      snprintf(v3, 0x800u, "FAN PWM: %d\n", a1);
      sub_47AB4(4, v3, 0);
      v2 = dword_9F808;
    }
    *(_DWORD *)dword_A0D68 = (a1 >> 1 << 16) | ((100 - a1) >> 1);
    *(_BYTE *)(dword_A0D68 + 12978) = a1;
    sub_675D4(v2, a1);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 9E320: using guessed type int dword_9E320;
// 9F808: using guessed type int dword_9F808;
// A0D68: using guessed type int dword_A0D68;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00014040) --------------------------------------------------------
int sub_14040()
{
  flt_9F7EC = -8.0;
  flt_9F7F0 = -1.0;
  flt_9F7F4 = -0.75;
  flt_9F7F8 = 0.0;
  flt_9F7E4 = 70.0;
  dword_9F7E0 = 1084227584;
  dword_9F7DC = 1120403456;
  return 1116471296;
}
// 9F7DC: using guessed type int dword_9F7DC;
// 9F7E0: using guessed type int dword_9F7E0;
// 9F7E4: using guessed type float flt_9F7E4;
// 9F7EC: using guessed type float flt_9F7EC;
// 9F7F0: using guessed type float flt_9F7F0;
// 9F7F4: using guessed type float flt_9F7F4;
// 9F7F8: using guessed type float flt_9F7F8;

//----- (0001409C) --------------------------------------------------------
void sub_1409C()
{
  float v0; // s0
  int v1; // r6
  int v2; // r5
  int v3; // r4
  int v4; // r0
  bool v5; // cc
  bool v6; // cc
  _BOOL4 v7; // r5
  int v8; // r8
  int v9; // r7
  int v10; // r6
  float v11; // s14
  signed int v12; // r0
  int v13; // r6
  char s[2048]; // [sp+18h] [bp-800h] BYREF

  sub_1758C();
  v1 = sub_171C0();
  v2 = sub_17264();
  v3 = sub_169E4();
  v4 = sub_16B30();
  v5 = v2 <= 2;
  if ( v2 <= 2 )
    v5 = v1 <= 2;
  if ( !v5 )
    goto LABEL_21;
  v6 = v4 <= 85;
  if ( v4 <= 85 )
    v6 = v3 <= 70;
  v7 = !v6;
  if ( !v6 )
  {
LABEL_21:
    v13 = sub_16940();
    flt_9F7E8 = (float)sub_16B30();
    sub_13BE8();
    sub_13EE8(100);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, " Air out temprature is too high, set fixed full fan speed\n");
      sub_47AB4(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "PWM keep 100:  airin_temp=%d, airout_temp=%f\n", v13, flt_9F7E8);
        sub_47AB4(3, s, 0);
      }
    }
    return;
  }
  if ( (byte_241D04 & 2) == 0 || (unsigned __int8)byte_241D0A > 0x64u )
  {
    sub_1758C();
    v8 = *(unsigned __int8 *)(dword_A0D68 + 12978);
    v9 = sub_16940();
    flt_9F7E8 = (float)sub_16B30();
    sub_13BE8();
    v10 = (int)v0 + v8;
    if ( v10 == *(unsigned __int8 *)(dword_A0D68 + 12978) )
      goto LABEL_19;
    v11 = (float)v10;
    if ( (float)v10 > *(float *)&dword_9F7E0 )
    {
      if ( v11 <= *(float *)&dword_9F7DC )
      {
        v12 = (unsigned __int8)(unsigned int)v11;
        goto LABEL_18;
      }
    }
    else if ( *(float *)&dword_9F7E0 <= *(float *)&dword_9F7DC )
    {
      v12 = (unsigned __int8)(unsigned int)*(float *)&dword_9F7E0;
LABEL_18:
      sub_13EE8(v12);
LABEL_19:
      if ( (unsigned int)dword_9E31C > 4 )
      {
        snprintf(
          s,
          0x800u,
          "PWM change from %d to %d:  airin_temp=%d, airout_temp=%f\n",
          *(unsigned __int8 *)(dword_A0D68 + 12978),
          v10,
          v9,
          flt_9F7E8);
        sub_47AB4(4, s, 0);
      }
      return;
    }
    v12 = (unsigned __int8)(unsigned int)*(float *)&dword_9F7DC;
    goto LABEL_18;
  }
  sub_13EE8((unsigned __int8)byte_241D0A);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "fan_etf: Set fixed fan speed=%d\n", (unsigned __int8)byte_241D0A);
    sub_47AB4(3, s, v7);
  }
}
// 14154: variable 'v0' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// 9F7DC: using guessed type int dword_9F7DC;
// 9F7E0: using guessed type int dword_9F7E0;
// 9F7E8: using guessed type float flt_9F7E8;
// A0D68: using guessed type int dword_A0D68;
// 241D04: using guessed type char byte_241D04;
// 241D0A: using guessed type char byte_241D0A;

//----- (00014350) --------------------------------------------------------
int sub_14350()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v1, "Note: front fan is power on!\n");
    sub_47AB4(3, v1, 0);
  }
  return sub_66518(0);
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000143B4) --------------------------------------------------------
int sub_143B4()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v1, "Note: front fan is power off!\n");
    sub_47AB4(3, v1, 0);
  }
  return sub_66564(0);
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00014420) --------------------------------------------------------
int sub_14420()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v1, "Note: rear fan is power on!\n");
    sub_47AB4(3, v1, 0);
  }
  return sub_66518(1);
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00014484) --------------------------------------------------------
int sub_14484()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v1, "Note: rear fan is power off!\n");
    sub_47AB4(3, v1, 0);
  }
  return sub_66564(1);
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000144E8) --------------------------------------------------------
int __fastcall sub_144E8(int a1, int a2)
{
  int v4; // r4
  int v5; // r5

  v4 = 8;
  do
  {
    v5 = sub_2EC38(28, a1, a2);
    if ( v5 )
      break;
    sub_4A804();
    --v4;
  }
  while ( v4 );
  return v5;
}

//----- (00014528) --------------------------------------------------------
int __fastcall sub_14528(int a1, int a2, int a3, int a4, unsigned __int8 *a5)
{
  int v9; // r8
  __int16 v10; // r10
  bool v11; // zf
  int v13; // r11
  int v14; // r10
  __int16 v15; // r8
  struct timeval v16; // [sp+8h] [bp-14h] BYREF
  struct timeval v17; // [sp+10h] [bp-Ch] BYREF

  sub_4A60C(&v16);
  if ( a4 )
  {
    v13 = 2;
    v14 = 0;
    while ( 1 )
    {
      sub_144E8(a2, a1);
      sub_1ADD4(0x98u, a3, *a5, 1, a2, a1);
      sub_144E8(a2, a1);
      sub_4A804();
      sub_144E8(a2, a1);
      sub_1ADD4(0x98u, a3, 0, 0, a2, a1);
      v15 = sub_144E8(a2, a1);
      sub_4A804();
      if ( HIBYTE(v15) == a3 || (unsigned __int8)v15 == *a5 )
        break;
      v11 = v13 == 1;
      v14 = 1;
      v13 = 1;
      if ( v11 )
      {
LABEL_6:
        sub_4A60C(&v17);
        return 0;
      }
    }
    sub_4A60C(&v17);
    if ( !v14 )
      return a4;
  }
  else
  {
    v9 = 2;
    while ( 1 )
    {
      sub_144E8(a2, a1);
      sub_1ADD4(0x98u, a3, 0, 0, a2, a1);
      sub_4A804();
      v10 = sub_144E8(a2, a1);
      sub_4A804();
      if ( HIBYTE(v10) == a3 )
        break;
      v11 = v9 == 1;
      a4 = 1;
      v9 = 1;
      if ( v11 )
        goto LABEL_6;
    }
    sub_4A60C(&v17);
    if ( !a4 && (_BYTE)v10 )
    {
      *a5 = v10;
      return 1;
    }
  }
  return 0;
}

//----- (000146C4) --------------------------------------------------------
int __fastcall sub_146C4(int a1)
{
  int v1; // r11
  _DWORD *v2; // r7
  int v3; // r9
  unsigned int v5; // r5
  int v6; // r4
  const char *v8; // r4
  unsigned __int8 v9; // [sp+15h] [bp-807h] BYREF
  unsigned __int8 v10; // [sp+16h] [bp-806h] BYREF
  unsigned __int8 v11; // [sp+17h] [bp-805h] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v1 = (unsigned __int8)a1;
  v2 = &dword_9F80C[27 * a1];
  v3 = 0;
  v9 = 0;
  while ( 2 )
  {
    v5 = *((unsigned __int8 *)v2 + 13);
    v6 = 4;
    v10 = 4;
    sub_1A954(v1, v5, 0, 1);
    sub_1A958(v1, v5, 0, 0);
    while ( 1 )
    {
      v11 = 0;
      sub_14528(a1, v5, 254, 0, &v11);
      if ( v11 == 26 )
      {
        v8 = "NCT218";
        goto LABEL_10;
      }
      if ( v11 == 85 )
        break;
      if ( !--v6 )
      {
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(
            s,
            0x800u,
            "Wrong temp sensor type, chain = %d, sensor = %d, type = 0x%x, retry.\n",
            a1,
            (unsigned __int8)(v5 / 3),
            v11);
          sub_47AB4(3, s, 0);
        }
        *(_BYTE *)(dword_A0D68 + a1 + 1112) = 0;
        return -1;
      }
    }
    v8 = "TMP451";
LABEL_10:
    v2[5] = v8;
    v2[8] = v8;
    ++v3;
    v9 = 0;
    sub_14528(a1, v5, 9, 1, &v10);
    sub_14528(a1, v5, 17, 1, &v9);
    v2 += 6;
    if ( v3 != 4 )
      continue;
    break;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "chain %d temp sensor %s\n", a1, v8);
    sub_47AB4(3, s, 0);
  }
  return 0;
}
// 1A954: using guessed type int __fastcall sub_1A954(_DWORD, _DWORD, _DWORD, _DWORD);
// 9E31C: using guessed type int dword_9E31C;
// 9F80C: using guessed type _DWORD dword_9F80C[432];
// A0D68: using guessed type int dword_A0D68;

//----- (000148B4) --------------------------------------------------------
int __fastcall sub_148B4(pthread_rwlock_t *a1)
{
  int result; // r0
  int *v2; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_init(a1, 0);
  if ( result )
  {
    v2 = _errno_location();
    snprintf(
      s,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v2,
      "temperature/temperature.c",
      "init_temp_info",
      658);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (00014930) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_14930(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// 14938: positive sp value 814 has been found
// 14938: unbalanced stack, ignored a potential tail call

//----- (0001493C) --------------------------------------------------------
int __fastcall sub_1493C(pthread_mutex_t *a1)
{
  int result; // r0
  int *v2; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_init(a1, 0);
  if ( result )
  {
    v2 = _errno_location();
    snprintf(
      s,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v2,
      "temperature/temperature.c",
      "init_temp_info",
      658);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (000149B8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_149B8(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// 149C0: positive sp value 814 has been found
// 149C0: unbalanced stack, ignored a potential tail call

//----- (000149C4) --------------------------------------------------------
int __fastcall sub_149C4(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_rdlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "temperature/temperature.c", a2, a3);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (00014A34) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_14A34(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 14A3C: positive sp value 814 has been found
// 14A3C: unbalanced stack, ignored a potential tail call

//----- (00014A40) --------------------------------------------------------
void __fastcall __noreturn sub_14A40(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "temperature/temperature.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (00014A98) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_14A98(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 14AA0: positive sp value 814 has been found
// 14AA0: unbalanced stack, ignored a potential tail call

//----- (00014AA4) --------------------------------------------------------
void __fastcall __noreturn sub_14AA4(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "temperature/temperature.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (00014AFC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_14AFC(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 14B04: positive sp value 814 has been found
// 14B04: unbalanced stack, ignored a potential tail call

//----- (00014B08) --------------------------------------------------------
void __fastcall __noreturn sub_14B08(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "temperature/temperature.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (00014B60) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_14B60(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 14B68: positive sp value 814 has been found
// 14B68: unbalanced stack, ignored a potential tail call

//----- (00014B6C) --------------------------------------------------------
void sub_14B6C()
{
  FILE *v0; // r0
  FILE *v1; // r4

  v0 = (FILE *)fopen64("/tmp/check_chip_type_failed", "r");
  if ( v0 )
  {
    fclose(v0);
    sub_226C0(0xDu, "Can't get temperature sensor type!");
  }
  else
  {
    v1 = (FILE *)fopen64("/tmp/check_chip_type_failed", "w+");
    if ( v1 )
    {
      fwrite("Can't get temperature sensor type.\n", 0x23u, 1u, v1);
      fclose(v1);
    }
    sub_226C0(0xCu, "Re-run cgminer to check temerature sensor type again!");
  }
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00014BF4) --------------------------------------------------------
void sub_14BF4()
{
  int v0; // r9
  int v1; // r10
  int v2; // r9
  int v3; // r9
  int v4; // r5
  int v5; // r9
  int *v6; // r0
  int *v7; // r0
  int *v8; // r0
  int v9; // r9
  int *v10; // r0
  int *v11; // r0
  int *v12; // r0
  int v13; // r9
  int *v14; // r0
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  int *v18; // r0
  int *v19; // r0
  int *v20; // r0
  int *v21; // r0
  int *v22; // r0
  int *v23; // r0
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  int *v27; // r0
  int *v28; // r0
  int *v29; // r0
  int *v30; // r0
  int *v31; // r0
  int *v32; // r0
  int *v33; // r0
  int *v34; // r0
  int *v35; // r0
  int *v36; // r0
  int *v37; // r0
  int *v38; // r0
  int *v39; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( !pthread_mutex_lock(&mutex) )
      goto LABEL_3;
LABEL_73:
    v17 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v17,
      "temperature/temperature.c",
      "get_pcb_temp_min",
      807);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  strcpy(s, "  pcb temp ");
  sub_47EC8(3, s, 0);
  if ( pthread_mutex_lock(&mutex) )
    goto LABEL_73;
LABEL_3:
  if ( pthread_rwlock_rdlock(&stru_9FEE4) )
  {
    v18 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v18,
      "temperature/temperature.c",
      "get_pcb_temp_min",
      807);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock(&mutex) )
  {
    v19 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v19,
      "temperature/temperature.c",
      "get_pcb_temp_min",
      807);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v0 = (__int16)dword_9FF08;
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
  {
    v21 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v21,
      "temperature/temperature.c",
      "get_pcb_temp_min",
      807);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  off_9E444();
  if ( v0 == 255 )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
    {
LABEL_8:
      if ( !pthread_mutex_lock(&mutex) )
        goto LABEL_9;
LABEL_61:
      v14 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v14,
        "temperature/temperature.c",
        "get_pcb_temp_max",
        812);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    strcpy(s, "INVALID");
    sub_47EC8(3, s, 0);
  }
  else
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_8;
    if ( pthread_mutex_lock(&mutex) )
    {
      v26 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v26,
        "temperature/temperature.c",
        "get_pcb_temp_min",
        807);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_rwlock_rdlock(&stru_9FEE4) )
    {
      v35 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v35,
        "temperature/temperature.c",
        "get_pcb_temp_min",
        807);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_mutex_unlock(&mutex) )
    {
      v39 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v39,
        "temperature/temperature.c",
        "get_pcb_temp_min",
        807);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    v13 = (__int16)dword_9FF08;
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
    {
      v38 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v38,
        "temperature/temperature.c",
        "get_pcb_temp_min",
        807);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    off_9E444();
    snprintf(s, 0x800u, "%d", v13);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_8;
  strcpy(s, "~");
  sub_47EC8(3, s, 0);
  if ( pthread_mutex_lock(&mutex) )
    goto LABEL_61;
LABEL_9:
  if ( pthread_rwlock_rdlock(&stru_9FEE4) )
  {
    v15 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v15,
      "temperature/temperature.c",
      "get_pcb_temp_max",
      812);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock(&mutex) )
  {
    v16 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v16,
      "temperature/temperature.c",
      "get_pcb_temp_max",
      812);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v1 = (__int16)dword_9FF04;
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
  {
    v20 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v20,
      "temperature/temperature.c",
      "get_pcb_temp_max",
      812);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  off_9E444();
  if ( v1 == 255 )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
    {
LABEL_14:
      if ( !pthread_mutex_lock(&mutex) )
        goto LABEL_15;
LABEL_51:
      v10 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v10,
        "temperature/temperature.c",
        "get_chip_temp_min",
        817);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    strcpy(s, "INVALID");
    sub_47EC8(3, s, 0);
  }
  else
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    if ( pthread_mutex_lock(&mutex) )
    {
      v25 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v25,
        "temperature/temperature.c",
        "get_pcb_temp_max",
        812);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_rwlock_rdlock(&stru_9FEE4) )
    {
      v37 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v37,
        "temperature/temperature.c",
        "get_pcb_temp_max",
        812);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_mutex_unlock(&mutex) )
    {
      v36 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v36,
        "temperature/temperature.c",
        "get_pcb_temp_max",
        812);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    v9 = (__int16)dword_9FF04;
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
    {
      v31 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v31,
        "temperature/temperature.c",
        "get_pcb_temp_max",
        812);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    off_9E444();
    snprintf(s, 0x800u, "%d", v9);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_14;
  strcpy(s, "  chip temp ");
  sub_47EC8(3, s, 0);
  if ( pthread_mutex_lock(&mutex) )
    goto LABEL_51;
LABEL_15:
  if ( pthread_rwlock_rdlock(&stru_9FEE4) )
  {
    v11 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v11,
      "temperature/temperature.c",
      "get_chip_temp_min",
      817);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock(&mutex) )
  {
    v12 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v12,
      "temperature/temperature.c",
      "get_chip_temp_min",
      817);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v2 = SHIWORD(dword_9FF08);
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
  {
    v22 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v22,
      "temperature/temperature.c",
      "get_chip_temp_min",
      817);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  off_9E444();
  if ( v2 == 255 )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
    {
LABEL_20:
      if ( !pthread_mutex_lock(&mutex) )
        goto LABEL_21;
LABEL_41:
      v6 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v6,
        "temperature/temperature.c",
        "get_chip_temp_max",
        822);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    strcpy(s, "INVALID");
    sub_47EC8(3, s, 0);
  }
  else
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_20;
    if ( pthread_mutex_lock(&mutex) )
    {
      v24 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v24,
        "temperature/temperature.c",
        "get_chip_temp_min",
        817);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_rwlock_rdlock(&stru_9FEE4) )
    {
      v30 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v30,
        "temperature/temperature.c",
        "get_chip_temp_min",
        817);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_mutex_unlock(&mutex) )
    {
      v29 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v29,
        "temperature/temperature.c",
        "get_chip_temp_min",
        817);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    v5 = SHIWORD(dword_9FF08);
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
    {
      v28 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v28,
        "temperature/temperature.c",
        "get_chip_temp_min",
        817);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    off_9E444();
    snprintf(s, 0x800u, "%d", v5);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_20;
  strcpy(s, "~");
  sub_47EC8(3, s, 0);
  if ( pthread_mutex_lock(&mutex) )
    goto LABEL_41;
LABEL_21:
  if ( pthread_rwlock_rdlock(&stru_9FEE4) )
  {
    v7 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v7,
      "temperature/temperature.c",
      "get_chip_temp_max",
      822);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock(&mutex) )
  {
    v8 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v8,
      "temperature/temperature.c",
      "get_chip_temp_max",
      822);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v3 = SHIWORD(dword_9FF04);
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
  {
    v23 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v23,
      "temperature/temperature.c",
      "get_chip_temp_max",
      822);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  off_9E444();
  if ( v3 == 255 )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    strcpy(s, "INVALID");
    sub_47EC8(3, s, 0);
  }
  else
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    if ( pthread_mutex_lock(&mutex) )
    {
      v27 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v27,
        "temperature/temperature.c",
        "get_chip_temp_max",
        822);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_rwlock_rdlock(&stru_9FEE4) )
    {
      v33 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v33,
        "temperature/temperature.c",
        "get_chip_temp_max",
        822);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_mutex_unlock(&mutex) )
    {
      v32 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v32,
        "temperature/temperature.c",
        "get_chip_temp_max",
        822);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    v4 = SHIWORD(dword_9FF04);
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
    {
      v34 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v34,
        "temperature/temperature.c",
        "get_chip_temp_max",
        822);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    off_9E444();
    snprintf(s, 0x800u, "%d", v4);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "\n");
    sub_47EC8(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF04: using guessed type int dword_9FF04;
// 9FF08: using guessed type int dword_9FF08;

//----- (00015C50) --------------------------------------------------------
int sub_15C50()
{
  int result; // r0
  int v1; // r5
  pthread_mutex_t *v2; // r2
  _BYTE *v3; // lr
  int v4; // t1
  char *v5; // r9
  char *v6; // r3
  char i; // r1
  char v8; // t1
  pthread_mutex_t *v9; // r3
  int v10; // r1

  sub_1493C(&stru_2440BC);
  sub_148B4(&rwlock);
  dword_9FF04 = 0;
  dword_9FF08 = 0;
  dword_9FF0C = 0;
  memset(dword_9F80C, 0, sizeof(dword_9F80C));
  memset(&unk_9FF10, 0, 0x6C0u);
  result = sub_14040();
  v1 = dword_A0D68;
  dword_9FF0C = 0;
  v2 = (pthread_mutex_t *)dword_9F80C;
  dword_9FF04 = -8257663;
  dword_9FF08 = 16711935;
  v3 = (_BYTE *)(dword_A0D68 + 1112);
  do
  {
    v4 = *(_DWORD *)(v1 + 4);
    v1 += 4;
    if ( v4 == 1 )
    {
      v5 = (char *)&unk_77D51;
      v6 = (char *)v2;
      for ( i = 17; ; i = v8 )
      {
        v6[12] = i;
        v6 += 24;
        result = (unsigned __int8)(3 * i);
        *(v6 - 10) = 0;
        *v6 = i;
        *(v6 - 11) = result;
        v6[1] = result;
        v6[2] = 1;
        if ( v5 == "get_temp_stats" )
          break;
        v8 = *v5++;
      }
      v9 = v2;
      v10 = 0;
      LOWORD(v2->__lock) = -127;
      *((_WORD *)&v2->__align + 2) = 255;
      *((_WORD *)&v2->__align + 4) = 0;
      *(_WORD *)&v2->__size[2] = -127;
      *((_WORD *)&v2->__align + 3) = 255;
      *((_WORD *)&v2->__align + 5) = 0;
      do
      {
        ++v10;
        *((_WORD *)&v9->__align + 8) = 255;
        v9->__size[15] = 1;
        *((_WORD *)&v9[1].__align + 2) = 255;
        ++v9;
        v9->__size[3] = 1;
      }
      while ( v10 != 4 );
      *v3 = 4;
    }
    v2 = (pthread_mutex_t *)((char *)v2 + 108);
    ++v3;
  }
  while ( v2 != &mutex );
  return result;
}
// 9F80C: using guessed type _DWORD dword_9F80C[432];
// 9FF04: using guessed type int dword_9FF04;
// 9FF08: using guessed type int dword_9FF08;
// 9FF0C: using guessed type int dword_9FF0C;
// A0D68: using guessed type int dword_A0D68;
// 2440BC: using guessed type pthread_mutex_t stru_2440BC;

//----- (00015DA8) --------------------------------------------------------
int sub_15DA8()
{
  int i; // r4
  int result; // r0

  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        goto LABEL_6;
    }
    result = sub_146C4(i);
    if ( result )
      return result;
  }
LABEL_6:
  remove("/tmp/check_chip_type_failed");
  return 0;
}
// A0D68: using guessed type int dword_A0D68;

//----- (00015E0C) --------------------------------------------------------
int sub_15E0C()
{
  int i; // r4
  char *v1; // r6
  int j; // r5
  int v3; // r1

  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        return 0;
    }
    v1 = (char *)&unk_9F80C + 108 * i;
    for ( j = 0; j != 4; ++j )
    {
      v3 = (unsigned __int8)v1[13];
      v1 += 24;
      sub_1A954((unsigned __int8)i, v3, 0, 1);
    }
  }
  return 0;
}
// 1A954: using guessed type int __fastcall sub_1A954(_DWORD, _DWORD, _DWORD, _DWORD);
// A0D68: using guessed type int dword_A0D68;

//----- (00015E90) --------------------------------------------------------
void __fastcall sub_15E90(int a1)
{
  int v1; // r4
  _WORD *v2; // r9
  int i; // r10
  int v4; // r1
  _WORD *v5; // r3
  _WORD *v6; // r11
  int j; // r6
  _WORD *v8; // r4
  int v9; // r5
  int v10; // r2
  int v11; // r1
  int v12; // r3
  double v13; // d7
  double v14; // d6
  double v15; // d6
  int v16; // r9
  pthread_mutex_t *v17; // r11
  pthread_mutex_t *v18; // r5
  int v19; // t1
  pthread_mutex_t *v20; // r12
  int k; // r0
  pthread_mutex_t *v22; // r2
  int m; // r3
  int v24; // lr
  __int16 v25; // r1
  bool v26; // zf
  __int16 v27; // r1
  pthread_mutex_t *v28; // r10
  int v29; // r6
  int v30; // t1
  pthread_mutex_t *v31; // r4
  int n; // lr
  pthread_mutex_t *v33; // r1
  int ii; // r2
  int v35; // r0
  __int16 v36; // r3
  bool v37; // zf
  int v38; // r4
  int v39; // r9
  int v40; // r10
  _DWORD *v41; // r8
  _DWORD *v42; // r4
  int jj; // r6
  int v44; // r5
  int v45; // r2
  bool v46; // zf
  int v47; // r2
  int v48; // r1
  int v49; // r3
  const char *v50; // r3
  int v51; // t1
  pthread_mutex_t *v52; // r6
  int kk; // lr
  pthread_mutex_t *v54; // r0
  pthread_mutex_t *v55; // r1
  int v56; // r12
  int v57; // r2
  int v58; // r3
  int v59; // r2
  int *v60; // r3
  pthread_mutex_t *v61; // r0
  int v62; // r1
  int align_low; // r2
  int v64; // r1
  int v65; // r2
  __int16 v66; // r8
  int v67; // r2
  int v68; // r1
  const char *v69; // r3
  int *v70; // r0
  int *v71; // r0
  int *v72; // r0
  int *v73; // r0
  unsigned int v75; // [sp+20h] [bp-834h]
  unsigned int v76; // [sp+2Ch] [bp-828h]
  unsigned int v77; // [sp+30h] [bp-824h]
  pthread_mutex_t *v78; // [sp+30h] [bp-824h]
  unsigned int v79; // [sp+34h] [bp-820h]
  int v80; // [sp+3Ch] [bp-818h]
  unsigned __int8 v81; // [sp+43h] [bp-811h] BYREF
  int v82; // [sp+44h] [bp-810h] BYREF
  int v83; // [sp+48h] [bp-80Ch] BYREF
  int v84; // [sp+4Ch] [bp-808h]
  char s[2052]; // [sp+50h] [bp-804h] BYREF

  v1 = dword_A0D68;
  v2 = dword_9F80C;
  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(v1 + 4 * i + 4) != 1 )
    {
      ++i;
      v2 += 54;
      if ( i == 16 )
        goto LABEL_22;
    }
    v4 = 0;
    v5 = v2;
    v2[2] = 255;
    v2[3] = 255;
    v2[4] = 0;
    v2[5] = 0;
    *v2 = -127;
    v2[1] = -127;
    do
    {
      ++v4;
      v5[8] = 255;
      *((_BYTE *)v5 + 15) = 1;
      v5[14] = 255;
      v5 += 12;
      *((_BYTE *)v5 + 3) = 1;
    }
    while ( v4 != 4 );
    v6 = v2;
    for ( j = 0; j != 4; ++j )
    {
      v8 = v6;
      v9 = 0;
      do
      {
        v10 = *((unsigned __int8 *)v8 + 14);
        v11 = *((unsigned __int8 *)v8 + 13);
        v81 = -1;
        if ( sub_14528(i, v11, v10, 0, &v81) )
        {
          v12 = (__int16)(v81 - 64);
          if ( v9 )
          {
            v13 = (double)v12;
            if ( a1 )
              v14 = 8.2952;
            else
              v14 = 11.243;
            if ( a1 )
              v15 = v13 * 0.8755 - v14;
            else
              v15 = v13 * 0.9705 - v14;
            LOWORD(v12) = (int)v15;
          }
          v8[8] = v12;
          *((_BYTE *)v8 + 15) = 0;
        }
        else
        {
          v8[8] = 255;
          *((_BYTE *)v8 + 15) = 1;
          if ( (unsigned int)dword_9E31C > 3 )
          {
            snprintf(
              s,
              0x800u,
              "read temp sensor failed: chain = %d, sensor = %d, chip = %d, reg = %d\n",
              i,
              j,
              *((unsigned __int8 *)v8 + 13),
              *((unsigned __int8 *)v8 + 14));
            sub_47AB4(3, s, 0);
          }
        }
        v26 = v9 == 1;
        v8 += 6;
        v9 = 1;
      }
      while ( !v26 );
      v6 += 12;
    }
    v2 += 54;
    v1 = dword_A0D68;
  }
LABEL_22:
  v16 = v1;
  v17 = (pthread_mutex_t *)dword_9F80C;
  dword_A05D0 = 0;
  dword_A05D4 = 0;
  dword_A05D8 = 0;
  dword_A05DC = 0;
  v18 = (pthread_mutex_t *)dword_9F80C;
  do
  {
    while ( 1 )
    {
      v19 = *(_DWORD *)(v16 + 4);
      v16 += 4;
      if ( v19 == 1 )
        break;
      v18 = (pthread_mutex_t *)((char *)v18 + 108);
      if ( v18 == &mutex )
        goto LABEL_36;
    }
    v20 = v18;
    for ( k = 0; k != 4; ++k )
    {
      v22 = v20;
      for ( m = 0; m != 4; m += 2 )
      {
        if ( !v22->__size[15] )
        {
          v24 = (unsigned __int8)v22->__size[12];
          v25 = *((_WORD *)&v22->__align + 8);
          v26 = v24 == 65;
          if ( v24 != 65 )
            v26 = v24 == 17;
          if ( v26 )
          {
            v27 = v25 + *(_WORD *)((char *)&dword_A05D0 + m);
            ++*(_WORD *)((char *)&dword_A05D8 + m);
            *(_WORD *)((char *)&dword_A05D0 + m) = v27;
          }
          else
          {
            v66 = *(_WORD *)((char *)&dword_A05D4 + m);
            ++*(_WORD *)((char *)&dword_A05DC + m);
            *(_WORD *)((char *)&dword_A05D4 + m) = v25 + v66;
          }
        }
        v22 = (pthread_mutex_t *)((char *)v22 + 12);
      }
      ++v20;
    }
    v18 = (pthread_mutex_t *)((char *)v18 + 108);
  }
  while ( v18 != &mutex );
LABEL_36:
  v79 = (__int16)dword_A05D8;
  if ( (_WORD)dword_A05D8 )
    LOWORD(dword_A05D0) = sub_772E8((__int16)dword_A05D0, (__int16)dword_A05D8);
  v77 = (__int16)dword_A05DC;
  if ( (_WORD)dword_A05DC )
    LOWORD(dword_A05D4) = sub_772E8((__int16)dword_A05D4, (__int16)dword_A05DC);
  v75 = SHIWORD(dword_A05D8);
  if ( HIWORD(dword_A05D8) )
    HIWORD(dword_A05D0) = sub_772E8(SHIWORD(dword_A05D0), SHIWORD(dword_A05D8));
  v76 = SHIWORD(dword_A05DC);
  if ( HIWORD(dword_A05DC) )
    HIWORD(dword_A05D4) = sub_772E8(SHIWORD(dword_A05D4), SHIWORD(dword_A05DC));
  v80 = v1;
  dword_A05E0 = 0;
  dword_A05E4 = 0;
  v28 = (pthread_mutex_t *)dword_9F80C;
  v29 = v1;
  do
  {
    while ( 1 )
    {
      v30 = *(_DWORD *)(v29 + 4);
      v29 += 4;
      if ( v30 == 1 )
        break;
      v28 = (pthread_mutex_t *)((char *)v28 + 108);
      if ( v28 == v18 )
        goto LABEL_58;
    }
    v31 = v28;
    for ( n = 0; n != 4; ++n )
    {
      v33 = v31;
      for ( ii = 0; ii != 4; ii += 2 )
      {
        if ( !v33->__size[15] )
        {
          v35 = (unsigned __int8)v33->__size[12];
          v36 = *((_WORD *)&v33->__align + 8);
          v37 = v35 == 65;
          if ( v35 != 65 )
            v37 = v35 == 17;
          if ( v37 )
            *(_WORD *)((char *)&dword_A05E0 + ii) += (v36 - *(_WORD *)((char *)&dword_A05D0 + ii))
                                                   * (v36 - *(_WORD *)((char *)&dword_A05D0 + ii));
          else
            *(_WORD *)((char *)&dword_A05E4 + ii) += (v36 - *(_WORD *)((char *)&dword_A05D4 + ii))
                                                   * (v36 - *(_WORD *)((char *)&dword_A05D4 + ii));
        }
        v33 = (pthread_mutex_t *)((char *)v33 + 12);
      }
      ++v31;
    }
    v28 = (pthread_mutex_t *)((char *)v28 + 108);
  }
  while ( v28 != v18 );
LABEL_58:
  v38 = v80;
  if ( v79 )
    LOWORD(dword_A05E0) = sub_772E8((__int16)dword_A05E0, v79);
  if ( v77 )
    LOWORD(dword_A05E4) = sub_772E8((__int16)dword_A05E4, v77);
  if ( v75 )
    HIWORD(dword_A05E0) = sub_772E8(SHIWORD(dword_A05E0), v75);
  if ( v76 )
    HIWORD(dword_A05E4) = sub_772E8(SHIWORD(dword_A05E4), v76);
  v39 = 0;
  v78 = v28;
  do
  {
    while ( *(_DWORD *)(v38 + 4 * v39 + 4) != 1 )
    {
      if ( ++v39 == 16 )
        goto LABEL_85;
    }
    v40 = 0;
    v41 = &dword_9F80C[27 * v39];
    do
    {
      v42 = v41;
      for ( jj = 0; ; jj = 1 )
      {
        v44 = *((unsigned __int8 *)v42 + 15);
        if ( !*((_BYTE *)v42 + 15) )
        {
          v45 = *((unsigned __int8 *)v42 + 12);
          v46 = v45 == 65;
          if ( v45 != 65 )
            v46 = v45 == 17;
          if ( v46 )
          {
            v47 = *((__int16 *)&dword_A05E0 + jj);
            if ( v47 > 100 )
            {
              v48 = *((__int16 *)v42 + 8);
              v49 = v48 - *((__int16 *)&dword_A05D0 + jj);
              if ( (float)(v49 * v49) > (float)((float)v47 * 2.7) )
              {
                *((_BYTE *)v42 + 15) = 1;
                if ( (unsigned int)dword_9E31C > 3 )
                {
                  v50 = "chip";
                  if ( !jj )
                    v50 = "pcb";
                  snprintf(
                    s,
                    0x800u,
                    "[OUTLIER] air_in, chain = %d, sensor = %d, chip = %d, type = %s, temp = %d\n",
                    v39,
                    v40,
                    *((unsigned __int8 *)v42 + 13),
                    v50,
                    v48);
                  sub_47AB4(3, s, v44);
                }
              }
            }
          }
          else
          {
            v67 = *((__int16 *)&dword_A05E4 + jj);
            if ( v67 > 100 )
            {
              v68 = *((__int16 *)v42 + 8);
              if ( (float)((v68 - *((__int16 *)&dword_A05D4 + jj)) * (v68 - *((__int16 *)&dword_A05D4 + jj))) > (float)((float)v67 * 2.7) )
              {
                *((_BYTE *)v42 + 15) = 1;
                if ( (unsigned int)dword_9E31C > 3 )
                {
                  v69 = "chip";
                  if ( !jj )
                    v69 = "pcb";
                  snprintf(
                    s,
                    0x800u,
                    "[OUTLIER] air_out, chain = %d, sensor = %d, chip = %d, type = %s, temp = %d\n",
                    v39,
                    v40,
                    *((unsigned __int8 *)v42 + 13),
                    v69,
                    v68);
                  sub_47AB4(3, s, 0);
                }
              }
            }
          }
        }
        v42 += 3;
        if ( jj == 1 )
          break;
      }
      ++v40;
      v41 += 6;
    }
    while ( v40 != 4 );
    ++v39;
    v38 = dword_A0D68;
  }
  while ( v39 != 16 );
LABEL_85:
  v83 = 16711935;
  v82 = -8257663;
  v84 = 0;
  do
  {
    while ( 1 )
    {
      v51 = *(_DWORD *)(v38 + 4);
      v38 += 4;
      if ( v51 == 1 )
        break;
      v17 = (pthread_mutex_t *)((char *)v17 + 108);
      if ( v17 == v78 )
        goto LABEL_106;
    }
    v52 = v17;
    for ( kk = 0; kk != 4; ++kk )
    {
      v54 = v52;
      v55 = v17;
      v56 = 0;
      do
      {
        v57 = (unsigned __int8)v54->__size[15];
        *((_WORD *)&v55->__align + 4) += v57;
        if ( !v57 )
        {
          v58 = *((__int16 *)&v54->__align + 8);
          v59 = *((__int16 *)&v55->__align + 2);
          if ( SLOWORD(v55->__align) < v58 )
            LOWORD(v55->__lock) = v58;
          if ( v59 > v58 )
            *((_WORD *)&v55->__align + 2) = v58;
        }
        v26 = v56 == 1;
        v55 = (pthread_mutex_t *)((char *)v55 + 2);
        v56 = 1;
        v54 = (pthread_mutex_t *)((char *)v54 + 12);
      }
      while ( !v26 );
      ++v52;
    }
    v60 = &v82;
    v61 = v17;
    do
    {
      v62 = *((__int16 *)&v61->__align + 4);
      *((_WORD *)v60 + 4) += v62;
      if ( v62 != 4 )
      {
        align_low = SLOWORD(v61->__align);
        v64 = *((__int16 *)v60 + 2);
        if ( *(__int16 *)v60 < align_low )
          *(_WORD *)v60 = align_low;
        v65 = *((__int16 *)&v61->__align + 2);
        if ( v64 > v65 )
          *((_WORD *)v60 + 2) = v65;
      }
      v60 = (int *)((char *)v60 + 2);
      v61 = (pthread_mutex_t *)((char *)v61 + 2);
    }
    while ( &v83 != v60 );
    v17 = (pthread_mutex_t *)((char *)v17 + 108);
  }
  while ( v17 != v78 );
LABEL_106:
  if ( pthread_mutex_lock(&mutex) )
  {
    v71 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v71,
      "temperature/temperature.c",
      "get_temp_stats",
      450);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_rwlock_wrlock(&stru_9FEE4) )
  {
    v72 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v72,
      "temperature/temperature.c",
      "get_temp_stats",
      450);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  memcpy(&unk_9FF10, dword_9F80C, 0x6C0u);
  dword_9FF04 = v82;
  dword_9FF08 = v83;
  dword_9FF0C = v84;
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
  {
    v73 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v73,
      "temperature/temperature.c",
      "get_temp_stats",
      453);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock(&mutex) )
  {
    v70 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v70,
      "temperature/temperature.c",
      "get_temp_stats",
      453);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  off_9E444();
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(
      s,
      0x800u,
      "[GLOBAL TEMP]  PCB: %d ~ %d, bad = %d; CHIP: %d ~ %d, bad = %d;\n",
      (__int16)dword_9FF08,
      (__int16)dword_9FF04,
      (__int16)dword_9FF0C,
      SHIWORD(dword_9FF08),
      SHIWORD(dword_9FF04),
      SHIWORD(dword_9FF0C));
    sub_47AB4(4, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 9E444: using guessed type int (*off_9E444)();
// 9F80C: using guessed type _DWORD dword_9F80C[432];
// 9FEE4: using guessed type pthread_rwlock_t;
// 9FF04: using guessed type int dword_9FF04;
// 9FF08: using guessed type int dword_9FF08;
// 9FF0C: using guessed type int dword_9FF0C;
// A05D0: using guessed type int dword_A05D0;
// A05D4: using guessed type int dword_A05D4;
// A05D8: using guessed type int dword_A05D8;
// A05DC: using guessed type int dword_A05DC;
// A05E0: using guessed type int dword_A05E0;
// A05E4: using guessed type int dword_A05E4;
// A0D68: using guessed type int dword_A0D68;

//----- (0001691C) --------------------------------------------------------
int __fastcall sub_1691C(int a1, int a2)
{
  return dword_9F80C[27 * a1 + 5 + 6 * a2];
}
// 9F80C: using guessed type _DWORD dword_9F80C[432];

//----- (00016940) --------------------------------------------------------
int sub_16940()
{
  int v0; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_pcb_temp_min", 807);
  sub_149C4(&stru_9FEE4, "get_pcb_temp_min", 807);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_pcb_temp_min", 807);
  v0 = (__int16)dword_9FF08;
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_pcb_temp_min", 807);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF08: using guessed type int dword_9FF08;

//----- (000169E4) --------------------------------------------------------
int sub_169E4()
{
  int v0; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_pcb_temp_max", 812);
  sub_149C4(&stru_9FEE4, "get_pcb_temp_max", 812);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_pcb_temp_max", 812);
  v0 = (__int16)dword_9FF04;
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_pcb_temp_max", 812);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF04: using guessed type int dword_9FF04;

//----- (00016A8C) --------------------------------------------------------
int sub_16A8C()
{
  int v0; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_chip_temp_min", 817);
  sub_149C4(&stru_9FEE4, "get_chip_temp_min", 817);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_chip_temp_min", 817);
  v0 = SHIWORD(dword_9FF08);
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_chip_temp_min", 817);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF08: using guessed type int dword_9FF08;

//----- (00016B30) --------------------------------------------------------
int sub_16B30()
{
  int v0; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_chip_temp_max", 822);
  sub_149C4(&stru_9FEE4, "get_chip_temp_max", 822);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_chip_temp_max", 822);
  v0 = SHIWORD(dword_9FF04);
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_chip_temp_max", 822);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF04: using guessed type int dword_9FF04;

//----- (00016BD4) --------------------------------------------------------
int __fastcall sub_16BD4(int a1)
{
  int v2; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_pcb_temp_min_one_chain", 827);
  sub_149C4(&stru_9FEE4, "get_pcb_temp_min_one_chain", 827);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_pcb_temp_min_one_chain", 827);
  v2 = word_9FF10[54 * a1 + 2];
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_pcb_temp_min_one_chain", 827);
  off_9E444();
  return v2;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF10: using guessed type __int16 word_9FF10[864];

//----- (00016C84) --------------------------------------------------------
int __fastcall sub_16C84(int a1)
{
  int v2; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_pcb_temp_max_one_chain", 832);
  sub_149C4(&stru_9FEE4, "get_pcb_temp_max_one_chain", 832);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_pcb_temp_max_one_chain", 832);
  v2 = word_9FF10[54 * a1];
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_pcb_temp_max_one_chain", 832);
  off_9E444();
  return v2;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF10: using guessed type __int16 word_9FF10[864];

//----- (00016D34) --------------------------------------------------------
int __fastcall sub_16D34(int a1)
{
  int v2; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_chip_temp_min_one_chain", 837);
  sub_149C4(&stru_9FEE4, "get_chip_temp_min_one_chain", 837);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_chip_temp_min_one_chain", 837);
  v2 = word_9FF10[54 * a1 + 3];
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_chip_temp_min_one_chain", 837);
  off_9E444();
  return v2;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF10: using guessed type __int16 word_9FF10[864];

//----- (00016DE4) --------------------------------------------------------
int __fastcall sub_16DE4(int a1)
{
  int v2; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_chip_temp_max_one_chain", 842);
  sub_149C4(&stru_9FEE4, "get_chip_temp_max_one_chain", 842);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_chip_temp_max_one_chain", 842);
  v2 = word_9FF10[54 * a1 + 1];
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_chip_temp_max_one_chain", 842);
  off_9E444();
  return v2;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF10: using guessed type __int16 word_9FF10[864];

//----- (00016E94) --------------------------------------------------------
int __fastcall sub_16E94(int a1, int a2)
{
  int v4; // r1
  int v5; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_pcb_temp", 850);
  sub_149C4(&stru_9FEE4, "get_pcb_temp", 850);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_pcb_temp", 850);
  v4 = 108 * a1 + 24 * a2;
  if ( *((_BYTE *)&dword_9F80C[452] + v4 + 3) )
  {
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
      sub_14AA4("get_pcb_temp", 859);
    off_9E444();
    if ( pthread_mutex_lock(&mutex) )
      sub_14B08("get_pcb_temp_max", 812);
    sub_149C4(&stru_9FEE4, "get_pcb_temp_max", 812);
    if ( pthread_mutex_unlock(&mutex) )
      sub_14A40("get_pcb_temp_max", 812);
    v5 = (__int16)dword_9FF04;
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
      sub_14AA4("get_pcb_temp_max", 812);
  }
  else
  {
    v5 = *(__int16 *)((char *)&word_9FF10[8] + v4);
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
      sub_14AA4("get_pcb_temp", 856);
  }
  off_9E444();
  return v5;
}
// 9E444: using guessed type int (*off_9E444)();
// 9F80C: using guessed type _DWORD dword_9F80C[432];
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF04: using guessed type int dword_9FF04;
// 9FF10: using guessed type __int16 word_9FF10[864];

//----- (00017028) --------------------------------------------------------
int __fastcall sub_17028(int a1, int a2)
{
  int v4; // r1
  int v5; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_chip_temp", 870);
  sub_149C4(&stru_9FEE4, "get_chip_temp", 870);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_chip_temp", 870);
  v4 = 108 * a1 + 24 * a2;
  if ( *((_BYTE *)&dword_9F80C[455] + v4 + 3) )
  {
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
      sub_14AA4("get_chip_temp", 879);
    off_9E444();
    if ( pthread_mutex_lock(&mutex) )
      sub_14B08("get_chip_temp_max", 822);
    sub_149C4(&stru_9FEE4, "get_chip_temp_max", 822);
    if ( pthread_mutex_unlock(&mutex) )
      sub_14A40("get_chip_temp_max", 822);
    v5 = SHIWORD(dword_9FF04);
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
      sub_14AA4("get_chip_temp_max", 822);
  }
  else
  {
    v5 = *(__int16 *)((char *)&word_9FF10[14] + v4);
    if ( pthread_rwlock_unlock(&stru_9FEE4) )
      sub_14AA4("get_chip_temp", 876);
  }
  off_9E444();
  return v5;
}
// 9E444: using guessed type int (*off_9E444)();
// 9F80C: using guessed type _DWORD dword_9F80C[432];
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF04: using guessed type int dword_9FF04;
// 9FF10: using guessed type __int16 word_9FF10[864];

//----- (000171C0) --------------------------------------------------------
int sub_171C0()
{
  int v0; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_pcb_temp_bad", 887);
  sub_149C4(&stru_9FEE4, "get_pcb_temp_bad", 887);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_pcb_temp_bad", 887);
  v0 = (__int16)dword_9FF0C;
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_pcb_temp_bad", 887);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF0C: using guessed type int dword_9FF0C;

//----- (00017264) --------------------------------------------------------
int sub_17264()
{
  int v0; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_14B08("get_chip_temp_bad", 892);
  sub_149C4(&stru_9FEE4, "get_chip_temp_bad", 892);
  if ( pthread_mutex_unlock(&mutex) )
    sub_14A40("get_chip_temp_bad", 892);
  v0 = SHIWORD(dword_9FF0C);
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
    sub_14AA4("get_chip_temp_bad", 892);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF0C: using guessed type int dword_9FF0C;

//----- (00017308) --------------------------------------------------------
int sub_17308()
{
  int v0; // r5
  int *v2; // r0
  int *v3; // r0
  int *v4; // r0
  int *v5; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "Enter 30s sleep to cool down hash board, waiting...\n");
    sub_47AB4(3, s, 0);
  }
  sub_4A804();
  sub_15C50();
  if ( sub_15DA8() )
    sub_14B6C();
  sub_15E90(0);
  if ( pthread_mutex_lock(&mutex) )
  {
    v3 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v3,
      "temperature/temperature.c",
      "get_pcb_temp_min",
      807);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_rwlock_rdlock(&stru_9FEE4) )
  {
    v4 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      "temperature/temperature.c",
      "get_pcb_temp_min",
      807);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock(&mutex) )
  {
    v5 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v5,
      "temperature/temperature.c",
      "get_pcb_temp_min",
      807);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v0 = (__int16)dword_9FF08;
  if ( pthread_rwlock_unlock(&stru_9FEE4) )
  {
    v2 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v2,
      "temperature/temperature.c",
      "get_pcb_temp_min",
      807);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  off_9E444();
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "Environment temperature: %d\n", v0);
    sub_47AB4(3, s, 0);
  }
  return v0;
}
// 9E31C: using guessed type int dword_9E31C;
// 9E444: using guessed type int (*off_9E444)();
// 9FEE4: using guessed type pthread_rwlock_t stru_9FEE4;
// 9FF08: using guessed type int dword_9FF08;

//----- (0001758C) --------------------------------------------------------
const char *sub_1758C()
{
  return "/var/log/temp";
}

//----- (00017598) --------------------------------------------------------
int __fastcall sub_17598(int a1, char a2)
{
  _DWORD *v3; // r4
  int i; // r5
  int v6; // r1
  int result; // r0

  v3 = &dword_9F80C[27 * a1];
  for ( i = 0; i != 4; ++i )
  {
    v6 = *((unsigned __int8 *)v3 + 13);
    v3 += 6;
    result = sub_1A958(a1, v6, 0, a2);
  }
  return result;
}
// 9F80C: using guessed type _DWORD dword_9F80C[432];

//----- (000175E4) --------------------------------------------------------
int __fastcall sub_175E4(int result)
{
  dword_A05E8 = result;
  return result;
}
// A05E8: using guessed type int dword_A05E8;

//----- (000175F4) --------------------------------------------------------
_DWORD *__fastcall sub_175F4(_DWORD *result)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3

  v1 = *(_DWORD *)(dword_A05E8 + 4);
  v2 = *(_DWORD *)(dword_A05E8 + 8);
  v3 = *(_DWORD *)(dword_A05E8 + 12);
  *result = *(_DWORD *)dword_A05E8;
  result[1] = v1;
  result[2] = v2;
  result[3] = v3;
  return result;
}
// A05E8: using guessed type int dword_A05E8;

//----- (00017614) --------------------------------------------------------
void __fastcall sub_17614(int a1, int a2, int a3, int a4)
{
  int i; // r4
  int v8; // r3
  int v9; // r1
  int v10; // r7
  unsigned __int8 *v11; // r12
  int v12; // r3
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  for ( i = 0; i != 16; ++i )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
      {
        v8 = dword_A05EC;
        v9 = 2 * i;
        v10 = (unsigned __int8)byte_A05F0;
        *(_BYTE *)(a1 + i) = *(_BYTE *)(*(_DWORD *)(dword_A05EC + 4 * i) + 29);
        *(_BYTE *)(a2 + i) = *(_BYTE *)(*(_DWORD *)(v8 + 4 * i) + 30);
        *(_WORD *)(a3 + v9) = *(_WORD *)(*(_DWORD *)(v8 + 4 * i) + 31);
        *(_WORD *)(a4 + v9) = *(_WORD *)(*(_DWORD *)(v8 + 4 * i) + 33);
        if ( !v10 && (unsigned int)dword_9E31C > 3 )
          break;
      }
      if ( ++i == 16 )
        goto LABEL_7;
    }
    v11 = *(unsigned __int8 **)(v8 + 4 * i);
    v12 = i;
    snprintf(
      s,
      0x800u,
      "chain[%d] board bin: %d, chip bin: %d, chip ft: A%dV%d, chip version: %c%c\n",
      v12,
      v11[29],
      v11[30],
      v11[31],
      v11[32],
      v11[33],
      v11[34]);
    sub_47AB4(3, s, 0);
  }
LABEL_7:
  byte_A05F0 = 1;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;
// A05F0: using guessed type char byte_A05F0;
// A0D68: using guessed type int dword_A0D68;

//----- (0001774C) --------------------------------------------------------
void sub_1774C()
{
  int v0; // r6
  int v1; // r4
  void *v2; // r0

  v0 = dword_A05EC;
  if ( dword_A05EC )
  {
    v1 = 0;
    *(_DWORD *)(dword_A05EC + 64) = 0;
    *(_DWORD *)(v0 + 68) = 0;
    *(_DWORD *)(v0 + 72) = 0;
    *(_DWORD *)(v0 + 76) = 0;
    *(_DWORD *)(v0 + 80) = 0;
    *(_DWORD *)(v0 + 84) = 0;
    *(_DWORD *)(v0 + 88) = 0;
    *(_DWORD *)(v0 + 92) = 0;
    *(_BYTE *)(v0 + 96) = 0;
    do
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * v1 + 4) == 1 )
      {
        v2 = *(void **)(v0 + 4 * v1);
        if ( v2 )
          memset(v2, 0, 0x100u);
      }
      ++v1;
    }
    while ( v1 != 16 );
  }
}
// A05EC: using guessed type int dword_A05EC;
// A0D68: using guessed type int dword_A0D68;

//----- (000177D8) --------------------------------------------------------
void sub_177D8()
{
  void *v0; // r8
  _DWORD *v1; // r4
  int v2; // r5
  void *v3; // r0
  void *v4; // t1

  v0 = (void *)dword_A05EC;
  if ( dword_A05EC )
  {
    v1 = (_DWORD *)(dword_A05EC - 4);
    v2 = dword_A05EC + 60;
    do
    {
      v4 = (void *)v1[1];
      ++v1;
      v3 = v4;
      if ( v4 )
      {
        free(v3);
        *v1 = 0;
      }
    }
    while ( v1 != (_DWORD *)v2 );
    free(v0);
    dword_A05EC = 0;
  }
}
// A05EC: using guessed type int dword_A05EC;

//----- (0001782C) --------------------------------------------------------
int sub_1782C()
{
  int v0; // r4
  int v1; // r7
  void *v2; // r9
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_A05EC || (dword_A05EC = (int)calloc(0x64u, 1u)) != 0 )
  {
    v0 = 0;
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * v0 + 4) == 1 )
      {
        v1 = dword_A05EC;
        if ( !*(_DWORD *)(dword_A05EC + 4 * v0) )
        {
          v2 = malloc(0x100u);
          *(_DWORD *)(v1 + 4 * v0) = v2;
          if ( !v2 )
            break;
        }
      }
      if ( ++v0 == 16 )
        return 0;
    }
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v4, 0x800u, "No memory for configuraion for chain %d.\n", v0);
      sub_47AB4(3, v4, 0);
    }
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v4, "No memory for configuraion.\n");
    sub_47AB4(3, v4, 0);
  }
  sub_177D8();
  return -1;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;
// A0D68: using guessed type int dword_A0D68;

//----- (00017968) --------------------------------------------------------
int __fastcall sub_17968(char *a1, int a2, char *s1, _BYTE *a4, size_t n)
{
  int v5; // r8
  int v7; // r7
  char *v10; // r11
  int v11; // r5
  bool v12; // zf
  const void *v13; // r0
  __int16 s2[4]; // [sp+Ch] [bp-8h] BYREF

  v7 = 0;
  if ( !a2 )
    v5 = 0;
  s2[0] = 0;
  if ( a2 )
  {
    v5 = 0;
    do
    {
      v10 = s1;
      v11 = 0;
      while ( 1 )
      {
        v12 = memcmp(v10, s2, (unsigned __int8)n) == 0;
        v13 = v10;
        v10 += (unsigned __int8)n;
        if ( v12 )
        {
          *a4 = v11;
          goto LABEL_11;
        }
        ++v11;
        if ( !memcmp(v13, a1, (unsigned __int8)n) )
          break;
        if ( v11 == 32 )
          goto LABEL_11;
      }
      v5 = (unsigned __int8)(v5 + 1);
LABEL_11:
      ++v7;
      a1 += (unsigned __int8)n;
    }
    while ( a2 != v7 );
  }
  return v5;
}
// 179FC: variable 'v5' is possibly undefined

//----- (00017A14) --------------------------------------------------------
int __fastcall sub_17A14(char *a1, char *a2, size_t n)
{
  int v3; // r6
  int v6; // r8
  char *v7; // r11
  int v8; // r5
  bool v9; // zf
  const void *v10; // r0
  int v12; // [sp+0h] [bp-14h]
  __int16 v14; // [sp+Ch] [bp-8h] BYREF

  v3 = 0;
  v12 = 0;
  v14 = 0;
  do
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * v3 + 4) == 1 )
      {
        v6 = *(unsigned __int8 *)(dword_A0D68 + 12935);
        if ( *(_BYTE *)(dword_A0D68 + 12935) )
          break;
      }
LABEL_2:
      ++v3;
      a2 += n;
      if ( v3 == 16 )
        return v12;
    }
    v7 = a1;
    v8 = 0;
    while ( 1 )
    {
      ++v8;
      v9 = memcmp(v7, &v14, n) == 0;
      v10 = v7;
      if ( v9 )
        break;
      v7 += n;
      if ( !memcmp(v10, a2, n) || v6 == v8 )
        goto LABEL_2;
    }
    memcpy(v7, a2, n);
    ++v3;
    a2 += n;
    v12 = (unsigned __int8)(v12 + 1);
  }
  while ( v3 != 16 );
  return v12;
}
// A0D68: using guessed type int dword_A0D68;

//----- (00017AF8) --------------------------------------------------------
void __fastcall sub_17AF8(int a1)
{
  int i; // r4
  int v3; // r5
  unsigned int v4; // r3
  char v5[2048]; // [sp+0h] [bp-800h] BYREF

  for ( i = 0; i != 256; ++i )
  {
    while ( 1 )
    {
      v3 = i & 0xF;
      v4 = dword_9E31C;
      if ( (i & 0xF) != 0 )
        break;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(v5, 0x800u, "0x%04X ", i);
        sub_47EC8(3, v5, i & 0xF);
        v4 = dword_9E31C;
      }
LABEL_4:
      if ( v4 > 3 )
        goto LABEL_10;
LABEL_5:
      if ( ++i == 256 )
        return;
    }
    if ( v3 != 8 )
      goto LABEL_4;
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_5;
    strcpy(v5, "  ");
    sub_47EC8(3, v5, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_5;
LABEL_10:
    snprintf(v5, 0x800u, "%02X ", *(unsigned __int8 *)(a1 + i));
    sub_47EC8(3, v5, 0);
    if ( v3 != 15 || (unsigned int)dword_9E31C <= 3 )
      goto LABEL_5;
    strcpy(v5, "\n");
    sub_47EC8(3, v5, 0);
  }
}
// 17C20: conditional instruction was optimized away because r5.4==0
// 9E31C: using guessed type int dword_9E31C;

//----- (00017C28) --------------------------------------------------------
int __fastcall sub_17C28(char a1, _BYTE *a2, _BYTE *a3)
{
  int v6; // r7
  int v7; // r3
  int v8; // r0
  int v9; // lr
  int v10; // t1

  v6 = dword_A05EC;
  if ( !dword_A05EC )
  {
    if ( sub_1782C() )
      return -1;
    sub_1774C();
    v6 = dword_A05EC;
  }
  v7 = v6;
  v8 = dword_A0D68;
  v9 = dword_A0D68 + 64;
  do
  {
    v10 = *(_DWORD *)(v8 + 4);
    v8 += 4;
    if ( v10 == 1 )
    {
      *(_BYTE *)(*(_DWORD *)v7 + 30) = a1;
      *(_BYTE *)(*(_DWORD *)v7 + 31) = *a2;
      *(_BYTE *)(*(_DWORD *)v7 + 32) = a2[1];
      *(_BYTE *)(*(_DWORD *)v7 + 33) = *a3;
      *(_BYTE *)(*(_DWORD *)v7 + 34) = a3[1];
    }
    v7 += 4;
  }
  while ( v8 != v9 );
  *(_BYTE *)(v6 + 96) = 1;
  return 0;
}
// A05EC: using guessed type int dword_A05EC;
// A0D68: using guessed type int dword_A0D68;

//----- (00017CE0) --------------------------------------------------------
void __fastcall sub_17CE0(unsigned __int16 *a1)
{
  int v2; // r1
  int v3; // r2
  int v4; // r3
  _DWORD s[8]; // [sp+8h] [bp-824h] BYREF
  char v6[2052]; // [sp+28h] [bp-804h] BYREF

  memset(s, 0, sizeof(s));
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(v6, 0x800u, "%-30s : 0x%04x\n", "fixture_header", *a1);
  sub_47AB4(3, v6, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(v6, 0x800u, "%-30s : 0x%04x\n", "fixture_version", a1[1]);
  sub_47AB4(3, v6, 0);
  v2 = *((_DWORD *)a1 + 2);
  v3 = *((_DWORD *)a1 + 3);
  v4 = *((_DWORD *)a1 + 4);
  s[0] = *((_DWORD *)a1 + 1);
  s[1] = v2;
  s[2] = v3;
  s[3] = v4;
  s[4] = *((_DWORD *)a1 + 5);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(v6, 0x800u, "%-30s : %s\n", "hash_board_sn", (const char *)s);
  sub_47AB4(3, v6, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_10;
  snprintf(v6, 0x800u, "%-30s : 0x%04x\n", "pcb_version", a1[12]);
  sub_47AB4(3, v6, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(v6, 0x800u, "%-30s : 0x%04x\n", "bom_version", a1[13]);
  sub_47AB4(3, v6, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v6, 0x800u, "%-30s : 0x%02x\n", "product_id", *((unsigned __int8 *)a1 + 28));
    sub_47AB4(3, v6, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(v6, 0x800u, "%-30s : 0x%02x\n", "board_bin", *((unsigned __int8 *)a1 + 29));
    sub_47AB4(3, v6, 0);
LABEL_10:
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(v6, 0x800u, "%-30s : A%dV%d\n", "chip_ft", *((unsigned __int8 *)a1 + 31), *((unsigned __int8 *)a1 + 32));
    sub_47AB4(3, v6, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(v6, 0x800u, "%-30s : BIN%d\n", "chip_bin", *((unsigned __int8 *)a1 + 30));
    sub_47AB4(3, v6, 0);
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v6, 0x800u, "%-30s : %c%c\n", "chip_version", *((unsigned __int8 *)a1 + 33), *((unsigned __int8 *)a1 + 34));
    sub_47AB4(3, v6, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v6, "\n");
      sub_47AB4(3, v6, 0);
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00017FF8) --------------------------------------------------------
void __fastcall sub_17FF8(int a1)
{
  unsigned int v2; // r2
  int v3; // r3
  unsigned int v4; // r4
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v2 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_2;
  snprintf(s, 0x800u, "%-30s : 0x%04x\n", "miner_header", *(unsigned __int16 *)(a1 + 40));
  sub_47AB4(3, s, 0);
  v2 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_15:
    if ( v2 > 3 )
    {
      snprintf(s, 0x800u, "%-30s : %d\n", "ideal_hash_rate", *(_DWORD *)(a1 + 122));
      sub_47AB4(3, s, 0);
      v2 = dword_9E31C;
    }
    goto LABEL_2;
  }
  snprintf(s, 0x800u, "%-30s : 0x%02x\n", "work_mode_count", *(unsigned __int8 *)(a1 + 128));
  sub_47AB4(3, s, 0);
  v2 = dword_9E31C;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s : 0x%02x\n", "miner_bin", *(unsigned __int8 *)(a1 + 129));
    sub_47AB4(3, s, 0);
    v2 = dword_9E31C;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "[mode %d]\n", 0);
      sub_47AB4(3, s, 0);
      v2 = dword_9E31C;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s : %d\n", "voltage", *(unsigned __int16 *)(a1 + 120));
        sub_47AB4(3, s, 0);
        v2 = dword_9E31C;
        goto LABEL_15;
      }
    }
  }
LABEL_2:
  v3 = 0;
  while ( 1 )
  {
    v4 = v3 + 1;
    if ( v2 > 3 )
    {
      snprintf(s, 0x800u, "IC[%03d]:%3d ", v3, 5 * *(unsigned __int8 *)(a1 + v4 + 41));
      sub_47EC8(3, s, 0);
      if ( v4 == 6 * (v4 / 6) && (unsigned int)dword_9E31C > 3 )
        break;
    }
    v3 = v4;
    if ( v4 == 78 )
      return;
LABEL_4:
    v2 = dword_9E31C;
  }
  strcpy(s, "\n");
  sub_47EC8(3, s, v4 % 6);
  v3 = v4;
  if ( v4 != 78 )
    goto LABEL_4;
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0001823C) --------------------------------------------------------
void __fastcall sub_1823C(int a1, unsigned __int16 *a2)
{
  char v3[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v3, 0x800u, "[chain %d]\n", a1);
    sub_47AB4(3, v3, 0);
  }
  sub_17AF8((int)a2);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    *(_WORD *)v3 = 10;
    sub_47EC8(3, v3, 0);
  }
  sub_17CE0(a2);
  sub_17FF8((int)a2);
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000182D4) --------------------------------------------------------
void sub_182D4()
{
  unsigned int i; // r4
  unsigned int v1; // r0
  unsigned int v2; // r4
  int v3; // r8
  int v4; // r7
  unsigned __int16 *v5; // r6
  int v6; // r0
  const char *v7; // r2
  unsigned int v8; // r3
  int v9; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        goto LABEL_5;
    }
    v1 = i;
    sub_6F13C(v1);
  }
LABEL_5:
  v2 = 0;
  v3 = 0;
  sub_4A804();
  do
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * v2 + 4) != 1 )
        goto LABEL_6;
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
      {
        snprintf(s, 0x800u, "load eeprom for chain %d", v2);
        sub_47AB4(5, s, 0);
      }
      v4 = dword_A05EC;
      v5 = *(unsigned __int16 **)(dword_A05EC + 4 * v2);
      v6 = sub_6F3AC(v2, 0, (int)v5, 256);
      if ( v6 )
      {
        v3 |= v6;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          v7 = "Read configuration fail for chain %d.\n";
          v8 = v2;
          goto LABEL_15;
        }
        goto LABEL_6;
      }
      sub_1823C(v2, v5);
      if ( v5[19] == sub_514F8((int)v5, 38) )
      {
        v9 = *v5;
        if ( v9 == 5014 )
        {
          *(_BYTE *)(v4 + v2 + 64) = 1;
          goto LABEL_22;
        }
        if ( (unsigned int)dword_9E31C <= 3 )
          goto LABEL_21;
        snprintf(s, 0x800u, "Fixture header check fail, fixture_header = 0x%x\n", v9);
        sub_47AB4(3, s, 0);
      }
      else
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          goto LABEL_21;
        strcpy(s, "Fixture CRC check fail.\n");
        sub_47AB4(3, s, 0);
      }
      if ( (unsigned int)dword_9E31C <= 3 )
      {
LABEL_21:
        v3 = -1;
        goto LABEL_22;
      }
      snprintf(s, 0x800u, "Fixture data load fail for chain %d.\n", v2);
      v3 = -1;
      sub_47AB4(3, s, 0);
LABEL_22:
      if ( v5[127] != sub_514F8((int)(v5 + 20), 214) )
      {
        if ( (unsigned int)dword_9E31C > 3 )
        {
          strcpy(s, "Miner CRC check fail.\n");
          sub_47AB4(3, s, 0);
        }
        goto LABEL_6;
      }
      v8 = v5[20];
      if ( v8 == 5014 )
      {
        *(_BYTE *)(v4 + v2 + 80) = 1;
        goto LABEL_6;
      }
      if ( (unsigned int)dword_9E31C > 3 )
        break;
LABEL_6:
      if ( ++v2 == 16 )
        goto LABEL_16;
    }
    v7 = "Miner header check fail, miner_header = 0x%x\n";
LABEL_15:
    ++v2;
    snprintf(s, 0x800u, v7, v8);
    sub_47AB4(3, s, 0);
  }
  while ( v2 != 16 );
LABEL_16:
  if ( !v3 )
    *(_BYTE *)(dword_A05EC + 96) = 1;
}
// 9E31C: using guessed type int dword_9E31C;
// 9E320: using guessed type int dword_9E320;
// A05EC: using guessed type int dword_A05EC;
// A0D68: using guessed type int dword_A0D68;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (000185FC) --------------------------------------------------------
void __fastcall sub_185FC(int a1)
{
  bool v1; // zf
  _BOOL4 v2; // r0
  int v3; // r2

  v1 = a1 == 0;
  v2 = a1 != 0;
  v3 = dword_A05EC;
  if ( v1 )
    v2 = dword_A05EC == 0;
  if ( v2 )
  {
    if ( sub_1782C() )
      return;
    sub_1774C();
    v3 = dword_A05EC;
  }
  if ( !*(_BYTE *)(v3 + 96) )
    sub_182D4();
}
// A05EC: using guessed type int dword_A05EC;

//----- (00018650) --------------------------------------------------------
int sub_18650()
{
  unsigned int v0; // r4
  int v1; // r9
  int v2; // r10
  unsigned __int16 s[128]; // [sp+8h] [bp-904h] BYREF
  char v5[2052]; // [sp+108h] [bp-804h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) )
  {
    v0 = 0;
    v1 = 0;
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * v0 + 4) != 1 )
        goto LABEL_4;
      v2 = *(_DWORD *)(dword_A05EC + 4 * v0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(v5, 0x800u, "Flush miner configuration for chain %d.\n", v0);
        sub_47AB4(3, v5, 0);
      }
      *(_BYTE *)(v2 + 40) = -106;
      *(_BYTE *)(v2 + 41) = 19;
      *(_WORD *)(v2 + 254) = sub_514F8(v2 + 40, 214);
      if ( sub_6F254(v0, 0x28u, v2 + 40, 216) )
      {
        if ( (unsigned int)dword_9E31C > 3 )
        {
          v1 = -1;
          snprintf(v5, 0x800u, "Flush miner configuration for chain %d failed.\n", v0);
          sub_47AB4(3, v5, 0);
          goto LABEL_4;
        }
LABEL_10:
        ++v0;
        v1 = -1;
        if ( v0 == 16 )
          return v1;
      }
      else
      {
        memset(s, 255, sizeof(s));
        if ( sub_6F3AC(v0, 0x28u, (int)&s[20], 216) )
        {
          if ( (unsigned int)dword_9E31C <= 3 )
            goto LABEL_10;
          v1 = -1;
          snprintf(v5, 0x800u, "Read miner configuration for chain %d failed.\n", v0);
          sub_47AB4(3, v5, 0);
        }
        else if ( !memcmp((const void *)(v2 + 40), &s[20], 0xD8u) )
        {
          sub_1823C(v0, s);
        }
        else
        {
          if ( (unsigned int)dword_9E31C <= 3 )
            goto LABEL_10;
          v1 = -1;
          snprintf(v5, 0x800u, "Flush miner configration for chain %d failed.\n", v0);
          sub_47AB4(3, v5, 0);
        }
LABEL_4:
        if ( ++v0 == 16 )
          return v1;
      }
    }
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v5, "No fixture configuration for flush.\n");
    sub_47AB4(3, v5, 0);
    return -1;
  }
  else
  {
    return -1;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;
// A0D68: using guessed type int dword_A0D68;

//----- (000188CC) --------------------------------------------------------
int sub_188CC()
{
  return *(unsigned __int8 *)(dword_A05EC + 96);
}
// A05EC: using guessed type int dword_A05EC;

//----- (000188E0) --------------------------------------------------------
int sub_188E0()
{
  int v0; // r3
  int v1; // r12
  _BYTE *v2; // r2
  int v3; // t1
  int result; // r0

  v0 = dword_A0D68;
  v1 = dword_A0D68 + 64;
  v2 = (_BYTE *)(dword_A05EC + 80);
  do
  {
    while ( 1 )
    {
      v3 = *(_DWORD *)(v0 + 4);
      v0 += 4;
      if ( v3 == 1 )
        break;
      ++v2;
      if ( v0 == v1 )
        return 1;
    }
    result = (unsigned __int8)*v2;
    if ( !*v2 )
      return result;
    ++v2;
  }
  while ( v0 != v1 );
  return 1;
}
// A05EC: using guessed type int dword_A05EC;
// A0D68: using guessed type int dword_A0D68;

//----- (0001893C) --------------------------------------------------------
int __fastcall sub_1893C(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) )
    return *(_DWORD *)(dword_A05EC + 4 * a1) + 4;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "No hash board sn, chain = %d.\n", a1);
    sub_47AB4(3, v2, 0);
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (000189C8) --------------------------------------------------------
int __fastcall sub_189C8(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) )
    return *(unsigned __int16 *)(*(_DWORD *)(dword_A05EC + 4 * a1) + 24);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "No pcb version, chain = %d.\n", a1);
    sub_47AB4(3, v2, 0);
  }
  return 0xFFFF;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00018A54) --------------------------------------------------------
int __fastcall sub_18A54(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) )
    return *(unsigned __int16 *)(*(_DWORD *)(dword_A05EC + 4 * a1) + 26);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "No bom version, chain = %d.\n", a1);
    sub_47AB4(3, v2, 0);
  }
  return 0xFFFF;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00018AE0) --------------------------------------------------------
int __fastcall sub_18AE0(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_A05EC + 4 * a1) + 28);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "No product id, chain = %d.\n", a1);
    sub_47AB4(3, v2, 0);
  }
  return 255;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00018B6C) --------------------------------------------------------
int __fastcall sub_18B6C(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_A05EC + 4 * a1) + 29);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "No board bin, chain = %d.\n", a1);
    sub_47AB4(3, v2, 0);
  }
  return 255;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00018BF8) --------------------------------------------------------
int __fastcall sub_18BF8(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_A05EC + 4 * a1) + 128);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "No work mode count, chain = %d.\n", a1);
    sub_47AB4(3, v2, 0);
  }
  return 255;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00018C84) --------------------------------------------------------
int __fastcall sub_18C84(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) )
    return *(unsigned __int8 *)(*(_DWORD *)(dword_A05EC + 4 * a1) + 129);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "No miner bin, chain = %d\n", a1);
    sub_47AB4(3, v2, 0);
  }
  return 255;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00018D10) --------------------------------------------------------
int __fastcall sub_18D10(int a1, int a2, int a3)
{
  int v4; // r12
  int v5; // r1
  int v6; // r2
  int v7; // t1
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( !dword_A05EC || !*(_BYTE *)(dword_A05EC + 96) )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return -1;
    snprintf(s, 0x800u, "No work mode freq, chain = %d, mode = %d.\n", a1, a2);
LABEL_12:
    sub_47AB4(3, s, 0);
    return -1;
  }
  if ( a2 || (v4 = *(_DWORD *)(dword_A05EC + 4 * a1), !*(_BYTE *)(v4 + 128)) )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return -1;
    snprintf(s, 0x800u, "Invalid work mode to get freq, chain = %d, mode = %d.\n", a1, a2);
    goto LABEL_12;
  }
  v5 = a3 - 4;
  v6 = v4 + 41;
  do
  {
    v7 = *(unsigned __int8 *)++v6;
    *(_DWORD *)(v5 + 4) = 5 * v7;
    v5 += 4;
  }
  while ( v6 != v4 + 119 );
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00018E08) --------------------------------------------------------
int __fastcall sub_18E08(int a1, int a2, _DWORD *a3)
{
  int result; // r0
  int v4; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( !dword_A05EC || !*(_BYTE *)(dword_A05EC + 96) )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return -1;
    snprintf(s, 0x800u, "No work mode voltage, chain = %d, mode = %d.\n", a1, a2);
LABEL_13:
    sub_47AB4(3, s, 0);
    return -1;
  }
  if ( a2 || (v4 = *(_DWORD *)(dword_A05EC + 4 * a1), !*(_BYTE *)(v4 + 128)) )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return -1;
    snprintf(s, 0x800u, "Invalid work mode to get voltage, chain = %d, mode = %d.\n", a1, a2);
    goto LABEL_13;
  }
  if ( a3 )
    v4 = *(unsigned __int16 *)(v4 + 120);
  result = 0;
  if ( a3 )
    *a3 = v4;
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00018EE4) --------------------------------------------------------
int __fastcall sub_18EE4(int a1, int a2, _DWORD *a3)
{
  int result; // r0
  int v4; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( !dword_A05EC || !*(_BYTE *)(dword_A05EC + 96) )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return -1;
    snprintf(s, 0x800u, "No work mode hash rate, chain = %d, mode = %d.\n", a1, a2);
LABEL_13:
    sub_47AB4(3, s, 0);
    return -1;
  }
  if ( a2 || (v4 = *(_DWORD *)(dword_A05EC + 4 * a1), !*(_BYTE *)(v4 + 128)) )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return -1;
    snprintf(s, 0x800u, "Invalid work mode to get hash rate, chain = %d, mode = %d.\n", a1, a2);
    goto LABEL_13;
  }
  if ( a3 )
    v4 = *(_DWORD *)(v4 + 122);
  result = 0;
  if ( a3 )
    *a3 = v4;
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00018FC0) --------------------------------------------------------
int __fastcall sub_18FC0(int a1, int a2)
{
  int v3; // r2
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( !dword_A05EC || !*(_BYTE *)(dword_A05EC + 96) )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return 0;
    snprintf(s, 0x800u, "No work mode conf, chain = %d, mode = %d.\n", a1, a2);
LABEL_10:
    sub_47AB4(3, s, 0);
    return 0;
  }
  if ( !a2 )
  {
    v3 = *(_DWORD *)(dword_A05EC + 4 * a1);
    if ( *(_BYTE *)(v3 + 128) )
      return v3 + 42;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "Invalid work mode to get conf, chain = %d, mode = %d.\n", a1, a2);
    goto LABEL_10;
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00019098) --------------------------------------------------------
int __fastcall sub_19098(int a1, int a2, void *src)
{
  int v5; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) && (v5 = *(_DWORD *)(dword_A05EC + 4 * a1)) != 0 )
  {
    if ( !a2 && *(_BYTE *)(v5 + 128) )
    {
      memcpy((void *)(v5 + 42), src, 0x56u);
      return a2;
    }
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "Invalid work mode %d.\n", a2);
LABEL_11:
      sub_47AB4(3, s, 0);
      return -1;
    }
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "Can't set work mode conf, configuration is not loaded, chain = %d, mode = %d.\n", a1, a2);
    goto LABEL_11;
  }
  return -1;
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00019190) --------------------------------------------------------
int __fastcall sub_19190(int a1, char a2)
{
  int v3; // r3
  char v4[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) && (v3 = *(_DWORD *)(dword_A05EC + 4 * a1)) != 0 )
  {
    *(_BYTE *)(v3 + 128) = a2;
    return 0;
  }
  else
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v4, 0x800u, "Can't set work mode count, configuration is not loaded, chain = %d.\n", a1);
      sub_47AB4(3, v4, 0);
    }
    return -1;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (00019228) --------------------------------------------------------
int __fastcall sub_19228(int a1, char a2)
{
  int v3; // r3
  char v4[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_A05EC && *(_BYTE *)(dword_A05EC + 96) && (v3 = *(_DWORD *)(dword_A05EC + 4 * a1)) != 0 )
  {
    *(_BYTE *)(v3 + 129) = a2;
    return 0;
  }
  else
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v4, 0x800u, "Can't set miner bin, configuration is not loaded, chain = %d.\n", a1);
      sub_47AB4(3, v4, 0);
    }
    return -1;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A05EC: using guessed type int dword_A05EC;

//----- (0001942C) --------------------------------------------------------
int sub_1942C()
{
  size_t v0; // r6
  int v1; // r4
  int v3; // r7
  int v4; // r10
  int v5; // r9
  int v6; // r6
  int v7; // r10
  int v8; // r7
  int v9; // r0
  int v10; // [sp+8h] [bp-3Ch]
  char *v11; // [sp+Ch] [bp-38h]
  char *v12; // [sp+10h] [bp-34h]
  char *v13; // [sp+14h] [bp-30h]
  char *v14; // [sp+18h] [bp-2Ch]
  int v15; // [sp+1Ch] [bp-28h]
  int v16; // [sp+20h] [bp-24h]
  int v17; // [sp+24h] [bp-20h]
  char *ptr; // [sp+28h] [bp-1Ch]
  char *v19; // [sp+2Ch] [bp-18h]
  char *v20; // [sp+30h] [bp-14h]
  char *v21; // [sp+34h] [bp-10h]
  char v22; // [sp+3Ch] [bp-8h] BYREF
  char v23; // [sp+3Dh] [bp-7h] BYREF
  char v24; // [sp+3Eh] [bp-6h] BYREF
  _BYTE v25[5]; // [sp+3Fh] [bp-5h] BYREF

  ptr = (char *)calloc(0x10u, 1u);
  v19 = (char *)calloc(0x10u, 1u);
  v20 = (char *)calloc(0x20u, 1u);
  v21 = (char *)calloc(0x20u, 1u);
  sub_17614((int)ptr, (int)v19, (int)v20, (int)v21);
  v0 = *(unsigned __int8 *)(dword_A0D68 + 12935);
  v11 = (char *)calloc(v0, 1u);
  v12 = (char *)calloc(v0, 1u);
  v13 = (char *)calloc(2 * v0, 1u);
  v14 = (char *)calloc(2 * v0, 1u);
  v1 = *(unsigned __int8 *)(dword_A05EC + 96);
  if ( !*(_BYTE *)(dword_A05EC + 96) )
    goto LABEL_2;
  v3 = sub_17A14(v11, ptr, 1u);
  v4 = sub_17A14(v12, v19, 1u);
  v15 = sub_17A14(v13, v20, 2u);
  v17 = sub_17A14(v14, v21, 2u);
  pthread_mutex_lock(&stru_A05F4);
  if ( dword_A060C <= 0 )
  {
LABEL_20:
    v1 = 0;
    goto LABEL_21;
  }
  v5 = v4;
  v6 = 0;
  v7 = v3;
  while ( 1 )
  {
    while ( 1 )
    {
      v8 = sub_17968(v11, v7, (char *)(dword_A0610 + 192 * v6), &v22, 1u);
      v10 = sub_17968(v12, v5, (char *)(dword_A0610 + 192 * v6 + 32), &v23, 1u);
      v16 = sub_17968(v13, v15, (char *)(dword_A0610 + 192 * v6 + 64), &v24, 2u);
      v9 = sub_17968(v14, v17, (char *)(dword_A0610 + 192 * v6 + 128), v25, 2u);
      if ( v7 == v8 )
        break;
      if ( v7 != 1 )
        goto LABEL_6;
      if ( !v22 )
        break;
      if ( dword_A060C <= ++v6 )
        goto LABEL_20;
    }
    if ( v5 != v10 && (v5 != 1 || v23) || v15 != v16 && (v15 != 1 || v24) )
      goto LABEL_6;
    if ( v17 == v9 )
      break;
    if ( v17 == 1 && !v25[0] )
    {
      v1 = 1;
      goto LABEL_21;
    }
LABEL_6:
    if ( dword_A060C <= ++v6 )
      goto LABEL_20;
  }
  v1 = 1;
LABEL_21:
  pthread_mutex_unlock(&stru_A05F4);
LABEL_2:
  free(ptr);
  free(v19);
  free(v20);
  free(v21);
  free(v11);
  free(v12);
  free(v13);
  free(v14);
  return v1;
}
// A05EC: using guessed type int dword_A05EC;
// A060C: using guessed type int dword_A060C;
// A0610: using guessed type int dword_A0610;
// A0D68: using guessed type int dword_A0D68;

//----- (00019720) --------------------------------------------------------
int __fastcall sub_19720(unsigned int a1, unsigned int a2)
{
  unsigned __int64 v2; // r6

  v2 = __PAIR64__(a1, a2);
  pthread_mutex_lock(&stru_A05F4);
  *(_QWORD *)&dword_A060C = v2;
  return pthread_mutex_unlock(&stru_A05F4);
}
// A060C: using guessed type int dword_A060C;

//----- (00019750) --------------------------------------------------------
int sub_19750()
{
  pthread_mutex_lock(&stru_A05F4);
  dword_A0610 = 0;
  dword_A060C = 0;
  return pthread_mutex_unlock(&stru_A05F4);
}
// A060C: using guessed type int dword_A060C;
// A0610: using guessed type int dword_A0610;

//----- (00019780) --------------------------------------------------------
bool __fastcall sub_19780(unsigned int a1)
{
  return (unsigned __int8)sub_713A4(a1) == 0;
}

//----- (000197A0) --------------------------------------------------------
bool __fastcall sub_197A0(unsigned int a1)
{
  return (unsigned __int8)sub_71AF4(a1) == 0;
}

//----- (000197B8) --------------------------------------------------------
void __fastcall sub_197B8(int a1)
{
  int v2; // r0
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  sub_1A7AC();
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "chain[%d] PIC jump to app\n", a1);
    sub_47AB4(3, s, 0);
  }
  sub_7157C((unsigned __int8)a1);
  v2 = sub_711A0((unsigned __int8)a1);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "Check chain[%d] PIC fw version=0x%02x\n", a1, v2);
    sub_47AB4(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00019868) --------------------------------------------------------
int sub_19868()
{
  double v0; // d0
  int v1; // r6
  int v2; // r4
  int v3; // r7
  unsigned __int8 v4; // r0
  int v5; // r8
  double v6; // d15
  unsigned int v7; // r3
  int v8; // r3
  unsigned int v10; // r9
  unsigned int v11; // s28
  unsigned int v12; // s30
  double v13; // d14
  double v14; // d15
  float v15; // s14
  unsigned int v16; // [sp+1Ch] [bp-810h] BYREF
  unsigned int v17; // [sp+20h] [bp-80Ch]
  unsigned int v18; // [sp+24h] [bp-808h]
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  v1 = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * v2 + 4) != 1 )
        goto LABEL_2;
      v17 = 0;
      ++v1;
      v18 = 0;
      v16 = 0;
      v4 = sub_71F68((unsigned __int8)v2, &v16, 3);
      v5 = v4;
      if ( v4 )
      {
        v6 = 0.0;
      }
      else
      {
        v10 = v16;
        v11 = v17;
        v12 = v18;
        strcpy(s, "Received an voltage response.\n");
        sub_47AB4(5, s, 0);
        v13 = (double)v11 * 3.3;
        v14 = (double)v12 * 3.3 * 0.0009765625;
        snprintf(s, 0x800u, "an0 = %f, an2 %f, an6 %f.\n", (double)v10 * 3.3 * 0.0009765625, v13 * 0.0009765625, v14);
        sub_47AB4(5, s, v5);
        if ( v14 >= 2.3599999 && v14 <= 2.6400001 )
        {
          v15 = v14 / 2.5;
          snprintf(s, 0x800u, "v_an2 = %f\n", v13 / (float)(v15 * 1024.0));
          sub_47AB4(5, s, v5);
          v6 = v13 / (float)(v15 * 1024.0) * 7.5999999;
          snprintf(s, 0x800u, "v_10 = %f\n", v6);
          sub_47AB4(5, s, v5);
        }
        else
        {
          v6 = 0.0;
          strcpy(s, "Ref an vol too high or too low.\n");
          sub_47AB4(5, s, 0);
        }
      }
      v7 = dword_9E31C;
      if ( (unsigned int)dword_9E31C > 4 )
        break;
      if ( fabs(v6 - v0) > 0.5 )
        goto LABEL_9;
LABEL_2:
      if ( ++v2 == 16 )
        goto LABEL_12;
    }
    snprintf(s, 0x800u, "chain = %d, voltage = %f\n", v2, v6);
    sub_47AB4(4, s, 0);
    v7 = dword_9E31C;
    if ( fabs(v6 - v0) <= 0.5 )
    {
      if ( (unsigned int)dword_9E31C > 4 )
      {
        snprintf(s, 0x800u, "chain[%d] target_vol = %.2f, actural_vol = %.2f, check voltage passed.\n", v2, v0, v6);
        sub_47AB4(4, s, 0);
      }
      goto LABEL_2;
    }
LABEL_9:
    if ( v7 <= 3 )
    {
      v3 = -1;
      goto LABEL_2;
    }
    v8 = v2++;
    snprintf(s, 0x800u, "chain[%d] target_vol = %.2f, actural_vol = %.2f, more than 0.5v diff.\n", v8, v0, v6);
    v3 = -1;
    sub_47AB4(3, s, 0);
  }
  while ( v2 != 16 );
LABEL_12:
  if ( !v1 )
    return -1;
  return v3;
}
// 19910: variable 'v0' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00019BB4) --------------------------------------------------------
int sub_19BB4()
{
  int v0; // r4
  int v1; // r5
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( *(_BYTE *)(dword_A0D68 + 12935) )
  {
    v0 = 0;
    while ( 1 )
    {
      if ( (unsigned int)dword_9E31C > 4 )
      {
        snprintf(s, 0x800u, "retry time: %d\n", v0);
        sub_47AB4(4, s, 0);
      }
      ++v0;
      v1 = sub_19868();
      if ( !v1 )
      {
        sleep(1u);
        v1 = sub_19868();
        if ( !v1 )
          break;
      }
      sleep(1u);
      if ( v0 == 30 )
        return v1;
    }
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00019CA0) --------------------------------------------------------
int __fastcall sub_19CA0(int a1)
{
  int v2; // r5

  sub_734CC();
  usleep(0x493E0u);
  v2 = sub_19BB4();
  if ( v2 )
  {
    sub_31794(12, 0);
    sub_226C0(8u, "power set failed!");
  }
  dword_A0618 = a1;
  byte_A0614 = 1;
  return v2;
}
// A0614: using guessed type char byte_A0614;
// A0618: using guessed type int dword_A0618;

//----- (00019D18) --------------------------------------------------------
int __fastcall sub_19D18(int a1, int a2)
{
  int v4; // r7
  int v5; // r0
  int v6; // r2
  unsigned int v7; // r3
  int v8; // r6
  unsigned int v9; // r5
  unsigned int v10; // r4
  unsigned int v11; // r10
  int v12; // r11
  int v13; // r4
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = sub_73604();
  v5 = sub_73604();
  v6 = v4 - v5;
  LOWORD(v7) = -3855;
  if ( v4 - v5 < 0 )
    v6 = v5 - v4;
  HIWORD(v7) = -3856;
  v8 = v5;
  v9 = (unsigned int)(((unsigned int)v6 * (unsigned __int64)v7) >> 32) >> 4;
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "da_N_target %d, da_N_curr %d, da_N_step %d, step %d\n", v4, v5, 17, v9);
    sub_47AB4(4, s, 0);
  }
  if ( v9 )
  {
    v10 = v8 + 17;
    v11 = v8 - 17;
    v12 = 17 * v9 + v8 + 17;
    do
    {
      if ( v4 > v8 )
        v9 = v10;
      else
        v9 = v11;
      v10 += 17;
      v11 -= 17;
      sub_73584((unsigned __int8)v9);
    }
    while ( v10 != v12 );
  }
  if ( v4 != v9 )
    sub_73584((unsigned __int8)v4);
  v13 = sub_19BB4();
  if ( v13 )
  {
    sub_31794(12, 0);
    sub_226C0(8u, "power set failed!");
  }
  *(_DWORD *)(a2 + 4) = a1;
  *(_BYTE *)a2 = 1;
  return v13;
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00019E68) --------------------------------------------------------
unsigned int sub_19E68()
{
  sub_685C8();
  return sleep(1u);
}

//----- (00019E7C) --------------------------------------------------------
unsigned int sub_19E7C()
{
  sub_6860C();
  return sleep(1u);
}

//----- (00019E90) --------------------------------------------------------
int sub_19E90()
{
  unsigned __int16 v0; // r0
  int v1; // r5
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = sub_731E4();
  v1 = v0;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v3, 0x800u, "power type version: 0x%04x\n", v0);
    sub_47AB4(3, v3, 0);
    if ( v1 == 66 )
    {
      dword_A061C = 2000;
      dword_A0624 = 1850;
      byte_A0614 = 0;
      dword_A0618 = 0;
      dword_A0620 = 1800;
      dword_A0628 = 1800;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy(v3, "Power init:\n");
        sub_47AB4(3, v3, 0);
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(v3, 0x800u, "current_voltage_raw     = %d\n", dword_A0618);
          sub_47AB4(3, v3, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return 0;
          snprintf(v3, 0x800u, "highest_voltage_raw     = %d\n", dword_A061C);
          sub_47AB4(3, v3, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return 0;
          snprintf(v3, 0x800u, "working_voltage_raw     = %d\n", dword_A0620);
          sub_47AB4(3, v3, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return 0;
          snprintf(v3, 0x800u, "higher_voltage_raw      = %d\n", dword_A0624);
          sub_47AB4(3, v3, 0);
        }
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(v3, 0x800u, "check_asic_voltage_raw  = %d\n", dword_A0628);
          sub_47AB4(3, v3, 0);
        }
      }
      return 0;
    }
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v3, "power type version error\n");
      sub_47AB4(3, v3, 0);
    }
  }
  else if ( v0 == 66 )
  {
    dword_A061C = 2000;
    dword_A0624 = 1850;
    byte_A0614 = 0;
    dword_A0618 = 0;
    dword_A0620 = 1800;
    dword_A0628 = 1800;
    return 0;
  }
  sub_31794(12, 0);
  sub_226C0(8u, "get power type version failed!");
  return -1;
}
// 9E31C: using guessed type int dword_9E31C;
// A0614: using guessed type char byte_A0614;
// A0618: using guessed type int dword_A0618;
// A061C: using guessed type int dword_A061C;
// A0620: using guessed type int dword_A0620;
// A0624: using guessed type int dword_A0624;
// A0628: using guessed type int dword_A0628;

//----- (0001A0F0) --------------------------------------------------------
void __fastcall sub_1A0F0(int a1)
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  dword_A0620 = a1;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v1, 0x800u, "working_voltage_raw = %d\n", a1);
    sub_47AB4(3, v1, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0620: using guessed type int dword_A0620;

//----- (0001A150) --------------------------------------------------------
void __fastcall sub_1A150(int a1)
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  dword_A0624 = a1;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v1, 0x800u, "higher_voltage_raw = %d\n", a1);
    sub_47AB4(3, v1, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0624: using guessed type int dword_A0624;

//----- (0001A1B0) --------------------------------------------------------
int sub_1A1B0()
{
  return dword_A0620;
}
// A0620: using guessed type int dword_A0620;

//----- (0001A1C0) --------------------------------------------------------
int sub_1A1C0()
{
  return dword_A0618;
}
// A0618: using guessed type int dword_A0618;

//----- (0001A1D0) --------------------------------------------------------
int sub_1A1D0()
{
  return dword_A0624;
}
// A0624: using guessed type int dword_A0624;

//----- (0001A1E0) --------------------------------------------------------
int sub_1A1E0()
{
  int v0; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = dword_A0620;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "Set to voltage raw %d, one step.\n", dword_A0620);
    sub_47AB4(3, v2, 0);
    v0 = dword_A0620;
  }
  return sub_19CA0(v0);
}
// 9E31C: using guessed type int dword_9E31C;
// A0620: using guessed type int dword_A0620;

//----- (0001A240) --------------------------------------------------------
int sub_1A240()
{
  int v0; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = dword_A061C;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "Set to voltage raw %d, one step.\n", dword_A061C);
    sub_47AB4(3, v2, 0);
    v0 = dword_A061C;
  }
  return sub_19CA0(v0);
}
// 9E31C: using guessed type int dword_9E31C;
// A061C: using guessed type int dword_A061C;

//----- (0001A2A0) --------------------------------------------------------
int sub_1A2A0()
{
  int v0; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = dword_A0624;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "Set to voltage raw %d, one step.\n", dword_A0624);
    sub_47AB4(3, v2, 0);
    v0 = dword_A0624;
  }
  return sub_19CA0(v0);
}
// 9E31C: using guessed type int dword_9E31C;
// A0624: using guessed type int dword_A0624;

//----- (0001A300) --------------------------------------------------------
int sub_1A300()
{
  int v0; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = dword_A0628;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "Set to voltage raw %d, one step.\n", dword_A0628);
    sub_47AB4(3, v2, 0);
    v0 = dword_A0628;
  }
  return sub_19CA0(v0);
}
// 9E31C: using guessed type int dword_9E31C;
// A0628: using guessed type int dword_A0628;

//----- (0001A360) --------------------------------------------------------
int __fastcall sub_1A360(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v3, 0x800u, "Set to voltage raw %d, one step\n", a1);
    sub_47AB4(3, v3, 0);
  }
  return sub_19CA0(a1);
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0001A3B8) --------------------------------------------------------
int sub_1A3B8()
{
  int v0; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = dword_A0620;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "Set to voltage raw %d, step by step.\n", dword_A0620);
    sub_47AB4(3, v2, 0);
    v0 = dword_A0620;
  }
  return sub_19D18(v0, (int)&byte_A0614);
}
// 9E31C: using guessed type int dword_9E31C;
// A0614: using guessed type char byte_A0614;
// A0620: using guessed type int dword_A0620;

//----- (0001A420) --------------------------------------------------------
int sub_1A420()
{
  int v0; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = dword_A061C;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "Set to voltage raw %d, step by step.\n", dword_A061C);
    sub_47AB4(3, v2, 0);
    v0 = dword_A061C;
  }
  return sub_19D18(v0, (int)&byte_A0614);
}
// 9E31C: using guessed type int dword_9E31C;
// A0614: using guessed type char byte_A0614;
// A061C: using guessed type int dword_A061C;

//----- (0001A488) --------------------------------------------------------
int sub_1A488()
{
  int v0; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = dword_A0624;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "Set to voltage raw %d, step by step.\n", dword_A0624);
    sub_47AB4(3, v2, 0);
    v0 = dword_A0624;
  }
  return sub_19D18(v0, (int)&byte_A0614);
}
// 9E31C: using guessed type int dword_9E31C;
// A0614: using guessed type char byte_A0614;
// A0624: using guessed type int dword_A0624;

//----- (0001A4F0) --------------------------------------------------------
int __fastcall sub_1A4F0(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v3, 0x800u, "Set to voltage raw %d, step by step.\n", a1);
    sub_47AB4(3, v3, 0);
  }
  return sub_19D18(a1, (int)&byte_A0614);
}
// 9E31C: using guessed type int dword_9E31C;
// A0614: using guessed type char byte_A0614;

//----- (0001A79C) --------------------------------------------------------
int __fastcall sub_1A79C(int result)
{
  dword_A062C = result;
  return result;
}
// A062C: using guessed type int dword_A062C;

//----- (0001A7AC) --------------------------------------------------------
int sub_1A7AC()
{
  return *(_DWORD *)dword_A062C;
}
// A062C: using guessed type int dword_A062C;

//----- (0001A7C0) --------------------------------------------------------
int __fastcall sub_1A7C0(int a1)
{
  int v2; // r5
  int v3; // r4
  char v5[2048]; // [sp+0h] [bp-800h] BYREF

  v2 = 1 << a1;
  v3 = 3000;
  do
  {
    if ( (sub_6FF04() & v2) != 0 )
      return 1;
    sub_4A830();
    --v3;
  }
  while ( v3 );
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v5, 0x800u, "Error: send open core work Failed on Chain[%d]!\n", a1);
    sub_47AB4(3, v5, 0);
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0001A850) --------------------------------------------------------
int sub_1A850()
{
  int i; // r4
  int result; // r0

  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
      result = sub_754BC((unsigned __int8)i, 0);
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001A894) --------------------------------------------------------
int __fastcall sub_1A894(unsigned int a1, int a2)
{
  return sub_75A88(a1, a2, 1);
}

//----- (0001A89C) --------------------------------------------------------
int __fastcall sub_1A89C(unsigned int a1, int a2)
{
  return sub_75A88(a1, a2, 0);
}

//----- (0001A8A4) --------------------------------------------------------
int __fastcall sub_1A8A4(unsigned int a1)
{
  return sub_75A2C(a1, 1);
}

//----- (0001A8AC) --------------------------------------------------------
void __fastcall sub_1A8AC(unsigned int a1, int a2)
{
  int i; // r4
  unsigned int v5; // r0
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        goto LABEL_5;
    }
    v5 = (unsigned __int8)i;
    sub_74B18(v5, a1);
  }
LABEL_5:
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "set chip baud = %d, chip_divider = %d\n", a1, a2);
    sub_47AB4(4, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (0001A958) --------------------------------------------------------
int __fastcall sub_1A958(int result, int a2, int a3, char a4)
{
  int v5; // r6
  int i; // r4
  bool v9; // zf

  v5 = result;
  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
    {
      v9 = v5 == 255;
      if ( v5 != 255 )
        v9 = v5 == (unsigned __int8)i;
      if ( v9 )
      {
        if ( a3 )
          result = sub_752C0((unsigned __int8)i, a4);
        else
          result = sub_75294((unsigned __int8)i, a2, a4);
      }
    }
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001A9D4) --------------------------------------------------------
int __fastcall sub_1A9D4(int a1)
{
  int v2; // r4
  int result; // r0
  int v4; // r3
  bool v5; // zf

  v2 = 0;
  do
  {
    while ( 1 )
    {
      result = (unsigned __int8)v2;
      v4 = dword_A0D68 + 4 * v2++;
      if ( *(_DWORD *)(v4 + 4) == 1 )
      {
        v5 = a1 == 255;
        if ( a1 != 255 )
          v5 = a1 == result;
        if ( v5 )
          break;
      }
      if ( v2 == 16 )
        return result;
    }
    result = sub_75B10(result);
  }
  while ( v2 != 16 );
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001AA30) --------------------------------------------------------
void __fastcall sub_1AA30(int a1, int a2, int a3)
{
  int v3; // r7
  int v5; // r8
  int v6; // r5
  int v7; // r6
  int v8; // r4
  int v9; // r4
  unsigned int v10; // r4
  int v11; // r2
  int v12; // r4
  int v13; // r3
  float v14; // s21
  float v15; // s22
  float v16; // s20
  float v17; // s23
  unsigned int v18; // [sp+34h] [bp-810h]
  char s[2052]; // [sp+40h] [bp-804h] BYREF

  v3 = 0;
  v5 = a3;
  v6 = a2;
  v7 = 0;
  do
  {
    v8 = *(unsigned __int8 *)(dword_A0D68 + 12954);
    pthread_mutex_lock(&stru_A0DB0);
    v9 = v3 * v8;
    v3 += 6;
    v18 = sub_2EC38(180, v9, a1);
    v10 = sub_2EC38(184, v9, a1);
    pthread_mutex_unlock(&stru_A0DB0);
    v11 = v10 & 0xFFF;
    v12 = HIWORD(v10) & 0xFFF;
    v13 = HIWORD(v18) & 0xFFF;
    v14 = (double)(v11 - v13) * 1.5 * 0.000244140625;
    v15 = (double)(int)(v13 - (v18 & 0xFFF)) * 1.5 * 0.000244140625;
    v16 = (double)(v12 - v11) * 1.5 * 0.000244140625;
    v17 = (double)(v18 & 0xFFF) * 1.5 * 0.000244140625;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(
        s,
        0x800u,
        "chain %d domain %2d: d0 %.3f, d1 %.3f, d2 %.3f, d3 %.3f, sum = %f\n",
        a1,
        v7,
        v17,
        v15,
        v14,
        v16,
        (double)v12 * 1.5 * 0.000244140625);
      sub_47EC8(3, s, 0);
    }
    ++v7;
    v6 += 16;
    v5 += 4;
    if ( a2 )
    {
      *(float *)(v6 - 12) = v15;
      *(float *)(v6 - 8) = v14;
      *(float *)(v6 - 4) = v16;
      *(float *)(v6 - 16) = v17;
    }
    if ( a3 )
      *(float *)(v5 - 4) = (float)((float)(v17 + v15) + v14) + v16;
  }
  while ( v7 != 13 );
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (0001AC10) --------------------------------------------------------
int __fastcall sub_1AC10(unsigned int a1)
{
  int v2; // r4
  int result; // r0
  int v4; // r3

  v2 = 0;
  do
  {
    while ( 1 )
    {
      result = (unsigned __int8)v2;
      v4 = dword_A0D68 + 4 * v2++;
      if ( *(_DWORD *)(v4 + 4) == 1 )
        break;
      if ( v2 == 16 )
        return result;
    }
    result = sub_74D64(result, a1);
  }
  while ( v2 != 16 );
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001AC60) --------------------------------------------------------
unsigned int __fastcall sub_1AC60(__int16 a1)
{
  char v2; // r6
  int v3; // r4
  unsigned int result; // r0
  int v5; // r3

  switch ( dword_9EE34 )
  {
    case 4:
      v2 = 0;
      break;
    case 8:
      v2 = 1;
      break;
    case 12:
      v2 = 2;
      break;
    default:
      v2 = 0;
      break;
  }
  v3 = 0;
  do
  {
    while ( 1 )
    {
      result = (unsigned __int8)v3;
      v5 = dword_A0D68 + 4 * v3++;
      if ( *(_DWORD *)(v5 + 4) == 1 )
        break;
      if ( v3 == 16 )
        return result;
    }
    result = sub_75374(result, 1, v2, a1);
  }
  while ( v3 != 16 );
  return result;
}
// 9EE34: using guessed type int dword_9EE34;
// A0D68: using guessed type int dword_A0D68;

//----- (0001ACE4) --------------------------------------------------------
int sub_1ACE4()
{
  int i; // r7
  int v1; // r3
  int v2; // r4
  int v3; // r6
  int result; // r0
  int v5; // r3

  for ( i = 6; i != 78; i += 6 )
  {
    v1 = dword_A0D68;
    v2 = 0;
    v3 = (unsigned __int8)(i * *(_BYTE *)(dword_A0D68 + 12954));
    while ( 1 )
    {
      result = (unsigned __int8)v2;
      v5 = *(_DWORD *)(v1 + 4 * v2++ + 4);
      if ( v5 == 1 )
        break;
      if ( v2 == 16 )
        goto LABEL_7;
LABEL_4:
      v1 = dword_A0D68;
    }
    result = sub_759F4(result, v3, 13, 1, 1);
    if ( v2 != 16 )
      goto LABEL_4;
LABEL_7:
    ;
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001AD6C) --------------------------------------------------------
int __fastcall sub_1AD6C(int result, int a2, char a3, char a4)
{
  int v4; // r6
  int i; // r4
  bool v9; // zf

  v4 = result;
  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
    {
      v9 = v4 == i;
      if ( v4 != i )
        v9 = v4 == 255;
      result = (unsigned __int8)i;
      if ( v9 )
        result = sub_74A6C((unsigned __int8)i, a2, a3, a4);
    }
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001ADD4) --------------------------------------------------------
int __fastcall sub_1ADD4(
        unsigned __int8 a1,
        unsigned __int8 a2,
        unsigned __int8 a3,
        int a4,
        unsigned __int8 a5,
        unsigned __int8 a6)
{
  if ( a4 )
    return sub_75974(a6, a5, a1, a2, a3);
  else
    return sub_75928(a6, a5, a1, a2);
}

//----- (0001AE00) --------------------------------------------------------
int sub_1AE00()
{
  int v0; // r4
  int v1; // r3
  int v2; // r6
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(v4, 0x800u, "--- %s\n", "dhash_chip_set_addr_all");
    sub_47AB4(7, v4, 0);
  }
  v0 = 0;
  v1 = dword_A0D68;
  *(_BYTE *)(dword_A0D68 + 12954) = 3;
  while ( *(_DWORD *)(v1 + 4 * v0 + 4) != 1 || !*(_BYTE *)(v1 + v0 + 12918) )
  {
    if ( ++v0 == 16 )
      return sub_4A804();
LABEL_7:
    v1 = dword_A0D68;
  }
  v2 = (unsigned __int8)v0++;
  sub_74AC8(v2);
  sub_4A804();
  sub_74AC8(v2);
  sub_4A804();
  sub_74AC8(v2);
  sub_4A804();
  sub_74ACC(v2, *(unsigned __int8 *)(dword_A0D68 + 12954));
  if ( v0 != 16 )
    goto LABEL_7;
  return sub_4A804();
}
// 74AC8: using guessed type int __fastcall sub_74AC8(_DWORD);
// 9E320: using guessed type int dword_9E320;
// A0D68: using guessed type int dword_A0D68;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (0001AF48) --------------------------------------------------------
int __fastcall sub_1AF48(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  unsigned int *p_varg_r0; // r2
  unsigned __int8 *v10; // r1
  int v11; // r12
  int v12; // r3
  int *v13; // r1
  int v14; // r3
  int var34[17]; // [sp+4h] [bp-34h] BYREF
  unsigned int varg_r0; // [sp+48h] [bp+10h] BYREF
  int varg_r1; // [sp+4Ch] [bp+14h]
  int varg_r2; // [sp+50h] [bp+18h]
  int varg_r3; // [sp+54h] [bp+1Ch]

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  memset(&var34[2], 0, 0x2Cu);
  p_varg_r0 = &varg_r0;
  v10 = (unsigned __int8 *)&varg_r0;
  v11 = 2;
  var34[0] = bswap32(varg_r0);
  var34[1] = varg_r1;
  do
  {
    v12 = v10[9];
    v10 += 4;
    var34[v11++] = (v12 << 16) | (v10[4] << 24) | v10[7] | (v10[6] << 8);
  }
  while ( v11 != 5 );
  v13 = &var34[5];
  do
  {
    v14 = *((unsigned __int8 *)p_varg_r0++ + 21);
    *v13++ = (v14 << 16)
           | (*((unsigned __int8 *)p_varg_r0 + 16) << 24)
           | *((unsigned __int8 *)p_varg_r0 + 19)
           | (*((unsigned __int8 *)p_varg_r0 + 18) << 8);
  }
  while ( p_varg_r0 != (unsigned int *)&a9 );
  return sub_708A4(var34, 0x34u);
}

//----- (0001B010) --------------------------------------------------------
int __fastcall sub_1B010(
        unsigned int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33)
{
  unsigned int *p_varg_r0; // r2
  unsigned __int8 *v34; // r1
  int v35; // r12
  int v36; // r3
  int *v37; // r6
  unsigned int *v38; // r5
  int *v39; // r1
  int v40; // r3
  int var98[43]; // [sp+4h] [bp-ACh] BYREF
  unsigned int varg_r0; // [sp+B0h] [bp+0h] BYREF
  int varg_r1; // [sp+B4h] [bp+4h]
  int varg_r2; // [sp+B8h] [bp+8h]
  int varg_r3; // [sp+BCh] [bp+Ch]

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  memset(&var98[2], 0, 0x8Cu);
  p_varg_r0 = &varg_r0;
  v34 = (unsigned __int8 *)&varg_r0;
  v35 = 2;
  var98[0] = bswap32(varg_r0);
  var98[1] = varg_r1;
  do
  {
    v36 = v34[9];
    v34 += 4;
    var98[v35++] = (v36 << 16) | (v34[4] << 24) | v34[7] | (v34[6] << 8);
  }
  while ( v35 != 5 );
  v37 = &var98[5];
  do
  {
    v38 = p_varg_r0 + 8;
    v39 = v37;
    do
    {
      v40 = *((unsigned __int8 *)p_varg_r0++ + 21);
      *v39++ = (v40 << 16)
             | (*((unsigned __int8 *)p_varg_r0 + 16) << 24)
             | *((unsigned __int8 *)p_varg_r0 + 19)
             | (*((unsigned __int8 *)p_varg_r0 + 18) << 8);
    }
    while ( p_varg_r0 != v38 );
    v37 += 8;
  }
  while ( p_varg_r0 != (unsigned int *)&a33 );
  return sub_708A4(var98, 0x94u);
}

//----- (0001B0EC) --------------------------------------------------------
int __fastcall sub_1B0EC(int a1, char a2)
{
  int i; // r4
  int result; // r0

  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
      result = sub_75C4C((unsigned __int8)i, a2, 0);
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B138) --------------------------------------------------------
int __fastcall sub_1B138(int a1, char a2, char a3, char a4)
{
  int i; // r4
  int result; // r0

  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
      result = sub_75CC4((unsigned __int8)i, a2, a3, a4);
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B194) --------------------------------------------------------
int sub_1B194()
{
  unsigned __int8 vars0; // [sp+0h] [bp+0h]
  unsigned __int8 vars1; // [sp+1h] [bp+1h]
  unsigned __int8 vars2; // [sp+2h] [bp+2h]
  unsigned __int16 vars4; // [sp+4h] [bp+4h]
  unsigned __int8 vars6; // [sp+6h] [bp+6h]

  return (int)(float)((float)((float)(25.0 / (float)vars2) * (float)vars4) / (float)(vars6 * vars0 * vars1));
}
// 1B1B0: variable 'vars2' is possibly undefined
// 1B1C0: variable 'vars4' is possibly undefined
// 1B1C8: variable 'vars6' is possibly undefined
// 1B1BC: variable 'vars0' is possibly undefined
// 1B1BC: variable 'vars1' is possibly undefined

//----- (0001B1F4) --------------------------------------------------------
int __fastcall sub_1B1F4(int result, int a2, int a3, unsigned int a4, int a5, __int16 a6)
{
  int v6; // r6
  int i; // r4
  bool v11; // zf
  int v12; // r0

  v6 = result;
  for ( i = 0; i != 16; ++i )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
        goto LABEL_2;
      v11 = v6 == 255;
      if ( v6 != 255 )
        v11 = i == v6;
      if ( !v11 )
        goto LABEL_2;
      v12 = (unsigned __int8)i;
      if ( a2 )
        break;
      result = sub_750D8((unsigned __int8)i, a3, a4, a5, a6);
LABEL_2:
      if ( ++i == 16 )
        return result;
    }
    result = sub_75094(v12, a4, a5, a6);
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B298) --------------------------------------------------------
void __fastcall sub_1B298(int a1, int a2)
{
  int i; // r4

  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
    {
      sub_752FC((unsigned __int8)i);
      if ( a2 )
        sub_75644((unsigned __int8)i);
      else
        sub_7569C((unsigned __int8)i);
    }
  }
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B2F8) --------------------------------------------------------
int __fastcall sub_1B2F8(int result)
{
  int v1; // r6
  int i; // r4

  v1 = result;
  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
      result = sub_75548((unsigned __int8)i, v1);
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B340) --------------------------------------------------------
const char *__fastcall sub_1B340(int a1, char a2)
{
  return sub_43D2C(a1, "miner_version", byte_1B0A18, a2);
}

//----- (0001B358) --------------------------------------------------------
const char *__fastcall sub_1B358(int a1, char a2)
{
  return sub_43D2C(a1, "miner_id", byte_241D24, a2);
}

//----- (0001B370) --------------------------------------------------------
const char *__fastcall sub_1B370(int a1, char a2)
{
  return sub_43D6C(a1, "miner_count", (const char *)(dword_A0D68 + 12935), a2);
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B394) --------------------------------------------------------
const char *__fastcall sub_1B394(int a1, char a2)
{
  return sub_43D2C(a1, "frequency", (const char *)(dword_A0D68 + 12981), a2);
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B3B8) --------------------------------------------------------
const char *__fastcall sub_1B3B8(int a1, char a2)
{
  int v3; // r5
  int v4; // r4
  const char *v5; // r6
  const char *v6; // r2
  const char *result; // r0
  char s[16]; // [sp+4h] [bp-10h] BYREF

  v3 = 12822;
  v4 = 0;
  v5 = sub_43D6C(a1, "fan_num", (const char *)(dword_A0D68 + 12936), a2);
  do
  {
    sprintf(s, "fan%d", ++v4);
    v6 = (const char *)(dword_A0D68 + v3);
    v3 += 4;
    result = sub_43DEC((int)v5, s, v6, a2);
    v5 = result;
  }
  while ( v4 != 16 );
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B440) --------------------------------------------------------
const char *__fastcall sub_1B440(int a1, char a2)
{
  int v3; // r6
  const char *v4; // r5
  int v5; // r0
  int v6; // r6
  int v7; // r0
  int v8; // r6
  int v9; // r0
  int v10; // r7
  int v11; // r11
  int v12; // r0
  int v13; // r2
  int v14; // r6
  int v15; // r0
  int v16; // r7
  int v17; // r11
  int v18; // r0
  int v19; // r2
  int v20; // r6
  int v21; // r0
  const char *result; // r0
  char s[12]; // [sp+Ch] [bp-50h] BYREF
  char v24[68]; // [sp+18h] [bp-44h] BYREF

  v3 = 0;
  v4 = sub_43D6C(a1, "temp_num", (const char *)(dword_A0D68 + 12935), a2);
  do
  {
    v5 = v3++;
    *(_WORD *)s = sub_16C84(v5);
    sprintf(v24, "temp%d", v3);
    v4 = sub_43D8C((int)v4, v24, s, a2);
  }
  while ( v3 != 16 );
  v6 = 0;
  do
  {
    v7 = v6++;
    *(_WORD *)s = sub_16DE4(v7);
    sprintf(v24, "temp2_%d", v6);
    v4 = sub_43D8C((int)v4, v24, s, a2);
  }
  while ( v6 != 16 );
  v8 = 0;
  do
  {
    v9 = v8++;
    *(_WORD *)s = sub_17028(v9, 1);
    sprintf(v24, "temp3_%d", v8);
    v4 = sub_43D8C((int)v4, v24, s, a2);
  }
  while ( v8 != 16 );
  v10 = 0;
  do
  {
    v11 = 0;
    v12 = sub_16E94(v10, 0);
    v13 = sprintf(v24, "%d", v12);
    do
    {
      ++v11;
      v14 = v13 + 1;
      *(_WORD *)&v24[v13] = 45;
      v15 = sub_16E94(v10, (unsigned __int8)v11);
      v13 = sprintf(&v24[v14], "%d", v15) + v14;
    }
    while ( v11 != 3 );
    sprintf(s, "temp_pcb%d", ++v10);
    v4 = sub_43D2C((int)v4, s, v24, a2);
  }
  while ( v10 != 16 );
  v16 = 0;
  do
  {
    v17 = 0;
    v18 = sub_17028(v16, 0);
    v19 = sprintf(v24, "%d", v18);
    do
    {
      ++v17;
      v20 = v19 + 1;
      *(_WORD *)&v24[v19] = 45;
      v21 = sub_17028(v16, (unsigned __int8)v17);
      v19 = sprintf(&v24[v20], "%d", v21) + v20;
    }
    while ( v17 != 3 );
    sprintf(s, "temp_chip%d", ++v16);
    result = sub_43D2C((int)v4, s, v24, a2);
    v4 = result;
  }
  while ( v16 != 16 );
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B6E0) --------------------------------------------------------
const char *__fastcall sub_1B6E0(int a1)
{
  int v2; // r4
  int v3; // r3
  const char *result; // r0
  double v5; // [sp+0h] [bp-18h] BYREF
  char s[12]; // [sp+Ch] [bp-Ch] BYREF

  v2 = 0;
  v5 = (double)sub_30578();
  do
  {
    sprintf(s, "freq_avg%d", ++v2, v3, v5);
    v5 = (double)(int)(v5 * 100.0) / 100.0;
    result = sub_43F2C(a1, s, (const char *)&v5, 1);
    a1 = (int)result;
  }
  while ( v2 != 16 );
  return result;
}
// 1B6E0: too many cbuild loops
// 1B72C: variable 'v3' is possibly undefined

//----- (0001B780) --------------------------------------------------------
const char *__fastcall sub_1B780(int a1)
{
  double v3; // [sp+0h] [bp-2Ch] BYREF
  char v4[32]; // [sp+8h] [bp-24h] BYREF

  strcpy(v4, "total_rateideal");
  v3 = (double)sub_3047C();
  return sub_43F2C(a1, v4, (const char *)&v3, 1);
}

//----- (0001B7DC) --------------------------------------------------------
const char *__fastcall sub_1B7DC(int a1, char a2)
{
  return sub_43D2C(a1, "rate_unit", "GH", a2);
}

//----- (0001B7F4) --------------------------------------------------------
const char *__fastcall sub_1B7F4(int a1)
{
  int v2; // r5
  int v3; // r0
  int v4; // r12
  int v5; // r4
  unsigned __int8 *v6; // lr
  int v7; // t1
  int v8; // r3
  double v10; // [sp+0h] [bp-2Ch] BYREF
  char v11[32]; // [sp+8h] [bp-24h] BYREF

  v2 = 0;
  v3 = sub_30578();
  v4 = dword_A0D68;
  v5 = dword_A0D68 + 64;
  v6 = (unsigned __int8 *)(dword_A0D68 + 12918);
  v10 = (double)v3;
  strcpy(v11, "total_freqavg");
  do
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(v4 + 4);
      v4 += 4;
      if ( v7 == 1 )
        break;
      ++v6;
      if ( v4 == v5 )
        goto LABEL_7;
    }
    v8 = *v6++;
    if ( v8 )
      v2 += v8;
  }
  while ( v4 != v5 );
LABEL_7:
  v10 = (double)(int)((double)v3 / (double)v2 * 100.0) / 100.0;
  return sub_43F2C(a1, v11, (const char *)&v10, 1);
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B8D0) --------------------------------------------------------
const char *__fastcall sub_1B8D0(int a1)
{
  int v1; // r3
  int v2; // r4
  int v3; // r12
  __int16 v4; // r1
  int v5; // t1
  __int16 v7; // [sp+6h] [bp-22h] BYREF
  char v8[32]; // [sp+8h] [bp-20h] BYREF

  v1 = dword_A0D68;
  v2 = 0;
  v3 = dword_A0D68 + 12918;
  v7 = 0;
  strcpy(v8, "total_acn");
  v4 = 0;
  do
  {
    v5 = *(_DWORD *)(v1 + 4);
    v1 += 4;
    ++v3;
    if ( v5 == 1 )
    {
      v2 = 1;
      v4 += *(unsigned __int8 *)(v3 - 1);
    }
  }
  while ( v1 != dword_A0D68 + 64 );
  if ( v2 )
    v7 = v4;
  return sub_43D8C(a1, v8, (const char *)&v7, 1);
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001B964) --------------------------------------------------------
const char *__fastcall sub_1B964(int a1)
{
  double v1; // d0
  int v3; // r4
  char *v4; // r0
  double v6; // [sp+0h] [bp-2Ch] BYREF
  char v7[32]; // [sp+8h] [bp-24h] BYREF

  v3 = 0;
  strcpy(v7, "total_rate");
  v6 = 0.0;
  do
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * v3 + 4) == 1 )
      {
        v4 = &byte_241B00[32 * v3];
        if ( *v4 )
          break;
      }
      if ( ++v3 == 16 )
        goto LABEL_6;
    }
    ++v3;
    strtod(v4, 0);
    v1 = v6 + v1;
    v6 = v1;
  }
  while ( v3 != 16 );
LABEL_6:
  v6 = (double)(int)(v6 * 100.0) / 100.0;
  return sub_43F2C(a1, v7, (const char *)&v6, 1);
}
// 1B9F8: variable 'v1' is possibly undefined
// A0D68: using guessed type int dword_A0D68;

//----- (0001BA48) --------------------------------------------------------
const char *__fastcall sub_1BA48(int a1)
{
  int v2; // r4
  const char *result; // r0
  double v4; // [sp+0h] [bp-2Ch] BYREF
  char s[36]; // [sp+8h] [bp-24h] BYREF

  v2 = 0;
  do
  {
    ++v2;
    v4 = 0.0;
    sprintf(s, "chain_rateideal%d", v2);
    v4 = (double)(int)((double)sub_30578() / 1000.0 * 100.0) / 100.0;
    result = sub_43F2C(a1, s, (const char *)&v4, 1);
    a1 = (int)result;
  }
  while ( v2 != 16 );
  return result;
}

//----- (0001BAE8) --------------------------------------------------------
const char *__fastcall sub_1BAE8(int a1, char a2)
{
  char v5; // [sp+7h] [bp-5h] BYREF

  v5 = sub_169E4();
  return sub_43D6C(a1, "temp_max", &v5, a2);
}

//----- (0001BB20) --------------------------------------------------------
const char *__fastcall sub_1BB20(int a1)
{
  __int64 v2; // r0
  double v3; // d8
  double v4; // r0
  double v5; // d7
  double v7; // [sp+0h] [bp-8h] BYREF

  *(_QWORD *)&dword_2463D0 = (__int64)(dbl_242EF0 + dbl_242F10 + dbl_246238);
  v2 = (__int64)(dbl_242EF0 + dbl_242F10 + dbl_246238) + dword_242EE8;
  if ( v2 )
  {
    v3 = (double)dword_242EE8;
    LODWORD(v4) = sub_778B4(v2);
    v5 = v3 / v4;
  }
  else
  {
    v5 = 0.0;
  }
  v7 = v5;
  return sub_4402C(a1, "Device Hardware%", (const char *)&v7, 1);
}
// 1BBA4: variable 'v4' is possibly undefined
// 242EE8: using guessed type int dword_242EE8;
// 242EF0: using guessed type double dbl_242EF0;
// 242F10: using guessed type double dbl_242F10;
// 246238: using guessed type double dbl_246238;
// 2463D0: using guessed type int dword_2463D0;

//----- (0001BBE0) --------------------------------------------------------
const char *__fastcall sub_1BBE0(int a1, char a2)
{
  return sub_43DCC(a1, "no_matching_work", (const char *)&dword_242EE8, a2);
}
// 242EE8: using guessed type int dword_242EE8;

//----- (0001BBF8) --------------------------------------------------------
const char *__fastcall sub_1BBF8(int a1, char a2)
{
  int i; // r4
  int v5; // r2
  const char *result; // r0
  char s[12]; // [sp+4h] [bp-Ch] BYREF

  for ( i = 0; i != 16; ++i )
  {
    sprintf(s, "chain_acn%d", i + 1);
    v5 = i + 12918;
    result = sub_43D6C(a1, s, (const char *)(dword_A0D68 + v5), a2);
    a1 = (int)result;
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001BC68) --------------------------------------------------------
const char *__fastcall sub_1BC68(int a1, char a2)
{
  int v4; // r5
  int v5; // r4
  const char *v6; // r2
  const char *result; // r0
  char s[16]; // [sp+4h] [bp-10h] BYREF

  v4 = 11254;
  v5 = 0;
  do
  {
    sprintf(s, "chain_acs%d", ++v5);
    v6 = (const char *)(dword_A0D68 + v4);
    v4 += 97;
    result = sub_43D2C(a1, s, v6, a2);
    a1 = (int)result;
  }
  while ( v5 != 16 );
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001BCD4) --------------------------------------------------------
const char *__fastcall sub_1BCD4(int a1, char a2)
{
  int v4; // r5
  int v5; // r4
  const char *v6; // r2
  const char *result; // r0
  char v8[20]; // [sp+0h] [bp-14h] BYREF

  v4 = 1206;
  v5 = 0;
  do
  {
    sprintf(v8, "chain_hw%d", ++v5);
    v6 = (const char *)(dword_A0D68 + v4);
    v4 += 4;
    result = sub_43E0C(a1, v8, v6, a2);
    a1 = (int)result;
  }
  while ( v5 != 16 );
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001BD40) --------------------------------------------------------
const char *__fastcall sub_1BD40(int a1, char a2)
{
  const char *v2; // r5
  int v5; // r4
  const char *result; // r0
  char v7[16]; // [sp+0h] [bp-10h] BYREF

  v2 = byte_241B00;
  v5 = 0;
  do
  {
    sprintf(v7, "chain_rate%d", ++v5);
    result = sub_43D2C(a1, v7, v2, a2);
    a1 = (int)result;
    v2 += 32;
  }
  while ( v5 != 16 );
  return result;
}

//----- (0001BDA4) --------------------------------------------------------
const char *__fastcall sub_1BDA4(const char *a1, char a2)
{
  int v3; // r10
  int v4; // r5
  int v5; // r4
  int v6; // r10
  _QWORD *v7; // r2
  char v10[4]; // [sp+8h] [bp-814h] BYREF
  int v11; // [sp+Ch] [bp-810h]
  int v12; // [sp+10h] [bp-80Ch]
  int v13; // [sp+14h] [bp-808h]
  _DWORD v14[513]; // [sp+18h] [bp-804h] BYREF

  v3 = 0;
  do
  {
    while ( 1 )
    {
      v4 = v3 + 1;
      v5 = *(_DWORD *)(dword_A0D68 + 4 * v3 + 4);
      if ( v5 == 1 )
        break;
      ++v3;
      if ( v4 == 16 )
        return a1;
    }
    v14[0] = 123;
    memset(&v14[1], 0, 0x7FCu);
    v12 = 0;
    v13 = 0;
    *(_DWORD *)v10 = 0;
    v11 = 0;
    sprintf(v10, "chain_xtime%d", v3 + 1);
    v6 = dword_A0D68 + v3;
    dword_A0DC8[256 * v4 - 256] = 0;
    if ( *(unsigned __int8 *)(v6 + 12918) > 1u )
    {
      v7 = &qword_A07D8[128 * v4 + 62];
      do
      {
        *((_DWORD *)v7 + 1) = 0;
        v7 = (_QWORD *)((char *)v7 + 4);
        ++v5;
      }
      while ( *(unsigned __int8 *)(v6 + 12918) > v5 );
    }
    v3 = v4;
    *(_WORD *)((char *)v14 + strlen((const char *)v14)) = 125;
    a1 = sub_43D2C((int)a1, v10, (const char *)v14, a2);
  }
  while ( v4 != 16 );
  return a1;
}
// 836FC: using guessed type __int16 word_836FC;
// A07D8: using guessed type _QWORD qword_A07D8[176];
// A0D68: using guessed type int dword_A0D68;
// A0DC8: using guessed type _DWORD dword_A0DC8[4096];

//----- (0001BED0) --------------------------------------------------------
const char *__fastcall sub_1BED0(const char *a1, char a2)
{
  int v4; // r4
  int v5; // r3
  char v7[20]; // [sp+0h] [bp-28h] BYREF
  char v8[20]; // [sp+14h] [bp-14h] BYREF

  v4 = 0;
  do
  {
    while ( 1 )
    {
      v5 = dword_A0D68 + 4 * v4++;
      if ( *(_DWORD *)(v5 + 4) == 1 )
        break;
      if ( v4 == 16 )
        return a1;
    }
    sprintf(v7, "chain_offside_%d", v4);
    a1 = sub_43D2C((int)a1, v7, v8, a2);
  }
  while ( v4 != 16 );
  return a1;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001BF54) --------------------------------------------------------
const char *__fastcall sub_1BF54(const char *a1, char a2)
{
  int v4; // r4
  int v5; // r3
  char v7[20]; // [sp+0h] [bp-28h] BYREF
  __int16 v8[10]; // [sp+14h] [bp-14h] BYREF

  v4 = 0;
  do
  {
    while ( 1 )
    {
      v5 = dword_A0D68 + 4 * v4++;
      if ( *(_DWORD *)(v5 + 4) == 1 )
        break;
      if ( v4 == 16 )
        return a1;
    }
    sprintf(v7, "chain_opencore_%d", v4);
    v8[0] = 49;
    a1 = sub_43D2C((int)a1, v7, (const char *)v8, a2);
  }
  while ( v4 != 16 );
  return a1;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001BFE0) --------------------------------------------------------
_DWORD *__fastcall sub_1BFE0(_DWORD *result)
{
  result[2] = 1779033703;
  result[3] = -1150833019;
  result[4] = 1013904242;
  result[5] = -1521486534;
  result[6] = 1359893119;
  result[7] = -1694144372;
  result[8] = 528734635;
  result[9] = 1541459225;
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (0001C054) --------------------------------------------------------
int __fastcall sub_1C054(_DWORD *a1, unsigned int *a2)
{
  int v2; // r7
  int v4; // r8
  int v5; // r1
  int v6; // r9
  unsigned int v7; // r5
  unsigned int v8; // r3
  int v9; // r6
  unsigned int v10; // r12
  int v11; // r3
  int v12; // r0
  int v13; // r5
  int v14; // r3
  int v15; // r2
  int v16; // r4
  int v17; // lr
  int v18; // r3
  int v19; // r6
  unsigned int v20; // r12
  int v21; // r10
  int v22; // r6
  int v23; // r0
  int v24; // r6
  int v25; // r8
  int v26; // r5
  int v27; // r2
  int v28; // r9
  int v29; // r3
  int v30; // r9
  int v31; // r11
  int v32; // r10
  int v33; // r11
  int v34; // r12
  int v35; // r6
  int v36; // r7
  int v37; // r12
  int v38; // r5
  int v39; // lr
  int v40; // r12
  int v41; // r2
  int v42; // r9
  int v43; // r10
  int v44; // r4
  int v45; // r11
  int v46; // r6
  int v47; // r7
  int v48; // r0
  int v49; // r5
  int v50; // r6
  int v51; // lr
  int v52; // r9
  int v53; // r2
  int v54; // r11
  int v55; // r9
  int v56; // r3
  unsigned int v57; // r10
  int v58; // r1
  int v59; // r4
  int v60; // r12
  int v61; // lr
  int v62; // r6
  int v63; // r0
  int v64; // r2
  int v65; // r1
  int v66; // r5
  int v67; // r9
  int v68; // lr
  int v69; // r2
  int v70; // r4
  int v71; // r12
  int v72; // r3
  int v73; // r4
  int v74; // r0
  int v75; // r4
  int v76; // r8
  int v77; // r1
  int v78; // r9
  unsigned int v79; // r10
  int v80; // r7
  int v81; // r2
  int v82; // r7
  int v83; // r6
  int v84; // r12
  int v85; // r3
  int v86; // r6
  int v87; // r4
  int v88; // r0
  int v89; // r6
  int v90; // r1
  int v91; // r9
  int v92; // r5
  int v93; // r7
  int v94; // r5
  int v95; // lr
  int v96; // r12
  int v97; // r3
  int v98; // lr
  int v99; // r0
  int v100; // r4
  int v101; // lr
  int v102; // r9
  int v103; // r1
  int v104; // lr
  int v105; // r8
  int v106; // r5
  int v107; // r11
  int v108; // r6
  int v109; // r3
  int v110; // r10
  int v111; // r1
  int v112; // r4
  int v113; // r8
  int v114; // r1
  int v115; // r6
  int v116; // r2
  int v117; // r5
  int v118; // r0
  int v119; // r12
  int v120; // lr
  int v121; // r7
  int v122; // r3
  int v123; // r9
  int v124; // r1
  int v125; // r4
  int v126; // r5
  int v127; // r9
  int v128; // r10
  int v129; // r5
  int v130; // r12
  int v131; // r2
  int v132; // r8
  int v133; // r3
  int v134; // r0
  int v135; // r7
  int v136; // r11
  int v137; // r1
  int v138; // r10
  int v139; // r8
  int v140; // r5
  int v141; // r2
  int v142; // r9
  int v143; // r5
  int v144; // r0
  int v145; // r12
  int v146; // r7
  int v147; // r11
  int v148; // r3
  int v149; // r7
  int v150; // r10
  int v151; // lr
  int v152; // r7
  int v153; // r9
  int v154; // r8
  int v155; // r6
  int v156; // r5
  int v157; // r12
  int v158; // r0
  int v159; // r3
  int v160; // r0
  int v161; // r11
  int v162; // lr
  int v163; // r11
  int v164; // r10
  int v165; // r8
  int v166; // r10
  int v167; // r9
  int v168; // r5
  int v169; // r9
  int v170; // r12
  int v171; // r0
  int v172; // r12
  int v173; // r7
  int v174; // r11
  int v175; // r3
  unsigned int v176; // r6
  unsigned int v177; // r1
  int v178; // lr
  int v179; // r2
  int v180; // r3
  unsigned int v181; // r7
  int v182; // r4
  int v183; // r12
  int v184; // r4
  unsigned int v185; // r10
  int v186; // r1
  int v187; // r8
  int v188; // lr
  int v189; // r10
  unsigned int v190; // r7
  int v191; // r6
  int v192; // r1
  int v193; // r2
  unsigned int v194; // r8
  int v195; // r9
  int v196; // r3
  int v197; // r0
  int v198; // r6
  int v199; // r5
  int v200; // r4
  int v201; // r12
  int v202; // r9
  int result; // r0
  unsigned int *v204; // [sp+4h] [bp-78h]
  unsigned int v205; // [sp+4h] [bp-78h]
  unsigned int v206; // [sp+4h] [bp-78h]
  int v207; // [sp+4h] [bp-78h]
  unsigned int v208; // [sp+8h] [bp-74h]
  unsigned int v209; // [sp+8h] [bp-74h]
  unsigned int v210; // [sp+8h] [bp-74h]
  unsigned int v211; // [sp+Ch] [bp-70h]
  unsigned int v212; // [sp+Ch] [bp-70h]
  unsigned int v213; // [sp+Ch] [bp-70h]
  unsigned int v214; // [sp+10h] [bp-6Ch]
  unsigned int v215; // [sp+10h] [bp-6Ch]
  unsigned int v216; // [sp+10h] [bp-6Ch]
  unsigned int v217; // [sp+14h] [bp-68h]
  unsigned int v218; // [sp+14h] [bp-68h]
  unsigned int v219; // [sp+14h] [bp-68h]
  unsigned int v220; // [sp+18h] [bp-64h]
  unsigned int v221; // [sp+18h] [bp-64h]
  unsigned int v222; // [sp+18h] [bp-64h]
  unsigned int v223; // [sp+1Ch] [bp-60h]
  unsigned int v224; // [sp+1Ch] [bp-60h]
  unsigned int v225; // [sp+1Ch] [bp-60h]
  int v226; // [sp+1Ch] [bp-60h]
  int v227; // [sp+1Ch] [bp-60h]
  unsigned int v228; // [sp+20h] [bp-5Ch]
  unsigned int v229; // [sp+20h] [bp-5Ch]
  unsigned int v230; // [sp+20h] [bp-5Ch]
  unsigned int v231; // [sp+20h] [bp-5Ch]
  int v232; // [sp+24h] [bp-58h]
  unsigned int v233; // [sp+24h] [bp-58h]
  unsigned int v234; // [sp+24h] [bp-58h]
  unsigned int v235; // [sp+24h] [bp-58h]
  unsigned int v236; // [sp+28h] [bp-54h]
  unsigned int v237; // [sp+28h] [bp-54h]
  unsigned int v238; // [sp+28h] [bp-54h]
  int v239; // [sp+28h] [bp-54h]
  unsigned int v240; // [sp+2Ch] [bp-50h]
  unsigned int v241; // [sp+2Ch] [bp-50h]
  unsigned int v242; // [sp+2Ch] [bp-50h]
  int v243; // [sp+2Ch] [bp-50h]
  unsigned int v244; // [sp+30h] [bp-4Ch]
  unsigned int v245; // [sp+30h] [bp-4Ch]
  unsigned int v246; // [sp+30h] [bp-4Ch]
  unsigned int v247; // [sp+34h] [bp-48h]
  unsigned int v248; // [sp+34h] [bp-48h]
  unsigned int v249; // [sp+34h] [bp-48h]
  unsigned int v250; // [sp+38h] [bp-44h]
  unsigned int v251; // [sp+38h] [bp-44h]
  unsigned int v252; // [sp+38h] [bp-44h]
  unsigned int v253; // [sp+3Ch] [bp-40h]
  unsigned int v254; // [sp+3Ch] [bp-40h]
  unsigned int v255; // [sp+3Ch] [bp-40h]
  unsigned int v256; // [sp+40h] [bp-3Ch]
  unsigned int v257; // [sp+40h] [bp-3Ch]
  unsigned int v258; // [sp+40h] [bp-3Ch]
  unsigned int v259; // [sp+40h] [bp-3Ch]
  unsigned int v260; // [sp+44h] [bp-38h]
  unsigned int v261; // [sp+44h] [bp-38h]
  unsigned int v262; // [sp+44h] [bp-38h]
  unsigned int v263; // [sp+44h] [bp-38h]
  unsigned int v264; // [sp+48h] [bp-34h]
  unsigned int v265; // [sp+48h] [bp-34h]
  unsigned int v266; // [sp+48h] [bp-34h]
  int v267; // [sp+4Ch] [bp-30h]
  unsigned int v268; // [sp+50h] [bp-2Ch]
  unsigned int v269; // [sp+54h] [bp-28h]
  int v270; // [sp+58h] [bp-24h]
  int v271; // [sp+5Ch] [bp-20h]
  int v272; // [sp+60h] [bp-1Ch]
  int v273; // [sp+64h] [bp-18h]
  int v274; // [sp+68h] [bp-14h]
  int v275; // [sp+6Ch] [bp-10h]
  int v276; // [sp+70h] [bp-Ch]

  v2 = a1[2];
  v4 = a1[6];
  v5 = a1[8];
  v6 = a1[7];
  v204 = a2;
  v271 = a1[3];
  v273 = a1[5];
  v276 = a1[9];
  v7 = bswap32(*a2);
  v272 = a1[4];
  v8 = (__ROR4__(v4, 11) ^ __ROR4__(v4, 6) ^ __ROR4__(v4, 25)) + v276 + 1116352408 + ((v6 ^ v5) & v4 ^ v5) + v7;
  v223 = v7;
  v9 = v273 + v8;
  v10 = (__ROR4__(v2, 13) ^ __ROR4__(v2, 2) ^ __ROR4__(v2, 22)) + ((v2 | v271) & v272 | v2 & v271) + v8;
  v208 = bswap32(a2[1]);
  v270 = v2;
  v275 = v5;
  v11 = ((v4 ^ v6) & (v273 + v8) ^ v6)
      + v5
      + 1899447441
      + v208
      + (__ROR4__(v273 + v8, 11) ^ __ROR4__(v273 + v8, 6) ^ __ROR4__(v273 + v8, 25));
  v267 = v4;
  v12 = (__ROR4__(v10, 13) ^ __ROR4__(v10, 2) ^ __ROR4__(v10, 22)) + ((v2 | v10) & v271 | v2 & v10) + v11;
  v13 = v272 + v11;
  v274 = v6;
  v256 = bswap32(a2[2]);
  v14 = ((v267 ^ v9) & (v272 + v11) ^ v267)
      + v6
      - 1245643825
      + v256
      + (__ROR4__(v272 + v11, 11) ^ __ROR4__(v272 + v11, 6) ^ __ROR4__(v272 + v11, 25));
  v15 = (__ROR4__(v12, 13) ^ __ROR4__(v12, 2) ^ __ROR4__(v12, 22)) + ((v10 | v12) & v2 | v10 & v12) + v14;
  v16 = v271 + v14;
  v228 = bswap32(a2[3]);
  v17 = ((v9 ^ v13) & v16 ^ v9)
      + v4
      - 373957723
      + v228
      + (__ROR4__(v271 + v14, 11) ^ __ROR4__(v16, 6) ^ __ROR4__(v16, 25));
  v18 = (__ROR4__(v15, 13) ^ __ROR4__(v15, 2) ^ __ROR4__(v15, 22)) + ((v12 | v15) & v10 | v12 & v15) + v17;
  v260 = bswap32(a2[4]);
  v19 = ((v13 ^ v16) & (v270 + v17) ^ v13)
      + v260
      + 961987163
      + v9
      + (__ROR4__(v270 + v17, 11) ^ __ROR4__(v270 + v17, 6) ^ __ROR4__(v270 + v17, 25));
  v20 = v10 + v19;
  v21 = (__ROR4__(v18, 13) ^ __ROR4__(v18, 2) ^ __ROR4__(v18, 22)) + ((v15 | v18) & v12 | v15 & v18) + v19;
  v236 = bswap32(v204[5]);
  v22 = ((v16 ^ (v2 + v17)) & v20 ^ v16)
      + v236
      + 1508970993
      + v13
      + (__ROR4__(v20, 11) ^ __ROR4__(v20, 6) ^ __ROR4__(v20, 25));
  v23 = v12 + v22;
  v24 = (__ROR4__(v21, 13) ^ __ROR4__(v21, 2) ^ __ROR4__(v21, 22)) + ((v18 | v21) & v15 | v18 & v21) + v22;
  v253 = bswap32(v204[6]);
  v25 = (((v270 + v17) ^ v20) & v23 ^ (v270 + v17))
      + v253
      - 1841331548
      + v16
      + (__ROR4__(v23, 11) ^ __ROR4__(v23, 6) ^ __ROR4__(v23, 25));
  v26 = (__ROR4__(v24, 13) ^ __ROR4__(v24, 2) ^ __ROR4__(v24, 22)) + ((v21 | v24) & v18 | v21 & v24) + v25;
  v27 = v15 + v25;
  v240 = bswap32(v204[7]);
  v28 = ((v20 ^ v23) & v27 ^ v20)
      + v240
      - 1424204075
      + v2
      + v17
      + (__ROR4__(v27, 11) ^ __ROR4__(v27, 6) ^ __ROR4__(v27, 25));
  v29 = v18 + v28;
  v244 = bswap32(v204[8]);
  v211 = bswap32(v204[9]);
  v30 = (__ROR4__(v26, 13) ^ __ROR4__(v26, 2) ^ __ROR4__(v26, 22)) + ((v24 | v26) & v21 | v24 & v26) + v28;
  v214 = bswap32(v204[10]);
  v217 = bswap32(v204[11]);
  v31 = ((v23 ^ v27) & v29 ^ v23) + v244 - 670586216 + v20 + (__ROR4__(v29, 11) ^ __ROR4__(v29, 6) ^ __ROR4__(v29, 25));
  v32 = v21 + v31;
  v247 = bswap32(v204[12]);
  v33 = (__ROR4__(v30, 13) ^ __ROR4__(v30, 2) ^ __ROR4__(v30, 22)) + ((v26 | v30) & v24 | v26 & v30) + v31;
  v34 = ((v27 ^ v29) & v32 ^ v27) + v211 + 310598401 + v23 + (__ROR4__(v32, 11) ^ __ROR4__(v32, 6) ^ __ROR4__(v32, 25));
  v35 = v24 + v34;
  v250 = bswap32(v204[13]);
  v36 = (__ROR4__(v33, 13) ^ __ROR4__(v33, 2) ^ __ROR4__(v33, 22)) + ((v30 | v33) & v26 | v30 & v33) + v34;
  v220 = bswap32(v204[14]);
  v37 = ((v29 ^ v32) & v35 ^ v29) + v214 + 607225278 + v27 + (__ROR4__(v35, 11) ^ __ROR4__(v35, 6) ^ __ROR4__(v35, 25));
  v205 = bswap32(v204[15]);
  v38 = v26 + v37;
  v39 = (__ROR4__(v36, 13) ^ __ROR4__(v36, 2) ^ __ROR4__(v36, 22)) + ((v33 | v36) & v30 | v33 & v36) + v37;
  v264 = v208 + v214;
  v40 = ((v32 ^ v35) & v38 ^ v32) + v217 + 1426881987 + v29 + (__ROR4__(v38, 11) ^ __ROR4__(v38, 6) ^ __ROR4__(v38, 25));
  v41 = (__ROR4__(v39, 13) ^ __ROR4__(v39, 2) ^ __ROR4__(v39, 22)) + ((v36 | v39) & v33 | v36 & v39) + v40;
  v42 = v30 + v40;
  v43 = ((v35 ^ v38) & v42 ^ v35) + v247 + 1925078388 + v32 + (__ROR4__(v42, 11) ^ __ROR4__(v42, 6) ^ __ROR4__(v42, 25));
  v44 = (__ROR4__(v41, 13) ^ __ROR4__(v41, 2) ^ __ROR4__(v41, 22)) + ((v39 | v41) & v36 | v39 & v41) + v43;
  v45 = v33 + v43;
  v46 = ((v38 ^ v42) & v45 ^ v38) + v250 - 2132889090 + v35 + (__ROR4__(v45, 11) ^ __ROR4__(v45, 6) ^ __ROR4__(v45, 25));
  v47 = v36 + v46;
  v48 = (__ROR4__(v44, 13) ^ __ROR4__(v44, 2) ^ __ROR4__(v44, 22)) + ((v41 | v44) & v39 | v41 & v44) + v46;
  v49 = ((v42 ^ v45) & v47 ^ v42) + v220 - 1680079193 + v38 + (__ROR4__(v47, 11) ^ __ROR4__(v47, 6) ^ __ROR4__(v47, 25));
  v50 = (__ROR4__(v48, 13) ^ __ROR4__(v48, 2) ^ __ROR4__(v48, 22)) + ((v44 | v48) & v41 | v44 & v48) + v49;
  v51 = v39 + v49;
  v52 = ((v45 ^ v47) & v51 ^ v45) + v205 - 1046744716 + v42 + (__ROR4__(v51, 11) ^ __ROR4__(v51, 6) ^ __ROR4__(v51, 25));
  v53 = v41 + v52;
  v209 = (__ROR4__(v220, 19) ^ __ROR4__(v220, 17) ^ (v220 >> 10))
       + v223
       + v211
       + (__ROR4__(v208, 18) ^ __ROR4__(v208, 7) ^ (v208 >> 3));
  v232 = (__ROR4__(v50, 13) ^ __ROR4__(v50, 2) ^ __ROR4__(v50, 22)) + ((v48 | v50) & v44 | v48 & v50) + v52;
  v54 = ((v47 ^ v51) & v53 ^ v47) + v209 - 459576895 + v45 + (__ROR4__(v53, 11) ^ __ROR4__(v53, 6) ^ __ROR4__(v53, 25));
  v55 = v44 + v54;
  v56 = (__ROR4__(v232, 13) ^ __ROR4__(v232, 2) ^ __ROR4__(v232, 22)) + ((v50 | v232) & v48 | v50 & v232) + v54;
  v57 = (__ROR4__(v205, 19) ^ __ROR4__(v205, 17) ^ (v205 >> 10))
      + v264
      + (__ROR4__(v256, 18) ^ __ROR4__(v256, 7) ^ (v256 >> 3));
  v58 = ((v51 ^ v53) & (v44 + v54) ^ v51)
      + v57
      - 272742522
      + v47
      + (__ROR4__(v44 + v54, 11) ^ __ROR4__(v44 + v54, 6) ^ __ROR4__(v44 + v54, 25));
  v59 = v48 + v58;
  v60 = (__ROR4__(v56, 13) ^ __ROR4__(v56, 2) ^ __ROR4__(v56, 22)) + ((v232 | v56) & v50 | v232 & v56) + v58;
  v224 = (__ROR4__(v228, 18) ^ __ROR4__(v228, 7) ^ (v228 >> 3))
       + v256
       + v217
       + (__ROR4__(v209, 19) ^ __ROR4__(v209, 17) ^ (v209 >> 10));
  v61 = ((v53 ^ v55) & v59 ^ v53)
      + v224
      + 264347078
      + v51
      + (__ROR4__(v48 + v58, 11) ^ __ROR4__(v59, 6) ^ __ROR4__(v59, 25));
  v62 = v50 + v61;
  v63 = (__ROR4__(v60, 13) ^ __ROR4__(v60, 2) ^ __ROR4__(v60, 22)) + ((v56 | v60) & v232 | v56 & v60) + v61;
  v257 = v57;
  v229 = (__ROR4__(v260, 18) ^ __ROR4__(v260, 7) ^ (v260 >> 3))
       + v228
       + v247
       + (__ROR4__(v57, 19) ^ __ROR4__(v57, 17) ^ (v57 >> 10));
  v64 = ((v55 ^ v59) & v62 ^ v55) + v229 + 604807628 + v53 + (__ROR4__(v62, 11) ^ __ROR4__(v62, 6) ^ __ROR4__(v62, 25));
  v65 = (__ROR4__(v63, 13) ^ __ROR4__(v63, 2) ^ __ROR4__(v63, 22)) + ((v60 | v63) & v56 | v60 & v63) + v64;
  v66 = v232 + v64;
  v233 = (__ROR4__(v236, 18) ^ __ROR4__(v236, 7) ^ (v236 >> 3))
       + v260
       + v250
       + (__ROR4__(v224, 19) ^ __ROR4__(v224, 17) ^ (v224 >> 10));
  v67 = ((v59 ^ v62) & v66 ^ v59) + v233 + 770255983 + v55 + (__ROR4__(v66, 11) ^ __ROR4__(v66, 6) ^ __ROR4__(v66, 25));
  v68 = v56 + v67;
  v69 = (__ROR4__(v65, 13) ^ __ROR4__(v65, 2) ^ __ROR4__(v65, 22)) + ((v63 | v65) & v60 | v63 & v65) + v67;
  v237 = (__ROR4__(v253, 18) ^ __ROR4__(v253, 7) ^ (v253 >> 3))
       + v236
       + v220
       + (__ROR4__(v229, 19) ^ __ROR4__(v229, 17) ^ (v229 >> 10));
  v70 = ((v62 ^ v66) & (v56 + v67) ^ v62)
      + v237
      + 1249150122
      + v59
      + (__ROR4__(v68, 11) ^ __ROR4__(v68, 6) ^ __ROR4__(v68, 25));
  v71 = v60 + v70;
  v72 = (__ROR4__(v69, 13) ^ __ROR4__(v69, 2) ^ __ROR4__(v69, 22)) + ((v65 | v69) & v63 | v65 & v69) + v70;
  v261 = (__ROR4__(v240, 18) ^ __ROR4__(v240, 7) ^ (v240 >> 3))
       + v253
       + v205
       + (__ROR4__(v233, 19) ^ __ROR4__(v233, 17) ^ (v233 >> 10));
  v73 = ((v66 ^ v68) & v71 ^ v66) + v261 + 1555081692 + v62 + (__ROR4__(v71, 11) ^ __ROR4__(v71, 6) ^ __ROR4__(v71, 25));
  v74 = v63 + v73;
  v75 = (__ROR4__(v72, 13) ^ __ROR4__(v72, 2) ^ __ROR4__(v72, 22)) + ((v69 | v72) & v65 | v69 & v72) + v73;
  v241 = (__ROR4__(v244, 18) ^ __ROR4__(v244, 7) ^ (v244 >> 3))
       + v240
       + v209
       + (__ROR4__(v237, 19) ^ __ROR4__(v237, 17) ^ (v237 >> 10));
  v76 = ((v68 ^ v71) & v74 ^ v68) + v241 + 1996064986 + v66 + (__ROR4__(v74, 11) ^ __ROR4__(v74, 6) ^ __ROR4__(v74, 25));
  v77 = v65 + v76;
  v78 = (__ROR4__(v75, 13) ^ __ROR4__(v75, 2) ^ __ROR4__(v75, 22)) + ((v72 | v75) & v69 | v72 & v75) + v76;
  v79 = (__ROR4__(v211, 18) ^ __ROR4__(v211, 7) ^ (v211 >> 3))
      + v244
      + v57
      + (__ROR4__(v261, 19) ^ __ROR4__(v261, 17) ^ (v261 >> 10));
  v80 = ((v71 ^ v74) & v77 ^ v71) + v79 - 1740746414 + v68 + (__ROR4__(v77, 11) ^ __ROR4__(v77, 6) ^ __ROR4__(v77, 25));
  v81 = v69 + v80;
  v82 = (__ROR4__(v78, 13) ^ __ROR4__(v78, 2) ^ __ROR4__(v78, 22)) + ((v75 | v78) & v72 | v75 & v78) + v80;
  v245 = (__ROR4__(v214, 18) ^ __ROR4__(v214, 7) ^ (v214 >> 3))
       + v211
       + v224
       + (__ROR4__(v241, 19) ^ __ROR4__(v241, 17) ^ (v241 >> 10));
  v265 = v79;
  v83 = ((v74 ^ v77) & v81 ^ v74) + v245 - 1473132947 + v71 + (__ROR4__(v81, 11) ^ __ROR4__(v81, 6) ^ __ROR4__(v81, 25));
  v84 = (__ROR4__(v82, 13) ^ __ROR4__(v82, 2) ^ __ROR4__(v82, 22)) + ((v78 | v82) & v75 | v78 & v82) + v83;
  v85 = v72 + v83;
  v215 = (__ROR4__(v217, 18) ^ __ROR4__(v217, 7) ^ (v217 >> 3))
       + v214
       + v229
       + (__ROR4__(v79, 19) ^ __ROR4__(v79, 17) ^ (v79 >> 10));
  v86 = ((v77 ^ v81) & v85 ^ v77) + v215 - 1341970488 + v74 + (__ROR4__(v85, 11) ^ __ROR4__(v85, 6) ^ __ROR4__(v85, 25));
  v87 = v75 + v86;
  v88 = (__ROR4__(v84, 13) ^ __ROR4__(v84, 2) ^ __ROR4__(v84, 22)) + ((v82 | v84) & v78 | v82 & v84) + v86;
  v218 = (__ROR4__(v247, 18) ^ __ROR4__(v247, 7) ^ (v247 >> 3))
       + v217
       + v233
       + (__ROR4__(v245, 19) ^ __ROR4__(v245, 17) ^ (v245 >> 10));
  v89 = ((v81 ^ v85) & v87 ^ v81) + v218 - 1084653625 + v77 + (__ROR4__(v87, 11) ^ __ROR4__(v87, 6) ^ __ROR4__(v87, 25));
  v90 = (__ROR4__(v88, 13) ^ __ROR4__(v88, 2) ^ __ROR4__(v88, 22)) + ((v84 | v88) & v82 | v84 & v88) + v89;
  v91 = v78 + v89;
  v248 = (__ROR4__(v250, 18) ^ __ROR4__(v250, 7) ^ (v250 >> 3))
       + v247
       + v237
       + (__ROR4__(v215, 19) ^ __ROR4__(v215, 17) ^ (v215 >> 10));
  v92 = ((v85 ^ v87) & v91 ^ v85) + v248 - 958395405 + v81 + (__ROR4__(v91, 11) ^ __ROR4__(v91, 6) ^ __ROR4__(v91, 25));
  v93 = v82 + v92;
  v94 = (__ROR4__(v90, 13) ^ __ROR4__(v90, 2) ^ __ROR4__(v90, 22)) + ((v88 | v90) & v84 | v88 & v90) + v92;
  v212 = (__ROR4__(v220, 18) ^ __ROR4__(v220, 7) ^ (v220 >> 3))
       + v250
       + v261
       + (__ROR4__(v218, 19) ^ __ROR4__(v218, 17) ^ (v218 >> 10));
  v95 = ((v87 ^ v91) & v93 ^ v87) + v212 - 710438585 + v85 + (__ROR4__(v93, 11) ^ __ROR4__(v93, 6) ^ __ROR4__(v93, 25));
  v96 = v84 + v95;
  v97 = (__ROR4__(v94, 13) ^ __ROR4__(v94, 2) ^ __ROR4__(v94, 22)) + ((v90 | v94) & v88 | v90 & v94) + v95;
  v221 = (__ROR4__(v205, 18) ^ __ROR4__(v205, 7) ^ (v205 >> 3))
       + v220
       + v241
       + (__ROR4__(v248, 19) ^ __ROR4__(v248, 17) ^ (v248 >> 10));
  v98 = ((v91 ^ v93) & v96 ^ v91) + v221 + 113926993 + v87 + (__ROR4__(v96, 11) ^ __ROR4__(v96, 6) ^ __ROR4__(v96, 25));
  v99 = v88 + v98;
  v100 = (__ROR4__(v97, 13) ^ __ROR4__(v97, 2) ^ __ROR4__(v97, 22)) + ((v94 | v97) & v90 | v94 & v97) + v98;
  v251 = (__ROR4__(v209, 18) ^ __ROR4__(v209, 7) ^ (v209 >> 3))
       + v205
       + v79
       + (__ROR4__(v212, 19) ^ __ROR4__(v212, 17) ^ (v212 >> 10));
  v101 = ((v93 ^ v96) & v99 ^ v93) + v251 + 338241895 + v91 + (__ROR4__(v99, 11) ^ __ROR4__(v99, 6) ^ __ROR4__(v99, 25));
  v102 = v90 + v101;
  v103 = __ROR4__(v90 + v101, 11);
  v104 = (__ROR4__(v100, 13) ^ __ROR4__(v100, 2) ^ __ROR4__(v100, 22)) + ((v97 | v100) & v94 | v97 & v100) + v101;
  v254 = (__ROR4__(v257, 18) ^ __ROR4__(v257, 7) ^ (v257 >> 3))
       + v209
       + v245
       + (__ROR4__(v221, 19) ^ __ROR4__(v221, 17) ^ (v221 >> 10));
  v105 = ((v96 ^ v99) & v102 ^ v96) + v254 + 666307205 + v93 + (v103 ^ __ROR4__(v102, 6) ^ __ROR4__(v102, 25));
  v106 = v94 + v105;
  v107 = (__ROR4__(v104, 13) ^ __ROR4__(v104, 2) ^ __ROR4__(v104, 22)) + ((v100 | v104) & v97 | v100 & v104) + v105;
  v258 = (__ROR4__(v224, 18) ^ __ROR4__(v224, 7) ^ (v224 >> 3))
       + v257
       + v215
       + (__ROR4__(v251, 19) ^ __ROR4__(v251, 17) ^ (v251 >> 10));
  v108 = ((v99 ^ v102) & v106 ^ v99)
       + v258
       + 773529912
       + v96
       + (__ROR4__(v106, 11) ^ __ROR4__(v106, 6) ^ __ROR4__(v106, 25));
  v109 = v97 + v108;
  v110 = (__ROR4__(v107, 13) ^ __ROR4__(v107, 2) ^ __ROR4__(v107, 22)) + ((v104 | v107) & v100 | v104 & v107) + v108;
  v225 = (__ROR4__(v229, 18) ^ __ROR4__(v229, 7) ^ (v229 >> 3))
       + v224
       + v218
       + (__ROR4__(v254, 19) ^ __ROR4__(v254, 17) ^ (v254 >> 10));
  v111 = ((v102 ^ v106) & v109 ^ v102)
       + v225
       + 1294757372
       + v99
       + (__ROR4__(v109, 11) ^ __ROR4__(v109, 6) ^ __ROR4__(v109, 25));
  v112 = v100 + v111;
  v113 = (__ROR4__(v110, 13) ^ __ROR4__(v110, 2) ^ __ROR4__(v110, 22)) + ((v107 | v110) & v104 | v107 & v110) + v111;
  v230 = (__ROR4__(v233, 18) ^ __ROR4__(v233, 7) ^ (v233 >> 3))
       + v229
       + v248
       + (__ROR4__(v258, 19) ^ __ROR4__(v258, 17) ^ (v258 >> 10));
  v114 = ((v106 ^ v109) & v112 ^ v106)
       + v230
       + 1396182291
       + v102
       + (__ROR4__(v112, 11) ^ __ROR4__(v112, 6) ^ __ROR4__(v112, 25));
  v115 = v104 + v114;
  v116 = (__ROR4__(v113, 13) ^ __ROR4__(v113, 2) ^ __ROR4__(v113, 22)) + ((v110 | v113) & v107 | v110 & v113) + v114;
  v234 = (__ROR4__(v237, 18) ^ __ROR4__(v237, 7) ^ (v237 >> 3))
       + v233
       + v212
       + (__ROR4__(v225, 19) ^ __ROR4__(v225, 17) ^ (v225 >> 10));
  v117 = ((v109 ^ v112) & v115 ^ v109)
       + v234
       + 1695183700
       + v106
       + (__ROR4__(v104 + v114, 11) ^ __ROR4__(v104 + v114, 6) ^ __ROR4__(v115, 25));
  v118 = v107 + v117;
  v119 = (__ROR4__(v116, 13) ^ __ROR4__(v116, 2) ^ __ROR4__(v116, 22)) + ((v113 | v116) & v110 | v113 & v116) + v117;
  v238 = (__ROR4__(v261, 18) ^ __ROR4__(v261, 7) ^ (v261 >> 3))
       + v237
       + v221
       + (__ROR4__(v230, 19) ^ __ROR4__(v230, 17) ^ (v230 >> 10));
  v120 = ((v112 ^ (v104 + v114)) & (v107 + v117) ^ v112)
       + v238
       + 1986661051
       + v109
       + (__ROR4__(v107 + v117, 11) ^ __ROR4__(v107 + v117, 6) ^ __ROR4__(v107 + v117, 25));
  v121 = v110 + v120;
  v122 = (__ROR4__(v119, 13) ^ __ROR4__(v119, 2) ^ __ROR4__(v119, 22)) + ((v116 | v119) & v113 | v116 & v119) + v120;
  v262 = (__ROR4__(v241, 18) ^ __ROR4__(v241, 7) ^ (v241 >> 3))
       + v261
       + v251
       + (__ROR4__(v234, 19) ^ __ROR4__(v234, 17) ^ (v234 >> 10));
  v123 = ((v115 ^ (v107 + v117)) & v121 ^ v115)
       + v262
       - 2117940946
       + v112
       + (__ROR4__(v110 + v120, 11) ^ __ROR4__(v121, 6) ^ __ROR4__(v121, 25));
  v124 = v113 + v123;
  v125 = (__ROR4__(v122, 13) ^ __ROR4__(v122, 2) ^ __ROR4__(v122, 22)) + ((v119 | v122) & v116 | v119 & v122) + v123;
  v242 = (__ROR4__(v265, 18) ^ __ROR4__(v265, 7) ^ (v265 >> 3))
       + v241
       + v254
       + (__ROR4__(v238, 19) ^ __ROR4__(v238, 17) ^ (v238 >> 10));
  v126 = ((v118 ^ (v110 + v120)) & v124 ^ v118)
       + v242
       - 1838011259
       + v115
       + (__ROR4__(v113 + v123, 11) ^ __ROR4__(v113 + v123, 6) ^ __ROR4__(v124, 25));
  v127 = (__ROR4__(v125, 13) ^ __ROR4__(v125, 2) ^ __ROR4__(v125, 22)) + ((v122 | v125) & v119 | v122 & v125) + v126;
  v128 = v116 + v126;
  v266 = (__ROR4__(v245, 18) ^ __ROR4__(v245, 7) ^ (v245 >> 3))
       + v265
       + v258
       + (__ROR4__(v262, 19) ^ __ROR4__(v262, 17) ^ (v262 >> 10));
  v129 = ((v121 ^ v124) & (v116 + v126) ^ v121)
       + v266
       - 1564481375
       + v118
       + (__ROR4__(v116 + v126, 11) ^ __ROR4__(v116 + v126, 6) ^ __ROR4__(v116 + v126, 25));
  v130 = v119 + v129;
  v131 = (__ROR4__(v127, 13) ^ __ROR4__(v127, 2) ^ __ROR4__(v127, 22)) + ((v125 | v127) & v122 | v125 & v127) + v129;
  v206 = (__ROR4__(v215, 18) ^ __ROR4__(v215, 7) ^ (v215 >> 3))
       + v245
       + v225
       + (__ROR4__(v242, 19) ^ __ROR4__(v242, 17) ^ (v242 >> 10));
  v132 = ((v124 ^ v128) & v130 ^ v124)
       + v206
       - 1474664885
       + v121
       + (__ROR4__(v130, 11) ^ __ROR4__(v130, 6) ^ __ROR4__(v130, 25));
  v133 = v122 + v132;
  v134 = (__ROR4__(v131, 13) ^ __ROR4__(v131, 2) ^ __ROR4__(v131, 22)) + ((v127 | v131) & v125 | v127 & v131) + v132;
  v246 = (__ROR4__(v218, 18) ^ __ROR4__(v218, 7) ^ (v218 >> 3))
       + v215
       + v230
       + (__ROR4__(v266, 19) ^ __ROR4__(v266, 17) ^ (v266 >> 10));
  v135 = ((v128 ^ v130) & v133 ^ v128)
       + v246
       - 1035236496
       + v124
       + (__ROR4__(v133, 11) ^ __ROR4__(v133, 6) ^ __ROR4__(v133, 25));
  v136 = (__ROR4__(v134, 13) ^ __ROR4__(v134, 2) ^ __ROR4__(v134, 22)) + ((v131 | v134) & v127 | v131 & v134) + v135;
  v219 = (__ROR4__(v248, 18) ^ __ROR4__(v248, 7) ^ (v248 >> 3))
       + v218
       + v234
       + (__ROR4__(v206, 19) ^ __ROR4__(v206, 17) ^ (v206 >> 10));
  v137 = ((v130 ^ v133) & (v125 + v135) ^ v130)
       + v219
       - 949202525
       + v128
       + (__ROR4__(v125 + v135, 11) ^ __ROR4__(v125 + v135, 6) ^ __ROR4__(v125 + v135, 25));
  v138 = (__ROR4__(v136, 13) ^ __ROR4__(v136, 2) ^ __ROR4__(v136, 22)) + ((v134 | v136) & v131 | v134 & v136) + v137;
  v139 = v127 + v137;
  v210 = (__ROR4__(v212, 18) ^ __ROR4__(v212, 7) ^ (v212 >> 3))
       + v248
       + v238
       + (__ROR4__(v246, 19) ^ __ROR4__(v246, 17) ^ (v246 >> 10));
  v140 = ((v133 ^ (v125 + v135)) & v139 ^ v133)
       + v210
       - 778901479
       + v130
       + (__ROR4__(v127 + v137, 11) ^ __ROR4__(v127 + v137, 6) ^ __ROR4__(v139, 25));
  v141 = v131 + v140;
  v142 = (__ROR4__(v138, 13) ^ __ROR4__(v138, 2) ^ __ROR4__(v138, 22)) + ((v136 | v138) & v134 | v136 & v138) + v140;
  v213 = (__ROR4__(v221, 18) ^ __ROR4__(v221, 7) ^ (v221 >> 3))
       + v212
       + v262
       + (__ROR4__(v219, 19) ^ __ROR4__(v219, 17) ^ (v219 >> 10));
  v143 = (((v125 + v135) ^ v139) & v141 ^ (v125 + v135))
       + v213
       - 694614492
       + v133
       + (__ROR4__(v141, 11) ^ __ROR4__(v141, 6) ^ __ROR4__(v141, 25));
  v144 = v134 + v143;
  v145 = (__ROR4__(v142, 13) ^ __ROR4__(v142, 2) ^ __ROR4__(v142, 22)) + ((v138 | v142) & v136 | v138 & v142) + v143;
  v222 = (__ROR4__(v251, 18) ^ __ROR4__(v251, 7) ^ (v251 >> 3))
       + v221
       + v242
       + (__ROR4__(v210, 19) ^ __ROR4__(v210, 17) ^ (v210 >> 10));
  v146 = ((v139 ^ v141) & v144 ^ v139)
       + v222
       - 200395387
       + v125
       + v135
       + (__ROR4__(v144, 11) ^ __ROR4__(v144, 6) ^ __ROR4__(v144, 25));
  v147 = v136 + v146;
  v148 = (__ROR4__(v145, 13) ^ __ROR4__(v145, 2) ^ __ROR4__(v145, 22)) + ((v142 | v145) & v138 | v142 & v145) + v146;
  v216 = (__ROR4__(v254, 18) ^ __ROR4__(v254, 7) ^ (v254 >> 3))
       + v251
       + v266
       + (__ROR4__(v213, 19) ^ __ROR4__(v213, 17) ^ (v213 >> 10));
  v149 = ((v141 ^ v144) & v147 ^ v141)
       + v216
       + 275423344
       + v139
       + (__ROR4__(v147, 11) ^ __ROR4__(v147, 6) ^ __ROR4__(v147, 25));
  v150 = v138 + v149;
  v151 = (__ROR4__(v148, 13) ^ __ROR4__(v148, 2) ^ __ROR4__(v148, 22)) + ((v145 | v148) & v142 | v145 & v148) + v149;
  v249 = (__ROR4__(v258, 18) ^ __ROR4__(v258, 7) ^ (v258 >> 3))
       + v254
       + v206
       + (__ROR4__(v222, 19) ^ __ROR4__(v222, 17) ^ (v222 >> 10));
  v152 = ((v144 ^ v147) & v150 ^ v144)
       + v249
       + 430227734
       + v141
       + (__ROR4__(v150, 11) ^ __ROR4__(v150, 6) ^ __ROR4__(v150, 25));
  v153 = v142 + v152;
  v154 = (__ROR4__(v151, 13) ^ __ROR4__(v151, 2) ^ __ROR4__(v151, 22)) + ((v148 | v151) & v145 | v148 & v151) + v152;
  v252 = (__ROR4__(v225, 18) ^ __ROR4__(v225, 7) ^ (v225 >> 3))
       + v258
       + v246
       + (__ROR4__(v216, 19) ^ __ROR4__(v216, 17) ^ (v216 >> 10));
  v155 = ((v147 ^ v150) & v153 ^ v147)
       + v252
       + 506948616
       + v144
       + (__ROR4__(v153, 11) ^ __ROR4__(v153, 6) ^ __ROR4__(v153, 25));
  v156 = (__ROR4__(v154, 13) ^ __ROR4__(v154, 2) ^ __ROR4__(v154, 22)) + ((v151 | v154) & v148 | v151 & v154) + v155;
  v157 = v145 + v155;
  v255 = (__ROR4__(v230, 18) ^ __ROR4__(v230, 7) ^ (v230 >> 3))
       + v225
       + v219
       + (__ROR4__(v249, 19) ^ __ROR4__(v249, 17) ^ (v249 >> 10));
  v158 = ((v150 ^ v153) & v157 ^ v150)
       + v255
       + 659060556
       + v147
       + (__ROR4__(v157, 11) ^ __ROR4__(v157, 6) ^ __ROR4__(v157, 25));
  v159 = v148 + v158;
  v160 = (__ROR4__(v156, 13) ^ __ROR4__(v156, 2) ^ __ROR4__(v156, 22)) + ((v154 | v156) & v151 | v154 & v156) + v158;
  v259 = (__ROR4__(v234, 18) ^ __ROR4__(v234, 7) ^ (v234 >> 3))
       + v230
       + v210
       + (__ROR4__(v252, 19) ^ __ROR4__(v252, 17) ^ (v252 >> 10));
  v161 = ((v153 ^ v157) & v159 ^ v153)
       + v259
       + 883997877
       + v150
       + (__ROR4__(v159, 11) ^ __ROR4__(v159, 6) ^ __ROR4__(v159, 25));
  v162 = v151 + v161;
  v163 = (__ROR4__(v160, 13) ^ __ROR4__(v160, 2) ^ __ROR4__(v160, 22)) + ((v156 | v160) & v154 | v156 & v160) + v161;
  v268 = (__ROR4__(v238, 18) ^ __ROR4__(v238, 7) ^ (v238 >> 3))
       + v234
       + v213
       + (__ROR4__(v255, 19) ^ __ROR4__(v255, 17) ^ (v255 >> 10));
  v164 = ((v157 ^ v159) & v162 ^ v157)
       + v268
       + 958139571
       + v153
       + (__ROR4__(v162, 11) ^ __ROR4__(v162, 6) ^ __ROR4__(v162, 25));
  v165 = v154 + v164;
  v166 = (__ROR4__(v163, 13) ^ __ROR4__(v163, 2) ^ __ROR4__(v163, 22)) + ((v160 | v163) & v156 | v160 & v163) + v164;
  v269 = (__ROR4__(v262, 18) ^ __ROR4__(v262, 7) ^ (v262 >> 3))
       + v238
       + v222
       + (__ROR4__(v259, 19) ^ __ROR4__(v259, 17) ^ (v259 >> 10));
  v167 = ((v159 ^ v162) & v165 ^ v159)
       + v269
       + 1322822218
       + v157
       + (__ROR4__(v165, 11) ^ __ROR4__(v165, 6) ^ __ROR4__(v165, 25));
  v168 = v156 + v167;
  v169 = (__ROR4__(v166, 13) ^ __ROR4__(v166, 2) ^ __ROR4__(v166, 22)) + ((v163 | v166) & v160 | v163 & v166) + v167;
  v263 = (__ROR4__(v242, 18) ^ __ROR4__(v242, 7) ^ (v242 >> 3))
       + v262
       + v216
       + (__ROR4__(v268, 19) ^ __ROR4__(v268, 17) ^ (v268 >> 10));
  v170 = ((v162 ^ v165) & v168 ^ v162)
       + v263
       + 1537002063
       + v159
       + (__ROR4__(v168, 11) ^ __ROR4__(v168, 6) ^ __ROR4__(v168, 25));
  v171 = v160 + v170;
  v172 = (__ROR4__(v169, 13) ^ __ROR4__(v169, 2) ^ __ROR4__(v169, 22)) + ((v166 | v169) & v163 | v166 & v169) + v170;
  v231 = (__ROR4__(v266, 18) ^ __ROR4__(v266, 7) ^ (v266 >> 3))
       + v242
       + v249
       + (__ROR4__(v269, 19) ^ __ROR4__(v269, 17) ^ (v269 >> 10));
  v173 = ((v165 ^ v168) & v171 ^ v165)
       + v231
       + 1747873779
       + v162
       + (__ROR4__(v171, 11) ^ __ROR4__(v171, 6) ^ __ROR4__(v171, 25));
  v174 = v163 + v173;
  v226 = (__ROR4__(v172, 13) ^ __ROR4__(v172, 2) ^ __ROR4__(v172, 22)) + ((v169 | v172) & v166 | v169 & v172) + v173;
  v235 = (__ROR4__(v206, 18) ^ __ROR4__(v206, 7) ^ (v206 >> 3))
       + v266
       + v252
       + (__ROR4__(v263, 19) ^ __ROR4__(v263, 17) ^ (v263 >> 10));
  v175 = ((v168 ^ v171) & v174 ^ v168)
       + v235
       + 1955562222
       + v165
       + (__ROR4__(v174, 11) ^ __ROR4__(v174, 6) ^ __ROR4__(v174, 25));
  v176 = (__ROR4__(v246, 18) ^ __ROR4__(v246, 7) ^ (v246 >> 3)) + v206;
  v207 = (__ROR4__(v226, 13) ^ __ROR4__(v226, 2) ^ __ROR4__(v226, 22)) + ((v172 | v226) & v169 | v172 & v226) + v175;
  v177 = v176 + v255 + (__ROR4__(v231, 19) ^ __ROR4__(v231, 17) ^ (v231 >> 10));
  v239 = v166 + v175;
  v178 = ((v171 ^ v174) & v239 ^ v171)
       + v177
       + 2024104815
       + v168
       + (__ROR4__(v239, 11) ^ __ROR4__(v239, 6) ^ __ROR4__(v239, 25));
  v179 = v169 + v178;
  v180 = (__ROR4__(v207, 13) ^ __ROR4__(v207, 2) ^ __ROR4__(v207, 22)) + ((v226 | v207) & v172 | v226 & v207) + v178;
  v181 = (__ROR4__(v219, 18) ^ __ROR4__(v219, 7) ^ (v219 >> 3))
       + v246
       + v259
       + (__ROR4__(v235, 19) ^ __ROR4__(v235, 17) ^ (v235 >> 10));
  v182 = ((v174 ^ v239) & (v169 + v178) ^ v174)
       + v181
       - 2067236844
       + v171
       + (__ROR4__(v169 + v178, 11) ^ __ROR4__(v169 + v178, 6) ^ __ROR4__(v169 + v178, 25));
  v183 = v172 + v182;
  v184 = (__ROR4__(v180, 13) ^ __ROR4__(v180, 2) ^ __ROR4__(v180, 22)) + ((v207 | v180) & v226 | v207 & v180) + v182;
  v185 = (__ROR4__(v210, 18) ^ __ROR4__(v210, 7) ^ (v210 >> 3))
       + v219
       + v268
       + (__ROR4__(v177, 19) ^ __ROR4__(v177, 17) ^ (v177 >> 10));
  v186 = ((v239 ^ (v169 + v178)) & v183 ^ v239)
       + v185
       - 1933114872
       + v174
       + (__ROR4__(v183, 11) ^ __ROR4__(v183, 6) ^ __ROR4__(v183, 25));
  v243 = __ROR4__(v185, 19) ^ __ROR4__(v185, 17) ^ (v185 >> 10);
  v187 = v226;
  v188 = (__ROR4__(v184, 13) ^ __ROR4__(v184, 2) ^ __ROR4__(v184, 22)) + ((v180 | v184) & v207 | v180 & v184) + v186;
  v227 = v179;
  v189 = v187 + v186;
  v190 = (__ROR4__(v213, 18) ^ __ROR4__(v213, 7) ^ (v213 >> 3))
       + v210
       + v269
       + (__ROR4__(v181, 19) ^ __ROR4__(v181, 17) ^ (v181 >> 10));
  v191 = ((v179 ^ v183) & v189 ^ v179)
       + v190
       - 1866530822
       + v239
       + (__ROR4__(v189, 11) ^ __ROR4__(v189, 6) ^ __ROR4__(v189, 25));
  v192 = (__ROR4__(v188, 13) ^ __ROR4__(v188, 2) ^ __ROR4__(v188, 22)) + ((v184 | v188) & v180 | v184 & v188) + v191;
  v193 = v207 + v191;
  v194 = (__ROR4__(v222, 18) ^ __ROR4__(v222, 7) ^ (v222 >> 3)) + v213 + v263 + v243;
  v195 = ((v183 ^ v189) & v193 ^ v183)
       + v194
       - 1538233109
       + v227
       + (__ROR4__(v193, 11) ^ __ROR4__(v193, 6) ^ __ROR4__(v193, 25));
  v196 = v180 + v195;
  v197 = (__ROR4__(v192, 13) ^ __ROR4__(v192, 2) ^ __ROR4__(v192, 22)) + ((v188 | v192) & v184 | v188 & v192) + v195;
  v198 = (__ROR4__(v216, 18) ^ __ROR4__(v216, 7) ^ (v216 >> 3))
       + v222
       - 1090935817
       + v231
       + (__ROR4__(v190, 19) ^ __ROR4__(v190, 17) ^ (v190 >> 10))
       + v183
       + ((v189 ^ (v207 + v191)) & v196 ^ v189)
       + (__ROR4__(v196, 11) ^ __ROR4__(v196, 6) ^ __ROR4__(v196, 25));
  v199 = (__ROR4__(v197, 13) ^ __ROR4__(v197, 2) ^ __ROR4__(v197, 22)) + ((v192 | v197) & v188 | v192 & v197) + v198;
  v200 = v184 + v198;
  v201 = (__ROR4__(v249, 18) ^ __ROR4__(v249, 7) ^ (v249 >> 3))
       + v216
       - 965641998
       + v235
       + (__ROR4__(v194, 19) ^ __ROR4__(v194, 17) ^ (v194 >> 10))
       + v189
       + ((v193 ^ v196) & v200 ^ v193)
       + (__ROR4__(v200, 11) ^ __ROR4__(v200, 6) ^ __ROR4__(v200, 25));
  v202 = (__ROR4__(v199, 13) ^ __ROR4__(v199, 2) ^ __ROR4__(v199, 22))
       + ((v197 | v199) & v192 | v197 & v199)
       + v270
       + v201;
  result = v272 + v197;
  a1[9] = v276 + v193;
  a1[5] = v273 + v192;
  a1[8] = v275 + v196;
  a1[4] = result;
  a1[3] = v271 + v199;
  a1[7] = v274 + v200;
  a1[2] = v202;
  a1[6] = v267 + v188 + v201;
  return result;
}

//----- (0001E4B4) --------------------------------------------------------
int *__fastcall sub_1E4B4(int *result, unsigned int *a2, signed int a3)
{
  signed int v3; // r5
  int v4; // r3
  int *v5; // r6
  unsigned int *v6; // r4
  bool v7; // cf
  int v8; // r2
  int v9; // r8
  signed int v10; // r7
  _BOOL4 v11; // r3
  unsigned int v12; // r5
  unsigned int *v13; // r7
  unsigned int *v14; // r1
  unsigned int *v15; // r9

  v3 = a3;
  v4 = *result;
  v5 = result;
  v6 = a2;
  v7 = __CFADD__(*result, a3);
  v8 = *result + a3;
  v9 = *result & 0x3F;
  if ( v7 )
    v4 = result[1];
  v10 = 64 - v9;
  *result = v8;
  if ( v7 )
    result[1] = v4 + 1;
  v11 = v10 <= v3;
  if ( !v9 )
    v11 = 0;
  if ( v11 )
  {
    v15 = (unsigned int *)(result + 10);
    v3 -= v10;
    memcpy((char *)result + v9 + 40, a2, 64 - v9);
    v6 = (unsigned int *)((char *)v6 + v10);
    v9 = 0;
    result = (int *)sub_1C054(v5, v15);
  }
  if ( v3 > 63 )
  {
    v12 = v3 - 64;
    v13 = &v6[16 * (v12 >> 6) + 16];
    do
    {
      v14 = v6;
      v6 += 16;
      result = (int *)sub_1C054(v5, v14);
    }
    while ( v6 != v13 );
    v3 = v12 - (v12 >> 6 << 6);
  }
  if ( v3 > 0 )
    return (int *)memcpy((char *)v5 + v9 + 40, v6, v3);
  return result;
}

//----- (0001E580) --------------------------------------------------------
int *__fastcall sub_1E580(int *result, unsigned int *a2, signed int a3)
{
  if ( a3 > 0 )
    return sub_1E4B4(result, a2, a3);
  return result;
}

//----- (0001E58C) --------------------------------------------------------
int *__fastcall sub_1E58C(int a1, _BYTE *a2)
{
  unsigned int v4; // r2
  int v5; // r1
  unsigned int v6; // r3
  unsigned int v7; // r0
  unsigned int v8; // r3
  signed int v9; // r2
  int *result; // r0
  unsigned int v11; // [sp+0h] [bp-Ch] BYREF
  char v12; // [sp+4h] [bp-8h]
  char v13; // [sp+5h] [bp-7h]
  char v14; // [sp+6h] [bp-6h]
  char v15; // [sp+7h] [bp-5h]

  v4 = *(_DWORD *)a1 & 0x3F;
  v5 = *(_QWORD *)a1 >> 29;
  v6 = 8 * *(_DWORD *)a1;
  v15 = 8 * *(_BYTE *)a1;
  v12 = HIBYTE(v6);
  HIBYTE(v11) = v5;
  BYTE1(v11) = BYTE2(v5);
  v7 = HIWORD(v6);
  v8 = v6 >> 8;
  BYTE2(v11) = BYTE1(v5);
  v13 = v7;
  if ( v4 > 0x37 )
    v9 = 120 - v4;
  else
    v9 = 56 - v4;
  v14 = v8;
  LOBYTE(v11) = HIBYTE(v5);
  sub_1E4B4((int *)a1, dword_7901C, v9);
  result = sub_1E4B4((int *)a1, &v11, 8);
  *a2 = *(_BYTE *)(a1 + 11);
  a2[1] = *(_WORD *)(a1 + 10);
  a2[2] = BYTE1(*(_DWORD *)(a1 + 8));
  a2[3] = *(_DWORD *)(a1 + 8);
  a2[4] = *(_BYTE *)(a1 + 15);
  a2[5] = *(_WORD *)(a1 + 14);
  a2[6] = BYTE1(*(_DWORD *)(a1 + 12));
  a2[7] = *(_DWORD *)(a1 + 12);
  a2[8] = *(_BYTE *)(a1 + 19);
  a2[9] = *(_WORD *)(a1 + 18);
  a2[10] = BYTE1(*(_DWORD *)(a1 + 16));
  a2[11] = *(_DWORD *)(a1 + 16);
  a2[12] = *(_BYTE *)(a1 + 23);
  a2[13] = *(_WORD *)(a1 + 22);
  a2[14] = BYTE1(*(_DWORD *)(a1 + 20));
  a2[15] = *(_DWORD *)(a1 + 20);
  a2[16] = *(_BYTE *)(a1 + 27);
  a2[17] = *(_WORD *)(a1 + 26);
  a2[18] = BYTE1(*(_DWORD *)(a1 + 24));
  a2[19] = *(_DWORD *)(a1 + 24);
  a2[20] = *(_BYTE *)(a1 + 31);
  a2[21] = *(_WORD *)(a1 + 30);
  a2[22] = BYTE1(*(_DWORD *)(a1 + 28));
  a2[23] = *(_DWORD *)(a1 + 28);
  a2[24] = *(_BYTE *)(a1 + 35);
  a2[25] = *(_WORD *)(a1 + 34);
  a2[26] = BYTE1(*(_DWORD *)(a1 + 32));
  a2[27] = *(_DWORD *)(a1 + 32);
  a2[28] = *(_BYTE *)(a1 + 39);
  a2[29] = *(_WORD *)(a1 + 38);
  a2[30] = BYTE1(*(_DWORD *)(a1 + 36));
  a2[31] = *(_DWORD *)(a1 + 36);
  return result;
}
// 7901C: using guessed type unsigned int dword_7901C[16];

//----- (0001E740) --------------------------------------------------------
int *__fastcall sub_1E740(unsigned int *a1, signed int a2, _BYTE *a3)
{
  int v5[59]; // [sp+0h] [bp-ECh] BYREF

  v5[2] = 1779033703;
  v5[4] = 1013904242;
  v5[5] = -1521486534;
  v5[6] = 1359893119;
  v5[7] = -1694144372;
  v5[3] = -1150833019;
  v5[8] = 528734635;
  v5[9] = 1541459225;
  v5[0] = 0;
  v5[1] = 0;
  if ( a2 > 0 )
    sub_1E4B4(v5, a1, a2);
  return sub_1E58C((int)v5, a3);
}

//----- (0001E7E8) --------------------------------------------------------
int __fastcall sub_1E7E8(char *a1, size_t a2, int a3)
{
  int v6; // r0
  int *v8; // r0

  v6 = sub_36C34();
  if ( v6 )
  {
    if ( v6 == 1 )
    {
      v8 = sub_31ABC();
      snprintf(a1, a2, "%s:%s", "searchfailed", (const char *)v8);
    }
    else
    {
      snprintf(a1, a2, "searching");
    }
    return 0;
  }
  else
  {
    snprintf(a1, a2, "%d", a3);
    return 0;
  }
}

//----- (0001E884) --------------------------------------------------------
int __fastcall sub_1E884(char *a1)
{
  int v2; // r8
  int v3; // r5
  int v4; // r4
  char *v5; // r0
  int v6; // r3
  int v7; // r5
  int v8; // r5
  int v9; // r5
  char *v10; // r0
  int v12; // [sp+4h] [bp-8h]

  v2 = 0;
  v3 = 0;
  v12 = sub_1A1B0();
  v4 = 0;
  v5 = a1;
  do
  {
    while ( 1 )
    {
      v6 = dword_A0D68 + 4 * v4++;
      if ( *(_DWORD *)(v6 + 4) )
        break;
      if ( v4 == 16 )
        goto LABEL_5;
    }
    ++v2;
    v7 = sprintf(v5, "chain%d_voltage=%d;", v4, v12) + v3;
    v8 = v7 + sprintf(&a1[v7], "chain%d_voladded=%d;", v4, 0);
    v9 = v8 + sprintf(&a1[v8], "chain%d_basefreq=%d;", v4, 300);
    v3 = v9 + sprintf(&a1[v9], "chain%d_badcore=%d;", v4, 0);
    v5 = &a1[v3];
  }
  while ( v4 != 16 );
LABEL_5:
  v10 = &a1[v3 + sprintf(v5, "chainnum=%d;", v2)];
  return sprintf(v10, "version=%s;", byte_1B07E4);
}
// A0D68: using guessed type int dword_A0D68;

//----- (0001E990) --------------------------------------------------------
int __fastcall sub_1E990(int a1, char *a2, size_t a3)
{
  const char *v4; // r5
  int v6; // r0
  int result; // r0
  int v8; // [sp+0h] [bp-80Ch] BYREF
  int v9; // [sp+4h] [bp-808h] BYREF
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v4 = (const char *)(a1 + 4);
  v8 = -1;
  v9 = -1;
  if ( strstr((const char *)(a1 + 4), "/rate") )
  {
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      strcpy(s, "cmd : get rate");
      sub_47AB4(7, s, 0);
    }
    v6 = sub_3047C();
LABEL_7:
    sub_1E7E8(a2, a3, v6);
    return 0;
  }
  if ( strstr(v4, "/test") )
  {
    _isoc99_sscanf(v4, "/test.%d.%d", &v8, &v9);
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf(s, 0x800u, "cmd : get test = %d", v8);
      sub_47AB4(7, s, 0);
    }
    if ( v8 == 523 )
      sub_1E884(a2);
    else
      sprintf(a2, "OK get test=%d", v8);
    return 0;
  }
  else
  {
    if ( strstr(v4, "/ideal_rate") )
    {
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        strcpy(s, "cmd : get ideal rate");
        sub_47AB4(7, s, 0);
      }
      v6 = sub_30348();
      goto LABEL_7;
    }
    if ( strstr(v4, "/max_rate") )
    {
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        strcpy(s, "cmd : get max rate");
        sub_47AB4(7, s, 0);
      }
      v6 = sub_301EC();
      goto LABEL_7;
    }
    if ( strstr(v4, "/miner_status") )
    {
      result = (unsigned __int8)byte_1AECC5;
      if ( byte_1AECC5 )
      {
        if ( byte_244080 || (result = (unsigned __int8)byte_1AECC4, byte_1AECC4) || dword_9E320 > 6 )
        {
          strcpy(s, "cmd : get miner status");
          sub_47AB4(7, s, 0);
          return 0;
        }
      }
    }
    else if ( strstr(v4, "/productName") )
    {
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        strcpy(s, "cmd : get miner type");
        sub_47AB4(7, s, 0);
      }
      snprintf(a2, 0x100u, "%s", byte_1B08E4);
      return 0;
    }
    else
    {
      return -1;
    }
  }
  return result;
}
// 122EC: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (0001EE10) --------------------------------------------------------
void sub_1EE10()
{
  off_A0634 = sub_1E990;
}
// A0634: using guessed type _UNKNOWN *off_A0634;

//----- (0001EE28) --------------------------------------------------------
int __fastcall sub_1EE28(int a1)
{
  char *v2; // r7
  int v3; // r6
  ssize_t v4; // r3
  char v5; // r3
  char *v6; // r12
  char *v7; // r1
  const char *v9; // lr
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // lr
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r7
  int v19; // r9
  int v20; // r9
  int v21; // r9
  int v22; // r9
  int v23; // r9
  int v24; // r0
  size_t v25; // r0
  unsigned int v26; // r9
  ssize_t v27; // r0
  ssize_t v28; // r11
  signed int v29; // [sp+8h] [bp-17F8h]
  char v30[4]; // [sp+10h] [bp-17F0h] BYREF
  socklen_t addr_len; // [sp+14h] [bp-17ECh] BYREF
  char needle[8]; // [sp+18h] [bp-17E8h] BYREF
  _DWORD optval[2]; // [sp+20h] [bp-17E0h] BYREF
  struct sockaddr addr; // [sp+28h] [bp-17D8h] BYREF
  char s[2040]; // [sp+38h] [bp-17C8h] BYREF
  char v36[4096]; // [sp+838h] [bp-FC8h] BYREF
  char v37[10240]; // [sp+1838h] [bp+38h] BYREF
  _DWORD v38[11]; // [sp+4038h] [bp+2838h] BYREF
  int v39; // [sp+4064h] [bp+2864h] BYREF

  optval[0] = 3;
  optval[1] = 0;
  v2 = v37;
  memset(v36, 0, sizeof(v36));
  addr_len = 0;
  strcpy(v30, "\r\n");
  v3 = 0;
  strcpy(needle, "\r\n\r\n");
  memset(v37, 0, sizeof(v37));
  do
  {
    if ( byte_A0630 )
      goto LABEL_6;
    v4 = recvfrom(a1, v2, 10239 - v3, 0, &addr, &addr_len);
    v3 += v4;
    if ( v4 <= 0 )
    {
      close(a1);
      if ( !byte_1AECC5 || !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
        return 0;
      strcpy((char *)v38, ":statusServiceThread recvfrom<=0");
      sub_47AB4(7, (const char *)v38, 0);
      return 0;
    }
    v2 = &v37[v3];
    if ( v3 > 10238 )
    {
      close(a1);
      if ( !byte_1AECC5 || !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
        return 0;
      strcpy((char *)v38, "BUFSIZE is too small!");
      sub_47AB4(7, (const char *)v38, 0);
      return 0;
    }
  }
  while ( !strstr(v37, needle) );
  if ( byte_1AECC5 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
    {
      strcpy((char *)v38, "find http request end flag!");
      sub_47AB4(7, (const char *)v38, 0);
LABEL_6:
      if ( byte_1AECC5 )
      {
        if ( !byte_244080 )
          goto LABEL_8;
LABEL_10:
        snprintf((char *)v38, 0x800u, "get http=%s", v37);
        sub_47AB4(7, (const char *)v38, 0);
      }
    }
    else
    {
LABEL_8:
      if ( byte_1AECC4 || dword_9E320 > 6 )
        goto LABEL_10;
    }
  }
  if ( v37[0] != 71 || v37[1] != 69 || v37[2] != 84 || v37[3] != 32 )
  {
    close(a1);
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      qmemcpy(v38, "statusServiceThread not support http command", sizeof(v38));
      v5 = aStatusservicet[44];
      v6 = (char *)&v39;
      v7 = (char *)v38;
      goto LABEL_18;
    }
    return 0;
  }
  if ( setsockopt(a1, 1, 21, optval, 8u) )
  {
    close(a1);
    if ( !byte_1AECC5 || !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
      return 0;
    v9 = "setsockopt SO_SNDTIMEO failed";
    goto LABEL_42;
  }
  v18 = setsockopt(a1, 1, 20, optval, 8u);
  if ( v18 )
  {
    close(a1);
    if ( !byte_1AECC5 || !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
      return 0;
    v9 = "setsockopt SO_RCVTIMEO failed";
LABEL_42:
    v10 = *(_DWORD *)v9;
    v11 = *((_DWORD *)v9 + 1);
    v12 = *((_DWORD *)v9 + 2);
    v13 = *((_DWORD *)v9 + 3);
    v14 = v9 + 16;
    v38[0] = v10;
    v38[1] = v11;
    v38[2] = v12;
    v38[3] = v13;
    v15 = v14[1];
    v16 = v14[2];
    v17 = v14[3];
    v38[4] = *v14;
    v38[5] = v15;
    v38[6] = v16;
    LOWORD(v38[7]) = v17;
    sub_47AB4(7, (const char *)v38, 0);
    return 0;
  }
  if ( !off_A0634 )
  {
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      strcpy((char *)v38, "No 6060 test case found.");
      sub_47AB4(7, (const char *)v38, 0);
    }
LABEL_48:
    v29 = strlen(v36);
    v19 = sprintf((char *)v38, "HTTP/1.0  200  OK%s", v30);
    v20 = v19 + sprintf((char *)v38 + v19, "Server: SearchFreqServer%s", v30);
    v21 = v20 + sprintf((char *)v38 + v20, "Cache-Control: no-cache%s", v30);
    v22 = v21 + sprintf((char *)v38 + v21, "Pragma: no-cache%s", v30);
    v23 = v22 + sprintf((char *)v38 + v22, "Content-Type: text/plain%s", v30);
    v24 = sprintf((char *)v38 + v23, "Content-Length: %d%s", v29, v30);
    sprintf((char *)v38 + v23 + v24, "Connection: Keep-Alive%s", needle);
    if ( !byte_1AECC5 )
    {
      if ( byte_A0630 )
        goto LABEL_70;
      goto LABEL_53;
    }
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
    {
      strcpy(s, "send http response...\n");
      sub_47AB4(7, s, 0);
      if ( !byte_A0630 )
        goto LABEL_53;
LABEL_66:
      if ( !byte_1AECC5 )
        goto LABEL_70;
    }
    else if ( !byte_A0630 )
    {
LABEL_53:
      v25 = strlen((const char *)v38);
      v26 = 0;
      while ( 1 )
      {
        v27 = send(a1, (char *)v38 + v26, v25 - v26, 0);
        if ( v27 == -1 )
        {
          if ( *_errno_location() != 11 )
          {
LABEL_60:
            close(a1);
            if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
            {
              qmemcpy(s, "statusServiceThread send http response error", 44);
              v5 = aStatusservicet_1[44];
              v6 = &s[44];
              v7 = s;
LABEL_18:
              *v6 = v5;
              sub_47AB4(7, v7, 0);
            }
            return 0;
          }
          if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
          {
            strcpy(s, "statusServiceThread send http timeout, try again...");
            sub_47AB4(7, s, 0);
          }
          usleep((__useconds_t)&loc_186A0);
        }
        else
        {
          if ( v27 <= 0 )
            goto LABEL_60;
          v26 += v27;
        }
        v25 = strlen((const char *)v38);
        if ( v25 <= v26 || byte_A0630 )
          goto LABEL_66;
      }
    }
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
    {
      strcpy(s, "send http data...");
      sub_47AB4(7, s, 0);
    }
    while ( 1 )
    {
LABEL_70:
      v28 = send(a1, &v36[v18], v29 - v18, 0);
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        snprintf(s, 0x800u, "send http data ret=%d", v28);
        sub_47AB4(7, s, 0);
      }
      if ( v28 <= 0 )
        break;
      v18 += v28;
      if ( v29 <= v18 || byte_A0630 )
        goto LABEL_81;
    }
    if ( !byte_1AECC5 )
      goto LABEL_86;
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
    {
      strcpy(s, "statusServiceThread send http data error");
      sub_47AB4(7, s, 0);
LABEL_81:
      if ( !byte_1AECC5 )
        goto LABEL_86;
      if ( byte_244080 )
        goto LABEL_85;
    }
    if ( byte_1AECC4 || dword_9E320 > 6 )
    {
LABEL_85:
      strcpy(s, "one client disconnected!");
      sub_47AB4(7, s, 0);
    }
LABEL_86:
    close(a1);
    return v18;
  }
  if ( !((int (__fastcall *)(char *, char *, int))off_A0634)(v37, v36, 4096) )
    goto LABEL_48;
  close(a1);
  if ( !byte_1AECC5 || !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
    return 0;
  strcpy((char *)v38, "statusServiceThread exit for Error cmd!");
  sub_47AB4(7, (const char *)v38, 0);
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// A0630: using guessed type char byte_A0630;
// A0634: using guessed type _UNKNOWN *off_A0634;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (0001FA04) --------------------------------------------------------
int sub_1FA04()
{
  int v0; // r0
  int v1; // r0
  int v2; // r4
  socklen_t addr_len; // [sp+Ch] [bp-828h] BYREF
  struct sockaddr addr; // [sp+10h] [bp-824h] BYREF
  struct sockaddr v6; // [sp+20h] [bp-814h] BYREF
  char s[2052]; // [sp+30h] [bp-804h] BYREF

  prctl(15, "http", 0);
  do
  {
    v0 = socket(2, 1, 6);
    dword_9C290 = v0;
    if ( v0 < 0 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
      {
        strcpy(s, "socket creating failed, try again after 10s...");
        sub_47AB4(5, s, 0);
      }
      sleep(0xAu);
    }
    else
    {
      *(_DWORD *)&addr.sa_family = -1407778814;
      memset(&addr.sa_data[2], 0, 12);
      if ( bind(v0, &addr, 0x10u) < 0 )
      {
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
        {
          strcpy(s, "http port bind failed! try again after 10s...");
          sub_47AB4(5, s, 0);
        }
      }
      else
      {
        if ( listen(dword_9C290, 100) >= 0 )
          break;
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
        {
          strcpy(s, "http listen failed! try again after 10s...");
          sub_47AB4(5, s, 0);
        }
      }
      close(dword_9C290);
      dword_9C290 = -1;
      sleep(0xAu);
    }
  }
  while ( !byte_A0630 );
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
  {
    strcpy(s, "start listen on 6060 ...");
    sub_47AB4(5, s, 0);
  }
  if ( !byte_A0630 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        usleep(0x2710u);
        addr_len = 16;
        v1 = accept(dword_9C290, &v6, &addr_len);
        v2 = v1;
        if ( v1 != -1 )
          break;
        if ( byte_A0630 )
          goto LABEL_19;
      }
      if ( byte_A0630 )
        break;
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        snprintf(s, 0x800u, "one client connected sock=%d", v1);
        sub_47AB4(7, s, 0);
      }
      sub_1EE28(v2);
      if ( byte_A0630 )
        goto LABEL_19;
    }
    close(v1);
  }
LABEL_19:
  close(dword_9C290);
  dword_9C290 = -1;
  return 0;
}
// 9C290: using guessed type int dword_9C290;
// 9E320: using guessed type int dword_9E320;
// A0630: using guessed type char byte_A0630;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (0001FD84) --------------------------------------------------------
void sub_1FD84()
{
  int v0; // r0
  pthread_t v1; // [sp+0h] [bp-828h] BYREF
  pthread_attr_t attr; // [sp+4h] [bp-824h] BYREF
  char s[2048]; // [sp+28h] [bp-800h] BYREF

  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
  {
    strcpy(s, "start the http log.\n");
    sub_47AB4(5, s, 0);
  }
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  v0 = pthread_create(&v1, &attr, (void *(*)(void *))sub_1FA04, 0);
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
  {
    snprintf(s, 0x800u, "httpListenThread start ret=%d", v0);
    sub_47AB4(5, s, 0);
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0001FEA0) --------------------------------------------------------
char *__fastcall sub_1FEA0(const char *a1)
{
  const char *v2; // r4
  char *v3; // r6
  size_t v4; // r0
  size_t v5; // r5
  size_t v6; // r8
  size_t v7; // r5
  int v8; // r3
  char *v9; // r0
  unsigned int v10; // r6
  struct hostent *v11; // r3
  int v12; // r0
  int v13; // r5
  int v14; // r4
  signed int v15; // r6
  ssize_t v16; // r0
  const char *v17; // r12
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  _DWORD *v22; // r12
  char *v23; // r4
  int v24; // r1
  char *v26; // r0
  char *v27; // r0
  char *v28; // r5
  size_t v29; // r0
  char *v30; // r0
  _DWORD v31[2]; // [sp+8h] [bp-2008h] BYREF
  char s[1024]; // [sp+10h] [bp-2000h] BYREF
  char dest[1024]; // [sp+410h] [bp-1C00h] BYREF
  struct sockaddr v34[127]; // [sp+810h] [bp-1800h] BYREF
  char v35[4096]; // [sp+1010h] [bp-1000h] BYREF

  memset(v35, 0, sizeof(v35));
  memset(s, 0, sizeof(s));
  memset(dest, 0, sizeof(dest));
  if ( !a1 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
    {
      v23 = 0;
      strcpy((char *)v34, "url is null!\n");
      sub_47AB4(5, (const char *)v34, 0);
      return v23;
    }
    return 0;
  }
  if ( !strncmp(a1, "http://", 7u) )
  {
    v2 = a1 + 7;
    v3 = strchr(v2, 47);
    v4 = strlen(v2);
    v5 = v4;
    if ( v3 )
    {
      v6 = strlen(v3);
      v7 = v5 - v6;
      memcpy(s, v2, v7);
      v8 = (unsigned __int8)v3[1];
      s[v7] = 0;
      if ( v8 )
      {
        memcpy(dest, v3 + 1, v6 - 1);
        s[v6 + 1023] = 0;
      }
    }
    else
    {
      memcpy(s, v2, v4);
      s[v5] = 0;
    }
    v9 = strchr(s, 58);
    if ( v9 )
    {
      *v9 = 0;
      v10 = strtol(v9 + 1, 0, 10);
    }
    else
    {
      v10 = 80;
    }
    v11 = gethostbyname(s);
    if ( !v11 )
      goto LABEL_37;
    *(_WORD *)v34[0].sa_data = __rev16(v10);
    v34[0].sa_family = 2;
    *(_DWORD *)&v34[0].sa_data[2] = **(_DWORD **)v11->h_addr_list;
    v12 = socket(2, 1, 0);
    v13 = v12;
    if ( v12 == -1
      || (v31[0] = 10, v31[1] = 0, setsockopt(v12, 1, 21, v31, 8u))
      || (v14 = setsockopt(v13, 1, 20, v31, 8u)) != 0
      || connect(v13, v34, 0x10u) == -1
      || v13 < 0 )
    {
LABEL_37:
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
      {
        v23 = 0;
        strcpy((char *)v34, "tcp client create failed\n");
        sub_47AB4(5, (const char *)v34, 0);
        return v23;
      }
    }
    else
    {
      sprintf(v35, "GET /%s HTTP/1.1\r\nHOST: %s:%d\r\nAccept: */*\r\n\r\n", dest, s, v10);
      v15 = strlen(v35);
      if ( v15 )
      {
        while ( 1 )
        {
          v16 = send(v13, &v35[v14], v15 - v14, 0);
          v14 += v16;
          if ( v16 == -1 )
            break;
          if ( v15 <= v14 )
            goto LABEL_39;
        }
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
        {
          v17 = "tcp client send failed\n";
LABEL_23:
          v18 = *(_DWORD *)v17;
          v19 = *((_DWORD *)v17 + 1);
          v20 = *((_DWORD *)v17 + 2);
          v21 = *((_DWORD *)v17 + 3);
          v22 = v17 + 16;
          v23 = 0;
          *(_DWORD *)&v34[0].sa_family = v18;
          *(_DWORD *)&v34[0].sa_data[2] = v19;
          *(_DWORD *)&v34[0].sa_data[6] = v20;
          *(_DWORD *)&v34[0].sa_data[10] = v21;
          v24 = v22[1];
          *(_DWORD *)&v34[1].sa_family = *v22;
          *(_DWORD *)&v34[1].sa_data[2] = v24;
          sub_47AB4(5, (const char *)v34, 0);
          return v23;
        }
      }
      else
      {
LABEL_39:
        if ( recv(v13, v35, 0x1000u, 0) > 0 )
        {
          close(v13);
          v26 = strstr(v35, "HTTP/1.1");
          if ( v26 )
          {
            if ( strtol(v26 + 9, 0, 10) == 200 )
            {
              v27 = strstr(v35, "\r\n\r\n");
              v28 = v27;
              if ( v27 )
              {
                v29 = strlen(v27);
                v30 = (char *)malloc(v29 + 1);
                v23 = v30;
                if ( v30 )
                  strcpy(v30, v28 + 4);
                return v23;
              }
            }
          }
        }
        else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
        {
          v17 = "tcp client recv failed\n";
          goto LABEL_23;
        }
      }
    }
    return 0;
  }
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 4 )
    return 0;
  strcpy((char *)v34, "parse url failed!\n");
  sub_47AB4(5, (const char *)v34, 0);
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (000203C8) --------------------------------------------------------
int __fastcall sub_203C8(char *a1)
{
  int v2; // r0
  int v3; // r6
  int v4; // r9
  int v5; // r5
  struct in_addr *i; // r4
  char *v8; // r1
  _DWORD v10[2]; // [sp+0h] [bp-208h] BYREF
  _OWORD v11[32]; // [sp+8h] [bp-200h] BYREF

  v2 = socket(2, 2, 0);
  v3 = v2;
  if ( v2 < 0 )
    return -1;
  v10[0] = 512;
  v10[1] = v11;
  if ( ioctl(v2, 0x8912u, v10) )
  {
    v4 = -1;
  }
  else
  {
    v4 = -1;
    v5 = v10[0] >> 5;
    for ( i = (struct in_addr *)&v11[2 * (v10[0] >> 5) - 2]; v5-- != 0; i -= 8 )
    {
      if ( !ioctl(v3, 0x8915u, i) )
      {
        v8 = inet_ntoa(i[5]);
        if ( v8 )
        {
          strcpy(a1, v8);
          v4 = strcmp("127.0.0.1", a1);
          if ( v4 )
          {
            v4 = 0;
            break;
          }
        }
      }
    }
  }
  close(v3);
  return v4;
}

//----- (000204A8) --------------------------------------------------------
void __noreturn sub_204A8()
{
  int v0; // r4
  int v1; // r3
  bool v2; // cc
  int v3; // r12
  _DWORD s[16]; // [sp+8h] [bp-844h] BYREF
  char v5[2052]; // [sp+48h] [bp-804h] BYREF

  memset(s, 0, sizeof(s));
  prctl(15, "heart_beat", 0, 0, 0);
LABEL_2:
  v0 = 0;
  pthread_setcancelstate(1, 0);
  while ( 1 )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * v0 + 4) != 1 )
    {
LABEL_3:
      if ( ++v0 == 16 )
        goto LABEL_10;
    }
    sub_4A804();
    if ( sub_197A0((unsigned __int8)v0) )
    {
      s[v0] = 0;
      goto LABEL_3;
    }
    v1 = v0;
    v2 = (unsigned int)dword_9E31C > 1;
    v3 = s[v0] + 1;
    s[v0] = v3;
    if ( !v2 )
      goto LABEL_3;
    ++v0;
    snprintf(v5, 0x800u, "chain[%d] heart beat fail %d times.\n", v1, v3);
    sub_47AB4(1, v5, 0);
    if ( v0 == 16 )
    {
LABEL_10:
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      sleep(0xAu);
      goto LABEL_2;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (000205BC) --------------------------------------------------------
int sub_205BC()
{
  int v0; // r5
  _BYTE *v1; // r8
  unsigned __int64 v2; // r6
  unsigned int v3; // r4
  int v4; // r0
  unsigned __int64 v5; // r0
  char *v6; // r12
  unsigned int v7; // t1
  _BYTE v9[208]; // [sp+0h] [bp-D0h] BYREF
  char v10[2048]; // [sp+D0h] [bp+0h] BYREF

  v0 = 0;
  while ( 1 )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * v0 + 4) == 1 )
    {
      v1 = &v9[-4];
      v2 = 0;
      v3 = 0;
      do
      {
        v4 = sub_2F530(v0, v3++);
        v2 += (unsigned int)v4;
        *((_DWORD *)v1 + 1) = v4;
        v1 += 4;
      }
      while ( v3 != 52 );
      if ( v2 > (unsigned int)&loc_3F79C + 3 )
        break;
    }
LABEL_2:
    if ( ++v0 == 16 )
      return 0;
  }
  LODWORD(v5) = sub_77910(v2, 0x68u);
  v6 = v9;
  while ( 1 )
  {
    v7 = *(_DWORD *)v6;
    v6 += 4;
    if ( v7 < v5 )
      break;
    if ( v10 == v6 )
      goto LABEL_2;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v10, "Domain unbalance happened!\n");
    sub_47AB4(3, v10, 0);
  }
  return 1;
}
// 20678: variable 'v5' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (000206E0) --------------------------------------------------------
void sub_206E0()
{
  int v0; // r7
  int v1; // r10
  int v2; // r4
  int v3; // r12
  int v4; // lr
  int v5; // r5
  int v6; // r9
  int v7; // r0
  int v8; // r3
  bool v9; // zf
  int v10; // r3
  int v11; // r3
  int v12; // r2
  bool v13; // cc
  bool v14; // cc
  int v15; // [sp+20h] [bp-81Ch]
  int v16; // [sp+24h] [bp-818h]
  _DWORD v17[4]; // [sp+28h] [bp-814h] BYREF
  char s[2052]; // [sp+38h] [bp-804h] BYREF

  v0 = 0;
  sub_175F4(v17);
  v1 = 0;
  v2 = 0;
  v15 = sub_169E4();
  v16 = sub_16B30();
  do
  {
    while ( 1 )
    {
      v5 = v2;
      if ( *(_DWORD *)(dword_A0D68 + 4 * v2 + 4) == 1 )
        break;
      if ( ++v2 == 16 )
        goto LABEL_11;
    }
    v6 = sub_16C84(v2);
    v7 = sub_16DE4(v2);
    v8 = dword_A0638[v2];
    v9 = v8 == 0;
    v10 = v6 - v8;
    if ( v9 )
    {
      v10 = dword_A0638[v2 + 16];
      v3 = v10;
      if ( v10 )
      {
        v3 = v7 - v10;
        v10 = v6;
      }
    }
    else
    {
      v3 = v7 - dword_A0638[v2 + 16];
    }
    ++v2;
    if ( v1 < v10 )
      v1 = v10;
    if ( v0 < v3 )
      v0 = v3;
    dword_A0638[v5] = v6;
    dword_A0638[v5 + 16] = v7;
  }
  while ( v2 != 16 );
LABEL_11:
  v11 = v17[0];
  if ( !byte_A06B8 )
    v11 = v17[1];
  v12 = v17[2];
  if ( byte_A06B8 )
    v4 = 95;
  else
    v12 = v17[3];
  if ( byte_A06B8 )
    v3 = 80;
  else
    v4 = 98;
  if ( !byte_A06B8 )
    v3 = 85;
  v13 = v16 <= v4;
  if ( v16 <= v4 )
    v13 = v15 <= v3;
  if ( !v13 )
    goto LABEL_28;
  v14 = v0 <= v12;
  if ( v0 <= v12 )
    v14 = v1 <= v11;
  if ( !v14 )
  {
LABEL_28:
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(
        s,
        0x800u,
        "over max temp, pcb temp %d (max %d), chip temp %d(max %d) pcb temp rise %d (max %d) chip temp rise %d (max %d)\n",
        v15,
        v3,
        v16,
        v4,
        v1,
        v11,
        v0,
        v12);
      sub_47AB4(3, s, 0);
    }
    sub_226C0(0xEu, "over max temp");
  }
}
// 207D4: variable 'v4' is possibly undefined
// 207D8: variable 'v3' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// A0638: using guessed type _DWORD dword_A0638[32];
// A06B8: using guessed type char byte_A06B8;
// A0D68: using guessed type int dword_A0D68;

//----- (00020880) --------------------------------------------------------
void __noreturn sub_20880()
{
  int v0; // r4
  bool v1; // zf

  sub_1758C();
  v0 = 0;
  prctl(15, "temp_mtr", 0, 0, 0);
  while ( 1 )
  {
    pthread_mutex_lock(&stru_A0DB0);
    sub_15E90(1);
    v1 = (v0++ & 3) == 0;
    if ( v1 || !byte_A06B8 )
      sub_1409C();
    sub_13C54(0x190u);
    pthread_mutex_unlock(&stru_A0DB0);
    sub_4A804();
  }
}
// A06B8: using guessed type char byte_A06B8;

//----- (0002090C) --------------------------------------------------------
void __noreturn sub_2090C()
{
  int v0; // r0
  unsigned int v1; // r0
  int v2; // r5
  int v3; // r4
  _QWORD v4[2]; // [sp+8h] [bp-14h] BYREF

  v0 = sub_702AC();
  sub_702CC(v0 | 0x10000);
  prctl(15, "nonce_reg_process", 0);
  while ( 1 )
  {
    v1 = sub_6FD6C();
    v2 = (unsigned __int8)(v1 >> 1);
    if ( (unsigned __int8)(v1 >> 1) )
    {
      v3 = 0;
      do
      {
        while ( 1 )
        {
          sub_6FDC4(v4);
          if ( (v4[0] & 0x80000000LL) != 0 )
            break;
          ++v3;
          sub_2F194((int)v4);
          if ( v2 == v3 )
            goto LABEL_7;
        }
        ++v3;
        sub_2EE74((int)v4);
      }
      while ( v2 != v3 );
    }
LABEL_7:
    sub_4A804();
  }
}

//----- (00020998) --------------------------------------------------------
time_t sub_20998()
{
  int v0; // r4
  char *v1; // r0
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    v0 = *_errno_location();
    v1 = strerror(v0);
    snprintf(s, 0x800u, "Failed to get sysinfo, errno = %u, reason = %s.\n", v0, v1);
    sub_47AB4(3, s, 0);
  }
  return time(0);
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00020A08) --------------------------------------------------------
time_t sub_20A08()
{
  struct sysinfo v1; // [sp+0h] [bp-44h] BYREF

  if ( sysinfo(&v1) )
    return sub_20998();
  else
    return v1.uptime;
}

//----- (00020A38) --------------------------------------------------------
void sub_20A38()
{
  time_t v0; // r0
  __int64 v1; // r6
  int v2; // r3
  int v3; // r5
  double v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v0 = sub_20A08();
  v1 = *(_QWORD *)&dword_241D50;
  v2 = dword_A06BC;
  dword_A06BC = v0;
  v3 = v0 - v2;
  LODWORD(v4) = sub_778A4(*(_QWORD *)&dword_241D50 - qword_A06C0);
  qword_A06C0 = v1;
  dbl_241D48 = v4 * 4294967300.0 / 1000000000.0 / (double)v3;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "avg rate is %0.2f in %ld mins\n", v4 * 4294967300.0 / 1000000000.0 / (double)v3, v3 / 60);
    sub_47AB4(3, s, 0);
  }
}
// 20AA0: variable 'v4' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// A06BC: using guessed type int dword_A06BC;
// A06C0: using guessed type __int64 qword_A06C0;
// 241D48: using guessed type double dbl_241D48;
// 241D50: using guessed type int dword_241D50;

//----- (00020B28) --------------------------------------------------------
time_t sub_20B28()
{
  time_t result; // r0

  dword_A06C8 = sub_20A08();
  result = sub_20A08();
  dword_A06BC = result;
  return result;
}
// A06BC: using guessed type int dword_A06BC;
// A06C8: using guessed type int dword_A06C8;

//----- (00020B48) --------------------------------------------------------
int sub_20B48()
{
  unsigned int v1; // r5
  int v2; // r9
  unsigned int v3; // r0
  int v4; // r8
  int v5; // r7
  int v6; // r6
  int v7; // r4
  int v8; // r3
  int v9; // r6
  int v10; // r0
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( sub_16940() <= 7 || (double)sub_3047C() * 0.98 <= dbl_241D48 )
    return 0;
  v1 = sub_16940();
  v2 = sub_30524(v1, 1);
  v3 = sub_312D8();
  v4 = sub_3050C(v3, 0);
  v5 = sub_1A1B0();
  v6 = sub_1A1C0();
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "latest avg rate < %.2f......\n", 0.98);
    sub_47AB4(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "current PCB min temperature %d\n", v1);
      sub_47AB4(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "current voltage raw is %d, working voltage raw is %d\n", v6, v5);
        sub_47AB4(3, s, 0);
      }
    }
  }
  if ( v1 > 0x16 )
  {
    v7 = (unsigned __int8)byte_A06CC;
    if ( byte_A06CC )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy(s, "high temp, voltage has already increased 0.1V/0.2V\n");
        sub_47AB4(3, s, 0);
      }
      return 0;
    }
    if ( v4 >= 2 )
      v8 = 10;
    else
      v8 = 20;
    v9 = v8 + v6;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "high temp, increase voltage 0.1V/0.2V to %d\n", v9);
      sub_47AB4(3, s, v7);
    }
    byte_A06CC = 1;
    byte_A06B8 = 0;
    sub_1A0F0(v9);
  }
  else
  {
    if ( v5 != v6 )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy(s, "low temp, voltage has already increased to higher voltage\n");
        sub_47AB4(3, s, 0);
        return 0;
      }
      return 0;
    }
    if ( byte_A06CC )
      v10 = sub_3055C(v4, v2);
    else
      v10 = sub_30540(v4, v2);
    if ( v5 + 99 < v10 )
      v10 = v5 + 100;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "low temp, increase voltage to higher voltage %d\n", v10);
      sub_47AB4(3, s, 0);
    }
    byte_A06B8 = 0;
  }
  if ( sub_257E4() )
    sub_226C0(4u, "reopen core failed!");
  sub_20B28();
  return -1;
}
// 9E31C: using guessed type int dword_9E31C;
// A06B8: using guessed type char byte_A06B8;
// A06CC: using guessed type char byte_A06CC;
// 241D48: using guessed type double dbl_241D48;

//----- (00020E60) --------------------------------------------------------
void sub_20E60()
{
  if ( sub_16940() > 7 && (double)sub_3047C() * 0.95 > dbl_241D48 )
  {
    if ( sub_205BC() )
      sub_226C0(0xAu, "Unbalance happened, reboot!\n");
  }
}
// 241D48: using guessed type double dbl_241D48;

//----- (00020EC8) --------------------------------------------------------
int sub_20EC8()
{
  int v0; // r6
  int v1; // r5
  int v2; // r0
  bool v3; // cc
  int v4; // r4
  int result; // r0
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v0 = sub_16940();
  v1 = sub_1A1B0();
  v2 = sub_1A1C0();
  v3 = v1 <= v2;
  if ( v1 != v2 )
    v3 = v0 <= 26;
  v4 = v2;
  result = !v3;
  if ( !v3 )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "current PCB min temperature is %d\n", v0);
      sub_47AB4(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "current voltage is %d, recovery to %d\n", v4, v1);
        sub_47AB4(3, s, 0);
      }
    }
    sub_1A3B8();
    return -1;
  }
  return result;
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00020F90) --------------------------------------------------------
void __noreturn sub_20F90()
{
  time_t v0; // r5
  unsigned int v1; // r0
  unsigned int v2; // r4
  unsigned int v3; // r11

  prctl(15, "chk_sys", 0);
  sub_2F7DC();
  v0 = sub_20A08();
  while ( 1 )
  {
    if ( sub_226B0() == 1 )
    {
      v1 = sub_20A08() - v0;
      if ( *(_QWORD *)&dword_241D50 || v1 > 0x708 )
        break;
    }
    sub_4A804();
  }
  dword_A06D0 = sub_20A08();
  sub_20B28();
LABEL_7:
  v2 = 1;
  while ( 1 )
  {
    if ( v2 == 5 * (v2 / 5) && sub_20EC8() )
      goto LABEL_7;
    v3 = v2 % 0x3C;
    if ( v2 == 60 * (v2 / 0x3C) )
    {
LABEL_19:
      v3 = 0;
      sub_23590();
    }
    if ( v2 == 1800 * (v2 / 0x708) )
    {
      sub_20A38();
      sub_14BF4();
      if ( sub_20B48() )
        goto LABEL_7;
    }
    if ( v2 == 21600 * (v2 / 0x5460) )
      sub_20E60();
    if ( !v3 )
    {
      sub_2F354();
      sub_2F5AC();
    }
    if ( v2 == 10 * (v2 / 0xA) )
      sub_2F984();
    ++v2;
    sub_4A804();
    if ( v2 == 120 )
    {
      byte_A06B8 = 1;
      if ( sub_20EC8() )
        goto LABEL_7;
      goto LABEL_19;
    }
  }
}
// A06B8: using guessed type char byte_A06B8;
// A06D0: using guessed type int dword_A06D0;
// 241D50: using guessed type int dword_241D50;

//----- (00021140) --------------------------------------------------------
int sub_21140()
{
  int v0; // r3
  int v1; // r2
  int v2; // r10
  time_t v4; // r0
  char *v5; // r3
  int v6; // r2
  __int64 v7; // r4
  int v8; // r6
  int v9; // t1
  double v10; // r0
  time_t v11; // r0
  double v12; // d11
  int v13; // r5
  int v14; // s24
  int v15; // r8
  int v16; // r9
  int v17; // r12
  int v18; // r4
  int v19; // r8
  unsigned int v20; // r1
  unsigned int v21; // r0
  int v22; // r3
  bool v23; // cf
  unsigned int v24; // lr
  __int64 v25; // r2
  unsigned int v26; // r1
  __int64 v27; // r0
  double v28; // r0
  double v29; // d6

  ++dword_A06D4;
  sub_23298();
  v0 = dword_A06D4;
  v1 = dword_A06D4 >> 31;
  v2 = dword_A06D4 % 5;
  if ( dword_A06D4 == 5 * (dword_A06D4 / 5) )
  {
    v11 = sub_20A08();
    v12 = 0.0;
    v13 = v2;
    v14 = v11 - dword_A06C8;
    dword_A06C8 = v11;
    do
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * v2 + 4) == 1 )
      {
        v15 = dword_A06D8[v2];
        v16 = *(_DWORD *)((char *)&unk_241A80 + v13 + 4);
        v17 = 10 * v2 + v15;
        v18 = (v15 + 1) % 10;
        v19 = dword_A06D8[v2 + 16];
        dword_A06D8[v2] = v18;
        if ( v19 <= 9 )
          dword_A06D8[v2 + 16] = ++v19;
        v20 = *(_DWORD *)((char *)&unk_A0758 + v13);
        v21 = *(_DWORD *)((char *)&unk_241A80 + v13);
        v22 = *(_DWORD *)((char *)&unk_A0758 + v13 + 4);
        *(_DWORD *)((char *)&unk_A0758 + v13) = v21;
        v23 = v21 >= v20;
        v24 = v21 - v20;
        LODWORD(v25) = *(_DWORD *)((char *)&qword_A07D8[160] + v13);
        v26 = *(_DWORD *)((char *)&qword_A07D8[160] + v13 + 4);
        HIDWORD(v25) = v16 - (v22 + !v23);
        LODWORD(qword_A07D8[v17]) = v24;
        *(_DWORD *)((char *)&qword_A07D8[160] + v13) = v24 + v25;
        HIDWORD(qword_A07D8[v17]) = HIDWORD(v25);
        *(_DWORD *)((char *)&unk_A0758 + v13 + 4) = v16;
        v27 = __PAIR64__(v26, v24) + v25;
        *(_DWORD *)((char *)&qword_A07D8[160] + v13 + 4) = HIDWORD(v27);
        LODWORD(v28) = sub_778A4(v27);
        v29 = v28 * 4294967300.0 / (double)v19 / (double)v14;
        sprintf(&byte_241B00[32 * v2], "%.2f", v29 / 1000000000.0);
        v12 = v12 + v29 / 1000000000.0;
        *(_QWORD *)((char *)&qword_A07D8[160] + v13) -= qword_A07D8[10 * v2 + v18];
      }
      ++v2;
      v13 += 8;
    }
    while ( v2 != 16 );
    sprintf((char *)&dword_1B09FC, "%.2f", v12);
    v0 = dword_A06D4;
    v1 = dword_A06D4 >> 31;
  }
  if ( v0 != 1800 * (((int)((unsigned __int64)(2443359173LL * v0) >> 32) >> 10) - v1) )
    return 0;
  v4 = sub_20A08();
  v5 = (char *)&unk_241A80;
  v6 = dword_A0D68;
  v7 = 0;
  v8 = v4 - dword_A06D0;
  dword_A06D0 = v4;
  do
  {
    v9 = *(_DWORD *)(v6 + 4);
    v6 += 4;
    if ( v9 == 1 )
      v7 += *(_QWORD *)v5;
    v5 += 8;
  }
  while ( byte_241B00 != v5 );
  LODWORD(v10) = sub_778A4(v7 - qword_A0D58);
  qword_A0D58 = v7;
  dbl_1B0A10 = v10 * 4294967300.0 / 1000000000.0 / (double)v8;
  return 0;
}
// 21244: variable 'v10' is possibly undefined
// 213B0: variable 'v28' is possibly undefined
// A06C8: using guessed type int dword_A06C8;
// A06D0: using guessed type int dword_A06D0;
// A06D4: using guessed type int dword_A06D4;
// A06D8: using guessed type _DWORD[32];
// A07D8: using guessed type _QWORD[176];
// A0D58: using guessed type __int64 qword_A0D58;
// A0D68: using guessed type int dword_A0D68;
// 1B09FC: using guessed type int dword_1B09FC;
// 1B0A10: using guessed type double dbl_1B0A10;

//----- (00021478) --------------------------------------------------------
void __noreturn sub_21478()
{
  int v0; // r3
  int v1; // r3
  struct timeval v2; // [sp+8h] [bp-8h] BYREF

  prctl(15, "chk_status");
  while ( 1 )
  {
    pthread_mutex_lock(&stru_A0DB0);
    if ( byte_A06B8 )
    {
      sub_4A60C(&v2);
      v0 = v2.tv_sec - dword_A0D7C;
      if ( v2.tv_usec - dword_A0D80 < 0 )
        --v0;
      if ( v0 <= 120 )
      {
        if ( dword_A0D60 )
        {
          sub_226C0(1u, 0);
          dword_A0D60 = 0;
        }
      }
      else
      {
        v1 = dword_A0D60 + 1;
        dword_A0D60 = v1;
        if ( v1 == 1 )
        {
          sub_226C0(2u, "network connection lost");
          v1 = dword_A0D60;
        }
        if ( v1 > 720 )
          sub_226C0(5u, "network connection lost");
      }
    }
    sub_206E0();
    pthread_mutex_unlock(&stru_A0DB0);
    sub_21140();
    sub_4A804();
  }
}
// A06B8: using guessed type char byte_A06B8;
// A0D60: using guessed type int dword_A0D60;
// A0D7C: using guessed type int dword_A0D7C;
// A0D80: using guessed type int dword_A0D80;

//----- (00021578) --------------------------------------------------------
int sub_21578()
{
  pthread_attr_t attr; // [sp+4h] [bp-824h] BYREF
  char v2[2048]; // [sp+28h] [bp-800h] BYREF

  if ( dword_23A29C )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  dword_23A29C = (int)calloc(1u, 0x40u);
  if ( sub_4BDCC(dword_23A29C, &attr, (void *(*)(void *))sub_20880, (void *)dword_23A29C) )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v2, "create thread failed\n");
      sub_47AB4(3, v2, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_23A29C + 12));
    if ( (unsigned int)dword_9E31C <= 3 )
      return 0;
    strcpy(v2, "create thread\n");
    sub_47AB4(3, v2, 0);
    return 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A29C: using guessed type int dword_23A29C;

//----- (00021690) --------------------------------------------------------
int sub_21690()
{
  pthread_attr_t attr; // [sp+4h] [bp-824h] BYREF
  char v2[2048]; // [sp+28h] [bp-800h] BYREF

  if ( dword_23A2A8 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  dword_23A2A8 = (int)calloc(1u, 0x40u);
  if ( sub_4BDCC(dword_23A2A8, &attr, (void *(*)(void *))sub_204A8, (void *)dword_23A2A8) )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v2, "create thread failed\n");
      sub_47AB4(3, v2, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_23A2A8 + 12));
    if ( (unsigned int)dword_9E31C <= 3 )
      return 0;
    strcpy(v2, "create thread\n");
    sub_47AB4(3, v2, 0);
    return 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A2A8: using guessed type int dword_23A2A8;

//----- (000217A8) --------------------------------------------------------
int sub_217A8()
{
  pthread_attr_t attr; // [sp+4h] [bp-824h] BYREF
  char v2[2048]; // [sp+28h] [bp-800h] BYREF

  if ( dword_23A298 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x800000u);
  dword_23A298 = (int)calloc(1u, 0x40u);
  if ( sub_4BDCC(dword_23A298, &attr, (void *(*)(void *))sub_2090C, (void *)dword_23A298) )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v2, "create thread failed\n");
      sub_47AB4(3, v2, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_23A298 + 12));
    if ( (unsigned int)dword_9E31C <= 3 )
      return 0;
    strcpy(v2, "create thread\n");
    sub_47AB4(3, v2, 0);
    return 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A298: using guessed type int dword_23A298;

//----- (000218C0) --------------------------------------------------------
int sub_218C0()
{
  return 0;
}

//----- (000218C8) --------------------------------------------------------
int sub_218C8()
{
  pthread_attr_t attr; // [sp+4h] [bp-824h] BYREF
  char v2[2048]; // [sp+28h] [bp-800h] BYREF

  if ( dword_23A2A4 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  dword_23A2A4 = (int)calloc(1u, 0x40u);
  if ( sub_4BDCC(dword_23A2A4, &attr, (void *(*)(void *))sub_20F90, (void *)dword_23A2A4) )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v2, "create thread failed\n");
      sub_47AB4(3, v2, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_23A2A4 + 12));
    if ( (unsigned int)dword_9E31C <= 3 )
      return 0;
    strcpy(v2, "create thread\n");
    sub_47AB4(3, v2, 0);
    return 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A2A4: using guessed type int dword_23A2A4;

//----- (000219E0) --------------------------------------------------------
int sub_219E0()
{
  pthread_attr_t attr; // [sp+4h] [bp-824h] BYREF
  char v2[2048]; // [sp+28h] [bp-800h] BYREF

  if ( dword_23A2A0 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  dword_23A2A0 = (int)calloc(1u, 0x40u);
  if ( sub_4BDCC(dword_23A2A0, &attr, (void *(*)(void *))sub_21478, (void *)dword_23A2A0) )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v2, "create thread failed\n");
      sub_47AB4(3, v2, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_23A2A0 + 12));
    if ( (unsigned int)dword_9E31C <= 3 )
      return 0;
    strcpy(v2, "create thread\n");
    sub_47AB4(3, v2, 0);
    return 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A2A0: using guessed type int dword_23A2A0;

//----- (00021AF8) --------------------------------------------------------
void sub_21AF8()
{
  int v0; // r5
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  v0 = dword_23A29C;
  if ( dword_23A29C && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_47AB4(3, v1, 0);
      v0 = dword_23A29C;
    }
    sub_4A1F0(v0);
    free((void *)dword_23A29C);
    dword_23A29C = 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A29C: using guessed type int dword_23A29C;

//----- (00021B98) --------------------------------------------------------
void sub_21B98()
{
  int v0; // r5
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  v0 = dword_23A2A8;
  if ( dword_23A2A8 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_47AB4(3, v1, 0);
      v0 = dword_23A2A8;
    }
    sub_4A1F0(v0);
    free((void *)dword_23A2A8);
    dword_23A2A8 = 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A2A8: using guessed type int dword_23A2A8;

//----- (00021C38) --------------------------------------------------------
void sub_21C38()
{
  int v0; // r5
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  v0 = dword_23A298;
  if ( dword_23A298 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_47AB4(3, v1, 0);
      v0 = dword_23A298;
    }
    sub_4A1F0(v0);
    free((void *)dword_23A298);
    dword_23A298 = 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A298: using guessed type int dword_23A298;

//----- (00021CDC) --------------------------------------------------------
void sub_21CDC()
{
  int v0; // r5
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  v0 = dword_23A2A4;
  if ( dword_23A2A4 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_47AB4(3, v1, 0);
      v0 = dword_23A2A4;
    }
    sub_4A1F0(v0);
    free((void *)dword_23A2A4);
    dword_23A2A4 = 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A2A4: using guessed type int dword_23A2A4;

//----- (00021D7C) --------------------------------------------------------
void sub_21D7C()
{
  int v0; // r5
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  v0 = dword_23A2A0;
  if ( dword_23A2A0 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_47AB4(3, v1, 0);
      v0 = dword_23A2A0;
    }
    sub_4A1F0(v0);
    free((void *)dword_23A2A0);
    dword_23A2A0 = 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 23A2A0: using guessed type int dword_23A2A0;

//----- (00021E78) --------------------------------------------------------
int __fastcall sub_21E78(int a1)
{
  int v2; // r0
  int v3; // r0
  int result; // r0
  char v5[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v5, 0x800u, "set UART baud to %d\n", a1);
    sub_47AB4(3, v5, 0);
  }
  if ( a1 > 3000000 )
    v2 = 400000000;
  else
    v2 = 25000000;
  v3 = sub_772E8(v2, 8 * a1);
  sub_1A8AC(a1, v3 - 1);
  sub_4A830();
  result = sub_70E58(a1);
  *(_DWORD *)(dword_A0D68 + 12956) = a1;
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00021F2C) --------------------------------------------------------
int sub_21F2C()
{
  sub_21E78(12000000);
  sub_4A804();
  return sub_15E0C();
}

//----- (00021F4C) --------------------------------------------------------
int __fastcall sub_21F4C(int result)
{
  int v1; // r12
  int v2; // r8
  int v3; // r6
  int v4; // r2
  unsigned int v5; // r2
  int v6; // lr
  int v7; // r7
  int v8; // r1
  int v9; // r6
  _WORD *v10; // r3
  int v11; // [sp+0h] [bp-1Ch]
  int v12; // [sp+4h] [bp-18h]
  int v13; // [sp+Ch] [bp-10h]
  int v14; // [sp+10h] [bp-Ch]

  v1 = dword_A0D68;
  v11 = dword_A0D68 + 12917;
  v13 = dword_A0D68 + 12933;
  v14 = -12917 - dword_A0D68;
  do
  {
    v2 = v14 + v11;
    v3 = *(unsigned __int8 *)++v11;
    if ( v3 )
    {
      result = 0;
      v5 = 0;
      v12 = 2 * v2;
      v6 = v1 + 97 * v2;
      v7 = v3;
      do
      {
        v8 = result + v5;
        v9 = v6 + result + v5;
        v10 = (_WORD *)(v1 + 8 * (78 * v2 + v5 + 158));
        if ( v5 == 6 * (v5 / 6) )
        {
          ++result;
          *(_BYTE *)(v9 + 11254) = 32;
          v8 = result + v5;
        }
        ++v5;
        *(_BYTE *)(v6 + v8 + 11254) = 111;
        v10[3] = 0;
        v10[4] = 0;
        v10[5] = 0;
        v10[6] = 0;
      }
      while ( v5 != v7 );
      v4 = result + v5;
    }
    else
    {
      v4 = 0;
      v12 = 2 * v2;
    }
    *(_BYTE *)(v1 + v2 + 32 * (v12 + v2) + v4 + 11254) = 0;
  }
  while ( v11 != v13 );
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (00022088) --------------------------------------------------------
void __fastcall sub_22088(unsigned int *a1)
{
  int v2; // r3
  unsigned int *v3; // r5
  unsigned int v4; // r8
  unsigned int v5; // r2
  unsigned int v6; // r4
  int v7; // r3
  char dest[2052]; // [sp+8h] [bp-804h] BYREF

  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
  {
    strcpy(dest, "==========================capability start==========================\n");
    sub_47AB4(5, dest, 0);
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
    {
      snprintf(dest, 0x800u, "board num = %d\n", *a1);
      sub_47AB4(5, dest, 0);
    }
  }
  v2 = (unsigned __int8)byte_244080;
  if ( *a1 )
  {
    v3 = a1;
    v4 = 0;
    do
    {
      if ( v2 || (v2 = (unsigned __int8)byte_1AECC4, byte_1AECC4) || dword_9E320 > 4 )
      {
        snprintf(dest, 0x800u, "board id = %d, chain num = %d\n", v3[1], v3[2]);
        sub_47AB4(5, dest, 0);
        v2 = (unsigned __int8)byte_244080;
      }
      v5 = v3[2];
      if ( v5 )
      {
        v6 = 0;
        do
        {
          if ( !v2 )
          {
            while ( 1 )
            {
              v2 = (unsigned __int8)byte_1AECC4;
              if ( byte_1AECC4 || dword_9E320 > 4 )
                break;
              if ( v5 <= ++v6 )
                goto LABEL_17;
            }
          }
          v7 = v3[v6++ + 3];
          snprintf(dest, 0x800u, "\tchain id = %d\n", v7);
          sub_47AB4(5, dest, 0);
          v5 = v3[2];
          v2 = (unsigned __int8)byte_244080;
        }
        while ( v5 > v6 );
      }
LABEL_17:
      ++v4;
      v3 += 18;
    }
    while ( *a1 > v4 );
  }
  if ( v2 || byte_1AECC4 || dword_9E320 > 4 )
  {
    strcpy(dest, "==========================capability end============================\n");
    sub_47AB4(5, dest, 0);
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (000222E8) --------------------------------------------------------
void sub_222E8()
{
  int v0; // r0
  bool v1; // cc
  int v2; // r2
  int v3; // r1
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  v0 = (unsigned __int8)byte_241D0A;
  v1 = (unsigned int)dword_9E31C > 3;
  v2 = dword_A0D68 + 12288;
  v3 = ((unsigned __int8)byte_241D04 >> 1) & 1;
  *(_BYTE *)(dword_A0D68 + 12977) = (byte_241D04 & 2) != 0;
  *(_BYTE *)(v2 + 690) = v0;
  if ( v1 )
  {
    snprintf(s, 0x800u, "fan_eft : %d  fan_pwm : %d\n", (unsigned __int8)v3, v0);
    sub_47AB4(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 241D04: using guessed type char byte_241D04;
// 241D0A: using guessed type char byte_241D0A;

//----- (0002236C) --------------------------------------------------------
char *__fastcall sub_2236C(char *a1, int a2)
{
  int v2; // r5
  int v3; // r6
  char *v4; // r9
  int v5; // r3
  int v6; // r2
  int v7; // r0
  int v8; // r1
  int v9; // r10
  int v10; // r5
  int v11; // r3
  int v12; // r2
  int v13; // r0
  int v14; // r1
  int v15; // r2
  char *result; // r0
  int v19; // [sp+Ch] [bp-820h]
  char src[4]; // [sp+14h] [bp-818h] BYREF
  int v21; // [sp+18h] [bp-814h]
  int v22; // [sp+1Ch] [bp-810h]
  int v23; // [sp+20h] [bp-80Ch]
  int v24; // [sp+24h] [bp-808h]
  _DWORD v25[513]; // [sp+28h] [bp-804h] BYREF

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2 + 1;
      if ( *(_DWORD *)(dword_A0D68 + 4 * v2 + 4) == 1 )
        break;
      ++v2;
      if ( v3 == 16 )
        goto LABEL_13;
    }
    v25[0] = 123;
    memset(&v25[1], 0, 0x7FCu);
    *(_DWORD *)src = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    sprintf(src, "Chain%d:{", v2 + 1);
    v4 = (char *)stpcpy((char *)v25 + 1, src);
    v5 = 0;
    v6 = dword_A0D6C % 60 - 1;
    v7 = v6 - a2;
    do
    {
      v8 = v6 + (v6 < 0 ? 0x3C : 0);
      --v6;
      v5 += dword_A4DC8[9360 * v2 + 2 * v8];
    }
    while ( v7 != v6 );
    sprintf(src, "N%d=%d", 0, v5);
    strcpy(v4, src);
    if ( *(unsigned __int8 *)(dword_A0D68 + 12955) > 1u )
    {
      v19 = v2 + 1;
      v9 = 4680 * v2;
      v10 = 1;
      do
      {
        v11 = 0;
        v12 = dword_A0D6C % 60 - 1;
        v13 = v12 - a2;
        do
        {
          v14 = v12 + (v12 < 0 ? 0x3C : 0);
          --v12;
          v11 += dword_A4DC8[120 * v10 + 2 * v9 + 2 * v14];
        }
        while ( v13 != v12 );
        v15 = v10++;
        sprintf(src, ",N%d=%d", v15, v11);
        strcat((char *)v25, src);
      }
      while ( *(unsigned __int8 *)(dword_A0D68 + 12955) > v10 );
      v3 = v19;
    }
    v2 = v3;
    strcat((char *)v25, "},");
    strcat(a1, (const char *)v25);
  }
  while ( v3 != 16 );
LABEL_13:
  result = &a1[strlen(a1)];
  *(result - 1) = 0;
  return result;
}
// 12064: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// A0D68: using guessed type int dword_A0D68;
// A0D6C: using guessed type int dword_A0D6C;
// A4DC8: using guessed type _DWORD dword_A4DC8[74838];

//----- (000225B4) --------------------------------------------------------
void sub_225B4()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "This is fix-freq version\n");
  sub_47AB4(3, v0, 0);
}

//----- (000225FC) --------------------------------------------------------
int sub_225FC()
{
  int i; // r4
  int v1; // r0
  int v2; // r0
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v4, "****power off hashboard****\n");
    sub_47AB4(3, v4, 0);
  }
  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        goto LABEL_7;
    }
    v1 = (unsigned __int8)i;
    sub_1979C(v1);
  }
LABEL_7:
  sub_19E7C();
  v2 = sub_6F79C();
  return sub_6F7C4(v2 & 0xFFFFFFBF);
}
// 1979C: using guessed type int __fastcall sub_1979C(_DWORD);
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (000226B0) --------------------------------------------------------
int sub_226B0()
{
  return dword_A0D70;
}
// A0D70: using guessed type int dword_A0D70;

//----- (000226C0) --------------------------------------------------------
void __fastcall sub_226C0(unsigned int a1, const char *a2)
{
  const char *v2; // r9
  int v3; // r3
  unsigned int v4; // r4
  int v6; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  LOWORD(v3) = dword_9E31C;
  v4 = a1;
  dword_A0D70 = a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( a2 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( a1 > 0x10 )
    v2 = 0;
  else
    LOWORD(v3) = -25468;
  if ( a1 <= 0x10 )
  {
    HIWORD(v3) = 7;
    v2 = *(const char **)(v3 + 4 * a1);
  }
  snprintf(s, 0x800u, "%s\n", v2);
  sub_47AB4(3, s, 0);
  if ( !a2 )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_11;
    if ( v4 > 0x10 )
      v6 = 0;
    else
      v6 = 40068;
    if ( v4 <= 0x10 )
    {
      HIWORD(v6) = 7;
      v6 = *(_DWORD *)(v6 + 4 * v4);
    }
    snprintf(s, 0x800u, "%s\n", v6);
    goto LABEL_10;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%s: %s\n", v2, a2);
LABEL_10:
    sub_47AB4(3, s, 0);
  }
LABEL_11:
  v4 = dword_A0D70;
LABEL_12:
  switch ( v4 )
  {
    case 3u:
    case 4u:
    case 6u:
    case 8u:
    case 9u:
    case 0xBu:
    case 0xDu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( (unsigned int)dword_9E31C > 1 )
      {
        snprintf(s, 0x800u, "stop mining: %s\n", a2);
        sub_47AB4(1, s, 0);
      }
      sub_21D7C();
      sub_21AF8();
      sub_21CDC();
      sub_21C38();
      sub_225FC();
      while ( 1 )
        sleep(1u);
    case 5u:
    case 0xAu:
    case 0xCu:
      if ( (unsigned int)dword_9E31C > 1 )
      {
        snprintf(s, 0x800u, "stop mining: %s\n", a2);
        sub_47AB4(1, s, 0);
      }
      sub_21D7C();
      sub_21AF8();
      sub_21CDC();
      sub_21C38();
      sub_225FC();
      strcpy(s, "restart\n");
      sub_47AB4(0, s, 0);
      _assert_fail("0", "driver-btm-api.c", 0x91u, "stop_mining_and_restart");
      return;
    default:
      return;
  }
}
// 22784: control flows out of bounds to 22788
// 22720: variable 'v2' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// A0D70: using guessed type int dword_A0D70;

//----- (000228FC) --------------------------------------------------------
int sub_228FC()
{
  int v0; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = sub_16940();
  dword_241D20 = v0;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "Bring up temperature is %d\n", v0);
    sub_47AB4(3, v2, 0);
    v0 = dword_241D20;
  }
  if ( v0 >= -5 )
    return 0;
  sub_31794(9, 255);
  sub_226C0(0xFu, "Environment temperature is too low!");
  return -1;
}
// 9E31C: using guessed type int dword_9E31C;
// 241D20: using guessed type int dword_241D20;

//----- (00022990) --------------------------------------------------------
int __fastcall sub_22990(int a1)
{
  int v2; // r2
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v4, 0x800u, "Chain %d PIC reset failed.\n", a1);
    sub_47AB4(3, v4, 0);
  }
  v2 = dword_A0D68 + 12288;
  *(_DWORD *)(dword_A0D68 + 4 * a1 + 4) = 0;
  --*(_BYTE *)(v2 + 647);
  sub_31794(4, a1);
  sub_226C0(7u, "PIC reset failed.\n");
  return -1;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00022A2C) --------------------------------------------------------
int __fastcall sub_22A2C(int a1, int a2)
{
  if ( a1 > 12 )
    return 0;
  if ( (a1 & 1) != 0 )
  {
    ++a1;
    a2 = ~a2;
  }
  return a2 + 6 * a1;
}

//----- (00022A54) --------------------------------------------------------
int __fastcall sub_22A54(int result)
{
  dword_A0D74 = result;
  return result;
}
// A0D74: using guessed type int dword_A0D74;

//----- (00022A64) --------------------------------------------------------
unsigned int sub_22A64()
{
  return *(_DWORD *)dword_A0D74 & 0xFFFF0000 | (unsigned __int16)*(_DWORD *)dword_A0D74;
}
// A0D74: using guessed type int dword_A0D74;

//----- (00022A88) --------------------------------------------------------
int __fastcall sub_22A88(int a1)
{
  if ( !sub_19780((unsigned __int8)a1) )
    return sub_22990(a1);
  sub_197B8(a1);
  return 0;
}

//----- (00022AB8) --------------------------------------------------------
int sub_22AB8()
{
  int v0; // r4
  int v1; // r6
  int v2; // r0

  v0 = 0;
  v1 = 0;
  do
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * v0 + 4) != 1 )
    {
      if ( ++v0 == 16 )
        return v1;
    }
    v2 = v0++;
    v1 |= sub_22A88(v2);
  }
  while ( v0 != 16 );
  return v1;
}
// A0D68: using guessed type int dword_A0D68;

//----- (00022B10) --------------------------------------------------------
int sub_22B10()
{
  unsigned int v0; // r5
  int v1; // r2
  unsigned int v2; // r7
  int v3; // r9
  int v4; // r4
  unsigned int v5; // r6
  unsigned int v7; // [sp+14h] [bp+0h] BYREF
  char s[2052]; // [sp+18h] [bp+4h] BYREF

  v0 = 0;
  v1 = dword_A0D68;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0xFFFFFF;
  while ( 1 )
  {
    while ( *(_DWORD *)(v1 + 4 * v4 + 4) != 1 )
    {
      if ( ++v4 == 16 )
        goto LABEL_12;
    }
    if ( sub_18E08(v4, (unsigned __int8)dword_9EE38, &v7) )
      break;
    ++v2;
    v3 += v7;
    if ( v0 < v7 )
      v0 = v7;
    if ( v5 >= v7 )
      v5 = v7;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "voltage[%d] = %d\n", v4, v7);
      sub_47AB4(3, s, 0);
    }
    ++v4;
    v1 = dword_A0D68;
    if ( v4 == 16 )
      goto LABEL_12;
  }
  v1 = dword_A0D68;
LABEL_12:
  if ( v2 == *(unsigned __int8 *)(v1 + 12935) )
  {
    if ( v3 == v2 * sub_772E8(v3, v2) )
    {
      sub_1A0F0(v7);
      return 0;
    }
    else if ( (int)(v0 - v5) > 20 )
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        return -1;
      snprintf(s, 0x800u, "Different voltage, min = %d, max = %d, diff is too large.\n", v5, v0);
      sub_47AB4(3, s, 0);
      return -1;
    }
    else
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "Different voltage, min = %d, max = %d, use max one.\n", v5, v0);
        sub_47AB4(3, s, 0);
      }
      sub_1A0F0(v0);
      return 0;
    }
  }
  else
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return -1;
    strcpy(s, "Voltage read fail.\n");
    sub_47AB4(3, s, 0);
    return -1;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 9EE38: using guessed type int dword_9EE38;
// A0D68: using guessed type int dword_A0D68;

//----- (00022D34) --------------------------------------------------------
int sub_22D34()
{
  int v1; // r4
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( !byte_A0D78 || (byte_241D04 & 0x10) == 0 )
    return sub_22B10();
  v1 = *(unsigned __int16 *)(dword_A0D74 + 2);
  if ( (byte_241D05 & 8) == 0 )
    v1 = (unsigned __int16)word_241D0E;
  sub_1A0F0(v1);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "set fixed voltage raw to %d\n", v1);
    sub_47AB4(3, v2, 0);
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D74: using guessed type int dword_A0D74;
// A0D78: using guessed type char byte_A0D78;
// 241D04: using guessed type char byte_241D04;
// 241D05: using guessed type char byte_241D05;
// 241D0E: using guessed type __int16 word_241D0E;

//----- (00022DD8) --------------------------------------------------------
int sub_22DD8()
{
  unsigned __int8 *v0; // r4
  char *v2; // r3
  int v3; // r0
  int v4; // r12
  unsigned __int16 *v5; // r5
  int v6; // t1
  char *v7; // r2
  int v8; // r1

  LOWORD(v0) = 3432;
  if ( dword_9C294 == 2 )
  {
    HIWORD(v0) = 10;
    v2 = (char *)&unk_1371C4;
    v3 = *(_DWORD *)v0;
    v4 = *(_DWORD *)v0 + 64;
    v5 = (unsigned __int16 *)(*(_DWORD *)v0 + 12979);
    do
    {
      v6 = *(_DWORD *)(v3 + 4);
      v3 += 4;
      if ( v6 == 1 )
      {
        v8 = *v5;
        v7 = v2 + 312;
        do
        {
          *((_DWORD *)v2 + 1) = v8;
          v2 += 4;
        }
        while ( v2 != v7 );
      }
      else
      {
        v7 = v2 + 312;
      }
      v2 = v7;
    }
    while ( v3 != v4 );
  }
  else
  {
    HIWORD(v0) = 10;
  }
  return sub_30CAC((int)&unk_1371C8, v0[17], dword_9C298, 1);
}
// 9C294: using guessed type int dword_9C294;
// 9C298: using guessed type int dword_9C298;

//----- (00022E9C) --------------------------------------------------------
void __fastcall sub_22E9C(unsigned int a1, int a2, int a3)
{
  int v4; // r8
  unsigned int v5; // r3
  int v8; // r0
  unsigned int i; // r1
  unsigned int v10; // r4
  int v11; // r0
  unsigned int v12; // r8
  __int64 v13; // r2
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v4 = dword_A0D68;
  if ( *(_BYTE *)(dword_A0D68 + 12954) && (v5 = *(_DWORD *)(dword_A0D68 + 12950)) != 0 )
  {
    v8 = *(unsigned __int8 *)(dword_A0D68 + 12954) << 24;
    if ( v5 > 1 )
    {
      for ( i = 1; i < v5; i *= 2 )
        ;
      v8 = sub_772E8(v8, i);
    }
    v10 = v8 * a3 / 100;
    *(_DWORD *)(v4 + 68) = v10;
    v11 = v10 / a1;
    *(_DWORD *)(v4 + 72) = v10 / a1;
    if ( (byte_241D04 & 4) != 0 && word_241D12 )
    {
      v11 = HIBYTE(word_241D12) + 1000 * (unsigned __int8)word_241D12;
      *(_DWORD *)(v4 + 72) = v11;
    }
    v12 = (unsigned int)(v11 * a2) >> 2;
    sub_6FC8C(v12 & 0x1FFFF | 0x80000000);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "freq = %d, percent = %d, hcn = %d, timeout = %d\n", a1, a3, (a2 * v10) >> 2, v12);
      sub_47AB4(3, s, 0);
    }
  }
  else
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "Note: addrInterval or corenum is not initialized.\n");
      sub_47AB4(3, s, 0);
      v4 = dword_A0D68;
    }
    HIDWORD(v13) = (char *)&loc_1FFFC + 3;
    LODWORD(v13) = -1;
    *(_QWORD *)(v4 + 68) = v13;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 241D04: using guessed type char byte_241D04;
// 241D12: using guessed type __int16 word_241D12;

//----- (00023034) --------------------------------------------------------
void sub_23034()
{
  dword_9C294 = 2;
  byte_A0D78 = 1;
  if ( (unsigned int)dword_9E31C > 3 )
    sub_225B4();
}
// 9C294: using guessed type int dword_9C294;
// 9E31C: using guessed type int dword_9E31C;
// A0D78: using guessed type char byte_A0D78;

//----- (0002306C) --------------------------------------------------------
void sub_2306C()
{
  int i; // r4
  int v1; // r0
  int v2; // r0
  int v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  for ( i = 0; i != 16; ++i )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 && (unsigned int)dword_9E31C > 3 )
      {
        v1 = sub_189C8(i);
        snprintf(s, 0x800u, "Chain [%d] PCB Version: 0x%04x\n", i, v1);
        sub_47AB4(3, s, 0);
        if ( (unsigned int)dword_9E31C > 3 )
          break;
      }
      if ( ++i == 16 )
        return;
    }
    v2 = sub_18A54(i);
    v3 = i;
    snprintf(s, 0x800u, "Chain [%d] BOM Version: 0x%04x\n", v3, v2);
    sub_47AB4(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00023150) --------------------------------------------------------
char *sub_23150()
{
  int v0; // r4
  char *result; // r0
  unsigned int v2; // r7
  int v3; // r1
  unsigned int *v4; // r5
  unsigned int *v5; // lr
  char i; // r12
  unsigned int v7; // t1
  unsigned int v8[73]; // [sp+4h] [bp-124h] BYREF

  *(_BYTE *)(dword_A0D68 + 12935) = 0;
  sub_66410(v8);
  sub_22088(v8);
  v0 = dword_A0D68;
  result = (char *)memset((void *)(dword_A0D68 + 4), 0, 0x40u);
  v2 = v8[0];
  *(_BYTE *)(v0 + 12935) = 0;
  if ( v2 )
  {
    v3 = 0;
    v4 = v8;
    do
    {
      if ( v4[2] )
      {
        v5 = v4 + 2;
        result = 0;
        for ( i = *(_BYTE *)(v0 + 12935) + 1; ; ++i )
        {
          v7 = v5[1];
          ++v5;
          ++result;
          *(_DWORD *)(v0 + 4 * v7 + 4) = 1;
          if ( v4[2] <= (unsigned int)result )
            break;
        }
        *(_BYTE *)(v0 + 12935) = i;
      }
      ++v3;
      v4 += 18;
    }
    while ( v3 != v2 );
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0002321C) --------------------------------------------------------
int sub_2321C()
{
  char v1[68]; // [sp+0h] [bp-44h] BYREF

  memset(v1, 0, 0x40u);
  sprintf(v1, "echo %d > %s", 0, "/sys/class/gpio/gpio941/value");
  system(v1);
  memset(v1, 0, 0x40u);
  sprintf(v1, "echo %d > %s", 0, "/sys/class/gpio/gpio942/value");
  return system(v1);
}

//----- (00023298) --------------------------------------------------------
int sub_23298()
{
  int v0; // r0
  char v1; // r2
  int result; // r0
  int v3; // r2
  char v4[64]; // [sp+0h] [bp-40h] BYREF

  v0 = sub_36C34();
  if ( dword_9C294 )
  {
    switch ( dword_A0D70 )
    {
      case 1:
        memset(v4, 0, sizeof(v4));
        sprintf(v4, "echo %d > %s", 0, "/sys/class/gpio/gpio941/value");
        system(v4);
        memset(v4, 0, sizeof(v4));
        v1 = byte_9C29C;
        goto LABEL_6;
      case 2:
      case 5:
        memset(v4, 0, sizeof(v4));
        sprintf(v4, "echo %d > %s", 0, "/sys/class/gpio/gpio941/value");
        system(v4);
        memset(v4, 0, sizeof(v4));
        sprintf(v4, "echo %d > %s", 1, "/sys/class/gpio/gpio942/value");
        return system(v4);
      case 6:
        memset(v4, 0, sizeof(v4));
        sprintf(v4, "echo %d > %s");
        goto LABEL_9;
      default:
        memset(v4, 0, sizeof(v4));
        byte_9C29C ^= 1u;
        sprintf(v4, "echo %d > %s");
LABEL_9:
        system(v4);
        memset(v4, 0, sizeof(v4));
        sprintf(v4, "echo %d > %s", 0, "/sys/class/gpio/gpio942/value");
        result = system(v4);
        break;
    }
  }
  else if ( v0 )
  {
    if ( v0 == 1 )
    {
      memset(v4, dword_9C294, sizeof(v4));
      v3 = (unsigned __int8)byte_9C29C;
      byte_9C29C ^= 1u;
      sprintf(v4, "echo %d > %s", v3, "/sys/class/gpio/gpio941/value");
    }
    else
    {
      memset(v4, dword_9C294, sizeof(v4));
      sprintf(v4, "echo %d > %s", 0, "/sys/class/gpio/gpio941/value");
    }
    system(v4);
    memset(v4, 0, sizeof(v4));
    v1 = byte_9C29C;
LABEL_6:
    byte_9C29C = v1 ^ 1;
    sprintf(v4, "echo %d > %s");
    return system(v4);
  }
  else
  {
    memset(v4, 0, sizeof(v4));
    sprintf(v4, "echo %d > %s", 1, "/sys/class/gpio/gpio941/value");
    system(v4);
    memset(v4, 0, sizeof(v4));
    sprintf(v4, "echo %d > %s", 0, "/sys/class/gpio/gpio942/value");
    return system(v4);
  }
  return result;
}
// 23368: control flows out of bounds to 2336C
// 9C294: using guessed type int dword_9C294;
// 9C29C: using guessed type char byte_9C29C;
// A0D70: using guessed type int dword_A0D70;

//----- (00023590) --------------------------------------------------------
int sub_23590()
{
  int v0; // r12
  int i; // r5
  int v2; // r8
  unsigned int v3; // r4
  int v4; // r11
  bool v5; // cc
  int v6; // r1
  _DWORD *v7; // r3
  int v8; // r10
  int v9; // r9
  int result; // r0
  _BYTE *v11; // r6
  int v12; // r11
  int v13; // r3
  int v14; // t1
  char *v15; // r8
  int v16; // r12
  int v17; // r0
  int v18; // lr
  unsigned int v19; // r3
  int v20; // r10
  int v21; // r2
  unsigned int v22; // r7
  int v23; // r4
  int v24; // r5
  int v25; // r2
  int v26; // r2
  _WORD *v27; // r2
  int v28; // r12
  int v29; // [sp+10h] [bp-824h]
  int v30; // [sp+14h] [bp-820h]
  int v31; // [sp+1Ch] [bp-818h]
  int v32; // [sp+20h] [bp-814h]
  char s[2052]; // [sp+30h] [bp-804h] BYREF

  v0 = dword_A0D6C;
  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 && *(_BYTE *)(dword_A0D68 + i + 12918) )
    {
      v2 = 78 * i;
      v3 = 0;
      v4 = dword_A0D68;
      do
      {
        v5 = (unsigned int)dword_9E31C > 4;
        v6 = *(_DWORD *)(v4 + 8 * (v2 + v3) + 1274);
        v7 = &dword_A4DC8[9360 * i + 120 * v3 + 2 * (v0 % 60)];
        *v7 = *(_DWORD *)(v4 + 8 * (v2 + v3) + 1270);
        v7[1] = v6;
        if ( v5 )
        {
          snprintf(s, 0x800u, "chain %u asic %u asic_nonce_num %llu\n", i, v3, *(_QWORD *)(v4 + 8 * (v2 + v3) + 1270));
          sub_47AB4(4, s, 0);
          v0 = dword_A0D6C;
        }
        v4 = dword_A0D68;
        ++v3;
      }
      while ( *(unsigned __int8 *)(dword_A0D68 + i + 12918) > v3 );
    }
  }
  dword_A0D6C = v0 + 1;
  memset(byte_245234, 0, 0x1000u);
  memset(byte_2440FC, 0, 0x1000u);
  memset(byte_243004, 0, sizeof(byte_243004));
  v8 = 0;
  sub_2236C(byte_245234, 10);
  sub_2236C(byte_2440FC, 30);
  sub_2236C(byte_243004, 60);
  v9 = dword_A0D68;
  result = -2004318071 * dword_A0D6C;
  v29 = dword_A0D68 + 64;
  v11 = (_BYTE *)(dword_A0D68 + 12918);
  v12 = dword_A0D68;
  v13 = dword_A0D6C % 60 - 1;
  if ( v13 < 0 )
    v13 = dword_A0D6C % 60 + 59;
  v32 = v13;
  do
  {
    v14 = *(_DWORD *)(v12 + 4);
    v12 += 4;
    if ( v14 == 1 )
    {
      if ( *v11 )
      {
        v30 = 2 * v8;
        v15 = (char *)&unk_A0DC8 + 1024 * v8;
        v16 = 0;
        v17 = v32 + 4680 * v8;
        v31 = v8;
        v18 = v9 + 97 * v8;
        v19 = 0;
        v20 = 78 * v8;
        result = (int)&dword_A4DC8[2 * v17];
        do
        {
          v21 = v19 + v16;
          v22 = v18 + v19 + v16;
          result += 480;
          if ( v19 == 6 * (v19 / 6) )
          {
            ++v16;
            *(_BYTE *)(v22 + 11254) = 32;
            v21 = v19 + v16;
          }
          v23 = *(_DWORD *)(result - 480);
          v24 = v18 + v21;
          if ( v23 > 1 )
          {
            LOBYTE(v25) = 111;
          }
          else
          {
            v25 = v18 + v21;
            *(_BYTE *)(v25 + 11254) = 111;
          }
          if ( v23 > 1 )
            *(_BYTE *)(v24 + 11254) = v25;
          else
            ++*(_DWORD *)&v15[4 * v19];
          v26 = v20 + v19++ + 158;
          v27 = (_WORD *)(v9 + 8 * v26);
          v27[3] = 0;
          v27[4] = 0;
          v27[5] = 0;
          v27[6] = 0;
        }
        while ( (unsigned __int8)*v11 > v19 );
        v28 = v19 + v16;
        v8 = v31;
      }
      else
      {
        v28 = (unsigned __int8)*v11;
        v30 = 2 * v8;
      }
      *(_BYTE *)(v9 + v8 + 32 * (v30 + v8) + v28 + 11254) = 0;
    }
    ++v8;
    ++v11;
  }
  while ( v29 != v12 );
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// A0D6C: using guessed type int dword_A0D6C;
// A4DC8: using guessed type _DWORD dword_A4DC8[74838];

//----- (000239C4) --------------------------------------------------------
int sub_239C4()
{
  int v0; // r3
  int v1; // r4
  int v2; // r7
  unsigned int v3; // r1
  int v4; // r2
  int v5; // r3
  int v7; // [sp+8h] [bp-80Ch]
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v0 = dword_A0D68;
  v1 = 0;
  v7 = 0;
  *(_BYTE *)(dword_A0D68 + 12955) = 0;
  while ( *(_DWORD *)(v0 + 4 * v1 + 4) != 1 )
  {
LABEL_2:
    if ( ++v1 == 16 )
      return v7;
LABEL_3:
    v0 = dword_A0D68;
  }
  v2 = 0;
  do
  {
    sub_70974(v1);
    sleep(3u);
    sub_19798((unsigned __int8)v1);
    sub_4A804();
    sub_709B8(v1);
    sub_4A804();
    sub_2EA28(v1, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "Chain[%d]: find %d asic, times %d\n", v1, *(unsigned __int8 *)(dword_A0D68 + v1 + 12918), v2);
      sub_47AB4(3, s, 0);
    }
    ++v2;
    if ( *(_BYTE *)(dword_A0D68 + v1 + 12918) == 78 )
    {
      if ( *(unsigned __int8 *)(dword_A0D68 + 12955) <= 0x4Du )
        *(_BYTE *)(dword_A0D68 + 12955) = 78;
      goto LABEL_2;
    }
    sub_22A88(v1);
  }
  while ( v2 != 3 );
  v3 = *(unsigned __int8 *)(dword_A0D68 + v1 + 12918);
  if ( *(unsigned __int8 *)(dword_A0D68 + 12955) < v3 )
    *(_BYTE *)(dword_A0D68 + 12955) = v3;
  if ( v3 == 78 )
    goto LABEL_2;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "Chain %d only find %d asic, will power off hash board %d\n", v1, v3, v1);
    sub_47AB4(3, s, 0);
  }
  sub_1979C((unsigned __int8)v1);
  v4 = dword_9C294;
  v5 = dword_A0D68 + 12288;
  *(_DWORD *)(dword_A0D68 + 4 * v1 + 4) = 0;
  --*(_BYTE *)(v5 + 647);
  if ( v4 != 1 )
  {
    sub_31794(1, 255);
    sub_226C0(9u, "Cannot find all asic!");
    return -1;
  }
  ++v1;
  v7 = -1;
  if ( v1 != 16 )
    goto LABEL_3;
  return v7;
}
// 19798: using guessed type int __fastcall sub_19798(_DWORD);
// 1979C: using guessed type int __fastcall sub_1979C(_DWORD);
// 9C294: using guessed type int dword_9C294;
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00023BF0) --------------------------------------------------------
int sub_23BF0()
{
  int v0; // r0
  int v1; // r5
  int v2; // r4
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  sub_6FB84(byte_241D24, 0x20u);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "miner ID : %s\n", byte_241D24);
    sub_47AB4(3, s, 0);
  }
  v0 = sub_70CC0();
  v1 = BYTE2(v0);
  v2 = (unsigned __int8)v0;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "FPGA Version = 0x%04X\n", (unsigned __int16)v0);
    sub_47AB4(3, s, 0);
  }
  return sprintf(byte_1B0A18, "%d.%d.%d.%d", v2, v1, 1, 3);
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00023CC8) --------------------------------------------------------
int sub_23CC8()
{
  _DWORD *v0; // r0

  if ( dword_A0D68 )
  {
    memset((void *)dword_A0D68, 0, 0x3368u);
    v0 = (_DWORD *)dword_A0D68;
LABEL_3:
    v0[3239] = 115200;
    *((_WORD *)v0 + 6475) = 96;
    *((_WORD *)v0 + 6476) = 0;
    sub_222E8();
    return 0;
  }
  v0 = calloc(0x3368u, 1u);
  dword_A0D68 = (int)v0;
  if ( v0 )
    goto LABEL_3;
  return -1;
}
// A0D68: using guessed type int dword_A0D68;

//----- (00023D44) --------------------------------------------------------
void sub_23D44()
{
  sub_4A60C((struct timeval *)&dword_A0D7C);
  sub_63D74();
}
// A0D7C: using guessed type int dword_A0D7C;

//----- (00023D5C) --------------------------------------------------------
size_t __fastcall sub_23D5C(_DWORD *a1, int a2, int a3)
{
  char v4; // r3
  char v5; // r2
  int v6; // r3
  unsigned __int8 *v7; // r1
  int v8; // r0
  char *v9; // r9
  size_t v10; // r4
  size_t v11; // r2
  int v12; // r1
  __int64 v13; // r6
  int v14; // r10
  size_t v15; // r11
  void *v16; // r0
  int v17; // r6
  _DWORD **v18; // lr
  size_t v19; // r4
  _DWORD **v20; // r3
  _DWORD *v21; // t1
  int v22; // r12
  int v23; // r0
  int v24; // r1
  int v25; // r12
  int v26; // r0
  int v27; // r1
  __int16 v28; // r0
  __int64 v29; // kr00_8
  void *v30; // r0
  __int64 src; // [sp+8h] [bp-864h] BYREF
  _DWORD v34[22]; // [sp+10h] [bp-85Ch] BYREF
  char v35[2052]; // [sp+68h] [bp-804h] BYREF

  v4 = BYTE1(v34[2]) & 0xFE | *(_BYTE *)(a2 + 680) & 1;
  v34[3] = a3;
  BYTE1(v34[2]) = v4 | 2;
  src = 0;
  v5 = 82;
  LOWORD(v34[0]) = 82;
  v6 = 15;
  if ( byte_A0D90 )
    v5 = *(_BYTE *)(a2 + 644);
  BYTE2(v34[2]) = 15;
  if ( byte_A0D90 )
  {
    v6 = *(_DWORD *)(a2 + 648);
    LOBYTE(v34[20]) = v5;
  }
  LOBYTE(v34[2]) = qword_A0D88;
  v7 = (unsigned __int8 *)(a2 + 1780);
  if ( byte_A0D90 )
    v34[21] = v6;
  sub_49940(&v34[4], v7, 4);
  sub_49940(&v34[5], (unsigned __int8 *)(a2 + 1712), 32);
  sub_49940(&v34[14], (unsigned __int8 *)(a2 + 1792), 4);
  sub_49940(&v34[13], (unsigned __int8 *)(a2 + 1804), 4);
  v8 = *(_DWORD *)(a2 + 1576);
  v9 = *(char **)(a2 + 1568);
  v10 = *(_DWORD *)(a2 + 1572);
  v11 = *(_DWORD *)(a2 + 632);
  HIWORD(v34[15]) = v8;
  LOWORD(v34[15]) = v10;
  LOWORD(v34[16]) = v11;
  v12 = *(_DWORD *)&v9[v8 + 4];
  v13 = *(_QWORD *)(a2 + 624);
  v34[18] = *(_DWORD *)&v9[v8];
  v34[19] = v12;
  src = v13;
  memcpy(&v34[18], &src, v11);
  v14 = *(_DWORD *)(a2 + 1708);
  HIWORD(v34[16]) = v14;
  v15 = v10 + 32 * v14;
  v16 = malloc(v15 + 90);
  v17 = (int)v16;
  if ( !v16 )
  {
    strcpy(v35, "Failed to malloc tmp_buf");
    sub_47AB4(3, v35, 1);
    sub_62EC0(1);
  }
  v34[1] = v15 + 82;
  memset(v16, 0, v15 + 90);
  memcpy((void *)v17, v34, 0x58u);
  memcpy((void *)(v17 + 88), v9, v10);
  if ( v14 > 0 )
  {
    v18 = *(_DWORD ***)(a2 + 676);
    v19 = v17 + v10 + 88;
    v20 = &v18[v14];
    do
    {
      v21 = *v18++;
      v19 += 32;
      v22 = v21[1];
      v23 = v21[2];
      v24 = v21[3];
      *(_DWORD *)(v19 - 32) = *v21;
      *(_DWORD *)(v19 - 28) = v22;
      *(_DWORD *)(v19 - 24) = v23;
      *(_DWORD *)(v19 - 20) = v24;
      v25 = v21[5];
      v26 = v21[6];
      v27 = v21[7];
      *(_DWORD *)(v19 - 16) = v21[4];
      *(_DWORD *)(v19 - 12) = v25;
      *(_DWORD *)(v19 - 8) = v26;
      *(_DWORD *)(v19 - 4) = v27;
    }
    while ( v18 != v20 );
  }
  v28 = sub_514F8(v17, (unsigned __int16)(v15 + 88));
  v29 = qword_A0D88;
  *(_WORD *)(v17 + v15 + 88) = v28;
  qword_A0D88 = v29 + 1;
  v30 = malloc(v15 + 90);
  *a1 = v30;
  memcpy(v30, (const void *)v17, v15 + 90);
  free((void *)v17);
  return v15 + 90;
}
// A0D88: using guessed type __int64 qword_A0D88;
// A0D90: using guessed type char byte_A0D90;

//----- (00023FD4) --------------------------------------------------------
int __fastcall sub_23FD4(unsigned __int8 *a1)
{
  int *v1; // r9
  int v4; // r7
  size_t v5; // r7
  _DWORD *v6; // r0
  _DWORD *v7; // r6
  int v8; // r2
  char v9; // r2
  int v10; // r3
  int v11; // r0
  int v12; // r3
  unsigned int v13; // r3
  int v14; // r1
  int v15; // r2
  int v16; // lr
  int v17; // r0
  int v18; // r0
  __int64 v19; // r2
  int v20; // r0
  int v21; // r3
  bool v22; // zf
  int v23; // r0
  int v24; // r0
  _DWORD v25[14]; // [sp+8h] [bp-848h] BYREF
  __int64 v26; // [sp+40h] [bp-810h]
  unsigned int v27; // [sp+48h] [bp-808h]
  int v28; // [sp+4Ch] [bp-804h]
  char s[2048]; // [sp+50h] [bp-800h] BYREF

  if ( *a1 == 82 )
  {
    v4 = *((_DWORD *)a1 + 1);
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf(s, 0x800u, "%s: len = 0x%x\n", "dhash_chip_send_job", *((_DWORD *)a1 + 1));
      sub_47AB4(7, s, 0);
    }
    v5 = v4 + 8;
    v6 = calloc(v5, 1u);
    v7 = v6;
    if ( v6 )
    {
      memcpy(v6, a1, v5);
      if ( byte_A0D90 )
      {
        v21 = *((unsigned __int8 *)v7 + 80);
        v22 = v21 == 0;
        if ( *((_BYTE *)v7 + 80) )
        {
          v21 = v7[21];
        }
        else
        {
          v1 = &dword_9EE34;
          v8 = 1;
        }
        if ( v22 )
        {
          v21 = v8;
          *v1 = v8;
        }
        else
        {
          v1 = &dword_9EE34;
          dword_9EE34 = v21;
        }
        if ( dword_9C2A0 != v21 )
        {
          if ( (unsigned int)dword_9E31C > 3 )
          {
            snprintf(s, 0x800u, "Version num %d\n", v21);
            sub_47AB4(3, s, 0);
            v21 = *v1;
          }
          dword_9C2A0 = v21;
        }
      }
      else
      {
        v1 = &dword_9EE34;
      }
      v9 = *((_BYTE *)v7 + 9);
      if ( (v9 & 2) != 0 )
      {
        sub_6FE4C(*((unsigned __int8 *)v7 + 10));
        v10 = dword_A0D68;
        *(_BYTE *)(dword_A0D68 + 12976) = *((_BYTE *)v7 + 10);
        v9 = *((_BYTE *)v7 + 9);
      }
      else
      {
        v10 = dword_A0D68;
      }
      v11 = *v1;
      v12 = *(_DWORD *)(v10 + 72);
      v28 = v9 & 1;
      v25[1] = v11;
      v13 = v12 * v11;
      v14 = *((unsigned __int16 *)v7 + 30);
      v25[9] = v7[4];
      v15 = *((unsigned __int16 *)v7 + 32);
      v16 = *((unsigned __int16 *)v7 + 33);
      v25[8] = v7[3];
      v17 = v7[14];
      v27 = v13 >> 2;
      v25[13] = v15;
      v25[7] = v17;
      v18 = *((unsigned __int16 *)v7 + 31);
      v25[10] = v7 + 5;
      v19 = *((_QWORD *)v7 + 9);
      v25[12] = v18;
      v20 = v7[13];
      v25[3] = v14;
      v25[2] = a1 + 88;
      v25[4] = &a1[v14 + 88];
      v25[5] = v16;
      v26 = v19;
      v25[11] = 32;
      v25[6] = v20;
      v25[0] = 0;
      if ( !byte_A0D91 )
      {
        v23 = sub_702AC();
        sub_702CC(v23 | 0x10000);
        v24 = sub_6F79C();
        sub_6F7C4(v24 | 0x80);
        byte_A0D91 = 1;
      }
      if ( (unsigned int)dword_9E31C > 4 )
      {
        snprintf(s, 0x800u, "start to send job, mid_auto_gen = %d", v25[0]);
        sub_47AB4(4, s, 0);
      }
      sub_70330((int)v25);
      free(v7);
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        snprintf(s, 0x800u, "--- %s end\n", "dhash_chip_send_job");
        sub_47AB4(7, s, 0);
      }
      sub_4A60C((struct timeval *)&dword_A0D7C);
      sub_4A804();
      return 0;
    }
    else if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf(s, 0x800u, "%s: malloc buffer failed.\n", "dhash_chip_send_job");
      sub_47AB4(7, s, 0);
      return -2;
    }
    else
    {
      return -2;
    }
  }
  else if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(s, 0x800u, "%s: SEND_JOB_TYPE is wrong : 0x%x\n", "dhash_chip_send_job", *a1);
    sub_47AB4(7, s, 0);
    return -1;
  }
  else
  {
    return -1;
  }
}
// 2414C: variable 'v1' is possibly undefined
// 24320: variable 'v8' is possibly undefined
// 9C2A0: using guessed type int dword_9C2A0;
// 9E31C: using guessed type int dword_9E31C;
// 9E320: using guessed type int dword_9E320;
// 9EE34: using guessed type int dword_9EE34;
// A0D68: using guessed type int dword_A0D68;
// A0D7C: using guessed type int dword_A0D7C;
// A0D90: using guessed type char byte_A0D90;
// A0D91: using guessed type char byte_A0D91;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (00024418) --------------------------------------------------------
unsigned int sub_24418()
{
  sub_6FB14();
  sub_7090C(15);
  return sleep(2u);
}

//----- (00024434) --------------------------------------------------------
int __fastcall sub_24434(int result, int a2)
{
  pthread_mutex_t *v2; // r8
  int v3; // r4
  int v5; // r7
  size_t v6; // r5
  void *v7; // r0
  int v8; // r5
  void *v9; // r0
  int v10; // lr
  int v11; // r12
  _DWORD *v12; // r11
  int v13; // r5
  int v14; // r10
  _DWORD *v15; // r3
  _DWORD *v16; // r2
  int v17; // r12
  int v18; // r0
  int v19; // r1
  int v20; // r12
  int v21; // r0
  int v22; // r1
  int *v23; // r0
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  char s[2088]; // [sp+10h] [bp-828h] BYREF

  if ( *(_DWORD *)(a2 + 672) )
  {
    v2 = (pthread_mutex_t *)(result + 212);
    v3 = result;
    v5 = *(_DWORD *)(a2 + 1708);
    v6 = *(_DWORD *)(a2 + 1572);
    if ( pthread_mutex_lock((pthread_mutex_t *)(result + 212)) )
    {
      v24 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v24,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1216);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 236)) )
    {
      v25 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v25,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1216);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    free(*(void **)(v3 + 672));
    free(*(void **)(v3 + 612));
    free(*(void **)(v3 + 1568));
    if ( (v6 & 3) != 0 )
      v6 = (v6 & 0xFFFFFFFC) + 4;
    v7 = calloc(v6, 1u);
    *(_DWORD *)(v3 + 1568) = v7;
    if ( !v7 )
    {
      strcpy(s, "Failed to calloc pool_stratum coinbase in c5");
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    memcpy(v7, *(const void **)(a2 + 1568), v6);
    if ( *(int *)(v3 + 1708) > 0 )
    {
      v8 = 0;
      do
      {
        v9 = *(void **)(*(_DWORD *)(v3 + 676) + 4 * v8++);
        free(v9);
      }
      while ( *(_DWORD *)(v3 + 1708) > v8 );
    }
    if ( v5 )
    {
      v12 = realloc(*(void **)(v3 + 676), 4 * v5 + 1);
      *(_DWORD *)(v3 + 676) = v12;
      if ( v5 > 0 )
      {
        v13 = 0;
        while ( 1 )
        {
          v14 = 4 * v13;
          v12[v13] = malloc(0x20u);
          v15 = *(_DWORD **)(*(_DWORD *)(v3 + 676) + 4 * v13);
          if ( !v15 )
          {
            strcpy(s, "Failed to malloc pool_stratum swork merkle_bin");
            sub_47AB4(3, s, 1);
            sub_62EC0(1);
          }
          ++v13;
          v16 = *(_DWORD **)(*(_DWORD *)(a2 + 676) + v14);
          v17 = v16[1];
          v18 = v16[2];
          v19 = v16[3];
          *v15 = *v16;
          v15[1] = v17;
          v15[2] = v18;
          v15[3] = v19;
          v20 = v16[5];
          v21 = v16[6];
          v22 = v16[7];
          v15[4] = v16[4];
          v15[5] = v20;
          v15[6] = v21;
          v15[7] = v22;
          if ( v5 == v13 )
            break;
          v12 = *(_DWORD **)(v3 + 676);
        }
      }
    }
    *(_DWORD *)v3 = *(_DWORD *)a2;
    *(_QWORD *)(v3 + 1824) = *(_QWORD *)(a2 + 1824);
    *(_DWORD *)(v3 + 1572) = *(_DWORD *)(a2 + 1572);
    *(_DWORD *)(v3 + 1576) = *(_DWORD *)(a2 + 1576);
    *(_DWORD *)(v3 + 632) = *(_DWORD *)(a2 + 632);
    *(_DWORD *)(v3 + 1708) = *(_DWORD *)(a2 + 1708);
    *(_DWORD *)(v3 + 672) = _strdup(*(const char **)(a2 + 672));
    *(_DWORD *)(v3 + 612) = _strdup(*(const char **)(a2 + 612));
    v10 = *(_DWORD *)(a2 + 1808);
    v11 = *(_DWORD *)(a2 + 1812);
    *(_DWORD *)(v3 + 1804) = *(_DWORD *)(a2 + 1804);
    *(_DWORD *)(v3 + 1808) = v10;
    *(_DWORD *)(v3 + 1812) = v11;
    memcpy((void *)(v3 + 1580), (const void *)(a2 + 1580), 0x80u);
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 236)) )
    {
      v26 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v26,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1254);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    if ( pthread_mutex_unlock(v2) )
    {
      v23 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v23,
        "driver-btm-api.c",
        "copy_pool_stratum",
        1254);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    return off_9E444();
  }
  return result;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (00024848) --------------------------------------------------------
int __fastcall sub_24848(int result)
{
  dword_A0D94 = result;
  return result;
}
// A0D94: using guessed type int dword_A0D94;

//----- (00024858) --------------------------------------------------------
int sub_24858()
{
  int v0; // r12
  char s; // [sp+8h] [bp-804h] BYREF

  v0 = dword_A0D94;
  if ( dword_A0D94 && (unsigned int)dword_9E31C > 3 )
  {
    snprintf(
      &s,
      0x800u,
      "pulse_mode = %d, ccdly_sel = %d, pwth_sel = %d\n",
      *(unsigned __int8 *)dword_A0D94,
      *(unsigned __int8 *)(dword_A0D94 + 2),
      *(unsigned __int8 *)(dword_A0D94 + 1));
    sub_47AB4(3, &s, 0);
    v0 = dword_A0D94;
  }
  return (unsigned __int8)*(_WORD *)v0
       | (unsigned __int16)((unsigned __int8)HIBYTE(*(_WORD *)v0) << 8)
       | (*(unsigned __int8 *)(v0 + 2) << 16);
}
// 9E31C: using guessed type int dword_9E31C;
// A0D94: using guessed type int dword_A0D94;

//----- (00024904) --------------------------------------------------------
void sub_24904()
{
  int v0; // r0
  __int16 v1; // [sp+4h] [bp-8h]
  char v2; // [sp+6h] [bp-6h]

  v0 = sub_24858();
  v2 = BYTE2(v0);
  v1 = v0;
  sub_1A850();
  sub_1AE00();
  sub_4A804();
  sub_1ACE4();
  sub_4A804();
  sub_1B0EC(255, v1);
  sub_1B138(255, SHIBYTE(v1), v2, 0);
  sub_4A804();
  sub_1AC10(0xFFu);
  sub_4A804();
  sub_1A958(255, 0, 1, 3);
  sub_1A9D4(255);
  sub_1B298(255, 0);
}

//----- (000249A8) --------------------------------------------------------
int sub_249A8()
{
  return 0;
}

//----- (000249B0) --------------------------------------------------------
int sub_249B0()
{
  int v0; // r3
  int v1; // r12
  int v3; // r4
  unsigned int v4; // r0
  int v5; // r3
  char v6[2052]; // [sp+0h] [bp-804h] BYREF

  sub_24418();
  sub_13EE8(100);
  sub_6FBE0(0x40000000);
  sub_23BF0();
  sub_70B9C();
  sub_23150();
  v0 = dword_A0D68;
  v1 = *(unsigned __int8 *)(dword_A0D68 + 12935);
  if ( !*(_BYTE *)(dword_A0D68 + 12935) )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v6, "No chain exist, exit.\n");
      sub_47AB4(3, v6, v1);
    }
    return -1;
  }
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
  {
    snprintf(v6, 0x800u, "chain num = %d", *(unsigned __int8 *)(dword_A0D68 + 12935));
    sub_47AB4(5, v6, 0);
    v0 = dword_A0D68;
  }
  v3 = 0;
  while ( 1 )
  {
    v4 = (unsigned __int8)v3;
    v5 = *(_DWORD *)(v0 + 4 * v3++ + 4);
    if ( v5 == 1 )
      break;
    if ( v3 == 16 )
      goto LABEL_13;
LABEL_10:
    v0 = dword_A0D68;
  }
  sub_748C0(v4);
  if ( v3 != 16 )
    goto LABEL_10;
LABEL_13:
  sub_185FC(1);
  if ( sub_188CC() )
    return 0;
  if ( dword_9C294 != 1 )
    sub_31794(3, 255);
  if ( (unsigned int)dword_9E31C <= 3 )
    return -1;
  strcpy(v6, "Fixture data load failed, exit.\n");
  sub_47AB4(3, v6, 0);
  return -1;
}
// 9C294: using guessed type int dword_9C294;
// 9E31C: using guessed type int dword_9E31C;
// 9E320: using guessed type int dword_9E320;
// A0D68: using guessed type int dword_A0D68;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00024B88) --------------------------------------------------------
int sub_24B88()
{
  int v0; // r4
  int v2; // r5
  int v3; // r2
  int i; // r4
  int v5; // r0
  unsigned int v6; // r4
  int v7; // r0
  int v8; // r9
  int v9; // r4
  int v10; // r3
  _BYTE *v11; // r3
  int v12; // r12
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( sub_3C4FC(0) )
  {
    if ( (dword_9C294 == 1 || !dword_9C294 && sub_344E0()) && !sub_188E0() )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        v0 = -1;
        strcpy(s, "Miner data load failed, exit.\n");
        sub_47AB4(3, s, 0);
        return v0;
      }
      return -1;
    }
    v2 = 0;
    v3 = dword_A0D68;
    for ( i = 0; i != 16; ++i )
    {
      while ( *(_DWORD *)(v3 + 4 * i + 4) != 1 )
      {
        if ( ++i == 16 )
          goto LABEL_13;
      }
      v5 = sub_18AE0(i);
      v2 += v5;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "product_id[%d] = %d\n", i, v5);
        sub_47AB4(3, s, 0);
      }
      v3 = dword_A0D68;
    }
LABEL_13:
    v6 = *(unsigned __int8 *)(v3 + 12935);
    v7 = sub_772E8(v2, v6);
    if ( v7 * v6 == v2 )
    {
      if ( v7 != 255 )
      {
        dword_9C2A4 = v7;
        sub_2306C();
        if ( dword_242F4C > 0 )
        {
          v8 = 0;
          v9 = 0;
          do
          {
            v10 = *(_DWORD *)(dword_244048 + 4 * v9);
            if ( **(_BYTE **)(v10 + 164) )
            {
              v11 = *(_BYTE **)(v10 + 172);
              v12 = (unsigned __int8)*v11;
              if ( *v11 )
              {
                ++v8;
              }
              else if ( (unsigned int)dword_9E31C > 3 )
              {
                strcpy(s, "Blank worker exists.\n");
                sub_47AB4(3, s, v12);
              }
            }
            ++v9;
          }
          while ( v9 < dword_242F4C );
          if ( v8 )
          {
            v0 = sub_13C54(0xFA0u);
            if ( !v0 )
            {
              if ( (unsigned int)dword_9E31C > 3 )
              {
                strcpy(s, "Fan check passed.\n");
                sub_47AB4(3, s, 0);
              }
              v0 = sub_22AB8();
              if ( !v0 || *(_BYTE *)(dword_A0D68 + 12935) && dword_9C294 )
              {
                sub_21690();
                v0 = sub_19E90();
                if ( !v0 )
                {
                  if ( (unsigned int)dword_9E31C > 3 )
                  {
                    snprintf(s, 0x800u, "Enter %ds sleep to make sure power release finish.\n", 30);
                    sub_47AB4(3, s, 0);
                  }
                  sub_19E7C();
                  sleep(0x1Eu);
                  sub_19E68();
                  v0 = sub_1A300();
                  if ( !v0 )
                  {
                    sub_6F7C4(33792);
                    sub_6FD34();
                    sub_4A804();
                    sub_21E78(115200);
                    sub_4A804();
                    v0 = sub_239C4();
                    if ( !v0 || *(_BYTE *)(dword_A0D68 + 12935) && dword_9C294 )
                    {
                      v0 = sub_1A420();
                      if ( !v0 )
                      {
                        sub_24904();
                        dword_1AEA10 = 0;
                        dword_1AEA18 = 0;
                        dword_1AEA14 = 0;
                      }
                    }
                  }
                }
              }
            }
            return v0;
          }
        }
        if ( (unsigned int)dword_9E31C > 3 )
        {
          v0 = -1;
          strcpy(s, "No valid pools, please configure them first!\n");
          sub_47AB4(3, s, 0);
          return v0;
        }
        return -1;
      }
    }
    else if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "Product id are different.\n");
      sub_47AB4(3, s, 0);
    }
    sub_31794(15, 255);
    dword_9C2A4 = 255;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      v0 = -1;
      strcpy(s, "product id is invalid\n");
      sub_47AB4(3, s, 0);
      return v0;
    }
    return -1;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return -1;
  strcpy(s, "board adapt failed, exit\n");
  sub_47AB4(3, s, 0);
  return -1;
}
// 9C294: using guessed type int dword_9C294;
// 9C2A4: using guessed type int dword_9C2A4;
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA10: using guessed type int dword_1AEA10;
// 1AEA14: using guessed type int dword_1AEA14;
// 1AEA18: using guessed type int dword_1AEA18;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00025098) --------------------------------------------------------
int __fastcall sub_25098(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  float v8; // s0
  int *v9; // r7
  unsigned __int8 *v10; // r6
  FILE *v11; // r0
  FILE *v12; // r11
  signed int v13; // r8
  char *v14; // r8
  int v16; // r0
  int v17; // r11
  int v18; // r6
  unsigned int v19; // r0
  int v20; // r3
  int v21; // r0
  int v22; // r1
  int v23; // r3
  int v24; // r0
  int v25; // r0
  char v26; // [sp+1Bh] [bp-869h] BYREF
  _DWORD v27[25]; // [sp+1Ch] [bp-868h] BYREF
  char s[2080]; // [sp+80h] [bp-804h] BYREF
  int varg_r0; // [sp+8A8h] [bp+24h]
  int varg_r1; // [sp+8ACh] [bp+28h]
  int varg_r2; // [sp+8B0h] [bp+2Ch]
  int varg_r3; // [sp+8B4h] [bp+30h]

  dword_9C294 = 2;
  byte_A0D78 = 1;
  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  v26 = 0;
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_2;
  sub_225B4();
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    v9 = &dword_9EE34;
    v10 = (unsigned __int8 *)&byte_9EE64;
  }
  else
  {
    snprintf(s, 0x800u, "Miner compile time: %s type: %s\n", byte_1B07E4, byte_1B08E4);
    sub_47AB4(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
    {
LABEL_2:
      v9 = &dword_9EE34;
      v10 = (unsigned __int8 *)&byte_9EE64;
      goto LABEL_3;
    }
    strcpy(s, "commit version: f92c682 2020-01-08 18:55:42, build by: lzq 2020-01-14 15:00:34\n");
    LOWORD(v9) = (unsigned __int16)&dword_9EE34;
    sub_47AB4(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
    {
      v10 = (unsigned __int8 *)&byte_9EE64;
      HIWORD(v9) = (unsigned int)&dword_9EE34 >> 16;
      goto LABEL_3;
    }
    HIWORD(v9) = (unsigned int)&dword_9EE34 >> 16;
    snprintf(s, 0x800u, "opt_multi_version     = %d\n", *v9);
    LOWORD(v10) = (unsigned __int16)&byte_9EE64;
    sub_47AB4(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
    {
      HIWORD(v10) = (unsigned int)&byte_9EE64 >> 16;
      goto LABEL_3;
    }
    HIWORD(v10) = (unsigned int)&byte_9EE64 >> 16;
    snprintf(s, 0x800u, "opt_bitmain_ab        = %d\n", *v10);
    sub_47AB4(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "mid_auto_gen          = %d\n", 0);
    sub_47AB4(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "opt_bitmain_work_mode = %d\n", dword_9EE38);
      sub_47AB4(3, s, 0);
    }
  }
LABEL_3:
  v11 = (FILE *)fopen64("/nvdata/sn", "r");
  v12 = v11;
  if ( v11 )
  {
    fseek(v11, 0, 2);
    v13 = ftell(v12);
    fseek(v12, 0, 0);
    if ( v13 >= 100 )
      v13 = 100;
    if ( fread(v27, v13, 1u, v12) )
    {
      v14 = &s[v13 + 2047];
      if ( *(v14 - 2148) == 10 )
        *(v14 - 2148) = 0;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%s\n", (const char *)v27);
        sub_47AB4(3, s, 0);
      }
    }
    else if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "read /nvdata/sn wrong\n");
      sub_47AB4(3, s, 0);
    }
    fclose(v12);
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "no SN got, please write SN to /nvdata/sn\n");
    sub_47AB4(3, s, 0);
  }
  sub_669C4();
  sub_14350();
  sub_14420();
  *v10 = 1;
  *v9 = 8;
  sub_1EE10();
  sub_1FD84();
  v27[0] = varg_r0;
  v27[1] = varg_r1;
  v27[2] = varg_r2;
  v27[3] = varg_r3;
  v27[4] = a5;
  v27[5] = a6;
  v27[6] = a7;
  v27[7] = a8;
  *(_DWORD *)&byte_241D00 = varg_r0;
  *(_DWORD *)&byte_241D04 = varg_r1;
  unk_241D08 = varg_r2;
  *(_DWORD *)&word_241D0C = varg_r3;
  unk_241D10 = a5;
  unk_241D14 = a6;
  unk_241D18 = a7;
  unk_241D1C = a8;
  if ( (unsigned __int8)varg_r0 != 81 )
  {
    if ( (unsigned int)dword_9E31C <= 4 )
      return 0;
    snprintf(s, 0x800u, "config_parameter.token_type != 0x%x, it is 0x%x\n", 81, (unsigned __int8)byte_241D00);
LABEL_29:
    sub_47AB4(4, s, 0);
    return 0;
  }
  v16 = sub_514F8((int)&byte_241D00, 30);
  if ( v16 != (unsigned __int16)word_241D1E )
  {
    if ( (unsigned int)dword_9E31C <= 4 )
      return 0;
    snprintf(
      s,
      0x800u,
      "config_parameter.crc = 0x%x, but we calculate it as 0x%x\n",
      (unsigned __int16)word_241D1E,
      v16);
    goto LABEL_29;
  }
  memset(s, 0, 0x40u);
  sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio941/value");
  system(s);
  memset(s, 0, 0x40u);
  sprintf(s, "echo %d > %s", 0, "/sys/class/gpio/gpio942/value");
  system(s);
  if ( (unsigned __int8)sub_667A0()
    || (unsigned __int8)sub_23CC8()
    || (unsigned __int8)sub_66298()
    || (unsigned __int8)sub_249B0() )
  {
    return 0;
  }
  v17 = dword_9C294;
  if ( !dword_9C294 )
  {
    v18 = (unsigned __int8)sub_34568(161);
    do
    {
      v19 = (unsigned __int8)v17;
      v20 = dword_A0D68 + 4 * v17++;
      if ( *(_DWORD *)(v20 + 4) == 1 )
        sub_748C0(v19);
    }
    while ( v17 != 16 );
    if ( v18 )
      return 0;
  }
  if ( (unsigned __int8)sub_217A8() || (unsigned __int8)sub_24B88() )
    return 0;
  v21 = dword_A0D68;
  if ( byte_A0D78 && (byte_241D04 & 8) != 0 )
  {
    if ( (byte_241D05 & 8) != 0 )
      v22 = dword_A0D74;
    else
      v22 = (unsigned __int16)word_241D0C;
    v23 = dword_A0D68 + 12288;
    if ( (byte_241D05 & 8) != 0 )
      LOWORD(v22) = *(_WORD *)v22;
    *(_WORD *)(dword_A0D68 + 12979) = v22;
    sprintf((char *)(v21 + 12981), "%u", *(unsigned __int16 *)(v23 + 691));
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "fixd frequency is %d\n", *(unsigned __int16 *)(dword_A0D68 + 12979));
      sub_47AB4(3, s, 0);
    }
  }
  else
  {
    v25 = dword_A0D68 + 12288;
    *(_BYTE *)(dword_A0D68 + 12979) = 44;
    *(_BYTE *)(v25 + 692) = 1;
  }
  if ( (unsigned __int8)sub_22D34() )
    return 0;
  sub_15C50();
  if ( (unsigned __int8)sub_15DA8() )
    sub_14B6C();
  sub_4A804();
  sub_21F2C();
  sub_4A804();
  sub_15E90(0);
  if ( (unsigned __int8)sub_228FC()
    || (unsigned __int8)sub_219E0()
    || (unsigned __int8)sub_218C0()
    || (unsigned __int8)sub_21578()
    || dword_9C294 != 2 && (unsigned __int8)sub_305A8() )
  {
    return 0;
  }
  sub_22DD8();
  sub_22E9C((int)v8, *v9, 90);
  sub_31368(&v26);
  v24 = v26 ? sub_1A488() : sub_1A3B8();
  if ( (_BYTE)v24 )
    return 0;
  sub_21F4C(v24);
  if ( (unsigned __int8)sub_218C8() )
    return 0;
  sub_4A804();
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "Init done!\n");
    sub_47AB4(3, s, 0);
  }
  return 1;
}
// 25714: variable 'v8' is possibly undefined
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 9C294: using guessed type int dword_9C294;
// 9E31C: using guessed type int dword_9E31C;
// 9EE34: using guessed type int dword_9EE34;
// 9EE38: using guessed type int dword_9EE38;
// 9EE64: using guessed type char byte_9EE64;
// A0D68: using guessed type int dword_A0D68;
// A0D74: using guessed type int dword_A0D74;
// A0D78: using guessed type char byte_A0D78;
// 241D00: using guessed type char byte_241D00;
// 241D04: using guessed type char byte_241D04;
// 241D05: using guessed type char byte_241D05;
// 241D0C: using guessed type __int16 word_241D0C;
// 241D1E: using guessed type __int16 word_241D1E;

//----- (000257E4) --------------------------------------------------------
int sub_257E4()
{
  float v0; // s0
  int v2; // r0
  char v3; // [sp+7h] [bp-801h] BYREF
  char v4[2048]; // [sp+8h] [bp-800h] BYREF

  v3 = 0;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v4, "reopen_core start!\n");
    sub_47AB4(3, v4, 0);
  }
  pthread_mutex_lock(&stru_A0D98);
  pthread_mutex_lock(&stru_A0DB0);
  memset(v4, 0, 0x40u);
  sprintf(v4, "echo %d > %s", 0, "/sys/class/gpio/gpio941/value");
  system(v4);
  memset(v4, 0, 0x40u);
  sprintf(v4, "echo %d > %s", 0, "/sys/class/gpio/gpio942/value");
  system(v4);
  if ( !sub_249B0() && !sub_24B88() && !sub_22D34() )
  {
    sub_15C50();
    if ( sub_15DA8() )
      sub_14B6C();
    sub_4A804();
    sub_21F2C();
    sub_4A804();
    sub_15E90(0);
    if ( !sub_228FC() )
    {
      pthread_mutex_unlock(&stru_A0DB0);
      sub_22DD8();
      sub_22E9C((int)v0, dword_9EE34, 90);
      sub_31368(&v3);
      if ( v3 )
        v2 = sub_1A488();
      else
        v2 = sub_1A3B8();
      if ( !v2 )
      {
        sub_21F4C(0);
        pthread_mutex_unlock(&stru_A0D98);
        sub_4A60C((struct timeval *)&dword_A0D7C);
        sub_4A804();
        if ( (unsigned int)dword_9E31C > 3 )
        {
          strcpy(v4, "reopen_core done!\n");
          sub_47AB4(3, v4, 0);
        }
      }
    }
  }
  return 0;
}
// 25914: variable 'v0' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// 9EE34: using guessed type int dword_9EE34;
// A0D7C: using guessed type int dword_A0D7C;

//----- (000259F4) --------------------------------------------------------
int __fastcall sub_259F4(const void *a1, size_t a2)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  return sub_76F20((int)aBitmainSubmitN, a1, a2, &v3);
}

//----- (00025A28) --------------------------------------------------------
int __fastcall sub_25A28(const void *a1, size_t a2)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  return sub_76F20((int)aBitmainApiStat, a1, a2, &v3);
}

//----- (00025A5C) --------------------------------------------------------
int sub_25A5C()
{
  puts("bmminer_socket_init");
  while ( sub_76964((int)&off_9C3B8, 3) )
    sleep(3u);
  sleep(3u);
  puts("regist ..");
  while ( 1 )
  {
    sub_76C60((int)aBitmainSubmitN);
    if ( !sub_76C60((int)aBitmainApiStat) )
      break;
    sleep(3u);
  }
  puts("regist done!");
  return 0;
}
// 9C3B8: using guessed type int (*off_9C3B8)();

//----- (00025AEC) --------------------------------------------------------
int __fastcall sub_25AEC(pthread_rwlock_t *a1, int a2)
{
  int result; // r0
  int *v4; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  result = pthread_rwlock_init(a1, 0);
  if ( result )
  {
    v4 = _errno_location();
    snprintf(
      s,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      "bmminer.c",
      "bitmain_soc_prepare",
      a2);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (00025B64) --------------------------------------------------------
void __fastcall __noreturn sub_25B64(int a1)
{
  int *v2; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v2 = _errno_location();
  snprintf(
    s,
    0x800u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *v2,
    "bmminer.c",
    "bitmain_soc_prepare",
    a1);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (00025BBC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_25BBC(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { POP             {R4,PC} }
}
// 25BC0: positive sp value 810 has been found
// 25BC0: unbalanced stack, ignored a potential tail call

//----- (00025BC4) --------------------------------------------------------
int __fastcall sub_25BC4(int a1, int a2)
{
  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    sub_25B64(a2);
  return sub_25AEC((pthread_rwlock_t *)(a1 + 24), a2);
}

//----- (00025BFC) --------------------------------------------------------
char *__fastcall sub_25BFC(size_t *a1, const char **a2, int a3, char a4)
{
  const char *v4; // r11
  const char *v8; // r10
  size_t v9; // r4
  const char *v10; // r8
  size_t v11; // r4
  size_t v12; // r4
  char *v13; // r0
  char *v14; // r5
  size_t v15; // r7
  size_t v16; // r2
  size_t v17; // r6
  size_t v18; // r7
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = a2[72];
  v8 = a2[77];
  v9 = strlen(v4);
  v10 = a2[80];
  v11 = v9 + strlen(a2[77]) + 456;
  v12 = v11 + 3 + strlen(v10);
  v13 = (char *)calloc(1u, v12);
  v14 = v13;
  if ( v13 )
  {
    *(_DWORD *)(v13 + 1) = a3;
    *v13 = a4;
    memcpy(v13 + 5, a2, 0x1C0u);
    v15 = (unsigned __int8)(strlen(v4) + 1);
    v14[453] = v15;
    memcpy(v14 + 454, v4, v15);
    v16 = (unsigned __int8)(strlen(v8) + 1);
    v14[v15 + 454] = v16;
    v17 = v16 + v15 + 455;
    memcpy(&v14[v15 + 455], v8, v16);
    v18 = (unsigned __int8)(strlen(v10) + 1);
    v14[v17] = v18;
    memcpy(&v14[v17 + 1], v10, v18);
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf(s, 0x800u, "need data size:%d, actual size:%d\n", v12, v18 + v17 + 1);
      sub_47AB4(7, s, 0);
    }
    *a1 = v12;
  }
  return v14;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (00025DA0) --------------------------------------------------------
int __fastcall sub_25DA0(int a1, const char **a2, int a3, char a4)
{
  char *v4; // r4
  size_t v6; // [sp+4h] [bp-804h] BYREF
  char v7[2048]; // [sp+8h] [bp-800h] BYREF

  v4 = sub_25BFC(&v6, a2, a3, a4);
  if ( sub_259F4(v4, v6) && (byte_244080 || byte_1AECC4 || dword_9E320 > 2) )
  {
    strcpy(v7, "cgminer return err for this nonce!\n");
    sub_47AB4(3, v7, 0);
  }
  free(v4);
  return 1;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00025E54) --------------------------------------------------------
int __fastcall sub_25E54(const char *a1)
{
  int v2; // r4
  __time_t v3; // r3
  struct tm *v4; // r0
  struct timeval timer; // [sp+1Ch] [bp-B0h] BYREF
  char s[32]; // [sp+24h] [bp-A8h] BYREF
  char v8[32]; // [sp+44h] [bp-88h] BYREF
  char v9[40]; // [sp+64h] [bp-68h] BYREF
  char v10[64]; // [sp+8Ch] [bp-40h] BYREF

  memset(s, 0, sizeof(s));
  memset(v8, 0, sizeof(v8));
  memset(v9, 0, sizeof(v9));
  memset(v10, 0, 0x3Bu);
  v2 = 0;
  sub_4A60C(&timer);
  while ( 1 )
  {
    v3 = timer.tv_sec - v2++;
    timer.tv_sec = v3;
    v4 = localtime(&timer.tv_sec);
    snprintf(
      v9,
      0x28u,
      aD02d02d02d02d0_1,
      v4->tm_year + 1900,
      v4->tm_mon + 1,
      v4->tm_mday,
      v4->tm_hour,
      v4->tm_min,
      v4->tm_sec);
    snprintf(v10, 0x3Bu, "%s%s", "BITMAIN_OPENSOURCE", v9);
    sub_4889C(v10, 0x3Bu, v8);
    sub_4889C(v8, 0x20u, s);
    if ( !strncmp(s, a1, 0x20u) )
      break;
    if ( v2 == 4 )
      return 0;
  }
  puts("socket auth pass!!!!!!!!!!!!!!!!!!!!");
  return 1;
}

//----- (00025FA8) --------------------------------------------------------
int sub_25FA8()
{
  _DWORD *v0; // r4
  int v1; // r3
  _DWORD *v2; // r3
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  v0 = (_DWORD *)dword_241D5C;
  if ( !dword_241D5C )
    _assert_fail("cgpu", "bmminer.c", 0x193u, "bitmain_primary_init");
  v1 = dword_241D64;
  *(_DWORD *)(dword_241D5C + 4) = &unk_138580;
  v0[8] = 0;
  v0[5] = v1;
  v0[37] = 1;
  if ( !v1 )
  {
    strcpy(v4, "Failed to calloc cgpu_info data");
    sub_47AB4(3, v4, 1);
    sub_62EC0(1);
  }
  v2 = (_DWORD *)(v1 + 4096);
  v2[482] = 0;
  v2[483] = 1;
  v2[484] = 2;
  return 0;
}
// 241D5C: using guessed type int dword_241D5C;
// 241D64: using guessed type int dword_241D64;

//----- (00026080) --------------------------------------------------------
int __fastcall sub_26080(const char *a1, int a2)
{
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( a2 != 32 && (byte_244080 || byte_1AECC4 || dword_9E320 > 2) )
  {
    snprintf(v4, 0x800u, "invald hash size %d\n", a2);
    sub_47AB4(3, v4, 0);
  }
  byte_A0D90 = sub_25E54(a1);
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// A0D90: using guessed type char byte_A0D90;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00026118) --------------------------------------------------------
void __fastcall sub_26118(_DWORD *a1, int a2, int a3)
{
  size_t v5; // r7
  size_t v6; // r4
  void *v7; // r0
  void *v8; // r3
  int v9; // r0
  _DWORD *v10; // r0
  int v11; // r3
  size_t v12; // r10
  _DWORD *v13; // r8
  size_t v14; // r7
  int *v15; // r4
  int v16; // r5
  _DWORD *v17; // r3
  int v18; // r12
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int v22; // r0
  int v23; // r1
  int v24; // r2
  char *v25; // r4
  size_t v26; // r0
  size_t v27; // r10
  char *v28; // r4
  size_t v29; // r10
  _DWORD *v30; // r2
  int v31; // r1
  _DWORD *v32; // r9
  size_t v33; // r10
  int v34; // r1
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  memcpy(a1, (const void *)a2, 0x738u);
  v5 = a1[393];
  v6 = v5 + 1848;
  v7 = calloc(1u, v5);
  v8 = memcpy(v7, (const void *)(a2 + 1848), v5);
  v9 = a1[427];
  a1[392] = v8;
  v10 = sub_49624(4 * v9 + 1, "bmminer.c", "parse_job_buf", 567);
  v11 = a1[427];
  a1[169] = v10;
  if ( v11 > 0 )
  {
    v13 = v10;
    v14 = v5 + 1880;
    v15 = (int *)(a2 + v6);
    v16 = 0;
    while ( 1 )
    {
      v13[v16] = sub_49624(0x20u, "bmminer.c", "parse_job_buf", 570);
      v12 = v14 + 32 * v16;
      v17 = *(_DWORD **)(a1[169] + 4 * v16);
      if ( !v17 )
      {
        strcpy(s, "Failed to malloc local merkle_bin");
        sub_47AB4(3, s, 1);
        sub_62EC0(1);
      }
      v18 = *v15;
      ++v16;
      v19 = v15[1];
      v15 += 8;
      v20 = *(v15 - 6);
      v21 = *(v15 - 5);
      *v17 = v18;
      v17[1] = v19;
      v17[2] = v20;
      v17[3] = v21;
      v22 = *(v15 - 3);
      v23 = *(v15 - 2);
      v24 = *(v15 - 1);
      v17[4] = *(v15 - 4);
      v17[5] = v22;
      v17[6] = v23;
      v17[7] = v24;
      if ( a1[427] <= v16 )
        break;
      v13 = (_DWORD *)a1[169];
    }
  }
  else
  {
    v12 = v5 + 1848;
  }
  v25 = _strdup((const char *)(a2 + v12));
  v26 = strlen(v25);
  a1[168] = v25;
  v27 = v26 + 1 + v12;
  v28 = _strdup((const char *)(a2 + v27));
  v29 = v27 + strlen(v28);
  a1[153] = v28;
  v30 = (_DWORD *)(a2 + v29 + 1);
  v31 = v30[1];
  v32 = (_DWORD *)(a2 + v29 + 9);
  v33 = v29 + 17;
  unk_1385F8 = *v30;
  unk_1385FC = v31;
  v34 = v32[1];
  LODWORD(dbl_9ED90) = *v32;
  HIDWORD(dbl_9ED90) = v34;
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(s, 0x800u, "parse job buf len:%d\n", v33);
    sub_47AB4(7, s, 0);
  }
  if ( v33 != a3 )
  {
    strcpy(s, "ERR: data trans/recv unmathced!");
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
}
// 9E320: using guessed type int dword_9E320;
// 9ED90: using guessed type double dbl_9ED90;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (000263C0) --------------------------------------------------------
int __fastcall sub_263C0(const void *a1, int a2)
{
  int v4; // r4
  _DWORD *v5; // r5
  int v6; // r2
  int v7; // r4
  void *v8; // r0
  int *v10; // r0
  int *v11; // r0
  int *v12; // r0
  int *v13; // r0
  int *v14; // r0
  int *v15; // r0
  void *ptr; // [sp+14h] [bp-808h] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v4 = dword_241D64;
  ptr = 0;
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(s, 0x800u, "%s, rec job data %p size: %d\n", "bitmain_update_job_cb", a1, a2);
    sub_47AB4(7, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(v4 + 420)) )
  {
    v12 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v12,
      "bmminer.c",
      "bitmain_update_job_cb",
      611);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v5 = calloc(1u, 0x738u);
  sub_26118(v5, (int)a1, a2);
  if ( !*((_BYTE *)v5 + 640) )
  {
    strcpy(s, "Bitmain S9 has to use stratum pools");
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)v4) )
  {
    v10 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v10,
      "bmminer.c",
      "bitmain_update_job_cb",
      622);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 24)) )
  {
    v11 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v11,
      "bmminer.c",
      "bitmain_update_job_cb",
      622);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  *(_DWORD *)(v4 + 476) = *v5;
  sub_24434(v4 + 4176, v4 + 2328);
  *(_DWORD *)(v4 + 6032) = *(_DWORD *)(v4 + 6028);
  sub_24434(v4 + 2328, v4 + 480);
  *(_DWORD *)(v4 + 6028) = *(_DWORD *)(v4 + 6024);
  sub_24434(v4 + 480, (int)v5);
  v6 = dword_9C550 + 1;
  *(_DWORD *)(v4 + 6024) = dword_9C550 + 1;
  dword_9C550 = v6;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 24)) )
  {
    v14 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v14,
      "bmminer.c",
      "bitmain_update_job_cb",
      634);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v4) )
  {
    v15 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v15,
      "bmminer.c",
      "bitmain_update_job_cb",
      634);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  off_9E444();
  sub_23D5C(&ptr, (int)v5, *(_DWORD *)(v4 + 6024));
  pthread_mutex_lock(&stru_A0D98);
  sub_23FD4((unsigned __int8 *)ptr);
  pthread_mutex_unlock(&stru_A0D98);
  free(ptr);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(v4 + 420)) )
  {
    v13 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v13,
      "bmminer.c",
      "bitmain_update_job_cb",
      644);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  off_9E444();
  if ( (int)v5[427] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)(v5[169] + 4 * v7++);
      free(v8);
    }
    while ( v5[427] > v7 );
  }
  free((void *)v5[169]);
  free((void *)v5[392]);
  free((void *)v5[168]);
  free((void *)v5[153]);
  free(v5);
  return 0;
}
// 9C550: using guessed type int dword_9C550;
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 241D64: using guessed type int dword_241D64;
// 244080: using guessed type char byte_244080;

//----- (00026874) --------------------------------------------------------
size_t __fastcall sub_26874(int *a1)
{
  int v1; // r3
  size_t result; // r0
  char v3[2052]; // [sp+0h] [bp-804h] BYREF

  v1 = *a1;
  switch ( *a1 )
  {
    case 0:
    case 1:
    case 2:
      result = strlen((const char *)a1[2]) + 1;
      break;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
    case 19:
    case 22:
    case 26:
      result = 4;
      break;
    case 10:
    case 11:
    case 12:
    case 13:
    case 15:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      result = 8;
      break;
    case 14:
      result = 1;
      break;
    default:
      if ( byte_244080 || (result = (unsigned __int8)byte_1AECC4, byte_1AECC4) || dword_9E320 > 2 )
      {
        snprintf(v3, 0x800u, "Should not happen for unknown data type %d", v1);
        sub_47AB4(3, v3, 0);
        result = 0;
      }
      break;
  }
  return result;
}
// 2688C: control flows out of bounds to 26890
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (000269B8) --------------------------------------------------------
char *__fastcall sub_269B8(int a1, size_t *a2)
{
  size_t v2; // r6
  int v5; // r4
  char *v6; // r8
  size_t v7; // r7
  char *v8; // r8
  size_t v9; // r5
  char *v10; // r6
  size_t v11; // r7
  char *v12; // r0
  size_t v13; // r4
  char *v14; // r12
  int v15; // lr
  int v16; // r0
  int v17; // r1
  char *v18; // r2
  size_t v19; // r7
  char *v20; // r0
  char *v21; // r2
  size_t v22; // r1
  int v23; // lr
  size_t v24; // r5
  int v25; // r12
  size_t v26; // r6
  int v27; // r3
  char *v28; // r8
  char *v29; // r0
  int v30; // r1
  char *result; // r0
  int v32; // r3

  v2 = 0;
  v5 = a1;
  v6 = 0;
  do
  {
    v7 = v2 + 4;
    v8 = (char *)realloc(v6, v2 + 4);
    *(_DWORD *)&v8[v2] = *(_DWORD *)v5;
    v9 = strlen(*(const char **)(v5 + 4)) + 1 + v2 + 4;
    v10 = (char *)realloc(v8, v9);
    strcpy(&v10[v7], *(const char **)(v5 + 4));
    v11 = sub_26874((int *)v5);
    v12 = v10;
    v2 = v9 + v11;
    v6 = (char *)realloc(v12, v9 + v11);
    memcpy(&v6[v9], *(const void **)(v5 + 8), v11);
    v5 = *(_DWORD *)(v5 + 20);
  }
  while ( v5 != a1 );
  v13 = v2 + 28;
  v14 = (char *)realloc(v6, v2 + 12);
  v15 = dword_242EE8;
  v16 = dword_138600;
  v17 = dword_138604;
  v18 = &v14[v2];
  v19 = v2 + 284;
  *(_QWORD *)&dword_138600 = 0;
  *(_DWORD *)&v14[v2] = v16;
  *((_DWORD *)v18 + 1) = v17;
  *((_DWORD *)v18 + 2) = v15;
  v20 = (char *)realloc(v14, v2 + 28);
  v21 = &v20[v2 + 12];
  v22 = v2 + 284;
  v23 = dword_1B0A00;
  *(_DWORD *)v21 = dword_1B09FC;
  v24 = v2 + 292;
  v25 = dword_1B0A04;
  v26 = v2 + 296;
  v27 = dword_1B0A08;
  *((_DWORD *)v21 + 1) = v23;
  *((_DWORD *)v21 + 2) = v25;
  *((_DWORD *)v21 + 3) = v27;
  v28 = (char *)realloc(v20, v22);
  memcpy(&v28[v13], byte_1B0A18, 0x100u);
  v29 = (char *)realloc(v28, v24);
  v30 = HIDWORD(dbl_1B0A10);
  *(_DWORD *)&v29[v19] = LODWORD(dbl_1B0A10);
  *(_DWORD *)&v29[v19 + 4] = v30;
  result = (char *)realloc(v29, v26);
  v32 = dword_9EE38;
  *a2 = v26;
  *(_DWORD *)&result[v24] = v32;
  return result;
}
// 9EE38: using guessed type int dword_9EE38;
// 138600: using guessed type int dword_138600;
// 138604: using guessed type int dword_138604;
// 1B09FC: using guessed type int dword_1B09FC;
// 1B0A00: using guessed type int dword_1B0A00;
// 1B0A04: using guessed type int dword_1B0A04;
// 1B0A08: using guessed type int dword_1B0A08;
// 1B0A10: using guessed type double dbl_1B0A10;
// 242EE8: using guessed type int dword_242EE8;

//----- (00026B54) --------------------------------------------------------
int __fastcall sub_26B54(int a1, size_t *a2)
{
  if ( a1 )
    return (int)sub_269B8(a1, a2);
  return a1;
}

//----- (00026B60) --------------------------------------------------------
void __fastcall sub_26B60(int a1)
{
  int v1; // r4
  int v2; // r3
  void *v3; // r0
  int v4; // r2

  v1 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      free(*(void **)(v1 + 4));
      if ( *(_BYTE *)(v1 + 12) )
      {
        free(*(void **)(v1 + 8));
        v2 = *(_DWORD *)(v1 + 20);
        v3 = (void *)v1;
        if ( v1 == v2 )
        {
LABEL_7:
          free((void *)v1);
          return;
        }
      }
      else
      {
        v2 = *(_DWORD *)(v1 + 20);
        v3 = (void *)v1;
        if ( v1 == v2 )
          goto LABEL_7;
      }
      v4 = *(_DWORD *)(v1 + 16);
      v1 = v2;
      *(_DWORD *)(v2 + 16) = v4;
      *(_DWORD *)(v4 + 20) = v2;
      free(v3);
    }
  }
}

//----- (00026BCC) --------------------------------------------------------
const char *__fastcall sub_26BCC(int a1)
{
  int v2; // r4
  int v3; // r0
  const char *result; // r0
  int v5; // [sp+0h] [bp-14h] BYREF
  char s[16]; // [sp+4h] [bp-10h] BYREF

  v2 = 0;
  do
  {
    sprintf(s, "freq%d", v2 + 1);
    v3 = v2++;
    v5 = sub_30580(v3);
    result = sub_43DCC(a1, s, (const char *)&v5, 1);
    a1 = (int)result;
  }
  while ( v2 != 16 );
  return result;
}

//----- (00026C30) --------------------------------------------------------
int sub_26C30()
{
  const char *v0; // r0
  const char *v1; // r0
  const char *v2; // r0
  const char *v3; // r0
  int v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  int v23; // r4
  char *v24; // r0
  char *v25; // r6
  size_t v27; // [sp+Ch] [bp-4h] BYREF

  prctl(15, "api", 0);
  while ( !*(_BYTE *)(dword_241D5C + 364) )
  {
    sleep(1u);
    v0 = sub_1B370(0, 1);
    v1 = sub_1B394((int)v0, 1);
    v2 = sub_1B3B8((int)v1, 1);
    v3 = sub_1B440((int)v2, 1);
    v4 = nullsub_2(v3, 1);
    v5 = sub_1B780(v4);
    v6 = sub_1B7DC((int)v5, 1);
    v7 = sub_1B7F4((int)v6);
    v8 = sub_1B8D0((int)v7);
    v9 = sub_1B964((int)v8);
    v10 = sub_1BA48((int)v9);
    v11 = sub_1BAE8((int)v10, 1);
    v12 = sub_1BBE0((int)v11, 1);
    v13 = sub_1BBF8((int)v12, 1);
    v14 = sub_1BC68((int)v13, 1);
    v15 = sub_1BCD4((int)v14, 1);
    v16 = sub_1BD40((int)v15, 1);
    v17 = sub_1BDA4(v16, 1);
    v18 = sub_1BED0(v17, 1);
    v19 = sub_1BF54(v18, 1);
    v20 = sub_26BCC((int)v19);
    v21 = sub_1B340((int)v20, 1);
    v22 = sub_1B358((int)v21, 1);
    v23 = (int)v22;
    if ( v22 )
    {
      v24 = sub_269B8((int)v22, &v27);
      v25 = v24;
      if ( v24 )
      {
        sub_25A28(v24, v27);
        free(v25);
      }
    }
    sub_26B60(v23);
  }
  return 0;
}
// 1B6DC: using guessed type int __fastcall nullsub_2(_DWORD, _DWORD);
// 241D5C: using guessed type int dword_241D5C;

//----- (00026D7C) --------------------------------------------------------
int sub_26D7C()
{
  return 0;
}

//----- (00026D84) --------------------------------------------------------
void __fastcall sub_26D84(int a1, const char **a2)
{
  int v3; // [sp+Ch] [bp-804h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v3 = a1;
  sub_64C1C((int)&off_9E548, (int)"Options for both config file and command line");
  sub_64C1C((int)&off_9EDA8, (int)"Options for command line only");
  sub_64CF0(&v3, a2, (void (*)(const char *, ...))sub_52B50);
  if ( v3 != 1 )
  {
    strcpy(s, "Unexpected extra commandline arguments");
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 0);
  }
  sub_53DD0();
  if ( dword_1AECD8 )
    sub_63E84();
  if ( dword_1AECC8 )
  {
    byte_1AEB9C = 1;
    strcpy(byte_1AEBC4, (const char *)dword_1AECC8);
    if ( dword_1AECD4 )
      strcpy((char *)&word_1AEBA4, (const char *)dword_1AECD4);
    else
      strcpy((char *)&word_1AEBA4, "a+");
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      snprintf(s, 0x800u, "Log file path: %s Open flag: %s", byte_1AEBC4, (const char *)&word_1AEBA4);
      sub_47AB4(3, s, 0);
    }
  }
}
// 9E320: using guessed type int dword_9E320;
// 9E548: using guessed type char *off_9E548;
// 9EDA8: using guessed type char *off_9EDA8;
// 1AEB9C: using guessed type char byte_1AEB9C;
// 1AEBA4: using guessed type __int16 word_1AEBA4;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC8: using guessed type int dword_1AECC8;
// 1AECD4: using guessed type int dword_1AECD4;
// 1AECD8: using guessed type int dword_1AECD8;
// 244080: using guessed type char byte_244080;

//----- (00026F38) --------------------------------------------------------
void __fastcall sub_26F38(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_9;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x00] = 0x%08X, Chip Address, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_9:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:16]  CHIP_ID", HIWORD(v2));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]   CORE_NUM", BYTE1(v2));
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]    ADDR", (unsigned __int8)v2);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
        goto LABEL_9;
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000270B8) --------------------------------------------------------
void __fastcall sub_270B8(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_8;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x04] = 0x%08X, Hash Rate, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_8:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31]    LONG", v2 >> 31);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[30:0]  HASHRATE", v2 & 0x7FFFFFFF);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_8;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000271F8) --------------------------------------------------------
void __fastcall sub_271F8(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r5
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_20;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x08] = 0x%08X, PLL0 Parameter, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_20:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31]     LOCKED", v2 >> 31);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[30]     PLLEN", (v2 >> 30) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[29]     Reserved", (v2 >> 28) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[28]     BYPASS", (v2 >> 29) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:16]  FBDIV", HIWORD(v2) & 0xFFF);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_17;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:14]  Reserved", (unsigned __int16)v2 >> 14);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[13:8]   REFDIV", (v2 >> 8) & 0x3F);
  sub_47EC8(3, s, 0);
LABEL_14:
  v1 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_20;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]      Reserved", (v2 >> 7) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:4]    POSTDIV1", (v2 >> 4) & 7);
  sub_47EC8(3, s, 0);
LABEL_17:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]      Reserved", (v2 >> 3) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2:0]    POSTDIV2", v2 & 7);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_20;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00027578) --------------------------------------------------------
void __fastcall sub_27578(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_9;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x0C] = 0x%08X, Chip Nonce Offset, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_9:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31]     CNOV", v2 >> 31);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[30:16]  Reserved", HIWORD(v2) & 0x7FFF);
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:0]   CNO", (unsigned __int16)v2);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
        goto LABEL_9;
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000276F8) --------------------------------------------------------
void __fastcall sub_276F8(int *a1)
{
  int v1; // r6
  const char *v2; // r3
  unsigned int v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = *a1;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    v2 = "NOT FOUND";
    if ( *((_BYTE *)a1 + 4) )
      v2 = "FOUND";
    snprintf(s, 0x800u, ">> ASIC_REG[0x10] = 0x%08X, Hash Counting Number, %s\n", v1, v2);
    sub_47EC8(3, s, 0);
    v4 = dword_9E31C;
    if ( *((_BYTE *)a1 + 4) )
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:0]  HCN", v1);
      sub_47EC8(3, s, 0);
      v4 = dword_9E31C;
    }
    if ( v4 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000277E4) --------------------------------------------------------
void __fastcall sub_277E4(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_10;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x14] = 0x%08X, Ticket Mask, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_10:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:24]  TM3", HIBYTE(v2));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23:16]  TM2", BYTE2(v2));
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]   TM1", BYTE1(v2));
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]    TM0", (unsigned __int8)v2);
          sub_47EC8(3, s, 0);
          v1 = dword_9E31C;
          goto LABEL_10;
        }
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000279A4) --------------------------------------------------------
void __fastcall sub_279A4(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r5
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_31;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x18] = 0x%08X, Misc Control, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_31:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:28]  RTST_EN", v2 >> 28);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:24]  BT8D_8_5", HIBYTE(v2) & 0xF);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23]     CORE_SWPS", (v2 >> 23) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[22]     CORE_SRST", (v2 >> 22) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[21]     SPAT_NOD", (v2 >> 21) & 1);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_17;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[20]     RVS_K0", (v2 >> 20) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[19:18]  DSCLK_SEL", (v2 >> 18) & 3);
  sub_47EC8(3, s, 0);
LABEL_14:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_20;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[17]     TOPCLK_SEL", (v2 >> 17) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[16]     BCLK_SEL", HIWORD(v2) & 1);
  sub_47EC8(3, s, 0);
LABEL_17:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_23;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15]     TVER_EN", (v2 >> 15) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[14]     RFS", (v2 >> 14) & 1);
  sub_47EC8(3, s, 0);
LABEL_20:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_26;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[13]     INV_CLKO", (v2 >> 13) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[12:8]   BT8D_4_0", (v2 >> 8) & 0x1F);
  sub_47EC8(3, s, 0);
LABEL_23:
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_29:
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[1:0]    HASHRATE_TWS", v2 & 3);
    sub_47EC8(3, s, 0);
    v1 = dword_9E31C;
    goto LABEL_31;
  }
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]      RET_WORK_ERR_FLAG", (v2 >> 7) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:4]    TFS", (v2 >> 4) & 7);
  sub_47EC8(3, s, 0);
LABEL_26:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]      RI_DISA", (v2 >> 3) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2]      FORCE_CORE_EN", (v2 >> 2) & 1);
      sub_47EC8(3, s, 0);
      goto LABEL_29;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00027EE4) --------------------------------------------------------
void __fastcall sub_27EE4(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_11;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x24] = 0x%08X, Top Process Monitor, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
    goto LABEL_11;
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31]    START", v2 >> 31);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_11;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[30:26] Reserved", (v2 >> 26) & 0x1F);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[25:24] PM_SEL", HIBYTE(v2) & 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23:16] Reserved", BYTE2(v2));
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:0]  PM_COUNT", (unsigned __int16)v2);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
LABEL_11:
        if ( v1 > 3 )
        {
          strcpy(s, "\n");
          sub_47EC8(3, s, 0);
        }
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000280E4) --------------------------------------------------------
void __fastcall sub_280E4(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_19;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x28] = 0x%08X, fast UART configuration, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_19:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:30] DIV4_ODDSET", v2 >> 30);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[29,28] Reserved", (v2 >> 28) & 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:24] PLL3_DIV4", HIBYTE(v2) & 0xF);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23:22] USRC_ODDSET", (v2 >> 22) & 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[21:16] USRC_DIV", HIWORD(v2) & 0x3F);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_17:
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]   CLKO_DIV", (unsigned __int8)v2);
    sub_47EC8(3, s, 0);
    v1 = dword_9E31C;
    goto LABEL_19;
  }
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15]    SYNC_CLKO", (v2 >> 15) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[14]    CLKO_SEL", (v2 >> 14) & 1);
  sub_47EC8(3, s, 0);
LABEL_14:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[13:12] CLKO_ODDSET", (v2 >> 12) & 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[11,8]  Reserved", (v2 >> 8) & 0xF);
      sub_47EC8(3, s, 0);
      goto LABEL_17;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00028424) --------------------------------------------------------
void __fastcall sub_28424(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r5
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_25;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x58] = 0x%08X, Io Driver Strenght Configuration, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_25:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:28]  Reserved", v2 >> 28);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:24]  RF_DS", HIBYTE(v2) & 0xF);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23]     Reserved", (v2 >> 23) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[22:20]  TF_DS", (v2 >> 20) & 7);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[19]     Reserved", (v2 >> 19) & 1);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_17;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[18:16]  R0_DS", HIWORD(v2) & 7);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15]     Reserved", (v2 >> 15) & 1);
  sub_47EC8(3, s, 0);
LABEL_14:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_20;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[14:12]  CLKO_DS", (v2 >> 12) & 7);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[11]     Reserved", (v2 >> 11) & 1);
  sub_47EC8(3, s, 0);
LABEL_17:
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_23:
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2:0]    CO_DS", v2 & 7);
    sub_47EC8(3, s, 0);
    v1 = dword_9E31C;
    goto LABEL_25;
  }
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[10:8]   NRSTO_DS", (v2 >> 8) & 7);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]      Reserved", (v2 >> 7) & 1);
  sub_47EC8(3, s, 0);
LABEL_20:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:4]    BO_DS", (v2 >> 4) & 7);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]      Reserved", (v2 >> 3) & 1);
      sub_47EC8(3, s, 0);
      goto LABEL_23;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00028864) --------------------------------------------------------
void __fastcall sub_28864(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r5
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_20;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x60] = 0x%08X, PLL1 Parameter, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_20:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31]     LOCKED", v2 >> 31);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[30]     PLLEN", (v2 >> 30) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[29]     Reserved", (v2 >> 28) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[28]     BYPASS", (v2 >> 29) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:16]  FBDIV", HIWORD(v2) & 0xFFF);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_17;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:14]  Reserved", (unsigned __int16)v2 >> 14);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[13:8]   REFDIV", (v2 >> 8) & 0x3F);
  sub_47EC8(3, s, 0);
LABEL_14:
  v1 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_20;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]      Reserved", (v2 >> 7) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:4]    POSTDIV1", (v2 >> 4) & 7);
  sub_47EC8(3, s, 0);
LABEL_17:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]      Reserved", (v2 >> 3) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2:0]    POSTDIV2", v2 & 7);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_20;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00028BE4) --------------------------------------------------------
void __fastcall sub_28BE4(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_19;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x64] = 0x%08X, PLL2 Parameter, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_19:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31]     LOCKED", v2 >> 31);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[30]     PLLEN", (v2 >> 30) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[29:28]  Reserved", (v2 >> 28) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:16]  FBDIV", HIWORD(v2) & 0xFFF);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:14]  Reserved", (unsigned __int16)v2 >> 14);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_17:
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2:0]    POSTDIV2", v2 & 7);
    sub_47EC8(3, s, 0);
    v1 = dword_9E31C;
    goto LABEL_19;
  }
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[13:8]   REFDIV", (v2 >> 8) & 0x3F);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]      Reserved", (v2 >> 7) & 1);
  sub_47EC8(3, s, 0);
LABEL_14:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:4]    POSTDIV1", (v2 >> 4) & 7);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]      Reserved", (v2 >> 3) & 1);
      sub_47EC8(3, s, 0);
      goto LABEL_17;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00028F24) --------------------------------------------------------
void __fastcall sub_28F24(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_19;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x68] = 0x%08X, PLL3 Parameter, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_19:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31]     LOCKED", v2 >> 31);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[30]     PLLEN", (v2 >> 30) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[29:28]  Reserved", (v2 >> 28) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:16]  FBDIV", HIWORD(v2) & 0xFFF);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:14]  Reserved", (unsigned __int16)v2 >> 14);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_17:
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2:0]    POSTDIV2", v2 & 7);
    sub_47EC8(3, s, 0);
    v1 = dword_9E31C;
    goto LABEL_19;
  }
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[13:8]   REFDIV", (v2 >> 8) & 0x3F);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]      Reserved", (v2 >> 7) & 1);
  sub_47EC8(3, s, 0);
LABEL_14:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:4]    POSTDIV1", (v2 >> 4) & 7);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]      Reserved", (v2 >> 3) & 1);
      sub_47EC8(3, s, 0);
      goto LABEL_17;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00029264) --------------------------------------------------------
void __fastcall sub_29264(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r5
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_28;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x6C] = 0x%08X, Ldo Control, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_28:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31]     FSW_CKEN", v2 >> 31);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[30:27]  Reserved", (v2 >> 27) & 0xF);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[26]     PD1", (v2 >> 26) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[25:24]  BIT_LDO_CURRENT1", HIBYTE(v2) & 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23]     PD_LIMIT1", (v2 >> 23) & 1);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_17;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[22:20]  BIT_LDO_OUT1", (v2 >> 20) & 7);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[19]     PD_EFFP", (v2 >> 19) & 1);
  sub_47EC8(3, s, 0);
LABEL_14:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_20;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[18:16]  Reserved", HIWORD(v2) & 7);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:12]  RES", (unsigned __int16)v2 >> 12);
  sub_47EC8(3, s, 0);
LABEL_17:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_23;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[11]     PD_BG", (v2 >> 11) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[10]     PD0", (v2 >> 10) & 1);
  sub_47EC8(3, s, 0);
LABEL_20:
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_26:
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2:0]    BIT_LDO_BG", v2 & 7);
    sub_47EC8(3, s, 0);
    v1 = dword_9E31C;
    goto LABEL_28;
  }
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[9:8]    BIT_LDO_CURRENT0", (v2 >> 8) & 3);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]      PD_LIMIT0", (v2 >> 7) & 1);
  sub_47EC8(3, s, 0);
LABEL_23:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:4]    BIT_LDO_OUT0", (v2 >> 4) & 7);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]      PD_SCP", (v2 >> 3) & 1);
      sub_47EC8(3, s, 0);
      goto LABEL_26;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00029724) --------------------------------------------------------
void __fastcall sub_29724(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r5
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_29;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0x90] = 0x%08X, Frequency Sweep Control1, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_29:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:30]  Reserved", v2 >> 30);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[29]     CORE_CLK_CFG_DIS", (v2 >> 29) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[28]     EN_OR_MATCH_NONCES", (v2 >> 28) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27]     INC_DISABLE", (v2 >> 27) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[26:24]  SWEEP_STATE", HIBYTE(v2) & 7);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_17;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23:16]  SWEEP_ST_ADDR", BYTE2(v2));
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:14]  SN_FLTR", (unsigned __int16)v2 >> 14);
  sub_47EC8(3, s, 0);
LABEL_14:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_20;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[13]     ALL_CORE_CLK_SEL_CHANGE_ST", (v2 >> 13) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[12]     SWEEP_FAIL_LOCK_EN", (v2 >> 12) & 1);
  sub_47EC8(3, s, 0);
LABEL_17:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_23;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[11]     SWEEP_RESET", (v2 >> 11) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[10:8]   CURR_PAT_ADDR", (v2 >> 8) & 7);
  sub_47EC8(3, s, 0);
LABEL_20:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_26;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]      SWP_ONE_PAT_DONE", (v2 >> 7) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:4]    SWP_PAT_ADDR", (v2 >> 4) & 7);
  sub_47EC8(3, s, 0);
LABEL_23:
  v1 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_29;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]      SWP_DONE_ALL", (v2 >> 3) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2]      SWP_ONGOING", (v2 >> 2) & 1);
  sub_47EC8(3, s, 0);
LABEL_26:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[1]      SWP_TRIG", (v2 >> 1) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[0]      SWP_EN", v2 & 1);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_29;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00029C24) --------------------------------------------------------
void __fastcall sub_29C24(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r5
  char *v3; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_26;
  }
  v3 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v3 = "NOT FOUND";
  snprintf(s, 0x800u, ">> ASIC_REG[0xB0] = 0x%08X, Clock Overlap Counter, %s\n", v2, v3);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_26:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:30]  Reserved", v2 >> 30);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[29]     C0_SEL", (v2 >> 29) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[28]     ENTIN", (v2 >> 28) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:26]  VRTSEl", HIBYTE(v2) & 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[25:24]  Reserved", (v2 >> 21) & 7);
    sub_47EC8(3, s, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_17;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23:21]  VREFSEL", (v2 >> 20) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[20]     DIFF", (v2 >> 19) & 1);
  sub_47EC8(3, s, 0);
LABEL_14:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_20;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[19]     EN", (v2 >> 18) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[18]     INSEL", HIWORD(v2) & 3);
  sub_47EC8(3, s, 0);
LABEL_17:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_23;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[17:16]  RSVD1", (unsigned __int16)v2 >> 6);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:5]   SCONT", (v2 >> 5) & 1);
  sub_47EC8(3, s, 0);
LABEL_20:
  v1 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_26;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[4]      STAT", (v2 >> 4) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]      SWEN", (v2 >> 3) & 1);
  sub_47EC8(3, s, 0);
LABEL_23:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2]      DRDY", (v2 >> 2) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[1:0]    MT", v2 & 3);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_26;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002A0A4) --------------------------------------------------------
int __fastcall sub_2A0A4(int a1, int a2, int a3, _DWORD *a4)
{
  unsigned int v4; // r8
  unsigned int i; // r5
  unsigned int v7; // r9
  int *v8; // r11
  bool v9; // cc
  int result; // r0
  unsigned __int8 v11; // r0
  int v12; // r12
  bool v13; // zf
  int v14; // r7
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v4 = dword_241D70;
  if ( !dword_241D70 )
    return 0;
  for ( i = 1; ; ++i )
  {
    v7 = dword_241D6C + 1;
    v8 = &dword_241D68[2 * dword_241D6C + 2];
    if ( *((unsigned __int8 *)v8 + 10) == a3 )
      break;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "Get another register: 0x%X\n", a3);
      sub_47AB4(3, s, 0);
      v7 = dword_241D6C + 1;
    }
    dword_241D6C = v7;
    if ( v7 > 0x1FE )
      dword_241D6C = 0;
    v9 = v4 > i;
    --dword_241D70;
    if ( !v9 )
      return 0;
  }
  v11 = *((_BYTE *)v8 + 9) / *(_BYTE *)(dword_A0D68 + 12954);
  v12 = *((unsigned __int8 *)v8 + 11);
  v13 = v11 == a2;
  if ( v11 == a2 )
    v13 = v12 == a1;
  v14 = v13;
  if ( v13 )
  {
    *a4 = v8[1];
    v7 = dword_241D6C + 1;
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "Get another asic response: chain = %d, asic = %d\n", v12, v11);
    sub_47AB4(3, s, v14);
    v7 = dword_241D6C + 1;
  }
  result = 1;
  dword_241D6C = v7;
  --dword_241D70;
  if ( v7 > 0x1FE )
    dword_241D6C = 0;
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 241D68: using guessed type int dword_241D68[];
// 241D6C: using guessed type int dword_241D6C;
// 241D70: using guessed type int dword_241D70;

//----- (0002A248) --------------------------------------------------------
int __fastcall sub_2A248(_BYTE *a1, char a2, char a3)
{
  int v4; // r3
  int result; // r0

  *(_DWORD *)a1 = 0;
  *(_WORD *)a1 = 1346;
  v4 = dword_A0D68;
  a1[4] = 0;
  LOBYTE(v4) = *(_BYTE *)(v4 + 12954);
  a1[3] = a3;
  a1[2] = v4 * a2;
  result = sub_51554(a1, 0x20u);
  a1[4] = a1[4] & 0xE0 | result & 0x1F;
  return result;
}
// A0D68: using guessed type int dword_A0D68;

//----- (0002A29C) --------------------------------------------------------
void *__fastcall sub_2A29C(_DWORD *a1, const void *a2, size_t a3)
{
  void *result; // r0
  _DWORD *v5; // r3
  _DWORD *v6; // r4
  unsigned int v7; // t1

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  result = memcpy(a1, a2, a3);
  v5 = a1 - 1;
  v6 = a1 + 2;
  do
  {
    v7 = v5[1];
    *++v5 = bswap32(v7);
  }
  while ( v5 != v6 );
  return result;
}

//----- (0002A2D8) --------------------------------------------------------
int __fastcall sub_2A2D8(int a1, char a2, char a3)
{
  _BYTE v7[8]; // [sp+4h] [bp-14h] BYREF
  int v8[3]; // [sp+Ch] [bp-Ch] BYREF

  sub_2E9B8();
  sub_2A248(v7, a2, a3);
  sub_2A29C(v8, v7, 5u);
  return sub_70808(v8, a1);
}

//----- (0002A324) --------------------------------------------------------
int __fastcall sub_2A324(int a1, int a2, int a3, int a4)
{
  int v8; // r6
  int result; // r0
  int v10; // r11

  v8 = 10;
  while ( 1 )
  {
    sub_4A804();
    pthread_mutex_lock(&stru_138630);
    if ( dword_241D70 )
      break;
    pthread_mutex_unlock(&stru_138630);
LABEL_4:
    result = sub_4A804();
    if ( !--v8 )
      return result;
  }
  v10 = sub_2A0A4(a1, a2, a3, (_DWORD *)a4);
  result = pthread_mutex_unlock(&stru_138630);
  if ( !v10 )
    goto LABEL_4;
  *(_BYTE *)(a4 + 4) = 1;
  return result;
}
// 138630: using guessed type pthread_mutex_t stru_138630;
// 241D70: using guessed type int dword_241D70;

//----- (0002A3B8) --------------------------------------------------------
void __fastcall sub_2A3B8(int a1, int a2)
{
  unsigned int v3; // r7
  int v4; // r1
  const char *v5; // r3
  unsigned int v6; // r7
  int v7; // r1
  const char *v8; // r3
  unsigned int v9; // r3
  unsigned int v10; // r7
  int v11; // r1
  const char *v12; // r3
  unsigned int v13; // r3
  unsigned int v14; // r7
  int v15; // r1
  const char *v16; // r3
  unsigned int v17; // r3
  unsigned int v18; // r7
  int v19; // r1
  const char *v20; // r3
  unsigned int v21; // r3
  unsigned int v22; // r7
  int v23; // r1
  const char *v24; // r3
  unsigned int v25; // r3
  unsigned int v26; // r6
  unsigned int v27; // r3
  char *v28; // r3
  unsigned int v29; // r6
  unsigned int v30; // r3
  char *v31; // r3
  unsigned int v32; // r6
  unsigned int v33; // r3
  char *v34; // r3
  unsigned int v35; // r7
  int v36; // r1
  const char *v37; // r3
  unsigned int v38; // r3
  unsigned int v39; // r7
  int v40; // r1
  const char *v41; // r3
  unsigned int v42; // r3
  unsigned int v43; // r6
  unsigned int v44; // r3
  char *v45; // r3
  unsigned int v46; // r7
  int v47; // r1
  const char *v48; // r3
  unsigned int v49; // r3
  unsigned int v50; // r6
  unsigned int v51; // r3
  char *v52; // r3
  unsigned int v53; // r6
  unsigned int v54; // r3
  char *v55; // r3
  unsigned int v56; // r7
  const char *v57; // r3
  unsigned int v58; // r3
  unsigned int v59; // r6
  const char *v60; // r3
  unsigned int v61; // r6
  const char *v62; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  switch ( a1 )
  {
    case 40:
      sub_280E4((unsigned int *)a2);
      return;
    case 44:
      v6 = *(_DWORD *)a2;
      v7 = *(unsigned __int8 *)(a2 + 4);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      v8 = "NOT FOUND";
      if ( v7 )
        v8 = "FOUND";
      snprintf(s, 0x800u, ">> ASIC_REG[0x2C] = 0x%08X, UART Relay, %s\n", v6, v8);
      sub_47EC8(3, s, 0);
      v9 = dword_9E31C;
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:16] GAP_CNT", HIWORD(v6));
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:2]  Reserved", (unsigned __int16)v6 >> 2);
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[1]     RO_RELAY_EN", (v6 >> 1) & 1);
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[0]     CO_RELAY_EN", v6 & 1);
        sub_47EC8(3, s, 0);
        v9 = dword_9E31C;
      }
      if ( v9 <= 3 )
        return;
      goto LABEL_225;
    case 48:
      v10 = *(_DWORD *)a2;
      v11 = *(unsigned __int8 *)(a2 + 4);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      v12 = "NOT FOUND";
      if ( v11 )
        v12 = "FOUND";
      snprintf(s, 0x800u, ">> ASIC_REG[0x30] = 0x%08X, Core Number, %s\n", v10, v12);
      sub_47EC8(3, s, 0);
      v13 = dword_9E31C;
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:9] Reserved", v10 >> 9);
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[8:0]  CORE_NUM", v10 & 0x1FF);
        sub_47EC8(3, s, 0);
        v13 = dword_9E31C;
      }
      if ( v13 <= 3 )
        return;
      goto LABEL_225;
    case 56:
      v3 = *(_DWORD *)a2;
      v4 = *(unsigned __int8 *)(a2 + 4);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      v5 = "NOT FOUND";
      if ( v4 )
        v5 = "FOUND";
      snprintf(s, 0x800u, ">> ASIC_REG[0x38] = 0x%08X, Ticket Mask2, %s\n", v3, v5);
      sub_47EC8(3, s, 0);
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:0]  TM", v3);
        sub_47EC8(3, s, 0);
      }
      if ( (unsigned int)dword_9E31C > 3 )
        goto LABEL_225;
      return;
    case 68:
      v14 = *(_DWORD *)a2;
      v15 = *(unsigned __int8 *)(a2 + 4);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      v16 = "NOT FOUND";
      if ( v15 )
        v16 = "FOUND";
      snprintf(s, 0x800u, ">> ASIC_REG[0x44] = 0x%08X, External Temperature Sensor Read, %s\n", v14, v16);
      sub_47EC8(3, s, 0);
      v17 = dword_9E31C;
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:24]  LOCAL_TEMP_ADDR", HIBYTE(v14));
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23:16]  LOCAL_TEMP_DATA", BYTE2(v14));
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]   EXTERNAL_TEMP_ADDR", BYTE1(v14));
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]    EXTERNAL_TEMP_DATA", (unsigned __int8)v14);
        sub_47EC8(3, s, 0);
        v17 = dword_9E31C;
      }
      if ( v17 <= 3 )
        return;
      goto LABEL_225;
    case 72:
      v18 = *(_DWORD *)a2;
      v19 = *(unsigned __int8 *)(a2 + 4);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      v20 = "NOT FOUND";
      if ( v19 )
        v20 = "FOUND";
      snprintf(s, 0x800u, ">> ASIC_REG[0x48] = 0x%08X, Error Flag, %s\n", v18, v20);
      sub_47EC8(3, s, 0);
      v21 = dword_9E31C;
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:24]  CORE_RESP_ERR", HIBYTE(v18));
        sub_47EC8(3, s, 0);
        v21 = dword_9E31C;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23:17]  Reserved", (v18 >> 17) & 0x7F);
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[16]     PKT_END_ERR", HIWORD(v18) & 1);
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]   WORK_ERR_CNT", BYTE1(v18));
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]    CMD_ERR_CNT", (unsigned __int8)v18);
          sub_47EC8(3, s, 0);
          v21 = dword_9E31C;
        }
      }
      if ( v21 <= 3 )
        return;
      goto LABEL_225;
    case 76:
      v22 = *(_DWORD *)a2;
      v23 = *(unsigned __int8 *)(a2 + 4);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      v24 = "NOT FOUND";
      if ( v23 )
        v24 = "FOUND";
      snprintf(s, 0x800u, ">> ASIC_REG[0x4C] = 0x%08X, Nonce Error Counter, %s\n", v22, v24);
      sub_47EC8(3, s, 0);
      v25 = dword_9E31C;
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:0]  ERR_CNT", v22);
        sub_47EC8(3, s, 0);
        v25 = dword_9E31C;
      }
      if ( v25 > 3 )
        goto LABEL_225;
      return;
    case 80:
      v29 = *(_DWORD *)a2;
      v30 = dword_9E31C;
      if ( (unsigned int)dword_9E31C <= 3 )
      {
        if ( *(_BYTE *)(a2 + 4) )
          return;
      }
      else
      {
        v31 = "FOUND";
        if ( !*(_BYTE *)(a2 + 4) )
          v31 = "NOT FOUND";
        snprintf(s, 0x800u, ">> ASIC_REG[0x50] = 0x%08X, Nonce Overflow Counter, %s\n", v29, v31);
        sub_47EC8(3, s, 0);
        v30 = dword_9E31C;
        if ( *(_BYTE *)(a2 + 4) )
        {
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:8]  Reserved", v29 >> 8);
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]   OVF_CNT", (unsigned __int8)v29);
          sub_47EC8(3, s, 0);
          v30 = dword_9E31C;
        }
      }
      if ( v30 <= 3 )
        return;
      goto LABEL_225;
    case 84:
      v26 = *(_DWORD *)a2;
      v27 = dword_9E31C;
      if ( (unsigned int)dword_9E31C <= 3 )
      {
        if ( *(_BYTE *)(a2 + 4) )
          return;
      }
      else
      {
        v28 = "FOUND";
        if ( !*(_BYTE *)(a2 + 4) )
          v28 = "NOT FOUND";
        snprintf(s, 0x800u, ">> ASIC_REG[0x54] = 0x%08X, Analog Mux Control, %s\n", v26, v28);
        sub_47EC8(3, s, 0);
        v27 = dword_9E31C;
        if ( *(_BYTE *)(a2 + 4) )
        {
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:3]  Reserved", v26 >> 3);
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2:0]   DIODE_VDD_MUX_SEL", v26 & 7);
          sub_47EC8(3, s, 0);
          v27 = dword_9E31C;
        }
      }
      if ( v27 <= 3 )
        return;
      goto LABEL_225;
    case 88:
      sub_28424((unsigned int *)a2);
      return;
    case 92:
      v32 = *(_DWORD *)a2;
      v33 = dword_9E31C;
      if ( (unsigned int)dword_9E31C <= 3 )
      {
        if ( *(_BYTE *)(a2 + 4) )
          return;
      }
      else
      {
        v34 = "FOUND";
        if ( !*(_BYTE *)(a2 + 4) )
          v34 = "NOT FOUND";
        snprintf(s, 0x800u, ">> ASIC_REG[0x5C] = 0x%08X, Time Out, %s\n", v32, v34);
        sub_47EC8(3, s, 0);
        v33 = dword_9E31C;
        if ( *(_BYTE *)(a2 + 4) )
        {
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:16]  Reserved", HIWORD(v32));
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:0]   TMOUT", (unsigned __int16)v32);
          sub_47EC8(3, s, 0);
          v33 = dword_9E31C;
        }
      }
      if ( v33 <= 3 )
        return;
      goto LABEL_225;
    case 96:
      sub_28864((unsigned int *)a2);
      return;
    case 100:
      sub_28BE4((unsigned int *)a2);
      return;
    case 104:
      sub_28F24((unsigned int *)a2);
      return;
    case 108:
      sub_29264((unsigned int *)a2);
      return;
    case 144:
      sub_29724((unsigned int *)a2);
      return;
    case 148:
      v35 = *(_DWORD *)a2;
      v36 = *(unsigned __int8 *)(a2 + 4);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      v37 = "NOT FOUND";
      if ( v36 )
        v37 = "FOUND";
      snprintf(s, 0x800u, ">> ASIC_REG[0x94] = 0x%08X, Sweeping Work DAta, %s\n", v35, v37);
      sub_47EC8(3, s, 0);
      v38 = dword_9E31C;
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:0]  WORK_DATA", v35);
        sub_47EC8(3, s, 0);
        v38 = dword_9E31C;
      }
      if ( v38 > 3 )
        goto LABEL_225;
      return;
    case 152:
      v39 = *(_DWORD *)a2;
      v40 = *(unsigned __int8 *)(a2 + 4);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      v41 = "NOT FOUND";
      if ( v40 )
        v41 = "FOUND";
      snprintf(s, 0x800u, ">> ASIC_REG[0x98] = 0x%08X, Returned Group Pattern Status, %s\n", v39, v41);
      sub_47EC8(3, s, 0);
      v42 = dword_9E31C;
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:0]  RSTS", v39);
        sub_47EC8(3, s, 0);
        v42 = dword_9E31C;
      }
      if ( v42 > 3 )
        goto LABEL_225;
      return;
    case 156:
      v43 = *(_DWORD *)a2;
      v44 = dword_9E31C;
      if ( (unsigned int)dword_9E31C <= 3 )
      {
        if ( *(_BYTE *)(a2 + 4) )
          return;
      }
      else
      {
        v45 = "FOUND";
        if ( !*(_BYTE *)(a2 + 4) )
          v45 = "NOT FOUND";
        snprintf(s, 0x800u, ">> ASIC_REG[0x9C] = 0x%08X, Nonce Returned Timeout, %s\n", v43, v45);
        sub_47EC8(3, s, 0);
        v44 = dword_9E31C;
        if ( *(_BYTE *)(a2 + 4) )
        {
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:16]  Reserved", HIWORD(v43));
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:0]   SWEEP_TIMEOUT", (unsigned __int16)v43);
          sub_47EC8(3, s, 0);
          v44 = dword_9E31C;
        }
      }
      if ( v44 <= 3 )
        return;
      goto LABEL_225;
    case 160:
      v46 = *(_DWORD *)a2;
      v47 = *(unsigned __int8 *)(a2 + 4);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      v48 = "NOT FOUND";
      if ( v47 )
        v48 = "FOUND";
      snprintf(s, 0x800u, ">> ASIC_REG[0xA0] = 0x%08X, Returned Single Pattern Status, %s\n", v46, v48);
      sub_47EC8(3, s, 0);
      v49 = dword_9E31C;
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:0]  RSTS", v46);
        sub_47EC8(3, s, 0);
        v49 = dword_9E31C;
      }
      if ( v49 > 3 )
        goto LABEL_225;
      return;
    case 164:
      v50 = *(_DWORD *)a2;
      v51 = dword_9E31C;
      if ( (unsigned int)dword_9E31C <= 3 )
      {
        if ( *(_BYTE *)(a2 + 4) )
          return;
      }
      else
      {
        v52 = "FOUND";
        if ( !*(_BYTE *)(a2 + 4) )
          v52 = "NOT FOUND";
        snprintf(s, 0x800u, ">> ASIC_REG[0xA4] = 0x%08X, Midstate Cal Registter, %s\n", v50, v52);
        sub_47EC8(3, s, 0);
        v51 = dword_9E31C;
        if ( *(_BYTE *)(a2 + 4) )
        {
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31]     MID_AUTO_GEN", v50 >> 31);
          sub_47EC8(3, s, 0);
          v51 = dword_9E31C;
          if ( (unsigned int)dword_9E31C > 3 )
          {
            snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[30]     VER_FIX", (v50 >> 30) & 1);
            sub_47EC8(3, s, 0);
            if ( (unsigned int)dword_9E31C <= 3 )
              return;
            snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[29:28]  MIDSX_GEN", (v50 >> 28) & 3);
            sub_47EC8(3, s, 0);
            if ( (unsigned int)dword_9E31C <= 3 )
              return;
            snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:16]  Reserved", HIWORD(v50) & 0xFFF);
            sub_47EC8(3, s, 0);
            if ( (unsigned int)dword_9E31C <= 3 )
              return;
            snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:0]   VER_MASK", (unsigned __int16)v50);
            sub_47EC8(3, s, 0);
            v51 = dword_9E31C;
          }
        }
      }
      if ( v51 <= 3 )
        return;
      goto LABEL_225;
    case 172:
      v53 = *(_DWORD *)a2;
      v54 = dword_9E31C;
      if ( (unsigned int)dword_9E31C <= 3 )
      {
        if ( *(_BYTE *)(a2 + 4) )
          return;
      }
      else
      {
        v55 = "FOUND";
        if ( !*(_BYTE *)(a2 + 4) )
          v55 = "NOT FOUND";
        snprintf(s, 0x800u, ">> ASIC_REG[0xAC] = 0x%08X, Clock Overlap Counter, %s\n", v53, v55);
        sub_47EC8(3, s, 0);
        v54 = dword_9E31C;
        if ( *(_BYTE *)(a2 + 4) )
        {
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:24]  DOMAIN3_CNT", HIBYTE(v53));
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[23:16]  DOMAIN2_CNT", BYTE2(v53));
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]   DOMAIN1_CNT", BYTE1(v53));
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]    DOMAIN0_CNT", (unsigned __int8)v53);
          sub_47EC8(3, s, 0);
          v54 = dword_9E31C;
        }
      }
      if ( v54 <= 3 )
        return;
      goto LABEL_225;
    case 176:
      sub_29C24((unsigned int *)a2);
      return;
    case 180:
      v56 = *(_DWORD *)a2;
      if ( (unsigned int)dword_9E31C <= 3 )
      {
        if ( !*(_BYTE *)(a2 + 4) )
          return;
      }
      else
      {
        v57 = "NOT FOUND";
        if ( *(_BYTE *)(a2 + 4) )
          v57 = "FOUND";
        snprintf(s, 0x800u, ">> ASIC_REG[0xB4] = 0x%08X, Adc Dataout0, %s\n", v56, v57);
        sub_47EC8(3, s, 0);
        v58 = dword_9E31C;
        if ( !*(_BYTE *)(a2 + 4) )
          goto LABEL_198;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:28]  Reserved", v56 >> 28);
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C <= 3 )
            return;
          snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:16]  C1_DOUT", HIWORD(v56) & 0xFFF);
          sub_47EC8(3, s, 0);
        }
      }
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:12]  Reserved", (unsigned __int16)v56 >> 12);
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[11:0]   C0_DOUT", v56 & 0xFFF);
      sub_47EC8(3, s, 0);
      v58 = dword_9E31C;
LABEL_198:
      if ( v58 <= 3 )
        return;
      goto LABEL_225;
    case 184:
      v59 = *(_DWORD *)a2;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        v60 = "NOT FOUND";
        if ( *(_BYTE *)(a2 + 4) )
          v60 = "FOUND";
        snprintf(s, 0x800u, ">> ASIC_REG[0xB8] = 0x%08X, Adc Dataout1, %s\n", v59, v60);
        sub_47EC8(3, s, 0);
      }
      if ( *(_BYTE *)(a2 + 4) )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:28]  Reserved", v59 >> 28);
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[27:16]  C3_DOUT", HIWORD(v59) & 0xFFF);
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:12]  Reserved", (unsigned __int16)v59 >> 12);
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[11:0]   C2_DOUT", v59 & 0xFFF);
        sub_47EC8(3, s, 0);
      }
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      goto LABEL_225;
  }
  if ( a1 != 224 )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "Unknown reg: %d\n", a1);
      sub_47AB4(3, s, 0);
    }
    return;
  }
  v61 = *(_DWORD *)a2;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    v62 = "NOT FOUND";
    if ( *(_BYTE *)(a2 + 4) )
      v62 = "FOUND";
    snprintf(s, 0x800u, ">> ASIC_REG[0xE0] = 0x%08X, Returned Nonce Counter, %s\n", v61, v62);
    sub_47EC8(3, s, 0);
  }
  if ( !*(_BYTE *)(a2 + 4) )
    goto LABEL_224;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[31:16]  RETURN_NONCE_CNT_MATCH", HIWORD(v61));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:0]   RETURN_NONCE_CNT", (unsigned __int16)v61);
      sub_47EC8(3, s, 0);
LABEL_224:
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
LABEL_225:
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002BBB8) --------------------------------------------------------
void __fastcall sub_2BBB8(int a1, unsigned int *a2)
{
  if ( a1 )
  {
    switch ( a1 )
    {
      case 4:
        sub_270B8(a2);
        break;
      case 8:
        sub_271F8(a2);
        break;
      case 12:
        sub_27578(a2);
        break;
      case 16:
        sub_276F8((int *)a2);
        break;
      case 20:
        sub_277E4(a2);
        break;
      case 24:
        sub_279A4(a2);
        break;
      case 36:
        sub_27EE4(a2);
        break;
      default:
        sub_2A3B8(a1, (int)a2);
        break;
    }
  }
  else
  {
    sub_26F38(a2);
  }
}

//----- (0002BC3C) --------------------------------------------------------
void sub_2BC3C()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "Invalid parameter.\n");
  sub_47AB4(3, v0, 0);
}

//----- (0002BC80) --------------------------------------------------------
void __fastcall sub_2BC80(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_13;
  }
  v4 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(
    s,
    0x800u,
    ">> core_id[%d], CORE_REG[0] = 0x%02X, Clock Delay Ctrl, %s\n",
    HIWORD(v2),
    (unsigned __int8)v2,
    v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_13:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:6]  CCDLY_SEL", (unsigned __int8)v2 >> 6);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_11;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[5:4]  PWTH_SEL", (v2 >> 4) & 3);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3]    HASH_CLKEN", (v2 >> 3) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2]    MMEN", (v2 >> 2) & 1);
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[1]    Reserved", (v2 >> 1) & 1);
        sub_47EC8(3, s, 0);
LABEL_11:
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[0]    SWPF_MODE", v2 & 1);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
        goto LABEL_13;
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002BEC8) --------------------------------------------------------
void __fastcall sub_2BEC8(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_9;
  }
  v4 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(
    s,
    0x800u,
    ">> core_id[%d], CORE_REG[1] = 0x%02X, Process Monitor Ctrl, %s\n",
    HIWORD(v2),
    (unsigned __int8)v2,
    v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_9:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:3]  Reserved", (unsigned __int8)v2 >> 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[2]    PM_START", (v2 >> 2) & 1);
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[1:0]  PM_SEL", v2 & 3);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
        goto LABEL_9;
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002C050) --------------------------------------------------------
void __fastcall sub_2C050(unsigned int *a1)
{
  unsigned int v1; // r3
  const char *v2; // r2
  int v3; // r6
  unsigned int v5; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = *a1;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    v2 = "NOT FOUND";
    v3 = (unsigned __int16)v1;
    if ( *((_BYTE *)a1 + 4) )
      v2 = "FOUND";
    snprintf(
      s,
      0x800u,
      ">> core_id[%d], CORE_REG[2] = 0x%04X, Process Monitor Data, %s\n",
      HIWORD(v1),
      (unsigned __int16)v1,
      v2);
    sub_47EC8(3, s, 0);
    v5 = dword_9E31C;
    if ( *((_BYTE *)a1 + 4) )
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:0] FREQ_CNT", v3);
      sub_47EC8(3, s, 0);
      v5 = dword_9E31C;
    }
    if ( v5 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002C144) --------------------------------------------------------
void __fastcall sub_2C144(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_9;
  }
  v4 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(s, 0x800u, ">> core_id[%d], CORE_REG[3] = 0x%02X, Core Error, %s\n", HIWORD(v2), (unsigned __int8)v2, v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_9:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:5]  Reserved", (unsigned __int8)v2 >> 5);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[4]    INI_NONCE_ERR", (v2 >> 4) & 1);
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3:0]  CMD_ERR_CNT", v2 & 0xF);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
        goto LABEL_9;
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002C2CC) --------------------------------------------------------
void __fastcall sub_2C2CC(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_8;
  }
  v4 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(s, 0x800u, ">> core_id[%d], CORE_REG[4] = 0x%04X, Core Enable, %s\n", HIWORD(v2), (unsigned __int16)v2, v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_8:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]  Reserved", BYTE1(v2));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]   CORE_EN_I", (unsigned __int8)v2);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_8;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002C414) --------------------------------------------------------
void __fastcall sub_2C414(unsigned int *a1)
{
  unsigned int v1; // r3
  const char *v2; // r2
  int v3; // r6
  unsigned int v5; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = *a1;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    v2 = "NOT FOUND";
    v3 = (unsigned __int8)v1;
    if ( *((_BYTE *)a1 + 4) )
      v2 = "FOUND";
    snprintf(
      s,
      0x800u,
      ">> core_id[%d], CORE_REG[5] = 0x%02X, Hash Clock Control, %s\n",
      HIWORD(v1),
      (unsigned __int8)v1,
      v2);
    sub_47EC8(3, s, 0);
    v5 = dword_9E31C;
    if ( *((_BYTE *)a1 + 4) )
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:0]  CLOCK_CTRL", v3);
      sub_47EC8(3, s, 0);
      v5 = dword_9E31C;
    }
    if ( v5 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002C508) --------------------------------------------------------
void __fastcall sub_2C508(unsigned int *a1)
{
  unsigned int v1; // r3
  const char *v2; // r2
  int v3; // r6
  unsigned int v5; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = *a1;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    v2 = "NOT FOUND";
    v3 = (unsigned __int16)v1;
    if ( *((_BYTE *)a1 + 4) )
      v2 = "FOUND";
    snprintf(
      s,
      0x800u,
      ">> core_id[%d], CORE_REG[6] = 0x%02X, Hash Clock Counter, %s\n",
      HIWORD(v1),
      (unsigned __int16)v1,
      v2);
    sub_47EC8(3, s, 0);
    v5 = dword_9E31C;
    if ( *((_BYTE *)a1 + 4) )
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]  CLOCK_CNT", v3);
      sub_47EC8(3, s, 0);
      v5 = dword_9E31C;
    }
    if ( v5 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002C5FC) --------------------------------------------------------
void __fastcall sub_2C5FC(unsigned int *a1)
{
  unsigned int v1; // r2
  unsigned int v2; // r3
  const char *v4; // r2
  unsigned int v5; // r6
  unsigned int v6; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_13;
  }
  v4 = "FOUND";
  v5 = (unsigned __int16)v2;
  v6 = HIWORD(v2);
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(s, 0x800u, ">> core_id[%d], CORE_REG[7] = 0x%02X, Clock Select Ctrl, %s\n", v6, v5, v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_13:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]  Reserved", v5 >> 8);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_11;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]     SWPF_MODE", (v5 >> 7) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:5]   Reserved", (v5 >> 5) & 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[4]     PULSE_MODE", (v5 >> 4) & 1);
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3:2]   Reserved", (v5 >> 2) & 3);
        sub_47EC8(3, s, 0);
LABEL_11:
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[1:0]   CLOCK_CNT", v5 & 3);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
        goto LABEL_13;
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002C844) --------------------------------------------------------
void __fastcall sub_2C844(unsigned int *a1)
{
  unsigned int v1; // r2
  unsigned int v2; // r3
  const char *v4; // r2
  unsigned int v5; // r6
  unsigned int v6; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_13;
  }
  v4 = "FOUND";
  v5 = (unsigned __int16)v2;
  v6 = HIWORD(v2);
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(s, 0x800u, ">> core_id[%d], CORE_REG[8] = 0x%02X, IR Drop Ctrl, %s\n", v6, v5, v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_13:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]  Reserved", v5 >> 8);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_11;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]     IR_CLEAR", (v5 >> 7) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6:5]   Reserved", (v5 >> 5) & 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[4]     IR_INI", (v5 >> 4) & 1);
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3:2]   Reserved", (v5 >> 2) & 3);
        sub_47EC8(3, s, 0);
LABEL_11:
        if ( (unsigned int)dword_9E31C <= 3 )
          return;
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[1:0]   IR_MODE", v5 & 3);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
        goto LABEL_13;
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002CA8C) --------------------------------------------------------
void __fastcall sub_2CA8C(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_8;
  }
  v4 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(
    s,
    0x800u,
    ">> core_id[%d], CORE_REG[9] = 0x%02X, IR Drop S1 Sum, %s\n",
    HIWORD(v2),
    (unsigned __int16)v2,
    v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_8:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:6]  Reserved", (unsigned __int16)v2 >> 6);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[5:0]   IR_S1_NUM", v2 & 0x3F);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_8;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002CBD4) --------------------------------------------------------
void __fastcall sub_2CBD4(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_8;
  }
  v4 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(
    s,
    0x800u,
    ">> core_id[%d], CORE_REG[10] = 0x%02X, IR Drop S2 Sum, %s\n",
    HIWORD(v2),
    (unsigned __int16)v2,
    v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_8:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:6]  Reserved", (unsigned __int16)v2 >> 6);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[5:0]   IR_S2_NUM", v2 & 0x3F);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_8;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002CD1C) --------------------------------------------------------
void __fastcall sub_2CD1C(unsigned int *a1)
{
  unsigned int v1; // r3
  const char *v2; // r2
  int v3; // r6
  unsigned int v5; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = *a1;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    v2 = "NOT FOUND";
    v3 = (unsigned __int16)v1;
    if ( *((_BYTE *)a1 + 4) )
      v2 = "FOUND";
    snprintf(
      s,
      0x800u,
      ">> core_id[%d], CORE_REG[11] = 0x%02X, IR Drop Data Low, %s\n",
      HIWORD(v1),
      (unsigned __int16)v1,
      v2);
    sub_47EC8(3, s, 0);
    v5 = dword_9E31C;
    if ( *((_BYTE *)a1 + 4) )
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:0]  IR_DATA_LOW", v3);
      sub_47EC8(3, s, 0);
      v5 = dword_9E31C;
    }
    if ( v5 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002CE10) --------------------------------------------------------
void __fastcall sub_2CE10(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_8;
  }
  v4 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(
    s,
    0x800u,
    ">> core_id[%d], CORE_REG[12] = 0x%02X, IR Drop Data High, %s\n",
    HIWORD(v2),
    (unsigned __int16)v2,
    v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_8:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]  Reserved", BYTE1(v2));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]   IR_DATA_HIGH", (unsigned __int8)v2);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_8;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002CF58) --------------------------------------------------------
void __fastcall sub_2CF58(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r6
  char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_9;
  }
  v4 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(
    s,
    0x800u,
    ">> core_id[%d], CORE_REG[13] = 0x%02X, OCV Pulse Width, %s\n",
    HIWORD(v2),
    (unsigned __int16)v2,
    v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_9:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:11]  Reserved", (unsigned __int16)v2 >> 11);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[10:8]   OCV_DOUT", (v2 >> 8) & 7);
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7:0]    PULSE_WIDTH", (unsigned __int8)v2);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
        goto LABEL_9;
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002D0E0) --------------------------------------------------------
void __fastcall sub_2D0E0(unsigned int *a1)
{
  unsigned int v1; // r2
  unsigned int v2; // r3
  const char *v4; // r2
  unsigned int v5; // r6
  unsigned int v6; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_11;
  }
  v4 = "FOUND";
  v5 = (unsigned __int16)v2;
  v6 = HIWORD(v2);
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(s, 0x800u, ">> core_id[%d], CORE_REG[14] = 0x%02X, OCV Sel, %s\n", v6, v5, v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
    goto LABEL_11;
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15:8]  Reserved", v5 >> 8);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_11;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]     OCV_CLEAR", (v5 >> 7) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6]     OCV_EN", (v5 >> 6) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[5]     Reserved", (v5 >> 5) & 1);
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[4:0]   OCV_SEL", v5 & 0x1F);
        sub_47EC8(3, s, 0);
        v1 = dword_9E31C;
LABEL_11:
        if ( v1 > 3 )
        {
          strcpy(s, "\n");
          sub_47EC8(3, s, 0);
        }
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002D2E8) --------------------------------------------------------
void __fastcall sub_2D2E8(unsigned int *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r5
  char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = dword_9E31C;
  v2 = *a1;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    if ( *((_BYTE *)a1 + 4) )
      return;
    goto LABEL_17;
  }
  v4 = "FOUND";
  if ( !*((_BYTE *)a1 + 4) )
    v4 = "NOT FOUND";
  snprintf(s, 0x800u, ">> core_id[%d], CORE_REG[14] = 0x%02X, PG Mont, %s\n", HIWORD(v2), (unsigned __int16)v2, v4);
  sub_47EC8(3, s, 0);
  v1 = dword_9E31C;
  if ( !*((_BYTE *)a1 + 4) )
  {
LABEL_17:
    if ( v1 > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
    }
    return;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[15]     PGM_OVERLAP", (v2 >> 14) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[14:10]  Reserved", (v2 >> 9) & 0x1F);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[9:8]    CLK_SEL", (v2 >> 7) & 3);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_14;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[7]      PGM_AUTO", (v2 >> 6) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[6]      PGM_ADD", (v2 >> 5) & 1);
    sub_47EC8(3, s, 0);
  }
  v1 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_17;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[5:4]    PGM_CTRL", (v2 >> 4) & 1);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[3:2]    Reserved ", (v2 >> 2) & 3);
  sub_47EC8(3, s, 0);
LABEL_14:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[1]      PGM_UPLOAD", (v2 >> 1) & 1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s = 0x%X\n", "BIT[0]      PGM_ENABLE", v2 & 1);
      sub_47EC8(3, s, 0);
      v1 = dword_9E31C;
      goto LABEL_17;
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002D5F0) --------------------------------------------------------
void __fastcall sub_2D5F0(int a1, unsigned int *a2)
{
  char v2[2052]; // [sp+0h] [bp-804h] BYREF

  switch ( a1 )
  {
    case 8:
      sub_2C844(a2);
      break;
    case 9:
      sub_2CA8C(a2);
      break;
    case 10:
      sub_2CBD4(a2);
      break;
    case 11:
      sub_2CD1C(a2);
      break;
    case 12:
      sub_2CE10(a2);
      break;
    case 13:
      sub_2CF58(a2);
      break;
    case 14:
      sub_2D0E0(a2);
      break;
    case 15:
      sub_2D2E8(a2);
      break;
    default:
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(v2, 0x800u, "Unknown reg: %d\n", a1);
        sub_47AB4(3, v2, 0);
      }
      break;
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002D700) --------------------------------------------------------
int __fastcall sub_2D700(int result, char a2, char a3)
{
  char v3; // r3
  char v4; // lr
  char v5; // r3
  char v6; // r2

  *(_DWORD *)result = 0;
  v3 = *(_BYTE *)(result + 1);
  v4 = *(_BYTE *)(result + 3);
  *(_BYTE *)result = -1;
  v5 = v3 & 0xF0 | a3 & 0xF;
  v6 = *(_BYTE *)(result + 2);
  *(_BYTE *)(result + 3) = v4 & 0x7F;
  *(_BYTE *)(result + 1) = v5 & 0x3F;
  *(_BYTE *)(result + 2) = v6 & 0x80 | a2 & 0x7F;
  return result;
}

//----- (0002D744) --------------------------------------------------------
int __fastcall sub_2D744(int result, char a2)
{
  char v2; // r3
  char v3; // lr
  char v4; // r2

  *(_DWORD *)result = 0;
  v2 = *(_BYTE *)(result + 1);
  *(_BYTE *)result = -1;
  v3 = *(_BYTE *)(result + 2);
  v4 = *(_BYTE *)(result + 3);
  *(_BYTE *)(result + 1) = v2 & 0x30 | a2 & 0xF;
  *(_BYTE *)(result + 2) = v3 & 0x80;
  *(_BYTE *)(result + 3) = v4 | 0x80;
  return result;
}

//----- (0002D788) --------------------------------------------------------
int __fastcall sub_2D788(int result, char a2, char a3)
{
  char v3; // r3
  char v4; // r12
  char v5; // r2

  *(_DWORD *)result = 0;
  v3 = *(_BYTE *)(result + 1);
  v4 = *(_BYTE *)(result + 2);
  *(_BYTE *)result = a3;
  v5 = *(_BYTE *)(result + 3);
  *(_BYTE *)(result + 2) = v4 & 0x80;
  *(_BYTE *)(result + 1) = v3 & 0xB0 | a2 & 0xF | 0x80;
  *(_BYTE *)(result + 3) = v5 | 0x80;
  return result;
}

//----- (0002D7C8) --------------------------------------------------------
void __fastcall sub_2D7C8(int a1, char a2, char a3, int a4)
{
  int v4; // r12

  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *(_BYTE *)a1 = 65;
    *(_BYTE *)(a1 + 1) = 9;
    v4 = dword_A0D68;
    *(_DWORD *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + 8) = 0;
    LOBYTE(v4) = *(_BYTE *)(v4 + 12954);
    *(_BYTE *)(a1 + 7) = a4;
    *(_BYTE *)(a1 + 3) = a3;
    *(_BYTE *)(a1 + 4) = HIBYTE(a4);
    *(_BYTE *)(a1 + 5) = BYTE2(a4);
    *(_BYTE *)(a1 + 6) = BYTE1(a4);
    *(_BYTE *)(a1 + 2) = v4 * a2;
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(a1 + 8) & 0xE0 | sub_51554((_BYTE *)a1, 0x40u) & 0x1F;
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    sub_2BC3C();
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (0002D868) --------------------------------------------------------
int __fastcall sub_2D868(int a1, char a2, char a3, char a4)
{
  int v9; // [sp+4h] [bp-20h]
  _BYTE v10[12]; // [sp+8h] [bp-1Ch] BYREF
  int v11[4]; // [sp+14h] [bp-10h] BYREF

  sub_2E9B8();
  BYTE1(v9) = a4 & 0xF;
  HIWORD(v9) = a3 & 0x7F;
  LOBYTE(v9) = -1;
  sub_2D7C8((int)v10, a2, 60, v9);
  sub_2A29C(v11, v10, 9u);
  return sub_70808(v11, a1);
}

//----- (0002D8E4) --------------------------------------------------------
int __fastcall sub_2D8E4(int a1, char a2, char a3)
{
  int v7; // [sp+4h] [bp-1Ch]
  _BYTE v8[12]; // [sp+8h] [bp-18h] BYREF
  int v9[3]; // [sp+14h] [bp-Ch] BYREF

  sub_2E9B8();
  LOBYTE(v7) = -1;
  HIBYTE(v7) = 0x80;
  *(_WORD *)((char *)&v7 + 1) = a3 & 0xF;
  sub_2D7C8((int)v8, a2, 60, v7);
  sub_2A29C(v9, v8, 9u);
  return sub_70808(v9, a1);
}

//----- (0002D958) --------------------------------------------------------
int __fastcall sub_2D958(int a1, char a2, char a3, char a4)
{
  unsigned __int8 v7; // r4
  int v9; // [sp+4h] [bp-20h]
  _BYTE v10[12]; // [sp+8h] [bp-1Ch] BYREF
  int v11[4]; // [sp+14h] [bp-10h] BYREF

  v7 = a3 & 0xF | 0x80;
  sub_2E9B8();
  HIBYTE(v9) = 0x80;
  *(_WORD *)((char *)&v9 + 1) = v7;
  LOBYTE(v9) = a4;
  sub_2D7C8((int)v10, a2, 60, v9);
  sub_2A29C(v11, v10, 9u);
  return sub_70808(v11, a1);
}

//----- (0002D9CC) --------------------------------------------------------
void __fastcall sub_2D9CC(int a1, unsigned int *a2)
{
  if ( a1 )
  {
    switch ( a1 )
    {
      case 1:
        sub_2BEC8(a2);
        break;
      case 2:
        sub_2C050(a2);
        break;
      case 3:
        sub_2C144(a2);
        break;
      case 4:
        sub_2C2CC(a2);
        break;
      case 5:
        sub_2C414(a2);
        break;
      case 6:
        sub_2C508(a2);
        break;
      case 7:
        sub_2C5FC(a2);
        break;
      default:
        sub_2D5F0(a1, a2);
        break;
    }
  }
  else
  {
    sub_2BC80(a2);
  }
}

//----- (0002DA50) --------------------------------------------------------
int __fastcall sub_2DA50(int a1, unsigned int a2, unsigned int a3)
{
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( a1 <= 15 && *(_DWORD *)(dword_A0D68 + 4 * a1 + 4) )
  {
    if ( a2 > 0x4D )
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        return 0;
      snprintf(v4, 0x800u, "Invalid ASIC ID: %d\n", a2);
    }
    else
    {
      if ( a3 <= 0x5F )
        return 1;
      if ( (unsigned int)dword_9E31C <= 3 )
        return 0;
      snprintf(v4, 0x800u, "Invalid core ID: %d\n", a3);
    }
LABEL_12:
    sub_47AB4(3, v4, 0);
    return 0;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v4, 0x800u, "Invalid chain ID: %d\n", a1);
    goto LABEL_12;
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (0002DB40) --------------------------------------------------------
void __fastcall sub_2DB40(int a1, unsigned int a2, int a3)
{
  unsigned __int8 v5; // r9
  unsigned int *v6; // r4
  int v7; // r5
  int v8; // r6
  unsigned int *v9; // r1
  _BYTE s[120]; // [sp+8h] [bp-87Ch] BYREF
  char v11[2052]; // [sp+80h] [bp-804h] BYREF

  v5 = a3;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v11, 0x800u, "Dump core register start. chain = %d, asic = %d, core = %d\n", a1, a2, a3);
    sub_47AB4(3, v11, 0);
  }
  memset(s, 0, sizeof(s));
  pthread_mutex_lock(&stru_A0DB0);
  byte_138648[0] = 1;
  if ( sub_2DA50(a1, a2, v5) )
  {
    v6 = (unsigned int *)s;
    v7 = 0;
    do
    {
      v8 = (unsigned __int8)v7;
      sub_2D868(a1, a2, v5, v7);
      sub_2A324(a1, a2, 64, (int)v6);
      ++v7;
      v9 = v6;
      v6 += 2;
      sub_2D9CC(v8, v9);
    }
    while ( v7 != 15 );
  }
  byte_138648[0] = 0;
  pthread_mutex_unlock(&stru_A0DB0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v11, "Dump core register done.\n");
    sub_47AB4(3, v11, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002DC90) --------------------------------------------------------
int __fastcall sub_2DC90(int a1, int a2, int a3)
{
  int v5; // r5
  unsigned int v6; // r8
  unsigned __int16 v7; // r4
  unsigned int v8; // r3
  int v9; // r5
  unsigned int v12; // [sp+18h] [bp-8h] BYREF
  int v13; // [sp+1Ch] [bp-4h]
  char v14[2052]; // [sp+20h] [bp+0h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v14, 0x800u, "Dump core process monitor data register start. chain = %d, asic = %d\n", a1, a2);
    sub_47AB4(4, v14, 0);
  }
  pthread_mutex_lock(&stru_A0DB0);
  byte_138648[0] = 1;
  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v14, "Critical path chain.\n");
    sub_47AB4(4, v14, 0);
  }
  v5 = 0;
  sub_2D958(a1, a2, 1, 6);
  sub_2D8E4(a1, a2, 2);
  while ( 1 )
  {
    v12 = 0;
    ++v5;
    v13 = 0;
    sub_2A324(a1, a2, 64, (int)&v12);
    v6 = HIWORD(v12);
    if ( !(_BYTE)v13 )
      break;
    v7 = v12;
    if ( (unsigned int)dword_9E31C > 4 )
    {
      snprintf(v14, 0x800u, "%8u", (unsigned __int16)v12);
      sub_47EC8(4, v14, 0);
    }
    *(_DWORD *)(a3 + 4 * v6) = v7;
    if ( (v5 & 0xF) != 0 || (unsigned int)dword_9E31C <= 4 )
    {
      if ( v5 == 96 )
        goto LABEL_13;
    }
    else
    {
      strcpy(v14, "\n");
      sub_47EC8(4, v14, 0);
      if ( v5 == 96 )
      {
LABEL_13:
        v8 = dword_9E31C;
        v9 = 0;
        goto LABEL_20;
      }
    }
  }
  if ( (unsigned int)dword_9E31C <= 3 )
  {
    v9 = -1;
    goto LABEL_17;
  }
  v9 = -1;
  snprintf(v14, 0x800u, "dump chain %u, asic %u, failed. found = %u\n", a1, a2, (unsigned __int8)v13);
  sub_47AB4(3, v14, 0);
  v8 = dword_9E31C;
LABEL_20:
  if ( v8 > 4 )
  {
    strcpy(v14, "\n");
    sub_47EC8(4, v14, 0);
  }
LABEL_17:
  sub_2D958(a1, a2, 1, 0);
  byte_138648[0] = 0;
  pthread_mutex_unlock(&stru_A0DB0);
  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v14, "Dump core process monitor data register done.\n");
    sub_47AB4(4, v14, 0);
  }
  return v9;
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002DF9C) --------------------------------------------------------
int __fastcall sub_2DF9C(int a1, int a2)
{
  unsigned int v4; // r4
  int v5; // r9
  int v6; // r1
  char *v7; // r3
  unsigned int v8; // r0
  int v9; // r2
  int v10; // t1
  unsigned int v11; // r0
  char v13; // [sp+4h] [bp-988h] BYREF
  _BYTE s[384]; // [sp+8h] [bp-984h] BYREF
  char v15[2052]; // [sp+188h] [bp-804h] BYREF

  memset(s, 0, sizeof(s));
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v15, 0x800u, "dump chain %u, asic cp pm data:\n", a1);
    sub_47AB4(3, v15, 0);
  }
  v4 = 0;
  do
  {
    memset(s, 0, sizeof(s));
    v5 = sub_2DC90(a1, (unsigned __int8)v4, (int)s);
    if ( v5 )
    {
      *(_BYTE *)(a2 + 8 * v4 + 4) = 1;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(v15, 0x800u, "dump chain %u, asic %u cp pm data failed\n", a1, v4);
        sub_47AB4(3, v15, 0);
      }
    }
    v6 = 0;
    v7 = &v13;
    v8 = 0;
    do
    {
      v10 = *((_DWORD *)v7 + 1);
      v7 += 4;
      v9 = v10;
      if ( v10 )
        v8 += v9;
      else
        ++v6;
    }
    while ( &s[380] != v7 );
    if ( v6 == 96 )
      v11 = 0;
    else
      v11 = v8 / (96 - v6);
    *(_DWORD *)(a2 + 8 * v4) = v11;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v15, 0x800u, "[%3d]:%-6u", v4, v11);
      sub_47EC8(3, v15, 0);
    }
    ++v4;
    if ( v4 == 6 * (v4 / 6) && (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v15, "\n");
      sub_47EC8(3, v15, v4 % 6);
    }
  }
  while ( v4 != 78 );
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v15, "\n");
    sub_47EC8(3, v15, 0);
  }
  return v5;
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002E180) --------------------------------------------------------
void __fastcall sub_2E180(int a1, unsigned int a2, int a3)
{
  unsigned __int8 v5; // r7
  unsigned int v6[2]; // [sp+8h] [bp-80Ch] BYREF
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v5 = a3;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(
      s,
      0x800u,
      "Dump core process monitor data register start.            chain = %d, asic = %d, core = %d\n",
      a1,
      a2,
      a3);
    sub_47AB4(3, s, 0);
  }
  if ( sub_2DA50(a1, a2, v5) )
  {
    v6[1] = 0;
    v6[0] = 0;
    pthread_mutex_lock(&stru_A0DB0);
    byte_138648[0] = 1;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "LVT delay chain.\n");
      sub_47AB4(3, s, 0);
    }
    sub_2D958(a1, a2, 1, 4);
    sub_2D868(a1, a2, v5, 2);
    sub_2A324(a1, a2, 64, (int)v6);
    sub_2C050(v6);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "SVT delay chain.\n");
      sub_47AB4(3, s, 0);
    }
    sub_2D958(a1, a2, 1, 5);
    sub_2D868(a1, a2, v5, 2);
    sub_2A324(a1, a2, 64, (int)v6);
    sub_2C050(v6);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "HVT delay chain.\n");
      sub_47AB4(3, s, 0);
    }
    sub_2D958(a1, a2, 1, 6);
    sub_2D868(a1, a2, v5, 2);
    sub_2A324(a1, a2, 64, (int)v6);
    sub_2C050(v6);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "Critical path chain.\n");
      sub_47AB4(3, s, 0);
    }
    sub_2D958(a1, a2, 1, 7);
    sub_2D868(a1, a2, v5, 2);
    sub_2A324(a1, a2, 64, (int)v6);
    sub_2C050(v6);
    sub_2D958(a1, a2, 1, 0);
    byte_138648[0] = 0;
    pthread_mutex_unlock(&stru_A0DB0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "Dump core process monitor data register done.\n");
      sub_47AB4(3, s, 0);
    }
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "register is invalid.\n");
    sub_47AB4(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002E4F8) --------------------------------------------------------
void __fastcall sub_2E4F8(int a1, unsigned int a2, int a3)
{
  unsigned __int8 v5; // r7
  unsigned int v6[2]; // [sp+8h] [bp-80Ch] BYREF
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v5 = a3;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "Dump core hash clock register start. chain = %d, asic = %d, core = %d\n", a1, a2, a3);
    sub_47AB4(3, s, 0);
  }
  if ( sub_2DA50(a1, a2, v5) )
  {
    v6[1] = 0;
    v6[0] = 0;
    pthread_mutex_lock(&stru_A0DB0);
    byte_138648[0] = 1;
    sub_2D958(a1, a2, 5, 1);
    sub_2D868(a1, a2, v5, 5);
    sub_2A324(a1, a2, 64, (int)v6);
    sub_2C414(v6);
    sub_2D868(a1, a2, v5, 6);
    sub_2A324(a1, a2, 64, (int)v6);
    sub_2C508(v6);
    sub_2D958(a1, a2, 5, 0);
    byte_138648[0] = 0;
    pthread_mutex_unlock(&stru_A0DB0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "Dump core hash clock register done.\n");
      sub_47AB4(3, s, 0);
    }
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "register is invalid.\n");
    sub_47AB4(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002E6D4) --------------------------------------------------------
void __fastcall sub_2E6D4(int a1, unsigned int a2)
{
  _WORD *v4; // r5
  int v5; // t1
  unsigned int v6; // [sp+Ch] [bp-82Ch] BYREF
  _DWORD v7[3]; // [sp+10h] [bp-828h] BYREF
  _BYTE v8[12]; // [sp+1Ch] [bp-81Ch] BYREF
  int v9; // [sp+28h] [bp-810h]
  int v10; // [sp+2Ch] [bp-80Ch]
  int v11; // [sp+30h] [bp-808h]
  __int16 v12; // [sp+34h] [bp-804h] BYREF
  char s[2048]; // [sp+38h] [bp-800h] BYREF

  v7[1] = 201851904;
  v7[2] = 605557776;
  qmemcpy(v8, "(,08DHLPTX\\`", sizeof(v8));
  v9 = -1871943580;
  v10 = -1600350060;
  v11 = -1263489884;
  v12 = -8008;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "Dump asic register start. chain = %d, asic = %d\n", a1, a2);
    sub_47AB4(3, s, 0);
  }
  pthread_mutex_lock(&stru_A0DB0);
  if ( sub_2DA50(a1, a2, 0) )
  {
    v4 = (_WORD *)((char *)v7 + 3);
    do
    {
      v5 = *((unsigned __int8 *)v4 + 1);
      v4 = (_WORD *)((char *)v4 + 1);
      v6 = 0;
      v7[0] = 0;
      sub_2A2D8(a1, a2, v5);
      sub_2A324(a1, a2, v5, (int)&v6);
      sub_2BBB8(v5, &v6);
    }
    while ( v4 != (__int16 *)((char *)&v12 + 1) );
  }
  pthread_mutex_unlock(&stru_A0DB0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "Dump asic register done.\n");
    sub_47AB4(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002E81C) --------------------------------------------------------
void __fastcall sub_2E81C(int a1, unsigned int a2, int a3, int a4)
{
  unsigned int v8[2]; // [sp+Ch] [bp-814h] BYREF
  _BYTE v9[12]; // [sp+14h] [bp-80Ch] BYREF
  int s[512]; // [sp+20h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf((char *)s, 0x800u, "Dump asic register start. chain = %d, asic = %d, reg = 0x%x\n", a1, a2, a3);
    sub_47AB4(3, (const char *)s, 0);
  }
  if ( sub_2DA50(a1, a2, 0) )
  {
    pthread_mutex_lock(&stru_A0DB0);
    v8[0] = 0;
    v8[1] = 0;
    sub_2E9B8();
    sub_2D7C8((int)v9, a2, a3, a4);
    sub_2A29C(s, v9, 9u);
    sub_70808(s, a1);
    sub_2A2D8(a1, a2, a3);
    sub_2A324(a1, a2, a3, (int)v8);
    sub_2BBB8(a3, v8);
    pthread_mutex_unlock(&stru_A0DB0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy((char *)s, "Dump asic register done.\n");
      sub_47AB4(3, (const char *)s, 0);
    }
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy((char *)s, "register is invalid.\n");
    sub_47AB4(3, (const char *)s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0002E9B8) --------------------------------------------------------
int sub_2E9B8()
{
  pthread_mutex_lock(&stru_138630);
  dword_241D68 = 0;
  dword_241D6C = 0;
  dword_241D70 = 0;
  return pthread_mutex_unlock(&stru_138630);
}
// 138630: using guessed type pthread_mutex_t stru_138630;
// 241D68: using guessed type int dword_241D68;
// 241D6C: using guessed type int dword_241D6C;
// 241D70: using guessed type int dword_241D70;

//----- (0002E9F0) --------------------------------------------------------
int sub_2E9F0()
{
  pthread_mutex_lock(&stru_138564);
  dword_23A2B0 = 0;
  dword_23A2B4 = 0;
  dword_23A2B8 = 0;
  return pthread_mutex_unlock(&stru_138564);
}
// 138564: using guessed type pthread_mutex_t stru_138564;
// 23A2B0: using guessed type int dword_23A2B0;
// 23A2B4: using guessed type int dword_23A2B4;
// 23A2B8: using guessed type int dword_23A2B8;

//----- (0002EA28) --------------------------------------------------------
int __fastcall sub_2EA28(int a1, int a2)
{
  int v3; // r2
  int v5; // r6
  int v6; // r9
  int v7; // r8
  int v8; // r11
  int v9; // r0
  int v10; // r2
  _BYTE *v11; // r10
  int v12; // r3
  int *v13; // r1
  int v14; // r12
  int v15; // lr
  unsigned int v16; // r1
  bool v17; // zf
  int v18; // r1
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v3 = dword_A0D68 + 4 * a1;
  if ( *(_DWORD *)(v3 + 4) )
  {
    v5 = 0;
    v6 = 0;
    if ( !a2 )
      *(_BYTE *)(dword_A0D68 + a1 + 12918) = 0;
    sub_2E9B8();
    sub_1AD6C((unsigned __int8)a1, 1, 0, a2);
    while ( 1 )
    {
      while ( 1 )
      {
        sub_4A804();
        pthread_mutex_lock(&stru_138630);
        v7 = dword_241D70;
        v5 += dword_241D70;
        if ( dword_241D70 <= 0 )
          break;
        v8 = dword_A0D68;
        v9 = 0;
        v10 = dword_241D6C;
        v11 = (_BYTE *)(dword_A0D68 + a1 + 12918);
        do
        {
          while ( 1 )
          {
            v12 = v10 + 1;
            ++v9;
            v13 = &dword_241D68[2 * v10 + 2];
            if ( (unsigned int)(v10 + 1) > 0x1FE )
              v12 = 0;
            v14 = *((unsigned __int8 *)v13 + 10);
            v10 = v12;
            v15 = *((unsigned __int8 *)v13 + 11);
            v16 = v13[1];
            v17 = v15 == a1;
            if ( v15 == a1 )
              v17 = v14 == 0;
            if ( v17 )
              break;
            if ( v7 == v9 )
              goto LABEL_21;
          }
          if ( HIWORD(v16) == 5014 )
            ++*v11;
        }
        while ( v7 != v9 );
LABEL_21:
        v18 = *(unsigned __int8 *)(v8 + 12935);
        v6 = 0;
        dword_241D6C = v12;
        dword_241D70 = 0;
        if ( v5 > 390 * v18 )
        {
LABEL_22:
          pthread_mutex_unlock(&stru_138630);
          return 1;
        }
LABEL_27:
        pthread_mutex_unlock(&stru_138630);
      }
      if ( v5 > 390 * *(unsigned __int8 *)(dword_A0D68 + 12935) )
        goto LABEL_22;
      if ( dword_241D70 )
      {
        if ( !a2 && *(_BYTE *)(dword_A0D68 + a1 + 12918) == 78 )
          goto LABEL_22;
        goto LABEL_27;
      }
      ++v6;
      sub_4A804();
      pthread_mutex_unlock(&stru_138630);
      if ( v6 == 4 )
        return 1;
    }
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return *(_DWORD *)(v3 + 4);
  snprintf(s, 0x800u, "Chain %d is not exist.\n", a1);
  sub_47AB4(3, s, 0);
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 138630: using guessed type pthread_mutex_t stru_138630;
// 241D68: using guessed type int dword_241D68[];
// 241D6C: using guessed type int dword_241D6C;
// 241D70: using guessed type int dword_241D70;

//----- (0002EC38) --------------------------------------------------------
int __fastcall sub_2EC38(int a1, int a2, int a3)
{
  int v6; // r11
  int v7; // r10
  int v8; // r2
  int v9; // r7
  int v10; // r5
  int v11; // r1
  unsigned int v12; // r3
  int *v13; // r1
  int v15; // r4
  int v16; // [sp+18h] [bp-814h]
  int *v17; // [sp+18h] [bp-814h]
  char v18; // [sp+1Ch] [bp-810h]
  char v19; // [sp+20h] [bp-80Ch]
  int v20; // [sp+24h] [bp-808h]
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  v16 = (unsigned __int8)a3;
  v18 = a2;
  v6 = ((_BYTE)a1 + 76) & 0xFB;
  v19 = a1;
  v20 = 5;
LABEL_2:
  sub_2E9B8();
  v7 = 8;
  sub_1AD6C(v16, 0, v18, v19);
  while ( 1 )
  {
    sub_4A804();
    pthread_mutex_lock(&stru_138630);
    v8 = dword_241D70;
    if ( dword_241D70 )
      break;
LABEL_19:
    pthread_mutex_unlock(&stru_138630);
    if ( !--v7 )
    {
      if ( !--v20 )
      {
        if ( (unsigned int)dword_9E31C > 4 )
        {
          snprintf(s, 0x800u, "read asic reg timeout: expect chain = %d, chip = %d, reg = %d\n", a3, a2, a1);
          sub_47AB4(4, s, 0);
        }
        sub_2E9B8();
        return 0;
      }
      goto LABEL_2;
    }
  }
  v9 = dword_241D70;
  v10 = 0;
  while ( 1 )
  {
    v11 = 510;
    dword_241D70 = v8 - 1;
    v12 = dword_241D6C + 1;
    if ( (unsigned int)(dword_241D6C + 1) <= 0x1FE )
      ++dword_241D6C;
    else
      v11 = 0;
    if ( v12 > 0x1FE )
      dword_241D6C = v11;
    v13 = &dword_241D68[2 * v12];
    if ( *((unsigned __int8 *)v13 + 11) == a3
      && *((unsigned __int8 *)v13 + 9) == a2
      && *((unsigned __int8 *)v13 + 10) == a1 )
    {
      break;
    }
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_9;
    ++v10;
    snprintf(
      s,
      0x800u,
      "read asic reg error: expect chain = %d, chip = %d, reg = %d, got chain = %d, chip = %d, reg = %d\n",
      a3,
      a2,
      a1,
      *((unsigned __int8 *)v13 + 11),
      BYTE1(dword_241D68[2 * v12 + 2]),
      BYTE2(dword_241D68[2 * v12 + 2]));
    sub_47AB4(3, s, 0);
    if ( v9 == v10 )
      goto LABEL_19;
LABEL_10:
    v8 = dword_241D70;
  }
  if ( a1 != 28 )
  {
    if ( !v6 )
    {
      v17 = &dword_241D68[2 * v12];
      pthread_mutex_unlock(&stru_138630);
      sub_2E9B8();
      return v17[1];
    }
LABEL_9:
    if ( v9 == ++v10 )
      goto LABEL_19;
    goto LABEL_10;
  }
  v15 = v13[1];
  if ( (v15 & 0xE0000000) != 0 )
    v15 = 0;
  pthread_mutex_unlock(&stru_138630);
  sub_2E9B8();
  return v15;
}
// 9E31C: using guessed type int dword_9E31C;
// 138630: using guessed type pthread_mutex_t stru_138630;
// 241D68: using guessed type int dword_241D68[];
// 241D6C: using guessed type int dword_241D6C;
// 241D70: using guessed type int dword_241D70;

//----- (0002EE74) --------------------------------------------------------
void __fastcall sub_2EE74(int a1)
{
  int v2; // r8
  int v3; // r5
  int *v4; // r7
  unsigned int v5; // r5
  int v6; // r7
  unsigned int v7; // r4
  unsigned int v8; // r8
  unsigned int v9; // r0
  unsigned int v10; // r4
  _BOOL4 v11; // r3
  _BOOL4 v12; // r3
  int v13; // r3
  unsigned int v14; // r3
  bool v15; // cc
  char s[2080]; // [sp+8h] [bp-820h] BYREF

  if ( byte_A0D91 )
  {
    if ( (*(_BYTE *)a1 & 0x80) != 0 )
    {
      if ( (*(_BYTE *)a1 & 0x40) != 0 )
      {
        if ( (unsigned int)dword_9E31C > 3 )
        {
          strcpy(s, "!!! nonce crc error\n");
          sub_47AB4(3, s, 0);
        }
        ++dword_242D70;
      }
      else
      {
        pthread_mutex_lock(&stru_138564);
        if ( (unsigned int)dword_23A2B8 <= 0x1FE )
        {
          v2 = *(_WORD *)(a1 + 2) & 0x7FFF;
          v3 = 15 * dword_23A2B0[0];
          v4 = &dword_23A2B0[15 * dword_23A2B0[0]];
          v4[4] = v2;
          v4[8] = *(_DWORD *)(a1 + 4);
          v4[9] = *(_BYTE *)a1 & 0xF;
          v4[3] = sub_6F69C(v2);
          v4[5] = sub_6F6B0(v2);
          *((_QWORD *)v4 + 3) = sub_6F684(v2);
          sub_6F6C8(v2, (int)&dword_23A2B0[v3 + 10], 32);
          v5 = v4[8];
          v6 = v4[9];
          v7 = *(unsigned __int8 *)(dword_A0D68 + 12954);
          if ( !*(_BYTE *)(dword_A0D68 + 12954) )
            v7 = 3;
          v8 = sub_75CEC(v5);
          v9 = sub_75CF4(v5, v7);
          v10 = v9;
          v11 = v9 > 0x4D;
          if ( v6 > 15 )
            v11 = 1;
          if ( v11 )
            goto LABEL_33;
          v12 = v5 == 0;
          if ( v8 > 0x5F )
            v12 = 1;
          if ( v12 )
          {
LABEL_33:
            if ( (unsigned int)dword_9E31C > 4 )
            {
              snprintf(s, 0x800u, "buf [%x] is error!\n", v5);
              sub_47AB4(4, s, 0);
              if ( (unsigned int)dword_9E31C > 4 )
              {
                snprintf(s, 0x800u, "chain = %d, chip = %d, core = %d\n", v6, v10, v8);
                sub_47AB4(4, s, 0);
              }
            }
          }
          else
          {
            v13 = 7488 * v6 + 96 * v9 + v8 + 1264;
            ++dword_13864C[v13];
          }
          v14 = dword_23A2B0[0] + 1;
          v15 = (unsigned int)(dword_23A2B0[0] + 1) > 0x1FE;
          dword_23A2B0[0] = v14;
          if ( v14 > 0x1FE )
            v14 = 0;
          ++dword_23A2B8;
          if ( v15 )
            dword_23A2B0[0] = v14;
        }
        else if ( (unsigned int)dword_9E31C > 3 )
        {
          strcpy(s, "nonce_read_out buffer is full!\n");
          sub_47AB4(3, s, 0);
        }
        pthread_mutex_unlock(&stru_138564);
      }
    }
    else if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "!!! nonce invalid\n");
      sub_47AB4(3, s, 0);
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// A0D91: using guessed type char byte_A0D91;
// 138564: using guessed type pthread_mutex_t stru_138564;
// 13864C: using guessed type _DWORD dword_13864C[1263];
// 23A2B0: using guessed type int dword_23A2B0[];
// 23A2B8: using guessed type int dword_23A2B8;
// 242D70: using guessed type int dword_242D70;

//----- (0002F194) --------------------------------------------------------
void __fastcall sub_2F194(int a1)
{
  int v2; // r2
  int v3; // r4
  unsigned int v4; // r0
  int *v5; // r1
  int v6; // lr
  char v7[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (*(_BYTE *)a1 & 0x40) != 0 )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v7, "!!! reg crc error\n");
      sub_47AB4(3, v7, 0);
    }
    ++dword_242D6C;
  }
  else if ( (*(_BYTE *)(a1 + 3) & 0x60) != 0 )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v7, 0x800u, "!!! REG_TYPE = 1. %u\n", *(_DWORD *)a1);
      sub_47AB4(3, v7, 0);
    }
  }
  else
  {
    pthread_mutex_lock(&stru_138630);
    v2 = dword_241D70;
    if ( (unsigned int)dword_241D70 > 0x1FE )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy(v7, "reg_value_buf buffer is full!\n");
        sub_47AB4(3, v7, 0);
      }
    }
    else
    {
      v3 = (unsigned __int8)byte_138648[0];
      v4 = dword_241D68[0] + 1;
      v5 = &dword_241D68[2 * dword_241D68[0] + 2];
      v5[1] = *(_DWORD *)(a1 + 4);
      *((_BYTE *)v5 + 8) = *(_BYTE *)(a1 + 3) & 0x1F;
      *((_BYTE *)v5 + 9) = *(_BYTE *)(a1 + 2);
      v6 = *(unsigned __int8 *)(a1 + 1);
      if ( v6 != 64 )
        v3 |= 1u;
      *((_BYTE *)v5 + 10) = v6;
      *((_BYTE *)v5 + 11) = *(_BYTE *)a1 & 0xF;
      if ( v3 )
      {
        dword_241D68[0] = v4;
        dword_241D70 = v2 + 1;
        if ( v4 > 0x1FE )
          dword_241D68[0] = 0;
      }
    }
    pthread_mutex_unlock(&stru_138630);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 138630: using guessed type pthread_mutex_t stru_138630;
// 241D68: using guessed type int dword_241D68[];
// 241D70: using guessed type int dword_241D70;
// 242D6C: using guessed type int dword_242D6C;

//----- (0002F354) --------------------------------------------------------
void sub_2F354()
{
  int i; // r8
  unsigned int v1; // r12
  int v2; // r6
  char *v3; // r4
  int v4; // r3
  char *v5; // r0
  int v6; // r2
  int v7; // t1
  unsigned int v8; // r5
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(s, "\n dump asic nonce number...\n");
    sub_47AB4(4, s, 0);
  }
  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) )
    {
      v1 = dword_9E31C;
      if ( (unsigned int)dword_9E31C > 4 )
      {
        snprintf(s, 0x800u, "Chain[%d]:\n", i);
        sub_47AB4(4, s, 0);
        v1 = dword_9E31C;
      }
      v2 = 0;
      v3 = (char *)&unk_139A08 + 29952 * i;
      v4 = 0;
      do
      {
        v5 = v3 + 384;
        v6 = 0;
        do
        {
          v7 = *((_DWORD *)v3 + 1);
          v3 += 4;
          v6 += v7;
        }
        while ( v3 != v5 );
        v2 += v6;
        v8 = v4 + 1;
        if ( v1 > 4 )
        {
          snprintf(s, 0x800u, "IC[%03d] = %-10d ", v4, v6);
          sub_47AB4(4, s, 0);
          v1 = dword_9E31C;
          if ( v8 == 6 * (v8 / 6) && (unsigned int)dword_9E31C > 4 )
          {
            strcpy(s, "\n");
            sub_47AB4(4, s, v8 % 6);
            v1 = dword_9E31C;
          }
        }
        v4 = v8;
      }
      while ( v8 != 78 );
      if ( v1 > 4 )
      {
        snprintf(s, 0x800u, "Chain[%d] total nonce number = %d\n", i, v2);
        sub_47AB4(4, s, 0);
        if ( (unsigned int)dword_9E31C > 4 )
        {
          strcpy(s, "\n");
          sub_47AB4(4, s, 0);
        }
      }
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (0002F530) --------------------------------------------------------
int __fastcall sub_2F530(int a1, unsigned int a2)
{
  unsigned int v2; // r3
  int v3; // r1
  int v4; // r3
  int v5; // r12
  int result; // r0
  int v7; // lr
  char *v8; // r12
  char *v9; // r3
  int v10; // t1

  v2 = a2 >> 2;
  v3 = 3 * (a2 & 3);
  v4 = 3 * v2;
  if ( (unsigned int)(2 * v4) > 0xFFFFFFF9 )
    return 0;
  v5 = 29952 * a1;
  result = 0;
  v7 = 6;
  v8 = &byte_138648[768 * v4 + 5056 + 32 * v3 + v5];
  do
  {
    v9 = v8;
    do
    {
      v10 = *((_DWORD *)v9 + 1);
      v9 += 4;
      result += v10;
    }
    while ( v9 != v8 + 96 );
    --v7;
    v8 += 384;
  }
  while ( v7 );
  return result;
}

//----- (0002F5AC) --------------------------------------------------------
void sub_2F5AC()
{
  int v0; // r6
  int i; // r10
  unsigned int v2; // lr
  int v3; // r5
  int v4; // r4
  int v5; // r2
  int v6; // r8
  _DWORD *v7; // r12
  _DWORD *v8; // r3
  int v9; // t1
  char v10; // r8
  int v11; // r3
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(s, "\n dump domain nonce number...\n");
    sub_47AB4(4, s, 0);
  }
  v0 = 0;
  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) )
    {
      v2 = dword_9E31C;
      if ( (unsigned int)dword_9E31C > 4 )
      {
        snprintf(s, 0x800u, "Chain[%d]:\n", i);
        sub_47AB4(4, s, 0);
        v2 = dword_9E31C;
      }
      v3 = 0;
      v4 = 0;
      do
      {
        if ( 6 * ((unsigned int)v4 >> 2) <= 0xFFFFFFF9 )
        {
          v6 = 6;
          v5 = 0;
          v7 = &dword_13864C[576 * ((unsigned int)v4 >> 2) + 1263 + 24 * (v4 & 3) + v0];
          do
          {
            v8 = v7;
            do
            {
              v9 = v8[1];
              ++v8;
              v5 += v9;
            }
            while ( v7 + 24 != v8 );
            --v6;
            v7 += 96;
          }
          while ( v6 );
          v3 += v5;
        }
        else
        {
          v5 = 0;
        }
        if ( v2 > 4 )
        {
          v10 = v4 + 1;
          snprintf(s, 0x800u, "D[%02d]:%-10d ", v4, v5);
          sub_47AB4(4, s, 0);
          v2 = dword_9E31C;
          if ( (((_BYTE)v4 + 1) & 3) != 0 )
          {
            ++v4;
          }
          else if ( (unsigned int)dword_9E31C > 4 )
          {
            v11 = v4++ >> 2;
            snprintf(s, 0x800u, "D_BIG[%02d]:%-10d\n", v11, v3);
            v3 = v10 & 3;
            sub_47AB4(4, s, v3);
            v2 = dword_9E31C;
          }
          else
          {
            ++v4;
            v3 = v10 & 3;
          }
        }
        else if ( (++v4 & 3) == 0 )
        {
          v3 = 0;
        }
      }
      while ( v4 != 52 );
      if ( v2 > 4 )
      {
        strcpy(s, "\n");
        sub_47AB4(4, s, 0);
      }
    }
    v0 += 7488;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 13864C: using guessed type _DWORD dword_13864C[1263];

//----- (0002F7DC) --------------------------------------------------------
char *sub_2F7DC()
{
  return off_9C554;
}
// 9C554: using guessed type char *off_9C554;

//----- (0002F7EC) --------------------------------------------------------
void __fastcall sub_2F7EC(int a1, int a2)
{
  unsigned int v3; // r3
  int v5; // r6
  unsigned int v6; // r4
  int v7; // r2
  int v8; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v3 = dword_9E31C;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "\n asic nonce number for chain[%d] asic[%d]...\n", a1, a2);
    sub_47AB4(3, s, 0);
    v3 = dword_9E31C;
  }
  v5 = 384 * a2 + 29952 * a1;
  v6 = 0;
  do
  {
    while ( v3 <= 3 )
    {
      ++v6;
LABEL_4:
      if ( v6 == 96 )
        goto LABEL_10;
    }
    v7 = v5 + 4 * v6;
    v8 = v6++;
    snprintf(s, 0x800u, "core[%03d]=%-8d", v8, *(_DWORD *)((char *)&dword_13864C[1264] + v7));
    sub_47AB4(3, s, 0);
    v3 = dword_9E31C;
    if ( v6 != 10 * (v6 / 0xA) || (unsigned int)dword_9E31C <= 3 )
      goto LABEL_4;
    strcpy(s, "\n");
    sub_47AB4(3, s, v6 % 0xA);
    v3 = dword_9E31C;
  }
  while ( v6 != 96 );
LABEL_10:
  if ( v3 > 3 )
  {
    strcpy(s, "\n");
    sub_47AB4(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 13864C: using guessed type _DWORD dword_13864C[1263];

//----- (0002F930) --------------------------------------------------------
void sub_2F930()
{
  int i; // r5
  int j; // r4
  int v2; // r1

  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
    {
      for ( j = 0; j != 78; ++j )
      {
        v2 = j;
        sub_2F7EC(i, v2);
      }
    }
  }
}
// A0D68: using guessed type int dword_A0D68;

//----- (0002F984) --------------------------------------------------------
void sub_2F984()
{
  FILE *v0; // r5
  int v1; // r0
  FILE *v2; // r4
  unsigned int v3; // r4
  unsigned int v4; // r3
  int v5; // r5
  int v6; // r0
  int v7; // r0
  unsigned __int8 v8; // r3
  FILE *v9; // r5
  int v10; // r6
  int v11; // r4
  int v12; // r6
  int v13; // r4
  int i; // r4
  int v15; // [sp+8h] [bp-828h] BYREF
  int v16; // [sp+Ch] [bp-824h] BYREF
  char s[32]; // [sp+10h] [bp-820h] BYREF
  char ptr[2048]; // [sp+30h] [bp-800h] BYREF

  v15 = 0;
  v16 = 0;
  v0 = (FILE *)fopen64("/tmp/testID", "rb");
  if ( v0 )
  {
    memset(s, 0, sizeof(s));
    fread(s, 1u, 0x20u, v0);
    fclose(v0);
    if ( s[0] == 48 && s[1] == 120 )
    {
      _isoc99_sscanf(s, "%x %x", &v15, &v16);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(ptr, 0x800u, "receive test id :0x%x, data : 0x%x!\n", v15, v16);
        sub_47AB4(3, ptr, 0);
      }
    }
    else
    {
      v1 = strtol(s, 0, 10);
      v15 = v1;
      if ( v1 && (unsigned int)dword_9E31C > 3 )
      {
        snprintf(ptr, 0x800u, "receive test id :%d!\n", v1);
        sub_47AB4(3, ptr, 0);
      }
    }
  }
  v2 = (FILE *)fopen64("/tmp/testID", "wb");
  if ( v2 )
  {
    memset(ptr, 0, 0x20u);
    sprintf(ptr, "%d", 0);
    fwrite(ptr, 1u, 0x20u, v2);
    fclose(v2);
  }
  v3 = v15;
  if ( v15 )
  {
    switch ( v15 )
    {
      case 11:
        sub_2F930();
        break;
      case 12:
        v7 = dword_9C558;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(ptr, 0x800u, "current voltage raw = %d\n", dword_9C558);
          sub_47AB4(3, ptr, 0);
          v7 = dword_9C558;
        }
        sub_1A0F0(v7);
        sub_1A3B8();
        dword_9C558 -= 10;
        break;
      case 13:
        v6 = dword_9C55C;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(ptr, 0x800u, "current voltage raw = %d\n", dword_9C55C);
          sub_47AB4(3, ptr, 0);
          v6 = dword_9C55C;
        }
        sub_1A0F0(v6);
        sub_1A3B8();
        dword_9C55C += 10;
        break;
      case 14:
        v8 = dword_9C560;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(ptr, 0x800u, "current pwm = %d\n", dword_9C560);
          sub_47AB4(3, ptr, 0);
          v8 = dword_9C560;
        }
        sub_13EE8(v8);
        dword_9C560 -= 3;
        break;
      case 15:
        v10 = sub_1A1B0() + 20;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(ptr, 0x800u, "Increase voltage to get pm, current voltage raw = %d\n", v10);
          sub_47AB4(3, ptr, 0);
        }
        v11 = 0;
        sub_1A0F0(v10);
        sub_1A3B8();
        do
        {
          if ( *(_DWORD *)(dword_A0D68 + 4 * v11 + 4) == 1 )
          {
            memset(ptr, 0, 0x270u);
            sub_2DF9C(v11, (int)ptr);
          }
          ++v11;
        }
        while ( v11 != 16 );
        break;
      case 16:
        v12 = sub_1A1B0() - 20;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(ptr, 0x800u, "Decrease voltage to get pm, current voltage raw = %d\n", v12);
          sub_47AB4(3, ptr, 0);
        }
        v13 = 0;
        sub_1A0F0(v12);
        sub_1A3B8();
        do
        {
          if ( *(_DWORD *)(dword_A0D68 + 4 * v13 + 4) == 1 )
          {
            memset(ptr, 0, 0x270u);
            sub_2DF9C(v13, (int)ptr);
          }
          ++v13;
        }
        while ( v13 != 16 );
        break;
      case 17:
        if ( (unsigned int)dword_9E31C > 1 )
        {
          strcpy(ptr, "try to set log level...\n");
          sub_47AB4(1, ptr, 0);
        }
        v9 = (FILE *)fopen64("/etc/config/log_level", "rb");
        if ( v9 )
        {
          memset(s, 0, sizeof(s));
          fread(s, 1u, 0x20u, v9);
          fclose(v9);
          strtol(s, 0, 10);
          if ( (unsigned int)dword_9E31C > 1 )
          {
            snprintf(ptr, 0x800u, "log level set to %d\n", dword_9E31C);
            sub_47AB4(1, ptr, 0);
          }
        }
        break;
      case 18:
        byte_A06B8 = 0;
        if ( sub_257E4() )
          sub_226C0(4u, "reopen core failed!");
        sub_20B28();
        break;
      case 19:
        for ( i = 0; i != 16; ++i )
        {
          if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
          {
            sub_1AA2C((unsigned __int8)i);
            sub_1AA30((unsigned __int8)i, 0, 0);
            sub_1A9D4((unsigned __int8)i);
          }
        }
        break;
      default:
        v4 = v15 & 0xFF000000;
        if ( (v15 & 0xFF000000) == 0xA0000000 )
        {
          if ( (unsigned int)dword_9E31C > 3 )
          {
            strcpy(ptr, "dump asic reg!\n");
            sub_47AB4(3, ptr, 0);
          }
          sub_2E6D4((v3 >> 20) & 0xF, (unsigned __int8)(v3 >> 12));
        }
        else
        {
          switch ( v4 )
          {
            case 0xB0000000:
              if ( (unsigned int)dword_9E31C > 3 )
              {
                strcpy(ptr, "dump core reg!\n");
                sub_47AB4(3, ptr, 0);
              }
              sub_2DB40((v3 >> 20) & 0xF, (unsigned __int8)(v3 >> 12), (unsigned __int8)v3);
              break;
            case 0xB1000000:
              if ( (unsigned int)dword_9E31C > 3 )
              {
                strcpy(ptr, "dump core process monitor reg!\n");
                sub_47AB4(3, ptr, 0);
              }
              sub_2E180((v3 >> 20) & 0xF, (unsigned __int8)(v3 >> 12), (unsigned __int8)v3);
              break;
            case 0xB2000000:
              if ( (unsigned int)dword_9E31C > 3 )
              {
                strcpy(ptr, "dump core clock counter reg!\n");
                sub_47AB4(3, ptr, 0);
              }
              sub_2E4F8((v3 >> 20) & 0xF, (unsigned __int8)(v3 >> 12), (unsigned __int8)v3);
              break;
            case 0xC0000000:
              v5 = v16;
              if ( (unsigned int)dword_9E31C > 3 )
              {
                strcpy(ptr, "write asic reg!\n");
                sub_47AB4(3, ptr, 0);
              }
              sub_2E81C((v3 >> 20) & 0xF, (unsigned __int8)(v3 >> 12), (unsigned __int8)v3, v5);
              break;
          }
        }
        break;
    }
  }
}
// 122EC: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1AA2C: using guessed type int __fastcall sub_1AA2C(_DWORD);
// 9C558: using guessed type int dword_9C558;
// 9C55C: using guessed type int dword_9C55C;
// 9C560: using guessed type int dword_9C560;
// 9E31C: using guessed type int dword_9E31C;
// A06B8: using guessed type char byte_A06B8;
// A0D68: using guessed type int dword_A0D68;

//----- (0003011C) --------------------------------------------------------
int __fastcall sub_3011C(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) - *(_DWORD *)(a2 + 4);
}

//----- (0003012C) --------------------------------------------------------
int __fastcall sub_3012C(int a1, int a2)
{
  return *(_DWORD *)(a2 + 4) - *(_DWORD *)(a1 + 4);
}

//----- (0003013C) --------------------------------------------------------
int __fastcall sub_3013C(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0003014C) --------------------------------------------------------
int __fastcall sub_3014C(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // r12
  int v5; // r2
  int v6; // r4
  _DWORD *v7; // r12
  int v8; // r2
  int v9; // t1

  if ( *a2 >= a1 )
    return 0;
  v4 = a3 + 0x3FFFFFFF;
  v5 = a3 - 1;
  if ( a2[v4] <= a1 )
    return v5;
  if ( v5 <= 0 || a1 <= a2[1] )
  {
    v8 = 0;
  }
  else
  {
    v6 = v5;
    v7 = a2 + 1;
    v8 = 0;
    do
    {
      if ( ++v8 == v6 )
        break;
      v9 = v7[1];
      ++v7;
    }
    while ( a1 > v9 );
  }
  if ( a4 || a2[v8 + 1] + a2[v8] <= 2 * a1 )
    ++v8;
  return v8;
}

//----- (000301EC) --------------------------------------------------------
int sub_301EC()
{
  int result; // r0
  int v1; // r3
  int v2; // r4
  int v3; // r5
  int *v4; // r2
  int v5; // t1
  _DWORD *v6; // r2
  int v7; // t1
  _BYTE v8[8]; // [sp+0h] [bp-93Ch] BYREF
  int v9; // [sp+134h] [bp-808h] BYREF
  char s[2052]; // [sp+138h] [bp-804h] BYREF

  result = dword_1AEA10;
  if ( !dword_1AEA10 )
  {
    v1 = dword_A0D68;
    if ( dword_9C294 != 2 )
    {
      v2 = dword_1AEA10;
      v3 = dword_1AEA10;
      while ( 1 )
      {
        if ( *(_DWORD *)(v1 + 4 * v3 + 4) == 1 )
        {
          sub_18D10(v3, (unsigned __int8)dword_9EE38, (int)v8);
          v4 = (int *)&v8[-4];
          do
          {
            v5 = v4[1];
            ++v4;
            v2 += 383 * v5;
          }
          while ( v4 != &v9 );
          if ( ++v3 == 16 )
            goto LABEL_10;
        }
        else if ( ++v3 == 16 )
        {
          goto LABEL_10;
        }
        v1 = dword_A0D68;
      }
    }
    v6 = &unk_242DB4;
    v2 = dword_1AEA10;
    do
    {
      v7 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      ++v6;
      if ( v7 == 1 )
        v2 += 29874 * *(v6 - 1);
    }
    while ( v6 != (_DWORD *)&unk_242DF4 );
LABEL_10:
    result = v2 / 1000;
    dword_1AEA10 = result;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "max_hash_rate = %d\n", v2 / 1000);
      sub_47AB4(3, s, 0);
      return dword_1AEA10;
    }
  }
  return result;
}
// 9C294: using guessed type int dword_9C294;
// 9E31C: using guessed type int dword_9E31C;
// 9EE38: using guessed type int dword_9EE38;
// A0D68: using guessed type int dword_A0D68;
// 1AEA10: using guessed type int dword_1AEA10;

//----- (00030348) --------------------------------------------------------
int sub_30348()
{
  int v0; // r7
  int v1; // r2
  int v2; // r4
  _DWORD *v3; // r1
  int v4; // t1
  int v6; // [sp+4h] [bp-804h] BYREF
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v0 = dword_1AEA14;
  v6 = 0;
  if ( dword_1AEA14 )
    return v0;
  v1 = dword_A0D68;
  if ( dword_9C294 == 2 )
  {
    v3 = &unk_242DB4;
    do
    {
      v4 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      ++v3;
      if ( v4 == 1 )
        v0 += 29874 * *(v3 - 1);
    }
    while ( v3 != (_DWORD *)&unk_242DF4 );
    v0 /= 1000;
  }
  else
  {
    v2 = dword_1AEA14;
    while ( 1 )
    {
      if ( *(_DWORD *)(v1 + 4 * v2 + 4) == 1 )
      {
        sub_18EE4(v2, (unsigned __int8)dword_9EE38, &v6);
        v0 += v6;
      }
      if ( ++v2 == 16 )
        break;
      v1 = dword_A0D68;
    }
  }
  dword_1AEA14 = v0;
  if ( (unsigned int)dword_9E31C <= 3 )
    return v0;
  snprintf(s, 0x800u, "ideal_hash_rate = %d\n", v0);
  sub_47AB4(3, s, 0);
  return dword_1AEA14;
}
// 9C294: using guessed type int dword_9C294;
// 9E31C: using guessed type int dword_9E31C;
// 9EE38: using guessed type int dword_9EE38;
// A0D68: using guessed type int dword_A0D68;
// 1AEA14: using guessed type int dword_1AEA14;

//----- (0003047C) --------------------------------------------------------
int sub_3047C()
{
  int result; // r0
  char v1[2048]; // [sp+0h] [bp-800h] BYREF

  result = dword_1AEA18;
  if ( !dword_1AEA18 )
  {
    if ( *(_DWORD *)(dword_1AEA1C + 4) <= sub_30348() )
    {
      result = (*(int (**)(void))(dword_1AEA1C + 8))();
      dword_1AEA18 = result;
    }
    else
    {
      result = dword_1AEA18;
    }
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v1, 0x800u, "sale_hash_rate = %d\n", result);
      sub_47AB4(3, v1, 0);
      return dword_1AEA18;
    }
  }
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA18: using guessed type int dword_1AEA18;
// 1AEA1C: using guessed type int dword_1AEA1C;

//----- (0003050C) --------------------------------------------------------
int __fastcall sub_3050C(int a1, int a2)
{
  return sub_3014C(a1, (_DWORD *)(dword_1AEA20 + 4), *(_DWORD *)dword_1AEA20, a2);
}
// 1AEA20: using guessed type int dword_1AEA20;

//----- (00030524) --------------------------------------------------------
int __fastcall sub_30524(int a1, int a2)
{
  return sub_3014C(a1, (_DWORD *)(dword_1AEA20 + 72), *(_DWORD *)(dword_1AEA20 + 68), a2);
}
// 1AEA20: using guessed type int dword_1AEA20;

//----- (00030540) --------------------------------------------------------
int __fastcall sub_30540(int a1, int a2)
{
  return *(_DWORD *)(dword_1AEA20 + 4 * (a2 + 8 * a1 + 154));
}
// 1AEA20: using guessed type int dword_1AEA20;

//----- (0003055C) --------------------------------------------------------
int __fastcall sub_3055C(int a1, int a2)
{
  return *(_DWORD *)(dword_1AEA20 + 4 * (a2 + 8 * a1 + 26));
}
// 1AEA20: using guessed type int dword_1AEA20;

//----- (00030578) --------------------------------------------------------
int sub_30578()
{
  return 0;
}

//----- (00030580) --------------------------------------------------------
int __fastcall sub_30580(int a1)
{
  int v1; // r3

  if ( dword_9C294 == 2 )
    LOWORD(v1) = 11700;
  else
    LOWORD(v1) = 11636;
  HIWORD(v1) = 36;
  return *(_DWORD *)(v1 + 4 * a1);
}
// 9C294: using guessed type int dword_9C294;

//----- (000305A8) --------------------------------------------------------
int sub_305A8()
{
  int v0; // r4
  int v1; // r9
  char *v3; // r2
  unsigned int v4; // r3
  unsigned int v5; // t1
  unsigned int v6; // [sp+Ch] [bp-804h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v0 = sub_36B40((int *)&v6);
  if ( v0 )
  {
    sub_31794(3, 255);
    sub_226C0(0xBu, "Get max freq failed!");
    return -1;
  }
  else
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * v0 + 4) != 1 )
    {
LABEL_3:
      if ( ++v0 == 16 )
        return 0;
    }
    v1 = 312 * v0;
    memset((char *)&unk_1371C8 + 312 * v0, 0, 0x138u);
    if ( !sub_18D10(v0, (unsigned __int8)dword_9EE38, (int)&unk_1371C8 + 312 * v0) )
    {
      v3 = (char *)&unk_1371C4 + v1;
      while ( 1 )
      {
        v5 = *((_DWORD *)v3 + 1);
        v3 += 4;
        v4 = v5;
        if ( v5 > v6 )
          break;
        if ( v3 == (char *)&unk_1372FC + v1 )
          goto LABEL_3;
      }
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "Freq(%d) > Max_freq(%d), invalid!\n", v4, v6);
        sub_47AB4(3, s, 0);
      }
    }
    sub_31794(3, 255);
    sub_226C0(0xBu, "Get frequency failed!");
    return -1;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 9EE38: using guessed type int dword_9EE38;
// A0D68: using guessed type int dword_A0D68;

//----- (000306F0) --------------------------------------------------------
int __fastcall sub_306F0(int a1, int a2)
{
  int v4; // r6
  int v5; // r4
  int v6; // r0
  int v7; // r5
  int result; // r0

  v4 = sub_1A1C0();
  if ( a2 )
  {
    v5 = sub_3014C(a1, (_DWORD *)(dword_1AEA20 + 4), *(_DWORD *)dword_1AEA20, 1);
    v6 = sub_16940();
    v7 = dword_1AEA20;
    result = *(_DWORD *)(v7
                       + 4
                       * (sub_3014C(v6, (_DWORD *)(dword_1AEA20 + 72), *(_DWORD *)(dword_1AEA20 + 68), 1) + 8 * v5 + 26));
    if ( result == v4 )
      return result;
    return sub_1A4F0(result);
  }
  result = sub_1A1B0();
  if ( result != v4 )
    return sub_1A4F0(result);
  return result;
}
// 1AEA20: using guessed type int dword_1AEA20;

//----- (00030770) --------------------------------------------------------
void __fastcall sub_30770(int a1, unsigned int a2, int a3, int a4)
{
  bool v4; // zf
  const char *v5; // r3
  unsigned int v6; // r11
  unsigned int v7; // r8
  unsigned int v8; // r2
  unsigned int v9; // r6
  unsigned int v10; // r5
  _QWORD *v11; // r4
  int v12; // r7
  _QWORD *v13; // r4
  unsigned __int8 *v14; // r6
  int v15; // r5
  int v16; // lr
  int v17; // r3
  int v18; // r1
  int v19; // r0
  int v20; // r12
  int v21; // r6
  char v22; // r3
  char v23; // r1
  char v24; // r2
  unsigned int v25; // r7
  size_t nmemb; // [sp+10h] [bp-9BCh]
  int v27; // [sp+14h] [bp-9B8h]
  unsigned int v28; // [sp+20h] [bp-9ACh]
  _BYTE v32[4]; // [sp+34h] [bp-998h] BYREF
  int v33; // [sp+38h] [bp-994h] BYREF
  int v34; // [sp+3Ch] [bp-990h]
  _QWORD base[49]; // [sp+40h] [bp-98Ch] BYREF
  char s[2052]; // [sp+1C8h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    v4 = a4 == 0;
    v5 = "false";
    if ( !v4 )
      v5 = "true";
    snprintf(s, 0x800u, "chain = %d, freq = %d, is_higher_voltage = %s\n", a1, a3, v5);
    sub_47AB4(3, s, 0);
  }
  v33 = 0;
  v34 = 0;
  memset(base, 0, sizeof(base));
  sub_74E08((int)&v33, v32, 0);
  v6 = v32[0];
  BYTE2(v34) = v32[0];
  v28 = BYTE1(v33);
  if ( (unsigned __int8)v33 > 7u )
  {
    nmemb = 0;
    v8 = dword_9E31C;
  }
  else
  {
    v27 = (unsigned __int8)v33;
    v7 = (unsigned __int8)v33;
    nmemb = 0;
    v8 = dword_9E31C;
    do
    {
      if ( v28 <= v7 )
      {
        v9 = v28;
        do
        {
          if ( v6 <= 1 )
          {
            v10 = v6;
            v11 = &base[nmemb];
            v12 = v9 * v27 * v6;
            do
            {
              *(_BYTE *)v11 = v7;
              *((_BYTE *)v11 + 1) = v9;
              *((_BYTE *)v11 + 2) = v10;
              *((_DWORD *)v11 + 1) = v12;
              if ( v8 > 4 )
              {
                snprintf(s, 0x800u, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v27, v9, v10, v12);
                sub_47AB4(4, s, 0);
                v8 = dword_9E31C;
              }
              ++v10;
              ++v11;
              v12 += v9 * v27;
            }
            while ( (unsigned __int8)v10 <= 1u );
            nmemb += (unsigned __int8)(1 - v6) + 1;
          }
          v9 = (unsigned __int8)(v9 + 1);
        }
        while ( v9 <= v7 );
      }
      v7 = (unsigned __int8)++v27;
    }
    while ( (unsigned __int8)v27 <= 7u );
  }
  if ( v8 > 4 )
  {
    strcpy(s, "\n");
    sub_47AB4(4, s, 0);
    if ( (unsigned int)dword_9E31C > 4 )
    {
      strcpy(s, "sorted\n");
      sub_47AB4(4, s, 0);
    }
  }
  qsort(base, nmemb, 8u, (__compar_fn_t)sub_3012C);
  if ( nmemb )
  {
    v13 = base;
    v14 = (unsigned __int8 *)base;
    v15 = 0;
    do
    {
      while ( (unsigned int)dword_9E31C <= 4 )
      {
        ++v15;
        v14 += 8;
        if ( v15 == nmemb )
          goto LABEL_24;
      }
      v16 = *((_DWORD *)v14 + 1);
      v17 = v15;
      v18 = v14[2];
      v19 = v14[1];
      ++v15;
      v20 = *v14;
      v14 += 8;
      snprintf(s, 0x800u, "[%d] post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v17, v20, v19, v18, v16);
      sub_47AB4(4, s, 0);
    }
    while ( v15 != nmemb );
LABEL_24:
    v21 = 0;
    do
    {
      v22 = *((_BYTE *)v13++ + 2);
      v23 = *((_BYTE *)v13 - 8);
      v24 = *((_BYTE *)v13 - 7);
      BYTE2(v34) = v22;
      LOBYTE(v33) = v23;
      BYTE1(v33) = v24;
      v25 = sub_1B194();
      if ( (unsigned int)dword_9E31C > 4 )
      {
        snprintf(
          s,
          0x800u,
          "[%d] _POSTDIV1 = %d, _POSTDIV2 = %d, USER_DIV = %d, freq = %d\n",
          v21,
          (unsigned __int8)v33,
          BYTE1(v33),
          BYTE2(v34),
          v25);
        sub_47AB4(4, s, 0);
      }
      ++v21;
      if ( dword_9C2A8 < v25 )
      {
        sub_306F0(v25, a4);
        sub_1B1F4(a1, 1, 0, a2, v33, v34);
        usleep((__useconds_t)&unk_F4240);
      }
    }
    while ( v21 != v15 );
  }
}
// 9C2A8: using guessed type int dword_9C2A8;
// 9E31C: using guessed type int dword_9E31C;

//----- (00030B64) --------------------------------------------------------
unsigned int __fastcall sub_30B64(
        int a1,
        unsigned int a2,
        int a3,
        unsigned int a4,
        unsigned int a5,
        unsigned __int8 a6)
{
  const char *v8; // r3
  unsigned int result; // r0
  unsigned int v10; // r4
  unsigned int v11; // r6
  int v12; // r10
  unsigned int v13; // [sp+14h] [bp-818h]
  _BYTE v16[4]; // [sp+24h] [bp-808h] BYREF
  char s[4]; // [sp+28h] [bp-804h] BYREF
  int v18; // [sp+2Ch] [bp-800h]

  if ( (unsigned int)dword_9E31C > 3 )
  {
    v8 = "true";
    if ( !a6 )
      v8 = "false";
    snprintf(
      s,
      0x800u,
      "chain = %d, freq_start = %d, freq_end = %d, freq_step = %d, is_higher_voltage = %s\n",
      a1,
      a3,
      a4,
      a5,
      v8);
    sub_47AB4(3, s, 0);
  }
  *(_DWORD *)s = 0;
  v18 = 0;
  result = (a5 - 1 + a4 - a3) / a5;
  v13 = result;
  if ( result )
  {
    v10 = a3 + a5;
    v11 = 1;
    do
    {
      if ( a4 < v10 )
        v12 = a4;
      else
        v12 = v10;
      ++v11;
      sub_306F0(v12, a6);
      v10 += a5;
      sub_74E08((int)s, v16, 0);
      BYTE2(v18) = v16[0];
      sub_1B1F4(a1, 1, 0, a2, *(int *)s, v18);
      result = usleep((__useconds_t)"d asic, will power off hash board %d\n");
    }
    while ( v13 >= v11 );
  }
  return result;
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00030CAC) --------------------------------------------------------
int __fastcall sub_30CAC(int a1, unsigned int a2, unsigned int a3, int a4)
{
  int v6; // lr
  int v7; // r8
  size_t v8; // r9
  int v9; // r4
  int v10; // r5
  unsigned int v11; // r10
  int v12; // t1
  unsigned int v13; // r6
  unsigned int v14; // r0
  unsigned int v15; // r2
  int v16; // r12
  int v17; // r1
  unsigned int v18; // r3
  unsigned int v19; // t1
  _BYTE *v20; // r3
  _BYTE *v21; // r0
  int v22; // t1
  unsigned __int16 *v23; // r3
  unsigned int v24; // r4
  unsigned int v25; // r10
  int *v26; // r5
  int i; // r6
  int j; // r4
  unsigned int v29; // r3
  int v30; // r0
  int v31; // r9
  char *v32; // r5
  int v33; // r8
  int v34; // r4
  int *v35; // r7
  int v36; // r12
  char *v37; // r3
  int *v38; // r2
  int v39; // t1
  int *v40; // r2
  unsigned int v41; // r3
  unsigned int v42; // r1
  unsigned int v43; // t1
  unsigned int v44; // r8
  unsigned int v45; // r5
  char *v46; // r4
  unsigned int v47; // r2
  int v48; // r11
  int v50; // [sp+Ch] [bp-1C90h]
  int *v51; // [sp+Ch] [bp-1C90h]
  int v55; // [sp+18h] [bp-1C84h]
  int v56; // [sp+1Ch] [bp-1C80h]
  char *v57; // [sp+1Ch] [bp-1C80h]
  int v58; // [sp+28h] [bp-1C74h]
  int v59; // [sp+28h] [bp-1C74h]
  unsigned int v60; // [sp+2Ch] [bp-1C70h]
  int *v61; // [sp+2Ch] [bp-1C70h]
  unsigned int v62; // [sp+34h] [bp-1C68h]
  int v63; // [sp+3Ch] [bp-1C60h]
  char v64[4]; // [sp+44h] [bp-1C58h] BYREF
  int v65; // [sp+48h] [bp-1C54h]
  int v66; // [sp+4Ch] [bp-1C50h]
  int v67; // [sp+50h] [bp-1C4Ch] BYREF
  int v68; // [sp+54h] [bp-1C48h]
  _DWORD s[16]; // [sp+58h] [bp-1C44h] BYREF
  _DWORD v70[16]; // [sp+98h] [bp-1C04h] BYREF
  int base[16]; // [sp+D8h] [bp-1BC4h] BYREF
  char v72[2040]; // [sp+118h] [bp-1B84h] BYREF
  int v73; // [sp+914h] [bp-1388h] BYREF
  _BYTE v74[4996]; // [sp+918h] [bp-1384h] BYREF

  memset(v74, 0, 0x1380u);
  memset(s, 255, sizeof(s));
  memset(v70, 0, sizeof(v70));
  memset(base, 0, sizeof(base));
  v6 = dword_A0D68;
  v58 = dword_A0D68 + 12979;
  v60 = a2;
  v50 = dword_9C294;
  v7 = dword_A0D68 + 64;
  v8 = 0;
  v9 = 0;
  v56 = a1 + 312;
  v10 = -4;
  v11 = 0;
  v66 = 0;
  v65 = 0;
  do
  {
    while ( 1 )
    {
      v12 = *(_DWORD *)(v6 + 4);
      v6 += 4;
      if ( v12 == 1 )
        break;
      ++v9;
      v10 += 312;
      if ( v6 == v7 )
        goto LABEL_20;
    }
    v13 = 0;
    v14 = 0;
    v15 = 0xFFFFFF;
    v16 = v10 + a1;
    v17 = v10 + a1;
    do
    {
      v19 = *(_DWORD *)(v17 + 4);
      v17 += 4;
      v18 = v19;
      v13 += v19;
      if ( v14 < v19 )
        v14 = v18;
      if ( v15 >= v18 )
        v15 = v18;
    }
    while ( v17 != v56 + v10 );
    s[v9] = v15;
    if ( v11 < v14 )
      v11 = v14;
    v70[v9] = v14;
    v20 = &v74[4 * v8 + 896];
    v21 = &v74[v10];
    ++v8;
    *((_DWORD *)v20 - 752) = v15;
    do
    {
      v22 = *(_DWORD *)(v16 + 4);
      v16 += 4;
      *((_DWORD *)v21 + 1) = v22 - v15;
      v21 += 4;
    }
    while ( v16 != v17 );
    v23 = (unsigned __int16 *)v50;
    v10 += 312;
    if ( v50 == 2 )
      v23 = (unsigned __int16 *)v58;
    else
      v17 = 4 * v9;
    if ( v50 == 2 )
    {
      v17 = 4 * v9;
      dword_242DB4[v9] = *v23;
    }
    ++v9;
    *(_DWORD *)((char *)&unk_242D74 + v17) = v13 / 0x4E;
  }
  while ( v6 != v7 );
LABEL_20:
  v24 = v11;
  v63 = v11;
  v25 = v60;
  qsort(base, v8, 4u, (__compar_fn_t)sub_3013C);
  sub_30770(255, v60, base[0], a4);
  if ( base[0] != v24 )
  {
    if ( v8 > 1 )
    {
      v26 = base;
      for ( i = 1; i != v8; ++i )
      {
        for ( j = 0; j != 16; ++j )
        {
          while ( 1 )
          {
            if ( *(_DWORD *)(dword_A0D68 + 4 * j + 4) == 1 )
            {
              v29 = v26[1];
              if ( s[j] >= v29 )
                break;
            }
            if ( ++j == 16 )
              goto LABEL_28;
          }
          v30 = j;
          sub_30B64(v30, v60, *v26, v29, a3, a4);
        }
LABEL_28:
        ++v26;
      }
    }
    v31 = 0;
    v51 = &v73;
    sub_306F0(v63, a4);
    do
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * v31 + 4) != 1 || (v55 = s[v31], v55 == v70[v31]) )
      {
        v61 = v51 + 78;
      }
      else
      {
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(v72, 0x800u, "chain = %d, start = %d, freq_step = %d\n", v31, v55, a3);
          sub_47AB4(3, v72, 0);
        }
        v32 = v72;
        v67 = 0;
        v68 = 0;
        v33 = 0;
        memset(v72, 0, 0x270u);
        v34 = 0;
        v35 = v51 + 1;
        do
        {
          v36 = v34 + 6;
          v37 = v32;
          v38 = v35;
          do
          {
            v39 = *v38++;
            v37 += 8;
            *((_DWORD *)v37 - 1) = v39;
            *(_DWORD *)&v32[8 * v34 + v33] = v34;
            ++v34;
          }
          while ( v34 != v36 );
          v33 -= 48;
          v35 += 6;
          qsort(v32, 6u, 8u, (__compar_fn_t)sub_3011C);
          v32 += 48;
        }
        while ( v33 != -624 );
        v40 = v51;
        v41 = 0;
        v61 = v51 + 78;
        do
        {
          v43 = v40[1];
          ++v40;
          v42 = v43;
          if ( v41 < v43 )
            v41 = v42;
        }
        while ( v51 + 78 != v40 );
        v62 = (a3 - 1 + v41) / a3;
        if ( v62 )
        {
          v59 = 0;
          v44 = v55 + a3;
          do
          {
            ++v59;
            v45 = v44 - v55;
            v57 = v72;
            do
            {
              v46 = v57;
              do
              {
                v47 = *((_DWORD *)v46 + 1);
                v48 = *(_DWORD *)v46;
                if ( v47 >= v45 || a3 > v45 - v47 )
                {
                  sub_74E08((int)&v67, v64, 0);
                  BYTE2(v68) = v64[0];
                  sub_1B1F4(v31, 0, (unsigned __int8)(3 * v48), v25, v67, v68);
                }
                v46 += 48;
              }
              while ( v57 + 624 != v46 );
              v57 += 8;
              usleep((__useconds_t)&loc_186A0);
            }
            while ( v57 != &v72[48] );
            v44 += a3;
          }
          while ( v62 != v59 );
        }
      }
      ++v31;
      v51 = v61;
    }
    while ( v31 != 16 );
  }
  return v63;
}
// 9C294: using guessed type int dword_9C294;
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 242DB4: using guessed type _DWORD dword_242DB4[16];

//----- (00031224) --------------------------------------------------------
int __fastcall sub_31224(int a1, unsigned int a2, int a3)
{
  _BYTE v6[4]; // [sp+14h] [bp-808h] BYREF
  char s[4]; // [sp+18h] [bp-804h] BYREF
  int v8; // [sp+1Ch] [bp-800h]

  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "chain = %d, freq = %d\n", a1, a3);
    sub_47AB4(3, s, 0);
  }
  *(_DWORD *)s = 0;
  v8 = 0;
  sub_74E08((int)s, v6, 0);
  BYTE2(v8) = v6[0];
  return sub_1B1F4(a1, 1, 0, a2, *(int *)s, v8);
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000312D8) --------------------------------------------------------
unsigned int sub_312D8()
{
  int v0; // lr
  _DWORD *v1; // r3
  unsigned int result; // r0
  int v3; // t1
  _DWORD *v4; // r12
  unsigned int v5; // r2
  unsigned int v6; // r1
  unsigned int v7; // t1

  v0 = dword_A0D68;
  if ( dword_9C294 == 2 )
  {
    result = *(unsigned __int16 *)(dword_A0D68 + 12979);
    if ( result < 0x32 )
      return 50;
  }
  else
  {
    v1 = &unk_1371C4;
    result = 50;
    do
    {
      v3 = *(_DWORD *)(v0 + 4);
      v0 += 4;
      v4 = v1 + 78;
      if ( v3 == 1 )
      {
        v5 = 0;
        do
        {
          v7 = v1[1];
          ++v1;
          v6 = v7;
          if ( v5 < v7 )
            v5 = v6;
        }
        while ( v1 != v4 );
        if ( result < v5 )
          result = v5;
      }
      v1 = v4;
    }
    while ( v4 != (_DWORD *)&unk_138544 );
  }
  return result;
}
// 9C294: using guessed type int dword_9C294;
// A0D68: using guessed type int dword_A0D68;

//----- (00031368) --------------------------------------------------------
void __fastcall sub_31368(_BYTE *a1)
{
  unsigned int v2; // r0
  int v3; // r6
  int v4; // r8
  int v5; // r0
  int v6; // r6
  int v7; // r0

  v2 = sub_312D8();
  v3 = dword_1AEA20;
  v4 = sub_3014C(v2, (_DWORD *)(dword_1AEA20 + 4), *(_DWORD *)dword_1AEA20, 0);
  v5 = sub_3014C(dword_241D20, (_DWORD *)(v3 + 72), *(_DWORD *)(v3 + 68), 1);
  *a1 = 0;
  if ( dword_241D20 <= 20 )
  {
    v6 = v5 + 8 * v4 + 26;
    v7 = sub_1A1B0() + 100;
    if ( v7 >= *(_DWORD *)(dword_1AEA20 + 4 * v6) )
      v7 = *(_DWORD *)(dword_1AEA20 + 4 * v6);
    sub_1A150(v7);
    *a1 = 1;
  }
}
// 1AEA20: using guessed type int dword_1AEA20;
// 241D20: using guessed type int dword_241D20;

//----- (000313F8) --------------------------------------------------------
int __fastcall sub_313F8(int result)
{
  dword_1AEA20 = result;
  return result;
}
// 1AEA20: using guessed type int dword_1AEA20;

//----- (00031408) --------------------------------------------------------
void *__fastcall sub_31408(void *a1)
{
  memcpy(a1, (const void *)dword_1AEA20, 0x468u);
  return a1;
}
// 1AEA20: using guessed type int dword_1AEA20;

//----- (0003142C) --------------------------------------------------------
int __fastcall sub_3142C(int result)
{
  dword_1AEA1C = result;
  return result;
}
// 1AEA1C: using guessed type int dword_1AEA1C;

//----- (0003143C) --------------------------------------------------------
_DWORD *__fastcall sub_3143C(_DWORD *result)
{
  int v1; // r1
  int v2; // r2

  v1 = *(_DWORD *)(dword_1AEA1C + 4);
  v2 = *(_DWORD *)(dword_1AEA1C + 8);
  *result = *(_DWORD *)dword_1AEA1C;
  result[1] = v1;
  result[2] = v2;
  return result;
}
// 1AEA1C: using guessed type int dword_1AEA1C;

//----- (0003145C) --------------------------------------------------------
int __fastcall sub_3145C(int a1)
{
  char v2[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)dword_9E31C > 1 )
  {
    snprintf(v2, 0x800u, "input value error: %c\n", a1);
    sub_47AB4(1, v2, 0);
  }
  return 255;
}
// 9E31C: using guessed type int dword_9E31C;

//----- (000314BC) --------------------------------------------------------
int __fastcall sub_314BC(int a1)
{
  int v1; // r3

  if ( (unsigned int)(a1 - 48) <= 9 )
    return a1 & 0xF;
  v1 = a1 & 0xDF;
  switch ( v1 )
  {
    case 'A':
      return 10;
    case 'B':
      return 11;
    case 'C':
      return 12;
    case 'D':
      return 13;
    case 'E':
      return 14;
    case 'F':
      return 15;
  }
  return sub_3145C(a1);
}

//----- (00031538) --------------------------------------------------------
int __fastcall sub_31538(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  bool v3; // cc
  int v4; // r3
  int v8; // r7
  unsigned __int8 *v9; // r8
  unsigned __int8 *v10; // r4
  char *v11; // r11
  int v12; // r6
  int v13; // t1
  char v14; // r5
  char v15; // r4
  int v16; // [sp+Ch] [bp-808h]
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v3 = (int)a1 <= 0;
  if ( a1 )
    v3 = a3 <= 0;
  v4 = v3;
  if ( !a2 )
    v4 = 1;
  if ( v4 )
  {
    if ( (unsigned int)dword_9E31C > 4 )
    {
      snprintf(s, 0x800u, "s2hex para error dst(%p), src(%p), inlen(%d)\n", a1, a2, a3);
      sub_47AB4(4, s, 0);
    }
    return -1;
  }
  else
  {
    v8 = a3 >> 1;
    v16 = a3 & 1;
    if ( a3 >> 1 )
    {
      v9 = &a2[2 * v8];
      v10 = a2;
      v11 = a1 - 1;
      do
      {
        v12 = v10[1];
        v13 = *v10;
        v10 += 2;
        v14 = sub_314BC(v13);
        *++v11 = sub_314BC(v12) ^ (16 * v14);
      }
      while ( v10 != v9 );
    }
    if ( v16 )
    {
      v15 = sub_314BC(a2[2 * v8]);
      a1[v8] = sub_3145C(0) ^ (16 * v15);
    }
    return v8 + v16;
  }
}
// 9E31C: using guessed type int dword_9E31C;

//----- (00031658) --------------------------------------------------------
unsigned int __fastcall sub_31658(_DWORD *a1, unsigned int a2)
{
  unsigned int result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // r2
  int v10; // r3
  _DWORD *v11; // r4
  unsigned int v12; // t1
  unsigned int v13; // r1
  unsigned int v14; // r2
  unsigned int *v15; // r2
  unsigned int *v16; // r1
  unsigned int v17; // t1
  unsigned int v18[8]; // [sp+0h] [bp-128h] BYREF
  _BYTE s[32]; // [sp+20h] [bp-108h] BYREF
  _DWORD v20[58]; // [sp+40h] [bp-E8h] BYREF

  memset(v18, 0, sizeof(v18));
  memset(s, 0, sizeof(s));
  if ( !a1 )
    return 0;
  v5 = a1[6];
  v6 = a1[7];
  v7 = a1[8];
  v20[2] = a1[5];
  v20[3] = v5;
  v20[4] = v6;
  v20[5] = v7;
  v8 = a1[10];
  v9 = a1[11];
  v10 = a1[12];
  v20[6] = a1[9];
  v20[7] = v8;
  v20[8] = v9;
  v20[9] = v10;
  sub_50B5C(&v20[2], 32);
  v12 = a1[2];
  v11 = a1 + 2;
  v20[0] = 80;
  v20[1] = 0;
  v13 = v11[1];
  v14 = v11[2];
  v18[0] = v12;
  v18[1] = v13;
  v18[2] = v14;
  sub_50B5C(v18, 12);
  sub_5162C((int)&v20[10], v18, 0xCu);
  v18[0] = bswap32(a2);
  sub_50B5C(v18, 4);
  sub_5162C((int)&v20[13], v18, 4u);
  sub_1E58C((int)v20, v18);
  memset(v20, 0, sizeof(v20));
  sub_1E740(v18, 32, s);
  v15 = &v18[7];
  v16 = &v18[-1];
  do
  {
    v17 = v15[1];
    ++v15;
    v16[1] = bswap32(v17);
    ++v16;
  }
  while ( v15 != (unsigned int *)&s[28] );
  result = v18[7];
  if ( v18[7] )
    return 1;
  return result;
}

//----- (00031794) --------------------------------------------------------
void __fastcall sub_31794(int a1, int a2)
{
  char v2[2052]; // [sp+0h] [bp-804h] BYREF

  switch ( a1 )
  {
    case 0:
      snprintf((char *)dword_1AEA24, 0x40u, "J%d:1", a2);
      break;
    case 1:
      snprintf((char *)dword_1AEA24, 0x40u, "J%d:2", a2);
      break;
    case 2:
      snprintf((char *)dword_1AEA24, 0x40u, "J%d:8", a2);
      break;
    case 3:
      snprintf((char *)dword_1AEA24, 0x40u, "J%d:4", a2);
      break;
    case 4:
      snprintf((char *)dword_1AEA24, 0x40u, "J%d:5", a2);
      break;
    case 5:
      dword_1AEA24[0] = 3226194;
      break;
    case 6:
      dword_1AEA24[0] = 3291730;
      break;
    case 7:
      snprintf((char *)dword_1AEA24, 0x40u, "T:%d", a2);
      break;
    case 8:
      dword_1AEA24[0] = 3226192;
      break;
    case 9:
      dword_1AEA24[0] = 3291728;
      break;
    case 10:
      dword_1AEA24[0] = 3226182;
      break;
    case 11:
      snprintf((char *)dword_1AEA24, 0x40u, "J%d:6", a2);
      break;
    case 12:
      dword_1AEA24[0] = 3226198;
      break;
    case 13:
      dword_1AEA24[0] = 3226189;
      break;
    case 14:
      dword_1AEA24[0] = 3226190;
      break;
    case 15:
      dword_1AEA24[0] = 3422800;
      break;
    case 17:
      dword_1AEA24[0] = 3357266;
      break;
    case 18:
      dword_1AEA24[0] = 3226179;
      break;
    case 19:
      dword_1AEA24[0] = 3291726;
      break;
    case 20:
      dword_1AEA24[0] = 3160659;
      break;
    case 21:
      dword_1AEA24[0] = 3357262;
      break;
    case 22:
      dword_1AEA24[0] = 3488336;
      break;
    default:
      strcpy((char *)dword_1AEA24, "unknown");
      break;
  }
  sub_36C44(1);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(v2, 0x800u, "Sweep error string = %s.\n", (const char *)dword_1AEA24);
    sub_47AB4(3, v2, 0);
  }
}
// 317A8: control flows out of bounds to 317AC
// 9E31C: using guessed type int dword_9E31C;
// 1AEA24: using guessed type int dword_1AEA24[16];

//----- (00031ABC) --------------------------------------------------------
int *sub_31ABC()
{
  return &dword_1AEA24;
}
// 1AEA24: using guessed type int dword_1AEA24;

//----- (00031ACC) --------------------------------------------------------
int sub_31ACC()
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v1, "[DEBUG] Get stats.\n");
    sub_47AB4(4, v1, 0);
  }
  return dword_1AEA64 + 8;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (00031B48) --------------------------------------------------------
bool __fastcall sub_31B48(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v3, 0x800u, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", a1);
    sub_47AB4(4, v3, 0);
  }
  return *(_DWORD *)(dword_1AEA64 + 4 * (a1 + 479234)) > 0x3A58Fu;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (00031BC8) --------------------------------------------------------
int __fastcall sub_31BC8(int a1)
{
  int v2; // r4
  int result; // r0
  int v4; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "[DEBUG] Check if is unbalanche happen, chain = %d\n", a1);
    sub_47AB4(4, s, 0);
  }
  v2 = 0;
  result = 0;
  do
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(dword_1AEA64 + 4 * ((_DWORD)&loc_74B20 + 78 * a1 + v2 + 2));
      if ( (unsigned int)v4 > 0xBF8 || (double)v4 < 2298.0 )
      {
        result = 1;
        if ( (unsigned int)dword_9E31C > 3 )
          break;
      }
      if ( ++v2 == 78 )
        return result;
    }
    snprintf(s, 0x800u, "Unbalance happened: chain = %d, asic = %d\n", a1, v2++);
    sub_47AB4(3, s, 0);
    result = 1;
  }
  while ( v2 != 78 );
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (00031CE8) --------------------------------------------------------
int sub_31CE8()
{
  int v0; // r4
  int v1; // r0
  int v2; // r0
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v4, "[DEBUG] HW sweep reset.\n");
    sub_47AB4(4, v4, 0);
  }
  v0 = 0;
  sub_1B298(255, 0);
  do
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * v0 + 4) != 1 )
    {
      if ( ++v0 == 16 )
        goto LABEL_7;
    }
    v1 = (unsigned __int8)v0++;
    sub_7561C(v1);
  }
  while ( v0 != 16 );
LABEL_7:
  v2 = sub_6F79C();
  return sub_6F7C4(v2 & 0xFFFF70FF | 0x8400);
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00031DA8) --------------------------------------------------------
void *sub_31DA8()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v1, "[DEBUG] HW sweep clear stats.\n");
    sub_47AB4(4, v1, 0);
  }
  return memset((void *)(dword_1AEA64 + 8), 0, 0x3B7C84u);
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (00031E2C) --------------------------------------------------------
void *sub_31E2C()
{
  int v0; // r4
  void *result; // r0
  char v2; // r5
  unsigned int v3[512]; // [sp+28h] [bp+0h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy((char *)v3, "[DEBUG] Send 1-midstate work.\n");
    sub_47AB4(4, (const char *)v3, 0);
  }
  v0 = 0;
  result = memset(v3, 0, 0x34u);
  LOBYTE(v3[0]) = 1;
  do
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * v0 + 4) != 1 )
    {
      if ( ++v0 == 16 )
        return result;
    }
    while ( (sub_6FF04() & (1 << v0)) == 0 )
      sub_4A804();
    v2 = v0++ | 0x80;
    BYTE1(v3[0]) = v2;
    sub_1AF48(v3[0], v3[1], v3[2], v3[3], v3[4], v3[5], v3[6], v3[7], v3[8]);
    result = (void *)sub_4A804();
  }
  while ( v0 != 16 );
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00031F44) --------------------------------------------------------
void sub_31F44()
{
  void *v0; // r0
  char v1[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v1, "[DEBUG] Free memory for hw sweep.\n");
    sub_47AB4(4, v1, 0);
  }
  v0 = (void *)dword_1AEA64;
  if ( dword_1AEA64 )
  {
    if ( *(_DWORD *)(dword_1AEA64 + 4) )
    {
      free(*(void **)(dword_1AEA64 + 4));
      v0 = (void *)dword_1AEA64;
    }
    free(v0);
    dword_1AEA64 = 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (00031FE0) --------------------------------------------------------
void sub_31FE0()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v0, "[DEBUG] HW sweep exit.\n");
    sub_47AB4(4, v0, 0);
  }
  sub_31F44();
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0003203C) --------------------------------------------------------
int sub_3203C()
{
  _DWORD *v1; // r6
  void *v2; // r5
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v3, "[DEBUG] HW sweep init.\n");
    sub_47AB4(4, v3, 0);
    if ( (unsigned int)dword_9E31C > 4 )
    {
      strcpy(v3, "[DEBUG] Allocate memory for hw sweep.\n");
      sub_47AB4(4, v3, 0);
    }
  }
  if ( dword_1AEA64 )
    return 0;
  v1 = calloc(0x3D1DC4u, 1u);
  dword_1AEA64 = (int)v1;
  if ( !v1 )
  {
    sub_31794(13, 255);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v3, "Fail to allocate memory for hw sweep ctxt.\n");
      sub_47AB4(3, v3, 0);
      return -1;
    }
    return -1;
  }
  v2 = malloc(0x4E0u);
  v1[1] = v2;
  if ( !v2 )
  {
    sub_31F44();
    sub_31794(13, 255);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v3, "Fail to allocate memory for hw sweep private data.\n");
      sub_47AB4(3, v3, 0);
    }
    return -1;
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (000321E0) --------------------------------------------------------
void __fastcall sub_321E0(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // r5
  unsigned int v5; // r6
  int v6; // r8
  int v7; // lr
  int v8; // r2
  int v9; // r12
  int v10; // r7
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = 78 * a1;
  v5 = HIWORD(a3);
  v6 = a4 + 4 * a1;
  v7 = (unsigned __int16)a3;
  v8 = *(_DWORD *)(dword_1AEA64 + 4);
  v9 = a4 + 4 * (78 * a1 + a2) + 1908736;
  *(_DWORD *)(v9 + 3200) += v5;
  v10 = v7 - v5 + *(_DWORD *)(v6 + 1941440);
  if ( v5 > 0xBF8 )
  {
    *(_DWORD *)(v6 + 1941440) = v10;
    *(_BYTE *)(v8 + v4 + a2) = 1;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(
        s,
        0x800u,
        "Nonce counter overflow: chain = %d, asic = %d, nonce_return = %d, nonce_match = %d, nonce_accumulate = %d\n",
        a1,
        a2,
        v7,
        v5,
        *(_DWORD *)(a4 + 4 * (78 * a1 + a2) + 1911936));
      sub_47AB4(3, s, 0);
    }
  }
  else
  {
    *(_DWORD *)(v6 + 1916928) += v5;
    *(_DWORD *)(v6 + 1941440) = v10;
    *(_BYTE *)(v8 + v4 + a2) = 1;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (000322E4) --------------------------------------------------------
void __fastcall sub_322E4(int a1)
{
  int v1; // r12
  unsigned int v2; // r1
  _BOOL4 v3; // r3
  int v4; // r3

  v1 = *(_BYTE *)a1 & 0xF;
  v2 = *(_BYTE *)(a1 + 2) / 3u;
  v3 = v2 <= 0x4D;
  if ( !*(_DWORD *)(dword_A0D68 + 4 * v1 + 4) )
    v3 = 0;
  if ( !v3 )
    goto LABEL_4;
  v4 = *(unsigned __int8 *)(a1 + 1);
  if ( v4 == 144 )
  {
    if ( (*(_DWORD *)(a1 + 4) & 0x88) != 0 )
      *(_BYTE *)(*(_DWORD *)(dword_1AEA64 + 4) + 78 * v1 + v2) = 1;
  }
  else
  {
    if ( v4 != 224 )
    {
LABEL_4:
      sub_3762C((char *)a1);
      return;
    }
    sub_321E0(*(_BYTE *)a1 & 0xF, v2, *(_DWORD *)(a1 + 4), dword_1AEA64 + 8);
  }
}
// A0D68: using guessed type int dword_A0D68;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (000323A0) --------------------------------------------------------
bool __fastcall sub_323A0(int a1)
{
  int v2; // r4
  int v3; // r0
  int v4; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v2 = *(_DWORD *)(dword_1AEA64 + 4);
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "[DEBUG] Check if read reg done, chain = %d, done_threshold = %d.\n", a1, 1);
    sub_47AB4(4, s, 0);
  }
  v3 = 0;
  v4 = v2 + 78 * a1 - 1;
  do
  {
    if ( *(unsigned __int8 *)++v4 )
      ++v3;
  }
  while ( v4 != v2 + 77 + 78 * a1 );
  return v3 == 78;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (00032450) --------------------------------------------------------
bool sub_32450()
{
  int i; // r4
  _BOOL4 result; // r0

  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        return 1;
    }
    result = sub_323A0(i);
    if ( !result )
      return result;
  }
  return 1;
}
// A0D68: using guessed type int dword_A0D68;

//----- (000324A8) --------------------------------------------------------
int __fastcall sub_324A8(int a1, __useconds_t *a2)
{
  int v3; // r0
  unsigned int v4; // r3
  __useconds_t v5; // r1
  char v6; // r11
  int v7; // r6
  int v8; // r0
  int v9; // r4
  int v10; // r0
  int v11; // r4
  int v12; // r0
  int v13; // r3
  unsigned int v14; // r0
  int i; // r4
  int v16; // r0
  int v17; // r4
  signed int v18; // r5
  int v19; // r10
  int v20; // r0
  int v21; // r0
  __useconds_t v22; // r5
  int v23; // r6
  int v24; // r4
  unsigned int v25; // r0
  int v26; // r4
  int v27; // r9
  int v28; // r7
  char *v29; // r10
  char *v30; // r5
  int v31; // r4
  int v32; // t1
  char *v33; // r9
  bool v35; // cc
  int v36[34]; // [sp+0h] [bp-8A4h] BYREF
  int *v37; // [sp+88h] [bp-81Ch]
  void *v38; // [sp+8Ch] [bp-818h]
  __useconds_t useconds; // [sp+90h] [bp-814h]
  char *v40; // [sp+94h] [bp-810h]
  __int16 v41; // [sp+9Ch] [bp-808h]
  char v42; // [sp+9Eh] [bp-806h]
  char s[2052]; // [sp+A0h] [bp-804h] BYREF

  v37 = &dword_9E31C;
  v3 = sub_24858();
  v4 = dword_9E31C;
  v5 = *a2;
  v6 = BYTE2(v3);
  v41 = v3;
  v38 = (void *)BYTE1(v3);
  useconds = v5;
  v42 = BYTE2(v3);
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "[DEBUG] Send work, max_freq = %d\n", useconds);
    sub_47AB4(4, s, 0);
    v4 = *v37;
  }
  v7 = 3;
  while ( 1 )
  {
    if ( v4 > 4 )
    {
      strcpy(s, "[DEBUG] Set start nonce offset invalid.\n");
      sub_47AB4(4, s, 0);
    }
    sub_66908(24, 0);
    v8 = sub_6F79C();
    v9 = 0;
    sub_6F7C4(v8 & 0xFFFF70FF | 0x8400);
    do
    {
      while ( *(_DWORD *)(dword_A0D68 + 4 * v9 + 4) != 1 )
      {
        if ( ++v9 == 16 )
          goto LABEL_10;
      }
      v10 = (unsigned __int8)v9++;
      sub_74DD0(v10, 1, 0);
    }
    while ( v9 != 16 );
LABEL_10:
    if ( (unsigned int)*v37 > 4 )
    {
      strcpy(s, "[DEBUG] Send null work.\n");
      sub_47AB4(4, s, 0);
    }
    v11 = 0;
    memset(s, 0, 0x94u);
    s[0] = 1;
    do
    {
      while ( *(_DWORD *)(dword_A0D68 + 4 * v11 + 4) != 1 )
      {
        if ( ++v11 == 16 )
          goto LABEL_15;
      }
      while ( (sub_6FF04() & (1 << v11)) == 0 )
        sub_4A804();
      s[1] = v11++ | 0x80;
      memcpy(v36, &s[16], 0x84u);
      sub_1B010(
        *(unsigned int *)s,
        *(int *)&s[4],
        *(int *)&s[8],
        *(int *)&s[12],
        v36[0],
        v36[1],
        v36[2],
        v36[3],
        v36[4],
        v36[5],
        v36[6],
        v36[7],
        v36[8],
        v36[9],
        v36[10],
        v36[11],
        v36[12],
        v36[13],
        v36[14],
        v36[15],
        v36[16],
        v36[17],
        v36[18],
        v36[19],
        v36[20],
        v36[21],
        v36[22],
        v36[23],
        v36[24],
        v36[25],
        v36[26],
        v36[27],
        v36[28]);
      sub_4A804();
    }
    while ( v11 != 16 );
LABEL_15:
    sleep(1u);
    v12 = sub_6F79C();
    sub_6F7C4(v12 & 0xFFFF70FF | 0x8100);
    usleep((__useconds_t)&loc_186A0);
    if ( !--v7 )
      break;
    v4 = *v37;
  }
  sub_1B298(255, 1);
  sub_1B138(255, (char)v38, v6, 1);
  sub_31E2C();
  usleep(0x186A0u);
  sub_31E2C();
  usleep(0x186A0u);
  sub_31E2C();
  usleep(0x186A0u);
  v13 = dword_A0D68;
  do
  {
    while ( *(_DWORD *)(v13 + 4 * v7 + 4) != 1 )
    {
      if ( ++v7 == 16 )
        goto LABEL_25;
    }
    v14 = (unsigned __int8)v7++;
    sub_75458(v14, 0);
    v13 = dword_A0D68;
  }
  while ( v7 != 16 );
LABEL_25:
  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(v13 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        goto LABEL_29;
    }
    v16 = (unsigned __int8)i;
    sub_7561C(v16);
    v13 = dword_A0D68;
  }
LABEL_29:
  v17 = 3;
  v18 = 30000 - (useconds - 250) / 0x14;
  do
  {
    v19 = 0;
    while ( *(_DWORD *)(v13 + 4 * v19 + 4) != 1 )
    {
      if ( ++v19 == 16 )
        goto LABEL_35;
LABEL_32:
      v13 = dword_A0D68;
    }
    v20 = (unsigned __int8)v19++;
    sub_756F4(v20, v18 / 333);
    if ( v19 != 16 )
      goto LABEL_32;
LABEL_35:
    usleep((__useconds_t)&loc_186A0);
    --v17;
    v13 = dword_A0D68;
  }
  while ( v17 );
  if ( *(_DWORD *)(dword_A0D68 + 4) == 1 )
    goto LABEL_39;
  while ( ++v17 != 16 )
  {
    while ( *(_DWORD *)(v13 + 4 * v17 + 4) == 1 )
    {
LABEL_39:
      v21 = (unsigned __int8)v17++;
      sub_75718(v21, 8);
      v13 = dword_A0D68;
      if ( v17 == 16 )
        goto LABEL_40;
    }
  }
LABEL_40:
  v22 = v18 + 1000;
  v23 = 8;
  while ( 2 )
  {
    v24 = 0;
    while ( 2 )
    {
      if ( *(_DWORD *)(v13 + 4 * v24 + 4) != 1 )
      {
        if ( ++v24 == 16 )
          break;
        goto LABEL_43;
      }
      v25 = (unsigned __int8)v24++;
      sub_7575C(v25);
      if ( v24 != 16 )
      {
LABEL_43:
        v13 = dword_A0D68;
        continue;
      }
      break;
    }
    usleep(v22);
    if ( --v23 )
    {
      v13 = dword_A0D68;
      continue;
    }
    break;
  }
  sub_31E2C();
  usleep(0x186A0u);
  sub_31E2C();
  usleep(0x186A0u);
  sub_31E2C();
  usleep(0x186A0u);
  sub_1B138(255, (char)v38, v6, 0);
  if ( (unsigned int)*v37 > 4 )
  {
    strcpy(s, "[DEBUG] Get nonce counter, chain.\n");
    sub_47AB4(4, s, 0);
    v35 = (unsigned int)*v37 > 4;
    v38 = *(void **)(dword_1AEA64 + 4);
    if ( v35 )
    {
      snprintf(s, 0x800u, "[DEBUG] Read reg and wait done, reg = %d, done_threshold = %d.\n", 224, 1);
      sub_47AB4(4, s, 0);
    }
  }
  else
  {
    v38 = *(void **)(dword_1AEA64 + 4);
  }
  memset(v38, 0, 0x4E0u);
  v26 = 5;
  sub_1AD6C(255, 1, 0, 224);
  while ( !sub_32450() )
  {
    usleep((__useconds_t)&loc_186A0);
    if ( !--v26 )
    {
      v40 = s;
      v27 = 95;
      useconds = (__useconds_t)&loc_186A0;
      while ( 1 )
      {
        v28 = 0;
        v29 = (char *)v38 - 1;
        do
        {
          while ( *(_DWORD *)(dword_A0D68 + 4 * v28 + 4) != 1 )
          {
            if ( ++v28 == 16 )
              goto LABEL_62;
          }
          v30 = &v29[78 * v28];
          LOBYTE(v31) = 0;
          do
          {
            v32 = (unsigned __int8)*++v30;
            if ( v32 != 1 )
              sub_1AD6C((unsigned __int8)v28, 0, v31, 224);
            v31 = (unsigned __int8)(v31 + 3);
          }
          while ( v31 != 234 );
          ++v28;
        }
        while ( v28 != 16 );
LABEL_62:
        usleep(useconds);
        if ( sub_32450() )
          return 0;
        if ( !--v27 )
        {
          v33 = v40;
          if ( (unsigned int)*v37 > 3 )
          {
            snprintf(v40, 0x800u, "Read REG[0x%X] done failed.\n", 224);
            sub_47AB4(3, v33, 0);
          }
          return -1;
        }
      }
    }
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA64: using guessed type int dword_1AEA64;

//----- (00032B3C) --------------------------------------------------------
char **sub_32B3C()
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v1, "[DEBUG] Get hw ops.\n");
    sub_47AB4(4, v1, 0);
  }
  return &off_9C564;
}
// 9C564: using guessed type char *off_9C564;
// 9E31C: using guessed type int dword_9E31C;

//----- (00032BB0) --------------------------------------------------------
int sub_32BB0()
{
  return dword_1AEA68 + 8;
}
// 1AEA68: using guessed type int dword_1AEA68;

//----- (00032BC4) --------------------------------------------------------
bool __fastcall sub_32BC4(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v3, 0x800u, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", a1);
    sub_47AB4(4, v3, 0);
  }
  return *(_DWORD *)(dword_1AEA68 + 4 * (a1 + 479234)) > 0x3A58Fu;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA68: using guessed type int dword_1AEA68;

//----- (00032C44) --------------------------------------------------------
int __fastcall sub_32C44(int a1)
{
  int v1; // r1
  int v2; // r12
  unsigned int v3; // r3
  int result; // r0
  int v6; // r6
  unsigned int v7; // r7
  int v8; // r4
  int v9; // r5
  int v10; // [sp+10h] [bp-80Ch]
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v1 = dword_1AEA68;
  v2 = 3 * a1;
  v3 = *(_DWORD *)(dword_1AEA68 + 4 * (a1 + 479234));
  result = 0;
  v6 = 0;
  v10 = a1 + 4 * v2;
  v7 = v3 / 0x68;
  while ( 1 )
  {
    v8 = 0;
    v9 = 4 * (v10 + v6);
    while ( 1 )
    {
      if ( *(_DWORD *)(v1 + 4 * ((_DWORD)&loc_76390 + v9 + v8 + 2)) < v7 )
      {
        result = 1;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(
            s,
            0x800u,
            "Domain unbalance happen, chain = %d, domain = %d, nonce_num_domain = %d, threshold = %d.\n",
            a1,
            4 * v6 + v8,
            *(_DWORD *)(v1 + 4 * ((_DWORD)&loc_76390 + v9 + v8 + 2)),
            v7);
          sub_47AB4(3, s, 0);
          result = 1;
        }
      }
      if ( ++v8 == 4 )
        break;
      v1 = dword_1AEA68;
    }
    if ( ++v6 == 13 )
      break;
    v1 = dword_1AEA68;
  }
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA68: using guessed type int dword_1AEA68;

//----- (00032D48) --------------------------------------------------------
void *sub_32D48()
{
  return memset((void *)(dword_1AEA68 + 8), 0, 0x3B7C84u);
}
// 1AEA68: using guessed type int dword_1AEA68;

//----- (00032D68) --------------------------------------------------------
int __fastcall sub_32D68(int a1)
{
  int v1; // r9
  int v2; // r7
  int v3; // r11
  int v4; // r9
  _DWORD *v5; // r10
  int *v6; // r4
  int *v7; // r12
  int v8; // r0
  int v9; // r1
  int *v10; // lr
  int v11; // r2
  int v12; // r3
  int v13; // r5
  int v14; // r0
  int v15; // r6
  int v16; // r1
  int v17; // r9
  int v18; // r2
  _DWORD *v19; // r12
  int v20; // r1
  int v21; // r2
  int v22; // r3
  _DWORD *v23; // r7
  _DWORD *v24; // lr
  _DWORD *v25; // lr
  int v26; // r1
  int v27; // r2
  int v28; // r3
  _DWORD *v29; // lr
  int v30; // r1
  int v31; // r2
  int v32; // r3
  bool v33; // zf
  unsigned int v34; // r4
  int v35; // r5
  unsigned int v36; // r3
  int v37; // r1
  _DWORD *v39; // r3
  int v40; // r1
  int v41; // lr
  int v42; // r0
  _DWORD *v43; // r2
  int v44; // r0
  int v45; // r1
  int v46; // lr
  int v47; // r0
  int v48; // r0
  int v49; // r1
  int v50; // r3
  int v51[33]; // [sp+0h] [bp-9A4h] BYREF
  int *v52; // [sp+88h] [bp-91Ch]
  _DWORD *v53; // [sp+8Ch] [bp-918h]
  int v54; // [sp+90h] [bp-914h]
  unsigned int v55; // [sp+94h] [bp-910h]
  _DWORD *v56; // [sp+98h] [bp-90Ch]
  int v57; // [sp+9Ch] [bp-908h]
  int v58; // [sp+A0h] [bp-904h]
  int v59; // [sp+A4h] [bp-900h]
  int v60; // [sp+A8h] [bp-8FCh]
  int v61; // [sp+ACh] [bp-8F8h]
  int v62; // [sp+B0h] [bp-8F4h]
  int v63; // [sp+B4h] [bp-8F0h]
  int v64; // [sp+B8h] [bp-8ECh]
  int v65; // [sp+BCh] [bp-8E8h]
  int *v66; // [sp+C0h] [bp-8E4h]
  void *v67; // [sp+C4h] [bp-8E0h]
  struct timeval v68; // [sp+C8h] [bp-8DCh] BYREF
  struct timeval v69; // [sp+D0h] [bp-8D4h] BYREF
  _BYTE v70[20]; // [sp+D8h] [bp-8CCh] BYREF
  int v71; // [sp+ECh] [bp-8B8h]
  int v72; // [sp+F0h] [bp-8B4h]
  int v73; // [sp+F4h] [bp-8B0h]
  int v74; // [sp+F8h] [bp-8ACh]
  int v75; // [sp+FCh] [bp-8A8h]
  int v76; // [sp+100h] [bp-8A4h]
  int v77; // [sp+104h] [bp-8A0h]
  int v78; // [sp+108h] [bp-89Ch] BYREF
  _BYTE v79[148]; // [sp+10Ch] [bp-898h] BYREF
  char s[2052]; // [sp+1A0h] [bp-804h] BYREF

  v65 = a1;
  v66 = &dword_9E31C;
  sub_4A60C(&v68);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "\n");
    sub_47EC8(3, s, 0);
    if ( (unsigned int)*v66 > 3 )
    {
      snprintf(s, 0x800u, ">>>> Send work for chain %d.\n", v65);
      sub_47AB4(3, s, 0);
    }
  }
  v55 = 0;
  v64 = 0;
  v63 = 6656 * v65 + 3898820;
  v62 = (unsigned __int8)~((unsigned int)~(v65 << 25) >> 25);
  v1 = 1 << v65;
  v2 = 0;
  v67 = &unk_EDF22;
  do
  {
    v3 = v1;
    v4 = v2;
    v60 = 0;
    v61 = *(_DWORD *)(dword_1AEA68 + 4 * ((_DWORD)v67 + v64) + 4) + 20;
    do
    {
      v5 = (_DWORD *)v61;
      v59 = v60 & 3;
      v54 = 0;
      do
      {
        while ( (v3 & sub_6FF04()) == 0 )
        {
          ++v4;
          usleep(0x3E8u);
        }
        v6 = (int *)v70;
        v7 = v5 - 5;
        v53 = v5 - 5;
        do
        {
          v8 = *v7;
          v7 += 4;
          v9 = *(v7 - 3);
          v10 = v6;
          v11 = *(v7 - 2);
          v6 += 4;
          v12 = *(v7 - 1);
          *v10 = v8;
          v10[1] = v9;
          v10[2] = v11;
          v10[3] = v12;
        }
        while ( v7 != v5 + 7 );
        v13 = 0;
        *v6 = *v7;
        memset(&v79[2], 0, 0x92u);
        v14 = *(v5 - 3);
        v58 = v4;
        v15 = v63 + 52 * v55;
        v16 = *(v5 - 2);
        v17 = v59;
        v79[1] = v62;
        v18 = *(v5 - 1);
        LOBYTE(v71) = v71 + 1;
        *(_DWORD *)&v79[8] = v14;
        *(_DWORD *)&v79[12] = v16;
        *(_DWORD *)&v79[16] = v18;
        v52 = &v78;
        v57 = v3;
        *(_DWORD *)&v79[4] = v55 & 0x7F | v54;
        v56 = v53 + 12;
        v79[0] = 1;
        do
        {
          v19 = (_DWORD *)(dword_1AEA68 + v15);
          if ( v13 == v17 )
          {
            v39 = &v79[32 * v13 + 20];
            v40 = v5[1];
            v41 = v5[2];
            *v39 = *v5;
            v42 = v5[3];
            v43 = v53;
            v39[1] = v40;
            v39[3] = v42;
            v44 = v5[4];
            v39[2] = v41;
            v45 = v5[5];
            v46 = v5[6];
            v39[4] = v44;
            v47 = v5[7];
            v39[5] = v45;
            v39[6] = v46;
            v39[7] = v47;
            do
            {
              v43 += 4;
              v19 += 4;
              v48 = *(v43 - 3);
              v49 = *(v43 - 2);
              v50 = *(v43 - 1);
              v33 = v43 == v56;
              *(v19 - 4) = *(v43 - 4);
              *(v19 - 3) = v48;
              *(v19 - 2) = v49;
              *(v19 - 1) = v50;
            }
            while ( !v33 );
            *v19 = *v56;
          }
          else
          {
            v20 = v72;
            v21 = v73;
            v22 = v74;
            v23 = v70;
            v24 = &v79[32 * v13 + 20];
            *v24 = v71;
            v24[1] = v20;
            v24[2] = v21;
            v24[3] = v22;
            v25 = &v79[32 * v13 + 36];
            v26 = v76;
            v27 = v77;
            v28 = v78;
            *v25 = v75;
            v25[1] = v26;
            v25[2] = v27;
            v25[3] = v28;
            do
            {
              v29 = v23;
              v23 += 4;
              v19 += 4;
              v30 = v29[1];
              v31 = v29[2];
              v32 = v29[3];
              v33 = v29 + 4 == v52;
              *(v19 - 4) = *v29;
              *(v19 - 3) = v30;
              *(v19 - 2) = v31;
              *(v19 - 1) = v32;
            }
            while ( !v33 );
            *v19 = *v23;
          }
          ++v13;
          v15 += 52;
        }
        while ( v13 != 4 );
        v3 = v57;
        v5 += 13;
        v34 = v55 + 4;
        v4 = v58;
        memcpy(v51, &v79[16], sizeof(v51));
        v35 = v54 + 128;
        v54 += 128;
        sub_1B010(
          *(unsigned int *)v79,
          *(int *)&v79[4],
          *(int *)&v79[8],
          *(int *)&v79[12],
          v51[0],
          v51[1],
          v51[2],
          v51[3],
          v51[4],
          v51[5],
          v51[6],
          v51[7],
          v51[8],
          v51[9],
          v51[10],
          v51[11],
          v51[12],
          v51[13],
          v51[14],
          v51[15],
          v51[16],
          v51[17],
          v51[18],
          v51[19],
          v51[20],
          v51[21],
          v51[22],
          v51[23],
          v51[24],
          v51[25],
          v51[26],
          v51[27],
          v51[28]);
        if ( v34 >= 0x80 )
          v36 = 0;
        else
          v36 = v34;
        v55 = v36;
      }
      while ( v35 != 1024 );
      ++v60;
      v61 += 416;
    }
    while ( v60 != 383 );
    v2 = v4;
    v1 = v3;
    ++v64;
  }
  while ( v64 != 78 );
  sub_4A60C(&v69);
  v37 = v69.tv_sec - v68.tv_sec;
  if ( v69.tv_usec - v68.tv_usec < 0 )
    --v37;
  if ( (unsigned int)*v66 > 3 )
  {
    snprintf(s, 0x800u, "Send work for chain %d done, time cost %lds, sleep_count = %d\n", v65, v37, v2);
    sub_47AB4(3, s, 0);
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA68: using guessed type int dword_1AEA68;

//----- (000331AC) --------------------------------------------------------
unsigned int __fastcall sub_331AC(int a1)
{
  unsigned int v1; // r6
  unsigned int v3; // r1
  unsigned int v4; // r7
  int v5; // r8
  int v6; // r9
  unsigned int result; // r0
  int v8; // r2
  int v9; // r1
  bool v10; // cc
  int v11; // r3
  int v12; // r12
  int v13; // r2
  int v14; // r2

  v1 = *(_DWORD *)(a1 + 4);
  v3 = *(unsigned __int8 *)(dword_A0D68 + 12954);
  if ( !*(_BYTE *)(dword_A0D68 + 12954) )
    v3 = 3;
  v4 = sub_75CF4(v1, v3);
  v5 = *(_WORD *)(a1 + 2) & 0x7FFF;
  v6 = *(_BYTE *)a1 & 0xF;
  result = sub_75CEC(v1);
  if ( *(_DWORD *)(dword_A0D68 + 4 * v6 + 4) )
  {
    v8 = dword_1AEA68;
    if ( (*(_BYTE *)a1 & 0x20) != 0 )
    {
      ++*(_DWORD *)(dword_1AEA68 + 4 * v6 + 1941192);
    }
    else if ( (*(_BYTE *)a1 & 0x40) != 0 )
    {
      ++*(_DWORD *)(dword_1AEA68 + 4 * v6 + 1941256);
    }
    else if ( (*(_BYTE *)a1 & 0x80) != 0 )
    {
      if ( v4 > 0x4D )
      {
        ++*(_DWORD *)(dword_1AEA68 + 4 * v6 + 3853516);
      }
      else
      {
        result = 4 * (__int16)result + (v5 & 3);
        v9 = v5 >> 7;
        v10 = (unsigned int)(v5 >> 7) > 7;
        if ( (unsigned int)(v5 >> 7) <= 7 )
          v10 = result > 0x17E;
        if ( v10 )
        {
          ++*(_DWORD *)(dword_1AEA68 + 4 * v6 + 1941448);
        }
        else if ( *(_DWORD *)(*(_DWORD *)(dword_1AEA68 + 4 * ((_DWORD)&unk_EDF22 + v4) + 4) + 52 * v9 + 416 * result + 4) == v1 )
        {
          v11 = dword_1AEA68 + 4 * (383 * v4 + 29874 * v6 + result);
          result = v11 + 1941504;
          v12 = *(_DWORD *)(v11 + 1941576);
          if ( (v12 & (1 << v9)) != 0 )
          {
            ++*(_DWORD *)(dword_1AEA68 + 4 * v6 + 1941128);
          }
          else
          {
            *(_DWORD *)(v11 + 1941576) = v12 | (1 << v9);
            result = *(_DWORD *)(v11 + 8) + 1;
            *(_DWORD *)(v11 + 8) = result;
            ++*(_DWORD *)(v8 + 4 * (v4 + 78 * v6) + 1911944);
            ++*(_DWORD *)(v8 + 4 * v6 + 1916936);
          }
        }
        else
        {
          result = sub_31658((_DWORD *)(dword_1AEA68 + 52 * (v5 & 0x7F) + 6656 * v6 + 3898820), v1);
          if ( result )
            v13 = *(_DWORD *)(dword_1AEA68 + 4 * v6 + 1941384);
          else
            v13 = *(_DWORD *)(dword_1AEA68 + 4 * v6 + 1941448);
          v14 = v13 + 1;
          if ( result )
            *(_DWORD *)(dword_1AEA68 + 4 * v6 + 1941384) = v14;
          else
            *(_DWORD *)(dword_1AEA68 + 4 * v6 + 1941448) = v14;
        }
      }
    }
    else
    {
      ++*(_DWORD *)(dword_1AEA68 + 4 * v6 + 1941320);
    }
  }
  else
  {
    ++*(_DWORD *)(dword_1AEA68 + 3853512);
  }
  return result;
}
// A0D68: using guessed type int dword_A0D68;
// 1AEA68: using guessed type int dword_1AEA68;

//----- (00033428) --------------------------------------------------------
void sub_33428()
{
  int v0; // r5
  char *v1; // r2
  char *v2; // r4
  int v3; // r4

  v0 = 0;
  v1 = (char *)dword_1AEA68;
  do
  {
    v2 = (char *)&unk_EDF22 + v0++;
    v3 = 4 * (_DWORD)v2;
    if ( *(_DWORD *)&v1[v3 + 4] )
    {
      free(*(void **)&v1[v3 + 4]);
      v1 = (char *)dword_1AEA68;
      *(_DWORD *)(dword_1AEA68 + v3 + 4) = 0;
    }
  }
  while ( v0 != 78 );
  free(v1);
  dword_1AEA68 = 0;
}
// 1AEA68: using guessed type int dword_1AEA68;

//----- (00033490) --------------------------------------------------------
void sub_33490()
{
  if ( dword_1AEA68 )
    sub_33428();
}
// 1AEA68: using guessed type int dword_1AEA68;

//----- (000334A8) --------------------------------------------------------
int __fastcall sub_334A8(FILE **a1, int a2, int a3, int a4)
{
  int v4; // r6
  int v5; // r7
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r5
  int v16; // r8
  _DWORD *v17; // r4
  int v19; // [sp+4h] [bp-840h]
  _DWORD ptr[12]; // [sp+10h] [bp-834h] BYREF
  char v23[2052]; // [sp+40h] [bp-804h] BYREF

  if ( a4 )
  {
    v4 = 52 * a3 * a4;
    v19 = 4 * ((_DWORD)&unk_EDF22 + a2);
    v5 = 0;
    while ( 1 )
    {
      v15 = v5++;
      v16 = *(_DWORD *)(dword_1AEA68 + v19 + 4);
      v17 = (_DWORD *)(v16 + v4);
      if ( fread(ptr, 1u, 0x30u, *a1) != 48 )
        break;
      v17[1] = ptr[0];
      v6 = ptr[5];
      v7 = ptr[6];
      v8 = ptr[7];
      v17[5] = ptr[4];
      *(_DWORD *)(v16 + v4 + 24) = v6;
      *(_DWORD *)(v16 + v4 + 28) = v7;
      *(_DWORD *)(v16 + v4 + 32) = v8;
      v9 = ptr[9];
      v10 = ptr[10];
      v11 = ptr[11];
      *(_DWORD *)(v16 + v4 + 36) = ptr[8];
      *(_DWORD *)(v16 + v4 + 40) = v9;
      *(_DWORD *)(v16 + v4 + 44) = v10;
      v12 = ptr[1];
      v13 = ptr[2];
      v14 = ptr[3];
      *(_DWORD *)(v16 + v4 + 48) = v11;
      v17[2] = v12;
      *(_DWORD *)(v16 + v4 + 12) = v13;
      *(_DWORD *)(v16 + v4 + 16) = v14;
      *(_DWORD *)(v16 + v4) = v15;
      v4 += 52;
      if ( v5 == a4 )
        return v5;
    }
    if ( (unsigned int)dword_9E31C <= 3 )
      return v15;
    strcpy(v23, "Load core pattern failed!\n");
    sub_47AB4(3, v23, 0);
    return v15;
  }
  else
  {
    return 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA68: using guessed type int dword_1AEA68;

//----- (00033618) --------------------------------------------------------
int __fastcall sub_33618(int a1)
{
  _DWORD *v2; // r7
  const char *v3; // r5
  int v4; // r6
  unsigned int v5; // r5
  int i; // r4
  int v7; // r2
  _DWORD *v9; // r0
  char *v10; // r4
  char *v11; // r9
  void *v12; // r0
  FILE *stream; // [sp+Ch] [bp-804h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(s, "[DEBUG] Free memory for sw sweep.\n");
    sub_47AB4(4, s, 0);
  }
  v2 = (_DWORD *)dword_1AEA68;
  if ( !dword_1AEA68 )
  {
    v9 = calloc(0x3D1DC4u, 1u);
    v2 = v9;
    dword_1AEA68 = (int)v9;
    if ( v9 )
    {
      v10 = (char *)(v9 + 974626);
      v11 = (char *)(v9 + 974704);
      while ( 1 )
      {
        v12 = malloc((size_t)&loc_26E60);
        *((_DWORD *)v10 + 1) = v12;
        v10 += 4;
        if ( !v12 )
          break;
        if ( v11 == v10 )
          goto LABEL_4;
      }
      if ( (unsigned int)dword_9E31C <= 3 )
      {
LABEL_22:
        sub_33428();
LABEL_23:
        sub_31794(13, 255);
        return -1;
      }
      strcpy(s, "Fail to allocate memory for works.\n");
      sub_47AB4(3, s, 0);
    }
    else
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_23;
      strcpy(s, "Fail to allocate memory for sw sweep ctxt.\n");
      sub_47AB4(3, s, 0);
    }
    if ( !dword_1AEA68 )
      goto LABEL_23;
    goto LABEL_22;
  }
LABEL_4:
  *v2 = a1;
  v3 = *(const char **)dword_1AEA68;
  stream = (FILE *)fopen64(*(_DWORD *)dword_1AEA68, "r");
  if ( stream )
  {
    v4 = 0;
    while ( 1 )
    {
      v5 = 0;
      for ( i = 0; i != 383; ++i )
      {
        v7 = i;
        v5 += sub_334A8(&stream, v4, v7, 8);
      }
      if ( v5 <= 0xBF7 )
        break;
      if ( ++v4 == 78 )
      {
        fclose(stream);
        return 0;
      }
    }
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "No enough work, asic = %d, work_count = %d, work_count_target = %d.\n", v4, v5, 3064);
      sub_47AB4(3, s, 0);
    }
    fclose(stream);
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "Fail to open pattern file %s.\n", v3);
    sub_47AB4(3, s, 0);
  }
  sub_31794(22, 255);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "Load pattern file failed.\n");
    sub_47AB4(3, s, 0);
  }
  return -1;
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 9E31C: using guessed type int dword_9E31C;
// 1AEA68: using guessed type int dword_1AEA68;

//----- (00033918) --------------------------------------------------------
char **sub_33918()
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v1, "[DEBUG] Get sw ops.\n");
    sub_47AB4(4, v1, 0);
  }
  return &off_9C590;
}
// 9C590: using guessed type char *off_9C590;
// 9E31C: using guessed type int dword_9E31C;

//----- (00033988) --------------------------------------------------------
void __noreturn sub_33988()
{
  int v0; // r0
  unsigned int v1; // r0
  int v2; // r8
  int v3; // r4
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v4, "[DEBUG] Recv nonce and register.\n");
    sub_47AB4(4, v4, 0);
  }
  v0 = sub_702AC();
  sub_702CC(v0 | 0x10000);
  sub_2E9B8();
  while ( 1 )
  {
    v1 = sub_6FD6C();
    v2 = (unsigned __int8)(v1 >> 1);
    if ( (unsigned __int8)(v1 >> 1) )
      break;
LABEL_12:
    usleep(0x3E8u);
  }
  v3 = 0;
  while ( 1 )
  {
    sub_6FDC4(v4);
    if ( v4[3] < 0 )
      break;
    if ( (unsigned int)dword_241D70 <= 0x1FE && dword_241D68[0] <= 0x1FEu )
    {
      sub_376A4(v4);
LABEL_7:
      if ( v2 == ++v3 )
        goto LABEL_12;
    }
    else
    {
      ++v3;
      sub_2E9B8();
      if ( v2 == v3 )
        goto LABEL_12;
    }
  }
  sub_37594();
  goto LABEL_7;
}
// 9E31C: using guessed type int dword_9E31C;
// 241D68: using guessed type int dword_241D68[];
// 241D70: using guessed type int dword_241D70;

//----- (00033A7C) --------------------------------------------------------
int sub_33A7C()
{
  int v0; // r8
  int i; // r4
  int v2; // r3
  int v3; // r10
  float v4; // s12
  float v5; // s14
  int v6; // r2
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v0 = 0;
  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        return v0;
    }
    v2 = dword_1AEA6C;
    v3 = 4 * (i + 1268);
    v4 = *(float *)(dword_1AEA6C + v3);
    v5 = *(float *)(*(_DWORD *)(dword_1AEA6C + 8) + 20);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "chain = %d, nonce_rate_max = %.4f, nonce_rate_threshold = %.4f\n", i, v4, v5);
      sub_47AB4(3, s, 0);
      v2 = dword_1AEA6C;
      v4 = *(float *)(dword_1AEA6C + v3);
      v5 = *(float *)(*(_DWORD *)(dword_1AEA6C + 8) + 20);
    }
    v6 = i + 1300;
    if ( v4 < v5 )
    {
      v0 = 1;
      *(_DWORD *)(v2 + 4 * v6) = 1;
    }
  }
  return v0;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA6C: using guessed type int dword_1AEA6C;

//----- (00033B7C) --------------------------------------------------------
void sub_33B7C()
{
  char v0[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v0, "[DEBUG] Sweep exit.\n");
    sub_47AB4(4, v0, 0);
    if ( (unsigned int)dword_9E31C > 4 )
    {
      strcpy(v0, "[DEBUG] Free memory for sweep.\n");
      sub_47AB4(4, v0, 0);
    }
  }
  if ( dword_1AEA6C )
  {
    free((void *)dword_1AEA6C);
    dword_1AEA6C = 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA6C: using guessed type int dword_1AEA6C;

//----- (00033C2C) --------------------------------------------------------
int __fastcall sub_33C2C(int a1, int a2)
{
  _DWORD *v4; // r1
  int v5; // r12
  int v6; // r1
  int v7; // r8
  int i; // r4
  _DWORD v10[10]; // [sp+0h] [bp-82Ch] BYREF
  char v11[2052]; // [sp+28h] [bp-804h] BYREF

  memset(v10, 0, sizeof(v10));
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v11, "Build tuning basic config.\n");
    sub_47AB4(3, v11, 0);
  }
  v4 = *(_DWORD **)(a1 + 4);
  v10[0] = **(_DWORD **)a1;
  v10[1] = *v4;
  v5 = v4[5];
  v10[2] = v4[1];
  v6 = v4[2];
  v10[4] = v5;
  v10[3] = v6;
  LOWORD(v10[5]) = *(_WORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 8);
  v10[6] = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 12);
  v10[7] = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 16);
  v10[8] = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 20);
  v10[9] = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 28);
  v7 = sub_39F80((int)v10);
  if ( v7 && (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v11, "Do freq tuning basic failed.\n");
    sub_47AB4(3, v11, 0);
  }
  for ( i = 0; i != 16; ++i )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
      {
        if ( sub_39B70(i) )
        {
          *(_DWORD *)(a2 + 4 * i) = sub_39B88(i);
          goto LABEL_7;
        }
        *(_DWORD *)(a2 + 4 * i) = v10[1];
        if ( (unsigned int)dword_9E31C > 3 )
          break;
      }
LABEL_7:
      if ( ++i == 16 )
        return v7;
    }
    strcpy(v11, "Freq result is invalid, using freq_base as default.\n");
    sub_47AB4(3, v11, 0);
  }
  return v7;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA6C: using guessed type int dword_1AEA6C;

//----- (00033E28) --------------------------------------------------------
int __fastcall sub_33E28(int a1)
{
  unsigned int v2; // r6
  _DWORD *v4; // r7
  char *v5; // lr
  char *v6; // r12
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  _DWORD *v11; // lr
  char *v12; // r12
  int v13; // r1
  int v14; // r2
  char v15[2052]; // [sp+0h] [bp-804h] BYREF

  v2 = a1 - 160;
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v15, 0x800u, "[DEBUG] Sweep init, sweep_type = 0x%X.\n", a1);
    sub_47AB4(4, v15, 0);
    if ( v2 > 1 )
      goto LABEL_3;
    if ( (unsigned int)dword_9E31C > 4 )
    {
      strcpy(v15, "[DEBUG] Allocate memory for sweep.\n");
      sub_47AB4(4, v15, 0);
    }
  }
  else if ( v2 > 1 )
  {
LABEL_3:
    sub_31794(20, 255);
    if ( (unsigned int)dword_9E31C <= 3 )
      return -1;
    v5 = "Sweep type error, exit.\n";
    v6 = v15;
LABEL_14:
    v7 = *(_DWORD *)v5;
    v8 = *((_DWORD *)v5 + 1);
    v9 = *((_DWORD *)v5 + 2);
    v10 = *((_DWORD *)v5 + 3);
    v11 = v5 + 16;
    *(_DWORD *)v6 = v7;
    *((_DWORD *)v6 + 1) = v8;
    *((_DWORD *)v6 + 2) = v9;
    *((_DWORD *)v6 + 3) = v10;
    v12 = v6 + 16;
    v13 = v11[1];
    v14 = v11[2];
    *(_DWORD *)v12 = *v11;
    *((_DWORD *)v12 + 1) = v13;
    v12[8] = v14;
    sub_47AB4(3, v15, 0);
    return -1;
  }
  v4 = (_DWORD *)dword_1AEA6C;
  if ( !dword_1AEA6C )
  {
    v4 = calloc(0x2148u, 1u);
    dword_1AEA6C = (int)v4;
    if ( !v4 )
    {
      sub_31794(13, 255);
      if ( (unsigned int)dword_9E31C <= 3 )
        return -1;
      v5 = " memory for sweep ctxt.\n";
      qmemcpy(v15, "Fail to allocate", 16);
      v6 = &v15[16];
      goto LABEL_14;
    }
  }
  *v4 = a1;
  v4[1] = 1199570688;
  if ( sub_3C4FC(0) )
  {
    if ( dword_1AEA70 )
    {
      *(_DWORD *)(dword_1AEA6C + 8) = dword_1AEA70;
      return 0;
    }
    sub_31794(15, 255);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v15, 0x800u, "Unknown miner type(%d).\n", 1);
      sub_47AB4(3, v15, 0);
      return -1;
    }
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v15, "board adapt failed, exit\n");
    sub_47AB4(3, v15, 0);
  }
  return -1;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA6C: using guessed type int dword_1AEA6C;
// 1AEA70: using guessed type int dword_1AEA70;

//----- (0003405C) --------------------------------------------------------
int __fastcall sub_3405C(int **a1, int a2, int a3)
{
  int result; // r0
  int v6; // r0
  int v7; // r2
  int v8; // r4
  unsigned int v9; // r5
  int v10; // lr
  int v11; // r3
  int v12; // r1
  int v13; // r2
  int v14; // r4
  int v15; // t1
  int v16; // r12
  unsigned int v17; // r0
  unsigned int v18; // t1
  unsigned int v20; // r12
  int v21; // r0
  unsigned int v22; // r4
  int v23; // t1
  int v24; // lr
  unsigned int v25; // r2
  unsigned int v26; // t1
  int v27; // r6
  int v28; // r0
  int v29; // r4
  int v30; // r0
  int v31; // r3
  int v32; // r5
  int v33; // r0
  int v34; // r5
  int v35; // r6
  int v36; // r8
  int v37; // r0
  int v38; // r1
  char *v39; // r12
  int v40; // r3
  int v41; // t1
  int v42; // t1
  int v43; // [sp+8h] [bp-81Ch]
  unsigned int v44; // [sp+Ch] [bp-818h]
  char *v45; // [sp+10h] [bp-814h]
  unsigned int v46; // [sp+1Ch] [bp-808h] BYREF
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "\n");
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, ">>>> Get ideal hash rate, round %d.\n", a3);
      sub_47AB4(3, s, 0);
    }
  }
  v43 = sub_385EC(a2);
  if ( v43 )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return v43;
    strcpy(s, "Board init failed.\n");
    sub_47AB4(3, s, 0);
    return v43;
  }
  sub_38064();
  v6 = **a1;
  v7 = (*a1)[4];
  if ( v6 > v7 )
  {
    **a1 = v7;
    v6 = **a1;
  }
  sub_1A0F0(v6);
  sub_30CAC(
    dword_1AEA6C + 12,
    (unsigned __int8)byte_A0D79,
    dword_9C298,
    *(unsigned __int8 *)(*(_DWORD *)(dword_1AEA6C + 8) + 8));
  v8 = sub_1A1C0();
  if ( v8 != sub_1A1B0() )
  {
    result = sub_1A3B8();
    if ( result )
      return result;
  }
  v9 = 0xFFFFFF;
  v10 = dword_A0D68;
  v11 = dword_1AEA6C + 8;
  v12 = dword_1AEA6C + 5000;
  v13 = dword_1AEA6C + 8;
  v14 = dword_A0D68;
  do
  {
    v15 = *(_DWORD *)(v14 + 4);
    v14 += 4;
    v16 = v13 + 312;
    if ( v15 == 1 )
    {
      do
      {
        v18 = *(_DWORD *)(v13 + 4);
        v13 += 4;
        v17 = v18;
        if ( v9 >= v18 )
          v9 = v17;
      }
      while ( v13 != v16 );
    }
    v13 = v16;
  }
  while ( v16 != v12 );
  v20 = dword_9E31C;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_min = %d\n", 255, v9);
    sub_47AB4(3, s, 0);
    v10 = dword_A0D68;
    v20 = dword_9E31C;
    v11 = dword_1AEA6C + 8;
    v12 = dword_1AEA6C + 5000;
  }
  v21 = v10;
  v22 = 0;
  do
  {
    v23 = *(_DWORD *)(v21 + 4);
    v21 += 4;
    v24 = v11 + 312;
    if ( v23 == 1 )
    {
      do
      {
        v26 = *(_DWORD *)(v11 + 4);
        v11 += 4;
        v25 = v26;
        if ( v22 < v26 )
          v22 = v25;
      }
      while ( v11 != v24 );
    }
    v11 = v24;
  }
  while ( v24 != v12 );
  if ( v20 > 3 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_max = %d\n", 255, v22);
    sub_47AB4(3, s, 0);
  }
  v27 = 0;
  v46 = v22;
  sub_22E9C(v9, 8, 20);
  do
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * v27 + 4) != 1 )
    {
      if ( ++v27 == 16 )
        goto LABEL_34;
    }
    v28 = v27++;
    sub_37BD4(v28, 1);
  }
  while ( v27 != 16 );
LABEL_34:
  v29 = 0;
  sub_39138((int)&v46);
  v30 = sub_37770();
  v31 = dword_A0D68;
  v32 = v30;
  do
  {
    while ( *(_DWORD *)(v31 + 4 * v29 + 4) != 1 )
    {
      if ( ++v29 == 16 )
        goto LABEL_38;
    }
    v33 = v29++;
    sub_3883C(v33, v32);
    v31 = dword_A0D68;
  }
  while ( v29 != 16 );
LABEL_38:
  v44 = dword_9E31C;
  v45 = (char *)&unk_1D2C70 + v32;
  v34 = 0;
  v35 = 12;
  v36 = 0;
  while ( 1 )
  {
    if ( *(_DWORD *)(v31 + 4 * v34 + 4) == 1 )
    {
      v37 = 0;
      v38 = dword_1AEA6C + v35 - 4;
      v39 = &v45[v35];
      do
      {
        v41 = *(_DWORD *)(v38 + 4);
        v38 += 4;
        v40 = v41;
        v42 = *((_DWORD *)v39 + 1);
        v39 += 4;
        v37 += v42 * v40 / 0x1F40u;
      }
      while ( v38 != dword_1AEA6C + v35 + 308 );
      v36 += v37;
      *(_DWORD *)(dword_1AEA6C + 4 * (v34 + 1250) + 4) = v37;
      if ( v44 > 3 )
        break;
    }
    ++v34;
    v35 += 312;
    if ( v34 == 16 )
      goto LABEL_46;
LABEL_40:
    v31 = dword_A0D68;
  }
  snprintf(s, 0x800u, "chain = %d, ideal_hash_rate_GH = %d\n", v34++, v37);
  sub_47AB4(3, s, 0);
  v35 += 312;
  v44 = dword_9E31C;
  if ( v34 != 16 )
    goto LABEL_40;
LABEL_46:
  if ( v44 > 3 )
  {
    snprintf(s, 0x800u, "hash_rate_total_GH = %d\n", v36);
    sub_47AB4(3, s, 0);
  }
  return v43;
}
// 9C298: using guessed type int dword_9C298;
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// A0D79: using guessed type char byte_A0D79;
// 1AEA6C: using guessed type int dword_1AEA6C;

//----- (000344E0) --------------------------------------------------------
int sub_344E0()
{
  FILE *v0; // r4
  int result; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = (FILE *)fopen64("/config/scanfreqdone", "r");
  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v2, "[DEBUG] Check if sweep is already done.\n");
    sub_47AB4(4, v2, 0);
  }
  result = (int)v0;
  if ( v0 )
  {
    fclose(v0);
    return 1;
  }
  return result;
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 9E31C: using guessed type int dword_9E31C;

//----- (00034568) --------------------------------------------------------
int __fastcall sub_34568(int a1)
{
  float v1; // s0
  int v3; // r6
  int v5; // r3
  int v6; // r9
  unsigned int v7; // r8
  _DWORD **v8; // r6
  int v9; // r5
  int v10; // r5
  char *v11; // r8
  char *v12; // r1
  const char *v13; // r1
  int v14; // r5
  _DWORD *v15; // r3
  unsigned int v16; // r1
  char *v17; // r8
  char *v18; // r9
  int v19; // r5
  int v20; // r5
  int v21; // r12
  int v22; // r5
  int v23; // r1
  unsigned int v24; // r1
  int v25; // r5
  unsigned int v26; // r0
  _BYTE *v27; // r2
  int v28; // r12
  int v29; // t1
  unsigned int v30; // r1
  int v31; // r6
  int i; // r3
  int v33; // r8
  unsigned int v34; // r9
  int k; // r5
  int v36; // r0
  unsigned int v37; // r8
  int v38; // r3
  int v39; // r2
  int v40; // t1
  __int64 v41; // r6
  bool v42; // cc
  int v43; // r6
  _DWORD *v44; // r5
  int v45; // r7
  int v46; // r1
  int v47; // r3
  int v48; // r3
  float v49; // s14
  int v50; // r6
  unsigned int v51; // lr
  int v52; // r0
  int v53; // r12
  _DWORD *v54; // r3
  int v55; // t1
  _DWORD *v56; // r1
  int v57; // t1
  int v58; // r0
  unsigned int v59; // r1
  int v60; // lr
  int v61; // t1
  int v62; // r5
  int v63; // t1
  signed int v64; // r1
  signed int v65; // s17
  unsigned int v66; // s15
  unsigned int v67; // r7
  int v68; // r5
  int v69; // r0
  int v70; // r6
  int v71; // r3
  _DWORD *v72; // r2
  int v73; // lr
  int v74; // r12
  int v75; // t1
  _DWORD *v76; // r1
  int v77; // t1
  int v78; // r12
  int v79; // lr
  unsigned int v80; // r6
  int v81; // r5
  int v82; // r1
  int v83; // t1
  int v84; // r0
  int v85; // t1
  int v86; // lr
  unsigned int v87; // r0
  char *v88; // r1
  int v89; // t1
  char *v90; // r12
  int v91; // t1
  __int64 v92; // r0
  unsigned int v93; // r6
  int v94; // r2
  int v95; // r3
  int v96; // r3
  unsigned int v97; // r2
  int v98; // r7
  int v99; // r1
  int v100; // r7
  int j; // r6
  int v102; // r5
  int v103; // r3
  int v104; // r2
  int v105; // r5
  int v106; // r12
  int v107; // r2
  unsigned int v108; // r0
  int m; // r3
  int v110; // r1
  int v111; // t1
  bool v112; // zf
  unsigned int v113; // r0
  int v114; // r2
  unsigned int v115; // r3
  const char *v116; // r12
  int v117; // r0
  int v118; // r1
  int v119; // r2
  int v120; // r3
  int *v121; // r12
  int v122; // r0
  int v123; // r1
  int v124; // r2
  int v125; // r3
  int v126; // r1
  int v127; // r2
  int v128; // r7
  int v129; // r6
  int v130; // lr
  int v131; // r1
  int v132; // r5
  int v133; // t1
  int v134; // r12
  int v135; // r0
  unsigned int v136; // t1
  unsigned int v137; // r0
  int v138; // lr
  int *v139; // r5
  int v140; // t1
  int v141; // r2
  int v142; // t1
  unsigned int v143; // r6
  unsigned int *v144; // r1
  int v145; // r5
  int v146; // r2
  unsigned int v147; // r6
  int v148; // r0
  char *v149; // r3
  int v150; // t1
  int v151; // r8
  int v152; // r3
  int v153; // r1
  int v154; // r2
  unsigned int v155; // r0
  int v156; // r12
  char *v157; // r2
  int v158; // t1
  int v159; // [sp+18h] [bp-1044h]
  int v160; // [sp+1Ch] [bp-1040h]
  unsigned int v161; // [sp+2Ch] [bp-1030h]
  char *v162; // [sp+2Ch] [bp-1030h]
  int v163; // [sp+2Ch] [bp-1030h]
  unsigned int v164; // [sp+30h] [bp-102Ch]
  char *v165; // [sp+30h] [bp-102Ch]
  unsigned int v166; // [sp+30h] [bp-102Ch]
  char *v167; // [sp+30h] [bp-102Ch]
  char *v168; // [sp+30h] [bp-102Ch]
  char *v169; // [sp+30h] [bp-102Ch]
  int v170; // [sp+34h] [bp-1028h]
  int v171; // [sp+34h] [bp-1028h]
  pthread_t newthread; // [sp+3Ch] [bp-1020h] BYREF
  struct timeval v173; // [sp+40h] [bp-101Ch] BYREF
  _DWORD v174[2]; // [sp+48h] [bp-1014h] BYREF
  int (__fastcall *v175)(unsigned int); // [sp+50h] [bp-100Ch]
  _BYTE s[64]; // [sp+54h] [bp-1008h] BYREF
  _BYTE v177[1988]; // [sp+94h] [bp-FC8h] BYREF
  _DWORD v178[513]; // [sp+858h] [bp-804h] BYREF

  if ( sub_344E0() )
  {
    v3 = 0;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy((char *)v178, "Sweep already done, exit.\n");
      sub_47AB4(3, (const char *)v178, 0);
    }
    return v3;
  }
  sub_4A60C(&v173);
  dword_1AEA74 = 2;
  v3 = sub_33E28(a1);
  if ( v3 )
  {
    dword_1AEA74 = 1;
    return v3;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_8;
  strcpy((char *)v178, "Sweep start...\n");
  sub_47AB4(3, (const char *)v178, 0);
  v10 = *(_DWORD *)(dword_1AEA6C + 8);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf((char *)v178, 0x800u, "%-40s : %s\n", "proj_type", *(const char **)v10);
    sub_47EC8(3, (const char *)v178, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_8;
    snprintf((char *)v178, 0x800u, "%-40s : %d\n", "work_mode_count", *(_DWORD *)(v10 + 4));
    sub_47EC8(3, (const char *)v178, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_68;
    v11 = "false";
    if ( *(_BYTE *)(v10 + 8) )
      v12 = "true";
    else
      v12 = "false";
    snprintf((char *)v178, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol", v12);
    sub_47EC8(3, (const char *)v178, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_8;
    if ( *(_BYTE *)(v10 + 9) )
      v11 = "true";
    snprintf((char *)v178, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v11);
    sub_47EC8(3, (const char *)v178, 0);
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_71;
  v13 = "true";
  if ( !*(_DWORD *)(v10 + 12) )
    v13 = "false";
  snprintf((char *)v178, 0x800u, "%-40s : %s\n", "is_board_init_with_power_off", v13);
  sub_47EC8(3, (const char *)v178, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_8;
  snprintf((char *)v178, 0x800u, "%-40s : %.4f\n", "hw_threshold", *(float *)(v10 + 16));
  sub_47EC8(3, (const char *)v178, 0);
LABEL_68:
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_74;
  snprintf((char *)v178, 0x800u, "%-40s : %.2f\n", "nonce_rate_threshold", *(float *)(v10 + 20));
  sub_47EC8(3, (const char *)v178, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_8;
  snprintf((char *)v178, 0x800u, "%-40s : %.2f\n", "nonce_rate_ideal_threshold", *(float *)(v10 + 24));
  sub_47EC8(3, (const char *)v178, 0);
LABEL_71:
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_77:
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "pm_read_freq", *(_DWORD *)(v10 + 44));
      sub_47EC8(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf((char *)v178, 0x800u, "%-40s : %d\n", "pm_grade_step", *(_DWORD *)(v10 + 48));
        sub_47EC8(3, (const char *)v178, 0);
        goto LABEL_80;
      }
    }
    goto LABEL_8;
  }
  snprintf((char *)v178, 0x800u, "%-40s : %.2f\n", "nonce_rate_ideal_threshold", *(float *)(v10 + 24));
  sub_47EC8(3, (const char *)v178, 0);
  if ( (unsigned int)dword_9E31C <= 3 )
    goto LABEL_8;
  snprintf((char *)v178, 0x800u, "%-40s : %s\n", "pattern_path", *(const char **)(v10 + 32));
  sub_47EC8(3, (const char *)v178, 0);
LABEL_74:
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_80:
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "r2_back_step", *(_DWORD *)(v10 + 52));
      sub_47EC8(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy((char *)v178, "\n");
        sub_47EC8(3, (const char *)v178, 0);
      }
    }
    goto LABEL_8;
  }
  snprintf((char *)v178, 0x800u, "%-40s : %d\n", "fan_pwm", *(_DWORD *)(v10 + 36));
  sub_47EC8(3, (const char *)v178, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf((char *)v178, 0x800u, "%-40s : %d\n", "pm_read_voltage", *(_DWORD *)(v10 + 40));
    sub_47EC8(3, (const char *)v178, 0);
    goto LABEL_77;
  }
LABEL_8:
  v5 = *(_DWORD *)(dword_1AEA6C + 8);
  if ( *(_DWORD *)(v5 + 4) )
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = (_DWORD **)(*(_DWORD *)(v5 + 56) + v6);
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_10;
      snprintf((char *)v178, 0x800u, "[work mode %d]\n", v7);
      sub_47EC8(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf((char *)v178, 0x800u, "%-40s : %d\n", "voltage_base", **v8);
        sub_47EC8(3, (const char *)v178, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          goto LABEL_10;
        snprintf((char *)v178, 0x800u, "%-40s : %d\n", "voltage_step", (*v8)[1]);
        sub_47EC8(3, (const char *)v178, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          goto LABEL_20;
        snprintf((char *)v178, 0x800u, "%-40s : %d\n", "voltage_threshold", (*v8)[2]);
        sub_47EC8(3, (const char *)v178, 0);
        if ( (unsigned int)dword_9E31C <= 3 )
          goto LABEL_10;
        snprintf((char *)v178, 0x800u, "%-40s : %d\n", "voltage_apply_inc", (*v8)[3]);
        sub_47EC8(3, (const char *)v178, 0);
      }
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_23;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "voltage_apply_max", (*v8)[4]);
      sub_47EC8(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_10;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "voltage_unbalance_inc", (*v8)[5]);
      sub_47EC8(3, (const char *)v178, 0);
LABEL_20:
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_26;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "voltage_r2_inc", (*v8)[6]);
      sub_47EC8(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_10;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_base", *v8[1]);
      sub_47EC8(3, (const char *)v178, 0);
LABEL_23:
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_29;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_threshold", v8[1][1]);
      sub_47EC8(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_10;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_serial_threshold", v8[1][2]);
      sub_47EC8(3, (const char *)v178, 0);
LABEL_26:
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_32;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_diff_threshold", v8[1][3]);
      sub_47EC8(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_10;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_high_vol_threshold_dec", v8[1][4]);
      sub_47EC8(3, (const char *)v178, 0);
LABEL_29:
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_35;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_basic_step", v8[1][5]);
      sub_47EC8(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_10;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_pm_grade_step", v8[1][6]);
      sub_47EC8(3, (const char *)v178, 0);
LABEL_32:
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_38;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_pm_grade_bad_asic_dec", v8[1][7]);
      sub_47EC8(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_10;
      snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_tempeture_dec", v8[1][8]);
      sub_47EC8(3, (const char *)v178, 0);
LABEL_35:
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf((char *)v178, 0x800u, "%-40s : %d\n", "freq_basic_retry", v8[1][9]);
        sub_47EC8(3, (const char *)v178, 0);
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf((char *)v178, 0x800u, "%-40s : %d\n", "hash_rate_target", *v8[2]);
          sub_47EC8(3, (const char *)v178, 0);
LABEL_38:
          if ( (unsigned int)dword_9E31C > 3 )
          {
            snprintf((char *)v178, 0x800u, "%-40s : %d\n", "hash_rate_for_vol_inc", v8[2][1]);
            sub_47EC8(3, (const char *)v178, 0);
            if ( (unsigned int)dword_9E31C > 3 )
            {
              snprintf((char *)v178, 0x800u, "%-40s : %d\n", "hash_rate_rank_step", v8[2][2]);
              sub_47EC8(3, (const char *)v178, 0);
            }
          }
        }
      }
LABEL_10:
      ++v7;
      v6 += 12;
      v5 = *(_DWORD *)(dword_1AEA6C + 8);
    }
    while ( v7 < *(_DWORD *)(v5 + 4) );
  }
  v3 = sub_371E8(a1, *(const char **)(v5 + 32));
  if ( v3 )
  {
    dword_1AEA74 = 1;
    sub_33B7C();
    return v3;
  }
  pthread_create(&newthread, 0, (void *(*)(void *))sub_33988, 0);
  pthread_detach(newthread);
  v3 = sub_24B88();
  if ( v3 )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy((char *)v178, "Board init failed.\n");
      sub_47AB4(3, (const char *)v178, 0);
    }
    goto LABEL_45;
  }
  *(float *)(dword_1AEA6C + 4) = (float)sub_17308();
  sub_21F2C();
  usleep(0x2710u);
  sub_13EE8(*(unsigned __int8 *)(*(_DWORD *)(dword_1AEA6C + 8) + 36));
  sub_1A0F0(*(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 40));
  sub_30770(
    255,
    (unsigned __int8)byte_A0D79,
    *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 44),
    *(unsigned __int8 *)(*(_DWORD *)(dword_1AEA6C + 8) + 8));
  v14 = sub_1A1C0();
  if ( v14 != sub_1A1B0() )
  {
    v3 = sub_1A3B8();
    if ( v3 )
    {
LABEL_45:
      dword_1AEA74 = 1;
      goto LABEL_46;
    }
  }
  sub_38EEC((char *)(dword_1AEA6C + 5272), dword_1AEA6C + 5896, *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 48));
  v15 = *(_DWORD **)(dword_1AEA6C + 8);
  if ( !v15[1] )
  {
    v16 = dword_9E31C;
LABEL_154:
    if ( v16 > 3 )
    {
      strcpy((char *)v178, "Flush result.\n");
      sub_47AB4(3, (const char *)v178, 0);
    }
    goto LABEL_93;
  }
  v16 = dword_9E31C;
  v17 = 0;
  v18 = 0;
  while ( 1 )
  {
    v159 = v15[14];
    if ( v16 > 3 )
    {
      snprintf((char *)v178, 0x800u, "Do single work mode pattern test, work_mode = %d.\n", v18);
      sub_47AB4(3, (const char *)v178, 0);
    }
    memset(v177, 0, sizeof(v177));
    v19 = dword_1AEA6C;
    memset((void *)(dword_1AEA6C + 5072), 0, 0x40u);
    memset((void *)(v19 + 5136), 0, 0x40u);
    memset((void *)(v19 + 5200), 0, 0x40u);
    v20 = v19 + 4 * (_DWORD)v18 + 4096;
    *(_DWORD *)(v20 + 1168) = 0;
    *(_DWORD *)(v20 + 1172) = 0;
    if ( sub_3997C() )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy((char *)v178, "Freq tuning basic init failed.\n");
        sub_47AB4(3, (const char *)v178, 0);
      }
      goto LABEL_92;
    }
    v160 = v159 + 12 * (_DWORD)v18;
    memset(s, 0, sizeof(s));
    v24 = sub_33C2C(v160, (int)s);
    if ( v24 )
      goto LABEL_92;
    v25 = dword_A0D68;
    v26 = 0;
    v27 = s;
    v28 = dword_A0D68;
    do
    {
      v29 = *(_DWORD *)(v28 + 4);
      v28 += 4;
      v27 += 4;
      if ( v29 == 1 )
      {
        ++v24;
        v26 += *((_DWORD *)v27 - 1);
      }
    }
    while ( v27 != v177 );
    if ( v24 )
      v26 /= v24;
    v30 = *(_DWORD *)(*(_DWORD *)(v160 + 4) + 36);
    if ( v30 > v26 )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf((char *)v178, 0x800u, "freq_avg = %d, freq_basic_retry = %d, is_need_retry = %d\n", v26, v30, 1);
        sub_47AB4(3, (const char *)v178, 0);
        v25 = dword_A0D68;
      }
      v41 = 3435973837LL
          * (*(_DWORD *)(*(_DWORD *)(v160 + 8) + 8)
           * 1000
           * *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 52)
           / 0x74B2u
           / *(unsigned __int8 *)(v25 + 12935));
      **(_DWORD **)(v159 + 12 * (_DWORD)v18) += *(_DWORD *)(*(_DWORD *)(v159 + 12 * (_DWORD)v18) + 24);
      v42 = (unsigned int)dword_9E31C > 3;
      *(_DWORD *)(*(_DWORD *)(v160 + 4) + 4) -= 5 * (HIDWORD(v41) >> 2);
      if ( v42 )
      {
        snprintf((char *)v178, 0x800u, "voltage_base = %d\n", **(_DWORD **)(v159 + 12 * (_DWORD)v18));
        sub_47AB4(3, (const char *)v178, 0);
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf((char *)v178, 0x800u, "freq_threshold = %d\n", *(_DWORD *)(*(_DWORD *)(v160 + 4) + 4));
          sub_47AB4(3, (const char *)v178, 0);
        }
      }
      memset(s, 0, sizeof(s));
      if ( sub_33C2C(v160, (int)s) )
        goto LABEL_92;
      v25 = dword_A0D68;
    }
    else if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf((char *)v178, 0x800u, "freq_avg = %d, freq_basic_retry = %d, is_need_retry = %d\n", v26, v30, 0);
      sub_47AB4(3, (const char *)v178, 0);
      v25 = dword_A0D68;
    }
    v31 = 0;
    for ( i = v25; ; i = dword_A0D68 )
    {
      if ( *(_DWORD *)(i + 4 * v31 + 4) == 1 )
      {
        sub_39BEC(v31);
        if ( v1 > *(float *)(dword_1AEA6C + 4 * v31 + 5072) )
          *(float *)(dword_1AEA6C + 4 * v31 + 5072) = v1;
      }
      if ( ++v31 == 16 )
        break;
    }
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy((char *)v178, "Build tuning PM grade config.\n");
      sub_47AB4(3, (const char *)v178, 0);
    }
    v38 = 4;
    v39 = dword_A0D68;
    *(_DWORD *)v177 = **(_DWORD **)(v159 + 12 * (_DWORD)v18);
    do
    {
      v40 = *(_DWORD *)(v39 + 4);
      v39 += 4;
      if ( v40 == 1 )
        *(_DWORD *)&v177[v38] = *(_DWORD *)&s[v38 - 4];
      v38 += 4;
    }
    while ( v38 != 68 );
    *(_DWORD *)&v177[68] = *(_DWORD *)(*(_DWORD *)(v160 + 4) + 4);
    *(_DWORD *)&v177[72] = *(_DWORD *)(*(_DWORD *)(v160 + 4) + 8);
    *(_DWORD *)&v177[76] = *(_DWORD *)(*(_DWORD *)(v160 + 4) + 12);
    *(_DWORD *)&v177[80] = *(_DWORD *)(*(_DWORD *)(v160 + 4) + 24);
    *(_DWORD *)&v177[84] = *(_DWORD *)(*(_DWORD *)(v160 + 4) + 28);
    v177[88] = *(_BYTE *)(*(_DWORD *)(dword_1AEA6C + 8) + 8);
    v177[89] = *(_BYTE *)(*(_DWORD *)(dword_1AEA6C + 8) + 9);
    *(_DWORD *)&v177[92] = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 12);
    *(_DWORD *)&v177[96] = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 16);
    *(_DWORD *)&v177[100] = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 20);
    *(_DWORD *)&v177[104] = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 28);
    *(_DWORD *)&v177[108] = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 48);
    *(_DWORD *)&v177[112] = (unsigned int)(*(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 48) + 5)
                          / *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 48);
    memcpy(&v177[116], (const void *)(dword_1AEA6C + 5272), 0x270u);
    memcpy(&v177[740], (const void *)(dword_1AEA6C + 5896), 0x4E0u);
    if ( sub_3BBE8((int)v177) )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy((char *)v178, "PM grade init failed.\n");
        sub_47AB4(3, (const char *)v178, 0);
      }
      goto LABEL_92;
    }
    v43 = sub_3BD34();
    if ( v43 )
      break;
    v44 = &v177[4];
    do
    {
      v45 = 4 * v43;
      if ( *(_DWORD *)(dword_A0D68 + 4 * v43 + 4) == 1 )
      {
        if ( sub_3B5A8(v43) )
        {
          sub_3B5C4(v43, dword_1AEA6C + 312 * v43 + 12);
        }
        else
        {
          v46 = dword_1AEA6C + 320 + 312 * v43;
          v47 = dword_1AEA6C + 312 * v43 + 8;
          do
          {
            *(_DWORD *)(v47 + 4) = *v44;
            v47 += 4;
          }
          while ( v47 != v46 );
          if ( (unsigned int)dword_9E31C > 3 )
          {
            snprintf((char *)v178, 0x800u, "Chain %d freq result is invalid, using freq_base as default.\n", v43);
            sub_47AB4(3, (const char *)v178, 0);
          }
        }
        sub_3B658(v43);
        if ( v1 > *(float *)(dword_1AEA6C + v45 + 5072) )
          *(float *)(dword_1AEA6C + v45 + 5072) = v1;
      }
      ++v43;
      ++v44;
    }
    while ( v43 != 16 );
    v48 = dword_1AEA6C;
    v49 = *(float *)(dword_1AEA6C + 4);
    if ( v49 < 35.0 )
    {
      if ( v49 < 25.0 || v49 >= 35.0 )
      {
        if ( v49 >= 15.0 )
        {
          if ( v49 >= 25.0 )
            v50 = 10;
          else
            v50 = 20;
        }
        else
        {
          v50 = 10;
        }
      }
      else
      {
        v50 = 30;
      }
    }
    else
    {
      v50 = 40;
    }
    v51 = dword_9E31C;
    if ( (unsigned int)dword_9E31C > 4 )
    {
      snprintf((char *)v178, 0x800u, "env_temp = %.2f, freq_sub = %d.\n", v49, v50);
      sub_47AB4(4, (const char *)v178, 0);
      v48 = dword_1AEA6C;
      v51 = dword_9E31C;
    }
    v52 = dword_A0D68;
    v53 = v48 + 5000;
    v54 = (_DWORD *)(v48 + 8);
    do
    {
      v55 = *(_DWORD *)(v52 + 4);
      v52 += 4;
      v56 = v54 + 78;
      if ( v55 == 1 )
      {
        do
        {
          v57 = v54[1];
          *++v54 = v57 - v50;
        }
        while ( v54 != v56 );
      }
      v54 = v56;
    }
    while ( v56 != (_DWORD *)v53 );
    if ( v51 > 3 )
    {
      snprintf((char *)v178, 0x800u, "Sub runtime freq directly, freq_sub = %d.\n", v50);
      sub_47AB4(3, (const char *)v178, 0);
    }
    sub_3143C(v174);
    v58 = dword_A0D68;
    v59 = 0;
    v60 = dword_1AEA6C + 8;
    v164 = 149370 * (unsigned int)*(unsigned __int8 *)(dword_A0D68 + 12935) / 0x3E8;
    do
    {
      v61 = *(_DWORD *)(v58 + 4);
      v58 += 4;
      v62 = v60 + 312;
      if ( v61 == 1 )
      {
        do
        {
          v63 = *(_DWORD *)(v60 + 4);
          v60 += 4;
          v59 += 383 * v63;
        }
        while ( v60 != v62 );
      }
      v60 = v62;
    }
    while ( v58 != dword_A0D68 + 64 );
    v64 = v59 / 0x3E8;
    v65 = v64;
    v66 = (unsigned int)((double)v64 * 0.97);
    if ( v66 < v174[1] )
      v161 = 1000 * (v66 / 0x3E8);
    else
      v161 = v175((unsigned int)((double)v64 * 0.97));
    v67 = dword_9E31C;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf((char *)v178, 0x800u, "hash_rate_unit_GH    = %d\n", v164);
      sub_47AB4(3, (const char *)v178, 0);
      v67 = dword_9E31C;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf((char *)v178, 0x800u, "hash_rate_curr_GH     = %d\n", v65);
        sub_47AB4(3, (const char *)v178, 0);
        v67 = dword_9E31C;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf((char *)v178, 0x800u, "hash_rate_for_sale_GH = %d\n", v66);
          sub_47AB4(3, (const char *)v178, 0);
          v67 = dword_9E31C;
          if ( (unsigned int)dword_9E31C > 3 )
          {
            snprintf((char *)v178, 0x800u, "hash_rate_sale_GH     = %d\n", v161);
            sub_47AB4(3, (const char *)v178, 0);
            v67 = dword_9E31C;
          }
        }
      }
    }
    v68 = dword_A0D68;
    v69 = v66 - v161;
    v162 = (char *)dword_1AEA6C;
    if ( v69 <= 0 )
    {
      v71 = 0;
      v70 = dword_1AEA6C + 8;
    }
    else
    {
      v70 = dword_1AEA6C + 8;
      v71 = 5 * (v69 / v164);
      v72 = (_DWORD *)(dword_1AEA6C + 8);
      v73 = dword_1AEA6C + 5000;
      v74 = dword_A0D68;
      do
      {
        v75 = *(_DWORD *)(v74 + 4);
        v74 += 4;
        v76 = v72 + 78;
        if ( v75 == 1 )
        {
          do
          {
            v77 = v72[1];
            *++v72 = v77 - v71;
          }
          while ( v76 != v72 );
        }
        v72 = v76;
      }
      while ( v76 != (_DWORD *)v73 );
    }
    v78 = v70;
    v79 = v68;
    v80 = 0;
    v81 = v68 + 64;
    v82 = v78;
    v165 = v162 + 12;
    do
    {
      v83 = *(_DWORD *)(v79 + 4);
      v79 += 4;
      v84 = v82 + 312;
      if ( v83 == 1 )
      {
        do
        {
          v85 = *(_DWORD *)(v82 + 4);
          v82 += 4;
          v80 += 383 * v85;
        }
        while ( v82 != v84 );
      }
      v82 = v84;
    }
    while ( v81 != v79 );
    if ( v67 > 3 )
    {
      snprintf(
        (char *)v178,
        0x800u,
        "Sub runtime freq by hash rate, freq_sub = %d, hash_rate_now = %d.\n",
        v71,
        v80 / 0x3E8);
      sub_47AB4(3, (const char *)v178, 0);
      v162 = (char *)dword_1AEA6C;
      v165 = (char *)(dword_1AEA6C + 12);
    }
    sub_3143C(v174);
    v86 = dword_A0D68;
    v87 = 0;
    v88 = v165 - 4;
    do
    {
      v89 = *(_DWORD *)(v86 + 4);
      v86 += 4;
      v90 = v88 + 312;
      if ( v89 == 1 )
      {
        do
        {
          v91 = *((_DWORD *)v88 + 1);
          v88 += 4;
          v87 += 383 * v91;
        }
        while ( v90 != v88 );
      }
      v88 = v90;
    }
    while ( v86 != dword_A0D68 + 64 );
    v92 = 274877907LL * v87;
    v93 = HIDWORD(v92) >> 6;
    if ( (unsigned int)dword_9E31C <= 3
      || (snprintf(
            (char *)v178,
            0x800u,
            "hash_rate_curr = %d, hash_rate_for_vol_inc = %d\n",
            HIDWORD(v92) >> 6,
            *(_DWORD *)(*(_DWORD *)(v160 + 8) + 4)),
          sub_47AB4(3, (const char *)v178, 0),
          (unsigned int)dword_9E31C <= 3) )
    {
      if ( *(_DWORD *)(*(_DWORD *)(v159 + 12 * (_DWORD)v18) + 8) <= **(_DWORD **)(v159 + 12 * (_DWORD)v18) )
        goto LABEL_272;
    }
    else
    {
      snprintf(
        (char *)v178,
        0x800u,
        "voltage_base = %d, voltage_threshold = %d\n",
        **(_DWORD **)(v159 + 12 * (_DWORD)v18),
        *(_DWORD *)(*(_DWORD *)(v159 + 12 * (_DWORD)v18) + 8));
      sub_47AB4(3, (const char *)v178, 0);
      if ( **(_DWORD **)(v159 + 12 * (_DWORD)v18) >= *(_DWORD *)(*(_DWORD *)(v159 + 12 * (_DWORD)v18) + 8) )
      {
        if ( (unsigned int)dword_9E31C > 3 )
        {
          strcpy((char *)v178, "Pass: voltage is reach threshold.\n");
          sub_47AB4(3, (const char *)v178, 0);
          v94 = 1;
          goto LABEL_220;
        }
        goto LABEL_272;
      }
    }
    if ( (unsigned int)v175(v93) >= *(_DWORD *)(*(_DWORD *)(v160 + 8) + 4) && !sub_33A7C() )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy((char *)v178, "Pass: hash rate is enough.\n");
        sub_47AB4(3, (const char *)v178, 0);
      }
LABEL_272:
      v94 = 1;
      goto LABEL_220;
    }
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy((char *)v178, "Not pass: hash rate is not enough.\n");
      sub_47AB4(3, (const char *)v178, 0);
    }
    v94 = 0;
LABEL_220:
    v95 = dword_1AEA6C + 4096;
    *((_DWORD *)v162 + 1267) = v94;
    if ( *(_DWORD *)(v95 + 972) )
    {
      v98 = sub_33A7C();
      if ( v98 )
      {
        v99 = dword_1AEA6C;
        v100 = 12;
        for ( j = 0; j != 16; ++j )
        {
          if ( *(_DWORD *)(dword_A0D68 + 4 * j + 4) == 1 )
          {
            if ( *(_DWORD *)(v99 + 4 * (j + 1300)) )
              v102 = 250;
            else
              v102 = 300;
            if ( (unsigned int)dword_9E31C > 3 )
            {
              snprintf((char *)v178, 0x800u, "Mark unqualified, chain = %d, freq = %d\n", j, v102);
              sub_47AB4(3, (const char *)v178, 0);
            }
            v99 = dword_1AEA6C;
            v103 = dword_1AEA6C + v100 - 4;
            v104 = dword_1AEA6C + v100 + 308;
            do
            {
              *(_DWORD *)(v103 + 4) = v102;
              v103 += 4;
            }
            while ( v104 != v103 );
            *(_DWORD *)(v99 + 4 * (j + 1250) + 4) = 29874 * v102 / 0x3E8u;
          }
          v100 += 312;
        }
        *(_DWORD *)(v99 + 4 * (_DWORD)(v18 + 1316) + 4) = 1;
      }
      else
      {
        if ( sub_3405C((int **)v160, *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 12), 0) )
        {
          if ( (unsigned int)dword_9E31C <= 3 )
            goto LABEL_92;
          v116 = "Get ideal hash rate failed, round 0, exit.\n";
          goto LABEL_276;
        }
        if ( sub_378DC() )
        {
          if ( sub_3405C((int **)v160, 1, 1) )
          {
            if ( (unsigned int)dword_9E31C <= 3 )
              goto LABEL_92;
            v116 = "Get ideal hash rate failed, round 1, exit.\n";
            goto LABEL_276;
          }
          v163 = 1;
        }
        else
        {
          v163 = 0;
        }
        if ( sub_378DC() )
        {
          sub_3143C(v174);
          v137 = 0;
          v138 = 0;
          v139 = (int *)(dword_A0D68 + 4);
          do
          {
            v140 = *v139++;
            if ( v140 == 1 )
            {
              v141 = dword_1AEA6C + 8 + v138;
              do
              {
                v142 = *(_DWORD *)(v141 + 4);
                v141 += 4;
                v137 += 383 * v142;
              }
              while ( dword_1AEA6C + 320 + v138 != v141 );
            }
            v138 += 312;
          }
          while ( v138 != 4992 );
          v166 = v137 / 0x3E8;
          v143 = v175(v137 / 0x3E8);
          if ( (unsigned int)dword_9E31C > 3 )
          {
            snprintf((char *)v178, 0x800u, "hash_rate_curr_GH = %d\n", v166);
            sub_47AB4(3, (const char *)v178, 0);
            if ( (unsigned int)dword_9E31C > 3 )
            {
              snprintf((char *)v178, 0x800u, "hash_rate_sale_GH = %d\n", v143);
              sub_47AB4(3, (const char *)v178, 0);
            }
          }
          v144 = *(unsigned int **)(v160 + 8);
          if ( v143 > *v144 )
          {
            v145 = dword_A0D68;
            v146 = dword_1AEA6C;
            v147 = 5 * (v144[2] / (((unsigned int)&loc_24778 + 2) * *(unsigned __int8 *)(dword_A0D68 + 12935) / 0x3E8));
            v148 = 1;
            v167 = (char *)(dword_1AEA6C - 304);
            v170 = dword_1AEA6C + 8;
            do
            {
              if ( *(_DWORD *)(v145 + 4 * v148) == 1 )
              {
                v149 = &v167[312 * v148];
                do
                {
                  v150 = *((_DWORD *)v149 + 1);
                  v149 += 4;
                  *(_DWORD *)v149 = v150 - v147;
                }
                while ( v149 != (char *)(v170 + 312 * v148) );
              }
              ++v148;
            }
            while ( v148 != 17 );
            v155 = 0;
            v169 = (char *)(v146 - 304);
            v156 = 1;
            v171 = v146 + 8;
            do
            {
              if ( *(_DWORD *)(v145 + 4 * v156) == 1 )
              {
                v157 = &v169[312 * v156];
                do
                {
                  v158 = *((_DWORD *)v157 + 1);
                  v157 += 4;
                  v155 += 383 * v158;
                }
                while ( (char *)(v171 + 312 * v156) != v157 );
              }
              ++v156;
            }
            while ( v156 != 17 );
            if ( (unsigned int)dword_9E31C > 3 )
            {
              snprintf(
                (char *)v178,
                0x800u,
                "Sub runtime freq to low rank, freq_sub = %d, hash_rate_now = %d.\n",
                v147,
                v155 / 0x3E8);
              sub_47AB4(3, (const char *)v178, 0);
            }
          }
          else
          {
            **(_DWORD **)(v159 + 12 * (_DWORD)v18) += *(_DWORD *)(*(_DWORD *)(v159 + 12 * (_DWORD)v18) + 20);
            if ( (unsigned int)dword_9E31C > 3 )
            {
              snprintf((char *)v178, 0x800u, "Inc voltage, voltage_base = %d\n", **(_DWORD **)(v159 + 12 * (_DWORD)v18));
              sub_47AB4(3, (const char *)v178, 0);
            }
          }
          if ( sub_3405C((int **)v160, 1, v163 + 1) )
          {
            if ( (unsigned int)dword_9E31C <= 3 )
              goto LABEL_92;
            v116 = "Get ideal hash rate failed, round 2, exit.\n";
LABEL_276:
            v117 = *(_DWORD *)v116;
            v118 = *((_DWORD *)v116 + 1);
            v119 = *((_DWORD *)v116 + 2);
            v120 = *((_DWORD *)v116 + 3);
            v121 = (int *)(v116 + 16);
            v178[0] = v117;
            v178[1] = v118;
            v178[2] = v119;
            v178[3] = v120;
            v122 = *v121;
            v123 = v121[1];
            v124 = v121[2];
            v125 = v121[3];
            v121 += 4;
            v178[4] = v122;
            v178[5] = v123;
            v178[6] = v124;
            v178[7] = v125;
            v126 = v121[1];
            v127 = v121[2];
            v178[8] = *v121;
            v178[9] = v126;
            v178[10] = v127;
            sub_47AB4(3, (const char *)v178, 0);
            goto LABEL_92;
          }
          if ( sub_378DC() )
          {
            *(_DWORD *)(dword_1AEA6C + 4 * (_DWORD)(v18 + 1316)) = 1;
            v168 = v17;
            do
            {
              if ( *(_DWORD *)(dword_A0D68 + 4 * v98 + 4) == 1 )
              {
                if ( sub_37834(v98) )
                  v151 = 250;
                else
                  v151 = 300;
                if ( (unsigned int)dword_9E31C > 3 )
                {
                  snprintf((char *)v178, 0x800u, "Mark unbalance, chain = %d, freq = %d\n", v98, v151);
                  sub_47AB4(3, (const char *)v178, 0);
                }
                v152 = dword_1AEA6C;
                v153 = dword_1AEA6C + 320 + 312 * v98;
                v154 = dword_1AEA6C + 312 * v98 + 8;
                do
                {
                  *(_DWORD *)(v154 + 4) = v151;
                  v154 += 4;
                }
                while ( v153 != v154 );
                *(_DWORD *)(v152 + 4 * (v98 + 1250) + 4) = 29874 * v151 / 0x3E8u;
              }
              ++v98;
            }
            while ( v98 != 16 );
            v17 = v168;
          }
        }
      }
      v128 = dword_1AEA6C;
      v129 = dword_A0D68;
      v130 = 0;
      v131 = dword_1AEA6C + 8;
      v132 = dword_1AEA6C + 1376 * (_DWORD)v18 + 7143;
      do
      {
        v133 = *(_DWORD *)(v129 + 4);
        v129 += 4;
        v134 = v131 + 312;
        if ( v133 == 1 )
        {
          v135 = v132;
          do
          {
            v136 = *(_DWORD *)(v131 + 4);
            v131 += 4;
            *(_BYTE *)++v135 = v136 / 5;
          }
          while ( v134 != v131 );
          *(_WORD *)(v132 + 79) = **(_DWORD **)v160;
          *(_DWORD *)(v128 + 1376 * (_DWORD)v18 + 86 * v130 + 7224) = *(_DWORD *)(v128 + 4 * v130 + 5004);
        }
        ++v130;
        v131 = v134;
        v132 += 86;
      }
      while ( v130 != 16 );
    }
    sub_39AB4();
    sub_3B4EC();
    v96 = dword_1AEA6C;
    if ( *(_DWORD *)(dword_1AEA6C + 5068) )
    {
      v15 = *(_DWORD **)(dword_1AEA6C + 8);
      v97 = v15[1];
      if ( (char *)(v97 - 1) == v18 )
      {
        v16 = dword_9E31C;
      }
      else
      {
        sub_385EC(v15[3]);
        v16 = dword_9E31C;
        v15 = *(_DWORD **)(dword_1AEA6C + 8);
        v97 = v15[1];
      }
    }
    else
    {
      **(_DWORD **)(v159 + 12 * (_DWORD)v18) += *(_DWORD *)(*(_DWORD *)(v159 + 12 * (_DWORD)v18) + 4);
      v16 = dword_9E31C;
      v42 = (unsigned int)dword_9E31C > 3;
      *(_DWORD *)(*(_DWORD *)(v160 + 4) + 4) -= *(_DWORD *)(*(_DWORD *)(v160 + 4) + 16);
      if ( v42 )
      {
        snprintf(
          (char *)v178,
          0x800u,
          "Not pass, try again, voltage = %d, freq_threshold = %d\n",
          **(_DWORD **)(v159 + 12 * (_DWORD)v18),
          *(_DWORD *)(*(_DWORD *)(v160 + 4) + 4));
        sub_47AB4(3, (const char *)v178, 0);
        v96 = dword_1AEA6C;
        v16 = dword_9E31C;
      }
      v15 = *(_DWORD **)(v96 + 8);
      --v17;
      v97 = v15[1];
    }
    v18 = ++v17;
    if ( (unsigned int)v17 >= v97 )
      goto LABEL_154;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy((char *)v178, "Do freq tuning PM grade failed.\n");
    sub_47AB4(3, (const char *)v178, 0);
  }
LABEL_92:
  sub_39AB4();
  sub_3B4EC();
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy((char *)v178, "Do single work mode pattern test failed, exit.\n");
    sub_47AB4(3, (const char *)v178, 0);
    v16 = dword_9E31C;
    goto LABEL_154;
  }
LABEL_93:
  v21 = dword_1AEA6C;
  v22 = 0;
  v23 = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 4);
  do
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * v22 + 4) == 1 )
    {
      sub_19190(v22, v23);
      v21 = dword_1AEA6C;
      v23 = *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 4);
    }
    ++v22;
  }
  while ( v22 != 16 );
  if ( v23 )
  {
    v33 = 0;
    v34 = 0;
    while ( 2 )
    {
      for ( k = 0; k != 16; ++k )
      {
        if ( *(_DWORD *)(dword_A0D68 + 4 * k + 4) == 1 )
        {
          v36 = sub_19098(k, (unsigned __int8)v34, (void *)(v21 + v33 + 7144 + 86 * k));
          if ( v36 )
          {
            v3 = v36;
            if ( (unsigned int)dword_9E31C > 3 )
            {
              snprintf((char *)v178, 0x800u, "Flush result to eeprom failed, work_mode = %d, chain = %d.\n", v34, k);
              sub_47AB4(3, (const char *)v178, 0);
            }
            goto LABEL_123;
          }
          v21 = dword_1AEA6C;
        }
      }
      ++v34;
      v33 += 1376;
      if ( v34 < *(_DWORD *)(*(_DWORD *)(v21 + 8) + 4) )
        continue;
      break;
    }
  }
  v3 = sub_18650();
LABEL_123:
  if ( *(_DWORD *)(*(_DWORD *)(dword_1AEA6C + 8) + 4) )
  {
    if ( *(_DWORD *)(dword_1AEA6C + 5268) )
    {
      sub_31794(14, 255);
    }
    else
    {
      v37 = *(_DWORD *)(dword_1AEA6C + 5264);
      if ( v37 )
      {
        sub_31794(21, 255);
      }
      else
      {
        v105 = 0;
        while ( 1 )
        {
          sub_3143C(v178);
          v106 = dword_1AEA6C;
          v107 = dword_A0D68;
          v108 = 0;
          for ( m = 0; m != 16; ++m )
          {
            v111 = *(_DWORD *)(v107 + 4);
            v107 += 4;
            v110 = v111;
            v112 = v111 == 1;
            if ( v111 == 1 )
              v110 = 1376 * v37 + 86 * m;
            if ( v112 )
              v108 += *(_DWORD *)(dword_1AEA6C + v110 + 7224);
          }
          if ( v178[1] > v108 )
          {
            v113 = 1000 * (v108 / 0x3E8);
          }
          else
          {
            v113 = ((int (*)(void))v178[2])();
            v106 = dword_1AEA6C;
          }
          v114 = *(_DWORD *)(v106 + 8);
          v115 = **(_DWORD **)(*(_DWORD *)(v114 + 56) + v105 + 8);
          if ( v115 > v113 )
            break;
          ++v37;
          v105 += 12;
          if ( v37 >= *(_DWORD *)(v114 + 4) )
            goto LABEL_127;
        }
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(
            (char *)v178,
            0x800u,
            "Under target hash rate: work_mode = %d, hash_rate_sale = %d, hash_rate_target = %d.\n",
            v37,
            v113,
            v115);
          sub_47AB4(3, (const char *)v178, 0);
        }
        sub_31794(6, 255);
      }
    }
  }
LABEL_127:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy((char *)v178, "Mark sweep done.\n");
    sub_47AB4(3, (const char *)v178, 0);
  }
  system("touch /config/scanfreqdone");
  if ( v3 || dword_1AEA74 != 2 )
    goto LABEL_45;
  dword_1AEA74 = 0;
LABEL_46:
  pthread_cancel(newthread);
  sub_374D4();
  sub_373BC();
  sub_33B7C();
  sub_4A60C((struct timeval *)v177);
  v9 = *(_DWORD *)v177 - v173.tv_sec;
  if ( *(_DWORD *)&v177[4] - v173.tv_usec < 0 )
    --v9;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy((char *)v178, "\n");
    sub_47AB4(3, (const char *)v178, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf((char *)v178, 0x800u, "*** Sweep done, time cost %ld minutes. ***\n", v9 / 60);
      sub_47AB4(3, (const char *)v178, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy((char *)v178, "\n");
        sub_47AB4(3, (const char *)v178, 0);
      }
    }
  }
  return v3;
}
// 354C8: variable 'v1' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// A0D79: using guessed type char byte_A0D79;
// 1AEA6C: using guessed type int dword_1AEA6C;
// 1AEA74: using guessed type int dword_1AEA74;

//----- (00036B40) --------------------------------------------------------
int __fastcall sub_36B40(int *a1)
{
  int v2; // r4
  int v3; // r2
  int v5; // r3
  char v6[2052]; // [sp+0h] [bp-804h] BYREF

  v2 = sub_33E28(161);
  if ( !v2 )
  {
    v3 = *(_DWORD *)(dword_1AEA6C + 8);
    if ( *(_DWORD *)(v3 + 4) > (unsigned int)dword_9EE38 )
    {
      v5 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 56) + 12 * dword_9EE38 + 4) + 4);
      *a1 = v5;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(v6, 0x800u, "max_freq = %d\n", v5);
        sub_47AB4(3, v6, 0);
      }
    }
    else if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v6, 0x800u, "Invalid work mode, opt_bitmain_work_mode = %d\n", dword_9EE38);
      v2 = -1;
      sub_47AB4(3, v6, 0);
    }
    else
    {
      v2 = -1;
    }
  }
  sub_33B7C();
  return v2;
}
// 9E31C: using guessed type int dword_9E31C;
// 9EE38: using guessed type int dword_9EE38;
// 1AEA6C: using guessed type int dword_1AEA6C;

//----- (00036C34) --------------------------------------------------------
int sub_36C34()
{
  return dword_1AEA74;
}
// 1AEA74: using guessed type int dword_1AEA74;

//----- (00036C44) --------------------------------------------------------
int __fastcall sub_36C44(int result)
{
  dword_1AEA74 = result;
  return result;
}
// 1AEA74: using guessed type int dword_1AEA74;

//----- (00036C54) --------------------------------------------------------
int __fastcall sub_36C54(int result)
{
  dword_1AEA70 = result;
  return result;
}
// 1AEA70: using guessed type int dword_1AEA70;

//----- (00036C64) --------------------------------------------------------
_DWORD *__fastcall sub_36C64(_DWORD *a1)
{
  int v2; // r1
  int v3; // r2
  int v4; // r3
  int *v5; // lr
  int *v6; // r12
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // r0
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r1
  int v16; // r2

  v2 = *(_DWORD *)(dword_1AEA70 + 4);
  v3 = *(_DWORD *)(dword_1AEA70 + 8);
  v4 = *(_DWORD *)(dword_1AEA70 + 12);
  v5 = (int *)(dword_1AEA70 + 16);
  *a1 = *(_DWORD *)dword_1AEA70;
  a1[1] = v2;
  a1[2] = v3;
  a1[3] = v4;
  v6 = a1 + 4;
  v7 = *v5;
  v8 = v5[1];
  v9 = v5[2];
  v10 = v5[3];
  v5 += 4;
  *v6 = v7;
  v6[1] = v8;
  v6[2] = v9;
  v6[3] = v10;
  v6 += 4;
  v11 = *v5;
  v12 = v5[1];
  v13 = v5[2];
  v14 = v5[3];
  v5 += 4;
  *v6 = v11;
  v6[1] = v12;
  v6[2] = v13;
  v6[3] = v14;
  v6 += 4;
  v15 = v5[1];
  v16 = v5[2];
  *v6 = *v5;
  v6[1] = v15;
  v6[2] = v16;
  return a1;
}
// 1AEA70: using guessed type int dword_1AEA70;

//----- (00036CA4) --------------------------------------------------------
int __fastcall sub_36CA4(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00036CB4) --------------------------------------------------------
void __fastcall sub_36CB4(int a1, int a2)
{
  int i; // r6
  bool v3; // zf
  int v4; // r4
  unsigned int v5; // r3
  unsigned int v6; // r4
  int v7; // r12
  int v8; // r3
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  for ( i = 0; i != 16; ++i )
  {
    while ( 2 )
    {
      v3 = a1 == i;
      if ( a1 == i )
        v3 = *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1;
      v4 = !v3;
      if ( !v3 )
        goto LABEL_2;
      v5 = dword_9E31C;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "Dump asic grade table, chain = %d\n", i);
        sub_47EC8(3, s, v4);
        v5 = dword_9E31C;
      }
      v6 = 0;
      do
      {
        while ( v5 <= 3 )
        {
          ++v6;
LABEL_13:
          if ( v6 == 78 )
            goto LABEL_19;
        }
        v7 = *(unsigned __int8 *)(a2 + 78 * i + v6);
        v8 = v6++;
        snprintf(s, 0x800u, "[%3d]:%-3d ", v8, v7);
        sub_47EC8(3, s, 0);
        v5 = dword_9E31C;
        if ( v6 != 6 * (v6 / 6) || (unsigned int)dword_9E31C <= 3 )
          goto LABEL_13;
        strcpy(s, "\n");
        sub_47EC8(3, s, v6 % 6);
        v5 = dword_9E31C;
      }
      while ( v6 != 78 );
LABEL_19:
      if ( v5 <= 3 )
      {
LABEL_2:
        if ( ++i == 16 )
          return;
        continue;
      }
      break;
    }
    strcpy(s, "\n");
    sub_47EC8(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00036E34) --------------------------------------------------------
void sub_36E34()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "Handle is NULL.\n");
  sub_47AB4(3, v0, 0);
}

//----- (00036E78) --------------------------------------------------------
int __fastcall sub_36E78(_DWORD *a1)
{
  int v2; // r3
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v4, 0x800u, "[DEBUG] Send work one chain, chain = %d.\n", *a1);
    sub_47AB4(4, v4, 0);
  }
  if ( dword_1AEA78 )
  {
    v2 = *(_DWORD *)(dword_1AEA78 + 4);
    if ( v2 )
    {
      (*(void (__fastcall **)(_DWORD, _DWORD))(v2 + 28))(*a1, a1[2]);
      a1[1] = 1;
      return 0;
    }
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return 0;
  sub_36E34();
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00036F30) --------------------------------------------------------
int sub_36F30()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v1, "Handle is NULL.\n");
  sub_47AB4(3, v1, 0);
  return 1;
}

//----- (00036F78) --------------------------------------------------------
void __fastcall sub_36F78(int a1)
{
  int v2; // r3
  char v3[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v3, "[DEBUG] Send work for hw sweep.\n");
    sub_47AB4(4, v3, 0);
  }
  if ( dword_1AEA78 && (v2 = *(_DWORD *)(dword_1AEA78 + 4)) != 0 )
  {
    (*(void (__fastcall **)(int, int))(v2 + 28))(255, a1);
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    sub_36E34();
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (0003702C) --------------------------------------------------------
void __fastcall sub_3702C(int a1)
{
  int v2; // r4
  _DWORD *v3; // r5
  int v4; // r2
  void *v5; // r3
  pthread_t v6; // r0
  int i; // r3
  pthread_t v8[16]; // [sp+0h] [bp-840h] BYREF
  _DWORD s[520]; // [sp+40h] [bp-800h] BYREF

  if ( dword_1AEA78 && *(_DWORD *)(dword_1AEA78 + 4) )
  {
    memset(v8, 0, sizeof(v8));
    v2 = 0;
    v3 = s;
    memset(s, 0, 0xC0u);
    v4 = dword_A0D68;
    do
    {
      while ( *(_DWORD *)(v4 + 4 * v2 + 4) != 1 || *(_DWORD *)(dword_1AEA78 + 4 * (v2 + 2)) != 1 )
      {
        ++v2;
        v3 += 3;
        if ( v2 == 16 )
          goto LABEL_8;
      }
      v5 = v3;
      *v3 = v2;
      v3[1] = 0;
      v3 += 3;
      *(v3 - 1) = a1;
      pthread_create(&v8[v2], 0, (void *(*)(void *))sub_36E78, v5);
      v6 = v8[v2++];
      pthread_detach(v6);
      v4 = dword_A0D68;
    }
    while ( v2 != 16 );
LABEL_8:
    for ( i = 0; i != 16; ++i )
    {
LABEL_9:
      while ( *(_DWORD *)(v4 + 4 * i + 4) == 1 && v8[i] && !s[3 * i + 1] )
      {
        while ( 1 )
        {
          usleep((__useconds_t)&loc_186A0);
          v4 = dword_A0D68;
          i = *(_DWORD *)(dword_A0D68 + 4);
          if ( i != 1 )
            break;
          if ( !v8[0] || s[1] )
            goto LABEL_9;
        }
        i = 1;
      }
    }
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy((char *)s, "Handle is NULL.\n");
    sub_47AB4(3, (const char *)s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (000371E8) --------------------------------------------------------
int __fastcall sub_371E8(int a1, const char *a2)
{
  unsigned int v4; // r6
  int *v6; // r8
  int *v7; // r0
  int *v8; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v4 = a1 - 160;
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "[DEBUG] sweep_type = 0x%X, pattern_file_path = %s\n", a1, a2);
    sub_47AB4(4, s, 0);
    if ( v4 > 1 )
      goto LABEL_3;
    if ( (unsigned int)dword_9E31C > 4 )
    {
      strcpy(s, "[DEBUG] allocate memory for pattern test.\n");
      sub_47AB4(4, s, 0);
    }
  }
  else if ( v4 > 1 )
  {
LABEL_3:
    sub_31794(20, 255);
    if ( (unsigned int)dword_9E31C <= 3 )
      return -1;
    snprintf(s, 0x800u, "Invalid sweep type 0x%X\n", a1);
LABEL_13:
    sub_47AB4(3, s, 0);
    return -1;
  }
  v6 = (int *)dword_1AEA78;
  if ( !dword_1AEA78 )
  {
    v7 = (int *)calloc(0xECu, 1u);
    v6 = v7;
    dword_1AEA78 = (int)v7;
    if ( !v7 )
    {
      sub_31794(13, 255);
      if ( (unsigned int)dword_9E31C <= 3 )
        return -1;
      strcpy(s, "Fail to allocate memory for send work context.\n");
      goto LABEL_13;
    }
    v8 = v7 + 1;
    do
    {
      v8[1] = 0;
      ++v8;
    }
    while ( v8 != v7 + 17 );
  }
  *v6 = a1;
  if ( a1 == 160 )
    v6[1] = (int)sub_33918();
  else
    v6[1] = (int)sub_32B3C();
  return (*(int (__fastcall **)(const char *))(*(_DWORD *)(dword_1AEA78 + 4) + 4))(a2);
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (000373BC) --------------------------------------------------------
void sub_373BC()
{
  _DWORD *v0; // r0
  int v1; // r3
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v2, "[DEBUG] Pattern test exit.\n");
    sub_47AB4(4, v2, 0);
    v0 = (_DWORD *)dword_1AEA78;
    if ( !dword_1AEA78 )
    {
      if ( (unsigned int)dword_9E31C <= 4 )
        return;
      goto LABEL_9;
    }
  }
  else
  {
    v0 = (_DWORD *)dword_1AEA78;
    if ( !dword_1AEA78 )
      return;
  }
  v1 = v0[1];
  if ( v1 )
  {
    (*(void (**)(void))(v1 + 8))();
    if ( (unsigned int)dword_9E31C <= 4 )
      goto LABEL_5;
    goto LABEL_9;
  }
  if ( (unsigned int)dword_9E31C > 4 )
  {
LABEL_9:
    strcpy(v2, "[DEBUG] Free memory for pattern test.\n");
    sub_47AB4(4, v2, 0);
LABEL_5:
    v0 = (_DWORD *)dword_1AEA78;
    if ( !dword_1AEA78 )
      return;
  }
  free(v0);
  dword_1AEA78 = 0;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (000374D4) --------------------------------------------------------
void sub_374D4()
{
  int v0; // r3
  char v1[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v1, "[DEBUG] Pattern test reset.\n");
    sub_47AB4(4, v1, 0);
  }
  if ( dword_1AEA78 && (v0 = *(_DWORD *)(dword_1AEA78 + 4)) != 0 )
  {
    (*(void (**)(void))(v0 + 16))();
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v1, "Handle is NULL.\n");
    sub_47AB4(3, v1, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00037594) --------------------------------------------------------
void sub_37594()
{
  int v0; // r2
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_1AEA78 && (v0 = *(_DWORD *)(dword_1AEA78 + 4)) != 0 )
  {
    if ( *(_DWORD *)(dword_1AEA78 + 232) )
      (*(void (**)(void))(v0 + 20))();
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v1, "Handle is NULL.\n");
    sub_47AB4(3, v1, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (0003762C) --------------------------------------------------------
char *__fastcall sub_3762C(char *result)
{
  int v1; // r12
  bool v2; // cc
  int *v3; // r2
  char v4; // r1
  int v5; // r2

  v1 = dword_241D68[0] + 1;
  v2 = dword_241D68[0] > 0x1FDu;
  v3 = &dword_241D68[2 * dword_241D68[0] + 2];
  v3[1] = *((_DWORD *)result + 1);
  *((_BYTE *)v3 + 8) = result[3] & 0x1F;
  *((_BYTE *)v3 + 9) = result[2];
  *((_BYTE *)v3 + 10) = result[1];
  v4 = *result;
  if ( !v2 )
    dword_241D68[0] = v1;
  *((_BYTE *)v3 + 11) = v4 & 0xF;
  if ( v2 )
    dword_241D68[0] = 0;
  if ( (unsigned int)dword_241D70 > 0x1FE )
    v5 = 511;
  else
    v5 = dword_241D70 + 1;
  dword_241D70 = v5;
  return result;
}
// 241D68: using guessed type int dword_241D68[];
// 241D70: using guessed type int dword_241D70;

//----- (000376A4) --------------------------------------------------------
void __fastcall sub_376A4(char *a1)
{
  char v2[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_1AEA78 && *(_DWORD *)(dword_1AEA78 + 4) )
  {
    pthread_mutex_lock(&stru_138630);
    if ( *(_DWORD *)(dword_1AEA78 + 232) )
      (*(void (__fastcall **)(char *))(*(_DWORD *)(dword_1AEA78 + 4) + 24))(a1);
    else
      sub_3762C(a1);
    pthread_mutex_unlock(&stru_138630);
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    sub_47AB4(3, v2, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 138630: using guessed type pthread_mutex_t stru_138630;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00037770) --------------------------------------------------------
int sub_37770()
{
  int v0; // r3
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v2, "[DEBUG] Get stats.\n");
    sub_47AB4(4, v2, 0);
  }
  if ( dword_1AEA78 )
  {
    v0 = *(_DWORD *)(dword_1AEA78 + 4);
    if ( v0 )
      return (*(int (**)(void))(v0 + 32))();
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    sub_47AB4(3, v2, 0);
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00037834) --------------------------------------------------------
int __fastcall sub_37834(int a1)
{
  int v2; // r3
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v4, 0x800u, "[DEBUG] Check if chain is unbalance happen, chain = %d.\n", a1);
    sub_47AB4(4, v4, 0);
  }
  if ( dword_1AEA78 )
  {
    v2 = *(_DWORD *)(dword_1AEA78 + 4);
    if ( v2 )
      return (*(int (__fastcall **)(int))(v2 + 36))(a1);
  }
  if ( (unsigned int)dword_9E31C > 3 )
    return sub_36F30();
  return 1;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (000378DC) --------------------------------------------------------
int sub_378DC()
{
  int i; // r4
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v2, "[DEBUG] Check if is unbalance happen.\n");
    sub_47AB4(4, v2, 0);
  }
  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 && sub_37834(i) )
      return 1;
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00037994) --------------------------------------------------------
int __fastcall sub_37994(int a1)
{
  float v1; // s0
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(
      s,
      0x800u,
      "[DEBUG] Check if chain is unqualified happen, chain = %d, nonce_rate_threshold = %.2f\n",
      a1,
      v1);
    sub_47AB4(4, s, 0);
  }
  if ( dword_1AEA78 && *(_DWORD *)(dword_1AEA78 + 4) )
  {
    if ( *(float *)(dword_1AEA78 + 4 * a1 + 168) < v1 )
    {
      *(_BYTE *)(dword_1AEA78 + a1 + 88) = 1;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    return sub_36F30();
  }
  else
  {
    return 1;
  }
}
// 37A4C: variable 'v1' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00037A68) --------------------------------------------------------
int sub_37A68()
{
  int i; // r4
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v2, "[DEBUG] check if is unqualified happen.\n");
    sub_47AB4(4, v2, 0);
  }
  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 && sub_37994(i) )
      return 1;
  }
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00037B2C) --------------------------------------------------------
int __fastcall sub_37B2C(int a1)
{
  int v2; // r3
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v4, 0x800u, "[DEBUG] Check if recv nonce enough, chain = %d.\n", a1);
    sub_47AB4(4, v4, 0);
  }
  if ( dword_1AEA78 )
  {
    v2 = *(_DWORD *)(dword_1AEA78 + 4);
    if ( v2 )
      return (*(int (__fastcall **)(int))(v2 + 40))(a1);
  }
  if ( (unsigned int)dword_9E31C > 3 )
    return sub_36F30();
  return 1;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00037BD4) --------------------------------------------------------
void __fastcall sub_37BD4(int a1, int a2)
{
  const char *v4; // r3
  int v5; // r0
  int v6; // r3
  int i; // r2
  int v8; // t1
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        v4 = "READY";
      }
      else
      {
        v4 = "DONE";
        if ( a2 != 2 )
          v4 = "UNKNOWN";
      }
    }
    else
    {
      v4 = "BLOCK";
    }
    snprintf(s, 0x800u, "chain = %d, status = %s\n", a1, v4);
    sub_47AB4(3, s, 0);
    v5 = dword_1AEA78;
    if ( !dword_1AEA78 || !*(_DWORD *)(dword_1AEA78 + 4) )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy(s, "Handle is NULL.\n");
        sub_47AB4(3, s, 0);
      }
      return;
    }
LABEL_12:
    v6 = 0;
    for ( i = dword_A0D68; ; i += 4 )
    {
      v8 = *(_DWORD *)(i + 4);
      if ( v8 == 1 )
      {
        if ( a1 == 255 )
        {
          *(_DWORD *)(v5 + 4 * v6 + 8) = a2;
        }
        else if ( a1 == v6 )
        {
          *(_DWORD *)(v5 + 4 * (a1 + 2)) = a2;
          return;
        }
      }
      if ( ++v6 == 16 )
        return;
    }
  }
  v5 = dword_1AEA78;
  if ( dword_1AEA78 && *(_DWORD *)(dword_1AEA78 + 4) )
    goto LABEL_12;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00037D44) --------------------------------------------------------
int __fastcall sub_37D44(int a1)
{
  int v2; // r2
  int v3; // r2
  const char *v4; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v2 = dword_1AEA78;
  if ( (unsigned int)dword_9E31C > 4 )
  {
    v3 = *(_DWORD *)(dword_1AEA78 + 4 * (a1 + 2));
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v4 = "READY";
      }
      else
      {
        v4 = "UNKNOWN";
        if ( v3 == 2 )
          v4 = "DONE";
      }
    }
    else
    {
      v4 = "BLOCK";
    }
    snprintf(s, 0x800u, "[DEBUG] chain = %d, status = %s\n", a1, v4);
    sub_47AB4(4, s, 0);
    v2 = dword_1AEA78;
  }
  if ( v2 && *(_DWORD *)(v2 + 4) )
    return *(_DWORD *)(v2 + 4 * (a1 + 2));
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "Handle is NULL.\n");
    sub_47AB4(3, s, 0);
  }
  return 2;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00037E60) --------------------------------------------------------
void sub_37E60()
{
  int v0; // r3
  char v1[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v1, "[DEBUG] Clear stats.\n");
    sub_47AB4(4, v1, 0);
  }
  if ( dword_1AEA78 && (v0 = *(_DWORD *)(dword_1AEA78 + 4)) != 0 )
  {
    (*(void (**)(void))(v0 + 12))();
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    sub_36E34();
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00037EF8) --------------------------------------------------------
int sub_37EF8()
{
  int i; // r4

  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 && !sub_37D44(i) )
      return 1;
  }
  return 0;
}
// A0D68: using guessed type int dword_A0D68;

//----- (00037F50) --------------------------------------------------------
int sub_37F50()
{
  int i; // r4
  int result; // r0

  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        return 0;
    }
    result = sub_37D44(i);
    if ( result == 1 )
      return result;
  }
  return 0;
}
// A0D68: using guessed type int dword_A0D68;

//----- (00037FA8) --------------------------------------------------------
void __fastcall sub_37FA8(unsigned int a1)
{
  unsigned int v2; // r7
  int i; // r4
  int v4; // r0
  char v5[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v5, 0x800u, "[DEBUG] Set chain serial, chain_serial_count = %d.\n", a1);
    sub_47AB4(4, v5, 0);
  }
  v2 = 0;
  for ( i = 0; i != 16; ++i )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
      {
        if ( a1 <= v2 )
          return;
        if ( !sub_37D44(i) )
          break;
      }
      if ( ++i == 16 )
        return;
    }
    v4 = i;
    ++v2;
    sub_37BD4(v4, 1);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00038064) --------------------------------------------------------
void sub_38064()
{
  _DWORD *v0; // r4
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v1, "[DEBUG] Clear ctxt.\n");
    sub_47AB4(4, v1, 0);
  }
  v0 = (_DWORD *)dword_1AEA78;
  if ( dword_1AEA78 && *(_DWORD *)(dword_1AEA78 + 4) )
  {
    *(_DWORD *)(dword_1AEA78 + 72) = 0;
    v0[19] = 0;
    v0[20] = 0;
    v0[21] = 0;
    v0[22] = 0;
    v0[23] = 0;
    v0[24] = 0;
    v0[25] = 0;
    memset(v0 + 26, 0, 0x40u);
    memset(v0 + 42, 0, 0x40u);
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v1, "Handle is NULL.\n");
    sub_47AB4(3, v1, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (0003816C) --------------------------------------------------------
int __fastcall sub_3816C(int a1)
{
  float v1; // s0
  float v2; // s1
  float v3; // s2
  int v5; // r0
  unsigned int v6; // r2
  int v7; // r5
  int v8; // r5
  unsigned int v9; // r12
  int result; // r0
  int v11; // r3
  float v12; // s13
  float v13; // s17
  float v14; // s16
  char s[2048]; // [sp+18h] [bp-800h] BYREF

  v5 = sub_37770();
  v6 = dword_9E31C;
  v7 = v5;
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(
      s,
      0x800u,
      "[DEBUG] Check if is need stop, chain = %d, hw_threshold = %.4f, nonce_rate_threshold = %.2f, nonce_rate_dec_threshold = %.2f.\n",
      a1,
      v1,
      v2,
      v3);
    sub_47AB4(4, s, 0);
    v6 = dword_9E31C;
  }
  if ( !dword_1AEA78 || !*(_DWORD *)(dword_1AEA78 + 4) )
  {
    if ( v6 > 3 )
    {
      strcpy(s, "Handle is NULL.\n");
      sub_47AB4(3, s, 0);
      return 1;
    }
    return 1;
  }
  v8 = v7 + 4 * a1;
  v9 = *(_DWORD *)(v8 + 1941376);
  if ( v9 > (unsigned int)(float)(v1 * 238990.0) )
  {
    if ( v6 > 3 )
    {
      snprintf(
        s,
        0x800u,
        "chain = %d, hw = %d, hw_threshold = %d, too much hw.\n",
        a1,
        v9,
        (unsigned int)(float)(v1 * 238990.0));
      sub_47AB4(3, s, 0);
      return 1;
    }
    return 1;
  }
  v11 = dword_1AEA78 + 4 * a1;
  v12 = *(float *)(v11 + 168);
  v13 = *(float *)(v11 + 104);
  v14 = (float)*(unsigned int *)(v8 + 1916928) / 238990.0;
  *(float *)(v11 + 104) = v14;
  if ( v12 < v14 )
    *(float *)(v11 + 168) = v14;
  if ( v6 > 3 )
  {
    snprintf(
      s,
      0x800u,
      "chain = %d, nonce_rate_curr = %.4f, nonce_rate_last = %.4f, nonce_rate_max = %.4f\n",
      a1,
      v14,
      v13,
      *(float *)(v11 + 168));
    sub_47AB4(3, s, 0);
  }
  result = sub_37834(a1);
  if ( result )
  {
    *(_BYTE *)(dword_1AEA78 + a1 + 72) = 1;
    return 1;
  }
  else if ( v14 < v13 && (float)(v3 * *(float *)(dword_1AEA78 + 4 * a1 + 168)) > v14 )
  {
    result = 1;
    *(_BYTE *)(dword_1AEA78 + a1 + 72) = 1;
  }
  return result;
}
// 38280: variable 'v1' is possibly undefined
// 3827C: variable 'v2' is possibly undefined
// 38278: variable 'v3' is possibly undefined
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (000383C0) --------------------------------------------------------
int sub_383C0()
{
  _DWORD *v0; // r2
  int v1; // r3
  int v2; // t1
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v4, "[DEBUG] Check if all chain pattern test done.\n");
    sub_47AB4(4, v4, 0);
  }
  if ( dword_1AEA78 && *(_DWORD *)(dword_1AEA78 + 4) )
  {
    v0 = (_DWORD *)(dword_1AEA78 + 8);
    v1 = dword_A0D68;
    while ( 1 )
    {
      v2 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      if ( v2 == 1 && *v0 != 2 )
        break;
      ++v0;
      if ( v1 == dword_A0D68 + 64 )
        return 1;
    }
    return 0;
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v4, "Handle is NULL.\n");
    sub_47AB4(3, v4, 0);
    return 1;
  }
  else
  {
    return 1;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (000384D8) --------------------------------------------------------
int sub_384D8()
{
  _DWORD *v0; // r2
  int v1; // r3
  int v2; // t1
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v4, "[DEBUG] Check if all chain pattern test done except block.\n");
    sub_47AB4(4, v4, 0);
  }
  if ( dword_1AEA78 && *(_DWORD *)(dword_1AEA78 + 4) )
  {
    v0 = (_DWORD *)(dword_1AEA78 + 8);
    v1 = dword_A0D68;
    while ( 1 )
    {
      v2 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      if ( v2 == 1 && (*v0 & 0xFFFFFFFD) != 0 )
        break;
      ++v0;
      if ( v1 == dword_A0D68 + 64 )
        return 1;
    }
    return 0;
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v4, "Handle is NULL.\n");
    sub_47AB4(3, v4, 0);
    return 1;
  }
  else
  {
    return 1;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (000385EC) --------------------------------------------------------
int __fastcall sub_385EC(int a1)
{
  int v1; // r6
  int i; // r4
  unsigned int v3; // r0
  int j; // r4
  char v5; // r0
  int v6; // r12
  char v8; // r0
  int v9; // r4
  int v10; // r0
  int v11; // r0
  char v12[2052]; // [sp+0h] [bp-804h] BYREF

  v1 = a1;
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v12, 0x800u, "[DEBUG] Board init, is_power_off = %d.\n", a1);
    sub_47AB4(4, v12, 0);
  }
  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
    {
      if ( ++i == 16 )
        goto LABEL_7;
    }
    v3 = (unsigned __int8)i;
    sub_748C0(v3);
  }
LABEL_7:
  if ( v1 )
  {
    v11 = sub_22AB8();
    v6 = v11;
    if ( v11 )
      return v6;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v12, "Sleep 30s for power release ...\n");
      sub_47AB4(3, v12, 0);
    }
    sleep(0x1Eu);
    v6 = sub_1A300();
    if ( v6 )
      return v6;
    sub_21E78(115200);
    sub_4A804();
    v6 = sub_239C4();
    if ( v6 )
      return v6;
    v6 = sub_1A420();
    if ( v6 )
      return v6;
  }
  else
  {
    for ( j = 0; j != 16; ++j )
    {
      while ( *(_DWORD *)(dword_A0D68 + 4 * j + 4) != 1 )
      {
        if ( ++j == 16 )
          goto LABEL_13;
      }
      v5 = j;
      sub_70974(v5);
    }
LABEL_13:
    sleep(3u);
    v6 = sub_1A240();
    if ( v6 )
      return v6;
    do
    {
      while ( *(_DWORD *)(dword_A0D68 + 4 * v1 + 4) == 1 )
      {
        v8 = v1++;
        sub_709B8(v8);
        if ( v1 == 16 )
          goto LABEL_18;
      }
      ++v1;
    }
    while ( v1 != 16 );
LABEL_18:
    sleep(3u);
    sub_4A804();
    sub_21E78(115200);
    sub_4A804();
  }
  v9 = 0;
  sub_24904();
  do
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * v9 + 4) != 1 )
    {
      if ( ++v9 == 16 )
        goto LABEL_23;
    }
    v10 = (unsigned __int8)v9++;
    sub_17598(v10, 0);
  }
  while ( v9 != 16 );
LABEL_23:
  sub_4A804();
  sub_21F2C();
  sub_4A804();
  return 0;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (0003883C) --------------------------------------------------------
void __fastcall sub_3883C(int a1, int a2)
{
  unsigned int v2; // r3
  int v4; // r6
  unsigned int v5; // r4
  int v6; // r12
  int v7; // r3
  unsigned int v8; // r3
  int v9; // r7
  int v10; // r11
  int v11; // r8
  int v12; // r6
  int i; // r4
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v2 = dword_9E31C;
  if ( dword_1AEA78 && *(_DWORD *)(dword_1AEA78 + 4) )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
    {
LABEL_4:
      v4 = a2 + 312 * a1;
      v5 = 0;
      while ( 1 )
      {
        if ( v2 > 3 )
        {
          v6 = 4 * v5;
          v7 = v5++;
          snprintf(s, 0x800u, "IC[%03d]:%04d ", v7, *(_DWORD *)(v4 + v6 + 1911936));
          sub_47EC8(3, s, 0);
          v2 = dword_9E31C;
          if ( v5 != 6 * (v5 / 6) || (unsigned int)dword_9E31C <= 3 )
            goto LABEL_5;
          strcpy(s, "\n");
          sub_47EC8(3, s, v5 % 6);
          v2 = dword_9E31C;
          if ( v5 == 78 )
          {
LABEL_11:
            if ( v2 > 3 )
            {
              strcpy(s, "\n");
              sub_47EC8(3, s, 0);
            }
            if ( *(_DWORD *)dword_1AEA78 != 161 )
            {
              v8 = dword_9E31C;
              v9 = 0;
              v10 = v4 - 104 * a1;
              v11 = v10;
              do
              {
                v12 = 4 * v9;
                for ( i = 0; i != 4; ++i )
                {
                  if ( v8 > 3 )
                  {
                    snprintf(s, 0x800u, "D[%02d]:%04d ", v12 + i, *(_DWORD *)(v11 + 4 * i + 1936960));
                    sub_47EC8(3, s, 0);
                    v8 = dword_9E31C;
                  }
                }
                if ( v8 > 3 )
                {
                  snprintf(s, 0x800u, "D_BIG[%02d]:%05d\n", v9, *(_DWORD *)(v10 + v12 - 156 * a1 + 1940288));
                  sub_47EC8(3, s, 0);
                  v8 = dword_9E31C;
                }
                ++v9;
                v11 += 16;
              }
              while ( v9 != 13 );
              if ( v8 > 3 )
              {
                strcpy(s, "\n\n");
                sub_47EC8(3, s, 0);
              }
            }
            return;
          }
        }
        else
        {
          ++v5;
LABEL_5:
          if ( v5 == 78 )
            goto LABEL_11;
        }
      }
    }
    snprintf(s, 0x800u, "chain %d:\n", a1);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-30s : %d\n", "send_nonce_num", &loc_3A590);
      sub_47EC8(3, s, 0);
      v2 = dword_9E31C;
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_4;
      snprintf(s, 0x800u, "%-30s : %d\n", "recv_nonce_num", *(_DWORD *)(a2 + 4 * (a1 + 479232)));
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_35;
      snprintf(
        s,
        0x800u,
        "%-30s : %f\n",
        "nonce_return_rate",
        (float)((float)*(unsigned int *)(a2 + 4 * (a1 + 479232)) / 238990.0));
      sub_47EC8(3, s, 0);
      v2 = dword_9E31C;
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_4;
      snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_repeated", *(_DWORD *)(a2 + 4 * (a1 + 485280)));
      sub_47EC8(3, s, 0);
    }
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_38;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_top_check_fail", *(_DWORD *)(a2 + 4 * (a1 + 485296)));
    sub_47EC8(3, s, 0);
    v2 = dword_9E31C;
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_crc_err", *(_DWORD *)(a2 + 4 * (a1 + 485312)));
    sub_47EC8(3, s, 0);
LABEL_35:
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_41;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_invalid", *(_DWORD *)(a2 + 4 * (a1 + 485328)));
    sub_47EC8(3, s, 0);
    v2 = dword_9E31C;
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_hw", *(_DWORD *)(a2 + 4 * (a1 + 485344)));
    sub_47EC8(3, s, 0);
LABEL_38:
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_44;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_extra", *(_DWORD *)(a2 + 4 * (a1 + 485360)));
    sub_47EC8(3, s, 0);
    v2 = dword_9E31C;
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %d\n", "nonce_num_unknown_err", *(_DWORD *)(a2 + 4 * (a1 + 485376)));
    sub_47EC8(3, s, 0);
LABEL_41:
    v2 = dword_9E31C;
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %d\n", "invalid_asic_num", *(_DWORD *)(a2 + 4 * (a1 + 963376) + 4));
    sub_47EC8(3, s, 0);
    v2 = dword_9E31C;
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_4;
    snprintf(s, 0x800u, "%-30s : %d\n", "invalid_chain_num", *(_DWORD *)(a2 + 3853504));
    sub_47EC8(3, s, 0);
LABEL_44:
    v2 = dword_9E31C;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
      v2 = dword_9E31C;
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "Chain %d:\n", a1);
        sub_47AB4(3, s, 0);
        v2 = dword_9E31C;
      }
    }
    goto LABEL_4;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "Handle is NULL.\n");
    sub_47AB4(3, s, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (00038ECC) --------------------------------------------------------
int __fastcall sub_38ECC(int a1)
{
  return a1 + 479232;
}

//----- (00038EEC) --------------------------------------------------------
void __fastcall sub_38EEC(char *a1, int a2, unsigned int a3)
{
  int v4; // r10
  char *v5; // r7
  int v6; // r8
  int v7; // r4
  int v8; // r5
  char *v9; // r9
  int v10; // r0
  char *v11; // r3
  char *v12; // r2
  int i; // r3
  int v14; // r1
  char *v15; // r7
  unsigned int j; // r4
  unsigned int v17; // r0
  int v18; // r10
  int v21; // [sp+10h] [bp-A84h]
  _DWORD s[156]; // [sp+20h] [bp-A74h] BYREF
  char v23[2052]; // [sp+290h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v23, "Get asic grade by PM data:\n");
    sub_47AB4(3, v23, 0);
  }
  memset(s, 0, sizeof(s));
  v4 = 0;
  do
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * v4 + 4) != 1 )
    {
      if ( ++v4 == 16 )
        return;
    }
    sub_2DF9C(v4, (int)s);
    v5 = a1;
    v6 = 0;
    v21 = v4;
    v7 = 0;
    v8 = a2 + 78 * v4;
    v9 = a1;
    do
    {
      v10 = v7 + 6;
      v11 = v5;
      do
      {
        v11 += 8;
        *(_DWORD *)&v5[8 * v7 + v6] = s[2 * v7];
        *((_DWORD *)v11 - 1) = v7++;
      }
      while ( v10 != v7 );
      qsort(v5, 6u, 8u, (__compar_fn_t)sub_36CA4);
      v12 = v5;
      for ( i = 0; i != 6; ++i )
      {
        v14 = *((_DWORD *)v12 + 1);
        v12 += 8;
        *(_BYTE *)(v8 + v14) = i;
      }
      v6 -= 48;
      v5 += 48;
    }
    while ( v6 != -624 );
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v23, "1 step result:\n");
      sub_47AB4(3, v23, 0);
    }
    sub_36CB4(v4, a2);
    do
    {
      v15 = v9;
      for ( j = 0; j != 6; ++j )
      {
        v17 = j;
        v18 = *((_DWORD *)v15 + 1);
        v15 += 8;
        *(_BYTE *)(v8 + v18) = v17 / a3;
      }
      v9 += 48;
    }
    while ( a1 + 624 != v9 );
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v23, 0x800u, "%d step result:\n", a3);
      sub_47AB4(3, v23, 0);
    }
    v4 = v21 + 1;
    sub_36CB4(v21, a2);
  }
  while ( v21 != 15 );
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (00039138) --------------------------------------------------------
void __fastcall sub_39138(int a1)
{
  int v2; // r0
  int v3; // r2
  int v4; // r3
  int i; // r5
  int v6; // r6
  int v7; // r6
  int v8; // r3
  int v9; // r12
  unsigned int v10; // r0
  unsigned int v11; // r8
  int v12; // r7
  __int64 v13; // r2
  int v14; // t1
  bool v15; // zf
  int v16; // r12
  _DWORD *v17; // r1
  int v18; // r3
  unsigned int v19; // [sp+4h] [bp-850h]
  int v20; // [sp+8h] [bp-84Ch]
  int v21; // [sp+1Ch] [bp-838h]
  int v22; // [sp+24h] [bp-830h]
  int v23; // [sp+28h] [bp-82Ch]
  struct timeval v24; // [sp+40h] [bp-814h] BYREF
  struct timeval v25; // [sp+48h] [bp-80Ch] BYREF
  char v26[2052]; // [sp+50h] [bp-804h] BYREF

  if ( dword_1AEA78 && *(_DWORD *)(dword_1AEA78 + 4) )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v26, "Pattern test start...\n");
      sub_47AB4(3, v26, 0);
    }
    sub_4A60C(&v24);
    sub_37E60();
    v2 = sub_702AC();
    sub_702CC(v2 | 0x10000);
    v3 = *(_DWORD *)dword_1AEA78;
    *(_DWORD *)(dword_1AEA78 + 232) = 1;
    if ( v3 == 161 )
      sub_36F78(a1);
    else
      sub_3702C(a1);
    v4 = dword_1AEA78;
    for ( i = 0; i != 16; ++i )
    {
      while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 || *(_DWORD *)(v4 + 4 * (i + 2)) != 1 )
      {
        if ( ++i == 16 )
          goto LABEL_15;
      }
      v6 = 3;
      do
      {
        if ( sub_37B2C(i) )
          break;
        usleep((__useconds_t)&loc_186A0);
        --v6;
      }
      while ( v6 );
      v4 = dword_1AEA78;
    }
LABEL_15:
    *(_DWORD *)(v4 + 232) = 0;
    v7 = sub_37770();
    v21 = 0;
    v23 = dword_1AEA78;
    v22 = dword_A0D68;
    do
    {
      v8 = *(_DWORD *)(v22 + 4);
      v22 += 4;
      if ( v8 == 1 && *(_DWORD *)(v23 + 4 * v21 + 8) == 1 )
      {
        v19 = 0;
        v20 = v7 - 4 + (_DWORD)&loc_1D2C8 * v21;
        do
        {
          v9 = v20;
          v10 = 0;
          v11 = 4 * (13 * v21 + v19 / 6);
          v12 = *(_DWORD *)(v7 + v11 + 1940288);
          do
          {
            v13 = 2863311531LL * v10;
            v14 = *(_DWORD *)(v9 + 4);
            v9 += 4;
            ++v10;
            v12 += v14;
            HIDWORD(v13) >>= 6;
            *(_DWORD *)(v7 + 4 * (4 * (78 * v21 + v19) + HIDWORD(v13)) + 1916992) += v14;
            *(_DWORD *)(v7 + 4 * (HIDWORD(v13) + v11) + 1936960) += v14;
            ++*(_DWORD *)(v7 + 4 * (702 * v21 + 9 * v19 + v14) + 3853572);
          }
          while ( v10 != 383 );
          v15 = v19++ == 77;
          *(_DWORD *)(v7 + v11 + 1940288) = v12;
          v20 += 1532;
        }
        while ( !v15 );
        v16 = v7 + 3853572 + 2808 * v21;
        do
        {
          v17 = (_DWORD *)v16;
          do
          {
            v17[1] += *v17;
            ++v17;
          }
          while ( v17 != (_DWORD *)(v16 + 32) );
          v16 += 36;
        }
        while ( v16 != v7 + 3856380 + 2808 * v21 );
      }
      ++v21;
    }
    while ( v21 != 16 );
    sub_4A60C(&v25);
    v18 = v25.tv_sec - v24.tv_sec;
    if ( v25.tv_usec - v24.tv_usec < 0 )
      --v18;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(v26, 0x800u, "Pattern test done, time cost %lds\n", v18);
      sub_47AB4(3, v26, 0);
    }
  }
  else if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v26, "Handle is NULL.\n");
    sub_47AB4(3, v26, 0);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA78: using guessed type int dword_1AEA78;

//----- (0003954C) --------------------------------------------------------
int sub_3954C()
{
  int v0; // r4

  v0 = sub_1A1C0();
  if ( v0 == sub_1A1B0() )
    return 0;
  else
    return sub_1A3B8();
}

//----- (00039574) --------------------------------------------------------
int __fastcall sub_39574(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v5; // r0
  int j; // r4
  int v7; // r0
  int v8; // r4
  int v9; // r9
  int v10; // r3
  int v11; // r4
  int v12; // r5
  float v13; // s0
  int v14; // r2
  bool v15; // cc
  int v16; // r1
  int v17; // r5
  int v19; // r4
  unsigned int v20; // [sp+14h] [bp-828h]
  int v21; // [sp+18h] [bp-824h]
  unsigned int i; // [sp+34h] [bp-808h] BYREF
  char s[2052]; // [sp+38h] [bp-804h] BYREF

  v21 = a1;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "freq_prev = %d, freq_start = %d, freq_step = %d, freq_max = %d\n", a1, a2, a3, a4);
    sub_47AB4(3, s, 0);
  }
  for ( i = a2; i <= a4; i += a3 )
  {
    if ( (unsigned int)dword_9E31C <= 3 || (strcpy(s, "\n"), sub_47EC8(3, s, 0), (unsigned int)dword_9E31C <= 3) )
    {
      v5 = sub_37F50();
      if ( !v5 )
        goto LABEL_36;
    }
    else
    {
      snprintf(s, 0x800u, ">>>> freq_curr = %d\n", i);
      sub_47AB4(3, s, 0);
      v5 = sub_37F50();
      if ( !v5 )
      {
LABEL_36:
        if ( (unsigned int)dword_9E31C <= 3 )
          return 0;
        v19 = v5;
        strcpy(s, "All ready chain done, exit.\n");
        sub_47AB4(3, s, v5);
        return v19;
      }
    }
    for ( j = 0; j != 16; ++j )
    {
      while ( *(_DWORD *)(dword_A0D68 + 4 * j + 4) != 1 || sub_37D44(j) != 1 )
      {
        if ( ++j == 16 )
          goto LABEL_11;
      }
      v7 = j;
      sub_30B64(v7, (unsigned __int8)byte_A0D79, v21, i, dword_9C298, *(_BYTE *)(*(_DWORD *)dword_1AEA7C + 21));
    }
LABEL_11:
    v21 = i;
    v8 = sub_3954C();
    if ( v8 )
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        return v8;
      strcpy(s, "Set voltage failed, exit.\n");
      sub_47AB4(3, s, 0);
      return v8;
    }
    sub_22E9C(i, 8, 20);
    sub_39138((int)&i);
    v9 = sub_37770();
    v20 = i;
    v10 = dword_A0D68;
    do
    {
      while ( *(_DWORD *)(v10 + 4 * v8 + 4) != 1 )
      {
        if ( ++v8 == 16 )
          goto LABEL_18;
      }
      if ( sub_37D44(v8) == 1 )
        sub_3883C(v8, v9);
      ++v8;
      v10 = dword_A0D68;
    }
    while ( v8 != 16 );
LABEL_18:
    v11 = 0;
    while ( 1 )
    {
      v12 = 4 * v11;
      if ( *(_DWORD *)(v10 + 4 * v11 + 4) == 1 && sub_37D44(v11) == 1 )
        break;
      if ( ++v11 == 16 )
        goto LABEL_30;
LABEL_20:
      v10 = dword_A0D68;
    }
    v13 = *(float *)(*(_DWORD *)dword_1AEA7C + 28);
    if ( sub_3816C(v11) )
      goto LABEL_33;
    v14 = dword_1AEA7C;
    v15 = (unsigned int)dword_9E31C > 3;
    v16 = dword_1AEA7C + v12;
    *(_DWORD *)(v16 + 4) = v20;
    *(_DWORD *)(v16 + 68) = 1;
    if ( v15 )
    {
      snprintf(s, 0x800u, "Valid freq, chain = %d, freq_result = %d.\n", v11, v20);
      sub_47AB4(3, s, 0);
      v14 = dword_1AEA7C;
    }
    if ( *(_DWORD *)(v14 + v12 + 4) >= *(_DWORD *)(*(_DWORD *)v14 + 8) )
LABEL_33:
      sub_37BD4(v11, 2);
    sub_38ECC(v11++);
    v17 = dword_1AEA7C + v12;
    if ( v13 > *(float *)(v17 + 132) )
      *(float *)(v17 + 132) = v13;
    if ( v11 != 16 )
      goto LABEL_20;
LABEL_30:
    ;
  }
  return 0;
}
// 9C298: using guessed type int dword_9C298;
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// A0D79: using guessed type char byte_A0D79;
// 1AEA7C: using guessed type int dword_1AEA7C;

//----- (0003997C) --------------------------------------------------------
int sub_3997C()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v1, "[DEBUG] Freq tuning basic init.\n");
    sub_47AB4(4, v1, 0);
    if ( (unsigned int)dword_9E31C > 4 )
    {
      strcpy(v1, "[DEBUG] Allocate memory for freq tuning basic.\n");
      sub_47AB4(4, v1, 0);
    }
  }
  if ( dword_1AEA7C )
    return 0;
  dword_1AEA7C = (int)calloc(0xC4u, 1u);
  if ( dword_1AEA7C )
    return 0;
  sub_31794(13, 255);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(v1, "Fail to allocate memory for freq tuning basic context.\n");
    sub_47AB4(3, v1, 0);
  }
  return -1;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA7C: using guessed type int dword_1AEA7C;

//----- (00039AB4) --------------------------------------------------------
void sub_39AB4()
{
  char v0[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v0, "[DEBUG] Freq tuning basic exit.\n");
    sub_47AB4(4, v0, 0);
    if ( (unsigned int)dword_9E31C > 4 )
    {
      strcpy(v0, "[DEBUG] Free memory for freq tuning basic.\n");
      sub_47AB4(4, v0, 0);
    }
  }
  if ( dword_1AEA7C )
  {
    free((void *)dword_1AEA7C);
    dword_1AEA7C = 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA7C: using guessed type int dword_1AEA7C;

//----- (00039B70) --------------------------------------------------------
int __fastcall sub_39B70(int a1)
{
  return *(_DWORD *)(dword_1AEA7C + 4 * a1 + 68);
}
// 1AEA7C: using guessed type int dword_1AEA7C;

//----- (00039B88) --------------------------------------------------------
int __fastcall sub_39B88(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v3, 0x800u, "[DEBUG] Get freq result, chain = %d.\n", a1);
    sub_47AB4(4, v3, 0);
  }
  return *(_DWORD *)(dword_1AEA7C + 4 * a1 + 4);
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA7C: using guessed type int dword_1AEA7C;

//----- (00039BEC) --------------------------------------------------------
int __fastcall sub_39BEC(int a1)
{
  return dword_1AEA7C + 4 * a1;
}
// 1AEA7C: using guessed type int dword_1AEA7C;

//----- (00039C04) --------------------------------------------------------
void sub_39C04()
{
  unsigned int v0; // r3
  char *v1; // r6
  char *v2; // r12
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C <= 3 )
    return;
  snprintf(s, 0x800u, "%-40s : %d\n", "voltage", **(_DWORD **)dword_1AEA7C);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-40s : %d\n", "freq_base", *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 4));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %d\n", "freq_threshold", *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 8));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_16;
    snprintf(s, 0x800u, "%-40s : %d\n", "freq_serial_threshold", *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 12));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %d\n", "freq_step", *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 16));
    sub_47EC8(3, s, 0);
  }
  v0 = dword_9E31C;
  if ( (unsigned int)dword_9E31C <= 3 )
  {
LABEL_19:
    if ( v0 > 3 )
    {
      snprintf(s, 0x800u, "%-40s : %.2f\n", "nonce_rate_threshold", *(float *)(*(_DWORD *)dword_1AEA7C + 32));
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "%-40s : %.2f\n", "nonce_rate_dec_threshold", *(float *)(*(_DWORD *)dword_1AEA7C + 36));
        sub_47EC8(3, s, 0);
      }
    }
    return;
  }
  v1 = "false";
  if ( *(_BYTE *)(*(_DWORD *)dword_1AEA7C + 20) )
    v2 = "true";
  else
    v2 = "false";
  snprintf(s, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol", v2);
  sub_47EC8(3, s, 0);
  if ( (unsigned int)dword_9E31C > 3 )
  {
    if ( *(_BYTE *)(*(_DWORD *)dword_1AEA7C + 21) )
      v1 = "true";
    snprintf(s, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v1);
    sub_47EC8(3, s, 0);
LABEL_16:
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %d\n", "is_board_init_with_power_off", *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 24));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %.4f\n", "hw_threshold", *(float *)(*(_DWORD *)dword_1AEA7C + 28));
    sub_47EC8(3, s, 0);
    v0 = dword_9E31C;
    goto LABEL_19;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA7C: using guessed type int dword_1AEA7C;

//----- (00039F80) --------------------------------------------------------
int __fastcall sub_39F80(int a1)
{
  _DWORD *v2; // r5
  int v3; // r8
  int i; // r4
  int v6; // r0
  int j; // r4
  _DWORD *v8; // r3
  unsigned int v9; // r11
  unsigned int v10; // r2
  unsigned int v11; // r1
  unsigned int v12; // r9
  int v13; // r0
  int v14; // r4
  int v15; // r12
  int v16; // r8
  int v17; // [sp+8h] [bp-814h]
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "Do freq tuning basic.\n");
    sub_47AB4(3, s, 0);
  }
  v2 = (_DWORD *)dword_1AEA7C;
  memset((void *)(dword_1AEA7C + 4), 0, 0xC0u);
  *v2 = a1;
  v3 = sub_385EC(*(_DWORD *)(a1 + 24));
  if ( !v3 )
  {
    sub_38064();
    sub_1A0F0(**(_DWORD **)dword_1AEA7C);
    sub_30770(
      255,
      (unsigned __int8)byte_A0D79,
      *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 4),
      *(unsigned __int8 *)(*(_DWORD *)dword_1AEA7C + 20));
    v3 = sub_3954C();
    if ( !v3 )
    {
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy(s, "\n");
        sub_47EC8(3, s, 0);
        if ( (unsigned int)dword_9E31C > 3 )
        {
          strcpy(s, ">>>> Do tuning parallel.\n");
          sub_47AB4(3, s, 0);
        }
      }
      for ( i = 0; i != 16; ++i )
      {
        while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 )
        {
          if ( ++i == 16 )
            goto LABEL_13;
        }
        v6 = i;
        sub_37BD4(v6, 1);
      }
LABEL_13:
      v3 = sub_39574(
             *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 4),
             *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 4),
             *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 16),
             *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 12));
      if ( !v3 && !sub_383C0() )
      {
        if ( (unsigned int)dword_9E31C > 3 )
        {
          strcpy(s, "\n");
          sub_47EC8(3, s, 0);
          if ( (unsigned int)dword_9E31C > 3 )
          {
            strcpy(s, ">>>> Do tuning serial.\n");
            sub_47AB4(3, s, 0);
          }
        }
        for ( j = 0; j != 16; ++j )
        {
          if ( *(_DWORD *)(dword_A0D68 + 4 * j + 4) == 1 && sub_37D44(j) == 1 )
            sub_37BD4(j, 0);
        }
        v8 = *(_DWORD **)dword_1AEA7C;
        v9 = *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 4);
        v10 = *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 12);
        if ( v9 <= v10 )
        {
          v9 = v8[3];
          v11 = v10 + v8[4];
        }
        else
        {
          v11 = v8[1];
        }
        v12 = v11;
        v17 = 0;
        while ( sub_37EF8() )
        {
          if ( (unsigned int)dword_9E31C > 3 )
          {
            strcpy(s, "\n");
            sub_47EC8(3, s, 0);
            if ( (unsigned int)dword_9E31C > 3 )
            {
              ++v17;
              snprintf(s, 0x800u, ">>>> Round %d:\n");
              sub_47AB4(3, s, 0);
            }
          }
          sub_37FA8(2u);
          v13 = sub_39574(v9, v12, *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 16), *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 8));
          v14 = v13;
          if ( v13 )
            return v13;
          do
          {
            if ( *(_DWORD *)(dword_A0D68 + 4 * v14 + 4) == 1 && sub_37D44(v14) == 2 )
            {
              v15 = dword_1AEA7C + 4 * v14;
              if ( *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 12) >= *(_DWORD *)(v15 + 4) )
                v16 = *(_DWORD *)(v15 + 4);
              else
                v16 = *(_DWORD *)(*(_DWORD *)dword_1AEA7C + 12);
              sub_30770(v14, (unsigned __int8)byte_A0D79, v16, 0);
              if ( (unsigned int)dword_9E31C > 3 )
              {
                snprintf(s, 0x800u, "Down freq, chain = %d, freq = %d.\n", v14, v16);
                sub_47AB4(3, s, 0);
              }
            }
            ++v14;
          }
          while ( v14 != 16 );
        }
        return 0;
      }
    }
    return v3;
  }
  if ( (unsigned int)dword_9E31C <= 3 )
    return v3;
  strcpy(s, "Board init failed.\n");
  sub_47AB4(3, s, 0);
  return v3;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// A0D79: using guessed type char byte_A0D79;
// 1AEA7C: using guessed type int dword_1AEA7C;

//----- (0003A3C4) --------------------------------------------------------
unsigned int __fastcall sub_3A3C4(int a1, int a2)
{
  int v2; // lr
  unsigned int v3; // r12
  int v4; // r2
  int v5; // lr
  int v6; // t1
  unsigned int v7; // r4
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v2 = a2 + 312 * a1;
  v3 = 0;
  v4 = v2 - 4;
  v5 = v2 + 308;
  do
  {
    v6 = *(_DWORD *)(v4 + 4);
    v4 += 4;
    v3 += v6;
  }
  while ( v4 != v5 );
  v7 = v3 / 0x4E;
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_avg = %d\n", a1, v3 / 0x4E);
    sub_47AB4(4, s, 0);
  }
  return v7;
}
// 9E31C: using guessed type int dword_9E31C;

//----- (0003A458) --------------------------------------------------------
unsigned int __fastcall sub_3A458(int a1, int a2)
{
  int v2; // r1
  int v3; // lr
  unsigned int v4; // r4
  int i; // r12
  int v6; // t1
  int v7; // r2
  bool v8; // zf
  unsigned int v9; // r3
  unsigned int v10; // t1
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v2 = a2 - 4;
  v3 = dword_A0D68;
  v4 = 0xFFFFFF;
  for ( i = 0; i != 16; ++i )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v3 + 4);
      v3 += 4;
      v7 = v2 + 312;
      if ( v6 == 1 )
      {
        v8 = a1 == 255;
        if ( a1 != 255 )
          v8 = a1 == i;
        if ( v8 )
          break;
      }
      ++i;
      v2 += 312;
      if ( i == 16 )
        goto LABEL_12;
    }
    do
    {
      v10 = *(_DWORD *)(v2 + 4);
      v2 += 4;
      v9 = v10;
      if ( v4 >= v10 )
        v4 = v9;
    }
    while ( v2 != v7 );
    v2 = v7;
  }
LABEL_12:
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_min = %d\n", a1, v4);
    sub_47AB4(4, s, 0);
  }
  return v4;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (0003A520) --------------------------------------------------------
unsigned int __fastcall sub_3A520(int a1, int a2)
{
  unsigned int v2; // r4
  int v3; // lr
  int v4; // r1
  int i; // r12
  int v6; // t1
  int v7; // r2
  bool v8; // zf
  unsigned int v9; // r3
  unsigned int v10; // t1
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v2 = 0;
  v3 = dword_A0D68;
  v4 = a2 - 4;
  for ( i = 0; i != 16; ++i )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v3 + 4);
      v3 += 4;
      v7 = v4 + 312;
      if ( v6 == 1 )
      {
        v8 = a1 == 255;
        if ( a1 != 255 )
          v8 = a1 == i;
        if ( v8 )
          break;
      }
      ++i;
      v4 += 312;
      if ( i == 16 )
        goto LABEL_12;
    }
    do
    {
      v10 = *(_DWORD *)(v4 + 4);
      v4 += 4;
      v9 = v10;
      if ( v2 < v10 )
        v2 = v9;
    }
    while ( v4 != v7 );
    v4 = v7;
  }
LABEL_12:
  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_max = %d\n", a1, v2);
    sub_47AB4(4, s, 0);
  }
  return v2;
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;

//----- (0003A5E8) --------------------------------------------------------
int __fastcall sub_3A5E8(int a1)
{
  unsigned int v2; // r6
  unsigned int v3; // r8
  unsigned int v4; // r7
  unsigned int v5; // r0
  int v6; // r3
  unsigned int v7; // r1
  unsigned int v9; // lr
  int v10; // r0
  unsigned int v11; // r1
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v2 = sub_3A3C4(a1, dword_1AEA80 + 4);
  v3 = sub_3A458(a1, dword_1AEA80 + 4);
  v4 = sub_3A520(a1, dword_1AEA80 + 4);
  v5 = sub_3A520(a1, dword_1AEA80 + 5060);
  v6 = *(_DWORD *)dword_1AEA80;
  v7 = *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 68);
  if ( v7 > v2 )
  {
    v9 = *(_DWORD *)(v6 + 76);
    if ( v9 > v4 - v3 )
    {
      if ( v7 < v5 )
      {
        if ( (unsigned int)dword_9E31C <= 3 )
          return 1;
        snprintf(s, 0x800u, "chain = %d, freq_max_runtime = %d, freq_threshold = %d, max freq enough\n", a1, v5, v7);
      }
      else
      {
        v10 = *(_DWORD *)(v6 + 112);
        v11 = *(_DWORD *)(dword_1AEA80 + 4 * (a1 + 2512) + 4);
        if ( v11 < v10 - 1 )
          return 0;
        if ( (unsigned int)dword_9E31C <= 3 )
          return 1;
        snprintf(s, 0x800u, "chain = %d, grade_curr = %d, grade_max = %d, grade done\n", a1, v11, v10);
      }
    }
    else
    {
      if ( (unsigned int)dword_9E31C <= 3 )
        return 1;
      snprintf(
        s,
        0x800u,
        "chain = %d, freq_max = %d, freq_min = %d, freq_diff = %d, freq_diff_threshold = %d, freq diff enough\n",
        a1,
        v4,
        v3,
        v4 - v3,
        v9);
    }
LABEL_14:
    sub_47AB4(3, s, 0);
    return 1;
  }
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "chain = %d, freq_avg = %d, freq_threshold = %d, avg freq enough\n", a1, v2, v7);
    goto LABEL_14;
  }
  return 1;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003A79C) --------------------------------------------------------
void __fastcall sub_3A79C(int a1, int a2, int a3)
{
  int v5; // r11
  bool v6; // zf
  _BOOL4 v7; // r4
  unsigned int v8; // r1
  unsigned int v9; // r4
  int i; // [sp+8h] [bp-81Ch]
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(s, 0x800u, "[DEBUG] Dump freq table, chain = %d.\n", a1);
    sub_47AB4(4, s, 0);
  }
  v5 = 78 * a1;
  for ( i = 0; i != 16; ++i )
  {
    if ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
    {
      v6 = a1 == 255;
      if ( a1 != 255 )
        v6 = a1 == i;
      v7 = !v6;
      if ( v6 )
      {
        v8 = dword_9E31C;
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(s, 0x800u, "chain = %d\n", i);
          sub_47EC8(3, s, v7);
          v8 = dword_9E31C;
        }
        v9 = 0;
        while ( v8 > 3 )
        {
          snprintf(s, 0x800u, "[%3d]:%-3d", v9, *(_DWORD *)(a2 + 312 * i + 4 * v9));
          sub_47EC8(3, s, 0);
          if ( a3 )
          {
            v8 = dword_9E31C;
            if ( (unsigned int)*(unsigned __int8 *)(*(_DWORD *)dword_1AEA80 + v5 + v9 + 740) <= *(_DWORD *)(dword_1AEA80 + 4 * (a1 + 2512) + 4) )
              goto LABEL_18;
            if ( (unsigned int)dword_9E31C <= 3 )
              goto LABEL_19;
            strcpy(s, "+  ");
            sub_47EC8(3, s, 0);
            v8 = dword_9E31C;
LABEL_26:
            ++v9;
            if ( v9 != 6 * (v9 / 6) || v8 <= 3 )
              goto LABEL_20;
            strcpy(s, "\n");
            sub_47EC8(3, s, v9 % 6);
            v8 = dword_9E31C;
            if ( v9 == 78 )
            {
LABEL_29:
              if ( v8 > 3 )
              {
                strcpy(s, "\n");
                sub_47EC8(3, s, 0);
              }
              goto LABEL_4;
            }
          }
          else
          {
            v8 = dword_9E31C;
            if ( (unsigned int)dword_9E31C > 3 )
            {
              *(_DWORD *)s = &unk_202020;
              sub_47EC8(3, s, 0);
              v8 = dword_9E31C;
              goto LABEL_26;
            }
LABEL_19:
            ++v9;
LABEL_20:
            if ( v9 == 78 )
              goto LABEL_29;
          }
        }
        if ( !a3
          || (unsigned int)*(unsigned __int8 *)(*(_DWORD *)dword_1AEA80 + v5 + v9 + 740) > *(_DWORD *)(dword_1AEA80 + 4 * (a1 + 2512) + 4) )
        {
          goto LABEL_19;
        }
LABEL_18:
        if ( v8 > 3 )
        {
          strcpy(s, "=  ");
          sub_47EC8(3, s, 0);
          v8 = dword_9E31C;
          goto LABEL_26;
        }
        goto LABEL_19;
      }
    }
LABEL_4:
    ;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003AA80) --------------------------------------------------------
int sub_3AA80()
{
  int v0; // r4

  v0 = sub_1A1C0();
  if ( v0 == sub_1A1B0() )
    return 0;
  else
    return sub_1A3B8();
}

//----- (0003AAA8) --------------------------------------------------------
int __fastcall sub_3AAA8(int a1)
{
  int *v1; // r5
  int i; // r4
  int v3; // lr
  int v4; // r3
  int result; // r0
  __int16 *v6; // r4
  int v7; // r8
  int v8; // r6
  int v9; // r7
  unsigned int v10; // r0
  int v11; // r3
  unsigned int v12; // r1
  __int16 *v13; // r2
  int v14; // r6
  int j; // r4
  unsigned int v16; // r9
  int v17; // r6
  int v18; // r4
  int v19; // r2
  int v20; // r4
  int v21; // r10
  unsigned int v22; // r9
  int *v23; // r2
  int v24; // lr
  int v25; // r3
  int v26; // r0
  int v27; // r1
  int v28; // t1
  unsigned int v29; // t1
  unsigned int v30; // r9
  int v31; // r5
  int v32; // r4
  int v33; // r2
  int v34; // r0
  unsigned int v35; // r0
  int v36; // r4
  int v37; // r0
  int v38; // r3
  int v39; // r7
  int v40; // r4
  int v41; // r6
  float v42; // s0
  int v43; // r2
  bool v44; // cc
  int v45; // r1
  int v46; // r3
  int v47; // r0
  __int16 *v48; // r2
  int v49; // t1
  int v50; // r3
  int v51; // r0
  __int16 *v52; // r2
  int v53; // t1
  int k; // r4
  int v55; // r10
  int v56; // r1
  int v57; // r12
  int v58; // r3
  int v59; // r2
  int v60; // r0
  int v61; // t1
  int v62; // r12
  int v63; // [sp+8h] [bp-13B4h]
  char *v64; // [sp+14h] [bp-13A8h]
  int c; // [sp+20h] [bp-139Ch]
  unsigned int v67; // [sp+28h] [bp-1394h] BYREF
  char v68[4]; // [sp+2Ch] [bp-1390h] BYREF
  int v69; // [sp+30h] [bp-138Ch] BYREF
  __int16 v70; // [sp+34h] [bp-1388h] BYREF
  char v71; // [sp+36h] [bp-1386h]
  char s[4996]; // [sp+38h] [bp-1384h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "\n");
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, ">>>> Do single grade tuning.\n");
      sub_47AB4(3, s, 0);
    }
  }
  v1 = &dword_A0D68;
  for ( i = 0; i != 16; ++i )
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) != 1 || sub_37D44(i) != 1 || (unsigned int)dword_9E31C <= 3 )
    {
      if ( ++i == 16 )
        goto LABEL_8;
    }
    v3 = i + 2512;
    v4 = i;
    snprintf(s, 0x800u, "chain = %d, grade = %d\n", v4, *(_DWORD *)(dword_1AEA80 + 4 * v3 + 4));
    sub_47AB4(3, s, 0);
  }
LABEL_8:
  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "Board init start.\n");
    sub_47AB4(3, s, 0);
  }
  c = sub_385EC(*(_DWORD *)(*(_DWORD *)dword_1AEA80 + 92));
  if ( c )
  {
    if ( (unsigned int)dword_9E31C <= 3 )
      return c;
    strcpy(s, "Board init failed, exit.\n");
    sub_47AB4(3, s, 0);
    return c;
  }
  sub_38064();
  v6 = &v70;
  memset((void *)(dword_1AEA80 + 10116), 0, 0x40u);
  v7 = 8 - (_DWORD)s;
  memset(s, 0, 0x1380u);
  v8 = 0;
  v9 = 4 - (_DWORD)s;
  do
  {
    while ( *(_DWORD *)(dword_A0D68 + 4 * v8 + 4) != 1 )
    {
LABEL_17:
      ++v8;
      v6 += 156;
      if ( v8 == 16 )
        goto LABEL_25;
    }
    if ( sub_37D44(v8) == 1 )
    {
      v46 = (int)v6 + v7 + dword_1AEA80 - 4;
      v47 = (int)v6 + v9 + dword_1AEA80 + 312;
      v48 = v6;
      do
      {
        v49 = *(_DWORD *)(v46 + 4);
        v46 += 4;
        *((_DWORD *)v48 + 1) = v49;
        v48 += 2;
      }
      while ( v46 != v47 );
      goto LABEL_17;
    }
    v10 = sub_3A3C4(v8, dword_1AEA80 + 4);
    v11 = dword_1AEA80;
    v12 = *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 72);
    if ( v10 <= v12 )
    {
      v50 = (int)v6 + v7 + dword_1AEA80 - 4;
      v51 = (int)v6 + v9 + dword_1AEA80 + 312;
      v52 = v6;
      do
      {
        v53 = *(_DWORD *)(v50 + 4);
        v50 += 4;
        *((_DWORD *)v52 + 1) = v53;
        v52 += 2;
      }
      while ( v50 != v51 );
      goto LABEL_17;
    }
    v13 = v6;
    while ( 1 )
    {
      *((_DWORD *)v13 + 1) = v12;
      v13 += 2;
      if ( v13 == v6 + 156 )
        break;
      v12 = *(_DWORD *)(*(_DWORD *)v11 + 72);
    }
    ++v8;
    v6 += 156;
  }
  while ( v8 != 16 );
LABEL_25:
  sub_30CAC((int)s, (unsigned __int8)byte_A0D79, dword_9C298, *(unsigned __int8 *)(*(_DWORD *)dword_1AEA80 + 88));
  c = sub_3AA80();
  if ( c )
    return c;
  while ( 2 )
  {
    if ( !sub_37F50() )
      goto LABEL_38;
    if ( a1 )
    {
      v14 = 0;
      for ( j = 0; j != 16; ++j )
      {
        while ( *(_DWORD *)(*v1 + 4 * j + 4) != 1 || sub_37D44(j) != 1 )
        {
          if ( ++j == 16 )
            goto LABEL_37;
        }
        v16 = sub_3A3C4(j, dword_1AEA80 + 5060);
        if ( (unsigned int)dword_9E31C > 3 )
        {
          snprintf(
            s,
            0x800u,
            "chain = %d, freq_avg = %d, freq_threshold = %d\n",
            j,
            v16,
            *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 72));
          sub_47AB4(3, s, 0);
        }
        if ( v16 > *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 72) )
          v14 = 1;
      }
LABEL_37:
      if ( v14 )
      {
LABEL_38:
        if ( (unsigned int)dword_9E31C > 3 )
        {
          v17 = 1;
          goto LABEL_40;
        }
        return c;
      }
    }
    v17 = 1;
    for ( k = 0; k != 16; ++k )
    {
      while ( 1 )
      {
        v55 = 4 * k;
        if ( *(_DWORD *)(*v1 + 4 * k + 4) == 1 && sub_37D44(k) == 1 )
          break;
        if ( ++k == 16 )
          goto LABEL_98;
      }
      v56 = *(_DWORD *)(dword_1AEA80 + v55 + 10116);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(
          s,
          0x800u,
          "chain = %d, grade_curr = %d, is_grade_curr_done = %d\n",
          k,
          *(_DWORD *)(dword_1AEA80 + v55 + 10052),
          *(_DWORD *)(dword_1AEA80 + v55 + 10116));
        sub_47AB4(3, s, 0);
        v56 = *(_DWORD *)(dword_1AEA80 + 4 * (k + 2528) + 4);
      }
      if ( !v56 )
        v17 = 0;
    }
LABEL_98:
    if ( (unsigned int)dword_9E31C > 3 )
    {
LABEL_40:
      snprintf(s, 0x800u, "is_single_grade_done = %d\n", v17);
      sub_47AB4(3, s, 0);
    }
    if ( v17 )
      return c;
    do
    {
      while ( 1 )
      {
        v18 = 4 * v17;
        if ( *(_DWORD *)(*v1 + 4 * v17 + 4) == 1 && sub_37D44(v17) == 1 )
        {
          v19 = dword_1AEA80 + v18 + 0x2000;
          v20 = *(_DWORD *)(dword_1AEA80 + v18 + 10116);
          if ( !v20 )
            break;
        }
        if ( ++v17 == 16 )
          goto LABEL_63;
      }
      v21 = *(_DWORD *)dword_1AEA80;
      v22 = *(_DWORD *)(v19 + 1860);
      v23 = (int *)(dword_1AEA80 + 312 * v17 + 5056);
      v24 = dword_1AEA80 + 312 + 312 * v17;
      v25 = dword_1AEA80 + 312 * v17;
      v26 = *(_DWORD *)dword_1AEA80 + 78 * v17 + 739;
      do
      {
        v28 = *(_DWORD *)(v25 + 4);
        v25 += 4;
        v27 = v28;
        v23[1] = v28;
        ++v23;
        v29 = *(unsigned __int8 *)++v26;
        if ( v29 > v22 )
        {
          v20 = v27 + *(_DWORD *)(v21 + 80);
          *v23 = v20;
        }
      }
      while ( v24 != v25 );
      if ( *(_BYTE *)(v21 + 89) )
        sub_306F0(v20, 1);
      sub_74E08((int)&v69, v68, 0);
      v71 = v68[0];
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(
          s,
          0x800u,
          "chain = %d, grade_curr = %d, freq_target = %d\n",
          v17,
          *(_DWORD *)(dword_1AEA80 + 4 * (v17 + 2512) + 4),
          v20);
        sub_47AB4(3, s, 0);
      }
      v30 = 0;
      v64 = (char *)v1;
      v63 = dword_1AEA80;
      while ( ++v30 != 6 )
      {
        while ( 1 )
        {
          v31 = *(_DWORD *)v63;
          if ( v30 / *(_DWORD *)(*(_DWORD *)v63 + 108) <= *(_DWORD *)(v63 + 4 * (v17 + 2512) + 4) )
            break;
          v32 = 0;
          while ( 1 )
          {
            v33 = 3 * v32++;
            sub_1B1F4(
              v17,
              0,
              (unsigned __int8)(3 * *(_DWORD *)(v31 + 8 * (v30 + 2 * v33) + 120)),
              (unsigned __int8)byte_A0D79,
              v69,
              v70);
            if ( v32 == 13 )
              break;
            v31 = *(_DWORD *)dword_1AEA80;
          }
          ++v30;
          usleep((__useconds_t)&unk_F4240);
          v63 = dword_1AEA80;
          if ( v30 == 6 )
            goto LABEL_62;
        }
      }
LABEL_62:
      v34 = v17++;
      v1 = (int *)v64;
      sub_3A79C(v34, v63 + 5060, 1);
    }
    while ( v17 != 16 );
LABEL_63:
    v35 = sub_3A458(255, dword_1AEA80 + 5060);
    sub_22E9C(v35, 8, 20);
    result = sub_3AA80();
    v36 = result;
    if ( !result )
    {
      v67 = sub_3A520(255, dword_1AEA80 + 5060);
      sub_39138((int)&v67);
      v37 = sub_37770();
      v38 = *v1;
      v39 = v37;
      do
      {
        while ( *(_DWORD *)(v38 + 4 * v36 + 4) != 1 )
        {
          if ( ++v36 == 16 )
            goto LABEL_71;
        }
        if ( sub_37D44(v36) == 1 && !*(_DWORD *)(dword_1AEA80 + 4 * (v36 + 2528) + 4) )
          sub_3883C(v36, v39);
        ++v36;
        v38 = *v1;
      }
      while ( v36 != 16 );
LABEL_71:
      v40 = 0;
LABEL_74:
      v41 = 4 * v40;
      if ( *(_DWORD *)(v38 + 4 * v40 + 4) == 1
        && sub_37D44(v40) == 1
        && !*(_DWORD *)(dword_1AEA80 + 4 * (v40 + 2528) + 4) )
      {
        v42 = *(float *)(*(_DWORD *)dword_1AEA80 + 96);
        if ( sub_3816C(v40) )
        {
          v43 = dword_1AEA80 + v41 + 0x2000;
          v44 = (unsigned int)dword_9E31C > 3;
          v45 = *(_DWORD *)(dword_1AEA80 + v41 + 10052);
          *(_DWORD *)(v43 + 1924) = 1;
          *(_DWORD *)(v43 + 1860) = v45 + 1;
          if ( !v44 )
            goto LABEL_79;
          snprintf(s, 0x800u, "Inc grade: chain = %d, grade_curr = %d\n", v40, v45 + 1);
LABEL_105:
          sub_47AB4(3, s, 0);
        }
        else
        {
          v57 = dword_1AEA80;
          v58 = dword_1AEA80 + 312 * v40;
          v59 = dword_1AEA80 + 312 * v40 + 5056;
          v60 = dword_1AEA80 + 312 + 312 * v40;
          do
          {
            v61 = *(_DWORD *)(v59 + 4);
            v59 += 4;
            *(_DWORD *)(v58 + 4) = v61;
            v58 += 4;
          }
          while ( v58 != v60 );
          v62 = v57 + v41;
          *(_DWORD *)(v62 + 4996) = 1;
          if ( (unsigned int)dword_9E31C > 3 )
          {
            snprintf(
              s,
              0x800u,
              "Update freq result of high grade, chain = %d, grade_curr = %d.\n",
              v40,
              *(_DWORD *)(v62 + 10052));
            sub_47AB4(3, s, 0);
            if ( (unsigned int)dword_9E31C > 3 )
            {
              snprintf(
                s,
                0x800u,
                "Update high grade freq: chain = %d, grade_curr = %d\n",
                v40,
                *(_DWORD *)(dword_1AEA80 + 4 * (v40 + 2512) + 4));
              goto LABEL_105;
            }
          }
        }
LABEL_79:
        sub_38ECC(v40);
        if ( v42 > *(float *)(dword_1AEA80 + v41 + 10180) )
          *(float *)(dword_1AEA80 + v41 + 10180) = v42;
        if ( sub_3A5E8(v40) )
          sub_37BD4(v40, 2);
      }
      if ( ++v40 == 16 )
        continue;
      v38 = *v1;
      goto LABEL_74;
    }
    return result;
  }
}
// 9C298: using guessed type int dword_9C298;
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// A0D79: using guessed type char byte_A0D79;
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003B4EC) --------------------------------------------------------
void sub_3B4EC()
{
  char v0[2048]; // [sp+0h] [bp-800h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v0, "[DEBUG] PM grade exit.\n");
    sub_47AB4(4, v0, 0);
    if ( (unsigned int)dword_9E31C > 4 )
    {
      strcpy(v0, "[DEBUG] Free memory for pm grade.\n");
      sub_47AB4(4, v0, 0);
    }
  }
  if ( dword_1AEA80 )
  {
    free((void *)dword_1AEA80);
    dword_1AEA80 = 0;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003B5A8) --------------------------------------------------------
int __fastcall sub_3B5A8(int a1)
{
  return *(_DWORD *)(dword_1AEA80 + 4 * (a1 + 1248) + 4);
}
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003B5C4) --------------------------------------------------------
int __fastcall sub_3B5C4(int a1, int a2)
{
  int v4; // r2
  int v5; // r3
  int result; // r0
  int v7; // t1
  char v8[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    snprintf(v8, 0x800u, "[DEBUG] Get freq result, chain = %d.\n", a1);
    sub_47AB4(4, v8, 0);
  }
  v4 = a2 - 4;
  v5 = dword_1AEA80 + 312 * a1;
  result = dword_1AEA80 + 312 + 312 * a1;
  do
  {
    v7 = *(_DWORD *)(v5 + 4);
    v5 += 4;
    *(_DWORD *)(v4 + 4) = v7;
    v4 += 4;
  }
  while ( v5 != result );
  return result;
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003B658) --------------------------------------------------------
int __fastcall sub_3B658(int a1)
{
  return dword_1AEA80 + 4 * (a1 + 2544);
}
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003B674) --------------------------------------------------------
void sub_3B674()
{
  unsigned int v0; // r2
  int v1; // r4
  int v2; // r12
  int v3; // r3
  char *v4; // r12
  char *v5; // r12
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v0 = dword_9E31C;
  if ( (unsigned int)dword_9E31C > 3 )
  {
    snprintf(s, 0x800u, "%-40s : %d\n", "voltage", **(_DWORD **)dword_1AEA80);
    sub_47EC8(3, s, 0);
    v0 = dword_9E31C;
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-40s : ", "freq_base");
      sub_47EC8(3, s, 0);
      v0 = dword_9E31C;
    }
  }
  v1 = 0;
  do
  {
    while ( 1 )
    {
      v2 = 4 * v1;
      if ( *(_DWORD *)(dword_A0D68 + 4 * v1 + 4) == 1 && v0 > 3 )
        break;
      if ( ++v1 == 16 )
        goto LABEL_7;
    }
    v3 = v1++;
    snprintf(s, 0x800u, "[%d] = %d ", v3, *(_DWORD *)(*(_DWORD *)dword_1AEA80 + v2 + 4));
    sub_47EC8(3, s, 0);
    v0 = dword_9E31C;
  }
  while ( v1 != 16 );
LABEL_7:
  if ( v0 > 3 )
  {
    strcpy(s, "\n");
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-40s : %d\n", "freq_threshold", *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 68));
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      snprintf(s, 0x800u, "%-40s : %d\n", "freq_serial_threshold", *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 72));
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        goto LABEL_21;
      snprintf(s, 0x800u, "%-40s : %d\n", "freq_diff_threshold", *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 76));
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C <= 3 )
        return;
      snprintf(s, 0x800u, "%-40s : %d\n", "freq_step", *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 80));
      sub_47EC8(3, s, 0);
    }
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_26;
    snprintf(s, 0x800u, "%-40s : %d\n", "freq_bad_asic_dec", *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 84));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    v4 = "true";
    if ( !*(_BYTE *)(*(_DWORD *)dword_1AEA80 + 88) )
      v4 = "false";
    snprintf(s, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol", v4);
    sub_47EC8(3, s, 0);
LABEL_21:
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_29;
    v5 = "true";
    if ( !*(_BYTE *)(*(_DWORD *)dword_1AEA80 + 89) )
      v5 = "false";
    snprintf(s, 0x800u, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v5);
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %d\n", "is_board_init_with_power_off", *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 92));
    sub_47EC8(3, s, 0);
LABEL_26:
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_32;
    snprintf(s, 0x800u, "%-40s : %.4f\n", "hw_threshold", *(float *)(*(_DWORD *)dword_1AEA80 + 96));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %.2f\n", "nonce_rate_threshold", *(float *)(*(_DWORD *)dword_1AEA80 + 100));
    sub_47EC8(3, s, 0);
LABEL_29:
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %.2f\n", "nonce_rate_dec_threshold", *(float *)(*(_DWORD *)dword_1AEA80 + 104));
    sub_47EC8(3, s, 0);
    if ( (unsigned int)dword_9E31C <= 3 )
      return;
    snprintf(s, 0x800u, "%-40s : %d\n", "pm_grade_step", *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 108));
    sub_47EC8(3, s, 0);
LABEL_32:
    if ( (unsigned int)dword_9E31C > 3 )
    {
      snprintf(s, 0x800u, "%-40s : %d\n", "pm_grade_count", *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 112));
      sub_47EC8(3, s, 0);
    }
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003BBE8) --------------------------------------------------------
int __fastcall sub_3BBE8(int a1)
{
  _DWORD *v2; // r6
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 4 )
  {
    strcpy(v4, "[DEBUG] PM grade init.\n");
    sub_47AB4(4, v4, 0);
    if ( (unsigned int)dword_9E31C > 4 )
    {
      strcpy(v4, "[DEBUG] Allocate memory for pm grade.\n");
      sub_47AB4(4, v4, 0);
    }
  }
  v2 = (_DWORD *)dword_1AEA80;
  if ( dword_1AEA80 || (v2 = calloc(0x2804u, 1u), (dword_1AEA80 = (int)v2) != 0) )
  {
    *v2 = a1;
    sub_3B674();
    return 0;
  }
  else
  {
    sub_31794(13, 255);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v4, "Fail to allocate memory for pm grade context.\n");
      sub_47AB4(3, v4, 0);
    }
    return -1;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003BD34) --------------------------------------------------------
int sub_3BD34()
{
  int **v0; // r9
  int v1; // r7
  int v2; // r8
  int v3; // lr
  int v4; // r2
  int v5; // t1
  int v6; // r12
  unsigned int v7; // r3
  int v8; // r0
  int v9; // r1
  int i; // r7
  bool v12; // zf
  int v13; // r1
  int v14; // r0
  int v15; // r8
  int v16; // r7
  unsigned int v17; // r0
  int v18; // r7
  unsigned int v19; // r10
  int v20; // r7
  int v21; // r8
  unsigned int v22; // r2
  int v23; // r0
  int v24; // r3
  int v25; // t1
  int v26; // lr
  unsigned int v27; // r1
  int j; // r7
  int v29; // r8
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( (unsigned int)dword_9E31C > 3 )
  {
    strcpy(s, "Do freq tuning PM grade.\n");
    sub_47AB4(3, s, 0);
  }
  v0 = (int **)dword_1AEA80;
  v1 = 1;
  v2 = dword_A0D68;
  v3 = 0;
  v4 = dword_1AEA80;
  do
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(v2 + 4);
      v2 += 4;
      if ( v5 == 1 )
        break;
      ++v3;
      v4 += 312;
      if ( v3 == 16 )
        goto LABEL_13;
    }
    v6 = (int)&(*v0)[v3];
    v7 = *(_DWORD *)(v6 + 4);
    if ( v7 >= (*v0)[17] )
    {
      v8 = 0;
    }
    else
    {
      v8 = (*v0)[21];
      v1 = 0;
    }
    v9 = v4 + 312;
    while ( 1 )
    {
      *(_DWORD *)(v4 + 4) = v7 - v8;
      v4 += 4;
      if ( v4 == v9 )
        break;
      v7 = *(_DWORD *)(v6 + 4);
    }
    ++v3;
    v4 = v9;
  }
  while ( v3 != 16 );
LABEL_13:
  if ( v1 )
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "Freq is already enough of all chain, exit.\n");
      sub_47AB4(3, s, 0);
    }
    return 0;
  }
  else
  {
    sub_1A0F0(**v0);
    memcpy((void *)(dword_1AEA80 + 5060), (const void *)(dword_1AEA80 + 4), 0x1380u);
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(s, "\n");
      sub_47EC8(3, s, 0);
      if ( (unsigned int)dword_9E31C > 3 )
      {
        strcpy(s, ">>>> Do PM grade tuning parallel.\n");
        sub_47AB4(3, s, 0);
      }
    }
    for ( i = 0; i != 16; ++i )
    {
      while ( *(_DWORD *)(dword_A0D68 + 4 * i + 4) == 1 )
      {
        v12 = sub_3A5E8(i) == 0;
        v13 = 2;
        v14 = i;
        if ( v12 )
        {
          v13 = 1;
          v14 = i;
        }
        ++i;
        sub_37BD4(v14, v13);
        if ( i == 16 )
          goto LABEL_24;
      }
    }
    do
    {
LABEL_24:
      if ( !sub_37F50() )
        goto LABEL_39;
      v15 = 0;
      v16 = 0;
      do
      {
        while ( 1 )
        {
          if ( *(_DWORD *)(dword_A0D68 + 4 * v16 + 4) == 1 && sub_37D44(v16) == 1 )
          {
            v17 = sub_3A3C4(v16, dword_1AEA80 + 5060);
            if ( v17 >= *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 72) )
              v15 = 1;
            if ( (unsigned int)dword_9E31C > 3 )
              break;
          }
          if ( ++v16 == 16 )
            goto LABEL_33;
        }
        snprintf(
          s,
          0x800u,
          "chain = %d, freq_avg = %d, freq_serial_threshold = %d\n",
          v16++,
          v17,
          *(_DWORD *)(*(_DWORD *)dword_1AEA80 + 72));
        sub_47AB4(3, s, 0);
      }
      while ( v16 != 16 );
LABEL_33:
      if ( (unsigned int)dword_9E31C > 3 )
      {
        snprintf(s, 0x800u, "is_need_serial = %d\n", v15);
        sub_47AB4(3, s, 0);
      }
      if ( v15 )
      {
LABEL_39:
        if ( !sub_383C0() )
        {
          if ( (unsigned int)dword_9E31C > 3 )
          {
            strcpy(s, "\n");
            sub_47EC8(3, s, 0);
            if ( (unsigned int)dword_9E31C > 3 )
            {
              strcpy(s, ">>>> Do PM grade tuning serial.\n");
              sub_47AB4(3, s, 0);
            }
          }
          for ( j = 0; j != 16; ++j )
          {
            if ( *(_DWORD *)(dword_A0D68 + 4 * j + 4) == 1 && sub_37D44(j) == 1 )
              sub_37BD4(j, 0);
          }
          v29 = 0;
          while ( sub_37EF8() )
          {
            sub_37FA8(2u);
            if ( (unsigned int)dword_9E31C > 3 )
            {
              strcpy(s, "\n");
              sub_47EC8(3, s, 0);
              if ( (unsigned int)dword_9E31C > 3 )
              {
                snprintf(s, 0x800u, ">>>> serial round %d:\n", v29++);
                sub_47AB4(3, s, 0);
              }
            }
            while ( sub_37F50() )
            {
              v18 = sub_3AAA8(0);
              if ( v18 )
              {
                if ( (unsigned int)dword_9E31C <= 3 )
                  goto LABEL_38;
                strcpy(s, "Serial tuning failed, exit.\n");
                sub_47AB4(3, s, 0);
                v19 = dword_9E31C;
                goto LABEL_58;
              }
            }
          }
        }
        v19 = dword_9E31C;
        v20 = 0;
        v21 = 4;
        do
        {
          if ( *(_DWORD *)(dword_A0D68 + 4 * v20 + 4) == 1 )
          {
            v22 = 0;
            v23 = dword_1AEA80 + v21 - 4;
            v24 = v23;
            do
            {
              v25 = *(_DWORD *)(v24 + 4);
              v24 += 4;
              v22 += v25;
            }
            while ( v24 != v21 - 4 + dword_1AEA80 + 312 );
            v26 = *(_DWORD *)dword_1AEA80 + 4 * v20;
            v27 = *(_DWORD *)(v26 + 4);
            if ( v22 < v27 )
            {
              while ( 1 )
              {
                *(_DWORD *)(v23 + 4) = v27;
                v23 += 4;
                if ( v24 == v23 )
                  break;
                v27 = *(_DWORD *)(v26 + 4);
              }
              if ( v19 > 3 )
              {
                snprintf(
                  s,
                  0x800u,
                  "Back to conf freq, chain = %d, pm_freq_avg = %d, conf_freq = %d.\n",
                  v20,
                  v22,
                  *(_DWORD *)(v26 + 4));
                sub_47AB4(3, s, 0);
                v19 = dword_9E31C;
              }
            }
          }
          ++v20;
          v21 += 312;
        }
        while ( v20 != 16 );
        v18 = 0;
        goto LABEL_58;
      }
      v18 = sub_3AAA8(1);
    }
    while ( !v18 );
    if ( (unsigned int)dword_9E31C <= 3 )
      goto LABEL_38;
    strcpy(s, "Parallel tuning failed, exit.\n");
    sub_47AB4(3, s, 0);
    v19 = dword_9E31C;
LABEL_58:
    if ( v19 > 3 )
    {
      strcpy(s, "Dump PM grade tuning result:\n");
      sub_47AB4(3, s, 0);
    }
LABEL_38:
    sub_3A79C(255, dword_1AEA80 + 4, 0);
    return v18;
  }
}
// 9E31C: using guessed type int dword_9E31C;
// A0D68: using guessed type int dword_A0D68;
// 1AEA80: using guessed type int dword_1AEA80;

//----- (0003C398) --------------------------------------------------------
int __fastcall sub_3C398(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  _DWORD *v13; // r12
  int v14; // r3
  char v16[2048]; // [sp+0h] [bp-800h] BYREF

  pthread_mutex_lock(&stru_1AEA88);
  v13 = realloc((void *)dword_1AEAA4, 36 * (dword_1AEAA0 + 1));
  if ( v13 )
  {
    v13[9 * dword_1AEAA0] = a1;
    v13[9 * dword_1AEAA0 + 1] = a2;
    v13[9 * dword_1AEAA0 + 2] = a3;
    v13[9 * dword_1AEAA0 + 3] = a4;
    v13[9 * dword_1AEAA0 + 4] = a5;
    v13[9 * dword_1AEAA0 + 5] = a6;
    v13[9 * dword_1AEAA0 + 6] = a7;
    v13[9 * dword_1AEAA0 + 7] = a8;
    v14 = dword_1AEAA0++;
    v13[9 * v14 + 8] = a9;
    dword_1AEAA4 = (int)v13;
    return pthread_mutex_unlock(&stru_1AEA88);
  }
  else
  {
    if ( (unsigned int)dword_9E31C > 3 )
    {
      strcpy(v16, "realloc fail when register miner config\n");
      sub_47AB4(3, v16, 0);
    }
    return pthread_mutex_unlock(&stru_1AEA88);
  }
}
// 9E31C: using guessed type int dword_9E31C;
// 1AEAA0: using guessed type int dword_1AEAA0;
// 1AEAA4: using guessed type int dword_1AEAA4;

//----- (0003C4FC) --------------------------------------------------------
int __fastcall sub_3C4FC(int a1)
{
  int v1; // r7
  int v2; // r4
  int v3; // r6

  if ( !(a1 | (unsigned __int8)byte_1AEA84 ^ 1) )
    return 1;
  sub_3C6CC();
  pthread_mutex_lock(&stru_1AEA88);
  if ( dword_1AEAA0 <= 0 )
  {
LABEL_10:
    v1 = 0;
  }
  else
  {
    v2 = 0;
    v3 = 0;
    while ( 1 )
    {
      ++v3;
      sub_19720(*(_DWORD *)(dword_1AEAA4 + v2 + 4), *(_DWORD *)(dword_1AEAA4 + v2));
      v1 = sub_1942C();
      if ( v1 )
        break;
      sub_19750();
      v2 += 36;
      if ( v3 >= dword_1AEAA0 )
        goto LABEL_10;
    }
    sub_313F8(*(_DWORD *)(dword_1AEAA4 + v2 + 8));
    sub_3142C(*(_DWORD *)(dword_1AEAA4 + v2 + 12));
    sub_175E4(*(_DWORD *)(dword_1AEAA4 + v2 + 16));
    sub_36C54(*(_DWORD *)(dword_1AEAA4 + v2 + 20));
    sub_1A79C(*(_DWORD *)(dword_1AEAA4 + v2 + 24));
    sub_24848(*(_DWORD *)(dword_1AEAA4 + v2 + 28));
    sub_22A54(*(_DWORD *)(dword_1AEAA4 + v2 + 32));
    byte_1AEA84 = 1;
  }
  dword_1AEAA0 = 0;
  free((void *)dword_1AEAA4);
  dword_1AEAA4 = 0;
  pthread_mutex_unlock(&stru_1AEA88);
  return v1;
}
// 1AEA84: using guessed type char byte_1AEA84;
// 1AEAA0: using guessed type int dword_1AEAA0;
// 1AEAA4: using guessed type int dword_1AEAA4;

//----- (0003C620) --------------------------------------------------------
int __fastcall sub_3C620(int a1)
{
  int v1; // r4

  v1 = dword_9C5BC;
  return v1 * sub_772E8(a1, dword_9C5BC);
}
// 9C5BC: using guessed type int dword_9C5BC;

//----- (0003C640) --------------------------------------------------------
int sub_3C640()
{
  return sub_3C398(
           1,
           (int)&unk_1AEAA8,
           (int)&unk_9C5C8,
           (int)&dword_9C5BC,
           (int)&unk_9CA74,
           (int)&unk_9CA38,
           (int)&unk_1AEB68,
           (int)&unk_9CA34,
           (int)&unk_9CA30);
}
// 9C5BC: using guessed type int dword_9C5BC;

//----- (0003C6A4) --------------------------------------------------------
int __fastcall sub_3C6A4(int a1)
{
  int v1; // r4
  int v2; // r5

  v1 = dword_9CAE4;
  v2 = dword_9CAE0;
  return v1 + v2 * sub_772E8(a1 - dword_9CAE4, dword_9CAE0);
}
// 9CAE0: using guessed type int dword_9CAE0;
// 9CAE4: using guessed type int dword_9CAE4;

//----- (0003C6CC) --------------------------------------------------------
int sub_3C6CC()
{
  sub_3C398(
    1,
    (int)&unk_9CF54,
    (int)&unk_9CAEC,
    (int)&dword_9CAE0,
    (int)&unk_9D05C,
    (int)&unk_9D020,
    (int)&unk_9D01C,
    (int)&unk_9D018,
    (int)&unk_9D014);
  return sub_3C398(
           3,
           (int)&unk_9D4D4,
           (int)&unk_9D06C,
           (int)&dword_9CAE0,
           (int)&unk_9D05C,
           (int)&unk_9D718,
           (int)&unk_9D01C,
           (int)&unk_9D018,
           (int)&unk_9D714);
}
// 9CAE0: using guessed type int dword_9CAE0;

//----- (0003C770) --------------------------------------------------------
int __fastcall sub_3C770(unsigned int *a1, char *s)
{
  size_t v4; // r7
  _BYTE *v5; // r0
  char *v6; // r2
  unsigned int v7; // r1
  int v8; // r8
  unsigned int v9; // r3
  size_t v10; // r5
  char *v11; // r0

  v4 = strlen(s);
  v5 = (_BYTE *)a1[1];
  v6 = (char *)a1[2];
  v7 = *a1;
  v8 = v6 - v5;
  v9 = v6 - v5 + 12 + v4;
  if ( *a1 < v9 )
  {
    v10 = v7 + 0x20000;
    if ( v9 > v7 + 0x20000 )
      v10 = ((unsigned int)vcvts_n_f32_u32(v9, 0x10u) + 2) << 16;
    v11 = (char *)realloc(v5, v10);
    v6 = &v11[v8];
    *a1 = v10;
    a1[1] = (unsigned int)v11;
    a1[2] = (unsigned int)&v11[v8];
  }
  memcpy(v6, s, v4 + 1);
  a1[2] += v4;
  return 1;
}

//----- (0003C804) --------------------------------------------------------
int __fastcall sub_3C804(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // r12
  char *v5; // r1
  int result; // r0

  v4 = *(_BYTE **)(a1 + 4);
  if ( a4 )
  {
    LOBYTE(a4) = 0;
    LOWORD(v5) = -2332;
  }
  else
  {
    LOWORD(v5) = -2316;
  }
  HIWORD(v5) = 7;
  *(_DWORD *)(a1 + 8) = v4;
  *v4 = a4;
  *(_BYTE *)(a1 + 13) = a4;
  result = sub_3C770((unsigned int *)a1, v5);
  byte_1AEB6C = 1;
  byte_1AEB6D = 1;
  return result;
}
// 1AEB6C: using guessed type char byte_1AEB6C;
// 1AEB6D: using guessed type char byte_1AEB6D;

//----- (0003C850) --------------------------------------------------------
int __fastcall sub_3C850(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // r12
  char *v5; // r1
  int result; // r0

  v4 = *(_BYTE **)(a1 + 4);
  if ( a4 )
  {
    LOBYTE(a4) = 0;
    LOWORD(v5) = -2312;
  }
  else
  {
    LOWORD(v5) = -2292;
  }
  HIWORD(v5) = 7;
  *(_DWORD *)(a1 + 8) = v4;
  *v4 = a4;
  *(_BYTE *)(a1 + 13) = a4;
  result = sub_3C770((unsigned int *)a1, v5);
  byte_1AEB6C = 1;
  byte_1AEB6E = 1;
  return result;
}
// 1AEB6C: using guessed type char byte_1AEB6C;
// 1AEB6E: using guessed type char byte_1AEB6E;

//----- (0003C89C) --------------------------------------------------------
const char *__fastcall sub_3C89C(const char *s, int a2)
{
  const char *v2; // r5
  unsigned int v3; // r4
  const char *v5; // r2
  unsigned int v6; // r3
  int v7; // r6
  unsigned int v8; // t1
  unsigned int v9; // t1
  size_t v10; // r6
  char *v11; // r3
  char *v12; // r2
  char *v13; // r1
  unsigned int v14; // t1
  char *v15; // r2
  char *v16; // r1
  char sa[2048]; // [sp+10h] [bp-800h] BYREF

  v2 = s;
  v3 = *(unsigned __int8 *)s;
  if ( *s )
  {
    v5 = s;
    v6 = *(unsigned __int8 *)s;
    v7 = 0;
    while ( 1 )
    {
      if ( v6 == 61 )
        goto LABEL_11;
      if ( v6 <= 0x3D )
      {
        if ( v6 != 34 )
        {
          if ( v6 != 44 )
            goto LABEL_6;
          if ( a2 )
            goto LABEL_12;
LABEL_5:
          ++v7;
          goto LABEL_6;
        }
        if ( a2 )
          goto LABEL_5;
LABEL_6:
        v8 = *(unsigned __int8 *)++v5;
        v6 = v8;
        if ( !v8 )
          goto LABEL_13;
      }
      else
      {
        if ( v6 == 92 )
          goto LABEL_5;
        if ( v6 != 124 )
          goto LABEL_6;
LABEL_11:
        if ( !a2 )
          goto LABEL_5;
LABEL_12:
        v9 = *(unsigned __int8 *)++v5;
        v6 = v9;
        if ( !v9 )
        {
LABEL_13:
          if ( !v7 )
            return s;
          v10 = strlen(s) + v7 + 1;
          s = (const char *)malloc(v10);
          if ( !s )
          {
            snprintf(sa, 0x800u, "Failed to malloc escape buf %d in %s %s():%d", v10, "api.c", "escape_string", 836);
            sub_47AB4(3, sa, 1);
            sub_62EC0(1);
          }
          v11 = (char *)s;
          while ( 2 )
          {
            if ( !v3 )
            {
              *v11 = 0;
              return s;
            }
            if ( v3 != 61 )
            {
              if ( v3 <= 0x3D )
              {
                if ( v3 == 34 )
                {
                  v12 = v11 + 1;
                  if ( a2 )
                  {
                    v13 = v11++;
                    *v13 = 92;
                    v12 = v13 + 2;
                  }
                  *v11 = 34;
                  v11 = v12;
                  goto LABEL_24;
                }
                if ( v3 != 44 )
                  goto LABEL_35;
              }
              else
              {
                if ( v3 == 92 )
                {
                  *v11 = 92;
                  v11[1] = 92;
                  v11 += 2;
LABEL_24:
                  v14 = *(unsigned __int8 *)++v2;
                  v3 = v14;
                  continue;
                }
                if ( v3 != 124 )
                {
LABEL_35:
                  *v11++ = v3;
                  goto LABEL_24;
                }
              }
            }
            break;
          }
          v15 = v11 + 1;
          if ( !a2 )
          {
            v16 = v11++;
            *v16 = 92;
            v15 = v16 + 2;
          }
          *v11 = v3;
          v11 = v15;
          goto LABEL_24;
        }
      }
    }
  }
  return s;
}

//----- (0003CA70) --------------------------------------------------------
void sub_3CA70()
{
  JUMPOUT(0x3C960);
}
// 3CA74: control flows out of bounds to 3C960

//----- (0003CA78) --------------------------------------------------------
void __fastcall sub_3CA78(unsigned int *a1, char *s, int a3, _BYTE *a4)
{
  char *v6; // r5

  if ( *a4 )
  {
    if ( !a3 )
    {
      *a4 = 0;
      goto LABEL_5;
    }
    sub_3C770(a1, "{");
    *a4 = 0;
    v6 = (char *)sub_3C89C(s, 1);
  }
  else
  {
    if ( !a3 )
    {
LABEL_5:
      v6 = (char *)sub_3C89C(s, a3);
      sub_3C770(a1, "CMD=");
      sub_3C770(a1, v6);
      sub_3C770(a1, "|");
      if ( s == v6 )
        return;
      goto LABEL_6;
    }
    sub_3C770(a1, ",");
    v6 = (char *)sub_3C89C(s, 1);
  }
  sub_3C770(a1, "\"");
  sub_3C770(a1, v6);
  sub_3C770(a1, "\":[");
  if ( s != v6 )
LABEL_6:
    free(v6);
}

//----- (0003CB84) --------------------------------------------------------
bool __fastcall sub_3CB84(const struct sockaddr *a1, const char **a2, _BYTE *a3)
{
  char *v6; // r0
  int v7; // r7
  int v8; // r6
  unsigned __int8 *v9; // r0
  int v10; // r2
  int v11; // r1
  int v12; // r3
  int v13; // t1
  int v14; // lr
  int v15; // t1
  int v16; // t1
  int v18; // r5
  _DWORD buf[4]; // [sp+10h] [bp-34h] BYREF
  char s[36]; // [sp+20h] [bp-24h] BYREF

  v6 = (char *)malloc(0x2Eu);
  *a2 = v6;
  getnameinfo(a1, 0x80u, v6, 0x2Eu, 0, 0, 1u);
  if ( a1->sa_family == 2 )
  {
    sprintf(s, "::ffff:%s", *a2);
    inet_pton(10, s, buf);
  }
  else
  {
    inet_pton(10, *a2, buf);
  }
  *a3 = (*_ctype_toupper_loc())[82];
  if ( dword_1B0B20 )
  {
    if ( dword_1AEB74 > 0 )
    {
      v7 = 0;
      v8 = dword_1AEB70 + 15;
      while ( 2 )
      {
        v9 = (unsigned __int8 *)buf;
        v10 = v8 - 16;
        v11 = v8;
        while ( 1 )
        {
          v13 = *v9++;
          v12 = v13;
          v15 = *(unsigned __int8 *)++v11;
          v14 = v15;
          v16 = *(unsigned __int8 *)++v10;
          if ( v16 != (v12 & v14) )
            break;
          if ( v10 == v8 )
          {
            v18 = 1;
            *a3 = *(_BYTE *)(v8 + 17);
            return v18;
          }
        }
        ++v7;
        v8 += 36;
        if ( v7 != dword_1AEB74 )
          continue;
        break;
      }
    }
    return 0;
  }
  else
  {
    v18 = (unsigned __int8)byte_24633C;
    if ( !byte_24633C )
    {
      if ( !strcmp(*a2, "127.0.0.1") )
      {
        return 1;
      }
      else if ( !buf[0] && !buf[1] && !buf[2] )
      {
        return buf[3] == 0x1000000;
      }
    }
    return v18;
  }
}
// 1AEB70: using guessed type int dword_1AEB70;
// 1AEB74: using guessed type int dword_1AEB74;
// 1B0B20: using guessed type int dword_1B0B20;
// 24633C: using guessed type char byte_24633C;

//----- (0003CD2C) --------------------------------------------------------
int sub_3CD2C()
{
  struct addrinfo *v0; // r5
  struct addrinfo *i; // r3
  int v2; // r0
  int v3; // r11
  int *v4; // r0
  char *v5; // r0
  time_t v7; // r9
  int *v8; // r0
  char *v9; // r8
  int ai_family; // r3
  struct sockaddr *ai_addr; // r3
  int v12; // t1
  int v13; // r1
  int v14; // r2
  int v15; // r3
  size_t v16; // r0
  size_t v17; // r10
  int v18; // r6
  ssize_t v19; // r5
  _BOOL4 v20; // r10
  const char *v21; // r1
  socklen_t v22; // r1
  const char *v23; // r5
  int v24; // r0
  int *v25; // r0
  char *v26; // r0
  struct addrinfo *v27; // r5
  struct addrinfo *j; // r3
  int v29; // r0
  size_t v30; // r0
  ssize_t v31; // r5
  int *v32; // r0
  char *v33; // r0
  int *v34; // r0
  char *v35; // r0
  char *v36; // [sp+10h] [bp-88h]
  size_t n; // [sp+18h] [bp-80h]
  char *v38; // [sp+20h] [bp-78h]
  int fd; // [sp+24h] [bp-74h]
  char v40; // [sp+43h] [bp-55h] BYREF
  socklen_t addr_len; // [sp+44h] [bp-54h] BYREF
  const char *v42; // [sp+48h] [bp-50h] BYREF
  struct addrinfo *pai; // [sp+4Ch] [bp-4Ch] BYREF
  int optval; // [sp+50h] [bp-48h] BYREF
  char v45[12]; // [sp+54h] [bp-44h] BYREF
  char s[12]; // [sp+60h] [bp-38h] BYREF
  char serv[12]; // [sp+6Ch] [bp-2Ch] BYREF
  addrinfo req; // [sp+78h] [bp-20h] BYREF
  struct sockaddr v49[8]; // [sp+98h] [bp+0h] BYREF
  char v50[1016]; // [sp+118h] [bp+80h] BYREF
  int v51; // [sp+518h] [bp+480h] BYREF
  int v52; // [sp+51Ch] [bp+484h]
  int v53; // [sp+520h] [bp+488h]
  int v54; // [sp+524h] [bp+48Ch]
  int v55; // [sp+528h] [bp+490h]
  char v56[2052]; // [sp+918h] [bp+880h] BYREF

  strcpy(v45, "bmminer-");
  sprintf(s, "%d", dword_9EE48);
  memset(&req, 0, sizeof(req));
  if ( getaddrinfo(off_9EE54[0], s, &req, &pai) )
  {
    strcpy(v56, "Invalid API Multicast Address");
    sub_47AB4(3, v56, 1);
    sub_62EC0(1);
  }
  v0 = pai;
  if ( !pai )
  {
LABEL_17:
    freeaddrinfo(pai);
    strcpy(v56, "API mcast could not open socket");
    sub_47AB4(3, v56, 1);
    sub_62EC0(1);
  }
  for ( i = pai; ; i = pai )
  {
    v2 = socket(i->ai_family, 2, 0);
    if ( v2 > 0 )
    {
      v3 = v2;
      goto LABEL_9;
    }
    v0 = v0->ai_next;
    if ( !v0 )
      break;
  }
  v3 = v2;
  if ( v2 == -1 )
    goto LABEL_17;
LABEL_9:
  optval = 1;
  if ( setsockopt(v3, 1, 2, &optval, 4u) < 0 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      snprintf(
        v56,
        0x800u,
        "API mcast setsockopt SO_REUSEADDR failed (%s)%s",
        v5,
        " - API multicast listener will not be available");
      goto LABEL_14;
    }
    return close(v3);
  }
  v7 = time(0);
  while ( 1 )
  {
    if ( bind(v3, v0->ai_addr, v0->ai_addrlen) >= 0 )
    {
      ai_family = v0->ai_family;
      if ( ai_family == 2 )
      {
        v51 = 0;
        v52 = 0;
        v51 = *(_DWORD *)&v0->ai_addr->sa_data[2];
        if ( setsockopt(v3, 0, 35, &v51, 8u) >= 0 )
        {
LABEL_25:
          freeaddrinfo(pai);
          v36 = off_9EE50[0];
          v16 = strlen(off_9EE50[0]);
          v17 = v16 + 10;
          n = v16 + 9;
          v38 = (char *)malloc(v16 + 10);
          if ( !v38 )
          {
            strcpy(v56, "Failed to malloc mcast expect_code");
            sub_47AB4(3, v56, 1);
            sub_62EC0(1);
          }
          fd = -1;
          v18 = 0;
          snprintf(v38, v17, aSS_1, v45, v36);
          while ( 1 )
          {
            do
            {
              while ( 1 )
              {
                ++v18;
                sub_4A804();
                addr_len = 128;
                v19 = recvfrom(v3, v50, 0x3FFu, 0, v49, &addr_len);
                if ( v19 >= 0 )
                  break;
                if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
                {
                  v25 = _errno_location();
                  v26 = strerror(*v25);
                  snprintf(v56, 0x800u, "API mcast failed count=%d (%s) (%d)", v18, v26, v3);
                  sub_47AB4(7, v56, 0);
                }
              }
              v20 = sub_3CB84(v49, &v42, &v40);
              if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
              {
                v21 = "Ignored";
                if ( v20 )
                  v21 = "Accepted";
                snprintf(v56, 0x800u, "API mcast from %s - %s", v42, v21);
                sub_47AB4(7, v56, 0);
              }
            }
            while ( !v20 );
            v50[v19] = 0;
            v22 = addr_len;
            if ( v19 )
            {
              if ( v50[v19 - 1] == 10 )
                v50[--v19] = 0;
              getnameinfo(v49, v22, 0, 0, serv, 0xAu, 1u);
              if ( byte_1AECC5 )
              {
LABEL_58:
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
                {
                  snprintf(v56, 0x800u, "API mcast request rep=%d (%s) from [%s]:%s", v19, v50, v42, serv);
                  sub_47AB4(7, v56, 0);
                }
                if ( n < v19 && !memcmp(v50, v38, n) )
                  goto LABEL_42;
                if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
                {
                  strcpy(v56, "API mcast request was no good");
                  sub_47AB4(7, v56, 0);
                }
              }
              else if ( n < v19 && !memcmp(v50, v38, n) )
              {
LABEL_42:
                v23 = &v50[n];
                v24 = strtol(&v50[n], 0, 10);
                if ( (unsigned int)(v24 - 1) <= 0xFFFE )
                {
                  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
                  {
                    snprintf(v56, 0x800u, "API mcast request OK port %s=%d", v23, v24);
                    sub_47AB4(7, v56, 0);
                  }
                  if ( getaddrinfo(v42, v23, &req, &pai) )
                  {
                    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
                    {
                      snprintf(v56, 0x800u, "Invalid client address %s", v42);
                      goto LABEL_79;
                    }
                  }
                  else
                  {
                    v27 = pai;
                    if ( pai )
                    {
                      for ( j = pai; ; j = pai )
                      {
                        v29 = socket(j->ai_family, 2, 0);
                        if ( v3 > 0 )
                          break;
                        v27 = v27->ai_next;
                        if ( !v27 )
                          break;
                      }
                      fd = v29;
                    }
                    if ( fd == -1 )
                    {
                      freeaddrinfo(pai);
                      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
                      {
                        snprintf(v56, 0x800u, "API mcast could not open socket to client %s", v42);
LABEL_79:
                        sub_47AB4(3, v56, 0);
                      }
                    }
                    else
                    {
                      snprintf((char *)&v51, 0x400u, "cgm-FTW-%d-%s", dword_9EE5C, off_9EE4C);
                      v30 = strlen((const char *)&v51);
                      v31 = sendto(fd, &v51, v30 + 1, 0, v27->ai_addr, v27->ai_addrlen);
                      freeaddrinfo(pai);
                      if ( v31 < 0 )
                      {
                        if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
                        {
                          v32 = _errno_location();
                          v33 = strerror(*v32);
                          snprintf(v56, 0x800u, "API mcast send reply failed (%s) (%d)", v33, fd);
                          sub_47AB4(7, v56, 0);
                        }
                      }
                      else if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
                      {
                        snprintf(v56, 0x800u, "API mcast send reply (%s) succeeded (%d) (%d)", &v51, v31, fd);
                        sub_47AB4(7, v56, 0);
                      }
                      close(fd);
                    }
                  }
                }
                else if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
                {
                  snprintf(v56, 0x800u, "API mcast request ignored - invalid port (%s)", v23);
                  sub_47AB4(7, v56, 0);
                }
              }
            }
            else
            {
              getnameinfo(v49, addr_len, 0, 0, serv, 0xAu, 1u);
              if ( byte_1AECC5 )
                goto LABEL_58;
            }
          }
        }
        if ( !byte_244080 && !byte_1AECC4 )
          goto LABEL_110;
      }
      else
      {
        if ( ai_family != 10 )
          goto LABEL_25;
        ai_addr = v0->ai_addr;
        v12 = *(_DWORD *)&ai_addr->sa_data[6];
        ai_addr = (struct sockaddr *)((char *)ai_addr + 8);
        v13 = *(_DWORD *)&ai_addr->sa_data[2];
        v14 = *(_DWORD *)&ai_addr->sa_data[6];
        v15 = *(_DWORD *)&ai_addr->sa_data[10];
        v51 = v12;
        v52 = v13;
        v53 = v14;
        v54 = v15;
        v55 = 0;
        if ( setsockopt(v3, 41, 20, &v51, 0x14u) >= 0 )
          goto LABEL_25;
        if ( !byte_244080 && !byte_1AECC4 )
        {
LABEL_110:
          if ( dword_9E320 <= 2 )
            return close(v3);
        }
      }
      v34 = _errno_location();
      v35 = strerror(*v34);
      snprintf(v56, 0x800u, "API mcast join failed (%s)%s", v35, " - API multicast listener will not be available");
LABEL_14:
      sub_47AB4(3, v56, 0);
      return close(v3);
    }
    v8 = _errno_location();
    v9 = strerror(*v8);
    if ( time(0) - v7 > 61 )
      break;
    sub_4A804();
  }
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
  {
    snprintf(
      v56,
      0x800u,
      "API mcast bind to port %d failed (%s)%s",
      dword_9EE48,
      v9,
      " - API multicast listener will not be available");
    goto LABEL_14;
  }
  return close(v3);
}
// 9E320: using guessed type int dword_9E320;
// 9EE48: using guessed type int dword_9EE48;
// 9EE4C: using guessed type _UNKNOWN *off_9EE4C;
// 9EE50: using guessed type char *off_9EE50[3];
// 9EE54: using guessed type char *off_9EE54[2];
// 9EE5C: using guessed type int dword_9EE5C;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (0003D8E4) --------------------------------------------------------
void sub_3D8E4()
{
  JUMPOUT(0x3D054);
}
// 3D8E8: control flows out of bounds to 3D054

//----- (0003D8EC) --------------------------------------------------------
int __fastcall sub_3D8EC(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_4BD10("APIMcast");
  sub_3CD2C();
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}

//----- (0003D924) --------------------------------------------------------
int __fastcall sub_3D924(int result, int a2)
{
  int v2; // r4

  v2 = result;
  if ( !*(_BYTE *)(result + 13) )
  {
    if ( !a2 )
      return result;
    goto LABEL_3;
  }
  result = sub_3C770((unsigned int *)result, (char *)&word_7A848);
  *(_BYTE *)(v2 + 13) = 0;
  if ( a2 )
  {
LABEL_3:
    sub_3C770((unsigned int *)v2, ",\"id\":1}");
    return sub_3C770((unsigned int *)v2, (char *)&word_7A848);
  }
  return result;
}
// 7A848: using guessed type __int16 word_7A848;

//----- (0003D988) --------------------------------------------------------
void *__fastcall sub_3D988(char ***a1, char *s)
{
  char **v2; // r5
  size_t v5; // r0
  char *v6; // r7
  size_t v7; // r4
  unsigned int v8; // r1
  size_t v9; // r9
  char *v10; // r5
  void *result; // r0
  int v12; // r10
  char sa[2048]; // [sp+18h] [bp-800h] BYREF

  v2 = *a1;
  v5 = strlen(s);
  v6 = v2[1];
  v7 = v5;
  v8 = (unsigned int)v2[2];
  v9 = v5 + 1;
  v10 = *v2;
  if ( (unsigned int)&v6[v5 + 1] > v8 )
  {
    v12 = v5 + 4097 - (v9 & 0xFFF);
    v10 = (char *)realloc(v10, v8 + v12);
    **a1 = v10;
    if ( !v10 )
    {
      snprintf(
        sa,
        0x800u,
        "OOM buf siz=%d tot=%d ext=%d in %s %s():%d",
        v7,
        (*a1)[2],
        v12,
        "api.c",
        "add_item_buf",
        1176);
      sub_47AB4(3, sa, 1);
      sub_62EC0(1);
    }
    (*a1)[2] += v12;
  }
  result = memcpy(&v6[(_DWORD)v10], s, v9);
  (*a1)[1] += v7;
  return result;
}

//----- (0003DAA0) --------------------------------------------------------
void __fastcall sub_3DAA0(const char *a1, int a2, int a3, int a4)
{
  const char *v7; // r9
  size_t v8; // r0
  size_t v9; // r2
  char *v10; // r3
  signed int v11; // r5
  int v12; // r2
  int v13; // r7
  int v14; // r10
  _BOOL4 v15; // r3
  fd_set *p_tv_usec; // r3
  int v17; // r0
  ssize_t v18; // r0
  ssize_t v19; // r8
  int v20; // r0
  char *v21; // r0
  int v22; // [sp+Ch] [bp-898h]
  signed int v23; // [sp+10h] [bp-894h]
  struct timeval timeout; // [sp+18h] [bp-88Ch] BYREF
  fd_set writefds; // [sp+20h] [bp-884h] BYREF
  char s[2048]; // [sp+A0h] [bp-804h] BYREF

  v7 = a1;
  v8 = strlen(a1);
  v9 = v8;
  if ( a2 )
  {
    v9 = v8 + 1;
    *(_WORD *)&v7[v8] = 93;
  }
  if ( a4 )
  {
    strcpy((char *)&v7[v9], ",\"id\":1}");
    v9 = strlen(v7);
  }
  v23 = v9 + 1;
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    v10 = "";
    if ( v9 > 0xA )
      v10 = "...";
    snprintf(s, 0x800u, "API: send reply: (%d) '%.10s%s'", v23, v7, v10);
    sub_47AB4(7, s, 0);
  }
  v11 = v23;
  LOBYTE(v12) = a3 & 0x1F;
  if ( a3 <= 0 )
    v12 = -(-a3 & 0x1F);
  v13 = 0;
  v14 = 0;
  v22 = 1 << v12;
  while ( 1 )
  {
    v15 = v14 <= 4;
    if ( v11 <= 0 )
      v15 = 0;
    if ( !v15 )
      break;
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->__fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( &writefds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
    writefds.__fds_bits[a3 / 32] |= v22;
    v17 = select(a3 + 1, 0, &writefds, 0, &timeout);
    if ( v17 <= 0 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
      {
        snprintf(s, 0x800u, "API: send select failed (%d)", v17);
        sub_47AB4(4, s, 0);
      }
      return;
    }
    v18 = send(a3, v7, v11, 0);
    v19 = v18;
    ++v13;
    if ( v18 < 0 )
    {
      v20 = *_errno_location();
      if ( v20 != 11 )
      {
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
        {
          v21 = strerror(v20);
          snprintf(s, 0x800u, "API: send (%d:%d) failed: %s", v23, v23 - v11, v21);
          sub_47AB4(4, s, 0);
        }
        return;
      }
LABEL_27:
      ++v14;
    }
    else if ( v13 == 1 )
    {
      if ( v11 != v18 )
      {
        if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
        {
          snprintf(s, 0x800u, "API: sent %d of %d first go", v18, v11);
          sub_47AB4(7, s, 0);
        }
        goto LABEL_26;
      }
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        snprintf(s, 0x800u, "API: sent all of %d first go", v11);
        sub_47AB4(7, s, 0);
      }
LABEL_47:
      v11 -= v19;
      v7 += v19;
    }
    else if ( v11 == v18 )
    {
      if ( !byte_1AECC5 || !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
        goto LABEL_47;
      snprintf(s, 0x800u, "API: sent all of remaining %d (sendc=%d)", v11, v13);
      v11 -= v19;
      sub_47AB4(7, s, 0);
      v7 += v19;
    }
    else
    {
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        snprintf(s, 0x800u, "API: sent %d of remaining %d (sendc=%d)", v18, v11, v13);
        sub_47AB4(7, s, 0);
      }
LABEL_26:
      v11 -= v19;
      v7 += v19;
      if ( !v19 )
        goto LABEL_27;
    }
  }
}
// 7A848: using guessed type __int16 word_7A848;
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (0003DFAC) --------------------------------------------------------
int __fastcall sub_3DFAC(unsigned __int8 **a1, int *a2)
{
  _BYTE *v2; // r2
  int v3; // r3
  bool v4; // zf
  _BYTE *v5; // r3
  _BYTE *v6; // r2
  _BYTE *v7; // r3
  int result; // r0

  v2 = *a1;
  v3 = **a1;
  if ( **a1 )
  {
    while ( v3 != 44 )
    {
      v4 = v3 == 92;
      v5 = v2;
      if ( v4 && v2[1] )
        v5 = v2 + 1;
      *a1 = v5 + 1;
      v6 = (_BYTE *)(*a2)++;
      *v6 = *v5;
      v2 = *a1;
      v3 = **a1;
      if ( !**a1 )
        goto LABEL_10;
    }
    *a1 = v2 + 1;
  }
LABEL_10:
  v7 = (_BYTE *)*a2;
  result = *a2 + 1;
  *a2 = result;
  *v7 = 0;
  return result;
}

//----- (0003E02C) --------------------------------------------------------
int __fastcall sub_3E02C(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  size_t v7; // r0
  void *v8; // r5
  unsigned __int8 *v10[2]; // [sp+4h] [bp-80Ch] BYREF
  void *v11; // [sp+Ch] [bp-804h] BYREF
  char v12[2048]; // [sp+10h] [bp-800h] BYREF

  v10[0] = a1;
  v7 = strlen((const char *)a1);
  v8 = malloc(v7 + 1);
  v11 = v8;
  if ( !v8 )
  {
    strcpy(v12, "Failed to malloc pooldetails buf");
    sub_47AB4(3, v12, 1);
    sub_62EC0(1);
  }
  *a2 = v8;
  sub_3DFAC(v10, (int *)&v11);
  if ( *v10[0] && (*a3 = v11, sub_3DFAC(v10, (int *)&v11), *v10[0]) )
  {
    *a4 = v11;
    sub_3DFAC(v10, (int *)&v11);
    return 1;
  }
  else
  {
    free(v8);
    return 0;
  }
}

//----- (0003E12C) --------------------------------------------------------
void __fastcall __noreturn sub_3E12C(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (0003E184) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_3E184(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 3E18C: positive sp value 814 has been found
// 3E18C: unbalanced stack, ignored a potential tail call

//----- (0003E190) --------------------------------------------------------
void __fastcall __noreturn sub_3E190(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (0003E1F4) --------------------------------------------------------
void __fastcall __noreturn sub_3E1F4(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (0003E258) --------------------------------------------------------
void __fastcall __noreturn sub_3E258(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (0003E2B0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_3E2B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 3E2B8: positive sp value 814 has been found
// 3E2B8: unbalanced stack, ignored a potential tail call

//----- (0003E2BC) --------------------------------------------------------
int sub_3E2BC()
{
  int v0; // r4
  int *v1; // r3
  int v2; // t1
  int v3; // r2

  if ( pthread_rwlock_rdlock(&stru_24638C) )
    sub_3E12C("numascs", 1381);
  if ( dword_245140 > 0 )
  {
    v0 = 0;
    v1 = (int *)dword_242FEC;
    do
    {
      v2 = *v1++;
      v3 = **(_DWORD **)(v2 + 4);
      if ( v3 == 2 || v3 == 3 )
        ++v0;
    }
    while ( v1 != (int *)(dword_242FEC + 4 * dword_245140) );
  }
  else
  {
    v0 = 0;
  }
  if ( pthread_rwlock_unlock(&stru_24638C) )
    sub_3E258("numascs", 1386);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 242FEC: using guessed type int dword_242FEC;
// 245140: using guessed type int dword_245140;
// 24638C: using guessed type pthread_rwlock_t stru_24638C;

//----- (0003E378) --------------------------------------------------------
int __fastcall sub_3E378(int a1)
{
  int v2; // r4
  int v3; // r2
  int v4; // r1
  int v5; // t1
  int v6; // r3

  if ( pthread_rwlock_rdlock(&stru_24638C) )
    sub_3E12C("ascdevice", 1395);
  if ( dword_245140 <= 0 )
  {
LABEL_11:
    if ( pthread_rwlock_unlock(&stru_24638C) )
      sub_3E258("ascdevice", 1403);
    off_9E444();
    return -1;
  }
  else
  {
    v2 = 0;
    v3 = 0;
    v4 = dword_242FEC - 4;
    while ( 1 )
    {
      v5 = *(_DWORD *)(v4 + 4);
      v4 += 4;
      v6 = **(_DWORD **)(v5 + 4);
      if ( v6 == 2 || v6 == 3 )
        ++v3;
      if ( v3 == a1 + 1 )
        break;
      if ( dword_245140 == ++v2 )
        goto LABEL_11;
    }
    if ( pthread_rwlock_unlock(&stru_24638C) )
      sub_3E258("ascdevice", 1408);
    off_9E444();
    return v2;
  }
}
// 9E444: using guessed type int (*off_9E444)();
// 242FEC: using guessed type int dword_242FEC;
// 245140: using guessed type int dword_245140;
// 24638C: using guessed type pthread_rwlock_t stru_24638C;

//----- (0003E48C) --------------------------------------------------------
int __fastcall sub_3E48C(int *a1)
{
  int v2; // r0
  int v3; // r6
  void **v4; // r4
  void **v5; // r5
  void **v6; // r0

  if ( pthread_mutex_lock(&stru_1AEB78) )
    sub_3E190("tidyup", 4500);
  v2 = *a1;
  byte_1AEB6C = 1;
  if ( v2 != -1 )
  {
    shutdown(v2, 2);
    close(*a1);
    *a1 = -1;
  }
  if ( dword_1AEB70 )
  {
    free((void *)dword_1AEB70);
    dword_1AEB70 = 0;
  }
  v3 = dword_1AEB90;
  if ( dword_1AEB90 )
  {
    v4 = (void **)dword_1AEB90;
    do
    {
      v5 = (void **)v4[2];
      free(*((void **)*v4 + 1));
      free(*v4);
      v6 = v4;
      v4 = v5;
      free(v6);
    }
    while ( (void **)v3 != v5 );
    dword_1AEB90 = 0;
  }
  if ( pthread_mutex_unlock(&stru_1AEB78) )
    sub_3E1F4("tidyup", 4521);
  return off_9E444();
}
// 9E444: using guessed type int (*off_9E444)();
// 1AEB6C: using guessed type char byte_1AEB6C;
// 1AEB70: using guessed type int dword_1AEB70;
// 1AEB90: using guessed type int dword_1AEB90;

//----- (0003E580) --------------------------------------------------------
void __noreturn sub_3E580()
{
  int *v0; // r0
  int *v1; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( !pthread_mutex_lock(&stru_1AEB78) )
  {
    if ( !pthread_mutex_unlock(&stru_1AEB78) )
    {
      off_9E444();
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        strcpy(s, "API: killing bmminer");
        sub_47AB4(7, s, 0);
      }
      sub_54D4C();
    }
    v1 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v1, "api.c", "quit_thread", 4818);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v0 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v0, "api.c", "quit_thread", 4817);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (0003E708) --------------------------------------------------------
int sub_3E708()
{
  int *v1; // r0
  int *v2; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_1AEB78) )
  {
    v1 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "api.c", "restart_thread", 4831);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock(&stru_1AEB78) )
  {
    v2 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v2, "api.c", "restart_thread", 4832);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  off_9E444();
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    strcpy(s, "API: restarting bmminer");
    sub_47AB4(7, s, 0);
  }
  sub_57A6C();
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (0003E88C) --------------------------------------------------------
int __fastcall sub_3E88C(unsigned int *a1, char **a2, int a3, int a4)
{
  int v7; // r5
  int v8; // r11
  int v9; // r5
  char ***v10; // r5
  char *v11; // r3
  unsigned __int8 *v12; // r3
  unsigned __int8 *v13; // r2
  char **v14; // r0
  int v15; // r4
  int v16; // r4
  char *v18; // r3
  char *v19; // r6
  char *v20; // r3
  char *v21; // r1
  char ***v22; // r0
  int *v23; // r0
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  int *v27; // r0
  int *v28; // r0
  int *v29; // r0
  int *v30; // r0
  const char *v32; // [sp+2Ch] [bp-848h]
  const char *v33; // [sp+2Ch] [bp-848h]
  char s[64]; // [sp+30h] [bp-844h] BYREF
  char v35[2052]; // [sp+70h] [bp-804h] BYREF

  v7 = *(_DWORD *)(dword_1AEB94 + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v7) )
  {
    v25 = _errno_location();
    snprintf(v35, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v25, "api.c", "print_data", 1193);
    sub_47AB4(3, v35, 1);
    sub_62EC0(1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 24)) )
  {
    v26 = _errno_location();
    snprintf(v35, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v26, "api.c", "print_data", 1193);
    sub_47AB4(3, v35, 1);
    sub_62EC0(1);
  }
  v8 = sub_46F04(dword_1AEB94, "api.c", "print_data", 1194);
  v9 = *(_DWORD *)(dword_1AEB94 + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v9 + 24)) )
  {
    v29 = _errno_location();
    snprintf(v35, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v29, "api.c", "print_data", 1195);
    sub_47AB4(3, v35, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v9) )
  {
    v30 = _errno_location();
    snprintf(v35, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v30, "api.c", "print_data", 1195);
    sub_47AB4(3, v35, 1);
    sub_62EC0(1);
  }
  off_9E444();
  v10 = (char ***)(v8 + 12);
  *(_DWORD *)(*(_DWORD *)(v8 + 12) + 4) = 0;
  if ( a4 )
    sub_3D988(v10, ",");
  if ( a3 )
  {
    sub_3D988(v10, "{");
    if ( !a2 )
      goto LABEL_26;
  }
  else if ( !a2 )
  {
    goto LABEL_19;
  }
  if ( a3 )
  {
LABEL_16:
    sub_3D988(v10, "\"");
    sub_3D988(v10, a2[1]);
    sub_3D988(v10, "\"");
    sub_3D988(v10, ":");
    v11 = *a2;
    switch ( (unsigned int)*a2 )
    {
      case 0u:
        v33 = a2[2];
        v19 = (char *)sub_3C89C(v33, 1);
        sub_3D988(v10, "\"");
        sub_3D988(v10, v19);
        sub_3D988(v10, "\"");
        v20 = (char *)v33;
        goto LABEL_56;
      case 1u:
      case 2u:
        sub_3D988(v10, "\"");
        v21 = a2[2];
        v22 = (char ***)(v8 + 12);
        goto LABEL_60;
      case 3u:
        goto LABEL_29;
      case 4u:
        goto LABEL_28;
      case 5u:
        goto LABEL_27;
      case 6u:
        goto LABEL_46;
      case 7u:
      case 8u:
        goto LABEL_11;
      case 9u:
        sub_3D988(v10, "\"");
        snprintf(s, 0x40u, "0x%08x", *(_DWORD *)a2[2]);
        v21 = s;
        v22 = (char ***)(v8 + 12);
        goto LABEL_60;
      case 0xAu:
        goto LABEL_44;
      case 0xBu:
        goto LABEL_43;
      case 0xCu:
        goto LABEL_42;
      case 0xDu:
        goto LABEL_41;
      case 0xEu:
        goto LABEL_38;
      case 0xFu:
        goto LABEL_37;
      case 0x10u:
        goto LABEL_36;
      case 0x11u:
      case 0x14u:
      case 0x15u:
        goto LABEL_35;
      case 0x12u:
        goto LABEL_34;
      case 0x13u:
        goto LABEL_33;
      case 0x16u:
      case 0x1Au:
        goto LABEL_32;
      case 0x17u:
        goto LABEL_31;
      case 0x18u:
        goto LABEL_30;
      case 0x19u:
        goto LABEL_45;
      default:
        goto LABEL_49;
    }
  }
  while ( 1 )
  {
    sub_3D988(v10, a2[1]);
    sub_3D988(v10, "=");
    v11 = *a2;
    switch ( (unsigned int)*a2 )
    {
      case 0u:
        v32 = a2[2];
        v19 = (char *)sub_3C89C(v32, 0);
        sub_3D988(v10, v19);
        v20 = (char *)v32;
LABEL_56:
        if ( v20 != v19 )
          free(v19);
        break;
      case 1u:
      case 2u:
        sub_3D988(v10, a2[2]);
        break;
      case 3u:
LABEL_29:
        snprintf(s, 0x40u, "%u", (unsigned __int8)*a2[2]);
        goto LABEL_12;
      case 4u:
LABEL_28:
        snprintf(s, 0x40u, "%d", *(__int16 *)a2[2]);
        goto LABEL_12;
      case 5u:
LABEL_27:
        snprintf(s, 0x40u, "%u", *(unsigned __int16 *)a2[2]);
        goto LABEL_12;
      case 6u:
LABEL_46:
        snprintf(s, 0x40u, "%d", *(_DWORD *)a2[2]);
        goto LABEL_12;
      case 7u:
      case 8u:
LABEL_11:
        snprintf(s, 0x40u, "%u", *(_DWORD *)a2[2]);
        goto LABEL_12;
      case 9u:
        snprintf(s, 0x40u, "0x%08x", *(_DWORD *)a2[2]);
        sub_3D988(v10, s);
        break;
      case 0xAu:
LABEL_44:
        snprintf(s, 0x40u, "%llu", *(_QWORD *)a2[2]);
        goto LABEL_12;
      case 0xBu:
LABEL_43:
        snprintf(s, 0x40u, "%lld", *(_QWORD *)a2[2]);
        goto LABEL_12;
      case 0xCu:
LABEL_42:
        snprintf(s, 0x40u, "%f", *(double *)a2[2]);
        goto LABEL_12;
      case 0xDu:
LABEL_41:
        snprintf(s, 0x40u, "%.0f", *(double *)a2[2]);
        goto LABEL_12;
      case 0xEu:
LABEL_38:
        v18 = "false";
        if ( *a2[2] )
          v18 = "true";
        snprintf(s, 0x40u, "%s", v18);
        goto LABEL_12;
      case 0xFu:
LABEL_37:
        snprintf(s, 0x40u, "%ld.%06ld", *(_DWORD *)a2[2], *((_DWORD *)a2[2] + 1));
        goto LABEL_12;
      case 0x10u:
LABEL_36:
        snprintf(s, 0x40u, "%lu", *(_DWORD *)a2[2]);
        goto LABEL_12;
      case 0x11u:
      case 0x14u:
      case 0x15u:
LABEL_35:
        snprintf(s, 0x40u, "%.2f", *(double *)a2[2]);
        goto LABEL_12;
      case 0x12u:
LABEL_34:
        snprintf(s, 0x40u, "%.4f", *(double *)a2[2]);
        goto LABEL_12;
      case 0x13u:
LABEL_33:
        snprintf(s, 0x40u, "%.2f", *(float *)a2[2]);
        goto LABEL_12;
      case 0x16u:
      case 0x1Au:
LABEL_32:
        snprintf(s, 0x40u, "%.3f", *(float *)a2[2]);
        goto LABEL_12;
      case 0x17u:
LABEL_31:
        snprintf(s, 0x40u, "%.15f", *(double *)a2[2]);
        goto LABEL_12;
      case 0x18u:
LABEL_30:
        snprintf(s, 0x40u, "%.8f", *(double *)a2[2]);
        goto LABEL_12;
      case 0x19u:
LABEL_45:
        snprintf(s, 0x40u, "%.4f", *(double *)a2[2] * 100.0);
LABEL_12:
        sub_3D988(v10, s);
        break;
      default:
LABEL_49:
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
        {
          snprintf(v35, 0x800u, "API: unknown2 data type %d ignored", v11);
          sub_47AB4(3, v35, 0);
        }
        if ( a3 )
        {
          sub_3D988(v10, "\"");
          v21 = "Unknown";
          v22 = (char ***)(v8 + 12);
LABEL_60:
          sub_3D988(v22, v21);
          sub_3D988(v10, "\"");
        }
        else
        {
          sub_3D988(v10, "Unknown");
        }
        break;
    }
    free(a2[1]);
    if ( !*((_BYTE *)a2 + 12) )
    {
      v12 = (unsigned __int8 *)a2[5];
      if ( v12 == (unsigned __int8 *)a2 )
        break;
      goto LABEL_15;
    }
    free(a2[2]);
    v12 = (unsigned __int8 *)a2[5];
    if ( v12 == (unsigned __int8 *)a2 )
      break;
LABEL_15:
    v13 = (unsigned __int8 *)a2[4];
    v14 = a2;
    a2 = (char **)v12;
    *((_DWORD *)v12 + 4) = v13;
    *((_DWORD *)v13 + 5) = v12;
    free(v14);
    sub_3D988(v10, ",");
    if ( a3 )
      goto LABEL_16;
  }
  free(a2);
  if ( !a3 )
  {
LABEL_19:
    sub_3D988(v10, "|");
    goto LABEL_20;
  }
LABEL_26:
  sub_3D988(v10, (char *)&word_836FC);
LABEL_20:
  sub_3C770(a1, **(char ***)(v8 + 12));
  v15 = *(_DWORD *)(dword_1AEB94 + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v15) )
  {
    v27 = _errno_location();
    snprintf(v35, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v27, "api.c", "print_data", 1365);
    sub_47AB4(3, v35, 1);
    sub_62EC0(1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v15 + 24)) )
  {
    v28 = _errno_location();
    snprintf(v35, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v28, "api.c", "print_data", 1365);
    sub_47AB4(3, v35, 1);
    sub_62EC0(1);
  }
  sub_47080(dword_1AEB94, v8, "api.c", "print_data", 1366);
  v16 = *(_DWORD *)(dword_1AEB94 + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v16 + 24)) )
  {
    v23 = _errno_location();
    snprintf(v35, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v23, "api.c", "print_data", 1367);
    sub_47AB4(3, v35, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v16) )
  {
    v24 = _errno_location();
    snprintf(v35, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v24, "api.c", "print_data", 1367);
    sub_47AB4(3, v35, 1);
    sub_62EC0(1);
  }
  off_9E444();
  return 0;
}
// 3E9B8: control flows out of bounds to 3E9BC
// 3EAEC: control flows out of bounds to 3EAF0
// 3EF38: conditional instruction was optimized away because r7.4!=0
// 3EF50: conditional instruction was optimized away because r7.4!=0
// 836FC: using guessed type __int16 word_836FC;
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AEB94: using guessed type int dword_1AEB94;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0003F3D8) --------------------------------------------------------
const char *__fastcall sub_3F3D8(int a1, const char *a2, int a3, const char *a4, char a5)
{
  char *v9; // r4
  int v10; // r3
  const char *result; // r0
  _DWORD *v12; // r0
  int v13; // r3
  _DWORD *v14; // r0
  int v15; // r1
  _DWORD *v16; // r2
  int v17; // r0
  _QWORD *v18; // r0
  __int64 v19; // r2
  _WORD *v20; // r0
  __int16 v21; // r3
  _BYTE *v22; // r0
  char v23; // r3
  _DWORD *v24; // r0
  int v25; // r3
  _BYTE *v26; // r0
  char v27; // r3
  size_t v28; // r5
  void *v29; // r0
  char v30[2052]; // [sp+0h] [bp-804h] BYREF

  v9 = (char *)malloc(0x18u);
  *((_DWORD *)v9 + 1) = _strdup(a2);
  if ( a1 )
    v10 = *(_DWORD *)(a1 + 16);
  else
    a2 = v9;
  if ( a1 )
  {
    *((_DWORD *)v9 + 5) = a1;
    a2 = (const char *)a1;
    *(_DWORD *)(a1 + 16) = v9;
    *((_DWORD *)v9 + 4) = v10;
  }
  *(_DWORD *)v9 = a3;
  if ( a1 )
    *(_DWORD *)(v10 + 20) = v9;
  else
    *((_DWORD *)v9 + 4) = v9;
  if ( !a1 )
    *((_DWORD *)v9 + 5) = v9;
  v9[12] = a5;
  if ( !a4 )
  {
    v9[12] = 0;
    a4 = "(null)";
    *(_DWORD *)v9 = 2;
LABEL_15:
    *((_DWORD *)v9 + 2) = a4;
    return a2;
  }
  if ( !a5 )
    goto LABEL_15;
  switch ( a3 )
  {
    case 0:
    case 1:
    case 2:
      v28 = strlen(a4) + 1;
      v29 = malloc(v28);
      *((_DWORD *)v9 + 2) = v29;
      memcpy(v29, a4, v28);
      return a2;
    case 3:
      v26 = malloc(4u);
      v27 = *a4;
      *((_DWORD *)v9 + 2) = v26;
      *v26 = v27;
      return a2;
    case 4:
    case 5:
      v20 = malloc(4u);
      v21 = *(_WORD *)a4;
      *((_DWORD *)v9 + 2) = v20;
      *v20 = v21;
      return a2;
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
      v12 = malloc(4u);
      v13 = *(_DWORD *)a4;
      *((_DWORD *)v9 + 2) = v12;
      *v12 = v13;
      result = a2;
      break;
    case 10:
    case 11:
      v18 = malloc(8u);
      v19 = *(_QWORD *)a4;
      *((_DWORD *)v9 + 2) = v18;
      *v18 = v19;
      return a2;
    case 12:
    case 13:
    case 15:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      v14 = malloc(8u);
      v15 = *((_DWORD *)a4 + 1);
      v16 = v14;
      v17 = *(_DWORD *)a4;
      *((_DWORD *)v9 + 2) = v16;
      *v16 = v17;
      v16[1] = v15;
      return a2;
    case 14:
      v22 = malloc(1u);
      v23 = *a4;
      *((_DWORD *)v9 + 2) = v22;
      *v22 = v23;
      return a2;
    case 19:
    case 22:
    case 26:
      v24 = malloc(4u);
      v25 = *(_DWORD *)a4;
      *((_DWORD *)v9 + 2) = v24;
      *v24 = v25;
      return a2;
    default:
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
      {
        snprintf(v30, 0x800u, "API: unknown1 data type %d ignored", a3);
        sub_47AB4(3, v30, 0);
      }
      *((_DWORD *)v9 + 2) = "Unknown";
      *(_DWORD *)v9 = 1;
      v9[12] = 0;
      return a2;
  }
  return result;
}
// 3F458: control flows out of bounds to 3F45C
// 3F428: variable 'v10' is possibly undefined
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0003F65C) --------------------------------------------------------
int __fastcall sub_3F65C(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5)
{
  int v8; // r1
  int *v9; // r2
  int v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r7
  const char *v14; // r1
  const char *v15; // r0
  const char *v16; // r0
  char **v17; // r0
  int result; // r0
  int v19; // r4
  const char *v20; // r0
  const char *v21; // r0
  int v22; // r0
  int v23; // r0
  char *v24; // r3
  int v25; // [sp+Ch] [bp-2010h] BYREF
  char v26[4]; // [sp+10h] [bp-200Ch] BYREF
  int v27; // [sp+14h] [bp-2008h] BYREF
  char s[8168]; // [sp+18h] [bp-2004h] BYREF

  v25 = a2;
  if ( a5 )
    sub_3C770(a1, "{\"STATUS\":[");
  v8 = dword_9D80C[0];
  if ( dword_9D80C[0] == 4 )
  {
LABEL_9:
    v11 = sub_3F3D8(0, "STATUS", 1, "F", 0);
    v12 = sub_3F3D8((int)v11, "When", 16, (const char *)&dword_1AEB98, 0);
    v27 = -1;
    v13 = sub_3F3D8((int)v12, "Code", 6, (const char *)&v27, 0);
    sprintf(s, "%d", v25);
    LOWORD(v14) = (unsigned __int16)"Msg";
    v15 = v13;
    goto LABEL_10;
  }
  if ( dword_9D810 != v25 )
  {
    v9 = dword_9D80C;
    v10 = 0;
    while ( 1 )
    {
      v8 = v9[4];
      ++v10;
      v9 += 4;
      if ( v8 == 4 )
        goto LABEL_9;
      if ( v9[1] == v25 )
        goto LABEL_13;
    }
  }
  v10 = 0;
LABEL_13:
  switch ( v8 )
  {
    case 2:
      v26[0] = 73;
      break;
    case 3:
      v26[0] = 83;
      break;
    case 1:
      v26[0] = 87;
      break;
    default:
      v26[0] = 69;
      break;
  }
  v19 = 4 * v10;
  v26[1] = 0;
  switch ( dword_9D80C[4 * v10 + 2] )
  {
    case 0:
    case 1:
    case 2:
    case 14:
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], a3);
      break;
    case 4:
      v22 = sub_3E2BC();
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], a3, v22 - 1);
      break;
    case 5:
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], dword_242F4C);
      break;
    case 6:
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], a3, dword_242F4C - 1);
      break;
    case 7:
      v23 = sub_3E2BC();
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], v23);
      break;
    case 8:
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], "command");
      break;
    case 9:
      snprintf(
        s,
        0x1FFFu,
        (const char *)dword_9D80C[v19 + 3],
        a3,
        *(_DWORD *)(*(_DWORD *)(dword_244048 + 4 * a3) + 164));
      break;
    case 10:
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], a4);
      break;
    case 11:
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], a3, a4);
      break;
    case 12:
      v24 = "false";
      if ( a3 )
        v24 = "true";
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], v24);
      break;
    case 13:
      snprintf(s, 0x1FFFu, (const char *)dword_9D80C[v19 + 3], a4, a3);
      break;
    default:
      strcpy(s, (const char *)dword_9D80C[v19 + 3]);
      break;
  }
  v20 = sub_3F3D8(0, "STATUS", 1, v26, 0);
  v21 = sub_3F3D8((int)v20, "When", 16, (const char *)&dword_1AEB98, 0);
  v15 = sub_3F3D8((int)v21, "Code", 6, (const char *)&v25, 0);
  LOWORD(v14) = -908;
LABEL_10:
  HIWORD(v14) = (unsigned int)"Msg" >> 16;
  v16 = sub_3F3D8((int)v15, v14, 0, s, 0);
  v17 = (char **)sub_3F3D8((int)v16, "Description", 0, off_9EE60, 0);
  result = sub_3E88C(a1, v17, a5, 0);
  if ( a5 )
    return sub_3C770(a1, (char *)&word_7A848);
  return result;
}
// 3F808: control flows out of bounds to 3F80C
// 7A848: using guessed type __int16 word_7A848;
// 9D80C: using guessed type int dword_9D80C[];
// 9D810: using guessed type int dword_9D810;
// 9EE60: using guessed type char *off_9EE60;
// 1AEB98: using guessed type int dword_1AEB98;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (0003FA78) --------------------------------------------------------
int __fastcall sub_3FA78(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3F65C(a1, 46, 0, 0, a4);
}

//----- (0003FA8C) --------------------------------------------------------
void __fastcall sub_3FA8C(unsigned int *a1, int a2, const char *a3, int a4)
{
  const char *v4; // r4
  FILE *v7; // r0
  FILE *v8; // r6
  char *v9; // r6
  char *v10; // r8
  char v11[4096]; // [sp+8h] [bp-1000h] BYREF

  v4 = a3;
  if ( !a3 || !*a3 )
  {
    v4 = v11;
    sub_53CD4(v11);
  }
  v7 = (FILE *)fopen64(v4, "w");
  v8 = v7;
  if ( v7 )
  {
    sub_53654(v7);
    fclose(v8);
    v9 = (char *)sub_3C89C(v4, a4);
    sub_3F65C(a1, 44, 0, (int)v9, a4);
    if ( v4 != v9 )
      free(v9);
  }
  else
  {
    v10 = (char *)sub_3C89C(v4, a4);
    sub_3F65C(a1, 43, 0, (int)v10, a4);
    if ( v4 != v10 )
      free(v10);
  }
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0003FB70) --------------------------------------------------------
int __fastcall sub_3FB70(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3F65C(a1, 124, 0, 0, a4);
}

//----- (0003FD78) --------------------------------------------------------
int __fastcall sub_3FD78(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  int v7; // r5
  void (*v8)(void); // r3
  unsigned int *v9; // r0
  int v10; // r2
  int v11; // r1
  int v12; // r0
  int v13; // r4
  int v14; // r0
  unsigned __int8 v16; // [sp+18h] [bp+18h]

  v7 = sub_3E2BC();
  if ( v7 )
  {
    if ( a3 && *a3 )
    {
      v12 = strtol(a3, 0, 10);
      v13 = v12;
      if ( (v7 <= v12) | ((unsigned int)v12 >> 31) )
      {
        v16 = a4;
        v10 = v12;
        v8 = 0;
        v9 = a1;
        v11 = 107;
      }
      else
      {
        v14 = sub_3E378(v12);
        if ( v14 < 0 )
        {
          v16 = a4;
          v8 = 0;
          v10 = v13;
          v9 = a1;
          v11 = 107;
        }
        else
        {
          v8 = *(void (**)(void))(*(_DWORD *)(sub_56518(v14) + 4) + 36);
          if ( v8 )
          {
            v8();
            v16 = a4;
            v8 = 0;
            v10 = v13;
            v9 = a1;
            v11 = 113;
          }
          else
          {
            v16 = a4;
            v10 = v13;
            v9 = a1;
            v11 = 114;
          }
        }
      }
    }
    else
    {
      v8 = 0;
      v16 = a4;
      v9 = a1;
      v10 = 0;
      v11 = 15;
    }
  }
  else
  {
    v16 = a4;
    v9 = a1;
    v8 = 0;
    v10 = 0;
    v11 = 105;
  }
  return sub_3F65C(v9, v11, v10, (int)v8, v16);
}

//----- (00040328) --------------------------------------------------------
int __fastcall sub_40328(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3F65C(a1, 102, 0, 0, a4);
}

//----- (0004033C) --------------------------------------------------------
int __fastcall sub_4033C(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v6; // r5
  char *v7; // r0
  char *v8; // r7
  int v9; // r8
  int v10; // r9
  int v11; // r10
  int v12; // r4
  bool v13; // zf
  const char *v15; // r3
  int v16; // r1
  unsigned __int8 v17; // [sp+20h] [bp+20h]

  if ( a3 && *a3 )
  {
    v6 = a1;
    v7 = strchr(a3, 44);
    v8 = v7;
    if ( v7 && (*v7 = 0, v7 != (char *)-1) && (v9 = (unsigned __int8)v7[1], v7[1]) )
    {
      if ( !strcasecmp(a3, "all") )
      {
        v10 = 0;
        v11 = 1;
      }
      else
      {
        v11 = strcasecmp(a3, "bestshare");
        if ( v11 )
        {
          v17 = a4;
          v15 = a3;
          a1 = v6;
          v16 = 95;
          return sub_3F65C(a1, v16, 0, (int)v15, v17);
        }
        v10 = 1;
      }
      v12 = LOBYTE((*_ctype_tolower_loc())[v9]);
      v13 = v12 == 116;
      if ( v12 != 116 )
        v13 = v12 == 102;
      v8[1] = v12;
      if ( v13 )
      {
        if ( v12 == 116 )
          sub_5658C();
        if ( v11 )
          sub_58E30();
        if ( v10 )
          sub_53C3C();
        v15 = "BestShare";
        if ( v11 )
          v15 = "All";
        v17 = a4;
        a1 = v6;
        if ( v12 == 116 )
          v16 = 96;
        else
          v16 = 97;
      }
      else
      {
        v15 = 0;
        v17 = a4;
        a1 = v6;
        v16 = 76;
      }
    }
    else
    {
      v15 = 0;
      v17 = a4;
      a1 = v6;
      v16 = 75;
    }
  }
  else
  {
    v15 = 0;
    v17 = a4;
    v16 = 94;
  }
  return sub_3F65C(a1, v16, 0, (int)v15, v17);
}

//----- (000404C8) --------------------------------------------------------
int __fastcall sub_404C8(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3F65C(a1, 88, 0, 0, a4);
}

//----- (000404DC) --------------------------------------------------------
int __fastcall sub_404DC(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v6; // r5
  char *v7; // r0
  unsigned int v8; // r0
  int v9; // r7
  int v10; // r3
  int v11; // r2
  int v12; // r1
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  if ( a3 && *a3 )
  {
    v6 = a1;
    v7 = strchr(a3, 44);
    if ( v7 )
    {
      *v7 = 0;
      v8 = strtol(v7 + 1, 0, 10);
      v9 = v8;
      if ( v8 > 0x270F )
      {
        v14 = a4;
        v10 = (int)a3;
        v11 = v8;
        v12 = 84;
        a1 = v6;
      }
      else
      {
        if ( !strcasecmp(a3, "queue") )
        {
          dword_9EE6C = v9;
        }
        else if ( !strcasecmp(a3, "scantime") )
        {
          dword_9ED98 = v9;
        }
        else
        {
          if ( strcasecmp(a3, "expiry") )
          {
            v14 = a4;
            v10 = (int)a3;
            v11 = 0;
            a1 = v6;
            v12 = 83;
            return sub_3F65C(a1, v12, v11, v10, v14);
          }
          dword_9ED9C = v9;
        }
        v14 = a4;
        v10 = (int)a3;
        v11 = v9;
        a1 = v6;
        v12 = 82;
      }
    }
    else
    {
      v14 = a4;
      v10 = (int)a3;
      v11 = 0;
      v12 = 86;
      a1 = v6;
    }
  }
  else
  {
    v10 = 0;
    v14 = a4;
    v11 = 0;
    v12 = 85;
  }
  return sub_3F65C(a1, v12, v11, v10, v14);
}
// 9ED98: using guessed type int dword_9ED98;
// 9ED9C: using guessed type int dword_9ED9C;
// 9EE6C: using guessed type int dword_9EE6C;

//----- (0004062C) --------------------------------------------------------
int __fastcall sub_4062C(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4)
{
  int v6; // r6
  unsigned int *v7; // r5
  int v8; // r1
  bool v9; // zf
  int v10; // r3
  _BOOL4 v12; // r2
  int v13; // r1
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  if ( a3 && *a3 )
  {
    v7 = a1;
    v6 = (unsigned __int8)*a3;
    v8 = LOBYTE((*_ctype_tolower_loc())[v6]);
    v9 = v8 == 116;
    if ( v8 != 116 )
      v9 = v8 == 102;
    *a3 = v8;
    v10 = !v9;
    if ( v9 )
    {
      v14 = a4;
      a1 = v7;
      byte_245154 = v8 == 116;
      v12 = v8 == 116;
      v13 = 77;
    }
    else
    {
      v10 = 0;
      v14 = a4;
      a1 = v7;
      v12 = 0;
      v13 = 76;
    }
  }
  else
  {
    v10 = 0;
    v14 = a4;
    v12 = 0;
    v13 = 75;
  }
  return sub_3F65C(a1, v13, v12, v10, v14);
}
// 245154: using guessed type char byte_245154;

//----- (000406D4) --------------------------------------------------------
void __fastcall sub_406D4(unsigned int *a1, int a2, const char *a3, int a4)
{
  int v5; // r3
  int v6; // r2
  int v7; // r1
  unsigned int *v8; // r6
  int v9; // r0
  int v10; // r7
  int v11; // r4
  char *v12; // r8
  unsigned __int8 v13; // [sp+20h] [bp+18h]

  v5 = dword_242F4C;
  if ( !dword_242F4C )
  {
    v13 = a4;
    v6 = 0;
    v7 = 8;
LABEL_6:
    sub_3F65C(a1, v7, v6, v5, v13);
    return;
  }
  v8 = a1;
  if ( !a3 || !*a3 )
  {
    v5 = 0;
    v6 = 0;
    v7 = 25;
    v13 = a4;
    goto LABEL_6;
  }
  v9 = strtol(a3, 0, 10);
  v10 = v9;
  if ( v9 < 0 || v9 >= dword_242F4C )
  {
    v13 = a4;
    v6 = v9;
    a1 = v8;
    v5 = 0;
    v7 = 26;
    goto LABEL_6;
  }
  if ( dword_242F4C <= 1 )
  {
    v13 = a4;
    v6 = v9;
    a1 = v8;
    v5 = 0;
    v7 = 66;
    goto LABEL_6;
  }
  v11 = *(_DWORD *)(dword_244048 + 4 * v9);
  if ( v11 == sub_58084() )
    sub_59E6C(0);
  if ( v11 == sub_58084() )
  {
    v13 = a4;
    v6 = v10;
    a1 = v8;
    v5 = 0;
    v7 = 67;
    goto LABEL_6;
  }
  *(_DWORD *)(v11 + 100) = 0;
  v12 = (char *)sub_3C89C(*(const char **)(v11 + 164), a4);
  if ( v12 == *(char **)(v11 + 164) )
  {
    sub_535B8(v11);
    v13 = a4;
    v5 = (int)v12;
    v6 = v10;
    a1 = v8;
    v7 = 68;
    goto LABEL_6;
  }
  sub_535B8(v11);
  sub_3F65C(v8, 68, v10, (int)v12, a4);
  free(v12);
}
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00040858) --------------------------------------------------------
int __fastcall sub_40858(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  unsigned __int8 v13; // [sp+18h] [bp+18h]

  if ( dword_242F4C )
  {
    v6 = a1;
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_242F4C )
      {
        v13 = a4;
        v7 = v9;
        a1 = v6;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_244048 + 4 * v9);
        if ( *(_DWORD *)(v11 + 100) )
        {
          if ( dword_2440F8 <= 1 )
          {
            v13 = a4;
            v7 = v9;
            a1 = v6;
            v8 = 51;
          }
          else
          {
            *(_DWORD *)(v11 + 100) = 0;
            if ( v11 == sub_58084() )
              sub_59E6C(0);
            v13 = a4;
            v7 = v10;
            a1 = v6;
            v8 = 48;
          }
        }
        else
        {
          v13 = a4;
          v7 = v9;
          a1 = v6;
          v8 = 50;
        }
      }
    }
    else
    {
      v13 = a4;
      v7 = 0;
      v8 = 25;
    }
  }
  else
  {
    v13 = a4;
    v7 = 0;
    v8 = 8;
  }
  return sub_3F65C(a1, v8, v7, 0, v13);
}
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;
// 2440F8: using guessed type int dword_2440F8;

//----- (0004099C) --------------------------------------------------------
int __fastcall sub_4099C(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  int v12; // r8
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  if ( dword_242F4C )
  {
    v6 = a1;
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_242F4C )
      {
        v14 = a4;
        v7 = v9;
        a1 = v6;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_244048 + 4 * v9);
        if ( *(_DWORD *)(v11 + 100) == 1 )
        {
          v14 = a4;
          v7 = v9;
          a1 = v6;
          v8 = 49;
        }
        else
        {
          v12 = *(_DWORD *)(v11 + 4);
          *(_DWORD *)(v11 + 100) = 1;
          if ( v12 < *(_DWORD *)(sub_58084() + 4) )
            sub_59E6C(v11);
          v14 = a4;
          v7 = v10;
          a1 = v6;
          v8 = 47;
        }
      }
    }
    else
    {
      v14 = a4;
      v7 = 0;
      v8 = 25;
    }
  }
  else
  {
    v14 = a4;
    v7 = 0;
    v8 = 8;
  }
  return sub_3F65C(a1, v8, v7, 0, v14);
}
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00040ABC) --------------------------------------------------------
int __fastcall sub_40ABC(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5)
{
  char *v6; // r3
  unsigned int *v7; // r7
  char *v9; // r9
  int v10; // r0
  int v11; // r2
  int v12; // r1
  int v14; // r5
  int v15; // r0
  int v16; // r4
  unsigned __int8 v17; // [sp+20h] [bp+20h]

  v6 = (char *)dword_242F4C;
  if ( dword_242F4C )
  {
    v7 = a1;
    if ( s && *s )
    {
      v9 = strchr(s, 44);
      if ( v9 )
      {
        *v9 = 0;
        v10 = strtol(s, 0, 10);
        if ( v10 >= 0 && v10 < dword_242F4C )
        {
          v14 = *(_DWORD *)(dword_244048 + 4 * v10);
          v15 = strtol(v9 + 1, 0, 10);
          v16 = v15;
          if ( v15 < 0 )
          {
            v6 = *(char **)(v14 + 164);
            v11 = v15;
            v17 = a4;
            a1 = v7;
            v12 = 121;
          }
          else
          {
            *(_DWORD *)(v14 + 56) = v15;
            sub_52B98();
            v6 = *(char **)(v14 + 164);
            v11 = v16;
            v17 = a4;
            a1 = v7;
            v12 = 122;
          }
        }
        else
        {
          v17 = a4;
          v11 = v10;
          a1 = v7;
          v6 = 0;
          v12 = 26;
        }
      }
      else
      {
        v17 = a4;
        v6 = s;
        v11 = 0;
        a1 = v7;
        v12 = 86;
      }
    }
    else
    {
      v6 = 0;
      v17 = a4;
      v11 = 0;
      v12 = 25;
    }
  }
  else
  {
    v17 = a4;
    v11 = 0;
    v12 = 8;
  }
  return sub_3F65C(a1, v12, v11, (int)v6, v17);
}
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00040C04) --------------------------------------------------------
int __fastcall sub_40C04(unsigned int *a1, int a2, char *s, int a4)
{
  const char *v4; // r4
  char *v6; // r2
  char *v7; // r3
  unsigned int *v8; // r6
  char *v9; // r0
  char v10; // r3
  const char *v11; // r9
  int v12; // r0
  char *v13; // r12
  int v14; // r1
  int v15; // r4
  int v16; // r2
  char *v17; // r3
  int v18; // lr
  int v19; // t1
  bool v20; // zf
  int v21; // r6
  char *v22; // r2
  int v23; // r3
  int v25; // r0
  char v26; // [sp+7h] [bp-2Dh] BYREF
  unsigned int *v27; // [sp+8h] [bp-2Ch] BYREF
  int v28; // [sp+Ch] [bp-28h]

  v28 = a4;
  v27 = a1;
  if ( !dword_242F4C )
    return sub_3F65C(a1, 8, 0, 0, v28);
  v4 = s;
  if ( !s || !*s )
    return sub_3F65C(v27, 25, 0, 0, v28);
  if ( dword_242F4C > 0 )
  {
    v6 = &v26;
    v7 = (char *)&v27 + dword_242F4C - 1;
    do
      *++v6 = 0;
    while ( v6 != v7 );
  }
  v8 = 0;
  do
  {
    v9 = strchr(v4, 44);
    if ( v9 )
      v10 = 0;
    v11 = v9 + 1;
    if ( v9 )
      *v9 = v10;
    else
      v11 = 0;
    v12 = strtol(v4, 0, 10);
    v4 = v11;
    v13 = (char *)v8 + 1;
    if ( v12 < 0 )
      return sub_3F65C(v27, 26, v12, 0, v28);
    v14 = dword_242F4C;
    if ( dword_242F4C <= v12 )
      return sub_3F65C(v27, 26, v12, 0, v28);
    if ( *((_BYTE *)&v27 + v12) )
      return sub_3F65C(v27, 74, v12, 0, v28);
    (&v27)[v12] = v8;
    *((_BYTE *)&v27 + v12) = 1;
    v8 = (unsigned int *)((char *)v8 + 1);
  }
  while ( v11 && *v11 );
  v15 = dword_244048;
  v16 = 0;
  v17 = &v26;
  do
  {
    v19 = (unsigned __int8)*++v17;
    v18 = v19;
    v20 = v19 == 0;
    if ( v19 )
    {
      v18 = *(_DWORD *)(v15 + 4 * v16);
      v8 = (&v27)[v16];
    }
    ++v16;
    if ( !v20 )
      *(_DWORD *)(v18 + 4) = v8;
  }
  while ( v17 != &v26 + v14 );
  v21 = 0;
  do
  {
    v22 = &v26;
    v23 = 0;
    while ( 1 )
    {
      if ( !*++v22 )
      {
        v25 = *(_DWORD *)(v15 + 4 * v23);
        if ( *(_DWORD *)(v25 + 4) == v21 )
          break;
      }
      if ( v14 == ++v23 )
        goto LABEL_30;
    }
    *(_DWORD *)(v25 + 4) = v13++;
    *((_BYTE *)&v27 + v23) = 1;
LABEL_30:
    ++v21;
  }
  while ( v14 != v21 );
  if ( *(_DWORD *)(sub_58084() + 4) )
    sub_59E6C(0);
  return sub_3F65C(v27, 73, 0, 0, v28);
}
// 40CE8: variable 'v10' is possibly undefined
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00040E64) --------------------------------------------------------
void __fastcall sub_40E64(unsigned int *a1, int a2, char *a3, int a4)
{
  char *v7; // r7
  int *v8; // r7
  char *v9; // r4
  char *s; // [sp+Ch] [bp-Ch] BYREF
  int v11; // [sp+10h] [bp-8h] BYREF
  int v12; // [sp+14h] [bp-4h] BYREF

  if ( a3 && *a3 )
  {
    if ( sub_3E02C((unsigned __int8 *)a3, &s, &v11, &v12) )
    {
      v8 = (int *)sub_58548();
      sub_52D98((int)v8, s);
      sub_62ECC((int)v8, 1, s, (const char *)v11, (const char *)v12);
      v9 = (char *)sub_3C89C(s, a4);
      sub_3F65C(a1, 55, *v8, (int)v9, a4);
      if ( s != v9 )
        free(v9);
    }
    else
    {
      v7 = (char *)sub_3C89C(a3, a4);
      sub_3F65C(a1, 53, 0, (int)v7, a4);
      if ( a3 != v7 )
        free(v7);
    }
  }
  else
  {
    sub_3F65C(a1, 52, 0, 0, a4);
  }
}

//----- (00040F6C) --------------------------------------------------------
int __fastcall sub_40F6C(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r7
  int v11; // r4
  unsigned __int8 v12; // [sp+18h] [bp+18h]

  if ( dword_242F4C )
  {
    v6 = a1;
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      if ( pthread_mutex_lock(&stru_2440BC) )
        sub_3E190("switchpool", 2907);
      if ( pthread_rwlock_rdlock(&rwlock) )
        sub_3E12C("switchpool", 2907);
      if ( pthread_mutex_unlock(&stru_2440BC) )
        sub_3E1F4("switchpool", 2907);
      if ( v9 >= 0 && v9 < dword_242F4C )
      {
        v11 = *(_DWORD *)(dword_244048 + 4 * v9);
        *(_DWORD *)(v11 + 100) = 1;
        if ( pthread_rwlock_unlock(&rwlock) )
          sub_3E258("switchpool", 2917);
        off_9E444();
        sub_59E6C(v11);
        v12 = a4;
        v7 = v9;
        a1 = v6;
        v8 = 27;
      }
      else
      {
        if ( pthread_rwlock_unlock(&rwlock) )
          sub_3E258("switchpool", 2910);
        off_9E444();
        v12 = a4;
        v7 = v9;
        a1 = v6;
        v8 = 26;
      }
    }
    else
    {
      v12 = a4;
      v7 = 0;
      v8 = 25;
    }
  }
  else
  {
    v12 = a4;
    v7 = 0;
    v8 = 8;
  }
  return sub_3F65C(a1, v8, v7, 0, v12);
}
// 9E444: using guessed type int (*off_9E444)();
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;
// 2440BC: using guessed type pthread_mutex_t stru_2440BC;

//----- (00041120) --------------------------------------------------------
int __fastcall sub_41120(int a1, int a2, int a3, int a4)
{
  int v6; // r6
  char **v7; // r0
  int result; // r0
  char **v9; // r0
  int v10; // [sp+Ch] [bp-4h] BYREF

  v10 = sub_3E2BC();
  sub_3F65C((unsigned int *)a1, 104, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_3C770((unsigned int *)a1, ",\"ASCS\":[");
    v7 = (char **)sub_3F3D8(0, "Count", 6, (const char *)&v10, 0);
    result = sub_3E88C((unsigned int *)a1, v7, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_3C770((unsigned int *)a1, "ASCS,");
    v9 = (char **)sub_3F3D8(0, "Count", 6, (const char *)&v10, 0);
    return sub_3E88C((unsigned int *)a1, v9, 0, 0);
  }
  return result;
}

//----- (00041200) --------------------------------------------------------
int __fastcall sub_41200(int a1, int a2, _BYTE *a3, int a4)
{
  int v7; // r2
  int v8; // r3
  int v9; // r6
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  char **v16; // r0
  int result; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  char **v24; // r1
  char *v25; // r3
  int v26; // r2

  if ( a3 )
  {
    v7 = LOBYTE((*_ctype_tolower_loc())[(unsigned __int8)*a3]);
    *a3 = v7;
    switch ( v7 )
    {
      case 'd':
        v8 = (unsigned __int8)byte_1AECC5 ^ 1;
        byte_1AECC5 ^= 1u;
        byte_1AECC4 = v8;
        if ( v8 )
          goto LABEL_4;
        break;
      case 'n':
        byte_1AECC4 = 0;
        byte_1AECC5 = 0;
        byte_242EF8 = 0;
        byte_242F18 = 0;
        byte_242F08 = 0;
        byte_24401C = 0;
        break;
      case 'p':
        byte_242F08 ^= 1u;
        byte_1AECC4 = byte_242F08;
        break;
      case 'q':
        byte_242EF8 ^= 1u;
        break;
      case 'r':
        v25 = &byte_242F18;
        goto LABEL_15;
      case 's':
        byte_24511C = 1;
        break;
      case 'v':
        v25 = &byte_1AECC4;
LABEL_15:
        v26 = (unsigned __int8)*v25 ^ 1;
        *v25 = v26;
        if ( v26 )
LABEL_4:
          byte_242EF8 = 0;
        break;
      case 'w':
        byte_24401C ^= 1u;
        break;
      default:
        break;
    }
  }
  sub_3F65C((unsigned int *)a1, 79, 0, 0, a4);
  if ( a4 )
  {
    v9 = sub_3C770((unsigned int *)a1, ",\"DEBUG\":[");
    v10 = sub_3F3D8(0, "Silent", 14, &byte_24511C, 0);
    v11 = sub_3F3D8((int)v10, "Quiet", 14, &byte_242EF8, 0);
    v12 = sub_3F3D8((int)v11, "Verbose", 14, &byte_1AECC4, 0);
    v13 = sub_3F3D8((int)v12, "Debug", 14, &byte_1AECC5, 0);
    v14 = sub_3F3D8((int)v13, "RPCProto", 14, &byte_242F18, 0);
    v15 = sub_3F3D8((int)v14, "PerDevice", 14, &byte_242F08, 0);
    v16 = (char **)sub_3F3D8((int)v15, "WorkTime", 14, &byte_24401C, 0);
    result = sub_3E88C((unsigned int *)a1, v16, 1, 0);
    if ( v9 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_3C770((unsigned int *)a1, "DEBUG,");
    v18 = sub_3F3D8(0, "Silent", 14, &byte_24511C, 0);
    v19 = sub_3F3D8((int)v18, "Quiet", 14, &byte_242EF8, 0);
    v20 = sub_3F3D8((int)v19, "Verbose", 14, &byte_1AECC4, 0);
    v21 = sub_3F3D8((int)v20, "Debug", 14, &byte_1AECC5, 0);
    v22 = sub_3F3D8((int)v21, "RPCProto", 14, &byte_242F18, 0);
    v23 = sub_3F3D8((int)v22, "PerDevice", 14, &byte_242F08, 0);
    v24 = (char **)sub_3F3D8((int)v23, "WorkTime", 14, &byte_24401C, 0);
    return sub_3E88C((unsigned int *)a1, v24, 0, 0);
  }
  return result;
}
// 41238: control flows out of bounds to 4123C
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 242EF8: using guessed type char byte_242EF8;
// 242F08: using guessed type char byte_242F08;
// 242F18: using guessed type char byte_242F18;
// 24401C: using guessed type char byte_24401C;
// 24511C: using guessed type char byte_24511C;

//----- (000415C4) --------------------------------------------------------
int __fastcall sub_415C4(int a1, int a2, const char *a3, int a4, unsigned __int8 a5)
{
  const char *v8; // r3
  _UNKNOWN **v9; // r4
  const char *v10; // t1
  const __int32_t **v11; // r0
  __int32_t v12; // r3
  int v13; // r5
  const char *v14; // r0
  const char *v15; // r3
  char **v16; // r0
  int result; // r0
  int v18; // r0
  const char *v19; // r3
  int v20; // r0
  int v21; // r0
  char s[100]; // [sp+Ch] [bp-64h] BYREF

  if ( !a3 || !*a3 )
    return sub_3F65C((unsigned int *)a1, 71, 0, 0, a4);
  v8 = (const char *)off_9DD3C;
  if ( off_9DD3C )
  {
    v9 = &off_9DD3C;
    while ( strcmp(v8, a3) )
    {
      v10 = (const char *)v9[3];
      v9 += 3;
      v8 = v10;
      if ( !v10 )
      {
        sub_3F65C((unsigned int *)a1, 72, 0, 0, a4);
        if ( !a4 )
          goto LABEL_20;
        goto LABEL_17;
      }
    }
    sprintf(s, "|%s|", a3);
    v11 = _ctype_toupper_loc();
    v12 = (*v11)[a5];
    if ( v12 == (*v11)[87] || strstr(*((const char **)&unk_242DF4 + v12 - (*v11)[65]), s) )
    {
      sub_3F65C((unsigned int *)a1, 72, 0, 0, a4);
      if ( a4 )
        v13 = sub_3C770((unsigned int *)a1, ",\"CHECK\":[");
      else
        v13 = sub_3C770((unsigned int *)a1, "CHECK,");
      v14 = sub_3F3D8(0, "Exists", 2, "Y", 0);
      v15 = "Y";
      goto LABEL_12;
    }
    sub_3F65C((unsigned int *)a1, 72, 0, 0, a4);
    if ( a4 )
      v21 = sub_3C770((unsigned int *)a1, ",\"CHECK\":[");
    else
      v21 = sub_3C770((unsigned int *)a1, "CHECK,");
    v19 = "Y";
    v13 = v21;
  }
  else
  {
    sub_3F65C((unsigned int *)a1, 72, 0, 0, a4);
    if ( a4 )
    {
LABEL_17:
      v18 = sub_3C770((unsigned int *)a1, ",\"CHECK\":[");
      v19 = "N";
      v13 = v18;
    }
    else
    {
LABEL_20:
      v20 = sub_3C770((unsigned int *)a1, "CHECK,");
      v19 = "N";
      v13 = v20;
    }
  }
  v14 = sub_3F3D8(0, "Exists", 2, v19, 0);
  v15 = "N";
LABEL_12:
  v16 = (char **)sub_3F3D8((int)v14, "Access", 2, v15, 0);
  result = sub_3E88C((unsigned int *)a1, v16, a4, 0);
  if ( (a4 & v13) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 9DD3C: using guessed type _UNKNOWN *off_9DD3C;

//----- (0004183C) --------------------------------------------------------
int __fastcall sub_4183C(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r10
  int v8; // r11
  int v9; // r5
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r3
  const char *v15; // r0
  const char *v16; // r3
  const char *v17; // r0
  const char *v18; // r3
  char **v19; // r1
  _BOOL4 v20; // r3
  int v21; // [sp+Ch] [bp-8h] BYREF

  if ( !dword_245140 )
    return sub_3F65C((unsigned int *)a1, 10, 0, 0, a4);
  result = sub_3F65C((unsigned int *)a1, 69, 0, 0, a4);
  if ( !a4 )
  {
    v21 = 0;
    if ( dword_245140 <= 0 )
      return result;
    v7 = 0;
    goto LABEL_6;
  }
  result = sub_3C770((unsigned int *)a1, ",\"DEVDETAILS\":[");
  v7 = result;
  v21 = 0;
  if ( dword_245140 > 0 )
  {
LABEL_6:
    v8 = 0;
    result = 0;
    do
    {
      v9 = sub_56518(result);
      v10 = sub_3F3D8(v8, "DEVDETAILS", 6, (const char *)&v21, 0);
      v11 = sub_3F3D8((int)v10, "Name", 1, *(const char **)(*(_DWORD *)(v9 + 4) + 8), 0);
      v12 = sub_3F3D8((int)v11, "ID", 6, (const char *)(v9 + 8), 0);
      v13 = sub_3F3D8((int)v12, "Driver", 1, *(const char **)(*(_DWORD *)(v9 + 4) + 4), 0);
      v14 = *(const char **)(v9 + 168);
      if ( !v14 )
        v14 = "";
      v15 = sub_3F3D8((int)v13, "Kernel", 2, v14, 0);
      v16 = *(const char **)(v9 + 12);
      if ( !v16 )
        v16 = "";
      v17 = sub_3F3D8((int)v15, "Model", 2, v16, 0);
      v18 = *(const char **)(v9 + 16);
      if ( !v18 )
        v18 = "";
      v19 = (char **)sub_3F3D8((int)v17, "Device Path", 2, v18, 0);
      v20 = a4;
      if ( a4 )
        v20 = v21 > 0;
      v8 = sub_3E88C((unsigned int *)a1, v19, a4, v20);
      result = ++v21;
    }
    while ( v21 < dword_245140 );
  }
  if ( v7 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 245140: using guessed type int dword_245140;

//----- (00041A18) --------------------------------------------------------
int __fastcall sub_41A18(int a1, int a2, int a3, int a4)
{
  int v6; // r5
  char **v7; // r0
  int result; // r0
  char **v9; // r0
  int v10; // [sp+Ch] [bp-4h] BYREF

  v10 = 0;
  sub_3F65C((unsigned int *)a1, 59, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_3C770((unsigned int *)a1, ",\"PGAS\":[");
    v7 = (char **)sub_3F3D8(0, "Count", 6, (const char *)&v10, 0);
    result = sub_3E88C((unsigned int *)a1, v7, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_3C770((unsigned int *)a1, "PGAS,");
    v9 = (char **)sub_3F3D8(0, "Count", 6, (const char *)&v10, 0);
    return sub_3E88C((unsigned int *)a1, v9, 0, 0);
  }
  return result;
}

//----- (00041AEC) --------------------------------------------------------
int __fastcall sub_41AEC(int a1, int a2, int a3, int a4)
{
  int v6; // r6
  const char *v7; // r0
  const char *v8; // r0
  char **v9; // r0
  int result; // r0
  const char *v11; // r0
  const char *v12; // r0
  char **v13; // r1

  sub_3F65C((unsigned int *)a1, 16, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_3C770((unsigned int *)a1, ",\"NONCENUM\":[");
    v7 = sub_3F3D8(0, "10min nonce", 1, byte_245234, 0);
    v8 = sub_3F3D8((int)v7, "30min nonce", 1, byte_2440FC, 0);
    v9 = (char **)sub_3F3D8((int)v8, "60min nonce", 1, byte_243004, 0);
    result = sub_3E88C((unsigned int *)a1, v9, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_3C770((unsigned int *)a1, "NONCENUM,");
    v11 = sub_3F3D8(0, "10min nonce", 1, byte_245234, 0);
    v12 = sub_3F3D8((int)v11, "30min nonce", 1, byte_2440FC, 0);
    v13 = (char **)sub_3F3D8((int)v12, "60min nonce", 1, byte_243004, 0);
    return sub_3E88C((unsigned int *)a1, v13, 0, 0);
  }
  return result;
}

//----- (00041E1C) --------------------------------------------------------
int __fastcall sub_41E1C(int a1, int a2, int a3, int a4)
{
  int v6; // r6
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  char **v11; // r0
  int result; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  char **v17; // r1

  sub_3F65C((unsigned int *)a1, 22, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_3C770((unsigned int *)a1, ",\"VERSION\":[");
    v7 = sub_3F3D8(0, "BMMiner", 1, "1.0.0", 0);
    v8 = sub_3F3D8((int)v7, "API", 2, "3.1", 0);
    v9 = sub_3F3D8((int)v8, "Miner", 1, byte_1B0A18, 0);
    v10 = sub_3F3D8((int)v9, "CompileTime", 1, byte_1B07E4, 0);
    v11 = (char **)sub_3F3D8((int)v10, "Type", 1, byte_1B08E4, 0);
    result = sub_3E88C((unsigned int *)a1, v11, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_3C770((unsigned int *)a1, "VERSION,");
    v13 = sub_3F3D8(0, "BMMiner", 1, "1.0.0", 0);
    v14 = sub_3F3D8((int)v13, "API", 2, "3.1", 0);
    v15 = sub_3F3D8((int)v14, "Miner", 1, byte_1B0A18, 0);
    v16 = sub_3F3D8((int)v15, "CompileTime", 1, byte_1B07E4, 0);
    v17 = (char **)sub_3F3D8((int)v16, "Type", 1, byte_1B08E4, 0);
    return sub_3E88C((unsigned int *)a1, v17, 0, 0);
  }
  return result;
}

//----- (00041FD4) --------------------------------------------------------
int __fastcall sub_41FD4(int a1, int a2, int a3, int a4)
{
  char *v6; // r1
  int v7; // r8
  const char *v8; // r7
  const char *v9; // r0
  const char *v10; // r9
  const char *v11; // r0
  char **v12; // r0
  int result; // r0

  sub_3F65C((unsigned int *)a1, 78, 0, 0, a4);
  v6 = ",\"COIN\":[";
  if ( !a4 )
    v6 = "COIN,";
  v7 = sub_3C770((unsigned int *)a1, v6);
  v8 = sub_3F3D8(0, "Hash Method", 2, "sha256", 0);
  if ( pthread_mutex_lock(&stru_244084) )
    sub_3E190("minecoin", 3633);
  if ( pthread_rwlock_rdlock(&stru_24409C) )
    sub_3E12C("minecoin", 3633);
  if ( pthread_mutex_unlock(&stru_244084) )
    sub_3E1F4("minecoin", 3633);
  v9 = sub_3F3D8((int)v8, "Current Block Time", 15, (const char *)&dword_245170, 1);
  v10 = sub_3F3D8((int)v9, "Current Block Hash", 1, byte_242EA4, 1);
  if ( pthread_rwlock_unlock(&stru_24409C) )
    sub_3E258("minecoin", 3636);
  off_9E444();
  v11 = sub_3F3D8((int)v10, "LP", 14, &byte_244082, 0);
  v12 = (char **)sub_3F3D8((int)v11, "Network Difficulty", 24, (const char *)&dbl_9ED90, 1);
  result = sub_3E88C((unsigned int *)a1, v12, a4, 0);
  if ( (a4 & v7) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 9E444: using guessed type int (*off_9E444)();
// 9ED90: using guessed type double dbl_9ED90;
// 244082: using guessed type char byte_244082;
// 244084: using guessed type pthread_mutex_t stru_244084;
// 245170: using guessed type int dword_245170;

//----- (00042198) --------------------------------------------------------
int __fastcall sub_42198(unsigned int *a1, int a2, int a3, int a4)
{
  double v4; // d0
  int result; // r0
  _BOOL4 v9; // r1
  int v10; // r4
  float v11; // s14
  int v12; // s15
  int v13; // r10
  int v14; // r1
  const char *v15; // r10
  const char *v16; // r9
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r9
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  int v29; // r2
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  const char *v35; // r0
  const char *v36; // r0
  const char *v37; // r0
  int v38; // r3
  int v39; // r5
  __int64 v40; // r10
  double v41; // d8
  double v42; // r0
  double v43; // d7
  const char *v44; // r5
  __int64 v45; // r0
  double v46; // r0
  double v47; // d7
  const char *v48; // r0
  char **v49; // r0
  int v50; // [sp+Ch] [bp-50h] BYREF
  float v51; // [sp+10h] [bp-4Ch] BYREF
  int v52; // [sp+14h] [bp-48h] BYREF
  double v53; // [sp+18h] [bp-44h] BYREF
  double v54; // [sp+20h] [bp-3Ch] BYREF
  double v55; // [sp+28h] [bp-34h] BYREF
  double v56; // [sp+30h] [bp-2Ch] BYREF
  char s[28]; // [sp+3Ch] [bp-20h] BYREF

  v50 = a2;
  result = sub_3E2BC();
  v9 = (v50 & ~(v50 >> 31)) < result;
  if ( v50 < 0 )
    v9 = 0;
  if ( v9 )
  {
    result = sub_3E378(v50);
    if ( result >= 0 )
    {
      v10 = sub_56518(result);
      v11 = *(double *)(v10 + 176);
      v51 = v11;
      sub_53118(v10);
      v12 = *(_DWORD *)(v10 + 36);
      v13 = *(_DWORD *)(v10 + 32);
      v14 = *(_DWORD *)(v10 + 96);
      v53 = v4;
      if ( v13 == 1 )
        v15 = "N";
      else
        v15 = "Y";
      *(double *)(v10 + 88) = (double)v12 / v4 * 60.0;
      switch ( v14 )
      {
        case 0:
          v16 = "Alive";
          break;
        case 1:
          v16 = "Sick";
          break;
        case 2:
          v16 = "Dead";
          break;
        case 3:
          v16 = "NoStart";
          break;
        case 4:
          v16 = "Initialising";
          break;
        default:
          v16 = "Unknown";
          break;
      }
      v17 = sub_3F3D8(0, "ASC", 6, (const char *)&v50, 0);
      v18 = sub_3F3D8((int)v17, "Name", 1, *(const char **)(*(_DWORD *)(v10 + 4) + 8), 0);
      v19 = sub_3F3D8((int)v18, "ID", 6, (const char *)(v10 + 8), 0);
      v20 = sub_3F3D8((int)v19, "Enabled", 1, v15, 0);
      v21 = sub_3F3D8((int)v20, "Status", 1, v16, 0);
      v22 = sub_3F3D8((int)v21, "Temperature", 19, (const char *)&v51, 0);
      v54 = *(double *)(v10 + 80) / v53;
      v23 = sub_3F3D8((int)v22, "MHS av", 17, (const char *)&v54, 0);
      sprintf(s, "MHS %ds", dword_9ED78);
      v24 = sub_3F3D8((int)v23, s, 17, (const char *)(v10 + 48), 0);
      v25 = sub_3F3D8((int)v24, "Accepted", 6, (const char *)(v10 + 36), 0);
      v26 = sub_3F3D8((int)v25, "Rejected", 6, (const char *)(v10 + 40), 0);
      v27 = sub_3F3D8((int)v26, "Hardware Errors", 6, (const char *)(v10 + 44), 0);
      v28 = sub_3F3D8((int)v27, "Utility", 20, (const char *)(v10 + 88), 0);
      if ( *(int *)(v10 + 220) <= 0 )
        v29 = -1;
      else
        v29 = *(_DWORD *)(v10 + 216);
      v52 = v29;
      v30 = sub_3F3D8((int)v28, "Last Share Pool", 6, (const char *)&v52, 0);
      v31 = sub_3F3D8((int)v30, "Last Share Time", 16, (const char *)(v10 + 220), 0);
      v32 = sub_3F3D8((int)v31, "Total MH", 18, (const char *)(v10 + 80), 0);
      v33 = sub_3F3D8((int)v32, "Diff1 Work", 11, (const char *)(v10 + 192), 0);
      v34 = sub_3F3D8((int)v33, "Difficulty Accepted", 24, (const char *)(v10 + 200), 0);
      v35 = sub_3F3D8((int)v34, "Difficulty Rejected", 24, (const char *)(v10 + 208), 0);
      v36 = sub_3F3D8((int)v35, "Last Share Difficulty", 24, (const char *)(v10 + 224), 0);
      v37 = sub_3F3D8((int)v36, "Last Valid Work", 16, (const char *)(v10 + 232), 0);
      v38 = *(_DWORD *)(v10 + 44);
      v39 = (int)v37;
      v40 = *(_QWORD *)(v10 + 192) + v38;
      if ( v40 )
      {
        v41 = (double)v38;
        LODWORD(v42) = sub_778B4(v40);
        v43 = v41 / v42;
      }
      else
      {
        v43 = 0.0;
      }
      v55 = v43;
      v44 = sub_3F3D8(v39, "Device Hardware%", 25, (const char *)&v55, 0);
      v45 = *(_QWORD *)(v10 + 192);
      if ( v45 )
      {
        LODWORD(v46) = sub_778B4(v45);
        v47 = *(double *)(v10 + 208) / v46;
      }
      else
      {
        v47 = 0.0;
      }
      v56 = v47;
      v48 = sub_3F3D8((int)v44, "Device Rejected%", 25, (const char *)&v56, 0);
      v49 = (char **)sub_3F3D8((int)v48, "Device Elapsed", 13, (const char *)&v53, 0);
      return sub_3E88C(a1, v49, a3, a4);
    }
  }
  return result;
}
// 42258: control flows out of bounds to 4225C
// 42198: too many cbuild loops
// 42238: variable 'v4' is possibly undefined
// 424E4: variable 'v42' is possibly undefined
// 4252C: variable 'v46' is possibly undefined
// 9ED78: using guessed type int dword_9ED78;

//----- (000428AC) --------------------------------------------------------
int __fastcall sub_428AC(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r9
  int v8; // r3
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  double v12; // d5
  double v13; // d7
  double v14; // d6
  const char *v15; // r0
  double v16; // d5
  double v17; // d7
  double v18; // d6
  char **v19; // r1
  _BOOL4 v20; // r3
  int v21; // r4
  int v22; // r3
  const char *v23; // r6
  const char *v24; // r5
  time_t v25; // r0
  unsigned int v26; // lr
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  const char *v35; // r0
  const char *v36; // r0
  const char *v37; // r0
  const char *v38; // r0
  const char *v39; // r0
  const char *v40; // r0
  const char *v41; // r0
  const char *v42; // r0
  const char *v43; // r0
  int v44; // r6
  char *v45; // r0
  const char *v46; // r0
  const char *v47; // r0
  const char *v48; // r0
  const char *v49; // r0
  const char *v50; // r0
  const char *v51; // r0
  const char *v52; // r0
  const char *v53; // r0
  const char *v54; // r0
  const char *v55; // r6
  const char *v56; // [sp+Ch] [bp-130h]
  int v58; // [sp+1Ch] [bp-120h]
  int v59; // [sp+24h] [bp-118h] BYREF
  double v60; // [sp+28h] [bp-114h] BYREF
  double v61; // [sp+30h] [bp-10Ch] BYREF
  char s[256]; // [sp+38h] [bp-104h] BYREF

  memset(s, 0, sizeof(s));
  if ( !dword_242F4C )
    return sub_3F65C((unsigned int *)a1, 8, 0, 0, a4);
  result = sub_3F65C((unsigned int *)a1, 7, 0, 0, a4);
  if ( !a4 )
  {
    v59 = 0;
    if ( dword_242F4C <= 0 )
      return result;
    v58 = 0;
    goto LABEL_6;
  }
  result = sub_3C770((unsigned int *)a1, ",\"POOLS\":[");
  v58 = result;
  v59 = 0;
  if ( dword_242F4C > 0 )
  {
LABEL_6:
    v7 = 0;
    v8 = 0;
    do
    {
      v21 = *(_DWORD *)(dword_244048 + 4 * v8);
      if ( !*(_BYTE *)(v21 + 105) )
      {
        v22 = *(_DWORD *)(v21 + 100);
        if ( v22 == 1 )
        {
          v55 = "Alive";
          if ( *(_BYTE *)(v21 + 97) )
            v55 = "Dead";
          v56 = v55;
        }
        else if ( v22 )
        {
          v23 = "Rejecting";
          if ( v22 != 2 )
            v23 = "Unknown";
          v56 = v23;
        }
        else
        {
          v56 = "Disabled";
        }
        v24 = "N";
        if ( *(_DWORD *)(v21 + 108) )
          v24 = "Y";
        if ( *(int *)(v21 + 352) > 0 )
        {
          v25 = time(0);
          v26 = (v25 - *(_DWORD *)(v21 + 352)) & ~((v25 - *(_DWORD *)(v21 + 352)) >> 31);
          sprintf(s, "%d:%02d:%02d", v26 / 0xE10, v26 % 0xE10 / 0x3C, v26 % 0xE10 % 0x3C);
        }
        else
        {
          *(_WORD *)s = 48;
        }
        v27 = sub_3F3D8(v7, "POOL", 6, (const char *)&v59, 0);
        v28 = sub_3F3D8((int)v27, "URL", 0, *(const char **)(v21 + 164), 0);
        v29 = sub_3F3D8((int)v28, "Status", 1, v56, 0);
        v30 = sub_3F3D8((int)v29, "Priority", 6, (const char *)(v21 + 4), 0);
        v31 = sub_3F3D8((int)v30, "Quota", 6, (const char *)(v21 + 56), 0);
        v32 = sub_3F3D8((int)v31, "Long Poll", 1, v24, 0);
        v33 = sub_3F3D8((int)v32, "Getworks", 7, (const char *)(v21 + 116), 0);
        v34 = sub_3F3D8((int)v33, "Accepted", 11, (const char *)(v21 + 8), 0);
        v35 = sub_3F3D8((int)v34, "Rejected", 11, (const char *)(v21 + 16), 0);
        v36 = sub_3F3D8((int)v35, "Discarded", 7, (const char *)(v21 + 124), 0);
        v37 = sub_3F3D8((int)v36, "Stale", 7, (const char *)(v21 + 120), 0);
        v38 = sub_3F3D8((int)v37, "Get Failures", 7, (const char *)(v21 + 128), 0);
        v39 = sub_3F3D8((int)v38, "Remote Failures", 7, (const char *)(v21 + 132), 0);
        v40 = sub_3F3D8((int)v39, "User", 0, *(const char **)(v21 + 172), 0);
        v41 = sub_3F3D8((int)v40, "Last Share Time", 1, s, 0);
        v42 = sub_3F3D8((int)v41, "Diff", 1, (const char *)(v21 + 48), 0);
        v43 = sub_3F3D8((int)v42, "Diff1 Shares", 11, (const char *)(v21 + 40), 0);
        v44 = (int)v43;
        if ( *(_DWORD *)(v21 + 184) )
        {
          v45 = sub_497D0(*(char **)(v21 + 180));
          v46 = sub_3F3D8(v44, "Proxy Type", 2, v45, 0);
          v47 = sub_3F3D8((int)v46, "Proxy", 0, *(const char **)(v21 + 184), 0);
        }
        else
        {
          v54 = sub_3F3D8((int)v43, "Proxy Type", 2, "", *(_DWORD *)(v21 + 184));
          v47 = sub_3F3D8((int)v54, "Proxy", 2, "", 0);
        }
        v48 = sub_3F3D8((int)v47, "Difficulty Accepted", 24, (const char *)(v21 + 72), 0);
        v49 = sub_3F3D8((int)v48, "Difficulty Rejected", 24, (const char *)(v21 + 80), 0);
        v50 = sub_3F3D8((int)v49, "Difficulty Stale", 24, (const char *)(v21 + 88), 0);
        v51 = sub_3F3D8((int)v50, "Last Share Difficulty", 24, (const char *)(v21 + 360), 0);
        v52 = sub_3F3D8((int)v51, "Has Stratum", 14, (const char *)(v21 + 640), 0);
        v53 = sub_3F3D8((int)v52, "Stratum Active", 14, (const char *)(v21 + 641), 0);
        if ( *(_BYTE *)(v21 + 641) )
          v9 = sub_3F3D8((int)v53, "Stratum URL", 0, *(const char **)(v21 + 576), 0);
        else
          v9 = sub_3F3D8((int)v53, "Stratum URL", 2, "", *(_BYTE *)(v21 + 641));
        v10 = sub_3F3D8((int)v9, "Has GBT", 14, (const char *)(v21 + 736), 0);
        v11 = sub_3F3D8((int)v10, "Best Share", 10, (const char *)(v21 + 368), 1);
        v12 = *(double *)(v21 + 80);
        v13 = v12 + *(double *)(v21 + 72) + *(double *)(v21 + 88);
        if ( v13 == 0.0 )
          v14 = 0.0;
        else
          v14 = v12 / v13;
        v60 = v14;
        v15 = sub_3F3D8((int)v11, "Pool Rejected%", 25, (const char *)&v60, 0);
        v16 = *(double *)(v21 + 88);
        v17 = *(double *)(v21 + 72) + *(double *)(v21 + 80) + v16;
        if ( v17 == 0.0 )
          v18 = 0.0;
        else
          v18 = v16 / v17;
        v61 = v18;
        v19 = (char **)sub_3F3D8((int)v15, "Pool Stale%", 25, (const char *)&v61, 0);
        if ( a4 )
          v20 = v59 > 0;
        else
          v20 = 0;
        result = sub_3E88C((unsigned int *)a1, v19, a4, v20);
        v7 = result;
      }
      v8 = ++v59;
    }
    while ( v59 < dword_242F4C );
  }
  if ( v58 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00043158) --------------------------------------------------------
int __fastcall sub_43158(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6)
{
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r8
  const char *v16; // r0
  const char *v17; // r0
  double *v18; // r3
  const char *v19; // r0
  const char *v20; // r0
  int v21; // r2
  char **v22; // r1
  int v23; // r3
  int v25; // [sp+Ch] [bp-14h] BYREF
  double v26; // [sp+10h] [bp-10h] BYREF
  double v27; // [sp+18h] [bp-8h] BYREF

  v25 = a2;
  v26 = (dbl_245228 - dbl_2463B0) / 1000.0 / (dbl_9ED68 - dbl_9ED80);
  v9 = sub_3F3D8(0, "STATS", 6, (const char *)&v25, 0);
  v10 = sub_3F3D8((int)v9, "ID", 1, a3, 0);
  v27 = (double)SLODWORD(flt_1B09F8) + dbl_9ED68;
  v11 = sub_3F3D8((int)v10, "Elapsed", 13, (const char *)&v27, 0);
  v12 = sub_3F3D8((int)v11, "Calls", 8, a4, 0);
  v13 = sub_3F3D8((int)v12, "Wait", 15, a4 + 4, 0);
  v14 = sub_3F3D8((int)v13, "Max", 15, a4 + 12, 0);
  v15 = sub_3F3D8((int)v14, "Min", 15, a4 + 20, 0);
  if ( !(_BYTE)dword_1B09FC )
    sprintf((char *)&dword_1B09FC, "%.2f", 0.0);
  v16 = sub_3F3D8((int)v15, "GHS 5s", 1, (const char *)&dword_1B09FC, 0);
  v17 = sub_3F3D8((int)v16, "GHS av", 17, (const char *)&v26, 0);
  v18 = &dbl_1B0A10;
  if ( dbl_1B0A10 < 0.01 )
    v18 = &v26;
  v19 = sub_3F3D8((int)v17, "GHS 30m", 17, (const char *)v18, 0);
  v20 = sub_3F3D8((int)v19, "Mode", 6, (const char *)&dword_9EE38, 0);
  v22 = (char **)v20;
  if ( a5 )
  {
    if ( v20 )
      v21 = *((_DWORD *)v20 + 4);
    else
      v22 = (char **)a5;
    if ( v20 )
    {
      v23 = *(_DWORD *)(a5 + 16);
      *(_DWORD *)(a5 + 16) = v21;
      *(_DWORD *)(*((_DWORD *)v20 + 4) + 20) = a5;
      *(_DWORD *)(v23 + 20) = v20;
      *((_DWORD *)v20 + 4) = v23;
    }
  }
  sub_3E88C(a1, v22, a6, 1);
  return v25 + 1;
}
// 4334C: variable 'v21' is possibly undefined
// 9ED68: using guessed type double dbl_9ED68;
// 9ED80: using guessed type double dbl_9ED80;
// 9EE38: using guessed type int dword_9EE38;
// 1B09F8: using guessed type float flt_1B09F8;
// 1B09FC: using guessed type int dword_1B09FC;
// 1B0A10: using guessed type double dbl_1B0A10;
// 245228: using guessed type double dbl_245228;
// 2463B0: using guessed type double dbl_2463B0;

//----- (000433A8) --------------------------------------------------------
int __fastcall sub_433A8(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r4
  int v8; // r8
  int v9; // r5
  int v10; // r3
  int (*v11)(void); // r6
  int v12; // r0
  int v13; // [sp+Ch] [bp-20h]
  char s[24]; // [sp+14h] [bp-18h] BYREF

  result = sub_3F65C((unsigned int *)a1, 70, 0, 0, a4);
  if ( !a4 )
  {
    if ( dword_245140 <= 0 )
      return result;
    v13 = 0;
    goto LABEL_5;
  }
  result = sub_3C770((unsigned int *)a1, ",\"STATS\":[");
  v13 = result;
  if ( dword_245140 > 0 )
  {
LABEL_5:
    v7 = 0;
    v8 = 0;
    do
    {
      result = sub_56518(v7);
      v9 = result;
      if ( result )
      {
        v10 = *(_DWORD *)(result + 4);
        if ( v10 )
        {
          v11 = *(int (**)(void))(v10 + 28);
          if ( v11 )
          {
            v12 = v11();
            v10 = *(_DWORD *)(v9 + 4);
            v11 = (int (*)(void))v12;
          }
          sprintf(s, "%s%d", *(const char **)(v10 + 8), *(_DWORD *)(v9 + 8));
          result = sub_43158((unsigned int *)a1, v8, s, (const char *)(v9 + 292), (int)v11, a4);
          v8 = result;
        }
      }
      ++v7;
    }
    while ( dword_245140 > v7 );
  }
  if ( v13 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 245140: using guessed type int dword_245140;

//----- (000434B8) --------------------------------------------------------
int __fastcall sub_434B8(int a1, int a2, int a3, int a4)
{
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  char **v9; // r0
  int result; // r0
  int v11; // r4
  int v12; // r9
  int v13; // r5
  int v14; // r3
  int (*v15)(void); // r6
  int v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  char **v20; // r0
  int v21; // [sp+Ch] [bp-20h]
  char s[24]; // [sp+14h] [bp-18h] BYREF

  sub_3F65C((unsigned int *)a1, 70, 0, 0, a4);
  if ( !a4 )
  {
    v6 = sub_3F3D8(0, "BMMiner", 1, "1.0.0", 0);
    v7 = sub_3F3D8((int)v6, "Miner", 1, byte_1B0A18, 0);
    v8 = sub_3F3D8((int)v7, "CompileTime", 1, byte_1B07E4, 0);
    v9 = (char **)sub_3F3D8((int)v8, "Type", 1, byte_1B08E4, 0);
    result = sub_3E88C((unsigned int *)a1, v9, 0, 0);
    if ( dword_245140 <= 0 )
      return result;
    v21 = 0;
    goto LABEL_5;
  }
  v21 = sub_3C770((unsigned int *)a1, ",\"STATS\":[");
  v17 = sub_3F3D8(0, "BMMiner", 1, "1.0.0", 0);
  v18 = sub_3F3D8((int)v17, "Miner", 1, byte_1B0A18, 0);
  v19 = sub_3F3D8((int)v18, "CompileTime", 1, byte_1B07E4, 0);
  v20 = (char **)sub_3F3D8((int)v19, "Type", 1, byte_1B08E4, 0);
  result = sub_3E88C((unsigned int *)a1, v20, 1, 0);
  if ( dword_245140 > 0 )
  {
LABEL_5:
    v11 = 0;
    v12 = 0;
    do
    {
      result = sub_56518(v11);
      v13 = result;
      if ( result )
      {
        v14 = *(_DWORD *)(result + 4);
        if ( v14 )
        {
          v15 = *(int (**)(void))(v14 + 28);
          if ( v15 )
          {
            v16 = v15();
            v14 = *(_DWORD *)(v13 + 4);
            v15 = (int (*)(void))v16;
          }
          sprintf(s, "%s%d", *(const char **)(v14 + 8), *(_DWORD *)(v13 + 8));
          result = sub_43158((unsigned int *)a1, v12, s, (const char *)(v13 + 292), (int)v15, a4);
          v12 = result;
        }
      }
      ++v11;
    }
    while ( dword_245140 > v11 );
  }
  if ( v21 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 245140: using guessed type int dword_245140;

//----- (000436DC) --------------------------------------------------------
int __fastcall sub_436DC(int a1, int a2, int a3, int a4)
{
  char *v6; // r1
  int v7; // r1
  double v8; // d7
  double v9; // d8
  double v10; // d10
  double v11; // r0
  const char *v12; // r4
  const char *v13; // r0
  const char *v14; // r0
  double *v15; // r3
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r4
  __int64 v35; // r8
  double v36; // d8
  double v37; // r0
  double v38; // d7
  const char *v39; // r4
  double v40; // r0
  double v41; // d7
  const char *v42; // r0
  double v43; // d7
  double v44; // d5
  const char *v45; // r0
  double v46; // d7
  double v47; // d5
  const char *v48; // r0
  char **v49; // r4
  int result; // r0
  int v51; // [sp+10h] [bp-54h]
  __int64 v53; // [sp+18h] [bp-4Ch]
  double v54; // [sp+20h] [bp-44h] BYREF
  double v55; // [sp+28h] [bp-3Ch] BYREF
  double v56; // [sp+30h] [bp-34h] BYREF
  double v57; // [sp+38h] [bp-2Ch] BYREF
  double v58; // [sp+40h] [bp-24h] BYREF
  double v59; // [sp+48h] [bp-1Ch] BYREF
  double v60; // [sp+50h] [bp-14h] BYREF
  double v61; // [sp+58h] [bp-Ch] BYREF

  sub_3F65C((unsigned int *)a1, 11, 0, 0, a4);
  v6 = "SUMMARY,";
  if ( a4 )
    v6 = ",\"SUMMARY\":[";
  v51 = sub_3C770((unsigned int *)a1, v6);
  if ( pthread_mutex_lock(&stru_2463B8) )
    sub_3E190("summary", 2788);
  *(_QWORD *)&dword_2463D0 = (__int64)(dbl_242EF0 + dbl_242F10 + dbl_246238);
  v53 = (__int64)(dbl_242EF0 + dbl_242F10 + dbl_246238);
  LODWORD(v8) = sub_778B4(qword_245158);
  HIDWORD(v8) = v7;
  v9 = dbl_9ED68;
  if ( dbl_9ED68 == 0.0 )
  {
    v10 = 1.0;
  }
  else
  {
    v8 = v8 / dbl_9ED68;
    v10 = dbl_9ED68;
  }
  v54 = v8 * 60.0;
  v55 = (dbl_245228 - dbl_2463B0) / 1000.0 / (dbl_9ED68 - dbl_9ED80);
  LODWORD(v11) = sub_778B4(v53);
  v57 = (double)SLODWORD(flt_1B09F8) + v9;
  v56 = v11 / v10 * 60.0;
  v12 = sub_3F3D8(0, "Elapsed", 13, (const char *)&v57, 1);
  if ( !(_BYTE)dword_1B09FC )
    sprintf((char *)&dword_1B09FC, "%.2f", 0.0);
  v13 = sub_3F3D8((int)v12, "GHS 5s", 1, (const char *)&dword_1B09FC, 0);
  v14 = sub_3F3D8((int)v13, "GHS av", 17, (const char *)&v55, 0);
  v15 = &dbl_1B0A10;
  if ( dbl_1B0A10 < 0.01 )
    v15 = &v55;
  v16 = sub_3F3D8((int)v14, "GHS 30m", 17, (const char *)v15, 0);
  v17 = sub_3F3D8((int)v16, "Found Blocks", 7, (const char *)&dword_242FDC, 1);
  v18 = sub_3F3D8((int)v17, "Getworks", 11, (const char *)&dword_245168, 1);
  v19 = sub_3F3D8((int)v18, "Accepted", 11, (const char *)&qword_245158, 1);
  v20 = sub_3F3D8((int)v19, "Rejected", 11, (const char *)&qword_246368, 1);
  v21 = sub_3F3D8((int)v20, "Hardware Errors", 6, (const char *)&dword_242EE8, 1);
  v22 = sub_3F3D8((int)v21, "Utility", 20, (const char *)&v54, 0);
  v23 = sub_3F3D8((int)v22, "Discarded", 11, (const char *)&qword_242F00, 1);
  v24 = sub_3F3D8((int)v23, "Stale", 11, (const char *)&dword_242E98, 1);
  v25 = sub_3F3D8((int)v24, "Get Failures", 7, (const char *)&dword_245150, 1);
  v26 = sub_3F3D8((int)v25, "Local Work", 7, (const char *)&dword_246360, 1);
  v27 = sub_3F3D8((int)v26, "Remote Failures", 7, (const char *)&dword_244014, 1);
  v28 = sub_3F3D8((int)v27, "Network Blocks", 7, (const char *)&dword_24625C, 1);
  v29 = sub_3F3D8((int)v28, "Total MH", 18, (const char *)&dbl_245228, 1);
  v30 = sub_3F3D8((int)v29, "Work Utility", 20, (const char *)&v56, 0);
  v31 = sub_3F3D8((int)v30, "Difficulty Accepted", 24, (const char *)&dbl_242EF0, 1);
  v32 = sub_3F3D8((int)v31, "Difficulty Rejected", 24, (const char *)&dbl_242F10, 1);
  v33 = sub_3F3D8((int)v32, "Difficulty Stale", 24, (const char *)&dbl_246238, 1);
  v34 = sub_3F3D8((int)v33, "Best Share", 10, (const char *)&dword_1AF0D0, 1);
  v35 = *(_QWORD *)&dword_2463D0 + dword_242EE8;
  if ( v35 )
  {
    v36 = (double)dword_242EE8;
    LODWORD(v37) = sub_778B4(v35);
    v38 = v36 / v37;
  }
  else
  {
    v38 = 0.0;
  }
  v58 = v38;
  v39 = sub_3F3D8((int)v34, "Device Hardware%", 25, (const char *)&v58, 0);
  if ( *(_QWORD *)&dword_2463D0 )
  {
    LODWORD(v40) = sub_778B4(*(__int64 *)&dword_2463D0);
    v41 = dbl_242F10 / v40;
  }
  else
  {
    v41 = 0.0;
  }
  v59 = v41;
  v42 = sub_3F3D8((int)v39, "Device Rejected%", 25, (const char *)&v59, 0);
  v43 = dbl_242F10 + dbl_242EF0 + dbl_246238;
  if ( v43 == 0.0 )
    v44 = 0.0;
  else
    v44 = dbl_242F10 / v43;
  v60 = v44;
  v45 = sub_3F3D8((int)v42, "Pool Rejected%", 25, (const char *)&v60, 0);
  v46 = dbl_242EF0 + dbl_242F10 + dbl_246238;
  if ( v46 == 0.0 )
    v47 = 0.0;
  else
    v47 = dbl_246238 / v46;
  v61 = v47;
  v48 = sub_3F3D8((int)v45, "Pool Stale%", 25, (const char *)&v61, 0);
  v49 = (char **)sub_3F3D8((int)v48, "Last getwork", 16, (const char *)&dword_244020, 0);
  if ( pthread_mutex_unlock(&stru_2463B8) )
    sub_3E1F4("summary", 2844);
  off_9E444();
  result = sub_3E88C((unsigned int *)a1, v49, a4, 0);
  if ( (a4 & v51) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 437A4: variable 'v7' is possibly undefined
// 4382C: variable 'v11' is possibly undefined
// 43B20: variable 'v37' is possibly undefined
// 43B94: variable 'v40' is possibly undefined
// 9E444: using guessed type int (*off_9E444)();
// 9ED68: using guessed type double dbl_9ED68;
// 9ED80: using guessed type double dbl_9ED80;
// 1AF0D0: using guessed type int dword_1AF0D0;
// 1B09F8: using guessed type float flt_1B09F8;
// 1B09FC: using guessed type int dword_1B09FC;
// 1B0A10: using guessed type double dbl_1B0A10;
// 242E98: using guessed type int dword_242E98;
// 242EE8: using guessed type int dword_242EE8;
// 242EF0: using guessed type double dbl_242EF0;
// 242F00: using guessed type __int64 qword_242F00;
// 242F10: using guessed type double dbl_242F10;
// 242FDC: using guessed type int dword_242FDC;
// 244014: using guessed type int dword_244014;
// 244020: using guessed type int dword_244020;
// 245150: using guessed type int dword_245150;
// 245158: using guessed type __int64 qword_245158;
// 245168: using guessed type int dword_245168;
// 245228: using guessed type double dbl_245228;
// 246238: using guessed type double dbl_246238;
// 24625C: using guessed type int dword_24625C;
// 246360: using guessed type int dword_246360;
// 246368: using guessed type __int64 qword_246368;
// 2463B0: using guessed type double dbl_2463B0;
// 2463B8: using guessed type pthread_mutex_t stru_2463B8;
// 2463D0: using guessed type int dword_2463D0;

//----- (00043D0C) --------------------------------------------------------
const char *__fastcall sub_43D0C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 0, a3, a4);
}

//----- (00043D2C) --------------------------------------------------------
const char *__fastcall sub_43D2C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 1, a3, a4);
}

//----- (00043D4C) --------------------------------------------------------
const char *__fastcall sub_43D4C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 2, a3, a4);
}

//----- (00043D6C) --------------------------------------------------------
const char *__fastcall sub_43D6C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 3, a3, a4);
}

//----- (00043D8C) --------------------------------------------------------
const char *__fastcall sub_43D8C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 4, a3, a4);
}

//----- (00043DAC) --------------------------------------------------------
const char *__fastcall sub_43DAC(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 5, a3, a4);
}

//----- (00043DCC) --------------------------------------------------------
const char *__fastcall sub_43DCC(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 6, a3, a4);
}

//----- (00043DEC) --------------------------------------------------------
const char *__fastcall sub_43DEC(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 7, a3, a4);
}

//----- (00043E0C) --------------------------------------------------------
const char *__fastcall sub_43E0C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 8, a3, a4);
}

//----- (00043E2C) --------------------------------------------------------
const char *__fastcall sub_43E2C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 9, a3, a4);
}

//----- (00043E4C) --------------------------------------------------------
const char *__fastcall sub_43E4C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 10, a3, a4);
}

//----- (00043E6C) --------------------------------------------------------
const char *__fastcall sub_43E6C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 11, a3, a4);
}

//----- (00043E8C) --------------------------------------------------------
const char *__fastcall sub_43E8C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 12, a3, a4);
}

//----- (00043EAC) --------------------------------------------------------
const char *__fastcall sub_43EAC(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 13, a3, a4);
}

//----- (00043ECC) --------------------------------------------------------
const char *__fastcall sub_43ECC(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 14, a3, a4);
}

//----- (00043EEC) --------------------------------------------------------
const char *__fastcall sub_43EEC(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 15, a3, a4);
}

//----- (00043F0C) --------------------------------------------------------
const char *__fastcall sub_43F0C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 16, a3, a4);
}

//----- (00043F2C) --------------------------------------------------------
const char *__fastcall sub_43F2C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 17, a3, a4);
}

//----- (00043F4C) --------------------------------------------------------
const char *__fastcall sub_43F4C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 18, a3, a4);
}

//----- (00043F6C) --------------------------------------------------------
const char *__fastcall sub_43F6C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 19, a3, a4);
}

//----- (00043F8C) --------------------------------------------------------
const char *__fastcall sub_43F8C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 20, a3, a4);
}

//----- (00043FAC) --------------------------------------------------------
const char *__fastcall sub_43FAC(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 21, a3, a4);
}

//----- (00043FCC) --------------------------------------------------------
const char *__fastcall sub_43FCC(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 22, a3, a4);
}

//----- (00043FEC) --------------------------------------------------------
const char *__fastcall sub_43FEC(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 23, a3, a4);
}

//----- (0004400C) --------------------------------------------------------
const char *__fastcall sub_4400C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 24, a3, a4);
}

//----- (0004402C) --------------------------------------------------------
const char *__fastcall sub_4402C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 25, a3, a4);
}

//----- (0004404C) --------------------------------------------------------
const char *__fastcall sub_4404C(int a1, const char *a2, const char *a3, char a4)
{
  return sub_3F3D8(a1, a2, 26, a3, a4);
}

//----- (0004406C) --------------------------------------------------------
void sub_4406C()
{
  ;
}

//----- (000440C0) --------------------------------------------------------
void __fastcall sub_440C0(int *a1)
{
  int v2; // r0
  const char *v3; // r0
  const char *v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  int v29; // [sp+8h] [bp-824h] BYREF
  int v30; // [sp+Ch] [bp-820h] BYREF
  double v31; // [sp+10h] [bp-81Ch] BYREF
  int v32; // [sp+18h] [bp-814h] BYREF
  int v33; // [sp+1Ch] [bp-810h]
  __int64 v34; // [sp+20h] [bp-80Ch] BYREF
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  v2 = *a1;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0;
  v30 = 0;
  v3 = sub_3F3D8(v2, "Elapsed", 13, (const char *)&dbl_9ED68, 1);
  *a1 = (int)v3;
  v4 = sub_3F3D8((int)v3, "GHS 5s", 1, "14189.74", 0);
  *a1 = (int)v4;
  v31 = 14274.51;
  v5 = sub_3F3D8((int)v4, "GHS av", 17, (const char *)&v31, 1);
  *a1 = (int)v5;
  v6 = sub_3F3D8((int)v5, "Found Blocks", 7, (const char *)&v29, 1);
  *a1 = (int)v6;
  v32 = 20;
  v33 = 0;
  v7 = sub_3F3D8((int)v6, "Getworks", 11, (const char *)&v32, 1);
  *a1 = (int)v7;
  v32 = 82;
  v33 = 0;
  v8 = sub_3F3D8((int)v7, "Accepted", 11, (const char *)&v32, 1);
  *a1 = (int)v8;
  v32 = 0;
  v33 = 0;
  v9 = sub_3F3D8((int)v8, "Rejected", 11, (const char *)&v32, 1);
  *a1 = (int)v9;
  v10 = sub_3F3D8((int)v9, "Hardware Errors", 6, (const char *)&v30, 1);
  *a1 = (int)v10;
  v31 = 5.91;
  v11 = sub_3F3D8((int)v10, "Utility", 20, (const char *)&v31, 0);
  *a1 = (int)v11;
  v32 = 0;
  v33 = 0;
  v12 = sub_3F3D8((int)v11, "Discarded", 11, (const char *)&v32, 1);
  *a1 = (int)v12;
  v32 = 0;
  v33 = 0;
  v13 = sub_3F3D8((int)v12, "Stale", 11, (const char *)&v32, 1);
  *a1 = (int)v13;
  v14 = sub_3F3D8((int)v13, "Get Failures", 7, (const char *)&v29, 1);
  *a1 = (int)v14;
  v15 = sub_3F3D8((int)v14, "Local Work", 7, (const char *)&dword_246360, 1);
  *a1 = (int)v15;
  v16 = sub_3F3D8((int)v15, "Remote Failures", 7, (const char *)&v29, 1);
  *a1 = (int)v16;
  v17 = sub_3F3D8((int)v16, "Network Blocks", 7, (const char *)&dword_24625C, 1);
  *a1 = (int)v17;
  v18 = sub_3F3D8((int)v17, "Total MH", 18, (const char *)&dbl_245228, 1);
  *a1 = (int)v18;
  v31 = 0.0;
  v19 = sub_3F3D8((int)v18, "Work Utility", 20, (const char *)&v31, 0);
  *a1 = (int)v19;
  v31 = 1343488.0;
  v20 = sub_3F3D8((int)v19, "Difficulty Accepted", 24, (const char *)&v31, 1);
  *a1 = (int)v20;
  v31 = 16384.0;
  v21 = sub_3F3D8((int)v20, "Difficulty Rejected", 24, (const char *)&v31, 1);
  *a1 = (int)v21;
  v22 = sub_3F3D8((int)v21, "Difficulty Stale", 24, (const char *)&dbl_246238, 1);
  *a1 = (int)v22;
  v34 = 3432989;
  v23 = sub_3F3D8((int)v22, "Best Share", 10, (const char *)&v34, 1);
  *a1 = (int)v23;
  v31 = 0.0;
  v24 = sub_3F3D8((int)v23, "Device Hardware%", 25, (const char *)&v31, 0);
  *a1 = (int)v24;
  v25 = sub_3F3D8((int)v24, "Device Rejected%", 25, (const char *)&v31, 0);
  *a1 = (int)v25;
  v26 = sub_3F3D8((int)v25, "Pool Rejected%", 25, (const char *)&v31, 0);
  *a1 = (int)v26;
  v27 = sub_3F3D8((int)v26, "Pool Stale%", 25, (const char *)&v31, 0);
  *a1 = (int)v27;
  v28 = sub_3F3D8((int)v27, "Last getwork", 16, (const char *)&dword_244020, 0);
  *a1 = (int)v28;
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
  {
    snprintf(s, 0x800u, "root %d", v28);
    sub_47AB4(5, s, 0);
  }
}
// 9E320: using guessed type int dword_9E320;
// 9ED68: using guessed type double dbl_9ED68;
// 1AECC4: using guessed type char byte_1AECC4;
// 244020: using guessed type int dword_244020;
// 244080: using guessed type char byte_244080;
// 245228: using guessed type double dbl_245228;
// 246238: using guessed type double dbl_246238;
// 24625C: using guessed type int dword_24625C;
// 246360: using guessed type int dword_246360;

//----- (00044518) --------------------------------------------------------
int __fastcall sub_44518(unsigned int *a1, int a2, int a3, int a4)
{
  const char *v4; // r7
  int v6; // r2
  int v8; // r6
  unsigned int v9; // r2
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  char **v25; // r1
  _BOOL4 v26; // r3
  int v28; // [sp+Ch] [bp-4h] BYREF

  v6 = *(_DWORD *)(a3 + 244);
  v8 = a4;
  v28 = a2;
  if ( v6 )
  {
    v9 = *(_DWORD *)(a3 + 248);
    if ( v9 > 8 )
      v4 = (const char *)884;
    else
      a4 = 63020;
    if ( v9 > 8 )
      HIWORD(v4) = 8;
    else
      HIWORD(a4) = 7;
    if ( v9 <= 8 )
      v4 = *(const char **)(a4 + 4 * v9 + 144);
  }
  else
  {
    v4 = "None";
  }
  v10 = sub_3F3D8(0, "NOTIFY", 6, (const char *)&v28, 0);
  v11 = sub_3F3D8((int)v10, "Name", 1, *(const char **)(*(_DWORD *)(a3 + 4) + 8), 0);
  v12 = sub_3F3D8((int)v11, "ID", 6, (const char *)(a3 + 8), 0);
  v13 = sub_3F3D8((int)v12, "Last Well", 16, (const char *)(a3 + 240), 0);
  v14 = sub_3F3D8((int)v13, "Last Not Well", 16, (const char *)(a3 + 244), 0);
  v15 = sub_3F3D8((int)v14, "Reason Not Well", 1, v4, 0);
  v16 = sub_3F3D8((int)v15, "*Thread Fail Init", 6, (const char *)(a3 + 252), 0);
  v17 = sub_3F3D8((int)v16, "*Thread Zero Hash", 6, (const char *)(a3 + 256), 0);
  v18 = sub_3F3D8((int)v17, "*Thread Fail Queue", 6, (const char *)(a3 + 260), 0);
  v19 = sub_3F3D8((int)v18, "*Dev Sick Idle 60s", 6, (const char *)(a3 + 264), 0);
  v20 = sub_3F3D8((int)v19, "*Dev Dead Idle 600s", 6, (const char *)(a3 + 268), 0);
  v21 = sub_3F3D8((int)v20, "*Dev Nostart", 6, (const char *)(a3 + 272), 0);
  v22 = sub_3F3D8((int)v21, "*Dev Over Heat", 6, (const char *)(a3 + 276), 0);
  v23 = sub_3F3D8((int)v22, "*Dev Thermal Cutoff", 6, (const char *)(a3 + 280), 0);
  v24 = sub_3F3D8((int)v23, "*Dev Comms Error", 6, (const char *)(a3 + 284), 0);
  v25 = (char **)sub_3F3D8((int)v24, "*Dev Throttle", 6, (const char *)(a3 + 288), 0);
  if ( v8 )
    v26 = v28 > 0;
  else
    v26 = 0;
  return sub_3E88C(a1, v25, v8, v26);
}
// 445FC: variable 'v4' is possibly undefined

//----- (00044724) --------------------------------------------------------
int __fastcall sub_44724(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r9
  int v8; // r4
  int v9; // r0
  int v10; // r1

  if ( !dword_245140 )
    return sub_3F65C((unsigned int *)a1, 10, 0, 0, a4);
  result = sub_3F65C((unsigned int *)a1, 60, 0, 0, a4);
  if ( !a4 )
  {
    if ( dword_245140 <= 0 )
      return result;
    v7 = 0;
    goto LABEL_6;
  }
  result = sub_3C770((unsigned int *)a1, ",\"NOTIFY\":[");
  v7 = result;
  if ( dword_245140 > 0 )
  {
LABEL_6:
    v8 = 0;
    do
    {
      v9 = sub_56518(v8);
      v10 = v8++;
      result = sub_44518((unsigned int *)a1, v10, v9, a4);
    }
    while ( dword_245140 > v8 );
  }
  if ( v7 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 245140: using guessed type int dword_245140;

//----- (000447FC) --------------------------------------------------------
int sub_447FC()
{
  void *v0; // r0
  int result; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = calloc(1u, 0x40u);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc mcast thr");
    sub_47AB4(3, v2, 1);
    sub_62EC0(1);
  }
  result = sub_4BDCC((int)v0, 0, (void *(*)(void *))sub_3D8EC, v0);
  if ( result )
  {
    strcpy(v2, "API mcast thread create failed");
    sub_47AB4(3, v2, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (000448C4) --------------------------------------------------------
double sub_448C4()
{
  double v0; // d7
  double result; // r0

  v0 = dbl_9ED68;
  result = dbl_245228;
  if ( dbl_9ED68 > 0.0 )
    v0 = dbl_9ED68 - 1.0;
  dbl_2463B0 = dbl_245228;
  dbl_9ED80 = v0;
  return result;
}
// 9ED68: using guessed type double dbl_9ED68;
// 9ED80: using guessed type double dbl_9ED80;
// 245228: using guessed type double dbl_245228;
// 2463B0: using guessed type double dbl_2463B0;

//----- (0004490C) --------------------------------------------------------
void sub_4490C()
{
  int v0; // r5
  char *v1; // r7
  double v2; // d0
  int v3; // r3
  _BYTE *v4; // r0
  _DWORD *v5; // r0
  char *v6; // r3
  int v7; // r2
  bool v8; // zf
  const char *v9; // r4
  size_t v10; // r0
  unsigned __int8 *v11; // r5
  char *v12; // r0
  char *v13; // r0
  const __int32_t **v14; // r0
  const __int32_t *v15; // r2
  int v16; // r7
  __int32_t v17; // r1
  unsigned __int8 *v18; // r4
  int v19; // r8
  char *v20; // r0
  unsigned __int8 *v21; // r9
  const char *v22; // r5
  _UNKNOWN **v23; // r10
  int v24; // r6
  const char *v25; // t1
  size_t v26; // r0
  int v27; // r5
  char *v28; // r0
  const __int32_t **v29; // r0
  const char *v30; // r5
  _UNKNOWN **v31; // r4
  char *v32; // r7
  const char *v33; // t1
  size_t v34; // r0
  const char *v35; // t1
  char *v36; // r0
  size_t v37; // r0
  __int32_t v38; // r3
  int v39; // r4
  char *v40; // r0
  const char *v41; // r5
  size_t v42; // r0
  char *v43; // r0
  char *v44; // r8
  char *v45; // r2
  size_t v46; // r0
  int v47; // r3
  int v48; // t1
  int v49; // r6
  const char *v50; // r5
  int v51; // r3
  int v52; // t1
  bool v53; // zf
  char *v54; // r0
  char *v55; // r11
  const unsigned __int16 **v56; // r0
  int v57; // r2
  const __int32_t *v58; // r3
  char v59; // r1
  _BYTE *v60; // r4
  int v61; // r8
  char *v62; // r0
  int v63; // r8
  int v64; // r0
  const char **v65; // r4
  char *v66; // r8
  const char *v67; // t1
  const char *v68; // r9
  char *v69; // r0
  const char *v70; // r5
  char *v71; // r0
  _BYTE *v72; // r2
  _BYTE *v73; // r4
  _BYTE *v74; // r1
  _BYTE *v75; // r3
  _BYTE *v76; // r2
  int v77; // r2
  int v78; // lr
  _BYTE *v79; // r3
  int v80; // r1
  int v81; // r1
  _BYTE *v83; // r2
  _BYTE *v84; // r1
  _BYTE *v85; // r4
  _BYTE *v86; // r0
  char v87; // r3
  char v88; // t1
  char v89; // t1
  __int32_t v90; // r2
  struct addrinfo *v91; // r4
  struct addrinfo *i; // r3
  int v93; // r0
  int *v94; // r0
  char *v95; // r0
  time_t v96; // r8
  int *v97; // r0
  int v98; // r7
  int v99; // r4
  _BOOL4 v100; // r9
  const char *v101; // r1
  ssize_t v102; // r0
  int v103; // r5
  const char *v104; // r8
  time_t v105; // r0
  _BYTE *v106; // r3
  int v107; // r3
  char *v108; // r0
  size_t v109; // r0
  char *v110; // r6
  char *v111; // r0
  int v112; // r3
  const char *v113; // r1
  _UNKNOWN **v114; // r5
  int v115; // r4
  const char *v116; // t1
  size_t v117; // r0
  int *v118; // r3
  int v119; // r5
  __int32_t v120; // r2
  int v121; // r9
  int *v122; // r0
  char *v123; // r0
  int *v124; // r0
  char *v125; // r0
  int *v126; // r0
  double *v127; // r0
  int *v128; // r0
  char *v129; // r0
  const char *v130; // r3
  unsigned int *v131; // r3
  unsigned int v132; // r2
  unsigned int v133; // r2
  int *v134; // r0
  char *v135; // r0
  _DWORD *v136; // r0
  int *v137; // r0
  int v138; // r3
  int v139; // r0
  const __int32_t **v140; // [sp+14h] [bp-16460h]
  unsigned __int8 *v141; // [sp+18h] [bp-1645Ch]
  int *ptr; // [sp+20h] [bp-16454h]
  char *v143; // [sp+24h] [bp-16450h]
  double *v144; // [sp+2Ch] [bp-16448h]
  __int16 v145; // [sp+38h] [bp-1643Ch]
  int fd; // [sp+40h] [bp-16434h]
  const __int32_t **v147; // [sp+44h] [bp-16430h]
  char *dest; // [sp+48h] [bp-1642Ch]
  char *v149; // [sp+50h] [bp-16424h]
  char *v150; // [sp+5Ch] [bp-16418h]
  unsigned __int8 *v151; // [sp+60h] [bp-16414h]
  char *haystack; // [sp+64h] [bp-16410h]
  unsigned __int8 v153; // [sp+76h] [bp-163FEh] BYREF
  char v154; // [sp+77h] [bp-163FDh] BYREF
  const char *v155; // [sp+78h] [bp-163FCh] BYREF
  socklen_t addr_len; // [sp+7Ch] [bp-163F8h] BYREF
  struct addrinfo *ai; // [sp+80h] [bp-163F4h] BYREF
  int v158; // [sp+84h] [bp-163F0h] BYREF
  char service[12]; // [sp+88h] [bp-163ECh] BYREF
  char cp[32]; // [sp+94h] [bp-163E0h] BYREF
  struct addrinfo v161; // [sp+B4h] [bp-163C0h] BYREF
  _BYTE v162[12]; // [sp+D4h] [bp-163A0h] BYREF
  pthread_t th; // [sp+E0h] [bp-16394h]
  char v164[100]; // [sp+114h] [bp-16360h] BYREF
  char needle[100]; // [sp+178h] [bp-162FCh] BYREF
  struct sockaddr addr; // [sp+1DCh] [bp-16298h] BYREF
  char v167[252]; // [sp+25Ch] [bp-16218h] BYREF
  struct __jmp_buf_tag env; // [sp+358h] [bp-1611Ch] BYREF
  char s[2048]; // [sp+470h] [bp-16004h] BYREF
  char v170[2000]; // [sp+C70h] [bp-15804h] BYREF
  char v171[2000]; // [sp+1470h] [bp-15004h] BYREF
  char v172[2000]; // [sp+1C70h] [bp-14804h] BYREF
  char v173[2000]; // [sp+2470h] [bp-14004h] BYREF
  char v174[2000]; // [sp+2C70h] [bp-13804h] BYREF
  char v175[2000]; // [sp+3470h] [bp-13004h] BYREF
  char v176[1936]; // [sp+3C70h] [bp-12804h] BYREF
  char v177[1936]; // [sp+4470h] [bp-12004h] BYREF
  char v178[1936]; // [sp+4C70h] [bp-11804h] BYREF
  char v179[1936]; // [sp+5470h] [bp-11004h] BYREF
  char v180[1936]; // [sp+5C70h] [bp-10804h] BYREF
  char v181[1936]; // [sp+6470h] [bp-10004h] BYREF
  char v182[1936]; // [sp+6C70h] [bp-F804h] BYREF
  char v183[1936]; // [sp+7470h] [bp-F004h] BYREF
  char v184[1936]; // [sp+7C70h] [bp-E804h] BYREF
  char v185[1936]; // [sp+8470h] [bp-E004h] BYREF
  char v186[1936]; // [sp+8C70h] [bp-D804h] BYREF
  char v187[1936]; // [sp+9470h] [bp-D004h] BYREF
  char v188[1936]; // [sp+9C70h] [bp-C804h] BYREF
  char v189[1936]; // [sp+A470h] [bp-C004h] BYREF
  char v190[1936]; // [sp+AC70h] [bp-B804h] BYREF
  char v191[1936]; // [sp+B470h] [bp-B004h] BYREF
  char v192[1936]; // [sp+BC70h] [bp-A804h] BYREF
  char v193[1936]; // [sp+C470h] [bp-A004h] BYREF
  char v194[1936]; // [sp+CC70h] [bp-9804h] BYREF
  char v195[1936]; // [sp+D470h] [bp-9004h] BYREF
  char v196[1936]; // [sp+DC70h] [bp-8804h] BYREF
  char v197[1936]; // [sp+E470h] [bp-8004h] BYREF
  char v198[1936]; // [sp+EC70h] [bp-7804h] BYREF
  char v199[1936]; // [sp+F470h] [bp-7004h] BYREF
  char v200[1936]; // [sp+FC70h] [bp-6804h] BYREF
  char v201[8080]; // [sp+10470h] [bp-6004h] BYREF
  char v202[8080]; // [sp+12470h] [bp-4004h] BYREF
  _WORD v203[4098]; // [sp+14470h] [bp-2004h] BYREF

  v144 = 0;
  v145 = dword_9EE5C;
  ptr = (int *)malloc(4u);
  v3 = (unsigned __int8)byte_245205;
  *ptr = -1;
  if ( !v3 )
  {
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf(s, 0x800u, "API not running%s", " - API will not be available");
      sub_47AB4(7, s, 0);
    }
    goto LABEL_6;
  }
  v151 = (unsigned __int8 *)malloc(0x10u);
  v4 = malloc(0x10000u);
  *((_DWORD *)v151 + 1) = v4;
  *v4 = 0;
  v151[13] = 0;
  *((_DWORD *)v151 + 2) = v4;
  *(_DWORD *)v151 = 0x10000;
  v151[12] = 1;
  v5 = malloc(0xCu);
  v6 = &byte_1AEB6C;
  *v5 = v151;
  v7 = dword_1AEB90;
  v8 = dword_1AEB90 == 0;
  if ( dword_1AEB90 )
  {
    v5[2] = dword_1AEB90;
    v6 = *(char **)(v7 + 4);
  }
  else
  {
    v5[1] = v5;
    v5[2] = v5;
  }
  if ( v8 )
  {
    *((_DWORD *)v6 + 9) = v5;
  }
  else
  {
    v5[1] = v6;
    *(_DWORD *)(v7 + 4) = v5;
    v6 = (char *)v5[1];
  }
  if ( !v8 )
    *((_DWORD *)v6 + 2) = v5;
  if ( pthread_mutex_init(&stru_1AEB78, 0) )
  {
    v126 = _errno_location();
    snprintf(v189, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v126, "api.c", "api", 5189);
    sub_47AB4(3, v189, 1);
    sub_62EC0(1);
  }
  if ( _sigsetjmp(&env, 0) )
  {
    sub_3E48C(ptr);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&env);
LABEL_263:
    freeaddrinfo(ai);
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      snprintf(v175, 0x800u, "API bind to port %d failed (%s)%s", v0, v1, " - API will not be available");
      sub_47AB4(3, v175, 0);
    }
    goto LABEL_6;
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&env);
  v9 = (const char *)dword_242E60;
  if ( dword_242E60 )
  {
    v10 = strlen((const char *)dword_242E60) + 1;
  }
  else
  {
    v9 = "";
    v10 = 1;
  }
  dest = (char *)malloc(v10);
  if ( !dest )
  {
    strcpy(v190, "Failed to malloc ipgroups buf");
    sub_47AB4(3, v190, 1);
    sub_62EC0(1);
  }
  v11 = (unsigned __int8 *)dest;
  strcpy(dest, v9);
  if ( *dest )
  {
    do
    {
      v12 = strchr((const char *)v11, 44);
      if ( v12 )
      {
        *v12 = 0;
        v141 = (unsigned __int8 *)(v12 + 1);
      }
      else
      {
        v141 = 0;
      }
      if ( v11[1] != 58 )
      {
        v13 = strchr((const char *)v11, 58);
        if ( v13 )
          *v13 = 0;
        snprintf(v191, 0x800u, "API invalid group name '%s'", v11);
        sub_47AB4(3, v191, 1);
        sub_62EC0(1);
      }
      v14 = _ctype_toupper_loc();
      v15 = *v14;
      v140 = v14;
      v16 = LOBYTE((*v14)[*v11]);
      v17 = (*v14)[v16];
      if ( v17 < (*v14)[65] || v17 > v15[90] )
      {
        snprintf(v192, 0x800u, "API invalid group name '%c'");
        sub_47AB4(3, v192, 1);
        sub_62EC0(1);
      }
      if ( v16 == v15[87] )
      {
        snprintf(v193, 0x800u, "API group name can't be '%c'", v16);
        sub_47AB4(3, v193, 1);
        sub_62EC0(1);
      }
      if ( v16 == v15[82] )
      {
        snprintf(v194, 0x800u, "API group name can't be '%c'", v16);
        sub_47AB4(3, v194, 1);
        sub_62EC0(1);
      }
      if ( *((_DWORD *)&unk_242DF4 + v15[v16] - v15[65]) )
      {
        snprintf(v195, 0x800u, "API duplicate group name '%c'", *v11);
        sub_47AB4(3, v195, 1);
        sub_62EC0(1);
      }
      v18 = v11 + 2;
      v203[0] = 124;
      if ( v11 != (unsigned __int8 *)-2 && v11[2] )
      {
        v19 = 0;
        v143 = (char *)v203 + 1;
        do
        {
          v20 = strchr((const char *)v18, 58);
          if ( v20 )
          {
            v21 = (unsigned __int8 *)(v20 + 1);
            *v20 = 0;
          }
          else
          {
            v21 = 0;
          }
          if ( *v18 != 42 || v18[1] )
          {
            v22 = (const char *)off_9DD3C;
            if ( !off_9DD3C )
            {
LABEL_104:
              snprintf(v196, 0x800u, "API unknown command '%s' in group '%c'", v18, v16);
              sub_47AB4(3, v196, 1);
              sub_62EC0(1);
            }
            v23 = &off_9DD3C;
            v24 = 0;
            while ( strcasecmp((const char *)v18, v22) )
            {
              v25 = (const char *)v23[3];
              v23 += 3;
              v22 = v25;
              ++v24;
              if ( !v25 )
                goto LABEL_104;
            }
            sprintf(needle, "|%s|", v22);
            if ( !strstr((const char *)v203, needle) )
            {
              v70 = (const char *)dword_9D80C[3 * v24 + 332];
              strcpy(v143, v70);
              v71 = &v143[strlen(v70)];
              v71[1] = 0;
              v143 = v71 + 1;
              *v71 = 124;
            }
          }
          else
          {
            v19 = 1;
          }
          if ( !v21 )
            break;
          v18 = v21;
        }
        while ( *v21 );
        if ( v19 && off_9DD3C )
        {
          v65 = (const char **)&off_9DD3C;
          v66 = v143;
          do
          {
            if ( !*((_BYTE *)v65 + 8) )
            {
              sprintf(needle, "|%s|");
              if ( !strstr((const char *)v203, needle) )
              {
                v68 = *v65;
                strcpy(v66, *v65);
                v69 = &v66[strlen(v68)];
                v66 = v69 + 1;
                v69[1] = 0;
                *v69 = 124;
              }
            }
            v67 = v65[3];
            v65 += 3;
          }
          while ( v67 );
        }
      }
      v26 = strlen((const char *)v203);
      v27 = (*v140)[v16] - (*v140)[65];
      v28 = (char *)malloc(v26 + 1);
      *((_DWORD *)&unk_242DF4 + v27) = v28;
      if ( !v28 )
      {
        strcpy(v197, "Failed to malloc group commands buf");
        sub_47AB4(3, v197, 1);
        sub_62EC0(1);
      }
      strcpy(v28, (const char *)v203);
      if ( !v141 )
        break;
      v11 = v141;
    }
    while ( *v141 );
  }
  v29 = _ctype_toupper_loc();
  v30 = (const char *)off_9DD3C;
  v147 = v29;
  v203[0] = 124;
  if ( off_9DD3C )
  {
    v31 = &off_9DD3C;
    v32 = (char *)v203 + 1;
    do
    {
      while ( *((_BYTE *)v31 + 8) )
      {
        v33 = (const char *)v31[3];
        v31 += 3;
        v30 = v33;
        if ( !v33 )
          goto LABEL_60;
      }
      strcpy(v32, v30);
      v34 = strlen(v30);
      v35 = (const char *)v31[3];
      v31 += 3;
      v30 = v35;
      v36 = &v32[v34];
      v32 = v36 + 1;
      *v36 = 124;
      v36[1] = 0;
    }
    while ( v35 );
  }
LABEL_60:
  v37 = strlen((const char *)v203) + 1;
  v38 = (*v147)[82];
  if ( (unsigned int)(v38 + 128) < 0x180 )
    v38 = (*v147)[v38];
  v39 = v38 - (*v147)[65];
  v40 = (char *)malloc(v37);
  *((_DWORD *)&unk_242DF4 + v39) = v40;
  if ( !v40 )
  {
    strcpy(v198, "Failed to malloc noprivgroup commands buf");
    sub_47AB4(3, v198, 1);
    sub_62EC0(1);
  }
  strcpy(v40, (const char *)v203);
  free(dest);
  v41 = (const char *)dword_1B0B20;
  if ( dword_1B0B20 )
  {
    v42 = strlen((const char *)dword_1B0B20);
    v43 = (char *)malloc(v42 + 1);
    v44 = v43;
    if ( !v43 )
    {
      strcpy(v199, "Failed to malloc ipaccess buf");
      sub_47AB4(3, v199, 1);
      sub_62EC0(1);
    }
    strcpy(v43, v41);
    v45 = v44 - 1;
    v46 = 1;
    while ( 1 )
    {
      v48 = (unsigned __int8)*++v45;
      v47 = v48;
      if ( !v48 )
        break;
      if ( v47 == 44 )
        ++v46;
    }
    dword_1AEB70 = (int)calloc(v46, 0x24u);
    if ( !dword_1AEB70 )
    {
      strcpy(v200, "Failed to calloc ipaccess");
      sub_47AB4(3, v200, 1);
      sub_62EC0(1);
    }
    v49 = 0;
    v50 = v44;
    v149 = v44;
    dword_1AEB74 = 0;
    while ( 1 )
    {
      v51 = *(unsigned __int8 *)v50;
      if ( !*v50 )
      {
LABEL_96:
        free(v149);
        if ( v49 )
          goto LABEL_97;
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
        {
          snprintf(v170, 0x800u, "API not running (no valid IPs specified)%s", " - API will not be available");
          sub_47AB4(4, v170, 0);
        }
LABEL_6:
        free(ptr);
        return;
      }
      while ( 1 )
      {
        v53 = v51 == 9;
        if ( v51 != 9 )
          v53 = v51 == 32;
        if ( !v53 )
          break;
        v52 = *(unsigned __int8 *)++v50;
        v51 = v52;
      }
      if ( v51 != 44 )
        break;
      ++v50;
LABEL_95:
      if ( !v50 )
        goto LABEL_96;
    }
    v54 = strchr(v50, 44);
    if ( v54 )
    {
      v55 = v54 + 1;
      *v54 = 0;
    }
    else
    {
      v55 = 0;
    }
    v56 = _ctype_b_loc();
    v57 = *(unsigned __int8 *)v50;
    v58 = *v147;
    v59 = *((_BYTE *)*v147 + 328);
    if ( ((*v56)[v57] & 0x400) != 0 && v50[1] == 58 )
    {
      v90 = v58[v57];
      if ( v90 == v58[87] || *((_DWORD *)&unk_242DF4 + v90 - v58[65]) )
        v59 = v90;
      v50 += 2;
    }
    v60 = (_BYTE *)(dword_1AEB70 + 36 * v49);
    v60[32] = v59;
    v61 = *(unsigned __int8 *)v50;
    if ( v61 == 48 )
    {
      if ( v50[1] == 47 && v50[2] == 48 && !v50[3] )
      {
        v72 = v60 + 15;
        v73 = v60 - 1;
        v74 = v72;
        do
        {
          *++v73 = 0;
          *++v72 = 0;
        }
        while ( v73 != v74 );
        goto LABEL_118;
      }
      v62 = strchr(v50, 47);
      if ( v62 )
        goto LABEL_88;
    }
    else
    {
      v62 = strchr(v50, 47);
      if ( v62 )
        goto LABEL_86;
    }
    v75 = v60 + 15;
    do
      *++v75 = -1;
    while ( v60 + 31 != v75 );
    v61 = *(unsigned __int8 *)v50;
    v62 = (char *)&v50[strlen(v50)];
LABEL_86:
    if ( v61 == 91 && *(v62 - 1) == 93 )
    {
      v63 = 1;
      *v50++ = 0;
      *(v62 - 1) = 0;
LABEL_89:
      if ( *v62 )
      {
        *v62 = 0;
        v64 = strtol(v62 + 1, 0, 10);
        if ( v64 <= 0 )
          goto LABEL_94;
        if ( !v63 )
          v64 += 96;
        if ( v64 > 128 )
        {
LABEL_94:
          v50 = v55;
          goto LABEL_95;
        }
        v76 = v60 + 15;
        do
          *++v76 = 0;
        while ( v60 + 31 != v76 );
        v77 = 0;
        v78 = 7;
        while ( v64-- != 0 )
        {
          v79 = &v60[v77];
          v80 = (unsigned __int8)v60[v77 + 16];
          if ( !v78 )
            ++v77;
          v81 = v80 | (1 << v78);
          if ( v78 )
            --v78;
          else
            v78 = 7;
          v79[16] = v81;
        }
      }
      v83 = v60 - 1;
      do
        *++v83 = 0;
      while ( v60 + 15 != v83 );
      if ( v63 )
      {
        if ( inet_pton(10, v50, v60) == 1 )
          goto LABEL_137;
      }
      else
      {
        sprintf(cp, "::ffff:%s", v50);
        v49 = dword_1AEB74;
        v60 = (_BYTE *)(dword_1AEB70 + 36 * dword_1AEB74);
        if ( inet_pton(10, cp, v60) == 1 )
        {
LABEL_137:
          v84 = v60 + 15;
          v85 = v60 - 1;
          v86 = v84;
          do
          {
            v88 = *++v85;
            v87 = v88;
            v89 = *++v84;
            *v85 = v87 & v89;
          }
          while ( v85 != v86 );
LABEL_118:
          ++v49;
          v50 = v55;
          dword_1AEB74 = v49;
          goto LABEL_95;
        }
      }
      goto LABEL_94;
    }
LABEL_88:
    v63 = 0;
    goto LABEL_89;
  }
LABEL_97:
  v0 = v145;
  sub_4A804();
  sprintf(service, "%d", v145);
  memset(&v161.ai_family, 0, 28);
  v161.ai_flags = 1;
  if ( getaddrinfo(off_9EE58, service, &v161, &ai) )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      snprintf(v171, 0x800u, "API failed to resolve %s", off_9EE58);
      sub_47AB4(3, v171, 0);
    }
    goto LABEL_6;
  }
  v91 = ai;
  if ( ai )
  {
    for ( i = ai; ; i = ai )
    {
      v93 = socket(i->ai_family, 1, 0);
      *ptr = v93;
      if ( v93 > 0 )
        break;
      v91 = v91->ai_next;
      if ( !v91 )
        goto LABEL_233;
    }
  }
  else
  {
    v93 = *ptr;
LABEL_233:
    if ( v93 == -1 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
      {
        v122 = _errno_location();
        v123 = strerror(*v122);
        snprintf(v172, 0x800u, "API initialisation failed (%s)%s", v123, " - API will not be available");
        sub_47AB4(3, v172, 0);
      }
      freeaddrinfo(ai);
      free(ptr);
      return;
    }
    v91 = 0;
  }
  v158 = 1;
  if ( setsockopt(v93, 1, 2, &v158, 4u) < 0 && byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    v94 = _errno_location();
    v95 = strerror(*v94);
    snprintf(v173, 0x800u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v95);
    sub_47AB4(7, v173, 0);
  }
  v96 = time(0);
  while ( bind(*ptr, v91->ai_addr, v91->ai_addrlen) < 0 )
  {
    v97 = _errno_location();
    v1 = strerror(*v97);
    if ( time(0) - v96 > 61 )
      goto LABEL_263;
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
    {
      snprintf(v174, 0x800u, "API bind to port %d failed - trying again in 30sec", v145);
      sub_47AB4(4, v174, 0);
    }
    sub_4A804();
  }
  freeaddrinfo(ai);
  if ( listen(*ptr, 100) < 0 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      v134 = _errno_location();
      v135 = strerror(*v134);
      snprintf(v176, 0x800u, "API3 initialisation failed (%s)%s", v135, " - API will not be available");
      sub_47AB4(3, v176, 0);
    }
    close(*ptr);
    free(ptr);
    return;
  }
  if ( dword_1B0B20 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
    {
      snprintf(v177, 0x800u, "API running in IP access mode on port %d (%d)", v145, *ptr);
      sub_47AB4(4, v177, 0);
    }
  }
  else if ( byte_24633C )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
    {
      snprintf(v178, 0x800u, "API running in UNRESTRICTED read access mode on port %d (%d)", v145, *ptr);
      sub_47AB4(4, v178, 0);
    }
  }
  else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
  {
    snprintf(v179, 0x800u, "API running in local read access mode on port %d (%d)", v145, *ptr);
    sub_47AB4(4, v179, 0);
  }
  if ( byte_242FFD )
    sub_447FC();
  v98 = 0;
  dword_1AEB94 = (int)sub_46C54("StrBufs", 12, 2, 0, 0, "api.c", "api", 5301);
  while ( 1 )
  {
    v99 = (unsigned __int8)byte_1AEB6C;
    if ( byte_1AEB6C )
      goto LABEL_282;
    addr_len = 128;
    fd = accept(*ptr, &addr, &addr_len);
    if ( fd < 0 )
      break;
    v100 = sub_3CB84(&addr, &v155, &v153);
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      v101 = "Accepted";
      if ( !v100 )
        v101 = "Ignored";
      snprintf(v181, 0x800u, "API: connection from %s - %s", v155, v101);
      sub_47AB4(7, v181, 0);
    }
    if ( v100 )
    {
      v102 = recv(fd, v201, 0xFFFu, 0);
      v103 = v102;
      if ( v102 >= 0 )
      {
        v8 = byte_1AECC5 == 0;
        v201[v102] = 0;
        if ( !v8 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
        {
          snprintf(v183, 0x800u, "API: recv command: (%d) '%s'", v102, v201);
          sub_47AB4(7, v183, 0);
        }
        v104 = v201;
        v105 = time(0);
        v106 = (_BYTE *)*((_DWORD *)v151 + 1);
        *((_DWORD *)v151 + 2) = v106;
        dword_1AEB98 = v105;
        *v106 = 0;
        v107 = (unsigned __int8)v201[0];
        v151[13] = 0;
        if ( v107 == 123 )
        {
          v127 = sub_6D1D0((int)v201, v103, 0, v167);
          v144 = v127;
          if ( v127 && !*(_DWORD *)v127 )
          {
            v136 = (_DWORD *)sub_6DFCC(v127, "command");
            if ( v136 )
            {
              if ( *v136 == 2 )
              {
                v104 = (const char *)sub_6E350(v136);
                v137 = (int *)sub_6DFCC(v144, "parameter");
                if ( v137 )
                {
                  v138 = *v137;
                  if ( *v137 == 2 )
                  {
                    v150 = (char *)sub_6E350(v137);
                  }
                  else if ( v138 == 3 )
                  {
                    v139 = sub_6E430((int)v137);
                    v150 = v202;
                    sprintf(v202, "%d", v139);
                  }
                  else if ( v138 == 4 )
                  {
                    sub_6E4E0();
                    v150 = v202;
                    sprintf(v202, "%f", v2);
                  }
                  else
                  {
                    v150 = 0;
                  }
                }
                else
                {
                  v150 = 0;
                }
                goto LABEL_200;
              }
              sub_3F65C((unsigned int *)v151, 14, 0, 0, 1u);
            }
            else
            {
              sub_3F65C((unsigned int *)v151, 24, 0, 0, 1u);
            }
          }
          else
          {
            sub_3F65C((unsigned int *)v151, 23, 0, 0, 1u);
          }
          sub_3DAA0(*((const char **)v151 + 1), v151[13], fd, 1);
LABEL_276:
          if ( v98 )
            sub_3DAA0(*((const char **)v151 + 1), v151[13], fd, v100);
LABEL_225:
          if ( v144 )
            v121 = v100;
          else
            v121 = 0;
          if ( v121 )
          {
            if ( !*(_DWORD *)v144 && *((_DWORD *)v144 + 1) != -1 )
            {
              v131 = (unsigned int *)v144 + 1;
              __dmb(0xBu);
              do
              {
                v132 = __ldrex(v131);
                v133 = v132 - 1;
              }
              while ( __strex(v133, v131) );
              if ( !v133 )
                sub_6E5DC((void **)v144);
            }
          }
          goto LABEL_230;
        }
        v108 = strchr(v201, 124);
        if ( v108 )
        {
          v100 = v99;
          *v108 = 0;
          v150 = v108 + 1;
        }
        else
        {
          v150 = 0;
          v100 = v99;
        }
LABEL_200:
        haystack = strchr(v104, 43);
        if ( haystack )
        {
          v98 = 1;
          v154 = 1;
          v109 = strlen(v104);
          haystack = (char *)malloc(v109 + 3);
          if ( !haystack )
          {
            snprintf(v184, 0x800u, "OOM cmdsbuf in %s %s():%d", "api.c", "api", 5412);
            sub_47AB4(3, v184, 1);
            sub_62EC0(1);
          }
          v150 = 0;
          *(_WORD *)haystack = 124;
        }
        else
        {
          v98 = v99;
          v154 = 0;
        }
        v110 = (char *)v104;
        if ( !v98 )
        {
          v113 = (const char *)off_9DD3C;
          if ( off_9DD3C )
            goto LABEL_214;
          goto LABEL_247;
        }
        while ( 2 )
        {
          v111 = strchr(v110, 43);
          if ( v111 )
          {
            v104 = v111 + 1;
            *v111 = 0;
          }
          else
          {
            v104 = 0;
          }
          if ( !*v110 )
          {
LABEL_208:
            if ( v104 )
              v112 = v98 & 1;
            else
              v112 = 0;
            v110 = (char *)v104;
            if ( !v112 )
              goto LABEL_276;
            continue;
          }
          break;
        }
        v113 = (const char *)off_9DD3C;
        if ( off_9DD3C )
        {
LABEL_214:
          v114 = &off_9DD3C;
          v115 = 0;
          while ( strcmp(v110, v113) )
          {
            v116 = (const char *)v114[3];
            v114 += 3;
            v113 = v116;
            ++v115;
            if ( !v116 )
            {
              if ( !v98 )
                goto LABEL_247;
              goto LABEL_246;
            }
          }
          sprintf(v164, "|%s|", v110);
          if ( v98 )
          {
            if ( strstr(haystack, v164) )
              goto LABEL_208;
            v117 = strlen(haystack);
            strcpy((char *)stpcpy(&haystack[v117], v110), "|");
            sub_3CA78((unsigned int *)v151, v110, v100, &v154);
            v118 = &dword_9D80C[3 * v115];
            if ( !*((_BYTE *)v118 + 1337) )
            {
              sub_3F65C((unsigned int *)v151, 45, *((unsigned __int8 *)v118 + 1337), v118[332], v100);
              sub_3D924((int)v151, v100);
              goto LABEL_224;
            }
          }
          v119 = v153;
          v120 = (*v147)[v153];
          if ( v120 == (*v147)[87] || strstr(*((const char **)&unk_242DF4 + v120 - (*v147)[65]), v164) )
          {
            ((void (__fastcall *)(unsigned __int8 *, int, char *, _BOOL4, int))dword_9D80C[3 * v115 + 333])(
              v151,
              fd,
              v150,
              v100,
              v119);
          }
          else
          {
            sub_3F65C((unsigned int *)v151, 45, 0, dword_9D80C[3 * v115 + 332], v100);
            if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
            {
              snprintf(
                v185,
                0x800u,
                "API: access denied to '%s' for '%s' command",
                v155,
                (const char *)dword_9D80C[3 * v115 + 332]);
              sub_47AB4(7, v185, 0);
            }
          }
          if ( (unsigned __int8)v98 == 1 )
            goto LABEL_248;
        }
        else
        {
LABEL_246:
          sub_3CA78((unsigned int *)v151, v110, v100, &v154);
LABEL_247:
          sub_3F65C((unsigned int *)v151, 14, 0, 0, v100);
          if ( v98 )
          {
LABEL_248:
            sub_3D924((int)v151, v100);
LABEL_224:
            if ( !v98 )
              goto LABEL_225;
            goto LABEL_208;
          }
        }
        sub_3DAA0(*((const char **)v151 + 1), v151[13], fd, v100);
        goto LABEL_224;
      }
      v201[0] = 0;
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        v124 = _errno_location();
        v125 = strerror(*v124);
        snprintf(v182, 0x800u, "API: recv failed: %s", v125);
        sub_47AB4(7, v182, 0);
      }
    }
LABEL_230:
    close(fd);
  }
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
  {
    v128 = _errno_location();
    v129 = strerror(*v128);
    snprintf(v180, 0x800u, "API failed (%s)%s (%d)", v129, " - API will not be available", *ptr);
    sub_47AB4(3, v180, 0);
  }
LABEL_282:
  _pthread_unregister_cancel((__pthread_unwind_buf_t *)&env);
  sub_3E48C(ptr);
  free(ptr);
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    if ( byte_1AEB6D )
    {
      v130 = "QUIT";
    }
    else if ( byte_1AEB6E )
    {
      v130 = "RESTART";
    }
    else
    {
      v130 = "UNKNOWN!";
      if ( byte_1AEB6C )
        v130 = (const char *)&unk_7F6F4;
    }
    snprintf(v186, 0x800u, "API: terminating due to: %s", v130);
    sub_47AB4(7, v186, 0);
  }
  if ( pthread_mutex_lock(&stru_1AEB78) )
    sub_3E190("api", 5511);
  if ( byte_1AEB6E )
  {
    if ( sub_4BDCC((int)v162, 0, (void *(*)(void *))sub_3E708, v162) )
    {
      if ( !pthread_mutex_unlock(&stru_1AEB78) )
      {
        off_9E444();
        strcpy(v187, "API failed to initiate a restart - aborting");
        sub_47AB4(3, v187, 1);
        sub_62EC0(1);
      }
      sub_3E1F4("api", 5517);
    }
  }
  else
  {
    if ( !byte_1AEB6D )
      goto LABEL_296;
    if ( sub_4BDCC((int)v162, (const pthread_attr_t *)(unsigned __int8)byte_1AEB6E, (void *(*)(void *))sub_3E580, v162) )
    {
      if ( pthread_mutex_unlock(&stru_1AEB78) )
        sub_3E1F4("api", 5526);
      off_9E444();
      strcpy(v188, "API failed to initiate a clean quit - aborting");
      sub_47AB4(3, v188, 1);
      sub_62EC0(1);
    }
  }
  pthread_detach(th);
LABEL_296:
  if ( pthread_mutex_unlock(&stru_1AEB78) )
    sub_3E1F4("api", 5532);
  off_9E444();
}
// 45B00: conditional instruction was optimized away because r7.4 is in (1..FF)
// 46010: variable 'v0' is possibly undefined
// 46010: variable 'v1' is possibly undefined
// 467CC: variable 'v2' is possibly undefined
// 12064: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 9D80C: using guessed type int dword_9D80C[];
// 9DD3C: using guessed type _UNKNOWN *off_9DD3C;
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9ED78: using guessed type int dword_9ED78;
// 9EE58: using guessed type char *off_9EE58;
// 9EE5C: using guessed type int dword_9EE5C;
// 1AEB6C: using guessed type char byte_1AEB6C;
// 1AEB6D: using guessed type char byte_1AEB6D;
// 1AEB6E: using guessed type char byte_1AEB6E;
// 1AEB70: using guessed type int dword_1AEB70;
// 1AEB74: using guessed type int dword_1AEB74;
// 1AEB90: using guessed type int dword_1AEB90;
// 1AEB94: using guessed type int dword_1AEB94;
// 1AEB98: using guessed type int dword_1AEB98;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1B0B20: using guessed type int dword_1B0B20;
// 242E60: using guessed type int dword_242E60;
// 242FFD: using guessed type char byte_242FFD;
// 244080: using guessed type char byte_244080;
// 245205: using guessed type char byte_245205;
// 24633C: using guessed type char byte_24633C;

//----- (00046870) --------------------------------------------------------
void *__fastcall sub_46870(const char **a1, const char *a2, const char *a3, int a4)
{
  void *result; // r0
  int v6; // r3
  const char *v7; // r2
  signed int v8; // r6
  char *v9; // r0
  int v10; // r1
  const char *v11; // r0
  char *v12; // r5
  const char *v13; // r3
  const char *v14; // r1
  __int64 v15; // r2
  int v16; // r0
  int v17; // r3
  int v18; // r2
  const char *v19; // r3
  char *v20; // r0
  int v21; // r1
  const char *v22; // r0
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = (void *)*((unsigned __int8 *)a1 + 4);
  if ( result )
  {
    snprintf(
      s,
      0x800u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *a1,
      "k_alloc_items",
      a2,
      a3,
      a4,
      "klist.c",
      "k_alloc_items",
      19);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v6 = (int)a1[10];
  if ( v6 <= 0 )
  {
    v8 = (signed int)a1[9];
  }
  else
  {
    v7 = a1[6];
    if ( v6 <= (int)v7 )
      return result;
    v8 = (signed int)a1[9];
    if ( v6 < (int)&v7[v8] )
      v8 = v6 - (_DWORD)v7;
  }
  v9 = (char *)a1[13];
  v10 = (int)(a1[12] + 1);
  a1[12] = (const char *)v10;
  v11 = (const char *)realloc(v9, 4 * v10);
  a1[13] = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x800u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *a1,
      a1[12],
      "klist.c",
      "k_alloc_items",
      33);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v12 = (char *)calloc(v8, 0x10u);
  if ( !v12 )
  {
    snprintf(
      s,
      0x800u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *a1,
      v8,
      a1[6],
      a1[10],
      "klist.c",
      "k_alloc_items",
      38);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  *(_DWORD *)&a1[13][4 * (_DWORD)(a1[12] + 0x3FFFFFFF)] = v12;
  v13 = a1[6];
  v14 = *a1;
  a1[7] = (const char *)v8;
  a1[8] = (const char *)v8;
  a1[6] = &v13[v8];
  *(_DWORD *)v12 = v14;
  *((_DWORD *)v12 + 1) = 0;
  *((_DWORD *)v12 + 2) = v12 + 16;
  if ( v8 > 2 )
  {
    HIDWORD(v15) = v12 + 32;
    do
    {
      LODWORD(v15) = HIDWORD(v15) - 32;
      *(_DWORD *)(HIDWORD(v15) - 16) = v14;
      *(_QWORD *)(HIDWORD(v15) - 12) = v15;
      HIDWORD(v15) += 16;
    }
    while ( (char *)HIDWORD(v15) != &v12[16 * v8] );
  }
  v16 = *((unsigned __int8 *)a1 + 44);
  v17 = 16 * (v8 + 0xFFFFFFF);
  *(_DWORD *)&v12[v17] = v14;
  a1[3] = v12;
  v18 = v17 - 16;
  v19 = &v12[v17];
  *((_DWORD *)v19 + 1) = &v12[v18];
  *((_DWORD *)v19 + 2) = 0;
  if ( v16 )
    a1[4] = v19;
  do
  {
    v20 = (char *)a1[15];
    v21 = (int)(a1[14] + 1);
    a1[14] = (const char *)v21;
    v22 = (const char *)realloc(v20, 4 * v21);
    a1[15] = v22;
    if ( !v22 )
    {
      snprintf(
        s,
        0x800u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *a1,
        a1[14],
        "klist.c",
        "k_alloc_items",
        69);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    result = calloc(1u, (size_t)a1[5]);
    *((_DWORD *)v12 + 3) = result;
    if ( !result )
    {
      snprintf(s, 0x800u, "List %s failed to calloc item data in %s %s():%d", *a1, "klist.c", "k_alloc_items", 73);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    *(_DWORD *)&a1[15][4 * (_DWORD)(a1[14] + 0x3FFFFFFF)] = result;
    v12 = (char *)*((_DWORD *)v12 + 2);
  }
  while ( v12 );
  return result;
}

//----- (00046BAC) --------------------------------------------------------
_DWORD *__fastcall sub_46BAC(int a1)
{
  _DWORD *result; // r0
  const char *v3; // r3
  int v4; // r12
  char v5; // r1
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = calloc(1u, 0x40u);
  v3 = *(const char **)a1;
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to calloc store for %s in %s %s():%d", v3, "klist.c", "k_new_store", 85);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_BYTE *)(a1 + 44);
  *result = v3;
  result[2] = v4;
  *((_BYTE *)result + 44) = v5;
  *((_BYTE *)result + 4) = 1;
  return result;
}

//----- (00046C54) --------------------------------------------------------
_BYTE *__fastcall sub_46C54(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8)
{
  _BYTE *v12; // r0
  _BYTE *v13; // r4
  pthread_mutex_t *v14; // r0
  pthread_mutex_t *v15; // r5
  int *v17; // r0
  int *v18; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( a3 <= 0 )
  {
    snprintf(
      s,
      0x800u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      a1,
      a3,
      "klist.c",
      "_k_new_list",
      100);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( a4 < 0 )
  {
    snprintf(
      s,
      0x800u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      a1,
      a4,
      "klist.c",
      "_k_new_list",
      103);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v12 = calloc(1u, 0x40u);
  v13 = v12;
  if ( !v12 )
  {
    snprintf(s, 0x800u, "Failed to calloc list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 107);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v12[4] = 0;
  v14 = (pthread_mutex_t *)calloc(1u, 0x38u);
  v15 = v14;
  *((_DWORD *)v13 + 2) = v14;
  if ( !v14 )
  {
    snprintf(s, 0x800u, "Failed to calloc lock for list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 113);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_init(v14, 0) )
  {
    v18 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v18, "klist.c", "_k_new_list", 115);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&v15[1], 0) )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v17, "klist.c", "_k_new_list", 115);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  *(_DWORD *)v13 = a1;
  *((_DWORD *)v13 + 5) = a2;
  *((_DWORD *)v13 + 9) = a3;
  *((_DWORD *)v13 + 10) = a4;
  v13[44] = a5;
  sub_46870((const char **)v13, a6, a7, a8);
  return v13;
}

//----- (00046F04) --------------------------------------------------------
int __fastcall sub_46F04(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r12
  int v6; // r3

  v5 = *(_DWORD *)(a1 + 12);
  if ( !v5 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      return 0;
    sub_46870((const char **)a1, a2, a3, a4);
    v5 = *(_DWORD *)(a1 + 12);
    if ( !v5 )
      return 0;
  }
  v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 0;
  }
  else if ( *(_BYTE *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return v5;
}

//----- (00046F8C) --------------------------------------------------------
int __fastcall sub_46F8C(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r0
  int v6; // r4

  v5 = sub_46F04(a1, a2, a3, a4);
  v6 = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(a1 + 20));
  return v6;
}

//----- (00046FB8) --------------------------------------------------------
int __fastcall sub_46FB8(int a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( !*(_BYTE *)(a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_tail",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_unlink_tail",
      181);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 4);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v6 )
      a3 = 0;
    else
      *(_DWORD *)(a1 + 12) = 0;
    if ( v6 )
      *(_DWORD *)(v6 + 8) = a3;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    --*(_DWORD *)(a1 + 28);
  }
  return result;
}

//----- (00047080) --------------------------------------------------------
const char *__fastcall sub_47080(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  int v7; // r3
  int v8; // r3
  __int64 v9; // r2
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_add_head",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_head",
      205);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 12);
  if ( v7 )
    *(_DWORD *)(v7 + 4) = a2;
  v8 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = a2;
  if ( v8 && !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = a2;
  v9 = *(_QWORD *)(a1 + 28);
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)(a1 + 28) = v9;
  return result;
}

//----- (00047154) --------------------------------------------------------
const char **__fastcall sub_47154(const char **result, int a2, const char *a3, const char *a4, int a5)
{
  const char *v6; // r1
  const char *v7; // r3
  const char *v8; // r3
  const char *v9; // r3
  bool v10; // zf
  __int64 v11; // r2
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v6 = *(const char **)a2;
  if ( v6 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      v6,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( !*((_BYTE *)result + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v7 = result[4];
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = v7;
  v8 = result[4];
  if ( v8 )
    *((_DWORD *)v8 + 2) = a2;
  v9 = result[3];
  result[4] = (const char *)a2;
  v10 = v9 == 0;
  v11 = *(_QWORD *)(result + 7);
  if ( v10 )
    result[3] = (const char *)a2;
  LODWORD(v11) = v11 + 1;
  ++HIDWORD(v11);
  *(_QWORD *)(result + 7) = v11;
  return result;
}

//----- (000472A0) --------------------------------------------------------
const char **__fastcall sub_472A0(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  __int64 v9; // r2
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_before",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      262);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      267);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  *(_DWORD *)(a2 + 8) = a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  v8 = *(_DWORD *)(a3 + 4);
  if ( v8 )
    *(_DWORD *)(v8 + 8) = a2;
  else
    result[3] = (const char *)a2;
  *(_DWORD *)(a3 + 4) = a2;
  v9 = *(_QWORD *)(result + 7);
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)(result + 7) = v9;
  return result;
}

//----- (000473E8) --------------------------------------------------------
const char **__fastcall sub_473E8(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  __int64 v9; // r2
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_after",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      286);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      291);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  v8 = *(_DWORD *)(a3 + 8);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = a2;
  }
  else if ( *((_BYTE *)result + 44) )
  {
    result[4] = (const char *)a2;
  }
  *(_DWORD *)(a3 + 8) = a2;
  v9 = *(_QWORD *)(result + 7);
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)(result + 7) = v9;
  return result;
}

//----- (0004753C) --------------------------------------------------------
const char *__fastcall sub_4753C(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  __int64 v7; // r2
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_item",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_unlink_item",
      312);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v7 = *(_QWORD *)(a2 + 4);
  if ( (_DWORD)v7 )
  {
    *(_DWORD *)(v7 + 8) = HIDWORD(v7);
    HIDWORD(v7) = *(_DWORD *)(a2 + 8);
  }
  if ( HIDWORD(v7) )
    *(_DWORD *)(HIDWORD(v7) + 4) = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 12) == a2 )
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)(a1 + 44) && *(_DWORD *)(a1 + 16) == a2 )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return result;
}

//----- (00047628) --------------------------------------------------------
const char *__fastcall sub_47628(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  int v9; // r2
  const char *v10; // r3
  const char *v11; // r1
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *a1;
  v8 = *(const char **)a2;
  if ( result != v8 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_head",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_head",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( a1[3] )
  {
    v9 = *(_DWORD *)(a2 + 12);
    v10 = a1[4];
    if ( v9 )
      *(_DWORD *)(v9 + 4) = v10;
    else
      *(_DWORD *)(a2 + 16) = v10;
    if ( v9 )
      v9 = *(_DWORD *)(a2 + 12);
    *((_DWORD *)a1[4] + 2) = v9;
    *(_DWORD *)(a2 + 12) = a1[3];
    a1[4] = 0;
    v11 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v11;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (00047798) --------------------------------------------------------
const char *__fastcall sub_47798(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  const char *v9; // r3
  int v10; // r2
  const char *v11; // r1
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *a1;
  v8 = *(const char **)a2;
  if ( result != v8 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_tail",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  v9 = a1[3];
  if ( v9 )
  {
    v10 = *(_DWORD *)(a2 + 16);
    if ( v10 )
      *(_DWORD *)(v10 + 8) = v9;
    else
      *(_DWORD *)(a2 + 12) = v9;
    if ( v10 )
      v10 = *(_DWORD *)(a2 + 16);
    *((_DWORD *)a1[3] + 1) = v10;
    *(_DWORD *)(a2 + 16) = a1[4];
    a1[4] = 0;
    v11 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v11;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (00047904) --------------------------------------------------------
int __fastcall sub_47904(const char **a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  char *v9; // r5
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( *((_BYTE *)a1 + 4) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_free_list",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_list",
      400);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( (int)a1[12] > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(void **)&a1[13][4 * v5++];
      free(v6);
    }
    while ( (int)a1[12] > v5 );
  }
  free((void *)a1[13]);
  if ( (int)a1[14] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)&a1[15][4 * v7++];
      free(v8);
    }
    while ( (int)a1[14] > v7 );
  }
  free((void *)a1[15]);
  v9 = (char *)a1[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(v9 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)v9);
  free((void *)a1[2]);
  free(a1);
  return 0;
}

//----- (00047A20) --------------------------------------------------------
int __fastcall sub_47A20(const char **ptr, const char *a2, const char *a3, int a4)
{
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( !*((_BYTE *)ptr + 4) )
  {
    snprintf(
      s,
      0x800u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *ptr,
      "_k_free_store",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_store",
      424);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  free(ptr);
  return 0;
}

//----- (00047AB4) --------------------------------------------------------
void __fastcall sub_47AB4(int a1, const char *a2, int a3)
{
  int v6; // r4
  struct tm *v7; // r0
  int v8; // r0
  FILE *v9; // r5
  size_t v10; // r0
  size_t v11; // r0
  int v12; // r7
  time_t timer; // [sp+1Ch] [bp-4Ch] BYREF
  struct timeval v14; // [sp+20h] [bp-48h] BYREF
  char s[64]; // [sp+28h] [bp-40h] BYREF

  if ( byte_244080 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v14.tv_sec = 0;
    v14.tv_usec = 0;
    sub_4A60C(&v14);
    timer = v14.tv_sec;
    v6 = v14.tv_usec / 1000;
    v7 = localtime(&timer);
    snprintf(
      s,
      0x40u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      v7->tm_year + 1900,
      v7->tm_mon + 1,
      v7->tm_mday,
      v7->tm_hour,
      v7->tm_min,
      v7->tm_sec,
      v6);
    v8 = fileno((FILE *)stderr);
    if ( !isatty(v8) )
    {
      fprintf((FILE *)stderr, "%s%s\n", s, a2);
      fflush((FILE *)stderr);
    }
    if ( byte_1AEB9C )
    {
      v9 = (FILE *)dword_1AEBA0;
      if ( dword_1AEBA0 || (v9 = (FILE *)fopen64(&unk_1AEBC4, &word_1AEBA4), (dword_1AEBA0 = (int)v9) != 0) )
      {
        v10 = strlen(s);
        fwrite(s, v10, 1u, v9);
        v11 = strlen(a2);
        fwrite(a2, v11, 1u, (FILE *)dword_1AEBA0);
        fwrite(&word_8B454, 1u, 1u, (FILE *)dword_1AEBA0);
        fflush((FILE *)dword_1AEBA0);
      }
    }
    if ( a1 == 3 )
      v12 = 0;
    else
      v12 = byte_242EF8 & 1;
    if ( !v12 )
      sub_47DA0(s, a2, a3);
  }
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 8B454: using guessed type __int16 word_8B454;
// 9F7C8: using guessed type int stderr;
// 1AEB9C: using guessed type char byte_1AEB9C;
// 1AEBA0: using guessed type int dword_1AEBA0;
// 1AEBA4: using guessed type __int16 word_1AEBA4;
// 242EF8: using guessed type char byte_242EF8;
// 244080: using guessed type char byte_244080;

//----- (00047C94) --------------------------------------------------------
int __fastcall sub_47C94(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  result = pthread_mutex_unlock(&stru_246264);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "logging.c", "my_log_curses", a1);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}
// 47AB4: using guessed type int __fastcall sub_47AB4(_DWORD, _DWORD, _DWORD);
// 246264: using guessed type pthread_mutex_t stru_246264;

//----- (00047D0C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_47D0C(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { POP             {R4,PC} }
}
// 47D10: positive sp value 810 has been found
// 47D10: unbalanced stack, ignored a potential tail call

//----- (00047D14) --------------------------------------------------------
int sub_47D14()
{
  int result; // r0
  int *v1; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_lock(&stru_246264);
  if ( result )
  {
    v1 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "logging.c", "my_log_curses", 53);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}
// 47AB4: using guessed type int __fastcall sub_47AB4(_DWORD, _DWORD, _DWORD);
// 246264: using guessed type pthread_mutex_t stru_246264;

//----- (00047D94) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_47D94(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// 47D9C: positive sp value 814 has been found
// 47D9C: unbalanced stack, ignored a potential tail call

//----- (00047DA0) --------------------------------------------------------
int __fastcall sub_47DA0(const char *a1, const char *a2, int a3)
{
  if ( a3 )
  {
    pthread_mutex_trylock(&stru_246264);
    sub_47C94(42);
    off_9E444();
  }
  sub_47D14();
  printf("%s%s%s", a1, a2, "                    \n");
  sub_47C94(55);
  return off_9E444();
}
// 9E444: using guessed type int (*off_9E444)();
// 246264: using guessed type pthread_mutex_t stru_246264;

//----- (00047E18) --------------------------------------------------------
void __fastcall sub_47E18(int a1, const char *a2, int a3)
{
  int v6; // r0
  int v7; // r0

  if ( byte_244080 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)stderr, "%s\n", a2);
      fflush((FILE *)stderr);
    }
    if ( a1 == 3 )
      v7 = 0;
    else
      v7 = byte_242EF8 & 1;
    if ( !v7 )
      sub_47DA0("", a2, a3);
  }
}
// 9F7C8: using guessed type int stderr;
// 242EF8: using guessed type char byte_242EF8;
// 244080: using guessed type char byte_244080;

//----- (00047EC8) --------------------------------------------------------
void __fastcall sub_47EC8(int a1, const char *a2, int a3)
{
  int v6; // r0
  FILE *v7; // r8
  size_t v8; // r0
  int v9; // r0

  if ( byte_244080 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fputs(a2, (FILE *)stderr);
      fflush((FILE *)stderr);
    }
    if ( byte_1AEB9C )
    {
      v7 = (FILE *)dword_1AEBA0;
      if ( dword_1AEBA0 || (v7 = (FILE *)fopen64(&unk_1AEBC4, &word_1AEBA4), (dword_1AEBA0 = (int)v7) != 0) )
      {
        v8 = strlen(a2);
        fwrite(a2, v8, 1u, v7);
        fflush((FILE *)dword_1AEBA0);
      }
    }
    if ( a1 == 3 )
      v9 = 0;
    else
      v9 = byte_242EF8 & 1;
    if ( !v9 )
      sub_47DA0("", a2, a3);
  }
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 9F7C8: using guessed type int stderr;
// 1AEB9C: using guessed type char byte_1AEB9C;
// 1AEBA0: using guessed type int dword_1AEBA0;
// 1AEBA4: using guessed type __int16 word_1AEBA4;
// 242EF8: using guessed type char byte_242EF8;
// 244080: using guessed type char byte_244080;

//----- (000480A0) --------------------------------------------------------
__int64 __fastcall sub_480A0(int a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // r3
  __int64 result; // r0

  v3 = *(_DWORD *)(a1 + 24);
  if ( v3 )
  {
    *a2 = *(_QWORD *)(v3 + 16);
    result = *(_QWORD *)(v3 + 24);
    *a3 = result;
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
    return 0;
  }
  return result;
}

//----- (000484D8) --------------------------------------------------------
int __fastcall sub_484D8(int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r0
  int *v4; // lr
  char *v5; // r12
  int v6; // r3
  int v7; // r4
  int v8; // r1
  int v9; // t1
  unsigned int v10; // lr
  char *v11; // r3
  unsigned int v12; // t1
  int *v13; // r0
  int **v14; // r3
  int *v15; // r2
  int *v16; // t1
  int v17; // r6
  int v18; // r3
  int v19; // r4
  int v20; // r10
  int v21; // r9
  int v22; // r5
  int v23; // r8
  int v24; // r7
  int v25; // r11
  int v26; // r2
  int v27; // r12
  int v28; // r3
  int v29; // lr
  int v30; // r1
  int **v31; // r1
  int *v32; // r3
  int *v33; // t1
  bool v34; // zf
  unsigned __int8 *v35; // [sp+4h] [bp-164h]
  int *v36; // [sp+8h] [bp-160h]
  unsigned __int8 *v37; // [sp+14h] [bp-154h]
  int *v38; // [sp+18h] [bp-150h]
  int *v39; // [sp+1Ch] [bp-14Ch] BYREF
  int v40; // [sp+20h] [bp-148h]
  int v41; // [sp+24h] [bp-144h]
  int v42; // [sp+28h] [bp-140h]
  int v43; // [sp+2Ch] [bp-13Ch]
  int v44; // [sp+30h] [bp-138h]
  int v45; // [sp+34h] [bp-134h]
  int v46; // [sp+38h] [bp-130h]
  int v47; // [sp+3Ch] [bp-12Ch] BYREF
  _DWORD v48[15]; // [sp+40h] [bp-128h] BYREF
  char v49; // [sp+7Ch] [bp-ECh] BYREF
  char v50; // [sp+100h] [bp-68h] BYREF

  if ( a3 > 0 )
  {
    v38 = (int *)(result + 136);
    v35 = a2;
    v37 = &a2[64 * a3];
    v39 = (int *)(result + 168);
    do
    {
      v3 = v35;
      v4 = &v47;
      v5 = (char *)v48;
      do
      {
        v6 = v3[1];
        v7 = v3[2];
        v8 = v3[3];
        v9 = *v3;
        v3 += 4;
        v4[1] = (v6 << 16) | (v7 << 8) | v8 | (v9 << 24);
        ++v4;
      }
      while ( &v49 != (char *)v4 );
      do
      {
        v10 = *((_DWORD *)v5 + 14);
        v11 = v5;
        v12 = *((_DWORD *)v5 + 1);
        v5 += 4;
        *((_DWORD *)v5 + 15) = (__ROR4__(v10, 19) ^ __ROR4__(v10, 17) ^ (v10 >> 10))
                             + *((_DWORD *)v11 + 9)
                             + *(_DWORD *)v11
                             + (__ROR4__(v12, 18) ^ __ROR4__(v12, 7) ^ (v12 >> 3));
      }
      while ( &v50 != v5 );
      v13 = v39;
      v14 = &v39;
      v15 = v38;
      do
      {
        v16 = (int *)*v15++;
        v14[1] = v16;
        ++v14;
      }
      while ( v13 != v15 );
      v36 = v15;
      v17 = 0;
      v18 = v47;
      v19 = v44;
      v20 = v45;
      v21 = v46;
      v22 = v40;
      v23 = v41;
      v24 = v42;
      v25 = v43;
      while ( 1 )
      {
        v26 = (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v19, 25)) + (v21 & ~v19 ^ v20 & v19) + v48[v17];
        v27 = dword_9E324[v17++];
        v28 = v26 + v27 + v18;
        v29 = v25 + v28;
        v30 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((v24 ^ v23) & v22 ^ v24 & v23) + v28;
        v25 = v24;
        v18 = v21;
        if ( v17 == 64 )
          break;
        v24 = v23;
        v21 = v20;
        v23 = v22;
        v20 = v19;
        v22 = v30;
        v19 = v29;
      }
      v40 = v30;
      v31 = &v39;
      v32 = v38;
      v47 = v21;
      v44 = v29;
      v45 = v19;
      v46 = v20;
      v41 = v22;
      v42 = v23;
      v43 = v24;
      do
      {
        result = *v32;
        v33 = v31[1];
        ++v31;
        *v32++ += (int)v33;
      }
      while ( v36 != v32 );
      v34 = v37 == v35 + 64;
      v35 += 64;
    }
    while ( !v34 );
  }
  return result;
}
// 9E324: using guessed type _DWORD dword_9E324[63];

//----- (000486D4) --------------------------------------------------------
_DWORD *__fastcall sub_486D4(_DWORD *result)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r3
  int v3; // t1

  v1 = &unk_9E420;
  v2 = result + 34;
  do
  {
    v3 = v1[1];
    ++v1;
    *v2++ = v3;
  }
  while ( v2 != result + 42 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (00048704) --------------------------------------------------------
void *__fastcall sub_48704(unsigned __int8 *a1, char *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r2
  unsigned __int8 *v8; // r0
  size_t v9; // r6
  void *result; // r0
  unsigned int v11; // r3
  size_t v12; // r5
  unsigned __int8 *v13; // r6
  int v14; // r3

  v4 = *((_DWORD *)a1 + 1);
  v7 = 64 - v4;
  v8 = &a1[v4 + 8];
  if ( v7 >= n )
    v9 = n;
  else
    v9 = v7;
  result = memcpy(v8, a2, v9);
  v11 = n + *((_DWORD *)a1 + 1);
  if ( v11 > 0x3F )
  {
    v12 = n - v9;
    v13 = (unsigned __int8 *)&a2[v9];
    sub_484D8((int)a1, a1 + 8, 1);
    sub_484D8((int)a1, v13, v12 >> 6);
    result = memcpy(a1 + 8, &v13[v12 & 0xFFFFFFC0], v12 & 0x3F);
    v14 = *(_DWORD *)a1;
    *((_DWORD *)a1 + 1) = v12 & 0x3F;
    *(_DWORD *)a1 = v14 + (((v12 >> 6) + 1) << 6);
  }
  else
  {
    *((_DWORD *)a1 + 1) = v11;
  }
  return result;
}

//----- (000487B0) --------------------------------------------------------
int __fastcall sub_487B0(_DWORD *a1, _BYTE *a2)
{
  int v2; // r8
  int v3; // r9
  int v4; // r10
  int v5; // r11
  int v6; // r3
  unsigned __int8 *v9; // r6
  bool v10; // cf
  int v11; // r2
  int v12; // r7
  size_t v13; // r2
  unsigned __int8 *v14; // r0
  int v15; // r3
  int v16; // r7
  int result; // r0
  int *v18; // r3
  int *v19; // r5
  int v20; // t1
  int v21; // [sp+4h] [bp-8h]

  v6 = a1[1];
  v9 = (unsigned __int8 *)(a1 + 2);
  v10 = (v6 & 0x3Fu) >= 0x38;
  if ( (v6 & 0x3Fu) >= 0x38 )
    v11 = 128;
  else
    v11 = 64;
  v12 = v6 + *a1;
  v13 = v11 - v6;
  v14 = &v9[v6];
  if ( (v6 & 0x3Fu) >= 0x38 )
    v15 = 124;
  else
    v15 = 60;
  v16 = 8 * v12;
  if ( !v10 )
    v2 = 61;
  v21 = v15;
  if ( v10 )
    v2 = 125;
  else
    v3 = 62;
  if ( v10 )
    v3 = 126;
  else
    v4 = 63;
  if ( v10 )
    v4 = 127;
  else
    v5 = 1;
  if ( v10 )
    v5 = 2;
  memset(v14, 0, v13);
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  v9[v4] = v16;
  v9[v3] = BYTE1(v16);
  v9[v2] = BYTE2(v16);
  v9[v21] = HIBYTE(v16);
  result = sub_484D8((int)a1, v9, v5);
  v18 = a1 + 34;
  v19 = a1 + 42;
  do
  {
    a2[3] = *v18;
    v20 = *v18++;
    a2[2] = BYTE1(v20);
    a2[1] = *((_WORD *)v18 - 1);
    *a2 = *((_BYTE *)v18 - 1);
    a2 += 4;
  }
  while ( v19 != v18 );
  return result;
}
// 48844: variable 'v4' is possibly undefined
// 4884C: variable 'v3' is possibly undefined
// 48850: variable 'v2' is possibly undefined
// 4885C: variable 'v5' is possibly undefined

//----- (0004889C) --------------------------------------------------------
int __fastcall sub_4889C(char *a1, size_t n, _BYTE *a3)
{
  _DWORD *v3; // r3
  char *v5; // r2
  int v6; // t1
  _DWORD v8[34]; // [sp+0h] [bp-ACh] BYREF
  char v9; // [sp+88h] [bp-24h] BYREF

  v3 = &unk_9E420;
  v5 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *(_DWORD *)v5 = v6;
    v5 += 4;
  }
  while ( v3 != (_DWORD *)&unk_9E440 );
  v8[0] = 0;
  v8[1] = 0;
  sub_48704((unsigned __int8 *)v8, a1, n);
  return sub_487B0(v8, a3);
}

//----- (00048900) --------------------------------------------------------
int sub_48900()
{
  return 0;
}

//----- (00048908) --------------------------------------------------------
int __fastcall sub_48908(int a1, char *s, int a3)
{
  int v5; // r8
  int v6; // r9
  int v7; // r3
  int v8; // r9
  int v9; // r8
  fd_set *p_tv_usec; // r3
  ssize_t v12; // r0
  __int64 v13; // r4
  unsigned int v14; // r1
  unsigned int v15; // lr
  __int64 v16; // kr00_8
  unsigned int v17; // r2
  unsigned int v18; // r12
  int n; // [sp+Ch] [bp-820h]
  int v20; // [sp+10h] [bp-81Ch]
  int v21; // [sp+18h] [bp-814h]
  struct timeval timeout; // [sp+20h] [bp-80Ch] BYREF
  fd_set writefds; // [sp+28h] [bp-804h] BYREF

  v5 = *(_DWORD *)(a1 + 588);
  if ( byte_242F18 && byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf((char *)&writefds, 0x800u, "SEND: %s", s);
    sub_47AB4(7, (const char *)&writefds, 0);
  }
  n = a3 + 1;
  *(_WORD *)&s[strlen(s)] = 10;
  if ( a3 + 1 <= 0 )
  {
    v13 = 0;
LABEL_16:
    v14 = *(_DWORD *)(a1 + 504);
    v15 = *(_DWORD *)(a1 + 508);
    v16 = *(_QWORD *)(a1 + 496) + 1LL;
    *(_DWORD *)(a1 + 496) = v16;
    v17 = *(_DWORD *)(a1 + 512);
    *(_DWORD *)(a1 + 500) = HIDWORD(v16);
    v18 = *(_DWORD *)(a1 + 516);
    *(_QWORD *)(a1 + 504) = __PAIR64__(v15, v14) + v13;
    *(_QWORD *)(a1 + 512) = __PAIR64__(v18, v17) + v13;
    return 0;
  }
  else
  {
    LOBYTE(v6) = v5 & 0x1F;
    v7 = v5 / 32;
    if ( v5 <= 0 )
      v6 = -(-v5 & 0x1F);
    v8 = 1 << v6;
    v9 = v5 + 1;
    v21 = v7;
    v20 = 0;
    do
    {
      while ( 1 )
      {
        timeout.tv_usec = 0;
        timeout.tv_sec = 1;
        while ( 1 )
        {
          p_tv_usec = (fd_set *)&timeout.tv_usec;
          do
          {
            p_tv_usec->__fds_bits[1] = 0;
            p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
          }
          while ( &writefds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
          writefds.__fds_bits[v21] |= v8;
          if ( select(v9, 0, &writefds, 0, &timeout) > 0 )
            break;
          if ( *_errno_location() != 4 )
            return 1;
        }
        v12 = send(*(_DWORD *)(a1 + 588), &s[v20], n, 0x4000);
        if ( v12 < 0 )
          break;
        v20 += v12;
        n -= v12;
        if ( n <= 0 )
        {
          v13 = v20;
          goto LABEL_16;
        }
      }
    }
    while ( *_errno_location() == 11 );
    return 2;
  }
}
// 8B454: using guessed type __int16 word_8B454;
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 242F18: using guessed type char byte_242F18;
// 244080: using guessed type char byte_244080;

//----- (00048B74) --------------------------------------------------------
int __fastcall sub_48B74(const char **a1, int a2, int a3)
{
  const char *v5; // r0
  size_t v6; // r0
  ssize_t v7; // r0
  int v8; // r3
  int v9; // r7
  bool v10; // zf
  int v12; // r4
  char s; // [sp+10h] [bp-C00h] BYREF
  char v14; // [sp+11h] [bp-BFFh]
  char v15; // [sp+12h] [bp-BFEh]
  char v16; // [sp+13h] [bp-BFDh]
  char buf[2048]; // [sp+410h] [bp-800h] BYREF

  v5 = a1[150];
  if ( a3 )
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.0\r\n\r\n", v5, a1[146]);
  else
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n", v5, a1[146], v5, a1[146]);
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(buf, 0x800u, "Sending proxy %s:%s - %s", a1[151], a1[152], &s);
    sub_47AB4(7, buf, 0);
  }
  v6 = strlen(&s);
  send(a2, &s, v6, 0);
  v7 = recv(a2, &s, 0xCu, 0);
  if ( v7 > 0 )
  {
    v8 = (unsigned __int8)byte_1AECC5;
    *(&s + v7) = 0;
    if ( v8 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf(buf, 0x800u, "Received from proxy %s:%s - %s", a1[151], a1[152], &s);
      sub_47AB4(7, buf, 0);
    }
    v9 = strcmp(&s, "HTTP/1.1 200");
    if ( v9 && (v9 = strcmp(&s, "HTTP/1.0 200")) != 0 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
      {
        snprintf(buf, 0x800u, "HTTP Error from proxy %s:%s - %s", a1[151], a1[152], &s);
        sub_47AB4(4, buf, 0);
        return 0;
      }
    }
    else
    {
      while ( recv(a2, buf, 1u, 0) != -1 )
      {
        v10 = (unsigned __int8)buf[0] == 255;
        *(&s + v9++) = buf[0];
        if ( v10 )
          goto LABEL_27;
        if ( v9 == 4 )
        {
          while ( strncmp(&s, "\r\n\r\n", 4u) )
          {
            s = v14;
            v14 = v15;
            v15 = v16;
            if ( recv(a2, buf, 1u, 0) == -1 )
            {
              v16 = -1;
              goto LABEL_27;
            }
            v16 = buf[0];
            if ( (unsigned __int8)buf[0] == 255 )
              goto LABEL_27;
          }
          v12 = (unsigned __int8)byte_1AECC5;
          if ( !byte_1AECC5 )
            return 1;
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
          {
            snprintf(buf, 0x800u, "Success negotiating with %s:%s HTTP proxy", a1[151], a1[152]);
            sub_47AB4(7, buf, 0);
          }
          return v12;
        }
      }
      *(&s + v9) = -1;
LABEL_27:
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
      {
        v12 = 0;
        snprintf(buf, 0x800u, "Couldn't read HTTP byte from proxy %s:%s", a1[151], a1[152]);
        sub_47AB4(4, buf, 0);
        return v12;
      }
    }
    return 0;
  }
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
    return 0;
  snprintf(buf, 0x800u, "Couldn't read from proxy %s:%s after sending CONNECT", a1[151], a1[152]);
  sub_47AB4(4, buf, 0);
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (00049028) --------------------------------------------------------
int __fastcall sub_49028(int a1)
{
  _BYTE *v2; // r3
  int result; // r0

  v2 = *(_BYTE **)(a1 + 592);
  if ( v2 )
    *v2 = 0;
  result = *(_DWORD *)(a1 + 588);
  *(_BYTE *)(a1 + 643) = 0;
  *(_BYTE *)(a1 + 641) = 0;
  if ( result )
    result = close(result);
  *(_DWORD *)(a1 + 588) = 0;
  return result;
}

//----- (00049068) --------------------------------------------------------
int __fastcall sub_49068(int a1)
{
  unsigned int v2; // r2

  v2 = fcntl(a1, 3, 0) & 0xFFFFF7FF;
  return fcntl(a1, 4, v2);
}

//----- (00049090) --------------------------------------------------------
bool __fastcall sub_49090(int a1, int a2)
{
  __time_t v2; // r1
  fd_set *p_tv_usec; // r3
  int v4; // r4
  struct timeval timeout; // [sp+8h] [bp-88h] BYREF
  fd_set readfds; // [sp+10h] [bp-80h] BYREF

  v2 = a2 & ~(a2 >> 31);
  p_tv_usec = (fd_set *)&timeout.tv_usec;
  do
  {
    p_tv_usec->__fds_bits[1] = 0;
    p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
  }
  while ( &readfds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
  timeout.tv_usec = 0;
  timeout.tv_sec = v2;
  LOBYTE(v4) = a1 & 0x1F;
  if ( a1 <= 0 )
    v4 = -(-a1 & 0x1F);
  readfds.__fds_bits[a1 / 32] |= 1 << v4;
  return select(a1 + 1, &readfds, 0, 0, &timeout) > 0;
}

//----- (00049124) --------------------------------------------------------
_DWORD *__fastcall sub_49124(_DWORD *a1, unsigned int a2)
{
  _DWORD *v4; // r0

  if ( !a1 || *a1 != 1 )
    return 0;
  if ( (unsigned int)sub_6E1A8(a1) >= a2 )
  {
    v4 = sub_6E1C4(a1, a2);
    if ( v4 )
    {
      if ( *v4 == 2 )
        return sub_6E350(v4);
    }
  }
  return 0;
}

//----- (00049188) --------------------------------------------------------
char *__fastcall sub_49188(_DWORD *a1, unsigned int a2)
{
  char *result; // r0

  result = (char *)sub_49124(a1, a2);
  if ( result )
    return _strdup(result);
  return result;
}

//----- (000491A0) --------------------------------------------------------
void __fastcall __noreturn sub_491A0(const void *a1, const char *a2, const char *a3, int a4)
{
  int *v8; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v8 = _errno_location();
  snprintf(s, 0x800u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v8, a1, a2, a3, a4);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (000491FC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_491FC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  __asm { POP             {R4-R7,PC} }
}
// 49204: positive sp value 814 has been found
// 49204: unbalanced stack, ignored a potential tail call

//----- (00049208) --------------------------------------------------------
int __fastcall sub_49208(const char *a1, const char *a2, int a3)
{
  size_t v6; // r0
  int v7; // r3
  const char *v8; // r2
  const char *v9; // r0
  int v10; // t1
  int result; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( a1 )
  {
    v6 = strlen(a1);
    if ( !v6 )
      return 1;
    v7 = *(unsigned __int8 *)a1;
    if ( (int)dword_81958[v7] >= 0 )
    {
      v8 = a1;
      v9 = &a1[v6 - 1];
      while ( v8 != v9 )
      {
        v10 = *(unsigned __int8 *)++v8;
        v7 = v10;
        if ( (int)dword_81958[v10] < 0 )
          goto LABEL_8;
      }
      return 1;
    }
LABEL_8:
    if ( byte_244080 || (result = (unsigned __int8)byte_1AECC4, byte_1AECC4) || dword_9E320 > 2 )
    {
      snprintf(s, 0x800u, "Invalid char 0x%x passed to valid_hex from in %s %s():%d", v7, "util.c", a2, a3);
LABEL_12:
      sub_47AB4(3, s, 0);
      return 0;
    }
  }
  else if ( byte_244080 || (result = (unsigned __int8)byte_1AECC4, byte_1AECC4) || dword_9E320 > 2 )
  {
    snprintf(s, 0x800u, "Null string passed to valid_hex from in %s %s():%d", "util.c", a2, a3);
    goto LABEL_12;
  }
  return result;
}
// 81958: using guessed type _DWORD dword_81958[256];
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00049358) --------------------------------------------------------
int __fastcall sub_49358(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_wrlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (000493C8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_493C8(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 493D0: positive sp value 814 has been found
// 493D0: unbalanced stack, ignored a potential tail call

//----- (000493D4) --------------------------------------------------------
int __fastcall sub_493D4(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (00049444) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_49444(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 4944C: positive sp value 814 has been found
// 4944C: unbalanced stack, ignored a potential tail call

//----- (00049450) --------------------------------------------------------
int __fastcall sub_49450(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (000494C0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_494C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 494C8: positive sp value 814 has been found
// 494C8: unbalanced stack, ignored a potential tail call

//----- (000494CC) --------------------------------------------------------
void __fastcall __noreturn sub_494CC(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_62EC0(1);
}

//----- (00049524) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_49524(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 4952C: positive sp value 814 has been found
// 4952C: unbalanced stack, ignored a potential tail call

//----- (00049530) --------------------------------------------------------
int __fastcall sub_49530(int a1)
{
  pthread_mutex_t *v1; // r5
  int result; // r0
  _BYTE *v4; // r3

  v1 = (pthread_mutex_t *)(a1 + 704);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
    sub_494CC("clear_sock", 1765);
  while ( *(_DWORD *)(a1 + 588) && recv(*(_DWORD *)(a1 + 588), *(void **)(a1 + 592), 0x1FFCu, 0) > 0 )
    ;
  sub_49450(v1, "clear_sock", 1774);
  result = off_9E444();
  v4 = *(_BYTE **)(a1 + 592);
  if ( v4 )
    *v4 = 0;
  return result;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (000495C0) --------------------------------------------------------
int __fastcall sub_495C0(int a1, char a2)
{
  pthread_mutex_t *v2; // r5

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_494CC("tq_freezethaw", 1108);
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_49450(v2, "tq_freezethaw", 1111);
  return off_9E444();
}
// 9E444: using guessed type int (*off_9E444)();

//----- (00049624) --------------------------------------------------------
void *__fastcall sub_49624(size_t a1, const char *a2, const char *a3, int a4)
{
  size_t v4; // r4
  void *result; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v4 = a1;
  if ( (a1 & 3) != 0 )
    v4 = (a1 & 0xFFFFFFFC) + 4;
  result = malloc(v4);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to malloc size %d from %s %s:%d", v4, a2, a3, a4);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (000496A0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_496A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  __asm { POP             {R4-R8,PC} }
}
// 496A8: positive sp value 810 has been found
// 496A8: unbalanced stack, ignored a potential tail call

//----- (000496AC) --------------------------------------------------------
void *__fastcall sub_496AC(size_t a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = calloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to calloc memb %d size %d from %s %s:%d", a1, v5, a3, a4, a5);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (00049730) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_49730(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  __asm { POP             {R4-R8,PC} }
}
// 49738: positive sp value 810 has been found
// 49738: unbalanced stack, ignored a potential tail call

//----- (0004973C) --------------------------------------------------------
void *__fastcall sub_4973C(void *a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = realloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to realloc size %d from %s %s:%d", v5, a3, a4, a5);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (000497C0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_497C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  __asm { POP             {R4-R7,PC} }
}
// 497CC: positive sp value 814 has been found
// 497CC: unbalanced stack, ignored a potential tail call

//----- (000497D0) --------------------------------------------------------
char *__fastcall sub_497D0(char *a1)
{
  char **v2; // r3
  char *result; // r0

  if ( !a1 )
    return "http:";
  v2 = &off_81D74;
  result = "http0:";
  while ( 1 )
  {
    v2 += 2;
    if ( v2[1] == a1 )
      break;
    result = v2[2];
    if ( !result )
      return "invalid";
  }
  return result;
}
// 81D74: using guessed type char *off_81D74;

//----- (0004981C) --------------------------------------------------------
_BYTE *__fastcall sub_4981C(_BYTE *result, int a2, int a3)
{
  int v3; // r4
  _BYTE *v4; // r1
  _BYTE *v5; // r12
  unsigned int v6; // t1

  if ( a3 <= 0 )
  {
    *result = 0;
  }
  else
  {
    v3 = a2 + a3 - 1;
    v4 = (_BYTE *)(a2 - 1);
    v5 = result + 2;
    do
    {
      v6 = (unsigned __int8)*++v4;
      v5 += 2;
      *(v5 - 4) = *((_BYTE *)&unk_81958 + (v6 >> 4) + 1108);
      *(v5 - 3) = *((_BYTE *)&unk_81958 + (*v4 & 0xF) + 1108);
    }
    while ( v4 != (_BYTE *)v3 );
    result += 2 * a3;
    *result = 0;
  }
  return result;
}

//----- (0004988C) --------------------------------------------------------
_BYTE *__fastcall sub_4988C(int a1, int a2)
{
  int v2; // r5
  int v4; // r0
  int v6; // r12
  _BYTE *result; // r0
  _BYTE *v8; // r5
  _BYTE *v9; // r2
  char *v10; // r12
  unsigned int v11; // t1

  v2 = 2 * a2;
  v4 = 2 * a2 + 1;
  v6 = v4 & 3;
  if ( v4 <= 0 )
    v6 = -(-v4 & 3);
  result = sub_496AC(4 - v6 + v4, 1u, "util.c", "bin2hex", 789);
  if ( a2 > 0 )
  {
    v9 = (_BYTE *)(a1 - 1);
    v10 = result + 2;
    do
    {
      v11 = (unsigned __int8)*++v9;
      v10 += 2;
      *(v10 - 4) = *((_BYTE *)&unk_81958 + (v11 >> 4) + 1108);
      *(v10 - 3) = *((_BYTE *)&unk_81958 + (*v9 & 0xF) + 1108);
    }
    while ( v9 != (_BYTE *)(a1 - 1 + a2) );
    v8 = &result[v2];
  }
  else
  {
    v8 = result;
  }
  *v8 = 0;
  return result;
}

//----- (00049940) --------------------------------------------------------
int __fastcall sub_49940(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4; // r3
  unsigned int v5; // r12
  int result; // r0
  unsigned __int8 *v7; // r1
  int v8; // r3
  int v9; // r4
  char v10[2052]; // [sp+0h] [bp-804h] BYREF

  if ( !*a2 )
    return !a3;
  if ( !a3 )
    return 0;
  if ( !a2[1] )
  {
LABEL_16:
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      strcpy(v10, "hex2bin str truncated");
      sub_47AB4(3, v10, 0);
    }
    return 0;
  }
  v4 = dword_81958[a2[1]];
  v5 = dword_81958[*a2];
  result = (v4 >> 31) | (v5 >> 31);
  if ( !result )
  {
    v7 = a2 + 4;
    do
    {
      --a3;
      *a1++ = v4 | (16 * v5);
      v8 = *(v7 - 2);
      if ( !*(v7 - 2) )
        return !a3;
      if ( !a3 )
        return result;
      v9 = *(v7 - 1);
      v7 += 2;
      if ( !v9 )
        goto LABEL_16;
      v5 = dword_81958[v8];
      v4 = dword_81958[v9];
    }
    while ( ((v5 | v4) & 0x80000000) == 0 );
  }
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
    return 0;
  strcpy(v10, "hex2bin scan failed");
  sub_47AB4(3, v10, 0);
  return 0;
}
// 81958: using guessed type _DWORD dword_81958[256];
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00049AE4) --------------------------------------------------------
void __fastcall sub_49AE4(int a1, char *s)
{
  size_t v4; // r0
  size_t v5; // r3
  char *v6; // r1
  char *v7; // r0
  unsigned __int8 *v8; // r3
  unsigned __int8 v9; // t1
  int v10; // r1
  int v11; // r12
  int i; // r3
  int v13; // [sp+0h] [bp-814h] BYREF
  unsigned __int8 v14[12]; // [sp+4h] [bp-810h] BYREF
  char sa[2052]; // [sp+10h] [bp-804h] BYREF

  qmemcpy(v14, "000000000", 9);
  v4 = strlen(s);
  v13 = 0;
  if ( v4 )
  {
    v5 = 7 - v4;
    v6 = s - 1;
    v7 = &s[v4 - 1];
    v8 = &v14[v5];
    do
    {
      v9 = *++v6;
      *++v8 = v9;
    }
    while ( v6 != v7 );
  }
  v14[8] = 0;
  sub_49940(&v13, v14, 4);
  v10 = 0;
  v11 = 0;
  for ( i = 0; i != 32; ++i )
  {
    if ( (((unsigned __int16)(v13 & 0xE000) >> i) & 1) != 0 )
    {
      ++v10;
      v11 |= 1 << i;
      if ( v10 == 3 )
        break;
    }
  }
  v13 = v11;
  if ( (v11 & 0xE000) != 0 )
  {
    *(_BYTE *)(a1 + 644) = 1;
    *(_DWORD *)(a1 + 648) = 8;
  }
  else
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
    {
      snprintf(sa, 0x800u, "Pool %d rolling mask do not match!", *(_DWORD *)a1);
      sub_47AB4(5, sa, 0);
    }
    *(_BYTE *)(a1 + 644) = 0;
    *(_DWORD *)(a1 + 648) = 1;
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00049C54) --------------------------------------------------------
size_t __fastcall sub_49C54(_BYTE *a1, char *s)
{
  size_t result; // r0
  char v5; // r1
  char *v6; // r7
  unsigned int v7; // r12
  char *v8; // r6
  int v9; // t1
  unsigned int *v10; // r2
  unsigned int v11; // r3
  size_t *v12; // r3
  unsigned int *v13; // r2
  size_t *v14; // r5
  unsigned int v15; // t1
  int v16; // [sp+0h] [bp-20h] BYREF
  int v17; // [sp+4h] [bp-1Ch]
  unsigned int v18[5]; // [sp+8h] [bp-18h] BYREF
  unsigned int v19; // [sp+1Ch] [bp-4h] BYREF

  memset(v18, 0, sizeof(v18));
  v17 = 0;
  v19 = 0;
  result = strlen(s);
  if ( result )
  {
    v6 = s - 1;
    v7 = 0;
    v8 = &v6[result];
    while ( 1 )
    {
      v9 = (unsigned __int8)*++v6;
      v10 = &v19;
      v11 = *((_DWORD *)&unk_81958 + v9 + 286);
      while ( 1 )
      {
        *v10-- = 58 * v7 + v11;
        v11 = (58LL * v7 + (unsigned __int64)v11) >> 32;
        if ( &v16 == (int *)v10 )
          break;
        v7 = *v10;
      }
      if ( v8 == v6 )
        break;
      v7 = v19;
    }
    v5 = v17;
    result = bswap32(v18[0]);
  }
  else
  {
    v5 = 0;
  }
  v12 = (size_t *)(a1 + 1);
  v13 = v18;
  *a1 = v5;
  v14 = (size_t *)(a1 + 25);
  while ( 1 )
  {
    *v12++ = result;
    if ( v12 == v14 )
      break;
    v15 = v13[1];
    ++v13;
    result = bswap32(v15);
  }
  return result;
}

//----- (00049D2C) --------------------------------------------------------
int __fastcall sub_49D2C(int a1, int a2)
{
  char v3; // r2
  int result; // r0
  int v5; // r2

  if ( a2 > 127 )
  {
    v5 = (unsigned __int16)&unk_20407F;
    if ( a2 > v5 )
    {
      HIWORD(v5) = (unsigned int)&unk_20407F >> 16;
      if ( a2 <= v5 )
        result = 4;
      else
        result = 5;
      if ( a2 <= v5 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(a1 + 1) = a2;
  *(_BYTE *)a1 = v3;
  return result;
}

//----- (00049D78) --------------------------------------------------------
int __fastcall sub_49D78(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // r3
  unsigned int *v3; // r2
  unsigned int v4; // lr
  unsigned int v5; // t1
  unsigned int v6; // t1
  bool v7; // cf
  int v8; // r5
  unsigned int v10; // r7
  unsigned int v11; // lr
  unsigned int v12; // r12
  unsigned int v13; // r6
  unsigned int v14; // r7
  unsigned int v15; // r12
  unsigned int v16; // lr
  unsigned int v17; // r3
  unsigned int v18; // lr
  unsigned int v19; // r3
  unsigned int v20; // r6
  unsigned int v21; // r12
  unsigned int v22; // lr
  unsigned int v23; // r3
  unsigned int v24; // r12
  char *v25; // r7
  const char *v26; // r0
  char *v27; // r6
  const char *v28; // r3
  _DWORD v29[8]; // [sp+8h] [bp-844h] BYREF
  _DWORD v30[8]; // [sp+28h] [bp-824h] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  v2 = a1 + 8;
  v3 = a2 + 8;
  while ( 1 )
  {
    v5 = *--v2;
    v4 = v5;
    v6 = *--v3;
    v7 = v4 >= v6;
    if ( v4 > v6 )
      break;
    if ( !v7 || a1 == v2 )
    {
      v8 = 1;
      goto LABEL_7;
    }
  }
  v8 = 0;
LABEL_7:
  if ( !byte_1AECC5 )
    return v8;
  v10 = a1[7];
  v11 = a1[5];
  v12 = a1[4];
  v29[1] = bswap32(a1[6]);
  v13 = a1[2];
  v29[0] = bswap32(v10);
  v29[2] = bswap32(v11);
  v14 = a1[3];
  v29[3] = bswap32(v12);
  v15 = *a1;
  v16 = a1[1];
  v29[5] = bswap32(v13);
  v17 = a2[7];
  v29[6] = bswap32(v16);
  v18 = a2[6];
  v29[7] = bswap32(v15);
  v30[0] = bswap32(v17);
  v19 = a2[4];
  v20 = a2[3];
  v21 = bswap32(a2[5]);
  v30[1] = bswap32(v18);
  v22 = a2[2];
  v30[2] = v21;
  v30[3] = bswap32(v19);
  v23 = *a2;
  v24 = a2[1];
  v29[4] = bswap32(v14);
  v30[4] = bswap32(v20);
  v30[6] = bswap32(v24);
  v30[7] = bswap32(v23);
  v30[5] = bswap32(v22);
  v25 = sub_4988C((int)v29, 32);
  v26 = sub_4988C((int)v30, 32);
  v27 = (char *)v26;
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    v28 = "YES (hash <= target)";
    if ( !v8 )
      v28 = "no (false positive; hash > target)";
    snprintf(s, 0x800u, " Proof: %s\nTarget: %s\nTrgVal? %s", v25, v26, v28);
    sub_47AB4(7, s, 0);
  }
  free(v25);
  free(v27);
  return v8;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (00049F68) --------------------------------------------------------
char *sub_49F68()
{
  char *v0; // r4

  v0 = (char *)sub_496AC(1u, 0x58u, "util.c", "tq_new", 1077);
  *(_DWORD *)v0 = v0;
  *((_DWORD *)v0 + 1) = v0;
  pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
  pthread_cond_init((pthread_cond_t *)(v0 + 40), 0);
  return v0;
}

//----- (00049FC4) --------------------------------------------------------
void __fastcall sub_49FC4(char *a1)
{
  int v2; // r2
  _DWORD *v3; // r0
  _DWORD *v4; // r4
  _DWORD *v5; // r3
  bool v6; // zf

  if ( a1 )
  {
    v2 = **(_DWORD **)a1;
    v3 = (_DWORD *)(*(_DWORD *)a1 - 4);
    v4 = (_DWORD *)(v2 - 4);
    if ( a1 != *(char **)a1 )
    {
      do
      {
        v5 = (_DWORD *)v3[2];
        *(_DWORD *)(v2 + 4) = v5;
        *v5 = v2;
        free(v3);
        v3 = v4;
        v2 = v4[1];
        v6 = v4 + 1 == (_DWORD *)a1;
        v4 = (_DWORD *)(v2 - 4);
      }
      while ( !v6 );
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    free(a1);
  }
}

//----- (0004A02C) --------------------------------------------------------
int __fastcall sub_4A02C(int a1)
{
  return sub_495C0(a1, 1);
}

//----- (0004A034) --------------------------------------------------------
int __fastcall sub_4A034(int a1)
{
  return sub_495C0(a1, 0);
}

//----- (0004A03C) --------------------------------------------------------
int __fastcall sub_4A03C(int a1, int a2)
{
  _DWORD *v4; // r6
  _DWORD *v5; // r4
  _DWORD *v6; // r3
  int v7; // r8

  v4 = sub_496AC(1u, 0xCu, "util.c", "tq_push", 1129);
  *v4 = a2;
  v5 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_494CC("tq_push", 1133);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v7 = 0;
    free(v4);
  }
  else
  {
    v6 = *(_DWORD **)(a1 + 4);
    v7 = 1;
    *(_DWORD *)(a1 + 4) = v5;
    v4[1] = a1;
    v4[2] = v6;
    *v6 = v5;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_49450((pthread_mutex_t *)(a1 + 12), "tq_push", 1146);
  off_9E444();
  return v7;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (0004A110) --------------------------------------------------------
int __fastcall sub_4A110(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r6
  int *v5; // r4
  _DWORD *v6; // r2
  int v7; // r1
  int v8; // r5
  pthread_cond_t *v10; // r0
  int v11; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_494CC("tq_pop", 1158);
  v5 = *(int **)a1;
  if ( a1 == *(_DWORD *)a1 )
  {
    v10 = (pthread_cond_t *)(a1 + 40);
    if ( a2 )
      v11 = pthread_cond_timedwait(v10, v2, a2);
    else
      v11 = pthread_cond_wait(v10, v2);
    if ( v11 )
    {
      v8 = 0;
      goto LABEL_4;
    }
    if ( v5 == *(int **)a1 )
    {
      v8 = 0;
      goto LABEL_4;
    }
    v5 = *(int **)a1;
  }
  v6 = (_DWORD *)v5[1];
  v7 = *v5;
  v8 = *(v5 - 1);
  *(_DWORD *)(v7 + 4) = v6;
  *v6 = v7;
  *v5 = 0;
  v5[1] = 0;
  free(v5 - 1);
LABEL_4:
  sub_49450(v2, "tq_pop", 1184);
  off_9E444();
  return v8;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (0004A1F0) --------------------------------------------------------
int __fastcall sub_4A1F0(int result)
{
  int v1; // r4
  pthread_t v2; // r0
  sem_t *v3; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_cancel(v2);
      v3 = (sem_t *)(v1 + 16);
      *(_DWORD *)(v1 + 12) = 0;
    }
    else
    {
      v3 = (sem_t *)(v1 + 16);
    }
    return sem_destroy(v3);
  }
  return result;
}

//----- (0004A22C) --------------------------------------------------------
_DWORD *__fastcall sub_4A22C(_DWORD *result, int *a2)
{
  int v2; // r12
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result - *a2;
  *a2 = v3;
  v4 = result[1] - v2;
  a2[1] = v4;
  if ( v4 < 0 )
  {
    LODWORD(v5) = v3 - 1;
    HIDWORD(v5) = v4 + 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (0004A260) --------------------------------------------------------
_DWORD *__fastcall sub_4A260(_DWORD *result, int *a2)
{
  int v2; // lr
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result + *a2;
  *a2 = v3;
  v4 = result[1] + v2;
  a2[1] = v4;
  if ( v4 > (int)&unk_F423F )
  {
    LODWORD(v5) = v3 + 1;
    HIDWORD(v5) = v4 - 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (0004A2A4) --------------------------------------------------------
bool __fastcall sub_4A2A4(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] > a2[1];
  else
    return *a1 > *a2;
}

//----- (0004A2D8) --------------------------------------------------------
bool __fastcall sub_4A2D8(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] < a2[1];
  else
    return *a1 < *a2;
}

//----- (0004A30C) --------------------------------------------------------
_DWORD *__fastcall sub_4A30C(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1] / 1000;
  return result;
}

//----- (0004A33C) --------------------------------------------------------
_DWORD *__fastcall sub_4A33C(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = 1000 * a2[1];
  return result;
}

//----- (0004A358) --------------------------------------------------------
int __fastcall sub_4A358(_QWORD *a1)
{
  int result; // r0
  _DWORD v3[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v3);
  *a1 = __PAIR64__(v3[2], v3[0]);
  return result;
}
// 12460: using guessed type int __fastcall lldiv(_DWORD);

//----- (0004A390) --------------------------------------------------------
int __fastcall sub_4A390(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 12460: using guessed type int __fastcall lldiv(_DWORD);

//----- (0004A3D0) --------------------------------------------------------
int __fastcall sub_4A3D0(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = (_DWORD)&unk_F4240 * v4[2];
  *a1 = v3;
  return result;
}
// 12460: using guessed type int __fastcall lldiv(_DWORD);

//----- (0004A410) --------------------------------------------------------
int __fastcall sub_4A410(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 12460: using guessed type int __fastcall lldiv(_DWORD);

//----- (0004A44C) --------------------------------------------------------
_DWORD *__fastcall sub_4A44C(_DWORD *result, _DWORD *a2)
{
  int v2; // r3
  __int64 v3; // r2
  int v4; // lr
  int v5; // r1

  v2 = result[1];
  LODWORD(v3) = *result + *a2;
  *result = v3;
  HIDWORD(v3) = v2 + a2[1];
  result[1] = HIDWORD(v3);
  if ( SHIDWORD(v3) <= 999999999 )
  {
    if ( v3 < 0 )
    {
      do
      {
        HIDWORD(v3) += 1000000000;
        LODWORD(v3) = v3 - 1;
      }
      while ( v3 < 0 );
      *(_QWORD *)result = v3;
    }
  }
  else
  {
    v4 = v3 + 1;
    v5 = HIDWORD(v3) - 1000000000;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
    {
      v5 = -2000000000;
      v4 = v3 + 2;
    }
    *result = v4;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
      v5 += HIDWORD(v3);
    result[1] = v5;
  }
  return result;
}

//----- (0004A5C4) --------------------------------------------------------
const char *__fastcall sub_4A5C4(const char **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r0

  v3 = *a1;
  if ( *a1 && (v4 = strpbrk(*a1, a2)) != 0 )
  {
    *v4 = 0;
    *a1 = v4 + 1;
    return v3;
  }
  else
  {
    *a1 = 0;
    return v3;
  }
}

//----- (0004A60C) --------------------------------------------------------
int __fastcall sub_4A60C(struct timeval *a1)
{
  return gettimeofday(a1, 0);
}

//----- (0004A614) --------------------------------------------------------
int __fastcall sub_4A614(_DWORD *a1)
{
  return a1[1] / 1000000 + 1000 * *a1;
}

//----- (0004A644) --------------------------------------------------------
int __fastcall sub_4A644(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v3; // r3
  int v4; // r1
  int result; // r0

  v3 = *a1 - *a2;
  *a3 = v3;
  v4 = a2[1];
  result = a1[1] - v4;
  if ( result >= 0 )
  {
    a3[1] = result;
  }
  else
  {
    v4 = 1000000000;
    --v3;
  }
  if ( result < 0 )
  {
    *a3 = v3;
    a3[1] = result + v4;
  }
  return result;
}

//----- (0004A680) --------------------------------------------------------
int __fastcall sub_4A680(struct timespec *a1)
{
  return clock_gettime(1, a1);
}

//----- (0004A68C) --------------------------------------------------------
int __fastcall sub_4A68C(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8; // [sp+0h] [bp-8h] BYREF

  sub_4A3D0(&v8);
  v2 = *a1;
  v8.tv_nsec += a1[1];
  tv_nsec = v8.tv_nsec;
  v4 = v8.tv_sec + v2;
  v8.tv_sec += v2;
  if ( v8.tv_nsec <= 999999999 )
  {
    if ( v8.tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8.tv_sec = v4;
      v8.tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8.tv_nsec - 1000000000;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8.tv_sec = v5;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
      v6 += v8.tv_nsec;
    v8.tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, &v8, 0);
  while ( result == 4 );
  return result;
}

//----- (0004A74C) --------------------------------------------------------
int __fastcall sub_4A74C(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8; // [sp+0h] [bp-8h] BYREF

  sub_4A390(&v8);
  v2 = *a1;
  v8.tv_nsec += a1[1];
  tv_nsec = v8.tv_nsec;
  v4 = v8.tv_sec + v2;
  v8.tv_sec += v2;
  if ( v8.tv_nsec <= 999999999 )
  {
    if ( v8.tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8.tv_sec = v4;
      v8.tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8.tv_nsec - 1000000000;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8.tv_sec = v5;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
      v6 += v8.tv_nsec;
    v8.tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, &v8, 0);
  while ( result == 4 );
  return result;
}

//----- (0004A804) --------------------------------------------------------
int sub_4A804()
{
  struct timespec v1; // [sp+0h] [bp-8h] BYREF

  clock_gettime(1, &v1);
  return sub_4A68C(&v1.tv_sec);
}

//----- (0004A830) --------------------------------------------------------
int sub_4A830()
{
  struct timespec v1; // [sp+0h] [bp-Ch] BYREF

  clock_gettime(1, &v1);
  return sub_4A74C(&v1.tv_sec);
}

//----- (0004A864) --------------------------------------------------------
_DWORD *__fastcall sub_4A864(_DWORD *result, _DWORD *a2)
{
  if ( *result - *a2 <= 60 )
    return &unk_F4240;
  return result;
}

//----- (0004A8FC) --------------------------------------------------------
void sub_4A8FC()
{
  ;
}

//----- (0004A940) --------------------------------------------------------
int __fastcall sub_4A940(const char *a1, _DWORD *a2, char **a3)
{
  const char *v4; // r4
  char *v6; // r0
  char *v7; // r6
  char *v8; // r0
  char v9; // r5
  int v10; // r5
  char *v11; // r6
  size_t v12; // r0
  int v13; // r3
  int v14; // r7
  char *v16; // r0
  char v17[8]; // [sp+8h] [bp-10Ch] BYREF
  char s[260]; // [sp+10h] [bp-104h] BYREF

  v4 = a1;
  *a2 = a1;
  v6 = strstr(a1, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = (char)v8;
  if ( v8 )
    v9 = 1;
  if ( !v7 )
    v9 = 0;
  if ( v7 < v8 )
    v10 = v9 & 1;
  else
    v10 = 0;
  if ( !v10 )
    v8 = (char *)v4;
  v11 = strchr(v8, 58);
  v12 = strlen(v4);
  if ( v11 )
  {
    v13 = v11 - v4;
    v14 = ~(v11 - v4) + v12;
    if ( v14 <= 0 )
      return 0;
    ++v11;
  }
  else
  {
    v13 = v12;
    v14 = 0;
  }
  if ( v13 <= 0 )
    return 0;
  if ( v10 )
  {
    ++v4;
    v13 -= 2;
  }
  snprintf(s, 0xFEu, "%.*s", v13, v4);
  if ( v14 )
  {
    snprintf(v17, 6u, "%.*s", v14, v11);
    v16 = strpbrk(v17, "/#");
    if ( v16 )
      *v16 = 0;
  }
  else
  {
    strcpy(v17, "80");
  }
  *a3 = _strdup(v17);
  *a2 = _strdup(s);
  return 1;
}

//----- (0004AAB4) --------------------------------------------------------
char *__fastcall sub_4AAB4(char *s1, int a2)
{
  const char *v2; // r4
  int v4; // r5
  size_t v5; // r6
  char *v7; // r0
  char *v8; // r8
  char *v9; // r0
  const char *v10; // r1

  v2 = "http:";
  v4 = 0;
  v5 = 5;
  *(_DWORD *)(a2 + 184) = 0;
  while ( strncmp(s1, v2, v5) )
  {
    ++v4;
    v2 = (&off_81D74)[2 * v4];
    if ( !v2 )
      return s1;
    v5 = strlen((&off_81D74)[2 * v4]);
  }
  v7 = strchr(s1, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)sub_49624(1 - v5 + v7 - s1, "util.c", "get_proxy", 750);
    v10 = &s1[v5];
    *(_DWORD *)(a2 + 184) = v9;
    s1 = v8 + 1;
    strcpy(v9, v10);
    sub_4A940(*(const char **)(a2 + 184), (_DWORD *)(a2 + 604), (char **)(a2 + 608));
    *(_DWORD *)(a2 + 180) = dword_81958[2 * v4 + 264];
  }
  return s1;
}
// 81958: using guessed type _DWORD dword_81958[256];
// 81D74: using guessed type char *off_81D74;

//----- (0004AB90) --------------------------------------------------------
bool __fastcall sub_4AB90(int a1)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(a1 + 592);
  return *v1 || sub_49090(*(_DWORD *)(a1 + 588), (unsigned __int8)*v1);
}

//----- (0004ABB0) --------------------------------------------------------
void **__fastcall sub_4ABB0(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6)
{
  _DWORD *v7; // r6

  if ( a3 != a2 )
  {
    v7 = result;
    result = (void **)sub_4973C(*result, a3, a4, a5, a6);
    *v7 = result;
    if ( a3 > a2 )
      return (void **)memset((char *)result + a2, 0, a3 - a2);
  }
  return result;
}

//----- (0004AC1C) --------------------------------------------------------
int __fastcall sub_4AC1C(unsigned int a1, int a2)
{
  int v2; // r12
  int v3; // r3
  int result; // r0

  v2 = 0;
  v3 = 0;
  result = 0;
  do
  {
    if ( ((a1 >> v3) & 1) != 0 )
    {
      ++v2;
      result |= 1 << v3;
      if ( v2 == a2 )
        break;
    }
    ++v3;
  }
  while ( v3 != 32 );
  return result;
}

//----- (0004AC60) --------------------------------------------------------
int __fastcall sub_4AC60(_DWORD *a1, int a2)
{
  double *v3; // r0
  double *v4; // r5
  _DWORD *v5; // r7
  _DWORD *v6; // r0
  int v7; // r6
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  int v12; // r0
  const char *v13; // r4
  int v14; // r0
  int v15; // r0
  int v16; // r0
  _DWORD *v17; // r9
  char *v18; // r0
  char v19[92]; // [sp+14h] [bp-900h] BYREF
  char v20[160]; // [sp+70h] [bp-8A4h] BYREF
  char s[2052]; // [sp+110h] [bp-804h] BYREF

  v3 = sub_6D110(a2, 0, v19);
  v4 = v3;
  if ( v3 )
  {
    v5 = (_DWORD *)sub_6DFCC(v3, "result");
    v6 = (_DWORD *)sub_6DFCC(v4, "error");
    if ( v5 && *v5 != 7 && (!v6 || *v6 == 7) && (v12 = sub_6E048(v5), (v13 = (const char *)sub_6E0C8(v12)) != 0) )
    {
      v7 = 0;
      do
      {
        v16 = sub_6E138((int)v13);
        v17 = (_DWORD *)sub_6E0D4(v16);
        if ( !v17 )
          break;
        if ( !strcasecmp(v13, "version-rolling") && strlen(v13) == 15 )
        {
          if ( *v17 != 5 )
          {
            if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
            {
              snprintf(s, 0x800u, "Pool %d don't support ab!", *a1);
              sub_47AB4(5, s, 0);
            }
            *((_BYTE *)a1 + 644) = 0;
            v7 = 1;
            a1[162] = 1;
            break;
          }
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
          {
            snprintf(s, 0x800u, "POOL %d support ab mode!", *a1);
            sub_47AB4(5, s, 0);
          }
        }
        else if ( !strcasecmp(v13, "version-rolling.mask") && strlen(v13) == 20 )
        {
          v7 = 1;
          v18 = (char *)sub_6E350(v17);
          sub_49AE4((int)a1, v18);
        }
        else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
        {
          snprintf(s, 0x800u, "JSON-RPC unexpected mining.configure value: %s", v13);
          sub_47AB4(3, s, 0);
        }
        v14 = sub_6E138((int)v13);
        v15 = sub_6E094(v5, v14);
        v13 = (const char *)sub_6E0C8(v15);
      }
      while ( v13 );
    }
    else
    {
      v7 = 0;
    }
    if ( *((_DWORD *)v4 + 1) != -1 )
    {
      v8 = (unsigned int *)v4 + 1;
      __dmb(0xBu);
      do
      {
        v9 = __ldrex(v8);
        v10 = v9 - 1;
      }
      while ( __strex(v10, v8) );
      if ( !v10 )
        sub_6E5DC((void **)v4);
    }
    return v7;
  }
  if ( !byte_244080 )
  {
    v7 = (unsigned __int8)byte_1AECC4;
    if ( !byte_1AECC4 && dword_9E320 <= 5 )
      return v7;
  }
  snprintf(s, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)v19, v20);
  sub_47AB4(6, s, 0);
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0004AFA8) --------------------------------------------------------
int __fastcall sub_4AFA8(int a1)
{
  int *v3; // r0
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
  {
    snprintf(s, 0x800u, "Closing socket for stratum pool %d", *(_DWORD *)a1);
    sub_47AB4(6, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
  {
    v4 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", "suspend_stratum", 3130);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  sub_49028(a1);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 704)) )
  {
    v3 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "util.c", "suspend_stratum", 3132);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return off_9E444();
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0004B10C) --------------------------------------------------------
int __fastcall sub_4B10C(int a1, char *a2, int a3)
{
  int *v6; // r0
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_242F18 && byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(s, 0x800u, "SEND: %s", a2);
    sub_47AB4(7, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "util.c", "stratum_send", 1688);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( *(_BYTE *)(a1 + 641) )
  {
    v8 = sub_48908(a1, a2, a3);
    if ( !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 704)) )
    {
      off_9E444();
      switch ( v8 )
      {
        case 2:
          if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
          {
            strcpy(s, "Failed to send in stratum_send");
            sub_47AB4(7, s, 0);
            sub_4AFA8(a1);
            return 0;
          }
          break;
        case 3:
          goto LABEL_12;
        case 1:
          if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
          {
            snprintf(s, 0x800u, "Write select failed on pool %d sock", *(_DWORD *)a1);
            sub_47AB4(7, s, 0);
          }
          break;
        default:
          return v8 == 0;
      }
      sub_4AFA8(a1);
      return 0;
    }
LABEL_7:
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", "stratum_send", 1694);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 704)) )
    goto LABEL_7;
  off_9E444();
LABEL_12:
  result = (unsigned __int8)byte_1AECC5;
  if ( byte_1AECC5 )
  {
    if ( byte_244080 || (result = (unsigned __int8)byte_1AECC4, byte_1AECC4) || dword_9E320 > 6 )
    {
      strcpy(s, "Stratum send failed due to no pool stratum_active");
      sub_47AB4(7, s, 0);
      return 0;
    }
  }
  return result;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 242F18: using guessed type char byte_242F18;
// 244080: using guessed type char byte_244080;

//----- (0004B4C0) --------------------------------------------------------
char *__fastcall sub_4B4C0(int a1)
{
  char *v2; // r7
  signed int v3; // r6
  char *v4; // r0
  char *v5; // r5
  size_t v6; // r0
  size_t v7; // r7
  unsigned int v8; // lr
  __int64 v9; // kr08_8
  unsigned int v10; // r3
  unsigned int v11; // kr04_4
  int v12; // r1
  unsigned int v13; // r2
  ssize_t v15; // r5
  bool v16; // nf
  int v17; // r5
  char *v18; // r9
  size_t v19; // r7
  size_t v20; // r8
  unsigned int v21; // r0
  size_t v22; // r7
  char *v23; // r0
  struct timeval tv; // [sp+8h] [bp-2814h] BYREF
  struct timeval v25; // [sp+10h] [bp-280Ch] BYREF
  char v26[2040]; // [sp+18h] [bp-2804h] BYREF
  char v27[8196]; // [sp+818h] [bp-2004h] BYREF

  v2 = *(char **)(a1 + 592);
  if ( !strchr(v2, 10) )
  {
    gettimeofday(&tv, 0);
    if ( !sub_49090(*(_DWORD *)(a1 + 588), 60) )
    {
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        strcpy(v27, "Timed out waiting for data on socket_full");
        sub_47AB4(7, v27, 0);
      }
      goto LABEL_29;
    }
    while ( 1 )
    {
      memset(v27, 0, 0x2000u);
      v15 = recv(*(_DWORD *)(a1 + 588), v27, 0x1FFCu, 0);
      if ( !v15 )
        break;
      gettimeofday(&v25, 0);
      v16 = v15 < 0;
      v17 = (int)((double)(v25.tv_usec - tv.tv_usec) / 1000000.0 + (double)(v25.tv_sec - tv.tv_sec));
      if ( v16 )
      {
        if ( *_errno_location() != 11 || !sub_49090(*(_DWORD *)(a1 + 588), 60 - v17) )
        {
          if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
          {
            strcpy(v26, "Failed to recv sock in recv_line");
            sub_47AB4(7, v26, 0);
          }
          goto LABEL_35;
        }
      }
      else
      {
        v18 = *(char **)(a1 + 592);
        v19 = strlen(v27);
        v20 = strlen(v18);
        v21 = v19 + v20 + 1;
        if ( v21 >= *(_DWORD *)(a1 + 596) )
        {
          v22 = (v21 & 0xFFFFE000) + 0x2000;
          v23 = (char *)sub_4973C(v18, v22, "util.c", "recalloc_sock", 1803);
          *(_DWORD *)(a1 + 592) = v23;
          memset(&v23[v20], 0, v22 - v20);
          v18 = *(char **)(a1 + 592);
          *(_DWORD *)(a1 + 596) = v22;
        }
        strcat(v18, v27);
      }
      v2 = *(char **)(a1 + 592);
      if ( v17 > 59 || strchr(*(const char **)(a1 + 592), 10) )
        goto LABEL_2;
    }
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      strcpy(v26, "Socket closed waiting in recv_line");
      sub_47AB4(7, v26, 0);
    }
LABEL_35:
    sub_4AFA8(a1);
    v2 = *(char **)(a1 + 592);
  }
LABEL_2:
  v3 = strlen(v2);
  v4 = strtok(v2, (const char *)&word_8B454);
  if ( !v4 )
  {
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      strcpy(v27, "Failed to parse a \\n terminated string in recv_line");
      sub_47AB4(7, v27, 0);
    }
LABEL_29:
    v5 = 0;
    sub_49530(a1);
    return v5;
  }
  v5 = _strdup(v4);
  v6 = strlen(v5);
  v7 = v6;
  if ( (int)(v6 + 1) < v3 )
    memmove(*(void **)(a1 + 592), (const void *)(*(_DWORD *)(a1 + 592) + v6 + 1), v3 - v6 + 1);
  else
    **(_BYTE **)(a1 + 592) = 0;
  v8 = *(_DWORD *)(a1 + 532);
  v9 = *(_QWORD *)(a1 + 520) + 1LL;
  v10 = *(_DWORD *)(a1 + 536);
  v11 = *(_DWORD *)(a1 + 528);
  *(_DWORD *)(a1 + 520) = v9;
  *(_QWORD *)(a1 + 528) = __PAIR64__(v8, v11) + v7;
  v12 = (unsigned __int8)byte_242F18;
  v13 = *(_DWORD *)(a1 + 540);
  *(_DWORD *)(a1 + 524) = HIDWORD(v9);
  *(_QWORD *)(a1 + 536) = __PAIR64__(v13, v10) + v7;
  if ( v12 && byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(v27, 0x800u, "RECVD: %s", v5);
    sub_47AB4(7, v27, 0);
  }
  return v5;
}
// 8B454: using guessed type __int16 word_8B454;
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 242F18: using guessed type char byte_242F18;
// 244080: using guessed type char byte_244080;

//----- (0004BA2C) --------------------------------------------------------
time_t __fastcall sub_4BA2C(_DWORD *a1, int a2)
{
  time_t result; // r0

  result = time(0);
  a1[62] = a2;
  a1[61] = result;
  switch ( a2 )
  {
    case 0:
      ++a1[63];
      break;
    case 1:
      ++a1[64];
      break;
    case 2:
      ++a1[65];
      break;
    case 3:
      ++a1[66];
      break;
    case 4:
      ++a1[67];
      break;
    case 5:
      ++a1[68];
      break;
    case 6:
      ++a1[69];
      break;
    case 7:
      ++a1[70];
      break;
    case 8:
      ++a1[71];
      break;
    case 9:
      ++a1[72];
      break;
    default:
      return result;
  }
  return result;
}
// 4BA50: control flows out of bounds to 4BA54

//----- (0004BB1C) --------------------------------------------------------
char *__fastcall sub_4BB1C(char *a1, char *s)
{
  size_t v4; // r0
  const char *v5; // r1
  char *v6; // r4
  size_t v7; // r4
  size_t v8; // r0
  char *v10; // r4

  v4 = strlen(s);
  if ( !v4 )
    return a1;
  v7 = v4 + 1;
  if ( a1 )
  {
    v8 = strlen(a1) + v7;
    if ( (v8 & 3) != 0 )
      v8 = (v8 & 0xFFFFFFFC) + 4;
    v6 = (char *)sub_49624(v8, "util.c", "realloc_strcat", 3370);
    sprintf(v6, "%s%s", a1, s);
    free(a1);
    return v6;
  }
  if ( (v7 & 3) != 0 )
    v4 = v7 & 0xFFFFFFFC;
  else
    LOWORD(v5) = 9908;
  if ( (v7 & 3) != 0 )
    LOWORD(v5) = 9908;
  else
    v4 = v7;
  if ( (v7 & 3) != 0 )
    v4 += 4;
  HIWORD(v5) = 8;
  v10 = (char *)sub_49624(v4, v5, "realloc_strcat", 3370);
  strcpy(v10, s);
  return v10;
}
// 4BBC8: variable 'v5' is possibly undefined

//----- (0004BBF0) --------------------------------------------------------
char *__fastcall sub_4BBF0(const char *a1)
{
  size_t v2; // r0
  char *v3; // r5
  char *v4; // r7
  char *v5; // r4
  char v6; // r3
  char v7; // r2
  int v8; // t1
  char *v10; // r2
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( !a1 )
  {
    v10 = (char *)malloc(7u);
    if ( !v10 )
    {
      snprintf(s, 0x800u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3395);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
    strcpy(v10, "(null)");
  }
  v2 = strlen(a1);
  v3 = (char *)(a1 - 1);
  v4 = (char *)sub_49624(4 * v2 + 5, "util.c", "str_text", 3400);
  v5 = v4;
  do
  {
    while ( 1 )
    {
      v8 = (unsigned __int8)*++v3;
      v7 = v8;
      if ( (unsigned int)(v8 - 32) <= 0x5E )
        break;
      sprintf(v5, "0x%02x");
      v6 = *v3;
      v5 += 4;
      if ( !*v3 )
        goto LABEL_7;
    }
    *v5++ = v7;
    v6 = *v3;
  }
  while ( *v3 );
LABEL_7:
  *v5 = v6;
  return v4;
}

//----- (0004BD10) --------------------------------------------------------
int __fastcall sub_4BD10(const char *a1)
{
  char s[20]; // [sp+8h] [bp-14h] BYREF

  snprintf(s, 0x10u, "cg@%s", a1);
  return prctl(15, s, 0);
}

//----- (0004BD50) --------------------------------------------------------
int __fastcall sub_4BD50(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = sem_init(a1, 0, 0);
  v8 = result;
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, a2, a3, a4);
    sub_47AB4(3, s, 1);
    sub_62EC0(1);
  }
  return result;
}

//----- (0004BDCC) --------------------------------------------------------
int __fastcall sub_4BDCC(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4)
{
  sub_4BD50((sem_t *)(a1 + 16), "util.c", "thr_info_create", 1191);
  return pthread_create((pthread_t *)(a1 + 12), a2, a3, a4);
}

//----- (0004BE14) --------------------------------------------------------
int __fastcall sub_4BE14(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0

  result = sem_post(a1);
  if ( result )
    sub_491A0(a1, a2, a3, a4);
  return result;
}

//----- (0004BE4C) --------------------------------------------------------
int __fastcall sub_4BE4C(int a1)
{
  pthread_setcanceltype(1, 0);
  (*(void (__fastcall **)(_DWORD))(a1 + 16))(*(_DWORD *)(a1 + 20));
  sub_4BE14((sem_t *)a1, "util.c", "completion_thread", 3626);
  return 0;
}

//----- (0004BE90) --------------------------------------------------------
int __fastcall sub_4BE90(sem_t *sem, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v9; // r3
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  while ( 1 )
  {
    result = sem_wait(sem);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 != 4 )
    {
      snprintf(s, 0x800u, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v9, sem, a2, a3, a4);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
  }
  return result;
}

//----- (0004BF10) --------------------------------------------------------
int __fastcall sub_4BF10(sem_t *a1, int a2, const char *a3, const char *a4, int a5)
{
  __time_t tv_sec; // r10
  int v8; // r5
  int v9; // r3
  __time_t v10; // r2
  bool v11; // cc
  int v12; // r1
  __time_t v13; // r0
  int result; // r0
  struct timespec abstime; // [sp+18h] [bp-814h] BYREF
  struct timeval tv; // [sp+20h] [bp-80Ch] BYREF
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  gettimeofday(&tv, 0);
  tv_sec = tv.tv_sec;
  v8 = 1000 * tv.tv_usec;
  sub_4A3D0(&abstime);
  while ( 1 )
  {
    v9 = v8 + abstime.tv_nsec;
    v10 = tv_sec + abstime.tv_sec;
    v11 = v8 + abstime.tv_nsec <= 999999999;
    abstime.tv_sec += tv_sec;
    abstime.tv_nsec += v8;
    if ( v11 )
    {
      if ( v9 < 0 )
      {
        do
        {
          v9 += 1000000000;
          --v10;
        }
        while ( v9 < 0 );
        abstime.tv_sec = v10;
        abstime.tv_nsec = v9;
      }
    }
    else
    {
      v12 = v9 - 1000000000;
      v13 = v10 + 1;
      if ( v9 - 1000000000 > 999999999 )
      {
        v12 = v9 - 2000000000;
        v13 = v10 + 2;
      }
      abstime.tv_sec = v13;
      abstime.tv_nsec = v12;
    }
    result = sem_timedwait(a1, &abstime);
    if ( !result )
      break;
    result = *_errno_location();
    if ( result == 110 )
      break;
    if ( result != 4 )
    {
      snprintf(s, 0x800u, "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", result, a1, a3, a4, a5);
      sub_47AB4(3, s, 1);
      sub_62EC0(1);
    }
  }
  return result;
}

//----- (0004C044) --------------------------------------------------------
void sub_4C044()
{
  JUMPOUT(0x4BFCC);
}
// 4C048: control flows out of bounds to 4BFCC

//----- (0004C04C) --------------------------------------------------------
int *__fastcall sub_4C04C(sem_t *sem)
{
  int *result; // r0

  do
  {
    while ( 1 )
    {
      result = (int *)sem_trywait(sem);
      if ( (int)result < 0 )
        break;
      if ( result )
        return result;
    }
    result = _errno_location();
  }
  while ( *result == 4 );
  return result;
}

//----- (0004C084) --------------------------------------------------------
bool __fastcall sub_4C084(int a1, int a2, int a3)
{
  sem_t *v6; // r4
  int v7; // r5
  pthread_t newthread[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = (sem_t *)sub_49624(0x18u, "util.c", "cg_completion_timeout", 3637);
  sub_4BD50(v6, "util.c", "cg_completion_timeout", 3638);
  v6[1].__align = a1;
  *(&v6[1].__align + 1) = a2;
  pthread_create(newthread, 0, (void *(*)(void *))sub_4BE4C, v6);
  v7 = sub_4BF10(v6, a3, "util.c", "cg_completion_timeout", 3644);
  if ( v7 )
  {
    pthread_cancel(newthread[0]);
    return v7 == 0;
  }
  else
  {
    pthread_join(newthread[0], 0);
    free(v6);
    return 1;
  }
}

//----- (0004C150) --------------------------------------------------------
void __fastcall sub_4C150(void *a1, const void *a2, size_t a3, int a4, int a5, int a6)
{
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( (int)(a3 - 1) < 0 )
  {
    if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
      return;
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes from %s %s():%d", a3, a4, a5, a6);
LABEL_9:
    sub_47AB4(3, s, 0);
    return;
  }
  if ( !a1 )
  {
    if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
      return;
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d", a3, a4, a5, a6);
    goto LABEL_9;
  }
  if ( a2 )
  {
    memcpy(a1, a2, a3);
    return;
  }
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
  {
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d", a3, a4, a5, a6);
    goto LABEL_9;
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0004C460) --------------------------------------------------------
void __fastcall sub_4C460(void *a1, const void *a2)
{
  sub_4C150(a1, a2, 8u, (int)"util.c", (int)"copy_time", 1236);
}

//----- (0004C494) --------------------------------------------------------
int __fastcall sub_4C494(int a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r5
  int v6; // r6
  int v8; // r10
  unsigned int v9; // r4
  unsigned __int8 *v10; // r7
  char *v11; // r4
  _DWORD *v12; // r0
  bool v13; // r7
  signed int v14; // r0
  char *v15; // r2
  int v16; // r3
  int v17; // t1
  void *v18; // r0
  const char *v19; // r3
  int v20; // r6
  double v21; // d7
  size_t v22; // r1
  int v23; // r2
  size_t v24; // r3
  size_t v25; // r1
  void *v26; // r0
  void *v27; // r0
  size_t v28; // r12
  int v29; // r10
  int *v30; // r3
  int v31; // r2
  int v32; // r1
  int *v33; // r12
  int v34; // r0
  int v35; // r1
  int v36; // r2
  int v37; // r3
  int *v38; // r12
  int v39; // r0
  int v40; // r1
  int v41; // r2
  int v42; // r3
  int v43; // r0
  int v44; // r1
  int v45; // r2
  int v46; // r3
  int v47; // r12
  const char *v48; // r0
  char *v49; // r7
  const char *v50; // lr
  int v51; // r0
  int v52; // r1
  int v53; // r2
  int v54; // r3
  int *v55; // lr
  int v56; // r0
  int v57; // r1
  int v58; // r2
  int v59; // r3
  int v60; // r0
  int v61; // r1
  int v62; // r2
  int v63; // r3
  int v64; // r1
  void *v65; // r0
  signed int v66; // r7
  unsigned __int8 *v67; // r4
  int v68; // r6
  void *v69; // r0
  char *v70; // r3
  _BYTE v71[4]; // [sp+18h] [bp-964h] BYREF
  char *v72; // [sp+1Ch] [bp-960h]
  const char *v73; // [sp+20h] [bp-95Ch]
  int v74; // [sp+24h] [bp-958h]
  pthread_rwlock_t *v75; // [sp+28h] [bp-954h]
  pthread_mutex_t *v76; // [sp+2Ch] [bp-950h]
  size_t v77; // [sp+30h] [bp-94Ch]
  const char *v78; // [sp+34h] [bp-948h]
  const char *v79; // [sp+38h] [bp-944h]
  const char *v80; // [sp+3Ch] [bp-940h]
  const char *v81; // [sp+40h] [bp-93Ch]
  char *v82; // [sp+44h] [bp-938h]
  char *v83; // [sp+48h] [bp-934h]
  size_t v84; // [sp+4Ch] [bp-930h]
  size_t v85; // [sp+50h] [bp-92Ch]
  _BOOL4 v86; // [sp+54h] [bp-928h]
  const char *v87; // [sp+58h] [bp-924h]
  const char *v88; // [sp+5Ch] [bp-920h]
  const char *v89; // [sp+60h] [bp-91Ch]
  const char *v90; // [sp+64h] [bp-918h]
  char *s; // [sp+68h] [bp-914h]
  void *ptr; // [sp+6Ch] [bp-910h]
  char v93[228]; // [sp+74h] [bp-908h] BYREF
  _DWORD v94[513]; // [sp+158h] [bp-824h] BYREF

  v4 = sub_6E1C4(a2, 4u);
  v5 = v4;
  if ( !v4 || *v4 != 1 )
    return 0;
  v8 = (int)sub_6E1A8(v4);
  if ( v8 <= 0 )
  {
    v6 = 0;
LABEL_20:
    v11 = sub_49188(a2, 0);
    v90 = (const char *)sub_49124(a2, 1u);
    ptr = sub_49188(a2, 2u);
    s = sub_49188(a2, 3u);
    v89 = (const char *)sub_49124(a2, 5u);
    v88 = (const char *)sub_49124(a2, 6u);
    v87 = (const char *)sub_49124(a2, 7u);
    v12 = sub_6E1C4(a2, 8u);
    v13 = (char)v12;
    if ( v12 )
    {
      v13 = *sub_6E1C4(a2, 8u) == 5;
      v86 = v13;
    }
    else
    {
      v86 = 0;
    }
    if ( v11 )
    {
      v14 = strlen(v11);
      if ( v14 )
      {
        v15 = v11;
        while ( 1 )
        {
          v17 = (unsigned __int8)*v15++;
          v16 = v17;
          if ( (unsigned int)(v17 - 32) > 0x5E )
            break;
          if ( v14 <= v15 - v11 )
          {
            if ( !sub_49208(v90, "parse_notify", 1969)
              || !sub_49208((const char *)ptr, "parse_notify", 1969)
              || !sub_49208(s, "parse_notify", 1970)
              || !sub_49208(v89, "parse_notify", 1970)
              || !sub_49208(v88, "parse_notify", 1970)
              || !sub_49208(v87, "parse_notify", 1971) )
            {
              goto LABEL_34;
            }
            v76 = (pthread_mutex_t *)(a1 + 212);
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
              sub_494CC("parse_notify", 1980);
            v75 = (pthread_rwlock_t *)(a1 + 236);
            sub_49358((pthread_rwlock_t *)(a1 + 236), "parse_notify", 1980);
            v18 = *(void **)(a1 + 672);
            v81 = (const char *)(a1 + 1712);
            free(v18);
            v19 = v90;
            *(_DWORD *)(a1 + 672) = v11;
            snprintf((char *)(a1 + 1712), 0x41u, "%s", v19);
            v85 = strlen((const char *)ptr) >> 1;
            v80 = (const char *)(a1 + 1780);
            v84 = strlen(s) >> 1;
            snprintf((char *)(a1 + 1780), 9u, "%s", v89);
            v79 = (const char *)(a1 + 1792);
            snprintf((char *)(a1 + 1792), 9u, "%s", v88);
            v78 = (const char *)(a1 + 1804);
            v20 = 0;
            snprintf((char *)(a1 + 1804), 9u, "%s", v87);
            *(_BYTE *)(a1 + 680) = v13;
            v21 = *(double *)(a1 + 1816);
            v22 = v85;
            if ( v21 > 0.0 )
              *(double *)(a1 + 1824) = v21;
            v23 = *(_DWORD *)(a1 + 632);
            v24 = v22 + *(_DWORD *)(a1 + 1564);
            v25 = v84;
            *(_DWORD *)(a1 + 1576) = v24;
            v77 = v25 + v23 + v24;
            *(_DWORD *)(a1 + 1572) = v77;
            while ( *(_DWORD *)(a1 + 1708) > v20 )
            {
              v26 = *(void **)(*(_DWORD *)(a1 + 676) + 4 * v20++);
              free(v26);
            }
            if ( v8 )
            {
              v65 = sub_4973C(*(void **)(a1 + 676), 4 * v8 + 1, "util.c", "parse_notify", 2001);
              v73 = "util.c";
              v66 = 0;
              *(_DWORD *)(a1 + 676) = v65;
              v83 = &byte_242F18;
              v72 = &byte_1AECC5;
              v82 = v11;
              do
              {
                v74 = 4 * v66;
                if ( v66 >= v8 )
                {
                  v11 = v82;
                  *(_DWORD *)(a1 + 1708) = v8;
                  if ( v8 > 1 )
                    goto LABEL_58;
                  goto LABEL_57;
                }
                v67 = (unsigned __int8 *)sub_49188(v5, v66);
                v68 = *(_DWORD *)(a1 + 676);
                v69 = sub_49624(0x20u, v73, "parse_notify", 2006);
                v70 = v83;
                *(_DWORD *)(v68 + 4 * v66) = v69;
                if ( *v70 && *v72 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
                {
                  snprintf((char *)v94, 0x800u, "merkle %d: %s", v66, v67);
                  sub_47AB4(7, (const char *)v94, 0);
                }
                ++v66;
                v6 = sub_49940(*(_BYTE **)(*(_DWORD *)(a1 + 676) + v74), v67, 32);
                free(v67);
              }
              while ( v6 );
              v11 = v82;
              if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
              {
                v50 = "Failed to convert merkle to merkle_bin in parse_notify";
                goto LABEL_129;
              }
              goto LABEL_120;
            }
            *(_DWORD *)(a1 + 1708) = 0;
            v83 = &byte_242F18;
LABEL_57:
            ++*(_QWORD *)(a1 + 376);
LABEL_58:
            if ( v86 )
              *(_QWORD *)(a1 + 624) = 0;
            snprintf(
              v93,
              0xE1u,
              "%s%s%s%s%s%s%s",
              v80,
              v81,
              "0000000000000000000000000000000000000000000000000000000000000000",
              v78,
              v79,
              "00000000",
              off_9EDA4[0]);
            v6 = sub_49940((_BYTE *)(a1 + 1580), (unsigned __int8 *)v93, 112);
            if ( v6 )
            {
              v6 = sub_49940(v71, (unsigned __int8 *)ptr, v85);
              if ( v6 )
              {
                v6 = sub_49940(v71, (unsigned __int8 *)s, v84);
                if ( v6 )
                {
                  free(*(void **)(a1 + 1568));
                  v27 = sub_496AC(v77, 1u, "util.c", "parse_notify", 2063);
                  *(_DWORD *)(a1 + 1568) = v27;
                  sub_4C150(v27, v71, v85, (int)"util.c", (int)"parse_notify", 2064);
                  v28 = *(_DWORD *)(a1 + 1564);
                  if ( v28 )
                  {
                    sub_4C150(
                      (void *)(*(_DWORD *)(a1 + 1568) + v85),
                      *(const void **)(a1 + 616),
                      v28,
                      (int)"util.c",
                      (int)"parse_notify",
                      2066);
                    v28 = *(_DWORD *)(a1 + 1564);
                  }
                  sub_4C150(
                    (void *)(*(_DWORD *)(a1 + 1568) + v28 + *(_DWORD *)(a1 + 632) + v85),
                    v71,
                    v84,
                    (int)"util.c",
                    (int)"parse_notify",
                    2067);
                  v29 = (unsigned __int8)byte_1AECC5;
                  if ( byte_1AECC5 )
                  {
                    v48 = sub_4988C(*(_DWORD *)(a1 + 1568), *(_DWORD *)(a1 + 1572));
                    v49 = (char *)v48;
                    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
                    {
                      snprintf((char *)v94, 0x800u, "Pool %d coinbase %s", *(_DWORD *)a1, v48);
                      sub_47AB4(7, (const char *)v94, 0);
                    }
                    v6 = v29;
                    free(v49);
                  }
                  goto LABEL_66;
                }
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
                {
                  v33 = (int *)&unk_82D9C;
LABEL_113:
                  v34 = *v33;
                  v35 = v33[1];
                  v36 = v33[2];
                  v37 = v33[3];
                  v38 = v33 + 4;
                  v94[0] = v34;
                  v94[1] = v35;
                  v94[2] = v36;
                  v94[3] = v37;
                  v39 = *v38;
                  v40 = v38[1];
                  v41 = v38[2];
                  v42 = v38[3];
                  v38 += 4;
                  v94[4] = v39;
                  v94[5] = v40;
                  v94[6] = v41;
                  v94[7] = v42;
                  v43 = *v38;
                  v44 = v38[1];
                  v45 = v38[2];
                  v46 = v38[3];
                  v47 = v38[4];
                  v94[8] = v43;
                  v94[9] = v44;
                  v94[10] = v45;
                  v94[11] = v46;
                  LOBYTE(v94[12]) = v47;
                  sub_47AB4(3, (const char *)v94, 0);
                  goto LABEL_66;
                }
              }
              else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
              {
                v33 = (int *)&unk_82D68;
                goto LABEL_113;
              }
LABEL_120:
              v6 = 0;
              goto LABEL_66;
            }
            if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
              goto LABEL_120;
            v50 = "Failed to convert header to header_bin in parse_notify";
LABEL_129:
            v51 = *(_DWORD *)v50;
            v52 = *((_DWORD *)v50 + 1);
            v53 = *((_DWORD *)v50 + 2);
            v54 = *((_DWORD *)v50 + 3);
            v55 = (int *)(v50 + 16);
            v94[0] = v51;
            v94[1] = v52;
            v94[2] = v53;
            v94[3] = v54;
            v56 = *v55;
            v57 = v55[1];
            v58 = v55[2];
            v59 = v55[3];
            v55 += 4;
            v94[4] = v56;
            v94[5] = v57;
            v94[6] = v58;
            v94[7] = v59;
            v60 = *v55;
            v61 = v55[1];
            v62 = v55[2];
            v63 = v55[3];
            v55 += 4;
            v94[8] = v60;
            v94[9] = v61;
            v94[10] = v62;
            v94[11] = v63;
            v64 = v55[1];
            v94[12] = *v55;
            LOWORD(v94[13]) = v64;
            BYTE2(v94[13]) = BYTE2(v64);
            sub_47AB4(3, (const char *)v94, 0);
LABEL_66:
            sub_493D4(v75, "parse_notify", 2076);
            sub_49450(v76, "parse_notify", 2076);
            off_9E444();
            if ( !*v83 )
              goto LABEL_106;
            if ( !byte_1AECC5 )
              goto LABEL_84;
            if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
            {
              snprintf((char *)v94, 0x800u, "job_id: %s", v11);
              sub_47AB4(7, (const char *)v94, 0);
              if ( byte_1AECC5 )
              {
                if ( !byte_244080 )
                  goto LABEL_73;
LABEL_75:
                snprintf((char *)v94, 0x800u, "prev_hash: %s", v90);
                sub_47AB4(7, (const char *)v94, 0);
                if ( byte_1AECC5 )
                {
                  if ( !byte_244080 )
                    goto LABEL_77;
                  goto LABEL_79;
                }
LABEL_94:
                if ( byte_1AECC5 )
                {
                  if ( !byte_244080 )
                    goto LABEL_96;
LABEL_98:
                  snprintf((char *)v94, 0x800u, "ntime: %s", v87);
                  sub_47AB4(7, (const char *)v94, 0);
LABEL_99:
                  if ( byte_1AECC5 )
                  {
                    if ( !byte_244080 )
                      goto LABEL_101;
                    goto LABEL_103;
                  }
                }
                goto LABEL_106;
              }
LABEL_89:
              if ( !byte_1AECC5 )
                goto LABEL_106;
              if ( !byte_244080 )
              {
LABEL_91:
                if ( !byte_1AECC4 && dword_9E320 <= 6 )
                {
LABEL_96:
                  if ( byte_1AECC4 || dword_9E320 > 6 )
                    goto LABEL_98;
LABEL_101:
                  if ( byte_1AECC4 || dword_9E320 > 6 )
                  {
LABEL_103:
                    v30 = (int *)"yes";
                    if ( !v86 )
                      v30 = &dword_80288;
                    snprintf((char *)v94, 0x800u, "clean: %s", v30);
                    sub_47AB4(7, (const char *)v94, 0);
                  }
LABEL_106:
                  free(ptr);
                  free(s);
                  v31 = dword_245168;
                  v32 = dword_24516C;
                  ++*(_DWORD *)(a1 + 116);
                  *(_QWORD *)&dword_245168 = __PAIR64__(v32, v31) + 1;
                  if ( a1 == sub_58084() )
                    byte_246370 = 1;
                  return v6;
                }
              }
              snprintf((char *)v94, 0x800u, "nbit: %s", v88);
              sub_47AB4(7, (const char *)v94, 0);
              goto LABEL_94;
            }
LABEL_73:
            if ( byte_1AECC4 || dword_9E320 > 6 )
              goto LABEL_75;
LABEL_77:
            if ( byte_1AECC4 || dword_9E320 > 6 )
            {
LABEL_79:
              snprintf((char *)v94, 0x800u, "coinbase1: %s", (const char *)ptr);
              sub_47AB4(7, (const char *)v94, 0);
              if ( !byte_1AECC5 )
                goto LABEL_99;
              if ( !byte_244080 )
                goto LABEL_81;
LABEL_83:
              snprintf((char *)v94, 0x800u, "coinbase2: %s", s);
              sub_47AB4(7, (const char *)v94, 0);
LABEL_84:
              if ( !byte_1AECC5 )
                goto LABEL_106;
              if ( !byte_244080 )
              {
LABEL_86:
                if ( !byte_1AECC4 && dword_9E320 <= 6 )
                  goto LABEL_91;
              }
              snprintf((char *)v94, 0x800u, "bbversion: %s", v89);
              sub_47AB4(7, (const char *)v94, 0);
              goto LABEL_89;
            }
LABEL_81:
            if ( byte_1AECC4 || dword_9E320 > 6 )
              goto LABEL_83;
            goto LABEL_86;
          }
        }
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
        {
          snprintf(
            (char *)v94,
            0x800u,
            "Invalid char 0x%x passed to valid_ascii from in %s %s():%d",
            v16,
            "util.c",
            "parse_notify",
            1969);
          goto LABEL_33;
        }
        goto LABEL_34;
      }
      if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
      {
LABEL_34:
        free(v11);
        free(ptr);
        free(s);
        return v6;
      }
      snprintf(
        (char *)v94,
        0x800u,
        "Zero length string passed to valid_ascii from in %s %s():%d",
        "util.c",
        "parse_notify",
        1969);
    }
    else
    {
      if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
        goto LABEL_34;
      snprintf(
        (char *)v94,
        0x800u,
        "Null string passed to valid_ascii from in %s %s():%d",
        "util.c",
        "parse_notify",
        1969);
    }
LABEL_33:
    sub_47AB4(3, (const char *)v94, 0);
    goto LABEL_34;
  }
  v9 = 0;
  v6 = 0;
  while ( 1 )
  {
    memset(v93, 0, 0x20u);
    v10 = (unsigned __int8 *)sub_49188(v5, v9);
    if ( !v10 )
      return v6;
    v6 = sub_49940(v93, v10, 32);
    if ( !v6 )
    {
      if ( (byte_244080 || byte_1AECC4 || dword_9E320 > 2)
        && ((snprintf((char *)v94, 0x800u, "merkle %d: %s", v9, (const char *)v10),
             sub_47AB4(3, (const char *)v94, 0),
             byte_244080)
         || byte_1AECC4)
        || dword_9E320 > 2 )
      {
        strcpy((char *)v94, "Failed to convert merkle to merkle_bin in parse_notify");
        sub_47AB4(3, (const char *)v94, 0);
      }
      free(v10);
      return v6;
    }
    ++v9;
    free(v10);
    if ( v8 == v9 )
      goto LABEL_20;
  }
}
// 80288: using guessed type int dword_80288;
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9EDA4: using guessed type char *off_9EDA4[2];
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 242F18: using guessed type char byte_242F18;
// 244080: using guessed type char byte_244080;
// 245168: using guessed type int dword_245168;
// 24516C: using guessed type int dword_24516C;
// 246370: using guessed type char byte_246370;

//----- (0004D498) --------------------------------------------------------
int __fastcall sub_4D498(const char **a1, int a2, int a3)
{
  __int16 v6; // kr00_2
  unsigned int v7; // r10
  const char *v9; // r0
  const char *v10; // r10
  size_t v11; // r0
  size_t v12; // r8
  int v13; // r4
  unsigned int v14; // r10
  struct addrinfo *pai; // [sp+8h] [bp-A28h] BYREF
  char v16; // [sp+Ch] [bp-A24h] BYREF
  __int16 v17; // [sp+2Ch] [bp-A04h] BYREF
  char v18; // [sp+2Eh] [bp-A02h]
  char v19; // [sp+2Fh] [bp-A01h]
  int v20; // [sp+30h] [bp-A00h]
  char v21[8]; // [sp+34h] [bp-9FCh] BYREF
  _BYTE v22[500]; // [sp+3Ch] [bp-9F4h] BYREF
  struct addrinfo flags[64]; // [sp+230h] [bp-800h] BYREF

  v17 = 260;
  v6 = strtol(a1[146], 0, 10);
  v18 = HIBYTE(v6);
  v19 = v6;
  strcpy(v21, "CGMINER");
  v7 = bswap32(inet_addr(a1[150]));
  if ( v7 != -1 )
    goto LABEL_2;
  pai = (struct addrinfo *)&v16;
  memset(flags, 0, 0x20u);
  v9 = a1[150];
  flags[0].ai_family = 2;
  if ( !getaddrinfo(v9, 0, flags, &pai) )
  {
    v14 = *(_DWORD *)&pai->ai_addr->sa_data[2];
    freeaddrinfo(pai);
    v7 = bswap32(v14);
    if ( v7 != -1 )
    {
LABEL_2:
      HIBYTE(v20) = v7;
      LOBYTE(v20) = HIBYTE(v7);
      BYTE1(v20) = BYTE2(v7);
      BYTE2(v20) = BYTE1(v7);
      send(a2, &v17, 0x10u, 0);
      goto LABEL_3;
    }
LABEL_23:
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
    {
      snprintf((char *)flags, 0x800u, "Invalid IP address specified for socks4 proxy: %s", a1[150]);
      goto LABEL_9;
    }
    return 0;
  }
  if ( !a3 )
    goto LABEL_23;
  v10 = a1[150];
  v20 = 0x1000000;
  v11 = strlen(v10);
  if ( v11 >= 0xFF )
    v12 = 255;
  else
    v12 = v11;
  sub_4C150(v22, v10, v12, (int)"util.c", (int)"socks4_negotiate", 2898);
  v22[v12] = 0;
  send(a2, &v17, v12 + 17, 0);
LABEL_3:
  if ( recv(a2, flags, 1u, 0) == -1
    || LOBYTE(flags[0].ai_flags)
    || recv(a2, flags, 1u, 0) == -1
    || LOBYTE(flags[0].ai_flags) != 90 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
    {
      snprintf((char *)flags, 0x800u, "Bad response from %s:%s SOCKS4 server", a1[151], a1[152]);
LABEL_9:
      sub_47AB4(4, (const char *)flags, 0);
      return 0;
    }
    return 0;
  }
  v13 = 6;
  do
  {
    recv(a2, flags, 1u, 0);
    --v13;
  }
  while ( v13 );
  return 1;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0004D754) --------------------------------------------------------
int __fastcall sub_4D754(_DWORD *a1)
{
  int v2; // r0
  int v3; // r3
  int v4; // r0
  int v5; // r5
  const char *v7; // r1
  size_t v8; // r3
  void *v9; // r0
  _BYTE *v10; // r0
  int v11; // r2
  unsigned __int8 *v12; // r1
  int *v13; // r0
  int *v14; // r0
  int v15; // r3
  int v16; // r2
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r2
  struct addrinfo *v20; // r5
  int v21; // r0
  int *v22; // r9
  int v23; // r0
  int v24; // r6
  char *v25; // r12
  int v26; // r0
  int v27; // r1
  int v28; // r2
  __int16 v29; // r3
  int v30; // r7
  int v31; // r3
  int v32; // r8
  char *v33; // r7
  fd_set *v34; // r3
  int v35; // r0
  const char *v36; // r0
  int v37; // r3
  int v38; // r4
  int v39; // r2
  int v40; // r0
  const char *v41; // r3
  int v42; // r2
  size_t v43; // r0
  int v44; // r2
  int *v45; // r0
  int *v46; // r0
  int v47; // r2
  const char *v48; // r0
  size_t v49; // r0
  size_t v50; // r5
  __int16 v51; // r0
  char *v52; // r12
  int v53; // r12
  int v54; // r3
  char *v55; // r0
  char *v56; // r4
  _DWORD *v57; // r4
  _DWORD *v58; // r0
  char *v59; // r4
  unsigned int *v60; // r3
  unsigned int v61; // r2
  unsigned int v62; // r2
  int *v63; // r0
  int *v64; // r0
  int *v65; // r0
  int *v66; // r0
  _DWORD *v67; // r0
  _DWORD *v68; // r9
  _DWORD *v69; // r7
  _DWORD *v70; // r0
  _DWORD *v71; // r8
  char *v72; // r6
  char *v73; // r8
  const char *v74; // r0
  _DWORD *v76; // r0
  char *v77; // r0
  int *v78; // r0
  int v79; // r5
  int v80; // r5
  int v81; // r4
  int v83; // r4
  char *service; // [sp+18h] [bp-2B64h]
  char *servicea; // [sp+18h] [bp-2B64h]
  char *serviceb; // [sp+18h] [bp-2B64h]
  char *name; // [sp+1Ch] [bp-2B60h]
  pthread_mutex_t *mutex; // [sp+20h] [bp-2B5Ch]
  double *v89; // [sp+2Ch] [bp-2B50h]
  int v90; // [sp+30h] [bp-2B4Ch]
  unsigned int v91; // [sp+34h] [bp-2B48h]
  struct addrinfo *pai; // [sp+44h] [bp-2B38h] BYREF
  socklen_t optlen; // [sp+48h] [bp-2B34h] BYREF
  int optval; // [sp+4Ch] [bp-2B30h] BYREF
  struct timeval timeout; // [sp+50h] [bp-2B2Ch] BYREF
  struct addrinfo s; // [sp+58h] [bp-2B24h] BYREF
  char v97[92]; // [sp+78h] [bp-2B04h] BYREF
  char v98[156]; // [sp+D4h] [bp-2AA8h] BYREF
  char v99; // [sp+170h] [bp-2A0Ch] BYREF
  fd_set writefds; // [sp+174h] [bp-2A08h] BYREF
  char v101[2040]; // [sp+378h] [bp-2804h] BYREF
  char v102[8196]; // [sp+B78h] [bp-2004h] BYREF

  v89 = 0;
  mutex = (pthread_mutex_t *)(a1 + 176);
  v90 = 0;
  while ( 2 )
  {
    if ( pthread_mutex_lock(mutex) )
    {
      v46 = _errno_location();
      snprintf(
        v101,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v46,
        "util.c",
        "setup_stratum_socket",
        2945);
      sub_47AB4(3, v101, 1);
      sub_62EC0(1);
    }
    v2 = a1[147];
    *((_BYTE *)a1 + 641) = 0;
    if ( v2 )
      close(v2);
    a1[147] = 0;
    if ( pthread_mutex_unlock(mutex) )
    {
      v45 = _errno_location();
      snprintf(
        v101,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v45,
        "util.c",
        "setup_stratum_socket",
        2950);
      sub_47AB4(3, v101, 1);
      sub_62EC0(1);
    }
    off_9E444();
    memset(&s, 0, sizeof(s));
    v3 = a1[46];
    s.ai_socktype = 1;
    if ( v3 )
      goto LABEL_7;
    v36 = (const char *)dword_1B09F4;
    if ( !dword_1B09F4 )
    {
      name = (char *)a1[150];
      goto LABEL_104;
    }
    a1[46] = dword_1B09F4;
    sub_4A940(v36, a1 + 151, (char **)a1 + 152);
    v37 = a1[46];
    a1[45] = 3;
    name = (char *)a1[150];
    if ( !v37 )
    {
LABEL_104:
      service = (char *)a1[146];
      v4 = getaddrinfo(name, service, &s, &pai);
      goto LABEL_8;
    }
LABEL_7:
    name = (char *)a1[151];
    service = (char *)a1[152];
    v4 = getaddrinfo(name, service, &s, &pai);
LABEL_8:
    v91 = v4;
    if ( v4 )
    {
      if ( !*((_BYTE *)a1 + 99) )
      {
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
        {
          snprintf(v101, 0x800u, "Failed to resolve (?wrong URL) %s:%s", name, service);
          sub_47AB4(4, v101, 0);
        }
        *((_BYTE *)a1 + 99) = 1;
        goto LABEL_15;
      }
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        snprintf(v101, 0x800u, "Failed to getaddrinfo for %s:%s", name, service);
        sub_47AB4(6, v101, 0);
        goto LABEL_15;
      }
      goto LABEL_108;
    }
    v20 = pai;
    if ( !pai )
    {
LABEL_71:
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        snprintf(v101, 0x800u, "Failed to connect to stratum on %s:%s", name, service);
        sub_47AB4(6, v101, 0);
      }
      freeaddrinfo(pai);
      goto LABEL_15;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v23 = socket(v20->ai_family, v20->ai_socktype, v20->ai_protocol);
        v24 = v23;
        if ( v23 != -1 )
          break;
        if ( !byte_1AECC5 || !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
          goto LABEL_63;
        v25 = v101;
        v26 = *(_DWORD *)"Failed socket";
        v27 = *(_DWORD *)"ed socket";
        v28 = *(_DWORD *)"ocket";
        v29 = *(_WORD *)"t";
LABEL_70:
        *(_DWORD *)v25 = v26;
        *((_DWORD *)v25 + 1) = v27;
        *((_DWORD *)v25 + 2) = v28;
        *((_WORD *)v25 + 6) = v29;
        sub_47AB4(7, v101, 0);
        v20 = v20->ai_next;
        if ( !v20 )
          goto LABEL_71;
      }
      v21 = fcntl(v23, 3, 0);
      fcntl(v24, 4, v21 | 0x800);
      if ( connect(v24, v20->ai_addr, v20->ai_addrlen) != -1 )
        break;
      timeout.tv_usec = 0;
      timeout.tv_sec = 1;
      v22 = _errno_location();
      if ( *v22 == 115 )
      {
        v30 = v24 + 31;
        if ( v24 >= 0 )
          v30 = v24;
        LOBYTE(v31) = v24 & 0x1F;
        if ( v24 <= 0 )
          v31 = -(-v24 & 0x1F);
        v32 = 1 << v31;
        v33 = &v102[4 * (v30 >> 5)];
        while ( 1 )
        {
          v34 = (fd_set *)&v99;
          do
          {
            v34->__fds_bits[1] = 0;
            v34 = (fd_set *)((char *)v34 + 4);
          }
          while ( &writefds.__fds_bits[31] != (__fd_mask *)v34 );
          *((_DWORD *)v33 - 641) |= v32;
          v35 = select(v24 + 1, 0, &writefds, 0, &timeout);
          if ( v35 > 0 )
            break;
          if ( !v35 || *v22 != 4 )
            goto LABEL_85;
        }
        if ( (v32 & *((_DWORD *)v33 - 641)) != 0 )
        {
          optlen = 4;
          if ( !getsockopt(v24, 1, 4, &optval, &optlen) && !optval )
          {
            if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
            {
              strcpy(v101, "Succeeded delayed connect");
              sub_47AB4(7, v101, 0);
            }
            goto LABEL_100;
          }
        }
LABEL_85:
        close(v24);
        if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
        {
          qmemcpy(v101, "Select timeout/f", 16);
          v25 = &v101[16];
          v26 = *(_DWORD *)"ailed connect";
          v27 = *(_DWORD *)"d connect";
          v28 = *(_DWORD *)"nnect";
          v29 = *(_WORD *)"t";
          goto LABEL_70;
        }
      }
      else
      {
        close(v24);
        if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
        {
          strcpy(v101, "Failed sock connect");
          sub_47AB4(7, v101, 0);
        }
      }
LABEL_63:
      v20 = v20->ai_next;
      if ( !v20 )
        goto LABEL_71;
    }
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
    {
      strcpy(v101, "Succeeded immediate connect");
      sub_47AB4(4, v101, 0);
    }
LABEL_100:
    sub_49068(v24);
    freeaddrinfo(pai);
    if ( !a1[46] )
    {
LABEL_117:
      if ( !a1[148] )
      {
        a1[148] = sub_496AC(0x2000u, 1u, "util.c", "setup_stratum_socket", 3087);
        a1[149] = 0x2000;
      }
      a1[147] = v24;
      writefds.__fds_bits[0] = 45;
      *(_DWORD *)v101 = 30;
      timeout.tv_sec = 1;
      v40 = fcntl(v24, 3, 0);
      fcntl(v24, 4, v40 | 0x800);
      setsockopt(v24, 1, 9, &timeout, 4u);
      if ( !byte_244081 )
        fcntl(v24, 2, 1);
      setsockopt(v24, 6, 1, &timeout, 4u);
      setsockopt(v24, 6, 6, &timeout, 4u);
      setsockopt(v24, 6, 4, &writefds, 4u);
      setsockopt(v24, 6, 5, v101, 4u);
      if ( v90 )
      {
        sub_49530((int)a1);
        v44 = dword_24400C++;
        sprintf(v102, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v44);
      }
      else
      {
        v41 = (const char *)a1[159];
        v42 = dword_24400C++;
        if ( v41 )
          sprintf(
            v102,
            "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"miner_1397/1.0.0\", \"%s\"]}",
            v42,
            v41);
        else
          sprintf(v102, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"miner_1397/1.0.0\"]}", v42);
      }
      v43 = strlen(v102);
      if ( sub_48908((int)a1, v102, v43) )
      {
        if ( !byte_1AECC5 )
          goto LABEL_126;
        if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
          goto LABEL_130;
        strcpy(v101, "Failed to send s in initiate_stratum");
        sub_47AB4(7, v101, 0);
LABEL_137:
        v38 = (unsigned __int8)byte_1AECC5;
        if ( !byte_1AECC5 )
          goto LABEL_126;
LABEL_131:
        if ( byte_244080 )
          goto LABEL_133;
        goto LABEL_132;
      }
      if ( !sub_49090(a1[147], 60) )
      {
        if ( !byte_1AECC5 )
          goto LABEL_126;
        if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
        {
LABEL_130:
          v38 = 1;
          goto LABEL_131;
        }
        strcpy(v101, "Timed out waiting for response in initiate_stratum");
        sub_47AB4(7, v101, 0);
        goto LABEL_137;
      }
      v55 = sub_4B4C0((int)a1);
      v56 = v55;
      if ( !v55 )
        goto LABEL_137;
      v89 = sub_6D110((int)v55, 0, v97);
      free(v56);
      if ( !v89 )
      {
        v90 ^= 1u;
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
        {
          snprintf(v101, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)v97, v98);
          sub_47AB4(6, v101, 0);
        }
        goto LABEL_189;
      }
      v57 = (_DWORD *)sub_6DFCC(v89, "result");
      v58 = (_DWORD *)sub_6DFCC(v89, "error");
      if ( !v57 || *v57 == 7 )
      {
        if ( !v58 )
        {
          v59 = (char *)malloc(0x11u);
          if ( v59 )
            strcpy(v59, "(unknown reason)");
          goto LABEL_184;
        }
      }
      else if ( !v58 || *v58 == 7 )
      {
        v67 = sub_6E1C4(v57, 0);
        v68 = v67;
        if ( v67 )
        {
          if ( *v67 == 1 )
          {
            v69 = sub_6E1A8(v67);
            if ( (int)v69 > 0 )
            {
              do
              {
                v70 = sub_6E1C4(v68, v91);
                v71 = v70;
                if ( !v70 || *v70 != 1 )
                  break;
                v74 = (const char *)sub_49124(v70, 0);
                if ( v74 && !strncasecmp(v74, "mining.notify", 0xDu) )
                {
                  v72 = sub_49188(v71, 1u);
                  if ( v72 )
                    goto LABEL_233;
                  break;
                }
              }
              while ( v69 != (_DWORD *)++v91 );
            }
          }
        }
        v72 = (char *)(unsigned __int8)byte_1AECC5;
        if ( byte_1AECC5 )
        {
          if ( byte_244080 || (v72 = (char *)(unsigned __int8)byte_1AECC4, byte_1AECC4) || dword_9E320 > 6 )
          {
            v72 = 0;
            strcpy(v101, "Failed to get sessionid in initiate_stratum");
            sub_47AB4(7, v101, 0);
          }
        }
LABEL_233:
        v73 = sub_49188(v57, 1u);
        v5 = sub_49208(v73, "initiate_stratum", 3216);
        if ( v5 )
        {
          v76 = sub_6E1C4(v57, 2u);
          v77 = (char *)sub_6E430((int)v76);
          if ( (unsigned int)(v77 - 2) <= 0xE )
          {
            servicea = v77;
            if ( v72 )
            {
              v7 = (const char *)a1[159];
              if ( v7 )
              {
                if ( !strcmp(v72, v7) && (byte_244080 || byte_1AECC4 || dword_9E320 > 4) )
                {
                  snprintf(v101, 0x800u, "Pool %d successfully negotiated resume with the same session ID", *a1);
                  sub_47AB4(5, v101, 0);
                }
              }
            }
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
              sub_494CC("initiate_stratum", 3236);
            if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
            {
              v78 = _errno_location();
              snprintf(
                v101,
                0x800u,
                "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                *v78,
                "util.c",
                "initiate_stratum",
                3236);
              sub_47AB4(3, v101, 1);
              sub_62EC0(1);
            }
            free((void *)a1[153]);
            free((void *)a1[159]);
            a1[159] = v72;
            a1[153] = v73;
            v8 = strlen(v73) >> 1;
            v9 = (void *)a1[154];
            a1[391] = v8;
            free(v9);
            v10 = sub_496AC(a1[391], 1u, "util.c", "initiate_stratum", 3243);
            v11 = a1[391];
            v12 = (unsigned __int8 *)a1[153];
            a1[154] = v10;
            sub_49940(v10, v12, v11);
            a1[158] = servicea;
            if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
            {
              v13 = _errno_location();
              snprintf(
                v101,
                0x800u,
                "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                *v13,
                "util.c",
                "initiate_stratum",
                3246);
              sub_47AB4(3, v101, 1);
              sub_62EC0(1);
            }
            if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
            {
              v14 = _errno_location();
              snprintf(
                v101,
                0x800u,
                "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                *v14,
                "util.c",
                "initiate_stratum",
                3246);
              sub_47AB4(3, v101, 1);
              sub_62EC0(1);
            }
            off_9E444();
            if ( v72 && byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
            {
              snprintf(v101, 0x800u, "Pool %d stratum session id: %s", *a1, (const char *)a1[159]);
              sub_47AB4(7, v101, 0);
            }
            v15 = a1[144];
            *((_BYTE *)a1 + 641) = 1;
            if ( !v15 )
              a1[144] = a1[150];
            v16 = (unsigned __int8)byte_242F18;
            *((_QWORD *)a1 + 227) = 0;
            *((_QWORD *)a1 + 228) = 0x3FF0000000000000LL;
            if ( v16 )
            {
              v5 = (unsigned __int8)byte_1AECC5;
              if ( byte_1AECC5 )
              {
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
                {
                  snprintf(
                    v101,
                    0x800u,
                    "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
                    *a1,
                    (const char *)a1[153],
                    a1[158]);
                  sub_47AB4(7, v101, 0);
                }
              }
              else
              {
                v5 = v16;
              }
            }
LABEL_49:
            if ( *((_DWORD *)v89 + 1) == -1 )
              return v5;
            v17 = (unsigned int *)v89 + 1;
            __dmb(0xBu);
            do
            {
              v18 = __ldrex(v17);
              v19 = v18 - 1;
            }
            while ( __strex(v19, v17) );
            if ( v19 )
              return v5;
            sub_6E5DC((void **)v89);
            return v5;
          }
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
          {
            strcpy(v101, "Failed to get valid n2size in initiate_stratum");
            sub_47AB4(6, v101, 0);
          }
          v90 ^= 1u;
          free(v72);
          free(v73);
        }
        else
        {
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
          {
            strcpy(v101, "Failed to get valid nonce1 in initiate_stratum");
            sub_47AB4(6, v101, 0);
          }
          v90 ^= 1u;
          free(v72);
        }
        goto LABEL_189;
      }
      v59 = (char *)sub_6B6E8(v58, 3);
LABEL_184:
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        snprintf(v101, 0x800u, "JSON-RPC decode failed: %s", v59);
        sub_47AB4(6, v101, 0);
      }
      v90 ^= 1u;
      free(v59);
LABEL_189:
      if ( !v90 )
        goto LABEL_137;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      {
        v66 = _errno_location();
        snprintf(
          v101,
          0x800u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v66,
          "util.c",
          "initiate_stratum",
          3274);
        sub_47AB4(3, v101, 1);
        sub_62EC0(1);
      }
      if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v65 = _errno_location();
        snprintf(
          v101,
          0x800u,
          "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v65,
          "util.c",
          "initiate_stratum",
          3274);
        sub_47AB4(3, v101, 1);
        sub_62EC0(1);
      }
      free((void *)a1[159]);
      free((void *)a1[153]);
      a1[153] = 0;
      a1[159] = 0;
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v64 = _errno_location();
        snprintf(
          v101,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v64,
          "util.c",
          "initiate_stratum",
          3278);
        sub_47AB4(3, v101, 1);
        sub_62EC0(1);
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
      {
        v63 = _errno_location();
        snprintf(
          v101,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v63,
          "util.c",
          "initiate_stratum",
          3278);
        sub_47AB4(3, v101, 1);
        sub_62EC0(1);
      }
      off_9E444();
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        strcpy(v101, "Failed to resume stratum, trying afresh");
        sub_47AB4(7, v101, 0);
      }
      if ( v89 )
      {
        if ( *((_DWORD *)v89 + 1) != -1 )
        {
          v60 = (unsigned int *)v89 + 1;
          __dmb(0xBu);
          do
          {
            v61 = __ldrex(v60);
            v62 = v61 - 1;
          }
          while ( __strex(v62, v60) );
          if ( !v62 )
            sub_6E5DC((void **)v89);
        }
      }
      continue;
    }
    break;
  }
  switch ( a1[45] )
  {
    case 0:
      v47 = 0;
      goto LABEL_150;
    case 1:
      v47 = 1;
LABEL_150:
      if ( !sub_48B74((const char **)a1, v24, v47) )
        goto LABEL_15;
      goto LABEL_117;
    case 2:
      v39 = 0;
      goto LABEL_116;
    case 3:
    case 5:
      BYTE2(writefds.__fds_bits[0]) = 0;
      LOWORD(writefds.__fds_bits[0]) = 261;
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        snprintf(
          v101,
          0x800u,
          "Attempting to negotiate with %s:%s SOCKS5 proxy",
          (const char *)a1[151],
          (const char *)a1[152]);
        sub_47AB4(7, v101, 0);
      }
      send(v24, &writefds, 3u, 0);
      if ( recv(v24, v101, 1u, 0) != -1
        && v101[0] == 5
        && recv(v24, v101, 1u, 0) != -1
        && BYTE2(writefds.__fds_bits[0]) == (unsigned __int8)v101[0] )
      {
        v48 = (const char *)a1[150];
        serviceb = (char *)v48;
        writefds.__fds_bits[0] = 50331909;
        v49 = strlen(v48);
        if ( v49 >= 0xFF )
          v50 = 255;
        else
          v50 = v49;
        LOBYTE(writefds.__fds_bits[1]) = v50;
        sub_4C150((char *)&writefds.__fds_bits[1] + 1, serviceb, v50, (int)"util.c", (int)"socks5_negotiate", 2796);
        v51 = strtol((const char *)a1[146], 0, 10);
        v52 = &v102[v50];
        *(v52 - 2558) = v51;
        *(v52 - 2559) = HIBYTE(v51);
        send(v24, &writefds, v50 + 7, 0);
        if ( recv(v24, v101, 1u, 0) == -1
          || v101[0] != 5
          || recv(v24, v101, 1u, 0) == -1
          || (v79 = (unsigned __int8)v101[0], v101[0])
          || (recv(v24, v101, 1u, 0), recv(v24, v101, 1u, v79) == -1) )
        {
LABEL_168:
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
          {
            v53 = a1[152];
            v54 = a1[151];
            goto LABEL_176;
          }
          goto LABEL_15;
        }
        if ( v101[0] == 1 )
        {
          v83 = 4;
          do
          {
            recv(v24, v101, 1u, 0);
            --v83;
          }
          while ( v83 );
        }
        else
        {
          if ( v101[0] != 3 )
            goto LABEL_168;
          v80 = 0;
          if ( recv(v24, v101, 1u, 0) == -1 )
            v81 = -1;
          else
            v81 = (unsigned __int8)v101[0];
          while ( v80++ < v81 )
            recv(v24, v101, 1u, 0);
        }
        recv(v24, v101, 1u, 0);
        recv(v24, v101, 1u, 0);
        if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
        {
          snprintf(
            v101,
            0x800u,
            "Success negotiating with %s:%s SOCKS5 proxy",
            (const char *)a1[151],
            (const char *)a1[152]);
          sub_47AB4(7, v101, 0);
        }
        goto LABEL_117;
      }
      if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
      {
LABEL_108:
        if ( !byte_1AECC5 )
          goto LABEL_16;
        v38 = 0;
LABEL_132:
        if ( !byte_1AECC4 && dword_9E320 <= 6 )
        {
LABEL_134:
          if ( !v38 )
            goto LABEL_16;
LABEL_126:
          sub_4AFA8((int)a1);
          goto LABEL_16;
        }
LABEL_133:
        strcpy(v101, "Initiate stratum failed");
        sub_47AB4(7, v101, 0);
        goto LABEL_134;
      }
      v54 = a1[151];
      v53 = a1[152];
LABEL_176:
      snprintf(v101, 0x800u, "Bad response from %s:%s SOCKS5 server", v54, v53);
      sub_47AB4(4, v101, 0);
LABEL_15:
      if ( byte_1AECC5 )
      {
        v38 = 0;
        goto LABEL_131;
      }
LABEL_16:
      if ( v89 )
      {
        v5 = 0;
        goto LABEL_49;
      }
      return 0;
    case 4:
      v39 = 1;
LABEL_116:
      if ( sub_4D498((const char **)a1, v24, v39) )
        goto LABEL_117;
      goto LABEL_15;
    default:
      if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
        goto LABEL_108;
      snprintf(v101, 0x800u, "Unsupported proxy type for %s:%s", (const char *)a1[151], (const char *)a1[152]);
      sub_47AB4(4, v101, 0);
      goto LABEL_15;
  }
}
// 4E0A0: control flows out of bounds to 4E0A4
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1B09F4: using guessed type int dword_1B09F4;
// 242F18: using guessed type char byte_242F18;
// 24400C: using guessed type int dword_24400C;
// 244080: using guessed type char byte_244080;
// 244081: using guessed type char byte_244081;

//----- (0004F2F8) --------------------------------------------------------
int __fastcall sub_4F2F8(int a1)
{
  int v3; // r5

  if ( *(_BYTE *)(a1 + 641) )
    sub_4AFA8(a1);
  if ( sub_4D754((_DWORD *)a1) && (!*(_BYTE *)(a1 + 580) || sub_50338(a1)) && (v3 = sub_50730((_DWORD *)a1)) != 0 )
  {
    sub_58490(a1);
    return v3;
  }
  else
  {
    sub_5A31C(a1);
    return 0;
  }
}
// 50338: using guessed type int __fastcall sub_50338(_DWORD);

//----- (0004F374) --------------------------------------------------------
int __fastcall sub_4F374(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  const char *v5; // r6
  const char *v6; // r7
  char *v7; // r8
  char *v8; // r1
  _DWORD *v9; // r0
  int v10; // r2
  const char *v11; // r5
  int v12; // r3
  void *v13; // r0
  void *v14; // r0
  _DWORD *v16; // r0
  int *v17; // r0
  int *v18; // r0
  char s[264]; // [sp+10h] [bp-A2Ch] BYREF
  int v20; // [sp+118h] [bp-924h] BYREF
  char *v21; // [sp+11Ch] [bp-920h] BYREF
  char v22[256]; // [sp+120h] [bp-91Ch] BYREF
  char v23[12]; // [sp+220h] [bp-81Ch] BYREF

  memset(v22, 0, 0xFFu);
  v4 = sub_6E1C4(a2, 0);
  v5 = (const char *)sub_6E350(v4);
  if ( !v5 )
  {
    v5 = (const char *)a1[150];
    goto LABEL_6;
  }
  v6 = (const char *)a1[150];
  v7 = strchr(v6, 46);
  if ( !v7 )
  {
    if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
      return 0;
    snprintf(v23, 0x800u, "Denied stratum reconnect request for pool without domain '%s'", v6);
    goto LABEL_20;
  }
  v8 = strchr(v5, 46);
  if ( !v8 )
  {
    if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
      return 0;
    snprintf(v23, 0x800u, "Denied stratum reconnect request to url without domain '%s'", v5);
    goto LABEL_20;
  }
  if ( strcmp(v7, v8) )
  {
    if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
      return 0;
    snprintf(v23, 0x800u, "Denied stratum reconnect request to non-matching domain url '%s'", v6);
LABEL_20:
    sub_47AB4(3, v23, 0);
    return 0;
  }
LABEL_6:
  v9 = sub_6E1C4(a2, 1u);
  v10 = sub_6E430((int)v9);
  if ( v10 )
  {
    v11 = s;
    sprintf(s, "%d", v10);
  }
  else
  {
    v16 = sub_6E1C4(a2, 1u);
    v11 = (const char *)sub_6E350(v16);
    if ( !v11 )
      v11 = (const char *)a1[146];
  }
  snprintf(v22, 0xFEu, "%s:%s", v5, v11);
  if ( !sub_4A940(v22, &v20, &v21) )
    return 0;
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
  {
    snprintf(v23, 0x800u, "Stratum reconnect requested from pool %d to %s", *a1, v22);
    sub_47AB4(4, v23, 0);
  }
  sub_59B44(a1);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 176)) )
  {
    v17 = _errno_location();
    snprintf(v23, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v17, "util.c", "parse_reconnect", 2370);
    sub_47AB4(3, v23, 1);
    sub_62EC0(1);
  }
  sub_49028((int)a1);
  v12 = v20;
  v13 = (void *)a1[150];
  a1[144] = v20;
  a1[150] = v12;
  free(v13);
  v14 = (void *)a1[146];
  a1[146] = v21;
  free(v14);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176)) )
  {
    v18 = _errno_location();
    snprintf(v23, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v18, "util.c", "parse_reconnect", 2379);
    sub_47AB4(3, v23, 1);
    sub_62EC0(1);
  }
  off_9E444();
  return sub_4F2F8((int)a1);
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0004F748) --------------------------------------------------------
int __fastcall sub_4F748(_DWORD *a1, int a2)
{
  double v2; // d0
  double *v4; // r0
  double *v5; // r5
  _DWORD *v6; // r7
  _DWORD *v7; // r4
  _DWORD *v8; // r8
  const char *v9; // r0
  const char *v10; // r7
  unsigned int v11; // r4
  _DWORD *i; // r6
  bool v13; // cf
  unsigned int v14; // r1
  _DWORD *v15; // r0
  int v16; // r4
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r2
  const char *v21; // r4
  char *v22; // r0
  int v23; // r0
  int v24; // r0
  size_t v25; // r0
  _DWORD *v26; // r0
  char *v27; // r0
  _DWORD *v28; // r0
  double *v29; // r3
  double v30; // d9
  const char *v31; // r2
  int v32; // r3
  char *v33; // r9
  int v34; // r0
  int v35; // r0
  _DWORD *v36; // r0
  _DWORD *v37; // r0
  _DWORD *v38; // r0
  size_t v39; // r3
  void *v40; // r0
  void *v41; // r0
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  int *v45; // r0
  int *v46; // r0
  int v47; // [sp+0h] [bp-211Ch]
  int v48; // [sp+14h] [bp-2108h]
  char v49[92]; // [sp+1Ch] [bp-2100h] BYREF
  char v50[160]; // [sp+78h] [bp-20A4h] BYREF
  char s[8196]; // [sp+118h] [bp-2004h] BYREF

  v4 = sub_6D110(a2, 0, v49);
  v5 = v4;
  if ( v4 )
  {
    v6 = (_DWORD *)sub_6DFCC(v4, "method");
    if ( !v6 )
      goto LABEL_14;
    v7 = (_DWORD *)sub_6DFCC(v5, "error");
    v8 = (_DWORD *)sub_6DFCC(v5, "params");
    if ( v7 && *v7 != 7 )
    {
      v21 = (const char *)sub_6B6E8(v7, 3);
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        snprintf(s, 0x800u, "JSON-RPC method decode failed: %s", v21);
        sub_47AB4(6, s, 0);
      }
      v22 = (char *)v21;
      v16 = 0;
      free(v22);
      goto LABEL_15;
    }
    v9 = (const char *)sub_6E350(v6);
    v10 = v9;
    if ( !v9 )
      goto LABEL_14;
    v11 = strncasecmp(v9, "mining.multi_version", 0x14u);
    if ( !v11 )
    {
      *((_BYTE *)a1 + 644) = 1;
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        strcpy(s, "Pool support multi version");
        sub_47AB4(6, s, 0);
      }
      for ( i = a1 + 163; ; ++i )
      {
        v13 = v11 >= (unsigned int)sub_6E1A8(v8);
        v14 = v11++;
        if ( v13 )
          break;
        v15 = sub_6E1C4(v8, v14);
        *i = sub_6E430((int)v15);
      }
      goto LABEL_50;
    }
    if ( !strncasecmp(v10, "mining.notify", 0xDu) )
    {
      v16 = sub_4C494((int)a1, v8);
      if ( v16 )
      {
        *((_BYTE *)a1 + 643) = 1;
        goto LABEL_15;
      }
    }
    else
    {
      if ( strncasecmp(v10, "mining.set_version_mask", 0x17u) )
      {
        if ( !strncasecmp(v10, "mining.set_difficulty", 0x15u) )
        {
          v28 = sub_6E1C4(v8, 0);
          sub_6E570((int)v28);
          if ( v2 == 0.0 )
            goto LABEL_14;
          if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
            sub_494CC("parse_diff", 2235);
          if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
          {
            v44 = _errno_location();
            snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v44, "util.c", "parse_diff", 2235);
            sub_47AB4(3, s, 1);
            sub_62EC0(1);
          }
          v29 = (double *)(a1 + 456);
          v30 = *((double *)a1 + 227);
          *((double *)a1 + 227) = v2;
          if ( v30 <= 0.0 )
          {
            v30 = *v29;
            *v29 = v2;
          }
          if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
          {
            v43 = _errno_location();
            snprintf(
              s,
              0x800u,
              "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
              *v43,
              "util.c",
              "parse_diff",
              2248);
            sub_47AB4(3, s, 1);
            sub_62EC0(1);
          }
          if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
          {
            v42 = _errno_location();
            snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v42, "util.c", "parse_diff", 2248);
            sub_47AB4(3, s, 1);
            sub_62EC0(1);
          }
          off_9E444();
          if ( v2 == v30 )
          {
            v16 = (unsigned __int8)byte_1AECC5;
            if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
            {
              snprintf(s, 0x800u, "Pool %d difficulty set to %f", *a1, v2);
              sub_47AB4(7, s, 0);
              goto LABEL_15;
            }
            goto LABEL_50;
          }
          if ( v2 != (double)(int)v2 )
          {
            if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
            {
              snprintf(s, 0x800u, "Pool %d difficulty changed to %.1f", *a1, v2);
              v16 = 1;
              sub_47AB4(5, s, 0);
              goto LABEL_15;
            }
            goto LABEL_50;
          }
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
          {
            v47 = (int)v2;
            v31 = "Pool %d difficulty changed to %d";
            v32 = *a1;
LABEL_65:
            v16 = 1;
            snprintf(s, 0x800u, v31, v32, v47);
            sub_47AB4(5, s, 0);
            goto LABEL_15;
          }
        }
        else
        {
          if ( !strncasecmp(v10, "mining.set_extranonce", 0x15u) )
          {
            v33 = sub_49188(v8, 0);
            v16 = sub_49208(v33, "parse_extranonce", 2278);
            if ( v16 )
            {
              v36 = sub_6E1C4(v8, 1u);
              v48 = sub_6E430((int)v36);
              if ( !v48 )
              {
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
                {
                  strcpy(s, "Failed to get valid n2size in parse_extranonce");
                  sub_47AB4(6, s, 0);
                }
                v16 = 0;
                free(v33);
                goto LABEL_15;
              }
              if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
                sub_494CC("parse_extranonce", 2290);
              if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
              {
                v46 = _errno_location();
                snprintf(
                  s,
                  0x800u,
                  "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                  *v46,
                  "util.c",
                  "parse_extranonce",
                  2290);
                sub_47AB4(3, s, 1);
                sub_62EC0(1);
              }
              free((void *)a1[153]);
              a1[153] = v33;
              v39 = strlen(v33) >> 1;
              v40 = (void *)a1[154];
              a1[391] = v39;
              free(v40);
              v41 = sub_496AC(a1[391], 1u, "util.c", "parse_extranonce", 2295);
              a1[154] = v41;
              if ( !v41 )
              {
                snprintf(
                  s,
                  0x800u,
                  "Failed to calloc pool->nonce1bin in %s %s():%d",
                  "util.c",
                  "parse_extranonce",
                  2297);
                sub_47AB4(3, s, 1);
                sub_62EC0(1);
              }
              sub_49940((_BYTE *)a1[154], (unsigned __int8 *)a1[153], a1[391]);
              a1[158] = v48;
              if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
              {
                v45 = _errno_location();
                snprintf(
                  s,
                  0x800u,
                  "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                  *v45,
                  "util.c",
                  "parse_extranonce",
                  2300);
                sub_47AB4(3, s, 1);
                sub_62EC0(1);
              }
              sub_49450((pthread_mutex_t *)(a1 + 53), "parse_extranonce", 2300);
              off_9E444();
              if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
              {
                snprintf(s, 0x800u, "Pool %d extranonce change requested", *a1);
                sub_47AB4(5, s, 0);
                goto LABEL_15;
              }
              goto LABEL_50;
            }
            if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
            {
              strcpy(s, "Failed to get valid nonce1 in parse_extranonce");
              sub_47AB4(6, s, 0);
              goto LABEL_15;
            }
            goto LABEL_14;
          }
          if ( !strncasecmp(v10, "client.reconnect", 0x10u) )
          {
            v16 = sub_4F374(a1, v8);
            goto LABEL_15;
          }
          if ( !strncasecmp(v10, "client.get_version", 0x12u) )
          {
            if ( sub_6DFCC(v5, "id") )
            {
              v34 = sub_6DFCC(v5, "id");
              v35 = sub_6E430(v34);
              sprintf(s, "{\"id\": %d, \"result\": \"miner_1397/1.0.0\", \"error\": null}", v35);
              goto LABEL_44;
            }
LABEL_14:
            v16 = 0;
LABEL_15:
            if ( *((_DWORD *)v5 + 1) != -1 )
            {
              v17 = (unsigned int *)v5 + 1;
              __dmb(0xBu);
              do
              {
                v18 = __ldrex(v17);
                v19 = v18 - 1;
              }
              while ( __strex(v19, v17) );
              if ( !v19 )
                sub_6E5DC((void **)v5);
            }
            return v16;
          }
          if ( strncasecmp(v10, "client.show_message", 0x13u) )
          {
            if ( !strncasecmp(v10, "mining.ping", 0xBu) )
            {
              if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
              {
                snprintf(s, 0x800u, "Pool %d ping", *a1);
                sub_47AB4(6, s, 0);
              }
              if ( !sub_6DFCC(v5, "id") )
              {
                v16 = 0;
                goto LABEL_15;
              }
              v23 = sub_6DFCC(v5, "id");
              v24 = sub_6E430(v23);
              sprintf(s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", v24);
LABEL_44:
              v25 = strlen(s);
              v16 = sub_4B10C((int)a1, s, v25);
              goto LABEL_15;
            }
            goto LABEL_14;
          }
          if ( !v8 )
            goto LABEL_14;
          if ( *v8 != 1 )
            goto LABEL_14;
          v37 = sub_6E1C4(v8, 0);
          v38 = sub_6E350(v37);
          if ( !v38 )
            goto LABEL_14;
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
          {
            v31 = "Pool %d message: %s";
            v47 = (int)v38;
            v32 = *a1;
            goto LABEL_65;
          }
        }
LABEL_50:
        v16 = 1;
        goto LABEL_15;
      }
      v16 = 1;
      v26 = sub_6E1C4(v8, 0);
      v27 = (char *)sub_6E350(v26);
      sub_49AE4((int)a1, v27);
    }
    *((_BYTE *)a1 + 643) = v16;
    goto LABEL_15;
  }
  if ( byte_244080 || (v16 = (unsigned __int8)byte_1AECC4, byte_1AECC4) || dword_9E320 > 5 )
  {
    v16 = 0;
    snprintf(s, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)v49, v50);
    sub_47AB4(6, s, 0);
  }
  return v16;
}
// 4FBF4: variable 'v2' is possibly undefined
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (00050324) --------------------------------------------------------
int __fastcall sub_50324(_DWORD *a1, int a2)
{
  if ( a2 )
    return sub_4F748(a1, a2);
  else
    return 0;
}

//----- (00050338) --------------------------------------------------------
int __fastcall sub_50338(_DWORD *a1)
{
  size_t v2; // r0
  int v3; // r7
  char *v4; // r5
  _BOOL4 v5; // r6
  double *v7; // r8
  _DWORD *v8; // r7
  _DWORD *v9; // r0
  _DWORD *v10; // r5
  const char *v11; // r7
  char *v12; // r5
  unsigned int *v13; // r3
  unsigned int v14; // r2
  unsigned int v15; // r2
  char v16[252]; // [sp+Ch] [bp-28FCh] BYREF
  char s[2040]; // [sp+108h] [bp-2800h] BYREF
  char v18[8192]; // [sp+908h] [bp-2000h] BYREF

  ++dword_24400C;
  sprintf(v18, aIdDMethodMinin_5);
  v2 = strlen(v18);
  v3 = sub_4B10C((int)a1, v18, v2);
  if ( v3 )
  {
    while ( 1 )
    {
      v5 = sub_49090(a1[147], 2);
      if ( !v5 )
      {
        if ( byte_1AECC5 )
        {
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
          {
            v3 = (unsigned __int8)byte_1AECC5;
            strcpy(s, "Timed out waiting for response extranonce.subscribe");
            sub_47AB4(7, s, 0);
          }
          else
          {
            return (unsigned __int8)byte_1AECC5;
          }
        }
        return v3;
      }
      v4 = sub_4B4C0((int)a1);
      if ( !v4 )
        return 0;
      if ( !sub_4F748(a1, (int)v4) )
        break;
      free(v4);
    }
    v7 = sub_6D110((int)v4, 0, v16);
    free(v4);
    v8 = (_DWORD *)sub_6DFCC(v7, "result");
    v9 = (_DWORD *)sub_6DFCC(v7, "error");
    v10 = v9;
    if ( !v8 || *v8 == 6 )
    {
      if ( !v9 )
      {
        v12 = (char *)malloc(0x11u);
        if ( v12 )
          strcpy(v12, "(unknown reason)");
        goto LABEL_30;
      }
    }
    else if ( !v9 || *v9 == 7 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        v3 = v5;
        snprintf(s, 0x800u, "Stratum extranonce subscribe for pool %d", *a1);
        sub_47AB4(6, s, 0);
        goto LABEL_35;
      }
LABEL_26:
      v3 = v5;
LABEL_35:
      if ( v7 )
      {
        if ( *((_DWORD *)v7 + 1) != -1 )
        {
          v13 = (unsigned int *)v7 + 1;
          __dmb(0xBu);
          do
          {
            v14 = __ldrex(v13);
            v15 = v14 - 1;
          }
          while ( __strex(v15, v13) );
          if ( !v15 )
            sub_6E5DC((void **)v7);
        }
      }
      return v3;
    }
    v11 = (const char *)sub_49124(v9, 1u);
    if ( !v11 && (v11 = (const char *)sub_6E350(v10)) == 0
      || strcmp(v11, "Method 'subscribe' not found for service 'mining.extranonce'")
      && strcmp(v11, "Unrecognized request provided") )
    {
      v12 = (char *)sub_6B6E8(v10, 3);
LABEL_30:
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        snprintf(s, 0x800u, "Pool %d JSON extranonce subscribe failed: %s", *a1, v12);
        sub_47AB4(6, s, 0);
      }
      v3 = 0;
      free(v12);
      goto LABEL_35;
    }
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
    {
      v3 = v5;
      snprintf(s, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", *a1);
      sub_47AB4(6, s, 0);
      goto LABEL_35;
    }
    goto LABEL_26;
  }
  return v3;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 24400C: using guessed type int dword_24400C;
// 244080: using guessed type char byte_244080;

//----- (00050730) --------------------------------------------------------
int __fastcall sub_50730(_DWORD *a1)
{
  const char *v1; // r3
  int v3; // r2
  size_t v4; // r0
  int v5; // r9
  int v6; // r6
  char *v7; // r5
  double *v9; // r8
  _DWORD *v10; // r5
  _DWORD *v11; // r0
  char *v12; // r5
  unsigned int *v13; // r3
  unsigned int v14; // r2
  unsigned int v15; // r2
  int v16; // r3
  int v17; // r2
  size_t v18; // r0
  int v19; // r2
  size_t v20; // r0
  const char *v21; // [sp+0h] [bp-290Ch]
  char v22[252]; // [sp+Ch] [bp-2900h] BYREF
  char s[2040]; // [sp+108h] [bp-2804h] BYREF
  char v24[8196]; // [sp+908h] [bp-2004h] BYREF

  v1 = (const char *)a1[43];
  v3 = dword_24400C;
  v21 = (const char *)a1[44];
  ++dword_24400C;
  sprintf(v24, "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}", v3, v1, v21);
  v4 = strlen(v24);
  v5 = sub_4B10C((int)a1, v24, v4);
  if ( v5 )
  {
    while ( 1 )
    {
      v7 = sub_4B4C0((int)a1);
      if ( !v7 )
        return 0;
      v6 = sub_4F748();
      if ( !v6 )
        break;
      free(v7);
    }
    v9 = sub_6D110((int)v7, 0, v22);
    free(v7);
    v10 = (_DWORD *)sub_6DFCC(v9, "result");
    v11 = (_DWORD *)sub_6DFCC(v9, "error");
    if ( !v10 || *v10 == 6 )
    {
      if ( !v11 )
      {
        v12 = (char *)malloc(0x11u);
        if ( v12 )
          strcpy(v12, "(unknown reason)");
        goto LABEL_13;
      }
    }
    else if ( !v11 || *v11 == 7 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        snprintf(s, 0x800u, "Stratum authorisation success for pool %d", *a1);
        sub_47AB4(6, s, 0);
      }
      v16 = dword_243000;
      byte_1AECC6 = 1;
      *((_BYTE *)a1 + 99) = 1;
      if ( v16 )
      {
        v19 = dword_24400C++;
        sprintf(v24, "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}", v19, v16);
        v20 = strlen(v24);
        sub_4B10C((int)a1, v24, v20);
      }
      v6 = (unsigned __int8)byte_9EE64;
      if ( byte_9EE64 )
      {
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
        {
          strcpy(s, "LOW POWER MODE!");
          sub_47AB4(5, s, 0);
        }
        v17 = dword_24400C++;
        sprintf(
          v24,
          "{\"id\":%d, \"method\":\"mining.configure\", \"params\":[[\"version-rolling\"],{\"version-rolling.mask\":\"%08"
          "x\",\"version-rolling.min-bit-count\":%d}]}",
          v17,
          14680064,
          3);
        v18 = strlen(v24);
        sub_4B10C((int)a1, v24, v18);
        a1[162] = 1;
      }
      else
      {
        v6 = v5;
      }
      goto LABEL_17;
    }
    v12 = (char *)sub_6B6E8(v11, 3);
LABEL_13:
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
    {
      snprintf(s, 0x800u, "pool %d JSON stratum auth failed: %s", *a1, v12);
      sub_47AB4(6, s, 0);
    }
    free(v12);
    sub_4AFA8((int)a1);
LABEL_17:
    if ( v9 )
    {
      if ( *((_DWORD *)v9 + 1) != -1 )
      {
        v13 = (unsigned int *)v9 + 1;
        __dmb(0xBu);
        do
        {
          v14 = __ldrex(v13);
          v15 = v14 - 1;
        }
        while ( __strex(v15, v13) );
        if ( !v15 )
          sub_6E5DC((void **)v9);
      }
    }
    return v6;
  }
  return 0;
}
// 4F748: using guessed type int sub_4F748(void);
// 9E320: using guessed type int dword_9E320;
// 9EE64: using guessed type char byte_9EE64;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC6: using guessed type char byte_1AECC6;
// 243000: using guessed type int dword_243000;
// 24400C: using guessed type int dword_24400C;
// 244080: using guessed type char byte_244080;

//----- (00050AE0) --------------------------------------------------------
int __fastcall sub_50AE0(int *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // r12
  int v4; // r3

  if ( *a2 > *a3 )
    return -1;
  if ( *a2 == *a3 && a2[1] > a3[1] )
    return -1;
  v3 = *a3 - *a2;
  *a1 = v3;
  v4 = a3[1] - a2[1];
  a1[1] = v4;
  if ( v4 < 0 )
  {
    *a1 = v3 - 1;
    a1[1] = v4 + 1000000;
  }
  return 0;
}

//----- (00050B5C) --------------------------------------------------------
_BYTE *__fastcall sub_50B5C(_BYTE *result, int a2)
{
  _BYTE *v2; // r12
  unsigned int v3; // r3
  char v4; // lr
  char v5; // t1
  char v6; // t1

  if ( a2 != 1 )
  {
    v2 = result - 1;
    v3 = 0;
    result += a2;
    do
    {
      ++v3;
      v5 = *++v2;
      v4 = v5;
      v6 = *--result;
      *v2 = v6;
      *result = v4;
    }
    while ( v3 < ~v3 + a2 );
  }
  return result;
}

//----- (00050B9C) --------------------------------------------------------
int __fastcall sub_50B9C(int result, char a2)
{
  unsigned int v2; // r1
  unsigned int v3; // r1
  int v4; // r1
  unsigned int v5; // r1
  unsigned int v6; // r1

  switch ( result )
  {
    case 1:
      return result;
    case 2:
      if ( (a2 & 0x80) != 0x80 )
        result = 1;
      break;
    case 4:
      v4 = a2 & 0xC0;
      if ( v4 == 128 )
        goto LABEL_29;
      if ( v4 != 192 )
      {
        if ( v4 == 64 )
          result = 2;
        else
          result = 1;
      }
      break;
    case 8:
      v5 = a2 & 0xE0;
      if ( v5 == 128 )
        goto LABEL_50;
      if ( v5 <= 0x80 )
      {
        if ( v5 == 64 )
          goto LABEL_29;
        if ( v5 == 96 )
          goto LABEL_49;
        if ( v5 != 32 )
          goto LABEL_9;
        goto LABEL_25;
      }
      if ( v5 == 192 )
        goto LABEL_48;
      if ( v5 != 224 )
      {
        if ( v5 != 160 )
          goto LABEL_9;
        goto LABEL_39;
      }
      break;
    case 16:
      v2 = a2 & 0xF0;
      if ( v2 == 128 )
      {
        result = 9;
      }
      else if ( v2 > 0x80 )
      {
        if ( v2 == 192 )
        {
          result = 13;
        }
        else if ( v2 <= 0xC0 )
        {
          switch ( v2 )
          {
            case 0xA0u:
              result = 11;
              break;
            case 0xB0u:
              result = 12;
              break;
            case 0x90u:
              result = 10;
              break;
            default:
              goto LABEL_9;
          }
        }
        else if ( v2 == 224 )
        {
          result = 15;
        }
        else if ( v2 != 240 )
        {
          if ( v2 != 208 )
            goto LABEL_9;
          result = 14;
        }
      }
      else if ( v2 == 64 )
      {
LABEL_50:
        result = 5;
      }
      else if ( v2 > 0x40 )
      {
        switch ( v2 )
        {
          case '`':
LABEL_48:
            result = 7;
            break;
          case 'p':
            result = 8;
            break;
          case 'P':
LABEL_39:
            result = 6;
            break;
          default:
            goto LABEL_9;
        }
      }
      else
      {
        switch ( v2 )
        {
          case 0x20u:
LABEL_29:
            result = 3;
            break;
          case 0x30u:
LABEL_49:
            result = 4;
            break;
          case 0x10u:
LABEL_25:
            result = 2;
            break;
          default:
            goto LABEL_9;
        }
      }
      break;
    case 32:
      v6 = (unsigned __int8)((a2 & 0xF8) - 8);
      if ( v6 > 0xF0 )
        goto LABEL_9;
      result = *((char *)&unk_81958 + v6 + 2004);
      break;
    case 64:
      v3 = (unsigned __int8)((a2 & 0xFC) - 4);
      if ( v3 > 0xF8 )
LABEL_9:
        result = 1;
      else
        result = *((char *)&unk_81958 + v3 + 2248);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 50BA8: control flows out of bounds to 50BAC

//----- (00050E84) --------------------------------------------------------
void __fastcall sub_50E84(int a1, char *a2, int a3)
{
  int v5; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int *v13; // lr
  _DWORD *v14; // r12
  int v15; // r1
  int v16; // r2
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r1
  int v21; // r2
  int v22; // r3
  char v23; // r3
  char v24; // t1
  char v25; // t1
  char *v26; // r2
  _DWORD *v27; // r3
  char v28; // t1
  char v29; // r1
  _DWORD *v30; // r3
  char *v31; // r2
  char v32; // r1
  char v33; // t1
  char v34; // t1
  const char *v35; // r5
  char *v36; // r8
  char *v37; // r7
  char *v38; // r9
  char *v39; // r6
  unsigned __int64 v40; // r0
  size_t v41; // r0
  int v42; // r4
  size_t v43; // r0
  unsigned __int64 v44; // r2
  int i; // r4
  size_t v46; // r0
  size_t v47; // r0
  char *ptr; // [sp+20h] [bp-C7Ch]
  char *v50; // [sp+28h] [bp-C74h]
  __int64 v51; // [sp+2Ch] [bp-C70h]
  char *v52; // [sp+34h] [bp-C68h] BYREF
  _DWORD v53[3]; // [sp+38h] [bp-C64h] BYREF
  _DWORD v54[5]; // [sp+44h] [bp-C58h] BYREF
  int v55; // [sp+58h] [bp-C44h] BYREF
  _DWORD v56[2]; // [sp+5Ch] [bp-C40h] BYREF
  _DWORD v57[4]; // [sp+64h] [bp-C38h] BYREF
  int v58; // [sp+74h] [bp-C28h] BYREF
  _DWORD v59[3]; // [sp+78h] [bp-C24h] BYREF
  _DWORD v60[5]; // [sp+84h] [bp-C18h] BYREF
  char s[1024]; // [sp+98h] [bp-C04h] BYREF
  char v62[2052]; // [sp+498h] [bp-804h] BYREF

  memset(s, 0, sizeof(s));
  v5 = *(_DWORD *)(a1 + 128);
  memset(v57, 0, sizeof(v57));
  v6 = *(_DWORD *)(a1 + 132);
  v7 = *(_DWORD *)(a1 + 136);
  v8 = *(_DWORD *)(a1 + 140);
  v53[0] = v5;
  v53[1] = v6;
  v53[2] = v7;
  v54[0] = v8;
  v9 = *(_DWORD *)(a1 + 144);
  v10 = *(_DWORD *)(a1 + 148);
  v11 = *(_DWORD *)(a1 + 152);
  v12 = *(_DWORD *)(a1 + 156);
  v13 = &v55;
  v58 = 0;
  v54[1] = v9;
  v54[2] = v10;
  v54[3] = v11;
  v54[4] = v12;
  v14 = (char **)((char *)&v52 + 3);
  v15 = *(_DWORD *)(a1 + 68);
  v16 = *(_DWORD *)(a1 + 72);
  v55 = *(_DWORD *)(a1 + 64);
  v56[0] = v15;
  v56[1] = v16;
  v17 = *(_DWORD *)(a1 + 196);
  v18 = *(_DWORD *)(a1 + 200);
  v19 = *(_DWORD *)(a1 + 204);
  v59[0] = *(_DWORD *)(a1 + 192);
  v59[1] = v17;
  v59[2] = v18;
  v60[0] = v19;
  v20 = *(_DWORD *)(a1 + 212);
  v21 = *(_DWORD *)(a1 + 216);
  v22 = *(_DWORD *)(a1 + 220);
  v60[1] = *(_DWORD *)(a1 + 208);
  v60[2] = v20;
  v60[3] = v21;
  v60[4] = v22;
  do
  {
    v24 = *((_BYTE *)v14 + 1);
    v14 = (_DWORD *)((char *)v14 + 1);
    v23 = v24;
    v25 = *((_BYTE *)v13 - 1);
    v13 = (int *)((char *)v13 - 1);
    *(_BYTE *)v14 = v25;
    *(_BYTE *)v13 = v23;
  }
  while ( v14 != (_DWORD *)((char *)v54 + 3) );
  v26 = (char *)&v55;
  v27 = v57;
  do
  {
    v28 = *((_BYTE *)v27 - 1);
    v27 = (_DWORD *)((char *)v27 - 1);
    v29 = *v26;
    *v26++ = v28;
    *(_BYTE *)v27 = v29;
  }
  while ( (_DWORD *)((char *)v56 + 2) != v27 );
  v30 = (int *)((char *)&v58 + 3);
  v31 = s;
  do
  {
    v33 = *((_BYTE *)v30 + 1);
    v30 = (_DWORD *)((char *)v30 + 1);
    v32 = v33;
    v34 = *--v31;
    *(_BYTE *)v30 = v34;
    *v31 = v32;
  }
  while ( v30 != (_DWORD *)((char *)v60 + 3) );
  ptr = sub_4988C(a1, 128);
  v35 = "o";
  v36 = sub_4988C((int)v53, 32);
  v37 = sub_4988C((int)&v55, 12);
  v50 = sub_4988C((int)a2, 4);
  v38 = sub_4988C((int)a2, 5);
  v39 = sub_4988C((int)v59, 32);
  v40 = sub_532CC((__int64 *)a1);
  HIDWORD(v51) = HIDWORD(v40);
  if ( !a3 )
    v35 = "x";
  LODWORD(v51) = v40;
  sprintf(
    s,
    "%s %08x midstate %s data %s nonce %s hash %s diff %lld",
    v35,
    *(_DWORD *)(a1 + 340),
    v36,
    v37,
    v38,
    v39,
    v40);
  if ( !strcmp((const char *)dword_1AECD0, "screen") )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      snprintf(v62, 0x800u, s);
      sub_47AB4(3, v62, 0);
    }
  }
  else
  {
    v52 = &byte_244080;
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      snprintf(v62, 0x800u, s);
      sub_47AB4(3, v62, 0);
    }
    if ( dword_1B0D34 )
    {
      sprintf(
        s,
        "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
        v35,
        *(_DWORD *)(a1 + 340),
        ptr,
        v36,
        v37,
        v38,
        v39,
        v51);
      v41 = strlen(s);
      fwrite(s, v41, 1u, (FILE *)dword_1B0D34);
      fwrite(&word_8B454, 1u, 1u, (FILE *)dword_1B0D34);
      fflush((FILE *)dword_1B0D34);
      if ( a3 )
      {
        if ( dword_1B0B28 == 1 )
        {
          sprintf(s, "midstate %s data %s nonce %s hash %s", v36, v37, v50, v39);
          v47 = strlen(s);
          fwrite(s, v47, 1u, (FILE *)dword_1B0C30[0]);
          fwrite(&word_8B454, 1u, 1u, (FILE *)dword_1B0C30[0]);
          fflush((FILE *)dword_1B0C30[0]);
        }
        else if ( ((dword_1B0B28 - 32) & 0xFFFFFFDF) == 0 )
        {
          sprintf(s, "midstate %s data %s nonce %s hash %s", v36, v37, v50, v39);
          v42 = sub_50B9C(dword_1B0B28, *a2);
          v43 = strlen(s);
          fwrite(s, v43, 1u, (FILE *)dword_1B0C30[v42]);
          fwrite(&word_8B454, 1u, 1u, (FILE *)dword_1B0C30[v42]);
          fflush((FILE *)dword_1B0C30[v42]);
        }
        if ( byte_1B0B24 )
        {
          v44 = v51;
          for ( i = 0; i != 64; ++i )
          {
            v44 >>= 1;
            if ( !v44 )
              break;
          }
          if ( byte_1AECC5 && (*v52 || byte_1AECC4 || dword_9E320 > 6) )
          {
            snprintf(v62, 0x800u, "work diff %lld diffnum %d", v51, i);
            sub_47AB4(7, v62, 0);
          }
          sprintf(s, "midstate %s data %s nonce %s hash %s", v36, v37, v50, v39);
          v46 = strlen(s);
          fwrite(s, v46, 1u, *((FILE **)&unk_1B0B2C + i));
          fwrite(&word_8B454, 1u, 1u, *((FILE **)&unk_1B0B2C + i));
          fflush(*((FILE **)&unk_1B0B2C + i));
        }
      }
    }
  }
  if ( ptr )
    free(ptr);
  if ( v36 )
    free(v36);
  if ( v37 )
    free(v37);
  if ( v50 )
    free(v50);
  if ( v38 )
    free(v38);
  if ( v39 )
    free(v39);
}
// 8B454: using guessed type __int16 word_8B454;
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AECD0: using guessed type int dword_1AECD0;
// 1B0B24: using guessed type char byte_1B0B24;
// 1B0B28: using guessed type int dword_1B0B28;
// 1B0C30: using guessed type int dword_1B0C30[];
// 1B0D34: using guessed type int dword_1B0D34;
// 244080: using guessed type char byte_244080;

//----- (000514A4) --------------------------------------------------------
void __fastcall sub_514A4(int a1, char *a2, int a3)
{
  if ( dword_1AECD0 )
    sub_50E84(a1, a2, a3);
}
// 1AECD0: using guessed type int dword_1AECD0;

//----- (000514BC) --------------------------------------------------------
void __fastcall sub_514BC(int a1, int a2, int a3)
{
  int v3; // [sp+0h] [bp-10h] BYREF
  char v4; // [sp+4h] [bp-Ch]

  if ( dword_1AECD0 )
  {
    v3 = a2;
    v4 = 0;
    sub_50E84(a1, (char *)&v3, a3);
  }
}
// 1AECD0: using guessed type int dword_1AECD0;

//----- (000514F8) --------------------------------------------------------
int __fastcall sub_514F8(int a1, int a2)
{
  int v2; // r3
  int v3; // r1
  int v4; // r2
  int v5; // r12
  int v6; // t1
  char *v7; // r0

  if ( !a2 )
    return 0xFFFF;
  v2 = 255;
  v3 = a1 + (unsigned __int16)(a2 - 1);
  v4 = a1 - 1;
  v5 = 255;
  do
  {
    v6 = *(unsigned __int8 *)++v4;
    v7 = (char *)&unk_81958 + (v2 ^ v6);
    v2 = (unsigned __int8)v7[2500] ^ v5;
    v5 = (unsigned __int8)v7[2756];
  }
  while ( v3 != v4 );
  return v2 | (v5 << 8);
}

//----- (00051554) --------------------------------------------------------
int __fastcall sub_51554(_BYTE *a1, unsigned int a2)
{
  char v2; // r9
  unsigned __int8 v3; // r4
  int v4; // r6
  int v5; // r2
  int v6; // r8
  int v7; // r5
  int v8; // r7
  unsigned int v9; // lr
  unsigned int v10; // r3
  unsigned __int8 v11; // r3
  int v12; // r12
  int result; // r0

  if ( !a2 )
    return 31;
  v2 = 1;
  v3 = 0;
  v4 = 1;
  LOBYTE(v5) = 0;
  v6 = 1;
  v7 = 1;
  v8 = 1;
  v9 = 128;
  while ( 1 )
  {
    v5 = (unsigned __int8)(v5 + 1);
    ++v3;
    v10 = *a1 & v9;
    v9 >>= 1;
    if ( v10 )
      v11 = v2 ^ 1;
    else
      v11 = v2;
    if ( v5 == 8 )
    {
      ++a1;
      LOBYTE(v5) = 0;
      v9 = 128;
    }
    v12 = (unsigned __int8)(v11 ^ v7);
    v2 = v4;
    if ( v3 >= a2 )
      break;
    v4 = v6;
    v7 = v8;
    v6 = v12;
    v8 = v11;
  }
  if ( v4 )
    result = 16;
  else
    result = 0;
  if ( v6 )
    result |= 8u;
  if ( v11 != v7 )
    result |= 4u;
  if ( v8 )
    result |= 2u;
  if ( v11 )
    return result | 1;
  return result;
}

//----- (0005162C) --------------------------------------------------------
int __fastcall sub_5162C(int result, unsigned int *a2, unsigned int a3)
{
  unsigned int v3; // r2
  unsigned int *v4; // r2
  unsigned int v5; // t1

  v3 = a3 >> 2;
  if ( v3 )
  {
    v4 = &a2[v3];
    result -= 4;
    do
    {
      v5 = *a2++;
      *(_DWORD *)(result + 4) = bswap32(v5);
      result += 4;
    }
    while ( a2 != v4 );
  }
  return result;
}

//----- (00051658) --------------------------------------------------------
int __fastcall sub_51658(_DWORD *a1)
{
  *a1 = 4;
  return 0;
}

//----- (00051668) --------------------------------------------------------
int __fastcall sub_51668(_DWORD *a1)
{
  *a1 = 3;
  return 0;
}

//----- (00051678) --------------------------------------------------------
int __fastcall sub_51678(_DWORD *a1)
{
  *a1 = 1;
  return 0;
}

//----- (00051688) --------------------------------------------------------
int __fastcall sub_51688(_BYTE *a1)
{
  *a1 = 1;
  byte_1AECC4 = 1;
  return 0;
}
// 1AECC4: using guessed type char byte_1AECC4;

//----- (000516A4) --------------------------------------------------------
int sub_516A4()
{
  return 0;
}

//----- (000516B4) --------------------------------------------------------
int sub_516B4()
{
  return 1;
}

//----- (000516BC) --------------------------------------------------------
__int64 sub_516BC()
{
  return 0xFFFFFFFFLL;
}

//----- (000516C8) --------------------------------------------------------
int sub_516C8()
{
  return 1;
}

//----- (000516D4) --------------------------------------------------------
int sub_516D4()
{
  return 0;
}

//----- (000516DC) --------------------------------------------------------
int __fastcall sub_516DC(int result)
{
  *(_QWORD *)(result + 208) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_QWORD *)(result + 200) = 0;
  return result;
}

//----- (000516F8) --------------------------------------------------------
int __fastcall sub_516F8(int a1)
{
  sub_64370(a1, &dword_1AECC8);
  return 0;
}
// 1AECC8: using guessed type int dword_1AECC8;

//----- (00051710) --------------------------------------------------------
int __fastcall sub_51710(int a1)
{
  sub_64370(a1, &dword_1AECCC);
  return 0;
}
// 1AECCC: using guessed type _DWORD dword_1AECCC;

//----- (00051728) --------------------------------------------------------
int __fastcall sub_51728(int a1)
{
  sub_64370(a1, &dword_1AECD0);
  return 0;
}
// 1AECD0: using guessed type int dword_1AECD0;

//----- (00051740) --------------------------------------------------------
int __fastcall sub_51740(int a1)
{
  sub_64370(a1, &dword_1AECD4);
  return 0;
}
// 1AECD4: using guessed type int dword_1AECD4;

//----- (00051758) --------------------------------------------------------
int __fastcall sub_51758(int a1)
{
  sub_64370(a1, &dword_1AECD8);
  return 0;
}
// 1AECD8: using guessed type int dword_1AECD8;

//----- (00051770) --------------------------------------------------------
int __fastcall sub_51770(int a1)
{
  sub_64370(a1, &dword_242FF8);
  return 0;
}
// 242FF8: using guessed type int dword_242FF8;

//----- (0005199C) --------------------------------------------------------
_BYTE *__fastcall sub_5199C(const char *a1)
{
  const char *v1; // r4
  size_t v2; // r0
  _BYTE *v3; // r5
  _DWORD *v4; // r0
  int v5; // r2
  _BYTE *v6; // r2
  int i; // r3
  bool v8; // zf
  _BYTE *v9; // r3
  char v10; // t1

  v1 = a1;
  v2 = strlen(a1);
  v3 = sub_49624(2 * v2 + 1, "cgminer.c", "json_escape", 5915);
  v4 = sub_49624(8u, "cgminer.c", "json_escape", 5916);
  *v4 = v3;
  v5 = dword_1AECE0;
  dword_1AECE0 = (int)v4;
  v4[1] = v5;
  v6 = v3;
  for ( i = *(unsigned __int8 *)v1; *v1; i = *(unsigned __int8 *)v1 )
  {
    v8 = i == 34;
    if ( i != 34 )
      v8 = i == 92;
    v9 = v6 + 1;
    if ( v8 )
    {
      *v6 = 92;
      v6 += 2;
    }
    else
    {
      v9 = v6++;
    }
    v10 = *v1++;
    *v9 = v10;
  }
  *v6 = 0;
  return v3;
}
// 1AECE0: using guessed type int dword_1AECE0;

//----- (00051A54) --------------------------------------------------------
void __fastcall __noreturn sub_51A54(const char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", byte_1AECE4);
  v2 = sub_6530C((const char *)dword_2463E8, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 9F7D4: using guessed type int stdout;
// 2463E8: using guessed type int dword_2463E8;

//----- (00051AAC) --------------------------------------------------------
time_t __fastcall sub_51AAC(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 1;
  sub_4A60C((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (00051AE4) --------------------------------------------------------
time_t __fastcall sub_51AE4(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 0;
  sub_4A60C((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (00051B18) --------------------------------------------------------
int __fastcall sub_51B18(unsigned __int64 a1, char *s, size_t maxlen, int a4)
{
  double v6; // d8
  int v8; // r1
  double v9; // r0
  __int16 v10; // [sp+1Ch] [bp-4h] BYREF

  v10 = 0;
  if ( a1 <= 0xDE0B6B3A763FFFFLL )
  {
    if ( a1 <= 0x38D7EA4C67FFFLL )
    {
      if ( a1 > 0xE8D4A50FFFLL )
      {
        LODWORD(a1) = sub_77910(a1, 0x3B9ACA00u);
        v10 = 84;
        v6 = (double)(int)a1 / 1000.0;
        if ( !a4 )
          return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
      }
      else if ( a1 <= 0x3B9AC9FF )
      {
        if ( a1 > 0xF423F )
        {
          LODWORD(a1) = sub_77910(a1, 0x3E8u);
          v10 = 77;
          v6 = (double)(int)a1 / 1000.0;
          if ( !a4 )
            return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
        }
        else
        {
          v6 = (double)(int)a1;
          if ( a1 <= 0x3E7 )
          {
            if ( !a4 )
              return snprintf(s, maxlen, "%d%s", (_DWORD)a1, (const char *)&v10);
          }
          else
          {
            v10 = 75;
            v6 = v6 / 1000.0;
            if ( !a4 )
              return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
          }
        }
      }
      else
      {
        LODWORD(a1) = sub_77910(a1, (unsigned int)&unk_F4240);
        v10 = 71;
        v6 = (double)(int)a1 / 1000.0;
        if ( !a4 )
          return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
      }
    }
    else
    {
      LODWORD(a1) = sub_77910(a1, 0xE8D4A51000uLL);
      v10 = 80;
      v6 = (double)(int)a1 / 1000.0;
      if ( !a4 )
        return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
    }
  }
  else
  {
    LODWORD(a1) = sub_77910(a1, 0x38D7EA4C68000uLL);
    v10 = 69;
    v6 = (double)(int)a1 / 1000.0;
    if ( !a4 )
      return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
  }
  if ( v6 > 0.0 )
  {
    v9 = log10(*(double *)&a1);
    floor(v9);
    v8 = (int)(3.0 - v6);
  }
  else
  {
    v8 = 3;
  }
  return snprintf(s, maxlen, "%*.*f%s", a4 + 1, v8, v6, (const char *)&v10);
}
// 51CD4: variable 'a1' is possibly undefined

//----- (00051DD0) --------------------------------------------------------
int __fastcall sub_51DD0(int a1)
{
  int v2; // r1
  char *v3; // r2
  unsigned int v4; // t1
  char v6[28]; // [sp+0h] [bp-70h] BYREF
  char v7; // [sp+1Ch] [bp-54h] BYREF
  char v8[76]; // [sp+20h] [bp-50h] BYREF
  char v9; // [sp+6Ch] [bp-4h] BYREF

  v2 = a1 - 4;
  v3 = &v7;
  do
  {
    v4 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    *((_DWORD *)v3 + 1) = bswap32(v4);
    v3 += 4;
  }
  while ( v3 != &v9 );
  sub_4889C(v8, 0x50u, v6);
  return sub_4889C(v6, 0x20u, (_BYTE *)(a1 + 192));
}

//----- (00051E24) --------------------------------------------------------
int sub_51E24()
{
  pthread_t v0; // r0

  v0 = pthread_self();
  pthread_detach(v0);
  return 0;
}

//----- (00051E38) --------------------------------------------------------
void __noreturn sub_51E38()
{
  pthread_t v0; // r0

  v0 = pthread_self();
  pthread_detach(v0);
  pthread_setcanceltype(1, 0);
  sleep(7u);
  exit(1);
}

//----- (00051E60) --------------------------------------------------------
int __fastcall sub_51E60(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
  {
    snprintf(v3, 0x800u, "WTF No pool %d found!", a1);
    sub_47AB4(3, v3, 0);
  }
  return *(_DWORD *)(dword_244048 + 4 * a1);
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244048: using guessed type int dword_244048;
// 244080: using guessed type char byte_244080;

//----- (00051EEC) --------------------------------------------------------
int __fastcall sub_51EEC(int a1)
{
  int v1; // r2
  int v2; // r1
  int v3; // r3
  int v4; // t1

  if ( dword_242F4C <= 0 )
    return sub_51E60(a1);
  v1 = dword_244048;
  v2 = *(_DWORD *)dword_244048;
  if ( *(_DWORD *)(*(_DWORD *)dword_244048 + 4) != a1 )
  {
    v3 = 0;
    while ( ++v3 != dword_242F4C )
    {
      v4 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      v2 = v4;
      if ( *(_DWORD *)(v4 + 4) == a1 )
        return v2;
    }
    return sub_51E60(a1);
  }
  return v2;
}
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00051F54) --------------------------------------------------------
const char *__fastcall sub_51F54(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_242E70, &dword_242E6C) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_242E70 > 0x17 || (unsigned int)dword_242E6C > 0x3B )
    return "Invalid time set.";
  byte_242E64 = 1;
  return 0;
}
// 242E64: using guessed type char byte_242E64;
// 242E6C: using guessed type int dword_242E6C;
// 242E70: using guessed type int dword_242E70;

//----- (00051FC0) --------------------------------------------------------
char *__fastcall sub_51FC0(char *a1)
{
  bool v2; // nf
  double *v4; // r0
  size_t v5; // r6
  size_t v6; // r6
  char *v7; // r4
  char v8[92]; // [sp+Ch] [bp-100h] BYREF
  char v9[164]; // [sp+68h] [bp-A4h] BYREF

  if ( !dword_1AEDE4 )
    dword_1AEDE4 = (int)_strdup(a1);
  v2 = dword_1AEDE8 - 9 < 0;
  ++dword_1AEDE8;
  if ( !(v2 ^ __OFSUB__(dword_1AEDE8, 10) | (dword_1AEDE8 == 10)) )
    return "Too many levels of JSON includes (limit 10) or a loop";
  v4 = sub_6D374(a1, 0, v8);
  if ( v4 && !*(_DWORD *)v4 )
    return sub_520B4(v4, 1);
  v5 = strlen(a1);
  v6 = v5 + strlen(v9) + 35;
  v7 = (char *)sub_49624(v6, "cgminer.c", "load_config", 2119);
  snprintf(v7, v6, "JSON decode of file '%s' failed\n %s", a1, v9);
  return v7;
}
// 1AEDE4: using guessed type int dword_1AEDE4;
// 1AEDE8: using guessed type int dword_1AEDE8;

//----- (000520B4) --------------------------------------------------------
char *__fastcall sub_520B4(_DWORD *a1, int a2)
{
  _DWORD *v3; // r4
  int v4; // r3
  const char *v5; // r0
  char *v6; // r10
  char *v7; // r5
  _DWORD *v8; // r0
  int v9; // r1
  int v10; // r3
  const char *v11; // r3
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _BYTE *v15; // r0
  int v16; // r0
  _DWORD *v17; // r10
  unsigned int v18; // r5
  _DWORD *v19; // r0
  int v20; // r0
  _DWORD *v22; // [sp+10h] [bp-814h]
  char *v23; // [sp+10h] [bp-814h]
  const char *v24; // [sp+14h] [bp-810h]
  char *v25; // [sp+14h] [bp-810h]
  _DWORD *v26; // [sp+18h] [bp-80Ch]
  const char *v27; // [sp+1Ch] [bp-808h]
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a2 && !dword_1AEEB4 )
    dword_1AEEB4 = 1;
  if ( dword_9E54C == 16 )
    goto LABEL_28;
  if ( (dword_9E54C & 8) != 0 )
LABEL_53:
    _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x79Fu, "parse_config");
  v3 = &unk_9E564;
  while ( 1 )
  {
    v5 = (const char *)*(v3 - 7);
    if ( !v5 )
    {
      v4 = v3[1];
      if ( v4 == 16 )
        break;
      goto LABEL_8;
    }
    v6 = _strdup(v5);
    v7 = strtok(v6, "|");
    if ( !v7 )
      goto LABEL_27;
    while ( 2 )
    {
      if ( v7[1] != 45 )
        goto LABEL_12;
      v8 = (_DWORD *)sub_6DFCC(a1, v7 + 2);
      if ( !v8 )
        goto LABEL_12;
      v9 = *(v3 - 6);
      v10 = *v8;
      if ( (v9 & 6) == 0 )
      {
LABEL_18:
        if ( (unsigned int)(v10 - 5) > 1 )
        {
          v11 = "Invalid value";
          goto LABEL_21;
        }
        v15 = (_BYTE *)*(v3 - 2);
        if ( (v9 & 1) == 0 )
        {
          if ( v10 == 5 )
            sub_6428C(v15);
          else
            sub_6429C(v15);
          goto LABEL_12;
        }
        v11 = (const char *)((int (__fastcall *)(_BYTE *))*(v3 - 5))(v15);
        goto LABEL_33;
      }
      if ( v10 == 2 )
      {
        v22 = sub_6E350(v8);
        v16 = ((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v22, *(v3 - 2));
        v11 = (const char *)v16;
        if ( *(v3 - 6) == 4 )
        {
          v24 = (const char *)v16;
          sub_64370((int)v22, (_DWORD *)*(v3 - 2));
          v11 = v24;
        }
LABEL_33:
        if ( !v11 )
          goto LABEL_12;
        if ( a2 )
          goto LABEL_22;
LABEL_35:
        snprintf(::s, 0xC8u, "Parsing JSON option %s: %s", v7, v11);
        return ::s;
      }
      if ( v10 != 1 )
        goto LABEL_18;
      v23 = v6;
      v17 = v8;
      v25 = v7;
      v18 = 0;
      if ( !sub_6E1A8(v8) )
      {
LABEL_46:
        v6 = v23;
        goto LABEL_12;
      }
      while ( 1 )
      {
        v19 = sub_6E1C4(v17, v18);
        if ( !v19 )
          goto LABEL_46;
        if ( *v19 == 2 )
          break;
        if ( !*v19 )
        {
          v11 = (const char *)sub_520B4();
          goto LABEL_49;
        }
LABEL_45:
        if ( (unsigned int)sub_6E1A8(v17) <= ++v18 )
          goto LABEL_46;
      }
      v26 = sub_6E350(v19);
      v20 = ((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v26, *(v3 - 2));
      v11 = (const char *)v20;
      if ( *(v3 - 6) == 4 )
      {
        v27 = (const char *)v20;
        sub_64370((int)v26, (_DWORD *)*(v3 - 2));
        v11 = v27;
      }
LABEL_49:
      if ( !v11 )
        goto LABEL_45;
      v6 = v23;
      v7 = v25;
LABEL_21:
      if ( !a2 )
        goto LABEL_35;
LABEL_22:
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
      {
        snprintf(s, 0x800u, "Invalid config option %s: %s", v7, v11);
        sub_47AB4(3, s, 0);
      }
      dword_1AEEB4 = -1;
LABEL_12:
      v7 = strtok(0, "|");
      if ( v7 )
        continue;
      break;
    }
LABEL_27:
    free(v6);
    v4 = v3[1];
    if ( v4 == 16 )
      break;
LABEL_8:
    v3 += 7;
    if ( (v4 & 8) != 0 )
      goto LABEL_53;
  }
LABEL_28:
  v12 = (_DWORD *)sub_6DFCC(a1, "include");
  if ( !v12 || *v12 != 2 )
    return 0;
  v13 = sub_6E350(v12);
  return (char *)sub_51FC0(v13, 0);
}
// 51FC0: using guessed type int __fastcall sub_51FC0(_DWORD, _DWORD);
// 9E320: using guessed type int dword_9E320;
// 9E54C: using guessed type int dword_9E54C;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AEEB4: using guessed type int dword_1AEEB4;
// 244080: using guessed type char byte_244080;

//----- (0005243C) --------------------------------------------------------
char *__fastcall sub_5243C(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_6437C(a1, a2);
  if ( !result )
  {
    if ( *a2 < 100.0 )
    {
      return "Value out of range";
    }
    else if ( *a2 > 250.0 )
    {
      return "Value out of range";
    }
  }
  return result;
}

//----- (00052494) --------------------------------------------------------
char *__fastcall sub_52494(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_6437C(a1, a2);
  if ( !result )
  {
    if ( *a2 < 125.0 )
    {
      return "Value out of range";
    }
    else if ( *a2 > 500.0 )
    {
      return "Value out of range";
    }
  }
  return result;
}

//----- (000524EC) --------------------------------------------------------
int __fastcall sub_524EC(int a1, int a2, int (__fastcall **a3)(int))
{
  int v6; // r3
  char v8[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
  {
    snprintf(v8, 0x800u, "Thread %d being disabled", a2);
    sub_47AB4(4, v8, 0);
  }
  v6 = (unsigned __int8)byte_1AECC5;
  *(_QWORD *)(*(_DWORD *)(a1 + 36) + 48) = 0;
  if ( v6 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    strcpy(v8, "Waiting on sem in miner thread");
    sub_47AB4(7, v8, 0);
  }
  sub_4BE90((sem_t *)(a1 + 16), "cgminer.c", "mt_disable", 9147);
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
  {
    snprintf(v8, 0x800u, "Thread %d being re-enabled", a2);
    sub_47AB4(4, v8, 0);
  }
  return (*a3)(a1);
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (00052694) --------------------------------------------------------
char *__fastcall sub_52694(const char *a1)
{
  char *result; // r0

  dword_1AEEB8 = 2;
  result = sub_6448C(a1, &dword_242FE4);
  if ( !result && (unsigned int)dword_242FE4 > 0x270F )
    return "Value out of range";
  return result;
}
// 1AEEB8: using guessed type int dword_1AEEB8;
// 242FE4: using guessed type int dword_242FE4;

//----- (000526DC) --------------------------------------------------------
char *__fastcall sub_526DC(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && *a2 > 0x270Fu )
    return "Value out of range";
  return result;
}

//----- (0005270C) --------------------------------------------------------
char *__fastcall sub_5270C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && *a2 > 0x64u )
    return "Value out of range";
  return result;
}

//----- (00052738) --------------------------------------------------------
char *__fastcall sub_52738(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 0xFFFE )
    return "Value out of range";
  return result;
}

//----- (0005276C) --------------------------------------------------------
char *__fastcall sub_5276C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && (unsigned int)(*a2 - 42) > 0x14 )
    return "Value out of range";
  return result;
}

//----- (0005279C) --------------------------------------------------------
char *__fastcall sub_5279C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && (unsigned int)(*a2 - 22) > 0x21 )
    return "Value out of range";
  return result;
}

//----- (000527CC) --------------------------------------------------------
char *__fastcall sub_527CC(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && (unsigned int)(*a2 - 42) > 0x2B )
    return "Value out of range";
  return result;
}

//----- (000527FC) --------------------------------------------------------
char *__fastcall sub_527FC(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && (unsigned int)(*a2 - 22) > 0x35 )
    return "Value out of range";
  return result;
}

//----- (0005282C) --------------------------------------------------------
char *__fastcall sub_5282C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && (unsigned int)(*a2 - 32) > 0x1F )
    return "Value out of range";
  return result;
}

//----- (0005285C) --------------------------------------------------------
char *__fastcall sub_5285C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && *a2 > 4u )
    return "Value out of range";
  return result;
}

//----- (00052888) --------------------------------------------------------
char *__fastcall sub_52888(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && *a2 > 0xC8u )
    return "Value out of range";
  return result;
}

//----- (000528B4) --------------------------------------------------------
char *__fastcall sub_528B4(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && *a2 > 0x1E00u )
    return "Value out of range";
  return result;
}

//----- (000528E0) --------------------------------------------------------
char *__fastcall sub_528E0(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 0xFE )
    return "Value out of range";
  return result;
}

//----- (00052910) --------------------------------------------------------
char *__fastcall sub_52910(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && *a2 > 0xFFu )
    return "Value out of range";
  return result;
}

//----- (0005293C) --------------------------------------------------------
char *__fastcall sub_5293C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 9 )
    return "Value out of range";
  return result;
}

//----- (0005296C) --------------------------------------------------------
char *__fastcall sub_5296C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_6448C(a1, a2);
  if ( !result && *a2 > 0xAu )
    return "Value out of range";
  return result;
}

//----- (00052998) --------------------------------------------------------
void __fastcall sub_52998(const char *a1, const char *a2, int a3)
{
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  snprintf(s, 0x800u, "Free work called with NULL work from %s %s:%d", a1, a2, a3);
  sub_47AB4(3, s, 0);
}

//----- (000529E0) --------------------------------------------------------
double __fastcall sub_529E0(double a1)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double *v4; // r4
  double result; // r0

  v4 = (double *)LODWORD(a1);
  result = exp(a1);
  *v4 = (*v4 + v1 / v2 * (1.0 - 1.0 / (v2 / v3))) / (1.0 - 1.0 / (v2 / v3) + 1.0);
  return result;
}
// 52A00: variable 'v1' is possibly undefined
// 52A00: variable 'v2' is possibly undefined
// 529F0: variable 'v3' is possibly undefined

//----- (00052A30) --------------------------------------------------------
int sub_52A30()
{
  return 1;
}

//----- (00052A38) --------------------------------------------------------
int sub_52A38()
{
  return 1;
}

//----- (00052A4C) --------------------------------------------------------
const char *__fastcall sub_52A4C(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_242F28, &dword_242F24) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_242F28 > 0x17 || (unsigned int)dword_242F24 > 0x3B )
    return "Invalid time set.";
  byte_242F1C = 1;
  return 0;
}
// 242F1C: using guessed type char byte_242F1C;
// 242F24: using guessed type int dword_242F24;
// 242F28: using guessed type int dword_242F28;

//----- (00052AB8) --------------------------------------------------------
int __fastcall sub_52AB8(char *a1, size_t a2, time_t *a3)
{
  time_t v3; // r3
  int v6; // r4
  struct tm *v7; // r0
  time_t v9; // [sp+1Ch] [bp-8h] BYREF

  v3 = a3[1];
  v9 = *a3;
  v6 = v3 / 1000;
  v7 = localtime(&v9);
  return snprintf(
           a1,
           a2,
           "[%d-%02d-%02d %02d:%02d:%02d.%03d]",
           v7->tm_year + 1900,
           v7->tm_mon + 1,
           v7->tm_mday,
           v7->tm_hour,
           v7->tm_min,
           v7->tm_sec,
           v6);
}

//----- (00052B50) --------------------------------------------------------
void __noreturn sub_52B50(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  vsnprintf(byte_1AEEBC, 0x200u, a1, varg_r1);
  sub_47AB4(3, byte_1AEEBC, 1);
  exit(1);
}

//----- (00052B98) --------------------------------------------------------
void sub_52B98()
{
  unsigned int v0; // r4
  int *v1; // r7
  int *v2; // r5
  int v3; // t1
  unsigned int v4; // r3
  bool v5; // cf
  int *v6; // r8
  int v7; // t1
  unsigned int v8; // r6
  int v9; // r1
  int v10; // r1
  int v11; // r8
  _DWORD *v12; // t1
  char v13[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_242F4C <= 0 )
  {
    v0 = 1;
  }
  else
  {
    v0 = -1;
    v1 = (int *)dword_244048;
    v2 = (int *)dword_244048;
    do
    {
      v3 = *v2++;
      v4 = *(_DWORD *)(v3 + 56);
      v5 = 1;
      if ( v4 )
        v5 = v4 >= v0;
      if ( !v5 )
        v0 = v4;
    }
    while ( (int *)(dword_244048 + 4 * dword_242F4C) != v2 );
    if ( v0 == -1 )
    {
      v0 = 1;
    }
    else
    {
      v6 = (int *)dword_244048;
      do
      {
        v7 = *v6++;
        v8 = *(_DWORD *)(v7 + 56);
        if ( v8 )
        {
          sub_772CC(v8, v0);
          if ( v9 )
          {
            do
              sub_772CC(v8, --v0);
            while ( v10 );
          }
        }
      }
      while ( v2 != v6 );
    }
    v11 = dword_9ED60;
    do
    {
      v12 = (_DWORD *)*v1++;
      v12[16] = v12[16] * v11 / v0;
      v12[15] = v12[14] / v0;
    }
    while ( v2 != v1 );
  }
  dword_9ED60 = v0;
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(v13, 0x800u, "Global quota greatest common denominator set to %lu", v0);
    sub_47AB4(7, v13, 0);
  }
}
// 52C18: variable 'v9' is possibly undefined
// 52C30: variable 'v10' is possibly undefined
// 9E320: using guessed type int dword_9E320;
// 9ED60: using guessed type int dword_9ED60;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;
// 244080: using guessed type char byte_244080;

//----- (00052D1C) --------------------------------------------------------
char *__fastcall sub_52D1C(const char *a1, _DWORD *a2, int a3, int a4)
{
  char *result; // r0
  _BOOL4 v8; // r4
  int v9; // r3

  result = sub_6448C(a1, a2);
  if ( !result )
  {
    v8 = *a2 < a3;
    if ( *a2 > a4 )
      v9 = v8 | 1;
    else
      v9 = v8;
    if ( v9 )
      return "Value out of range";
  }
  return result;
}

//----- (00052D68) --------------------------------------------------------
int __fastcall sub_52D68(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0

  result = sscanf(a1, "%d-%d", a2, a3);
  if ( result == 1 )
    *a3 = *a2;
  return result;
}

//----- (00052D98) --------------------------------------------------------
int __fastcall sub_52D98(int a1, const char *a2)
{
  int v4; // r6
  char *v5; // r0
  int v6; // r3

  v4 = sub_4A940(a2, (_DWORD *)(a1 + 600), (char **)(a1 + 584));
  if ( v4 )
  {
    if ( !strncasecmp(a2, "stratum+tcp://", 0xEu) )
    {
      v5 = _strdup(a2);
      v6 = *(_DWORD *)(a1 + 600);
      *(_DWORD *)(a1 + 164) = v5;
      *(_BYTE *)(a1 + 640) = 1;
      *(_DWORD *)(a1 + 576) = v6;
      return v4;
    }
    return 0;
  }
  return v4;
}

//----- (00052E08) --------------------------------------------------------
int __fastcall sub_52E08(int a1, char *s1)
{
  char *v3; // r5
  char *v5; // r6

  v3 = sub_4AAB4(s1, a1);
  if ( !sub_52D98(a1, v3) )
  {
    sub_64370((int)v3, (_DWORD *)(a1 + 164));
    if ( strncmp(v3, "http://", 7u) )
    {
      if ( strncmp(v3, "https://", 8u) )
      {
        v5 = (char *)sub_49624(0x100u, "cgminer.c", "setup_url", 1037);
        strcpy(v5, "stratum+tcp://");
        strncat(v5, v3, 0xF2u);
        sub_52D98(a1, v5);
      }
    }
  }
  return *(_DWORD *)(a1 + 164);
}

//----- (00052EE8) --------------------------------------------------------
const char *__fastcall sub_52EE8(const char *a1)
{
  if ( !a1 || !*a1 )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol(a1, 0, 10) > 0xC8 )
    return "Invalid value passed to set temp cutoff";
  return 0;
}

//----- (00052F30) --------------------------------------------------------
void *__fastcall sub_52F30(void **a1)
{
  free(a1[72]);
  free(a1[77]);
  free(a1[82]);
  free(a1[80]);
  return memset(a1, 0, 0x1C0u);
}

//----- (00052F6C) --------------------------------------------------------
char *__fastcall sub_52F6C(int a1, int a2, int a3)
{
  int v6; // r7
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  char *result; // r0
  unsigned int v11[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = *(_DWORD *)(a1 + 340);
  sub_52F30((void **)a1);
  sub_4C150((void *)a1, (const void *)a2, 0x1C0u, (int)"cgminer.c", (int)"_copy_work", 4946);
  *(_DWORD *)(a1 + 340) = v6;
  v7 = *(const char **)(a2 + 288);
  if ( v7 )
    *(_DWORD *)(a1 + 288) = _strdup(v7);
  v8 = *(const char **)(a2 + 320);
  if ( v8 )
    *(_DWORD *)(a1 + 320) = _strdup(v8);
  v9 = *(const char **)(a2 + 308);
  if ( v9 )
  {
    if ( a3 )
    {
      *(_DWORD *)(a1 + 68) = bswap32(a3 + bswap32(*(_DWORD *)(a1 + 68)));
      sub_49940(v11, *(unsigned __int8 **)(a2 + 308), 4);
      v11[0] = bswap32(a3 + bswap32(v11[0]));
      *(_DWORD *)(a1 + 308) = sub_4988C((int)v11, 4);
    }
    else
    {
      *(_DWORD *)(a1 + 308) = _strdup(v9);
    }
  }
  else if ( a3 )
  {
    *(_DWORD *)(a1 + 68) = bswap32(a3 + bswap32(*(_DWORD *)(a1 + 68)));
  }
  result = *(char **)(a2 + 328);
  if ( result )
  {
    result = _strdup(result);
    *(_DWORD *)(a1 + 328) = result;
  }
  *(_DWORD *)(a1 + 444) = *(_DWORD *)(a2 + 444);
  return result;
}

//----- (00053084) --------------------------------------------------------
void __fastcall sub_53084(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v4; // r5

  v4 = *a1;
  if ( *a1 )
  {
    sub_52F30(*a1);
    free(v4);
    *a1 = 0;
  }
  else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
  {
    sub_52998(a2, a3, a4);
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00053118) --------------------------------------------------------
void __fastcall sub_53118(int a1)
{
  struct timeval v1; // [sp-10h] [bp-10h] BYREF

  if ( *(_DWORD *)(a1 + 368) )
  {
    sub_4A60C(&v1);
    sub_4A8FC();
  }
}
// 9ED68: using guessed type double dbl_9ED68;

//----- (0005317C) --------------------------------------------------------
void sub_5317C()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_4A60C(&v0);
  sub_4A8FC();
}

//----- (000531A4) --------------------------------------------------------
void sub_531A4()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_4A60C(&v0);
  sub_4A8FC();
}

//----- (000531CC) --------------------------------------------------------
void __fastcall sub_531CC(int a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r4
  int v4; // r3
  char v5[1016]; // [sp+8h] [bp-C00h] BYREF
  char v6[2048]; // [sp+408h] [bp-800h] BYREF

  v2 = 4;
  v3 = 0;
  do
  {
    v4 = (unsigned __int8)a2;
    --v2;
    a2 >>= 8;
    v3 = v4 + (v3 << 8);
  }
  while ( v2 );
  sub_4981C(v5, a1, 128);
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
  {
    snprintf(v6, 0x800u, "BENCHFILE nonce %u=0x%08x for work=%s", v3, v3, v5);
    sub_47AB4(3, v6, 0);
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00053294) --------------------------------------------------------
_BYTE *__fastcall sub_53294(_BYTE *result, unsigned int a2)
{
  void *v2; // r3
  _BYTE *v3; // r4

  v2 = (void *)*((_DWORD *)result + 77);
  *((_DWORD *)result + 17) = bswap32(a2);
  if ( v2 )
  {
    v3 = result;
    free(v2);
    result = sub_4988C((int)(v3 + 68), 4);
    *((_DWORD *)v3 + 77) = result;
  }
  return result;
}

//----- (000532CC) --------------------------------------------------------
unsigned __int64 __fastcall sub_532CC(__int64 *a1)
{
  double v2; // r0
  double v3; // d8
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d6
  double v8; // r0
  double v9; // d8

  if ( !a1 )
    return 0;
  LODWORD(v2) = sub_778A4(a1[27]);
  v3 = v2 * 6.27710174e57;
  LODWORD(v4) = sub_778A4(a1[26]);
  v5 = v3 + v4 * 3.40282367e38;
  LODWORD(v6) = sub_778A4(a1[25]);
  v7 = v6;
  LODWORD(v8) = sub_778A4(a1[24]);
  v9 = v8 + v5 + v7 * 1.84467441e19;
  if ( v9 == 0.0 )
    return 0;
  else
    return (unsigned __int64)(2.69595353e67 / v9);
}
// 532F0: variable 'v2' is possibly undefined
// 53304: variable 'v4' is possibly undefined
// 53310: variable 'v6' is possibly undefined
// 53324: variable 'v8' is possibly undefined

//----- (00053380) --------------------------------------------------------
void __fastcall sub_53380(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v5; // r1
  _DWORD *v9; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v5 = *a1;
  if ( *a1 )
  {
    if ( *((_BYTE *)v5 + 273) || v5[60] || *((_BYTE *)v5 + 272) )
    {
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        strcpy(s, "Discarded cloned or rolled work");
        sub_47AB4(7, s, 0);
      }
    }
    else
    {
      v9 = v5[65];
      if ( v9 )
      {
        ++v9[31];
        --*((_DWORD *)v5[65] + 16);
        --*((_DWORD *)v5[65] + 17);
      }
      ++qword_242F00;
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        strcpy(s, "Discarded work");
        sub_47AB4(7, s, 0);
      }
    }
    sub_53084(a1, a2, a3, a4);
  }
  else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
  {
    snprintf(s, 0x800u, "Discard work called with NULL work from %s %s:%d", a2, a3, a4);
    sub_47AB4(3, s, 0);
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 242F00: using guessed type __int64 qword_242F00;
// 244080: using guessed type char byte_244080;

//----- (000535B8) --------------------------------------------------------
int __fastcall sub_535B8(int result)
{
  int v1; // r5
  int v2; // r6
  int *v3; // r2
  int v4; // r4
  int v5; // r1
  int v6; // t1
  int v7; // r3
  bool v8; // cc
  int v9; // r3
  int v10; // r3

  v1 = dword_242F4C;
  v2 = dword_242F4C - 1;
  if ( dword_242F4C > 0 )
  {
    v3 = (int *)dword_244048;
    v4 = dword_244048 + 4 * dword_242F4C;
    do
    {
      v6 = *v3++;
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v8 = v7 <= *(_DWORD *)(result + 4);
      v9 = v7 - 1;
      if ( !v8 )
        *(_DWORD *)(v5 + 4) = v9;
    }
    while ( v3 != (int *)v4 );
  }
  if ( *(_DWORD *)result < v2 )
  {
    **(_DWORD **)(dword_244048 + 4 * v2) = *(_DWORD *)result;
    *(_DWORD *)(dword_244048 + 4 * *(_DWORD *)result) = *(_DWORD *)(dword_244048 + 4 * v2);
    v1 = dword_242F4C;
  }
  *(_DWORD *)result = v1;
  v10 = dword_242F4C;
  *(_BYTE *)(result + 105) = 1;
  dword_242F4C = v10 - 1;
  return result;
}
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00053654) --------------------------------------------------------
void __fastcall sub_53654(FILE *s)
{
  int v2; // r6
  const char *v3; // r11
  char *v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  char *v7; // r2
  int v8; // r3
  const char *v9; // r10
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  int v13; // r0
  int v14; // r4
  const char *v15; // r10
  char *v16; // r0
  const char *v17; // r0
  const char *v18; // r11
  char *v19; // r3
  const char *v20; // r0
  const char *v21; // r0
  const char **v22; // r4
  char *v23; // r8
  char *v24; // r11
  char *(__fastcall *v25)(const char *, _DWORD *); // r2
  bool v26; // zf
  int v27; // r3
  int v28; // r1
  int (__fastcall *v29)(_BYTE *); // r2
  bool v30; // zf
  const char **v31; // r3
  const char *v32; // r0
  int v33; // r1
  int v34; // r4
  int v35; // r5
  bool v36; // zf
  int v37; // [sp+14h] [bp-10h]
  const char *v38; // [sp+14h] [bp-10h]
  const char *v39; // [sp+18h] [bp-Ch]
  const char *v40; // [sp+18h] [bp-Ch]
  const char *v41; // [sp+1Ch] [bp-8h]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, s);
  if ( dword_242F4C > 0 )
  {
    v2 = 0;
    do
    {
      v13 = sub_51EEC(v2);
      v8 = *(_DWORD *)(v13 + 56);
      v14 = v13;
      if ( v8 == 1 )
      {
        if ( v2 )
          v15 = ",";
        else
          v15 = "";
        if ( *(_DWORD *)(v13 + 184) )
        {
          v16 = sub_497D0(*(char **)(v13 + 180));
          v40 = sub_5199C(v16);
          v17 = *(const char **)(v14 + 184);
          if ( v17 )
          {
            v20 = sub_5199C(v17);
            v19 = "|";
            v18 = v20;
            if ( !*(_DWORD *)(v14 + 184) )
              v19 = "";
          }
          else
          {
            v18 = "";
            v19 = "";
          }
        }
        else
        {
          v18 = "";
          v40 = "";
          v19 = "";
        }
        v38 = v19;
        v21 = sub_5199C(*(const char **)(v14 + 164));
        fprintf(s, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v15, v40, v18, v38, v21);
        if ( !*(_BYTE *)(v14 + 580) )
          goto LABEL_11;
      }
      else
      {
        if ( v2 )
          v3 = ",";
        else
          v3 = "";
        if ( *(_DWORD *)(v13 + 184) )
        {
          v4 = sub_497D0(*(char **)(v13 + 180));
          v41 = sub_5199C(v4);
          v5 = *(const char **)(v14 + 184);
          if ( v5 )
          {
            v6 = sub_5199C(v5);
            v7 = "|";
            v8 = *(_DWORD *)(v14 + 56);
            v9 = v6;
            if ( !*(_DWORD *)(v14 + 184) )
              v7 = "";
          }
          else
          {
            v8 = *(_DWORD *)(v14 + 56);
            v9 = "";
            v7 = "";
          }
        }
        else
        {
          v9 = "";
          v41 = "";
          v7 = "";
        }
        v39 = v7;
        v37 = v8;
        v10 = sub_5199C(*(const char **)(v14 + 164));
        fprintf(s, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v3, v41, v9, v39, v37, v10);
        if ( !*(_BYTE *)(v14 + 580) )
          goto LABEL_11;
      }
      fwrite("\n\t\t\"extranonce-subscribe\" : true,", 1u, 0x21u, s);
LABEL_11:
      ++v2;
      v11 = sub_5199C(*(const char **)(v14 + 172));
      fprintf(s, "\n\t\t\"user\" : \"%s\",", v11);
      v12 = sub_5199C(*(const char **)(v14 + 176));
      fprintf(s, "\n\t\t\"pass\" : \"%s\"\n\t}", v12);
    }
    while ( dword_242F4C > v2 );
  }
  fwrite("\n]\n", 1u, 3u, s);
  if ( dword_9E54C != 16 )
  {
    v22 = (const char **)&unk_9E564;
    while ( 1 )
    {
      v23 = _strdup(*(v22 - 7));
      v24 = strtok(v23, "|");
      if ( v24 )
        break;
LABEL_77:
      v22 += 7;
      free(v23);
      if ( *(v22 - 6) == (const char *)16 )
        goto LABEL_78;
    }
    while ( 1 )
    {
      if ( v24[1] == 45 && *(v22 - 1) != (const char *)&unk_2463F0 )
      {
        v28 = (int)*(v22 - 6);
        if ( (v28 & 1) == 0 )
          goto LABEL_72;
        v29 = (int (__fastcall *)(_BYTE *))*(v22 - 5);
        v30 = v29 == sub_6428C;
        if ( v29 != sub_6428C )
          v30 = v29 == sub_642AC;
        if ( v30 && **(v22 - 2) == (v29 == sub_6428C) )
        {
          fprintf(s, ",\n\"%s\" : true", v24 + 2);
        }
        else
        {
LABEL_72:
          if ( (v28 & 2) == 0 )
            goto LABEL_73;
          v25 = (char *(__fastcall *)(const char *, _DWORD *))*(v22 - 4);
          v26 = v25 == sub_526DC;
          if ( v25 != sub_526DC )
            v26 = v25 == sub_6448C;
          v27 = v26;
          if ( v25 == sub_52738 )
            v27 |= 1u;
          if ( v25 == sub_5296C )
            v27 |= 1u;
          if ( v25 == sub_5293C )
            v27 |= 1u;
          if ( v25 == sub_5270C )
            v27 |= 1u;
          if ( v25 == sub_52910 )
            v27 |= 1u;
          if ( v25 == sub_528E0 )
            v27 |= 1u;
          if ( v25 == sub_528B4 )
            v27 |= 1u;
          if ( v25 == sub_52888 )
            v27 |= 1u;
          if ( v25 == sub_5285C )
            v27 |= 1u;
          if ( v25 == sub_5282C )
            v27 |= 1u;
          if ( v25 == sub_527FC )
            v27 |= 1u;
          if ( v25 == sub_527CC )
            v27 |= 1u;
          if ( v25 == sub_5279C )
            v27 |= 1u;
          if ( v25 == sub_5276C )
            v27 |= 1u;
          if ( v27 )
          {
            fprintf(s, ",\n\"%s\" : \"%d\"", v24 + 2, *(_DWORD *)*(v22 - 2));
          }
          else
          {
            v36 = (char *)v25 == (char *)sub_52494;
            if ( (char *)v25 != (char *)sub_52494 )
              v36 = (char *)v25 == (char *)sub_5243C;
            if ( !v36 )
            {
LABEL_73:
              if ( (v28 & 6) != 0 )
              {
                v31 = (const char **)*(v22 - 2);
                if ( v31 != (const char **)&unk_1AF0CC )
                {
                  if ( *v31 )
                  {
                    v32 = sub_5199C(*v31);
                    fprintf(s, ",\n\"%s\" : \"%s\"", v24 + 2, v32);
                  }
                }
              }
              goto LABEL_63;
            }
            fprintf(s, ",\n\"%s\" : \"%.1f\"", v24 + 2, *(float *)*(v22 - 2));
          }
        }
      }
LABEL_63:
      v24 = strtok(0, "|");
      if ( !v24 )
        goto LABEL_77;
    }
  }
LABEL_78:
  v33 = dword_1AEEB8;
  if ( dword_1AEEB8 == 4 )
  {
    fwrite(",\n\"balance\" : true", 1u, 0x12u, s);
    v33 = dword_1AEEB8;
  }
  if ( v33 == 3 )
  {
    fwrite(",\n\"load-balance\" : true", 1u, 0x17u, s);
    v33 = dword_1AEEB8;
  }
  if ( v33 == 1 )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, s);
    v33 = dword_1AEEB8;
  }
  if ( v33 == 2 )
    fprintf(s, ",\n\"rotate\" : \"%d\"", dword_242FE4);
  fwrite("\n}\n", 1u, 3u, s);
  v34 = dword_1AECE0;
  dword_1AECE0 = 0;
  if ( v34 )
  {
    do
    {
      v35 = *(_DWORD *)(v34 + 4);
      free(*(void **)v34);
      free((void *)v34);
      v34 = v35;
    }
    while ( v35 );
  }
}
// 9E54C: using guessed type int dword_9E54C;
// 1AECE0: using guessed type int dword_1AECE0;
// 1AEEB8: using guessed type int dword_1AEEB8;
// 242F4C: using guessed type int dword_242F4C;
// 242FE4: using guessed type int dword_242FE4;

//----- (00053C3C) --------------------------------------------------------
int sub_53C3C()
{
  int result; // r0
  int *v1; // r2
  int v2; // r12
  int v3; // t1

  *(_DWORD *)dword_9ED70 = 0;
  dword_9ED74 = 0;
  dword_1AF0D0 = 0;
  dword_1AF0D4 = 0;
  result = sub_51B18(0, dword_9ED70, 8u, 0);
  if ( dword_242F4C > 0 )
  {
    result = 0;
    v1 = (int *)dword_244048;
    v2 = dword_244048 + 4 * dword_242F4C;
    do
    {
      v3 = *v1++;
      *(_DWORD *)(v3 + 368) = 0;
      *(_DWORD *)(v3 + 372) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  return result;
}
// 9ED74: using guessed type int dword_9ED74;
// 1AF0D0: using guessed type int dword_1AF0D0;
// 1AF0D4: using guessed type int dword_1AF0D4;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00053CD4) --------------------------------------------------------
char *__fastcall sub_53CD4(char *a1)
{
  size_t v2; // r0
  char *v3; // r12
  size_t v4; // lr
  char *v6; // r0

  if ( dword_242FF8 && *(_BYTE *)dword_242FF8 )
    return strcpy(a1, (const char *)dword_242FF8);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    v6 = getenv("HOME");
    strcpy((char *)stpcpy(a1, v6), "/");
  }
  else
  {
    *a1 = 0;
  }
  strcat(a1, ".bmminer/");
  mkdir(a1, 0x1FFu);
  v2 = strlen(a1);
  v3 = &a1[v2];
  v4 = v2;
  *(_DWORD *)&a1[v4] = *(_DWORD *)"bmminer.conf";
  strcpy(v3 + 4, "ner.conf");
  return *(char **)"bmminer.conf";
}
// 12064: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 242FF8: using guessed type int dword_242FF8;

//----- (00053DD0) --------------------------------------------------------
void sub_53DD0()
{
  dword_1AEDE4 = (int)sub_49624(0x1000u, "cgminer.c", "load_default_config", 2144);
  sub_53CD4((char *)dword_1AEDE4);
  if ( access((const char *)dword_1AEDE4, 4) )
  {
    free((void *)dword_1AEDE4);
    dword_1AEDE4 = 0;
  }
  else
  {
    sub_51FC0((char *)dword_1AEDE4);
  }
}
// 1AEDE4: using guessed type int dword_1AEDE4;

//----- (00053E30) --------------------------------------------------------
void __fastcall sub_53E30(void *a1)
{
  double v1; // d0
  __int64 v3; // r6
  double v4; // r0
  double v5; // d8
  __int64 v6; // kr00_8
  double v7; // r0
  double v8; // d8
  __int64 v9; // kr08_8
  double v10; // r0
  unsigned __int64 v11; // r0
  char *v12; // r6
  _QWORD v13[4]; // [sp+8h] [bp-824h] BYREF
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  if ( v1 == 0.0 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      v3 = 4294901760LL;
      strcpy(s, "Diff zero passed to set_target");
      sub_47AB4(3, s, 0);
      v11 = 0;
      v6 = 0;
      v9 = 0;
    }
    else
    {
      v11 = 0;
      v3 = 4294901760LL;
      v6 = 0;
      v9 = 0;
    }
  }
  else
  {
    v3 = (unsigned __int64)(2.69595353e67 / v1 * 1.59309191e-58);
    LODWORD(v4) = sub_778A4(v3);
    v5 = 2.69595353e67 / v1 - v4 * 6.27710174e57;
    v6 = (unsigned __int64)(v5 * 2.93873588e-39);
    LODWORD(v7) = sub_778A4(v6);
    v8 = v5 - v7 * 3.40282367e38;
    v9 = (unsigned __int64)(v8 * 5.42101086e-20);
    LODWORD(v10) = sub_778A4(v9);
    v11 = (unsigned __int64)(v8 - v10 * 1.84467441e19);
  }
  v13[3] = v3;
  v13[2] = v6;
  v13[1] = v9;
  v13[0] = v11;
  if ( byte_1AECC5 )
  {
    v12 = sub_4988C((int)v13, 32);
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf(s, 0x800u, "Generated target %s", v12);
      sub_47AB4(7, s, 0);
    }
    free(v12);
  }
  sub_4C150(a1, v13, 0x20u, (int)"cgminer.c", (int)"set_target", 8310);
}
// 53E4C: variable 'v1' is possibly undefined
// 53E80: variable 'v4' is possibly undefined
// 53EA8: variable 'v7' is possibly undefined
// 53ECC: variable 'v10' is possibly undefined
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (000540C4) --------------------------------------------------------
int __fastcall sub_540C4(int a1)
{
  return dword_244020 - *(_DWORD *)(a1 + 232);
}
// 244020: using guessed type int dword_244020;

//----- (000540DC) --------------------------------------------------------
bool __fastcall sub_540DC(int a1, int a2)
{
  *(_DWORD *)(a1 + 76) = a2;
  sub_51DD0(a1);
  return *(_DWORD *)(a1 + 220) == 0;
}

//----- (000540FC) --------------------------------------------------------
bool __fastcall sub_540FC(int a1, int a2)
{
  double v2; // d0

  *(_DWORD *)(a1 + 76) = a2;
  sub_51DD0(a1);
  return *(_QWORD *)(a1 + 216) <= (unsigned __int64)(4294901760.0 / v2);
}
// 5411C: variable 'v2' is possibly undefined

//----- (00054148) --------------------------------------------------------
int __fastcall sub_54148(int a1, int a2)
{
  _DWORD *v2; // r3
  int result; // r0
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  v2 = *(_DWORD **)(a1 + 36);
  if ( v2[59] == a2 )
  {
    if ( byte_244080 || (result = (unsigned __int8)byte_1AECC4, byte_1AECC4) || dword_9E320 > 5 )
    {
      snprintf(s, 0x800u, "%s %d duplicate share detected as HW error", *(const char **)(v2[1] + 8), v2[2]);
      sub_47AB4(6, s, 0);
      return 0;
    }
  }
  else
  {
    v2[59] = a2;
    return 1;
  }
  return result;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (000541EC) --------------------------------------------------------
void __fastcall sub_541EC(int *a1, int a2)
{
  _BYTE *v4; // r6
  int *v5; // r12
  int v6; // r0
  int v7; // r1
  _DWORD *v8; // lr
  int v9; // r2
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r1
  int v18; // r2
  int v19; // r1
  int v20; // r3
  int v21; // r2
  int v22; // r1
  int v23; // r2
  int v24; // r3
  _BYTE *v25; // r11
  char *v26; // r8
  char *v27; // r7
  char *v28; // r6
  _BYTE *v29; // r10
  _BYTE *v30; // r9
  char *v31; // r5
  size_t v32; // r0
  _BYTE *ptr; // [sp+Ch] [bp-4A8h]
  _DWORD v34[8]; // [sp+10h] [bp-4A4h] BYREF
  _DWORD v35[8]; // [sp+30h] [bp-484h] BYREF
  _DWORD v36[8]; // [sp+50h] [bp-464h] BYREF
  _BYTE v37[64]; // [sp+70h] [bp-444h] BYREF
  char s[1028]; // [sp+B0h] [bp-404h] BYREF

  if ( !dword_1AF0D8 )
    dword_1AF0D8 = fopen64("/nvdata/worklog.txt", "wb");
  v4 = v37;
  memset(s, 0, 0x400u);
  v5 = a1;
  memset(&v35[3], 0, 20);
  do
  {
    v6 = *v5;
    v5 += 4;
    v7 = *(v5 - 3);
    v8 = v4;
    v9 = *(v5 - 2);
    v4 += 16;
    v10 = *(v5 - 1);
    *v8 = v6;
    v8[1] = v7;
    v8[2] = v9;
    v8[3] = v10;
  }
  while ( v5 != a1 + 16 );
  v11 = a1[33];
  v12 = a1[34];
  v13 = a1[35];
  v34[0] = a1[32];
  v34[1] = v11;
  v34[2] = v12;
  v34[3] = v13;
  v14 = a1[37];
  v15 = a1[38];
  v16 = a1[39];
  v34[4] = a1[36];
  v34[5] = v14;
  v34[6] = v15;
  v34[7] = v16;
  v17 = v5[1];
  v18 = v5[2];
  v35[0] = *v5;
  v35[1] = v17;
  v35[2] = v18;
  v19 = a1[49];
  v20 = a1[51];
  v21 = a1[50];
  v36[0] = a1[48];
  v36[1] = v19;
  v36[2] = v21;
  v36[3] = v20;
  v22 = a1[53];
  v23 = a1[54];
  v24 = a1[55];
  v36[4] = a1[52];
  v36[5] = v22;
  v36[6] = v23;
  v36[7] = v24;
  sub_50B5C(v37, 64);
  sub_50B5C(v34, 32);
  sub_50B5C(v35, 12);
  sub_50B5C(v36, 32);
  ptr = sub_4988C((int)a1, 128);
  v25 = sub_4988C((int)v37, 64);
  v26 = sub_4988C((int)v34, 32);
  v27 = sub_4988C((int)v35, 12);
  v28 = sub_4988C(a2, 4);
  v29 = sub_4988C(a2, 5);
  v30 = sub_4988C((int)v36, 32);
  v31 = sub_4988C((int)(a1 + 111), 4);
  sprintf(s, "midstate %s data %s nonce %s version %s \r\n", v26, v27, v28, v31);
  v32 = strlen(s);
  fwrite(s, v32, 1u, (FILE *)dword_1AF0D8);
  fflush((FILE *)dword_1AF0D8);
  if ( ptr )
    free(ptr);
  if ( v25 )
    free(v25);
  if ( v26 )
    free(v26);
  if ( v27 )
    free(v27);
  if ( v28 )
    free(v28);
  if ( v29 )
    free(v29);
  if ( v30 )
    free(v30);
  if ( v31 )
    free(v31);
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1AF0D8: using guessed type int dword_1AF0D8;

//----- (000544A0) --------------------------------------------------------
void __fastcall sub_544A0(int *a1, unsigned int a2)
{
  unsigned int v2; // [sp+0h] [bp-Ch] BYREF
  char v3; // [sp+4h] [bp-8h]

  v2 = bswap32(a2);
  v3 = 0;
  sub_541EC(a1, (int)&v2);
}

//----- (000544C8) --------------------------------------------------------
int __fastcall sub_544C8(int *a1, unsigned int a2)
{
  unsigned int v5; // [sp+0h] [bp-Ch] BYREF
  char v6; // [sp+4h] [bp-8h]

  a1[19] = a2;
  sub_51DD0((int)a1);
  if ( a1[55] )
    return 0;
  v5 = bswap32(a2);
  v6 = 0;
  sub_541EC(a1, (int)&v5);
  return 1;
}

//----- (00054514) --------------------------------------------------------
void __fastcall sub_54514(int a1, int a2)
{
  int v4; // r5
  int v5; // r12
  int v6; // r0
  unsigned int v7; // r3
  unsigned int v8; // r2
  unsigned int v9; // r1
  unsigned int v10; // r3
  unsigned int v11; // r2
  int v12; // r1
  unsigned int v13; // r5
  int v14; // r6
  int v15; // r3
  int v16; // r1
  __int64 v17; // r2
  int v18; // r5
  int v19; // r2
  _DWORD *v20; // r3
  __int64 v21; // r2
  int v22; // r4
  _DWORD *v23; // r6
  int v24; // r7
  int v25; // r3
  unsigned int v26; // r4
  _DWORD *v27; // r5
  _DWORD *v28; // r11
  int v29; // r4
  char *v30; // r8
  unsigned int v31; // r1
  int v32; // r3
  _DWORD *v33; // r3
  unsigned int v34; // r2
  unsigned int v35; // r1
  bool v36; // cc
  int v37; // r2
  int v38; // r3
  void *v39; // r0
  void **v40; // r7
  void *v41; // r0
  unsigned int i; // [sp+4h] [bp-8h]

  ++*(_DWORD *)(a1 + 360);
  v4 = *(unsigned __int8 *)(a2 + 340);
  v5 = *(unsigned __int8 *)(a2 + 343);
  *(_DWORD *)(a2 + 364) = a2 + 340;
  *(_DWORD *)(a2 + 368) = 4;
  v6 = v4 + 17973517 + (v5 << 24) + (*(unsigned __int8 *)(a2 + 342) << 16) + (*(unsigned __int8 *)(a2 + 341) << 8);
  v7 = (-1622558010 - ((unsigned int)&unk_7F76D ^ v6)) ^ (((unsigned int)&unk_7F76D ^ v6) << 8);
  v8 = (-17973517 - ((unsigned int)&unk_7F76D ^ v6) - v7) ^ (v7 >> 13);
  v9 = (((unsigned int)&unk_7F76D ^ v6) - v7 - v8) ^ (v8 >> 12);
  v10 = (v7 - v8 - v9) ^ (v9 << 16);
  v11 = (v8 - v9 - v10) ^ (v10 >> 5);
  v12 = (v9 - v10 - v11) ^ (v11 >> 3);
  v13 = (v11 - v12 - ((v10 - v11 - v12) ^ (v12 << 10))) ^ (((v10 - v11 - v12) ^ (v12 << 10)) >> 15);
  *(_DWORD *)(a2 + 372) = v13;
  v14 = *(_DWORD *)(a1 + 352);
  if ( v14 )
  {
    v15 = *(_DWORD *)(v14 + 344);
    *(_DWORD *)(a2 + 352) = 0;
    v16 = a2 + 344;
    *(_DWORD *)(a2 + 344) = v15;
    *(_DWORD *)(a2 + 348) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16)
                          - *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) + 8) = a2;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) = a2 + 344;
  }
  else
  {
    *(_DWORD *)(a2 + 352) = 0;
    *(_DWORD *)(a2 + 348) = 0;
    *(_DWORD *)(a1 + 352) = a2;
    *(_DWORD *)(a2 + 344) = malloc(0x2Cu);
    v39 = *(void **)(*(_DWORD *)(a1 + 352) + 344);
    if ( !v39 )
      goto LABEL_31;
    memset(v39, 0, 0x2Cu);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) = *(_DWORD *)(a1 + 352) + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 4) = 32;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 8) = 5;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20) = 344;
    v40 = *(void ***)(*(_DWORD *)(a1 + 352) + 344);
    *v40 = malloc(0x180u);
    v41 = **(void ***)(*(_DWORD *)(a1 + 352) + 344);
    if ( !v41 )
      goto LABEL_31;
    memset(v41, 0, 0x180u);
    v16 = a2 + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 12);
  v17 = *(_QWORD *)*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344);
  v18 = 12 * (v13 & (HIDWORD(v17) - 1));
  ++*(_DWORD *)(v17 + v18 + 4);
  HIDWORD(v17) = *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v18);
  *(_DWORD *)(a2 + 356) = 0;
  *(_DWORD *)(a2 + 360) = HIDWORD(v17);
  HIDWORD(v17) = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
  v19 = *(_DWORD *)(HIDWORD(v17) + v18);
  v20 = (_DWORD *)(HIDWORD(v17) + v18);
  if ( v19 )
  {
    *(_DWORD *)(v19 + 12) = v16;
    v20 = (_DWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v18);
  }
  *v20 = v16;
  v21 = *(_QWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v18 + 4);
  if ( (unsigned int)v21 >= 10 * (HIDWORD(v21) + 1) )
  {
    v22 = *(_DWORD *)(a2 + 344);
    if ( *(_DWORD *)(v22 + 36) != 1 )
    {
      v23 = calloc(24 * *(_DWORD *)(v22 + 4), 1u);
      if ( v23 )
      {
        v24 = 0;
        *(_DWORD *)(v22 + 24) = (((2 * *(_DWORD *)(v22 + 4) - 1) & *(_DWORD *)(v22 + 12)) != 0)
                              + (*(_DWORD *)(v22 + 12) >> (*(_BYTE *)(v22 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a2 + 344) + 28) = 0;
        v25 = *(_DWORD *)(a2 + 344);
        v26 = *(_DWORD *)(v25 + 4);
        if ( v26 )
        {
          for ( i = 0; i < v26; ++i )
          {
            v27 = *(_DWORD **)(*(_DWORD *)v25 + v24);
            if ( v27 )
            {
              while ( 1 )
              {
                v28 = (_DWORD *)v27[4];
                v29 = 3 * ((2 * v26 - 1) & v27[7]);
                v30 = (char *)&v23[v29];
                v31 = *((_DWORD *)v30 + 1) + 1;
                *((_DWORD *)v30 + 1) = v31;
                if ( v31 > *(_DWORD *)(v25 + 24) )
                {
                  ++*(_DWORD *)(v25 + 28);
                  *((_DWORD *)v30 + 2) = *((_DWORD *)v30 + 1) / *(_DWORD *)(*(_DWORD *)(a2 + 344) + 24);
                }
                v27[3] = 0;
                v27[4] = v23[v29];
                v32 = v23[v29];
                if ( v32 )
                  *(_DWORD *)(v32 + 12) = v27;
                v23[v29] = v27;
                v25 = *(_DWORD *)(a2 + 344);
                if ( !v28 )
                  break;
                v26 = *(_DWORD *)(v25 + 4);
                v27 = v28;
              }
              v26 = *(_DWORD *)(v25 + 4);
            }
            v24 += 12;
          }
        }
        free(*(void **)v25);
        *(_DWORD *)(*(_DWORD *)(a2 + 344) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a2 + 344) + 8);
        **(_DWORD **)(a2 + 344) = v23;
        v33 = *(_DWORD **)(a2 + 344);
        v34 = v33[7];
        v35 = v33[3];
        v36 = v34 > v35 >> 1;
        if ( v34 <= v35 >> 1 )
          v37 = 0;
        else
          v37 = v33[8];
        if ( v36 )
          ++v37;
        v33[8] = v37;
        v38 = *(_DWORD *)(a2 + 344);
        if ( *(_DWORD *)(v38 + 32) > 1u )
          *(_DWORD *)(v38 + 36) = 1;
        return;
      }
LABEL_31:
      exit(-1);
    }
  }
}

//----- (0005494C) --------------------------------------------------------
int __fastcall sub_5494C(int a1, void *s2, size_t n, const void *a4, int a5, size_t na)
{
  int v6; // r5
  int v7; // r4

  v6 = a1;
  if ( a1 )
  {
    v7 = *(_DWORD *)(a1 + 352);
    while ( memcmp((const void *)(v6 + 128), s2, n) || memcmp((const void *)(v6 + a5), a4, na) )
    {
      v6 = v7;
      if ( !v7 )
        return v7;
      v7 = *(_DWORD *)(v7 + 352);
    }
  }
  return v6;
}

//----- (000549BC) --------------------------------------------------------
int __fastcall sub_549BC(int result, int a2)
{
  int v2; // r3

  if ( result )
  {
    v2 = *(_DWORD *)(result + 352);
    if ( a2 != *(_DWORD *)(result + 340) )
    {
      if ( v2 )
      {
        result = *(_DWORD *)(v2 + 352);
        while ( *(_DWORD *)(v2 + 340) != a2 )
        {
          v2 = result;
          if ( !result )
            return result;
          result = *(_DWORD *)(result + 352);
        }
      }
      return v2;
    }
  }
  return result;
}

//----- (00054A08) --------------------------------------------------------
void __fastcall sub_54A08(int a1, _DWORD *a2)
{
  int v2; // r12
  int v3; // r2
  int v4; // lr
  _DWORD *v5; // r12
  int v6; // r3
  int v7; // r4
  int v8; // r3
  _DWORD *v9; // r2
  int v10; // r3
  int v11; // r2
  int v12; // r2
  int v13; // r3

  v2 = *(_DWORD *)(a1 + 352);
  --*(_DWORD *)(a1 + 360);
  v3 = a2[87];
  if ( !v3 )
  {
    v7 = a2[88];
    v4 = *(_DWORD *)(v2 + 344);
    if ( !v7 )
    {
      free(*(void **)v4);
      free(*(void **)(*(_DWORD *)(a1 + 352) + 344));
      *(_DWORD *)(a1 + 352) = 0;
      return;
    }
    v6 = *(_DWORD *)(v4 + 20);
    v5 = a2 + 86;
    if ( a2 != (_DWORD *)(*(_DWORD *)(v4 + 16) - v6) )
      goto LABEL_17;
    goto LABEL_13;
  }
  v4 = *(_DWORD *)(v2 + 344);
  v5 = a2 + 86;
  v6 = *(_DWORD *)(v4 + 20);
  if ( a2 == (_DWORD *)(*(_DWORD *)(v4 + 16) - v6) )
  {
LABEL_13:
    *(_DWORD *)(v4 + 16) = v3 + v6;
    v3 = a2[87];
    if ( v3 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20);
      goto LABEL_3;
    }
    v7 = a2[88];
LABEL_17:
    *(_DWORD *)(a1 + 352) = v7;
    goto LABEL_4;
  }
LABEL_3:
  *(_DWORD *)(v3 + v6 + 8) = a2[88];
  v7 = *(_DWORD *)(a1 + 352);
LABEL_4:
  v8 = a2[88];
  v9 = *(_DWORD **)(v7 + 344);
  if ( v8 )
  {
    *(_DWORD *)(v8 + v9[5] + 4) = a2[87];
    v9 = *(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
  }
  v10 = 12 * ((v9[1] - 1) & a2[93]);
  --*(_DWORD *)(*v9 + v10 + 4);
  v11 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
  if ( *(_DWORD **)(v11 + v10) == v5 )
    *(_DWORD *)(v11 + v10) = a2[90];
  v12 = a2[89];
  v13 = a2[90];
  if ( v12 )
  {
    *(_DWORD *)(v12 + 16) = v13;
    v13 = a2[90];
  }
  if ( v13 )
    *(_DWORD *)(v13 + 12) = a2[89];
  --*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 12);
}

//----- (00054B78) --------------------------------------------------------
int __fastcall sub_54B78(int a1)
{
  _DWORD *v1; // r6
  int v3; // r5
  char v5[16]; // [sp+0h] [bp-810h] BYREF
  char v6[2048]; // [sp+10h] [bp-800h] BYREF

  v1 = *(_DWORD **)(a1 + 36);
  v3 = v1[1];
  snprintf(v5, 0x10u, "%d/Miner", *(_DWORD *)a1);
  sub_4BD10(v5);
  sub_51AAC(a1);
  if ( (*(int (__fastcall **)(int))(v3 + 52))(a1) )
  {
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      strcpy(v6, "Waiting on sem in miner thread");
      sub_47AB4(7, v6, 0);
    }
    sub_4BE90((sem_t *)(a1 + 16), "cgminer.c", "miner_thread", 9795);
    v1[58] = time(0);
    (*(void (__fastcall **)(int))(v3 + 60))(a1);
    (*(void (__fastcall **)(int))(v3 + 88))(a1);
    return 0;
  }
  else
  {
    sub_4BA2C(v1, 0);
    return 0;
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (00054CB4) --------------------------------------------------------
int __fastcall sub_54CB4(int result)
{
  if ( *(_DWORD *)(result + 32) != 1 )
    return (*(int (**)(void))(*(_DWORD *)(result + 4) + 16))();
  return result;
}

//----- (00054CCC) --------------------------------------------------------
void __fastcall __noreturn sub_54CCC(int a1, int a2)
{
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  if ( !pthread_create(newthread, 0, (void *(*)(void *))sub_51E38, 0) )
  {
    if ( a2 )
      sub_57944(0);
    if ( dword_1AF0DC > 0 )
    {
      kill(dword_1AF0DC, 15);
      dword_1AF0DC = 0;
    }
    pthread_cancel(newthread[0]);
    exit(a1);
  }
  exit(1);
}
// 1AF0DC: using guessed type int dword_1AF0DC;

//----- (00054D4C) --------------------------------------------------------
void __noreturn sub_54D4C()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  sub_4C084((int)sub_57F5C, 0, 5000);
  strcpy(v0, "Shutdown signal received.");
  sub_47AB4(3, v0, 1);
  sub_54CCC(0, 1);
}

//----- (00054DA8) --------------------------------------------------------
int __fastcall sub_54DA8(char *a1, size_t a2, int a3)
{
  double v3; // d0
  double v7; // r0
  double v8; // d8
  unsigned __int64 v9; // r8
  size_t v10; // r7
  char v12[16]; // [sp+28h] [bp-864h] BYREF
  char v13[16]; // [sp+38h] [bp-854h] BYREF
  char s[64]; // [sp+48h] [bp-844h] BYREF
  char v15[2052]; // [sp+88h] [bp-804h] BYREF

  sub_53118(a3);
  LODWORD(v7) = sub_778B4(*(_QWORD *)(a3 + 192));
  v8 = v7 / v3 * 60.0;
  v9 = (unsigned __int64)(*(double *)(a3 + 48) * 1000000.0);
  sub_51B18((unsigned __int64)(*(double *)(a3 + 80) / v3 * 1000000.0), v12, 0x10u, 4);
  sub_51B18(v9, v13, 0x10u, 4);
  snprintf(a1, a2, "%s%d ", *(const char **)(*(_DWORD *)(a3 + 4) + 8), *(_DWORD *)(a3 + 8));
  (*(void (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 20))(a1, a2, a3);
  v10 = strlen(a1);
  snprintf(
    s,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    dword_9ED78,
    v13,
    v12,
    *(double *)(a3 + 200),
    *(double *)(a3 + 208),
    *(_DWORD *)(a3 + 44),
    v8);
  if ( v10 + strlen(s) >= a2 )
  {
    snprintf(v15, 0x800u, "tailsprintf buffer overflow in %s %s line %d", "cgminer.c", "get_statline", 3113);
    sub_47AB4(3, v15, 1);
    sub_54CCC(1);
  }
  strcat(a1, s);
  return (*(int (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 24))(a1, a2, a3);
}
// 54DEC: variable 'v7' is possibly undefined
// 54DEC: variable 'v3' is possibly undefined
// 47AB4: using guessed type int __fastcall sub_47AB4(_DWORD, _DWORD, _DWORD);
// 54CCC: using guessed type void __fastcall __noreturn sub_54CCC(_DWORD);
// 9ED78: using guessed type int dword_9ED78;

//----- (00054F7C) --------------------------------------------------------
void __noreturn sub_54F7C()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "Failed to create restart thread");
  sub_47AB4(3, v0, 1);
  sub_54CCC(1, 1);
}

//----- (00054FC0) --------------------------------------------------------
int sub_54FC0()
{
  int result; // r0
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  sub_4A60C(&stru_1AF0BC);
  result = pthread_create(newthread, 0, (void *(*)(void *))sub_5C728, 0);
  if ( result )
    sub_54F7C();
  return result;
}
// 1AF0BC: using guessed type struct timeval stru_1AF0BC;

//----- (00055000) --------------------------------------------------------
void __fastcall __noreturn sub_55000(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_54CCC(1, 1);
}

//----- (0005505C) --------------------------------------------------------
void __fastcall __noreturn sub_5505C(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_54CCC(1, 1);
}

//----- (000550B8) --------------------------------------------------------
void __fastcall __noreturn sub_550B8(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_54CCC(1, 1);
}

//----- (00055114) --------------------------------------------------------
void __fastcall __noreturn sub_55114(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_54CCC(1, 1);
}

//----- (00055170) --------------------------------------------------------
int __fastcall sub_55170(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_mutex_t *v4; // r0
  int v5; // r4

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    sub_550B8("pool_tset", 803);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 1;
  if ( pthread_mutex_unlock(v4) )
    sub_55114("pool_tset", 808);
  off_9E444();
  return v5;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (000551DC) --------------------------------------------------------
int __fastcall sub_551DC(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_mutex_t *v4; // r0
  int v5; // r4

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    sub_550B8("pool_tclear", 818);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 0;
  if ( pthread_mutex_unlock(v4) )
    sub_55114("pool_tclear", 823);
  off_9E444();
  return v5;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (00055244) --------------------------------------------------------
int __fastcall sub_55244(_DWORD *a1)
{
  int v2; // r7
  int v3; // r2
  int v4; // r3
  const char *v5; // r0
  int v7; // r6
  int *v8; // r12
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int *v13; // r12
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r12
  const char *v19; // r1
  size_t v20; // r2
  int v21; // r3
  struct timeval v22; // [sp+8h] [bp-810h] BYREF
  struct timeval v23; // [sp+10h] [bp-808h] BYREF
  char s[2048]; // [sp+18h] [bp-800h] BYREF

  if ( *((_BYTE *)a1 + 736) )
  {
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf(s, 0x800u, "Retrieving block template from pool %s", (const char *)a1[41]);
      sub_47AB4(7, s, 0);
    }
  }
  else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
  {
    snprintf(s, 0x800u, "Testing pool %s", (const char *)a1[41]);
    sub_47AB4(6, s, 0);
  }
  v2 = *((unsigned __int8 *)a1 + 640);
  if ( *((_BYTE *)a1 + 640) )
  {
LABEL_38:
    v2 = sub_55170((int)a1, (_BYTE *)a1 + 642);
    if ( v2 )
      return *((unsigned __int8 *)a1 + 641);
    if ( !sub_4D754(a1) || *((_BYTE *)a1 + 580) && !sub_50338(a1) || (v7 = sub_50730(a1)) == 0 )
    {
      sub_551DC((int)a1, (_BYTE *)a1 + 642);
      return v2;
    }
    byte_244082 = 1;
    if ( pthread_create(a1 + 174, 0, (void *(*)(void *))sub_5C898, a1) )
    {
      v8 = (int *)&unk_86EC4;
    }
    else
    {
      if ( !pthread_create(a1 + 175, 0, (void *(*)(void *))sub_5FAA0, a1) )
        return v7;
      v8 = (int *)&unk_86EE8;
    }
    v9 = *v8;
    v10 = v8[1];
    v11 = v8[2];
    v12 = v8[3];
    v13 = v8 + 4;
    *(_DWORD *)s = v9;
    *(_DWORD *)&s[4] = v10;
    *(_DWORD *)&s[8] = v11;
    *(_DWORD *)&s[12] = v12;
    v14 = *v13;
    v15 = v13[1];
    v16 = v13[2];
    v17 = v13[3];
    v18 = v13[4];
    *(_DWORD *)&s[16] = v14;
    *(_DWORD *)&s[20] = v15;
    *(_DWORD *)&s[24] = v16;
    *(_DWORD *)&s[28] = v17;
    s[32] = v18;
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  if ( off_9ED7C )
  {
    if ( *((_BYTE *)a1 + 99) )
      goto LABEL_15;
    if ( !byte_1AECC5 )
    {
      *((_BYTE *)a1 + 99) = v2;
      goto LABEL_15;
    }
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
    {
      strcpy(s, "Probing for GBT support");
      sub_47AB4(7, s, 0);
      v3 = *((unsigned __int8 *)a1 + 736);
      v4 = (unsigned __int8)byte_1AECC5;
      *((_BYTE *)a1 + 99) = 0;
      if ( !v3 )
      {
        if ( *((_BYTE *)a1 + 900) )
        {
          if ( !v4 )
            goto LABEL_15;
          goto LABEL_54;
        }
        if ( v4 )
        {
          if ( !byte_244080 )
            goto LABEL_63;
          goto LABEL_65;
        }
LABEL_15:
        sub_4A60C(&v22);
        sub_4A60C(&v23);
        v5 = (const char *)a1[144];
        if ( v5 && !byte_1AF0E0 )
        {
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
          {
            snprintf(s, 0x800u, "Testing pool %d stratum %s", *a1, (const char *)a1[144]);
            sub_47AB4(6, s, 0);
            v5 = (const char *)a1[144];
          }
          if ( sub_4A940(v5, a1 + 150, (char **)a1 + 146) && sub_4D754(a1) )
          {
            if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
            {
              snprintf(s, 0x800u, "Switching pool %d %s to %s", *a1, (const char *)a1[41], (const char *)a1[144]);
              sub_47AB4(5, s, 0);
            }
            if ( !a1[41] )
              a1[41] = _strdup((const char *)a1[144]);
            *((_BYTE *)a1 + 640) = 1;
            goto LABEL_38;
          }
        }
        if ( !*((_BYTE *)a1 + 640) && !*((_BYTE *)a1 + 900) && !*((_BYTE *)a1 + 736) )
        {
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
          {
            v2 = 0;
            snprintf(
              s,
              0x800u,
              "No Stratum, GBT or Solo support in pool %d %s unable to use",
              *a1,
              (const char *)a1[41]);
            sub_47AB4(4, s, 0);
          }
          return v2;
        }
        if ( byte_1AECC5 )
        {
          if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
          {
            if ( *((_BYTE *)a1 + 97) )
              return v2;
LABEL_75:
            if ( dword_9E320 <= 3 )
              return v2;
LABEL_81:
            snprintf(s, 0x800u, "Pool %u slow/down or URL or credentials invalid", *a1);
            sub_47AB4(4, s, 0);
            return v2;
          }
          snprintf(s, 0x800u, "FAILED to retrieve work from pool %u %s", *a1, (const char *)a1[41]);
          sub_47AB4(7, s, 0);
        }
        if ( *((_BYTE *)a1 + 97) )
          return v2;
        if ( byte_244080 || byte_1AECC4 )
          goto LABEL_81;
        goto LABEL_75;
      }
      if ( !v4 )
        goto LABEL_15;
    }
    else
    {
      v21 = *((unsigned __int8 *)a1 + 736);
      *((_BYTE *)a1 + 99) = v2;
      if ( !v21 )
      {
        if ( !*((_BYTE *)a1 + 900) )
        {
          if ( !byte_244080 )
          {
LABEL_63:
            if ( !byte_1AECC4 && dword_9E320 <= 6 )
              goto LABEL_15;
          }
LABEL_65:
          v19 = "No GBT coinbase + append support found, pool unusable if it has no stratum";
          v20 = 75;
LABEL_58:
          memcpy(s, v19, v20);
          sub_47AB4(7, s, 0);
          goto LABEL_15;
        }
LABEL_54:
        if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
          goto LABEL_15;
        v19 = "GBT coinbase without append found, switching to GBT solo protocol";
        v20 = 66;
        goto LABEL_58;
      }
    }
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
    {
      strcpy(s, "GBT coinbase + append support found, switching to GBT protocol");
      sub_47AB4(7, s, 0);
    }
    goto LABEL_15;
  }
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
    return v2;
  strcpy(s, "CURL initialisation failed");
  sub_47AB4(3, s, 0);
  return v2;
}
// 9E320: using guessed type int dword_9E320;
// 9ED7C: using guessed type char *off_9ED7C;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AF0E0: using guessed type char byte_1AF0E0;
// 244080: using guessed type char byte_244080;
// 244082: using guessed type char byte_244082;

//----- (00055A28) --------------------------------------------------------
int __fastcall sub_55A28(int a1, int a2)
{
  if ( pthread_mutex_lock(&stru_246244) )
    sub_550B8("inc_dev_status", 8777);
  dword_245100 = a1;
  dword_245104 = a2;
  if ( pthread_mutex_unlock(&stru_246244) )
    sub_55114("inc_dev_status", 8780);
  return off_9E444();
}
// 9E444: using guessed type int (*off_9E444)();
// 245100: using guessed type int dword_245100;
// 245104: using guessed type int dword_245104;
// 246244: using guessed type pthread_mutex_t stru_246244;

//----- (00055AA4) --------------------------------------------------------
int sub_55AA4()
{
  if ( pthread_mutex_lock((pthread_mutex_t *)dword_1AF0E4) )
    sub_550B8("wake_gws", 5363);
  pthread_cond_signal(&stru_244050);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_1AF0E4) )
    sub_55114("wake_gws", 5365);
  return off_9E444();
}
// 9E444: using guessed type int (*off_9E444)();
// 1AF0E4: using guessed type int dword_1AF0E4;
// 244050: using guessed type pthread_cond_t stru_244050;

//----- (00055B0C) --------------------------------------------------------
int __fastcall sub_55B0C(int a1, unsigned int a2)
{
  unsigned int v4; // r4
  int v5; // r1
  __time_t v6; // r4
  int v7; // r1
  int v8; // r4
  struct timeval v10; // [sp+0h] [bp-10h] BYREF
  struct timespec abstime; // [sp+8h] [bp-8h] BYREF

  v4 = a2 / 0x3E8;
  sub_4A60C(&v10);
  v5 = 1000 * a2 - (_DWORD)&unk_F4240 * v4;
  v6 = v4 + v10.tv_sec;
  v7 = v5 + v10.tv_usec;
  if ( v7 > 999999 )
  {
    ++v6;
    v7 -= 1000000;
  }
  abstime.tv_sec = v6;
  abstime.tv_nsec = 1000 * v7;
  v8 = pthread_mutex_lock(&stru_246374);
  if ( v8 )
    sub_550B8("restart_wait", 5416);
  if ( !*(_BYTE *)(a1 + 62) )
    v8 = pthread_cond_timedwait(stru_246280, &stru_246374, &abstime);
  if ( pthread_mutex_unlock(&stru_246374) )
    sub_55114("restart_wait", 5426);
  off_9E444();
  return v8;
}
// 9E444: using guessed type int (*off_9E444)();
// 246280: using guessed type pthread_cond_t stru_246280[3];
// 246374: using guessed type pthread_mutex_t stru_246374;

//----- (00055C08) --------------------------------------------------------
void __fastcall __noreturn sub_55C08(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_54CCC(1);
}
// 47AB4: using guessed type int __fastcall sub_47AB4(_DWORD, _DWORD, _DWORD);
// 54CCC: using guessed type void __fastcall __noreturn sub_54CCC(_DWORD);

//----- (00055C64) --------------------------------------------------------
int sub_55C64()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_2440BC) )
    sub_550B8("total_work_inc", 2260);
  if ( pthread_rwlock_wrlock(&rwlock) )
    sub_5505C("total_work_inc", 2260);
  v0 = dword_1AF0E8++;
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_55C08("total_work_inc", 2262);
  if ( pthread_mutex_unlock(&stru_2440BC) )
    sub_55114("total_work_inc", 2262);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 1AF0E8: using guessed type int dword_1AF0E8;
// 2440BC: using guessed type pthread_mutex_t stru_2440BC;

//----- (00055D14) --------------------------------------------------------
int __fastcall sub_55D14(int a1)
{
  int v2; // r1
  bool v3; // zf
  unsigned int v4; // r3
  int v5; // r0
  _BYTE *v6; // r5
  int result; // r0
  unsigned int v8[513]; // [sp+0h] [bp-804h] BYREF

  v2 = dword_246360;
  v3 = byte_1AECC5 == 0;
  v4 = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + 1);
  v5 = *(_DWORD *)(a1 + 240) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  *(_DWORD *)(a1 + 240) = v5;
  *(_DWORD *)(a1 + 248) = 0;
  dword_246360 = v2 + 1;
  if ( !v3 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    strcpy((char *)v8, "Successfully rolled work");
    sub_47AB4(7, (const char *)v8, 0);
  }
  v6 = *(_BYTE **)(a1 + 308);
  if ( v6 )
  {
    sub_49940(v8, *(unsigned __int8 **)(a1 + 308), 4);
    v8[0] = bswap32(bswap32(v8[0]) + 1);
    sub_4981C(v6, (int)v8, 4);
  }
  result = sub_55C64();
  *(_DWORD *)(a1 + 340) = result;
  return result;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;
// 246360: using guessed type int dword_246360;

//----- (00055E38) --------------------------------------------------------
_DWORD *sub_55E38()
{
  _DWORD *v0; // r4
  char v2[2048]; // [sp+8h] [bp-800h] BYREF

  v0 = sub_496AC(1u, 0x1C0u, "cgminer.c", "make_work", 2269);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc work in make_work");
    sub_47AB4(3, v2, 1);
    sub_54CCC(1, 1);
  }
  v0[85] = sub_55C64();
  return v0;
}

//----- (00055ED0) --------------------------------------------------------
_DWORD *__fastcall sub_55ED0(int a1, int a2)
{
  _DWORD *v4; // r4

  v4 = sub_55E38();
  sub_52F6C((int)v4, a1, a2);
  return v4;
}

//----- (00055EF8) --------------------------------------------------------
_DWORD *__fastcall sub_55EF8(int a1)
{
  _DWORD *v2; // r4
  int v3; // r3

  v2 = sub_55E38();
  sub_52F6C((int)v2, a1, 0);
  *((_BYTE *)v2 + 273) = 1;
  sub_4A60C((struct timeval *)v2 + 52);
  v3 = v2[66];
  *((_BYTE *)v2 + 280) = 0;
  *((_BYTE *)v2 + 282) = 0;
  v2[66] = v3 - 1;
  return v2;
}

//----- (00055F44) --------------------------------------------------------
int __fastcall sub_55F44(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_5505C("add_queued", 9443);
  sub_54514((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    sub_55C08("add_queued", 9445);
  return off_9E444();
}
// 9E444: using guessed type int (*off_9E444)();

//----- (00055FB0) --------------------------------------------------------
void __fastcall sub_55FB0(pthread_rwlock_t *a1, void **a2)
{
  pthread_rwlock_t *v2; // r4
  void **v4; // [sp+4h] [bp-8h] BYREF

  v2 = a1 + 10;
  v4 = a2;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_5505C("work_completed", 9595);
  sub_54A08((int)a1, v4);
  if ( pthread_rwlock_unlock(v2) )
    sub_55C08("work_completed", 9597);
  off_9E444();
  sub_53084(&v4, "cgminer.c", "work_completed", 9599);
}
// 9E444: using guessed type int (*off_9E444)();

//----- (0005603C) --------------------------------------------------------
_DWORD *__fastcall sub_5603C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r5
  _DWORD *v11; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_5505C("take_queued_work_bymidstate", 9608);
  v11 = (_DWORD *)sub_5494C(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
    sub_54A08((int)a1, v11);
  if ( pthread_rwlock_unlock(v6) )
    sub_55C08("take_queued_work_bymidstate", 9612);
  off_9E444();
  return v11;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (000560E8) --------------------------------------------------------
int __fastcall sub_560E8(pthread_rwlock_t *a1)
{
  int i; // r4
  int lock; // [sp+4h] [bp-10h]
  struct timeval v5; // [sp+8h] [bp-Ch] BYREF

  sub_4A60C(&v5);
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_5505C("age_queued_work", 9574);
  lock = a1[11].__lock;
  if ( lock )
  {
    for ( i = *(_DWORD *)(lock + 352); ; i = *(_DWORD *)(i + 352) )
    {
      sub_4A8FC();
      if ( !i )
        break;
    }
  }
  if ( pthread_rwlock_unlock(a1 + 10) )
    sub_55C08("age_queued_work", 9585);
  off_9E444();
  return 0;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (000561E4) --------------------------------------------------------
void __fastcall __noreturn sub_561E4(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_47AB4(3, s, 1);
  sub_54CCC(1);
}
// 47AB4: using guessed type int __fastcall sub_47AB4(_DWORD, _DWORD, _DWORD);
// 54CCC: using guessed type void __fastcall __noreturn sub_54CCC(_DWORD);

//----- (00056240) --------------------------------------------------------
_DWORD *__fastcall sub_56240(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r7
  _DWORD *lock; // r4
  int v6; // r5

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_561E4("clone_queued_work_byid", 9548);
  lock = (_DWORD *)a1[11].__lock;
  if ( lock )
  {
    v6 = lock[88];
    if ( a2 == lock[85] )
    {
      v6 = (int)lock;
    }
    else
    {
      if ( !v6 )
      {
        lock = 0;
        goto LABEL_10;
      }
      lock = *(_DWORD **)(v6 + 352);
      while ( a2 != *(_DWORD *)(v6 + 340) )
      {
        if ( !lock )
          goto LABEL_10;
        v6 = (int)lock;
        lock = (_DWORD *)lock[88];
      }
    }
    lock = sub_55E38();
    sub_52F6C((int)lock, v6, 0);
  }
LABEL_10:
  if ( pthread_rwlock_unlock(v2) )
    sub_55C08("clone_queued_work_byid", 9552);
  off_9E444();
  return lock;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (0005630C) --------------------------------------------------------
_DWORD *__fastcall sub_5630C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5
  _DWORD *v12; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_561E4("clone_queued_work_bymidstate", 9501);
  v11 = sub_5494C(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
  {
    v12 = sub_55E38();
    sub_52F6C((int)v12, v11, 0);
  }
  else
  {
    v12 = 0;
  }
  if ( pthread_rwlock_unlock(v6) )
    sub_55C08("clone_queued_work_bymidstate", 9505);
  off_9E444();
  return v12;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (000563C8) --------------------------------------------------------
int __fastcall sub_563C8(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r6
  int lock; // r4
  int v6; // r3

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_561E4("find_queued_work_byid", 9536);
  lock = a1[11].__lock;
  if ( lock )
  {
    v6 = *(_DWORD *)(lock + 352);
    if ( a2 != *(_DWORD *)(lock + 340) )
    {
      if ( v6 )
      {
        lock = *(_DWORD *)(v6 + 352);
        while ( a2 != *(_DWORD *)(v6 + 340) )
        {
          if ( !lock )
            goto LABEL_10;
          v6 = lock;
          lock = *(_DWORD *)(lock + 352);
        }
      }
      lock = v6;
    }
  }
LABEL_10:
  if ( pthread_rwlock_unlock(v2) )
    sub_55C08("find_queued_work_byid", 9538);
  off_9E444();
  return lock;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (0005647C) --------------------------------------------------------
int __fastcall sub_5647C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_561E4("find_queued_work_bymidstate", 9489);
  v11 = sub_5494C(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( pthread_rwlock_unlock(v6) )
    sub_55C08("find_queued_work_bymidstate", 9491);
  off_9E444();
  return v11;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (00056518) --------------------------------------------------------
int __fastcall sub_56518(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&stru_24638C) )
    sub_561E4("get_devices", 624);
  v2 = *(_DWORD *)(dword_242FEC + 4 * a1);
  if ( pthread_rwlock_unlock(&stru_24638C) )
    sub_55C08("get_devices", 626);
  off_9E444();
  return v2;
}
// 9E444: using guessed type int (*off_9E444)();
// 242FEC: using guessed type int dword_242FEC;
// 24638C: using guessed type pthread_rwlock_t stru_24638C;

//----- (0005658C) --------------------------------------------------------
int sub_5658C()
{
  int v0; // r12
  int v1; // r2
  double v2; // d9
  int v3; // r8
  int v4; // r6
  int v5; // r10
  double v6; // r0
  double v7; // d10
  double v8; // r0
  double v9; // d10
  double v10; // d8
  double v11; // d7
  __int64 v12; // r6
  __int64 v13; // kr08_8
  __int64 v14; // r0
  int v15; // r1
  double v16; // d9
  double v17; // r0
  int v18; // r8
  int v19; // r6
  int v20; // r3
  const char *v21; // r1
  __int64 v22; // r10
  __int64 v23; // r0
  int v24; // r1
  double v25; // d8
  double v26; // r0
  int v27; // r5
  int v28; // r0
  int v29; // r1
  int v30; // r3
  double v31; // d7
  unsigned int v33; // [sp+10h] [bp-91Ch]
  unsigned int v34; // [sp+14h] [bp-918h]
  char v35[256]; // [sp+28h] [bp-904h] BYREF
  char s[2052]; // [sp+128h] [bp-804h] BYREF

  v0 = dword_1AF0EC - dword_1AF0F4;
  LOWORD(v1) = -30583;
  if ( dword_1AF0F0 - dword_1AF0F8 < 0 )
    --v0;
  HIWORD(v1) = -30584;
  v2 = dbl_9ED68;
  v3 = v0 / 3600;
  v4 = v0 - 60 * (((int)(v0 + ((unsigned __int64)(v0 * (__int64)v1) >> 32)) >> 5) - (v0 >> 31));
  v5 = ((int)(v0 % 3600 + ((unsigned __int64)(v0 % 3600 * (__int64)v1) >> 32)) >> 5) - ((v0 % 3600) >> 31);
  LODWORD(v6) = sub_778B4(*(__int64 *)&dword_245158);
  v7 = v6 / v2;
  LODWORD(v8) = sub_778B4(*(__int64 *)&dword_2463D0);
  v9 = v7 * 60.0;
  v10 = v8 / v2 * 60.0;
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3
    || (strcpy(s, "\nSummary of runtime statistics:\n"), sub_47AB4(4, s, 0), !byte_244080)
    && !byte_1AECC4
    && dword_9E320 <= 3 )
  {
    if ( dword_242F4C == 1 )
      goto LABEL_156;
LABEL_8:
    if ( byte_244080 || byte_1AECC4 )
      goto LABEL_10;
    goto LABEL_137;
  }
  snprintf(s, 0x800u, "Started at %s", byte_1AF0FC);
  sub_47AB4(4, s, 0);
  if ( dword_242F4C != 1 )
    goto LABEL_8;
  if ( byte_244080 || byte_1AECC4 )
    goto LABEL_157;
LABEL_156:
  if ( dword_9E320 > 3 )
  {
LABEL_157:
    snprintf(s, 0x800u, "Pool: %s", *(const char **)(*(_DWORD *)dword_244048 + 164));
    sub_47AB4(4, s, 0);
    goto LABEL_8;
  }
LABEL_137:
  if ( dword_9E320 <= 3 )
  {
    v11 = dbl_245228 / dbl_9ED68;
    goto LABEL_139;
  }
LABEL_10:
  snprintf(s, 0x800u, "Runtime: %d hrs : %d mins : %d secs", v3, v5, v4);
  sub_47AB4(4, s, 0);
  v11 = dbl_245228 / dbl_9ED68;
  if ( byte_244080 || byte_1AECC4 )
  {
LABEL_12:
    snprintf(s, 0x800u, "Average hashrate: %.1f Mhash/s", v11);
    sub_47AB4(4, s, 0);
    if ( byte_244080 || byte_1AECC4 )
      goto LABEL_14;
    goto LABEL_189;
  }
LABEL_139:
  if ( dword_9E320 > 3 )
    goto LABEL_12;
LABEL_189:
  if ( dword_9E320 <= 3 )
    goto LABEL_190;
LABEL_14:
  snprintf(s, 0x800u, "Solved blocks: %d", dword_242FDC);
  sub_47AB4(4, s, 0);
  if ( !byte_244080 && !byte_1AECC4 )
  {
LABEL_190:
    if ( dword_9E320 <= 3 )
      goto LABEL_158;
  }
  snprintf(s, 0x800u, "Best share difficulty: %s", dword_9ED70);
  sub_47AB4(4, s, 0);
  if ( byte_244080 || byte_1AECC4 )
  {
LABEL_18:
    snprintf(s, 0x800u, "Share submissions: %lld", *(_QWORD *)&dword_245158 + qword_246368);
    sub_47AB4(4, s, 0);
    if ( byte_244080 || byte_1AECC4 )
      goto LABEL_20;
    goto LABEL_159;
  }
LABEL_158:
  if ( dword_9E320 > 3 )
    goto LABEL_18;
LABEL_159:
  if ( dword_9E320 <= 3 )
    goto LABEL_160;
LABEL_20:
  snprintf(s, 0x800u, "Accepted shares: %lld", *(_QWORD *)&dword_245158);
  sub_47AB4(4, s, 0);
  if ( !byte_244080 && !byte_1AECC4 )
  {
LABEL_160:
    if ( dword_9E320 <= 3 )
      goto LABEL_161;
  }
  snprintf(s, 0x800u, "Rejected shares: %lld", qword_246368);
  sub_47AB4(4, s, 0);
  if ( byte_244080 || byte_1AECC4 )
  {
LABEL_24:
    snprintf(s, 0x800u, "Accepted difficulty shares: %1.f", dbl_242EF0);
    sub_47AB4(4, s, 0);
    if ( byte_244080 || byte_1AECC4 )
      goto LABEL_26;
    goto LABEL_162;
  }
LABEL_161:
  if ( dword_9E320 > 3 )
    goto LABEL_24;
LABEL_162:
  if ( dword_9E320 <= 3 )
  {
    v12 = *(_QWORD *)&dword_245158;
    if ( *(_QWORD *)&dword_245158 )
      goto LABEL_164;
    goto LABEL_54;
  }
LABEL_26:
  snprintf(s, 0x800u, "Rejected difficulty shares: %1.f", dbl_242F10);
  sub_47AB4(4, s, 0);
  v12 = *(_QWORD *)&dword_245158;
  if ( *(_QWORD *)&dword_245158 )
  {
    if ( !byte_244080 )
      goto LABEL_28;
LABEL_29:
    v13 = qword_246368;
    HIDWORD(v14) = (unsigned __int64)(3 * qword_246368) >> 32;
    LODWORD(v14) = 96 * qword_246368;
    LODWORD(v16) = sub_778B4(__PAIR64__((unsigned __int64)(96 * qword_246368) >> 32, 3 * (int)qword_246368) + v14 + qword_246368);
    HIDWORD(v16) = v15;
    LODWORD(v17) = sub_778B4(v13 + v12);
    snprintf(s, 0x800u, "Reject ratio: %.1f%%", v16 / v17);
    sub_47AB4(4, s, 0);
LABEL_30:
    if ( byte_244080 || byte_1AECC4 )
      goto LABEL_32;
    goto LABEL_145;
  }
LABEL_54:
  if ( !qword_246368 )
    goto LABEL_30;
  v12 = 0;
  if ( byte_244080 )
    goto LABEL_29;
LABEL_28:
  if ( byte_1AECC4 )
    goto LABEL_29;
LABEL_164:
  if ( dword_9E320 > 3 )
    goto LABEL_29;
LABEL_145:
  if ( dword_9E320 <= 3 )
    goto LABEL_146;
LABEL_32:
  snprintf(s, 0x800u, "Hardware errors: %d", dword_242EE8);
  sub_47AB4(4, s, 0);
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
  {
LABEL_146:
    if ( dword_9E320 <= 3 )
      goto LABEL_147;
    goto LABEL_36;
  }
  snprintf(s, 0x800u, "Utility (accepted shares / min): %.2f/min", v9);
  sub_47AB4(4, s, 0);
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
  {
LABEL_147:
    if ( dword_9E320 <= 3 )
      goto LABEL_148;
    goto LABEL_38;
  }
LABEL_36:
  snprintf(s, 0x800u, "Work Utility (diff1 shares solved / min): %.2f/min\n", v10);
  sub_47AB4(4, s, 0);
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
  {
LABEL_148:
    if ( dword_9E320 <= 3 )
      goto LABEL_149;
    goto LABEL_40;
  }
LABEL_38:
  snprintf(s, 0x800u, "Stale submissions discarded due to new blocks: %lld", *(_QWORD *)&dword_242E98);
  sub_47AB4(4, s, 0);
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
  {
LABEL_149:
    if ( dword_9E320 <= 3 )
      goto LABEL_150;
    goto LABEL_42;
  }
LABEL_40:
  snprintf(s, 0x800u, "Unable to get work from server occasions: %d", dword_245150);
  sub_47AB4(4, s, 0);
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
  {
LABEL_150:
    if ( dword_9E320 <= 3 )
      goto LABEL_151;
    goto LABEL_44;
  }
LABEL_42:
  snprintf(s, 0x800u, "Work items generated locally: %d", dword_246360);
  sub_47AB4(4, s, 0);
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
  {
LABEL_151:
    if ( dword_9E320 <= 3 )
      goto LABEL_152;
    goto LABEL_46;
  }
LABEL_44:
  snprintf(s, 0x800u, "Submitting work remotely delay occasions: %d", dword_244014);
  sub_47AB4(4, s, 0);
  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
  {
LABEL_152:
    if ( dword_242F4C <= 1 )
      goto LABEL_141;
    goto LABEL_47;
  }
LABEL_46:
  snprintf(s, 0x800u, "New blocks detected on network: %d\n", dword_24625C);
  sub_47AB4(4, s, 0);
  if ( dword_242F4C > 1 )
  {
LABEL_47:
    v18 = 0;
    while ( 1 )
    {
      v19 = *(_DWORD *)(dword_244048 + 4 * v18);
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
        break;
      v20 = *(_DWORD *)(v19 + 32);
      if ( v20 )
        goto LABEL_52;
LABEL_63:
      if ( !byte_1AECC4 )
      {
LABEL_110:
        if ( dword_9E320 <= 3 )
          goto LABEL_111;
      }
LABEL_64:
      snprintf(s, 0x800u, " Share submissions: %lld", *(_QWORD *)(v19 + 8) + *(_QWORD *)(v19 + 16));
      sub_47AB4(4, s, 0);
      if ( byte_244080 || byte_1AECC4 )
      {
LABEL_66:
        snprintf(s, 0x800u, " Accepted shares: %lld", *(_QWORD *)(v19 + 8));
        sub_47AB4(4, s, 0);
        if ( byte_244080 || byte_1AECC4 )
          goto LABEL_68;
        goto LABEL_112;
      }
LABEL_111:
      if ( dword_9E320 > 3 )
        goto LABEL_66;
LABEL_112:
      if ( dword_9E320 <= 3 )
        goto LABEL_113;
LABEL_68:
      snprintf(s, 0x800u, " Rejected shares: %lld", *(_QWORD *)(v19 + 16));
      sub_47AB4(4, s, 0);
      if ( !byte_244080 && !byte_1AECC4 )
      {
LABEL_113:
        if ( dword_9E320 <= 3 )
          goto LABEL_114;
      }
      snprintf(s, 0x800u, " Accepted difficulty shares: %1.f", *(double *)(v19 + 72));
      sub_47AB4(4, s, 0);
      if ( byte_244080 || byte_1AECC4 )
      {
LABEL_72:
        snprintf(s, 0x800u, " Rejected difficulty shares: %1.f", *(double *)(v19 + 80));
        sub_47AB4(4, s, 0);
        v22 = *(_QWORD *)(v19 + 8);
        if ( v22 )
          goto LABEL_75;
        goto LABEL_73;
      }
LABEL_114:
      if ( dword_9E320 > 3 )
        goto LABEL_72;
      v22 = *(_QWORD *)(v19 + 8);
      if ( v22 )
      {
        if ( dword_9E320 <= 3 )
          goto LABEL_117;
        goto LABEL_77;
      }
LABEL_73:
      if ( *(_QWORD *)(v19 + 16) )
      {
        v22 = 0;
LABEL_75:
        if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
        {
LABEL_117:
          if ( dword_9E320 <= 3 )
            goto LABEL_118;
          goto LABEL_80;
        }
LABEL_77:
        v34 = *(_DWORD *)(v19 + 16);
        HIDWORD(v23) = (unsigned __int64)(3LL * *(_QWORD *)(v19 + 16)) >> 32;
        LODWORD(v23) = 96 * v34;
        v33 = *(_DWORD *)(v19 + 20);
        LODWORD(v25) = sub_778B4(
                         __PAIR64__((unsigned __int64)(96LL * *(_QWORD *)(v19 + 16)) >> 32, 3 * v34)
                       + v23
                       + *(_QWORD *)(v19 + 16));
        HIDWORD(v25) = v24;
        LODWORD(v26) = sub_778B4(__PAIR64__(v33, v34) + v22);
        snprintf(s, 0x800u, " Reject ratio: %.1f%%", v25 / v26);
        sub_47AB4(4, s, 0);
      }
      if ( !byte_244080 && !byte_1AECC4 )
        goto LABEL_117;
LABEL_80:
      snprintf(s, 0x800u, " Items worked on: %d", *(_DWORD *)(v19 + 68));
      sub_47AB4(4, s, 0);
      if ( byte_244080 || byte_1AECC4 )
      {
LABEL_82:
        snprintf(s, 0x800u, " Stale submissions discarded due to new blocks: %d", *(_DWORD *)(v19 + 120));
        sub_47AB4(4, s, 0);
        if ( byte_244080 || byte_1AECC4 )
          goto LABEL_84;
        goto LABEL_119;
      }
LABEL_118:
      if ( dword_9E320 > 3 )
        goto LABEL_82;
LABEL_119:
      if ( dword_9E320 <= 3 )
        goto LABEL_120;
LABEL_84:
      snprintf(s, 0x800u, " Unable to get work from server occasions: %d", *(_DWORD *)(v19 + 128));
      sub_47AB4(4, s, 0);
      if ( !byte_244080 && !byte_1AECC4 )
      {
LABEL_120:
        if ( dword_9E320 <= 3 )
          goto LABEL_87;
      }
      snprintf(s, 0x800u, " Submitting work remotely delay occasions: %d\n", *(_DWORD *)(v19 + 132));
      sub_47AB4(4, s, 0);
LABEL_87:
      if ( dword_242F4C <= ++v18 )
        goto LABEL_88;
    }
    snprintf(s, 0x800u, "Pool: %s", *(const char **)(v19 + 164));
    sub_47AB4(4, s, 0);
    v20 = *(_DWORD *)(v19 + 32);
    if ( v20 )
    {
      if ( !byte_244080 && !byte_1AECC4 )
      {
LABEL_52:
        if ( dword_9E320 <= 3 )
          goto LABEL_110;
      }
      v21 = "S";
      if ( v20 <= 1 )
        v21 = "";
      snprintf(s, 0x800u, "SOLVED %d BLOCK%s!", v20, v21);
      sub_47AB4(4, s, 0);
    }
    if ( byte_244080 )
      goto LABEL_64;
    goto LABEL_63;
  }
LABEL_88:
  if ( byte_244080 || byte_1AECC4 )
    goto LABEL_90;
LABEL_141:
  if ( dword_9E320 > 3 )
  {
LABEL_90:
    strcpy(s, "Summary of per device statistics:\n");
    sub_47AB4(4, s, 0);
  }
  if ( dword_245140 > 0 )
  {
    v27 = 0;
    do
    {
      v28 = sub_56518(v27++);
      *(_DWORD *)(*(_DWORD *)(v28 + 4) + 20) = nullsub_3;
      *(_DWORD *)(*(_DWORD *)(v28 + 4) + 24) = nullsub_4;
      sub_54DA8(v35, 0xFFu, v28);
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
      {
        snprintf(s, 0x800u, "%s", v35);
        sub_47AB4(4, s, 0);
      }
    }
    while ( dword_245140 > v27 );
  }
  v29 = dword_1AF124;
  v30 = (unsigned __int8)byte_244080;
  if ( dword_1AF124 )
  {
    v31 = dbl_242EF0;
    if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
    {
      if ( (double)dword_1AF124 <= dbl_242EF0 )
        goto LABEL_143;
      goto LABEL_103;
    }
    snprintf(s, 0x800u, "Mined %.0f accepted shares of %d requested\n", dbl_242EF0, dword_1AF124);
    sub_47AB4(4, s, 0);
    v31 = dbl_242EF0;
    v29 = dword_1AF124;
    v30 = (unsigned __int8)byte_244080;
    if ( (double)dword_1AF124 > dbl_242EF0 )
    {
      if ( byte_244080 )
      {
LABEL_105:
        snprintf(s, 0x800u, "WARNING - Mined only %.0f shares of %d requested.", v31, v29);
        sub_47AB4(4, s, 0);
        v30 = (unsigned __int8)byte_244080;
        goto LABEL_106;
      }
LABEL_103:
      if ( !byte_1AECC4 && dword_9E320 <= 3 )
      {
LABEL_143:
        if ( dword_9E320 <= 3 )
          goto LABEL_109;
        goto LABEL_108;
      }
      goto LABEL_105;
    }
  }
LABEL_106:
  if ( !v30 && !byte_1AECC4 )
    goto LABEL_143;
LABEL_108:
  strcpy(s, " ");
  sub_47AB4(4, s, 0);
LABEL_109:
  fflush((FILE *)stderr);
  return fflush((FILE *)stdout);
}
// 56648: variable 'v6' is possibly undefined
// 56658: variable 'v8' is possibly undefined
// 56A90: variable 'v15' is possibly undefined
// 56AB8: variable 'v17' is possibly undefined
// 57080: variable 'v24' is possibly undefined
// 570A8: variable 'v26' is possibly undefined
// 47AB4: using guessed type int __fastcall sub_47AB4(_DWORD, _DWORD, _DWORD);
// 516B0: using guessed type int nullsub_3();
// 52A28: using guessed type int nullsub_4();
// 9E320: using guessed type int dword_9E320;
// 9ED68: using guessed type double dbl_9ED68;
// 9F7C8: using guessed type int stderr;
// 9F7D4: using guessed type int stdout;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AF0EC: using guessed type int dword_1AF0EC;
// 1AF0F0: using guessed type int dword_1AF0F0;
// 1AF0F4: using guessed type int dword_1AF0F4;
// 1AF0F8: using guessed type int dword_1AF0F8;
// 1AF124: using guessed type int dword_1AF124;
// 242E98: using guessed type int dword_242E98;
// 242EE8: using guessed type int dword_242EE8;
// 242EF0: using guessed type double dbl_242EF0;
// 242F10: using guessed type double dbl_242F10;
// 242F4C: using guessed type int dword_242F4C;
// 242FDC: using guessed type int dword_242FDC;
// 244014: using guessed type int dword_244014;
// 244048: using guessed type int dword_244048;
// 244080: using guessed type char byte_244080;
// 245140: using guessed type int dword_245140;
// 245150: using guessed type int dword_245150;
// 245158: using guessed type int dword_245158;
// 245228: using guessed type double dbl_245228;
// 24625C: using guessed type int dword_24625C;
// 246360: using guessed type int dword_246360;
// 246368: using guessed type __int64 qword_246368;
// 2463D0: using guessed type int dword_2463D0;

//----- (00057944) --------------------------------------------------------
int __fastcall sub_57944(int a1)
{
  int v2; // r5
  char *v3; // r0
  int result; // r0
  struct sysinfo info; // [sp+8h] [bp-844h] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  if ( !sysinfo(&info) )
  {
    dword_244004 = info.uptime;
    result = sub_4A60C((struct timeval *)&dword_1AF0EC);
    if ( a1 )
      return result;
    goto LABEL_8;
  }
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
  {
    v2 = *_errno_location();
    v3 = strerror(v2);
    snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v2, v3);
    sub_47AB4(6, s, 0);
  }
  dword_244004 = time(0);
  result = sub_4A60C((struct timeval *)&dword_1AF0EC);
  if ( !a1 )
  {
LABEL_8:
    if ( !byte_24511C )
    {
      if ( byte_1AECC6 )
        return sub_5658C();
    }
  }
  return result;
}
// 47AB4: using guessed type int __fastcall sub_47AB4(_DWORD, _DWORD, _DWORD);
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC6: using guessed type char byte_1AECC6;
// 1AF0EC: using guessed type int dword_1AF0EC;
// 244004: using guessed type int dword_244004;
// 244080: using guessed type char byte_244080;
// 24511C: using guessed type char byte_24511C;

//----- (00057A6C) --------------------------------------------------------
void sub_57A6C()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
  {
    snprintf(v0, 0x800u, "Attempting to restart %s", byte_1AECE4);
    sub_47AB4(4, v0, 0);
  }
  sub_4C084((int)sub_57F5C, 0, 5000);
  sub_57944(1);
  if ( dword_1AF0DC > 0 )
  {
    kill(dword_1AF0DC, 15);
    dword_1AF0DC = 0;
  }
  execv(*(const char **)dword_1AF128, (char *const *)dword_1AF128);
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
  {
    strcpy(v0, "Failed to restart application");
    sub_47AB4(4, v0, 0);
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AF0DC: using guessed type int dword_1AF0DC;
// 1AF128: using guessed type int dword_1AF128;
// 244080: using guessed type char byte_244080;

//----- (00057BAC) --------------------------------------------------------
int __fastcall sub_57BAC(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&stru_244028) )
    sub_561E4("get_thread", 604);
  v2 = *(_DWORD *)(dword_244024 + 4 * a1);
  if ( pthread_rwlock_unlock(&stru_244028) )
    sub_55C08("get_thread", 606);
  off_9E444();
  return v2;
}
// 9E444: using guessed type int (*off_9E444)();
// 244024: using guessed type int dword_244024;
// 244028: using guessed type pthread_rwlock_t stru_244028;

//----- (00057C20) --------------------------------------------------------
int __fastcall sub_57C20(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(sub_57BAC(a1) + 36) + 8);
}

//----- (00057C34) --------------------------------------------------------
bool sub_57C34()
{
  int v0; // r4
  int v1; // r0
  int v2; // r0
  int v3; // r3
  char v5[2052]; // [sp+0h] [bp-804h] BYREF

  if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 5 )
  {
    if ( !byte_1AECC5 )
      goto LABEL_7;
    goto LABEL_28;
  }
  strcpy(v5, "Received kill message");
  sub_47AB4(6, v5, 1);
  if ( byte_1AECC5 )
  {
    if ( byte_244080 || byte_1AECC4 )
    {
LABEL_6:
      strcpy(v5, "Killing off watchpool thread");
      sub_47AB4(7, v5, 1);
      goto LABEL_7;
    }
LABEL_28:
    if ( dword_9E320 <= 6 )
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_7:
  sub_4C084((int)sub_4A1F0, dword_245118, 1000);
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    strcpy(v5, "Killing off watchdog thread");
    sub_47AB4(7, v5, 1);
  }
  sub_4C084((int)sub_4A1F0, dword_245118, 1000);
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    strcpy(v5, "Shutting down mining threads");
    sub_47AB4(7, v5, 1);
  }
  if ( dword_245108 > 0 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      v2 = sub_57BAC(v1);
      if ( v2 )
      {
        v3 = *(_DWORD *)(v2 + 36);
        if ( v3 )
          *(_BYTE *)(v3 + 364) = 1;
      }
    }
    while ( v0 < dword_245108 );
  }
  sleep(1u);
  sub_4C084((int)sub_57F74, 0, 3000);
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    strcpy(v5, "Killing off API thread");
    sub_47AB4(7, v5, 1);
  }
  return sub_4C084((int)sub_4A1F0, dword_245118, 1000);
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;
// 245108: using guessed type int dword_245108;
// 245118: using guessed type int dword_245118;

//----- (00057F5C) --------------------------------------------------------
bool sub_57F5C()
{
  _BOOL4 result; // r0

  if ( byte_1AECC6 )
    return sub_57C34();
  return result;
}
// 1AECC6: using guessed type char byte_1AECC6;

//----- (00057F74) --------------------------------------------------------
void sub_57F74()
{
  int i; // r4
  int v1; // r0
  int v2; // r5
  pthread_t v3; // r0
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    strcpy(v4, "Killing off mining threads");
    sub_47AB4(7, v4, 1);
  }
  if ( dword_245108 > 0 )
  {
    for ( i = 0; dword_245108 > i; ++i )
    {
      while ( 1 )
      {
        v1 = sub_57BAC(i);
        v2 = v1;
        if ( v1 )
        {
          if ( *(_DWORD *)(v1 + 12) )
            break;
        }
        sub_4A1F0(v1);
LABEL_8:
        if ( dword_245108 <= ++i )
          return;
      }
      sub_4A1F0(v1);
      v3 = *(_DWORD *)(v2 + 12);
      if ( !v3 )
        goto LABEL_8;
      pthread_join(v3, 0);
    }
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;
// 245108: using guessed type int dword_245108;

//----- (00058084) --------------------------------------------------------
int sub_58084()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_2440BC) )
    sub_550B8("current_pool", 833);
  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_561E4("current_pool", 833);
  if ( pthread_mutex_unlock(&stru_2440BC) )
    sub_55114("current_pool", 833);
  v0 = dword_1AF12C;
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_55C08("current_pool", 837);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 1AF12C: using guessed type int dword_1AF12C;
// 2440BC: using guessed type pthread_mutex_t stru_2440BC;

//----- (0005812C) --------------------------------------------------------
int __fastcall sub_5812C(int a1, int a2, int a3)
{
  int v6; // r1
  unsigned int v7; // r2
  unsigned int v8; // r12
  int v9; // r4
  int v11; // r0

  if ( pthread_mutex_lock(&stru_246244) )
    sub_550B8("inc_work_stats", 8840);
  v6 = *(_DWORD *)(a1 + 36);
  v7 = *(_DWORD *)(v6 + 192);
  v8 = *(_DWORD *)(v6 + 196);
  qword_2463D0 += a3;
  *(_QWORD *)(v6 + 192) = __PAIR64__(v8, v7) + a3;
  if ( a2 )
  {
    *(_QWORD *)(a2 + 40) += a3;
  }
  else
  {
    v11 = sub_58084();
    *(_QWORD *)(v11 + 40) += a3;
  }
  v9 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v9 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_246244) )
    sub_55114("inc_work_stats", 8854);
  return off_9E444();
}
// 9E444: using guessed type int (*off_9E444)();
// 246244: using guessed type pthread_mutex_t stru_246244;
// 2463D0: using guessed type __int64 qword_2463D0;

//----- (0005821C) --------------------------------------------------------
int sub_5821C()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_2440BC) )
    sub_550B8("cp_prio", 7412);
  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_561E4("cp_prio", 7412);
  if ( pthread_mutex_unlock(&stru_2440BC) )
    sub_55114("cp_prio", 7412);
  v0 = *(_DWORD *)(dword_1AF12C + 4);
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_55C08("cp_prio", 7414);
  off_9E444();
  return v0;
}
// 9E444: using guessed type int (*off_9E444)();
// 1AF12C: using guessed type int dword_1AF12C;
// 2440BC: using guessed type pthread_mutex_t stru_2440BC;

//----- (000582C8) --------------------------------------------------------
void __fastcall sub_582C8(_DWORD *a1)
{
  int v2; // r3
  int v3; // r5
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v2 = dword_1AEEB8;
  a1[7] = 0;
  if ( v2 || (v3 = a1[1], v3 >= sub_5821C()) )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
    {
      snprintf(s, 0x800u, "Pool %d %s alive", *a1, (const char *)a1[41]);
      sub_47AB4(6, s, 0);
    }
  }
  else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
  {
    snprintf(s, 0x800u, "Pool %d %s alive, testing stability", *a1, (const char *)a1[41]);
    sub_47AB4(4, s, 0);
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AEEB8: using guessed type int dword_1AEEB8;
// 244080: using guessed type char byte_244080;

//----- (00058400) --------------------------------------------------------
void __fastcall sub_58400(_DWORD *a1)
{
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
  {
    snprintf(v2, 0x800u, "Stratum connection to pool %d resumed", *a1);
    sub_47AB4(6, v2, 0);
    sub_582C8(a1);
  }
  else
  {
    sub_582C8(a1);
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00058490) --------------------------------------------------------
void __fastcall sub_58490(int a1)
{
  if ( sub_551DC(a1, (_BYTE *)(a1 + 97)) )
    sub_58400((_DWORD *)a1);
}

//----- (000584B4) --------------------------------------------------------
int __fastcall sub_584B4(int a1)
{
  int v3; // r4

  if ( *(_DWORD *)(a1 + 100) != 1 )
    return 0;
  if ( (unsigned int)(dword_1AEEB8 - 3) <= 1 || *(_BYTE *)(a1 + 640) && *(_BYTE *)(a1 + 97) )
    return 1;
  if ( a1 == sub_58084() )
    return 1;
  if ( *(_DWORD *)(a1 + 732) )
    return 1;
  if ( !dword_1AEEB8 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 < sub_5821C() )
      return 1;
  }
  return (unsigned __int8)byte_1AF130;
}
// 1AEEB8: using guessed type int dword_1AEEB8;
// 1AF130: using guessed type char byte_1AF130;

//----- (00058548) --------------------------------------------------------
_BYTE *sub_58548()
{
  _BYTE *v0; // r0
  int v1; // r12
  _BYTE *v2; // r4
  int v3; // r1
  _DWORD *v4; // r0
  int v5; // r2
  int v7; // r3
  int v8; // r1
  int *v9; // r0
  int *v10; // r0
  int *v11; // r0
  int *v12; // r0
  int *v13; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v0 = sub_496AC(0x738u, 1u, "cgminer.c", "add_pool", 757);
  v1 = dword_242F4C;
  v2 = v0;
  *(_DWORD *)v0 = dword_242F4C;
  v3 = dword_242F4C;
  v0[644] = 0;
  *((_DWORD *)v0 + 1) = v1;
  v4 = sub_4973C((void *)dword_244048, 4 * (v3 + 2), "cgminer.c", "add_pool", 769);
  v5 = dword_242F4C;
  dword_244048 = (int)v4;
  ++dword_242F4C;
  v4[v5] = v2;
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 188), 0) )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v9, "cgminer.c", "add_pool", 772);
    goto LABEL_11;
  }
  if ( pthread_cond_init((pthread_cond_t *)(v2 + 296), 0) )
  {
    strcpy(s, "Failed to pthread_cond_init in add_pool");
    goto LABEL_11;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 212), 0) )
  {
    v10 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v10, "cgminer.c", "add_pool", 779);
    goto LABEL_11;
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v2 + 236), 0) )
  {
    v11 = _errno_location();
    v8 = 779;
    v7 = *v11;
    goto LABEL_10;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 704), 0) )
  {
    v12 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v12, "cgminer.c", "add_pool", 780);
    goto LABEL_11;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 740), 0) )
  {
    v13 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v13, "cgminer.c", "add_pool", 781);
LABEL_11:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v2 + 764), 0) )
  {
    v7 = *_errno_location();
    v8 = 781;
LABEL_10:
    snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", v7, "cgminer.c", "add_pool", v8);
    goto LABEL_11;
  }
  *((_DWORD *)v2 + 34) = -1;
  *((_DWORD *)v2 + 46) = 0;
  *((_DWORD *)v2 + 40) = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  *((_DWORD *)v2 + 86) = v2 + 344;
  *((_DWORD *)v2 + 87) = v2 + 344;
  *((_DWORD *)v2 + 14) = 1;
  sub_52B98();
  v2[580] = 0;
  return v2;
}
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00058794) --------------------------------------------------------
const char *__fastcall sub_58794(char *s)
{
  int v2; // r3
  _DWORD *v3; // r6
  char *v4; // r4
  char *v5; // r0
  char *v6; // r4

  if ( dword_1AF134 || dword_1AF138 )
    return "Use only user + pass or userpass, but not both";
  v2 = dword_1AF13C + 1;
  dword_1AF13C = v2;
  if ( v2 > dword_242F4C )
  {
    sub_58548();
    v2 = dword_1AF13C;
  }
  v3 = *(_DWORD **)(dword_244048 + 4 * (v2 + 0x3FFFFFFF));
  v4 = _strdup(s);
  sub_64370((int)s, v3 + 42);
  v5 = strtok(v4, ":");
  v3[43] = v5;
  if ( !v5 )
    return "Failed to find : delimited user info";
  v6 = strtok(0, ":");
  v3[44] = v6;
  if ( v6 )
    return 0;
  v3[44] = calloc(1u, 1u);
  return v6;
}
// 1AF134: using guessed type int dword_1AF134;
// 1AF138: using guessed type int dword_1AF138;
// 1AF13C: using guessed type int dword_1AF13C;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00058880) --------------------------------------------------------
const char *__fastcall sub_58880(int a1)
{
  int v3; // r3

  if ( dword_1AF13C )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_1AF134 + 1;
  dword_1AF134 = v3;
  if ( v3 > dword_242F4C )
  {
    sub_58548();
    v3 = dword_1AF134;
  }
  sub_64370(a1, (_DWORD *)(*(_DWORD *)(dword_244048 + 4 * (v3 + 0x3FFFFFFF)) + 172));
  return 0;
}
// 1AF134: using guessed type int dword_1AF134;
// 1AF13C: using guessed type int dword_1AF13C;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (000588FC) --------------------------------------------------------
int sub_588FC()
{
  int v0; // r3

  v0 = ++dword_1AF140;
  if ( dword_1AF140 > dword_242F4C )
  {
    sub_58548();
    v0 = dword_1AF140;
  }
  return *(_DWORD *)(dword_244048 + 4 * (v0 + 0x3FFFFFFF));
}
// 1AF140: using guessed type int dword_1AF140;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00058B64) --------------------------------------------------------
const char *__fastcall sub_58B64(int a1)
{
  int v3; // r3

  if ( dword_1AF13C )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_1AF138 + 1;
  dword_1AF138 = v3;
  if ( v3 > dword_242F4C )
  {
    sub_58548();
    v3 = dword_1AF138;
  }
  sub_64370(a1, (_DWORD *)(*(_DWORD *)(dword_244048 + 4 * (v3 + 0x3FFFFFFF)) + 176));
  return 0;
}
// 1AF138: using guessed type int dword_1AF138;
// 1AF13C: using guessed type int dword_1AF13C;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;

//----- (00058BE0) --------------------------------------------------------
int sub_58BE0()
{
  int v0; // r3
  int v1; // r4
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = ++dword_1AF144;
  if ( dword_1AF144 > dword_242F4C )
  {
    sub_58548();
    v0 = dword_1AF144;
  }
  v1 = *(_DWORD *)(dword_244048 + 4 * (v0 + 0x3FFFFFFF));
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(v3, 0x800u, "Enable extranonce subscribe on %d", *(_DWORD *)v1);
    sub_47AB4(7, v3, 0);
  }
  sub_6428C((_BYTE *)(v1 + 580));
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AF144: using guessed type int dword_1AF144;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;
// 244080: using guessed type char byte_244080;

//----- (00058CC0) --------------------------------------------------------
void __fastcall sub_58CC0(pthread_rwlock_t *a1)
{
  void **nr_readers; // r2
  int *v3; // r0
  void **v4; // [sp+14h] [bp-808h] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v4 = 0;
  if ( a1 && !pthread_rwlock_trywrlock(a1 + 10) )
  {
    nr_readers = (void **)a1[11].__nr_readers;
    a1[11].__nr_readers = 0;
    v4 = nr_readers;
    if ( pthread_rwlock_unlock(a1 + 10) )
    {
      v3 = _errno_location();
      snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "cgminer.c", "flush_queue", 9635);
      sub_47AB4(3, s, 1);
      sub_54CCC(1, 1);
    }
    off_9E444();
    if ( v4 )
    {
      sub_53084(&v4, "cgminer.c", "flush_queue", 9639);
      if ( byte_1AECC5 )
      {
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
        {
          strcpy(s, "Discarded queued work item");
          sub_47AB4(7, s, 0);
        }
      }
    }
  }
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 244080: using guessed type char byte_244080;

//----- (00058E30) --------------------------------------------------------
int sub_58E30()
{
  int v0; // r4
  char *v1; // r0
  int *v2; // r3
  int *v3; // r12
  int v4; // lr
  int v5; // t1
  int result; // r0
  int v7; // r5
  int v8; // r4
  int *v9; // r0
  int *v10; // r0
  struct sysinfo info; // [sp+10h] [bp-840h] BYREF
  char s[2048]; // [sp+50h] [bp-800h] BYREF

  if ( sysinfo(&info) )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
    {
      v0 = *_errno_location();
      v1 = strerror(v0);
      snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
      sub_47AB4(6, s, 0);
    }
    dword_242EA0 = time(0);
  }
  else
  {
    dword_242EA0 = info.uptime;
  }
  sub_4A60C((struct timeval *)&dword_1AF0F4);
  sub_4C460(algn_1AF148, &dword_1AF0F4);
  v2 = (int *)&unk_1AF150;
  dbl_245110 = 0.0;
  dbl_245210 = 0.0;
  dbl_245208 = 0.0;
  dbl_245218 = 0.0;
  dbl_245228 = 0.0;
  dbl_2463B0 = 0.0;
  do
  {
    *(_QWORD *)v2 = 0;
    v2 += 2;
  }
  while ( v2 != &dword_1AF1B0 );
  dbl_9ED88 = 1.0;
  dbl_9ED68 = 1.0;
  dbl_9ED80 = 1.0;
  dword_242EE8 = 0;
  dword_1AF1B0 = 0;
  dword_245100 = 0;
  dword_245104 = 0;
  dword_246360 = 0;
  dword_242FDC = 0;
  dword_245150 = 0;
  dword_244014 = 0;
  *(_QWORD *)&dword_245168 = 0;
  *(_QWORD *)&dword_245158 = 0;
  qword_246368 = 0;
  *(_QWORD *)&dword_242E98 = 0;
  *(_QWORD *)&dword_242F00 = 0;
  *(_QWORD *)&dword_2463D0 = 0;
  dbl_242EF0 = 0.0;
  dbl_242F10 = 0.0;
  dbl_246238 = 0.0;
  if ( dword_242F4C > 0 )
  {
    v3 = (int *)dword_244048;
    v4 = dword_244048 + 4 * dword_242F4C;
    do
    {
      v5 = *v3++;
      *(_DWORD *)(v5 + 116) = 0;
      *(_QWORD *)(v5 + 8) = 0;
      *(_QWORD *)(v5 + 16) = 0;
      *(_DWORD *)(v5 + 120) = 0;
      *(_DWORD *)(v5 + 124) = 0;
      *(_DWORD *)(v5 + 128) = 0;
      *(_DWORD *)(v5 + 132) = 0;
      *(_DWORD *)(v5 + 352) = 0;
      *(_QWORD *)(v5 + 40) = 0;
      *(_QWORD *)(v5 + 72) = 0;
      *(_QWORD *)(v5 + 80) = 0;
      *(_QWORD *)(v5 + 88) = 0;
      *(_DWORD *)(v5 + 360) = 0;
      *(_DWORD *)(v5 + 364) = 0;
    }
    while ( (int *)v4 != v3 );
  }
  result = sub_53C3C();
  if ( dword_245140 > 0 )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = sub_56518(v7);
      sub_4C460((void *)(v8 + 368), &dword_1AF0F4);
      if ( pthread_mutex_lock(&stru_2463B8) )
        break;
      *(_QWORD *)(v8 + 80) = 0;
      *(_DWORD *)(v8 + 36) = 0;
      *(_DWORD *)(v8 + 40) = 0;
      *(_DWORD *)(v8 + 44) = 0;
      *(_QWORD *)(v8 + 88) = 0;
      *(_DWORD *)(v8 + 220) = 0;
      *(_QWORD *)(v8 + 200) = 0;
      *(_QWORD *)(v8 + 208) = 0;
      *(_QWORD *)(v8 + 224) = 0;
      *(_QWORD *)(v8 + 192) = 0;
      if ( pthread_mutex_unlock(&stru_2463B8) )
      {
        v10 = _errno_location();
        snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v10, "cgminer.c", "zero_stats", 6182);
LABEL_19:
        sub_47AB4(3, s, 1);
        sub_54CCC(1, 1);
      }
      ++v7;
      off_9E444();
      result = (*(int (__fastcall **)(int))(*(_DWORD *)(v8 + 4) + 96))(v8);
      if ( dword_245140 <= v7 )
        return result;
    }
    v9 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "cgminer.c", "zero_stats", 6169);
    goto LABEL_19;
  }
  return result;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9ED68: using guessed type double dbl_9ED68;
// 9ED80: using guessed type double dbl_9ED80;
// 9ED88: using guessed type double dbl_9ED88;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AF0F4: using guessed type int dword_1AF0F4;
// 1AF148: using guessed type _BYTE[8];
// 1AF1B0: using guessed type int dword_1AF1B0;
// 242E98: using guessed type int dword_242E98;
// 242EA0: using guessed type int dword_242EA0;
// 242EE8: using guessed type int dword_242EE8;
// 242EF0: using guessed type double dbl_242EF0;
// 242F00: using guessed type int dword_242F00;
// 242F10: using guessed type double dbl_242F10;
// 242F4C: using guessed type int dword_242F4C;
// 242FDC: using guessed type int dword_242FDC;
// 244014: using guessed type int dword_244014;
// 244048: using guessed type int dword_244048;
// 244080: using guessed type char byte_244080;
// 245100: using guessed type int dword_245100;
// 245104: using guessed type int dword_245104;
// 245110: using guessed type double dbl_245110;
// 245140: using guessed type int dword_245140;
// 245150: using guessed type int dword_245150;
// 245158: using guessed type int dword_245158;
// 245168: using guessed type int dword_245168;
// 245208: using guessed type double dbl_245208;
// 245210: using guessed type double dbl_245210;
// 245218: using guessed type double dbl_245218;
// 245228: using guessed type double dbl_245228;
// 246238: using guessed type double dbl_246238;
// 246360: using guessed type int dword_246360;
// 246368: using guessed type __int64 qword_246368;
// 2463B0: using guessed type double dbl_2463B0;
// 2463B8: using guessed type pthread_mutex_t stru_2463B8;
// 2463D0: using guessed type int dword_2463D0;

//----- (00059234) --------------------------------------------------------
int __fastcall sub_59234(int a1, int a2)
{
  int v4; // r12
  int v5; // r1
  int result; // r0
  int (__fastcall *v7)(int); // r3
  int *v8; // r0
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
  {
    snprintf(
      s,
      0x800u,
      "%s%d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_47AB4(3, s, 0);
  }
  if ( pthread_mutex_lock(&stru_246244) )
  {
    v8 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v8,
      "cgminer.c",
      "inc_hw_errors_with_diff",
      8764);
    goto LABEL_12;
  }
  v4 = *(_DWORD *)(a1 + 36);
  v5 = *(_DWORD *)(v4 + 44) + a2;
  dword_242EE8 += a2;
  *(_DWORD *)(v4 + 44) = v5;
  if ( pthread_mutex_unlock(&stru_246244) )
  {
    v9 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v9,
      "cgminer.c",
      "inc_hw_errors_with_diff",
      8767);
LABEL_12:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  result = off_9E444();
  v7 = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84);
  if ( v7 )
    return v7(a1);
  return result;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 242EE8: using guessed type int dword_242EE8;
// 244080: using guessed type char byte_244080;
// 246244: using guessed type pthread_mutex_t stru_246244;

//----- (000593C8) --------------------------------------------------------
int __fastcall sub_593C8(int a1)
{
  int v2; // r12
  int v3; // r2
  int result; // r0
  int (__fastcall *v5)(int); // r3
  int *v6; // r0
  int *v7; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
  {
    snprintf(
      s,
      0x800u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_47AB4(6, s, 0);
  }
  if ( pthread_mutex_lock(&stru_246244) )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "cgminer.c", "inc_hw_errors", 8750);
    goto LABEL_12;
  }
  v2 = *(_DWORD *)(a1 + 36);
  v3 = *(_DWORD *)(v2 + 44) + 1;
  ++dword_242EE8;
  *(_DWORD *)(v2 + 44) = v3;
  if ( pthread_mutex_unlock(&stru_246244) )
  {
    v7 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v7, "cgminer.c", "inc_hw_errors", 8753);
LABEL_12:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  result = off_9E444();
  v5 = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84);
  if ( v5 )
    return v5(a1);
  return result;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 242EE8: using guessed type int dword_242EE8;
// 244080: using guessed type char byte_244080;
// 246244: using guessed type pthread_mutex_t stru_246244;

//----- (00059550) --------------------------------------------------------
unsigned __int64 __fastcall sub_59550(int a1)
{
  double v2; // r0
  double v3; // d8
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d6
  double v8; // r0
  double v9; // d8
  unsigned __int64 v10; // r6
  int v11; // r8
  unsigned __int64 *v12; // r3
  int *v14; // r0
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  LODWORD(v2) = sub_778A4(*(_QWORD *)(a1 + 216));
  v3 = v2 * 6.27710174e57;
  LODWORD(v4) = sub_778A4(*(_QWORD *)(a1 + 208));
  v5 = v3 + v4 * 3.40282367e38;
  LODWORD(v6) = sub_778A4(*(_QWORD *)(a1 + 200));
  v7 = v6;
  LODWORD(v8) = sub_778A4(*(_QWORD *)(a1 + 192));
  v9 = v8 + v5 + v7 * 1.84467441e19;
  if ( v9 == 0.0 )
    v9 = 0.0;
  round();
  v10 = (unsigned __int64)(2.69595353e67 / v9);
  if ( pthread_mutex_lock(&stru_2440BC) )
  {
    v14 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v14, "cgminer.c", "share_diff", 5145);
    goto LABEL_14;
  }
  v11 = pthread_rwlock_wrlock(&rwlock);
  if ( v11 )
  {
    v15 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v15, "cgminer.c", "share_diff", 5145);
    goto LABEL_14;
  }
  if ( qword_1AF0D0 < v10 )
  {
    qword_1AF0D0 = (unsigned __int64)(2.69595353e67 / v9);
    v11 = 1;
    sub_51B18(v10, dword_9ED70, 8u, 0);
  }
  v12 = (unsigned __int64 *)(*(_DWORD *)(a1 + 260) + 368);
  if ( *v12 < v10 )
    *v12 = v10;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v16 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v16, "cgminer.c", "share_diff", 5159);
    goto LABEL_14;
  }
  if ( pthread_mutex_unlock(&stru_2440BC) )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "share_diff", 5159);
LABEL_14:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  off_9E444();
  if ( v11 && (byte_244080 || byte_1AECC4 || dword_9E320 > 5) )
  {
    snprintf(s, 0x800u, "New best share: %s", dword_9ED70);
    sub_47AB4(6, s, 0);
  }
  return (unsigned __int64)(2.69595353e67 / v9);
}
// 59574: variable 'v2' is possibly undefined
// 59588: variable 'v4' is possibly undefined
// 59594: variable 'v6' is possibly undefined
// 595AC: variable 'v8' is possibly undefined
// 12274: using guessed type int round(void);
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AF0D0: using guessed type __int64 qword_1AF0D0;
// 244080: using guessed type char byte_244080;
// 2440BC: using guessed type pthread_mutex_t stru_2440BC;

//----- (00059820) --------------------------------------------------------
int __fastcall sub_59820(int *a1, int a2)
{
  double v4; // d8
  unsigned __int64 v5; // r0
  double v6; // r0
  double v7; // d8
  double v8; // r0
  int v9; // r5
  double v10; // r0
  int v11; // r5
  double v12; // r0
  int v13; // r4
  int v15; // r12
  int v16; // r2
  bool v17; // zf
  int v18; // r2
  int *v19; // r0
  int *v20; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = dbl_9ED90;
  v5 = sub_59550(a2);
  *(_QWORD *)(a2 + 232) = v5;
  LODWORD(v6) = sub_778A4(v5);
  if ( v4 <= v6 )
  {
    v15 = *(_DWORD *)(a2 + 260);
    v16 = (unsigned __int8)byte_244080;
    *(_BYTE *)(a2 + 283) = 1;
    v17 = v16 == 0;
    v18 = dword_242FDC + 1;
    ++*(_DWORD *)(v15 + 32);
    dword_242FDC = v18;
    *(_BYTE *)(a2 + 282) = 1;
    if ( !v17 || byte_1AECC4 || dword_9E320 > 4 )
    {
      snprintf(s, 0x800u, "Found block for pool %d!", **(_DWORD **)(a2 + 260));
      sub_47AB4(5, s, 0);
    }
  }
  if ( pthread_mutex_lock(&stru_246244) )
  {
    v19 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v19, "cgminer.c", "update_work_stats", 8830);
    goto LABEL_10;
  }
  v7 = *(double *)(a2 + 224);
  LODWORD(v8) = sub_778B4(qword_2463D0);
  qword_2463D0 = (__int64)(v8 + v7);
  v9 = *a1;
  LODWORD(v10) = sub_778B4(*(_QWORD *)(*a1 + 192));
  *(_QWORD *)(v9 + 192) = (__int64)(v10 + v7);
  v11 = *(_DWORD *)(a2 + 260);
  LODWORD(v12) = sub_778B4(*(_QWORD *)(v11 + 40));
  *(_QWORD *)(v11 + 40) = (__int64)(v12 + *(double *)(a2 + 224));
  v13 = *a1;
  *(_DWORD *)(v13 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_246244) )
  {
    v20 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v20,
      "cgminer.c",
      "update_work_stats",
      8835);
LABEL_10:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  return off_9E444();
}
// 5985C: variable 'v6' is possibly undefined
// 59890: variable 'v8' is possibly undefined
// 598B0: variable 'v10' is possibly undefined
// 598D4: variable 'v12' is possibly undefined
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9ED90: using guessed type double dbl_9ED90;
// 1AECC4: using guessed type char byte_1AECC4;
// 242FDC: using guessed type int dword_242FDC;
// 244080: using guessed type char byte_244080;
// 246244: using guessed type pthread_mutex_t stru_246244;
// 2463D0: using guessed type __int64 qword_2463D0;

//----- (00059A4C) --------------------------------------------------------
int __fastcall sub_59A4C(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  bool v4; // zf
  _DWORD *v5; // r5
  int v8; // r4
  char v10[2048]; // [sp+0h] [bp-800h] BYREF

  v5 = a4;
  v4 = a4 == 0;
  if ( a4 )
    a4 = 0;
  if ( !v4 )
    *v5 = a4;
  a2[19] = a3;
  sub_51DD0((int)a2);
  if ( a2[55] )
  {
    sub_593C8(a1);
    return 0;
  }
  else
  {
    sub_59820((int *)(a1 + 36), (int)a2);
    v8 = sub_49D78(a2 + 48, a2 + 40);
    if ( !v8 )
    {
      if ( v5 )
        *v5 = 1;
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        strcpy(v10, "Share above target");
        sub_47AB4(6, v10, 0);
      }
      else
      {
        return (unsigned __int8)byte_1AECC4;
      }
    }
    return v8;
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00059B44) --------------------------------------------------------
void __fastcall sub_59B44(_DWORD *a1)
{
  int v2; // r7
  _DWORD *v3; // r3
  int v4; // r4
  int v5; // r10
  int v6; // r1
  int v7; // r0
  int v8; // r2
  _DWORD *v9; // r12
  int v10; // r9
  _DWORD *v11; // r0
  int v12; // r2
  int v13; // r0
  _DWORD *v14; // lr
  int v15; // r0
  int v16; // r2
  int *v17; // r0
  int *v18; // r0
  void **v19; // [sp+14h] [bp-804h] BYREF
  char s[2048]; // [sp+18h] [bp-800h] BYREF

  v2 = pthread_mutex_lock((pthread_mutex_t *)dword_1AF0E4);
  if ( v2 )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "clear_pool_work", 7392);
    goto LABEL_37;
  }
  v3 = (_DWORD *)dword_1AF1B4;
  v19 = (void **)dword_1AF1B4;
  if ( !dword_1AF1B4 )
  {
    if ( !pthread_mutex_unlock((pthread_mutex_t *)dword_1AF0E4) )
    {
      off_9E444();
      return;
    }
    goto LABEL_38;
  }
  v4 = *(_DWORD *)(dword_1AF1B4 + 352);
  if ( *(_DWORD **)(dword_1AF1B4 + 260) == a1 )
    goto LABEL_6;
LABEL_4:
  v19 = (void **)v4;
  if ( v4 )
  {
    while ( 1 )
    {
      v3 = (_DWORD *)v4;
      v4 = *(_DWORD *)(v4 + 352);
      if ( (_DWORD *)v3[65] != a1 )
        goto LABEL_4;
LABEL_6:
      v5 = v3[87];
      v6 = dword_1AF1B4;
      v7 = *(_DWORD *)(dword_1AF1B4 + 344);
      if ( v5 )
        break;
      v10 = v3[88];
      if ( v10 )
      {
        v8 = *(_DWORD *)(v7 + 20);
        v9 = v3 + 86;
        if ( v3 != (_DWORD *)(*(_DWORD *)(v7 + 16) - v8) )
          goto LABEL_29;
LABEL_30:
        *(_DWORD *)(v7 + 16) = v5 + v8;
        v5 = v3[87];
        if ( v5 )
        {
          v8 = *(_DWORD *)(*(_DWORD *)(v6 + 344) + 20);
          goto LABEL_8;
        }
        v10 = v3[88];
LABEL_29:
        v6 = v10;
        dword_1AF1B4 = v10;
LABEL_9:
        v11 = *(_DWORD **)(v6 + 344);
        if ( v10 )
        {
          *(_DWORD *)(v10 + v11[5] + 4) = v3[87];
          v11 = *(_DWORD **)(v6 + 344);
        }
        v12 = 3 * ((v11[1] - 1) & v3[93]);
        --*(_DWORD *)(*v11 + 4 * v12 + 4);
        v13 = **(_DWORD **)(v6 + 344);
        v14 = *(_DWORD **)(v13 + 4 * v12);
        if ( v14 == v9 )
        {
          v6 = v3[90];
          *(_DWORD *)(v13 + 4 * v12) = v6;
        }
        v15 = v3[89];
        v16 = v3[90];
        if ( v14 == v9 )
          v6 = dword_1AF1B4;
        if ( v15 )
        {
          *(_DWORD *)(v15 + 16) = v16;
          v16 = v3[90];
        }
        if ( v16 )
          *(_DWORD *)(v16 + 12) = v3[89];
        --*(_DWORD *)(*(_DWORD *)(v6 + 344) + 12);
        goto LABEL_20;
      }
      free(*(void **)v7);
      free(*(void **)(dword_1AF1B4 + 344));
      dword_1AF1B4 = 0;
LABEL_20:
      ++v2;
      sub_53084(&v19, "cgminer.c", "clear_pool_work", 7398);
      v19 = (void **)v4;
      if ( !v4 )
        goto LABEL_21;
    }
    v8 = *(_DWORD *)(v7 + 20);
    v9 = v3 + 86;
    if ( v3 == (_DWORD *)(*(_DWORD *)(v7 + 16) - v8) )
      goto LABEL_30;
LABEL_8:
    *(_DWORD *)(v5 + v8 + 8) = v3[88];
    v10 = v3[88];
    goto LABEL_9;
  }
LABEL_21:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_1AF0E4) )
  {
LABEL_38:
    v18 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v18, "cgminer.c", "clear_pool_work", 7402);
LABEL_37:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  off_9E444();
  if ( v2 && (byte_244080 || byte_1AECC4 || dword_9E320 > 5) )
  {
    snprintf(s, 0x800u, "Cleared %d work items due to stratum disconnect on pool %d", v2, *a1);
    sub_47AB4(6, s, 0);
  }
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AF0E4: using guessed type int dword_1AF0E4;
// 1AF1B4: using guessed type int dword_1AF1B4;
// 244080: using guessed type char byte_244080;

//----- (00059E6C) --------------------------------------------------------
int __fastcall sub_59E6C(int a1)
{
  int v2; // r9
  _DWORD *v3; // r6
  int v4; // lr
  int v5; // r7
  int v6; // r11
  int v7; // r0
  int v8; // r12
  int *v9; // r2
  int v10; // r0
  int v11; // r1
  int v12; // t1
  int v13; // r3
  int v14; // r0
  int v15; // r5
  int v17; // r3
  int v18; // r2
  int *v19; // r0
  int v20; // r3
  int v21; // r12
  int *v22; // r0
  int *v23; // r0
  int v24; // r3
  int v25; // r12
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_2440BC) )
  {
    v20 = *_errno_location();
    v21 = 5238;
LABEL_55:
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v20, "cgminer.c", "switch_pools", v21);
    goto LABEL_56;
  }
  v2 = pthread_rwlock_wrlock(&rwlock);
  if ( v2 )
  {
    v22 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v22, "cgminer.c", "switch_pools", 5238);
    goto LABEL_56;
  }
  v3 = (_DWORD *)dword_1AF12C;
  v4 = dword_1AEEB8;
  v5 = *(_DWORD *)dword_1AF12C;
  if ( a1 )
  {
    v6 = *(_DWORD *)(a1 + 4);
    if ( v6 )
    {
      v7 = dword_242F4C;
      if ( dword_242F4C > 0 )
      {
        v8 = dword_244048;
        v9 = (int *)dword_244048;
        v10 = dword_244048 + 4 * dword_242F4C;
        while ( 1 )
        {
          v12 = *v9++;
          v11 = v12;
          v13 = *(_DWORD *)(v12 + 4);
          if ( v13 < v6 )
            *(_DWORD *)(v11 + 4) = v13 + 1;
          if ( (int *)v10 == v9 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            switch ( v4 )
            {
              case 0:
              case 3:
              case 4:
                goto LABEL_15;
              case 1:
              case 2:
                goto LABEL_38;
              default:
                goto LABEL_53;
            }
          }
          v6 = *(_DWORD *)(a1 + 4);
        }
      }
      *(_DWORD *)(a1 + 4) = 0;
      switch ( v4 )
      {
        case 0:
        case 3:
        case 4:
          goto LABEL_14;
        case 1:
        case 2:
          goto LABEL_37;
        default:
          goto LABEL_24;
      }
    }
    switch ( dword_1AEEB8 )
    {
      case 0:
      case 3:
      case 4:
        goto LABEL_13;
      case 1:
      case 2:
LABEL_37:
        v8 = dword_244048;
LABEL_38:
        if ( *(_BYTE *)(a1 + 97) )
          goto LABEL_41;
        v15 = *(_DWORD *)(v8 + 4 * *(_DWORD *)a1);
        break;
      default:
        goto LABEL_24;
    }
  }
  else
  {
    switch ( dword_1AEEB8 )
    {
      case 0:
      case 3:
      case 4:
LABEL_13:
        v7 = dword_242F4C;
LABEL_14:
        if ( v7 <= 0 )
          goto LABEL_24;
        do
        {
LABEL_15:
          v14 = sub_51EEC(v2);
          if ( !*(_BYTE *)(v14 + 97)
            && *(_DWORD *)(v14 + 100) == 1
            && (!*(_BYTE *)(v14 + 640) || *(_BYTE *)(v14 + 641) && *(_BYTE *)(v14 + 643)) )
          {
            v15 = *(_DWORD *)(dword_244048 + 4 * *(_DWORD *)v14);
            goto LABEL_25;
          }
          ++v2;
        }
        while ( dword_242F4C > v2 );
        v15 = *(_DWORD *)(dword_244048 + 4 * v5);
        break;
      case 1:
      case 2:
        v8 = dword_244048;
LABEL_41:
        if ( dword_242F4C <= 1 )
        {
LABEL_53:
          v15 = *(_DWORD *)(v8 + 4 * v5);
        }
        else
        {
          v17 = v5;
          v18 = 1;
          while ( 1 )
          {
            if ( ++v17 >= dword_242F4C )
            {
              v19 = (int *)v8;
              v17 = 0;
            }
            else
            {
              v19 = (int *)(v8 + 4 * v17);
            }
            v15 = *v19;
            if ( !*(_BYTE *)(*v19 + 97)
              && *(_DWORD *)(v15 + 100) == 1
              && (!*(_BYTE *)(v15 + 640) || *(_BYTE *)(v15 + 641) && *(_BYTE *)(v15 + 643)) )
            {
              break;
            }
            if ( ++v18 == dword_242F4C )
              goto LABEL_53;
          }
        }
        break;
      default:
LABEL_24:
        v15 = *(_DWORD *)(dword_244048 + 4 * v5);
        break;
    }
  }
LABEL_25:
  dword_1AF12C = v15;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v23 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v23, "cgminer.c", "switch_pools", 5319);
    goto LABEL_56;
  }
  if ( pthread_mutex_unlock(&stru_2440BC) )
  {
    v24 = *_errno_location();
    v25 = 5319;
LABEL_60:
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v24, "cgminer.c", "switch_pools", v25);
LABEL_56:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  off_9E444();
  if ( v3 != (_DWORD *)v15 && (unsigned int)(dword_1AEEB8 - 3) > 1 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
    {
      snprintf(s, 0x800u, "Switching to pool %d %s", *(_DWORD *)v15, *(const char **)(v15 + 164));
      sub_47AB4(4, s, 0);
    }
    sub_59B44(v3);
  }
  if ( pthread_mutex_lock(&stru_1AF1B8) )
  {
    v20 = *_errno_location();
    v21 = 5327;
    goto LABEL_55;
  }
  pthread_cond_broadcast(&cond);
  if ( pthread_mutex_unlock(&stru_1AF1B8) )
  {
    v24 = *_errno_location();
    v25 = 5329;
    goto LABEL_60;
  }
  return off_9E444();
}
// 59F24: control flows out of bounds to 59F28
// 59F44: control flows out of bounds to 59F48
// 59FF0: control flows out of bounds to 59FF4
// 5A2F4: control flows out of bounds to 5A2F8
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AEEB8: using guessed type int dword_1AEEB8;
// 1AF12C: using guessed type int dword_1AF12C;
// 242F4C: using guessed type int dword_242F4C;
// 244048: using guessed type int dword_244048;
// 244080: using guessed type char byte_244080;
// 2440BC: using guessed type pthread_mutex_t stru_2440BC;

//----- (0005A31C) --------------------------------------------------------
void __fastcall sub_5A31C(int a1)
{
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( !sub_55170(a1, (_BYTE *)(a1 + 97)) )
  {
    sub_4A60C((struct timeval *)(a1 + 136));
    if ( a1 == sub_58084() )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
      {
        snprintf(s, 0x800u, "Pool %d %s not responding!", *(_DWORD *)a1, *(const char **)(a1 + 164));
        sub_47AB4(4, s, 0);
      }
      sub_59E6C(0);
    }
    else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
    {
      snprintf(s, 0x800u, "Pool %d %s failed to return work", *(_DWORD *)a1, *(const char **)(a1 + 164));
      sub_47AB4(6, s, 0);
    }
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0005A44C) --------------------------------------------------------
int *__fastcall sub_5A44C(int a1)
{
  int v2; // r8
  int v3; // r4
  int v4; // r5
  double v5; // d8
  int v6; // r0
  void **v7; // r11
  int v8; // r1
  __int64 v9; // r2
  __int64 v11; // r2
  int *result; // r0
  double v13; // d6
  double v14; // d8
  __int64 v15; // r4
  int v16; // r8
  int *v17; // r0
  int *v18; // r0
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v2 = pthread_mutex_lock(&stru_1AF200);
  if ( v2 )
  {
    v17 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v17,
      "cgminer.c",
      "clear_stratum_shares",
      7361);
    goto LABEL_36;
  }
  v3 = dword_1AF218;
  if ( !dword_1AF218 )
  {
    if ( !pthread_mutex_unlock(&stru_1AF200) )
      return (int *)off_9E444();
    goto LABEL_37;
  }
  v4 = *(_DWORD *)(dword_1AF218 + 8);
  v5 = 0.0;
  if ( *(_DWORD *)(*(_DWORD *)(dword_1AF218 + 36) + 260) == a1 )
    goto LABEL_6;
LABEL_4:
  if ( v4 )
  {
    while ( 1 )
    {
      v3 = v4;
      v4 = *(_DWORD *)(v4 + 8);
      if ( *(_DWORD *)(*(_DWORD *)(v3 + 36) + 260) != a1 )
        goto LABEL_4;
LABEL_6:
      v6 = *(_DWORD *)(v3 + 4);
      v7 = (void **)dword_1AF218;
      v8 = *(_DWORD *)dword_1AF218;
      if ( v6 )
        break;
      LODWORD(v9) = *(_DWORD *)(v3 + 8);
      if ( (_DWORD)v9 )
      {
        HIDWORD(v9) = *(_DWORD *)(v8 + 20);
        if ( v3 != *(_DWORD *)(v8 + 16) - HIDWORD(v9) )
          goto LABEL_30;
LABEL_28:
        *(_DWORD *)(v8 + 16) = v6 + HIDWORD(v9);
        v6 = *(_DWORD *)(v3 + 4);
        if ( !v6 )
        {
          LODWORD(v9) = *(_DWORD *)(v3 + 8);
LABEL_30:
          HIDWORD(v9) = v9;
          v7 = (void **)v9;
          dword_1AF218 = v9;
LABEL_9:
          LODWORD(v9) = *v7;
          if ( HIDWORD(v9) )
          {
            *(_DWORD *)(HIDWORD(v9) + *(_DWORD *)(v9 + 20) + 4) = *(_DWORD *)(v3 + 4);
            LODWORD(v9) = *v7;
          }
          HIDWORD(v9) = 3 * ((*(_DWORD *)(v9 + 4) - 1) & *(_DWORD *)(v3 + 28));
          --*(_DWORD *)(*(_DWORD *)v9 + 4 * HIDWORD(v9) + 4);
          LODWORD(v9) = *(_DWORD *)*v7;
          if ( *(_DWORD *)(v9 + 4 * HIDWORD(v9)) == v3 )
            *(_DWORD *)(v9 + 4 * HIDWORD(v9)) = *(_DWORD *)(v3 + 16);
          v11 = *(_QWORD *)(v3 + 12);
          if ( (_DWORD)v11 )
          {
            *(_DWORD *)(v11 + 16) = HIDWORD(v11);
            HIDWORD(v11) = *(_DWORD *)(v3 + 16);
          }
          if ( HIDWORD(v11) )
            *(_DWORD *)(HIDWORD(v11) + 12) = *(_DWORD *)(v3 + 12);
          --*((_DWORD *)*v7 + 3);
          goto LABEL_18;
        }
        HIDWORD(v9) = *((_DWORD *)*v7 + 5);
LABEL_8:
        *(_DWORD *)(v6 + HIDWORD(v9) + 8) = *(_DWORD *)(v3 + 8);
        HIDWORD(v9) = *(_DWORD *)(v3 + 8);
        goto LABEL_9;
      }
      free(*(void **)v8);
      free(*v7);
      dword_1AF218 = 0;
LABEL_18:
      ++v2;
      v5 = v5 + *(double *)(*(_DWORD *)(v3 + 36) + 376);
      sub_53084((void ***)(v3 + 36), "cgminer.c", "clear_stratum_shares", 7369);
      --*(_DWORD *)(a1 + 732);
      free((void *)v3);
      if ( !v4 )
        goto LABEL_19;
    }
    v9 = *(_QWORD *)(v8 + 16);
    if ( v3 == (_DWORD)v9 - HIDWORD(v9) )
      goto LABEL_28;
    goto LABEL_8;
  }
LABEL_19:
  if ( pthread_mutex_unlock(&stru_1AF200) )
  {
LABEL_37:
    v18 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v18,
      "cgminer.c",
      "clear_stratum_shares",
      7375);
LABEL_36:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  result = (int *)off_9E444();
  if ( v2 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
    {
      snprintf(s, 0x800u, "Lost %d shares due to stratum disconnect on pool %d", v2, *(_DWORD *)a1);
      sub_47AB4(4, s, 0);
    }
    result = &dword_242E98;
    v13 = *(double *)(a1 + 88) + v5;
    v14 = dbl_246238 + v5;
    v15 = *(_QWORD *)&dword_242E98 + v2;
    v16 = *(_DWORD *)(a1 + 120) + v2;
    *(double *)(a1 + 88) = v13;
    *(_QWORD *)&dword_242E98 = v15;
    *(_DWORD *)(a1 + 120) = v16;
    dbl_246238 = v14;
  }
  return result;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AF218: using guessed type int dword_1AF218;
// 242E98: using guessed type int dword_242E98;
// 244080: using guessed type char byte_244080;
// 246238: using guessed type double dbl_246238;

//----- (0005A7E8) --------------------------------------------------------
int __fastcall sub_5A7E8(int a1, int a2)
{
  pthread_mutex_t *v2; // r8
  size_t v5; // r11
  int v6; // lr
  int v7; // r0
  int v8; // r3
  int v9; // r2
  int v10; // r6
  const void *v11; // r1
  int *v12; // r2
  char *v13; // r0
  unsigned int v14; // t1
  int v15; // r1
  int *v16; // r2
  unsigned int v17; // t1
  double v18; // d8
  int v19; // r0
  double v20; // r0
  double v21; // d8
  double v22; // r0
  double v23; // d8
  double v24; // r0
  double v25; // d8
  double v26; // r0
  double v27; // d7
  unsigned __int64 v28; // r0
  double v29; // d7
  double v30; // d7
  char *v32; // r9
  const char *v33; // r0
  char *v34; // r8
  int *v35; // r0
  int *v36; // r0
  int *v37; // r0
  int *v38; // r0
  int *v39; // r0
  int *v40; // r0
  __int64 v41; // [sp+18h] [bp-8ACh] BYREF
  _BYTE v42[28]; // [sp+20h] [bp-8A4h] BYREF
  char v43; // [sp+3Ch] [bp-888h] BYREF
  char v44[28]; // [sp+40h] [bp-884h] BYREF
  int v45; // [sp+5Ch] [bp-868h] BYREF
  _BYTE v46[28]; // [sp+60h] [bp-864h] BYREF
  char v47; // [sp+7Ch] [bp-848h] BYREF
  char v48[60]; // [sp+80h] [bp-844h] BYREF
  int v49; // [sp+BCh] [bp-808h] BYREF
  char s[136]; // [sp+C0h] [bp-804h] BYREF
  _BYTE v51[1916]; // [sp+148h] [bp-77Ch] BYREF

  v2 = (pthread_mutex_t *)(a1 + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
  {
    v35 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v35, "cgminer.c", "gen_stratum_work", 8354);
    goto LABEL_47;
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v36 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v36, "cgminer.c", "gen_stratum_work", 8354);
    goto LABEL_47;
  }
  v5 = *(_DWORD *)(a1 + 632);
  v6 = *(_DWORD *)(a1 + 1568);
  v7 = *(_DWORD *)(a1 + 1576);
  v41 = *(_QWORD *)(a1 + 624);
  sub_4C150((void *)(v6 + v7), &v41, v5, (int)"cgminer.c", (int)"gen_stratum_work", 8359);
  v8 = *(_DWORD *)(a1 + 624);
  v9 = *(_DWORD *)(a1 + 628);
  ++*(_QWORD *)(a1 + 624);
  *(_DWORD *)(a2 + 296) = v8;
  *(_DWORD *)(a2 + 300) = v9;
  *(_DWORD *)(a2 + 304) = *(_DWORD *)(a1 + 632);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v37 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v37,
      "cgminer.c",
      "gen_stratum_work",
      8365);
    goto LABEL_47;
  }
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v38 = _errno_location();
    snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v38, "cgminer.c", "gen_stratum_work", 8365);
    goto LABEL_47;
  }
  v10 = pthread_mutex_unlock(v2);
  if ( v10 )
  {
    v39 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v39,
      "cgminer.c",
      "gen_stratum_work",
      8365);
    goto LABEL_47;
  }
  sub_4889C(*(char **)(a1 + 1568), *(_DWORD *)(a1 + 1572), s);
  sub_4889C(s, 0x20u, v42);
  sub_4C150(v44, v42, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8369);
  if ( *(int *)(a1 + 1708) > 0 )
  {
    do
    {
      v11 = *(const void **)(*(_DWORD *)(a1 + 676) + 4 * v10++);
      sub_4C150(v46, v11, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8373);
      sub_4889C(v44, 0x40u, s);
      sub_4889C(s, 0x20u, v42);
      sub_4C150(v44, v42, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8375);
    }
    while ( *(_DWORD *)(a1 + 1708) > v10 );
  }
  v12 = (int *)&v43;
  v13 = (char *)&v41 + 4;
  do
  {
    v14 = v12[1];
    ++v12;
    *((_DWORD *)v13 + 1) = bswap32(v14);
    v13 += 4;
  }
  while ( v12 != &v45 );
  sub_4C150((void *)a2, (const void *)(a1 + 1580), 0x70u, (int)"cgminer.c", (int)"gen_stratum_work", 8384);
  sub_4C150((void *)(a2 + 36), v42, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8385);
  *(_QWORD *)(a2 + 312) = *(_QWORD *)(a1 + 1824);
  *(_DWORD *)(a2 + 288) = _strdup(*(const char **)(a1 + 672));
  *(_DWORD *)(a2 + 320) = _strdup(*(const char **)(a1 + 612));
  *(_DWORD *)(a2 + 308) = _strdup((const char *)(a1 + 1804));
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v40 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v40,
      "cgminer.c",
      "gen_stratum_work",
      8396);
LABEL_47:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  off_9E444();
  if ( byte_1AECC5 )
  {
    v32 = sub_4988C(a2, 112);
    v33 = sub_4988C((int)v42, 32);
    v34 = (char *)v33;
    if ( byte_1AECC5 )
    {
      if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
      {
LABEL_35:
        if ( !byte_1AECC4 && dword_9E320 <= 6 )
        {
LABEL_37:
          if ( !byte_1AECC4 && dword_9E320 <= 6 )
            goto LABEL_40;
LABEL_39:
          snprintf(
            s,
            0x800u,
            "Work job_id %s nonce2 %llu ntime %s",
            *(const char **)(a2 + 288),
            *(_QWORD *)(a2 + 296),
            *(const char **)(a2 + 308));
          sub_47AB4(7, s, 0);
          goto LABEL_40;
        }
LABEL_43:
        snprintf(s, 0x800u, "Generated stratum header %s", v32);
        sub_47AB4(7, s, 0);
        if ( !byte_1AECC5 )
          goto LABEL_40;
        if ( byte_244080 )
          goto LABEL_39;
        goto LABEL_37;
      }
      snprintf(s, 0x800u, "Generated stratum merkle %s", v33);
      sub_47AB4(7, s, 0);
      if ( byte_1AECC5 )
      {
        if ( byte_244080 )
          goto LABEL_43;
        goto LABEL_35;
      }
    }
LABEL_40:
    free(v32);
    free(v34);
  }
  v15 = a2 - 4;
  v16 = (int *)&v47;
  do
  {
    v17 = *(_DWORD *)(v15 + 4);
    v15 += 4;
    v16[1] = bswap32(v17);
    ++v16;
  }
  while ( &v49 != v16 );
  sub_486D4(s);
  sub_48704((unsigned __int8 *)s, v48, 0x40u);
  sub_4C150((void *)(a2 + 128), v51, 0x20u, (int)"cgminer.c", (int)"calc_midstate", 2251);
  sub_53E30((void *)(a2 + 160));
  ++dword_246360;
  if ( time(0) - dword_1AF21C > 5 )
  {
    dword_1AF21C = time(0);
    dword_1AF220 = dword_246360;
  }
  v18 = *(double *)(a2 + 312);
  v19 = dword_1AF224;
  *(_BYTE *)(a2 + 284) = 1;
  *(_DWORD *)(a2 + 260) = a1;
  *(_DWORD *)(a2 + 336) = v19;
  *(_DWORD *)(a2 + 248) = 0;
  *(_BYTE *)(a2 + 280) = 0;
  *(_BYTE *)(a2 + 440) = 83;
  *(_DWORD *)(a2 + 244) = 60;
  if ( v18 == 0.0 )
  {
    LODWORD(v20) = sub_778A4(*(_QWORD *)(a2 + 184));
    v21 = v20 * 6.27710174e57;
    LODWORD(v22) = sub_778A4(*(_QWORD *)(a2 + 176));
    v23 = v21 + v22 * 3.40282367e38;
    LODWORD(v24) = sub_778A4(*(_QWORD *)(a2 + 168));
    v25 = v23 + v24 * 1.84467441e19;
    LODWORD(v26) = sub_778A4(*(_QWORD *)(a2 + 160));
    v27 = v26 + v25;
    if ( v26 + v25 == 0.0 )
    {
      v18 = 2.69595353e67;
      v28 = -1;
    }
    else
    {
      v18 = 2.69595353e67 / v27;
      round();
      v28 = (unsigned __int64)(2.69595353e67 / v27);
    }
    *(double *)(a2 + 376) = v18;
  }
  else
  {
    *(double *)(a2 + 376) = v18;
    round();
    v28 = (unsigned __int64)v18;
  }
  *(double *)(a1 + 480) = v18;
  sub_51B18(v28, (char *)(*(_DWORD *)(a2 + 260) + 48), 8u, 0);
  v29 = *(double *)(a1 + 464);
  if ( v29 == v18 )
  {
    ++*(_DWORD *)(a1 + 488);
    goto LABEL_22;
  }
  if ( v29 <= v18 && v29 != 0.0 )
  {
LABEL_22:
    v30 = *(double *)(a1 + 472);
    if ( v30 != v18 )
      goto LABEL_23;
LABEL_29:
    ++*(_DWORD *)(a1 + 492);
    return sub_4A60C((struct timeval *)(a2 + 264));
  }
  v30 = *(double *)(a1 + 472);
  *(double *)(a1 + 464) = v18;
  *(_DWORD *)(a1 + 488) = 1;
  if ( v30 == v18 )
    goto LABEL_29;
LABEL_23:
  if ( v30 < v18 )
  {
    *(double *)(a1 + 472) = v18;
    *(_DWORD *)(a1 + 492) = 1;
  }
  return sub_4A60C((struct timeval *)(a2 + 264));
}
// 5AB60: variable 'v20' is possibly undefined
// 5AB74: variable 'v22' is possibly undefined
// 5AB88: variable 'v24' is possibly undefined
// 5AB94: variable 'v26' is possibly undefined
// 12274: using guessed type int round(void);
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AF21C: using guessed type int dword_1AF21C;
// 1AF220: using guessed type int dword_1AF220;
// 1AF224: using guessed type int dword_1AF224;
// 244080: using guessed type char byte_244080;
// 246360: using guessed type int dword_246360;

//----- (0005AFA8) --------------------------------------------------------
int __fastcall sub_5AFA8(int *a1, int *a2, int a3, int a4, __int64 a5, unsigned int a6)
{
  pthread_mutex_t *v8; // r6
  unsigned int v11; // r2
  int v12; // r2
  unsigned int v14; // r1
  int v15; // [sp+Ch] [bp-8h]

  v8 = (pthread_mutex_t *)(a3 + 212);
  *a2 = (int)sub_55E38();
  v15 = *a1;
  if ( pthread_mutex_lock(v8) )
    sub_550B8("get_work_by_nonce2", 8324);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a3 + 236)) )
    sub_5505C("get_work_by_nonce2", 8324);
  v11 = bswap32(a6);
  *(_QWORD *)(a3 + 624) = a5;
  a6 = v11;
  sub_4C150((void *)(a3 + 1580), &a6, 4u, (int)"cgminer.c", (int)"get_work_by_nonce2", 8327);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a3 + 236)) )
    sub_55C08("get_work_by_nonce2", 8328);
  if ( pthread_mutex_unlock(v8) )
    sub_55114("get_work_by_nonce2", 8328);
  off_9E444();
  sub_5A7E8(a3, *a2);
  v12 = dword_1AF224;
  *(_DWORD *)(*a2 + 260) = a4;
  v14 = a6;
  *(_DWORD *)(*a2 + 256) = v15;
  *(_DWORD *)(*a2 + 336) = v12;
  ++*(_DWORD *)(*(_DWORD *)(*a2 + 260) + 68);
  *(_BYTE *)(*a2 + 272) = 1;
  *(_DWORD *)(*a2 + 444) = v14;
  return 1;
}
// 9E444: using guessed type int (*off_9E444)();
// 1AF224: using guessed type int dword_1AF224;

//----- (0005B104) --------------------------------------------------------
int __fastcall sub_5B104(_DWORD *a1)
{
  int v2; // r5
  pthread_t v4; // r0
  int v5; // r5
  int *v6; // r0
  int *v7; // r0
  int *v8; // r0
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( !*((_BYTE *)a1 + 107) )
  {
    v4 = pthread_self();
    pthread_detach(v4);
  }
  v2 = *((unsigned __int8 *)a1 + 105);
  if ( *((_BYTE *)a1 + 105) )
    return 0;
  while ( !sub_55244(a1) )
  {
    sub_5A31C((int)a1);
    if ( *((_BYTE *)a1 + 107) )
      goto LABEL_16;
    sleep(0x1Eu);
    if ( *((_BYTE *)a1 + 105) )
      return 0;
  }
  sub_551DC((int)a1, (_BYTE *)a1 + 97);
  if ( pthread_mutex_lock(&stru_2440BC) )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "cgminer.c", "test_pool_thread", 10765);
    goto LABEL_23;
  }
  if ( pthread_rwlock_wrlock(&rwlock) )
  {
    v7 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v7, "cgminer.c", "test_pool_thread", 10765);
    goto LABEL_23;
  }
  if ( !byte_1AF228 )
  {
    v5 = *a1;
    dword_1AF12C = (int)a1;
    byte_1AF228 = 1;
    v2 = v5 != 0;
  }
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v8 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v8,
      "cgminer.c",
      "test_pool_thread",
      10779);
    goto LABEL_23;
  }
  if ( pthread_mutex_unlock(&stru_2440BC) )
  {
    v9 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v9,
      "cgminer.c",
      "test_pool_thread",
      10779);
LABEL_23:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  off_9E444();
  if ( v2 && (byte_244080 || byte_1AECC4 || dword_9E320 > 4) )
  {
    snprintf(s, 0x800u, "Switching to pool %d %s - first alive pool", *a1, (const char *)a1[41]);
    sub_47AB4(5, s, 0);
  }
  sub_582C8(a1);
  sub_59E6C(0);
LABEL_16:
  *((_BYTE *)a1 + 284) = 0;
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AF12C: using guessed type int dword_1AF12C;
// 1AF228: using guessed type char byte_1AF228;
// 244080: using guessed type char byte_244080;
// 2440BC: using guessed type pthread_mutex_t stru_2440BC;

//----- (0005B390) --------------------------------------------------------
void __fastcall sub_5B390(const char *a1, _DWORD *a2)
{
  int v4; // r10
  int v5; // r11
  char *v6; // r9
  char *v7; // r8
  char *v8; // r7
  signed int v9; // r4
  size_t v10; // r4
  const char *v11; // r12
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  _DWORD *v16; // r12
  int v17; // r1
  int *v18; // r0
  int v19; // r3
  int v20; // [sp+20h] [bp-C0Ch]
  int v21; // [sp+24h] [bp-C08h]
  char s[1024]; // [sp+28h] [bp-C04h] BYREF
  _DWORD v23[5]; // [sp+428h] [bp-804h] BYREF
  __int16 v24; // [sp+43Ch] [bp-7F0h]

  if ( !dword_1AECDC )
    return;
  v21 = a2[64];
  v4 = *(_DWORD *)(sub_57BAC(v21) + 36);
  v5 = a2[65];
  v20 = a2[108];
  v6 = sub_4988C((int)(a2 + 40), 32);
  v7 = sub_4988C((int)(a2 + 48), 32);
  v8 = sub_4988C((int)a2, 128);
  v9 = snprintf(
         s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         v20,
         a1,
         v6,
         *(const char **)(v5 + 164),
         *(const char **)(*(_DWORD *)(v4 + 4) + 8),
         *(_DWORD *)(v4 + 8),
         v21,
         v7,
         v8);
  free(v6);
  free(v7);
  free(v8);
  if ( v9 >= 1024 )
  {
    s[1023] = 0;
    goto LABEL_5;
  }
  if ( v9 >= 0 )
  {
LABEL_5:
    if ( pthread_mutex_lock(&stru_1AF22C) )
    {
      v18 = _errno_location();
      snprintf(
        (char *)v23,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v18,
        "cgminer.c",
        "sharelog",
        672);
    }
    else
    {
      v10 = fwrite(s, v9, 1u, (FILE *)dword_1AECDC);
      fflush((FILE *)dword_1AECDC);
      if ( !pthread_mutex_unlock(&stru_1AF22C) )
      {
        off_9E444();
        if ( v10 != 1 && (byte_244080 || byte_1AECC4 || dword_9E320 > 2) )
        {
          v11 = "sharelog fwrite error";
LABEL_12:
          v12 = *(_DWORD *)v11;
          v13 = *((_DWORD *)v11 + 1);
          v14 = *((_DWORD *)v11 + 2);
          v15 = *((_DWORD *)v11 + 3);
          v16 = v11 + 16;
          v23[0] = v12;
          v23[1] = v13;
          v23[2] = v14;
          v23[3] = v15;
          v17 = v16[1];
          v23[4] = *v16;
          v24 = v17;
          sub_47AB4(3, (const char *)v23, 0);
          return;
        }
        return;
      }
      v19 = *_errno_location();
      snprintf(
        (char *)v23,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        v19,
        "cgminer.c",
        "sharelog",
        675);
    }
    sub_47AB4(3, (const char *)v23, 1);
    sub_54CCC(1, 1);
  }
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
  {
    v11 = "sharelog printf error";
    goto LABEL_12;
  }
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECDC: using guessed type int dword_1AECDC;
// 244080: using guessed type char byte_244080;

//----- (0005B638) --------------------------------------------------------
int __fastcall sub_5B638(int a1, int a2)
{
  int v2; // r5
  int v6; // r8
  int v7; // r9
  int v8; // r8
  const char *v9; // lr
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // lr
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r1
  int v20; // r2
  int *v21; // r0
  int *v22; // r0
  struct timeval v23; // [sp+10h] [bp-80Ch] BYREF
  _DWORD s[10]; // [sp+18h] [bp-804h] BYREF
  __int16 v25; // [sp+40h] [bp-7DCh]

  v2 = (unsigned __int8)byte_1AF244;
  if ( !byte_1AF244 )
  {
    if ( dword_246240 )
      return v2;
    if ( *(_DWORD *)(a1 + 336) != dword_1AF224 )
    {
      v2 = (unsigned __int8)byte_1AECC5;
      if ( byte_1AECC5 )
      {
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
        {
          strcpy((char *)s, "Work stale due to block mismatch");
          sub_47AB4(7, (const char *)s, 0);
        }
        return v2;
      }
      return 1;
    }
    v6 = *(_DWORD *)(a1 + 276);
    v7 = *(_DWORD *)(a1 + 260);
    if ( v6 <= dword_9ED98 )
      v6 = dword_9ED9C;
    if ( !a2 && *(_BYTE *)(v7 + 640) )
    {
      if ( !*(_BYTE *)(v7 + 641) || !*(_BYTE *)(v7 + 643) )
      {
        v2 = (unsigned __int8)byte_1AECC5;
        if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
        {
          strcpy((char *)s, "Work stale due to stratum inactive");
          sub_47AB4(7, (const char *)s, 0);
          return v2;
        }
        return 1;
      }
      if ( pthread_mutex_lock((pthread_mutex_t *)(v7 + 212)) )
        sub_550B8("stale_work", 5084);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v7 + 236)) )
        sub_561E4("stale_work", 5084);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(v7 + 212)) )
      {
        v22 = _errno_location();
        snprintf(
          (char *)s,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v22,
          "cgminer.c",
          "stale_work",
          5084);
LABEL_56:
        sub_47AB4(3, (const char *)s, 1);
        sub_54CCC(1, 1);
      }
      if ( strcmp(*(const char **)(a1 + 288), *(const char **)(v7 + 672)) )
      {
        if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
        {
          off_9E444();
          v2 = (unsigned __int8)byte_1AECC5;
          if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
          {
            v9 = "Work stale due to stratum job_id mismatch";
            goto LABEL_42;
          }
          return 1;
        }
        goto LABEL_55;
      }
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
      {
LABEL_55:
        v21 = _errno_location();
        snprintf(
          (char *)s,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v21,
          "cgminer.c",
          "stale_work",
          5091);
        goto LABEL_56;
      }
      off_9E444();
    }
    v8 = v6 - (int)(*(double *)(v7 + 448) * 5.0 + 1.0);
    sub_4A60C(&v23);
    if ( v8 < 5 )
      v8 = 5;
    if ( v8 <= v23.tv_sec - *(_DWORD *)(a1 + 264) )
    {
      v2 = (unsigned __int8)byte_1AECC5;
      if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
      {
        strcpy((char *)s, "Work stale due to expiry");
        sub_47AB4(7, (const char *)s, 0);
        return v2;
      }
      return 1;
    }
    if ( a2 | (unsigned __int8)byte_245154 ^ 1
      || v7 == sub_58084()
      || *(_BYTE *)(a1 + 282)
      || (unsigned int)(dword_1AEEB8 - 3) <= 1 )
    {
      return v2;
    }
    v2 = (unsigned __int8)byte_1AECC5;
    if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      v9 = "Work stale due to fail only pool mismatch";
LABEL_42:
      v10 = *(_DWORD *)v9;
      v11 = *((_DWORD *)v9 + 1);
      v12 = *((_DWORD *)v9 + 2);
      v13 = *((_DWORD *)v9 + 3);
      v14 = (int *)(v9 + 16);
      s[0] = v10;
      s[1] = v11;
      s[2] = v12;
      s[3] = v13;
      v15 = *v14;
      v16 = v14[1];
      v17 = v14[2];
      v18 = v14[3];
      v14 += 4;
      s[4] = v15;
      s[5] = v16;
      s[6] = v17;
      s[7] = v18;
      v19 = v14[1];
      v20 = v14[2];
      s[8] = *v14;
      s[9] = v19;
      v25 = v20;
      sub_47AB4(7, (const char *)s, 0);
      return v2;
    }
    return 1;
  }
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9ED98: using guessed type int dword_9ED98;
// 9ED9C: using guessed type int dword_9ED9C;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AEEB8: using guessed type int dword_1AEEB8;
// 1AF224: using guessed type int dword_1AF224;
// 1AF244: using guessed type char byte_1AF244;
// 244080: using guessed type char byte_244080;
// 245154: using guessed type char byte_245154;
// 246240: using guessed type int dword_246240;

//----- (0005BB20) --------------------------------------------------------
void **__fastcall sub_5BB20(int a1, void *a2)
{
  _DWORD *v2; // r10
  int v3; // r2
  int v4; // r0
  int v5; // r5
  int v6; // r12
  int v7; // r3
  int v8; // r1
  int v9; // r0
  int v10; // r11
  _DWORD *v11; // r2
  int v12; // r3
  int v13; // r2
  int v14; // r12
  int v15; // r2
  int v16; // r3
  time_t v17; // r0
  int v18; // r5
  int v19; // r3
  void **v20; // r0
  bool v21; // zf
  void **result; // r0
  double v23; // d7
  int v24; // r3
  int v25; // r1
  int *v26; // r0
  int *v27; // r0
  int v28; // r3
  int v29; // r3
  int v30; // r2
  char *v31; // r1
  int v32; // r3
  bool v33; // cc
  time_t v35; // [sp+18h] [bp-824h]
  void **v37; // [sp+24h] [bp-818h] BYREF
  struct timespec abstime; // [sp+28h] [bp-814h] BYREF
  struct timeval v39; // [sp+30h] [bp-80Ch] BYREF
  char s[2052]; // [sp+38h] [bp-804h] BYREF

  v37 = 0;
  v2 = *(_DWORD **)(a1 + 36);
  sub_51AAC(a1);
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    strcpy(s, "Popping work from get queue to get work");
    sub_47AB4(7, s, 0);
  }
  v35 = time(0);
  while ( !v37 )
  {
    if ( pthread_mutex_lock((pthread_mutex_t *)dword_1AF0E4) )
    {
      v26 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v26, "cgminer.c", "hash_pop", 8176);
      goto LABEL_71;
    }
    while ( !dword_1AF1B4 || !*(_DWORD *)(*(_DWORD *)(dword_1AF1B4 + 344) + 12) )
    {
      sub_4A60C(&v39);
      abstime.tv_sec = v39.tv_sec + 10;
      abstime.tv_nsec = 1000 * v39.tv_usec;
      pthread_cond_signal(&stru_244050);
      if ( pthread_cond_timedwait((pthread_cond_t *)(dword_245160 + 40), (pthread_mutex_t *)dword_1AF0E4, &abstime) )
      {
        if ( !byte_1AF130 )
        {
          byte_1AF130 = 1;
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
          {
            strcpy(s, "Waiting for work to be available from pools.");
            sub_47AB4(4, s, 0);
          }
        }
      }
    }
    if ( byte_1AF130 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
      {
        strcpy(s, "Work available from pools, resuming.");
        sub_47AB4(4, s, 0);
      }
      v3 = dword_1AF1B4;
      byte_1AF130 = 0;
      if ( !dword_1AF1B4 )
LABEL_23:
        __und(0);
    }
    else
    {
      v3 = dword_1AF1B4;
    }
    v4 = *(_DWORD *)(v3 + 344);
    if ( *(_DWORD *)(v4 + 12) > dword_1AFC48 && !*(_BYTE *)(v3 + 273) && *(_DWORD *)(v3 + 276) )
    {
      v5 = *(_DWORD *)(v3 + 352);
      if ( !v5 )
        goto LABEL_23;
      while ( !*(_BYTE *)(v5 + 273) )
      {
        v25 = *(_DWORD *)(v5 + 352);
        if ( !*(_DWORD *)(v5 + 276) )
          break;
        v5 = *(_DWORD *)(v5 + 352);
        if ( !v25 )
          goto LABEL_23;
      }
    }
    else
    {
      v5 = v3;
    }
    v6 = *(_DWORD *)(v5 + 348);
    if ( v6 )
    {
      v7 = *(_DWORD *)(v4 + 20);
      v8 = v5 + 344;
      if ( v5 != *(_DWORD *)(v4 + 16) - v7 )
        goto LABEL_32;
    }
    else
    {
      v10 = *(_DWORD *)(v5 + 352);
      if ( !v10 )
      {
        free(*(void **)v4);
        free(*(void **)(dword_1AF1B4 + 344));
        dword_1AF1B4 = 0;
        goto LABEL_44;
      }
      v7 = *(_DWORD *)(v4 + 20);
      v8 = v5 + 344;
      if ( v5 != *(_DWORD *)(v4 + 16) - v7 )
        goto LABEL_62;
    }
    *(_DWORD *)(v4 + 16) = v6 + v7;
    v6 = *(_DWORD *)(v5 + 348);
    if ( !v6 )
    {
      v10 = *(_DWORD *)(v5 + 352);
LABEL_62:
      v9 = v10;
      dword_1AF1B4 = v10;
      goto LABEL_33;
    }
    v7 = *(_DWORD *)(*(_DWORD *)(v3 + 344) + 20);
LABEL_32:
    v9 = dword_1AF1B4;
    *(_DWORD *)(v6 + v7 + 8) = *(_DWORD *)(v5 + 352);
    v10 = *(_DWORD *)(v5 + 352);
LABEL_33:
    v11 = *(_DWORD **)(v9 + 344);
    if ( v10 )
    {
      *(_DWORD *)(v10 + v11[5] + 4) = *(_DWORD *)(v5 + 348);
      v11 = *(_DWORD **)(v9 + 344);
    }
    v12 = 3 * ((v11[1] - 1) & *(_DWORD *)(v5 + 372));
    --*(_DWORD *)(*v11 + 4 * v12 + 4);
    v13 = **(_DWORD **)(v9 + 344);
    v14 = *(_DWORD *)(v13 + 4 * v12);
    if ( v8 == v14 )
      *(_DWORD *)(v13 + 4 * v12) = *(_DWORD *)(v5 + 360);
    v15 = *(_DWORD *)(v5 + 356);
    v16 = *(_DWORD *)(v5 + 360);
    if ( v8 == v14 )
      v9 = dword_1AF1B4;
    if ( v15 )
    {
      *(_DWORD *)(v15 + 16) = v16;
      v16 = *(_DWORD *)(v5 + 360);
    }
    if ( v16 )
      *(_DWORD *)(v16 + 12) = *(_DWORD *)(v5 + 356);
    --*(_DWORD *)(*(_DWORD *)(v9 + 344) + 12);
LABEL_44:
    if ( !*(_BYTE *)(v5 + 273) && *(_DWORD *)(v5 + 276) )
      --dword_1AFC48;
    pthread_cond_signal(&stru_244050);
    pthread_cond_signal((pthread_cond_t *)(dword_245160 + 40));
    dword_244020 = time(0);
    if ( pthread_mutex_unlock((pthread_mutex_t *)dword_1AF0E4) )
    {
      v27 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v27, "cgminer.c", "hash_pop", 8248);
LABEL_71:
      sub_47AB4(3, s, 1);
      sub_54CCC(1, 1);
    }
    off_9E444();
    v37 = (void **)v5;
    if ( !sub_5B638(v5, 0) )
      continue;
    sub_53380(&v37, "cgminer.c", "get_work", 8638);
    sub_55AA4();
  }
  v17 = time(0);
  v18 = v17 - v35;
  v19 = (unsigned __int8)byte_1AECC5;
  if ( v17 - v35 <= 0 )
  {
LABEL_78:
    if ( !v19 )
      goto LABEL_53;
    goto LABEL_79;
  }
  if ( !byte_1AECC5 )
  {
    v2[58] += v18;
    goto LABEL_53;
  }
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
  {
    snprintf(s, 0x800u, "Get work blocked for %ld seconds", v17 - v35);
    sub_47AB4(7, s, 0);
    v19 = (unsigned __int8)byte_1AECC5;
    v2[58] += v18;
    goto LABEL_78;
  }
  v2[58] += v18;
LABEL_79:
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
  {
    snprintf(s, 0x800u, "Got work from get queue to get work for thread %d", a2);
    sub_47AB4(7, s, 0);
  }
LABEL_53:
  v20 = v37;
  v21 = byte_1AF244 == 0;
  v37[64] = a2;
  if ( v21 )
    goto LABEL_55;
  v28 = v2[95] + v2[96];
  v2[95] = v28;
  if ( v28 <= 0 )
  {
    v2[96] = 1;
LABEL_96:
    sub_4C150(v20, (char *)&unk_1AFC4C + 160 * v28, 0xA0u, (int)"cgminer.c", (int)"set_benchmark_work", 8619);
    goto LABEL_55;
  }
  if ( v28 <= 15 )
    goto LABEL_96;
  v29 = v2[94];
  v30 = -1;
  v31 = (char *)&unk_1AF248;
  v2[96] = -1;
  v32 = v29 + 1;
  v33 = v32 <= 15;
  if ( v32 > 15 )
    v32 = 0;
  else
    v30 = 5 * v32;
  v2[94] = v32;
  if ( v33 )
    v31 = (char *)&unk_1AF248 + 32 * v30;
  sub_4C150(v20, v31, 0xA0u, (int)"cgminer.c", (int)"set_benchmark_work", 8615);
LABEL_55:
  sub_51AE4(a1);
  result = v37;
  *((_BYTE *)v37 + 272) = 1;
  v23 = *(double *)(v2[1] + 104);
  if ( v23 > *((double *)result + 47) )
    v23 = *((double *)result + 47);
  *((double *)result + 28) = v23;
  v24 = v2[1];
  if ( *(double *)(v24 + 112) > v23 )
    v23 = *(double *)(v24 + 112);
  *((double *)result + 28) = v23;
  return result;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AF0E4: using guessed type int dword_1AF0E4;
// 1AF130: using guessed type char byte_1AF130;
// 1AF1B4: using guessed type int dword_1AF1B4;
// 1AF244: using guessed type char byte_1AF244;
// 1AFC48: using guessed type int dword_1AFC48;
// 244020: using guessed type int dword_244020;
// 244050: using guessed type pthread_cond_t stru_244050;
// 244080: using guessed type char byte_244080;
// 245160: using guessed type int dword_245160;

//----- (0005C2CC) --------------------------------------------------------
void **__fastcall sub_5C2CC(int a1, pthread_rwlock_t *a2, void *a3)
{
  void **v4; // r4

  v4 = sub_5BB20(a1, a3);
  sub_55F44(a2, (int)v4);
  return v4;
}

//----- (0005C2F4) --------------------------------------------------------
void **__fastcall sub_5C2F4(int a1)
{
  int v1; // r3
  void **v3; // r3
  void **v5; // [sp+4h] [bp-Ch] BYREF

  v1 = *(_DWORD *)(a1 + 356);
  if ( !v1 )
    return 0;
  v5 = *(void ***)(a1 + 356);
  if ( sub_5B638(v1, 0) )
  {
    sub_53380(&v5, "cgminer.c", "__get_queued", 9413);
    sub_55AA4();
  }
  else
  {
    sub_54514(a1, (int)v5);
  }
  v3 = v5;
  *(_DWORD *)(a1 + 356) = 0;
  return v3;
}

//----- (0005C374) --------------------------------------------------------
void **__fastcall sub_5C374(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r4
  void **v3; // r5

  v1 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_5505C("get_queued", 9434);
  v3 = sub_5C2F4((int)a1);
  if ( pthread_rwlock_unlock(v1) )
    sub_55C08("get_queued", 9436);
  off_9E444();
  return v3;
}
// 9E444: using guessed type int (*off_9E444)();

//----- (0005C3E0) --------------------------------------------------------
void sub_5C3E0()
{
  int v0; // r6
  int v1; // r4
  void **v2; // r3
  int v3; // r1
  char *v4; // r9
  int v5; // r0
  int v6; // r2
  void **v7; // r12
  char *v8; // r8
  _DWORD *v9; // r0
  int v10; // r2
  int v11; // r0
  void **v12; // lr
  _DWORD *v13; // r0
  _DWORD *v14; // r2
  int v15; // r0
  int *v16; // r0
  int *v17; // r0
  void **v18; // [sp+14h] [bp-808h] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v0 = pthread_mutex_lock((pthread_mutex_t *)dword_1AF0E4);
  if ( v0 )
  {
    v16 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v16, "cgminer.c", "discard_stale", 5373);
    goto LABEL_39;
  }
  v18 = (void **)dword_1AF1B4;
  if ( !dword_1AF1B4 )
  {
    pthread_cond_signal(&stru_244050);
    if ( !pthread_mutex_unlock((pthread_mutex_t *)dword_1AF0E4) )
    {
      off_9E444();
      return;
    }
    goto LABEL_41;
  }
  v1 = *(_DWORD *)(dword_1AF1B4 + 352);
  if ( !sub_5B638(dword_1AF1B4, 0) )
    goto LABEL_19;
LABEL_4:
  v2 = v18;
  v3 = dword_1AF1B4;
  v4 = (char *)v18[87];
  v5 = *(_DWORD *)(dword_1AF1B4 + 344);
  if ( v4 )
  {
    v6 = *(_DWORD *)(v5 + 20);
    v7 = v18 + 86;
    if ( v18 != (void **)(*(_DWORD *)(v5 + 16) - v6) )
    {
LABEL_6:
      *(_DWORD *)&v4[v6 + 8] = v2[88];
      v8 = (char *)v2[88];
LABEL_7:
      v9 = *(_DWORD **)(v3 + 344);
      if ( v8 )
      {
        *(_DWORD *)&v8[v9[5] + 4] = v2[87];
        v9 = *(_DWORD **)(v3 + 344);
      }
      v10 = 3 * ((v9[1] - 1) & (unsigned int)v2[93]);
      --*(_DWORD *)(*v9 + 4 * v10 + 4);
      v11 = **(_DWORD **)(v3 + 344);
      v12 = *(void ***)(v11 + 4 * v10);
      if ( v12 == v7 )
      {
        v3 = (int)v2[90];
        *(_DWORD *)(v11 + 4 * v10) = v3;
      }
      v13 = v2[89];
      v14 = v2[90];
      if ( v12 == v7 )
        v3 = dword_1AF1B4;
      if ( v13 )
      {
        v13[4] = v14;
        v14 = v2[90];
      }
      if ( v14 )
        v14[3] = v2[89];
      --*(_DWORD *)(*(_DWORD *)(v3 + 344) + 12);
      goto LABEL_18;
    }
LABEL_25:
    *(_DWORD *)(v5 + 16) = &v4[v6];
    v4 = (char *)v2[87];
    if ( v4 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(v3 + 344) + 20);
      goto LABEL_6;
    }
    v8 = (char *)v2[88];
LABEL_24:
    v3 = (int)v8;
    dword_1AF1B4 = (int)v8;
    goto LABEL_7;
  }
  v8 = (char *)v18[88];
  if ( v8 )
  {
    v6 = *(_DWORD *)(v5 + 20);
    v7 = v18 + 86;
    if ( v18 != (void **)(*(_DWORD *)(v5 + 16) - v6) )
      goto LABEL_24;
    goto LABEL_25;
  }
  free(*(void **)v5);
  free(*(void **)(dword_1AF1B4 + 344));
  dword_1AF1B4 = 0;
LABEL_18:
  ++v0;
  sub_53380(&v18, "cgminer.c", "discard_stale", 5380);
LABEL_19:
  while ( 1 )
  {
    v18 = (void **)v1;
    if ( !v1 )
      break;
    v15 = v1;
    v1 = *(_DWORD *)(v1 + 352);
    if ( sub_5B638(v15, 0) )
      goto LABEL_4;
  }
  pthread_cond_signal(&stru_244050);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_1AF0E4) )
  {
LABEL_41:
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "discard_stale", 5386);
LABEL_39:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  off_9E444();
  if ( v0 && byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    snprintf(s, 0x800u, "Discarded %d stales that didn't match current hash", v0);
    sub_47AB4(7, s, 0);
  }
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AF0E4: using guessed type int dword_1AF0E4;
// 1AF1B4: using guessed type int dword_1AF1B4;
// 244050: using guessed type pthread_cond_t stru_244050;
// 244080: using guessed type char byte_244080;

//----- (0005C728) --------------------------------------------------------
int sub_5C728()
{
  pthread_t v0; // r0
  int v1; // r8
  int v2; // r5
  int v3; // r3
  pthread_rwlock_t *v4; // r4

  v0 = pthread_self();
  pthread_detach(v0);
  sub_5C3E0();
  if ( pthread_rwlock_rdlock(&stru_244028) )
    sub_561E4("restart_thread", 5439);
  v1 = dword_245108;
  v2 = pthread_rwlock_unlock(&stru_244028);
  if ( v2 )
    sub_55C08("restart_thread", 5441);
  off_9E444();
  if ( v1 > 0 )
  {
    do
    {
      v3 = *(_DWORD *)(dword_244024 + 4 * v2);
      v4 = *(pthread_rwlock_t **)(v3 + 36);
      if ( v4 && !v4[1].__lock )
      {
        *(_BYTE *)(v3 + 62) = 1;
        sub_58CC0(v4);
        if ( pthread_mutex_lock(&stru_246348) )
          sub_550B8("restart_thread", 5460);
        (*(void (__fastcall **)(pthread_rwlock_t *))(v4->__nr_readers + 76))(v4);
        if ( pthread_mutex_unlock(&stru_246348) )
          sub_55114("restart_thread", 5462);
        off_9E444();
      }
      ++v2;
    }
    while ( v1 != v2 );
  }
  if ( pthread_mutex_lock(&stru_246374) )
    sub_550B8("restart_thread", 5466);
  pthread_cond_broadcast(stru_246280);
  if ( pthread_mutex_unlock(&stru_246374) )
    sub_55114("restart_thread", 5468);
  off_9E444();
  return 0;
}
// 9E444: using guessed type int (*off_9E444)();
// 244024: using guessed type int dword_244024;
// 244028: using guessed type pthread_rwlock_t stru_244028;
// 245108: using guessed type int dword_245108;
// 246280: using guessed type pthread_cond_t stru_246280[3];
// 246348: using guessed type pthread_mutex_t stru_246348;
// 246374: using guessed type pthread_mutex_t stru_246374;

//----- (0005C898) --------------------------------------------------------
int __fastcall sub_5C898(_DWORD *a1)
{
  pthread_t v2; // r0
  char *v3; // r0
  const struct timespec *v4; // r1
  int v5; // r6
  __int64 v6; // r4
  int v7; // r0
  int v8; // r1
  __int64 v9; // r2
  bool v10; // zf
  char v11; // r7
  int v12; // r7
  void ***v13; // r6
  void **v14; // r4
  time_t v15; // r0
  void **v16; // r3
  int v17; // r2
  void **v18; // r8
  size_t v19; // r0
  int v20; // r3
  int v21; // r12
  int v22; // r1
  void ***v23; // r5
  int v24; // r3
  unsigned int v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r1
  int v28; // r3
  unsigned int v29; // r2
  unsigned int v30; // r1
  int v31; // r3
  unsigned int v32; // r4
  void **v33; // r3
  int v34; // r2
  void **v35; // r3
  char *v36; // r3
  int v37; // r1
  void ****v38; // r3
  __int64 v39; // r2
  time_t v40; // r0
  void **v41; // r2
  int v42; // r3
  int v43; // r0
  _DWORD *v45; // r7
  void **v46; // r3
  unsigned int v47; // r4
  int v48; // r11
  _DWORD *v49; // r5
  _DWORD *v50; // r8
  int v51; // r4
  char *v52; // r9
  unsigned int v53; // r3
  int v54; // r3
  void **v55; // r3
  void *v56; // r2
  unsigned int v57; // r1
  bool v58; // cc
  char *v59; // r2
  char *v60; // lr
  char *v61; // r12
  int v62; // r0
  int v63; // r1
  int v64; // r2
  int v65; // r3
  _DWORD *v66; // lr
  char *v67; // r12
  int v68; // r1
  int v69; // r2
  int v70; // r3
  void **v71; // r0
  void **v72; // r7
  void *v73; // r0
  int *v74; // r0
  int v75; // r3
  const char *v76; // r1
  int v77; // r3
  int v78; // r3
  int v79; // r3
  int v80; // r2
  int v81; // r1
  int v82; // r3
  int v83; // r3
  int v84; // r3
  int v85; // r3
  unsigned int v86; // [sp+20h] [bp-C7Ch]
  int v87; // [sp+24h] [bp-C78h]
  __int64 v88; // [sp+28h] [bp-C74h]
  _DWORD *v89; // [sp+4Ch] [bp-C50h]
  int v90; // [sp+54h] [bp-C48h] BYREF
  void **v91; // [sp+58h] [bp-C44h] BYREF
  int v92; // [sp+5Ch] [bp-C40h] BYREF
  __int64 v93; // [sp+60h] [bp-C3Ch] BYREF
  char v94[12]; // [sp+68h] [bp-C34h] BYREF
  char s[16]; // [sp+74h] [bp-C28h] BYREF
  char v96[20]; // [sp+84h] [bp-C18h] BYREF
  char v97[1024]; // [sp+98h] [bp-C04h] BYREF
  char v98[2052]; // [sp+498h] [bp-804h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf(s, 0x10u, "%d/SStratum", *a1);
  sub_4BD10(s);
  v3 = sub_49F68();
  a1[182] = v3;
  if ( !v3 )
  {
    v60 = " stratum_q in stratum_sthread";
    qmemcpy(v98, "Failed to create", 16);
    v61 = &v98[16];
    goto LABEL_84;
  }
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
  {
    snprintf(v98, 0x800u, "in %s ", "stratum_sthread");
    sub_47AB4(5, v98, 0);
    v3 = (char *)a1[182];
  }
  v4 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
  v5 = 0;
  v6 = 0;
  if ( *((_BYTE *)a1 + 105) )
    goto LABEL_48;
  do
  {
    v7 = sub_4A110((int)v3, v4);
    v91 = (void **)v7;
    if ( !v7 )
    {
      v60 = "Stratum q returned empty work";
      v61 = v98;
LABEL_84:
      v62 = *(_DWORD *)v60;
      v63 = *((_DWORD *)v60 + 1);
      v64 = *((_DWORD *)v60 + 2);
      v65 = *((_DWORD *)v60 + 3);
      v66 = v60 + 16;
      *(_DWORD *)v61 = v62;
      *((_DWORD *)v61 + 1) = v63;
      *((_DWORD *)v61 + 2) = v64;
      *((_DWORD *)v61 + 3) = v65;
      v67 = v61 + 16;
      v68 = v66[1];
      v69 = v66[2];
      v70 = v66[3];
      *(_DWORD *)v67 = *v66;
      *((_DWORD *)v67 + 1) = v68;
      *((_DWORD *)v67 + 2) = v69;
      *((_WORD *)v67 + 6) = v70;
      sub_47AB4(3, v98, 1);
      sub_54CCC(1, 1);
    }
    if ( *(_DWORD *)(v7 + 304) > 8u )
    {
      if ( (byte_244080 || byte_1AECC4 || dword_9E320 > 2)
        && ((snprintf(
               v98,
               0x800u,
               "Pool %d asking for inappropriately long nonce2 length %d",
               *a1,
               *(_DWORD *)(v7 + 304)),
             sub_47AB4(3, v98, 0),
             byte_244080)
         || byte_1AECC4)
        || dword_9E320 > 2 )
      {
        strcpy(v98, "Not attempting to submit shares");
        sub_47AB4(3, v98, 0);
      }
      sub_53084(&v91, "cgminer.c", "stratum_sthread", 7650);
      goto LABEL_47;
    }
    v8 = *(_DWORD *)(v7 + 76);
    v9 = *(_QWORD *)(v7 + 296);
    v87 = v8;
    v10 = HIDWORD(v9) == HIDWORD(v6);
    v88 = v9;
    if ( HIDWORD(v9) == HIDWORD(v6) )
      v10 = (_DWORD)v9 == (_DWORD)v6;
    v90 = *(_DWORD *)(v7 + 76);
    v11 = v10;
    if ( v8 == v5 )
      v12 = v11 & 1;
    else
      v12 = 0;
    v93 = v9;
    if ( v12 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        snprintf(v98, 0x800u, "Filtering duplicate share to pool %d", *a1);
        sub_47AB4(6, v98, 0);
      }
      sub_53084(&v91, "cgminer.c", "stratum_sthread", 7662);
      goto LABEL_47;
    }
    sub_4981C(v94, (int)&v90, 4);
    sub_4981C(v96, (int)&v93, (int)v91[76]);
    v13 = (void ***)sub_496AC(0x34u, 1u, "cgminer.c", "stratum_sthread", 7671);
    v14 = v91;
    v15 = time(0);
    v16 = v91;
    v13[11] = (void **)v15;
    v13[9] = v16;
    memset(v97, 0, sizeof(v97));
    if ( pthread_mutex_lock(&stru_1AF200) )
    {
      v74 = _errno_location();
      snprintf(
        v98,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v74,
        "cgminer.c",
        "stratum_sthread",
        7680);
      goto LABEL_99;
    }
    v17 = dword_24400C;
    v13[10] = (void **)dword_24400C;
    dword_24400C = v17 + 1;
    if ( pthread_mutex_unlock(&stru_1AF200) )
    {
      v75 = *_errno_location();
      snprintf(
        v98,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        v75,
        "cgminer.c",
        "stratum_sthread",
        7683);
      goto LABEL_99;
    }
    off_9E444();
    v92 = 0;
    sub_49940(&v92, (unsigned __int8 *)a1 + 1780, 4);
    if ( *((_BYTE *)a1 + 644) )
      snprintf(
        v97,
        0x400u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%08x\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        (const char *)v91[72],
        v96,
        (const char *)v91[77],
        v94,
        bswap32((unsigned int)v91[111] & ~v92),
        v13[10]);
    else
      snprintf(
        v97,
        0x400u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        (const char *)v91[72],
        v96,
        (const char *)v91[77],
        v94,
        v13[10]);
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
    {
      snprintf(v98, 0x800u, "Submitting share %08lx to pool %d", v14[54], *a1);
      sub_47AB4(6, v98, 0);
    }
    while ( 1 )
    {
      v18 = v13[11];
      if ( (int)v18 + 119 < time(0) )
        goto LABEL_119;
      v19 = strlen(v97);
      if ( sub_4B10C((int)a1, v97, v19) )
      {
        if ( pthread_mutex_lock(&stru_1AF200) )
        {
          v78 = *_errno_location();
          snprintf(
            v98,
            0x800u,
            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
            v78,
            "cgminer.c",
            "stratum_sthread",
            7727);
          goto LABEL_99;
        }
        v20 = *((unsigned __int8 *)v13 + 40);
        v21 = *((unsigned __int8 *)v13 + 43);
        v22 = *((unsigned __int8 *)v13 + 42);
        v13[5] = (void **)(v13 + 10);
        v23 = (void ***)dword_1AF218;
        v24 = v20 + 17973517 + (v21 << 24) + (v22 << 16) + (*((unsigned __int8 *)v13 + 41) << 8);
        v13[6] = (void **)4;
        v25 = v24 ^ (unsigned int)&unk_7F76D;
        v26 = (-1622558010 - v25) ^ (v25 << 8);
        v27 = (-17973517 - v25 - v26) ^ (v26 >> 13);
        v28 = (v25 - v26 - v27) ^ (v27 >> 12);
        v29 = (v26 - v27 - v28) ^ (v28 << 16);
        v30 = (v27 - v28 - v29) ^ (v29 >> 5);
        v31 = (v28 - v29 - v30) ^ (v30 >> 3);
        v32 = (v30 - v31 - ((v29 - v30 - v31) ^ (v31 << 10))) ^ (((v29 - v30 - v31) ^ (v31 << 10)) >> 15);
        v13[7] = (void **)v32;
        if ( v23 )
        {
          v33 = *v23;
          v13[2] = 0;
          *v13 = v33;
          v13[1] = (void **)((_BYTE *)(*v23)[4] - (_BYTE *)(*v23)[5]);
          *((_DWORD *)(*v23)[4] + 2) = v13;
          (*v23)[4] = v13;
        }
        else
        {
          v13[2] = 0;
          v13[1] = 0;
          dword_1AF218 = (int)v13;
          v71 = (void **)malloc(0x2Cu);
          *v13 = v71;
          if ( !v71 )
            goto LABEL_145;
          memset(v71, 0, 0x2Cu);
          (*v13)[4] = v13;
          (*v13)[1] = (void *)32;
          (*v13)[2] = (void *)5;
          (*v13)[5] = 0;
          v72 = *v13;
          *v72 = malloc(0x180u);
          v73 = **v13;
          if ( !v73 )
            goto LABEL_145;
          memset(v73, 0, 0x180u);
          v23 = v13;
          (*v13)[10] = (void *)-1609490463;
        }
        (*v23)[3] = (char *)(*v23)[3] + 1;
        v34 = 12 * (v32 & ((unsigned int)(*v23)[1] - 1));
        ++*(_DWORD *)((char *)**v23 + v34 + 4);
        v35 = *(void ***)((char *)**v23 + v34);
        v13[3] = 0;
        v13[4] = v35;
        v36 = (char *)**v23;
        v37 = *(_DWORD *)&v36[v34];
        v38 = (void ****)&v36[v34];
        if ( v37 )
        {
          *(_DWORD *)(v37 + 12) = v13;
          v38 = (void ****)((char *)**v23 + v34);
        }
        *v38 = v13;
        v39 = *(_QWORD *)((char *)**v23 + v34 + 4);
        if ( (unsigned int)v39 < 10 * (HIDWORD(v39) + 1) || (*v13)[9] == (void *)1 )
          goto LABEL_33;
        v45 = calloc(24 * (_DWORD)(*v13)[1], 1u);
        if ( v45 )
        {
          (*v13)[6] = (void *)((((2 * (_DWORD)(*v13)[1] - 1) & (unsigned int)(*v13)[3]) != 0)
                             + ((unsigned int)(*v13)[3] >> (*((_BYTE *)*v13 + 8) + 1)));
          (*v13)[7] = 0;
          v46 = *v13;
          v47 = (unsigned int)(*v13)[1];
          if ( v47 )
          {
            v48 = 0;
            v86 = 0;
            v89 = a1;
            do
            {
              v49 = *(_DWORD **)((char *)*v46 + v48);
              if ( v49 )
              {
                while ( 1 )
                {
                  v50 = (_DWORD *)v49[4];
                  v51 = 3 * ((2 * v47 - 1) & v49[7]);
                  v52 = (char *)&v45[v51];
                  v53 = *((_DWORD *)v52 + 1) + 1;
                  *((_DWORD *)v52 + 1) = v53;
                  if ( v53 > (unsigned int)(*v13)[6] )
                  {
                    (*v13)[7] = (char *)(*v13)[7] + 1;
                    *((_DWORD *)v52 + 2) = *((_DWORD *)v52 + 1) / (unsigned int)(*v13)[6];
                  }
                  v49[3] = 0;
                  v49[4] = v45[v51];
                  v54 = v45[v51];
                  if ( v54 )
                    *(_DWORD *)(v54 + 12) = v49;
                  v45[v51] = v49;
                  v46 = *v13;
                  if ( !v50 )
                    break;
                  v47 = (unsigned int)v46[1];
                  v49 = v50;
                }
                v47 = (unsigned int)v46[1];
              }
              v48 += 12;
              ++v86;
            }
            while ( v86 < v47 );
            a1 = v89;
          }
          free(*v46);
          (*v13)[1] = (void *)(2 * (_DWORD)(*v13)[1]);
          (*v13)[2] = (char *)(*v13)[2] + 1;
          **v13 = v45;
          v55 = *v13;
          v56 = (*v13)[7];
          v57 = (unsigned int)(*v13)[3];
          v58 = (unsigned int)v56 > v57 >> 1;
          if ( (unsigned int)v56 <= v57 >> 1 )
            v59 = 0;
          else
            v59 = (char *)v55[8];
          if ( v58 )
            ++v59;
          v55[8] = v59;
          if ( (unsigned int)(*v13)[8] > 1 )
            (*v13)[9] = (void *)1;
LABEL_33:
          ++a1[183];
          if ( !pthread_mutex_unlock(&stru_1AF200) )
          {
            off_9E444();
            if ( sub_551DC((int)a1, (_BYTE *)a1 + 96) )
            {
              if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3 )
              {
                if ( !byte_1AECC5 )
                {
LABEL_39:
                  v40 = time(0);
                  v41 = v13[11];
                  v42 = (unsigned __int8)byte_1AECC5;
                  v13[12] = (void **)v40;
                  v43 = v40 - (_DWORD)v41;
                  if ( v43 > 0 )
                    v42 |= 1u;
                  if ( v42 && (byte_244080 || byte_1AECC4 || dword_9E320 > 5) )
                  {
                    snprintf(v98, 0x800u, "Pool %d stratum share submission lag time %d seconds", *a1, v43);
                    sub_47AB4(6, v98, 0);
                  }
                  goto LABEL_46;
                }
                goto LABEL_81;
              }
              snprintf(v98, 0x800u, "Pool %d communication resumed, submitting work", *a1);
              sub_47AB4(4, v98, 0);
            }
            if ( !byte_1AECC5 )
              goto LABEL_39;
            if ( byte_244080 || byte_1AECC4 )
            {
LABEL_53:
              strcpy(v98, "Successfully submitted, adding to stratum_shares db");
              sub_47AB4(7, v98, 0);
              goto LABEL_39;
            }
LABEL_81:
            if ( dword_9E320 <= 6 )
              goto LABEL_39;
            goto LABEL_53;
          }
          v79 = *_errno_location();
          snprintf(
            v98,
            0x800u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            v79,
            "cgminer.c",
            "stratum_sthread",
            7730);
LABEL_99:
          sub_47AB4(3, v98, 1);
          sub_54CCC(1, 1);
        }
LABEL_145:
        exit(-1);
      }
      if ( !sub_55170((int)a1, (_BYTE *)a1 + 96) && sub_584B4((int)a1) )
      {
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
        {
          snprintf(v98, 0x800u, "Pool %d stratum share submission failure", *a1);
          sub_47AB4(4, v98, 0);
        }
        v82 = a1[33] + 1;
        ++dword_244014;
        a1[33] = v82;
      }
      if ( byte_245204 )
        break;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      {
        v83 = *_errno_location();
        snprintf(
          v98,
          0x800u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          v83,
          "cgminer.c",
          "stratum_sthread",
          7752);
        goto LABEL_99;
      }
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v84 = *_errno_location();
        snprintf(
          v98,
          0x800u,
          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          v84,
          "cgminer.c",
          "stratum_sthread",
          7752);
        goto LABEL_99;
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
      {
        v85 = *_errno_location();
        snprintf(
          v98,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v85,
          "cgminer.c",
          "stratum_sthread",
          7752);
        goto LABEL_99;
      }
      v76 = (const char *)a1[153];
      if ( !v76 || strcmp((const char *)v91[80], v76) )
      {
        if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        {
          off_9E444();
          if ( !byte_1AECC5 )
            goto LABEL_124;
          if ( byte_244080 || byte_1AECC4 || dword_9E320 > 6 )
          {
            strcpy(v98, "No matching session id for resubmitting stratum share");
            sub_47AB4(7, v98, 0);
            goto LABEL_119;
          }
LABEL_121:
          if ( byte_1AECC4 || dword_9E320 > 6 )
            goto LABEL_123;
          goto LABEL_124;
        }
LABEL_111:
        v77 = *_errno_location();
        snprintf(
          v98,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v77,
          "cgminer.c",
          "stratum_sthread",
          7754);
        goto LABEL_99;
      }
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        goto LABEL_111;
      off_9E444();
      sleep(2u);
    }
    if ( !byte_1AECC5 )
      goto LABEL_124;
    if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
      goto LABEL_121;
    strcpy(v98, "Lowmem option prevents resubmitting stratum share");
    sub_47AB4(7, v98, 0);
LABEL_119:
    if ( byte_1AECC5 )
    {
      if ( !byte_244080 )
        goto LABEL_121;
LABEL_123:
      strcpy(v98, "Failed to submit stratum share, discarding");
      sub_47AB4(7, v98, 0);
    }
LABEL_124:
    sub_53084(&v91, "cgminer.c", "stratum_sthread", 7769);
    free(v13);
    v80 = dword_242E98;
    v81 = dword_242E9C;
    ++a1[30];
    *(_QWORD *)&dword_242E98 = __PAIR64__(v81, v80) + 1;
LABEL_46:
    v5 = v87;
    v6 = v88;
LABEL_47:
    v4 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
    v3 = (char *)a1[182];
  }
  while ( !*((_BYTE *)a1 + 105) );
LABEL_48:
  sub_4A02C((int)v3);
  return 0;
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AF218: using guessed type int dword_1AF218;
// 242E98: using guessed type int dword_242E98;
// 242E9C: using guessed type int dword_242E9C;
// 24400C: using guessed type int dword_24400C;
// 244014: using guessed type int dword_244014;
// 244080: using guessed type char byte_244080;
// 245204: using guessed type char byte_245204;

//----- (0005D8CC) --------------------------------------------------------
void __fastcall sub_5D8CC(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, const char *a5)
{
  double *v9; // r4
  int v10; // r6
  unsigned int v11; // r0
  unsigned int v12; // r2
  unsigned int v13; // r1
  unsigned int v14; // kr00_4
  unsigned int v15; // r2
  unsigned int v16; // r1
  double v17; // d6
  double v18; // d5
  double v19; // d7
  const char *v20; // r9
  size_t v21; // r0
  size_t v22; // r8
  char *v23; // r7
  int v24; // r6
  double v25; // r0
  int v26; // r2
  int v27; // r1
  double v28; // d6
  double v29; // d5
  double v30; // d7
  int v31; // r3
  time_t v32; // r0
  int v33; // r3
  int v34; // r3
  int v35; // r12
  int v36; // r3
  _DWORD *v37; // r0
  const char *v38; // r0
  int v39; // r3
  int v40; // r12
  char v41[20]; // [sp+20h] [bp-858h] BYREF
  char v42[2]; // [sp+34h] [bp-844h] BYREF
  _BYTE v43[30]; // [sp+36h] [bp-842h] BYREF
  char v44[36]; // [sp+54h] [bp-824h] BYREF
  char v45[2040]; // [sp+78h] [bp-800h] BYREF
  _DWORD savedregs[8]; // [sp+878h] [bp+0h] BYREF

  v9 = *(double **)(a4 + 260);
  v10 = *(_DWORD *)(sub_57BAC(*(_DWORD *)(a4 + 256)) + 36);
  if ( !a2 || *a2 != 5 && (!*(_BYTE *)(a4 + 324) || *a2 != 7) )
  {
    if ( !pthread_mutex_lock(&stru_246244) )
    {
      v11 = HIDWORD(qword_246368);
      v12 = qword_246368;
      ++*(_DWORD *)(v10 + 40);
      v14 = v12;
      v13 = v12 + 1;
      v15 = *((_DWORD *)v9 + 4);
      LODWORD(qword_246368) = v13;
      v16 = *((_DWORD *)v9 + 5);
      HIDWORD(qword_246368) = (__PAIR64__(v11, v14) + 1) >> 32;
      *((_DWORD *)v9 + 4) = v15 + 1;
      v17 = dbl_242F10;
      *((_DWORD *)v9 + 5) = (__PAIR64__(v16, v15) + 1) >> 32;
      *(double *)(v10 + 208) = *(double *)(v10 + 208) + *(double *)(a4 + 376);
      v18 = *(double *)(a4 + 376);
      v19 = v9[10] + v18;
      ++*((_DWORD *)v9 + 6);
      dbl_242F10 = v17 + v18;
      v9[10] = v19;
      if ( !pthread_mutex_unlock(&stru_246244) )
      {
        off_9E444();
        if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
        {
          strcpy(v45, "PROOF OF WORK RESULT: false (booooo)");
          sub_47AB4(7, v45, 0);
        }
        if ( byte_242EF8 || byte_24511C )
          goto LABEL_28;
        strcpy(v44, "reject");
        memset(&v44[7], (unsigned __int8)byte_24511C, 0x1Du);
        v42[0] = byte_24511C;
        if ( dword_242F4C > 1 )
          snprintf(v41, 0x14u, "pool %d", **(_DWORD **)(a4 + 260));
        else
          v41[0] = byte_24511C;
        if ( !*(_BYTE *)(a4 + 324) )
          a2 = (_DWORD *)sub_6DFCC(a1, "reject-reason");
        if ( a2 )
        {
          v20 = (const char *)sub_6E350(a2);
          v21 = strlen(v20);
          if ( v21 >= 0x1C )
            v22 = 28;
          else
            v22 = v21;
          *(_WORD *)v42 = 10272;
          v23 = (char *)savedregs + v22;
          sub_4C150(v43, v20, v22, (int)"cgminer.c", (int)"share_result", 3634);
          *(v23 - 2114) = 41;
          *(v23 - 2113) = 0;
          sub_4C150(&v44[7], v20, v22, (int)"cgminer.c", (int)"share_result", 3639);
          v44[6] = 58;
          *(v23 - 2077) = 0;
          goto LABEL_24;
        }
        if ( a3 )
          v36 = *(_BYTE *)(a4 + 284) & 1;
        else
          v36 = 0;
        if ( !v36 )
          goto LABEL_24;
        if ( *a3 == 1 )
        {
          v37 = sub_6E1C4(a3, 1u);
          if ( !v37 || *v37 != 2 )
            goto LABEL_24;
        }
        else
        {
          if ( *a3 != 2 )
            goto LABEL_24;
          v37 = a3;
        }
        v38 = (const char *)sub_6E350(v37);
        snprintf(v42, 0x1Fu, " (%s)", v38);
LABEL_24:
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
        {
          snprintf(
            v45,
            0x800u,
            "Rejected %s %s %d %s%s %s%s version 0x%x",
            a5,
            *(const char **)(*(_DWORD *)(v10 + 4) + 8),
            *(_DWORD *)(v10 + 8),
            v41,
            v42,
            "",
            "",
            *(_DWORD *)(a4 + 444));
          sub_47AB4(5, v45, 0);
        }
        sub_5B390(v44, (_DWORD *)a4);
LABEL_28:
        v24 = *((_DWORD *)v9 + 6);
        if ( v24 > 10 && !*(_BYTE *)(a4 + 281) )
        {
          if ( byte_246260 )
          {
            if ( dword_2440F8 > 1 )
            {
              LODWORD(v25) = sub_778B4(*(__int64 *)&dword_245158);
              if ( (double)v24 > v25 / dbl_9ED68 * 60.0 * 3.0 )
              {
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
                {
                  snprintf(v45, 0x800u, "Pool %d rejected %d sequential shares, disabling!", *(_DWORD *)v9, v24);
                  sub_47AB4(4, v45, 0);
                }
                if ( *((_DWORD *)v9 + 25) == 1 )
                  --dword_2440F8;
                *((_DWORD *)v9 + 25) = 2;
                if ( v9 == (double *)sub_58084() )
                  sub_59E6C(0);
                *((_DWORD *)v9 + 6) = 0;
              }
            }
          }
        }
        return;
      }
      v39 = *_errno_location();
      v40 = 3594;
      goto LABEL_78;
    }
    v34 = *_errno_location();
    v35 = 3586;
LABEL_67:
    snprintf(v45, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v34, "cgminer.c", "share_result", v35);
    goto LABEL_68;
  }
  if ( pthread_mutex_lock(&stru_246244) )
  {
    v34 = *_errno_location();
    v35 = 3523;
    goto LABEL_67;
  }
  v26 = dword_245158;
  v27 = dword_24515C;
  ++*(_DWORD *)(v10 + 36);
  v28 = dbl_242EF0;
  *(_QWORD *)&dword_245158 = __PAIR64__(v27, v26) + 1;
  ++*((_QWORD *)v9 + 1);
  *(double *)(v10 + 200) = *(double *)(v10 + 200) + *(double *)(a4 + 376);
  v29 = *(double *)(a4 + 376);
  v30 = v9[9] + v29;
  dbl_242EF0 = v28 + v29;
  v9[9] = v30;
  if ( pthread_mutex_unlock(&stru_246244) )
  {
    v39 = *_errno_location();
    v40 = 3533;
LABEL_78:
    snprintf(v45, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v39, "cgminer.c", "share_result", v40);
LABEL_68:
    sub_47AB4(3, v45, 1);
    sub_54CCC(1, 1);
  }
  off_9E444();
  v31 = *(_DWORD *)v9;
  *((_DWORD *)v9 + 6) = 0;
  *(_DWORD *)(v10 + 216) = v31;
  v32 = time(0);
  *(_DWORD *)(v10 + 220) = v32;
  v33 = (unsigned __int8)byte_1AECC5;
  *(_QWORD *)(v10 + 224) = *(_QWORD *)(a4 + 376);
  *((_DWORD *)v9 + 88) = v32;
  v9[45] = *(double *)(a4 + 376);
  if ( v33 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    strcpy(v45, "PROOF OF WORK RESULT: true (yay!!!)");
    sub_47AB4(7, v45, 0);
  }
  if ( !byte_242EF8 && !byte_24511C )
  {
    if ( dword_242F4C <= 1 )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
      {
        snprintf(
          v45,
          0x800u,
          "Accepted %s %s %d %s%s",
          a5,
          *(const char **)(*(_DWORD *)(v10 + 4) + 8),
          *(_DWORD *)(v10 + 8),
          "",
          "");
        sub_47AB4(5, v45, 0);
      }
    }
    else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
    {
      snprintf(
        v45,
        0x800u,
        "Accepted %s %s %d pool %d %s%s",
        a5,
        *(const char **)(*(_DWORD *)(v10 + 4) + 8),
        *(_DWORD *)(v10 + 8),
        **(_DWORD **)(a4 + 260),
        "",
        "");
      sub_47AB4(5, v45, 0);
    }
  }
  sub_5B390("accept", (_DWORD *)a4);
  if ( dword_1AF124 && (double)dword_1AF124 <= dbl_242EF0 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 3 )
    {
      snprintf(v45, 0x800u, "Successfully mined %d accepted shares as requested and exiting.", dword_1AF124);
      sub_47AB4(4, v45, 0);
    }
    sub_54D4C();
  }
  if ( *((_DWORD *)v9 + 25) == 2 )
  {
    if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 3
      || (snprintf(v45, 0x800u, "Rejecting pool %d now accepting shares, re-enabling!", *(_DWORD *)v9),
          sub_47AB4(4, v45, 0),
          *((_DWORD *)v9 + 25) != 1) )
    {
      *((_DWORD *)v9 + 25) = 1;
      ++dword_2440F8;
    }
    sub_59E6C(0);
  }
  if ( *(_BYTE *)(a4 + 283) )
    sub_54FC0();
}
// 5DC94: variable 'v25' is possibly undefined
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9ED68: using guessed type double dbl_9ED68;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AF124: using guessed type int dword_1AF124;
// 242EF0: using guessed type double dbl_242EF0;
// 242EF8: using guessed type char byte_242EF8;
// 242F10: using guessed type double dbl_242F10;
// 242F4C: using guessed type int dword_242F4C;
// 244080: using guessed type char byte_244080;
// 2440F8: using guessed type int dword_2440F8;
// 24511C: using guessed type char byte_24511C;
// 245158: using guessed type int dword_245158;
// 24515C: using guessed type int dword_24515C;
// 246244: using guessed type pthread_mutex_t stru_246244;
// 246260: using guessed type char byte_246260;
// 246368: using guessed type __int64 qword_246368;

//----- (0005E2EC) --------------------------------------------------------
void __fastcall sub_5E2EC(int a1, unsigned __int64 a2)
{
  double v3; // d0
  int v5; // r4
  char *v6; // r0
  int v7; // r11
  double v8; // d9
  int v9; // r6
  int v10; // r4
  double v11; // r0
  double v12; // r0
  double v13; // r0
  double v14; // r0
  double v15; // r0
  double v16; // d10
  int v17; // r3
  int *v18; // r11
  int v19; // r3
  int v20; // r8
  unsigned __int64 v21; // r0
  double v22; // d8
  double v23; // r0
  int v24; // r10
  int v25; // r3
  double v26; // d5
  int v27; // r0
  int v28; // r4
  double v29; // r0
  int v30; // r1
  double v31; // r0
  double v32; // d10
  double v33; // d6
  double v34; // d5
  double v35; // d7
  double v36; // d7
  double v37; // r0
  double v38; // r0
  double v39; // r0
  double v40; // r0
  double v41; // r0
  double v42; // r0
  int *v43; // r0
  int *v44; // r0
  int v45; // r3
  int v46; // r12
  int v47; // r3
  int v48; // r12
  char v50[16]; // [sp+20h] [bp-884h] BYREF
  char v51[16]; // [sp+30h] [bp-874h] BYREF
  char v52[16]; // [sp+40h] [bp-864h] BYREF
  char v53[16]; // [sp+50h] [bp-854h] BYREF
  struct sysinfo info; // [sp+60h] [bp-844h] BYREF
  char s[2052]; // [sp+A0h] [bp-804h] BYREF

  if ( sysinfo(&info) )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
    {
      v5 = *_errno_location();
      v6 = strerror(v5);
      snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v5, v6);
      sub_47AB4(6, s, 0);
    }
    dword_244004 = time(0);
  }
  else
  {
    dword_244004 = info.uptime;
  }
  sub_4A60C((struct timeval *)&dword_1AF0EC);
  sub_4A8FC();
  v7 = dword_1AF0EC;
  v8 = v3;
  if ( dword_9ED78 > dword_1AF0EC - dword_1B064C )
  {
    if ( a1 < 0 )
      return;
    v24 = 0;
    sub_4C460(algn_1AF148, &dword_1AF0EC);
  }
  else
  {
    dword_1B064C = dword_1AF0EC;
    sub_4C460(algn_1AF148, &dword_1AF0EC);
    if ( a1 < 0 )
    {
      v9 = pthread_mutex_lock(&stru_2463B8);
      if ( !v9 )
      {
        if ( dword_245108 > 0 )
        {
          do
          {
            while ( 1 )
            {
              v10 = *(_DWORD *)(sub_57BAC(v9) + 36);
              sub_4A8FC();
              sub_4C460((void *)(v10 + 140), &dword_1AF0EC);
              if ( v3 > 0.0 )
                break;
              if ( dword_245108 <= ++v9 )
                goto LABEL_15;
            }
            LODWORD(v11) = v10 + 48;
            v12 = sub_529E0(v11);
            LODWORD(v12) = v10 + 56;
            v13 = sub_529E0(v12);
            LODWORD(v13) = v10 + 64;
            v14 = sub_529E0(v13);
            LODWORD(v14) = v10 + 72;
            ++v9;
            v3 = 0.0;
            sub_529E0(v14);
          }
          while ( dword_245108 > v9 );
        }
LABEL_15:
        if ( pthread_mutex_unlock(&stru_2463B8) )
        {
          v47 = *_errno_location();
          v48 = 7100;
          goto LABEL_74;
        }
        off_9E444();
        if ( !pthread_mutex_lock(&stru_2463B8) )
        {
          LODWORD(v15) = sub_778A4(a2);
          v16 = v15;
          v17 = dword_1AF1B0;
          dbl_245228 = dbl_245228 + v15;
          goto LABEL_18;
        }
LABEL_68:
        v43 = _errno_location();
        snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v43, "cgminer.c", "hashmeter", 7103);
        goto LABEL_69;
      }
      v45 = *_errno_location();
      v46 = 7085;
LABEL_72:
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v45, "cgminer.c", "hashmeter", v46);
      goto LABEL_69;
    }
    v24 = 1;
  }
  v27 = sub_57BAC(a1);
  v28 = *(_DWORD *)(v27 + 36);
  sub_4C460((void *)(v27 + 44), &dword_1AF0EC);
  *(_DWORD *)(v28 + 240) = v7;
  sub_4A8FC();
  sub_4C460((void *)(v28 + 140), &dword_1AF0EC);
  if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
  {
    LODWORD(v29) = sub_778A4(a2);
    snprintf(s, 0x800u, "[thread %d: %llu hashes, %.1f mhash/sec]", a1, a2, v29 / v3 / 1000000.0);
    sub_47AB4(7, s, 0);
  }
  LODWORD(a2) = sub_77910(a2, (unsigned int)&unk_F4240);
  HIDWORD(a2) = v30;
  if ( pthread_mutex_lock(&stru_2463B8) )
  {
    v45 = *_errno_location();
    v46 = 7056;
    goto LABEL_72;
  }
  LODWORD(v31) = sub_778A4(a2);
  v16 = v31;
  *(double *)(v28 + 80) = *(double *)(v28 + 80) + v31;
  if ( v3 > 0.0 )
  {
    LODWORD(v31) = v28 + 48;
    v37 = sub_529E0(v31);
    LODWORD(v37) = v28 + 56;
    v38 = sub_529E0(v37);
    LODWORD(v38) = v28 + 64;
    v39 = sub_529E0(v38);
    LODWORD(v39) = v28 + 72;
    sub_529E0(v39);
  }
  if ( pthread_mutex_unlock(&stru_2463B8) )
  {
    v47 = *_errno_location();
    v48 = 7063;
    goto LABEL_74;
  }
  off_9E444();
  if ( ((unsigned __int8)v24 & (unsigned __int8)byte_242F08) != 0 )
  {
    sub_54DA8(s, 0x100u, v28);
    printf("%s          \r", s);
    fflush((FILE *)stdout);
    if ( pthread_mutex_lock(&stru_2463B8) )
      goto LABEL_68;
    v17 = dword_1AF1B0;
    dbl_245228 = dbl_245228 + v16;
    goto LABEL_18;
  }
  if ( pthread_mutex_lock(&stru_2463B8) )
    goto LABEL_68;
  v17 = dword_1AF1B0;
  dbl_245228 = dbl_245228 + v16;
  if ( v24 )
  {
LABEL_18:
    v18 = (int *)&unk_1AF150;
    v19 = v17 + 1;
    v20 = 0;
    *(double *)&v21 = 0.0;
    if ( v19 > 11 )
      v19 = 0;
    dword_1AF1B0 = v19;
    do
    {
      v22 = *(double *)v18;
      v18 += 2;
      if ( v22 >= 0.0 )
      {
        LODWORD(v23) = sub_778A4(v21);
        ++v20;
        v21 = (unsigned __int64)(v23 + v22);
      }
    }
    while ( v18 != &dword_1AF1B0 );
    if ( v20 )
    {
      LODWORD(a2) = sub_77910(v21, v20);
      HIDWORD(a2) = HIDWORD(v21);
    }
    if ( (double)dword_9ED78 > 0.0 )
    {
      sub_778A4(a2);
      LODWORD(v42) = &dbl_245110;
      *(double *)&v21 = sub_529E0(v42);
      if ( v8 <= 0.0 )
        goto LABEL_28;
    }
    else if ( v8 <= 0.0 )
    {
LABEL_28:
      v24 = 1;
      *(_QWORD *)&dword_242FF0 = (unsigned __int64)(dbl_245110 * 1000000.0);
      v25 = dword_1AF1B0;
      v26 = 0.0;
      dbl_1AF158[dword_1AF1B0 - 1] = 0.0;
      goto LABEL_44;
    }
    LODWORD(v21) = &dbl_245210;
    v40 = sub_529E0(*(double *)&v21);
    LODWORD(v40) = &dbl_245208;
    v41 = sub_529E0(v40);
    if ( v8 > 0.0 )
    {
      LODWORD(v41) = &dbl_245218;
      sub_529E0(v41);
    }
    goto LABEL_28;
  }
  v25 = dword_1AF1B0;
  v26 = dbl_1AF158[dword_1AF1B0 - 1];
LABEL_44:
  v32 = v16 + v26;
  v33 = (double)dword_244004;
  v34 = dbl_9ED88;
  v35 = (double)dword_242EA0;
  dbl_1AF158[v25 - 1] = v32;
  v36 = v33 - v35;
  dbl_9ED68 = v36;
  if ( v36 - v34 > 86400.0 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      snprintf(s, 0x800u, "cgminer time error total_secs = %f last_total_secs = %f", v36, v34);
      sub_47AB4(3, s, 0);
    }
    if ( !pthread_mutex_unlock(&stru_2463B8) )
    {
      off_9E444();
      sub_58E30();
      if ( !pthread_mutex_lock(&stru_2463B8) )
      {
        if ( !v24 )
          goto LABEL_51;
LABEL_56:
        sub_51B18((unsigned __int64)(dbl_245228 / dbl_9ED68 * 1000000.0), v50, 0x10u, 4);
        dbl_1B0650 = (double)((int)dbl_245110 / 10) / 100.0;
        sub_51B18((unsigned __int64)(dbl_245110 * 1000000.0), v51, 0x10u, 4);
        sub_51B18((unsigned __int64)(dbl_245210 * 1000000.0), v52, 0x10u, 4);
        sub_51B18((unsigned __int64)(dbl_245208 * 1000000.0), v53, 0x10u, 4);
        sub_51B18((unsigned __int64)(dbl_245218 * 1000000.0), s, 0x10u, 4);
        snprintf(
          byte_1B0658,
          0x100u,
          "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
          dword_9ED78,
          v51,
          v52,
          v53,
          s,
          v50);
        if ( !pthread_mutex_unlock(&stru_2463B8) )
        {
          off_9E444();
          printf("%s          \r", byte_1B0658);
          fflush((FILE *)stdout);
          return;
        }
        goto LABEL_70;
      }
      v45 = *_errno_location();
      v46 = 7153;
      goto LABEL_72;
    }
    v47 = *_errno_location();
    v48 = 7151;
LABEL_74:
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v47, "cgminer.c", "hashmeter", v48);
LABEL_69:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  dbl_9ED88 = v36;
  if ( v24 )
    goto LABEL_56;
LABEL_51:
  if ( pthread_mutex_unlock(&stru_2463B8) )
  {
LABEL_70:
    v44 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v44, "cgminer.c", "hashmeter", 7194);
    goto LABEL_69;
  }
  off_9E444();
}
// 5E3DC: variable 'v3' is possibly undefined
// 5E4A4: variable 'v11' is possibly undefined
// 5E554: variable 'v15' is possibly undefined
// 5E5AC: variable 'v23' is possibly undefined
// 5E5D0: variable 'v21' is possibly undefined
// 5E73C: variable 'v29' is possibly undefined
// 5E784: variable 'v30' is possibly undefined
// 5E7A8: variable 'v31' is possibly undefined
// 5EC1C: variable 'v42' is possibly undefined
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9ED68: using guessed type double dbl_9ED68;
// 9ED78: using guessed type int dword_9ED78;
// 9ED88: using guessed type double dbl_9ED88;
// 9F7D4: using guessed type int stdout;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AF0EC: using guessed type int dword_1AF0EC;
// 1AF148: using guessed type _BYTE algn_1AF148[8];
// 1AF158: using guessed type double dbl_1AF158[11];
// 1AF1B0: using guessed type int dword_1AF1B0;
// 1B064C: using guessed type int dword_1B064C;
// 1B0650: using guessed type double dbl_1B0650;
// 242EA0: using guessed type int dword_242EA0;
// 242F08: using guessed type char byte_242F08;
// 242FF0: using guessed type int dword_242FF0;
// 244004: using guessed type int dword_244004;
// 244080: using guessed type char byte_244080;
// 245108: using guessed type int dword_245108;
// 245110: using guessed type double dbl_245110;
// 245208: using guessed type double dbl_245208;
// 245210: using guessed type double dbl_245210;
// 245218: using guessed type double dbl_245218;
// 245228: using guessed type double dbl_245228;
// 2463B8: using guessed type pthread_mutex_t stru_2463B8;

//----- (0005F3DC) --------------------------------------------------------
void __fastcall sub_5F3DC(int a1)
{
  int v2; // r8
  int v3; // r3
  int v4; // r3
  int v5; // r9
  int v6; // r11
  unsigned __int64 v7; // r6
  int v8; // r3
  void **v9; // r3
  double v10; // d7
  void **v11; // r2
  int *v12; // r5
  struct timeval *v13; // r0
  __int64 v14; // r4
  __suseconds_t tv_usec; // r4
  __time_t tv_sec; // r3
  int v17; // r1
  int v18; // r5
  bool v19; // nf
  int v20; // r4
  int v21; // r4
  int v22; // r3
  bool v23; // cc
  unsigned __int64 v24; // r2
  _BOOL4 v25; // r1
  int v26; // r3
  int v27; // r1
  unsigned int v28; // r0
  int v29; // [sp+Ch] [bp-868h]
  _DWORD *v30; // [sp+10h] [bp-864h]
  _DWORD *v31; // [sp+14h] [bp-860h]
  unsigned int v32; // [sp+18h] [bp-85Ch]
  int v33; // [sp+24h] [bp-850h]
  void *v34; // [sp+28h] [bp-84Ch]
  __time_t v35; // [sp+2Ch] [bp-848h]
  __time_t v36; // [sp+2Ch] [bp-848h]
  struct timespec *remaining; // [sp+30h] [bp-844h]
  unsigned int v38; // [sp+38h] [bp-83Ch]
  unsigned int v39; // [sp+44h] [bp-830h]
  void **v40; // [sp+4Ch] [bp-828h] BYREF
  struct timeval v41; // [sp+50h] [bp-824h] BYREF
  struct timeval v42; // [sp+58h] [bp-81Ch] BYREF
  struct timeval v43; // [sp+60h] [bp-814h] BYREF
  struct timeval v44; // [sp+68h] [bp-80Ch] BYREF
  struct timespec requested_time; // [sp+70h] [bp-804h] BYREF

  v2 = *(_DWORD *)(a1 + 36);
  v29 = *(_DWORD *)(v2 + 4);
  v3 = dword_9ED78 / 5;
  if ( (int)((unsigned __int64)(1717986919LL * dword_9ED78) >> 32) >> 1 == dword_9ED78 >> 31 )
    v3 = 1;
  v33 = v3;
  if ( *(_DWORD *)(a1 + 4) )
    v4 = *(unsigned __int8 *)(a1 + 8);
  else
    v4 = 1;
  v34 = *(void **)a1;
  remaining = (struct timespec *)v4;
  v32 = (*(int (__fastcall **)(int))(v29 + 48))(a1);
  sub_4A60C(&v41);
  sub_4A60C(&v44);
  if ( *(_BYTE *)(v2 + 364) )
    goto LABEL_53;
  v5 = *(unsigned __int8 *)(v2 + 364);
  v6 = v5;
  v7 = 0;
  v8 = (_DWORD)&unk_F4240 * v33 + 1023;
  if ( (int)&unk_F4240 * v33 >= 0 )
    v8 = (_DWORD)&unk_F4240 * v33;
  v38 = v8 >> 10;
  do
  {
    v40 = sub_5BB20(a1, v34);
    *(_BYTE *)(a1 + 62) = 0;
    *(_BYTE *)(v2 + 172) = 1;
    sub_4A60C(&v43);
    v40[62] = 0;
    *(_QWORD *)(v2 + 160) = 0;
    if ( !(*(int (__fastcall **)(int))(v29 + 56))(a1) )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
      {
        snprintf((char *)&requested_time, 0x800u, "work prepare failed, exiting mining thread %d", v34);
        sub_47AB4(3, (const char *)&requested_time, 0);
      }
      break;
    }
    v9 = v40;
    v31 = (_DWORD *)(v2 + 304);
    v10 = *(double *)(v29 + 104);
    v30 = (_DWORD *)(v2 + 312);
    if ( v10 > *((double *)v40 + 47) )
      v10 = *((double *)v40 + 47);
    *((double *)v40 + 28) = v10;
    if ( *(double *)(v29 + 112) > v10 )
      v10 = *(double *)(v29 + 112);
    *((double *)v9 + 28) = v10;
    while ( 1 )
    {
      sub_4A60C(&v42);
      sub_4A22C(&v42, &v41.tv_sec);
      sub_4A260(&v41, (int *)(v2 + 296));
      if ( sub_4A2A4(&v41, v31) )
        sub_4C460(v31, &v41);
      if ( sub_4A2D8(&v41, v30) )
        sub_4C460(v30, &v41);
      v11 = v40;
      ++*(_DWORD *)(v2 + 292);
      v12 = (int *)v11[65];
      sub_4A260(&v41, v12 + 97);
      if ( sub_4A2A4(&v41, v12 + 99) )
        sub_4C460(v12 + 99, &v41);
      if ( sub_4A2D8(&v41, v12 + 101) )
        sub_4C460(v12 + 101, &v41);
      v13 = (struct timeval *)v40;
      ++v12[96];
      sub_4A60C(v13 + 53);
      pthread_setcancelstate(1, 0);
      sub_51AE4(a1);
      v14 = ((__int64 (__fastcall *)(int, void **, char *, _DWORD))*(_DWORD *)(v29 + 64))(
              a1,
              v40,
              (char *)v40[62] + v32,
              0);
      sub_51AAC(a1);
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      sub_4A60C(&v41);
      if ( v14 == -1 )
        break;
      v7 += v14;
      if ( *(_QWORD *)(v2 + 160) < v14 )
        *(_QWORD *)(v2 + 160) = v14;
      tv_usec = v41.tv_usec;
      tv_sec = v41.tv_sec;
      v17 = v41.tv_sec - v42.tv_sec;
      v5 += v41.tv_usec - v42.tv_usec + (v41.tv_usec - v42.tv_usec < 0 ? 0xF4240 : 0);
      if ( v41.tv_usec - v42.tv_usec < 0 )
        --v17;
      v6 += v17;
      if ( v5 > (int)&unk_F4240 )
      {
        ++v6;
        v5 -= 1000000;
      }
      v18 = v41.tv_sec - v43.tv_sec;
      if ( v41.tv_usec - v43.tv_usec < 0 )
        --v18;
      if ( v33 > v6 )
      {
        if ( v32 == -1 )
          goto LABEL_48;
        v27 = v5 + 1024;
        v35 = v41.tv_sec;
        if ( v5 + 1024 < 0 )
          v27 = v5 + 2047;
        v39 = (sub_772E8((int)&unk_F4240, v27 >> 10) + 16) * v33;
        tv_sec = v35;
        if ( 0xFFFFFC00 / v39 >= v32 )
          v32 = (v32 * v39) >> 10;
        else
          v32 = -1;
      }
      else if ( v33 < v6 )
      {
        tv_sec = v41.tv_sec;
        v32 = v33 * v32 / v6;
      }
      else if ( v5 > 100000 )
      {
        v36 = v41.tv_sec;
        v28 = sub_772E8((_DWORD)&unk_F4240 * v33 + v5, v38);
        tv_sec = v36;
        v32 = (v32 << 10) / v28;
      }
      v20 = tv_usec - v44.tv_usec;
      v19 = v20 < 0;
      v21 = v20 + (v20 < 0 ? 0xF4000 : 0);
      v22 = tv_sec - v44.tv_sec;
      if ( v19 )
      {
        --v22;
        v21 += 576;
      }
      if ( v7 )
      {
        v23 = v22 <= 0;
        if ( v22 <= 0 )
          v23 = v21 <= 200000;
        if ( !v23 )
          goto LABEL_43;
      }
      if ( dword_9ED78 <= v22 )
      {
LABEL_43:
        v24 = v7;
        v7 = 0;
        sub_5E2EC((int)v34, v24);
        sub_4C460(&v44, &v41);
        if ( *(_BYTE *)(a1 + 62) )
          goto LABEL_56;
      }
      else if ( *(_BYTE *)(a1 + 62) )
      {
LABEL_56:
        if ( !remaining )
        {
          v26 = *(_DWORD *)(a1 + 4);
          requested_time.tv_sec = 0;
          requested_time.tv_nsec = 250000000 * v26;
          nanosleep(&requested_time, 0);
        }
        goto LABEL_52;
      }
      if ( *(_BYTE *)(a1 + 60) || (v5 = *(_DWORD *)(v2 + 32)) != 0 )
      {
        v5 = 0;
        v6 = 0;
        sub_524EC(a1, (int)v34, (int (__fastcall **)(int))(v29 + 92));
      }
      else
      {
        v6 = 0;
      }
LABEL_48:
      v25 = *(_QWORD *)(v2 + 160) > 0xFFFFFFFD;
      if ( dword_9ED98 < v18 )
        v25 = 1;
      if ( v25 || sub_5B638((int)v40, 0) )
        goto LABEL_52;
    }
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 2 )
    {
      snprintf(
        (char *)&requested_time,
        0x800u,
        "%s %d failure, disabling!",
        *(const char **)(v29 + 8),
        *(_DWORD *)(v2 + 8));
      sub_47AB4(3, (const char *)&requested_time, 0);
    }
    *(_DWORD *)(v2 + 32) = 1;
    sub_4BA2C((_DWORD *)v2, 1);
    *(_BYTE *)(v2 + 364) = 1;
LABEL_52:
    sub_53084(&v40, "cgminer.c", "hash_sole_work", 9345);
  }
  while ( !*(_BYTE *)(v2 + 364) );
LABEL_53:
  *(_DWORD *)(v2 + 32) = 1;
}
// 9E320: using guessed type int dword_9E320;
// 9ED78: using guessed type int dword_9ED78;
// 9ED98: using guessed type int dword_9ED98;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (0005FAA0) --------------------------------------------------------
int __fastcall sub_5FAA0(_DWORD *a1)
{
  pthread_t v2; // r0
  int v3; // r0
  fd_set *v4; // r3
  int v5; // r3
  int v6; // r2
  bool v7; // nf
  int v8; // r1
  time_t *v9; // r2
  int v10; // r0
  char *v11; // r5
  int v13; // r3
  int v14; // r2
  int v15; // r4
  double *v16; // r0
  double *v17; // r7
  _DWORD *v18; // r9
  _DWORD *v19; // r10
  _DWORD *v20; // r0
  int v21; // r4
  unsigned int *v22; // r3
  unsigned int v23; // r2
  unsigned int v24; // r2
  void **v25; // r0
  void **v26; // r7
  time_t *v27; // r2
  time_t v28; // r8
  size_t v29; // r9
  unsigned __int8 *v30; // r11
  size_t v31; // r8
  unsigned int v32; // r0
  int v33; // r12
  unsigned int v34; // r2
  int v35; // r1
  unsigned int v36; // r1
  int v37; // r3
  int v38; // r0
  unsigned int v39; // r2
  unsigned int v40; // r1
  unsigned int v41; // r2
  int v42; // r3
  unsigned int v43; // r1
  unsigned int v44; // r4
  unsigned int v45; // r3
  size_t v46; // r3
  char *v47; // r4
  int v48; // r2
  size_t v49; // r12
  unsigned int v50; // r3
  unsigned int v51; // r1
  int v52; // r2
  unsigned int v53; // r12
  unsigned int v54; // r3
  unsigned int v55; // r2
  unsigned int v56; // r8
  _DWORD *v57; // r2
  int v58; // r4
  int v59; // r9
  int v60; // r4
  int v61; // r3
  int *v62; // r0
  const char *v63; // lr
  int v64; // r3
  int v65; // r12
  int *v66; // r0
  int *v67; // r0
  const char *v68; // lr
  int v69; // r3
  int v70; // r12
  int *v71; // r0
  const char *v72; // lr
  int v73; // r3
  int v74; // r12
  int *v75; // r0
  int *v76; // r0
  char *v77; // r0
  int v78; // r10
  int v79; // lr
  int v80; // r4
  int v81; // r3
  int v82; // r9
  int v83; // r7
  int v84; // r1
  int v85; // r0
  unsigned int v86; // r8
  int v87; // r3
  int v88; // r12
  int v89; // r2
  int v90; // r12
  int v91; // r5
  bool v92; // zf
  int v93; // r3
  bool v94; // zf
  bool v95; // zf
  int v96; // r11
  int v97; // r2
  int v98; // r8
  int v99; // r1
  int v100; // r2
  int v101; // r12
  int v102; // r3
  int v103; // r3
  _DWORD *v104; // r2
  int v105; // r3
  int v106; // r2
  __int64 v107; // r2
  size_t v108; // r2
  unsigned int v109; // r3
  unsigned __int8 *v110; // r11
  int v111; // r0
  unsigned int v112; // r4
  int v113; // r9
  unsigned int v114; // r1
  unsigned __int8 *v115; // r8
  int v116; // r2
  int v117; // r12
  size_t v118; // lr
  int v119; // r0
  unsigned int v120; // r2
  unsigned int v121; // r3
  int v122; // r1
  unsigned int v123; // r2
  unsigned int v124; // r3
  unsigned int v125; // r1
  unsigned int v126; // r2
  size_t v127; // r1
  size_t v128; // r2
  size_t v129; // r1
  int v130; // r11
  int v131; // r2
  unsigned int v132; // r12
  unsigned int v133; // r3
  int v134; // r2
  unsigned int v135; // r1
  unsigned int v136; // r3
  unsigned int v137; // r2
  unsigned int v138; // r9
  int v139; // r3
  int v140; // r8
  _DWORD *v141; // r3
  int v142; // r2
  int v143; // r3
  int v144; // r3
  int v145; // r1
  int *v146; // r3
  __int64 v147; // r2
  int v148; // r3
  _DWORD *v149; // r9
  int v150; // r2
  int v151; // r12
  unsigned int v152; // r0
  _DWORD *v153; // r3
  int v154; // r6
  _DWORD *v155; // r10
  _DWORD *v156; // r8
  _DWORD *v157; // r5
  int v158; // r4
  char *v159; // r11
  unsigned int v160; // r3
  int v161; // r1
  int v162; // r3
  bool v163; // cf
  _DWORD *v164; // r3
  _DWORD *v165; // r3
  unsigned int v166; // r2
  unsigned int v167; // r1
  bool v168; // cc
  int v169; // r2
  int v170; // r3
  int v171; // r0
  signed int v172; // r8
  char v173; // r1
  int v174; // r2
  __int64 v175; // r0
  double v176; // r0
  double v177; // d8
  int v178; // r4
  struct tm *v179; // r0
  int v180; // r1
  char *v181; // r3
  int v182; // t1
  int v183; // r2
  const char *v184; // r2
  int v185; // r12
  char *v186; // r3
  unsigned int v187; // r4
  unsigned int v188; // r3
  unsigned int v189; // r1
  unsigned int v190; // r2
  int v191; // r3
  unsigned int v192; // r1
  unsigned int v193; // r2
  int v194; // r3
  unsigned int v195; // r1
  int v196; // r4
  int v197; // r4
  int v198; // r4
  int v199; // r2
  _DWORD *v200; // r11
  int **v201; // r2
  int v202; // r3
  int *v203; // r1
  int v204; // r3
  int v205; // r1
  int v206; // r1
  int v207; // r3
  int v208; // r8
  time_t v209; // r0
  int v210; // r3
  int v211; // r0
  unsigned int *p_s1; // r2
  int i; // r3
  int v214; // t1
  double v215; // d0
  char *v216; // r12
  unsigned int *v217; // r3
  unsigned int v218; // r2
  unsigned int v219; // r2
  int *v220; // r0
  int v221; // r4
  unsigned __int8 *v222; // r10
  size_t v223; // r2
  int v224; // r3
  int *v225; // r0
  int *v226; // r0
  int *v227; // r0
  const char *v228; // lr
  int v229; // r3
  int v230; // r12
  int *v231; // r0
  int v232; // r9
  void *v233; // r0
  void **v234; // r11
  void *v235; // r0
  char *v236; // r3
  void *v237; // r4
  int *v238; // r0
  int *v239; // r0
  int *v240; // r0
  int *v241; // r0
  int *v242; // r0
  double v243; // d8
  unsigned int v244; // r0
  __int64 v245; // kr08_8
  double v246; // d6
  double v247; // d7
  unsigned int v248; // kr04_4
  double v249; // d6
  int v250; // r3
  int v251; // r2
  double v252; // d7
  int v253; // r1
  int v254; // [sp+4h] [bp-A20h]
  time_t *timer; // [sp+18h] [bp-A0Ch]
  void **timera; // [sp+18h] [bp-A0Ch]
  time_t *timerb; // [sp+18h] [bp-A0Ch]
  unsigned int v258; // [sp+30h] [bp-9F4h]
  size_t n; // [sp+3Ch] [bp-9E8h]
  size_t na; // [sp+3Ch] [bp-9E8h]
  size_t nb; // [sp+3Ch] [bp-9E8h]
  size_t nc; // [sp+3Ch] [bp-9E8h]
  _DWORD *nd; // [sp+3Ch] [bp-9E8h]
  int v264; // [sp+40h] [bp-9E4h]
  int v265; // [sp+44h] [bp-9E0h]
  char *v266; // [sp+44h] [bp-9E0h]
  _DWORD *v267; // [sp+44h] [bp-9E0h]
  size_t v268; // [sp+48h] [bp-9DCh]
  int v269; // [sp+48h] [bp-9DCh]
  char *v270; // [sp+50h] [bp-9D4h]
  int v271; // [sp+54h] [bp-9D0h]
  void **v272; // [sp+58h] [bp-9CCh] BYREF
  struct timeval timeout; // [sp+5Ch] [bp-9C8h] BYREF
  char s[16]; // [sp+64h] [bp-9C0h] BYREF
  char v275[16]; // [sp+74h] [bp-9B0h] BYREF
  unsigned int s1; // [sp+84h] [bp-9A0h] BYREF
  unsigned int v277; // [sp+88h] [bp-99Ch]
  unsigned int v278; // [sp+8Ch] [bp-998h]
  unsigned int v279; // [sp+90h] [bp-994h]
  unsigned int v280; // [sp+94h] [bp-990h]
  unsigned int v281; // [sp+98h] [bp-98Ch]
  unsigned int v282; // [sp+9Ch] [bp-988h]
  unsigned int v283; // [sp+A0h] [bp-984h] BYREF
  fd_set readfds; // [sp+A4h] [bp-980h] BYREF
  char s2[12]; // [sp+124h] [bp-900h] BYREF
  char v286; // [sp+130h] [bp-8F4h] BYREF
  char v287[160]; // [sp+180h] [bp-8A4h] BYREF
  time_t v288[513]; // [sp+220h] [bp-804h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf(s, 0x10u, "%d/RStratum", *a1);
  sub_4BD10(s);
LABEL_2:
  v3 = (int)a1;
  if ( *((_BYTE *)a1 + 105) )
    goto LABEL_16;
  do
  {
    if ( !sub_4AB90(v3) && !sub_584B4((int)a1) )
    {
      sub_4AFA8((int)a1);
      sub_5A44C((int)a1);
      sub_59B44(a1);
      while ( !sub_584B4((int)a1) )
      {
        if ( a1[25] && (a1 == (_DWORD *)sub_58084() || (unsigned int)(dword_1AEEB8 - 3) <= 1) )
          break;
        if ( pthread_mutex_lock(&stru_1AF1B8) )
        {
          v76 = _errno_location();
          v63 = "wait_lpcurrent";
          v64 = *v76;
          v65 = 9907;
          goto LABEL_135;
        }
        pthread_cond_wait(&cond, &stru_1AF1B8);
        if ( pthread_mutex_unlock(&stru_1AF1B8) )
        {
          v75 = _errno_location();
          v68 = "wait_lpcurrent";
          v69 = *v75;
          v70 = 9909;
LABEL_139:
          snprintf(
            (char *)v288,
            0x800u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            v69,
            "cgminer.c",
            v68,
            v70);
          goto LABEL_136;
        }
        off_9E444();
      }
      while ( !sub_4F2F8((int)a1) )
      {
        sub_5A31C((int)a1);
        if ( *((_BYTE *)a1 + 105) )
          return 0;
        sub_4A804();
      }
    }
    v4 = (fd_set *)&v283;
    do
    {
      v4->__fds_bits[1] = 0;
      v4 = (fd_set *)((char *)v4 + 4);
    }
    while ( &readfds.__fds_bits[31] != (__fd_mask *)v4 );
    v5 = a1[147];
    timeout.tv_usec = 0;
    timeout.tv_sec = 90;
    v6 = v5 + 31;
    if ( v5 >= 0 )
      v6 = v5;
    v7 = -v5 < 0;
    v8 = -v5 & 0x1F;
    LOBYTE(v5) = v5 & 0x1F;
    v9 = &v288[(v6 >> 5) + 512];
    if ( !v7 )
      v5 = -v8;
    *(v9 - 607) |= 1 << v5;
    if ( !sub_4AB90((int)a1) )
    {
      v10 = select(a1[147] + 1, &readfds, 0, 0, &timeout);
      if ( v10 <= 0 )
      {
        v13 = (unsigned __int8)byte_244080;
        if ( byte_1AECC5 )
        {
          if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
            goto LABEL_55;
          snprintf((char *)v288, 0x800u, "Stratum select failed on pool %d with value %d", *a1, v10);
          sub_47AB4(7, (const char *)v288, 0);
          v13 = (unsigned __int8)byte_244080;
        }
LABEL_28:
        if ( v13 || byte_1AECC4 )
        {
LABEL_30:
          snprintf((char *)v288, 0x800u, "Stratum connection to pool %d interrupted", *a1);
          sub_47AB4(5, (const char *)v288, 0);
LABEL_31:
          v14 = dword_245150;
          ++a1[32];
          dword_245150 = v14 + 1;
          if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
          {
            v62 = _errno_location();
            v63 = "supports_resume";
            v64 = *v62;
            v65 = 7477;
LABEL_135:
            snprintf(
              (char *)v288,
              0x800u,
              "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
              v64,
              "cgminer.c",
              v63,
              v65);
            goto LABEL_136;
          }
          if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
          {
            v66 = _errno_location();
            snprintf(
              (char *)v288,
              0x800u,
              "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
              *v66,
              "cgminer.c",
              "supports_resume",
              7477);
            goto LABEL_136;
          }
          if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
          {
            v67 = _errno_location();
            v68 = "supports_resume";
            v69 = *v67;
            v70 = 7477;
            goto LABEL_139;
          }
          v15 = a1[159];
          if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
          {
            v71 = _errno_location();
            v72 = "supports_resume";
            v73 = *v71;
            v74 = 7479;
            goto LABEL_141;
          }
          off_9E444();
          if ( !v15 || byte_245204 )
            sub_5A44C((int)a1);
          sub_59B44(a1);
          if ( a1 == (_DWORD *)sub_58084() )
            sub_54FC0();
          while ( !sub_4F2F8((int)a1) )
          {
            sub_5A31C((int)a1);
            if ( *((_BYTE *)a1 + 105) )
              return 0;
            sub_4A804();
          }
          goto LABEL_2;
        }
LABEL_55:
        if ( dword_9E320 <= 4 )
          goto LABEL_31;
        goto LABEL_30;
      }
    }
    v11 = sub_4B4C0((int)a1);
    if ( !v11 )
    {
      v13 = (unsigned __int8)byte_244080;
      goto LABEL_28;
    }
    sub_58490((int)a1);
    if ( !sub_50324(a1, (int)v11) )
    {
      v16 = sub_6D110((int)v11, 0, s2);
      v17 = v16;
      if ( v16 )
      {
        v18 = (_DWORD *)sub_6DFCC(v16, "result");
        v19 = (_DWORD *)sub_6DFCC(v17, "error");
        v20 = (_DWORD *)sub_6DFCC(v17, "id");
        v21 = (int)v20;
        if ( v20 && *v20 != 7 )
        {
          if ( sub_6DFCC(v18, "version-rolling.mask")
            || strstr(v11, "mining.configure")
            || strstr(v11, "mining.set_version_mask") )
          {
            goto LABEL_48;
          }
          v187 = sub_6E430(v21);
          v272 = (void **)v187;
          if ( pthread_mutex_lock(&stru_1AF200) )
            sub_550B8("parse_stratum_response", 7286);
          timera = (void **)dword_1AF218;
          v188 = ((unsigned __int8)v187 + 17973517 + (v187 & 0xFF000000) + (v187 & 0xFF0000) + (v187 & 0xFF00))
               ^ (unsigned int)&unk_7F76D;
          v189 = (-1622558010 - v188) ^ (v188 << 8);
          v190 = (-17973517 - v188 - v189) ^ (v189 >> 13);
          v191 = (v188 - v189 - v190) ^ (v190 >> 12);
          v192 = (v189 - v190 - v191) ^ (v191 << 16);
          v193 = (v190 - v191 - v192) ^ (v192 >> 5);
          v194 = (v191 - v192 - v193) ^ (v193 >> 3);
          v195 = (v193 - v194 - ((v192 - v193 - v194) ^ (v194 << 10))) ^ (((v192 - v193 - v194) ^ (v194 << 10)) >> 15);
          v258 = v195;
          if ( !dword_1AF218
            || (nd = **(_DWORD ***)dword_1AF218,
                (v196 = nd[3 * ((*(_DWORD *)(*(_DWORD *)dword_1AF218 + 4) - 1) & v195)]) == 0)
            || (v264 = *(_DWORD *)(*(_DWORD *)dword_1AF218 + 20), (v197 = v196 - v264) == 0) )
          {
LABEL_403:
            if ( pthread_mutex_unlock(&stru_1AF200) )
LABEL_428:
              sub_55114("parse_stratum_response", 7294);
            off_9E444();
            if ( v18 )
            {
              if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
                sub_550B8("parse_stratum_response", 7306);
              if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
                sub_561E4("parse_stratum_response", 7306);
              if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
                sub_55114("parse_stratum_response", 7306);
              v243 = *((double *)a1 + 228);
              if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
                sub_55C08("parse_stratum_response", 7308);
              off_9E444();
              if ( *v18 == 5 )
              {
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
                {
                  snprintf((char *)v288, 0x800u, "Accepted untracked stratum share from pool %d", *a1);
                  sub_47AB4(5, (const char *)v288, 0);
                }
                if ( pthread_mutex_lock(&stru_246244) )
                  sub_550B8("parse_stratum_response", 7316);
                v249 = *((double *)a1 + 9) + v243;
                ++qword_245158;
                v250 = a1[2];
                v251 = a1[3];
                v252 = dbl_242EF0 + v243;
                *((double *)a1 + 9) = v249;
                a1[2] = v250 + 1;
                a1[3] = __CFADD__(v250, 1) + v251;
                dbl_242EF0 = v252;
                if ( pthread_mutex_unlock(&stru_246244) )
                  sub_55114("parse_stratum_response", 7321);
              }
              else
              {
                if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
                {
                  snprintf((char *)v288, 0x800u, "Rejected untracked stratum share from pool %d", *a1);
                  sub_47AB4(5, (const char *)v288, 0);
                }
                if ( pthread_mutex_lock(&stru_246244) )
                  sub_550B8("parse_stratum_response", 7327);
                v244 = a1[5];
                v245 = qword_246368 + 1;
                v246 = *((double *)a1 + 10) + v243;
                v247 = dbl_242F10 + v243;
                v248 = a1[4];
                LODWORD(qword_246368) = qword_246368 + 1;
                a1[4] = v248 + 1;
                *((double *)a1 + 10) = v246;
                a1[5] = (__PAIR64__(v244, v248) + 1) >> 32;
                HIDWORD(qword_246368) = HIDWORD(v245);
                dbl_242F10 = v247;
                if ( pthread_mutex_unlock(&stru_246244) )
                  sub_55114("parse_stratum_response", 7332);
              }
              off_9E444();
              if ( *((_DWORD *)v17 + 1) == -1 )
                goto LABEL_61;
            }
            else
            {
LABEL_48:
              if ( *((_DWORD *)v17 + 1) == -1 )
                goto LABEL_61;
            }
LABEL_49:
            v22 = (unsigned int *)v17 + 1;
            __dmb(0xBu);
            do
            {
              v23 = __ldrex(v22);
              v24 = v23 - 1;
            }
            while ( __strex(v24, v22) );
            if ( !v24 )
              sub_6E5DC((void **)v17);
            goto LABEL_61;
          }
          v267 = *(_DWORD **)dword_1AF218;
          while ( v258 != *(_DWORD *)(v197 + 28)
               || *(_DWORD *)(v197 + 24) != 4
               || memcmp(*(const void **)(v197 + 20), &v272, 4u) )
          {
            v198 = *(_DWORD *)(v197 + 16);
            if ( v198 )
            {
              v197 = v198 - v264;
              if ( v197 )
                continue;
            }
            goto LABEL_403;
          }
          v199 = *(_DWORD *)(v197 + 4);
          v200 = v267;
          if ( v199 )
          {
            if ( v197 != v267[4] - v264 )
            {
LABEL_317:
              *(_DWORD *)(v199 + v200[5] + 8) = *(_DWORD *)(v197 + 8);
LABEL_318:
              v201 = (int **)dword_1AF218;
              v202 = *(_DWORD *)(v197 + 8);
              v203 = *(int **)dword_1AF218;
              if ( v202 )
              {
                *(_DWORD *)(v202 + v203[5] + 4) = *(_DWORD *)(v197 + 4);
                v203 = *v201;
              }
              v204 = 12 * ((v203[1] - 1) & *(_DWORD *)(v197 + 28));
              --*(_DWORD *)(*v203 + v204 + 4);
              v205 = **v201;
              if ( *(_DWORD *)(v205 + v204) == v197 )
                *(_DWORD *)(v205 + v204) = *(_DWORD *)(v197 + 16);
              v206 = *(_DWORD *)(v197 + 12);
              v207 = *(_DWORD *)(v197 + 16);
              if ( v206 )
              {
                *(_DWORD *)(v206 + 16) = v207;
                v207 = *(_DWORD *)(v197 + 16);
              }
              if ( v207 )
                *(_DWORD *)(v207 + 12) = *(_DWORD *)(v197 + 12);
              --(*v201)[3];
              goto LABEL_327;
            }
          }
          else
          {
            v253 = *(_DWORD *)(v197 + 8);
            if ( !v253 )
            {
              free(nd);
              free(*timera);
              dword_1AF218 = 0;
LABEL_327:
              --a1[183];
              if ( pthread_mutex_unlock(&stru_1AF200) )
                goto LABEL_428;
              off_9E444();
              v208 = *(_DWORD *)(v197 + 36);
              v209 = time(0);
              v210 = (unsigned __int8)byte_1AECC5;
              v211 = v209 - *(_DWORD *)(v197 + 48);
              if ( v211 > 0 )
                v210 = (unsigned __int8)byte_1AECC5 | 1;
              if ( v210 && (byte_244080 || byte_1AECC4 || dword_9E320 > 5) )
              {
                snprintf(
                  (char *)v288,
                  0x800u,
                  "Pool %d stratum share result lag time %d seconds",
                  **(_DWORD **)(v208 + 260),
                  v211);
                sub_47AB4(6, (const char *)v288, 0);
              }
              p_s1 = &s1;
              s1 = bswap32(*(_DWORD *)(v208 + 220));
              v277 = bswap32(*(_DWORD *)(v208 + 216));
              v278 = bswap32(*(_DWORD *)(v208 + 212));
              v279 = bswap32(*(_DWORD *)(v208 + 208));
              v280 = bswap32(*(_DWORD *)(v208 + 204));
              v281 = bswap32(*(_DWORD *)(v208 + 200));
              v282 = bswap32(*(_DWORD *)(v208 + 196));
              v283 = bswap32(*(_DWORD *)(v208 + 192));
              for ( i = 0; i != 29; ++i )
              {
                v214 = *(unsigned __int8 *)p_s1;
                p_s1 = (unsigned int *)((char *)p_s1 + 1);
                if ( v214 )
                  break;
              }
              v215 = *(double *)(v208 + 376);
              timerb = (time_t *)bswap32(*(unsigned int *)((char *)&s1 + i));
              round();
              sub_51B18(*(_QWORD *)(v208 + 232), v275, 0x10u, 0);
              if ( *(_BYTE *)(v208 + 283) )
                v216 = " BLOCK!";
              else
                v216 = "";
              snprintf((char *)v288, 0x40u, "%08lx Diff %s/%llu%s", timerb, v275, v254, (unsigned __int64)v215, v216);
              sub_5D8CC(v17, v18, v19, v208, (const char *)v288);
              sub_53084((void ***)(v197 + 36), "cgminer.c", "parse_stratum_response", 7339);
              free((void *)v197);
              if ( *((_DWORD *)v17 + 1) != -1 )
              {
                v217 = (unsigned int *)v17 + 1;
                __dmb(0xBu);
                do
                {
                  v218 = __ldrex(v217);
                  v219 = v218 - 1;
                }
                while ( __strex(v219, v217) );
                if ( !v219 )
                  sub_6E5DC((void **)v17);
              }
              goto LABEL_14;
            }
            if ( v197 != v267[4] - v264 )
              goto LABEL_432;
          }
          v267[4] = v199 + v264;
          v199 = *(_DWORD *)(v197 + 4);
          if ( v199 )
          {
            v200 = *timera;
            goto LABEL_317;
          }
          v253 = *(_DWORD *)(v197 + 8);
LABEL_432:
          dword_1AF218 = v253;
          goto LABEL_318;
        }
        if ( v19 )
        {
          v47 = (char *)sub_6B6E8(v19, 3);
        }
        else
        {
          v47 = (char *)malloc(0x11u);
          if ( v47 )
            strcpy(v47, "(unknown reason)");
        }
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
        {
          snprintf((char *)v288, 0x800u, "JSON-RPC non method decode failed: %s", v47);
          sub_47AB4(6, (const char *)v288, 0);
        }
        free(v47);
        if ( *((_DWORD *)v17 + 1) != -1 )
          goto LABEL_49;
      }
      else if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
      {
        snprintf((char *)v288, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)s2, v287);
        sub_47AB4(6, (const char *)v288, 0);
      }
LABEL_61:
      if ( !sub_4AC60(a1, (int)v11) )
      {
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
        {
          snprintf((char *)v288, 0x800u, "Unknown stratum msg: %s", v11);
          sub_47AB4(6, (const char *)v288, 0);
        }
        goto LABEL_15;
      }
    }
LABEL_14:
    if ( !*((_BYTE *)a1 + 680) )
      goto LABEL_15;
    v25 = (void **)sub_55E38();
    *((_BYTE *)a1 + 680) = 0;
    v272 = v25;
    sub_5A7E8((int)a1, (int)v25);
    v26 = v272;
    v27 = (time_t *)v272[65];
    *((_BYTE *)v272 + 280) = 1;
    v28 = v27[392];
    timer = v27;
    v29 = *(unsigned __int8 *)(v28 + 42);
    *(_DWORD *)v275 = 0;
    if ( *((_BYTE *)v26 + 282) )
      goto LABEL_54;
    v30 = (unsigned __int8 *)&v286;
    s1 = (unsigned int)v26[8];
    v277 = (unsigned int)v26[7];
    v278 = (unsigned int)v26[6];
    v279 = (unsigned int)v26[5];
    v280 = (unsigned int)v26[4];
    v281 = (unsigned int)v26[3];
    v282 = (unsigned int)v26[2];
    v283 = (unsigned int)v26[1];
    sub_4981C(s2, (int)&s1, 32);
    if ( v29 <= 4 )
    {
      sub_4C150(v275, (const void *)(v28 + 43), v29, (int)"cgminer.c", (int)"test_work_current", 5644);
      --*(_DWORD *)v275;
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)(timer + 53)) )
    {
      v225 = _errno_location();
      v63 = "test_work_current";
      v64 = *v225;
      v65 = 5649;
      goto LABEL_135;
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(timer + 59)) )
    {
      v227 = _errno_location();
      v228 = "test_work_current";
      v229 = *v227;
      v230 = 5649;
LABEL_357:
      snprintf((char *)v288, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v229, "cgminer.c", v228, v230);
      goto LABEL_136;
    }
    if ( *((_BYTE *)timer + 680) )
    {
      *((_BYTE *)timer + 680) = 0;
      *((_BYTE *)v26 + 280) = 1;
    }
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(timer + 59)) )
    {
      v226 = _errno_location();
      v72 = "test_work_current";
      v73 = *v226;
      v74 = 5657;
LABEL_141:
      snprintf((char *)v288, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", v73, "cgminer.c", v72, v74);
LABEL_136:
      sub_47AB4(3, (const char *)v288, 1);
      sub_54CCC(1, 1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(timer + 53)) )
    {
      v220 = _errno_location();
      v68 = "test_work_current";
      v69 = *v220;
      v70 = 5657;
      goto LABEL_139;
    }
    off_9E444();
    v265 = pthread_rwlock_wrlock((pthread_rwlock_t *)&unk_1B0758);
    if ( v265 )
    {
      v231 = _errno_location();
      v228 = "block_exists";
      v229 = *v231;
      v230 = 5570;
      goto LABEL_357;
    }
    v31 = strlen(s2);
    n = v31;
    LOWORD(v32) = 31161;
    if ( v31 > 0xB )
    {
      v224 = -17973521;
      HIWORD(v32) = -25033;
      v221 = v32;
      do
      {
        v31 -= 12;
        v222 = v30;
        v33 = (*(v30 - 10) << 16) + (*(v30 - 11) << 8) + *(v30 - 12) + (*(v30 - 9) << 24);
        v34 = (*(v30 - 6) << 16) + (*(v30 - 7) << 8) + *(v30 - 8) + (*(v30 - 5) << 24) + v32;
        v35 = (*(v30 - 2) << 16) + (*(v30 - 3) << 8) + *(v30 - 4) + (*(v30 - 1) << 24);
        v30 += 12;
        v36 = v35 + v224;
        v37 = (v33 - v34 - v36 + v221) ^ (v36 >> 13);
        v38 = v34 - v36 - v37;
        v39 = v36 - v37;
        v40 = v38 ^ (v37 << 8);
        v41 = (v39 - v40) ^ (v40 >> 13);
        v42 = (v37 - v40 - v41) ^ (v41 >> 12);
        v43 = (v40 - v41 - v42) ^ (v42 << 16);
        v44 = v42 - v43;
        v45 = (v41 - v42 - v43) ^ (v43 >> 5);
        v221 = (v44 - v45) ^ (v45 >> 3);
        v32 = (v43 - v45 - v221) ^ (v221 << 10);
        v224 = (v45 - v221 - v32) ^ (v32 >> 15);
      }
      while ( v31 > 0xB );
      v223 = v31;
    }
    else
    {
      HIWORD(v32) = -25033;
      v221 = v32;
      v222 = (unsigned __int8 *)s2;
      v223 = v31;
      v224 = -17973521;
    }
    v46 = n + v224;
    switch ( v223 )
    {
      case 1u:
        goto LABEL_107;
      case 2u:
        goto LABEL_106;
      case 3u:
        goto LABEL_105;
      case 4u:
        goto LABEL_104;
      case 5u:
        goto LABEL_103;
      case 6u:
        goto LABEL_102;
      case 7u:
        goto LABEL_101;
      case 8u:
        goto LABEL_100;
      case 9u:
        goto LABEL_99;
      case 0xAu:
        goto LABEL_98;
      case 0xBu:
        v46 += v222[10] << 24;
LABEL_98:
        v46 += v222[9] << 16;
LABEL_99:
        v46 += v222[8] << 8;
LABEL_100:
        v32 += v222[7] << 24;
LABEL_101:
        v32 += v222[6] << 16;
LABEL_102:
        v32 += v222[5] << 8;
LABEL_103:
        v32 += v222[4];
LABEL_104:
        v221 += v222[3] << 24;
LABEL_105:
        v221 += v222[2] << 16;
LABEL_106:
        v221 += v222[1] << 8;
LABEL_107:
        v221 += *v222;
        break;
      default:
        break;
    }
    v48 = (v221 - v32 - v46) ^ (v46 >> 13);
    v49 = v46 - v48;
    v50 = (v32 - v46 - v48) ^ (v48 << 8);
    v51 = (v49 - v50) ^ (v50 >> 13);
    v52 = (v48 - v50 - v51) ^ (v51 >> 12);
    v53 = (v50 - v51 - v52) ^ (v52 << 16);
    v54 = (v51 - v52 - v53) ^ (v53 >> 5);
    v55 = v52 - v53 - v54;
    v56 = (v54 - (v55 ^ (v54 >> 3)) - ((v53 - v54 - (v55 ^ (v54 >> 3))) ^ ((v55 ^ (v54 >> 3)) << 10)))
        ^ (((v53 - v54 - (v55 ^ (v54 >> 3))) ^ ((v55 ^ (v54 >> 3)) << 10)) >> 15);
    if ( dword_1B0778 )
    {
      v57 = *(_DWORD **)(dword_1B0778 + 68);
      v58 = *(_DWORD *)(*v57 + 12 * ((v57[1] - 1) & v56));
      if ( v58 )
      {
        v59 = -v57[5];
        v60 = v58 - v57[5];
        if ( v60 )
        {
          while ( v56 != *(_DWORD *)(v60 + 96)
               || n != *(_DWORD *)(v60 + 92)
               || memcmp(*(const void **)(v60 + 88), s2, n) )
          {
            v61 = *(_DWORD *)(v60 + 84);
            if ( v61 )
            {
              v60 = v61 + v59;
              if ( v61 + v59 )
                continue;
            }
            goto LABEL_146;
          }
          if ( pthread_rwlock_unlock((pthread_rwlock_t *)&unk_1B0758) )
            goto LABEL_393;
          off_9E444();
          if ( memcmp(timer + 136, &s1, 0x20u) )
          {
            if ( !memcmp(&s1, &unk_1B0784, 0x20u) )
            {
              if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
              {
                snprintf((char *)v288, 0x800u, "Pool %d now up to date at height %d", *timer, *(_DWORD *)v275);
                sub_47AB4(6, (const char *)v288, 0);
              }
              sub_4C150(timer + 136, &s1, 0x20u, (int)"cgminer.c", (int)"test_work_current", 5715);
            }
            else if ( byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
            {
              snprintf((char *)v288, 0x800u, "Stale data from pool %d at height %d", *timer, *(_DWORD *)v275);
              sub_47AB4(7, (const char *)v288, 0);
            }
          }
          if ( !*((_BYTE *)v26 + 280) )
            goto LABEL_133;
          v168 = (unsigned int)(dword_1AEEB8 - 3) > 1;
          v26[84] = (void *)++dword_1AF224;
          if ( v168 )
          {
            v237 = v26[65];
            if ( v237 != (void *)sub_58084() )
              goto LABEL_133;
          }
          if ( *((_BYTE *)v26 + 284) )
          {
            if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
            {
              snprintf((char *)v288, 0x800u, "Stratum from pool %d requested work restart", *timer);
              sub_47AB4(5, (const char *)v288, 0);
            }
            goto LABEL_132;
          }
          if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 4 )
            goto LABEL_132;
          v236 = "";
          if ( *((_BYTE *)v26 + 324) )
            v236 = "GBT ";
          snprintf((char *)v288, 0x800u, "%sLONGPOLL from pool %d requested work restart", v236, *(_DWORD *)v26[65]);
LABEL_302:
          sub_47AB4(5, (const char *)v288, 0);
          goto LABEL_132;
        }
      }
    }
LABEL_146:
    v77 = (char *)sub_496AC(0x68u, 1u, "cgminer.c", "block_exists", 5574);
    v78 = (int)v77;
    if ( !v77 )
    {
      strcpy((char *)v288, "block_exists OOM");
      sub_47AB4(3, (const char *)v288, 1);
      sub_54CCC(1, 1);
    }
    strcpy(v77, s2);
    v80 = dword_1B0778;
    v81 = dword_24625C;
    *(_DWORD *)(v78 + 100) = dword_24625C;
    dword_24625C = v81 + 1;
    if ( !v80 || *(_DWORD *)(*(_DWORD *)(v80 + 68) + 12) <= 3u )
      goto LABEL_205;
    na = (size_t)v26;
    v82 = 1;
    v83 = v80 + 68;
    v266 = v11;
    while ( 2 )
    {
      v84 = v83;
      v83 = 0;
      v85 = 0;
      v86 = 0;
      do
      {
        ++v86;
        if ( v82 )
        {
          v87 = *(_DWORD *)(v84 + 8);
          if ( v87 && (v88 = *(_DWORD *)(*(_DWORD *)(v80 + 68) + 20), (v87 += v88) != 0) )
          {
            v89 = 1;
            do
            {
              if ( v89 == v82 )
              {
                v90 = v89;
                goto LABEL_159;
              }
              v87 = *(_DWORD *)(v87 + 8);
              ++v89;
              if ( !v87 )
                break;
              v87 += v88;
            }
            while ( v87 );
            v90 = v82;
          }
          else
          {
            v90 = v82;
            v89 = 1;
          }
        }
        else
        {
          v87 = v84;
          v90 = 0;
          v89 = 0;
        }
LABEL_159:
        v91 = v84;
        v84 = v87;
        while ( v89 )
        {
          v95 = v84 == 0;
          if ( v84 )
            v95 = v90 == 0;
          if ( v95 )
          {
            if ( v91 )
            {
              v79 = *(_DWORD *)(v91 + 8);
              if ( v79 )
                v79 += *(_DWORD *)(*(_DWORD *)(v80 + 68) + 20);
              goto LABEL_182;
            }
          }
          else
          {
            v130 = *(_DWORD *)(*(_DWORD *)(v80 + 68) + 20);
            v79 = *(_DWORD *)(v91 - v130 + 100);
            if ( v79 - *(_DWORD *)(v84 - v130 + 100) > 0 )
            {
              v93 = *(_DWORD *)(v84 + 8);
              if ( v93 )
                v93 += v130;
LABEL_169:
              --v90;
              if ( !v85 )
              {
                v85 = v84;
                v84 = v93;
                goto LABEL_214;
              }
              v79 = v84 - *(_DWORD *)(*(_DWORD *)(v80 + 68) + 20);
              *(_DWORD *)(v85 + 8) = v79;
              if ( !v84 )
              {
                v85 = 0;
                v84 = v93;
                continue;
              }
              goto LABEL_173;
            }
            if ( v91 )
            {
              v79 = *(_DWORD *)(v91 + 8);
              if ( v79 )
                v79 += v130;
              goto LABEL_182;
            }
          }
          v79 = v91;
LABEL_182:
          --v89;
          if ( !v85 )
          {
            v85 = v91;
            v91 = v79;
LABEL_214:
            v83 = v85;
            if ( v85 )
            {
              v79 = 0;
              goto LABEL_174;
            }
            continue;
          }
          if ( !v91 )
          {
            *(_DWORD *)(v85 + 8) = 0;
            v85 = 0;
            v91 = v79;
            continue;
          }
          v93 = v84;
          v84 = v91;
          v96 = v91 - *(_DWORD *)(*(_DWORD *)(v80 + 68) + 20);
          v91 = v79;
          *(_DWORD *)(v85 + 8) = v96;
LABEL_173:
          v79 = v85 - *(_DWORD *)(*(_DWORD *)(v80 + 68) + 20);
          v85 = v84;
          v84 = v93;
LABEL_174:
          *(_DWORD *)(v85 + 4) = v79;
        }
        v92 = v90 == 0;
        if ( v90 )
          v92 = v84 == 0;
        if ( !v92 )
        {
          v93 = *(_DWORD *)(v84 + 8);
          v94 = v93 == 0;
          if ( v93 )
            v79 = *(_DWORD *)(v80 + 68);
          else
            v93 = v89;
          if ( !v94 )
          {
            v79 = *(_DWORD *)(v79 + 20);
            v93 += v79;
          }
          goto LABEL_169;
        }
      }
      while ( v84 );
      if ( v85 )
        *(_DWORD *)(v85 + 8) = 0;
      if ( v86 > 1 )
      {
        v82 *= 2;
        if ( !v83 )
        {
          v85 = 0;
          v97 = 0;
          v11 = v266;
          v26 = (void **)na;
          goto LABEL_192;
        }
        continue;
      }
      break;
    }
    v97 = v83;
    v11 = v266;
    v26 = (void **)na;
LABEL_192:
    *(_DWORD *)(*(_DWORD *)(v80 + 68) + 16) = v85;
    v98 = v97 - *(_DWORD *)(*(_DWORD *)(v80 + 68) + 20);
    v99 = *(_DWORD *)(v98 + 72);
    dword_1B0778 = v98;
    v265 = *(_DWORD *)(v98 + 100);
    if ( v99 )
    {
      v100 = *(_DWORD *)(v98 + 68);
      v101 = v98 + 68;
      v102 = *(_DWORD *)(v100 + 20);
      if ( v98 != *(_DWORD *)(v100 + 16) - v102 )
        goto LABEL_194;
LABEL_361:
      *(_DWORD *)(v100 + 16) = v99 + v102;
      v99 = *(_DWORD *)(v98 + 72);
      if ( !v99 )
      {
        v232 = *(_DWORD *)(v98 + 76);
        goto LABEL_363;
      }
      v102 = *(_DWORD *)(*(_DWORD *)(v98 + 68) + 20);
LABEL_194:
      v80 = v98;
      *(_DWORD *)(v99 + v102 + 8) = *(_DWORD *)(v98 + 76);
LABEL_195:
      v103 = *(_DWORD *)(v98 + 76);
      v104 = *(_DWORD **)(v80 + 68);
      if ( v103 )
      {
        *(_DWORD *)(v103 + v104[5] + 4) = *(_DWORD *)(v98 + 72);
        v104 = *(_DWORD **)(v80 + 68);
      }
      v105 = 3 * ((v104[1] - 1) & *(_DWORD *)(v98 + 96));
      --*(_DWORD *)(*v104 + 4 * v105 + 4);
      v106 = **(_DWORD **)(v80 + 68);
      if ( *(_DWORD *)(v106 + 4 * v105) == v101 )
        *(_DWORD *)(v106 + 4 * v105) = *(_DWORD *)(v98 + 84);
      v107 = *(_QWORD *)(v98 + 80);
      if ( (_DWORD)v107 )
      {
        *(_DWORD *)(v107 + 16) = HIDWORD(v107);
        HIDWORD(v107) = *(_DWORD *)(v98 + 84);
      }
      if ( HIDWORD(v107) )
        *(_DWORD *)(HIDWORD(v107) + 12) = *(_DWORD *)(v98 + 80);
      --*(_DWORD *)(*(_DWORD *)(v80 + 68) + 12);
    }
    else
    {
      v232 = *(_DWORD *)(v98 + 76);
      v100 = *(_DWORD *)(v98 + 68);
      if ( v232 )
      {
        v102 = *(_DWORD *)(v100 + 20);
        v101 = v98 + 68;
        if ( v98 == *(_DWORD *)(v100 + 16) - v102 )
          goto LABEL_361;
LABEL_363:
        v80 = v232;
        dword_1B0778 = v232;
        goto LABEL_195;
      }
      v80 = 0;
      free(*(void **)v100);
      free(*(void **)(v98 + 68));
      dword_1B0778 = 0;
    }
    free((void *)v98);
LABEL_205:
    v108 = strlen((const char *)v78);
    v268 = v108;
    LOWORD(v109) = 31161;
    if ( v108 <= 0xB )
    {
      HIWORD(v109) = -25033;
      v115 = (unsigned __int8 *)v78;
      v111 = v109;
      v127 = v108;
      nb = -17973521;
    }
    else
    {
      HIWORD(v109) = -25033;
      v271 = v80;
      v110 = (unsigned __int8 *)(v78 + 12);
      v111 = v109;
      v112 = v108;
      nb = -17973521;
      do
      {
        v112 -= 12;
        v113 = *(v110 - 1);
        v114 = (*(v110 - 6) << 16) + (*(v110 - 7) << 8) + *(v110 - 8) + (*(v110 - 5) << 24) + v109;
        v115 = v110;
        v116 = (*(v110 - 2) << 16) + (*(v110 - 3) << 8) + *(v110 - 4);
        v117 = (*(v110 - 10) << 16) + (*(v110 - 11) << 8) + *(v110 - 12) + (*(v110 - 9) << 24);
        v110 += 12;
        v118 = v116 + (v113 << 24) + nb;
        v119 = (v117 - v114 - v118 + v111) ^ (v118 >> 13);
        v120 = (v114 - v118 - v119) ^ (v119 << 8);
        v121 = (v118 - v119 - v120) ^ (v120 >> 13);
        v122 = (v119 - v120 - v121) ^ (v121 >> 12);
        v123 = (v120 - v121 - v122) ^ (v122 << 16);
        v124 = (v121 - v122 - v123) ^ (v123 >> 5);
        v111 = (v122 - v123 - v124) ^ (v124 >> 3);
        v125 = v123 - v124 - v111;
        v126 = v124 - v111;
        v109 = v125 ^ (v111 << 10);
        nb = (v126 - v109) ^ (v109 >> 15);
      }
      while ( v112 > 0xB );
      v127 = v112;
      v80 = v271;
    }
    v128 = v127 - 1;
    v129 = v268 + nb;
    switch ( v128 )
    {
      case 0u:
        goto LABEL_238;
      case 1u:
        goto LABEL_237;
      case 2u:
        goto LABEL_236;
      case 3u:
        goto LABEL_235;
      case 4u:
        goto LABEL_234;
      case 5u:
        goto LABEL_233;
      case 6u:
        goto LABEL_232;
      case 7u:
        goto LABEL_231;
      case 8u:
        goto LABEL_230;
      case 9u:
        goto LABEL_229;
      case 0xAu:
        v129 += v115[10] << 24;
LABEL_229:
        v129 += v115[9] << 16;
LABEL_230:
        v129 += v115[8] << 8;
LABEL_231:
        v109 += v115[7] << 24;
LABEL_232:
        v109 += v115[6] << 16;
LABEL_233:
        v109 += v115[5] << 8;
LABEL_234:
        v109 += v115[4];
LABEL_235:
        v111 += v115[3] << 24;
LABEL_236:
        v111 += v115[2] << 16;
LABEL_237:
        v111 += v115[1] << 8;
LABEL_238:
        v111 += *v115;
        break;
      default:
        break;
    }
    *(_DWORD *)(v78 + 88) = v78;
    v131 = (v111 - v109 - v129) ^ (v129 >> 13);
    v132 = (v109 - v129 - v131) ^ (v131 << 8);
    v133 = (v129 - v131 - v132) ^ (v132 >> 13);
    v134 = (v131 - v132 - v133) ^ (v133 >> 12);
    v135 = (v132 - v133 - v134) ^ (v134 << 16);
    v136 = (v133 - v134 - v135) ^ (v135 >> 5);
    v137 = v134 - v135 - v136;
    v138 = (v136 - (v137 ^ (v136 >> 3)) - ((v135 - v136 - (v137 ^ (v136 >> 3))) ^ ((v137 ^ (v136 >> 3)) << 10)))
         ^ (((v135 - v136 - (v137 ^ (v136 >> 3))) ^ ((v137 ^ (v136 >> 3)) << 10)) >> 15);
    *(_DWORD *)(v78 + 96) = v138;
    *(_DWORD *)(v78 + 92) = strlen((const char *)v78);
    if ( v80 )
    {
      v139 = *(_DWORD *)(v80 + 68);
      *(_DWORD *)(v78 + 76) = 0;
      v140 = v78 + 68;
      *(_DWORD *)(v78 + 68) = v139;
      *(_DWORD *)(v78 + 72) = *(_DWORD *)(*(_DWORD *)(v80 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v80 + 68) + 20);
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v80 + 68) + 16) + 8) = v78;
      *(_DWORD *)(*(_DWORD *)(v80 + 68) + 16) = v78 + 68;
    }
    else
    {
      *(_DWORD *)(v78 + 76) = 0;
      *(_DWORD *)(v78 + 72) = 0;
      dword_1B0778 = v78;
      v233 = malloc(0x2Cu);
      *(_DWORD *)(v78 + 68) = v233;
      if ( !v233 )
        goto LABEL_402;
      memset(v233, 0, 0x2Cu);
      v140 = v78 + 68;
      *(_DWORD *)(*(_DWORD *)(v78 + 68) + 16) = v78 + 68;
      *(_DWORD *)(*(_DWORD *)(v78 + 68) + 4) = 32;
      *(_DWORD *)(*(_DWORD *)(v78 + 68) + 8) = 5;
      *(_DWORD *)(*(_DWORD *)(v78 + 68) + 20) = 68;
      v234 = *(void ***)(v78 + 68);
      *v234 = malloc(0x180u);
      v235 = **(void ***)(v78 + 68);
      if ( !v235 )
LABEL_402:
        exit(-1);
      memset(v235, 0, 0x180u);
      v80 = v78;
      *(_DWORD *)(*(_DWORD *)(v78 + 68) + 40) = -1609490463;
    }
    ++*(_DWORD *)(*(_DWORD *)(v80 + 68) + 12);
    v141 = *(_DWORD **)(v80 + 68);
    v142 = 12 * (v138 & (v141[1] - 1));
    ++*(_DWORD *)(*v141 + v142 + 4);
    v143 = *(_DWORD *)(**(_DWORD **)(v80 + 68) + v142);
    *(_DWORD *)(v78 + 80) = 0;
    *(_DWORD *)(v78 + 84) = v143;
    v144 = **(_DWORD **)(v80 + 68);
    v145 = *(_DWORD *)(v144 + v142);
    v146 = (int *)(v144 + v142);
    if ( v145 )
    {
      *(_DWORD *)(v145 + 12) = v140;
      v146 = (int *)(**(_DWORD **)(v80 + 68) + v142);
    }
    *v146 = v140;
    v147 = *(_QWORD *)(**(_DWORD **)(v80 + 68) + v142 + 4);
    if ( (unsigned int)v147 >= 10 * (HIDWORD(v147) + 1) )
    {
      v148 = *(_DWORD *)(v78 + 68);
      if ( *(_DWORD *)(v148 + 36) != 1 )
      {
        v149 = calloc(24 * *(_DWORD *)(v148 + 4), 1u);
        if ( !v149 )
          goto LABEL_402;
        v150 = *(_DWORD *)(v78 + 68);
        *(_DWORD *)(v150 + 24) = (((2 * *(_DWORD *)(v150 + 4) - 1) & *(_DWORD *)(v150 + 12)) != 0)
                               + (*(_DWORD *)(v150 + 12) >> (*(_BYTE *)(v150 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(v78 + 68) + 28) = 0;
        v151 = *(_DWORD *)(v78 + 68);
        v152 = *(_DWORD *)(v151 + 4);
        if ( v152 )
        {
          v153 = a1;
          v154 = v78;
          v155 = v153;
          nc = 0;
          v269 = 0;
          v270 = v11;
          do
          {
            v156 = *(_DWORD **)(*(_DWORD *)v151 + nc);
            if ( v156 )
            {
              while ( 1 )
              {
                v157 = (_DWORD *)v156[4];
                v158 = 3 * ((2 * v152 - 1) & v156[7]);
                v159 = (char *)&v149[3 * ((2 * v152 - 1) & v156[7])];
                v160 = *((_DWORD *)v159 + 1) + 1;
                *((_DWORD *)v159 + 1) = v160;
                v161 = *(_DWORD *)(v154 + 68);
                if ( v160 > *(_DWORD *)(v161 + 24) )
                {
                  ++*(_DWORD *)(v161 + 28);
                  *((_DWORD *)v159 + 2) = *((_DWORD *)v159 + 1) / *(_DWORD *)(*(_DWORD *)(v154 + 68) + 24);
                }
                v156[3] = 0;
                v156[4] = v149[v158];
                v162 = v149[v158];
                if ( v162 )
                  *(_DWORD *)(v162 + 12) = v156;
                v149[v158] = v156;
                if ( !v157 )
                  break;
                v156 = v157;
                v152 = *(_DWORD *)(*(_DWORD *)(v154 + 68) + 4);
              }
              v151 = *(_DWORD *)(v154 + 68);
              v152 = *(_DWORD *)(v151 + 4);
            }
            v163 = ++v269 >= v152;
            nc += 12;
          }
          while ( !v163 );
          v11 = v270;
          v164 = v155;
          v78 = v154;
          a1 = v164;
        }
        free(*(void **)v151);
        *(_DWORD *)(*(_DWORD *)(v78 + 68) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(v78 + 68) + 8);
        **(_DWORD **)(v78 + 68) = v149;
        v165 = *(_DWORD **)(v78 + 68);
        v166 = v165[7];
        v167 = v165[3];
        v168 = v166 > v167 >> 1;
        if ( v166 <= v167 >> 1 )
          v169 = 0;
        else
          v169 = v165[8];
        if ( v168 )
          ++v169;
        v165[8] = v169;
        v170 = *(_DWORD *)(v78 + 68);
        if ( *(_DWORD *)(v170 + 32) > 1u )
          *(_DWORD *)(v170 + 36) = 1;
      }
    }
    v171 = 8 * (29 - *((unsigned __int8 *)v26 + 72));
    v172 = bswap32((unsigned int)v26[18]) & 0xFFFFFF;
    if ( v171 < 8 )
      LOBYTE(v171) = 8;
    v173 = 32 - v171;
    v174 = 0xFFFF << (v171 - 32);
    LODWORD(v175) = 0xFFFF << v171;
    HIDWORD(v175) = v174 | (0xFFFFu >> v173);
    LODWORD(v176) = sub_778A4(v175);
    v177 = v176 / (double)v172;
    if ( v177 != dbl_9ED90 )
    {
      sub_51B18((unsigned __int64)v177, byte_1B077C, 8u, 0);
      dbl_9ED90 = v177;
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
      {
        snprintf((char *)v288, 0x800u, "Network diff set to %s", byte_1B077C);
        sub_47AB4(5, (const char *)v288, 0);
      }
    }
    if ( v265 && byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf((char *)v288, 0x800u, "Deleted block %d from database", v265);
      sub_47AB4(7, (const char *)v288, 0);
    }
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)&unk_1B0758) )
    {
LABEL_393:
      v238 = _errno_location();
      snprintf(
        (char *)v288,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v238,
        "cgminer.c",
        "block_exists",
        5608);
      goto LABEL_136;
    }
    off_9E444();
    if ( pthread_mutex_lock(&stru_244084) )
    {
      v242 = _errno_location();
      snprintf(
        (char *)v288,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v242,
        "cgminer.c",
        "set_curblock",
        5515);
      goto LABEL_136;
    }
    if ( pthread_rwlock_wrlock(&stru_24409C) )
    {
      v240 = _errno_location();
      snprintf(
        (char *)v288,
        0x800u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v240,
        "cgminer.c",
        "set_curblock",
        5515);
      goto LABEL_136;
    }
    sub_4A60C((struct timeval *)&dword_245170);
    strcpy(byte_242EA4, s2);
    sub_4C150(&unk_1B0784, &s1, 0x20u, (int)"cgminer.c", (int)"set_curblock", 5518);
    v288[0] = dword_245170;
    v178 = dword_245174 / 1000;
    v179 = localtime(v288);
    snprintf(byte_1B07A4, 0x20u, "[%02d:%02d:%02d.%03d]", v179->tm_hour, v179->tm_min, v179->tm_sec, v178);
    if ( pthread_rwlock_unlock(&stru_24409C) )
    {
      v239 = _errno_location();
      snprintf(
        (char *)v288,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v239,
        "cgminer.c",
        "set_curblock",
        5520);
      goto LABEL_136;
    }
    if ( pthread_mutex_unlock(&stru_244084) )
    {
      v241 = _errno_location();
      snprintf(
        (char *)v288,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v241,
        "cgminer.c",
        "set_curblock",
        5520);
      goto LABEL_136;
    }
    off_9E444();
    v180 = 0;
    v181 = byte_242EA4;
    do
    {
      v182 = (unsigned __int8)*v181++;
      if ( v182 != 48 )
        break;
      ++v180;
    }
    while ( v180 != 57 );
    strncpy(dest, &byte_242EA4[v180], 8u);
    byte_1B07CC = 0;
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
    {
      snprintf((char *)v288, 0x800u, "New block: %s... diff %s", byte_242EA4, byte_1B077C);
      sub_47AB4(6, (const char *)v288, 0);
    }
    if ( v265 && byte_1AECC5 && (byte_244080 || byte_1AECC4 || dword_9E320 > 6) )
    {
      snprintf((char *)v288, 0x800u, "Deleted block %d from database", v265);
      sub_47AB4(7, (const char *)v288, 0);
    }
    sub_4C150(timer + 136, &s1, 0x20u, (int)"cgminer.c", (int)"test_work_current", 5665);
    if ( dword_24625C == 1 )
      goto LABEL_133;
    v183 = *((unsigned __int8 *)v26 + 280);
    v26[84] = (void *)++dword_1AF224;
    if ( !v183 )
    {
      if ( byte_244082 )
      {
        if ( !*((_BYTE *)timer + 900) && (byte_244080 || byte_1AECC4 || dword_9E320 > 4) )
        {
          strcpy((char *)v288, "New block detected on network before pool notification");
          sub_47AB4(5, (const char *)v288, 0);
        }
      }
      else if ( !*((_BYTE *)timer + 900) && (byte_244080 || byte_1AECC4 || dword_9E320 > 4) )
      {
        strcpy((char *)v288, "New block detected on network");
        sub_47AB4(5, (const char *)v288, 0);
      }
      goto LABEL_132;
    }
    if ( !*((_BYTE *)v26 + 284) )
    {
      if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 4 )
        goto LABEL_132;
      v186 = "";
      v185 = *(_DWORD *)v26[65];
      v184 = "%sLONGPOLL from pool %d detected new block";
      if ( *((_BYTE *)v26 + 324) )
        v186 = "GBT ";
LABEL_301:
      snprintf((char *)v288, 0x800u, v184, v186, v185);
      goto LABEL_302;
    }
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
    {
      v184 = "Stratum from pool %d detected new block at height %d";
      v185 = *(_DWORD *)v275;
      v186 = (char *)*timer;
      goto LABEL_301;
    }
LABEL_132:
    sub_54FC0();
LABEL_133:
    *((_BYTE *)v26 + 280) = 0;
LABEL_54:
    sub_53084(&v272, "cgminer.c", "stratum_rthread", 7595);
LABEL_15:
    free(v11);
    v3 = (int)a1;
  }
  while ( !*((_BYTE *)a1 + 105) );
LABEL_16:
  sub_4AFA8(v3);
  return 0;
}
// 6035C: control flows out of bounds to 60360
// 60CFC: control flows out of bounds to 60D00
// 60980: variable 'v79' is possibly undefined
// 611C8: variable 'v176' is possibly undefined
// 619E0: variable 'v254' is possibly undefined
// 12274: using guessed type int round(void);
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9ED90: using guessed type double dbl_9ED90;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AEEB8: using guessed type int dword_1AEEB8;
// 1AF218: using guessed type int dword_1AF218;
// 1AF224: using guessed type int dword_1AF224;
// 1B0778: using guessed type int dword_1B0778;
// 1B07CC: using guessed type char byte_1B07CC;
// 242EF0: using guessed type double dbl_242EF0;
// 242F10: using guessed type double dbl_242F10;
// 244080: using guessed type char byte_244080;
// 244082: using guessed type char byte_244082;
// 244084: using guessed type pthread_mutex_t stru_244084;
// 245150: using guessed type int dword_245150;
// 245158: using guessed type __int64 qword_245158;
// 245170: using guessed type int dword_245170;
// 245174: using guessed type int dword_245174;
// 245204: using guessed type char byte_245204;
// 246244: using guessed type pthread_mutex_t stru_246244;
// 24625C: using guessed type int dword_24625C;
// 246368: using guessed type __int64 qword_246368;

//----- (00062428) --------------------------------------------------------
void __fastcall sub_62428(struct timeval *a1)
{
  _DWORD *tv_usec; // r4
  int v2; // r5
  double *v3; // r12
  __int64 v4; // kr08_8
  double v5; // d6
  double v6; // d5
  double v7; // d7
  _BYTE *v8; // r3
  int v9; // r0
  int *v10; // r0
  double *v11; // r0
  double v12; // d6
  double v13; // d7
  double v14; // d5
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  void *arg[2]; // [sp+14h] [bp-80Ch] BYREF
  pthread_t v19; // [sp+1Ch] [bp-804h] BYREF
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  arg[0] = a1;
  tv_usec = (_DWORD *)a1[32].tv_usec;
  sub_4A60C(a1 + 54);
  if ( byte_1AF244 )
  {
    v2 = *(_DWORD *)(sub_57BAC(*((_DWORD *)arg[0] + 64)) + 36);
    if ( pthread_mutex_lock(&stru_246244) )
    {
      v10 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v10,
        "cgminer.c",
        "submit_work_async",
        8682);
    }
    else
    {
      v3 = (double *)arg[0];
      v4 = qword_245158;
      ++*(_DWORD *)(v2 + 36);
      qword_245158 = v4 + 1;
      v5 = dbl_242EF0;
      ++*((_QWORD *)tv_usec + 1);
      *(double *)(v2 + 200) = *(double *)(v2 + 200) + v3[47];
      v6 = v3[47];
      v7 = *((double *)tv_usec + 9) + v6;
      dbl_242EF0 = v5 + v6;
      *((double *)tv_usec + 9) = v7;
      if ( !pthread_mutex_unlock(&stru_246244) )
      {
        off_9E444();
        if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
        {
          snprintf(
            s,
            0x800u,
            "Accepted %s %d benchmark share nonce %08x",
            *(const char **)(*(_DWORD *)(v2 + 4) + 8),
            *(_DWORD *)(v2 + 8),
            *((_DWORD *)arg[0] + 19));
          sub_47AB4(5, s, 0);
        }
        return;
      }
      v15 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v15,
        "cgminer.c",
        "submit_work_async",
        8689);
    }
LABEL_49:
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
  if ( !sub_5B638((int)arg[0], 1) )
  {
    v8 = arg[0];
    if ( *((_BYTE *)arg[0] + 284) )
      goto LABEL_10;
    goto LABEL_24;
  }
  if ( byte_9EDA0 )
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
    {
      snprintf(s, 0x800u, "Pool %d stale share detected, submitting as user requested", *tv_usec);
LABEL_22:
      sub_47AB4(5, s, 0);
    }
  }
  else
  {
    if ( !*((_BYTE *)tv_usec + 104) )
    {
      if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
      {
        snprintf(s, 0x800u, "Pool %d stale share detected, discarding", *tv_usec);
        sub_47AB4(5, s, 0);
      }
      sub_5B390("discard", (_DWORD *)arg[0]);
      if ( pthread_mutex_lock(&stru_246244) )
      {
        v16 = _errno_location();
        snprintf(
          s,
          0x800u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v16,
          "cgminer.c",
          "submit_work_async",
          8710);
      }
      else
      {
        v11 = (double *)arg[0];
        v12 = *((double *)tv_usec + 11);
        v13 = dbl_246238;
        ++tv_usec[30];
        v14 = v11[47];
        ++qword_242E98;
        *((double *)tv_usec + 11) = v12 + v14;
        dbl_246238 = v13 + v14;
        if ( !pthread_mutex_unlock(&stru_246244) )
        {
          off_9E444();
          sub_53084((void ***)arg, "cgminer.c", "submit_work_async", 8719);
          return;
        }
        v17 = _errno_location();
        snprintf(
          s,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v17,
          "cgminer.c",
          "submit_work_async",
          8717);
      }
      goto LABEL_49;
    }
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
    {
      snprintf(s, 0x800u, "Pool %d stale share detected, submitting as pool requested", *tv_usec);
      goto LABEL_22;
    }
  }
  v8 = arg[0];
  *((_BYTE *)arg[0] + 281) = 1;
  if ( v8[284] )
  {
LABEL_10:
    if ( byte_1AECC5 )
    {
      if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 6 )
      {
        v9 = tv_usec[182];
        if ( !v9 )
        {
LABEL_15:
          if ( dword_9E320 <= 3 )
          {
            if ( tv_usec[182] )
            {
LABEL_17:
              sub_53084((void ***)arg, "cgminer.c", "submit_work_async", 8733);
              return;
            }
            goto LABEL_63;
          }
LABEL_37:
          strcpy(s, "Discarding work from removed pool");
          sub_47AB4(4, s, 0);
          if ( tv_usec[182] )
            goto LABEL_17;
          if ( byte_244080 || byte_1AECC4 )
          {
LABEL_40:
            snprintf(s, 0x800u, "Pushing pool %d work to stratum queue", *tv_usec);
            sub_47AB4(5, s, 0);
            goto LABEL_17;
          }
LABEL_63:
          if ( dword_9E320 <= 4 )
            goto LABEL_17;
          goto LABEL_40;
        }
        goto LABEL_34;
      }
      snprintf(s, 0x800u, "Pushing pool %d work to stratum queue", *tv_usec);
      sub_47AB4(7, s, 0);
    }
    v9 = tv_usec[182];
    if ( !v9 )
      goto LABEL_35;
    v8 = arg[0];
LABEL_34:
    if ( sub_4A03C(v9, (int)v8) )
      return;
LABEL_35:
    if ( byte_244080 || byte_1AECC4 )
      goto LABEL_37;
    goto LABEL_15;
  }
LABEL_24:
  if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
  {
    strcpy(s, "Pushing submit work to work thread");
    sub_47AB4(5, s, 0);
    v8 = arg[0];
  }
  if ( pthread_create(&v19, 0, (void *(*)(void *))sub_51E24, v8) )
  {
    strcpy(s, "Failed to create submit_work_thread");
    sub_47AB4(3, s, 1);
    sub_54CCC(1, 1);
  }
}
// 9E320: using guessed type int dword_9E320;
// 9E444: using guessed type int (*off_9E444)();
// 9EDA0: using guessed type char byte_9EDA0;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECC5: using guessed type char byte_1AECC5;
// 1AF244: using guessed type char byte_1AF244;
// 242E98: using guessed type __int64 qword_242E98;
// 242EF0: using guessed type double dbl_242EF0;
// 244080: using guessed type char byte_244080;
// 245158: using guessed type __int64 qword_245158;
// 246238: using guessed type double dbl_246238;
// 246244: using guessed type pthread_mutex_t stru_246244;

//----- (00062B4C) --------------------------------------------------------
int __fastcall sub_62B4C(int a1, int a2)
{
  int v4; // r6
  struct timeval *v6; // r5
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  sub_59820((int *)(a1 + 36), a2);
  v4 = sub_49D78((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160));
  if ( v4 )
  {
    v6 = (struct timeval *)sub_55E38();
    sub_52F6C((int)v6, a2, 0);
    sub_62428(v6);
    return v4;
  }
  else
  {
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 5 )
    {
      snprintf(
        s,
        0x800u,
        "%s %s %d: Share above target",
        "submit_tested_work",
        *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
        *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
      sub_47AB4(6, s, 0);
    }
    return 0;
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 244080: using guessed type char byte_244080;

//----- (00062C38) --------------------------------------------------------
int __fastcall sub_62C38(int a1, int a2, unsigned int a3)
{
  int v6; // r5

  v6 = sub_54148(a1, a3);
  if ( v6 && (*(_DWORD *)(a2 + 76) = a3, sub_51DD0(a2), !*(_DWORD *)(a2 + 220)) )
  {
    sub_62B4C(a1, a2);
    if ( dword_246240 && byte_24401D )
    {
      v6 = (unsigned __int8)byte_24401D;
      sub_531CC(a2, a3);
    }
  }
  else
  {
    v6 = 0;
    sub_593C8(a1);
  }
  return v6;
}
// 24401D: using guessed type char byte_24401D;
// 246240: using guessed type int dword_246240;

//----- (00062CCC) --------------------------------------------------------
void __fastcall sub_62CCC(int a1)
{
  struct timeval *v2; // r4

  v2 = (struct timeval *)sub_55E38();
  sub_52F6C((int)v2, a1, 0);
  sub_62428(v2);
}

//----- (00062CF4) --------------------------------------------------------
int __fastcall sub_62CF4(int a1, int a2, int a3)
{
  struct timeval *v4; // r5

  *(_DWORD *)(a2 + 76) = a3;
  v4 = (struct timeval *)sub_55E38();
  sub_52F6C((int)v4, a2, 0);
  sub_62428(v4);
  return 1;
}

//----- (00062EC0) --------------------------------------------------------
void __fastcall __noreturn sub_62EC0(int a1)
{
  sub_54CCC(a1, 1);
}

//----- (00062ECC) --------------------------------------------------------
int __fastcall sub_62ECC(int a1, int a2, char *s1, const char *a4, const char *a5)
{
  char *v8; // r0
  size_t v9; // r5
  size_t v10; // r5
  char *v11; // r0
  const char *v12; // r12
  const char *v13; // r3
  int v14; // r2

  v8 = sub_4AAB4(s1, a1);
  *(_DWORD *)(a1 + 172) = a4;
  *(_DWORD *)(a1 + 164) = v8;
  *(_DWORD *)(a1 + 176) = a5;
  v9 = strlen(a4);
  v10 = v9 + strlen(a5) + 2;
  v11 = (char *)sub_49624(v10, "cgminer.c", "add_pool_details", 10818);
  v12 = *(const char **)(a1 + 176);
  v13 = *(const char **)(a1 + 172);
  *(_DWORD *)(a1 + 168) = v11;
  snprintf(v11, v10, "%s:%s", v13, v12);
  v14 = *(_DWORD *)(a1 + 100);
  *(_BYTE *)(a1 + 284) = 1;
  *(_BYTE *)(a1 + 107) = a2 ^ 1;
  *(_BYTE *)(a1 + 97) = 1;
  if ( v14 != 1 )
  {
    *(_DWORD *)(a1 + 100) = 1;
    ++dword_2440F8;
  }
  pthread_create((pthread_t *)(a1 + 280), 0, (void *(*)(void *))sub_5B104, (void *)a1);
  if ( !a2 )
  {
    pthread_join(*(_DWORD *)(a1 + 280), 0);
    return (unsigned __int8)byte_1AF228;
  }
  return a2;
}
// 1AF228: using guessed type char byte_1AF228;
// 2440F8: using guessed type int dword_2440F8;

//----- (00063130) --------------------------------------------------------
int __fastcall sub_63130(int result)
{
  *(_DWORD *)(result + 28) = sub_516D4;
  *(_DWORD *)(result + 12) = nullsub_11;
  *(_DWORD *)(result + 20) = nullsub_3;
  *(_DWORD *)(result + 24) = nullsub_4;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = sub_52A30;
  *(_DWORD *)(result + 48) = sub_516BC;
  *(_DWORD *)(result + 52) = sub_52A38;
  *(_DWORD *)(result + 56) = sub_516C8;
  *(_DWORD *)(result + 60) = nullsub_12;
  *(_DWORD *)(result + 84) = nullsub_13;
  *(_DWORD *)(result + 88) = nullsub_14;
  *(_DWORD *)(result + 92) = nullsub_15;
  *(_DWORD *)(result + 96) = sub_516DC;
  *(_DWORD *)(result + 16) = nullsub_10;
  *(_DWORD *)(result + 36) = nullsub_10;
  *(_DWORD *)(result + 76) = nullsub_10;
  *(_DWORD *)(result + 80) = nullsub_10;
  *(_DWORD *)(result + 32) = sub_516B4;
  *(_DWORD *)(result + 72) = sub_516B4;
  *(_QWORD *)(result + 104) = 0x3FF0000000000000LL;
  *(_QWORD *)(result + 112) = 0x3FF0000000000000LL;
  return result;
}
// 516AC: using guessed type int nullsub_10();
// 516B0: using guessed type int nullsub_3();
// 516D0: using guessed type int nullsub_11();
// 52A28: using guessed type int nullsub_4();
// 52A2C: using guessed type int nullsub_12();
// 52A40: using guessed type int nullsub_13();
// 52A44: using guessed type int nullsub_14();
// 52A48: using guessed type int nullsub_15();

//----- (00063218) --------------------------------------------------------
int __fastcall sub_63218(pthread_rwlock_t *a1)
{
  int v2; // r1
  int v3; // r3
  int v4; // r1
  int v5; // r2
  int nr_writers_queued; // r3
  int result; // r0

  a1[1].__lock = 0;
  if ( pthread_rwlock_wrlock(&stru_24638C) )
    sub_5505C("enable_device", 11228);
  v2 = dword_242FEC;
  v3 = dword_1B07D0;
  a1->__lock = dword_1B07D0;
  *(_DWORD *)(v2 + 4 * v3) = a1;
  dword_1B07D0 = v3 + 1;
  if ( pthread_rwlock_unlock(&stru_24638C) )
    sub_55C08("enable_device", 11230);
  off_9E444();
  if ( byte_242FFC )
    nr_writers_queued = a1[4].__nr_writers_queued;
  else
    nr_writers_queued = 20744;
  if ( byte_242FFC )
    v5 = dword_1B07D4;
  else
    HIWORD(nr_writers_queued) = 36;
  if ( byte_242FFC )
  {
    nr_writers_queued += v5;
    dword_1B07D4 = nr_writers_queued;
  }
  else
  {
    v4 = *(_DWORD *)nr_writers_queued;
    v5 = a1[4].__nr_writers_queued;
  }
  if ( !byte_242FFC )
    *(_DWORD *)nr_writers_queued = v5 + v4;
  result = pthread_rwlock_init(a1 + 10, 0);
  if ( result )
    sub_55000("enable_device", 11241);
  a1[11].__lock = 0;
  return result;
}
// 632B4: variable 'v5' is possibly undefined
// 632BC: variable 'v4' is possibly undefined
// 9E444: using guessed type int (*off_9E444)();
// 1B07D0: using guessed type int dword_1B07D0;
// 1B07D4: using guessed type int dword_1B07D4;
// 242FEC: using guessed type int dword_242FEC;
// 242FFC: using guessed type char byte_242FFC;
// 24638C: using guessed type pthread_rwlock_t stru_24638C;

//----- (00063D10) --------------------------------------------------------
_BYTE *__fastcall sub_63D10(const void *a1)
{
  _BYTE *v2; // r5

  v2 = sub_49624(0x78u, "cgminer.c", "copy_drv", 11311);
  sub_4C150(v2, a1, 0x78u, (int)"cgminer.c", (int)"copy_drv", 11312);
  v2[100] = 1;
  return v2;
}

//----- (00063D74) --------------------------------------------------------
void sub_63D74()
{
  int v0; // r4
  char *v1; // r0
  struct sysinfo v2; // [sp+0h] [bp-940h] BYREF
  char s[256]; // [sp+40h] [bp-900h] BYREF
  char v4[2048]; // [sp+140h] [bp-800h] BYREF

  if ( sysinfo(&v2) )
  {
    v0 = *_errno_location();
    v1 = strerror(v0);
    sprintf(s, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
    dword_242EA0 = time(0);
    dword_244004 = dword_242EA0 + 1;
  }
  else
  {
    dword_242EA0 = v2.uptime;
    dword_244004 = v2.uptime + 1;
    sprintf(s, "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n", v2.uptime, v2.uptime + 1);
    if ( byte_244080 || byte_1AECC4 || dword_9E320 > 4 )
    {
      snprintf(v4, 0x800u, "%s", s);
      sub_47AB4(5, v4, 0);
    }
  }
}
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 242EA0: using guessed type int dword_242EA0;
// 244004: using guessed type int dword_244004;
// 244080: using guessed type char byte_244080;

//----- (00063E84) --------------------------------------------------------
void sub_63E84()
{
  FILE *v0; // r6
  signed int v1; // r0
  char *v2; // r7
  unsigned __int8 *v3; // r4
  int v4; // r7
  char *v5; // r0
  size_t v6; // r0
  int v7; // r3
  size_t v8; // r0
  int v9; // r3
  bool v10; // zf
  int v11; // r5
  char v12[256]; // [sp+8h] [bp-900h] BYREF
  char s[2048]; // [sp+108h] [bp-800h] BYREF

  v0 = (FILE *)fopen64(dword_1AECD8, "rb");
  memset(v12, 0, sizeof(v12));
  if ( v0 )
  {
    v1 = fread(v12, 1u, 0x100u, v0);
    if ( v1 <= 0 )
    {
      v11 = (int)&byte_244080;
      if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
        goto LABEL_24;
      snprintf(s, 0x800u, "Read miner version file %s error %d", (const char *)dword_1AECD8, v1);
      sub_47AB4(3, s, 0);
    }
    else
    {
      v2 = strchr(v12, 10);
      if ( v2 )
      {
        v3 = byte_1B0CC0;
        sub_4C150(byte_1B07E4, v12, v2 - v12, (int)"cgminer.c", (int)"read_version_file", 11540);
        v4 = stpcpy(v12, v2 + 1);
        v5 = strchr(v12, 10);
        if ( v5 )
          sub_4C150(byte_1B08E4, v12, v5 - v12, (int)"cgminer.c", (int)"read_version_file", 11549);
        else
          memcpy(byte_1B08E4, v12, v4 - (_DWORD)v12 + 1);
      }
      else
      {
        v3 = byte_1B0CC0;
        strcpy(byte_1B07E4, v12);
      }
      v6 = strlen(byte_1B07E4) - 1;
      v7 = byte_1B0CC0[v6 - 1244];
      if ( v7 == 10 )
      {
        byte_1B0CC0[v6 - 1244] = 0;
        v6 = strlen(byte_1B07E4) - 1;
        v7 = byte_1B0CC0[v6 - 1244];
      }
      if ( v7 == 13 )
        byte_1B0CC0[v6 - 1244] = 0;
      v8 = strlen(byte_1B08E4) - 1;
      v9 = byte_1B0CC0[v8 - 988];
      if ( v9 == 10 )
      {
        byte_1B0CC0[v8 - 988] = 0;
        v8 = strlen(byte_1B08E4) - 1;
        v9 = byte_1B0CC0[v8 - 988];
      }
      v10 = v9 == 13;
      v11 = 16512;
      if ( v9 == 13 )
      {
        v3 = &byte_1B0CC0[v8];
        LOBYTE(v9) = 0;
      }
      else
      {
        HIWORD(v11) = 36;
      }
      if ( v10 )
      {
        HIWORD(v11) = 36;
        *(v3 - 988) = v9;
      }
    }
  }
  else
  {
    v11 = (int)&byte_244080;
    if ( !byte_244080 && !byte_1AECC4 && dword_9E320 <= 2 )
      goto LABEL_24;
    snprintf(s, 0x800u, "Open miner version file %s error", (const char *)dword_1AECD8);
    sub_47AB4(3, s, 0);
  }
  if ( *(_BYTE *)v11 || byte_1AECC4 )
    goto LABEL_23;
LABEL_24:
  if ( dword_9E320 > 2 )
  {
LABEL_23:
    snprintf(s, 0x800u, "Miner compile time: %s type: %s", byte_1B07E4, byte_1B08E4);
    sub_47AB4(3, s, 0);
  }
}
// 12064: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 9E320: using guessed type int dword_9E320;
// 1AECC4: using guessed type char byte_1AECC4;
// 1AECD8: using guessed type int dword_1AECD8;
// 1B0CC0: using guessed type unsigned __int8 byte_1B0CC0[116];
// 244080: using guessed type char byte_244080;

//----- (00064250) --------------------------------------------------------
char *__fastcall sub_64250(const char *a1, const char *a2)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = (char *)malloc(v4 + v5);
  sprintf(v6, a1, a2);
  return v6;
}

//----- (0006428C) --------------------------------------------------------
int __fastcall sub_6428C(_BYTE *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0006429C) --------------------------------------------------------
int __fastcall sub_6429C(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (000642AC) --------------------------------------------------------
int __fastcall sub_642AC(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (000642BC) --------------------------------------------------------
char *__fastcall sub_642BC(const char *a1, _BYTE *a2)
{
  if ( !strcasecmp(a1, "yes") || !strcasecmp(a1, "true") )
  {
    *a2 = 1;
    return 0;
  }
  else if ( !strcasecmp(a1, (const char *)&dword_80288) || !strcasecmp(a1, "false") )
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    return sub_64DF4(a1);
  }
}
// 80288: using guessed type int dword_80288;

//----- (00064350) --------------------------------------------------------
char *__fastcall sub_64350(const char *a1, _BYTE *a2)
{
  char *result; // r0

  result = sub_642BC(a1, a2);
  if ( !result )
    *a2 ^= 1u;
  return result;
}

//----- (00064370) --------------------------------------------------------
int __fastcall sub_64370(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0;
}

//----- (0006437C) --------------------------------------------------------
char *__fastcall sub_6437C(const char *a1, _DWORD *a2)
{
  int v2; // s0
  int *v5; // r5
  _BYTE *v6; // r3
  char *result; // r0
  _BYTE *v8; // [sp+4h] [bp-4h] BYREF

  v5 = _errno_location();
  *v5 = 0;
  strtof(a1, &v8);
  v6 = v8;
  *a2 = v2;
  if ( *v6 || !*a1 )
    return sub_64250("'%s' is not a number", a1);
  result = (char *)*v5;
  if ( *v5 )
    return sub_64250("'%s' is out of range", a1);
  return result;
}
// 643AC: variable 'v2' is possibly undefined
// 12178: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (00064404) --------------------------------------------------------
char *__fastcall sub_64404(const char *a1, int *a2)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(a1, &endptr, 0);
  v6 = endptr;
  *a2 = v5;
  if ( *v6 || !*a1 )
    return sub_64250("'%s' is not a number", a1);
  result = (char *)*v4;
  if ( *v4 )
    return sub_64250("'%s' is out of range", a1);
  return result;
}

//----- (0006448C) --------------------------------------------------------
char *__fastcall sub_6448C(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  result = sub_64404(a1, &v4);
  if ( !result )
    *a2 = v4;
  return result;
}

//----- (00064554) --------------------------------------------------------
int __fastcall sub_64554(_DWORD *a1)
{
  ++*a1;
  return 0;
}

//----- (0006456C) --------------------------------------------------------
void __fastcall __noreturn sub_6456C(const char *a1)
{
  puts(a1);
  fflush((FILE *)stdout);
  exit(0);
}
// 9F7D4: using guessed type int stdout;

//----- (0006458C) --------------------------------------------------------
void __fastcall __noreturn sub_6458C(int a1)
{
  const char *v1; // r0

  v1 = (const char *)sub_6530C(dword_2463E8, a1);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 6530C: using guessed type int __fastcall sub_6530C(_DWORD, _DWORD);
// 9F7D4: using guessed type int stdout;
// 2463E8: using guessed type int dword_2463E8;

//----- (000645CC) --------------------------------------------------------
char *__fastcall sub_645CC(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "true";
  if ( !v2 )
    v3 = "false";
  return strncpy(a1, v3, 0x50u);
}

//----- (000645F0) --------------------------------------------------------
char *__fastcall sub_645F0(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "false";
  if ( !v2 )
    v3 = "true";
  return strncpy(a1, v3, 0x50u);
}

//----- (00064614) --------------------------------------------------------
char *__fastcall sub_64614(_BYTE *a1, const char **a2)
{
  size_t v4; // r0
  bool v5; // cc
  size_t v6; // r5
  char *v7; // r0
  const char *v8; // r1
  _BYTE *v9; // r4
  char *result; // r0

  v4 = strlen(*a2);
  v5 = v4 > 0x4E;
  v6 = v4;
  *a1 = 34;
  v7 = a1 + 1;
  v8 = *a2;
  if ( v5 )
  {
    result = strncpy(v7, v8, 0x4Eu);
    a1[79] = 34;
  }
  else
  {
    v9 = &a1[v6];
    result = strncpy(v7, v8, v6);
    v9[1] = 34;
    if ( v6 != 78 )
      v9[2] = 0;
  }
  return result;
}

//----- (00064674) --------------------------------------------------------
int __fastcall sub_64674(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%i", *a2);
}

//----- (00064688) --------------------------------------------------------
int __fastcall sub_64688(char *a1, float *a2)
{
  return snprintf(a1, 0x50u, "%.1f", *a2);
}

//----- (000646B4) --------------------------------------------------------
int __fastcall sub_646B4(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%u", *a2);
}

//----- (000646C8) --------------------------------------------------------
int __fastcall sub_646C8(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%li", *a2);
}

//----- (000646DC) --------------------------------------------------------
int __fastcall sub_646DC(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%lu", *a2);
}

//----- (000646F0) --------------------------------------------------------
const char *__fastcall sub_646F0(unsigned int *a1, size_t *a2)
{
  _DWORD *v2; // r12
  const char *v3; // r4
  int v5; // r4
  unsigned int v6; // lr

  *a1 = 0;
  if ( !dword_2463EC )
    return 0;
  v2 = (_DWORD *)dword_2463E4;
  if ( *(_DWORD *)(dword_2463E4 + 4) == 8 )
  {
    v5 = 28;
    v6 = 1;
    do
    {
      *a1 = v6;
      if ( dword_2463EC <= v6++ )
        return 0;
      v2 = (_DWORD *)(dword_2463E4 + v5);
      v5 += 28;
    }
    while ( v2[1] == 8 );
  }
  v3 = (const char *)(*v2 + 1);
  *a2 = strcspn(v3, (const char *)&off_89BE4);
  return v3;
}
// 89BE4: using guessed type _UNKNOWN *off_89BE4;
// 2463E4: using guessed type int dword_2463E4;
// 2463EC: using guessed type int dword_2463EC;

//----- (00064790) --------------------------------------------------------
int __fastcall sub_64790(int a1, size_t *a2)
{
  int v2; // r3
  size_t v3; // r0
  bool v4; // zf
  int v5; // r4

  v2 = *(unsigned __int8 *)(a1 + *a2);
  v3 = a1 + *a2;
  v4 = (v2 & 0xDF) == 0;
  if ( (v2 & 0xDF) != 0 )
    v4 = v2 == 61;
  if ( v4 )
    return 0;
  v5 = v3 + 2;
  *a2 = strcspn((const char *)(v3 + 2), (const char *)&off_89BE4);
  return v5;
}
// 89BE4: using guessed type _UNKNOWN *off_89BE4;

//----- (000647D8) --------------------------------------------------------
int __fastcall sub_647D8(int a1, unsigned int *a2, size_t *a3)
{
  unsigned int v3; // r3
  _DWORD *v7; // r2
  int result; // r0
  const char *v9; // r4

  v3 = *a2;
  if ( *a2 >= dword_2463EC )
    return 0;
  while ( 1 )
  {
    v7 = (_DWORD *)(dword_2463E4 + 28 * v3);
    if ( v7[1] != 8 )
      break;
LABEL_6:
    *a2 = ++v3;
    if ( v3 >= dword_2463EC )
      return 0;
  }
  if ( a1 )
  {
    result = sub_64790(a1, a3);
    a1 = result;
    if ( result )
      return result;
    v3 = *a2;
    goto LABEL_6;
  }
  v9 = (const char *)(*v7 + 1);
  *a3 = strcspn(v9, (const char *)&off_89BE4);
  return (int)v9;
}
// 89BE4: using guessed type _UNKNOWN *off_89BE4;
// 2463E4: using guessed type int dword_2463E4;
// 2463EC: using guessed type int dword_2463EC;

//----- (00064890) --------------------------------------------------------
int __fastcall sub_64890(const char **a1)
{
  __int64 v1; // r2
  bool v2; // cc
  _BYTE *v4; // r4
  int v5; // r0
  const char *v6; // r12
  unsigned int v7; // r3
  int v8; // r3
  bool v9; // zf
  int result; // r0
  int status; // [sp+Ch] [bp-4h] BYREF

  v1 = *(_QWORD *)a1;
  v2 = (unsigned int)a1[1] > 4;
  if ( a1[1] != (const char *)4 )
    v2 = (unsigned int)(a1[1] - 1) > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", (const char *)v1, HIDWORD(v1));
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", (const char *)v1);
  if ( *(_BYTE *)v1 != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)v1);
  v4 = (_BYTE *)(v1 + 1);
  v5 = strcspn((const char *)(v1 + 1), (const char *)&off_89BE4);
  for ( status = v5; ; v5 = status )
  {
    if ( *v4 == 45 )
    {
      if ( v5 == 1 )
        errx(1, "Option %s: invalid long option '--'", *a1);
      v6 = a1[1];
      ++dword_2463DC;
    }
    else
    {
      if ( v5 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *a1, v5 + 1, v4 - 1);
      v6 = a1[1];
      v7 = (unsigned int)(v6 - 2) & 0xFFFFFFFD;
      if ( !v7 )
        v7 = dword_2463D8;
      ++dword_2463E0;
      if ( ((unsigned int)(v6 - 2) & 0xFFFFFFFD) == 0 )
        dword_2463D8 = v7 + 1;
    }
    if ( v6 == (const char *)1 )
    {
      v8 = (unsigned __int8)v4[v5];
      v9 = v8 == 61;
      if ( v8 != 61 )
        v9 = v8 == 32;
      if ( v9 )
        errx(1, "Option %s: does not take arguments '%s'", *a1, &v4[v5 + 1]);
    }
    result = sub_64790((int)v4, (size_t *)&status);
    v4 = (_BYTE *)result;
    if ( !result )
      break;
  }
  return result;
}
// 89BE4: using guessed type _UNKNOWN *off_89BE4;
// 2463D8: using guessed type int dword_2463D8;
// 2463DC: using guessed type int dword_2463DC;
// 2463E0: using guessed type int dword_2463E0;

//----- (00064A04) --------------------------------------------------------
int __fastcall sub_64A04(int *a1)
{
  char *v2; // r0
  int v3; // r3
  int *v4; // lr
  char *v5; // r12
  int v6; // r4
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  char *v11; // r12
  int result; // r0
  int v13; // r1
  int v14; // r2

  v2 = (char *)realloc((void *)dword_2463E4, 28 * (dword_2463EC + 1));
  v3 = dword_2463EC;
  v4 = a1;
  v5 = v2;
  dword_2463E4 = (int)v2;
  ++dword_2463EC;
  v6 = 7 * v3;
  v7 = *v4;
  v8 = v4[1];
  v9 = v4[2];
  v10 = v4[3];
  v4 += 4;
  v11 = &v5[4 * v6];
  *(_DWORD *)v11 = v7;
  *((_DWORD *)v11 + 1) = v8;
  *((_DWORD *)v11 + 2) = v9;
  *((_DWORD *)v11 + 3) = v10;
  v11 += 16;
  result = *v4;
  v13 = v4[1];
  v14 = v4[2];
  *(_DWORD *)v11 = *v4;
  *((_DWORD *)v11 + 1) = v13;
  *((_DWORD *)v11 + 2) = v14;
  return result;
}
// 2463E4: using guessed type int dword_2463E4;
// 2463EC: using guessed type int dword_2463EC;

//----- (00064A68) --------------------------------------------------------
const char *__fastcall sub_64A68(unsigned int *a1, size_t *a2)
{
  const char *v4; // r0

  v4 = sub_646F0(a1, a2);
  if ( !v4 )
    return 0;
  while ( *v4 != 45 )
  {
    v4 = (const char *)sub_647D8((int)v4, a1, a2);
    if ( !v4 )
      return 0;
  }
  --*a2;
  return v4 + 1;
}

//----- (00064AC0) --------------------------------------------------------
_BYTE *__fastcall sub_64AC0(int a1, unsigned int *a2, size_t *a3)
{
  _BYTE *v5; // r0

  v5 = (_BYTE *)sub_647D8(a1, a2, a3);
  if ( !v5 )
    return 0;
  while ( *v5 != 45 )
  {
    v5 = (_BYTE *)sub_647D8((int)v5, a2, a3);
    if ( !v5 )
      return 0;
  }
  --*a3;
  return v5 + 1;
}

//----- (00064B18) --------------------------------------------------------
const char *__fastcall sub_64B18(unsigned int *a1)
{
  const char *result; // r0
  size_t v3; // [sp+4h] [bp-8h] BYREF

  v3 = 0;
  result = sub_646F0(a1, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (const char *)sub_647D8((int)result, a1, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00064B78) --------------------------------------------------------
_BYTE *__fastcall sub_64B78(int a1, unsigned int *a2)
{
  _BYTE *result; // r0
  size_t v4; // [sp+4h] [bp-8h] BYREF

  v4 = 1;
  result = (_BYTE *)sub_647D8(a1, a2, &v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (_BYTE *)sub_647D8((int)result, a2, &v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00064BD8) --------------------------------------------------------
int __fastcall sub_64BD8(
        const char *a1,
        const char *a2,
        const char *a3,
        const char *a4,
        const char *a5,
        const char *a6,
        const char *a7)
{
  const char *v8[8]; // [sp+4h] [bp-20h] BYREF

  v8[1] = a2;
  v8[0] = a1;
  v8[2] = a3;
  v8[3] = a4;
  v8[4] = a5;
  v8[5] = a6;
  v8[6] = a7;
  sub_64890(v8);
  return sub_64A04((int *)v8);
}

//----- (00064C1C) --------------------------------------------------------
int __fastcall sub_64C1C(int result, int a2)
{
  const char **v3; // r4
  int v4; // r6
  const char *v5; // r3
  int v6[8]; // [sp+4h] [bp-20h] BYREF

  v3 = (const char **)result;
  v4 = dword_2463EC;
  if ( a2 )
  {
    v6[0] = 0;
    memset(&v6[2], 0, 16);
    v6[6] = a2;
    v6[1] = 8;
    sub_64A04(v6);
    v5 = v3[1];
    if ( v5 == (const char *)16 )
    {
LABEL_7:
      result = 7 * v4;
      *(_DWORD *)(dword_2463E4 + 28 * v4 + 20) = dword_2463EC - v4;
      return result;
    }
  }
  else
  {
    v5 = *(const char **)(result + 4);
    if ( v5 == (const char *)16 )
      return result;
  }
  do
  {
    if ( v5 == (const char *)8 )
    {
      result = sub_64C1C(*v3, v3[6]);
    }
    else
    {
      sub_64890(v3);
      result = sub_64A04((int *)v3);
    }
    v3 += 7;
    v5 = v3[1];
  }
  while ( v5 != (const char *)16 );
  if ( a2 )
    goto LABEL_7;
  return result;
}
// 2463E4: using guessed type int dword_2463E4;
// 2463EC: using guessed type int dword_2463EC;

//----- (00064CF0) --------------------------------------------------------
bool __fastcall sub_64CF0(_DWORD *a1, const char **a2, void (*a3)(const char *, ...))
{
  int v6; // r0
  int v8; // [sp+4h] [bp-8h] BYREF

  dword_2463E8 = (int)*a2;
  v8 = 0;
  do
    v6 = sub_64E5C(a1, a2, &v8, a3);
  while ( v6 == 1 );
  return v6 == 0;
}
// 2463E8: using guessed type int dword_2463E8;

//----- (00064D4C) --------------------------------------------------------
void sub_64D4C()
{
  free((void *)dword_2463E4);
  dword_2463E4 = 0;
}
// 2463E4: using guessed type int dword_2463E4;

//----- (00064D6C) --------------------------------------------------------
int sub_64D6C(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  return fputc(10, (FILE *)stderr);
}
// 9F7C8: using guessed type int stderr;

//----- (00064DB4) --------------------------------------------------------
void __noreturn sub_64DB4(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 9F7C8: using guessed type int stderr;

//----- (00064DF4) --------------------------------------------------------
char *__fastcall sub_64DF4(const char *a1)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen(a1);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", a1);
  return v3;
}

//----- (00064E24) --------------------------------------------------------
void *__fastcall sub_64E24(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memmove((void *)(a2 + 4 * a3), (const void *)(a2 + 4 * a3 + 4), 4 * (*a1 - a3));
  --*a1;
  return result;
}

//----- (00064E5C) --------------------------------------------------------
int __fastcall sub_64E5C(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  bool v8; // zf
  int result; // r0
  const char **v10; // r6
  int *v11; // r3
  int v12; // r4
  int v13; // t1
  unsigned __int8 *v14; // r0
  int v15; // lr
  unsigned int v16; // r12
  int v17; // r1
  int v18; // r3
  char *v19; // r10
  int v20; // r3
  int v21; // r1
  char *v22; // r11
  int v23; // r10
  const char *v24; // r0
  int *v25; // r3
  const char *v26; // r7
  int *v27; // r11
  const char *v28; // r10
  size_t v29; // r4
  size_t v30; // lr
  int *v31; // r3
  const char *v32; // r11
  size_t v33; // r0
  int *v34; // r2
  const char *v35; // r11
  const char *v36; // r3
  size_t v37; // r10
  const char *v38; // [sp+8h] [bp-14h]
  int v39; // [sp+Ch] [bp-10h]
  unsigned int v40; // [sp+10h] [bp-Ch] BYREF
  size_t n[2]; // [sp+14h] [bp-8h] BYREF

  v8 = getenv("POSIXLY_CORRECT") == 0;
  result = (int)a2[1];
  if ( !v8 )
  {
    v10 = a2 + 1;
    if ( !result )
      return result;
    if ( *(_BYTE *)result != 45 )
      return 0;
    v12 = 1;
    if ( *(_BYTE *)(result + 1) == 45 )
      goto LABEL_23;
LABEL_15:
    v14 = (unsigned __int8 *)sub_64B18(&v40);
    if ( v14 )
    {
      v15 = *a3 + 1;
      if ( *v14 == (unsigned __int8)(*v10)[v15] )
      {
LABEL_17:
        v16 = v40;
        v38 = (const char *)(v14 - 1);
        *a3 = v15;
        n[0] = 2;
        v17 = 28 * v16;
        v18 = dword_2463E4 + 28 * v16;
        if ( *(_DWORD *)(v18 + 4) != 1 )
        {
LABEL_18:
          if ( v15 )
          {
            v19 = (char *)&(*v10)[v15 + 1];
            if ( *v19 )
            {
              *a3 = 0;
              goto LABEL_20;
            }
          }
          v19 = (char *)a2[v12 + 1];
          if ( v19 )
            goto LABEL_20;
          a4("%s: %.*s: %s", *a2, n[0], v38, "requires an argument");
          return -1;
        }
LABEL_37:
        v19 = 0;
        v22 = (char *)(*(int (__fastcall **)(_DWORD))(v18 + 8))(*(_DWORD *)(v18 + 20));
        goto LABEL_38;
      }
      while ( 1 )
      {
        v14 = sub_64B78((int)v14, &v40);
        if ( !v14 )
          break;
        v15 = *a3 + 1;
        if ( (unsigned __int8)(*v10)[v15] == *v14 )
          goto LABEL_17;
      }
    }
LABEL_36:
    v33 = strlen(*v10);
    a4("%s: %.*s: %s", *a2, v33, *v10, "unrecognized option");
    return -1;
  }
  if ( !result )
    return result;
  if ( *(_BYTE *)result == 45 )
  {
    v10 = a2 + 1;
    v12 = 1;
  }
  else
  {
    v11 = (int *)(a2 + 2);
    v12 = 1;
    do
    {
      v10 = (const char **)v11;
      v13 = *v11++;
      result = v13;
      ++v12;
      if ( !v13 )
        return result;
    }
    while ( *(_BYTE *)result != 45 );
  }
  if ( *(_BYTE *)(result + 1) != 45 )
    goto LABEL_15;
LABEL_23:
  v23 = *(unsigned __int8 *)(result + 2);
  if ( !*(_BYTE *)(result + 2) )
  {
    sub_64E24(a1, (int)a2, v12);
    return v23;
  }
  if ( *a3 )
    _assert_fail("*offset == 0", "ccan/opt/parse.c", 0x3Bu, "parse_one");
  v24 = sub_64A68(&v40, n);
  if ( !v24 )
    goto LABEL_36;
  v25 = a3;
  v26 = v24;
  v27 = v25;
  v39 = v12;
  while ( 1 )
  {
    v28 = *v10;
    v29 = n[0];
    if ( strncmp(*v10 + 2, v26, n[0]) )
      goto LABEL_35;
    v30 = v29 + 2;
    if ( v28[v29 + 2] == 61 )
      break;
    if ( !v28[v29 + 2] )
    {
      v16 = v40;
      v31 = v27;
      v32 = v26;
      a3 = v31;
      v12 = v39;
      v38 = v32 - 2;
      v17 = 28 * v40;
      n[0] = v30;
      v18 = dword_2463E4 + 28 * v40;
      if ( *(_DWORD *)(v18 + 4) == 1 )
        goto LABEL_37;
      goto LABEL_34;
    }
LABEL_35:
    v26 = sub_64AC0((int)v26, &v40, n);
    if ( !v26 )
      goto LABEL_36;
  }
  v16 = v40;
  v34 = v27;
  v35 = v26;
  a3 = v34;
  v36 = v28;
  v37 = v29 + 3;
  v12 = v39;
  v17 = 28 * v40;
  v19 = (char *)&v36[v37];
  n[0] = v30;
  v38 = v35 - 2;
  v18 = dword_2463E4 + 28 * v40;
  if ( *(_DWORD *)(v18 + 4) == 1 )
  {
    if ( v19 )
    {
      a4("%s: %.*s: %s", *a2, v30, v38, "doesn't allow an argument");
      return -1;
    }
    goto LABEL_37;
  }
  if ( !v19 )
  {
LABEL_34:
    v15 = *a3;
    goto LABEL_18;
  }
LABEL_20:
  v20 = dword_2463E4;
  v21 = dword_2463E4 + v17;
  if ( *(_DWORD *)(v21 + 4) == 4 )
  {
    sub_64370((int)v19, *(_DWORD **)(v21 + 20));
    v16 = v40;
    v20 = dword_2463E4;
  }
  v22 = (char *)(*(int (__fastcall **)(char *, _DWORD))(v20 + 28 * v16 + 12))(v19, *(_DWORD *)(v20 + 28 * v16 + 20));
LABEL_38:
  if ( v22 )
  {
    a4("%s: %.*s: %s", *a2, n[0], v38, v22);
    free(v22);
    return -1;
  }
  else
  {
    if ( *a3 )
    {
      if ( !(*v10)[*a3 + 1] )
      {
        *a3 = 0;
        goto LABEL_42;
      }
    }
    else
    {
LABEL_42:
      sub_64E24(a1, (int)a2, v12);
      if ( v19 )
      {
        if ( *v10 == v19 )
          sub_64E24(a1, (int)a2, v12);
      }
    }
    return 1;
  }
}
// 2463E4: using guessed type int dword_2463E4;

//----- (0006530C) --------------------------------------------------------
char *__fastcall sub_6530C(const char *a1, const char *a2)
{
  size_t v3; // r7
  int v4; // r4
  unsigned int v5; // r8
  size_t v6; // r7
  size_t v7; // r0
  size_t v8; // r7
  size_t v9; // r5
  const char *v10; // r11
  char *v11; // r0
  char *v12; // r4
  int v13; // r0
  char *v14; // r1
  char *v15; // r4
  char *v16; // r7
  char *v17; // r12
  int v18; // r8
  int v19; // r0
  int v20; // r2
  char *v21; // r5
  int v22; // r7
  unsigned int v23; // r8
  int v24; // r2
  unsigned int v25; // r4
  unsigned int v26; // r4
  char *v27; // r3
  int v28; // r3
  const char *v29; // r2
  int v30; // r0
  unsigned int v31; // r4
  char *v32; // r3
  char *v33; // r0
  char *v34; // r0
  int v36; // r2
  int v37; // r3
  __int16 *v39; // [sp+0h] [bp-74h]
  const char *v40; // [sp+4h] [bp-70h]
  char *s; // [sp+8h] [bp-6Ch]
  char *v42; // [sp+10h] [bp-64h]
  char *v43; // [sp+14h] [bp-60h]
  unsigned int v44[22]; // [sp+1Ch] [bp-58h] BYREF

  v3 = dword_2463E0 + 20 + strlen(a1);
  if ( a2 )
  {
    v3 += strlen(a2);
    if ( !dword_2463EC )
      goto LABEL_13;
    v4 = dword_2463E4;
  }
  else
  {
    if ( !dword_2463EC )
    {
      a2 = "";
      goto LABEL_13;
    }
    v36 = 0;
    v4 = dword_2463E4;
    v37 = dword_2463E4;
    do
    {
      ++v36;
      if ( *(void (__fastcall __noreturn **)(int))(v37 + 8) == sub_6458C )
      {
        a2 = *(const char **)(v37 + 20);
        if ( a2 )
        {
          v3 += strlen(*(const char **)(v37 + 20));
          goto LABEL_4;
        }
      }
      v37 += 28;
    }
    while ( v36 != dword_2463EC );
    a2 = "";
  }
LABEL_4:
  v5 = 0;
  v40 = a2;
  do
  {
    while ( 1 )
    {
      v9 = v3 + 6;
      v10 = *(const char **)(v4 + 24);
      if ( *(_DWORD *)(v4 + 4) != 8 )
        break;
      ++v5;
      v3 += strlen(*(const char **)(v4 + 24)) + 3;
      v4 += 28;
      if ( v5 >= dword_2463EC )
        goto LABEL_12;
    }
    if ( v10 != (const char *)&unk_2463F0 )
    {
      v6 = strlen(*(const char **)v4);
      v7 = v6 + v9 + strlen(v10);
      v8 = v7 + 118;
      if ( !*(_DWORD *)(v4 + 16) )
        v8 = v7 + 21;
      v3 = v8 + 1;
    }
    ++v5;
    v4 += 28;
  }
  while ( v5 < dword_2463EC );
LABEL_12:
  a2 = v40;
LABEL_13:
  v11 = (char *)malloc(v3);
  v12 = v11;
  v43 = v11;
  if ( v11 )
  {
    v13 = sprintf(v11, "Usage: %s", a1);
    v14 = v12;
    v15 = &v12[v13];
    v16 = v15 + 3;
    strcpy(&v14[v13], " [-");
    v17 = (char *)sub_64B18(v44);
    if ( v17 )
    {
      v18 = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_2463E4 + 28 * v44[0] + 24) != &unk_2463F0 )
          v16[v18++] = *v17;
        v17 = sub_64B78((int)v17, v44);
      }
      while ( v17 );
      if ( v18 )
      {
        v15 = &v16[v18 + 1];
        *(_WORD *)&v16[v18] = 93;
      }
    }
    v19 = sprintf(v15, " %s", a2);
    v20 = dword_2463EC;
    v39 = &word_8B454;
    v21 = &v15[v19 + 1];
    *(_WORD *)&v15[v19] = 10;
    if ( v20 )
    {
      v22 = 0;
      v23 = 0;
      do
      {
        v28 = dword_2463E4 + v22;
        v29 = *(const char **)(dword_2463E4 + v22 + 24);
        if ( v29 != (const char *)&unk_2463F0 )
        {
          if ( *(_DWORD *)(v28 + 4) == 8 )
          {
            v21 += sprintf(v21, "%s:\n", v29);
          }
          else
          {
            v30 = sprintf(v21, "%s", *(const char **)v28);
            v31 = v30;
            v32 = &v21[v30];
            if ( *(_DWORD *)(dword_2463E4 + v22 + 4) == 2 )
            {
              v42 = &v21[v30];
              s = *(char **)(dword_2463E4 + v22);
              v33 = strchr(s, 32);
              v32 = v42;
              if ( !v33 )
              {
                v34 = strchr(s, 61);
                v32 = v42;
                if ( !v34 )
                {
                  v31 += 6;
                  strcpy(v42, " <arg>");
                  v32 = &v21[v31];
                }
              }
            }
            if ( v31 > 0x13 )
              v24 = 1;
            else
              v24 = 20 - v31;
            v25 = sprintf(v32, "%.*s", v24, "                    ", v39) + v31;
            v26 = sprintf(&v21[v25], "%s", *(const char **)(dword_2463E4 + v22 + 24)) + v25;
            v27 = &v21[v26];
            if ( *(_DWORD *)(dword_2463E4 + v22 + 16) )
            {
              v44[20] = 3026478;
              (*(void (__fastcall **)(unsigned int *, _DWORD))(dword_2463E4 + v22 + 16))(
                v44,
                *(_DWORD *)(dword_2463E4 + v22 + 20));
              v27 = &v21[sprintf(&v21[v26], " (default: %s)", (const char *)v44) + v26];
            }
            *(_WORD *)v27 = *v39;
            v21 = v27 + 1;
          }
        }
        ++v23;
        v22 += 28;
      }
      while ( dword_2463EC > v23 );
    }
    *v21 = 0;
  }
  return v43;
}
// 65538: variable 'v39' is possibly undefined
// 7A848: using guessed type __int16 word_7A848;
// 8B454: using guessed type __int16 word_8B454;
// 2463E0: using guessed type int dword_2463E0;
// 2463E4: using guessed type int dword_2463E4;
// 2463EC: using guessed type int dword_2463EC;

//----- (00065750) --------------------------------------------------------
char *__fastcall memchr(char *result, __int16 a2, unsigned int a3)
{
  _DWORD *v3; // r3
  bool v4; // zf
  int v5; // r4
  char *v6; // r12
  char *v7; // r2
  char *v8; // r3

  if ( !a3 )
    return 0;
  if ( ((unsigned __int8)result & 3) != 0 )
  {
    if ( (unsigned __int8)*result == (unsigned __int8)a2 )
      return result;
    v3 = result + 1;
    while ( 1 )
    {
      --a3;
      result = (char *)v3;
      if ( !a3 )
        return 0;
      v4 = ((unsigned __int8)v3 & 3) == 0;
      v3 = (_DWORD *)((char *)v3 + 1);
      if ( v4 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
  }
  v5 = (unsigned __int16)(a2 << 8) | (unsigned __int8)a2 | (((unsigned __int16)(a2 << 8) | (unsigned __int8)a2) << 16);
  if ( a3 > 3 && (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) == 0 )
  {
    v6 = result + 4;
    while ( 1 )
    {
      a3 -= 4;
      result = v6;
      v6 += 4;
      if ( a3 <= 3 )
        break;
      if ( (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) != 0 )
        goto LABEL_16;
    }
    if ( !a3 )
      return 0;
  }
LABEL_16:
  if ( (unsigned __int8)*result != (unsigned __int8)a2 )
  {
    v7 = &result[a3];
    v8 = result + 1;
    while ( 1 )
    {
      result = v8++;
      if ( result == v7 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (00065864) --------------------------------------------------------
unsigned int __fastcall sub_65864(int a1, unsigned int a2, int *a3)
{
  int v3; // r6
  int v4; // r12
  unsigned int v5; // r4
  int v6; // lr
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // r5
  unsigned int v10; // r7
  int v11; // r8
  unsigned int v12; // r4
  int v13; // r12
  int v14; // r5
  unsigned int v15; // r3
  int v16; // r6
  unsigned int v17; // r6
  unsigned int v18; // r7
  unsigned int result; // r0
  unsigned int v20; // r5
  bool v21; // zf

  v3 = 1;
  v4 = 1;
  v5 = 0;
  v6 = -1;
  while ( 1 )
  {
    v7 = v4 + v5;
    v8 = a1 + v6;
    if ( v4 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)(v8 + v4);
      v10 = *(unsigned __int8 *)(a1 + v7);
      if ( v10 >= v9 )
        break;
      v5 = v7;
      v4 = 1;
      v3 = v7 - v6;
      ++v7;
      v8 = a1 + v6;
      if ( v7 >= a2 )
        goto LABEL_5;
    }
    if ( v10 == v9 )
    {
      v21 = v4++ == v3;
      if ( v21 )
      {
        v5 = v7;
        v4 = 1;
      }
    }
    else
    {
      v3 = 1;
      v6 = v5;
      v4 = 1;
      ++v5;
    }
  }
LABEL_5:
  v11 = 1;
  v12 = 0;
  v13 = 1;
  v14 = -1;
  *a3 = v3;
  while ( 1 )
  {
    v15 = v13 + v12;
    v16 = a1 + v14;
    if ( a2 <= v13 + v12 )
      break;
    while ( 1 )
    {
      v17 = *(unsigned __int8 *)(v16 + v13);
      v18 = *(unsigned __int8 *)(a1 + v15);
      if ( v18 <= v17 )
        break;
      v12 = v15;
      v13 = 1;
      v11 = v15 - v14;
      ++v15;
      v16 = a1 + v14;
      if ( a2 <= v15 )
        goto LABEL_9;
    }
    if ( v18 == v17 )
    {
      v21 = v13++ == v11;
      if ( v21 )
      {
        v12 = v15;
        v13 = 1;
      }
    }
    else
    {
      v11 = 1;
      v14 = v12;
      v13 = 1;
      ++v12;
    }
  }
LABEL_9:
  result = v6 + 1;
  v20 = v14 + 1;
  if ( v20 >= v6 + 1 )
  {
    *a3 = v11;
    return v20;
  }
  return result;
}

//----- (00065974) --------------------------------------------------------
int __fastcall sub_65974(int a1, int a2, char *s1, unsigned int a4)
{
  size_t v8; // r4
  size_t v9; // r6
  int *v10; // r3
  char *v11; // r1
  int v12; // r3
  int v13; // t1
  unsigned int v14; // r0
  unsigned int v15; // r3
  bool v16; // cf
  unsigned int v17; // r1
  unsigned int v18; // r1
  char *v19; // lr
  unsigned __int8 *v20; // r12
  int v21; // r9
  int v22; // t1
  int v23; // t1
  unsigned int v24; // lr
  unsigned __int8 *v25; // r1
  char *v26; // r8
  int v27; // r10
  int v28; // t1
  int v29; // t1
  int result; // r0
  size_t v31; // r3
  size_t v32; // r2
  unsigned int v33; // r10
  unsigned int v34; // r9
  int v35; // r3
  unsigned __int8 *v36; // r1
  size_t v37; // r3
  char *v38; // r12
  int v39; // r8
  int v40; // t1
  int v41; // t1
  unsigned __int8 *v42; // r3
  char *v43; // r1
  int v44; // lr
  int v45; // t1
  int v46; // t1
  unsigned int v47; // [sp+0h] [bp-424h]
  unsigned int v48; // [sp+4h] [bp-420h]
  int v49; // [sp+4h] [bp-420h]
  unsigned int v50; // [sp+Ch] [bp-418h]
  int v51[253]; // [sp+1Ch] [bp-408h] BYREF
  int v52; // [sp+41Ch] [bp-8h] BYREF

  v8 = a4 - 1;
  if ( a4 > 2 )
  {
    v9 = sub_65864((int)s1, a4, v51);
    v48 = v51[0];
  }
  else
  {
    v9 = a4 - 1;
    v48 = 1;
    v51[0] = 1;
  }
  v10 = v51;
  do
  {
    v10[1] = a4;
    ++v10;
  }
  while ( v10 != &v52 );
  if ( a4 )
  {
    v11 = s1 - 1;
    v12 = v8;
    do
    {
      v13 = (unsigned __int8)*++v11;
      v51[v13 + 1] = v12;
      v16 = v12-- != 0;
    }
    while ( v16 );
  }
  v14 = memcmp(s1, &s1[v48], v9);
  if ( !v14 )
  {
    v47 = a2 - a4;
    v50 = a4 - v48;
    v15 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = v51[*(unsigned __int8 *)(a1 + v15 + v8) + 1];
        if ( v17 )
        {
          v16 = 1;
          if ( v14 )
            v16 = v17 >= v48;
          v14 = 0;
          if ( !v16 )
            v17 = v50;
          v15 += v17;
          goto LABEL_15;
        }
        v18 = v9 < v14 ? v14 : v9;
        if ( v18 < v8 )
          break;
LABEL_25:
        v24 = v9 - 1;
        if ( v9 > v14 && (v25 = (unsigned __int8 *)(a1 + v9 - 1 + v15), (unsigned __int8)s1[v9 - 1] == *v25) )
        {
          v26 = &s1[v9 - 1];
          while ( v24 - 1 != v14 - 1 )
          {
            v28 = (unsigned __int8)*--v26;
            v27 = v28;
            v29 = *--v25;
            if ( v27 != v29 )
              break;
            --v24;
          }
        }
        else
        {
          v24 = v9;
        }
        if ( v14 + 1 > v24 )
          return a1 + v15;
        v14 = v50;
        v15 += v48;
        if ( v47 < v15 )
          return 0;
      }
      v19 = &s1[v18];
      v20 = (unsigned __int8 *)(a1 + v18 + v15);
      if ( *v20 == (unsigned __int8)s1[v18] )
      {
        while ( ++v18 < v8 )
        {
          v22 = (unsigned __int8)*++v19;
          v21 = v22;
          v23 = *++v20;
          if ( v21 != v23 )
            goto LABEL_35;
        }
        goto LABEL_25;
      }
LABEL_35:
      v14 = 0;
      v15 += v18 + 1 - v9;
LABEL_15:
      if ( v47 < v15 )
        return 0;
    }
  }
  v31 = a4 - v9;
  v32 = v9 - 1;
  v33 = a2 - a4;
  if ( a4 - v9 < v9 )
    v31 = v9;
  v34 = 0;
  v49 = v31 + 1;
  while ( 1 )
  {
    result = a1 + v34;
    v35 = v51[*(unsigned __int8 *)(a1 + v34 + v8) + 1];
    if ( !v35 )
      break;
LABEL_52:
    v34 += v35;
LABEL_53:
    if ( v34 > v33 )
      return 0;
  }
  if ( v9 < v8 )
  {
    v36 = (unsigned __int8 *)(a1 + v9 + v34);
    if ( *v36 != (unsigned __int8)s1[v9] )
    {
      v37 = v9;
LABEL_55:
      v34 += v37 + 1 - v9;
      goto LABEL_53;
    }
    v38 = &s1[v9];
    v37 = v9;
    while ( ++v37 < v8 )
    {
      v40 = (unsigned __int8)*++v38;
      v39 = v40;
      v41 = *++v36;
      if ( v39 != v41 )
        goto LABEL_55;
    }
  }
  if ( !v9 )
    return result;
  v42 = (unsigned __int8 *)(a1 + v32 + v34);
  if ( *v42 != (unsigned __int8)s1[v32] )
  {
LABEL_51:
    v35 = v49;
    goto LABEL_52;
  }
  v43 = &s1[v32];
  while ( v43 != s1 )
  {
    v45 = (unsigned __int8)*--v43;
    v44 = v45;
    v46 = *--v42;
    if ( v44 != v46 )
      goto LABEL_51;
  }
  return result;
}

//----- (00065CA0) --------------------------------------------------------
int __fastcall memmem(char *a1, unsigned int a2, char *a3, unsigned int a4)
{
  char *v6; // r5
  char *v9; // r0
  _BOOL4 v10; // r3
  unsigned int v11; // r7
  size_t v12; // r6
  unsigned int v13; // r0
  unsigned int v14; // r2
  size_t v15; // r12
  size_t v16; // r3
  char *v17; // lr
  char *v18; // r1
  int v19; // r8
  int v20; // t1
  int v21; // t1
  unsigned int v22; // lr
  char *v23; // r3
  char *v24; // r7
  int v25; // r9
  int v26; // t1
  int v27; // t1
  size_t v29; // r3
  size_t v30; // r9
  unsigned int v31; // r0
  unsigned int v32; // r7
  char *v33; // r2
  size_t v34; // r3
  char *v35; // r1
  int v36; // lr
  int v37; // t1
  int v38; // t1
  char *v39; // r3
  char *v40; // r2
  int v41; // r12
  int v42; // t1
  int v43; // t1
  int v44; // [sp+4h] [bp-20h]
  int v45; // [sp+8h] [bp-1Ch]
  int v46; // [sp+1Ch] [bp-8h] BYREF

  if ( !a4 )
    return (int)a1;
  if ( a4 > a2 )
    return 0;
  if ( a4 > 0x1F )
    return sub_65974((int)a1, a2, a3, a4);
  v9 = memchr(a1, (unsigned __int8)*a3, a2);
  v6 = v9;
  v10 = a4 == 1;
  if ( !v9 )
    v10 = 1;
  if ( v10 )
    return (int)v6;
  v11 = a2 - (v9 - a1);
  if ( a4 > v11 )
    return 0;
  if ( a4 > 2 )
  {
    v12 = sub_65864((int)a3, a4, &v46);
    v45 = v46;
  }
  else
  {
    v12 = a4 - 1;
    v45 = 1;
    v46 = 1;
  }
  v13 = memcmp(a3, &a3[v45], v12);
  if ( !v13 )
  {
    v14 = v11 - a4;
    v15 = 0;
    while ( 1 )
    {
      if ( v12 < v15 )
        v16 = v15;
      else
        v16 = v12;
      if ( a4 > v16 )
      {
        v17 = &a3[v16];
        v18 = &v6[v16 + v13];
        if ( a3[v16] != *v18 )
        {
LABEL_32:
          v15 = 0;
          v13 += 1 - v12 + v16;
          goto LABEL_29;
        }
        while ( a4 != ++v16 )
        {
          v20 = (unsigned __int8)*++v17;
          v19 = v20;
          v21 = (unsigned __int8)*++v18;
          if ( v19 != v21 )
            goto LABEL_32;
        }
      }
      v22 = v12 - 1;
      if ( v12 > v15 && (v23 = &v6[v12 - 1 + v13], a3[v12 - 1] == *v23) )
      {
        v24 = &a3[v12 - 1];
        while ( v22 - 1 != v15 - 1 )
        {
          v26 = (unsigned __int8)*--v24;
          v25 = v26;
          v27 = (unsigned __int8)*--v23;
          if ( v25 != v27 )
            break;
          --v22;
        }
      }
      else
      {
        v22 = v12;
      }
      if ( v15 + 1 > v22 )
      {
        v6 += v13;
        return (int)v6;
      }
      v15 = a4 - v45;
      v13 += v45;
LABEL_29:
      if ( v14 < v13 )
        return 0;
    }
  }
  v29 = a4 - v12;
  v30 = v12 - 1;
  v31 = v11 - a4;
  if ( a4 - v12 < v12 )
    v29 = v12;
  v32 = 0;
  v44 = v29 + 1;
  while ( 1 )
  {
    if ( a4 > v12 )
    {
      v33 = &v6[v12 + v32];
      if ( *v33 != a3[v12] )
      {
        v34 = v12;
LABEL_49:
        v32 += 1 - v12 + v34;
        goto LABEL_50;
      }
      v35 = &a3[v12];
      v34 = v12;
      while ( a4 != ++v34 )
      {
        v37 = (unsigned __int8)*++v35;
        v36 = v37;
        v38 = (unsigned __int8)*++v33;
        if ( v36 != v38 )
          goto LABEL_49;
      }
    }
    if ( !v12 )
      return (int)&v6[v32];
    v39 = &v6[v30 + v32];
    if ( *v39 == a3[v30] )
      break;
LABEL_52:
    v32 += v44;
LABEL_50:
    if ( v31 < v32 )
      return 0;
  }
  v40 = &a3[v30];
  while ( v40 != a3 )
  {
    v42 = (unsigned __int8)*--v40;
    v41 = v42;
    v43 = (unsigned __int8)*--v39;
    if ( v41 != v43 )
      goto LABEL_52;
  }
  return (int)&v6[v32];
}

//----- (0006607C) --------------------------------------------------------
void sub_6607C()
{
  unsigned int v0; // r0
  int v1; // r12
  int v2; // r1
  int v3; // lr
  int v4; // r3
  int *v5; // r2
  int v6; // r5
  unsigned int v7; // r2
  int v8; // r0
  int *v9; // r3
  int v10; // [sp+4h] [bp-808h] BYREF
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v10 = 0;
  memset(dword_1B0D38, 0, sizeof(dword_1B0D38));
  sub_6688C(2, &v10);
  if ( !v10 )
  {
    strcpy(s, "Cannot Find Any Plug In!\r\n");
    sub_47AB4(0, s, 0);
    return;
  }
  if ( v10 < 0 )
  {
    v10 = HIBYTE(v10);
    dword_1B0E5C = 1;
    snprintf(s, 0x800u, "HASH_ON_PLUG T9 = 0x%x\n", v10);
    sub_47AB4(2, s, 0);
    v7 = v10;
    if ( !v10 )
      return;
    v1 = dword_1B0D38[0];
    v2 = 0;
    v8 = 0;
    do
    {
      v9 = &dword_1B0D38[18 * v1];
      if ( (v7 & 1) != 0 )
      {
        v9[1] = v8;
        if ( v8 == 1 )
        {
          v9[3] = 2;
          v9[4] = 10;
          v9[5] = 11;
          v9[2] = 3;
        }
        else if ( v8 )
        {
          if ( v8 == 2 )
          {
            v9[3] = 3;
            v9[4] = 12;
            v9[5] = 13;
            v9[2] = 3;
          }
        }
        else
        {
          v9[3] = 1;
          v9[4] = 8;
          v9[5] = 9;
          v9[2] = 3;
        }
        ++v1;
        v2 = 1;
      }
      v7 >>= 1;
      ++v8;
    }
    while ( v7 );
  }
  else
  {
    dword_1B0E5C = 0;
    v10 = (unsigned __int16)v10;
    snprintf(s, 0x800u, "HASH_ON_PLUG V9 = 0x%x\n", (unsigned __int16)v10);
    sub_47AB4(2, s, 0);
    v0 = v10;
    if ( !v10 )
      return;
    v1 = dword_1B0D38[0];
    v2 = 0;
    v3 = 0;
    do
    {
      v4 = 9 * v1;
      v5 = &dword_1B0D38[18 * v1];
      if ( (v0 & 1) != 0 )
      {
        v6 = v5[2];
        v2 = 1;
        ++v1;
        v5[1] = v3;
        v5[2] = v6 + 1;
        dword_1B0D38[2 * v4 + 3 + v6] = v3;
      }
      v0 >>= 1;
      ++v3;
    }
    while ( v0 );
  }
  if ( v2 )
    dword_1B0D38[0] = v1;
}
// 1B0D38: using guessed type int dword_1B0D38[73];
// 1B0E5C: using guessed type int dword_1B0E5C;

//----- (00066298) --------------------------------------------------------
int sub_66298()
{
  int v0; // r6
  char v2[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_1B0E60 )
    return 0;
  if ( sub_667A0() )
  {
    v0 = -1;
    strcpy(v2, "fpga init failed\n");
    sub_47AB4(0, v2, 0);
    return v0;
  }
  if ( sub_669C4() )
  {
    v0 = -2;
    strcpy(v2, "gpio init failed\n");
    sub_47AB4(0, v2, 0);
    return v0;
  }
  memset(dword_1B0D38, 0, sizeof(dword_1B0D38));
  if ( sub_694C4() )
  {
    sub_667C0();
    nullsub_1();
    v0 = -3;
    strcpy(v2, "failed to load hal config\n");
    sub_47AB4(0, v2, 0);
    return v0;
  }
  sub_6607C();
  dword_1B0E60 = 1;
  sub_66474();
  sub_68B54();
  sub_67EA0();
  return 0;
}
// 669CC: using guessed type int nullsub_1(void);
// 1B0D38: using guessed type int dword_1B0D38[73];
// 1B0E60: using guessed type int dword_1B0E60;

//----- (000663D8) --------------------------------------------------------
void sub_663D8()
{
  int v0; // r0
  int v1; // r0

  if ( dword_1B0E60 )
  {
    nullsub_17();
    sub_667C0();
    v0 = nullsub_16();
    v1 = nullsub_18(v0);
    nullsub_1(v1);
    dword_1B0E60 = 0;
  }
}
// 6647C: using guessed type int nullsub_16(void);
// 669CC: using guessed type int __fastcall nullsub_1(_DWORD);
// 67F00: using guessed type int nullsub_17(void);
// 68BE4: using guessed type int __fastcall nullsub_18(_DWORD);
// 1B0E60: using guessed type int dword_1B0E60;

//----- (00066410) --------------------------------------------------------
void *__fastcall sub_66410(void *result)
{
  void *v1; // r4

  v1 = result;
  if ( result )
  {
    sub_6607C();
    return memcpy(v1, dword_1B0D38, 0x124u);
  }
  return result;
}
// 1B0D38: using guessed type int dword_1B0D38[73];

//----- (00066474) --------------------------------------------------------
int sub_66474()
{
  return 0;
}

//----- (00066480) --------------------------------------------------------
int __fastcall sub_66480(int a1)
{
  int v2; // r4
  unsigned int v4; // [sp+0h] [bp-Ch] BYREF
  int v5; // [sp+4h] [bp-8h] BYREF

  v4 = 0;
  v2 = 6;
  sub_6688C(0, &v5);
  v5 = (unsigned __int16)v5;
  while ( 1 )
  {
    sub_6688C(1, &v4);
    if ( ((v4 >> 8) & 7) == a1 )
      break;
    usleep(0x2710u);
    if ( !--v2 )
      return -1;
  }
  if ( v5 == 45093 )
    return 240 * (unsigned __int8)v4;
  else
    return 120 * (unsigned __int8)v4;
}

//----- (00066508) --------------------------------------------------------
int sub_66508()
{
  return 6;
}

//----- (00066510) --------------------------------------------------------
int sub_66510()
{
  return -1;
}

//----- (00066518) --------------------------------------------------------
int __fastcall sub_66518(int a1)
{
  int v1; // r4

  if ( !a1 )
    return sub_6739C(954, 1);
  if ( a1 == 1 )
    return sub_6739C(955, 1);
  v1 = sub_6739C(954, 1);
  return v1 + sub_6739C(955, 1);
}

//----- (00066564) --------------------------------------------------------
int __fastcall sub_66564(int a1)
{
  int v1; // r0
  int v2; // r4

  if ( !a1 )
  {
    v1 = 954;
    return sub_6739C(v1, 0);
  }
  if ( a1 == 1 )
  {
    v1 = 955;
    return sub_6739C(v1, 0);
  }
  v2 = sub_6739C(954, 0);
  return v2 + sub_6739C(955, 0);
}

//----- (000665B0) --------------------------------------------------------
int sub_665B0()
{
  int v0; // r0
  int v1; // r0
  int v2; // r0
  int result; // r0
  int v4; // [sp+4h] [bp-810h]
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v0 = open64("/dev/axi_fpga_dev", 2);
  dword_1B0E64 = v0;
  if ( v0 < 0 )
  {
    snprintf(s, 0x800u, "/dev/axi_fpga_dev open failed. fd = %d\n", v0);
    sub_47AB4(0, s, 0);
    return -1;
  }
  else
  {
    dword_1B0E68 = ((int (__fastcall *)(_DWORD, int, int, int, int))mmap64)(0, 4608, 3, 1, v0);
    if ( dword_1B0E68 )
    {
      v1 = open64("/dev/fpga_mem", 2);
      dword_1B0E6C = v1;
      if ( v1 < 0 )
      {
        snprintf(s, 0x800u, "/dev/fpga_mem open failed. fd_fpga_mem_hal = %d\n", v1);
        sub_47AB4(0, s, 0);
        perror("open");
        munmap((void *)dword_1B0E68, 0x1200u);
        close(dword_1B0E64);
        return -1;
      }
      else
      {
        v2 = mmap64(0, 0x1000000, 3, 1, v1, v4, 0, 0);
        dword_1B0E70 = v2;
        if ( v2 )
        {
          snprintf(s, 0x800u, "mmap fpga_mem_addr_hal = 0x%x\n", v2);
          sub_47AB4(3, s, 0);
          result = 0;
          dword_1B0E74 = 1;
        }
        else
        {
          snprintf(s, 0x800u, "mmap fpga_mem_addr_hal failed. fpga_mem_addr_hal = 0x%x\n", 0);
          sub_47AB4(0, s, 0);
          munmap((void *)dword_1B0E68, 0x1200u);
          close(dword_1B0E64);
          close(dword_1B0E6C);
          return -1;
        }
      }
    }
    else
    {
      snprintf(s, 0x800u, "mmap axi_fpga_addr failed. axi_fpga_addr = %p\n", 0);
      sub_47AB4(0, s, 0);
      close(dword_1B0E64);
      return -2;
    }
  }
  return result;
}
// 66648: variable 'v4' is possibly undefined
// 11FEC: using guessed type int __fastcall mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 12184: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 1B0E64: using guessed type int dword_1B0E64;
// 1B0E68: using guessed type int dword_1B0E68;
// 1B0E6C: using guessed type int dword_1B0E6C;
// 1B0E70: using guessed type int dword_1B0E70;
// 1B0E74: using guessed type int dword_1B0E74;

//----- (000667A0) --------------------------------------------------------
int sub_667A0()
{
  if ( dword_1B0E74 )
    return 0;
  else
    return sub_665B0();
}
// 1B0E74: using guessed type int dword_1B0E74;

//----- (000667C0) --------------------------------------------------------
void sub_667C0()
{
  char v0[2048]; // [sp+0h] [bp-800h] BYREF

  if ( dword_1B0E74 )
  {
    if ( munmap((void *)dword_1B0E68, 0x1200u) < 0 )
    {
      strcpy(v0, "munmap failed!\n");
      sub_47AB4(0, v0, 0);
    }
    if ( munmap((void *)dword_1B0E70, 0x1000000u) < 0 )
    {
      strcpy(v0, "munmap fpga_mem_addr_hal failed!\n");
      sub_47AB4(0, v0, 0);
    }
    dword_1B0E74 = 0;
    close(dword_1B0E64);
    close(dword_1B0E6C);
  }
}
// 1B0E64: using guessed type int dword_1B0E64;
// 1B0E68: using guessed type int dword_1B0E68;
// 1B0E6C: using guessed type int dword_1B0E6C;
// 1B0E70: using guessed type int dword_1B0E70;
// 1B0E74: using guessed type int dword_1B0E74;

//----- (0006688C) --------------------------------------------------------
int __fastcall sub_6688C(int a1, _DWORD *a2)
{
  int v4; // r3

  if ( !dword_1B0E74 && sub_665B0() )
    return -1;
  if ( dword_1B0E5C )
    v4 = dword_9EE84[a1];
  else
    v4 = dword_9EE84[a1 + 186];
  *a2 = *(_DWORD *)(dword_1B0E68 + 4 * v4);
  return 0;
}
// 9EE84: using guessed type _DWORD dword_9EE84[372];
// 1B0E5C: using guessed type int dword_1B0E5C;
// 1B0E68: using guessed type int dword_1B0E68;
// 1B0E74: using guessed type int dword_1B0E74;

//----- (00066908) --------------------------------------------------------
int __fastcall sub_66908(int a1, int a2)
{
  int v4; // r3

  if ( !dword_1B0E74 && sub_665B0() )
    return -1;
  if ( dword_1B0E5C )
    v4 = dword_9EE84[a1];
  else
    v4 = dword_9EE84[a1 + 186];
  *(_DWORD *)(dword_1B0E68 + 4 * v4) = a2;
  return 0;
}
// 9EE84: using guessed type _DWORD dword_9EE84[372];
// 1B0E5C: using guessed type int dword_1B0E5C;
// 1B0E68: using guessed type int dword_1B0E68;
// 1B0E74: using guessed type int dword_1B0E74;

//----- (00066980) --------------------------------------------------------
int sub_66980()
{
  if ( dword_1B0E74 || !sub_665B0() )
    return dword_1B0E70;
  else
    return 0;
}
// 1B0E70: using guessed type int dword_1B0E70;
// 1B0E74: using guessed type int dword_1B0E74;

//----- (000669B4) --------------------------------------------------------
int __fastcall sub_669B4(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (000669C4) --------------------------------------------------------
int sub_669C4()
{
  return 0;
}

//----- (000669D0) --------------------------------------------------------
int __fastcall sub_669D0(int a1, unsigned int a2)
{
  int v4; // [sp+Ch] [bp-804h] BYREF
  pthread_attr_t v5[56]; // [sp+10h] [bp-800h] BYREF

  v4 = a1;
  if ( a2 )
  {
    if ( !dword_1B0E78 )
    {
      pthread_mutex_init(&stru_1B0E7C, 0);
      dword_1B0E94 = (int)sub_69ED4((int)sub_669B4, 0, 0);
      pthread_mutex_init(&stru_1B0E98, 0);
      dword_1B0EB0 = 1;
      pthread_attr_init(v5);
      pthread_attr_setstacksize(v5, 0x200000u);
      pthread_create((pthread_t *)algn_1B0EB4, v5, (void *(*)(void *))sub_67258, 0);
      dword_1B0E78 = 1;
    }
    if ( pthread_mutex_lock(&stru_1B0E7C) )
    {
      strcpy(v5[0].__size, "fail to lock gpio ctrl mutex\n");
      sub_47AB4(0, v5[0].__size, 0);
      return -1;
    }
    else
    {
      if ( !sub_69F3C((int *)dword_1B0E94, (int)&v4) )
      {
        *(_QWORD *)v5[0].__size = a2 | 0xFFFFFFFF00000000LL;
        sub_69F24((int *)dword_1B0E94, &v4, 4u, v5, 8u);
      }
      pthread_mutex_unlock(&stru_1B0E7C);
      return 0;
    }
  }
  else
  {
    strcpy(v5[0].__size, "bad param\n");
    sub_47AB4(0, v5[0].__size, 0);
    return -1;
  }
}
// 1B0E78: using guessed type int dword_1B0E78;
// 1B0E94: using guessed type int dword_1B0E94;
// 1B0EB0: using guessed type int dword_1B0EB0;
// 1B0EB4: using guessed type _BYTE[4];

//----- (00066B44) --------------------------------------------------------
int __fastcall sub_66B44(int a1, int a2)
{
  int v3; // [sp+4h] [bp-808h] BYREF
  char v4[2052]; // [sp+8h] [bp-804h] BYREF

  v3 = a1;
  if ( a2 )
  {
    if ( pthread_mutex_lock(&stru_1B0E7C) )
    {
      strcpy(v4, "fail to lock gpio ctrl mutex\n");
      sub_47AB4(0, v4, 0);
      return -1;
    }
    else
    {
      if ( sub_69F3C((int *)dword_1B0E94, (int)&v3) == (int *)1 )
      {
        sub_69F5C((int *)dword_1B0E94, (int)&v3);
      }
      else
      {
        strcpy(v4, "callback function not registered before\n");
        sub_47AB4(1, v4, 0);
      }
      pthread_mutex_unlock(&stru_1B0E7C);
      return 0;
    }
  }
  else
  {
    strcpy(v4, "bad param\n");
    sub_47AB4(0, v4, 0);
    return -1;
  }
}
// 1B0E94: using guessed type int dword_1B0E94;

//----- (00066C5C) --------------------------------------------------------
int __fastcall sub_66C5C(int a1)
{
  int v2; // r6
  size_t v3; // r0
  char v5[64]; // [sp+0h] [bp-840h] BYREF
  char s[2048]; // [sp+40h] [bp-800h] BYREF

  if ( pthread_mutex_lock(&stru_1B0E98) )
  {
    strcpy(s, "failed to api lock\n");
    sub_47AB4(0, s, 0);
    return -1;
  }
  else
  {
    snprintf(v5, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(v5, 0) )
    {
      v2 = open64("/sys/class/gpio/export", 1);
      if ( v2 < 0 )
      {
        strcpy(s, "Failed to open export for writing!\n");
        sub_47AB4(0, s, 0);
        pthread_mutex_unlock(&stru_1B0E98);
        return -2;
      }
      else
      {
        v3 = snprintf(v5, 0x40u, "%d", a1);
        if ( write(v2, v5, v3) < 0 )
        {
          snprintf(s, 0x800u, "Failed to export gpio %d!", a1);
          sub_47AB4(0, s, 0);
          close(v2);
          pthread_mutex_unlock(&stru_1B0E98);
          return -3;
        }
        else
        {
          close(v2);
          pthread_mutex_unlock(&stru_1B0E98);
          return 0;
        }
      }
    }
    else
    {
      pthread_mutex_unlock(&stru_1B0E98);
      return 0;
    }
  }
}
// 12184: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (00066FA0) --------------------------------------------------------
int __fastcall sub_66FA0(int a1, int a2)
{
  int v4; // r0
  size_t v5; // r2
  int v6; // r7
  bool v7; // zf
  const char *v8; // r4
  char s[64]; // [sp+8h] [bp-844h] BYREF
  char v11[2052]; // [sp+48h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_1B0E98) )
  {
    strcpy(v11, "failed to api lock\n");
    sub_47AB4(0, v11, 0);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/direction", a1);
    v4 = open64(s, 1);
    v6 = v4;
    if ( v4 < 0 )
    {
      snprintf(v11, 0x800u, "Failed to open gpio %d direction for writing!\n", a1);
      sub_47AB4(0, v11, 0);
      pthread_mutex_unlock(&stru_1B0E98);
      return -2;
    }
    else
    {
      v7 = a2 == 0;
      if ( !a2 )
        v5 = 2;
      v8 = "out";
      if ( v7 )
        v8 = "in";
      else
        v5 = 3;
      if ( write(v4, v8, v5) < 0 )
      {
        snprintf(v11, 0x800u, "Failed to set gpio %d direction %s !\n", a1, v8);
        sub_47AB4(0, v11, 0);
        close(v6);
        pthread_mutex_unlock(&stru_1B0E98);
        return -3;
      }
      else
      {
        close(v6);
        pthread_mutex_unlock(&stru_1B0E98);
        return 0;
      }
    }
  }
}
// 67010: variable 'v5' is possibly undefined
// 12184: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (000670F0) --------------------------------------------------------
int __fastcall sub_670F0(int a1, _BYTE *a2)
{
  int v4; // r4
  int v5; // r0
  int v6; // r5
  int buf; // [sp+Ch] [bp-848h] BYREF
  char s[64]; // [sp+10h] [bp-844h] BYREF
  char v10[2052]; // [sp+50h] [bp-804h] BYREF

  buf = 0;
  v4 = pthread_mutex_lock(&stru_1B0E98);
  if ( v4 )
  {
    v4 = -1;
    strcpy(v10, "failed to api lock\n");
    sub_47AB4(0, v10, 0);
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    v5 = open64(s, 0);
    v6 = v5;
    if ( v5 < 0 )
    {
      snprintf(v10, 0x800u, "Failed to open gpio %d value for reading!\n", a1);
      v4 = -2;
      sub_47AB4(0, v10, 0);
      pthread_mutex_unlock(&stru_1B0E98);
    }
    else if ( read(v5, &buf, 4u) < 0 )
    {
      strcpy(v10, "Failed to read value!\n");
      v4 = -3;
      sub_47AB4(0, v10, 0);
      close(v6);
      pthread_mutex_unlock(&stru_1B0E98);
    }
    else
    {
      close(v6);
      pthread_mutex_unlock(&stru_1B0E98);
      *a2 = strtol((const char *)&buf, 0, 10);
    }
  }
  return v4;
}
// 12184: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (00067258) --------------------------------------------------------
int sub_67258()
{
  _DWORD *v0; // r4
  void (__fastcall *v1)(_DWORD *, _DWORD *, int); // r3
  int v2; // r6
  void (**v3)(void); // r5
  int v4; // r6
  unsigned __int8 v6; // [sp+Fh] [bp-Dh] BYREF
  _DWORD v7[3]; // [sp+10h] [bp-Ch] BYREF

  prctl(15, "gpio", 0);
  while ( dword_1B0EB0 )
  {
    if ( !pthread_mutex_lock(&stru_1B0E7C) )
    {
      v0 = sub_6A044(dword_1B0E94);
      if ( ((int (*)(void))*v0)() )
      {
        while ( 1 )
        {
          v2 = v0[5];
          v3 = (void (**)(void))((int (*)(void))v0[2])();
          v4 = ***(_DWORD ***)(v2 + 16);
          v6 = 0;
          if ( sub_670F0(v4, &v6) )
            break;
          if ( v3[1] != (void (*)(void))v6 )
          {
            (*v3)();
            v1 = (void (__fastcall *)(_DWORD *, _DWORD *, int))v0[1];
            v7[0] = *v3;
            v7[1] = v6;
            v1(v0, v7, 8);
          }
          free(v3);
          if ( !((int (__fastcall *)(_DWORD *))*v0)(v0) )
            goto LABEL_12;
        }
        free(v3);
      }
LABEL_12:
      j_free(v0);
      pthread_mutex_unlock(&stru_1B0E7C);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 1B0E94: using guessed type int dword_1B0E94;
// 1B0EB0: using guessed type int dword_1B0EB0;

//----- (0006739C) --------------------------------------------------------
int __fastcall sub_6739C(int a1, int a2)
{
  int v4; // r0
  int v5; // r5
  char *v6; // r1
  char v8[64]; // [sp+0h] [bp-840h] BYREF
  char v9[2048]; // [sp+40h] [bp-800h] BYREF

  if ( pthread_mutex_lock(&stru_1B0E98) )
  {
    strcpy(v9, "failed to api lock\n");
    sub_47AB4(0, v9, 0);
    return -1;
  }
  else
  {
    snprintf(v8, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    v4 = open64(v8, 1);
    v5 = v4;
    if ( v4 < 0 )
    {
      strcpy(v9, "Failed to open gpio value for writing!\n");
      sub_47AB4(0, v9, 0);
      pthread_mutex_unlock(&stru_1B0E98);
      return -2;
    }
    else
    {
      v6 = "01";
      if ( a2 )
        v6 = "1";
      if ( write(v4, v6, 1u) < 0 )
      {
        strcpy(v9, "Failed to write value!\n");
        sub_47AB4(0, v9, 0);
        close(v5);
        pthread_mutex_unlock(&stru_1B0E98);
        return -3;
      }
      else
      {
        close(v5);
        pthread_mutex_unlock(&stru_1B0E98);
        return 0;
      }
    }
  }
}
// 12184: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (000674E4) --------------------------------------------------------
int __fastcall sub_674E4(unsigned int a1)
{
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( dword_1B0E60 )
  {
    if ( a1 > 1 )
    {
      strcpy(v2, "bad param\n");
      sub_47AB4(0, v2, 0);
      return -3;
    }
    else
    {
      return a1 + 1;
    }
  }
  else
  {
    strcpy(v2, "please init platform first!!\n");
    sub_47AB4(0, v2, 0);
    return -2;
  }
}
// 1B0E60: using guessed type int dword_1B0E60;

//----- (00067584) --------------------------------------------------------
void __fastcall sub_67584(int a1)
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( a1 > 2 )
  {
    strcpy(v1, "bad param\n");
    sub_47AB4(0, v1, 0);
  }
}

//----- (000675D4) --------------------------------------------------------
int __fastcall sub_675D4(int a1, unsigned int a2)
{
  int v2; // r4
  int v4; // r5
  char v5[2052]; // [sp+0h] [bp-804h] BYREF

  if ( a1 > 2 )
  {
    strcpy(v5, "bad param\n");
    sub_47AB4(0, v5, 0);
    return -3;
  }
  else
  {
    v2 = a1 - 1;
    if ( a1 == 1 )
    {
      if ( a2 >= 0x64 )
        a2 = 100;
      v4 = (100 - a2) | (a2 << 16);
      sub_66908(19, v4);
      sub_66908(23, v4);
      return v2;
    }
    else
    {
      snprintf(v5, 0x800u, "pwm type %d not supported\n", a1 - 1);
      sub_47AB4(0, v5, 0);
      return 0;
    }
  }
}

//----- (00067698) --------------------------------------------------------
int __fastcall sub_67698(int a1, int a2)
{
  int v2; // r4
  char v5[2052]; // [sp+0h] [bp-804h] BYREF

  if ( a1 > 2 )
  {
    v2 = -3;
    strcpy(v5, "bad param\n");
    sub_47AB4(0, v5, 0);
  }
  else
  {
    v2 = a1 - 1;
    if ( a1 == 1 )
    {
      sub_6688C(19, (_DWORD *)a2);
      *(_DWORD *)a2 = *(unsigned __int16 *)(a2 + 2);
    }
    else
    {
      return -5;
    }
  }
  return v2;
}

//----- (00067718) --------------------------------------------------------
int __fastcall sub_67718(int a1, _DWORD *a2, int *a3, int *a4, int *a5)
{
  int v5; // r0
  int v6; // r12
  int v7; // r1
  int result; // r0
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  switch ( a1 )
  {
    case 0:
      v5 = 64;
      *a2 = 24;
      v6 = 68;
      v7 = 69;
      goto LABEL_3;
    case 1:
      v5 = 64;
      *a2 = 16;
      v6 = 70;
      v7 = 71;
      goto LABEL_3;
    case 2:
      v5 = 64;
      *a2 = 8;
      v6 = 72;
      v7 = 73;
      goto LABEL_3;
    case 3:
      result = 0;
      *a2 = 0;
      *a3 = 64;
      *a4 = 74;
      *a5 = 75;
      return result;
    case 4:
      v5 = 65;
      *a2 = 24;
      v6 = 76;
      v7 = 77;
      goto LABEL_3;
    case 5:
      v5 = 65;
      *a2 = 16;
      v6 = 78;
      v7 = 79;
      goto LABEL_3;
    case 6:
      v5 = 65;
      *a2 = 8;
      v6 = 80;
      v7 = 81;
      goto LABEL_3;
    case 7:
      result = 0;
      *a2 = 0;
      *a3 = 65;
      *a4 = 82;
      *a5 = 83;
      return result;
    case 8:
      v5 = 66;
      *a2 = 24;
      v6 = 84;
      v7 = 85;
      goto LABEL_3;
    case 9:
      v5 = 66;
      *a2 = 16;
      v6 = 86;
      v7 = 87;
      goto LABEL_3;
    case 10:
      v5 = 66;
      *a2 = 8;
      v6 = 115;
      v7 = 116;
      goto LABEL_3;
    case 11:
      result = 0;
      *a2 = 0;
      *a3 = 66;
      *a4 = 117;
      *a5 = 118;
      return result;
    case 12:
      v5 = 67;
      *a2 = 24;
      v6 = 119;
      v7 = 120;
      goto LABEL_3;
    case 13:
      v5 = 67;
      *a2 = 16;
      v6 = 121;
      v7 = 122;
LABEL_3:
      *a3 = v5;
      result = 0;
      *a4 = v6;
      *a5 = v7;
      break;
    default:
      snprintf(s, 0x800u, "%s: The uart %d is not supported!!!\n", "get_send_address_info", a1);
      sub_47AB4(0, s, 0);
      result = -1;
      break;
  }
  return result;
}
// 6772C: control flows out of bounds to 67730

//----- (0006793C) --------------------------------------------------------
int __fastcall sub_6793C(int a1)
{
  int result; // r0
  unsigned int v2; // [sp+Ch] [bp-808h] BYREF
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v2 = 0;
  switch ( a1 )
  {
    case 0:
      sub_6688C(88, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 1:
      sub_6688C(88, &v2);
      result = v2 & 0x3FF;
      break;
    case 2:
      sub_6688C(89, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 3:
      sub_6688C(89, &v2);
      result = v2 & 0x3FF;
      break;
    case 4:
      sub_6688C(90, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 5:
      sub_6688C(90, &v2);
      result = v2 & 0x3FF;
      break;
    case 6:
      sub_6688C(91, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 7:
      sub_6688C(91, &v2);
      result = v2 & 0x3FF;
      break;
    case 8:
      sub_6688C(92, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 9:
      sub_6688C(92, &v2);
      result = v2 & 0x3FF;
      break;
    case 10:
      sub_6688C(93, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 11:
      sub_6688C(93, &v2);
      result = v2 & 0x3FF;
      break;
    case 12:
      sub_6688C(94, &v2);
      result = HIWORD(v2) & 0x3FF;
      break;
    case 13:
      sub_6688C(94, &v2);
      result = v2 & 0x3FF;
      break;
    default:
      snprintf(s, 0x800u, "%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
      sub_47AB4(0, s, 0);
      result = 0;
      break;
  }
  return result;
}
// 67958: control flows out of bounds to 6795C

//----- (00067B24) --------------------------------------------------------
int __fastcall sub_67B24(int a1)
{
  pthread_mutex_t *v1; // r7
  int v3; // r4
  unsigned int v4; // r3
  int v6; // [sp+Ch] [bp-814h] BYREF
  int v7; // [sp+10h] [bp-810h] BYREF
  int v8; // [sp+14h] [bp-80Ch] BYREF
  unsigned int v9; // [sp+18h] [bp-808h] BYREF
  int v10; // [sp+1Ch] [bp-804h] BYREF
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  v1 = (pthread_mutex_t *)((char *)&unk_1B0EB8 + 24 * a1);
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  pthread_mutex_lock(v1);
  if ( sub_67718(a1, &v10, &v6, &v7, &v8) )
  {
    snprintf(s, 0x800u, "get_send_address_info error, chain_id = %d\n", a1);
  }
  else
  {
    v3 = 21;
    do
    {
      sub_6688C(v6, &v9);
      v4 = (unsigned __int8)(v9 >> v10);
      v9 = v4;
      if ( v4 == 255 )
        return pthread_mutex_unlock(v1);
      printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_tx_fifo", a1);
      sub_66908(v7, v9 | 0x80000000);
      usleep(0xBB8u);
      --v3;
    }
    while ( v3 );
    snprintf(s, 0x800u, "%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_tx_fifo", a1);
  }
  sub_47AB4(0, s, 0);
  return pthread_mutex_unlock(v1);
}

//----- (00067C5C) --------------------------------------------------------
unsigned int __fastcall sub_67C5C(int a1, int a2, unsigned int a3)
{
  unsigned int v5; // r5
  int v8; // r6
  int v9; // r0
  unsigned int v10; // r9
  int v11; // r4
  unsigned int v12; // r3
  int v13; // r4
  int v14; // r3
  unsigned int v15; // r1
  unsigned int v16; // r2
  unsigned int v17; // r2
  unsigned int v18; // [sp+Ch] [bp-808h] BYREF
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v18 = 0;
  switch ( a1 )
  {
    case 0:
      v8 = 96;
      v9 = 95;
      goto LABEL_5;
    case 1:
      v8 = 98;
      v9 = 97;
      goto LABEL_5;
    case 2:
      v8 = 100;
      v9 = 99;
      goto LABEL_5;
    case 3:
      v8 = 102;
      v9 = 101;
      goto LABEL_5;
    case 4:
      v8 = 104;
      v9 = 103;
      goto LABEL_5;
    case 5:
      v8 = 106;
      v9 = 105;
      goto LABEL_5;
    case 6:
      v8 = 108;
      v9 = 107;
      goto LABEL_5;
    case 7:
      v8 = 110;
      v9 = 109;
      goto LABEL_5;
    case 8:
      v8 = 112;
      v9 = 111;
      goto LABEL_5;
    case 9:
      v8 = 114;
      v9 = 113;
      goto LABEL_5;
    case 10:
      v8 = 124;
      v9 = 123;
      goto LABEL_5;
    case 11:
      v8 = 126;
      v9 = 125;
      goto LABEL_5;
    case 12:
      v8 = 128;
      v9 = 127;
      goto LABEL_5;
    case 13:
      v8 = 130;
      v9 = 129;
LABEL_5:
      sub_66908(v9, a3 & 0x3FF | 0x80000000);
      v10 = a3 >> 2;
      if ( a3 >> 2 )
      {
        v11 = a2;
        do
        {
          v11 += 4;
          sub_6688C(v8, &v18);
          v12 = v18;
          *(_BYTE *)(v11 - 1) = v18;
          *(_BYTE *)(v11 - 4) = HIBYTE(v12);
          *(_BYTE *)(v11 - 3) = BYTE2(v12);
          *(_BYTE *)(v11 - 2) = BYTE1(v12);
        }
        while ( a2 + 4 * v10 != v11 );
      }
      v13 = a3 & 3;
      v5 = a3 & 0xFFFFFFFC;
      if ( v13 )
      {
        sub_6688C(v8, &v18);
        v14 = a2 + 4 * v10;
        if ( v13 == 2 )
        {
          v5 += 2;
          v17 = HIWORD(v18);
          *(_BYTE *)(a2 + 4 * v10) = HIBYTE(v18);
          *(_BYTE *)(v14 + 1) = v17;
        }
        else if ( v13 == 3 )
        {
          v5 += 3;
          v15 = HIWORD(v18);
          v16 = v18 >> 8;
          *(_BYTE *)(a2 + 4 * v10) = HIBYTE(v18);
          *(_BYTE *)(v14 + 1) = v15;
          *(_BYTE *)(v14 + 2) = v16;
        }
        else
        {
          ++v5;
          *(_BYTE *)(a2 + 4 * v10) = HIBYTE(v18);
        }
      }
      break;
    default:
      v5 = 0;
      snprintf(s, 0x800u, "%s: The uart%d is not supported!!!\n", "get_read_address_info", a1);
      sub_47AB4(0, s, 0);
      snprintf(s, 0x800u, "get_read_address_info error, chain_id = %d\n", a1);
      sub_47AB4(0, s, 0);
      break;
  }
  return v5;
}
// 67C80: control flows out of bounds to 67C84

//----- (00067EA0) --------------------------------------------------------
int sub_67EA0()
{
  char v1[2056]; // [sp-808h] [bp-808h] BYREF

  if ( dword_1B0E60 )
    return 0;
  strcpy(v1, "please init platform first!!\n");
  sub_47AB4(0, v1, 0);
  return -1;
}
// 1B0E60: using guessed type int dword_1B0E60;

//----- (00068150) --------------------------------------------------------
unsigned int __fastcall sub_68150(int a1, int a2, unsigned int a3)
{
  pthread_mutex_t *v6; // r5
  unsigned int v7; // r0
  unsigned int v9; // r4

  v6 = (pthread_mutex_t *)((char *)&unk_1B1038 + 24 * a1);
  pthread_mutex_lock(v6);
  v7 = sub_6793C((unsigned __int8)a1);
  if ( v7 < a3 )
    a3 = v7;
  if ( a3 )
  {
    v9 = sub_67C5C(a1, a2, a3);
    pthread_mutex_unlock(v6);
    return v9;
  }
  else
  {
    pthread_mutex_unlock(v6);
    return 0;
  }
}

//----- (000681C4) --------------------------------------------------------
int __fastcall sub_681C4(int a1, int a2, int *a3)
{
  pthread_mutex_t *v5; // r4
  char v7[2048]; // [sp+0h] [bp-800h] BYREF

  if ( !a3 )
    return -3;
  v5 = (pthread_mutex_t *)((char *)&unk_1B0EB8 + 24 * a1);
  pthread_mutex_lock(v5);
  if ( a2 )
  {
    snprintf(v7, 0x800u, "unknown set config type = %d\n", a2);
    sub_47AB4(1, v7, 0);
  }
  else
  {
    sub_66908(15, *a3);
  }
  pthread_mutex_unlock(v5);
  return -5;
}

//----- (00068248) --------------------------------------------------------
int __fastcall sub_68248(int a1, int a2, _DWORD *a3, int a4)
{
  _BOOL4 v4; // r3
  int v5; // r6
  pthread_mutex_t *v6; // r4
  char v10[2048]; // [sp+0h] [bp-804h] BYREF

  v4 = a4 != 0;
  if ( a3 )
    v5 = v4;
  else
    v5 = 1;
  if ( v5 )
    return -3;
  v6 = (pthread_mutex_t *)((char *)&unk_1B0EB8 + 24 * a1);
  pthread_mutex_lock(v6);
  if ( !a2 )
  {
    *(_DWORD *)v10 = 0;
    sub_6688C(15, v10);
    *a3 = *(_DWORD *)v10;
    MEMORY[0] = 0;
    __und(0);
  }
  snprintf(v10, 0x800u, "unknown set config type = %d\n", a2);
  sub_47AB4(1, v10, 0);
  pthread_mutex_unlock(v6);
  return -5;
}

//----- (00068300) --------------------------------------------------------
int __fastcall sub_68300(int a1, int a2, _DWORD *a3)
{
  pthread_mutex_t *v5; // r4
  char v7[2048]; // [sp+0h] [bp-800h] BYREF

  if ( !a3 )
    return -3;
  v5 = (pthread_mutex_t *)((char *)&unk_1B0EB8 + 24 * a1);
  pthread_mutex_lock(v5);
  if ( a2 )
  {
    snprintf(v7, 0x800u, "unknown set config type = %d\n", a2);
    sub_47AB4(1, v7, 0);
  }
  else
  {
    sub_66908(15, *a3 << 16);
  }
  pthread_mutex_unlock(v5);
  return -5;
}

//----- (00068388) --------------------------------------------------------
int __fastcall sub_68388(int a1, int a2, int *a3, int a4)
{
  _BOOL4 v4; // r3
  int v5; // r6
  pthread_mutex_t *v6; // r4
  char v10[2048]; // [sp+0h] [bp-804h] BYREF

  v4 = a4 != 0;
  if ( a3 )
    v5 = v4;
  else
    v5 = 1;
  if ( v5 )
    return -3;
  v6 = (pthread_mutex_t *)((char *)&unk_1B0EB8 + 24 * a1);
  pthread_mutex_lock(v6);
  if ( !a2 )
  {
    *(_DWORD *)v10 = 0;
    sub_6688C(15, v10);
    *a3 = HIWORD(*(_DWORD *)v10) & 0x3F;
    MEMORY[0] = 0;
    __und(0);
  }
  snprintf(v10, 0x800u, "unknown set config type = %d\n", a2);
  sub_47AB4(1, v10, 0);
  pthread_mutex_unlock(v6);
  return -5;
}

//----- (00068444) --------------------------------------------------------
int __fastcall sub_68444(int a1)
{
  pthread_mutex_t *v2; // r4
  size_t v3; // r0
  unsigned int v4; // r6
  void *v5; // r0
  void *v6; // r7
  unsigned int v7; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v2 = (pthread_mutex_t *)((char *)&unk_1B1038 + 24 * a1);
  pthread_mutex_lock(v2);
  v3 = sub_6793C((unsigned __int8)a1);
  v4 = v3;
  if ( !v3 )
    return pthread_mutex_unlock(v2);
  v5 = malloc(v3);
  v6 = v5;
  if ( v5 )
  {
    v7 = sub_67C5C(a1, (int)v5, v4);
    if ( v4 != v7 )
    {
      snprintf(s, 0x800u, "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n", "clear_uart_rx_fifo", a1, v4, v7);
      sub_47AB4(0, s, 0);
    }
    free(v6);
    usleep(0x2710u);
    return pthread_mutex_unlock(v2);
  }
  snprintf(s, 0x800u, "%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
  sub_47AB4(0, s, 0);
  usleep((__useconds_t)"d asic, will power off hash board %d\n");
  return pthread_mutex_unlock(v2);
}

//----- (00068548) --------------------------------------------------------
int __fastcall sub_68548(int a1)
{
  sub_68444(a1);
  usleep(0x2710u);
  sub_67B24(a1);
  return 0;
}

//----- (0006856C) --------------------------------------------------------
int __fastcall sub_6856C(int a1)
{
  sub_67B24(a1);
  return 0;
}

//----- (0006857C) --------------------------------------------------------
int __fastcall sub_6857C(int a1)
{
  sub_68444(a1);
  return 0;
}

//----- (0006858C) --------------------------------------------------------
int __fastcall sub_6858C(int a1)
{
  unsigned __int8 v1; // r5
  pthread_mutex_t *v2; // r4
  int v3; // r5

  v1 = a1;
  v2 = (pthread_mutex_t *)((char *)&unk_1B1038 + 24 * a1);
  pthread_mutex_lock(v2);
  v3 = sub_6793C(v1);
  pthread_mutex_unlock(v2);
  return v3;
}

//----- (000685C8) --------------------------------------------------------
int sub_685C8()
{
  if ( !dword_1B11B8 )
  {
    sub_66C5C(907);
    sub_66FA0(907, 1);
    dword_1B11B8 = 1;
  }
  return sub_6739C(907, 0);
}
// 1B11B8: using guessed type int dword_1B11B8;

//----- (0006860C) --------------------------------------------------------
int sub_6860C()
{
  int result; // r0

  if ( dword_1B11B8 )
    return sub_6739C(907, 1);
  return result;
}
// 1B11B8: using guessed type int dword_1B11B8;

//----- (00068630) --------------------------------------------------------
int __fastcall sub_68630(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00068640) --------------------------------------------------------
int *__fastcall sub_68640(int *result, int *a2)
{
  int *v3; // [sp+4h] [bp-4h] BYREF

  v3 = result;
  if ( a2 )
  {
    result = sub_69F3C(a2, (int)&v3);
    if ( result == (int *)1 )
      return (int *)sub_69F5C(a2, (int)&v3);
  }
  return result;
}

//----- (00068684) --------------------------------------------------------
int sub_68684()
{
  _DWORD *v0; // r5
  int v1; // r2
  int v2; // r0
  int v3; // r3
  int *v4; // r0
  int v5; // r3
  int *v6; // r4
  _DWORD v8[3]; // [sp+Ch] [bp-Ch] BYREF

  prctl(15, "ui", 0);
  while ( dword_1B11BC )
  {
    if ( !pthread_mutex_lock(&stru_1B11C0) )
    {
      v0 = sub_6A044(dword_1B11D8);
      if ( ((int (*)(void))*v0)() )
      {
        do
        {
          v4 = (int *)((int (*)(void))v0[2])();
          v5 = v4[1];
          v6 = v4;
          if ( v5 )
          {
            v1 = *v4;
            v2 = v4[2];
          }
          else
          {
            sub_6739C(***(_DWORD ***)(v0[5] + 16), *((unsigned __int8 *)v4 + 8));
            v5 = *v6;
            v2 = v6[2] != 1;
            v1 = *v6;
            v6[2] = v2;
          }
          v3 = v5 - 200;
          v8[0] = v1;
          v6[1] = v3;
          v8[1] = v3;
          v8[2] = v2;
          ((void (__fastcall *)(_DWORD *, _DWORD *))v0[1])(v0, v8);
          free(v6);
        }
        while ( ((int (__fastcall *)(_DWORD *))*v0)(v0) );
      }
      j_free(v0);
      pthread_mutex_unlock(&stru_1B11C0);
    }
    usleep((__useconds_t)&loc_30D40);
  }
  return 0;
}
// 1B11BC: using guessed type int dword_1B11BC;
// 1B11D8: using guessed type int dword_1B11D8;

//----- (000687C8) --------------------------------------------------------
int __fastcall sub_687C8(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( sub_69B8C() == a1 )
    return 256;
  if ( sub_69BA8() == a1 )
    return 257;
  snprintf(v3, 0x800u, "unmaped port = %d\n", a1);
  sub_47AB4(0, v3, 0);
  return 258;
}

//----- (00068828) --------------------------------------------------------
int sub_68828()
{
  if ( sub_69B54() >= 0 )
    return sub_69B54();
  else
    return 0;
}

//----- (00068848) --------------------------------------------------------
int __fastcall sub_68848(unsigned int a1)
{
  if ( a1 == 2 )
  {
    if ( sub_69B70() < 0 )
      return 0;
    return sub_69B70();
  }
  else if ( a1 <= 2 )
  {
    if ( a1 != 1 )
      return 0;
    return sub_68828();
  }
  else
  {
    if ( a1 != 256 )
    {
      if ( a1 == 257 && sub_69BA8() >= 0 )
        return sub_69BA8();
      return 0;
    }
    if ( sub_69B8C() < 0 )
      return 0;
    return sub_69B8C();
  }
}

//----- (000688C0) --------------------------------------------------------
int sub_688C0()
{
  int result; // r0
  pthread_attr_t attr; // [sp+4h] [bp-28h] BYREF

  pthread_mutex_init(&stru_1B11C0, 0);
  off_1B11DC = 0;
  dword_1B11E0 = 0;
  dword_1B11E4 = 0;
  dword_1B11E8 = 0;
  dword_1B11EC = 0;
  dword_1B11D8 = (int)sub_69ED4((int)sub_68630, 0, 0);
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  result = pthread_create(&dword_1B11F0, &attr, (void *(*)(void *))sub_68684, 0);
  dword_1B11BC = 1;
  return result;
}
// 1B11BC: using guessed type int dword_1B11BC;
// 1B11D8: using guessed type int dword_1B11D8;
// 1B11DC: using guessed type _UNKNOWN *off_1B11DC;
// 1B11E0: using guessed type int dword_1B11E0;
// 1B11E4: using guessed type int dword_1B11E4;
// 1B11E8: using guessed type int dword_1B11E8;
// 1B11EC: using guessed type int dword_1B11EC;
// 1B11F0: using guessed type pthread_t;

//----- (00068948) --------------------------------------------------------
void __fastcall sub_68948(int a1)
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  snprintf(v1, 0x800u, "gpio port %d is not a supported key\n", a1);
  sub_47AB4(1, v1, 0);
}

//----- (00068988) --------------------------------------------------------
void __fastcall sub_68988(int a1, int a2)
{
  int v4; // r0
  pthread_t *v5; // r4
  int v6; // r5
  void (__fastcall *v7)(int, int); // r3
  pthread_t v8; // t1
  int v9; // r1

  v4 = sub_687C8(a1);
  if ( v4 == 258 )
  {
    sub_68948(a1);
  }
  else
  {
    v5 = (pthread_t *)&off_1B11DC;
    v6 = v4;
    do
    {
      v8 = *v5++;
      v7 = (void (__fastcall *)(int, int))v8;
      if ( v8 )
      {
        v9 = a2;
        if ( a2 )
          v9 = 1;
        v7(v6, v9);
      }
    }
    while ( v5 != &dword_1B11F0 );
  }
}
// 1B11DC: using guessed type _UNKNOWN *off_1B11DC;
// 1B11F0: using guessed type pthread_t dword_1B11F0;

//----- (000689E8) --------------------------------------------------------
int __fastcall sub_689E8(unsigned int a1, int a2)
{
  int *v3; // r6
  int *v4; // r4
  int v5; // r5
  int *v7; // [sp+Ch] [bp-808h] BYREF
  _DWORD v8[513]; // [sp+10h] [bp-804h] BYREF

  v3 = (int *)sub_68848(a1);
  if ( v3 )
  {
    if ( pthread_mutex_lock(&stru_1B11C0) )
    {
      v5 = -1;
      strcpy((char *)v8, "failed to api lock\n");
      sub_47AB4(0, (const char *)v8, 0);
    }
    else
    {
      v4 = (int *)dword_1B11D8;
      if ( a2 == 1 )
      {
        sub_68640(v3, (int *)dword_1B11D8);
        v5 = sub_6739C((int)v3, 0);
      }
      else if ( a2 == 2 )
      {
        v7 = v3;
        if ( dword_1B11D8 && !sub_69F3C((int *)dword_1B11D8, (int)&v7) )
        {
          v8[1] = 0;
          v5 = -1;
          v8[0] = 200;
          v8[2] = 1;
          sub_69F24(v4, &v7, 4u, v8, 0xCu);
        }
        else
        {
          v5 = -1;
        }
      }
      else
      {
        sub_68640(v3, (int *)dword_1B11D8);
        v5 = sub_6739C((int)v3, 1);
      }
      pthread_mutex_unlock(&stru_1B11C0);
    }
  }
  else
  {
    v5 = -1;
    strcpy((char *)v8, "unsuported gpio port\n");
    sub_47AB4(0, (const char *)v8, 0);
  }
  return v5;
}
// 1B11D8: using guessed type int dword_1B11D8;

//----- (00068B54) --------------------------------------------------------
int sub_68B54()
{
  int v0; // r0
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0

  if ( !dword_1B11F4 )
  {
    v0 = sub_68828();
    sub_66C5C(v0);
    v1 = sub_68828();
    sub_66FA0(v1, 1);
    v2 = sub_68848(2u);
    sub_66C5C(v2);
    v3 = sub_68848(2u);
    sub_66FA0(v3, 1);
    v4 = sub_68848(0x100u);
    sub_66C5C(v4);
    v5 = sub_68848(0x100u);
    sub_66FA0(v5, 0);
    v6 = sub_68848(0x101u);
    sub_66C5C(v6);
    v7 = sub_68848(0x101u);
    sub_66FA0(v7, 0);
    dword_1B11F4 = 1;
  }
  return 0;
}
// 1B11F4: using guessed type int dword_1B11F4;

//----- (00068BE8) --------------------------------------------------------
int sub_68BE8()
{
  return sub_689E8(1u, 0);
}

//----- (00068BF4) --------------------------------------------------------
int sub_68BF4()
{
  return sub_689E8(1u, 1);
}

//----- (00068C00) --------------------------------------------------------
int sub_68C00()
{
  if ( !dword_1B11BC )
    sub_688C0();
  return sub_689E8(1u, 2);
}
// 1B11BC: using guessed type int dword_1B11BC;

//----- (00068C38) --------------------------------------------------------
int sub_68C38()
{
  return sub_689E8(2u, 0);
}

//----- (00068C44) --------------------------------------------------------
int sub_68C44()
{
  return sub_689E8(2u, 1);
}

//----- (00068C50) --------------------------------------------------------
int sub_68C50()
{
  if ( !dword_1B11BC )
    sub_688C0();
  return sub_689E8(2u, 2);
}
// 1B11BC: using guessed type int dword_1B11BC;

//----- (00068C88) --------------------------------------------------------
int sub_68C88()
{
  return sub_689E8(0x10u, 0);
}

//----- (00068C94) --------------------------------------------------------
int sub_68C94()
{
  return sub_689E8(0x10u, 1);
}

//----- (00068CA0) --------------------------------------------------------
int sub_68CA0()
{
  if ( !dword_1B11BC )
    sub_688C0();
  return sub_689E8(0x10u, 2);
}
// 1B11BC: using guessed type int dword_1B11BC;

//----- (00068CD8) --------------------------------------------------------
int __fastcall sub_68CD8(int a1)
{
  int v2; // r5
  _DWORD *v3; // r2
  int v4; // r3
  int v7; // r0
  int v8; // r0
  char v9[2048]; // [sp+0h] [bp-800h] BYREF

  v2 = pthread_mutex_lock(&stru_1B11C0);
  if ( v2 )
  {
    v2 = -1;
    strcpy(v9, "failed to api lock\n");
    sub_47AB4(0, v9, 0);
  }
  else
  {
    if ( !dword_1B11F8 )
    {
      v7 = sub_68848(0x100u);
      sub_669D0(v7, (unsigned int)sub_68988);
      v8 = sub_68848(0x101u);
      sub_669D0(v8, (unsigned int)sub_68988);
      dword_1B11F8 = 1;
    }
    v3 = &off_1B11DC;
    v4 = 0;
    while ( *v3++ )
    {
      if ( ++v4 == 5 )
      {
        v2 = -2;
        strcpy(v9, "no more listener available\n");
        sub_47AB4(0, v9, 0);
        goto LABEL_8;
      }
    }
    dword_1B11BC[v4 + 8] = a1;
LABEL_8:
    pthread_mutex_unlock(&stru_1B11C0);
  }
  return v2;
}
// 1B11BC: using guessed type int dword_1B11BC[];
// 1B11DC: using guessed type _UNKNOWN *off_1B11DC;
// 1B11F8: using guessed type int dword_1B11F8;

//----- (00068DE8) --------------------------------------------------------
int __fastcall sub_68DE8(int a1)
{
  int v2; // r0
  int *v3; // r3
  int v4; // t1
  char v6[2052]; // [sp+0h] [bp-804h] BYREF

  v2 = pthread_mutex_lock(&stru_1B11C0);
  if ( v2 )
  {
    strcpy(v6, "failed to api lock\n");
    sub_47AB4(0, v6, 0);
    return -1;
  }
  else
  {
    v3 = (int *)&off_1B11DC;
    while ( 1 )
    {
      v4 = *v3++;
      if ( v4 == a1 )
        break;
      if ( ++v2 == 5 )
      {
        strcpy(v6, "listener not registered before\n");
        sub_47AB4(1, v6, 0);
        goto LABEL_7;
      }
    }
    dword_1B11BC[v2 + 8] = 0;
LABEL_7:
    pthread_mutex_unlock(&stru_1B11C0);
    return 0;
  }
}
// 1B11BC: using guessed type int dword_1B11BC[];
// 1B11DC: using guessed type _UNKNOWN *off_1B11DC;

//----- (000690A0) --------------------------------------------------------
void sub_690A0()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_1B11C0) )
  {
    strcpy(v0, "failed to api lock\n");
    sub_47AB4(0, v0, 0);
  }
  else
  {
    if ( dword_9F454 > 0 )
      sub_69348(dword_9F454);
    pthread_mutex_unlock(&stru_1B11C0);
  }
}
// 9F454: using guessed type int dword_9F454;

//----- (00069128) --------------------------------------------------------
int __fastcall sub_69128(int a1)
{
  int result; // r0
  char v2[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_1B11FC )
    return 0;
  if ( a1 )
  {
    result = open64(a1, 2050);
    dword_1B1200 = result;
    if ( result < 0 )
    {
      strcpy(v2, "open lcd failed!!!\n");
      sub_47AB4(0, v2, 0);
      return -1;
    }
    else
    {
      dword_1B11FC = 1;
    }
  }
  else
  {
    strcpy(v2, "bad param\n");
    sub_47AB4(0, v2, 0);
    return -3;
  }
  return result;
}
// 12184: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 1B11FC: using guessed type int dword_1B11FC;
// 1B1200: using guessed type int dword_1B1200;

//----- (000691EC) --------------------------------------------------------
int __fastcall sub_691EC(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // r7
  unsigned int v5; // r4
  bool v6; // cc
  int v7; // r5
  int v9; // r11
  unsigned __int8 v10; // r5
  size_t v11; // r6
  const void *v12; // r1
  char v15[2052]; // [sp+0h] [bp-804h] BYREF

  v4 = a2;
  if ( !dword_1B11FC )
    return -2;
  v5 = a4;
  if ( dword_1B1200 != a1 )
    goto LABEL_18;
  v6 = a4 > 0x40;
  if ( a4 <= 0x40 )
    v6 = (unsigned __int8)a2 > 3u;
  v7 = v6;
  if ( v6 )
  {
LABEL_18:
    strcpy(v15, "bad param\n");
    sub_47AB4(1, v15, 0);
    return -3;
  }
  else
  {
    v9 = pthread_mutex_lock(&stru_1B1204);
    if ( v9 )
    {
      strcpy(v15, "failed to lcd lock\n");
      sub_47AB4(v7, v15, v7);
      return -4;
    }
    else
    {
      do
      {
        v10 = v4 + 1;
        if ( v5 >= 0x10 )
          v11 = 16;
        else
          v11 = v5;
        v12 = (const void *)(a3 + v9);
        v9 += v11;
        memcpy((char *)&unk_1B121C + 16 * v4, v12, v11);
        v5 -= v11;
        v4 = (char)v10;
      }
      while ( v10 <= 3u && v5 != 0 );
      write(dword_1B1200, &unk_1B121C, 0x40u);
      pthread_mutex_unlock(&stru_1B1204);
      return 0;
    }
  }
}
// 1B11FC: using guessed type int dword_1B11FC;
// 1B1200: using guessed type int dword_1B1200;

//----- (00069340) --------------------------------------------------------
int sub_69340()
{
  return 0;
}

//----- (00069348) --------------------------------------------------------
int __fastcall sub_69348(int a1)
{
  int v1; // r6
  int v2; // r1
  char v4[2048]; // [sp+8h] [bp-800h] BYREF

  if ( !dword_1B11FC )
    return -2;
  if ( dword_1B1200 == a1 )
  {
    if ( pthread_mutex_lock(&stru_1B1204) )
    {
      strcpy(v4, "failed to lcd lock\n");
      sub_47AB4(0, v4, 0);
      return -4;
    }
    else
    {
      memset(&unk_1B121C, 0x20, 0x40u);
      v1 = dword_1B1200;
      lseek64(dword_1B1200, v2, 0, 0, 0);
      write(v1, &unk_1B121C, 0x40u);
      pthread_mutex_unlock(&stru_1B1204);
      return 0;
    }
  }
  else
  {
    strcpy(v4, "bad param\n");
    sub_47AB4(1, v4, 0);
    return -3;
  }
}
// 693A8: variable 'v2' is possibly undefined
// 12118: using guessed type int __fastcall lseek64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1B11FC: using guessed type int dword_1B11FC;
// 1B1200: using guessed type int dword_1B1200;

//----- (00069448) --------------------------------------------------------
int __fastcall sub_69448(int a1)
{
  int result; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( !dword_1B11FC )
    return 0;
  result = close(a1);
  if ( result )
  {
    strcpy(v2, "lcd close failed!!!\n");
    sub_47AB4(0, v2, 0);
    result = -1;
  }
  dword_1B11FC = 0;
  return result;
}
// 1B11FC: using guessed type int dword_1B11FC;

//----- (000694C4) --------------------------------------------------------
int sub_694C4()
{
  double *v0; // r0
  unsigned int v1; // r4
  void *v2; // r0
  _DWORD *v3; // r0
  _DWORD *v4; // r6
  _DWORD *i; // r5
  _DWORD *v6; // r0
  _DWORD *v7; // r11
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  _DWORD *v12; // r0
  bool v13; // cc
  unsigned int v14; // r1
  _BOOL4 v15; // r3
  _DWORD *v16; // r0
  _DWORD *v17; // r5
  _DWORD *v18; // r9
  unsigned int v19; // r4
  _DWORD *v20; // r0
  bool v21; // cc
  unsigned int v22; // r1
  _DWORD *v23; // r0
  _DWORD *v24; // r7
  int v25; // r0
  int v26; // r0
  int v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r0
  int v32; // r3
  int v33; // r3
  int v35; // r3
  int v36; // r3
  int v37; // r3
  int v38; // r3
  int v39; // r3
  int v40; // r3
  int v41; // r3
  int v42; // r3
  int v43; // r3
  int v44; // r3
  int v45; // r3
  int v46; // r3
  int v47; // r3
  int v48; // r3
  int v49; // r3
  int v50; // r3
  double *v51; // [sp+8h] [bp-90Ch]
  unsigned int v52; // [sp+Ch] [bp-908h]
  char v53[252]; // [sp+14h] [bp-900h] BYREF
  char s[2052]; // [sp+110h] [bp-804h] BYREF

  memset(dword_1B125C, 255, sizeof(dword_1B125C));
  memset(&unk_1B135C, 255, 0x48u);
  v0 = sub_6D110((int)aFanMax6000Id0N, 0, v53);
  v51 = v0;
  if ( !v0 || (v1 = *(_DWORD *)v0) != 0 )
  {
    snprintf(s, 0x800u, "%s,%d bad json format\n", "platform/7007/src/hal_conf.c", 43);
    sub_47AB4(0, s, 0);
    return -1;
  }
  else
  {
    v2 = sub_6B6E8(v0, 0);
    free(v2);
    v3 = (_DWORD *)sub_6DFCC(v51, "chain");
    v4 = v3;
    if ( v3 && *v3 == 1 )
    {
      for ( i = dword_1B125C; ; *(i - 1) = sub_6E430(v11) )
      {
        i += 4;
        v12 = sub_6E1A8(v4);
        v13 = v1 > 0x10;
        if ( v1 != 16 )
          v13 = (unsigned int)v12 > v1;
        v14 = v1;
        v15 = v13;
        ++v1;
        if ( !v13 )
          break;
        v6 = sub_6E1C4(v4, v14);
        v7 = v6;
        if ( !v6 || *v6 )
        {
          snprintf(s, 0x800u, "%s,%d bad object in chain\n", "platform/7007/src/hal_conf.c", 63);
          sub_47AB4(0, s, 0);
          v35 = *((_DWORD *)v51 + 1);
          if ( v35 != -1 )
          {
            v36 = v35 - 1;
            *((_DWORD *)v51 + 1) = v36;
            if ( !v36 )
              sub_6E5DC((void **)v51);
          }
          return -3;
        }
        v8 = sub_6DFCC(v6, "id");
        *(i - 4) = sub_6E430(v8);
        v9 = sub_6DFCC(v7, "uart");
        *(i - 3) = sub_6E430(v9);
        v10 = sub_6DFCC(v7, "plug");
        *(i - 2) = sub_6E430(v10);
        v11 = sub_6DFCC(v7, "reset");
      }
      v52 = v15;
      v16 = (_DWORD *)sub_6DFCC(v51, "fan");
      v17 = v16;
      if ( v16 && *v16 == 1 )
      {
        v18 = &unk_1B135C;
        v19 = v52;
        while ( 1 )
        {
          v18 += 3;
          v20 = sub_6E1A8(v17);
          v21 = v19 > 6;
          if ( v19 != 6 )
            v21 = (unsigned int)v20 > v19;
          v22 = v19++;
          if ( !v21 )
          {
            v28 = (_DWORD *)sub_6DFCC(v51, "red");
            if ( v28 && *v28 == 3 )
            {
              dword_1B13A4 = sub_6E430((int)v28);
              v29 = (_DWORD *)sub_6DFCC(v51, "green");
              if ( v29 && *v29 == 3 )
              {
                dword_1B13A8 = sub_6E430((int)v29);
                v30 = (_DWORD *)sub_6DFCC(v51, "reset");
                if ( v30 && *v30 == 3 )
                {
                  dword_1B13AC = sub_6E430((int)v30);
                  v31 = (_DWORD *)sub_6DFCC(v51, "ipreport");
                  if ( v31 && *v31 == 3 )
                  {
                    dword_1B13B0 = sub_6E430((int)v31);
                    v32 = *((_DWORD *)v51 + 1);
                    if ( v32 != -1 )
                    {
                      v33 = v32 - 1;
                      *((_DWORD *)v51 + 1) = v33;
                      if ( !v33 )
                        sub_6E5DC((void **)v51);
                    }
                    dword_1B13B4 = 1;
                    return 0;
                  }
                  else
                  {
                    snprintf(s, 0x800u, "%s,%d bad ipreport\n", "platform/7007/src/hal_conf.c", 128);
                    sub_47AB4(0, s, 0);
                    v47 = *((_DWORD *)v51 + 1);
                    if ( v47 != -1 )
                    {
                      v48 = v47 - 1;
                      *((_DWORD *)v51 + 1) = v48;
                      if ( !v48 )
                        sub_6E5DC((void **)v51);
                    }
                    return -9;
                  }
                }
                else
                {
                  snprintf(s, 0x800u, "%s,%d bad reset\n", "platform/7007/src/hal_conf.c", 120);
                  sub_47AB4(0, s, 0);
                  v45 = *((_DWORD *)v51 + 1);
                  if ( v45 != -1 )
                  {
                    v46 = v45 - 1;
                    *((_DWORD *)v51 + 1) = v46;
                    if ( !v46 )
                      sub_6E5DC((void **)v51);
                  }
                  return -8;
                }
              }
              else
              {
                snprintf(s, 0x800u, "%s,%d bad green\n", "platform/7007/src/hal_conf.c", 112);
                sub_47AB4(0, s, 0);
                v43 = *((_DWORD *)v51 + 1);
                if ( v43 != -1 )
                {
                  v44 = v43 - 1;
                  *((_DWORD *)v51 + 1) = v44;
                  if ( !v44 )
                    sub_6E5DC((void **)v51);
                }
                return -7;
              }
            }
            else
            {
              snprintf(s, 0x800u, "%s,%d bad red\n", "platform/7007/src/hal_conf.c", 104);
              sub_47AB4(0, s, 0);
              v41 = *((_DWORD *)v51 + 1);
              if ( v41 != -1 )
              {
                v42 = v41 - 1;
                *((_DWORD *)v51 + 1) = v42;
                if ( !v42 )
                  sub_6E5DC((void **)v51);
              }
              return -6;
            }
          }
          v23 = sub_6E1C4(v17, v22);
          v24 = v23;
          if ( !v23 || *v23 )
            break;
          v25 = sub_6DFCC(v23, "id");
          *(v18 - 3) = sub_6E430(v25);
          v26 = sub_6DFCC(v24, "name");
          *(v18 - 2) = sub_6E430(v26);
          v27 = sub_6DFCC(v24, "max");
          *(v18 - 1) = sub_6E430(v27);
        }
        snprintf(s, 0x800u, "%s,%d bad object in fan\n", "platform/7007/src/hal_conf.c", 89);
        sub_47AB4(0, s, 0);
        v37 = *((_DWORD *)v51 + 1);
        if ( v37 != -1 )
        {
          v38 = v37 - 1;
          *((_DWORD *)v51 + 1) = v38;
          if ( !v38 )
            sub_6E5DC((void **)v51);
        }
        return -5;
      }
      else
      {
        snprintf(s, 0x800u, "%s,%d bad fan format\n", "platform/7007/src/hal_conf.c", 80);
        sub_47AB4(0, s, 0);
        v49 = *((_DWORD *)v51 + 1);
        if ( v49 != -1 )
        {
          v50 = v49 - 1;
          *((_DWORD *)v51 + 1) = v50;
          if ( !v50 )
            sub_6E5DC((void **)v51);
        }
        return -4;
      }
    }
    else
    {
      snprintf(s, 0x800u, "%s,%d bad chain format\n", "platform/7007/src/hal_conf.c", 53);
      sub_47AB4(0, s, 0);
      v39 = *((_DWORD *)v51 + 1);
      if ( v39 != -1 )
      {
        v40 = v39 - 1;
        *((_DWORD *)v51 + 1) = v40;
        if ( !v40 )
          sub_6E5DC((void **)v51);
      }
      return -2;
    }
  }
}
// 1B125C: using guessed type _DWORD dword_1B125C[64];
// 1B13A4: using guessed type int dword_1B13A4;
// 1B13A8: using guessed type int dword_1B13A8;
// 1B13AC: using guessed type int dword_1B13AC;
// 1B13B0: using guessed type int dword_1B13B0;
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069B54) --------------------------------------------------------
int sub_69B54()
{
  if ( dword_1B13B4 )
    return dword_1B13A4;
  else
    return -1;
}
// 1B13A4: using guessed type int dword_1B13A4;
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069B70) --------------------------------------------------------
int sub_69B70()
{
  if ( dword_1B13B4 )
    return dword_1B13A8;
  else
    return -1;
}
// 1B13A8: using guessed type int dword_1B13A8;
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069B8C) --------------------------------------------------------
int sub_69B8C()
{
  if ( dword_1B13B4 )
    return dword_1B13AC;
  else
    return -1;
}
// 1B13AC: using guessed type int dword_1B13AC;
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069BA8) --------------------------------------------------------
int sub_69BA8()
{
  if ( dword_1B13B4 )
    return dword_1B13B0;
  else
    return -1;
}
// 1B13B0: using guessed type int dword_1B13B0;
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069BC4) --------------------------------------------------------
int __fastcall sub_69BC4(int a1)
{
  int v1; // r3
  int v2; // r2
  int v3; // r12

  if ( !dword_1B13B4 )
    return -1;
  v1 = 0;
  do
  {
    v2 = dword_1B125C[4 * v1];
    v3 = 4 * v1++;
    if ( v2 == a1 )
      return dword_1B125C[v3 + 1];
  }
  while ( v1 != 16 );
  return -2;
}
// 1B125C: using guessed type _DWORD dword_1B125C[64];
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069C18) --------------------------------------------------------
int __fastcall sub_69C18(int a1)
{
  int v1; // r3
  int v2; // r2
  int v3; // r12

  if ( !dword_1B13B4 )
    return -1;
  v1 = 0;
  do
  {
    v2 = dword_1B125C[4 * v1];
    v3 = 4 * v1++;
    if ( v2 == a1 )
      return dword_1B125C[v3 + 2];
  }
  while ( v1 != 16 );
  return -2;
}
// 1B125C: using guessed type _DWORD dword_1B125C[64];
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069C6C) --------------------------------------------------------
int __fastcall sub_69C6C(int a1)
{
  int v1; // r3
  int v2; // r2
  int v3; // r12

  if ( !dword_1B13B4 )
    return -1;
  v1 = 0;
  do
  {
    v2 = dword_1B125C[4 * v1];
    v3 = 4 * v1++;
    if ( v2 == a1 )
      return dword_1B125C[v3 + 3];
  }
  while ( v1 != 16 );
  return -2;
}
// 1B125C: using guessed type _DWORD dword_1B125C[64];
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069CC0) --------------------------------------------------------
int sub_69CC0()
{
  int result; // r0
  _DWORD *v1; // r3

  if ( !dword_1B13B4 )
    return -1;
  for ( result = 0; result != 16; ++result )
  {
    if ( dword_1B125C[4 * result] == 255 )
    {
      v1 = &dword_1B125C[4 * result];
      if ( v1[1] == 255 && v1[2] == 255 && v1[3] == 255 )
        break;
    }
  }
  return result;
}
// 1B125C: using guessed type _DWORD dword_1B125C[64];
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069D2C) --------------------------------------------------------
int __fastcall sub_69D2C(int a1)
{
  int *v1; // r2
  int v2; // r3
  int v3; // r1

  if ( !dword_1B13B4 )
    return -1;
  v1 = (int *)&unk_1B135C;
  v2 = 0;
  while ( 1 )
  {
    v3 = *v1;
    v1 += 3;
    if ( v3 == a1 )
      break;
    if ( ++v2 == 6 )
      return -2;
  }
  return dword_1B125C[3 * v2 + 65];
}
// 1B125C: using guessed type _DWORD dword_1B125C[64];
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069D84) --------------------------------------------------------
int __fastcall sub_69D84(int a1)
{
  int *v1; // r2
  int v2; // r3
  int v3; // r1

  if ( !dword_1B13B4 )
    return -1;
  v1 = (int *)&unk_1B135C;
  v2 = 0;
  while ( 1 )
  {
    v3 = *v1;
    v1 += 3;
    if ( v3 == a1 )
      break;
    if ( ++v2 == 6 )
      return -1;
  }
  return dword_1B125C[3 * v2 + 66];
}
// 1B125C: using guessed type _DWORD dword_1B125C[64];
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069DD4) --------------------------------------------------------
int sub_69DD4()
{
  int *v0; // r3
  int result; // r0
  int v2; // r1

  if ( !dword_1B13B4 )
    return -1;
  v0 = (int *)&unk_1B135C;
  result = 0;
  do
  {
    v2 = *v0;
    v0 += 3;
    if ( v2 != -1 )
      ++result;
  }
  while ( v0 != &dword_1B13A4 );
  return result;
}
// 1B13A4: using guessed type int dword_1B13A4;
// 1B13B4: using guessed type int dword_1B13B4;

//----- (00069E18) --------------------------------------------------------
int __fastcall sub_69E18(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_6AC04(a1, &v2);
  return v2;
}

//----- (00069E34) --------------------------------------------------------
void *__fastcall sub_69E34(int a1, const void *a2, size_t a3)
{
  int v4; // r5
  int v7; // r0
  int v9; // [sp+4h] [bp-8h] BYREF

  v4 = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(*(_DWORD *)v4 + 32) )
  {
    sub_6AC04(v7, &v9);
    (*(void (__fastcall **)(int))(*(_DWORD *)v4 + 32))(v9);
    v7 = *(_DWORD *)(a1 + 20);
  }
  return sub_6AC44(*(void ***)(v7 + 20), a2, a3);
}

//----- (00069E94) --------------------------------------------------------
int *__fastcall sub_69E94(int a1)
{
  int v1; // r1
  int *v3; // r0
  int *result; // r0

  v1 = *(_DWORD *)(a1 + 20);
  v3 = **(int ***)(a1 + 12);
  if ( v1 )
    result = sub_6AAFC(v3, v1);
  else
    result = sub_6AAA8((int)v3, (_DWORD *)*v3);
  *(_DWORD *)(a1 + 20) = result;
  if ( result )
    return (int *)result[5];
  return result;
}

//----- (00069ED4) --------------------------------------------------------
_DWORD *__fastcall sub_69ED4(int a1, int a2, int a3)
{
  _DWORD *v6; // r4
  _DWORD *v7; // r0

  v6 = malloc(4u);
  if ( v6 && (v7 = sub_6A3B0(a1, a2, a3), (*v6 = v7) != 0) )
    return v6;
  else
    return 0;
}

//----- (00069F24) --------------------------------------------------------
int __fastcall sub_69F24(int *a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  if ( a1 )
    return sub_6A488(*a1, a2, a3, a4, a5);
  else
    return 501;
}

//----- (00069F3C) --------------------------------------------------------
int *__fastcall sub_69F3C(int *result, int a2)
{
  if ( result )
    return (int *)(sub_6A408(*result, a2) != 0);
  return result;
}

//----- (00069F5C) --------------------------------------------------------
int __fastcall sub_69F5C(int *a1, int a2)
{
  int *v2; // r0
  int *v3; // r4
  void *ptr[3]; // [sp+4h] [bp-Ch] BYREF

  if ( !a1 )
    return 501;
  v2 = sub_6A6EC(*a1, a2);
  v3 = v2;
  if ( v2 )
  {
    sub_6AC04(v2[4], ptr);
    free(ptr[0]);
    destroy_sample_buffer((void **)v3[4]);
    sub_6AC04(v3[5], ptr);
    free(ptr[0]);
    destroy_sample_buffer((void **)v3[5]);
    free(v3);
  }
  return 0;
}

//----- (00069FD4) --------------------------------------------------------
int __fastcall sub_69FD4(int *a1, int a2, _DWORD *a3)
{
  _DWORD *v4; // r0

  if ( !a1 )
    return 0;
  v4 = sub_6A408(*a1, a2);
  if ( !v4 )
    return 0;
  sub_6AC04(v4[5], a3);
  return 1;
}

//----- (0006A018) --------------------------------------------------------
int __fastcall sub_6A018(void (__fastcall ***a1)(_DWORD))
{
  int v2; // r5

  if ( !a1 )
    return 0;
  v2 = sub_6A9A0(*a1);
  free(a1);
  return v2;
}

//----- (0006A044) --------------------------------------------------------
_DWORD *__fastcall sub_6A044(int a1)
{
  _DWORD *result; // r0

  result = malloc(0x18u);
  result[3] = a1;
  *result = sub_69E94;
  result[2] = sub_69E18;
  result[1] = sub_69E34;
  result[4] = 0;
  result[5] = 0;
  return result;
}

//----- (0006A090) --------------------------------------------------------
int **__fastcall sub_6A090(int **result, int *a2)
{
  int *v2; // r3
  int *v3; // r12
  int v4; // r2
  bool v5; // zf
  int v6; // r2

  v2 = (int *)a2[1];
  v3 = (int *)(result + 1);
  v4 = *v2;
  v5 = *v2 == (_DWORD)(result + 1);
  a2[1] = *v2;
  if ( !v5 )
    *(_DWORD *)(v4 + 8) = a2;
  v6 = a2[2];
  if ( v3 != v2 )
  {
    v2[2] = v6;
    v6 = a2[2];
  }
  if ( v6 )
  {
    result = *(int ***)v6;
    if ( *(int **)v6 == a2 )
      *(_DWORD *)v6 = v2;
    else
      *(_DWORD *)(v6 + 4) = v2;
  }
  else
  {
    *result = v2;
  }
  *v2 = (int)a2;
  if ( v3 != a2 )
    a2[2] = (int)v2;
  return result;
}

//----- (0006A0E4) --------------------------------------------------------
_DWORD *__fastcall sub_6A0E4(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // r3
  _DWORD *v3; // r12
  _DWORD *v4; // r2
  _DWORD *v5; // r2

  v2 = (_DWORD *)*a2;
  v3 = result + 1;
  v4 = *(_DWORD **)(*a2 + 4);
  *a2 = v4;
  if ( v4 != result + 1 )
    v4[2] = a2;
  v5 = (_DWORD *)a2[2];
  if ( v3 != v2 )
  {
    v2[2] = v5;
    v5 = (_DWORD *)a2[2];
  }
  if ( v5 )
  {
    result = (_DWORD *)v5[1];
    if ( result == a2 )
      v5[1] = v2;
    else
      *v5 = v2;
  }
  else
  {
    *result = v2;
  }
  v2[1] = a2;
  if ( v3 != a2 )
    a2[2] = v2;
  return result;
}

//----- (0006A138) --------------------------------------------------------
int __fastcall sub_6A138(int result, _DWORD *a2)
{
  _DWORD *v2; // r5
  int v3; // r6
  _DWORD *v4; // r4

  v2 = (_DWORD *)(result + 4);
  if ( a2 != (_DWORD *)(result + 4) )
  {
    v3 = result;
    v4 = a2;
    do
    {
      if ( v4[3] > 1u )
        _assert_fail(
          "debug_node_color(pTree,n) == clib_red || debug_node_color(pTree,n) == clib_black",
          "3rdparty/cstl/src/c_rb.c",
          0x1DFu,
          "debug_verify_property_1");
      result = sub_6A138(v3, *v4);
      v4 = (_DWORD *)v4[1];
    }
    while ( v4 != v2 );
  }
  return result;
}

//----- (0006A198) --------------------------------------------------------
int __fastcall sub_6A198(int result, _DWORD *a2)
{
  int v2; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r1
  _DWORD *v6; // r3
  _DWORD *v7; // r2

  v2 = result;
  v4 = (_DWORD *)(result + 4);
  while ( 2 )
  {
    if ( a2 != v4 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v5 = (_DWORD *)*a2;
          if ( a2[3] == 1 )
            break;
          a2 = (_DWORD *)a2[1];
LABEL_4:
          result = sub_6A198(v2);
          if ( a2 == v4 )
            return result;
        }
        if ( v5 != v4 && v5[3] )
          _assert_fail(
            "debug_node_color(pTree,n->left) == clib_black",
            "3rdparty/cstl/src/c_rb.c",
            0x1EFu,
            "debug_verify_property_4");
        v6 = (_DWORD *)a2[1];
        if ( v6 == v4 )
          break;
        if ( v6[3] )
          _assert_fail(
            "debug_node_color(pTree,n->right) == clib_black",
            "3rdparty/cstl/src/c_rb.c",
            0x1F0u,
            "debug_verify_property_4");
        v7 = (_DWORD *)a2[2];
        if ( v7 != v4 )
          goto LABEL_12;
        a2 = (_DWORD *)a2[1];
        result = sub_6A198(v2);
      }
      v7 = (_DWORD *)a2[2];
      if ( v7 == v4 )
      {
        a2 = (_DWORD *)*a2;
        continue;
      }
LABEL_12:
      if ( v7[3] )
        _assert_fail(
          "debug_node_color(pTree,n->parent) == clib_black",
          "3rdparty/cstl/src/c_rb.c",
          0x1F1u,
          "debug_verify_property_4");
      a2 = (_DWORD *)a2[1];
      goto LABEL_4;
    }
    return result;
  }
}

//----- (0006A2A0) --------------------------------------------------------
int __fastcall sub_6A2A0(int result, _DWORD *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // r4
  _DWORD *v5; // r8
  int v6; // r9
  int v7; // r5
  int i; // r6

  v4 = a2;
  v5 = (_DWORD *)(result + 4);
  v6 = result;
  v7 = a3;
  for ( i = a3 + 1; v4 != v5; v4 = (_DWORD *)v4[1] )
  {
    if ( !v4[3] )
      v7 = i++;
    result = sub_6A2A0(v6, *v4, v7, a4);
  }
  if ( *a4 == -1 )
  {
    *a4 = i;
  }
  else if ( *a4 != i )
  {
    _assert_fail(
      "black_count == *path_black_count",
      "3rdparty/cstl/src/c_rb.c",
      0x205u,
      "debug_verify_property_5_helper");
  }
  return result;
}

//----- (0006A330) --------------------------------------------------------
int __fastcall sub_6A330(_DWORD **a1)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r5
  int v5; // [sp+4h] [bp-4h] BYREF

  v2 = a1 + 1;
  v1 = *a1;
  sub_6A138((int)a1, *a1);
  if ( v1 != v2 && v1[3] )
    _assert_fail(
      "debug_node_color(pTree,root) == clib_black",
      "3rdparty/cstl/src/c_rb.c",
      0x1E6u,
      "debug_verify_property_2");
  sub_6A198((int)a1, v1);
  v5 = -1;
  return sub_6A2A0((int)a1, v1, 0, &v5);
}

//----- (0006A3B0) --------------------------------------------------------
_DWORD *__fastcall sub_6A3B0(int a1, int a2, int a3)
{
  _DWORD *result; // r0

  result = malloc(0x28u);
  if ( result )
  {
    result[5] = 0;
    result[6] = 0;
    result[3] = 0;
    result[4] = 0;
    result[9] = a1;
    result[7] = a2;
    result[8] = a3;
    *result = result + 1;
    result[1] = result + 1;
    result[2] = result + 1;
  }
  return result;
}

//----- (0006A408) --------------------------------------------------------
_DWORD *__fastcall sub_6A408(int a1, int a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r7
  _DWORD *v6; // r3
  int v7; // r5
  void *ptr; // [sp+4h] [bp-4h] BYREF

  v3 = (_DWORD *)(a1 + 4);
  v2 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 == a1 + 4 )
    return 0;
  while ( 1 )
  {
    sub_6AC04(v2[4], &ptr);
    v7 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v7 )
      break;
    v6 = (_DWORD *)*v2;
    v2 = (_DWORD *)v2[1];
    if ( v7 < 0 )
      v2 = v6;
    if ( v2 == v3 )
      return 0;
  }
  return v2;
}

//----- (0006A488) --------------------------------------------------------
int __fastcall sub_6A488(int a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  int *v9; // r5
  int v11; // r8
  int *v12; // r4
  __int64 v13; // r2
  int v14; // r7
  int v15; // r7
  int *v16; // r4
  int v17; // r3
  int *v18; // r7
  int v19; // r0
  int *v20; // r2
  void *ptr; // [sp+0h] [bp-Ch] BYREF
  void *v22[2]; // [sp+4h] [bp-8h] BYREF

  v9 = (int *)malloc(0x18u);
  if ( !v9 )
    return 2;
  v11 = a1 + 4;
  *v9 = a1 + 4;
  v9[1] = a1 + 4;
  v9[3] = 1;
  v9[4] = (int)sub_6ABA8(a2, a3);
  if ( a4 )
    v9[5] = (int)sub_6ABA8(a4, a5);
  else
    v9[5] = 0;
  v12 = *(int **)a1;
  if ( v11 == *(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = v9;
    v9[2] = 0;
    v20 = v9;
  }
  else
  {
    while ( 1 )
    {
      sub_6AC04(v12[4], &ptr);
      sub_6AC04(v9[4], v22);
      v14 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v22[0], ptr);
      free(ptr);
      free(v22[0]);
      if ( !v14 )
        return 401;
      v13 = *(_QWORD *)v12;
      if ( v14 < 0 )
        HIDWORD(v13) = *v12;
      if ( v11 == HIDWORD(v13) )
        break;
      v12 = (int *)HIDWORD(v13);
    }
    v9[2] = (int)v12;
    sub_6AC04(v12[4], &ptr);
    sub_6AC04(v9[4], v22);
    v15 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v22[0], ptr);
    free(ptr);
    free(v22[0]);
    v20 = *(int **)a1;
    if ( v15 >= 0 )
      v12[1] = (int)v9;
    else
      *v12 = (int)v9;
LABEL_17:
    if ( v9 != v20 )
    {
      do
      {
        v16 = (int *)v9[2];
        if ( v16[3] != 1 )
          break;
        v17 = v16[2];
        v18 = *(int **)v17;
        if ( v16 == *(int **)v17 )
        {
          v19 = *(_DWORD *)(v17 + 4);
          if ( *(_DWORD *)(v19 + 12) == 1 )
          {
            v16[3] = 0;
            v9 = (int *)v17;
            *(_DWORD *)(v19 + 12) = 0;
            *(_DWORD *)(v17 + 12) = 1;
          }
          else
          {
            if ( (int *)v18[1] == v9 )
            {
              sub_6A090((int **)a1, *(int **)v17);
              v18 = (int *)v18[2];
              v9 = v16;
              v17 = v18[2];
            }
            v18[3] = 0;
            *(_DWORD *)(v17 + 12) = 1;
            sub_6A0E4((_DWORD *)a1, (_DWORD *)v17);
            v20 = *(int **)a1;
          }
          goto LABEL_17;
        }
        if ( v18[3] == 1 )
        {
          v16[3] = 0;
          v9 = (int *)v17;
          v18[3] = 0;
          *(_DWORD *)(v17 + 12) = 1;
          goto LABEL_17;
        }
        if ( v9 == (int *)*v16 )
        {
          sub_6A0E4((_DWORD *)a1, (_DWORD *)v9[2]);
          v9 = v16;
          v17 = *(_DWORD *)(v16[2] + 8);
          v16 = (int *)v16[2];
        }
        v16[3] = 0;
        *(_DWORD *)(v17 + 12) = 1;
        sub_6A090((int **)a1, (int *)v17);
        v20 = *(int **)a1;
      }
      while ( v9 != *(int **)a1 );
    }
  }
  v20[3] = 0;
  sub_6A330((_DWORD **)a1);
  return 0;
}

//----- (0006A6EC) --------------------------------------------------------
int *__fastcall sub_6A6EC(int a1, int a2)
{
  int *v2; // r4
  int *v3; // r7
  int v6; // r5
  int *v7; // r3
  int *v8; // r5
  int *v9; // r7
  int **v10; // r3
  int v11; // r1
  int v12; // r3
  int v13; // r2
  int *v15; // r3
  int *v16; // r2
  int *v17; // r3
  int v18; // r1
  int v19; // r12
  int v20; // r0
  int v21; // r12
  int v22; // r0
  void *ptr; // [sp+4h] [bp-4h] BYREF

  v3 = (int *)(a1 + 4);
  v2 = *(int **)a1;
  if ( a1 + 4 == *(_DWORD *)a1 )
    return 0;
  while ( 1 )
  {
    sub_6AC04(v2[4], &ptr);
    v6 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    v7 = (int *)*v2;
    if ( !v6 )
      break;
    v2 = (int *)v2[1];
    if ( v6 < 0 )
      v2 = v7;
    if ( v2 == v3 )
      return 0;
  }
  v8 = (int *)v2[1];
  if ( v3 != v7 )
  {
    if ( v3 != v8 )
    {
      while ( v3 != (int *)*v8 )
        v8 = (int *)*v8;
      v9 = v8;
      v8 = (int *)v8[1];
      goto LABEL_14;
    }
    v8 = (int *)*v2;
  }
  v9 = v2;
LABEL_14:
  v8[2] = v9[2];
  v10 = (int **)v9[2];
  if ( v10 )
  {
    if ( v9 == *v10 )
      *v10 = v8;
    else
      v10[1] = v8;
  }
  else
  {
    *(_DWORD *)a1 = v8;
  }
  if ( v9 != v2 )
  {
    v11 = v2[4];
    v12 = v2[5];
    v13 = v9[5];
    v2[4] = v9[4];
    v9[4] = v11;
    v2[5] = v13;
    v9[5] = v12;
  }
  if ( !v9[3] )
  {
    v15 = *(int **)a1;
LABEL_25:
    if ( v8 != v15 )
    {
      while ( !v8[3] )
      {
        v16 = (int *)v8[2];
        v17 = (int *)*v16;
        if ( v8 == (int *)*v16 )
        {
          v17 = (int *)v16[1];
          if ( v17[3] == 1 )
          {
            v17[3] = 0;
            v16[3] = 1;
            sub_6A090((int **)a1, v16);
            v16 = (int *)v8[2];
            v17 = (int *)v16[1];
          }
          v21 = v17[1];
          v22 = *(_DWORD *)(v21 + 12);
          if ( *(_DWORD *)(*v17 + 12) )
          {
            if ( v22 )
            {
              v8 = v16;
            }
            else
            {
              *(_DWORD *)(*v17 + 12) = 0;
              v17[3] = 1;
              sub_6A0E4((_DWORD *)a1, v17);
              v8 = (int *)v8[2];
              v17 = (int *)v8[1];
              v21 = v17[1];
            }
LABEL_42:
            v17[3] = v8[3];
            v8[3] = 0;
            *(_DWORD *)(v21 + 12) = 0;
            sub_6A090((int **)a1, v8);
            v8 = *(int **)a1;
            v15 = *(int **)a1;
            goto LABEL_25;
          }
          v8 = v16;
          if ( v22 )
            goto LABEL_42;
        }
        else
        {
          if ( v17[3] == 1 )
          {
            v17[3] = 0;
            v16[3] = 1;
            sub_6A0E4((_DWORD *)a1, v16);
            v16 = (int *)v8[2];
            v17 = (int *)*v16;
          }
          v18 = v17[1];
          v19 = *v17;
          v20 = *(_DWORD *)(*v17 + 12);
          if ( *(_DWORD *)(v18 + 12) )
          {
            if ( v20 )
            {
              v8 = v16;
            }
            else
            {
              *(_DWORD *)(v18 + 12) = 0;
              v17[3] = 1;
              sub_6A090((int **)a1, v17);
              v8 = (int *)v8[2];
              v17 = (int *)*v8;
              v19 = *(_DWORD *)*v8;
            }
LABEL_37:
            v17[3] = v8[3];
            v8[3] = 0;
            *(_DWORD *)(v19 + 12) = 0;
            sub_6A0E4((_DWORD *)a1, v8);
            v8 = *(int **)a1;
            v15 = *(int **)a1;
            goto LABEL_25;
          }
          v8 = v16;
          if ( v20 )
            goto LABEL_37;
        }
        v17[3] = 1;
        if ( v8 == *(int **)a1 )
          break;
      }
    }
    v8[3] = 0;
  }
  sub_6A330((_DWORD **)a1);
  return v9;
}

//----- (0006A9A0) --------------------------------------------------------
int __fastcall sub_6A9A0(void (__fastcall **ptr)(_DWORD))
{
  char *v2; // r4
  char *v3; // r5
  char *v5; // r7
  void **v6; // r0
  void **v7; // r0
  int v8; // r8
  char *v9; // r0
  char *v10; // r0
  int v11; // [sp+0h] [bp-8h] BYREF
  int v12; // [sp+4h] [bp-4h] BYREF

  v3 = (char *)(ptr + 1);
  v2 = (char *)*ptr;
  while ( v2 != v3 )
  {
    if ( *(char **)v2 == v3 )
    {
      v5 = (char *)*((_DWORD *)v2 + 1);
      if ( v3 == v5 )
      {
        v6 = (void **)*((_DWORD *)v2 + 4);
        if ( ptr[7] )
        {
          sub_6AC04((int)v6, &v11);
          ptr[7](v11);
          v6 = (void **)*((_DWORD *)v2 + 4);
        }
        destroy_sample_buffer(v6);
        v7 = (void **)*((_DWORD *)v2 + 5);
        if ( v7 )
        {
          if ( ptr[8] )
          {
            sub_6AC04((int)v7, &v12);
            ptr[8](v12);
            v7 = (void **)*((_DWORD *)v2 + 5);
          }
          destroy_sample_buffer(v7);
        }
        v8 = *((_DWORD *)v2 + 2);
        if ( v8 )
        {
          if ( v5 == *(char **)v8 )
          {
            v9 = *(char **)(v8 + 4);
            v2 = (char *)*((_DWORD *)v2 + 2);
            if ( v5 != v9 )
            {
              free(v9);
              *(_DWORD *)(v8 + 4) = v5;
            }
          }
          else
          {
            free(*(void **)v8);
            v2 = (char *)v8;
            *(_DWORD *)v8 = v5;
          }
        }
        else
        {
          v10 = v2;
          v2 = v5;
          free(v10);
        }
      }
      else
      {
        v2 = (char *)*((_DWORD *)v2 + 1);
      }
    }
    else
    {
      v2 = *(char **)v2;
    }
  }
  free(ptr);
  return 0;
}

//----- (0006AAA8) --------------------------------------------------------
_DWORD *__fastcall sub_6AAA8(int a1, _DWORD *a2)
{
  int v2; // r0

  v2 = a1 + 4;
  while ( *a2 != v2 )
    a2 = (_DWORD *)*a2;
  return a2;
}

//----- (0006AAC8) --------------------------------------------------------
int __fastcall sub_6AAC8(int a1, int a2)
{
  int v2; // r0

  v2 = a1 + 4;
  while ( *(_DWORD *)(a2 + 4) != v2 )
    a2 = *(_DWORD *)(a2 + 4);
  return a2;
}

//----- (0006AAE8) --------------------------------------------------------
bool __fastcall sub_6AAE8(_DWORD *a1)
{
  return *a1 != (_DWORD)(a1 + 1);
}

//----- (0006AAFC) --------------------------------------------------------
int *__fastcall sub_6AAFC(int *a1, int a2)
{
  int *v2; // r3
  int *v3; // r12
  int i; // r2
  int *v6; // r2
  bool v7; // zf

  v2 = *(int **)(a2 + 4);
  v3 = a1 + 1;
  if ( v2 != a1 + 1 )
  {
    while ( v3 != (int *)*v2 )
      v2 = (int *)*v2;
    return v2;
  }
  for ( i = *a1; v3 != *(int **)(i + 4); i = *(_DWORD *)(i + 4) )
    ;
  if ( a2 == i )
    return 0;
  v6 = *(int **)(a2 + 8);
  if ( v3 == v6 )
    return a1 + 1;
  if ( a2 != v6[1] )
    return *(int **)(a2 + 8);
  while ( 1 )
  {
    v2 = (int *)v6[2];
    if ( v3 == v2 )
      break;
    v7 = v2[1] == (_DWORD)v6;
    v6 = (int *)v6[2];
    if ( !v7 )
      return v2;
  }
  return (int *)v6[2];
}

//----- (0006ABA8) --------------------------------------------------------
_DWORD *__fastcall sub_6ABA8(const void *a1, size_t a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  void *v6; // r0
  void *v8; // r0

  v4 = malloc(8u);
  v5 = v4;
  if ( v4 )
  {
    v4[1] = a2;
    v6 = malloc(a2);
    *v5 = v6;
    if ( v6 )
    {
      memcpy(v6, a1, a2);
    }
    else
    {
      v8 = v5;
      v5 = 0;
      free(v8);
    }
  }
  return v5;
}

//----- (0006AC04) --------------------------------------------------------
int __fastcall sub_6AC04(int a1, _DWORD *a2)
{
  size_t v3; // r5
  void *v5; // r0

  v3 = *(_DWORD *)(a1 + 4);
  v5 = malloc(v3);
  *a2 = v5;
  if ( !v5 )
    return 3;
  memcpy(v5, *(const void **)a1, v3);
  return 0;
}

//----- (0006AC44) --------------------------------------------------------
void *__fastcall sub_6AC44(void **a1, const void *a2, size_t a3)
{
  void *v6; // r0

  free(*a1);
  v6 = malloc(a3);
  *a1 = v6;
  return memcpy(v6, a2, a3);
}

//----- (0006AC78) --------------------------------------------------------
void __fastcall destroy_sample_buffer(void **a1)
{
  if ( a1 )
  {
    free(*a1);
    free(a1);
  }
}

//----- (0006AC9C) --------------------------------------------------------
int __fastcall agt_mk_comp_droids(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 < *a2 )
    return -1;
  else
    return *a1 != *a2;
}

//----- (0006ACC0) --------------------------------------------------------
int __fastcall sub_6ACC0(void *src, size_t n, const void **a3)
{
  return sub_6D610(a3, src, n);
}

//----- (0006ACD4) --------------------------------------------------------
size_t __fastcall sub_6ACD4(const void *a1, size_t a2, FILE *s)
{
  size_t result; // r0

  result = fwrite(a1, a2, 1u, s) - 1;
  if ( result )
    return -1;
  return result;
}

//----- (0006ACF0) --------------------------------------------------------
int __fastcall sub_6ACF0(int a1, int a2)
{
  return strcmp(*(const char **)(a1 + 4), *(const char **)(a2 + 4));
}

//----- (0006ACFC) --------------------------------------------------------
int __fastcall sub_6ACFC(char a1, int a2, int a3, int (__fastcall *a4)(__int16 *, int, int), int a5)
{
  int v5; // r9
  int v8; // r4

  v5 = a1 & 0x1F;
  if ( (a1 & 0x1F) != 0 )
  {
    v8 = a4(&word_8B454, 1, a5);
    if ( !v8 )
    {
      if ( a2 <= 0 )
        return 0;
      while ( 1 )
      {
        ++v8;
        if ( a4((__int16 *)"                                ", v5, a5) )
          break;
        if ( a2 == v8 )
          return 0;
      }
    }
    return -1;
  }
  if ( !a3 || (a1 & 0x20) != 0 )
    return 0;
  return a4((__int16 *)" ", 1, a5);
}
// 8B454: using guessed type __int16 word_8B454;

//----- (0006ADA0) --------------------------------------------------------
int __fastcall sub_6ADA0(char *a1, int (__fastcall *a2)(char *, int), int a3, unsigned int a4)
{
  char *i; // r11
  char *v9; // r5
  bool v10; // zf
  int v11; // r1
  char *v12; // r0
  int v13; // r1
  int v14; // r3
  unsigned int v15; // r2
  int v17; // [sp+Ch] [bp-18h] BYREF
  char s[20]; // [sp+10h] [bp-14h] BYREF

  if ( a2("\"", 1) )
    return -1;
  for ( i = a1; *i; i = v9 )
  {
    v9 = sub_6DB8C(i, &v17);
    if ( !v9 )
      return -1;
    v10 = v17 == 34;
    if ( v17 != 34 )
      v10 = v17 == 92;
    v11 = v10;
    if ( v17 <= 31 )
      v11 |= 1u;
    if ( !v11 && ((v17 == 47) & (a4 >> 10)) == 0 && ((v17 > 127) & (a4 >> 6)) == 0 )
      continue;
    if ( i != a1 && ((int (__fastcall *)(char *, int, int))a2)(a1, i - a1, a3) )
      return -1;
    if ( i == v9 )
      return ((int (__fastcall *)(char *, int, int))a2)("\"", 1, a3);
    if ( v17 == 12 )
    {
      v13 = 2;
      v12 = "\\f";
      goto LABEL_26;
    }
    if ( v17 <= 12 )
    {
      switch ( v17 )
      {
        case 9:
          v12 = "\\t";
          v13 = 2;
          goto LABEL_26;
        case 10:
          v12 = "\\n";
          v13 = 2;
          goto LABEL_26;
        case 8:
          v12 = "\\b";
          v13 = 2;
          goto LABEL_26;
      }
LABEL_32:
      if ( v17 >= 0x10000 )
      {
        v14 = (v17 - 0x10000) & 0x3FF | 0xDC00;
        v15 = ((unsigned int)(v17 - 0x10000) >> 10) & 0x3FF | 0xD800;
        v17 -= 0x10000;
        sprintf(s, "\\u%04x\\u%04x", v15, v14);
        v12 = s;
        v13 = 12;
        goto LABEL_26;
      }
LABEL_33:
      sprintf(s, "\\u%04x", v17);
      v12 = s;
      v13 = 6;
      goto LABEL_26;
    }
    if ( v17 == 34 )
    {
      v12 = "\\\"";
      v13 = 2;
      goto LABEL_26;
    }
    if ( v17 <= 34 )
    {
      if ( v17 == 13 )
      {
        v12 = "\\r";
        v13 = 2;
        goto LABEL_26;
      }
      goto LABEL_33;
    }
    if ( v17 == 47 )
    {
      v12 = "\\/";
      v13 = 2;
      goto LABEL_26;
    }
    if ( v17 != 92 )
      goto LABEL_32;
    v12 = "\\\\";
    v13 = 2;
LABEL_26:
    if ( ((int (__fastcall *)(char *, int, int))a2)(v12, v13, a3) )
      return -1;
    a1 = v9;
  }
  if ( i == a1 || !((int (__fastcall *)(char *, int, int))a2)(a1, i - a1, a3) )
    return ((int (__fastcall *)(char *, int, int))a2)("\"", 1, a3);
  return -1;
}
// 6AF28: conditional instruction was optimized away because %var_18.4 is in (E..21)

//----- (0006B004) --------------------------------------------------------
int __fastcall sub_6B004(_DWORD *a1, unsigned int a2, int a3, int (__fastcall *a4)(__int16 *, int, int), int a5)
{
  char *v10; // r11
  int v11; // r8
  int v12; // r7
  _DWORD *v13; // r7
  char *v14; // r0
  __int64 v15; // r0
  int v16; // r0
  int v17; // r1
  int *v18; // r0
  int *v19; // r9
  int v20; // r6
  unsigned int i; // r11
  _DWORD *v22; // r3
  char *v23; // r11
  unsigned int v24; // r9
  char *v25; // r7
  int (*v26)(const void *, const void *); // r3
  int v27; // r8
  char *v28; // r11
  int v29; // r10
  int v30; // r9
  char *v31; // r0
  int v32; // r0
  int v33; // r9
  signed int v34; // r8
  _DWORD *v35; // r0
  size_t nmemb; // [sp+Ch] [bp-88h]
  _DWORD *v37; // [sp+10h] [bp-84h]
  __int16 *v38; // [sp+10h] [bp-84h]
  char *v39; // [sp+14h] [bp-80h]
  int v40; // [sp+14h] [bp-80h]
  int v41; // [sp+18h] [bp-7Ch]
  int v42; // [sp+18h] [bp-7Ch]
  unsigned int v43; // [sp+1Ch] [bp-78h]
  unsigned int v44; // [sp+20h] [bp-74h]
  int *base; // [sp+24h] [bp-70h]
  __int16 s[52]; // [sp+2Ch] [bp-68h] BYREF

  if ( !a1 )
    return -1;
  switch ( *a1 )
  {
    case 0:
      v10 = ":";
      if ( (a2 & 0x20) != 0 )
        v11 = 1;
      else
        v11 = 2;
      if ( (a2 & 0x20) == 0 )
        v10 = ": ";
      if ( a1[8] )
        goto LABEL_40;
      a1[8] = 1;
      v12 = sub_6E048(a1);
      if ( a4((__int16 *)"{", 1, a5) )
        goto LABEL_40;
      if ( !v12 )
        goto LABEL_12;
      v42 = a3 + 1;
      if ( sub_6ACFC(a2, a3 + 1, 0, a4, a5) )
        goto LABEL_40;
      if ( (a2 & 0x180) != 0 )
      {
        v37 = sub_6DFB0(a1);
        v18 = (int *)sub_6D500((void *)(8 * (_DWORD)v37));
        base = v18;
        if ( v18 )
        {
          v39 = v10;
          v44 = a2;
          v19 = v18 + 1;
          v20 = v12;
          for ( i = 0; ; ++i )
          {
            *(v19 - 1) = sub_6BE28(v20);
            *v19 = sub_6E0C8(v20);
            v19 += 2;
            v20 = sub_6E094(a1, v20);
            if ( !v20 )
              break;
          }
          v22 = (_DWORD *)(i + 1);
          nmemb = i + 1;
          v43 = i;
          v23 = v39;
          if ( v37 != v22 )
            _assert_fail("i == size", "3rdparty/jansson-2.6/src/dump.c", 0x141u, "do_dump");
          v24 = 0;
          v25 = (char *)base;
          v26 = (int (*)(const void *, const void *))agt_mk_comp_droids;
          if ( (v44 & 0x80) != 0 )
            v26 = (int (*)(const void *, const void *))sub_6ACF0;
          qsort(base, nmemb, 8u, v26);
          v40 = v11;
          v38 = (__int16 *)v23;
          v27 = a3 + 1;
          v41 = a3;
          while ( 1 )
          {
            v28 = (char *)*((_DWORD *)v25 + 1);
            v29 = sub_6DFCC(a1, v28);
            if ( !v29 )
              _assert_fail("value", "3rdparty/jansson-2.6/src/dump.c", 0x151u, "do_dump");
            sub_6ADA0(v28, (int (__fastcall *)(char *, int))a4, a5, v44);
            if ( a4(v38, v40, a5) || sub_6B004(v29, v44, v27, a4, a5) )
              break;
            if ( v24 < v43 )
            {
              if ( a4((__int16 *)",", 1, a5) || sub_6ACFC(v44, v27, 1, a4, a5) )
                break;
            }
            else if ( sub_6ACFC(v44, v41, 0, a4, a5) )
            {
              break;
            }
            ++v24;
            v25 += 8;
            if ( v24 == nmemb )
            {
              sub_6D518(base);
              goto LABEL_12;
            }
          }
          sub_6D518(base);
        }
      }
      else
      {
        while ( 1 )
        {
          v30 = sub_6E094(a1, v12);
          v31 = (char *)sub_6E0C8(v12);
          sub_6ADA0(v31, (int (__fastcall *)(char *, int))a4, a5, a2);
          if ( a4((__int16 *)v10, v11, a5) )
            goto LABEL_40;
          v32 = sub_6E0D4(v12);
          if ( sub_6B004(v32, a2, v42, a4, a5) )
            goto LABEL_40;
          if ( !v30 )
            break;
          if ( !a4((__int16 *)",", 1, a5) )
          {
            v12 = v30;
            if ( !sub_6ACFC(a2, v42, 1, a4, a5) )
              continue;
          }
          goto LABEL_40;
        }
        if ( !sub_6ACFC(a2, a3, 0, a4, a5) )
        {
LABEL_12:
          a1[8] = 0;
          return a4(&word_836FC, 1, a5);
        }
      }
LABEL_40:
      a1[8] = 0;
      return -1;
    case 1:
      if ( a1[5] )
        goto LABEL_51;
      a1[5] = 1;
      v13 = sub_6E1A8(a1);
      if ( a4((__int16 *)"[", 1, a5) )
        goto LABEL_51;
      if ( !v13 )
        goto LABEL_16;
      v33 = a3 + 1;
      v34 = sub_6ACFC(a2, a3 + 1, 0, a4, a5);
      if ( v34 )
        goto LABEL_51;
      if ( (int)v13 <= 0 )
        goto LABEL_16;
      break;
    case 2:
      v14 = (char *)sub_6E350(a1);
      return sub_6ADA0(v14, (int (__fastcall *)(char *, int))a4, a5, a2);
    case 3:
      v15 = sub_6E430((int)a1);
      v16 = snprintf((char *)s, 0x64u, "%lld", v15);
      return a4(s, v16, a5);
    case 4:
      sub_6E4E0();
      v17 = sub_6D818((char *)s, 0x64u);
      if ( v17 < 0 )
        return -1;
      return a4(s, v17, a5);
    case 5:
      return a4((__int16 *)"true", 4, a5);
    case 6:
      return a4((__int16 *)"false", 5, a5);
    case 7:
      return a4((__int16 *)"null", 4, a5);
    default:
      return -1;
  }
  while ( 1 )
  {
    v35 = sub_6E1C4(a1, v34);
    if ( sub_6B004(v35, a2, v33, a4, a5) )
      break;
    if ( (int)v13 - 1 <= v34 )
    {
      if ( sub_6ACFC(a2, a3, 0, a4, a5) )
        break;
    }
    else if ( a4((__int16 *)",", 1, a5) || sub_6ACFC(a2, v33, 1, a4, a5) )
    {
      break;
    }
    if ( v13 == (_DWORD *)++v34 )
    {
LABEL_16:
      a1[5] = 0;
      return a4(&word_7A848, 1, a5);
    }
  }
LABEL_51:
  a1[5] = 0;
  return -1;
}
// 6B02C: control flows out of bounds to 6B030
// 7A848: using guessed type __int16 word_7A848;
// 836FC: using guessed type __int16 word_836FC;

//----- (0006B69C) --------------------------------------------------------
int __fastcall sub_6B69C(_DWORD *a1, int (__fastcall *a2)(__int16 *, int, int), int a3, __int16 a4)
{
  if ( (a4 & 0x200) != 0 || a1 && *a1 <= 1u )
    return sub_6B004(a1, a4, 0, a2, a3);
  else
    return -1;
}

//----- (0006B6E8) --------------------------------------------------------
void *__fastcall sub_6B6E8(_DWORD *a1, __int16 a2)
{
  void *v4; // r4
  const char *v6; // r0
  _DWORD v7[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = (void *)sub_6D580(v7);
  if ( v4 )
    return 0;
  if ( !sub_6B69C(a1, (int (__fastcall *)(__int16 *, int, int))sub_6ACC0, (int)v7, a2) )
  {
    v6 = (const char *)sub_6D5F4((int)v7);
    v4 = sub_6D530(v6);
  }
  sub_6D5B4((int)v7);
  return v4;
}

//----- (0006B754) --------------------------------------------------------
int __fastcall sub_6B754(_DWORD *a1, int a2, __int16 a3)
{
  return sub_6B69C(a1, (int (__fastcall *)(__int16 *, int, int))sub_6ACD4, a2, a3);
}

//----- (0006B768) --------------------------------------------------------
int __fastcall sub_6B768(_DWORD *a1, int a2, __int16 a3)
{
  FILE *v5; // r4
  int v6; // r5

  v5 = (FILE *)fopen64(a2, "w");
  if ( !v5 )
    return -1;
  v6 = sub_6B69C(a1, (int (__fastcall *)(__int16 *, int, int))sub_6ACD4, (int)v5, a3);
  fclose(v5);
  return v6;
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0006B7C4) --------------------------------------------------------
int __fastcall sub_6B7C4(int a1, int *a2, char *s2, int a4)
{
  int v4; // r4
  bool v8; // zf
  int result; // r0

  v4 = *a2;
  if ( *a2 != a1 + 12 || v4 != a2[1] )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(v4 - 4) == a4 )
      {
        v8 = strcmp((const char *)(v4 + 16), s2) == 0;
        result = v4 - 4;
        if ( v8 )
          return result;
        if ( a2[1] == v4 )
          return 0;
      }
      else if ( a2[1] == v4 )
      {
        return 0;
      }
      v4 = *(_DWORD *)(v4 + 4);
    }
  }
  return 0;
}

//----- (0006B840) --------------------------------------------------------
void __fastcall sub_6B840(int a1)
{
  int v1; // r3
  int v2; // r6
  int v3; // r0
  void *v4; // r5
  int v5; // r4
  int v6; // r3

  v1 = *(_DWORD *)(a1 + 16);
  v2 = a1 + 12;
  if ( v1 != a1 + 12 )
  {
    do
    {
      v3 = *(_DWORD *)(v1 + 8);
      v4 = (void *)(v1 - 4);
      v5 = *(_DWORD *)(v1 + 4);
      if ( v3 )
      {
        v6 = *(_DWORD *)(v3 + 4);
        if ( v6 != -1 )
        {
          *(_DWORD *)(v3 + 4) = v6 - 1;
          if ( v6 == 1 )
            sub_6E5DC();
        }
      }
      sub_6D518(v4);
      v1 = v5;
    }
    while ( v5 != v2 );
  }
}
// 6E5DC: using guessed type int sub_6E5DC(void);

//----- (0006B8A0) --------------------------------------------------------
int __fastcall sub_6B8A0(_DWORD *a1)
{
  _DWORD *v2; // r0
  int v3; // r1
  _DWORD *v4; // r3
  int v5; // r2
  _DWORD *v6; // r2

  *a1 = 0;
  a1[2] = 0;
  v2 = sub_6D500((void *)0x28);
  a1[1] = v2;
  if ( !v2 )
    return -1;
  v3 = a1[2];
  v4 = a1 + 3;
  a1[4] = a1 + 3;
  v5 = dword_8A954[v3];
  a1[3] = a1 + 3;
  if ( v5 )
  {
    v6 = &v2[2 * v5];
    do
    {
      v2[1] = v4;
      *v2 = v4;
      v2 += 2;
    }
    while ( v2 != v6 );
  }
  return 0;
}
// 8A954: using guessed type _DWORD dword_8A954[29];

//----- (0006B910) --------------------------------------------------------
void __fastcall sub_6B910(int a1)
{
  sub_6B840(a1);
  sub_6D518(*(void **)(a1 + 4));
}

//----- (0006B928) --------------------------------------------------------
int __fastcall sub_6B928(int a1, char *a2, int a3, int a4)
{
  unsigned int v7; // r1
  char *v8; // r5
  int v9; // r3
  unsigned int v10; // r4
  char *v11; // r2
  int v12; // r0
  int v13; // t1
  int v14; // r1
  int *v15; // r5
  int v16; // r0
  int v17; // r10
  int v18; // r0
  int v19; // r3
  int v20; // r3
  size_t v22; // r0
  void *v23; // r0
  _DWORD *v24; // r10
  int v25; // r2
  _DWORD *v26; // r3
  int v27; // r3
  unsigned int v28; // r10
  char *v29; // r0
  _DWORD *v30; // r11
  char *v31; // r0
  char *v32; // r3
  _DWORD *v33; // r9
  int v34; // lr
  int v35; // r1
  _DWORD *v36; // r0
  char *v37; // r1
  _DWORD *v38; // r12
  int v40; // [sp+4h] [bp-8h]

  v7 = dword_8A954[*(_DWORD *)(a1 + 8)];
  v8 = *(char **)(a1 + 4);
  if ( *(_DWORD *)a1 >= v7 )
  {
    sub_6D518(*(void **)(a1 + 4));
    v27 = *(_DWORD *)(a1 + 8) + 1;
    v28 = dword_8A954[v27];
    *(_DWORD *)(a1 + 8) = v27;
    v29 = (char *)sub_6D500((void *)(8 * v28));
    v8 = v29;
    *(_DWORD *)(a1 + 4) = v29;
    if ( !v29 )
      return -1;
    v30 = (_DWORD *)(a1 + 12);
    v7 = dword_8A954[*(_DWORD *)(a1 + 8)];
    v40 = *(_DWORD *)(a1 + 8);
    if ( v7 )
    {
      v31 = &v29[8 * v7];
      v32 = v8;
      do
      {
        *((_DWORD *)v32 + 1) = v30;
        *(_DWORD *)v32 = v30;
        v32 += 8;
      }
      while ( v31 != v32 );
    }
    v33 = *(_DWORD **)(a1 + 16);
    *(_DWORD *)(a1 + 12) = v30;
    *(_DWORD *)(a1 + 16) = v30;
    if ( v33 != v30 )
    {
      do
      {
        while ( 1 )
        {
          sub_772CC(*(v33 - 1), v28);
          v36 = *(_DWORD **)&v8[8 * v35];
          v37 = &v8[8 * v35];
          v38 = (_DWORD *)v33[1];
          if ( v36 == v30 && v30 == *((_DWORD **)v37 + 1) )
            break;
          v34 = *v36;
          v33[1] = v36;
          *v33 = v34;
          *(_DWORD *)(*v36 + 4) = v33;
          *v36 = v33;
          *(_DWORD *)v37 = v33;
          v33 = v38;
          if ( v38 == v30 )
            goto LABEL_26;
        }
        *v33 = *(_DWORD *)(a1 + 12);
        v33[1] = v30;
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) = v33;
        *(_DWORD *)(a1 + 12) = v33;
        *((_DWORD *)v37 + 1) = v33;
        *(_DWORD *)v37 = v33;
        v33 = v38;
      }
      while ( v38 != v30 );
LABEL_26:
      v8 = *(char **)(a1 + 4);
      v7 = dword_8A954[v40];
    }
  }
  v9 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v11 = a2;
    v10 = 5381;
    do
    {
      v12 = v9 + 32 * v10;
      v13 = (unsigned __int8)*++v11;
      v9 = v13;
      v10 += v12;
    }
    while ( v13 );
  }
  else
  {
    v10 = 5381;
  }
  sub_772CC(v10, v7);
  v15 = (int *)&v8[8 * v14];
  v16 = sub_6B7C4(a1, v15, a2, v10);
  v17 = v16;
  if ( v16 )
  {
    v18 = *(_DWORD *)(v16 + 12);
    if ( v18 )
    {
      v19 = *(_DWORD *)(v18 + 4);
      if ( v19 != -1 )
      {
        v20 = v19 - 1;
        *(_DWORD *)(v18 + 4) = v20;
        if ( !v20 )
          sub_6E5DC((void **)v18);
      }
    }
    *(_DWORD *)(v17 + 12) = a4;
    return 0;
  }
  v22 = strlen(a2);
  v23 = sub_6D500((void *)(v22 + 21));
  v24 = v23;
  if ( !v23 )
    return -1;
  *(_DWORD *)v23 = v10;
  *((_DWORD *)v23 + 4) = a3;
  strcpy((char *)v23 + 20, a2);
  v25 = *v15;
  v26 = v24 + 1;
  v24[3] = a4;
  v24[2] = v24 + 1;
  v24[1] = v24 + 1;
  if ( v25 == a1 + 12 && v25 == v15[1] )
  {
    v24[1] = *(_DWORD *)(a1 + 12);
    v24[2] = v25;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) = v26;
    *(_DWORD *)(a1 + 12) = v26;
    v15[1] = (int)v26;
    *v15 = (int)v26;
  }
  else
  {
    v24[1] = *(_DWORD *)v25;
    v24[2] = v25;
    *(_DWORD *)(*(_DWORD *)v25 + 4) = v26;
    *(_DWORD *)v25 = v26;
    *v15 = (int)v26;
  }
  ++*(_DWORD *)a1;
  return 0;
}
// 6B994: variable 'v14' is possibly undefined
// 6BB18: variable 'v35' is possibly undefined
// 8A954: using guessed type _DWORD dword_8A954[29];

//----- (0006BBAC) --------------------------------------------------------
int __fastcall sub_6BBAC(int a1, char *a2)
{
  char *v2; // r6
  int v3; // r3
  unsigned int v5; // r4
  int v6; // r0
  int v7; // t1
  int v8; // r1
  int result; // r0

  v2 = a2;
  v3 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v5 = 5381;
    do
    {
      v6 = v3 + 32 * v5;
      v7 = (unsigned __int8)*++a2;
      v3 = v7;
      v5 += v6;
    }
    while ( v7 );
  }
  else
  {
    v5 = 5381;
  }
  sub_772CC(v5, dword_8A954[*(_DWORD *)(a1 + 8)]);
  result = sub_6B7C4(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * v8), v2, v5);
  if ( result )
    return *(_DWORD *)(result + 12);
  return result;
}
// 6BC08: variable 'v8' is possibly undefined
// 8A954: using guessed type _DWORD dword_8A954[29];

//----- (0006BC1C) --------------------------------------------------------
int __fastcall sub_6BC1C(_DWORD *a1, char *a2)
{
  char *v2; // r6
  int v3; // r3
  unsigned int v5; // r4
  int v6; // r0
  int v7; // t1
  int v8; // r7
  char *v9; // r2
  int v10; // r1
  int v11; // r8
  int *v12; // r6
  int v13; // r0
  _DWORD *v14; // r4
  _DWORD *v15; // r2
  int v16; // r0
  int v17; // r1
  int v18; // r3
  int v19; // r0
  int v20; // r3
  int v21; // r3
  bool v23; // zf

  v2 = a2;
  v3 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v5 = 5381;
    do
    {
      v6 = v3 + 32 * v5;
      v7 = (unsigned __int8)*++a2;
      v3 = v7;
      v5 += v6;
    }
    while ( v7 );
  }
  else
  {
    v5 = 5381;
  }
  sub_772CC(v5, dword_8A954[a1[2]]);
  v8 = a1[1];
  v9 = v2;
  v11 = v10;
  v12 = (int *)(v8 + 8 * v10);
  v13 = sub_6B7C4((int)a1, v12, v9, v5);
  v14 = (_DWORD *)v13;
  if ( !v13 )
    return -1;
  v15 = (_DWORD *)(v13 + 4);
  v16 = v12[1];
  v17 = v14[2];
  v18 = v14[1];
  if ( v14 + 1 == *(_DWORD **)(v8 + 8 * v11) )
  {
    v23 = v15 == (_DWORD *)v16;
    if ( v15 == (_DWORD *)v16 )
      v15 = a1 + 3;
    else
      *(_DWORD *)(v8 + 8 * v11) = v17;
    if ( v23 )
    {
      v12[1] = (int)v15;
      *(_DWORD *)(v8 + 8 * v11) = v15;
    }
  }
  else if ( v15 == (_DWORD *)v16 )
  {
    v12[1] = v18;
  }
  v19 = v14[3];
  *(_DWORD *)(v18 + 4) = v17;
  *(_DWORD *)v14[2] = v18;
  if ( v19 )
  {
    v20 = *(_DWORD *)(v19 + 4);
    if ( v20 != -1 )
    {
      v21 = v20 - 1;
      *(_DWORD *)(v19 + 4) = v21;
      if ( !v21 )
        sub_6E5DC((void **)v19);
    }
  }
  sub_6D518(v14);
  --*a1;
  return 0;
}
// 6BC74: variable 'v10' is possibly undefined
// 8A954: using guessed type _DWORD dword_8A954[29];

//----- (0006BD2C) --------------------------------------------------------
int __fastcall sub_6BD2C(_DWORD *a1)
{
  int result; // r0
  _DWORD *v3; // r2
  int v4; // r1
  _DWORD *v5; // r3
  _DWORD *v6; // r1

  sub_6B840((int)a1);
  v3 = a1 + 3;
  v4 = dword_8A954[a1[2]];
  if ( v4 )
  {
    v5 = (_DWORD *)a1[1];
    v6 = &v5[2 * v4];
    do
    {
      v5[1] = v3;
      *v5 = v3;
      v5 += 2;
    }
    while ( v6 != v5 );
  }
  a1[4] = v3;
  a1[3] = v3;
  *a1 = 0;
  return result;
}
// 8A954: using guessed type _DWORD dword_8A954[29];

//----- (0006BD80) --------------------------------------------------------
int __fastcall sub_6BD80(int a1)
{
  if ( *(_DWORD *)(a1 + 16) == a1 + 12 )
    return 0;
  else
    return *(_DWORD *)(a1 + 16);
}

//----- (0006BD98) --------------------------------------------------------
int __fastcall sub_6BD98(int a1, char *a2)
{
  char *v2; // r6
  int v3; // r3
  unsigned int v5; // r4
  int v6; // r0
  int v7; // t1
  int v8; // r1
  int result; // r0

  v2 = a2;
  v3 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v5 = 5381;
    do
    {
      v6 = v3 + 32 * v5;
      v7 = (unsigned __int8)*++a2;
      v3 = v7;
      v5 += v6;
    }
    while ( v7 );
  }
  else
  {
    v5 = 5381;
  }
  sub_772CC(v5, dword_8A954[*(_DWORD *)(a1 + 8)]);
  result = sub_6B7C4(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * v8), v2, v5);
  if ( result )
    result += 4;
  return result;
}
// 6BDF4: variable 'v8' is possibly undefined
// 8A954: using guessed type _DWORD dword_8A954[29];

//----- (0006BE08) --------------------------------------------------------
int __fastcall sub_6BE08(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 4) == a1 + 12 )
    return 0;
  else
    return *(_DWORD *)(a2 + 4);
}

//----- (0006BE20) --------------------------------------------------------
int __fastcall sub_6BE20(int a1)
{
  return a1 + 16;
}

//----- (0006BE28) --------------------------------------------------------
int __fastcall sub_6BE28(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (0006BE30) --------------------------------------------------------
int __fastcall sub_6BE30(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (0006BE38) --------------------------------------------------------
void __fastcall sub_6BE38(int a1, int a2)
{
  int v3; // r0
  int v4; // r3
  int v5; // r3

  v3 = *(_DWORD *)(a1 + 8);
  if ( !v3 || (v4 = *(_DWORD *)(v3 + 4), v4 == -1) || (v5 = v4 - 1, (*(_DWORD *)(v3 + 4) = v5) != 0) )
  {
    *(_DWORD *)(a1 + 8) = a2;
  }
  else
  {
    sub_6E5DC((void **)v3);
    *(_DWORD *)(a1 + 8) = a2;
  }
}

//----- (0006BE90) --------------------------------------------------------
int __fastcall sub_6BE90(_DWORD *a1)
{
  int v1; // r2
  int v2; // r3
  bool v3; // zf

  v1 = a1[1];
  v2 = *(unsigned __int8 *)(*a1 + v1);
  v3 = v2 == 0;
  if ( *(_BYTE *)(*a1 + v1) )
    ++v1;
  else
    v2 = -1;
  if ( !v3 )
    a1[1] = v1;
  return v2;
}

//----- (0006BEB4) --------------------------------------------------------
int __fastcall sub_6BEB4(int a1)
{
  __int64 v1; // r2

  v1 = *(_QWORD *)(a1 + 4);
  if ( HIDWORD(v1) >= (unsigned int)v1 )
    return -1;
  LODWORD(v1) = HIDWORD(v1) + 1;
  HIDWORD(v1) = *(unsigned __int8 *)(*(_DWORD *)a1 + HIDWORD(v1));
  *(_DWORD *)(a1 + 8) = v1;
  return HIDWORD(v1);
}

//----- (0006BED8) --------------------------------------------------------
int __fastcall sub_6BED8(_DWORD *a1)
{
  unsigned int v1; // r3
  int (__fastcall *v3)(_DWORD *, int, _DWORD); // r3
  int v4; // r0
  int result; // r0

  v1 = a1[257];
  if ( v1 < a1[256] )
    goto LABEL_4;
  v3 = (int (__fastcall *)(_DWORD *, int, _DWORD))a1[258];
  a1[257] = 0;
  v4 = v3(a1, 1024, a1[259]);
  a1[256] = v4;
  if ( (unsigned int)(v4 - 1) <= 0xFFFFFFFD )
  {
    v1 = a1[257];
LABEL_4:
    result = *((unsigned __int8 *)a1 + v1);
    a1[257] = v1 + 1;
    return result;
  }
  return -1;
}

//----- (0006BF34) --------------------------------------------------------
int sub_6BF34(int result, _DWORD *a2, const char *a3, ...)
{
  int v3; // r5
  const char *v5; // r0
  int v6; // r8
  int v7; // r6
  int v8; // r9
  char *v9; // r3
  char s[160]; // [sp+10h] [bp-144h] BYREF
  char v11[159]; // [sp+B0h] [bp-A4h] BYREF
  char v12; // [sp+14Fh] [bp-5h]
  const char *varg_r2; // [sp+170h] [bp+1Ch]
  va_list varg_r3; // [sp+174h] [bp+20h] BYREF

  va_start(varg_r3, a3);
  varg_r2 = a3;
  v3 = result;
  if ( result )
  {
    vsnprintf(s, 0xA0u, varg_r2, varg_r3);
    s[159] = 0;
    if ( a2 )
    {
      v5 = (const char *)sub_6D5F4((int)(a2 + 10));
      v6 = a2[6];
      v7 = a2[7];
      v8 = a2[9];
      if ( v5 && *v5 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v11, 0xA0u, "%s near '%s'", s, v5);
          v9 = v11;
          v12 = 0;
          return sub_74820(v3, v6, v7, v8, "%s", v9);
        }
      }
      else if ( a2[5] != -2 )
      {
        snprintf(v11, 0xA0u, "%s near end of file", s);
        v9 = v11;
        v12 = 0;
        return sub_74820(v3, v6, v7, v8, "%s", v9);
      }
      v9 = s;
    }
    else
    {
      v7 = -1;
      v9 = s;
      v8 = 0;
      v6 = -1;
    }
    return sub_74820(v3, v6, v7, v8, "%s", v9);
  }
  return result;
}

//----- (0006C054) --------------------------------------------------------
void __fastcall sub_6C054(int a1)
{
  if ( *(_DWORD *)(a1 + 52) == 256 )
  {
    sub_6D518(*(void **)(a1 + 56));
    sub_6D5B4(a1 + 40);
  }
  else
  {
    sub_6D5B4(a1 + 40);
  }
}

//----- (0006C088) --------------------------------------------------------
int __fastcall sub_6C088(_BYTE *a1)
{
  _BYTE *v1; // r3
  int result; // r0
  _BYTE *v3; // lr
  int v4; // r2
  int v5; // t1
  int v6; // r0
  int v7; // r1

  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "3rdparty/jansson-2.6/src/load.c", 0x120u, "decode_unicode_escape");
  v1 = a1;
  result = 0;
  v3 = v1 + 4;
  do
  {
    v5 = (unsigned __int8)*++v1;
    v4 = v5;
    v6 = 16 * result;
    v7 = v5 - 48;
    if ( (unsigned __int8)(v5 - 48) > 9u )
    {
      if ( (unsigned int)(v4 - 97) > 0x19 )
      {
        if ( (unsigned int)(v4 - 65) > 0x19 )
          _assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 0x12Cu, "decode_unicode_escape");
        result = v4 - 55 + v6;
      }
      else
      {
        result = v4 - 87 + v6;
      }
    }
    else
    {
      result = v7 + v6;
    }
  }
  while ( v1 != v3 );
  return result;
}

//----- (0006C134) --------------------------------------------------------
_DWORD *__fastcall sub_6C134(_DWORD *result, int a2)
{
  _DWORD *v2; // r4
  int v4; // r2
  int v5; // r3
  int v6; // r3

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    --result[9];
    if ( a2 == 10 )
    {
      v4 = result[8];
      --result[6];
      result[7] = v4;
    }
    else
    {
      result = (_DWORD *)sub_6DA38((unsigned __int8)a2);
      if ( result )
        --v2[7];
    }
    v5 = v2[4];
    if ( !v5 )
      _assert_fail("stream->buffer_pos > 0", "3rdparty/jansson-2.6/src/load.c", 0xE0u, "stream_unget");
    v6 = v5 - 1;
    v2[4] = v6;
    if ( *((unsigned __int8 *)v2 + v6 + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "3rdparty/jansson-2.6/src/load.c", 0xE2u, "stream_unget");
  }
  return result;
}

//----- (0006C1F0) --------------------------------------------------------
int __fastcall sub_6C1F0(int a1, int a2)
{
  int v2; // r2
  int v4; // r3
  int v5; // r6
  int v6; // r1
  int v8; // r0
  int v9; // r5
  int v11; // r3
  int v12; // r2
  int v13; // r0
  int v14; // r8
  _BYTE *v15; // r6
  _BYTE *v16; // r9
  int v17; // r2
  int v18; // r3

  v2 = *(_DWORD *)(a1 + 16);
  v4 = a1 + v2;
  v5 = *(unsigned __int8 *)(a1 + v2 + 8);
  if ( *(_BYTE *)(a1 + v2 + 8) )
  {
    v6 = v2 + 1;
    goto LABEL_8;
  }
  v8 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  v9 = v8;
  if ( v8 == -1 )
  {
    *(_DWORD *)(a1 + 20) = -1;
    return v9;
  }
  *(_DWORD *)(a1 + 16) = v5;
  *(_BYTE *)(a1 + 8) = v8;
  if ( (unsigned int)(v8 - 128) <= 0x7F )
  {
    v13 = sub_6DA38((unsigned __int8)v8);
    v14 = v13;
    if ( !v13 )
      goto LABEL_20;
    if ( v13 <= 1 )
      _assert_fail("count >= 2", "3rdparty/jansson-2.6/src/load.c", 0xAFu, "stream_get");
    v15 = (_BYTE *)(a1 + 9);
    v16 = (_BYTE *)(a1 + 8 + v13);
    do
      *v15++ = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    while ( v16 != v15 );
    if ( !sub_6DAA4((char *)(a1 + 8), v14, 0) )
    {
LABEL_20:
      v18 = v9;
      *(_DWORD *)(a1 + 20) = -2;
      v9 = -2;
      sub_6BF34(a2, (_DWORD *)a1, "unable to decode byte 0x%x", v18);
      return v9;
    }
    *(_BYTE *)(a1 + v14 + 8) = 0;
    v17 = *(_DWORD *)(a1 + 16);
    v6 = v17 + 1;
    v4 = a1 + v17;
  }
  else
  {
    v6 = 1;
    v4 = a1;
    *(_BYTE *)(a1 + 9) = v5;
  }
LABEL_8:
  *(_DWORD *)(a1 + 16) = v6;
  v9 = *(unsigned __int8 *)(v4 + 8);
  ++*(_DWORD *)(a1 + 36);
  if ( v9 != 10 )
  {
    if ( sub_6DA38(v9) )
      ++*(_DWORD *)(a1 + 28);
    return v9;
  }
  v11 = *(_DWORD *)(a1 + 24);
  v12 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = v11 + 1;
  *(_DWORD *)(a1 + 32) = v12;
  return 10;
}

//----- (0006C368) --------------------------------------------------------
int __fastcall sub_6C368(int a1, int a2)
{
  int v3; // r4

  v3 = *(_DWORD *)(a1 + 20);
  if ( !v3 )
    v3 = sub_6C1F0(a1, a2);
  if ( (unsigned int)(v3 + 2) > 1 )
    fh_buffer_putc((const void **)(a1 + 40), v3);
  return v3;
}

//----- (0006C3A8) --------------------------------------------------------
_DWORD *__fastcall sub_6C3A8(_DWORD *result, int a2)
{
  _DWORD *v2; // r5
  char v4; // r1
  int v5; // r2

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    sub_6C134(result, a2);
    result = (_DWORD *)sub_6D728(v2 + 10, v4, v5);
    if ( result != (_DWORD *)a2 )
      _assert_fail("c == d", "3rdparty/jansson-2.6/src/load.c", 0x10Cu, "lex_unget_unsave");
  }
  return result;
}
// 6C3C8: variable 'v4' is possibly undefined
// 6C3C8: variable 'v5' is possibly undefined

//----- (0006C3F4) --------------------------------------------------------
unsigned int __fastcall sub_6C3F4(int a1, int a2)
{
  const void **v2; // r7
  unsigned int v5; // r4
  bool v6; // cc
  int v7; // r3
  int v8; // r4
  bool v9; // zf
  _BOOL4 v10; // r2
  bool v11; // cc
  char i; // r1
  int v13; // r3
  int v14; // r2
  int v16; // r0
  const char *v17; // r4
  int v18; // r0
  bool v19; // zf
  int v20; // r1
  double v21; // r2
  int v22; // r1
  int v23; // r0
  unsigned int v24; // r4
  int v25; // r0
  bool v26; // zf
  unsigned int v27; // r3
  const char *v28; // r4
  int *v29; // r7
  __int64 v30; // r0
  int v31; // r1
  int v32; // r0
  const char *v33; // r2
  _BYTE *v34; // r4
  unsigned __int8 *j; // r7
  int v36; // r3
  unsigned int v37; // r3
  int v38; // r8
  unsigned int v39; // r3
  unsigned int v40; // r4
  bool v41; // cc
  int v42; // r0
  unsigned __int8 *v43; // r11
  int v44; // r3
  int v45; // r0
  const char *v46; // r2
  int v47; // [sp+8h] [bp-1Ch]
  int v48; // [sp+Ch] [bp-18h]
  char src[4]; // [sp+14h] [bp-10h] BYREF
  double endptr; // [sp+18h] [bp-Ch] BYREF

  v2 = (const void **)(a1 + 40);
  sub_6D5E0(a1 + 40);
  if ( *(_DWORD *)(a1 + 52) == 256 )
  {
    sub_6D518(*(void **)(a1 + 56));
    *(_DWORD *)(a1 + 56) = 0;
  }
  do
  {
    v5 = *(_DWORD *)(a1 + 20);
    if ( !v5 )
      v5 = sub_6C1F0(a1, a2);
    v6 = v5 > 0x20;
    if ( v5 != 32 )
      v6 = v5 - 9 > 1;
    v7 = !v6;
  }
  while ( !v6 || v5 == 13 );
  if ( v5 == -1 )
  {
    *(_DWORD *)(a1 + 52) = v7;
    return v7;
  }
  if ( v5 == -2 )
    goto LABEL_31;
  fh_buffer_putc(v2, v5);
  if ( (((v5 & 0xFFFFFFDF) - 91) & 0xFFFFFFFD) == 0 )
    goto LABEL_34;
  v9 = v5 == 44;
  if ( v5 != 44 )
    v9 = v5 == 58;
  v10 = v9;
  if ( v9 )
    goto LABEL_34;
  if ( v5 != 34 )
  {
    v11 = v5 > 0x2D;
    if ( v5 != 45 )
      v11 = v5 - 48 > 9;
    if ( !v11 )
    {
      *(_DWORD *)(a1 + 52) = -1;
      if ( v5 == 45 )
      {
        v32 = sub_6C368(a1, a2);
        v31 = v32;
        if ( v32 != 48 )
        {
          if ( (unsigned int)(v32 - 48) > 9 )
            goto LABEL_86;
          goto LABEL_44;
        }
      }
      else if ( v5 != 48 )
      {
        do
LABEL_44:
          v18 = sub_6C368(a1, a2);
        while ( (unsigned int)(v18 - 48) <= 9 );
        goto LABEL_45;
      }
      v18 = sub_6C368(a1, a2);
      if ( (unsigned int)(v18 - 48) <= 9 )
      {
LABEL_85:
        v31 = v18;
LABEL_86:
        sub_6C3A8((_DWORD *)a1, v31);
        return *(_DWORD *)(a1 + 52);
      }
LABEL_45:
      v19 = v18 == 46;
      if ( v18 != 46 )
        v19 = v18 == 69;
      if ( v19 )
      {
        if ( v18 == 46 )
        {
          v20 = *(_DWORD *)(a1 + 20);
          if ( !v20 )
            v20 = sub_6C1F0(a1, a2);
          if ( (unsigned int)(v20 - 48) > 9 )
          {
            sub_6C134((_DWORD *)a1, v20);
            return *(_DWORD *)(a1 + 52);
          }
          fh_buffer_putc(v2, v20);
          do
            v18 = sub_6C368(a1, a2);
          while ( (unsigned int)(v18 - 48) <= 9 );
        }
        if ( (v18 & 0xFFFFFFDF) != 0x45 )
          goto LABEL_56;
      }
      else if ( v18 != 101 )
      {
        sub_6C3A8((_DWORD *)a1, v18);
        v28 = (const char *)sub_6D5F4((int)v2);
        v29 = _errno_location();
        *v29 = 0;
        v30 = strtoll(v28, (char **)&endptr, 10);
        if ( *v29 == 34 )
        {
          if ( v30 >= 0 )
            LOWORD(v46) = -21576;
          else
            LOWORD(v46) = -21604;
          HIWORD(v46) = 8;
          sub_6BF34(a2, (_DWORD *)a1, v46, HIDWORD(v30));
          return *(_DWORD *)(a1 + 52);
        }
        else
        {
          if ( (const char *)LODWORD(endptr) != &v28[*(_DWORD *)(a1 + 44)] )
            _assert_fail(
              "end == saved_text + lex->saved_text.length",
              "3rdparty/jansson-2.6/src/load.c",
              0x206u,
              "lex_scan_number");
          v8 = 257;
          *(_QWORD *)(a1 + 56) = v30;
          *(_DWORD *)(a1 + 52) = 257;
        }
        return v8;
      }
      v18 = sub_6C368(a1, a2);
      if ( ((v18 - 43) & 0xFFFFFFFD) == 0 )
        v18 = sub_6C368(a1, a2);
      if ( (unsigned int)(v18 - 48) <= 9 )
      {
        do
          v18 = sub_6C368(a1, a2);
        while ( (unsigned int)(v18 - 48) <= 9 );
LABEL_56:
        sub_6C3A8((_DWORD *)a1, v18);
        if ( sub_6D750((int)v2, &endptr) )
        {
          sub_6BF34(a2, (_DWORD *)a1, "real number overflow");
          return *(_DWORD *)(a1 + 52);
        }
        else
        {
          v21 = endptr;
          v8 = 258;
          *(_DWORD *)(a1 + 52) = 258;
          *(double *)(a1 + 56) = v21;
        }
        return v8;
      }
      goto LABEL_85;
    }
    if ( (v5 & 0xFFFFFFDF) - 65 > 0x19 )
    {
      for ( i = *(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8); i; i = *(_BYTE *)(a1 + v13 + 8) )
      {
        fh_buffer_putc(v2, i);
        v13 = *(_DWORD *)(a1 + 16) + 1;
        v14 = *(_DWORD *)(a1 + 36) + 1;
        *(_DWORD *)(a1 + 16) = v13;
        *(_DWORD *)(a1 + 36) = v14;
      }
      goto LABEL_31;
    }
    do
      v16 = sub_6C368(a1, a2);
    while ( (v16 & 0xFFFFFFDF) - 65 <= 0x19 );
    sub_6C3A8((_DWORD *)a1, v16);
    v17 = (const char *)sub_6D5F4((int)v2);
    if ( !strcmp(v17, "true") )
    {
      v8 = 259;
      *(_DWORD *)(a1 + 52) = 259;
      return v8;
    }
    if ( strcmp(v17, "false") )
    {
      if ( !strcmp(v17, "null") )
      {
        v8 = 261;
        *(_DWORD *)(a1 + 52) = 261;
        return v8;
      }
LABEL_31:
      v8 = -1;
      *(_DWORD *)(a1 + 52) = -1;
      return v8;
    }
    v5 = 260;
LABEL_34:
    *(_DWORD *)(a1 + 52) = v5;
    return v5;
  }
  *(_DWORD *)(a1 + 56) = v10;
  *(_DWORD *)(a1 + 52) = -1;
LABEL_59:
  v22 = a2;
  v23 = a1;
  while ( 1 )
  {
    v24 = sub_6C368(v23, v22);
LABEL_61:
    if ( v24 == 34 )
    {
      v34 = sub_6D500((void *)(*(_DWORD *)(a1 + 44) + 1));
      *(_DWORD *)(a1 + 56) = v34;
      if ( !v34 )
        goto LABEL_74;
      for ( j = (unsigned __int8 *)(sub_6D5F4((int)v2) + 1); ; j += 2 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v36 = *j;
            if ( v36 == 34 )
            {
              *v34 = 0;
              v8 = 256;
              *(_DWORD *)(a1 + 52) = 256;
              return v8;
            }
            if ( v36 == 92 )
              break;
            *v34 = v36;
            ++j;
            ++v34;
          }
          v37 = j[1];
          if ( v37 != 117 )
            break;
          v42 = sub_6C088(j + 1);
          v43 = j + 6;
          v44 = v42;
          v48 = v42 - 55296;
          if ( (unsigned int)(v42 - 55296) >= 0x400 )
          {
            if ( (unsigned int)(v42 - 56320) < 0x400 )
              goto LABEL_145;
            if ( !v42 )
            {
              sub_6BF34(a2, (_DWORD *)a1, "\\u0000 is not allowed", 0);
              goto LABEL_74;
            }
          }
          else
          {
            if ( j[6] != 92 || j[7] != 117 )
            {
LABEL_145:
              sub_6BF34(a2, (_DWORD *)a1, "invalid Unicode '\\u%04X'", v42);
              goto LABEL_74;
            }
            v47 = v42;
            v45 = sub_6C088(j + 7);
            v43 = j + 12;
            if ( (unsigned int)(v45 - 56320) >= 0x400 )
            {
              sub_6BF34(a2, (_DWORD *)a1, "invalid Unicode '\\u%04X\\u%04X'", v47, v45);
              goto LABEL_74;
            }
            v44 = v45 - 56320 + (v48 << 10) + 0x10000;
          }
          if ( sub_6D94C(v44, src, &endptr) )
            _assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 0x1AEu, "lex_scan_string");
          j = v43;
          memcpy(v34, src, LODWORD(endptr));
          v34 += LODWORD(endptr);
        }
        if ( v37 == 98 )
        {
          *v34 = 8;
        }
        else
        {
          if ( v37 <= 0x62 )
          {
            if ( v37 != 47 && v37 != 92 && v37 != 34 )
LABEL_123:
              _assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 0x1BCu, "lex_scan_string");
            goto LABEL_118;
          }
          if ( v37 == 110 )
          {
            *v34 = 10;
          }
          else
          {
            if ( v37 <= 0x6E )
            {
              if ( v37 != 102 )
                goto LABEL_123;
              LOBYTE(v37) = 12;
LABEL_118:
              *v34 = v37;
              goto LABEL_108;
            }
            if ( v37 == 114 )
            {
              *v34 = 13;
            }
            else
            {
              if ( v37 != 116 )
                goto LABEL_123;
              *v34 = 9;
            }
          }
        }
LABEL_108:
        ++v34;
      }
    }
    if ( v24 == -2 )
      goto LABEL_74;
    if ( v24 == -1 )
    {
      sub_6BF34(a2, (_DWORD *)a1, "premature end of input");
      goto LABEL_74;
    }
    if ( v24 <= 0x1F )
      break;
    v22 = a2;
    v23 = a1;
    if ( v24 == 92 )
    {
      v25 = sub_6C368(a1, a2);
      if ( v25 == 117 )
      {
        v38 = 4;
        v24 = sub_6C368(a1, a2);
        while ( 1 )
        {
          v39 = v24 & 0xFFFFFFDF;
          v40 = v24 - 48;
          v27 = v39 - 65;
          v41 = v27 > 5;
          if ( v27 > 5 )
            v41 = v40 > 9;
          if ( v41 )
            break;
          --v38;
          v24 = sub_6C368(a1, a2);
          if ( !v38 )
            goto LABEL_61;
        }
LABEL_73:
        sub_6BF34(a2, (_DWORD *)a1, "invalid escape", v27);
        goto LABEL_74;
      }
      v26 = v25 == 92;
      if ( v25 != 92 )
        v26 = (v25 & 0xFFFFFFBF) == 34;
      if ( !v26 && v25 != 47 && (v25 & 0xFFFFFFF7) != 0x66 )
      {
        v27 = (v25 - 114) & 0xFFFFFFFD;
        if ( v27 )
          goto LABEL_73;
      }
      goto LABEL_59;
    }
  }
  sub_6C3A8((_DWORD *)a1, v24);
  if ( v24 == 10 )
    LOWORD(v33) = -21748;
  else
    LOWORD(v33) = -21728;
  HIWORD(v33) = 8;
  sub_6BF34(a2, (_DWORD *)a1, v33, v24);
LABEL_74:
  sub_6D518(*(void **)(a1 + 56));
  return *(_DWORD *)(a1 + 52);
}

//----- (0006CBB0) --------------------------------------------------------
double *__fastcall sub_6CBB0(int a1, int a2, int a3)
{
  int v4; // r3
  void **v7; // r6
  int v9; // r3
  void *v10; // r8
  int v11; // r0
  int v12; // r7
  int v13; // r3
  int v14; // r3
  int v15; // r3
  int v16; // r3
  char *v17; // r3
  char *v18; // r3
  int v19; // r3
  int v20; // r0
  int v21; // r3
  int v22; // r3
  void **v23; // r0
  int v24; // r3
  double v25; // [sp+0h] [bp-Ch] BYREF

  v4 = *(_DWORD *)(a1 + 52);
  if ( v4 == 257 )
  {
    if ( (a2 & 8) == 0 )
      return (double *)sub_6E400(*(_QWORD *)(a1 + 56));
    if ( !sub_6D750(a1 + 40, &v25) )
      return sub_6E480();
    sub_6BF34(a3, (_DWORD *)a1, "real number overflow");
    return 0;
  }
  if ( v4 <= 257 )
  {
    if ( v4 == 91 )
    {
      v7 = (void **)sub_6E144();
      if ( v7 )
      {
        sub_6C3F4(a1, a3);
        v19 = *(_DWORD *)(a1 + 52);
        if ( v19 == 93 )
          return (double *)v7;
        if ( v19 )
        {
          while ( 1 )
          {
            v12 = sub_6CBB0(a1, a2, a3);
            if ( !v12 )
              break;
            if ( *(_DWORD *)(v12 + 4) != -1 )
              ++*(_DWORD *)(v12 + 4);
            v20 = sub_6ED4C(v7, (void **)v12);
            v21 = *(_DWORD *)(v12 + 4);
            if ( v20 )
            {
              if ( v21 != -1 )
              {
LABEL_65:
                v24 = v21 - 1;
                *(_DWORD *)(v12 + 4) = v24;
                if ( !v24 )
                  sub_6E5DC((void **)v12);
              }
              goto LABEL_33;
            }
            if ( v21 != -1 )
            {
              *(_DWORD *)(v12 + 4) = v21 - 1;
              if ( v21 == 1 )
                sub_6E5DC((void **)v12);
            }
            sub_6C3F4(a1, a3);
            v22 = *(_DWORD *)(a1 + 52);
            if ( v22 != 44 )
            {
              if ( v22 == 93 )
                return (double *)v7;
              goto LABEL_63;
            }
            sub_6C3F4(a1, a3);
            if ( !*(_DWORD *)(a1 + 52) )
              goto LABEL_63;
          }
        }
        else
        {
LABEL_63:
          sub_6BF34(a3, (_DWORD *)a1, "']' expected");
        }
        goto LABEL_33;
      }
    }
    else if ( v4 <= 91 )
    {
      if ( v4 != -1 )
        goto LABEL_41;
      sub_6BF34(a3, (_DWORD *)a1, "invalid token");
    }
    else
    {
      if ( v4 != 123 )
      {
        if ( v4 == 256 )
          return (double *)sub_6E2B0(*(const char **)(a1 + 56));
        goto LABEL_41;
      }
      v7 = (void **)sub_6DF5C();
      if ( v7 )
      {
        sub_6C3F4(a1, a3);
        v9 = *(_DWORD *)(a1 + 52);
        if ( v9 == 125 )
          return (double *)v7;
        if ( v9 != 256 )
        {
LABEL_67:
          sub_6BF34(a3, (_DWORD *)a1, "string or '}' expected");
          goto LABEL_33;
        }
        v10 = *(void **)(a1 + 56);
        *(_DWORD *)(a1 + 56) = 0;
        if ( v10 )
        {
          while ( 1 )
          {
            if ( (a2 & 1) != 0 && sub_6DFCC(v7, (char *)v10) )
            {
              sub_6D518(v10);
              sub_6BF34(a3, (_DWORD *)a1, "duplicate object key");
              goto LABEL_33;
            }
            sub_6C3F4(a1, a3);
            if ( *(_DWORD *)(a1 + 52) != 58 )
            {
              sub_6D518(v10);
              sub_6BF34(a3, (_DWORD *)a1, "':' expected");
              goto LABEL_33;
            }
            sub_6C3F4(a1, a3);
            v11 = sub_6CBB0(a1, a2, a3);
            v12 = v11;
            if ( !v11 )
            {
              sub_6D518(v10);
              goto LABEL_33;
            }
            v13 = *(_DWORD *)(v11 + 4);
            if ( v13 != -1 )
              *(_DWORD *)(v11 + 4) = v13 + 1;
            if ( sub_6E894(v7, (char *)v10, v11) )
            {
              sub_6D518(v10);
              v21 = *(_DWORD *)(v12 + 4);
              if ( v21 != -1 )
                goto LABEL_65;
              goto LABEL_33;
            }
            v14 = *(_DWORD *)(v12 + 4);
            if ( v14 != -1 )
            {
              v15 = v14 - 1;
              *(_DWORD *)(v12 + 4) = v15;
              if ( !v15 )
                sub_6E5DC((void **)v12);
            }
            sub_6D518(v10);
            sub_6C3F4(a1, a3);
            v16 = *(_DWORD *)(a1 + 52);
            if ( v16 != 44 )
              break;
            sub_6C3F4(a1, a3);
            if ( *(_DWORD *)(a1 + 52) != 256 )
              goto LABEL_67;
            v10 = *(void **)(a1 + 56);
            *(_DWORD *)(a1 + 56) = 0;
            if ( !v10 )
              return 0;
          }
          if ( v16 == 125 )
            return (double *)v7;
          sub_6BF34(a3, (_DWORD *)a1, "'}' expected");
LABEL_33:
          v17 = (char *)v7[1];
          if ( v17 != (char *)-1 )
          {
            v18 = v17 - 1;
            v7[1] = v18;
            if ( !v18 )
            {
              v23 = v7;
              v7 = 0;
              sub_6E5DC(v23);
              return (double *)v7;
            }
          }
        }
      }
    }
    return 0;
  }
  if ( v4 == 259 )
    return (double *)sub_6E5B8();
  if ( v4 < 259 )
    return sub_6E480();
  if ( v4 == 260 )
    return (double *)sub_6E5C4();
  if ( v4 == 261 )
    return (double *)sub_6E5D0();
LABEL_41:
  sub_6BF34(a3, (_DWORD *)a1, "unexpected token");
  return 0;
}
// 6CBB0: too many cbuild loops

//----- (0006D034) --------------------------------------------------------
double *__fastcall sub_6D034(_DWORD *a1, int a2, int a3)
{
  double *v6; // r7
  int v8; // r3
  int v9; // r3
  void **v10; // r0

  sub_6C3F4((int)a1, a3);
  v6 = (double *)(a2 & 4);
  if ( (a2 & 4) == 0 && (a1[13] & 0xFFFFFFDF) != 0x5B )
  {
    sub_6BF34(a3, a1, "'[' or '{' expected");
    return v6;
  }
  v6 = sub_6CBB0((int)a1, a2, a3);
  if ( !v6 )
    return 0;
  if ( (a2 & 2) == 0 )
  {
    sub_6C3F4((int)a1, a3);
    if ( a1[13] )
    {
      sub_6BF34(a3, a1, "end of file expected");
      v8 = *((_DWORD *)v6 + 1);
      if ( v8 != -1 )
      {
        v9 = v8 - 1;
        *((_DWORD *)v6 + 1) = v9;
        if ( !v9 )
        {
          v10 = (void **)v6;
          v6 = 0;
          sub_6E5DC(v10);
          return v6;
        }
      }
      return 0;
    }
  }
  if ( a3 )
    *(_DWORD *)(a3 + 8) = a1[9];
  return v6;
}

//----- (0006D110) --------------------------------------------------------
double *__fastcall sub_6D110(int a1, int a2, char *a3)
{
  double *v6; // r4
  _DWORD v8[2]; // [sp+0h] [bp-4Ch] BYREF
  _DWORD v9[2]; // [sp+8h] [bp-44h] BYREF
  char v10; // [sp+10h] [bp-3Ch]
  int v11; // [sp+18h] [bp-34h]
  int v12; // [sp+1Ch] [bp-30h]
  int v13; // [sp+20h] [bp-2Ch]
  int v14; // [sp+24h] [bp-28h]
  int v15; // [sp+2Ch] [bp-20h]
  _DWORD v16[7]; // [sp+30h] [bp-1Ch] BYREF

  sub_747D0(a3, "<string>");
  if ( a1 )
  {
    v6 = 0;
    v8[0] = a1;
    v9[0] = sub_6BE90;
    v8[1] = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v9[1] = v8;
    v13 = 1;
    if ( !sub_6D580(v16) )
    {
      v16[3] = -1;
      v6 = sub_6D034(v9, a2, (int)a3);
      sub_6C054((int)v9);
    }
  }
  else
  {
    sub_6BF34((int)a3, 0, "wrong arguments");
    return 0;
  }
  return v6;
}

//----- (0006D1D0) --------------------------------------------------------
double *__fastcall sub_6D1D0(int a1, int a2, int a3, char *a4)
{
  double *v8; // r4
  _DWORD v10[3]; // [sp+4h] [bp-4Ch] BYREF
  _DWORD v11[2]; // [sp+10h] [bp-40h] BYREF
  char v12; // [sp+18h] [bp-38h]
  int v13; // [sp+20h] [bp-30h]
  int v14; // [sp+24h] [bp-2Ch]
  int v15; // [sp+28h] [bp-28h]
  int v16; // [sp+2Ch] [bp-24h]
  int v17; // [sp+34h] [bp-1Ch]
  _DWORD v18[6]; // [sp+38h] [bp-18h] BYREF

  sub_747D0(a4, "<buffer>");
  if ( a1 )
  {
    v8 = 0;
    v10[0] = a1;
    v10[1] = a2;
    v11[0] = sub_6BEB4;
    v10[2] = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v16 = 0;
    v17 = 0;
    v11[1] = v10;
    v15 = 1;
    if ( !sub_6D580(v18) )
    {
      v18[3] = -1;
      v8 = sub_6D034(v11, a3, (int)a4);
      sub_6C054((int)v11);
    }
  }
  else
  {
    sub_6BF34((int)a4, 0, "wrong arguments");
    return 0;
  }
  return v8;
}

//----- (0006D29C) --------------------------------------------------------
double *__fastcall sub_6D29C(int a1, int a2, char *a3)
{
  char *v6; // r1
  double *v7; // r4
  _DWORD v9[2]; // [sp+0h] [bp-44h] BYREF
  char v10; // [sp+8h] [bp-3Ch]
  int v11; // [sp+10h] [bp-34h]
  int v12; // [sp+14h] [bp-30h]
  int v13; // [sp+18h] [bp-2Ch]
  int v14; // [sp+1Ch] [bp-28h]
  int v15; // [sp+24h] [bp-20h]
  _DWORD v16[7]; // [sp+28h] [bp-1Ch] BYREF

  if ( stdin == a1 )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  sub_747D0(a3, v6);
  if ( a1 )
  {
    v7 = 0;
    v9[1] = a1;
    v9[0] = fgetc;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !sub_6D580(v16) )
    {
      v16[3] = -1;
      v7 = sub_6D034(v9, a2, (int)a3);
      sub_6C054((int)v9);
    }
  }
  else
  {
    sub_6BF34((int)a3, 0, "wrong arguments");
    return 0;
  }
  return v7;
}
// 9F7D0: using guessed type int stdin;

//----- (0006D374) --------------------------------------------------------
double *__fastcall sub_6D374(char *a1, int a2, char *a3)
{
  int v6; // r0
  FILE *v7; // r7
  double *v8; // r6
  int *v10; // r0
  char *v11; // r0

  sub_747D0(a3, a1);
  if ( a1 )
  {
    v6 = fopen64(a1, "rb");
    v7 = (FILE *)v6;
    if ( v6 )
    {
      v8 = sub_6D29C(v6, a2, a3);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      sub_6BF34((int)a3, 0, "unable to open %s: %s", a1, v11);
    }
  }
  else
  {
    sub_6BF34((int)a3, 0, "wrong arguments");
    return 0;
  }
  return v8;
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0006D500) --------------------------------------------------------
void *__fastcall sub_6D500(void *result)
{
  if ( result )
    return off_9F5A4((size_t)result);
  return result;
}
// 9F5A4: using guessed type void *(*off_9F5A4)(size_t size);

//----- (0006D518) --------------------------------------------------------
void __fastcall sub_6D518(void *a1)
{
  if ( a1 )
    off_9F5A8(a1);
}
// 9F5A8: using guessed type void (*off_9F5A8)(void *ptr);

//----- (0006D530) --------------------------------------------------------
void *__fastcall sub_6D530(const char *a1)
{
  size_t v2; // r4
  void *v3; // r0
  void *v4; // r5

  v2 = strlen(a1) + 1;
  v3 = off_9F5A4(v2);
  v4 = v3;
  if ( v3 )
    memcpy(v3, a1, v2);
  return v4;
}
// 9F5A4: using guessed type void *(*off_9F5A4)(size_t size);

//----- (0006D570) --------------------------------------------------------
int __fastcall sub_6D570(__int64 a1)
{
  *(_QWORD *)&off_9F5A4 = a1;
  return a1;
}
// 9F5A4: using guessed type void *(*off_9F5A4)(size_t size);

//----- (0006D580) --------------------------------------------------------
int __fastcall sub_6D580(_DWORD *a1)
{
  _BYTE *v2; // r0

  a1[2] = 16;
  a1[1] = 0;
  v2 = sub_6D500((void *)0x10);
  *a1 = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (0006D5B4) --------------------------------------------------------
void __fastcall sub_6D5B4(int a1)
{
  void *v2; // r0

  v2 = *(void **)a1;
  if ( v2 )
    sub_6D518(v2);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
}

//----- (0006D5E0) --------------------------------------------------------
int __fastcall sub_6D5E0(int result)
{
  _BYTE *v1; // r2

  v1 = *(_BYTE **)result;
  *(_DWORD *)(result + 4) = 0;
  *v1 = 0;
  return result;
}

//----- (0006D5F4) --------------------------------------------------------
int __fastcall sub_6D5F4(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0006D5FC) --------------------------------------------------------
int __fastcall sub_6D5FC(int *a1)
{
  int result; // r0

  result = *a1;
  *a1 = 0;
  return result;
}

//----- (0006D610) --------------------------------------------------------
int __fastcall sub_6D610(const void **a1, void *src, size_t n)
{
  unsigned int v4; // r3
  size_t v7; // r0
  char *v8; // r8
  unsigned int v9; // r3
  unsigned int v10; // r0
  void *v11; // r6
  char *v12; // r0
  char *v13; // r2
  size_t v15; // r5

  v4 = (unsigned int)a1[2];
  v7 = (size_t)a1[1];
  if ( v4 - v7 > n )
  {
    v8 = (char *)*a1;
LABEL_10:
    memcpy(&v8[v7], src, n);
    v13 = (char *)*a1;
    v15 = (size_t)a1[1] + n;
    a1[1] = (const void *)v15;
    v13[v15] = 0;
    return 0;
  }
  if ( !((n == -1) | (v4 >> 31)) && -2 - n >= v7 )
  {
    v9 = 2 * v4;
    v10 = n + 1 + v7;
    v11 = (void *)(v10 < v9 ? v9 : v10);
    v12 = (char *)sub_6D500(v11);
    v8 = v12;
    if ( v12 )
    {
      memcpy(v12, *a1, (size_t)a1[1]);
      sub_6D518((void *)*a1);
      v7 = (size_t)a1[1];
      *a1 = v8;
      a1[2] = v11;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (0006D6DC) --------------------------------------------------------
int __fastcall sub_6D6DC(const void **a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  return sub_6D610(a1, s, v4);
}

//----- (0006D704) --------------------------------------------------------
int __fastcall fh_buffer_putc(const void **a1, char a2)
{
  char v3; // [sp+7h] [bp-5h] BYREF

  v3 = a2;
  return sub_6D610(a1, &v3, 1u);
}

//----- (0006D728) --------------------------------------------------------
int __fastcall sub_6D728(int *a1, char a2, int a3)
{
  int v3; // r3
  bool v4; // zf
  int result; // r0

  v3 = a1[1];
  v4 = v3 == 0;
  if ( v3 )
  {
    a3 = *a1;
    --v3;
    a2 = 0;
    a1[1] = v3;
    result = *(unsigned __int8 *)(a3 + v3);
  }
  else
  {
    result = 0;
  }
  if ( !v4 )
    *(_BYTE *)(a3 + v3) = a2;
  return result;
}

//----- (0006D750) --------------------------------------------------------
int __fastcall sub_6D750(int a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *endptr; // [sp+4h] [bp-8h] BYREF

  v5 = localeconv();
  v6 = *(const char **)a1;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*(const char **)a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *(const char **)a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( endptr != (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) )
    _assert_fail(
      "end == strbuffer->value + strbuffer->length",
      "3rdparty/jansson-2.6/src/strconv.c",
      0x46u,
      "jsonp_strtod");
  result = *v9 == 34 && v2 != 0.0;
  if ( result )
    return -1;
  *a2 = v2;
  return result;
}
// 6D7E0: variable 'v2' is possibly undefined

//----- (0006D818) --------------------------------------------------------
int __fastcall sub_6D818(char *a1, size_t a2)
{
  double v2; // d0
  unsigned int v5; // r0
  unsigned int v6; // r6
  int v7; // r1
  char *v8; // r0
  char *v9; // r5
  char *v10; // r0
  unsigned __int8 *v11; // r4
  int v12; // r3
  _BYTE *v13; // r5
  int v14; // t1
  size_t v15; // r2
  char *v17; // r3

  v5 = snprintf(a1, a2, "%.17g", v2);
  if ( a2 > v5 )
  {
    v6 = v5;
    v7 = *(unsigned __int8 *)localeconv()->decimal_point;
    if ( v7 != 46 )
    {
      v8 = strchr(a1, v7);
      if ( v8 )
        *v8 = 46;
    }
    v9 = strchr(a1, 46);
    v10 = strchr(a1, 101);
    if ( v9 )
    {
LABEL_6:
      if ( !v10 )
        return v6;
      goto LABEL_7;
    }
    if ( v10 )
    {
LABEL_7:
      v11 = (unsigned __int8 *)(v10 + 2);
      v12 = (unsigned __int8)v10[2];
      if ( v10[1] != 45 )
      {
        v13 = v10 + 1;
        if ( v12 != 48 )
        {
LABEL_10:
          if ( v11 != v13 )
          {
            v15 = v6 - (v11 - (unsigned __int8 *)a1);
            v6 -= v11 - v13;
            memmove(v13, v11, v15);
          }
          return v6;
        }
        do
LABEL_9:
          v14 = *++v11;
        while ( v14 == 48 );
        goto LABEL_10;
      }
      if ( v12 == 48 )
      {
        v13 = v10 + 2;
        goto LABEL_9;
      }
      return v6;
    }
    if ( v6 + 3 < a2 )
    {
      a1[v6] = 46;
      v17 = &a1[v6];
      v6 += 2;
      v17[1] = 48;
      a1[v6] = 0;
      v10 = strchr(a1, 101);
      goto LABEL_6;
    }
  }
  return -1;
}
// 6D834: variable 'v2' is possibly undefined

//----- (0006D94C) --------------------------------------------------------
int __fastcall sub_6D94C(int a1, _BYTE *a2, _DWORD *a3)
{
  char v3; // r3
  char v5; // r3
  char v6; // r3
  int v7; // r12

  if ( a1 < 0 )
    return -1;
  if ( a1 <= 127 )
  {
    *a2 = a1;
    *a3 = 1;
    return 0;
  }
  else if ( a1 < 2048 )
  {
    v5 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 6) - 64;
    a2[1] = v5;
    *a3 = 2;
    return 0;
  }
  else if ( a1 < 0x10000 )
  {
    v6 = (a1 & 0x3F) + 0x80;
    v7 = (((unsigned int)a1 >> 6) & 0x3F) - 128;
    *a2 = (a1 >> 12) - 32;
    a2[1] = v7;
    a2[2] = v6;
    *a3 = 3;
    return 0;
  }
  else if ( a1 >= 1114112 )
  {
    return -1;
  }
  else
  {
    v3 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 18) - 16;
    a2[1] = (((unsigned int)a1 >> 12) & 0x3F) + 0x80;
    a2[2] = (((unsigned int)a1 >> 6) & 0x3F) + 0x80;
    a2[3] = v3;
    *a3 = 4;
    return 0;
  }
}

//----- (0006DA38) --------------------------------------------------------
int __fastcall sub_6DA38(int a1)
{
  if ( (a1 & 0x80) == 0 )
    return 1;
  if ( (a1 ^ 0x80u) <= 0x41 )
    return 0;
  if ( (unsigned __int8)(a1 + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(a1 + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(a1 + 16) <= 4u )
    return 4;
  return 0;
}

//----- (0006DAA4) --------------------------------------------------------
int __fastcall sub_6DAA4(char *a1, int a2, int *a3)
{
  char v3; // lr
  int v4; // lr
  int result; // r0
  int v6; // r3
  _BYTE *v7; // r0
  int v8; // r12
  int v9; // t1
  bool v10; // zf
  _BOOL4 v11; // r3
  _BOOL4 v12; // r1

  v3 = *a1;
  switch ( a2 )
  {
    case 2:
      v4 = v3 & 0x1F;
      break;
    case 3:
      v4 = v3 & 0xF;
      break;
    case 4:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = (unsigned __int8)a1[1];
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = a1 + 1;
  v8 = 1;
  while ( 1 )
  {
    ++v8;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( a2 <= v8 )
      break;
    v9 = (unsigned __int8)*++v7;
    LOBYTE(v6) = v9;
    if ( (v9 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) < 0x800 )
    return 0;
  v10 = v4 == 127;
  if ( v4 <= 127 )
    v10 = a2 == 2;
  result = v10;
  if ( v10 )
    return 0;
  v11 = a2 == 3;
  if ( v4 >= 2048 )
    v11 = 0;
  if ( !v11 )
  {
    v12 = a2 == 4;
    if ( v4 >= 0x10000 )
      v12 = 0;
    if ( !v12 )
    {
      result = 1;
      if ( a3 )
        *a3 = v4;
      return result;
    }
    return 0;
  }
  return result;
}

//----- (0006DB8C) --------------------------------------------------------
char *__fastcall sub_6DB8C(char *result, _DWORD *a2)
{
  char *v2; // r4
  int v4; // r0
  int v5; // r2
  int v6; // r6
  int v7; // [sp+4h] [bp-14h] BYREF

  if ( *result )
  {
    v2 = result;
    v4 = sub_6DA38((unsigned __int8)*result);
    v6 = v4;
    if ( v4 > 0 )
    {
      if ( v4 == 1 )
      {
        v7 = v5;
        goto LABEL_6;
      }
      if ( sub_6DAA4(v2, v4, &v7) )
      {
LABEL_6:
        result = &v2[v6];
        if ( a2 )
          *a2 = v7;
        return result;
      }
    }
    return 0;
  }
  return result;
}
// 6DBBC: variable 'v5' is possibly undefined

//----- (0006DBFC) --------------------------------------------------------
int __fastcall sub_6DBFC(const char *a1, signed int a2)
{
  signed int v3; // r8
  int v4; // r4
  int v5; // r5
  char *v6; // r0

  if ( a2 == -1 )
    v3 = strlen(a1);
  else
    v3 = a2;
  if ( v3 <= 0 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_6DA38((unsigned __int8)a1[v4]);
    v6 = (char *)&a1[v4];
    if ( !v5 )
      break;
    if ( v5 > 1 )
    {
      if ( v5 + v4 > v3 )
        break;
      v4 += v5 - 1;
      if ( !sub_6DAA4(v6, v5, 0) )
        break;
    }
    if ( v3 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (0006DC90) --------------------------------------------------------
_QWORD *__fastcall sub_6DC90(int a1)
{
  __int64 v1; // r4
  _QWORD *result; // r0

  if ( a1 && *(_DWORD *)a1 == 3 )
    v1 = *(_QWORD *)(a1 + 8);
  else
    v1 = 0;
  result = sub_6D500((void *)0x10);
  if ( result )
  {
    result[1] = v1;
    *result = 0x100000003LL;
  }
  return result;
}

//----- (0006DCDC) --------------------------------------------------------
void *__fastcall sub_6DCDC(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // r12
  void *v4; // r5
  unsigned int v6; // r3
  unsigned int v7; // r12
  unsigned int v10; // r7
  void *v11; // r0

  v3 = a1[2];
  v4 = (void *)a1[4];
  if ( a2 + a1[3] <= v3 )
    return v4;
  v6 = 2 * v3;
  v7 = v3 + a2;
  if ( v6 < v7 )
    v10 = v7;
  else
    v10 = v6;
  v11 = sub_6D500((void *)(4 * v10));
  if ( !v11 )
    return 0;
  a1[2] = v10;
  a1[4] = v11;
  if ( !a3 )
    return v4;
  memcpy(v11, v4, 4 * a1[3]);
  sub_6D518(v4);
  return (void *)a1[4];
}

//----- (0006DD68) --------------------------------------------------------
bool __fastcall sub_6DD68(int *a1, int a2)
{
  int v2; // r3
  int v6; // r8
  int v7; // r0
  char *v8; // r7
  int v9; // r1
  int v10; // r0
  int v11; // r10
  int v12; // r7
  int v13; // r2
  unsigned int v14; // r6
  int v15; // r0
  int v16; // r1
  bool v17; // zf

  v2 = *a1;
  if ( *a1 != *(_DWORD *)a2 )
    return 0;
  if ( a1 == (int *)a2 )
    return 1;
  switch ( v2 )
  {
    case 0:
      if ( a1[2] != *(_DWORD *)(a2 + 8) )
        return 0;
      v6 = (int)(a1 + 2);
      v7 = sub_6BD80((int)(a1 + 2));
      if ( v7 )
      {
        v8 = (char *)sub_6BE20(v7);
        if ( v8 )
        {
          while ( 1 )
          {
            v11 = sub_6BE30((int)(v8 - 16));
            if ( !v11 )
              break;
            if ( *(_DWORD *)a2 )
              return 0;
            v9 = sub_6BBAC(a2 + 8, v8);
            if ( !v9 || !sub_6DD68(v11, v9) )
              return 0;
            if ( !*a1 )
            {
              v10 = sub_6BE08(v6, (int)(v8 - 16));
              if ( v10 )
              {
                v8 = (char *)sub_6BE20(v10);
                if ( v8 )
                  continue;
              }
            }
            return 1;
          }
        }
      }
      return 1;
    case 1:
      v12 = a1[3];
      if ( v12 != *(_DWORD *)(a2 + 12) )
        return 0;
      if ( v12 )
      {
        v13 = 1;
        v14 = 0;
        while ( 1 )
        {
          v15 = v2 == 1 && a1[3] > v14 ? *(_DWORD *)(a1[4] + 4 * v14) : 0;
          if ( v13 != 1 || *(_DWORD *)(a2 + 12) <= v14 )
            break;
          v16 = *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4 * v14);
          v17 = v16 == 0;
          if ( v16 )
            v17 = v15 == 0;
          if ( v17 || !sub_6DD68(v15, v16) )
            break;
          if ( v12 == ++v14 )
            return 1;
          v2 = *a1;
          v13 = *(_DWORD *)a2;
        }
        return 0;
      }
      return 1;
    case 2:
      return strcmp((const char *)a1[2], *(const char **)(a2 + 8)) == 0;
    case 3:
      return *((_QWORD *)a1 + 1) == *(_QWORD *)(a2 + 8);
  }
  if ( v2 != 4 )
    return 0;
  return *((double *)a1 + 1) == *(double *)(a2 + 8);
}

//----- (0006DF5C) --------------------------------------------------------
_DWORD *sub_6DF5C()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v3; // r0

  v0 = sub_6D500((void *)0x24);
  v1 = v0;
  if ( v0 )
  {
    v0[1] = 1;
    *v0 = 0;
    if ( sub_6B8A0(v0 + 2) )
    {
      v3 = v1;
      v1 = 0;
      sub_6D518(v3);
    }
    else
    {
      v1[7] = 0;
      v1[8] = 0;
    }
  }
  return v1;
}

//----- (0006DFB0) --------------------------------------------------------
_DWORD *__fastcall sub_6DFB0(_DWORD *result)
{
  if ( result )
  {
    if ( *result )
      return 0;
    else
      return (_DWORD *)result[2];
  }
  return result;
}

//----- (0006DFCC) --------------------------------------------------------
int __fastcall sub_6DFCC(_DWORD *a1, char *a2)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return sub_6BBAC((int)(a1 + 2), a2);
}

//----- (0006DFF0) --------------------------------------------------------
int __fastcall sub_6DFF0(_DWORD *a1, char *a2)
{
  if ( !a1 || *a1 )
    return -1;
  else
    return sub_6BC1C(a1 + 2, a2);
}

//----- (0006E014) --------------------------------------------------------
int __fastcall sub_6E014(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return -1;
  sub_6BD2C(a1 + 2);
  a1[7] = 0;
  return 0;
}

//----- (0006E048) --------------------------------------------------------
int __fastcall sub_6E048(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return sub_6BD80((int)(a1 + 2));
}

//----- (0006E06C) --------------------------------------------------------
int __fastcall sub_6E06C(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_6BD98((int)(a1 + 2), a2);
}

//----- (0006E094) --------------------------------------------------------
int __fastcall sub_6E094(_DWORD *a1, int a2)
{
  _BOOL4 v2; // r3

  if ( !a1 )
    return 0;
  v2 = a2 == 0;
  if ( *a1 )
    v2 = 1;
  if ( v2 )
    return 0;
  else
    return sub_6BE08((int)(a1 + 2), a2);
}

//----- (0006E0C8) --------------------------------------------------------
int __fastcall sub_6E0C8(int a1)
{
  if ( a1 )
    return sub_6BE20(a1);
  return a1;
}

//----- (0006E0D4) --------------------------------------------------------
int __fastcall sub_6E0D4(int a1)
{
  if ( a1 )
    return sub_6BE30(a1);
  return a1;
}

//----- (0006E138) --------------------------------------------------------
int __fastcall sub_6E138(int result)
{
  if ( result )
    result -= 16;
  return result;
}

//----- (0006E144) --------------------------------------------------------
_DWORD *sub_6E144()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r3
  void *v4; // r0

  v0 = sub_6D500((void *)0x18);
  v1 = v0;
  if ( v0 )
  {
    *v0 = 1;
    v0[1] = 1;
    v0[2] = 8;
    v0[3] = 0;
    v2 = sub_6D500((void *)0x20);
    v1[4] = v2;
    if ( v2 )
    {
      v1[5] = 0;
    }
    else
    {
      v4 = v1;
      v1 = 0;
      sub_6D518(v4);
    }
  }
  return v1;
}

//----- (0006E1A8) --------------------------------------------------------
_DWORD *__fastcall sub_6E1A8(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 1 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (0006E1C4) --------------------------------------------------------
_DWORD *__fastcall sub_6E1C4(_DWORD *result, unsigned int a2)
{
  if ( result )
  {
    if ( *result == 1 && result[3] > a2 )
      return *(_DWORD **)(result[4] + 4 * a2);
    else
      return 0;
  }
  return result;
}

//----- (0006E1F8) --------------------------------------------------------
int __fastcall sub_6E1F8(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  size_t v5; // r2
  char *v6; // r1
  char *v7; // r12
  int v8; // r0
  int v9; // t1

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 != 1 )
    v3 = 1;
  if ( v3 || *a2 != 1 || !sub_6DCDC(a1, a2[3], 1) )
    return -1;
  v5 = a2[3];
  v6 = (char *)a2[4];
  if ( v5 )
  {
    v5 *= 4;
    v7 = (char *)a2[4];
    do
    {
      v9 = *(_DWORD *)v7;
      v7 += 4;
      v8 = v9;
      if ( v9 )
      {
        if ( *(_DWORD *)(v8 + 4) != -1 )
          ++*(_DWORD *)(v8 + 4);
      }
    }
    while ( &v6[v5] != v7 );
  }
  memcpy((void *)(a1[4] + 4 * a1[3]), v6, v5);
  a1[3] += a2[3];
  return 0;
}

//----- (0006E2B0) --------------------------------------------------------
_DWORD *__fastcall sub_6E2B0(const char *a1)
{
  _QWORD *v2; // r0
  _DWORD *v3; // r4
  void *v4; // r0
  void *v6; // r0

  if ( !a1 )
    return 0;
  v2 = sub_6D500((void *)0xC);
  v3 = v2;
  if ( !v2 )
    return 0;
  *v2 = 0x100000002LL;
  v4 = sub_6D530(a1);
  v3[2] = v4;
  if ( !v4 )
  {
    v6 = v3;
    v3 = 0;
    sub_6D518(v6);
  }
  return v3;
}

//----- (0006E350) --------------------------------------------------------
_DWORD *__fastcall sub_6E350(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[2];
    else
      return 0;
  }
  return result;
}

//----- (0006E36C) --------------------------------------------------------
int __fastcall sub_6E36C(int a1, const char *a2)
{
  void *v4; // r6

  if ( !a1 )
    return -1;
  if ( *(_DWORD *)a1 != 2 || a2 == 0 )
    return -1;
  v4 = sub_6D530(a2);
  if ( !v4 )
    return -1;
  sub_6D518(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v4;
  return 0;
}

//----- (0006E3C4) --------------------------------------------------------
int __fastcall sub_6E3C4(int a1, const char *a2)
{
  if ( a2 && sub_6DBFC(a2, -1) )
    return sub_6E36C(a1, a2);
  else
    return -1;
}

//----- (0006E400) --------------------------------------------------------
_QWORD *__fastcall sub_6E400(__int64 a1)
{
  _QWORD *result; // r0

  result = sub_6D500((void *)0x10);
  if ( result )
  {
    result[1] = a1;
    *result = 0x100000003LL;
  }
  return result;
}

//----- (0006E430) --------------------------------------------------------
__int64 __fastcall sub_6E430(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

//----- (0006E458) --------------------------------------------------------
int __fastcall sub_6E458(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (0006E480) --------------------------------------------------------
double *sub_6E480()
{
  double v0; // d0
  double *result; // r0

  if ( fabs(v0) > 1.79769313e308 )
    return 0;
  result = (double *)sub_6D500((void *)0x10);
  if ( result )
  {
    result[1] = v0;
    *(_QWORD *)result = 0x100000004LL;
  }
  return result;
}
// 6E490: variable 'v0' is possibly undefined

//----- (0006E4E0) --------------------------------------------------------
void sub_6E4E0()
{
  ;
}

//----- (0006E570) --------------------------------------------------------
int __fastcall sub_6E570(int result)
{
  if ( result )
  {
    if ( *(_DWORD *)result == 3 )
      return sub_778B4(*(_QWORD *)(result + 8));
  }
  return result;
}

//----- (0006E5B8) --------------------------------------------------------
void *sub_6E5B8()
{
  return &unk_9F5AC;
}

//----- (0006E5C4) --------------------------------------------------------
void *sub_6E5C4()
{
  return &unk_9F5B4;
}

//----- (0006E5D0) --------------------------------------------------------
void *sub_6E5D0()
{
  return &unk_9F5BC;
}

//----- (0006E5DC) --------------------------------------------------------
void __fastcall sub_6E5DC(void **a1)
{
  char *v2; // r3
  void *v3; // r12
  _DWORD *v4; // r1
  unsigned int i; // r5
  int v6; // r0
  int v7; // r3

  if ( a1 )
  {
    v2 = (char *)*a1;
    if ( *a1 )
    {
      if ( v2 == (char *)1 )
      {
        v3 = a1[3];
        v4 = a1[4];
        if ( v3 )
        {
          for ( i = 0; i < (unsigned int)v3; ++i )
          {
            v6 = v4[i];
            if ( v6 )
            {
              v7 = *(_DWORD *)(v6 + 4);
              if ( v7 != -1 )
              {
                *(_DWORD *)(v6 + 4) = v7 - 1;
                if ( v7 == 1 )
                {
                  sub_6E5DC();
                  v4 = a1[4];
                  v3 = a1[3];
                }
              }
            }
          }
        }
        sub_6D518(v4);
        sub_6D518(a1);
      }
      else if ( v2 == (char *)2 )
      {
        sub_6D518(a1[2]);
        sub_6D518(a1);
      }
      else if ( (unsigned int)(v2 - 3) <= 1 )
      {
        sub_6D518(a1);
      }
    }
    else
    {
      sub_6B910((int)(a1 + 2));
      sub_6D518(a1);
    }
  }
}

//----- (0006E6A8) --------------------------------------------------------
int __fastcall sub_6E6A8(_DWORD *a1)
{
  unsigned int v2; // r1
  unsigned int i; // r4
  int v4; // r0
  int v5; // r3

  if ( !a1 || *a1 != 1 )
    return -1;
  v2 = a1[3];
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(_DWORD *)(a1[4] + 4 * i);
      if ( v4 )
      {
        v5 = *(_DWORD *)(v4 + 4);
        if ( v5 != -1 )
        {
          *(_DWORD *)(v4 + 4) = v5 - 1;
          if ( v5 == 1 )
          {
            sub_6E5DC((void **)v4);
            v2 = a1[3];
          }
        }
      }
    }
  }
  a1[3] = 0;
  return 0;
}

//----- (0006E724) --------------------------------------------------------
int __fastcall sub_6E724(_DWORD *a1, unsigned int a2)
{
  unsigned int v3; // r2
  int v5; // r6
  int v6; // r0
  int v7; // r3
  int v8; // r3
  int v9; // r3

  if ( !a1 )
    return -1;
  if ( *a1 != 1 )
    return -1;
  v3 = a1[3];
  if ( v3 <= a2 )
    return -1;
  v5 = 4 * a2;
  v6 = *(_DWORD *)(a1[4] + 4 * a2);
  if ( v6 )
  {
    v7 = *(_DWORD *)(v6 + 4);
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      *(_DWORD *)(v6 + 4) = v8;
      if ( !v8 )
      {
        sub_6E5DC((void **)v6);
        v3 = a1[3];
      }
    }
  }
  v9 = v3 - 1;
  if ( v3 - 1 > a2 )
  {
    memmove((void *)(a1[4] + v5), (const void *)(a1[4] + v5 + 4), 4 * (~a2 + v3));
    v9 = a1[3] - 1;
  }
  a1[3] = v9;
  return 0;
}

//----- (0006E7D4) --------------------------------------------------------
int __fastcall sub_6E7D4(void **a1, unsigned int a2, void **a3)
{
  _BOOL4 v5; // r3
  _DWORD *v6; // r3
  int v7; // r6
  int v8; // r0
  void ***v9; // r3
  int v10; // r2
  int v11; // r2
  char *v13; // r3
  char *v14; // r3

  if ( !a3 )
    return -1;
  if ( !a1 )
    goto LABEL_12;
  v5 = a3 == a1;
  if ( *a1 != (void *)1 )
    v5 = 1;
  if ( v5 || (unsigned int)a1[3] <= a2 )
  {
LABEL_12:
    v13 = (char *)a3[1];
    if ( v13 != (char *)-1 )
    {
      v14 = v13 - 1;
      a3[1] = v14;
      if ( !v14 )
        sub_6E5DC(a3);
    }
    return -1;
  }
  v6 = a1[4];
  v7 = 4 * a2;
  v8 = v6[a2];
  v9 = (void ***)&v6[a2];
  if ( v8 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != -1 )
    {
      v11 = v10 - 1;
      *(_DWORD *)(v8 + 4) = v11;
      if ( !v11 )
      {
        sub_6E5DC((void **)v8);
        v9 = (void ***)((char *)a1[4] + v7);
      }
    }
  }
  *v9 = a3;
  return 0;
}

//----- (0006E894) --------------------------------------------------------
int __fastcall sub_6E894(_DWORD *a1, char *a2, int a3)
{
  bool v4; // zf
  _BOOL4 v5; // r3
  int v6; // r2
  int result; // r0
  int v8; // r3
  int v9; // r3

  if ( !a3 )
    return -1;
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( v4 )
    goto LABEL_9;
  v5 = a3 == (_DWORD)a1;
  if ( *a1 )
    v5 = 1;
  if ( v5 || (v6 = a1[7], a1[7] = v6 + 1, (result = sub_6B928((int)(a1 + 2), a2, v6, a3)) != 0) )
  {
LABEL_9:
    v8 = *(_DWORD *)(a3 + 4);
    if ( v8 != -1 )
    {
      v9 = v8 - 1;
      *(_DWORD *)(a3 + 4) = v9;
      if ( !v9 )
        sub_6E5DC((void **)a3);
    }
    return -1;
  }
  return result;
}

//----- (0006E91C) --------------------------------------------------------
int __fastcall sub_6E91C(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r8
  int v6; // r0
  int v8; // r0
  char *v9; // r4
  int v10; // r12

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  v6 = sub_6BD80((int)(a2 + 2));
  if ( v6 )
  {
    while ( 1 )
    {
      v8 = sub_6BE20(v6);
      v9 = (char *)v8;
      if ( !v8 )
        break;
      v10 = sub_6BE30(v8 - 16);
      if ( !v10 )
        break;
      if ( *(_DWORD *)(v10 + 4) != -1 )
        ++*(_DWORD *)(v10 + 4);
      if ( sub_6E894(a1, v9, v10) )
        return -1;
      if ( !*a2 )
      {
        v6 = sub_6BE08(v4, (int)(v9 - 16));
        if ( v6 )
          continue;
      }
      return 0;
    }
  }
  return 0;
}

//----- (0006E9E4) --------------------------------------------------------
int __fastcall sub_6E9E4(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r8
  int v6; // r0
  char *i; // r5
  int v8; // r0
  int v9; // r10

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  v6 = sub_6BD80((int)(a2 + 2));
  if ( v6 )
  {
    for ( i = (char *)sub_6BE20(v6); i; i = (char *)sub_6BE20(v8) )
    {
      v9 = sub_6BE30((int)(i - 16));
      if ( !v9 )
        break;
      if ( !*a1 && sub_6BBAC((int)(a1 + 2), i) )
      {
        if ( *(_DWORD *)(v9 + 4) != -1 )
          ++*(_DWORD *)(v9 + 4);
        sub_6E894(a1, i, v9);
      }
      if ( *a2 )
        break;
      v8 = sub_6BE08(v4, (int)(i - 16));
      if ( !v8 )
        break;
    }
  }
  return 0;
}

//----- (0006EAD8) --------------------------------------------------------
int __fastcall sub_6EAD8(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r9
  int v6; // r0
  char *v7; // r4
  int v8; // r3
  int v9; // r0
  int v10; // r5

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  v6 = sub_6BD80((int)(a2 + 2));
  if ( v6 )
  {
    v7 = (char *)sub_6BE20(v6);
    if ( v7 )
    {
      while ( 1 )
      {
        v10 = sub_6BE30((int)(v7 - 16));
        if ( !v10 )
          break;
        if ( *a1 || !sub_6BBAC((int)(a1 + 2), v7) )
        {
          v8 = *(_DWORD *)(v10 + 4);
          if ( v8 != -1 )
            *(_DWORD *)(v10 + 4) = v8 + 1;
          sub_6E894(a1, v7, v10);
          if ( *a2 )
            return 0;
        }
        else if ( *a2 )
        {
          return 0;
        }
        v9 = sub_6BE08(v4, (int)(v7 - 16));
        if ( v9 )
        {
          v7 = (char *)sub_6BE20(v9);
          if ( v7 )
            continue;
        }
        return 0;
      }
    }
  }
  return 0;
}

//----- (0006EBD4) --------------------------------------------------------
int __fastcall sub_6EBD4(_DWORD *a1, char *a2, int a3)
{
  int v7; // r3
  int v8; // r3

  if ( a2 && sub_6DBFC(a2, -1) )
    return sub_6E894(a1, a2, a3);
  if ( a3 )
  {
    v7 = *(_DWORD *)(a3 + 4);
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      *(_DWORD *)(a3 + 4) = v8;
      if ( !v8 )
        sub_6E5DC((void **)a3);
    }
  }
  return -1;
}

//----- (0006EC44) --------------------------------------------------------
int __fastcall sub_6EC44(void **a1, unsigned int a2, void **a3)
{
  int v6; // r2
  char *v7; // r8
  char *v8; // r0
  int v9; // r7
  int v11; // r3
  char *v12; // r3
  char *v13; // r3

  if ( !a3 )
    return -1;
  if ( !a1 )
    goto LABEL_12;
  v6 = a3 == a1;
  if ( *a1 != (void *)1 )
    v6 |= 1u;
  if ( v6 || (unsigned int)a1[3] < a2 || (v7 = (char *)sub_6DCDC(a1, 1, 0)) == 0 )
  {
LABEL_12:
    v12 = (char *)a3[1];
    if ( v12 != (char *)-1 )
    {
      v13 = v12 - 1;
      a3[1] = v13;
      if ( !v13 )
        sub_6E5DC(a3);
    }
    return -1;
  }
  v8 = (char *)a1[4];
  v9 = 4 * (a2 + 1);
  if ( v8 == v7 )
  {
    memmove(&v8[v9], &v7[v9 - 4], 4 * ((int)a1[3] - a2));
  }
  else
  {
    memcpy(v8, v7, v9 - 4);
    memcpy((char *)a1[4] + v9, &v7[v9 - 4], 4 * ((int)a1[3] - a2));
    sub_6D518(v7);
  }
  v11 = (int)a1[3] + 1;
  *(_DWORD *)((char *)a1[4] + v9 - 4) = a3;
  a1[3] = (void *)v11;
  return 0;
}

//----- (0006ED4C) --------------------------------------------------------
int __fastcall sub_6ED4C(void **a1, void **a2)
{
  _BOOL4 v4; // r5
  char *v5; // r3
  char *v7; // r3
  char *v8; // r3

  if ( a2 )
  {
    if ( a1 )
    {
      v4 = a2 == a1;
      if ( *a1 != (void *)1 )
        v4 = 1;
      if ( !v4 && sub_6DCDC(a1, 1, 1) )
      {
        v5 = (char *)a1[3];
        *((_DWORD *)a1[4] + (_DWORD)v5) = a2;
        a1[3] = v5 + 1;
        return 0;
      }
    }
    v7 = (char *)a2[1];
    if ( v7 != (char *)-1 )
    {
      v8 = v7 - 1;
      a2[1] = v8;
      if ( !v8 )
        sub_6E5DC(a2);
    }
  }
  return -1;
}

//----- (0006EDE0) --------------------------------------------------------
bool __fastcall sub_6EDE0(int *a1, int a2)
{
  bool v2; // zf

  v2 = a2 == 0;
  if ( a2 )
    v2 = a1 == 0;
  return !v2 && sub_6DD68(a1, a2);
}

//----- (0006EDF8) --------------------------------------------------------
double *__fastcall sub_6EDF8(int a1)
{
  int v2; // r3
  void **v3; // r7
  int i; // r0
  int v6; // r0
  char *v7; // r5
  int v8; // r12
  unsigned int v9; // r3
  unsigned int j; // r5
  int v11; // r1

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)a1;
  if ( !*(_DWORD *)a1 )
  {
    v3 = (void **)sub_6DF5C();
    if ( v3 )
    {
      if ( !*(_DWORD *)a1 )
      {
        for ( i = sub_6BD80(a1 + 8); i; i = sub_6BE08(a1 + 8, (int)(v7 - 16)) )
        {
          v6 = sub_6BE20(i);
          v7 = (char *)v6;
          if ( !v6 )
            break;
          v8 = sub_6BE30(v6 - 16);
          if ( !v8 )
            break;
          if ( *(_DWORD *)(v8 + 4) != -1 )
            ++*(_DWORD *)(v8 + 4);
          sub_6E894(v3, v7, v8);
          if ( *(_DWORD *)a1 )
            break;
        }
      }
      return (double *)v3;
    }
    return 0;
  }
  switch ( v2 )
  {
    case 1:
      v3 = (void **)sub_6E144();
      if ( v3 )
      {
        if ( *(_DWORD *)a1 == 1 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( v9 )
          {
            for ( j = 0; j < v9; ++j )
            {
              v11 = 0;
              if ( j < v9 )
              {
                v11 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * j);
                if ( v11 )
                {
                  if ( *(_DWORD *)(v11 + 4) != -1 )
                    ++*(_DWORD *)(v11 + 4);
                }
              }
              sub_6ED4C(v3, (void **)v11);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v9 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return (double *)v3;
      }
      return 0;
    case 2:
      return (double *)sub_6E2B0(*(const char **)(a1 + 8));
    case 3:
      return (double *)sub_6DC90(a1);
  }
  if ( v2 != 4 )
  {
    if ( (unsigned int)(v2 - 5) <= 2 )
      return (double *)a1;
    return 0;
  }
  return sub_6E480();
}

//----- (0006EF88) --------------------------------------------------------
double *__fastcall sub_6EF88(int a1)
{
  int v2; // r3
  void **v3; // r6
  int i; // r5
  char *v5; // r7
  int v6; // r0
  int v7; // r0
  unsigned int v9; // r3
  unsigned int j; // r5
  int v11; // r0
  void **v12; // r0

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)a1;
  if ( !*(_DWORD *)a1 )
  {
    v3 = (void **)sub_6DF5C();
    if ( v3 )
    {
      if ( !*(_DWORD *)a1 )
      {
        for ( i = sub_6BD80(a1 + 8); i; i = sub_6BE08(a1 + 8, i) )
        {
          v5 = (char *)sub_6BE20(i);
          v6 = sub_6BE30(i);
          v7 = sub_6EF88(v6);
          sub_6E894(v3, v5, v7);
          if ( *(_DWORD *)a1 )
            break;
        }
      }
      return (double *)v3;
    }
    return 0;
  }
  switch ( v2 )
  {
    case 1:
      v3 = (void **)sub_6E144();
      if ( v3 )
      {
        if ( *(_DWORD *)a1 == 1 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( v9 )
          {
            for ( j = 0; j < v9; ++j )
            {
              v11 = 0;
              if ( v9 > j )
                v11 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * j);
              v12 = (void **)sub_6EF88(v11);
              sub_6ED4C(v3, v12);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v9 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return (double *)v3;
      }
      return 0;
    case 2:
      return (double *)sub_6E2B0(*(const char **)(a1 + 8));
    case 3:
      return (double *)sub_6DC90(a1);
  }
  if ( v2 != 4 )
  {
    if ( (unsigned int)(v2 - 5) <= 2 )
      return (double *)a1;
    return 0;
  }
  return sub_6E480();
}

//----- (0006F0EC) --------------------------------------------------------
int __fastcall sub_6F0EC(int a1)
{
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_open", a1);
  sub_47AB4(0, s, 0);
  return -2147483391;
}

//----- (0006F13C) --------------------------------------------------------
int __fastcall sub_6F13C(unsigned int a1)
{
  int result; // r0
  unsigned int v3; // [sp+0h] [bp-Ch] BYREF
  __int16 v4; // [sp+4h] [bp-8h]
  char v5; // [sp+6h] [bp-6h]
  char v6; // [sp+7h] [bp-5h]

  if ( a1 > 0xF )
    return sub_6F0EC(a1);
  result = dword_1B13B8[2 * a1];
  if ( !result || !dword_1B13B8[2 * a1 + 1] )
  {
    v4 = 0;
    v5 = 10;
    v3 = a1;
    v6 = a1;
    result = sub_73660((int)&v3);
    if ( result >= 0 )
    {
      dword_1B13B8[2 * a1] = result;
      dword_1B13B8[2 * a1 + 1] = 1;
    }
  }
  return result;
}
// 1B13B8: using guessed type _DWORD dword_1B13B8[32];

//----- (0006F1B8) --------------------------------------------------------
void __fastcall sub_6F1B8(unsigned int a1)
{
  int v2; // r6
  int v3; // r0
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_close", a1);
    sub_47AB4(0, s, 0);
  }
  else
  {
    v2 = 2 * a1;
    v3 = dword_1B13B8[2 * a1];
    if ( v3 || dword_1B13B8[v2 + 1] )
    {
      sub_73804(v3);
      dword_1B13B8[v2 + 1] = 0;
      dword_1B13B8[2 * a1] = 0;
    }
  }
}
// 1B13B8: using guessed type _DWORD dword_1B13B8[32];

//----- (0006F254) --------------------------------------------------------
int __fastcall sub_6F254(unsigned int a1, unsigned __int8 a2, int a3, int a4)
{
  int v8; // r8
  int v9; // r3
  int v10; // r0
  int v11; // r9
  unsigned __int8 v13; // [sp+Fh] [bp-801h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_write", a1);
    v11 = -2147483391;
    sub_47AB4(0, s, 0);
    return v11;
  }
  if ( !dword_1B13B8[2 * a1 + 1] )
  {
    v11 = sub_6F13C(a1);
    if ( v11 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_write", a1);
      sub_47AB4(0, s, 0);
      return v11;
    }
  }
  if ( a4 )
  {
    v8 = a3 + a4;
    while ( 1 )
    {
      v9 = a3;
      v10 = dword_1B13B8[2 * a1];
      ++a3;
      v13 = a2++;
      if ( sub_73A24(v10, &v13, 1, v9, 1) != 1 )
        break;
      if ( v8 == a3 )
        goto LABEL_10;
    }
    v11 = -2147483392;
    snprintf(s, 0x800u, "fail to write eeprom by iic, chain:%d, addr: %d", a1, v13);
    sub_47AB4(0, s, 0);
    return v11;
  }
LABEL_10:
  sleep(1u);
  return 0;
}
// 1B13B8: using guessed type _DWORD dword_1B13B8[32];

//----- (0006F3AC) --------------------------------------------------------
int __fastcall sub_6F3AC(unsigned int a1, unsigned __int8 a2, int a3, int a4)
{
  int v8; // r8
  int v9; // r3
  int v10; // r0
  int v11; // r9
  unsigned __int8 v13; // [sp+Fh] [bp-801h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_read", a1);
    v11 = -2147483391;
    sub_47AB4(0, s, 0);
    return v11;
  }
  if ( !dword_1B13B8[2 * a1 + 1] )
  {
    v11 = sub_6F13C(a1);
    if ( v11 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_read", a1);
      sub_47AB4(0, s, 0);
      return v11;
    }
  }
  if ( a4 )
  {
    v8 = a3 + a4;
    while ( 1 )
    {
      v9 = a3;
      v10 = dword_1B13B8[2 * a1];
      ++a3;
      v13 = a2++;
      if ( sub_73984(v10, &v13, 1, v9, 1) != 1 )
        break;
      if ( v8 == a3 )
        goto LABEL_10;
    }
    v11 = -2147483392;
    snprintf(s, 0x800u, "fail to read eeprom by iic, chain: %d, addr: %d\n", a1, v13);
    sub_47AB4(0, s, 0);
    return v11;
  }
LABEL_10:
  usleep((__useconds_t)"d asic, will power off hash board %d\n");
  return 0;
}
// 1B13B8: using guessed type _DWORD dword_1B13B8[32];

//----- (0006F508) --------------------------------------------------------
int sub_6F508()
{
  int v0; // r4
  int result; // r0
  int v2; // [sp+4h] [bp-4h] BYREF

  v0 = 10;
  v2 = 0;
  sub_6688C(35, &v2);
  sub_66908(35, v2 & 0xFFFFFFBF);
  do
  {
    usleep(0x3E8u);
    v2 = 0;
    result = sub_6688C(35, &v2);
    if ( (v2 & 0x40) == 0 )
      break;
    --v0;
  }
  while ( v0 );
  return result;
}

//----- (0006F570) --------------------------------------------------------
int __fastcall sub_6F570(int result)
{
  if ( result == 115200 )
    return 26;
  if ( (double)result == 1500000.0 )
    return 1;
  switch ( result )
  {
    case 3000000:
      return 0;
    case 6000000:
      return 3;
    case 12000000:
      return 4;
    case 25000000:
      return 5;
  }
  return result;
}

//----- (0006F610) --------------------------------------------------------
int __fastcall sub_6F610(int a1)
{
  int v2; // r4
  int result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  sub_66908(27, a1);
  if ( a1 >= 0 )
    return sub_6688C(27, &v4);
  v2 = 3001;
  do
  {
    sub_6688C(27, &v4);
    result = 1000;
    if ( v4 >= 0 )
      break;
    result = usleep(0x3E8u);
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (0006F67C) --------------------------------------------------------
int sub_6F67C()
{
  return 0;
}

//----- (0006F684) --------------------------------------------------------
__int64 __fastcall sub_6F684(int a1)
{
  return *(_QWORD *)(dword_1B1438 + (a1 << 6) + 8);
}
// 1B1438: using guessed type int dword_1B1438;

//----- (0006F69C) --------------------------------------------------------
int __fastcall sub_6F69C(int a1)
{
  return *(_DWORD *)(dword_1B1438 + (a1 << 6));
}
// 1B1438: using guessed type int dword_1B1438;

//----- (0006F6B0) --------------------------------------------------------
int __fastcall sub_6F6B0(int a1)
{
  return *(_DWORD *)(dword_1B1438 + (a1 << 6) + 4);
}
// 1B1438: using guessed type int dword_1B1438;

//----- (0006F6C8) --------------------------------------------------------
int __fastcall sub_6F6C8(int a1, int a2, int a3)
{
  int v3; // r0
  int v4; // r0
  int v5; // r2
  int v6; // r1
  char v7; // t1

  v3 = a1 << 6;
  if ( a3 )
  {
    v4 = dword_1B1438 + v3 + 31;
    v5 = a2 + a3 - 1;
    v6 = a2 - 1;
    do
    {
      v7 = *(_BYTE *)++v4;
      *(_BYTE *)++v6 = v7;
    }
    while ( v6 != v5 );
  }
  return 0;
}
// 1B1438: using guessed type int dword_1B1438;

//----- (0006F70C) --------------------------------------------------------
unsigned int sub_6F70C()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_6688C(13, &v1);
  v1 = ~(~HIWORD(v1) << 16);
  sub_66908(13, v1);
  return sleep(2u);
}

//----- (0006F754) --------------------------------------------------------
unsigned int sub_6F754()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_6688C(13, &v1);
  v1 = HIWORD(v1) << 16;
  sub_66908(13, v1);
  return sleep(2u);
}

//----- (0006F79C) --------------------------------------------------------
int sub_6F79C()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_6688C(35, &v1);
  return v1;
}

//----- (0006F7C4) --------------------------------------------------------
int __fastcall sub_6F7C4(int a1)
{
  return sub_66908(35, a1);
}

//----- (0006FB14) --------------------------------------------------------
int sub_6FB14()
{
  unsigned int v1; // [sp+4h] [bp-4h] BYREF

  v1 = 0;
  sub_6688C(13, &v1);
  sub_66908(13, ~(~HIWORD(v1) << 16));
  sleep(3u);
  sub_6688C(13, &v1);
  sub_66908(13, HIWORD(v1) << 16);
  sleep(1u);
  return sub_6F508();
}

//----- (0006FB84) --------------------------------------------------------
int __fastcall sub_6FB84(char *a1, size_t a2)
{
  int v5; // [sp+8h] [bp-Ch] BYREF
  int v6; // [sp+Ch] [bp-8h] BYREF

  v5 = 0;
  v6 = 0;
  sub_6688C(31, &v5);
  sub_6688C(32, &v6);
  return snprintf(a1, a2, "%08x%08x", v6, v5);
}

//----- (0006FBE0) --------------------------------------------------------
int __fastcall sub_6FBE0(int a1)
{
  return sub_66908(0, a1);
}

//----- (0006FBEC) --------------------------------------------------------
int sub_6FBEC()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(41, &v1);
  return v1;
}

//----- (0006FC0C) --------------------------------------------------------
int __fastcall sub_6FC0C(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(41, a1);
  return sub_6688C(41, &v2);
}

//----- (0006FC34) --------------------------------------------------------
int sub_6FC34()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(39, &v1);
  return v1;
}

//----- (0006FC54) --------------------------------------------------------
int __fastcall sub_6FC54(int a1)
{
  int v3; // [sp+4h] [bp-4h] BYREF

  sub_6688C(39, &v3);
  sub_66908(39, a1);
  return sub_6688C(39, &v3);
}

//----- (0006FC8C) --------------------------------------------------------
int __fastcall sub_6FC8C(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(20, a1);
  return sub_6688C(20, &v2);
}

//----- (0006FCB4) --------------------------------------------------------
int __fastcall sub_6FCB4(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(20, a1 & 0x1FFFF | 0x80000000);
  return sub_6688C(20, &v2);
}

//----- (0006FCE0) --------------------------------------------------------
int sub_6FCE0()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(22, &v1);
  return v1;
}

//----- (0006FD00) --------------------------------------------------------
int __fastcall sub_6FD00(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(22, a1);
  return sub_6688C(22, &v2);
}

//----- (0006FD28) --------------------------------------------------------
int sub_6FD28()
{
  return sub_66908(33, 196608);
}

//----- (0006FD34) --------------------------------------------------------
int sub_6FD34()
{
  return sub_66908(33, 0x10000);
}

//----- (0006FD40) --------------------------------------------------------
int sub_6FD40()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(33, &v1);
  return (unsigned __int16)v1;
}

//----- (0006FD60) --------------------------------------------------------
int sub_6FD60()
{
  return sub_66908(33, 0);
}

//----- (0006FD6C) --------------------------------------------------------
int sub_6FD6C()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(6, &v1);
  return v1 & 0x7FFF;
}

//----- (0006FDC4) --------------------------------------------------------
__int64 __fastcall sub_6FDC4(_QWORD *a1)
{
  __int64 result; // r0
  __int64 v3; // r2
  __int64 v4; // [sp+0h] [bp-10h] BYREF
  __int64 v5; // [sp+8h] [bp-8h] BYREF

  v4 = 0;
  v5 = 0;
  sub_6688C(4, &v4);
  sub_6688C(5, (_DWORD *)&v4 + 1);
  sub_6688C(4, &v5);
  sub_6688C(5, (_DWORD *)&v5 + 1);
  result = v4;
  v3 = v5;
  *a1 = v4;
  a1[1] = v3;
  return result;
}

//----- (0006FE2C) --------------------------------------------------------
int sub_6FE2C()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(21, &v1);
  return v1;
}

//----- (0006FE4C) --------------------------------------------------------
int __fastcall sub_6FE4C(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(21, a1);
  return sub_6688C(21, &v2);
}

//----- (0006FE74) --------------------------------------------------------
int sub_6FE74()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(44, &v1);
  return v1;
}

//----- (0006FE94) --------------------------------------------------------
int __fastcall sub_6FE94(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(44, a1);
  return sub_6688C(44, &v2);
}

//----- (0006FEBC) --------------------------------------------------------
int sub_6FEBC()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(42, &v1);
  return v1;
}

//----- (0006FEDC) --------------------------------------------------------
int __fastcall sub_6FEDC(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(42, a1);
  return sub_6688C(42, &v2);
}

//----- (0006FF04) --------------------------------------------------------
int sub_6FF04()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(3, &v1);
  return v1;
}

//----- (0006FF58) --------------------------------------------------------
int sub_6FF58()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(45, &v1);
  return v1;
}

//----- (0006FF78) --------------------------------------------------------
int __fastcall sub_6FF78(int a1, int a2)
{
  int v4; // [sp+4h] [bp-4h] BYREF

  switch ( a2 )
  {
    case 4:
      sub_66908(45, a1);
      sub_6688C(45, &v4);
      sub_66908(57, a1 | 0x4000);
      sub_66908(58, a1 | 0x8000);
      return sub_66908(59, a1 | 0xC000);
    case 8:
      sub_66908(45, a1);
      sub_6688C(45, &v4);
      sub_66908(57, a1 | 0x4000);
      sub_66908(58, a1 | 0x8000);
      sub_66908(59, a1 | 0xC000);
      sub_66908(60, a1 | 0x2000);
      sub_66908(61, a1 | 0x6000);
      sub_66908(62, a1 | 0xA000);
      return sub_66908(63, a1 | 0xE000);
    case 2:
      sub_66908(45, a1);
      sub_6688C(45, &v4);
      return sub_66908(57, a1 | 0x4000);
    default:
      sub_66908(45, a1);
      return sub_6688C(45, &v4);
  }
}

//----- (00070098) --------------------------------------------------------
int sub_70098()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(46, &v1);
  return v1;
}

//----- (000700B8) --------------------------------------------------------
int __fastcall sub_700B8(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(46, a1);
  return sub_6688C(46, &v2);
}

//----- (000700E0) --------------------------------------------------------
int sub_700E0()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(47, &v1);
  return v1;
}

//----- (00070100) --------------------------------------------------------
int __fastcall sub_70100(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(47, a1);
  return sub_6688C(47, &v2);
}

//----- (00070128) --------------------------------------------------------
int __fastcall sub_70128(int a1)
{
  int v1; // r5
  int v2; // r4
  int v3; // r0
  int v4; // t1
  int result; // r0

  v1 = a1 - 4;
  v2 = 48;
  do
  {
    v3 = v2++;
    v4 = *(_DWORD *)(v1 + 4);
    v1 += 4;
    result = sub_66908(v3, v4);
  }
  while ( v2 != 56 );
  return result;
}

//----- (00070150) --------------------------------------------------------
int __fastcall sub_70150(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(36, a1);
  return sub_6688C(36, &v2);
}

//----- (00070240) --------------------------------------------------------
int __fastcall sub_70240(int *a1)
{
  int v3; // [sp+4h] [bp-4h] BYREF

  sub_66908(37, *a1);
  sub_66908(38, a1[1]);
  sub_6688C(37, &v3);
  return sub_6688C(38, &v3);
}

//----- (00070284) --------------------------------------------------------
int __fastcall sub_70284(unsigned __int16 a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(40, a1);
  return sub_6688C(40, &v2);
}

//----- (000702AC) --------------------------------------------------------
int sub_702AC()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(7, &v1);
  return v1;
}

//----- (000702CC) --------------------------------------------------------
int __fastcall sub_702CC(int a1)
{
  int v2; // [sp+4h] [bp-8h] BYREF

  sub_66908(7, a1);
  return sub_6688C(7, &v2);
}

//----- (000702F4) --------------------------------------------------------
int sub_702F4()
{
  _DWORD v1[2]; // [sp+4h] [bp-8h] BYREF

  sub_6688C(7, v1);
  sub_66908(7, v1[0] | 0x10000);
  sub_6688C(7, v1);
  return 0;
}

//----- (00070330) --------------------------------------------------------
int __fastcall sub_70330(int a1)
{
  size_t v2; // r5
  unsigned int v3; // r7
  size_t v4; // r7
  _BYTE *v5; // r0
  _BYTE *v6; // r6
  _BYTE *v7; // r3
  char *v8; // r8
  char *v9; // r0
  char *v10; // r3
  int v11; // r6
  int v12; // r2
  char v13; // t1
  int v14; // r5
  size_t v15; // r7
  int v16; // r12
  int v17; // t1
  int v18; // lr
  int v19; // t1
  unsigned int v20; // r1
  size_t v21; // r2
  _DWORD *v22; // r3
  int v23; // lr
  int v24; // r12
  int v25; // r0
  int v26; // lr
  int v27; // r12
  int v28; // r0
  int v29; // r1
  int v30; // r1
  int v31; // r0
  int *v32; // r12
  int v33; // lr
  int v34; // r3
  int v35; // r3
  unsigned int v36; // r1
  int v37; // r8
  int v38; // r6
  _BOOL4 v39; // r3
  int v40; // r7
  int v41; // r4
  int result; // r0
  int v43; // [sp+Ch] [bp-38h]
  void *ptr; // [sp+10h] [bp-34h]
  size_t v45; // [sp+14h] [bp-30h]
  int v46; // [sp+1Ch] [bp-28h] BYREF
  int v47[9]; // [sp+20h] [bp-24h] BYREF

  memset(v47, 0, 0x20u);
  v2 = *(_DWORD *)(a1 + 12);
  v43 = dword_1B143C;
  v3 = v2 & 0xFFFFFFC0;
  if ( dword_1B143C == dword_1B1440 )
    v43 = dword_1B1444;
  if ( (*(_DWORD *)(a1 + 12) & 0x3Fu) <= 0x37 )
    v4 = v3 + 64;
  else
    v4 = v3 + 128;
  v5 = calloc(v4, 1u);
  v6 = v5;
  ptr = v5;
  if ( !v5 )
    return -4;
  memcpy(v5, *(const void **)(a1 + 8), v2);
  v7 = &v6[v4];
  v6[v2] = 0x80;
  *((_DWORD *)v7 - 2) = 0;
  *((_DWORD *)v7 - 1) = bswap32(8 * v2);
  if ( v4 )
  {
    v8 = v6 - 1;
    v9 = &v6[v4 - 1];
    v10 = v6 - 1;
    v11 = v43 - 1;
    v12 = v43 - 1;
    do
    {
      v13 = *++v10;
      *(_BYTE *)++v12 = v13;
    }
    while ( v9 != v10 );
    v45 = v4;
    v14 = 0;
    v15 = v43 - 1 + v4;
    do
    {
      v17 = *(unsigned __int8 *)++v11;
      v16 = v17;
      v19 = (unsigned __int8)*++v8;
      v18 = v19;
      if ( v16 != v19 )
        printf(
          "%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x",
          "dhash_send_job",
          v14,
          v16,
          v14,
          v18);
      ++v14;
    }
    while ( v15 != v11 );
    v4 = v45;
  }
  if ( *(_DWORD *)(a1 + 20) )
  {
    v20 = 0;
    v21 = v43 + v4;
    do
    {
      v21 += 32;
      v22 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 32 * v20++);
      v23 = v22[1];
      v24 = v22[2];
      v25 = v22[3];
      *(_DWORD *)(v21 - 32) = *v22;
      *(_DWORD *)(v21 - 28) = v23;
      *(_DWORD *)(v21 - 24) = v24;
      *(_DWORD *)(v21 - 20) = v25;
      v26 = v22[5];
      v27 = v22[6];
      v28 = v22[7];
      *(_DWORD *)(v21 - 16) = v22[4];
      *(_DWORD *)(v21 - 12) = v26;
      *(_DWORD *)(v21 - 8) = v27;
      *(_DWORD *)(v21 - 4) = v28;
    }
    while ( *(_DWORD *)(a1 + 20) > v20 );
  }
  sub_6F508();
  if ( v43 == dword_1B143C )
    v29 = dword_1B1448 + 0x200000;
  else
    v29 = dword_1B1448 + 2162688;
  sub_66908(41, v29);
  sub_6688C(41, &v46);
  sub_66908(44, *(_DWORD *)(a1 + 32));
  sub_6688C(44, &v46);
  if ( *(_DWORD *)a1 || (v30 = *(_DWORD *)(a1 + 4), v30 != 4) && v30 != 8 && v30 != 2 )
    v30 = 1;
  sub_6FF78(*(_DWORD *)(a1 + 36), v30);
  memset(v47, 0, 0x20u);
  v31 = *(_DWORD *)(a1 + 40);
  v32 = &v46;
  v33 = v31 + 32;
  do
  {
    v34 = *(unsigned __int8 *)(v31 + 2);
    v31 += 4;
    v32[1] = (v34 << 16)
           | (*(unsigned __int8 *)(v31 - 1) << 24)
           | *(unsigned __int8 *)(v31 - 4)
           | (*(unsigned __int8 *)(v31 - 3) << 8);
    ++v32;
  }
  while ( v31 != v33 );
  sub_70128((int)v47);
  sub_66908(46, *(_DWORD *)(a1 + 24));
  sub_6688C(46, &v46);
  sub_66908(47, *(_DWORD *)(a1 + 28));
  sub_6688C(47, &v46);
  sub_66908(
    36,
    (unsigned __int16)(*(_WORD *)(a1 + 52) << 8) | (*(_DWORD *)(a1 + 48) << 16) | (unsigned __int8)(v4 >> 6));
  sub_6688C(36, &v46);
  v35 = *(_DWORD *)(a1 + 60);
  v47[0] = *(_DWORD *)(a1 + 56);
  v47[1] = v35;
  sub_70240(v47);
  sub_70284(*(_DWORD *)(a1 + 20));
  sub_66908(42, (unsigned __int16)(v4 + 32 * *(_WORD *)(a1 + 20)));
  sub_6688C(42, &v46);
  usleep(0x3E8u);
  sub_66908(20, *(_DWORD *)(a1 + 64) & 0x1FFFF | 0x80000000);
  sub_6688C(20, &v46);
  v36 = *(_DWORD *)(a1 + 4);
  v37 = *(_DWORD *)a1;
  v38 = *(_DWORD *)(a1 + 68);
  v39 = v36 > 1;
  if ( *(_DWORD *)a1 )
    v39 = 0;
  if ( v39 )
  {
    v40 = 0;
    v37 = 0;
    v41 = (v36 << 8) & 0xF00;
  }
  else if ( v37 )
  {
    v41 = 256;
    v40 = 0x2000;
    v37 = 0x4000;
  }
  else
  {
    v40 = 0;
    v41 = 256;
  }
  if ( v38 )
  {
    v38 = 128;
    sub_702F4();
  }
  v46 = 0;
  sub_6688C(35, &v46);
  sub_66908(35, v46 & 0xFFFF709F | 0x8060 | v37 | v40 | v41 | v38);
  free(ptr);
  result = 0;
  dword_1B1440 = v43;
  return result;
}
// 1B143C: using guessed type int dword_1B143C;
// 1B1440: using guessed type int dword_1B1440;
// 1B1444: using guessed type int dword_1B1444;
// 1B1448: using guessed type int dword_1B1448;

//----- (0007075C) --------------------------------------------------------
int __fastcall sub_7075C(char a1)
{
  int v1; // r4
  int v3; // [sp+4h] [bp-8h] BYREF

  v1 = a1 & 0x3F;
  pthread_mutex_lock(&stru_1B144C);
  usleep(0xC350u);
  sub_6688C(27, &v3);
  sub_6F610(v3 & 0xFFFFFFC0 | v1);
  return pthread_mutex_unlock(&stru_1B144C);
}

//----- (000707B0) --------------------------------------------------------
int __fastcall sub_707B0(int a1, int a2)
{
  unsigned int v4; // r0
  int v6; // [sp+4h] [bp-8h] BYREF

  pthread_mutex_lock(&stru_1B144C);
  sub_6688C(27, &v6);
  if ( a2 )
    v4 = v6 & 0xFFF0FFFF | (a1 << 16) | 0xC00000;
  else
    v4 = v6 & 0xFFB0FFFF | (a1 << 16) & 0xFFBFFFFF;
  if ( !a2 )
    v4 |= 0x800000u;
  sub_6F610(v4);
  return pthread_mutex_unlock(&stru_1B144C);
}

//----- (00070808) --------------------------------------------------------
int __fastcall sub_70808(int *a1, int a2)
{
  int v5; // [sp+4h] [bp-4h] BYREF

  pthread_mutex_lock(&stru_1B144C);
  sub_66908(28, *a1);
  sub_66908(29, a1[1]);
  sub_66908(30, a1[2]);
  sub_6688C(28, &v5);
  sub_6688C(29, &v5);
  sub_6688C(30, &v5);
  sub_6688C(27, &v5);
  sub_6F610(v5 & 0x7F70FFFF | 0x80800000 | (a2 << 16));
  return pthread_mutex_unlock(&stru_1B144C);
}

//----- (000708A4) --------------------------------------------------------
int __fastcall sub_708A4(int *a1, unsigned int a2)
{
  unsigned int v4; // r5
  int *v5; // r5
  int v6; // r0
  int v7; // t1

  pthread_mutex_lock(&stru_1B1464);
  v4 = a2 >> 2;
  if ( v4 )
  {
    v5 = &a1[v4];
    v6 = 16;
    do
    {
      v7 = *a1++;
      sub_66908(v6, v7);
      v6 = 17;
    }
    while ( a1 != v5 );
  }
  return pthread_mutex_unlock(&stru_1B1464);
}

//----- (000708EC) --------------------------------------------------------
int sub_708EC()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_6688C(18, &v1);
  return v1;
}

//----- (0007090C) --------------------------------------------------------
int __fastcall sub_7090C(int a1)
{
  sub_66908(18, a1 | 0x80808000);
  dword_1B1440 = dword_1B143C;
  return sub_6FC54(dword_1B1448);
}
// 1B143C: using guessed type int dword_1B143C;
// 1B1440: using guessed type int dword_1B1440;
// 1B1448: using guessed type int dword_1B1448;

//----- (00070940) --------------------------------------------------------
int sub_70940()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_6688C(15, &v1);
  return v1;
}

//----- (00070968) --------------------------------------------------------
int __fastcall sub_70968(int a1)
{
  return sub_66908(15, a1);
}

//----- (00070974) --------------------------------------------------------
int __fastcall sub_70974(char a1)
{
  int v3; // [sp+4h] [bp-4h] BYREF

  v3 = 0;
  sub_6688C(13, &v3);
  return sub_66908(13, v3 | (1 << a1));
}

//----- (000709B8) --------------------------------------------------------
int __fastcall sub_709B8(char a1)
{
  int v3; // [sp+4h] [bp-4h] BYREF

  v3 = 0;
  sub_6688C(13, &v3);
  return sub_66908(13, v3 & ~(1 << a1));
}

//----- (000709FC) --------------------------------------------------------
int __fastcall sub_709FC(char a1)
{
  sub_70974(a1);
  usleep(0x186A0u);
  return sub_709B8(a1);
}

//----- (00070A20) --------------------------------------------------------
int sub_70A20()
{
  return usleep(0x186A0u);
}

//----- (00070A34) --------------------------------------------------------
unsigned int sub_70A34()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_6688C(0, &v1);
  return v1 >> 31;
}

//----- (00070AF4) --------------------------------------------------------
int sub_70AF4()
{
  int v1; // [sp+4h] [bp-4h] BYREF

  v1 = 0;
  sub_6688C(0, &v1);
  sub_66908(0, v1 & 0xDFFFFFFF);
  return 0;
}

//----- (00070B34) --------------------------------------------------------
int sub_70B34()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_6688C(0, &v1);
  return (v1 >> 29) & 1;
}

//----- (00070B5C) --------------------------------------------------------
int sub_70B5C()
{
  int v1; // [sp+4h] [bp-4h] BYREF

  v1 = 0;
  sub_6688C(0, &v1);
  sub_66908(0, v1 | 0x40000000);
  return 0;
}

//----- (00070B9C) --------------------------------------------------------
int sub_70B9C()
{
  int v0; // r0
  int v1; // r5
  int v2; // r0
  int v3; // r3
  int v5; // [sp+4h] [bp-48h] BYREF
  struct sysinfo info; // [sp+8h] [bp-44h] BYREF

  v0 = sub_66980();
  v1 = v0 + 0x200000;
  dword_1B1438 = v0;
  dword_1B143C = v0 + 0x200000;
  dword_1B1444 = v0 + 2162688;
  v2 = sysinfo(&info);
  if ( info.totalram <= 0x3B9ACA00 )
  {
    if ( info.totalram <= 0x1DCD6500 )
    {
      v3 = 200000000;
      if ( info.totalram > 0xBEBC200 )
        v2 = 251658240;
      else
        v3 = 117440512;
      if ( info.totalram > 0xBEBC200 )
        dword_1B1448 = v2;
      else
        v2 = v3;
      if ( info.totalram <= 0xBEBC200 )
        dword_1B1448 = v3;
    }
    else
    {
      v2 = 520093696;
      dword_1B1448 = 520093696;
    }
  }
  else
  {
    v2 = 1056964608;
    dword_1B1448 = 1056964608;
  }
  dword_1B1440 = v1;
  sub_6FC54(v2);
  sub_66908(41, dword_1B1448 + 0x200000);
  sub_6688C(41, &v5);
  sub_70AF4();
  sub_70B5C();
  return 0;
}
// 1B1438: using guessed type int dword_1B1438;
// 1B143C: using guessed type int dword_1B143C;
// 1B1440: using guessed type int dword_1B1440;
// 1B1444: using guessed type int dword_1B1444;
// 1B1448: using guessed type int dword_1B1448;

//----- (00070C98) --------------------------------------------------------
int sub_70C98()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_6688C(0, &v1);
  return (v1 >> 30) & 1;
}

//----- (00070CC0) --------------------------------------------------------
int sub_70CC0()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_6688C(0, &v1);
  return v1;
}

//----- (00070CE4) --------------------------------------------------------
int __fastcall sub_70CE4(int a1, int a2)
{
  char v3; // r5
  unsigned int v4; // r1
  unsigned int v6; // [sp+4h] [bp-8h] BYREF

  v3 = sub_6F570(a2);
  v6 = 0;
  sub_6688C(15, &v6);
  v4 = v6;
  if ( a1 )
  {
    switch ( a1 )
    {
      case 1:
        v4 = v6 & 0xFFFFC0FF | ((v3 & 0x3F) << 8);
        break;
      case 2:
        v4 = v6 & 0xFFC0FFFF | ((v3 & 0x3F) << 16);
        break;
      case 3:
        v4 = v6 & 0xC0FFFFFF | ((v3 & 0x3F) << 24);
        break;
    }
  }
  else
  {
    v4 = v6 & 0xFFFFFFC0 | v3 & 0x3F;
  }
  sub_66908(15, v4);
  return 0;
}

//----- (00070E58) --------------------------------------------------------
int __fastcall sub_70E58(int a1)
{
  char v1; // r4
  int v3; // [sp+4h] [bp-8h] BYREF

  v1 = sub_6F570(a1);
  v3 = 0;
  sub_6688C(15, &v3);
  sub_66908(
    15,
    v3 & 0xC0C0C0C0 | v1 & 0x3F | ((v1 & 0x3F) << 8) | ((v1 & 0x3F) << 16) & 0xC0FFFFFF | ((v1 & 0x3F) << 24));
  return 0;
}

//----- (00070EA8) --------------------------------------------------------
int __fastcall sub_70EA8(int a1)
{
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "open_pic", a1);
  sub_47AB4(0, s, 0);
  return -2147483135;
}

//----- (00070EF8) --------------------------------------------------------
void __fastcall sub_70EF8(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v4; // r4
  int v5; // r3
  unsigned int v6; // r4
  int v7; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  snprintf(s, 0x800u, "Dumping %u %s bytes from %p:\n", a2, "read return data", a1);
  v4 = 0;
  sub_47AB4(2, s, 0);
  do
  {
    while ( a2 > v4 )
    {
      v5 = a1[v4++];
      snprintf(s, 0x800u, "%02x ", v5);
      sub_47AB4(2, s, 0);
      if ( v4 == 16 )
        goto LABEL_5;
    }
    ++v4;
    *(_DWORD *)s = &unk_202020;
    sub_47AB4(2, s, 0);
  }
  while ( v4 != 16 );
LABEL_5:
  v6 = 0;
  do
  {
    while ( a2 <= v6 )
    {
      ++v6;
      strcpy(s, " ");
      sub_47AB4(2, s, 0);
      if ( v6 == 16 )
        goto LABEL_11;
    }
    v7 = a1[v6++];
    if ( (unsigned int)(v7 - 32) > 0x5E )
      v7 = 46;
    snprintf(s, 0x800u, "%c", v7);
    sub_47AB4(2, s, 0);
  }
  while ( v6 != 16 );
LABEL_11:
  strcpy(s, "\n");
  sub_47AB4(2, s, 0);
}

//----- (0007104C) --------------------------------------------------------
int __fastcall sub_7104C(unsigned int a1)
{
  int v2; // r6
  unsigned int v4; // [sp+0h] [bp-8h] BYREF
  __int16 v5; // [sp+4h] [bp-4h]
  char v6; // [sp+6h] [bp-2h]
  char v7; // [sp+7h] [bp-1h]

  if ( a1 > 0xF )
    return sub_70EA8(a1);
  v2 = dword_246410[2 * a1];
  if ( !v2 || !dword_246410[2 * a1 + 1] )
  {
    v5 = 0;
    v6 = 4;
    v4 = a1;
    v7 = a1;
    pthread_mutex_lock(&stru_1B147C);
    v2 = sub_73660((int)&v4);
    pthread_mutex_unlock(&stru_1B147C);
    if ( v2 >= 0 )
    {
      dword_246410[2 * a1] = v2;
      dword_246410[2 * a1 + 1] = 1;
    }
  }
  return v2;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (000710EC) --------------------------------------------------------
void __fastcall sub_710EC(unsigned int a1)
{
  int v2; // r6
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "close_pic", a1);
    sub_47AB4(0, s, 0);
  }
  else
  {
    v2 = 2 * a1;
    if ( dword_246410[2 * a1] || dword_246410[v2 + 1] )
    {
      pthread_mutex_lock(&stru_1B147C);
      sub_73804(dword_246410[2 * a1]);
      dword_246410[v2 + 1] = 0;
      pthread_mutex_unlock(&stru_1B147C);
    }
  }
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (000711A0) --------------------------------------------------------
int __fastcall sub_711A0(unsigned int a1)
{
  int v2; // r5
  int v3; // r4
  unsigned int v4; // r3
  int v6; // [sp+8h] [bp-81Ch] BYREF
  unsigned __int8 v7; // [sp+Ch] [bp-818h]
  _DWORD v8[4]; // [sp+10h] [bp-814h] BYREF
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "get_pic_version", a1);
    v3 = -2147483135;
    sub_47AB4(0, s, 0);
    return v3;
  }
  if ( !dword_246410[2 * a1 + 1] )
  {
    v3 = sub_7104C(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "get_pic_version", a1);
      sub_47AB4(0, s, 0);
      return v3;
    }
  }
  v2 = dword_246410[2 * a1];
  pthread_mutex_lock(&stru_1B147C);
  v8[1] = 6912;
  v8[0] = 386181717;
  v8[2] = 0;
  v8[3] = 0;
  v6 = 0;
  v7 = 0;
  if ( sub_738FC(v2, (int)v8, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_get_sw_ver_common");
LABEL_15:
    sub_47AB4(0, s, 0);
    goto LABEL_16;
  }
  usleep(0x30D40u);
  if ( sub_73874(v2, &v6, 5) != 5 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_get_sw_ver_common");
    goto LABEL_15;
  }
  if ( BYTE1(v6) == 23 && (unsigned __int8)v6 == 5 )
  {
    v3 = BYTE2(v6);
    v4 = BYTE2(v6) + 28;
    if ( HIBYTE(v6) == v4 >> 8 && v7 == (unsigned __int8)v4 )
      goto LABEL_10;
    snprintf(s, 0x800u, "%s failed 2!\n", "_bitmain_pic_get_sw_ver_common");
  }
  else
  {
    snprintf(s, 0x800u, "%s failed!\n", "_bitmain_pic_get_sw_ver_common");
  }
  sub_47AB4(0, s, 0);
  sub_70EF8((unsigned __int8 *)&v6, 5u);
LABEL_16:
  v3 = -2147483136;
LABEL_10:
  pthread_mutex_unlock(&stru_1B147C);
  return v3;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (000713A4) --------------------------------------------------------
int __fastcall sub_713A4(unsigned int a1)
{
  int v2; // r6
  int v3; // r4
  __int16 v5; // [sp+Ch] [bp-818h] BYREF
  _DWORD v6[4]; // [sp+10h] [bp-814h] BYREF
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "reset_pic", a1);
    v3 = -2147483135;
    sub_47AB4(0, s, 0);
    return v3;
  }
  if ( !dword_246410[2 * a1 + 1] )
  {
    v3 = sub_7104C(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "reset_pic", a1);
      sub_47AB4(0, s, 0);
      return v3;
    }
  }
  v2 = dword_246410[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_1B147C);
  v6[1] = 2816;
  v6[0] = 117746261;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  if ( sub_738FC(v2, (int)v6, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_reset_common");
LABEL_13:
    sub_47AB4(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x30D40u);
  if ( sub_73874(v2, &v5, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_reset_common");
    goto LABEL_13;
  }
  if ( (unsigned __int8)v5 == 7 && HIBYTE(v5) == 1 )
    goto LABEL_8;
  snprintf(
    s,
    0x800u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_reset_common",
    (unsigned __int8)v5,
    HIBYTE(v5));
  sub_47AB4(0, s, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_1B147C);
  usleep((__useconds_t)"d asic, will power off hash board %d\n");
  return v3;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (0007157C) --------------------------------------------------------
int __fastcall sub_7157C(unsigned int a1)
{
  int v2; // r6
  int v3; // r4
  __int16 v5; // [sp+Ch] [bp-818h] BYREF
  _DWORD v6[4]; // [sp+10h] [bp-814h] BYREF
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "jump_from_loader_to_app", a1);
    v3 = -2147483135;
    sub_47AB4(0, s, 0);
    return v3;
  }
  if ( !dword_246410[2 * a1 + 1] )
  {
    v3 = sub_7104C(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "jump_from_loader_to_app", a1);
      sub_47AB4(0, s, 0);
      return v3;
    }
  }
  v2 = dword_246410[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_1B147C);
  v6[1] = 2560;
  v6[0] = 100969045;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  if ( sub_738FC(v2, (int)v6, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_start_app_common");
LABEL_13:
    sub_47AB4(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x30D40u);
  if ( sub_73874(v2, &v5, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_start_app_common");
    goto LABEL_13;
  }
  usleep(0x30D40u);
  if ( (unsigned __int8)v5 == 6 && HIBYTE(v5) == 1 )
    goto LABEL_8;
  snprintf(
    s,
    0x800u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_start_app_common",
    (unsigned __int8)v5,
    HIBYTE(v5));
  sub_47AB4(0, s, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_1B147C);
  return v3;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (00071754) --------------------------------------------------------
int __fastcall sub_71754(unsigned int a1)
{
  int v2; // r6
  int v3; // r4
  __int16 v5; // [sp+Ch] [bp-818h] BYREF
  _DWORD v6[4]; // [sp+10h] [bp-814h] BYREF
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "enable_dc_dc", a1);
    v3 = -2147483135;
    sub_47AB4(0, s, 0);
    return v3;
  }
  if ( !dword_246410[2 * a1 + 1] )
  {
    v3 = sub_7104C(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "enable_dc_dc", a1);
      sub_47AB4(0, s, 0);
      return v3;
    }
  }
  v2 = dword_246410[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_1B147C);
  v6[1] = 1769473;
  v6[0] = 352692821;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  if ( sub_738FC(v2, (int)v6, 7) != 7 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_enable_dc_dc_common");
LABEL_13:
    sub_47AB4(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x30D40u);
  if ( sub_73874(v2, &v5, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_enable_dc_dc_common");
    goto LABEL_13;
  }
  if ( (unsigned __int8)v5 == 21 && HIBYTE(v5) == 1 )
    goto LABEL_8;
  snprintf(
    s,
    0x800u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_enable_dc_dc_common",
    (unsigned __int8)v5,
    HIBYTE(v5));
  sub_47AB4(0, s, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_1B147C);
  return v3;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (00071928) --------------------------------------------------------
int __fastcall sub_71928(unsigned int a1)
{
  int v2; // r6
  int v3; // r4
  __int16 v5; // [sp+Ch] [bp-818h] BYREF
  _DWORD v6[4]; // [sp+10h] [bp-814h] BYREF
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "disable_dc_dc", a1);
    v3 = -2147483135;
    sub_47AB4(0, s, 0);
    return v3;
  }
  if ( !dword_246410[2 * a1 + 1] )
  {
    v3 = sub_7104C(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "disable_dc_dc", a1);
      sub_47AB4(0, s, 0);
      return v3;
    }
  }
  v2 = dword_246410[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_1B147C);
  v6[1] = 1703936;
  v6[0] = 352692821;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  if ( sub_738FC(v2, (int)v6, 7) != 7 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_disable_dc_dc_common");
LABEL_13:
    sub_47AB4(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x30D40u);
  if ( sub_73874(v2, &v5, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_disable_dc_dc_common");
    goto LABEL_13;
  }
  if ( (unsigned __int8)v5 == 21 && HIBYTE(v5) == 1 )
    goto LABEL_8;
  snprintf(
    s,
    0x800u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_disable_dc_dc_common",
    (unsigned __int8)v5,
    HIBYTE(v5));
  sub_47AB4(0, s, 0);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_1B147C);
  return v3;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (00071AF4) --------------------------------------------------------
int __fastcall sub_71AF4(unsigned int a1)
{
  int v2; // r5
  int v3; // r4
  int v5; // [sp+8h] [bp-81Ch] BYREF
  __int16 v6; // [sp+Ch] [bp-818h]
  _DWORD v7[4]; // [sp+10h] [bp-814h] BYREF
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "send_pic_heart_beat", a1);
    v3 = -2147483135;
    sub_47AB4(0, s, 0);
    return v3;
  }
  if ( !dword_246410[2 * a1 + 1] )
  {
    v3 = sub_7104C(a1);
    if ( v3 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "send_pic_heart_beat", a1);
      sub_47AB4(0, s, 0);
      return v3;
    }
  }
  v2 = dword_246410[2 * a1];
  v3 = 0;
  pthread_mutex_lock(&stru_1B147C);
  v7[1] = 6656;
  v7[0] = 369404501;
  v7[2] = 0;
  v7[3] = 0;
  v5 = 0;
  v6 = 0;
  if ( sub_738FC(v2, (int)v7, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_heart_beat_common");
LABEL_13:
    sub_47AB4(0, s, 0);
    goto LABEL_14;
  }
  usleep(0x30D40u);
  if ( sub_73874(v2, &v5, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_heart_beat_common");
    goto LABEL_13;
  }
  if ( BYTE1(v5) == 22 && BYTE2(v5) == 1 )
    goto LABEL_8;
  snprintf(s, 0x800u, "%s failed!\n", "_bitmain_pic_heart_beat_common");
  sub_47AB4(0, s, 0);
  sub_70EF8((unsigned __int8 *)&v5, 6u);
LABEL_14:
  v3 = -2147483136;
LABEL_8:
  pthread_mutex_unlock(&stru_1B147C);
  return v3;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (00071CC8) --------------------------------------------------------
int __fastcall sub_71CC8(int a1)
{
  int v2; // r4
  __int16 v4; // [sp+Ch] [bp-814h] BYREF
  _DWORD v5[4]; // [sp+10h] [bp-810h] BYREF
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  v2 = 0;
  pthread_mutex_lock(&stru_1B147C);
  v5[3] = 0;
  v5[2] = 0;
  v5[0] = 17214037;
  v5[1] = 218103814;
  v4 = 0;
  if ( sub_738FC(a1, (int)v5, 8) != 8 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_seek_1704");
    goto LABEL_7;
  }
  usleep(0x30D40u);
  if ( sub_73874(a1, &v4, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_seek_1704");
    goto LABEL_7;
  }
  if ( (unsigned __int8)v4 != 1 || HIBYTE(v4) != 1 )
  {
    snprintf(
      s,
      0x800u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "_bitmain_pic_seek_1704",
      (unsigned __int8)v4,
      HIBYTE(v4));
LABEL_7:
    v2 = -2147483136;
    sub_47AB4(0, s, 0);
  }
  pthread_mutex_unlock(&stru_1B147C);
  return v2;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;

//----- (00071DF8) --------------------------------------------------------
void __fastcall sub_71DF8(unsigned __int8 *a1, int a2)
{
  int v2; // r5
  unsigned __int8 *v3; // r6
  unsigned int i; // r4
  int v5; // r3
  unsigned int v6; // r4
  int v7; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v2 = a2;
  v3 = a1;
  snprintf(s, 0x800u, "Dumping %u %s bytes from %p:\n", a2, "read return data", a1);
  sub_47AB4(2, s, 0);
  if ( v2 > 0 )
  {
    while ( 1 )
    {
      for ( i = 0; i != 16; ++i )
      {
        while ( v2 > i )
        {
          v5 = v3[i++];
          snprintf(s, 0x800u, "%02x ", v5);
          sub_47AB4(2, s, 0);
          if ( i == 16 )
            goto LABEL_6;
        }
        *(_DWORD *)s = &unk_202020;
        sub_47AB4(2, s, 0);
      }
LABEL_6:
      v6 = 0;
      do
      {
        while ( v2 <= v6 )
        {
          ++v6;
          strcpy(s, " ");
          sub_47AB4(2, s, 0);
          if ( v6 == 16 )
            goto LABEL_12;
        }
        v7 = v3[v6++];
        if ( (unsigned int)(v7 - 32) > 0x5E )
          v7 = 46;
        snprintf(s, 0x800u, "%c", v7);
        sub_47AB4(2, s, 0);
      }
      while ( v6 != 16 );
LABEL_12:
      strcpy(s, "\n");
      v3 += 16;
      sub_47AB4(2, s, 0);
      if ( v2 <= 16 )
        break;
      v2 -= 16;
    }
  }
}

//----- (00071F68) --------------------------------------------------------
int __fastcall sub_71F68(unsigned int a1, _DWORD *a2, int a3)
{
  int v6; // r8
  int v8; // r5
  __int16 v9; // r1
  _DWORD *v10; // r3
  unsigned int v11; // r2
  __int16 v12; // t1
  int v13; // r8
  unsigned __int16 v14; // r2
  unsigned __int16 v15; // r3
  int v16; // r0
  int v17; // [sp+Ch] [bp-818h] BYREF
  char v18; // [sp+10h] [bp-814h]
  char v19; // [sp+11h] [bp-813h]
  _DWORD v20[3]; // [sp+14h] [bp-810h] BYREF
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "pic_get_voltage", a1);
    v6 = -2147483135;
    sub_47AB4(0, s, 0);
    return v6;
  }
  if ( dword_246410[2 * a1 + 1] )
  {
    v6 = 0;
  }
  else
  {
    v16 = sub_7104C(a1);
    v6 = v16;
    if ( v16 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_get_voltage", a1);
      sub_47AB4(0, s, 0);
      return v6;
    }
  }
  if ( a3 != 3 )
  {
    snprintf(s, 0x800u, "%s failed: parameters error!\n", "pic_get_voltage");
    sub_47AB4(0, s, 0);
    return v6;
  }
  pthread_mutex_lock(&stru_1B147C);
  v8 = dword_246410[2 * a1];
  v18 = 0;
  v17 = 923052629;
  memset(v20, 0, 11);
  v19 = 59;
  if ( sub_738FC(v8, (int)&v17, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_read_an_voltage");
LABEL_24:
    v13 = -1;
    sub_47AB4(0, s, 0);
    goto LABEL_20;
  }
  usleep(0x30D40u);
  if ( sub_73874(v8, v20, 11) != 11 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_read_an_voltage");
    goto LABEL_24;
  }
  v9 = LOBYTE(v20[0]);
  if ( LOBYTE(v20[0]) != 11 || BYTE1(v20[0]) != 55 )
  {
    snprintf(
      s,
      0x800u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "_read_an_voltage",
      LOBYTE(v20[0]),
      BYTE1(v20[0]));
    v13 = -1;
    sub_47AB4(0, s, 0);
    goto LABEL_20;
  }
  v10 = v20;
  LOWORD(v11) = 0;
  while ( 1 )
  {
    v11 = (unsigned __int16)(v11 + v9);
    if ( v10 == &v20[2] )
      break;
    v12 = *((unsigned __int8 *)v10 + 1);
    v10 = (_DWORD *)((char *)v10 + 1);
    v9 = v12;
  }
  if ( BYTE1(v20[2]) != v11 >> 8 || BYTE2(v20[2]) != (unsigned __int8)v11 )
  {
    snprintf(s, 0x800u, "%s failed 2!\n", "_read_an_voltage");
    goto LABEL_24;
  }
  v13 = 0;
  v14 = __rev16(*(unsigned __int16 *)((char *)&v20[1] + 1));
  v15 = __rev16(*(unsigned __int16 *)((char *)&v20[1] + 3));
  *a2 = (unsigned __int16)__rev16(*(unsigned __int16 *)((char *)v20 + 3));
  a2[1] = v14;
  a2[2] = v15;
LABEL_20:
  pthread_mutex_unlock(&stru_1B147C);
  return v13;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (000721F8) --------------------------------------------------------
int __fastcall sub_721F8(unsigned int a1, __int16 a2, __int16 a3, int a4, int a5)
{
  int v9; // r10
  int v10; // r4
  int v11; // r7
  __int16 v12; // r5
  unsigned __int8 *v13; // r6
  char *v14; // r2
  unsigned int v15; // r3
  unsigned int v16; // t1
  __int16 v18; // [sp+Ch] [bp-828h] BYREF
  __int16 v19; // [sp+10h] [bp-824h] BYREF
  char v20; // [sp+12h] [bp-822h]
  char v21; // [sp+13h] [bp-821h]
  char v22; // [sp+14h] [bp-820h]
  char v23; // [sp+15h] [bp-81Fh]
  int v24; // [sp+16h] [bp-81Eh]
  int v25; // [sp+1Ah] [bp-81Ah]
  int v26; // [sp+1Eh] [bp-816h]
  int v27; // [sp+22h] [bp-812h]
  int v28; // [sp+26h] [bp-80Eh]
  int v29; // [sp+2Ah] [bp-80Ah]
  __int16 v30; // [sp+2Eh] [bp-806h]
  char s[2048]; // [sp+30h] [bp-804h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "app_write_data_into_flash", a1);
    v11 = -2147483135;
    sub_47AB4(0, s, 0);
    return v11;
  }
  if ( !dword_246410[2 * a1 + 1] )
  {
    v11 = sub_7104C(a1);
    if ( v11 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "app_write_data_into_flash", a1);
      sub_47AB4(0, s, 0);
      return v11;
    }
  }
  v9 = dword_246410[2 * a1];
  v10 = 0;
  pthread_mutex_lock(&stru_1B147C);
  if ( a5 >= 16 )
    v11 = 16;
  else
    v11 = a5;
  v23 = a3;
  v20 = a5 + 6;
  v22 = a2;
  v12 = (unsigned __int8)(a5 + 6) + a3 + 53 + a2;
  v19 = -21931;
  v18 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v21 = 53;
  if ( a5 > 0 )
  {
    v13 = (unsigned __int8 *)(a4 - 1);
    do
    {
      v16 = *++v13;
      v15 = v16;
      if ( (v10 & 1) == 0 && v15 > 0x3F )
      {
        snprintf(s, 0x800u, "%s: the data[%d] must less than 0x3f\n", "_app_write_data_into_flash_1704_v8", v10);
        sub_47AB4(v10 & 1, s, v10 & 1);
        LOWORD(v15) = *v13;
      }
      v14 = (char *)&v19 + v10++;
      v14[6] = v15;
      v12 += v15;
    }
    while ( v11 > v10 );
  }
  *((_BYTE *)&v19 + (unsigned __int16)(v11 + 6)) = HIBYTE(v12);
  *((_BYTE *)&v19 + (unsigned __int16)(v11 + 7)) = v12;
  if ( sub_738FC(v9, (int)&v19, (unsigned __int16)(v11 + 8)) == (unsigned __int16)(v11 + 8) )
  {
    usleep(0x30D40u);
    if ( sub_73874(v9, &v18, 2) == 2 )
    {
      if ( (unsigned __int8)v18 != 53 || HIBYTE(v18) != 1 )
      {
        v11 = 0;
        snprintf(
          s,
          0x800u,
          "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_app_write_data_into_flash_1704_v8",
          (unsigned __int8)v18,
          HIBYTE(v18));
        sub_47AB4(0, s, 0);
      }
      goto LABEL_15;
    }
    snprintf(s, 0x800u, "%s read iic 2 err\n", "_app_write_data_into_flash_1704_v8");
  }
  else
  {
    snprintf(s, 0x800u, "%s write iic 2 err\n", "_app_write_data_into_flash_1704_v8");
  }
  v11 = 0;
  sub_47AB4(0, s, 0);
LABEL_15:
  pthread_mutex_unlock(&stru_1B147C);
  return v11;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (000724B8) --------------------------------------------------------
signed int __fastcall sub_724B8(unsigned int a1, __int16 a2, __int16 a3, void *a4, int a5)
{
  int v9; // r7
  int v10; // r8
  unsigned __int8 *v11; // r0
  int v12; // r2
  signed int v13; // r4
  unsigned __int8 *v14; // r6
  const char *v15; // r2
  int v17; // r3
  int v18; // r8
  __int16 v19; // r0
  unsigned int v20; // r3
  unsigned int v21; // r2
  int v22; // r3
  unsigned __int8 *v23; // r7
  int v24; // [sp+14h] [bp-810h] BYREF
  char v25; // [sp+18h] [bp-80Ch]
  char v26; // [sp+19h] [bp-80Bh]
  char v27; // [sp+1Ah] [bp-80Ah]
  char v28; // [sp+1Bh] [bp-809h]
  char v29; // [sp+1Ch] [bp-808h]
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a1 > 0xF )
  {
    snprintf(s, 0x800u, "%s: Bad pic param, input chain is %d\n", "app_read_data_from_flash", a1);
    v13 = -2147483135;
    sub_47AB4(0, s, 0);
    return v13;
  }
  if ( !dword_246410[2 * a1 + 1] )
  {
    v13 = sub_7104C(a1);
    if ( v13 < 0 )
    {
      snprintf(s, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "app_read_data_from_flash", a1);
      sub_47AB4(0, s, 0);
      return v13;
    }
  }
  v9 = a5 + 5;
  v10 = dword_246410[2 * a1];
  pthread_mutex_lock(&stru_1B147C);
  v11 = (unsigned __int8 *)malloc(a5 + 5);
  LOWORD(v12) = -21931;
  if ( a5 >= 16 )
    v13 = 16;
  else
    v13 = a5;
  HIWORD(v12) = 13831;
  v24 = v12;
  v14 = v11;
  v25 = a2;
  v26 = a3;
  v27 = v13;
  v29 = v13 + 61 + a3 + a2;
  v28 = (unsigned __int16)(v13 + 61 + a3 + a2) >> 8;
  if ( sub_738FC(v10, (int)&v24, 9) == 9 )
  {
    usleep(0x30D40u);
    if ( v9 == sub_73874(v10, v14, a5 + 5) )
    {
      v17 = v14[1];
      v18 = *v14;
      v19 = *v14;
      if ( v17 == 54 && v14[2] == 1 && v9 == v18 )
      {
        if ( a5 + 3 > 0 )
        {
          LOWORD(v21) = 0;
          LOWORD(v22) = 0;
          while ( 1 )
          {
            v22 = (unsigned __int16)(v22 + 1);
            v21 = (unsigned __int16)(v21 + v19);
            if ( v22 >= a5 + 3 )
              break;
            v19 = v14[v22];
          }
          v20 = v21 >> 8;
        }
        else
        {
          v20 = 0;
          LOBYTE(v21) = 0;
        }
        v23 = &v14[v9];
        if ( *(v23 - 2) == v20 && *(v23 - 1) == (unsigned __int8)v21 )
        {
          memcpy(a4, v14 + 3, v13);
        }
        else
        {
          v13 = 0;
          snprintf(s, 0x800u, "%s failed 2!\n", "_app_read_data_from_flash_1704_v8");
          sub_47AB4(0, s, 0);
          sub_71DF8(v14, v18);
        }
      }
      else
      {
        snprintf(
          s,
          0x800u,
          "%s failed !\n read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x\n",
          "_app_read_data_from_flash_1704_v8",
          v18,
          v17,
          v14[2]);
        v13 = 0;
        sub_47AB4(0, s, 0);
        sub_71DF8(v14, a5 + 5);
      }
      goto LABEL_9;
    }
    v15 = "%s read iic 2 err\n";
  }
  else
  {
    v15 = "%s write iic 2 err\n";
  }
  v13 = 0;
  snprintf(s, 0x800u, v15, "_app_read_data_from_flash_1704_v8");
  sub_47AB4(0, s, 0);
LABEL_9:
  free(v14);
  pthread_mutex_unlock(&stru_1B147C);
  return v13;
}
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (00072790) --------------------------------------------------------
int __fastcall sub_72790(unsigned int a1, const char *a2)
{
  int v4; // r4
  int v5; // r5
  FILE *v6; // r0
  FILE *v7; // r6
  _BYTE *v8; // r4
  __int16 v9; // r0
  int v10; // r4
  int *v11; // r3
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  _BYTE *v16; // r0
  char *v17; // r2
  __int16 v18; // r3
  __int16 v19; // t1
  __int16 v21; // [sp+Ch] [bp-1BC4h] BYREF
  char v22[4]; // [sp+10h] [bp-1BC0h] BYREF
  char v23; // [sp+14h] [bp-1BBCh]
  char v24; // [sp+17h] [bp-1BB9h] BYREF
  int v25; // [sp+18h] [bp-1BB8h]
  int v26; // [sp+1Ch] [bp-1BB4h]
  int v27; // [sp+20h] [bp-1BB0h]
  int v28; // [sp+24h] [bp-1BACh] BYREF
  int v29; // [sp+28h] [bp-1BA8h] BYREF
  _DWORD v30[4]; // [sp+2Ch] [bp-1BA4h] BYREF
  char v31; // [sp+3Ch] [bp-1B94h]
  char v32; // [sp+3Dh] [bp-1B93h]
  int v33; // [sp+3Eh] [bp-1B92h]
  int v34; // [sp+42h] [bp-1B8Eh]
  __int16 v35; // [sp+46h] [bp-1B8Ah]
  char s[8]; // [sp+48h] [bp-1B88h] BYREF
  _BYTE v37[5000]; // [sp+848h] [bp-1388h] BYREF

  if ( a1 > 0xF )
  {
    v10 = -2147483135;
    snprintf(v37, 0x800u, "%s: Bad pic param, input chain is %d\n", "upgrade_pic", a1);
    sub_47AB4(0, v37, 0);
    return v10;
  }
  if ( !dword_246410[2 * a1 + 1] )
  {
    v4 = sub_7104C(a1);
    if ( v4 < 0 )
    {
      snprintf(v37, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "upgrade_pic", a1);
      sub_47AB4(0, v37, 0);
      return v4;
    }
  }
  memset(v37, 0, sizeof(v37));
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v5 = dword_246410[2 * a1];
  v25 = 0;
  *(_DWORD *)v22 = 0;
  v23 = 0;
  snprintf(s, 0x800u, "%s\n", "_update_pic_app_program_1704");
  sub_47AB4(2, s, 0);
  v6 = (FILE *)fopen64(a2, "r");
  v7 = v6;
  if ( !v6 )
  {
    snprintf(s, 0x800u, "%s: open %s failed\n", "_update_pic_app_program_1704", a2);
    v10 = -2147483136;
    sub_47AB4(0, s, 0);
    return v10;
  }
  fseek(v6, 0, 0);
  v8 = v37;
  memset(v37, 0, sizeof(v37));
  snprintf(s, 0x800u, "%s: pic_flash_length = %d\n", "_update_pic_app_program_1704", 2432);
  sub_47AB4(2, s, 0);
  do
  {
    v8 += 2;
    fgets(v22, 1023, v7);
    v9 = strtoul(v22, 0, 16);
    *(v8 - 1) = v9;
    *(v8 - 2) = HIBYTE(v9);
  }
  while ( &v37[4864] != v8 );
  fclose(v7);
  v10 = sub_713A4(a1);
  if ( v10 )
  {
LABEL_30:
    snprintf(s, 0x800u, aSResetPicError, "_update_pic_app_program_1704");
LABEL_32:
    sub_47AB4(0, s, 0);
    return v10;
  }
  v10 = sub_71CC8(v5);
  if ( v10 )
  {
    snprintf(s, 0x800u, "%s set 1704 flash pointer err\n", "_erase_pic_app");
    sub_47AB4(0, s, 0);
    snprintf(s, 0x800u, "%s: erase app flash error!\n\n", "_update_pic_app_program_1704");
    goto LABEL_32;
  }
  pthread_mutex_lock(&stru_1B147C);
  v29 = 67414613;
  LOWORD(v30[0]) = 2048;
  v21 = 0;
  if ( sub_738FC(v5, (int)&v29, 6) != 6 )
  {
    snprintf(s, 0x800u, "%s write iic err\n", "_bitmain_pic_erase_1704");
    goto LABEL_41;
  }
  usleep(0x30D40u);
  if ( sub_73874(v5, &v21, 2) != 2 )
  {
    snprintf(s, 0x800u, "%s read iic err\n", "_bitmain_pic_erase_1704");
    goto LABEL_41;
  }
  usleep(0x30D40u);
  if ( (unsigned __int8)v21 != 4 || HIBYTE(v21) != 1 )
  {
    snprintf(
      s,
      0x800u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "_bitmain_pic_erase_1704",
      (unsigned __int8)v21,
      HIBYTE(v21));
LABEL_41:
    sub_47AB4(0, s, 0);
  }
  pthread_mutex_unlock(&stru_1B147C);
  v10 = sub_71CC8(v5);
  if ( v10 )
  {
    snprintf(s, 0x800u, aSSet1704FlashP_0, "_update_pic_app_program_1704");
    goto LABEL_32;
  }
  do
  {
    v11 = (int *)&v37[16 * v10];
    v12 = *v11;
    v13 = v11[1];
    v14 = v11[2];
    v15 = v11[3];
    v25 = v12;
    v26 = v13;
    v27 = v14;
    v28 = v15;
    snprintf(s, 0x800u, "send pic program time: %d", v10);
    sub_47AB4(2, s, 0);
    pthread_mutex_lock(&stru_1B147C);
    v16 = v30;
    v17 = &v24;
    v18 = 22;
    v33 = 0;
    v21 = 0;
    v34 = 0;
    v35 = 0;
    memset(v30, 0, sizeof(v30));
    v29 = 34908757;
    do
    {
      v19 = (unsigned __int8)*++v17;
      v18 += v19;
      *v16++ = v19;
    }
    while ( (char *)&v28 + 3 != v17 );
    v31 = HIBYTE(v18);
    v32 = v18;
    if ( sub_738FC(v5, (int)&v29, 22) == 22 )
    {
      usleep(0x30D40u);
      if ( sub_73874(v5, &v21, 2) == 2 )
      {
        if ( (unsigned __int8)v21 == 2 && HIBYTE(v21) == 1 )
        {
          v29 = 84191829;
          LOWORD(v30[0]) = 2304;
          if ( sub_738FC(v5, (int)&v29, 6) == 6 )
          {
            usleep(0x30D40u);
            if ( sub_73874(v5, &v21, 2) == 2 )
            {
              if ( (unsigned __int8)v21 == 5 && HIBYTE(v21) == 1 )
              {
                snprintf(s, 0x800u, "%s  success write to pic flash\n", "_bitmain_pic_write_1704");
                sub_47AB4(2, s, 0);
                goto LABEL_28;
              }
              snprintf(
                s,
                0x800u,
                "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
                "_bitmain_pic_write_1704",
                (unsigned __int8)v21,
                HIBYTE(v21));
            }
            else
            {
              snprintf(s, 0x800u, "%s read iic 2 err\n", "_bitmain_pic_write_1704");
            }
          }
          else
          {
            snprintf(s, 0x800u, "%s write iic 2 err\n", "_bitmain_pic_write_1704");
          }
        }
        else
        {
          snprintf(
            s,
            0x800u,
            "%s failed 1! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
            "_bitmain_pic_write_1704",
            (unsigned __int8)v21,
            HIBYTE(v21));
        }
      }
      else
      {
        snprintf(s, 0x800u, "%s read iic 1 err\n", "_bitmain_pic_write_1704");
      }
    }
    else
    {
      snprintf(s, 0x800u, "%s write iic 1 err\n", "_bitmain_pic_write_1704");
    }
    sub_47AB4(0, s, 0);
LABEL_28:
    ++v10;
    pthread_mutex_unlock(&stru_1B147C);
  }
  while ( v10 != 304 );
  v10 = sub_713A4(a1);
  if ( v10 )
    goto LABEL_30;
  return v10;
}
// 124CC: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1B147C: using guessed type pthread_mutex_t stru_1B147C;
// 246410: using guessed type _DWORD dword_246410[32];

//----- (00072DE0) --------------------------------------------------------
int sub_72DE0()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v1, "set DA conversion N failed\n");
  sub_47AB4(0, v1, 0);
  return -2147482880;
}

//----- (00072E2C) --------------------------------------------------------
int sub_72E2C()
{
  int v0; // r5
  int result; // r0
  _DWORD v2[3]; // [sp+0h] [bp-Ch] BYREF

  v2[0] = 0;
  v2[1] = &loc_20000;
  pthread_mutex_lock(&stru_1B1494);
  v0 = sub_73660((int)v2);
  pthread_mutex_unlock(&stru_1B1494);
  result = v0;
  if ( v0 >= 0 )
  {
    dword_1B14AC = v0;
    dword_1B14B0 = 1;
  }
  return result;
}
// 1B1494: using guessed type pthread_mutex_t stru_1B1494;
// 1B14AC: using guessed type int dword_1B14AC;
// 1B14B0: using guessed type int dword_1B14B0;

//----- (00072E84) --------------------------------------------------------
int __fastcall sub_72E84(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4)
{
  unsigned int v7; // r4
  unsigned int v8; // r3
  unsigned __int8 *v9; // r4
  int v10; // r3
  unsigned __int8 *v11; // r1
  int v12; // r3
  __int16 v13; // t1
  int v14; // r4
  unsigned __int8 *v15; // r7
  int v16; // t1
  int v17; // r3
  int v18; // r4
  int v20; // [sp+0h] [bp-834h]
  int v22; // [sp+10h] [bp-824h]
  unsigned __int8 *v24; // [sp+18h] [bp-81Ch]
  unsigned __int8 *v25; // [sp+1Ch] [bp-818h]
  unsigned __int8 *v26; // [sp+20h] [bp-814h]
  unsigned __int8 v27; // [sp+2Fh] [bp-805h] BYREF
  char s[2048]; // [sp+30h] [bp-804h] BYREF

  v27 = 17;
  v26 = a4 + 8;
  v24 = a4 + 1;
  pthread_mutex_lock(&stru_1B1494);
  v25 = a4 + 5;
  v22 = 0;
  while ( 1 )
  {
    LOBYTE(v7) = 0;
    v8 = 0;
    do
    {
      v7 = (unsigned __int8)(v7 + 1);
      sub_73A24(a1, &v27, 1, (int)&a2[v8], 1);
      v8 = v7;
    }
    while ( v7 < a3 );
    v9 = a4;
    usleep((__useconds_t)&loc_61A80);
    do
    {
      v10 = (int)v9++;
      sub_73984(a1, &v27, 1, v10, 1);
    }
    while ( v26 != v9 );
    usleep(0x186A0u);
    v11 = v24;
    LOWORD(v12) = 0;
    do
    {
      v13 = *++v11;
      v12 = (unsigned __int16)(v12 + v13);
    }
    while ( v11 != v25 );
    if ( v12 != (unsigned __int16)(a4[6] + (a4[7] << 8)) )
    {
      snprintf(
        s,
        0x800u,
        "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x\n",
        v12,
        (unsigned __int16)(a4[6] + (a4[7] << 8)));
      sub_47AB4(0, s, 0);
      goto LABEL_10;
    }
    if ( *a2 == *a4 && a2[1] == a4[1] && a2[3] == a4[3] && a4[2] == 6 )
      break;
    strcpy(s, "power reply the bad data\n");
    sub_47AB4(0, s, 0);
LABEL_10:
    v14 = 0;
    v15 = a4 - 1;
    do
    {
      v16 = *++v15;
      v17 = v14++;
      snprintf(s, 0x800u, "read_back_data[%d] = 0x%02x", v17, v16);
      sub_47AB4(0, s, 0);
    }
    while ( v14 != 8 );
    v20 = v22++;
    snprintf(s, 0x800u, "Send power cmd(0x%02x) failed, retry %d\n", a2[3], v20);
    sub_47AB4(0, s, 0);
    if ( v22 == 3 )
    {
      v18 = -2147482880;
      goto LABEL_14;
    }
  }
  v18 = 0;
LABEL_14:
  pthread_mutex_unlock(&stru_1B1494);
  return v18;
}
// 1B1494: using guessed type pthread_mutex_t stru_1B1494;

//----- (00073100) --------------------------------------------------------
int __fastcall sub_73100(int a1, __int16 a2)
{
  int v3; // [sp+0h] [bp-14h] BYREF
  __int16 v4; // [sp+4h] [bp-10h]
  __int16 v5; // [sp+6h] [bp-Eh]
  int v6; // [sp+8h] [bp-Ch] BYREF
  int v7; // [sp+Ch] [bp-8h]

  v3 = -2096715179;
  v5 = a2 + 137;
  v6 = 0;
  v4 = (unsigned __int8)a2;
  v7 = 0;
  if ( sub_72E84(a1, (unsigned __int8 *)&v3, 8u, (unsigned __int8 *)&v6) )
    return sub_72DE0();
  else
    return (unsigned __int16)v7;
}

//----- (0007316C) --------------------------------------------------------
int sub_7316C()
{
  int result; // r0

  result = dword_1B14AC;
  if ( !dword_1B14AC || !dword_1B14B0 )
    return sub_72E2C();
  return result;
}
// 1B14AC: using guessed type int dword_1B14AC;
// 1B14B0: using guessed type int dword_1B14B0;

//----- (00073190) --------------------------------------------------------
int sub_73190()
{
  if ( !dword_1B14AC || !dword_1B14B0 )
  {
    pthread_mutex_lock(&stru_1B1494);
    sub_73804(dword_1B14AC);
    dword_1B14B0 = 0;
    pthread_mutex_unlock(&stru_1B1494);
  }
  return 0;
}
// 1B1494: using guessed type pthread_mutex_t stru_1B1494;
// 1B14AC: using guessed type int dword_1B14AC;
// 1B14B0: using guessed type int dword_1B14B0;

//----- (000731E4) --------------------------------------------------------
int sub_731E4()
{
  int v0; // r5
  int v1; // r7
  int v2; // r4
  int v3; // r6
  int v5; // [sp+8h] [bp-814h] BYREF
  __int16 v6; // [sp+Ch] [bp-810h]
  int v7; // [sp+10h] [bp-80Ch] BYREF
  int v8; // [sp+14h] [bp-808h]
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  if ( dword_1B14B0 || (v0 = sub_72E2C(), v0 >= 0) )
  {
    v1 = dword_1B14AC;
    v2 = 10;
    do
    {
      LOBYTE(v5) = -1;
      LOBYTE(v7) = 0;
      pthread_mutex_lock(&stru_1B1494);
      if ( sub_73984(v1, (unsigned __int8 *)&v7, 1, (int)&v5, 1) == 1 )
      {
        v3 = (unsigned __int8)v5;
        pthread_mutex_unlock(&stru_1B1494);
        if ( v3 == 245 )
          break;
      }
      else
      {
        snprintf(s, 0x800u, "%s: iic read is failed\n", "_bitmain_get_power_code_version");
        sub_47AB4(0, s, 0);
        pthread_mutex_unlock(&stru_1B1494);
      }
      usleep(0x186A0u);
      --v2;
    }
    while ( v2 );
    v5 = 33860181;
    v7 = 0;
    v8 = 0;
    v6 = 6;
    if ( sub_72E84(v1, (unsigned __int8 *)&v5, 6u, (unsigned __int8 *)&v7) )
    {
      v0 = -2147482880;
      strcpy(s, "get power version failed\n");
      sub_47AB4(0, s, 0);
    }
    else
    {
      return (unsigned __int16)v8;
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_version");
    sub_47AB4(0, s, 0);
  }
  return v0;
}
// 1B1494: using guessed type pthread_mutex_t stru_1B1494;
// 1B14AC: using guessed type int dword_1B14AC;
// 1B14B0: using guessed type int dword_1B14B0;

//----- (00073380) --------------------------------------------------------
void sub_73380()
{
  int v0; // [sp+0h] [bp-810h] BYREF
  __int16 v1; // [sp+4h] [bp-80Ch]
  _DWORD v2[2]; // [sp+8h] [bp-808h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( dword_1B14B0 || sub_72E2C() >= 0 )
  {
    v2[1] = 0;
    v2[0] = 0;
    v0 = 50637397;
    v1 = 7;
    if ( sub_72E84(dword_1B14AC, (unsigned __int8 *)&v0, 6u, (unsigned __int8 *)v2) )
    {
      strcpy(s, "get AD conversion N failed\n");
      sub_47AB4(0, s, 0);
      strcpy(s, "can nont get voltage\n");
      sub_47AB4(0, s, 0);
    }
  }
  else
  {
    snprintf(s, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_voltage");
    sub_47AB4(0, s, 0);
  }
}
// 1B14AC: using guessed type int dword_1B14AC;
// 1B14B0: using guessed type int dword_1B14B0;

//----- (000734CC) --------------------------------------------------------
int sub_734CC()
{
  double v0; // d0
  unsigned int v1; // r1
  int v2; // r5
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( dword_1B14B0 || (v2 = sub_72E2C(), v2 >= 0) )
  {
    v1 = (int)(765.411764 - v0 * 35.833333);
    if ( v1 > 0xFF )
      return -2147482879;
    else
      return sub_73100(dword_1B14AC, (unsigned __int8)v1);
  }
  else
  {
    snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage");
    sub_47AB4(0, v4, 0);
  }
  return v2;
}
// 734F8: variable 'v0' is possibly undefined
// 1B14AC: using guessed type int dword_1B14AC;
// 1B14B0: using guessed type int dword_1B14B0;

//----- (00073584) --------------------------------------------------------
int __fastcall sub_73584(__int16 a1)
{
  int v2; // r5
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_1B14B0 )
    return sub_73100(dword_1B14AC, a1);
  v2 = sub_72E2C();
  if ( v2 >= 0 )
    return sub_73100(dword_1B14AC, a1);
  snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage_by_n");
  sub_47AB4(0, v4, 0);
  return v2;
}
// 1B14AC: using guessed type int dword_1B14AC;
// 1B14B0: using guessed type int dword_1B14B0;

//----- (00073604) --------------------------------------------------------
int sub_73604()
{
  double v0; // d0

  return (int)(765.411764 - v0 * 35.833333);
}
// 7360C: variable 'v0' is possibly undefined

//----- (00073660) --------------------------------------------------------
int __fastcall sub_73660(int a1)
{
  int v2; // r0
  int v3; // r5
  int v4; // r0
  char v6[2052]; // [sp+0h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_1B14B4) )
  {
    v3 = -4;
    strcpy(v6, "failed to iic lock\n");
    sub_47AB4(0, v6, 0);
    return v3;
  }
  if ( a1 )
  {
    v2 = sub_73B94();
    v3 = v2;
    if ( v2 < 0 )
    {
      v3 = -1;
      strcpy(v6, "failed to i2c_init\n");
      sub_47AB4(0, v6, 0);
    }
    else
    {
      if ( sub_7467C(v2, *(unsigned __int16 *)(a1 + 4)) )
      {
        strcpy(v6, "failed to i2c_select\n");
        sub_47AB4(0, v6, 0);
        goto LABEL_6;
      }
      if ( sub_74568(v3, 1795, (2 * *(unsigned __int8 *)(a1 + 7)) | (16 * *(unsigned __int8 *)(a1 + 6))) )
      {
        strcpy(v6, "failed to i2c_ioctl\n");
        sub_47AB4(0, v6, 0);
LABEL_6:
        if ( v3 )
        {
          v4 = v3;
          v3 = -1;
          sub_73C78(v4);
        }
        else
        {
          v3 = -1;
        }
      }
    }
  }
  else
  {
    v3 = -3;
    strcpy(v6, "bad param\n");
    sub_47AB4(0, v6, 0);
  }
  pthread_mutex_unlock(&stru_1B14B4);
  return v3;
}
// 1B14B4: using guessed type pthread_mutex_t stru_1B14B4;

//----- (00073804) --------------------------------------------------------
void __fastcall sub_73804(int a1)
{
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( pthread_mutex_lock(&stru_1B14B4) )
  {
    strcpy(v2, "failed to i2c lock\n");
    sub_47AB4(0, v2, 0);
  }
  else
  {
    sub_73C78(a1);
    pthread_mutex_unlock(&stru_1B14B4);
  }
}
// 1B14B4: using guessed type pthread_mutex_t stru_1B14B4;

//----- (00073874) --------------------------------------------------------
int __fastcall sub_73874(int a1, _BYTE *a2, int a3)
{
  int v6; // r4
  char v8[2048]; // [sp+0h] [bp-800h] BYREF

  if ( pthread_mutex_lock(&stru_1B14B4) )
  {
    v6 = -4;
    strcpy(v8, "failed to i2c lock\n");
    sub_47AB4(0, v8, 0);
  }
  else
  {
    v6 = sub_73DA0(a1, a2, a3);
    pthread_mutex_unlock(&stru_1B14B4);
  }
  return v6;
}
// 1B14B4: using guessed type pthread_mutex_t stru_1B14B4;

//----- (000738FC) --------------------------------------------------------
int __fastcall sub_738FC(int a1, int a2, int a3)
{
  int v6; // r4
  char v8[2048]; // [sp+0h] [bp-800h] BYREF

  if ( pthread_mutex_lock(&stru_1B14B4) )
  {
    v6 = -4;
    strcpy(v8, "failed to i2c lock\n");
    sub_47AB4(0, v8, 0);
  }
  else
  {
    v6 = sub_73F8C(a1, a2, a3);
    pthread_mutex_unlock(&stru_1B14B4);
  }
  return v6;
}
// 1B14B4: using guessed type pthread_mutex_t stru_1B14B4;

//----- (00073984) --------------------------------------------------------
int __fastcall sub_73984(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v9; // r4
  char v11[2052]; // [sp+8h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_1B14B4) )
  {
    v9 = -4;
    strcpy(v11, "failed to i2c lock\n");
    sub_47AB4(0, v11, 0);
  }
  else
  {
    v9 = sub_7411C(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&stru_1B14B4);
  }
  return v9;
}
// 1B14B4: using guessed type pthread_mutex_t stru_1B14B4;

//----- (00073A24) --------------------------------------------------------
int __fastcall sub_73A24(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v9; // r4
  char v11[2052]; // [sp+8h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_1B14B4) )
  {
    v9 = -4;
    strcpy(v11, "failed to i2c lock\n");
    sub_47AB4(0, v11, 0);
  }
  else
  {
    v9 = sub_7436C(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&stru_1B14B4);
  }
  return v9;
}
// 1B14B4: using guessed type pthread_mutex_t stru_1B14B4;

//----- (00073AC4) --------------------------------------------------------
int __fastcall sub_73AC4(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00073AD4) --------------------------------------------------------
unsigned int sub_73AD4()
{
  int v0; // r4
  int v2; // [sp+4h] [bp-8h] BYREF

  v0 = 601;
  v2 = 0;
  do
  {
    sub_6688C(12, &v2);
    if ( v2 < 0 )
      return (unsigned int)v2 >> 31;
    usleep(0x1388u);
    --v0;
  }
  while ( v0 );
  return 0;
}

//----- (00073B30) --------------------------------------------------------
unsigned int __fastcall sub_73B30(_BYTE *a1)
{
  int v2; // r4
  unsigned int result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  v2 = 601;
  v4 = 0;
  do
  {
    sub_6688C(12, &v4);
    if ( v4 < 0 )
    {
      result = (unsigned int)v4 >> 31;
      *a1 = v4;
      return result;
    }
    usleep(0x1388u);
    --v2;
  }
  while ( v2 );
  return 0;
}

//----- (00073B94) --------------------------------------------------------
int sub_73B94()
{
  int v0; // r4
  int *v1; // r6
  int v3; // [sp+Ch] [bp-804h] BYREF
  _DWORD v4[512]; // [sp+10h] [bp-800h] BYREF

  v3 = -1;
  if ( dword_1B0E60 )
  {
    v0 = dword_1B14CC;
    if ( dword_1B14CC )
    {
      v1 = (int *)dword_1B14D0;
    }
    else
    {
      v1 = sub_69ED4((int)sub_73AC4, 0, 0);
      dword_1B14D0 = (int)v1;
      pthread_mutex_init(&stru_1B14D4, 0);
      v0 = dword_1B14CC;
    }
    dword_1B14CC = v0 + 1;
    v3 = v0 + 1;
    v4[0] = 0;
    v4[1] = 0;
    sub_69F24(v1, &v3, 4u, v4, 8u);
    return v3;
  }
  else
  {
    strcpy((char *)v4, "please init platform first!!\n");
    sub_47AB4(0, (const char *)v4, 0);
    return -2;
  }
}
// 1B0E60: using guessed type int dword_1B0E60;
// 1B14CC: using guessed type int dword_1B14CC;
// 1B14D0: using guessed type int dword_1B14D0;

//----- (00073C78) --------------------------------------------------------
void __fastcall sub_73C78(int a1)
{
  _DWORD *v1; // r4
  int v2; // [sp+4h] [bp-804h] BYREF
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v2 = a1;
  if ( pthread_mutex_lock(&stru_1B14D4) )
  {
    strcpy(s, "failed to i2c lock\n");
    sub_47AB4(0, s, 0);
  }
  else
  {
    if ( sub_69F3C((int *)dword_1B14D0, (int)&v2) == (int *)1 )
    {
      sub_69F5C((int *)dword_1B14D0, (int)&v2);
    }
    else
    {
      snprintf(s, 0x800u, "ctx(%d) is not inited\n", v2);
      sub_47AB4(1, s, 0);
    }
    v1 = sub_6A044(dword_1B14D0);
    if ( ((int (*)(void))*v1)() )
    {
      while ( ((int (__fastcall *)(_DWORD *))*v1)(v1) )
        ;
      j_free(v1);
      pthread_mutex_unlock(&stru_1B14D4);
    }
    else
    {
      j_free(v1);
      pthread_mutex_unlock(&stru_1B14D4);
      dword_1B14CC = 0;
      sub_6A018((void (__fastcall ***)(_DWORD))dword_1B14D0);
      dword_1B14D0 = 0;
    }
  }
}
// 1B14CC: using guessed type int dword_1B14CC;
// 1B14D0: using guessed type int dword_1B14D0;

//----- (00073DA0) --------------------------------------------------------
int __fastcall sub_73DA0(int a1, _BYTE *a2, int a3)
{
  void *v5; // r0
  int v6; // r5
  _BYTE *v7; // r8
  _BYTE *v8; // r0
  int v10; // [sp+4h] [bp-80Ch] BYREF
  void *ptr; // [sp+Ch] [bp-804h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v10 = a1;
  if ( pthread_mutex_lock(&stru_1B14D4) )
  {
    strcpy(s, "failed to i2c lock\n");
    sub_47AB4(0, s, 0);
    return -1;
  }
  else
  {
    ptr = 0;
    if ( sub_69FD4((int *)dword_1B14D0, (int)&v10, &ptr) == 1 )
    {
      v5 = ptr;
      v6 = (*(_DWORD *)ptr << 26)
         | 0x2000000
         | (*((_DWORD *)ptr + 1) >> 4 << 20)
         | (*((_DWORD *)ptr + 1) << 15) & 0x70000;
      if ( a3 )
      {
        v7 = &a2[a3];
        while ( 1 )
        {
          if ( !sub_73AD4() )
          {
            free(ptr);
            strcpy(s, "iic not ready 4 read1\n");
            sub_47AB4(0, s, 0);
            pthread_mutex_unlock(&stru_1B14D4);
            return -2;
          }
          sub_66908(12, v6);
          v8 = a2++;
          if ( !sub_73B30(v8) )
            break;
          if ( a2 == v7 )
          {
            v5 = ptr;
            goto LABEL_10;
          }
        }
        free(ptr);
        strcpy(s, "iic not ready 4 read2\n");
        sub_47AB4(0, s, 0);
        pthread_mutex_unlock(&stru_1B14D4);
        return -3;
      }
      else
      {
LABEL_10:
        free(v5);
        pthread_mutex_unlock(&stru_1B14D4);
        return a3;
      }
    }
    else
    {
      snprintf(s, 0x800u, "ctx %d not inited\n", v10);
      sub_47AB4(0, s, 0);
      pthread_mutex_unlock(&stru_1B14D4);
      return -2;
    }
  }
}
// 1B14D0: using guessed type int dword_1B14D0;

//----- (00073F8C) --------------------------------------------------------
int __fastcall sub_73F8C(int a1, int a2, int a3)
{
  _DWORD *v5; // r8
  int v6; // r6
  int v7; // r5
  int v8; // r6
  int v9; // t1
  int v10; // r4
  int v12; // [sp+4h] [bp-80Ch] BYREF
  void *ptr; // [sp+Ch] [bp-804h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v12 = a1;
  if ( pthread_mutex_lock(&stru_1B14D4) )
  {
    strcpy(s, "failed to i2c lock\n");
    sub_47AB4(0, s, 0);
    return -1;
  }
  else
  {
    ptr = 0;
    if ( sub_69FD4((int *)dword_1B14D0, (int)&v12, &ptr) == 1 )
    {
      v5 = ptr;
      if ( a3 )
      {
        v6 = a2 + a3;
        v7 = a2 - 1;
        v8 = v6 - 1;
        do
        {
          v9 = *(unsigned __int8 *)++v7;
          v10 = v9 | (v5[1] >> 4 << 20) | (*v5 << 26) | (v5[1] << 15) & 0x70000;
          if ( !sub_73AD4() )
          {
            free(ptr);
            strcpy(s, "iic not ready 4 write\n");
            sub_47AB4(0, s, 0);
            pthread_mutex_unlock(&stru_1B14D4);
            return -2;
          }
          sub_66908(12, v10);
        }
        while ( v8 != v7 );
        v5 = ptr;
      }
      free(v5);
      pthread_mutex_unlock(&stru_1B14D4);
      return a3;
    }
    else
    {
      snprintf(s, 0x800u, "ctx %d not inited\n", v12);
      sub_47AB4(0, s, 0);
      pthread_mutex_unlock(&stru_1B14D4);
      return -2;
    }
  }
}
// 1B14D0: using guessed type int dword_1B14D0;

//----- (0007411C) --------------------------------------------------------
int __fastcall sub_7411C(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v7; // r5
  _DWORD *v8; // r9
  _BYTE *v9; // r0
  int v10; // r4
  int v12; // [sp+4h] [bp-810h] BYREF
  void *ptr; // [sp+Ch] [bp-808h] BYREF
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v12 = a1;
  if ( a3 == 1 )
  {
    v7 = pthread_mutex_lock(&stru_1B14D4);
    if ( v7 )
    {
      strcpy(s, "failed to i2c lock\n");
      sub_47AB4(0, s, 0);
      return -1;
    }
    else
    {
      ptr = 0;
      if ( sub_69FD4((int *)dword_1B14D0, (int)&v12, &ptr) == 1 )
      {
        v8 = ptr;
        if ( a5 )
        {
          while ( 1 )
          {
            v10 = (*v8 << 26) | 0x3000000 | (v8[1] >> 4 << 20) | (v8[1] << 15) & 0x70000 | ((*a2 + v7) << 8);
            if ( !sub_73AD4() )
            {
              strcpy(s, "iic not ready 4 read1\n");
              sub_47AB4(0, s, 0);
              free(ptr);
              pthread_mutex_unlock(&stru_1B14D4);
              return -2;
            }
            sub_66908(12, v10);
            v9 = (_BYTE *)(a4 + v7++);
            if ( !sub_73B30(v9) )
              break;
            if ( a5 == v7 )
            {
              v8 = ptr;
              goto LABEL_11;
            }
          }
          strcpy(s, "iic failed to read data\n");
          sub_47AB4(0, s, 0);
          free(ptr);
          pthread_mutex_unlock(&stru_1B14D4);
          return -3;
        }
        else
        {
LABEL_11:
          free(v8);
          pthread_mutex_unlock(&stru_1B14D4);
          return a5;
        }
      }
      else
      {
        snprintf(s, 0x800u, "ctx %d not inited\n", v12);
        sub_47AB4(0, s, 0);
        pthread_mutex_unlock(&stru_1B14D4);
        return -2;
      }
    }
  }
  else
  {
    strcpy(s, "more than one byte reg address is not supported\n");
    sub_47AB4(0, s, 0);
    return -3;
  }
}
// 1B14D0: using guessed type int dword_1B14D0;

//----- (0007436C) --------------------------------------------------------
int __fastcall sub_7436C(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v7; // r8
  _DWORD *v8; // r9
  int v9; // r5
  int v10; // t1
  int v11; // r1
  int v12; // r4
  int v14; // [sp+4h] [bp-810h] BYREF
  void *ptr; // [sp+Ch] [bp-808h] BYREF
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v14 = a1;
  if ( a3 == 1 )
  {
    v7 = pthread_mutex_lock(&stru_1B14D4);
    if ( v7 )
    {
      strcpy(s, "failed to i2c lock\n");
      sub_47AB4(0, s, 0);
      return -1;
    }
    else
    {
      ptr = 0;
      if ( sub_69FD4((int *)dword_1B14D0, (int)&v14, &ptr) == 1 )
      {
        v8 = ptr;
        if ( a5 )
        {
          v9 = a4 - 1;
          do
          {
            v10 = *(unsigned __int8 *)++v9;
            v11 = *a2 + v7++;
            v12 = (*v8 << 26) | 0x1000000 | (v8[1] >> 4 << 20) | v10 | (v8[1] << 15) & 0x70000 | (v11 << 8);
            if ( !sub_73AD4() )
            {
              strcpy(s, "iic not ready 4 write\n");
              sub_47AB4(0, s, 0);
              free(ptr);
              pthread_mutex_unlock(&stru_1B14D4);
              return -2;
            }
            sub_66908(12, v12);
          }
          while ( a5 != v7 );
          v8 = ptr;
        }
        free(v8);
        pthread_mutex_unlock(&stru_1B14D4);
        return a5;
      }
      else
      {
        snprintf(s, 0x800u, "ctx %d not inited\n", v14);
        sub_47AB4(0, s, 0);
        pthread_mutex_unlock(&stru_1B14D4);
        return -2;
      }
    }
  }
  else
  {
    strcpy(s, "more than one byte reg address is not supported\n");
    sub_47AB4(0, s, 0);
    return -3;
  }
}
// 1B14D0: using guessed type int dword_1B14D0;

//----- (00074568) --------------------------------------------------------
int __fastcall sub_74568(int a1, int a2, int a3)
{
  _DWORD *v6; // r4
  int *v7; // r0
  int *v8; // r5
  int v9; // r12
  void (__fastcall *v10)(_DWORD *, _DWORD *, int); // r3
  _DWORD v12[513]; // [sp+0h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_1B14D4) )
  {
    strcpy((char *)v12, "failed to i2c lock\n");
    sub_47AB4(0, (const char *)v12, 0);
    return -4;
  }
  else
  {
    v6 = sub_6A044(dword_1B14D0);
    if ( ((int (*)(void))*v6)() )
    {
      while ( ***(_DWORD ***)(v6[5] + 16) != a1 )
      {
        if ( !((int (__fastcall *)(_DWORD *))*v6)(v6) )
          goto LABEL_8;
      }
      v7 = (int *)((int (*)(void))v6[2])();
      v8 = v7;
      if ( a2 == 1795 )
      {
        v9 = *v7;
        v10 = (void (__fastcall *)(_DWORD *, _DWORD *, int))v6[1];
        v12[1] = a3;
        v12[0] = v9;
        v10(v6, v12, 8);
        free(v8);
      }
    }
LABEL_8:
    j_free(v6);
    pthread_mutex_unlock(&stru_1B14D4);
    return 0;
  }
}
// 1B14D0: using guessed type int dword_1B14D0;

//----- (0007467C) --------------------------------------------------------
int __fastcall sub_7467C(int a1, int a2)
{
  _DWORD *v4; // r4
  _DWORD *v5; // r5
  void (__fastcall *v6)(_DWORD *, _DWORD *, int); // r3
  int v7; // r12
  _DWORD v9[512]; // [sp+0h] [bp-800h] BYREF

  if ( pthread_mutex_lock(&stru_1B14D4) )
  {
    strcpy((char *)v9, "failed to i2c lock\n");
    sub_47AB4(0, (const char *)v9, 0);
    return -4;
  }
  else
  {
    v4 = sub_6A044(dword_1B14D0);
    if ( ((int (*)(void))*v4)() )
    {
      while ( ***(_DWORD ***)(v4[5] + 16) != a1 )
      {
        if ( !((int (__fastcall *)(_DWORD *))*v4)(v4) )
          goto LABEL_7;
      }
      v5 = (_DWORD *)((int (*)(void))v4[2])();
      v6 = (void (__fastcall *)(_DWORD *, _DWORD *, int))v4[1];
      v7 = v5[1];
      v9[0] = a2;
      v9[1] = v7;
      v6(v4, v9, 8);
      free(v5);
    }
LABEL_7:
    j_free(v4);
    pthread_mutex_unlock(&stru_1B14D4);
    return 0;
  }
}
// 1B14D0: using guessed type int dword_1B14D0;

//----- (00074778) --------------------------------------------------------
char *__fastcall sub_74778(int a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  if ( v4 <= 0x4F )
    return (char *)memcpy((void *)(a1 + 12), s, v4 + 1);
  strcpy((char *)(a1 + 12), "...");
  return strcpy((char *)(a1 + 15), &s[v4 - 76]);
}

//----- (000747D0) --------------------------------------------------------
char *__fastcall sub_747D0(char *result, char *a2)
{
  if ( result )
  {
    result[92] = 0;
    *((_DWORD *)result + 2) = 0;
    *(_DWORD *)result = -1;
    *((_DWORD *)result + 1) = -1;
    if ( a2 )
      return sub_74778((int)result, a2);
    else
      result[12] = 0;
  }
  return result;
}

//----- (00074810) --------------------------------------------------------
int __fastcall sub_74810(int a1, char *s)
{
  bool v2; // zf

  v2 = s == 0;
  if ( s )
    v2 = a1 == 0;
  if ( !v2 )
    return (int)sub_74778(a1, s);
  return a1;
}

//----- (00074820) --------------------------------------------------------
int sub_74820(int result, int a2, int a3, int a4, char *format, ...)
{
  int v5; // r4
  va_list va; // [sp+1Ch] [bp+10h] BYREF

  va_start(va, format);
  v5 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0xA0u, format, va);
      *(_BYTE *)(v5 + 251) = 0;
    }
  }
  return result;
}

//----- (0007487C) --------------------------------------------------------
int __fastcall sub_7487C(int result, int a2, int a3, int a4, char *format, __gnuc_va_list arg)
{
  int v6; // r4

  v6 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0xA0u, format, arg);
      *(_BYTE *)(v6 + 251) = 0;
    }
  }
  return result;
}

//----- (000748C4) --------------------------------------------------------
int __fastcall sub_748C4(int a1, int a2, int a3, unsigned int a4, int a5)
{
  int v9; // r10
  unsigned int v10; // r1
  int v11; // r2
  int v12; // r0
  _BYTE v14[12]; // [sp+Ch] [bp-Ch] BYREF

  v9 = sub_76008(a2, a3, a4, a5, v14);
  if ( v9 )
    return -1;
  sub_761B0(a1, (int)v14, 9u);
  if ( a2 == 1 )
  {
    v10 = a1;
    v11 = 0;
    v12 = 0;
  }
  else
  {
    v11 = a3;
    v10 = a1;
    v12 = 1;
  }
  sub_75ED0(v12, v10, v11, a4, a5);
  return v9;
}

//----- (00074950) --------------------------------------------------------
int __fastcall sub_74950(int a1, int a2, int a3, unsigned int a4, char a5, char a6, char a7, __int16 a8)
{
  if ( a4 > 3 )
    return -1;
  else
    return sub_748C4(
             a1,
             a2,
             a3,
             (unsigned __int8)aDh[a4],
             a6 & 7 | 0x40000000 | (unsigned __int8)(16 * (a5 & 7)) | ((a7 & 0x3F) << 8) | ((a8 & 0xFFF) << 16));
}

//----- (000749A0) --------------------------------------------------------
int __fastcall sub_749A0(int a1, int a2, int a3, char a4, char a5, char a6)
{
  unsigned __int8 v6; // r12

  if ( a6 )
    v6 = (16 * (a4 & 3)) & 0x3B | ((a5 & 3) << 6);
  else
    v6 = (16 * (a4 & 3)) & 0x3A | ((a5 & 3) << 6) | 4;
  if ( a6 )
    v6 |= 1u;
  return sub_748C4(a1, a2, a3, 0x3Cu, v6 | 0x80008000);
}

//----- (000749EC) --------------------------------------------------------
int __fastcall sub_749EC(int a1)
{
  _BYTE v3[8]; // [sp+0h] [bp-8h] BYREF

  if ( sub_76164(v3) )
    return -1;
  else
    return sub_761B0(a1, (int)v3, 5u);
}

//----- (00074A28) --------------------------------------------------------
int __fastcall sub_74A28(int a1, char a2)
{
  _BYTE v4[8]; // [sp+0h] [bp-8h] BYREF

  if ( sub_760A0(a2, v4) )
    return -1;
  else
    return sub_761B0(a1, (int)v4, 5u);
}

//----- (00074A6C) --------------------------------------------------------
int __fastcall sub_74A6C(int a1, int a2, char a3, char a4)
{
  _BYTE v6[8]; // [sp+0h] [bp-8h] BYREF

  if ( sub_760F4(a2, a3, a4, v6) )
    return -1;
  else
    return sub_761B0(a1, (int)v6, 5u);
}

//----- (00074AB8) --------------------------------------------------------
int __fastcall sub_74AB8(int a1)
{
  return sub_74A6C(a1, 1, 0, 0);
}

//----- (00074ACC) --------------------------------------------------------
int __fastcall sub_74ACC(int a1, unsigned int a2)
{
  int v3; // r4
  char v4; // r7
  char v5; // r5
  int v6; // r6

  LOWORD(v3) = 0;
  v4 = a2;
  v5 = 0;
  v6 = sub_772E8(256, a2);
  do
  {
    v3 = (unsigned __int16)(v3 + 1);
    sub_74A28(a1, v5);
    v5 += v4;
  }
  while ( v3 < v6 );
  return 0;
}

//----- (00074B18) --------------------------------------------------------
int __fastcall sub_74B18(unsigned int a1, unsigned int a2)
{
  bool v3; // cc
  unsigned int v5; // r1
  unsigned __int8 v6; // r7
  unsigned __int8 v8; // r6
  int v9; // [sp+Ch] [bp-10h] BYREF
  int v10; // [sp+10h] [bp-Ch] BYREF
  int v11[2]; // [sp+14h] [bp-8h] BYREF

  v3 = a2 > 0x2DC6C0;
  v5 = 8 * a2;
  if ( v3 )
  {
    v6 = 0x17D78400 / v5 - 1;
    sub_75D9C(0, a1, 0, 0x68u, &v10);
    sub_75D9C(0, a1, 0, 0x28u, v11);
    HIBYTE(v10) = HIBYTE(v10) & 0x9F | 0x40;
    LOBYTE(v10) = v10 & 0x88 | 0x11;
    BYTE1(v10) = BYTE1(v10) & 0xC0 | 1;
    HIWORD(v10) = HIWORD(v10) & 0xF000 | 0x70;
    sub_748C4(a1, 1, 0, 0x68u, v10);
    sub_748C4(a1, 1, 0, 0x68u, v10);
    LOBYTE(v11[0]) = 15;
    HIBYTE(v11[0]) = HIBYTE(v11[0]) & 0x30 | 6;
    *(_WORD *)((char *)v11 + 1) = BYTE1(v11[0]) & 0xF;
    sub_748C4(a1, 1, 0, 0x28u, v11[0]);
    sub_75D9C(0, a1, 0, 0x18u, &v9);
    HIBYTE(v9) = HIBYTE(v9) & 0xF0 | (v6 >> 5) & 0xF;
    BYTE1(v9) = BYTE1(v9) & 0xE0 | v6 & 0x1F;
    BYTE2(v9) |= 1u;
  }
  else
  {
    v8 = 0x17D7840 / v5 - 1;
    sub_75D9C(0, a1, 0, 0x68u, &v10);
    sub_75D9C(0, a1, 0, 0x28u, v11);
    sub_75D9C(0, a1, 0, 0x18u, &v9);
    HIBYTE(v9) = HIBYTE(v9) & 0xF0 | (v8 >> 5) & 0xF;
    BYTE1(v9) = BYTE1(v9) & 0xE0 | v8 & 0x1F;
    BYTE2(v9) &= ~1u;
  }
  sub_748C4(a1, 1, 0, 0x18u, v9);
  sub_70CE4(a1, a2);
  return 0;
}

//----- (00074D64) --------------------------------------------------------
int __fastcall sub_74D64(int a1, unsigned int a2)
{
  return sub_748C4(
           a1,
           1,
           0,
           0x14u,
           (unsigned __int8)aDh[(unsigned __int8)a2 + 4]
         | (unsigned __int16)((unsigned __int8)aDh[BYTE1(a2) + 4] << 8)
         | ((unsigned __int8)aDh[BYTE2(a2) + 4] << 16) & 0xFFFFFF
         | ((unsigned __int8)aDh[HIBYTE(a2) + 4] << 24));
}

//----- (00074DD0) --------------------------------------------------------
int __fastcall sub_74DD0(int a1, int a2, unsigned __int16 a3)
{
  int v3; // r3

  if ( a2 )
    v3 = 0x80000000;
  else
    v3 = 0;
  if ( !a2 )
    v3 = v3 & 0x7FFFFFFF | ((unsigned __int8)v3 << 31);
  return sub_748C4(a1, 1, 0, 0xCu, v3 & 0xFFFF0000 | a3);
}

//----- (00074E08) --------------------------------------------------------
int __fastcall sub_74E08(int a1, _BYTE *a2, float *a3)
{
  float v3; // s0
  int v4; // r12
  int v5; // r4
  int v7; // r5
  int v8; // r8
  int v9; // r2
  int v10; // r9
  int v11; // r11
  float v12; // s11
  int v14; // r1
  float v15; // s13
  int v16; // r0
  int v17; // lr
  int v18; // r3
  float v19; // s7
  int v20; // s14
  float v21; // s15
  float v22; // s15
  float v23; // s16

  v4 = 2;
  v5 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 2;
  v10 = 0;
  v11 = 0;
  v12 = 10.0;
  while ( 1 )
  {
    v14 = 1;
    v15 = (float)v9;
    do
    {
      v16 = v14 * v14;
      v17 = (unsigned __int8)v14;
      v18 = v14;
      v19 = (float)v14 * v3;
      do
      {
        v20 = (int)((float)((float)((float)((float)v18 * v19) * v15) / 25.0) + 0.5);
        if ( (unsigned int)(v20 - 16) <= 0xEA )
        {
          v21 = (float)v20 * (float)(25.0 / (float)v9);
          if ( (v9 != 1 || v21 <= 3125.0) && v21 <= 3200.0 && v21 >= 2000.0 )
          {
            v22 = fabsf(v3 - (float)(v21 / (float)v16));
            if ( v22 < v12 )
            {
              v8 = (unsigned __int8)v14;
              v10 = v17;
              v12 = v22;
              v11 = v9;
              v5 = (int)((float)((float)((float)((float)v18 * v19) * v15) / 25.0) + 0.5);
              v7 = 1;
            }
          }
        }
        ++v18;
        v16 += v14;
        v17 = (unsigned __int8)v18;
      }
      while ( (unsigned __int8)v18 != 8 );
      ++v14;
    }
    while ( v14 != 8 );
    v9 = 1;
    if ( v4 == 1 )
      break;
    v4 = 1;
  }
  if ( v5 )
  {
    v23 = (float)((float)(25.0 / (float)v11) * (float)v5) / (float)(v7 * (__int16)v10 * (__int16)v8);
    if ( a3 )
      *a3 = v23;
    printf(
      "final refdiv: %d, fbdiv: %d, postdiv1: %d, postdiv2: %d, usr divider: %d, min diff value: %f\n",
      v11,
      v5,
      v10,
      v8,
      v7,
      v12);
    printf("Want freq: %f, Real freq: %f\n", v3, v23);
    *(_BYTE *)a1 = v10;
    *(_BYTE *)(a1 + 1) = v8;
    *(_BYTE *)(a1 + 2) = v11;
    *(_WORD *)(a1 + 4) = v5;
    *a2 = v7;
    a2[1] = v7;
    a2[2] = v7;
    a2[3] = v7;
    return 0;
  }
  else
  {
    puts("find div fail, use default value");
    return -1;
  }
}
// 74E84: variable 'v3' is possibly undefined

//----- (00075030) --------------------------------------------------------
int __fastcall sub_75030(int a1, int a2, int a3, unsigned int a4, float a5)
{
  _BYTE v10[4]; // [sp+14h] [bp-Ch] BYREF
  char v11[4]; // [sp+18h] [bp-8h] BYREF
  __int16 v12; // [sp+1Ch] [bp-4h]

  sub_74E08((int)v11, v10, 0);
  return sub_74950(a1, a2, a3, a4, v11[0], v11[1], v11[2], v12);
}

//----- (00075094) --------------------------------------------------------
int __fastcall sub_75094(int a1, unsigned int a2, int a3, __int16 a4)
{
  return sub_74950(a1, 1, 0, a2, a3, SBYTE1(a3), SBYTE2(a3), a4);
}

//----- (000750D8) --------------------------------------------------------
int __fastcall sub_750D8(int a1, int a2, unsigned int a3, int a4, __int16 a5)
{
  return sub_74950(a1, 0, a2, a3, a4, SBYTE1(a4), SBYTE2(a4), a5);
}

//----- (00075128) --------------------------------------------------------
int __fastcall sub_75128(unsigned int a1, int a2, unsigned int a3, char a4, char a5)
{
  unsigned int v7; // r8
  int v10; // [sp+Ch] [bp-4h] BYREF

  if ( a3 > 3 )
    return -1;
  v7 = (unsigned __int8)aDh[a3];
  sub_75D9C(1, a1, a2, v7, &v10);
  LOBYTE(v10) = v10 & 0x88 | (16 * (a4 & 7)) | a5 & 7;
  return sub_748C4(a1, 0, a2, v7, v10);
}

//----- (0007522C) --------------------------------------------------------
int sub_7522C()
{
  return 0;
}

//----- (0007523C) --------------------------------------------------------
int sub_7523C()
{
  return 0;
}

//----- (0007524C) --------------------------------------------------------
int __fastcall sub_7524C(int a1, unsigned __int8 a2, unsigned int a3, float a4)
{
  return sub_75030(a1, 0, a2, a3, a4);
}

//----- (00075270) --------------------------------------------------------
int __fastcall sub_75270(int a1, unsigned int a2, float a3)
{
  return sub_75030(a1, 1, 0, a2, a3);
}

//----- (00075294) --------------------------------------------------------
int __fastcall sub_75294(int a1, int a2, char a3)
{
  return sub_748C4(a1, 0, a2, 0x54u, a3 & 7);
}

//----- (000752C0) --------------------------------------------------------
int __fastcall sub_752C0(int a1, char a2)
{
  return sub_748C4(a1, 1, 0, 0x54u, a2 & 7);
}

//----- (000752EC) --------------------------------------------------------
int __fastcall sub_752EC(int a1)
{
  return sub_74A6C(a1, 1, 0, 72);
}

//----- (000752FC) --------------------------------------------------------
int __fastcall sub_752FC(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-4h] BYREF

  sub_75D9C(0, a1, 0, 0x6Cu, &v3);
  LOBYTE(v3) = v3 & 0xF8 | 3;
  BYTE1(v3) = BYTE1(v3) & 0xFC | 2;
  HIBYTE(v3) = HIBYTE(v3) & 0xFC | 2;
  return sub_748C4(a1, 1, 0, 0x6Cu, v3);
}

//----- (00075374) --------------------------------------------------------
int __fastcall sub_75374(unsigned int a1, int a2, char a3, __int16 a4)
{
  char v8; // r3
  int v10; // [sp+Ch] [bp-8h] BYREF

  sub_75D9C(0, a1, 0, 0xA4u, &v10);
  LOWORD(v10) = a4;
  if ( a2 )
    v8 = HIBYTE(v10) | 0x80;
  else
    v8 = HIBYTE(v10) & 0x7F;
  HIBYTE(v10) = v8 & 0x8F | (16 * (a3 & 3)) & 0xBF;
  return sub_748C4(a1, 1, 0, 0xA4u, v10);
}

//----- (00075458) --------------------------------------------------------
int __fastcall sub_75458(unsigned int a1, int a2)
{
  char v4; // r3
  int v6; // [sp+Ch] [bp-8h] BYREF

  sub_75D9C(0, a1, 0, 0x18u, &v6);
  if ( a2 )
    v4 = BYTE1(v6) | 0x80;
  else
    v4 = BYTE1(v6) & 0x7F;
  BYTE1(v6) = v4;
  return sub_748C4(a1, 1, 0, 0x18u, v6);
}

//----- (000754BC) --------------------------------------------------------
int __fastcall sub_754BC(unsigned int a1, int a2)
{
  int v5; // [sp+Ch] [bp-8h] BYREF

  sub_75D9C(0, a1, 0, 0x18u, &v5);
  if ( a2 )
  {
    BYTE2(v5) |= 0x40u;
    HIBYTE(v5) &= 0xFu;
  }
  else
  {
    BYTE2(v5) &= ~0x40u;
    HIBYTE(v5) |= 0xF0u;
  }
  return sub_748C4(a1, 1, 0, 0x18u, v5);
}

//----- (00075548) --------------------------------------------------------
int __fastcall sub_75548(int a1, int a2)
{
  return sub_748C4(a1, 1, 0, 0x10u, a2);
}

//----- (0007556C) --------------------------------------------------------
int __fastcall sub_7556C(int a1)
{
  sub_748C4(a1, 1, 0, 0x3Cu, -2147450618);
  return sub_748C4(a1, 1, 0, 0x3Cu, -2147483130);
}

//----- (000755D8) --------------------------------------------------------
int __fastcall sub_755D8(int a1)
{
  return sub_748C4(a1, 1, 0, 0x3Cu, -2147449686);
}

//----- (0007561C) --------------------------------------------------------
int __fastcall sub_7561C(int a1)
{
  return sub_748C4(a1, 1, 0, 0x90u, 2048);
}

//----- (00075644) --------------------------------------------------------
int __fastcall sub_75644(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-4h] BYREF

  sub_75D9C(0, a1, 0, 0x6Cu, &v3);
  HIBYTE(v3) |= 0x80u;
  return sub_748C4(a1, 1, 0, 0x6Cu, v3);
}

//----- (0007569C) --------------------------------------------------------
int __fastcall sub_7569C(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-4h] BYREF

  sub_75D9C(0, a1, 0, 0x6Cu, &v3);
  HIBYTE(v3) &= ~0x80u;
  return sub_748C4(a1, 1, 0, 0x6Cu, v3);
}

//----- (000756F4) --------------------------------------------------------
int __fastcall sub_756F4(int a1, int a2)
{
  return sub_748C4(a1, 1, 0, 0x9Cu, a2);
}

//----- (00075718) --------------------------------------------------------
int __fastcall sub_75718(int a1, char a2)
{
  return sub_748C4(a1, 1, 0, 0x90u, (unsigned __int8)(16 * ((a2 - 1) & 7)) | 0x30005001);
}

//----- (0007575C) --------------------------------------------------------
int __fastcall sub_7575C(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-4h] BYREF

  sub_75D9C(0, a1, 0, 0x90u, &v3);
  LOBYTE(v3) = v3 & 0x7D | 2;
  BYTE1(v3) &= ~8u;
  return sub_748C4(a1, 1, 0, 0x90u, v3);
}

//----- (00075830) --------------------------------------------------------
int __fastcall sub_75830(int a1)
{
  return sub_74A6C(a1, 1, 0, 144);
}

//----- (00075894) --------------------------------------------------------
int __fastcall sub_75894(int a1)
{
  return sub_74A6C(a1, 1, 0, 152);
}

//----- (000758A4) --------------------------------------------------------
int __fastcall sub_758A4(int a1)
{
  return sub_74A6C(a1, 1, 0, 160);
}

//----- (000758B4) --------------------------------------------------------
int sub_758B4()
{
  return -1;
}

//----- (000758BC) --------------------------------------------------------
int __fastcall sub_758BC(unsigned int a1, int a2)
{
  int v5; // [sp+Ch] [bp-4h] BYREF

  sub_75D9C(0, a1, a2, 0x18u, &v5);
  BYTE1(v5) |= 0x40u;
  LOBYTE(v5) = v5 & 0x8F | 0x30;
  return sub_748C4(a1, 0, a2, 0x18u, v5);
}

//----- (00075928) --------------------------------------------------------
int __fastcall sub_75928(int a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  return sub_748C4(a1, 0, a2, 0x1Cu, (unsigned __int16)(a4 << 8) | (a3 >> 1 << 17) & 0x39FFFFFF | 0x1000000);
}

//----- (00075974) --------------------------------------------------------
int __fastcall sub_75974(int a1, int a2, unsigned __int8 a3, int a4, unsigned __int8 a5)
{
  return sub_748C4(a1, 0, a2, 0x1Cu, (a5 | (a4 << 8)) & 0x3900FFFF | 0x10000 | (a3 >> 1 << 17) & 0x39FFFFFF | 0x1000000);
}

//----- (000759B8) --------------------------------------------------------
int __fastcall sub_759B8(int a1, int a2, unsigned __int8 a3, int a4, unsigned __int8 a5)
{
  return sub_75974(a1, a2, a3, a4, a5);
}

//----- (000759C4) --------------------------------------------------------
int __fastcall sub_759C4(int a1, unsigned __int8 a2, unsigned __int8 a3)
{
  return sub_748C4(a1, 0, 0, 0x44u, (unsigned __int16)(a3 << 8) | (a2 << 24));
}

//----- (000759F4) --------------------------------------------------------
int __fastcall sub_759F4(int a1, int a2, __int16 a3, char a4, char a5)
{
  return sub_748C4(
           a1,
           0,
           a2,
           0x2Cu,
           a5 & 1 | (unsigned __int16)(2 * (a4 & 1)) | ((unsigned __int16)(3 * a3 + 12) << 16));
}

//----- (00075A2C) --------------------------------------------------------
int __fastcall sub_75A2C(unsigned int a1, char a2)
{
  int v5; // [sp+Ch] [bp-8h] BYREF

  sub_75D9C(0, a1, 0, 0x18u, &v5);
  LOBYTE(v5) = v5 & 0xF7 | (8 * (a2 & 1));
  return sub_748C4(a1, 1, 0, 0x18u, v5);
}

//----- (00075A88) --------------------------------------------------------
int __fastcall sub_75A88(unsigned int a1, int a2, char a3)
{
  int v7; // [sp+Ch] [bp-4h] BYREF

  sub_75D9C(0, a1, a2, 0x18u, &v7);
  LOBYTE(v7) = v7 & 0xF7 | (8 * (a3 & 1));
  return sub_748C4(a1, 0, a2, 0x18u, v7);
}

//----- (00075AE8) --------------------------------------------------------
int __fastcall sub_75AE8(int a1, int a2)
{
  return sub_748C4(a1, 0, a2, 0xB0u, 0x100000);
}

//----- (00075B10) --------------------------------------------------------
int __fastcall sub_75B10(int a1)
{
  return sub_748C4(a1, 1, 0, 0xB0u, 0x100000);
}

//----- (00075B38) --------------------------------------------------------
int __fastcall sub_75B38(int a1, int a2)
{
  return sub_748C4(a1, 0, a2, 0xB0u, 806617146);
}

//----- (00075B64) --------------------------------------------------------
int __fastcall sub_75B64(int a1)
{
  return sub_748C4(a1, 1, 0, 0xB0u, 806617146);
}

//----- (00075B90) --------------------------------------------------------
int sub_75B90()
{
  return -1;
}

//----- (00075B98) --------------------------------------------------------
int sub_75B98()
{
  return -1;
}

//----- (00075BA0) --------------------------------------------------------
int __fastcall sub_75BA0(int a1)
{
  return sub_74A6C(a1, 1, 0, 176);
}

//----- (00075BB0) --------------------------------------------------------
int __fastcall sub_75BB0(int a1, char a2)
{
  return sub_74A6C(a1, 0, a2, 176);
}

//----- (00075BC0) --------------------------------------------------------
int __fastcall sub_75BC0(int a1)
{
  return sub_74A6C(a1, 1, 0, 180);
}

//----- (00075BD0) --------------------------------------------------------
int __fastcall sub_75BD0(int a1)
{
  return sub_74A6C(a1, 0, 0, 180);
}

//----- (00075BE0) --------------------------------------------------------
int __fastcall sub_75BE0(int a1)
{
  return sub_74A6C(a1, 1, 0, 184);
}

//----- (00075BF0) --------------------------------------------------------
int __fastcall sub_75BF0(int a1, char a2)
{
  return sub_74A6C(a1, 0, a2, 184);
}

//----- (00075C00) --------------------------------------------------------
int __fastcall sub_75C00(int a1, int a2, char a3, char a4)
{
  return sub_748C4(a1, 0, a2, 0x3Cu, (unsigned __int8)((16 * (a3 & 1)) | a4 & 3) | 0x80008700);
}

//----- (00075C4C) --------------------------------------------------------
int __fastcall sub_75C4C(int a1, char a2, char a3)
{
  return sub_748C4(a1, 1, 0, 0x3Cu, (unsigned __int8)((16 * (a2 & 1)) | a3 & 3) | 0x80008700);
}

//----- (00075C98) --------------------------------------------------------
int __fastcall sub_75C98(int a1, int a2, char a3, char a4, char a5)
{
  return sub_749A0(a1, 0, a2, a3, a4, a5);
}

//----- (00075CC4) --------------------------------------------------------
int __fastcall sub_75CC4(int a1, char a2, char a3, char a4)
{
  return sub_749A0(a1, 1, 0, a2, a3, a4);
}

//----- (00075CEC) --------------------------------------------------------
unsigned int __fastcall sub_75CEC(unsigned int a1)
{
  return a1 >> 25;
}

//----- (00075CF4) --------------------------------------------------------
int __fastcall sub_75CF4(unsigned int a1, unsigned int a2)
{
  return (unsigned __int8)((unsigned __int8)(a1 >> 17) / a2);
}

//----- (00075D08) --------------------------------------------------------
int __fastcall sub_75D08(unsigned int a1)
{
  char *v1; // r9
  int i; // r7
  char *v5; // r4
  void *v6; // r0

  if ( a1 > 3 )
    return -1;
  v1 = (char *)&unk_1B14EC + 512 * a1;
  for ( i = 0; i != 4; ++i )
  {
    if ( a1 == i )
    {
      v5 = (char *)&unk_1B1D04 + 0x20000 * a1;
      do
      {
        v6 = v5;
        v5 += 512;
        memcpy(v6, &unk_9F5C4, 0x200u);
      }
      while ( v5 != (char *)&unk_1D1D04 + 0x20000 * a1 );
      memcpy(v1, &unk_9F5C4, 0x200u);
    }
  }
  return 0;
}

//----- (00075D9C) --------------------------------------------------------
int __fastcall sub_75D9C(int a1, unsigned int a2, int a3, unsigned int a4, _DWORD *a5)
{
  unsigned int v6; // r6
  unsigned int v10; // r6
  int v11; // r4
  unsigned int v13; // r6
  unsigned __int8 *v14; // r6

  if ( a2 > 3 )
    return -1;
  v6 = a4 >> 2;
  pthread_mutex_lock((pthread_mutex_t *)&byte_1B14EC[2048]);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      v11 = -6;
      pthread_mutex_unlock((pthread_mutex_t *)&byte_1B14EC[2048]);
      goto LABEL_6;
    }
    v10 = v6 + ((a3 + (a2 << 8)) << 6);
    if ( byte_1B1D04[8 * v10] != a4 )
    {
      v11 = -5;
      pthread_mutex_unlock((pthread_mutex_t *)&byte_1B14EC[2048]);
LABEL_6:
      printf(
        "[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n",
        "get_register_cache_value",
        a1,
        a2,
        a3,
        a4);
      return v11;
    }
    v14 = &byte_1B1D04[8 * v10];
  }
  else
  {
    v13 = v6 + (a2 << 6);
    if ( byte_1B14EC[8 * v13] != a4 )
    {
      v11 = -4;
      pthread_mutex_unlock((pthread_mutex_t *)&byte_1B14EC[2048]);
      goto LABEL_6;
    }
    v14 = &byte_1B14EC[8 * v13];
  }
  *a5 = *((_DWORD *)v14 + 1);
  pthread_mutex_unlock((pthread_mutex_t *)&byte_1B14EC[2048]);
  printf(
    "[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x, register_value::%08x.\r\n",
    "get_register_cache_value",
    a1,
    a2,
    a3,
    a4,
    *a5);
  return 0;
}
// 1B14EC: using guessed type unsigned __int8 byte_1B14EC[2072];
// 1B1D04: using guessed type unsigned __int8 byte_1B1D04[131072];

//----- (00075ED0) --------------------------------------------------------
int __fastcall sub_75ED0(int a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  unsigned int v6; // r6
  unsigned int v10; // r6
  int v11; // r4
  unsigned int v13; // r6

  if ( a2 > 3 )
    return -1;
  v6 = a4 >> 2;
  pthread_mutex_lock((pthread_mutex_t *)&byte_1B14EC[2048]);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      v11 = -6;
      pthread_mutex_unlock((pthread_mutex_t *)&byte_1B14EC[2048]);
      goto LABEL_6;
    }
    v10 = v6 + ((a3 + (a2 << 8)) << 6);
    if ( byte_1B1D04[8 * v10] != a4 )
    {
      v11 = -5;
      pthread_mutex_unlock((pthread_mutex_t *)&byte_1B14EC[2048]);
LABEL_6:
      printf(
        "[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x failed.\r\n",
        "set_register_cache_value",
        a1,
        a2,
        a3,
        a4);
      return v11;
    }
    *(_DWORD *)&byte_1B1D04[8 * v10 + 4] = a5;
    pthread_mutex_unlock((pthread_mutex_t *)&byte_1B14EC[2048]);
  }
  else
  {
    v13 = v6 + (a2 << 6);
    if ( byte_1B14EC[8 * v13] != a4 )
    {
      v11 = -4;
      pthread_mutex_unlock((pthread_mutex_t *)&byte_1B14EC[2048]);
      goto LABEL_6;
    }
    *(_DWORD *)&byte_1B14EC[8 * v13 + 4] = a5;
    pthread_mutex_unlock((pthread_mutex_t *)&byte_1B14EC[2048]);
  }
  printf(
    "[%s] level::%d, which_chain::%u, which_asic::%u, register_address::%02x, register_value::%08x.\r\n",
    "set_register_cache_value",
    a1,
    a2,
    a3,
    a4,
    a5);
  return 0;
}
// 1B14EC: using guessed type unsigned __int8 byte_1B14EC[2072];
// 1B1D04: using guessed type unsigned __int8 byte_1B1D04[131072];

//----- (00076008) --------------------------------------------------------
int __fastcall sub_76008(int a1, char a2, char a3, int a4, _BYTE *a5)
{
  int v5; // r5

  if ( !a5 )
    return -1;
  v5 = 0;
  *(_DWORD *)a5 = 0;
  a5[3] = a3;
  a5[7] = a4;
  a5[2] = a2;
  a5[4] = HIBYTE(a4);
  a5[5] = BYTE2(a4);
  a5[6] = BYTE1(a4);
  a5[8] = 0;
  *a5 = (16 * (a1 != 0)) & 0x1E | 0x41;
  a5[1] = 9;
  a5[8] = a5[8] & 0xE0 | sub_76284(a5, 0x40u) & 0x1F;
  return v5;
}

//----- (000760A0) --------------------------------------------------------
int __fastcall sub_760A0(char a1, _BYTE *a2)
{
  int v2; // r5

  if ( !a2 )
    return -1;
  v2 = 0;
  *(_DWORD *)a2 = 0;
  a2[4] = 0;
  a2[2] = a1;
  a2[1] = 5;
  *a2 = 64;
  a2[4] = a2[4] & 0xE0 | sub_76284(a2, 0x20u) & 0x1F;
  return v2;
}

//----- (000760F4) --------------------------------------------------------
int __fastcall sub_760F4(int a1, char a2, char a3, _BYTE *a4)
{
  int v4; // r5

  if ( !a4 )
    return -1;
  v4 = 0;
  *(_DWORD *)a4 = 0;
  a4[3] = a3;
  a4[2] = a2;
  a4[4] = 0;
  a4[1] = 5;
  *a4 = (16 * (a1 != 0)) & 0x1D | 0x42;
  a4[4] = a4[4] & 0xE0 | sub_76284(a4, 0x20u) & 0x1F;
  return v4;
}

//----- (00076164) --------------------------------------------------------
int __fastcall sub_76164(_BYTE *a1)
{
  int v1; // r5

  if ( !a1 )
    return -1;
  v1 = 0;
  *(_DWORD *)a1 = 0;
  a1[4] = 0;
  a1[1] = 5;
  *a1 = 83;
  a1[4] = a1[4] & 0xE0 | sub_76284(a1, 0x20u) & 0x1F;
  return v1;
}

//----- (000761B0) --------------------------------------------------------
int __fastcall sub_761B0(int a1, int a2, unsigned int a3)
{
  int *v3; // r4
  unsigned int v4; // lr
  int v5; // r3
  int v6; // r12
  int v8; // r5
  int v9[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = 0;
  v9[0] = 0;
  if ( a3 )
    v3 = v9;
  v9[1] = 0;
  v9[2] = 0;
  if ( !a3 )
    goto LABEL_9;
LABEL_4:
  while ( 2 )
  {
    v5 = 0;
    if ( v4 < a3 )
    {
      do
      {
        v6 = *v3;
        if ( v5 )
        {
          v8 = *(unsigned __int8 *)(a2 + v4 + v5);
          if ( v5 == 1 )
          {
            *v3 = v6 | (v8 << 16);
          }
          else if ( v5 == 2 )
          {
            *v3 = v6 | (v8 << 8);
          }
          else
          {
            *v3 = v8 | v6;
            if ( v5 == 3 )
            {
              v4 += 4;
              ++v3;
              if ( v4 >= a3 )
                goto LABEL_9;
              goto LABEL_4;
            }
          }
        }
        else
        {
          *v3 = v6 | (*(unsigned __int8 *)(a2 + v4) << 24);
        }
        ++v5;
      }
      while ( v4 + v5 < a3 );
    }
    v4 += 4;
    ++v3;
    if ( v4 < a3 )
      continue;
    break;
  }
LABEL_9:
  sub_70808(v9, a1);
  return 0;
}
// 761F4: variable 'v3' is possibly undefined

//----- (00076284) --------------------------------------------------------
int __fastcall sub_76284(_BYTE *a1, unsigned int a2)
{
  int v2; // r2
  char v3; // r9
  unsigned int v4; // r12
  int v5; // r6
  int v6; // r8
  int v7; // r5
  int v8; // r7
  unsigned int v9; // r4
  unsigned int v10; // r3
  unsigned __int8 v11; // r3
  int v12; // lr
  int result; // r0

  if ( !a2 )
    return 31;
  LOBYTE(v2) = 0;
  v3 = 1;
  LOBYTE(v4) = 0;
  v5 = 1;
  v6 = 1;
  v7 = 1;
  v8 = 1;
  v9 = 128;
  while ( 1 )
  {
    v2 = (unsigned __int8)(v2 + 1);
    v4 = (unsigned __int8)(v4 + 1);
    v10 = *a1 & v9;
    v9 >>= 1;
    if ( v10 )
      v11 = v3 ^ 1;
    else
      v11 = v3;
    if ( v2 == 8 )
    {
      ++a1;
      LOBYTE(v2) = 0;
      v9 = 128;
    }
    v12 = (unsigned __int8)(v11 ^ v7);
    v3 = v5;
    if ( v4 >= a2 )
      break;
    v5 = v6;
    v7 = v8;
    v6 = v12;
    v8 = v11;
  }
  if ( v5 )
    result = 16;
  else
    result = 0;
  if ( v6 )
    result |= 8u;
  if ( v11 != v7 )
    result |= 4u;
  if ( v8 )
    result |= 2u;
  if ( v11 )
    return result | 1;
  return result;
}

//----- (000763AC) --------------------------------------------------------
int __fastcall sub_763AC(int a1)
{
  pthread_t v2; // r0
  unsigned int v3; // r2
  int v4; // r0
  int v5; // r4
  unsigned int i; // r3
  int v7; // r5
  size_t v8; // r0
  size_t v9; // r8
  void *v10; // r6
  ssize_t v11; // r0
  ssize_t v12; // r1
  int (__fastcall *v13)(void *, ssize_t); // r4
  size_t v14; // r0
  int v16; // [sp+8h] [bp-23Ch] BYREF
  socklen_t v17; // [sp+Ch] [bp-238h] BYREF
  char s[4]; // [sp+10h] [bp-234h] BYREF
  int v19; // [sp+14h] [bp-230h]
  int v20; // [sp+18h] [bp-22Ch]
  int v21; // [sp+1Ch] [bp-228h]
  struct sockaddr addr; // [sp+20h] [bp-224h] BYREF
  struct sockaddr v23; // [sp+30h] [bp-214h] BYREF
  char buf[4]; // [sp+40h] [bp-204h] BYREF
  char v25[252]; // [sp+44h] [bp-200h] BYREF
  char v26[4]; // [sp+140h] [bp-104h] BYREF
  _BYTE v27[252]; // [sp+144h] [bp-100h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v3 = *(_DWORD *)a1;
  *(_DWORD *)s = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  sprintf(s, "ct_b/fcb/%d", v3);
  prctl(15, s);
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  v4 = socket(2, 1, 0);
  v5 = v4;
  if ( v4 < 0 )
  {
    perror("socket error");
    return 0;
  }
  else
  {
    v16 = 1;
    if ( setsockopt(v4, 1, 2, &v16, 4u) < 0 )
    {
      perror("set sockopt err");
      return 0;
    }
    else
    {
      for ( i = *(_DWORD *)a1; ; *(_DWORD *)a1 = i )
      {
        *(_WORD *)addr.sa_data = __rev16(i);
        if ( bind(v5, &addr, 0x10u) >= 0 )
          break;
        perror("bind error");
        i = *(_DWORD *)a1 + 1;
      }
      if ( listen(v5, 5) < 0 )
      {
        perror("listen error");
      }
      else
      {
        v17 = 16;
        *(_DWORD *)(a1 + 144) = 1;
        v7 = accept(v5, &v23, &v17);
        if ( v7 >= 0 )
        {
          *(_DWORD *)buf = 0;
          memset(v25, 0, sizeof(v25));
          sprintf(buf, "%x %s\n", 63, (const char *)(a1 + 16));
          v8 = strlen(buf);
          send(v7, buf, v8 + 1, 0);
          v9 = *(_DWORD *)(a1 + 148);
          v10 = malloc(v9);
          v11 = recv(v7, v10, v9, 0);
          if ( v11 > 0 )
            *((_BYTE *)v10 + v11) = 0;
          while ( 1 )
          {
            v12 = recv(v7, v10, *(_DWORD *)(a1 + 148), 0);
            if ( v12 > 0 )
            {
              v13 = *(int (__fastcall **)(void *, ssize_t))(a1 + 12);
              if ( v13 )
                v13 = (int (__fastcall *)(void *, ssize_t))v13(v10, v12);
            }
            else
            {
              v13 = 0;
            }
            *(_DWORD *)v26 = 0;
            memset(v27, 0, sizeof(v27));
            sprintf(v26, "%x %d %s %s", 63, v13, (const char *)(a1 + 16), "OK");
            v14 = strlen(v26);
            send(v7, v26, v14 + 1, 0);
          }
        }
        perror("accept error");
      }
      return 0;
    }
  }
}

//----- (00076638) --------------------------------------------------------
int __fastcall sub_76638(int a1)
{
  pthread_t v2; // r0
  int v3; // r7
  ssize_t v4; // r0
  int v5; // r4
  int v6; // r4
  _DWORD *v7; // r0
  int v8; // r11
  _DWORD *v9; // r10
  const char *v10; // r5
  int v11; // r0
  int v12; // r3
  size_t v13; // r0
  int v14; // r10
  size_t v15; // r0
  size_t v17; // r0
  int v18; // [sp+10h] [bp-1DCh] BYREF
  pthread_t newthread; // [sp+14h] [bp-1D8h] BYREF
  _BYTE v20[8]; // [sp+18h] [bp-1D4h] BYREF
  int v21; // [sp+20h] [bp-1CCh]
  int v22; // [sp+24h] [bp-1C8h]
  char src[4]; // [sp+28h] [bp-1C4h] BYREF
  int v24; // [sp+2Ch] [bp-1C0h]
  int v25; // [sp+30h] [bp-1BCh]
  int v26; // [sp+34h] [bp-1B8h]
  int v27; // [sp+38h] [bp-1B4h]
  int v28; // [sp+3Ch] [bp-1B0h]
  int v29; // [sp+40h] [bp-1ACh]
  int v30; // [sp+44h] [bp-1A8h]
  char s1[4]; // [sp+48h] [bp-1A4h] BYREF
  int v32; // [sp+4Ch] [bp-1A0h]
  int v33; // [sp+50h] [bp-19Ch]
  int v34; // [sp+54h] [bp-198h]
  int v35; // [sp+58h] [bp-194h]
  int v36; // [sp+5Ch] [bp-190h]
  int v37; // [sp+60h] [bp-18Ch]
  int v38; // [sp+64h] [bp-188h]
  _DWORD buf[32]; // [sp+68h] [bp-184h] BYREF
  char v40[4]; // [sp+E8h] [bp-104h] BYREF
  _BYTE v41[252]; // [sp+ECh] [bp-100h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v22 = 0;
  qmemcpy(v20, "ct_b/mai", sizeof(v20));
  v21 = *(unsigned __int16 *)"n";
  prctl(15, v20);
  v3 = *(_DWORD *)(a1 + 8);
  while ( 1 )
  {
    memset(buf, 0, sizeof(buf));
    v4 = recv(v3, buf, 0x80u, 0);
    if ( v4 <= 0 )
      return 0;
    *((_BYTE *)buf + v4) = 0;
    *(_DWORD *)src = 0;
    v24 = 0;
    *(_DWORD *)s1 = 0;
    v32 = 0;
    v18 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    _isoc99_sscanf(buf, "%x%s%s", &v18, s1, src);
    v5 = strcmp(s1, "regist");
    if ( v5 )
    {
      v6 = dword_231D04 + 1;
      memcpy((char *)&unk_231D2C + 128 * dword_231D04, buf, 0x80u);
      dword_231D04 = v6;
    }
    else
    {
      v7 = calloc(0x98u, 1u);
      v8 = dword_231D08;
      v9 = v7;
      if ( !dword_231D08 )
        goto LABEL_18;
      v10 = s2;
      while ( 1 )
      {
        v11 = strcmp(src, v10);
        v10 += 136;
        if ( !v11 )
          break;
        if ( ++v5 == v8 )
          goto LABEL_11;
      }
      v12 = *((_DWORD *)&unk_235D2C + 34 * v5 + 33);
      v9[3] = *((_DWORD *)&unk_235D2C + 34 * v5);
      v9[37] = v12;
LABEL_11:
      if ( v8 == v5 )
      {
LABEL_18:
        *(_DWORD *)v40 = 0;
        memset(v41, 0, sizeof(v41));
        sprintf(v40, "%x %d %s %s %s", 63, 0, "reg_resp", "no_name", src);
        v17 = strlen(v40);
        send(v3, v40, v17 + 1, 0);
        free(v9);
      }
      else
      {
        *v9 = dword_9F7C4;
        v13 = strlen(src);
        memcpy(v9 + 4, src, v13 + 1);
        v9[36] = 0;
        pthread_create(&newthread, 0, (void *(*)(void *))sub_763AC, v9);
        while ( !v9[36] )
          usleep(0x2710u);
        v14 = *v9;
        *(_DWORD *)v40 = 0;
        if ( v14 != dword_9F7C4 )
          dword_9F7C4 = v14;
        memset(v41, 0, sizeof(v41));
        sprintf(v40, "%x %d %s %s %s", 63, v14, "reg_resp", "OK", src);
        v15 = strlen(v40);
        send(v3, v40, v15 + 1, 0);
        ++dword_9F7C4;
      }
    }
  }
}
// 122EC: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 9F7C4: using guessed type int dword_9F7C4;
// 231D04: using guessed type int dword_231D04;
// 231D08: using guessed type int dword_231D08;

//----- (00076964) --------------------------------------------------------
int __fastcall sub_76964(int a1, int a2)
{
  int v2; // r7
  char *v5; // r4
  char *v6; // r3
  char *v7; // r5
  char *v8; // r0
  int v9; // r2
  int v10; // r0
  int v11; // r5
  unsigned int v12; // r4
  int v13; // r8
  size_t v14; // r0
  ssize_t v15; // r0
  ssize_t v16; // r0
  _DWORD *v17; // r0
  int optval; // [sp+Ch] [bp-430h] BYREF
  socklen_t v20; // [sp+10h] [bp-42Ch] BYREF
  pthread_t newthread; // [sp+14h] [bp-428h] BYREF
  struct sockaddr addr; // [sp+18h] [bp-424h] BYREF
  struct sockaddr v23; // [sp+28h] [bp-414h] BYREF
  char buf[4]; // [sp+38h] [bp-404h] BYREF
  _BYTE s[124]; // [sp+3Ch] [bp-400h] BYREF
  _DWORD v26[32]; // [sp+B8h] [bp-384h] BYREF
  char v27[256]; // [sp+138h] [bp-304h] BYREF
  _DWORD v28[129]; // [sp+238h] [bp-204h] BYREF

  v2 = dword_231D0C;
  if ( dword_231D0C )
    return -1;
  pthread_mutex_init(&stru_231D10, 0);
  dword_231D08 = a2;
  if ( a2 )
  {
    v5 = (char *)(a1 + 4);
    v6 = s2;
    v7 = &v5[136 * a2];
    do
    {
      v8 = (char *)memcpy(v6, v5, 0x80u);
      v5 += 136;
      v9 = *((_DWORD *)v5 - 35);
      v6 = v8 + 136;
      *((_DWORD *)v8 + 32) = *((_DWORD *)v5 - 2);
      *((_DWORD *)v8 - 1) = v9;
    }
    while ( v5 != v7 );
  }
  *(_WORD *)&addr.sa_data[6] = 0;
  *(_DWORD *)&addr.sa_data[8] = 0;
  *(_WORD *)&addr.sa_data[12] = 0;
  *(_WORD *)addr.sa_data = 0;
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  optval = 1;
  v10 = socket(2, 1, 0);
  v11 = v10;
  if ( v10 < 0 )
  {
    v2 = -4;
    perror("socket error");
  }
  else if ( setsockopt(v10, 1, 2, &optval, 4u) < 0 )
  {
    v2 = -4;
    perror("set sockopt err");
  }
  else
  {
    v12 = 22026;
    while ( 1 )
    {
      *(_WORD *)addr.sa_data = __rev16(v12++);
      if ( bind(v11, &addr, 0x10u) >= 0 )
        break;
      perror("bind error");
    }
    if ( listen(v11, 5) < 0 )
    {
      v2 = -4;
      perror("listen error");
    }
    else
    {
      v20 = 16;
      v13 = accept(v11, &v23, &v20);
      if ( v13 < 0 )
      {
        v2 = -4;
        perror("accept error");
      }
      else
      {
        *(_DWORD *)buf = 0;
        memset(s, 0, sizeof(s));
        sprintf(buf, "Hello!0x%x\n", 63);
        v14 = strlen(buf);
        send(v13, buf, v14 + 1, 0);
        dword_231D0C = 1;
        memset(v28, 0, 512);
        dword_231D28 = v13;
        v15 = recv(v13, v28, 0x400u, 0);
        if ( v15 > 0 )
          *((_BYTE *)v28 + v15) = 0;
        strcpy(v27, "123 456 789 abc");
        memset(&v27[16], 0, 0xF0u);
        send(v13, v27, 0x10u, 0);
        memset(v26, 0, sizeof(v26));
        v16 = recv(v13, v26, 0x80u, 0);
        if ( v16 > 0 )
          *((_BYTE *)v26 + v16) = 0;
        v17 = malloc(0xCu);
        v17[2] = v13;
        v17[1] = v11;
        pthread_create(&newthread, 0, (void *(*)(void *))sub_76638, v17);
      }
    }
  }
  return v2;
}
// 231D08: using guessed type int dword_231D08;
// 231D0C: using guessed type int dword_231D0C;
// 231D10: using guessed type pthread_mutex_t;
// 231D28: using guessed type int dword_231D28;

//----- (00076C60) --------------------------------------------------------
int __fastcall sub_76C60(int a1)
{
  pthread_mutex_t *v2; // r8
  int v3; // r9
  int v4; // r5
  size_t v5; // r0
  int v6; // r0
  int v7; // r5
  ssize_t v8; // r0
  unsigned int v9; // r3
  int result; // r0
  unsigned int v11; // [sp+10h] [bp-47Ch] BYREF
  int v12; // [sp+14h] [bp-478h] BYREF
  struct sockaddr addr; // [sp+18h] [bp-474h] BYREF
  _DWORD v14[8]; // [sp+28h] [bp-464h] BYREF
  _DWORD v15[8]; // [sp+48h] [bp-444h] BYREF
  _DWORD v16[8]; // [sp+68h] [bp-424h] BYREF
  _DWORD dest[32]; // [sp+88h] [bp-404h] BYREF
  _DWORD v18[32]; // [sp+108h] [bp-384h] BYREF
  char buf[4]; // [sp+188h] [bp-304h] BYREF
  _BYTE s[252]; // [sp+18Ch] [bp-300h] BYREF
  _DWORD v21[129]; // [sp+288h] [bp-204h] BYREF

  if ( !dword_231D0C )
    return -1;
  v2 = (pthread_mutex_t *)malloc(0x24u);
  pthread_mutex_init(v2, 0);
  v3 = dword_231D28;
  *(_DWORD *)buf = 0;
  memset(s, 0, sizeof(s));
  sprintf(buf, "%x regist %s", 63, (const char *)a1);
  v4 = dword_231D04;
  v5 = strlen(buf);
  send(v3, buf, v5 + 1, 0);
  memset(dest, 0, sizeof(dest));
  while ( dword_231D04 == v4 )
    usleep(0x3E8u);
  memcpy(dest, (char *)&unk_231D2C + 128 * v4, sizeof(dest));
  v11 = 0;
  v12 = 0;
  memset(v14, 0, sizeof(v14));
  memset(v15, 0, sizeof(v15));
  memset(v16, 0, sizeof(v16));
  _isoc99_sscanf(dest, "%x%d%s%s%s", &v12, &v11, v14, v15, v16);
  if ( !v11 )
    return -4;
  addr.sa_family = 2;
  memset(addr.sa_data, 0, sizeof(addr.sa_data));
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)addr.sa_data = __rev16(v11);
  v6 = socket(2, 1, 0);
  v7 = v6;
  if ( v6 < 0 )
  {
    perror("socket err:");
    return -4;
  }
  else if ( connect(v6, &addr, 0x10u) < 0 )
  {
    perror("connect err:");
    return -3;
  }
  else
  {
    memset(v21, 0, 512);
    v8 = recv(v7, v21, 0x200u, 0);
    if ( v8 > 0 )
      *((_BYTE *)v21 + v8) = 0;
    memset(&v18[1], 0, 0x7Cu);
    v18[0] = &unk_214B4F;
    send(v7, v18, 4u, 0);
    v9 = v11;
    result = 0;
    v2[1].__owner = v7;
    *(_DWORD *)(a1 + 128) = v2;
    v2[1].__lock = v9;
  }
  return result;
}
// 122EC: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 231D04: using guessed type int dword_231D04;
// 231D0C: using guessed type int dword_231D0C;
// 231D28: using guessed type int dword_231D28;

//----- (00076F08) --------------------------------------------------------
int __fastcall sub_76F08(int a1, int a2, int a3, int a4)
{
  return a4;
}

//----- (00076F20) --------------------------------------------------------
int __fastcall sub_76F20(int a1, const void *a2, size_t a3, _DWORD *a4)
{
  pthread_mutex_t *v4; // r5
  int v8; // r4
  ssize_t v9; // r0
  int v11; // [sp+8h] [bp-148h] BYREF
  int v12; // [sp+Ch] [bp-144h] BYREF
  int v13; // [sp+10h] [bp-140h] BYREF
  int v14; // [sp+14h] [bp-13Ch]
  int v15; // [sp+18h] [bp-138h]
  int v16; // [sp+1Ch] [bp-134h]
  int v17; // [sp+20h] [bp-130h]
  int v18; // [sp+24h] [bp-12Ch]
  int v19; // [sp+28h] [bp-128h]
  int v20; // [sp+2Ch] [bp-124h]
  int v21; // [sp+30h] [bp-120h] BYREF
  int v22; // [sp+34h] [bp-11Ch]
  int v23; // [sp+38h] [bp-118h]
  int v24; // [sp+3Ch] [bp-114h]
  int v25; // [sp+40h] [bp-110h]
  int v26; // [sp+44h] [bp-10Ch]
  int v27; // [sp+48h] [bp-108h]
  int v28; // [sp+4Ch] [bp-104h]
  _DWORD buf[64]; // [sp+50h] [bp-100h] BYREF

  if ( !dword_231D0C )
    return -1;
  v4 = *(pthread_mutex_t **)(a1 + 128);
  if ( !v4 )
    return -2;
  v8 = pthread_mutex_trylock(*(pthread_mutex_t **)(a1 + 128));
  if ( v8 )
    return -3;
  if ( send(v4[1].__owner, a2, a3, 0) <= 0 )
  {
    v8 = -4;
    pthread_mutex_unlock(v4);
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    v9 = recv(v4[1].__owner, buf, 0x100u, 0);
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v21 = 0;
    v22 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    if ( v9 > 0 )
      _isoc99_sscanf(buf, "%x%d%s%s", &v11, &v12, &v13, &v21);
    if ( a4 )
      *a4 = v12;
    pthread_mutex_unlock(v4);
  }
  return v8;
}
// 122EC: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 231D0C: using guessed type int dword_231D0C;

//----- (000772CC) --------------------------------------------------------
int __fastcall sub_772CC(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x772C2);
  return a1 / a2;
}
// 772CE: control flows out of bounds to 772C2

//----- (000772E8) --------------------------------------------------------
int __fastcall sub_772E8(int result, unsigned int a2)
{
  int v2; // r12
  unsigned int v3; // r3

  if ( !a2 )
    JUMPOUT(0x77940);
  v2 = result ^ a2;
  if ( (a2 & 0x80000000) != 0 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v2 ^ result) < 0 )
      return -result;
  }
  else
  {
    v3 = result;
    if ( result < 0 )
      v3 = -result;
    if ( v3 <= a2 )
    {
      if ( v3 < a2 )
        result = 0;
      if ( v3 == a2 )
        return (v2 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_77330 + 16 * (31 - (__clz(a2) - __clz(v3)))))(0);
    }
    else
    {
      result = v3 >> (31 - __clz(a2));
      if ( v2 < 0 )
        return -result;
    }
  }
  return result;
}
// 77578: control flows out of bounds to 77940

//----- (000778A4) --------------------------------------------------------
int __fastcall sub_778A4(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x778CA);
  return a1;
}
// 778B2: control flows out of bounds to 778CA

//----- (000778B4) --------------------------------------------------------
int __fastcall sub_778B4(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (00077910) --------------------------------------------------------
int __fastcall sub_77910(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return _udivmoddi4(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (000779B0) --------------------------------------------------------
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}
// 779B0: invalid function type 'UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp)' has been ignored

//----- (00077AC8) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_9BF00;
  v8 = &off_9BF04 - &off_9BF00;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 9BF00: using guessed type _UNKNOWN *off_9BF00;
// 9BF04: using guessed type _UNKNOWN *off_9BF04;

//----- (00077B08) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1724 queued=1360 decompiled=1360 lumina nreq=0 worse=0 better=0
// ALL OK, 1360 function(s) have been successfully decompiled
