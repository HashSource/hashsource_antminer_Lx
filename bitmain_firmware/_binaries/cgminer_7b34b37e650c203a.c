/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_11E70();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int sem_wait(sem_t *sem);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int sem_post(sem_t *sem);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// size_t strcspn(const char *s, const char *reject);
// int printf(const char *format, ...);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int inet_pton(int af, const char *cp, void *buf);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// int setlogmask(int mask);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int memcmp(const void *s1, const void *s2, size_t n);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// unsigned int sleep(unsigned int seconds);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int pthread_setcancelstate(int state, int *oldstate);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int sysconf(int name);
// int dup2(int fd, int fd2);
// void *realloc(void *ptr, size_t size);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int strcasecmp(const char *s1, const char *s2);
// void perror(const char *s);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int sched_yield(void);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// double floor(double x);
// int __fastcall strtof(_DWORD, _DWORD); weak
// int __fastcall open64(_DWORD); weak
// char *getenv(const char *name);
// int puts(const char *s);
// int sysinfo(struct sysinfo *info);
// void *malloc(size_t size);
// double log10(double x);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
// struct tm *localtime(const time_t *timer);
// const __int32_t **_ctype_tolower_loc(void);
// char *dirname(char *path);
// const __int32_t **_ctype_toupper_loc(void);
// int _gmon_start__(void); weak
// int sem_trywait(sem_t *sem);
// int kill(__pid_t pid, int sig);
// const unsigned __int16 **_ctype_b_loc(void);
// __pid_t getpid(void);
// void exit(int status);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// size_t strlen(const char *s);
// int round(void); weak
// char *strchr(const char *s, int c);
// int pthread_setcanceltype(int type, int *oldtype);
// int nice(int inc);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int execv(const char *path, char *const argv[]);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// char *_strdup(const char *s);
// int mkdir(const char *path, __mode_t mode);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// void *memset(void *s, int c, size_t n);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// int fgetc(FILE *stream);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// ssize_t write(int fd, const void *buf, size_t n);
// int fileno(FILE *stream);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// void *memchr(const void *s, int c, size_t n);
// int access(const char *name, int type);
// int fclose(FILE *stream);
// int pipe(int pipedes[2]);
// char *strtok(char *s, const char *delim);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int shutdown(int fd, int how);
// int sigemptyset(sigset_t *set);
// FILE *popen(const char *command, const char *modes);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// __pid_t fork(void);
// void errx(int status, const char *format, ...);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int execl(const char *path, const char *arg, ...);
// int listen(int fd, int n);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int pthread_join(pthread_t th, void **thread_return);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __fastcall lldiv(_DWORD); weak
// int fputc(int c, FILE *stream);
// void syslog(int pri, const char *fmt, ...);
// int sscanf(const char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// void openlog(const char *ident, int option, int facility);
// double exp(double x);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// char *strpbrk(const char *s, const char *accept);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// in_addr_t inet_addr(const char *cp);
// void pthread_testcancel(void);
// char *strncat(char *dest, const char *src, size_t n);
// int sem_destroy(sem_t *sem);
// int isatty(int fd);
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int pclose(FILE *stream);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_15A70();
int deregister_tm_clones();
int register_tm_clones();
int sub_15AE4();
int __fastcall sub_15B00(unsigned int *a1, char *s);
int __fastcall sub_15B94(int a1, int a2, int a3, int a4);
int __fastcall sub_15BE0(int a1, int a2, int a3, int a4);
const char *__fastcall sub_15C2C(const char *s, int a2);
void sub_15E00();
void __fastcall sub_15E08(unsigned int *a1, char *s, int a3, _BYTE *a4);
void sub_15F14();
bool __fastcall sub_15FF8(const struct sockaddr *a1, const char **a2, _BYTE *a3);
int sub_161A0();
void sub_16D58();
int __fastcall sub_16D60(int a1);
int __fastcall sub_16D98(int result, int a2);
void *__fastcall sub_16DFC(char ***a1, char *s);
void __fastcall sub_16F14(const char *a1, int a2, int a3, int a4);
int __fastcall sub_17420(unsigned __int8 **a1, int *a2);
int __fastcall sub_174A0(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
void __fastcall __noreturn sub_175A0(const char *a1, int a2);
void __fastcall sub_175F8(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_17604(const char *a1, int a2);
void __fastcall __noreturn sub_17668(const char *a1, int a2);
void __fastcall __noreturn sub_176CC(const char *a1, int a2);
void __fastcall sub_17724(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int sub_17730();
int __fastcall sub_177EC(int a1);
int __fastcall sub_17900(int *a1);
void __noreturn sub_179F4();
int sub_17B7C();
int __fastcall sub_17D00(unsigned int *a1, char **a2, int a3, int a4);
const char *__fastcall sub_18850(int a1, const char *a2, int a3, const char *a4, char a5);
int __fastcall sub_18AD4(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5);
int __fastcall sub_18EF0(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
void __fastcall sub_18F04(unsigned int *a1, int a2, const char *a3, int a4);
int __fastcall sub_18FE8(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_191F0(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_197A0(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_197B4(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_19940(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_19954(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_19AA4(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4);
void __fastcall sub_19B4C(unsigned int *a1, int a2, const char *a3, int a4);
int __fastcall sub_19CD0(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_19E14(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_19F34(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5);
int __fastcall sub_1A07C(unsigned int *a1, int a2, char *s, int a4);
void __fastcall sub_1A2DC(unsigned int *a1, int a2, char *a3, int a4);
int __fastcall sub_1A3E4(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_1A598(int a1, int a2, int a3, int a4);
int __fastcall sub_1A678(int a1, int a2, _BYTE *a3, int a4);
int __fastcall sub_1AA3C(int a1, int a2, const char *a3, int a4, unsigned __int8 a5);
int __fastcall sub_1ACB4(int a1, int a2, int a3, int a4);
int __fastcall sub_1AE90(int a1, int a2, int a3, int a4);
int __fastcall sub_1AF64(int a1, int a2, int a3, int a4);
int __fastcall sub_1B294(int a1, int a2, int a3, int a4);
int __fastcall sub_1B44C(int a1, int a2, int a3, int a4);
int __fastcall sub_1B610(unsigned int *a1, int a2, int a3, int a4);
int __fastcall sub_1BD24(int a1, int a2, int a3, int a4);
int __fastcall sub_1C5D0(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6);
int __fastcall sub_1C820(int a1, int a2, int a3, int a4);
int __fastcall sub_1C930(int a1, int a2, int a3, int a4);
int __fastcall sub_1CB54(int a1, int a2, int a3, int a4);
const char *__fastcall sub_1D184(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D1A4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D1C4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D1E4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D204(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D224(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D244(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D264(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D284(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D2A4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D2C4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D2E4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D304(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D324(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D344(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D364(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D384(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D3A4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D3C4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D3E4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D404(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D424(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D444(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D464(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D484(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D4A4(int a1, const char *a2, const char *a3, char a4);
const char *__fastcall sub_1D4C4(int a1, const char *a2, const char *a3, char a4);
void sub_1D4E4();
void __fastcall sub_1D538(int *a1);
int __fastcall sub_1D990(unsigned int *a1, int a2, int a3, int a4);
int __fastcall sub_1DB9C(int a1, int a2, int a3, int a4);
int sub_1DC74();
double sub_1DD3C();
void sub_1DD84();
void *__fastcall sub_1FD14(const char **a1, const char *a2, const char *a3, int a4);
_DWORD *__fastcall sub_20050(int a1);
_BYTE *__fastcall sub_200F8(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8);
int __fastcall sub_203A8(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_20430(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_2045C(int a1, const char *a2, const char *a3, int a4);
const char *__fastcall sub_20524(int a1, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_205F8(const char **result, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_20744(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char **__fastcall sub_2088C(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char *__fastcall sub_209E0(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_20ACC(const char **a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_20C3C(const char **a1, int a2, const char *a3, const char *a4, int a5);
int __fastcall sub_20DA8(const char **a1, const char *a2, const char *a3, int a4);
int __fastcall sub_20EC4(const char **ptr, const char *a2, const char *a3, int a4);
void __fastcall sub_20F58(int a1, const char *a2, int a3);
int __fastcall sub_21138(int a1);
void __fastcall sub_211B0(int a1, int a2, int a3, int a4, int a5, int a6);
int sub_211B8();
void __fastcall sub_21238(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_21244(const char *a1, const char *a2, int a3);
void __fastcall sub_212BC(int a1, const char *a2, int a3);
__int64 __fastcall sub_21438(int a1, _QWORD *a2, _QWORD *a3);
int __fastcall sub_21870(int result, unsigned __int8 *a2, int a3);
_DWORD *__fastcall sub_21A6C(_DWORD *result);
void *__fastcall sub_21A9C(unsigned __int8 *a1, char *a2, size_t n);
int __fastcall sub_21B48(_DWORD *a1, _BYTE *a2);
int __fastcall sub_21C34(char *a1, size_t n, _BYTE *a3);
int sub_21C98();
int __fastcall sub_21CA0(int a1, char *s, int a3);
int __fastcall sub_21F0C(const char **a1, int a2, int a3);
int __fastcall sub_223C0(int a1);
int __fastcall sub_22400(int a1);
bool __fastcall sub_22428(int a1, int a2);
_DWORD *__fastcall sub_224BC(_DWORD *a1, unsigned int a2);
char *__fastcall sub_22520(_DWORD *a1, unsigned int a2);
void __fastcall __noreturn sub_22538(const void *a1, const char *a2, const char *a3, int a4);
void __fastcall sub_22594(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_225A0(const char *a1, const char *a2, int a3);
int __fastcall sub_226F0(pthread_rwlock_t *a1, const char *a2, int a3);
void __fastcall sub_22760(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_2276C(pthread_rwlock_t *a1, const char *a2, int a3);
void __fastcall sub_227DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_227E8(pthread_mutex_t *a1, const char *a2, int a3);
void __fastcall sub_22858(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_22864(const char *a1, int a2);
void __fastcall sub_228BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_228C8(int a1);
int __fastcall sub_22958(int a1, char a2);
void *__fastcall sub_229BC(size_t a1, const char *a2, const char *a3, int a4);
void __fastcall sub_22A38(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void *__fastcall sub_22A44(size_t a1, size_t a2, const char *a3, const char *a4, int a5);
void __fastcall sub_22AC8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void *__fastcall sub_22AD4(void *a1, size_t a2, const char *a3, const char *a4, int a5);
void __fastcall sub_22B58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
char *__fastcall sub_22B68(char *a1);
_BYTE *__fastcall sub_22BB4(_BYTE *result, int a2, int a3);
_BYTE *__fastcall sub_22C24(int a1, int a2);
int __fastcall sub_22CD8(_BYTE *a1, unsigned __int8 *a2, int a3);
void __fastcall sub_22E7C(int a1, char *s);
size_t __fastcall sub_22FEC(_BYTE *a1, char *s);
int __fastcall sub_230C4(int a1, int a2);
int __fastcall sub_23110(unsigned int *a1, unsigned int *a2);
char *sub_23300();
void __fastcall sub_2335C(char *a1);
int __fastcall sub_233C4(int a1);
int __fastcall sub_233CC(int a1);
int __fastcall sub_233D4(int a1, int a2);
int __fastcall sub_234A8(int a1, const struct timespec *a2);
int __fastcall sub_23588(int result);
_DWORD *__fastcall sub_235C4(_DWORD *result, int *a2);
_DWORD *__fastcall sub_235F8(_DWORD *result, int *a2);
bool __fastcall sub_2363C(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_23670(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_236A4(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_236D4(_DWORD *result, _DWORD *a2);
int __fastcall sub_236F0(_QWORD *a1);
int __fastcall sub_23728(_QWORD *a1);
int __fastcall sub_23768(_QWORD *a1);
int __fastcall sub_237A8(_QWORD *a1);
_DWORD *__fastcall sub_237E4(_DWORD *result, _DWORD *a2);
const char *__fastcall sub_2395C(const char **a1, const char *a2);
int __fastcall sub_239A4(struct timeval *a1);
int __fastcall sub_239AC(_DWORD *a1);
int __fastcall sub_239DC(_DWORD *a1, _DWORD *a2, int *a3);
int __fastcall sub_23A18(struct timespec *tp); // idb
int __fastcall sub_23A24(int *a1);
int __fastcall sub_23AE4(int *a1);
int sub_23B9C();
int __fastcall sub_23BFC(int result, _DWORD *a2);
void sub_23C94();
int __fastcall sub_23CD8(const char *a1, _DWORD *a2, char **a3);
char *__fastcall sub_23E4C(char *s1, int a2);
bool __fastcall sub_23F28(int a1);
void **__fastcall sub_23F48(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6);
int __fastcall sub_23FB4(unsigned int a1, int a2);
int __fastcall sub_23FF8(_DWORD *a1, int a2);
int __fastcall sub_24340(int a1);
int __fastcall sub_244A4(int a1, char *a2, int a3);
char *__fastcall sub_24858(int a1);
time_t __fastcall sub_24DC4(_DWORD *a1, int a2);
char *__fastcall sub_24EB4(char *a1, char *s);
char *__fastcall sub_24F88(const char *a1);
int __fastcall sub_250A8(const char *a1);
int __fastcall sub_250E8(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_25164(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4);
int __fastcall sub_251AC(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_251E4(int a1);
int __fastcall sub_25228(sem_t *sem, const char *a2, const char *a3, int a4);
int __fastcall sub_252A8(sem_t *a1, int a2, const char *a3, const char *a4, int a5);
void sub_253DC();
int *__fastcall sub_253E4(sem_t *sem);
bool __fastcall sub_2541C(int a1, int a2, int a3);
void __fastcall sub_254E8(void *a1, const void *a2, size_t a3, int a4, int a5, int a6);
void __fastcall sub_257F8(void *a1, const void *a2);
int __fastcall sub_2582C(int a1, _DWORD *a2);
int __fastcall sub_26830(const char **a1, int a2, int a3);
int __fastcall sub_26AEC(_DWORD *a1);
int __fastcall sub_28690(int a1);
int __fastcall sub_2870C(_DWORD *a1, _DWORD *a2);
int __fastcall sub_28AE0(_DWORD *a1, int a2);
int __fastcall sub_296BC(_DWORD *a1, int a2);
int __fastcall sub_296D0(_DWORD *a1);
int __fastcall sub_29AC8(_DWORD *a1);
int __fastcall sub_29E78(int *a1, _DWORD *a2, _DWORD *a3);
_BYTE *__fastcall sub_29EF4(_BYTE *result, int a2);
int __fastcall sub_29F34(int result, char a2);
void __fastcall sub_2A21C(int a1, char *a2, int a3);
void __fastcall sub_2A83C(int a1, char *a2, int a3);
void __fastcall sub_2A854(int a1, int a2, int a3);
int __fastcall sub_2A9C4(int result, unsigned int *a2, unsigned int a3);
int __fastcall sub_2A9F0(_DWORD *a1);
int __fastcall sub_2AA00(_DWORD *a1);
int __fastcall sub_2AA10(_DWORD *a1);
int __fastcall sub_2AA20(_BYTE *a1);
int sub_2AA3C();
int nullsub_3(); // weak
int nullsub_1(); // weak
int sub_2AA4C();
__int64 sub_2AA54();
int sub_2AA60();
int nullsub_4(); // weak
int sub_2AA6C();
int __fastcall sub_2AA74(int result);
void __noreturn sub_2AA90(const char *a1, ...);
int __fastcall sub_2AAD8(int a1);
int __fastcall sub_2AAF0(int a1);
int __fastcall sub_2AB08(int a1);
int __fastcall sub_2AB20(int a1);
int __fastcall sub_2AB38(int a1);
int __fastcall sub_2AB50(int a1);
_BYTE *__fastcall sub_2AD7C(const char *a1);
void __fastcall __noreturn sub_2AE34(const char *a1);
time_t __fastcall sub_2AE8C(int a1);
time_t __fastcall sub_2AEC4(int a1);
int __fastcall sub_2AEF8(unsigned __int64 a1, char *s, size_t maxlen, int a4);
int __fastcall sub_2B1B0(int a1);
int __fastcall sub_2B350(int a1);
void __fastcall sub_2B3A4(int a1);
void sub_2B41C();
int sub_2B4EC();
int __fastcall sub_2B500(int a1);
void __noreturn sub_2B63C();
_DWORD *__fastcall sub_2B664(_DWORD *result);
int __fastcall sub_2B684(unsigned __int8 *a1);
int __fastcall sub_2B6A8(int a1);
int __fastcall sub_2B730(int a1);
int __fastcall sub_2B7BC(int a1);
const char *__fastcall sub_2B824(const char *a1);
char *__fastcall sub_2B890(char *a1);
char *__fastcall sub_2B98C(_DWORD *a1, int a2);
int sub_2BD14();
char *__fastcall sub_2BEA0(const char *a1, float *a2);
char *__fastcall sub_2BEF8(const char *a1, float *a2);
int __fastcall sub_2BF50(int a1, int a2, int (__fastcall **a3)(int));
void sub_2C0F8();
void sub_2C148();
int __fastcall sub_2C1A4(int a1);
char *__fastcall sub_2C1EC(const char *a1);
char *__fastcall sub_2C234(const char *a1, _DWORD *a2);
char *__fastcall sub_2C264(const char *a1, _DWORD *a2);
char *__fastcall sub_2C298(const char *a1, _DWORD *a2);
char *__fastcall sub_2C2C8(const char *a1, _DWORD *a2);
char *__fastcall sub_2C2F8(const char *a1, _DWORD *a2);
char *__fastcall sub_2C328(const char *a1, _DWORD *a2);
char *__fastcall sub_2C358(const char *a1, _DWORD *a2);
char *__fastcall sub_2C388(const char *a1, _DWORD *a2);
char *__fastcall sub_2C3B4(const char *a1, _DWORD *a2);
char *__fastcall sub_2C3E0(const char *a1, _DWORD *a2);
char *__fastcall sub_2C40C(const char *a1, _DWORD *a2);
char *__fastcall sub_2C43C(const char *a1, _DWORD *a2);
char *__fastcall sub_2C468(const char *a1, _DWORD *a2);
char *__fastcall sub_2C494(const char *a1, _DWORD *a2);
char *__fastcall sub_2C4C4(const char *a1, _DWORD *a2);
void __fastcall sub_2C4F0(const char *a1, const char *a2, int a3);
double __fastcall sub_2C538(double a1);
int nullsub_2(); // weak
int nullsub_5(); // weak
int sub_2C588();
int sub_2C590();
int nullsub_6(); // weak
int nullsub_7(); // weak
int nullsub_8(); // weak
const char *__fastcall sub_2C5A4(const char *a1);
int __fastcall sub_2C610(char *a1, size_t a2, time_t *a3);
void sub_2C6A8();
char *__fastcall sub_2C82C(const char *a1, _DWORD *a2, int a3, int a4);
int __fastcall sub_2C878(const char *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_2C8A8(int a1, const char *a2);
int __fastcall sub_2C918(int a1, char *s1); // idb
const char *__fastcall sub_2C9F8(const char *a1);
void *__fastcall sub_2CA54(void **a1);
char *__fastcall sub_2CA90(int a1, int a2, int a3);
void __fastcall sub_2CBA8(void ***a1, const char *a2, const char *a3, int a4);
void __fastcall sub_2CC3C(int a1);
void sub_2CCA0();
void sub_2CCC8();
void __fastcall sub_2CCF0(int a1, unsigned int a2);
_BYTE *__fastcall sub_2CDB8(_BYTE *result, unsigned int a2);
unsigned __int64 __fastcall sub_2CDF0(__int64 *a1);
void __fastcall sub_2CEA0(void ***a1, const char *a2, const char *a3, int a4);
int __fastcall sub_2D0D8(int result);
void __fastcall sub_2D174(FILE *s);
int sub_2D75C();
char *__fastcall sub_2D7F4(char *a1);
void sub_2D8F0();
void __fastcall sub_2D950(void *a1);
int __fastcall sub_2DBE4(int a1);
bool __fastcall sub_2DBFC(int a1, int a2);
bool __fastcall sub_2DC1C(int a1, int a2);
int __fastcall sub_2DC68(int a1, int a2);
void __fastcall sub_2DD0C(int *a1, int a2);
void __fastcall sub_2DFC0(int *a1, unsigned int a2);
int __fastcall sub_2DFE8(int *a1, unsigned int a2);
void __fastcall sub_2E034(int a1, int a2);
int __fastcall sub_2E46C(int a1, void *s2, size_t n, const void *a4, int a5, size_t na);
int __fastcall sub_2E4DC(int result, int a2);
void __fastcall sub_2E528(int a1, _DWORD *a2);
int __fastcall sub_2E698(int result);
void __fastcall __noreturn sub_2E6B0(int a1, int a2);
void __noreturn sub_2E730();
void __noreturn sub_2E78C();
int __fastcall sub_2E7D0(char *a1, size_t a2, int a3);
void __noreturn sub_2E9A4();
int sub_2E9E8();
int __fastcall sub_2EA28(_BYTE *a1);
void __fastcall __noreturn sub_2EE34(const char *a1, int a2);
int __fastcall sub_2EE90(pthread_mutex_t *a1, const char *a2, int a3);
void __fastcall __noreturn sub_2EEB8(const char *a1, int a2);
int __fastcall sub_2EF14(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_2EF3C(int a1, const char *a2, int a3);
void __fastcall __noreturn sub_2EF84(const char *a1, int a2);
void __fastcall __noreturn sub_2EFE0(const char *a1, int a2);
void __fastcall __noreturn sub_2F03C(const char *a1, int a2);
int __fastcall sub_2F098(int a1, _BYTE *a2);
int __fastcall sub_2F104(int a1, int a2);
int __fastcall sub_2F180(int a1, _BYTE *a2);
int __fastcall sub_2F1E8(_DWORD *a1, int a2);
int sub_2F9C0();
int __fastcall sub_2FA28(int a1, unsigned int a2);
void __fastcall __noreturn sub_2FB24(const char *a1, int a2);
int __fastcall sub_2FB80(pthread_rwlock_t *a1, const char *a2, int a3);
int sub_2FBB8();
int __fastcall sub_2FC68(int a1);
_DWORD *sub_2FD8C();
_DWORD *__fastcall sub_2FE24(int a1, int a2);
_DWORD *__fastcall sub_2FE4C(int a1);
int __fastcall sub_2FE98(pthread_rwlock_t *a1, int a2);
void __fastcall sub_2FF04(pthread_rwlock_t *a1, void **a2);
_DWORD *__fastcall sub_2FF90(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_3003C(pthread_rwlock_t *a1);
void __fastcall __noreturn sub_30138(const char *a1, int a2);
_DWORD *__fastcall sub_30194(pthread_rwlock_t *a1, int a2);
_DWORD *__fastcall sub_30260(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_3031C(pthread_rwlock_t *a1, int a2);
int __fastcall sub_303D0(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_3046C(int a1);
int sub_304E0();
int __fastcall sub_3189C(int a1);
void sub_319C4();
int __fastcall sub_31B04(int a1);
int __fastcall sub_31B78(int a1);
bool sub_31B8C();
bool sub_31ECC();
void sub_31EE4();
int sub_31FF4();
int __fastcall sub_3209C(int a1, int a2, int a3);
int sub_3218C();
void __fastcall sub_32238(_DWORD *a1);
void __fastcall sub_32370(_DWORD *a1);
void __fastcall sub_32400(int a1);
int __fastcall sub_32424(int a1);
_BYTE *sub_324B8();
const char *__fastcall sub_32704(char *s);
const char *__fastcall sub_327F0(int a1);
int sub_3286C();
const char *__fastcall sub_32AD4(int a1);
int sub_32B50();
void __fastcall sub_32C30(pthread_rwlock_t *a1);
int sub_32DA0();
int __fastcall sub_331A4(int a1);
int __fastcall sub_3332C(int a1, int a2);
unsigned __int64 __fastcall sub_334C0(int a1);
int __fastcall sub_33790(int *a1, int a2);
int __fastcall sub_339BC(int a1, _DWORD *a2, int a3, _DWORD *a4);
void __fastcall sub_33AB4(_DWORD *a1);
int *__fastcall sub_33DDC(int a1);
int __fastcall sub_34178(int a1);
void __fastcall sub_3466C(int a1);
int sub_3479C();
void __noreturn sub_34DF4();
int __fastcall sub_355FC(int a1);
void __fastcall sub_35A94(const char *a1, _DWORD *a2);
int __fastcall sub_35D3C(_DWORD *a1);
int __fastcall sub_360B0(int a1, int a2);
int __fastcall sub_36690(int *a1, int *a2, int a3, int a4, __int64 a5, unsigned int a6);
int __fastcall sub_367EC(int a1, int a2);
void **__fastcall sub_36CD4(int a1, void *a2);
void **__fastcall sub_37020(int a1, pthread_rwlock_t *a2, void *a3);
void **__fastcall sub_37048(int a1);
void **__fastcall sub_370C8(pthread_rwlock_t *a1);
void sub_37134();
int sub_3747C();
void __fastcall sub_375EC(int a1, unsigned __int64 a2);
void __fastcall sub_38678(int a1);
void __noreturn sub_38D3C();
int __fastcall sub_3958C(_DWORD *a1);
int __fastcall sub_3A5D0(int a1);
int __fastcall sub_3BECC(_DWORD *a1);
int __fastcall sub_3D93C(int a1);
void __fastcall sub_3E108(struct timeval *a1);
int __fastcall sub_3E82C(int a1, int a2);
int __fastcall sub_3E918(int a1, int a2, unsigned int a3);
void __fastcall sub_3E9AC(int a1);
int __fastcall sub_3E9D4(int a1, int a2, int a3);
void __fastcall __noreturn sub_3EBA0(int a1);
int __fastcall sub_3EBAC(int a1, int a2, char *s1, const char *a4, const char *a5);
int __fastcall sub_3ECA0(int result);
int __fastcall sub_3EE00(int result);
int __fastcall sub_3EEE8(pthread_rwlock_t *a1);
int __fastcall sub_3EFD4(_DWORD *a1);
_BYTE *__fastcall sub_3F9E0(const void *a1);
void sub_3FA44();
void sub_3FB54();
void sub_3FE74();
char *__fastcall sub_4002C(const char *a1, const char *a2);
int __fastcall sub_40068(_BYTE *a1);
int __fastcall sub_40078(_BYTE *a1);
int __fastcall sub_40088(_BYTE *a1);
char *__fastcall sub_40098(const char *a1, _BYTE *a2);
char *__fastcall sub_4012C(const char *a1, _BYTE *a2);
int __fastcall sub_4014C(int a1, _DWORD *a2);
char *__fastcall sub_40158(const char *a1, _DWORD *a2);
char *__fastcall sub_401E0(const char *a1, int *a2);
char *__fastcall sub_40268(const char *a1, _DWORD *a2);
int __fastcall sub_40330(_DWORD *a1);
void __fastcall __noreturn sub_40348(const char *a1);
void __fastcall __noreturn sub_40368(int a1);
char *__fastcall sub_403A8(char *a1, unsigned __int8 *a2);
char *__fastcall sub_403CC(char *a1, unsigned __int8 *a2);
char *__fastcall sub_403F0(_BYTE *a1, const char **a2);
int __fastcall sub_40450(char *a1, _DWORD *a2);
int __fastcall sub_40464(char *a1, float *a2);
int __fastcall sub_40490(char *a1, _DWORD *a2);
int __fastcall sub_404A4(char *a1, _DWORD *a2);
int __fastcall sub_404B8(char *a1, _DWORD *a2);
const char *__fastcall sub_404CC(unsigned int *a1, size_t *a2);
int __fastcall sub_4056C(int a1, size_t *a2);
int __fastcall sub_405B4(int a1, unsigned int *a2, size_t *a3);
int __fastcall sub_4066C(const char **a1);
int __fastcall sub_407E0(int *a1);
const char *__fastcall sub_40844(unsigned int *a1, size_t *a2);
_BYTE *__fastcall sub_4089C(int a1, unsigned int *a2, size_t *a3);
const char *__fastcall sub_408F4(unsigned int *a1);
_BYTE *__fastcall sub_40954(int a1, unsigned int *a2);
int __fastcall sub_409B4(const char *a1, const char *a2, const char *a3, const char *a4, const char *a5, const char *a6, const char *a7);
int __fastcall sub_409F8(int result, int a2);
bool __fastcall sub_40ACC(_DWORD *a1, const char **a2, void (*a3)(const char *, ...));
void sub_40B28();
int sub_40B48(const char *a1, ...);
void __noreturn sub_40B90(const char *a1, ...);
char *__fastcall sub_40BD0(const char *a1);
void *__fastcall sub_40C00(_DWORD *a1, int a2, int a3);
int __fastcall sub_40C38(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...));
char *__fastcall sub_410E8(const char *a1, const char *a2);
char *__fastcall sub_4152C(char *result, __int16 a2, unsigned int a3);
unsigned int __fastcall sub_41640(int a1, unsigned int a2, int *a3);
int __fastcall sub_41750(int a1, int a2, char *s1, unsigned int a4);
int __fastcall memmem(char *a1, unsigned int a2, char *a3, unsigned int a4);
int __fastcall sub_41D64(unsigned __int8 *a1, int a2);
int __fastcall sub_41FA8(const void *a1, size_t a2);
int __fastcall sub_42554(const void *a1, size_t a2);
int __fastcall sub_42610(const void *a1, size_t a2);
int __fastcall sub_426C4(const void *a1, size_t a2);
int sub_4279C();
int sub_42A18();
void sub_42BA0();
void sub_42BE4();
int sub_42C44();
int __fastcall sub_42DD4(pthread_mutex_t *a1, const char *a2, int a3);
void __fastcall __noreturn sub_42E50(const char *a1, int a2);
__int64 sub_42EB4();
const char *sub_42F3C();
char *__fastcall sub_43370(int a1, size_t *a2);
void __fastcall sub_435E4(int a1);
int __fastcall sub_437BC(int a1);
int __fastcall sub_43ADC(int a1);
int __fastcall sub_43D64(int a1, int a2);
int __fastcall sub_43FA4(int a1);
int __fastcall sub_4424C(int a1, int a2, int a3, int a4);
int __fastcall sub_44264(int a1, const void *a2, size_t a3, _DWORD *a4);
int __fastcall sub_443B4(void *src, size_t n, const void **a3);
int __fastcall sub_443C8(void *src, size_t n, _DWORD *a3);
size_t __fastcall sub_4440C(const void *a1, size_t a2, FILE *s);
int __fastcall sub_44428(void *buf, size_t n, int *a3);
int __fastcall sub_44450(const char **a1, const char **a2);
int __fastcall sub_4445C(char *a1, int a2, int (__fastcall *a3)(char *, int, int), int a4, unsigned int a5);
int __fastcall sub_446E4(char a1, int a2, int a3, int (__fastcall *a4)(__int16 *, int, int), int a5);
int __fastcall sub_44794(int a1, const void *a2, char *s);
int __fastcall sub_447EC(_DWORD *a1, int a2, int a3, int a4, int (__fastcall *a5)(__int16 *, int, int), int a6);
int __fastcall sub_44FFC(_DWORD *a1, int (__fastcall *a2)(__int16 *, int, int), int a3, int a4);
_BYTE *__fastcall sub_45074(_DWORD *a1, int a2);
int __fastcall sub_4511C(_DWORD *a1, int a2, int a3);
int __fastcall sub_45130(_DWORD *a1, int a2, int a3);
int __fastcall sub_45194(_DWORD *a1, int a2, int a3);
int __fastcall sub_451C0(unsigned __int16 *a1, unsigned int a2, int a3);
int __fastcall sub_45704(int a1, int *a2, char *s2, int a4);
void __fastcall sub_45778(int a1);
int __fastcall sub_457E8(_DWORD *a1);
void __fastcall sub_45864(int a1);
int __fastcall sub_4587C(int a1, char *a2, int a3);
int __fastcall sub_45B10(int a1, char *s); // idb
int __fastcall sub_45B70(_DWORD *a1, char *s);
int __fastcall sub_45C90(_DWORD *a1);
int __fastcall sub_45CEC(int a1);
int __fastcall sub_45D04(int a1, char *s); // idb
int __fastcall sub_45D64(int a1, int a2);
int __fastcall sub_45D7C(int a1);
int __fastcall sub_45D84(int a1);
void __fastcall sub_45D8C(int a1, int a2);
int __fastcall sub_45DF8(int result);
int __fastcall sub_45EF4(_DWORD *a1);
int __fastcall sub_45F18(int a1);
int __fastcall sub_45F3C(_DWORD *a1);
int sub_45F98(int result, _DWORD *a2, int a3, const char *a4, ...);
void __fastcall sub_460C8(int a1);
int __fastcall sub_46108(int *a1);
int __fastcall sub_46134(_BYTE *a1);
_DWORD *__fastcall sub_461C8(_DWORD *result, int a2);
int __fastcall sub_46284(int a1, int a2);
int __fastcall sub_4640C(int a1, int a2);
_DWORD *__fastcall sub_4644C(_DWORD *result, int a2);
unsigned int __fastcall sub_46498(int a1, int a2);
_DWORD *__fastcall sub_46CB0(int a1, int a2, int a3);
_DWORD *__fastcall sub_47154(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall sub_47258(int a1, int a2, char *a3);
_DWORD *__fastcall sub_47320(int a1, int a2, int a3, char *a4);
_DWORD *__fastcall sub_473F4(int a1, int a2, char *a3);
_DWORD *__fastcall sub_474D4(int a1, int a2, char *a3);
_DWORD *__fastcall sub_475B0(char *a1, int a2, char *a3);
void *__fastcall sub_4774C(void *result);
void __fastcall sub_47764(void *a1);
_BYTE *__fastcall sub_4777C(const void *a1, size_t a2);
_BYTE *__fastcall sub_477C8(const char *a1);
int __fastcall sub_477E4(__int64 a1);
_DWORD *__fastcall sub_477F4(_DWORD *result, _DWORD *a2);
int __fastcall sub_47820(_DWORD *a1);
void __fastcall sub_47854(int a1);
int __fastcall sub_47880(int result);
int __fastcall sub_47894(int a1);
int __fastcall sub_4789C(int *a1);
int __fastcall sub_478B0(const void **a1, void *src, size_t n);
int __fastcall fh_buffer_putc(const void **a1, char a2);
int __fastcall sub_479A0(int *a1, char a2, int a3);
int __fastcall sub_479C8(int a1, double *a2);
int __fastcall sub_47AB8(char *a1, size_t a2, int a3);
int __fastcall sub_47BF8(int a1, _BYTE *a2, _DWORD *a3);
int __fastcall sub_47CE4(int a1);
int __fastcall sub_47D50(char *a1, unsigned int a2, int *a3);
char *__fastcall sub_47E38(char *result, int a2, _DWORD *a3);
int __fastcall sub_47EB4(int a1, unsigned int a2);
_QWORD *__fastcall sub_47F30(int a1);
void *__fastcall sub_47F80(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall sub_4800C(_BYTE *a1, size_t a2, int a3);
_DWORD *sub_48078();
_DWORD *__fastcall sub_480E0(_DWORD *result);
int __fastcall sub_480FC(_DWORD *a1, char *a2);
bool __fastcall sub_48124(int *a1, int *a2);
int __fastcall sub_48304(_DWORD *a1, char *a2);
int __fastcall sub_48364(_DWORD *a1);
int __fastcall sub_48388(_DWORD *a1, char *a2);
int __fastcall sub_483B0(_DWORD *a1, int a2);
int __fastcall sub_483E4(int a1);
int __fastcall sub_483F0(int a1);
int __fastcall sub_483FC(int result);
_DWORD *sub_48408();
_DWORD *__fastcall sub_48468(_DWORD *result);
_DWORD *__fastcall sub_48484(_DWORD *result, unsigned int a2);
int __fastcall sub_484B8(_DWORD *a1, _DWORD *a2);
const char *__fastcall sub_48590(const char *result);
_DWORD *__fastcall sub_485B8(_BYTE *a1, size_t a2);
_DWORD *__fastcall sub_485C0(_BYTE *a1, size_t a2);
_DWORD *__fastcall sub_485C8(_BYTE *a1, size_t a2);
const char *__fastcall BUFX_strdup(const char *result);
_DWORD *__fastcall sub_48630(_DWORD *result);
_DWORD *__fastcall sub_4864C(_DWORD *result);
int __fastcall sub_48668(int a1, const void *a2, size_t a3);
int __fastcall sub_486CC(int a1, const char *a2);
int __fastcall sub_48700(int a1, const void *a2, size_t a3);
int __fastcall sub_48744(int a1, const char *a2);
_DWORD *__fastcall sub_48778(char *format, __gnuc_va_list arg);
_DWORD *ipcomx_vprintf(char *a1, ...);
_QWORD *__fastcall sub_48858(__int64 a1);
__int64 __fastcall sub_4888C(int a1);
int __fastcall sub_488B4(int a1, __int64 a2);
double *sub_488DC();
void sub_48938();
int __fastcall sub_489C8(int result);
void *sub_48A10();
void *sub_48A1C();
void *sub_48A28();
void __fastcall sub_48A34(_DWORD *a1);
int __fastcall sub_48B00(_DWORD *a1);
int __fastcall sub_48B90(_DWORD *a1, int a2, _DWORD *a3);
int __fastcall sub_48C28(_DWORD *a1, unsigned int a2);
int __fastcall sub_48CF4(_DWORD *a1, char *a2, _DWORD *a3);
int __fastcall sub_48DB0(_DWORD *a1, _DWORD *a2);
int __fastcall sub_48E9C(_DWORD *a1, char *a2, _DWORD *a3);
int __fastcall sub_48F30(_DWORD *a1, _DWORD *a2);
int __fastcall sub_49010(_DWORD *a1, _DWORD *a2);
int __fastcall sub_49100(_DWORD *a1, unsigned int a2, _DWORD *a3);
int __fastcall sub_4935C(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_49438(int *a1, int *a2);
double *__fastcall sub_49450(int a1);
double *__fastcall sub_4960C(int a1);
char *__fastcall sub_49770(char *a1, char *s);
char *__fastcall sub_497D4(char *result, char *a2);
char *__fastcall sub_49814(char *a1, char *s);
int sub_49824(int result, int a2, int a3, int a4, char a5, char *format, ...);
int __fastcall sub_49888(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg);
int __fastcall sub_49B34(unsigned int a1, unsigned int a2);
int __fastcall sub_49B50(int result, unsigned int a2);
int __fastcall sub_4A10C(__int64 a1);
int __fastcall sub_4A11C(__int64 a1);
int __fastcall sub_4A178(unsigned __int64 a1, unsigned __int64 a2);
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
int __fastcall init(int a1, int a2, int a3);
int nullsub_10(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN loc_49B98; // weak
_UNKNOWN unk_4A450; // weak
__int16 word_4A834 = 11822; // weak
int dword_4B184 = 28526; // weak
const char asc_4C844[] = "                    "; // idb
__int16 word_4C858 = 10; // weak
_DWORD dword_4C8CC[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char *off_4CCE8 = "http:"; // weak
_UNKNOWN unk_4DD00; // weak
_UNKNOWN unk_4DD34; // weak
char aJsonEscape[12] = "json_escape"; // weak
_DWORD dword_4EABC[10] = { 1, 350896, 64, 350904, 64, 350916, 8, 350928, 10, 336076 }; // weak
char a00000002c01f50[321] = "00000002c01f502cb3e9fdb053230ec12a4954c1021a6b35862b5e29000000000000000084d1b83ae44057025e8c5b5756b44f04df5fffe4a7a30e5c12d12a97a7a4c2ea536dce431900896cb6d60e00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000d08f7e14c50dad77dc238b4db2901a0578e657b1954779ab9cd82a73829edf7f"; // weak
char a000000029c6bf4[321] = "000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000082b1514e7b6565941e5824f084292164ec5f97e7ea20c494bd96e524d478977b536dd2261900896c8b10020000000080000000000000000000000000000000000000000000000000000000000000000000000000000000008002000064e4e3becc01064d808269b330f40f4de82dc92e894d635025daa3e2e2c410b4"; // weak
_UNKNOWN unk_51CDC; // weak
__int16 word_51DD8 = 47; // weak
_UNKNOWN unk_5212C; // weak
_UNKNOWN unk_52150; // weak
__int16 word_5406C = 11105; // weak
char aUnexpectedExtr[39] = "Unexpected extra commandline arguments"; // weak
char aAllDevicesDisa[35] = "All devices disabled, cannot mint!"; // weak
const char a10[] = "1.0."; // idb
__int16 word_55AAC = 48; // weak
int (*off_55DAC)() = &sub_41FA8; // weak
__int16 word_5616C = 93; // weak
_UNKNOWN *off_66F00 = (_UNKNOWN *)0x15AFD; // weak
_UNKNOWN *off_66F04 = (_UNKNOWN *)0x15AE5; // weak
int dword_67298[] = { 3 }; // weak
int dword_6729C = 7; // weak
_UNKNOWN *off_677C8 = (_UNKNOWN *)0x558B4; // weak
int dword_67DB4 = 5; // weak
_DWORD dword_67DB8[63] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817
}; // weak
_UNKNOWN unk_67EB4; // weak
_UNKNOWN unk_67ED4; // weak
int (*off_67ED8)() = &sub_21C98; // weak
char *off_67FE0 = "--version-file"; // weak
int dword_67FE4 = 2; // weak
_UNKNOWN unk_67FFC; // weak
int dword_68718 = 1; // weak
double dbl_68720 = 1.0; // weak
char dword_68728[] = { '0', '\0', '\0', '\0' }; // idb
int dword_6872C = 0; // weak
int dword_68730 = 5; // weak
char *off_68734 = ":D"; // weak
double dbl_68738 = 1.0; // weak
double dbl_68740 = 1.0; // weak
double dbl_68748 = 1.84467441e19; // weak
int dword_68750 = 120; // weak
int dword_68754 = -1; // weak
int dword_68758 = 120; // weak
char byte_6875C = '\x01'; // weak
char byte_6875D = '\x01'; // weak
char *off_68760 = "--config|-c"; // weak
char *off_687EC = "000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"; // weak
int dword_687F4[4] = { 2, 5, 1800, 550 }; // weak
int dword_68804 = 4028; // weak
_UNKNOWN *off_68808 = (_UNKNOWN *)0x4D5C8; // weak
char *off_6880C[3] = { "FTW", "224.0.0.75", "0.0.0.0" }; // weak
char *off_68810[2] = { "224.0.0.75", "0.0.0.0" }; // weak
char *off_68814 = "0.0.0.0"; // weak
int dword_68818 = 4028; // weak
_UNKNOWN *off_6881C = &unk_55AA0; // weak
char byte_68820 = '\x01'; // weak
int dword_68824 = 1; // weak
char aBitmainApiDete[19] = "bitmain_api_detect"; // weak
char aBitmainUpdateJ[19] = "bitmain_update_job"; // weak
char aBitmainShutdow[17] = "bitmain_shutdown"; // weak
_UNKNOWN unk_689C8; // weak
int (*off_689D4)() = &sub_42A18; // weak
int dword_68A40 = 25000; // weak
void *(*off_68A44)(size_t size) = &malloc; // weak
void (*off_68A48)(void *ptr) = &free; // weak
_UNKNOWN unk_68A4C; // weak
_UNKNOWN unk_68A54; // weak
_UNKNOWN unk_68A5C; // weak
int stderr; // weak
int stdin; // weak
int stdout; // weak
char byte_68A78; // weak
char byte_68A7C; // weak
char byte_68A7D; // weak
char byte_68A7E; // weak
int dword_68A80; // weak
int dword_68A84; // weak
pthread_mutex_t stru_68A88; // idb
int dword_68AA0; // weak
int dword_68AA4; // weak
int dword_68AA8; // weak
char byte_68AAC; // weak
int dword_68AB0; // weak
__int16 word_68AB4; // weak
int dword_68AD4; // weak
char byte_68BD4; // weak
char byte_68BD5; // weak
char byte_68BD6; // weak
char byte_68BD8[512]; // weak
int dword_68DD8; // weak
int dword_68DDC; // weak
int dword_68DE0; // weak
int dword_68DE4; // weak
int dword_68DE8; // weak
int dword_68DEC; // weak
int dword_68DF0; // weak
char s[256]; // idb
int dword_68EF4; // weak
int dword_68EF8; // weak
char byte_68EFC; // weak
char byte_68F00[200]; // idb
int dword_68FC8; // weak
int dword_68FCC; // weak
int dword_68FD0; // weak
int dword_68FD4; // weak
struct timeval stru_68FD8; // weak
struct timeval stru_68FE0; // weak
_UNKNOWN unk_68FE8; // weak
__int64 qword_68FF0; // weak
int dword_68FF8; // weak
int dword_68FFC; // weak
int dword_69000; // weak
int dword_69004; // weak
int dword_69008; // weak
char byte_6900C; // weak
int dword_69010; // weak
int dword_69014; // weak
int dword_69018; // weak
int dword_6901C; // weak
int dword_69020; // weak
int dword_69024; // weak
char byte_69028[40]; // weak
int dword_69050; // weak
int dword_69054; // weak
int dword_69058; // weak
int dword_6905C; // weak
int dword_69060; // weak
char byte_69064; // weak
int dword_69068; // weak
int dword_6906C; // weak
int dword_69070; // weak
int dword_69074; // weak
int dword_69078; // weak
struct timeval stru_6907C; // weak
double dbl_69088[12]; // weak
int dword_690E8; // weak
int dword_690EC; // weak
pthread_mutex_t stru_690F0; // idb
int dword_69108; // weak
pthread_mutex_t stru_6910C; // idb
pthread_cond_t cond; // idb
pthread_mutex_t mutex; // idb
char byte_69170; // weak
pthread_t newthread; // idb
int dword_69178; // weak
char byte_6917C; // weak
int dword_69180; // weak
int dword_69188; // weak
pthread_mutex_t stru_6918C; // idb
int dword_691A4; // weak
int dword_691A8; // weak
int dword_691AC; // weak
_UNKNOWN unk_691B0; // weak
_UNKNOWN unk_69BB0; // weak
int dword_6A5B0; // weak
double dbl_6A5B8; // weak
char byte_6A5C0[256]; // weak
pthread_rwlock_t stru_6A6C0; // idb
int dword_6A6E0; // weak
char byte_6A6E4[8]; // weak
_UNKNOWN unk_6A6EC; // weak
char byte_6A70C[32]; // weak
char dest[8]; // idb
char byte_6A734; // weak
int dword_6A738; // weak
int dword_6A73C; // weak
int dword_6A740; // weak
int dword_6A744; // weak
int dword_6A748; // weak
char byte_6A74C[4]; // weak
char byte_6A84C[256]; // idb
_UNKNOWN unk_6A950; // weak
int dword_6A970; // weak
int dword_6A974; // weak
int dword_6A978[65]; // weak
char byte_6AA7C; // weak
_UNKNOWN unk_6AA80; // weak
int dword_6AB9C; // weak
float flt_6ABA0; // weak
int dword_6ABA4; // weak
int dword_6ABA8; // weak
int dword_6ABAC; // weak
int dword_6ABB0; // weak
double dbl_6ABB8; // weak
char byte_6ABC0[16]; // weak
unsigned __int8 byte_6ABD0[248]; // weak
int dword_6ACC8; // weak
int dword_6ACD0; // weak
int dword_6ACD4; // weak
__int64 qword_6ACD8; // weak
int dword_6ACE0; // weak
int dword_6ACE4; // weak
int dword_6ACE8; // weak
pthread_mutex_t stru_6ACEC; // weak
int dword_6AD04; // weak
_UNKNOWN unk_6AD08; // weak
_UNKNOWN unk_6ED08; // weak
char s2[17404]; // idb
int dword_73108; // weak
_BYTE algn_7310C[4]; // weak
_UNKNOWN unk_73110; // weak
_UNKNOWN *off_7311C; // weak
_UNKNOWN unk_73188; // weak
_UNKNOWN unk_731F0; // weak
_UNKNOWN unk_73268; // weak
int (__fastcall *off_73274)(_DWORD); // weak
int dword_732E0; // weak
char byte_732E4; // weak
int dword_732EC; // weak
int dword_732F0; // weak
__int64 qword_73318; // weak
int dword_73320; // weak
char byte_73324[68]; // weak
int dword_73368; // weak
double dbl_73370; // weak
char byte_73378; // weak
__int64 qword_73380; // weak
char byte_73388; // weak
double dbl_73390; // weak
char byte_73398; // weak
char byte_7339C; // weak
int dword_733A4; // weak
int dword_733A8; // weak
int dword_733CC; // weak
struct sigaction stru_733D0; // weak
int dword_7345C; // weak
char byte_73460; // weak
int dword_73464; // weak
int dword_7346C; // weak
int dword_73470; // weak
int dword_73478; // weak
char byte_7347C; // weak
char byte_7347D; // weak
int dword_73480; // weak
char byte_73484[4096]; // weak
int dword_74484; // weak
char byte_74488; // weak
int dword_7448C; // weak
int dword_74494; // weak
int dword_74498; // weak
char byte_7449C; // weak
char byte_7449D; // weak
int dword_744A0; // weak
int dword_744A4; // weak
pthread_rwlock_t stru_744A8; // weak
int dword_744C8; // weak
pthread_cond_t stru_744D0; // weak
char byte_74500; // weak
char byte_74501; // weak
char byte_74502; // weak
pthread_mutex_t stru_74504; // weak
pthread_rwlock_t stru_7451C; // idb
pthread_mutex_t stru_7453C; // weak
pthread_rwlock_t rwlock; // idb
int dword_74578; // weak
char byte_7457C[4096]; // weak
int dword_7557C; // weak
int dword_75580; // weak
int dword_75584; // weak
int dword_75588; // weak
double dbl_75590; // weak
int dword_75598; // weak
char byte_7559C; // weak
pthread_rwlock_t stru_755A0; // weak
int dword_755C0; // weak
int dword_755C4; // weak
int dword_755D0; // weak
char byte_755D4; // weak
__int64 qword_755D8; // weak
int dword_755E0; // weak
int dword_755E8; // weak
int dword_755EC; // weak
int dword_755F0; // weak
int dword_755F4; // weak
struct sigaction stru_755F8; // weak
char byte_75684; // weak
char byte_75685; // weak
double dbl_75688; // weak
double dbl_75690; // weak
double dbl_75698; // weak
double dbl_756A8; // weak
char byte_756B0; // weak
char byte_756B4[4100]; // weak
double dbl_766B8; // weak
int dword_766C0; // weak
pthread_mutex_t stru_766C4; // weak
int dword_766DC; // weak
char byte_766E0; // weak
pthread_mutex_t stru_766E4; // weak
pthread_cond_t stru_76700; // weak
struct sigaction stru_76730; // weak
char byte_767BC; // weak
int dword_767C0; // weak
int dword_767C4; // weak
pthread_mutex_t stru_767C8; // weak
int dword_767E0; // weak
__int64 qword_767E8; // weak
char byte_767F0; // weak
pthread_mutex_t stru_767F4; // weak
pthread_rwlock_t stru_7680C; // weak
double dbl_76830; // weak
pthread_mutex_t stru_76838; // weak
__int64 qword_76850; // weak
int dword_76858; // weak
int dword_7685C; // weak
int dword_76860; // weak
int dword_76864; // weak
int dword_76868; // weak
int dword_7686C; // weak
_UNKNOWN unk_76870; // weak
pthread_mutex_t stru_76874; // weak
pthread_mutex_t stru_7688C; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00011E64) --------------------------------------------------------
int init_proc()
{
  return sub_15A70();
}

//----- (00011E70) --------------------------------------------------------
void sub_11E70()
{
  JUMPOUT(0);
}
// 11E7C: control flows out of bounds to 0

//----- (000125F8) --------------------------------------------------------
void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  const char *v3; // r8
  FILE *v4; // r9
  size_t v5; // r0
  FILE *v6; // r0
  size_t v7; // r6
  int v8; // r9
  char *v9; // r7
  size_t i; // r5
  const unsigned __int16 **v11; // r0
  int v12; // t1
  int v13; // r3
  int v14; // r6
  int v15; // r0
  int (*v16)(void); // r2
  int (**v17)(); // r3
  bool v18; // zf
  int v19; // r0
  char *v20; // r0
  int v21; // r3
  char *v22; // r5
  char *v23; // r7
  int v24; // r6
  const char **v25; // r8
  const char *v26; // t1
  char *v27; // r0
  int v28; // r6
  const char *v29; // r0
  char *v30; // r0
  char *v31; // r8
  char *v32; // r7
  char *v33; // r0
  size_t v34; // r0
  unsigned __int8 *v35; // r12
  char *v36; // r5
  size_t v37; // r0
  unsigned int v38; // r6
  unsigned int v39; // r7
  int v40; // r12
  int v41; // r3
  unsigned __int8 *v42; // r10
  unsigned int v43; // r2
  unsigned __int8 *v44; // r0
  int v45; // r1
  unsigned int v46; // r8
  unsigned int v47; // r12
  int v48; // r3
  unsigned int v49; // r2
  unsigned int v50; // r12
  int v51; // r3
  unsigned int v52; // r7
  unsigned int v53; // r12
  char *v54; // r2
  unsigned int v55; // r12
  int v56; // r3
  unsigned int v57; // r7
  unsigned int v58; // r2
  int v59; // r3
  unsigned int v60; // r1
  unsigned int v61; // r2
  unsigned int v62; // r3
  unsigned int v63; // r6
  size_t v64; // r0
  unsigned __int8 *v65; // r3
  int v66; // r7
  int v67; // r3
  char *v68; // r8
  int v69; // r3
  int v70; // r6
  int v71; // r2
  _DWORD *v72; // r2
  int v73; // r1
  int v74; // r3
  _DWORD *v75; // r8
  int v76; // r1
  char *v77; // r9
  __int64 *v78; // r3
  __int64 v79; // r0
  _DWORD *v80; // r7
  _DWORD *v81; // r6
  int v82; // r5
  char *v83; // r2
  unsigned int v84; // r3
  int v85; // r1
  int v86; // r3
  int v87; // r3
  _DWORD *v88; // r3
  unsigned int v89; // r2
  unsigned int v90; // r1
  bool v91; // cc
  int v92; // r2
  int v93; // r3
  _BYTE *v94; // r6
  _DWORD *v95; // r0
  char *v96; // r3
  _DWORD *v97; // r2
  int *v98; // r3
  int v99; // r0
  int v100; // r1
  __int16 v101; // r3
  int v102; // r3
  int v103; // r3
  char *v104; // r9
  int v105; // r5
  _BYTE *v106; // r6
  _BYTE *v107; // r0
  unsigned __int8 *v108; // r1
  int v109; // r5
  const char *v110; // r1
  const char *v111; // r1
  const char *v112; // r5
  const char *v113; // r3
  int v114; // r3
  int v115; // r4
  int v116; // r2
  int v117; // r6
  int v118; // r5
  pthread_rwlock_t *v119; // r0
  char *v120; // r0
  int v121; // r9
  unsigned int v122; // r7
  char *j; // r0
  char v124; // r3
  char *v125; // r12
  const char *v126; // r0
  int v127; // r0
  bool v128; // zf
  int v129; // r0
  int v130; // r3
  int v131; // r3
  int v132; // r5
  unsigned __int8 *v133; // r7
  int v134; // r0
  int v135; // r3
  int v136; // r3
  char *v137; // r7
  int v138; // r5
  int v139; // r0
  int v140; // r3
  void *v141; // r0
  void **v142; // r9
  void *v143; // r0
  char *v144; // r12
  int *v145; // lr
  int v146; // r0
  int v147; // r1
  int v148; // r2
  int v149; // r3
  _DWORD *v150; // r12
  _DWORD *v151; // lr
  int v152; // r1
  const char *v153; // r1
  int v154; // r0
  int v155; // r3
  int v156; // r0
  int v157; // r1
  int v158; // r12
  int v159; // r3
  int v160; // r1
  int v161; // r12
  int k; // r3
  int v163; // r2
  int m; // r6
  _DWORD *v165; // r3
  int v166; // r4
  int v167; // r3
  const char *v168; // r0
  size_t v169; // r5
  size_t v170; // r5
  char *v171; // r0
  const char *v172; // r3
  char *v173; // r6
  __sighandler_t v174; // r4
  __sighandler_t v175; // r0
  bool v176; // zf
  __pid_t v177; // r0
  __pid_t v178; // r4
  size_t v179; // r0
  int n; // r5
  int v181; // r8
  const char *v182; // r8
  const char *v183; // r4
  const char *v184; // r10
  char *v185; // r8
  const char *v186; // r5
  _DWORD *v187; // r0
  int v188; // r2
  const char **v189; // r0
  sem_t *v190; // r7
  const char *v191; // r6
  char *v192; // r3
  int *v193; // r10
  int *v194; // r9
  char *v195; // r4
  int *v196; // r0
  int v197; // r12
  char *v198; // r1
  int v199; // r0
  int v200; // lr
  int v201; // r5
  int v202; // r5
  int v203; // r3
  int v204; // r3
  int v205; // r5
  int *v206; // r0
  int v207; // r2
  int v208; // r3
  int v209; // r1
  char *v210; // r5
  unsigned __int8 *v211; // r4
  pthread_mutex_t *v212; // r0
  int v213; // r3
  int v214; // r1
  int v215; // r3
  void **v216; // r0
  int v217; // r0
  unsigned __int8 *v218; // r8
  int v219; // r3
  int v220; // r1
  int v221; // r3
  void **v222; // r0
  int v223; // r0
  unsigned __int8 *v224; // r8
  int v225; // r3
  int ii; // r3
  _DWORD *v227; // r12
  int v228; // r3
  int v229; // r3
  char *v230; // r10
  int v231; // r1
  int v232; // r3
  int v233; // r12
  int v234; // r0
  int v235; // r3
  int v236; // r5
  int jj; // r10
  int v238; // r0
  unsigned __int8 *v239; // r1
  void **v240; // r8
  char *v241; // r1
  void **v242; // r3
  int v243; // r3
  const char *v244; // lr
  char *v245; // r12
  int v246; // r0
  int v247; // r1
  int v248; // r2
  int v249; // r3
  _DWORD *v250; // lr
  _DWORD *v251; // r12
  int v252; // r1
  int v253; // r2
  int kk; // r3
  _DWORD *v255; // r12
  int v256; // r3
  int mm; // r3
  int v258; // r3
  int v259; // r10
  int v260; // r1
  int v261; // r3
  int v262; // r0
  int v263; // r0
  int nn; // r10
  int v265; // r0
  unsigned __int8 *v266; // r1
  unsigned __int8 *v267; // r1
  int *v268; // r0
  void **v269; // r10
  struct timeval *v270; // r8
  void **v271; // r3
  int *v272; // r0
  int v273; // r0
  int v274; // r1
  int v275; // r3
  int v276; // r12
  int v277; // r4
  int v278; // r3
  const char **v279; // r8
  int v280; // r7
  int v281; // r3
  pthread_mutex_t *v282; // r0
  int v283; // r7
  int *v284; // r0
  int *v285; // r0
  int i1; // r4
  char v287; // [sp+10h] [bp-2A34h] BYREF
  char v288[4088]; // [sp+1018h] [bp-1A2Ch] BYREF
  const char *v289; // [sp+2010h] [bp-A34h]
  int *v290; // [sp+2020h] [bp-A24h]
  char *v291; // [sp+2024h] [bp-A20h]
  char *v292; // [sp+2028h] [bp-A1Ch]
  int *v293; // [sp+202Ch] [bp-A18h]
  int v294; // [sp+2030h] [bp-A14h]
  __int16 *v295; // [sp+2034h] [bp-A10h]
  const char *v296; // [sp+2038h] [bp-A0Ch]
  char *v297; // [sp+203Ch] [bp-A08h]
  char *v298; // [sp+2040h] [bp-A04h]
  int *v299; // [sp+2044h] [bp-A00h]
  char *v300; // [sp+2048h] [bp-9FCh]
  unsigned __int8 *v301; // [sp+204Ch] [bp-9F8h]
  char *format; // [sp+2050h] [bp-9F4h]
  const char **v303; // [sp+2054h] [bp-9F0h]
  int v304; // [sp+2058h] [bp-9ECh]
  int v305; // [sp+205Ch] [bp-9E8h] BYREF
  void **v306; // [sp+2060h] [bp-9E4h] BYREF
  char dest[32]; // [sp+2064h] [bp-9E0h] BYREF
  struct sigaction s; // [sp+2084h] [bp-9C0h] BYREF
  char v309[256]; // [sp+2110h] [bp-934h] BYREF
  int v310[513]; // [sp+2210h] [bp-834h] BYREF

  byte_68AAC = 0;
  v305 = a1;
  v3 = *a2;
  v303 = a2;
  v299 = (int *)&byte_68AAC;
  v306 = 0;
  memset(v309, 0, sizeof(v309));
  memset(&s, 0, 0x40u);
  snprintf((char *)&s, 0x40u, "pidof %s", v3);
  v4 = popen((const char *)&s, "r");
  if ( v4 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          if ( !fgets(v309, 256, v4) )
          {
            v6 = v4;
            v7 = 0;
            v8 = 0;
            pclose(v6);
            v9 = v309;
            for ( i = 1; strlen(v309) >= i; ++i )
            {
              memset(dest, 0, sizeof(dest));
              v11 = _ctype_b_loc();
              v12 = (unsigned __int8)*v9++;
              if ( ((*v11)[v12] & 0x2000) != 0 )
              {
                strncpy(dest, &v309[v7], i - v7 - 1);
                v13 = strtol(dest, 0, 10);
                if ( v13 > 0 && (++v8, byte_68BD5) && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                {
                  snprintf((char *)v310, 0x800u, "Parsed proc id is: %d\n", v13);
                  v7 = i;
                  sub_20F58(7, (const char *)v310, 0);
                }
                else
                {
                  v7 = i;
                }
              }
            }
            if ( v8 )
            {
              if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
              {
                snprintf((char *)v310, 0x800u, " %d instance of %s is  already Running on this machine", v8, v3);
                sub_20F58(3, (const char *)v310, 0);
              }
              if ( v8 != 1 )
              {
                snprintf((char *)v310, 0x800u, "%s is forbidden to start twice, will exit immediately!", *v303);
                sub_20F58(3, (const char *)v310, 1);
                sub_2E6B0(-1, 0);
              }
            }
            goto LABEL_34;
          }
        }
        while ( !byte_68BD5 );
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
          break;
LABEL_9:
        if ( byte_68BD4 || dword_67DB4 > 6 )
        {
LABEL_11:
          v5 = strlen(v309);
          snprintf((char *)v310, 0x800u, "strlen is: %d\n", v5);
          sub_20F58(7, (const char *)v310, 0);
        }
      }
      snprintf((char *)v310, 0x800u, "pidof %s command result is: %s\n", v3, v309);
      sub_20F58(7, (const char *)v310, 0);
      if ( byte_68BD5 )
      {
        if ( byte_74500 )
          goto LABEL_11;
        goto LABEL_9;
      }
    }
  }
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf((char *)v310, 0x800u, " app-service:%s Not Found!!!", v3);
    sub_20F58(7, (const char *)v310, 0);
  }
LABEL_34:
  strcpy((char *)&dword_68AD4, "bmminer.log");
  strcpy((char *)&word_68AB4, "a+");
  v297 = (char *)&word_68AB4;
  LOWORD(v14) = (unsigned __int16)byte_68BD8;
  v15 = sysconf(84);
  v18 = v15 == 1;
  if ( v15 == 1 )
  {
    v17 = &off_67ED8;
    v16 = sched_yield;
  }
  v19 = v305 + 1;
  if ( v18 )
    *v17 = v16;
  HIWORD(v14) = (unsigned int)byte_68BD8 >> 16;
  v304 = v14;
  v20 = (char *)sub_229BC(4 * v19, "cgminer.c", "main", 11819);
  v21 = v305;
  v22 = v20;
  *(_DWORD *)(v14 + 0x47C) = v20;
  if ( v21 > 0 )
  {
    v23 = v20 - 4;
    v24 = 0;
    v25 = v303 - 1;
    do
    {
      v26 = v25[1];
      ++v25;
      ++v24;
      *((_DWORD *)v23 + 1) = _strdup(v26);
      v23 += 4;
      v21 = v305;
    }
    while ( v305 > v24 );
  }
  *(_DWORD *)&v22[4 * v21] = 0;
  sub_2EE90(&stru_76838, "main", 11828);
  sub_2EE90(&stru_767C8, "main", 11829);
  sub_2EE90(&stru_766E4, "main", 11830);
  sub_2EF3C((int)&stru_7453C, "main", 11831);
  sub_2EE90(&stru_766C4, "main", 11832);
  v301 = byte_6ABD0;
  sub_2EE90(&stru_6918C, "main", 11833);
  sub_2EF3C((int)&stru_74504, "main", 11834);
  sub_2EE90(&stru_690F0, "main", 11835);
  sub_2EF14(&stru_6A6C0, "main", 11836);
  sub_2EF14(&stru_755A0, "main", 11837);
  sub_2EF14(&stru_744A8, "main", 11838);
  sub_2EF14(&stru_7680C, "main", 11839);
  sub_2EE90(&stru_6910C, "main", 11841);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v310, "Failed to pthread_cond_init lp_cond");
    sub_20F58(3, (const char *)v310, 1);
    sub_2E6B0(1, 0);
  }
  sub_2EE90(&stru_767F4, "main", 11848);
  if ( pthread_cond_init(&stru_76700, 0) )
  {
    strcpy((char *)v310, "Failed to pthread_cond_init restart_cond");
    sub_20F58(3, (const char *)v310, 1);
    sub_2E6B0(1, 0);
  }
  v298 = (char *)pthread_cond_init(&stru_744D0, 0);
  if ( v298 )
  {
    strcpy((char *)v310, "Failed to pthread_cond_init gws_cond");
    sub_20F58(3, (const char *)v310, 1);
    sub_2E6B0(1, 0);
  }
  v27 = sub_23300();
  dword_755E0 = (int)v27;
  if ( !v27 )
  {
    strcpy((char *)v310, "Failed to create getq");
    sub_20F58(3, (const char *)v310, 1);
    sub_2E6B0(1, 0);
  }
  v289 = (const char *)&unk_55AA8;
  *(_DWORD *)(v304 + 0x438) = v27 + 12;
  snprintf(::s, 0x100u, "%s %s", "cgminer", v289);
  s.sa_handler = (__sighandler_t)sub_2E78C;
  s.sa_flags = (int)v298;
  v296 = (const char *)&dword_755C4;
  sigemptyset(&s.sa_mask);
  sigaction(15, &s, &stru_755F8);
  sigaction(2, &s, &stru_76730);
  sigaction(6, &s, &stru_733D0);
  dword_755C4 = (int)v288;
  strcpy(v288, "/usr/bin");
  v28 = 36;
  dword_7557C = (int)&v287;
  v29 = *v303;
  v295 = &word_51DD8;
  v30 = _strdup(v29);
  v31 = (char *)dword_7557C;
  v32 = v30;
  v33 = dirname(v30);
  strcpy(v31, v33);
  free(v32);
  v34 = strlen((const char *)dword_7557C);
  v35 = v301;
  *(_WORD *)(dword_7557C + v34) = 47;
  *(_DWORD *)&v35[-644] = 9;
  v36 = (char *)sub_22A44(0x68u, 1u, "cgminer.c", "main", 11895);
  do
  {
    v37 = strlen(v36);
    --v28;
    *(_WORD *)&v36[v37] = 48;
  }
  while ( v28 );
  v38 = v37 + 1;
  v39 = -1640531527;
  v40 = -17973521;
  format = (char *)(v37 + 1);
  v41 = -1640531527;
  if ( v37 + 1 <= 0xB )
  {
    v44 = (unsigned __int8 *)v36;
    v54 = format;
  }
  else
  {
    v42 = (unsigned __int8 *)(v36 + 12);
    v300 = v36;
    do
    {
      v38 -= 12;
      v43 = (*(v42 - 6) << 16) + (*(v42 - 7) << 8) + *(v42 - 8) + (*(v42 - 5) << 24) + v39;
      v44 = v42;
      v45 = (*(v42 - 2) << 16) + (*(v42 - 3) << 8) + *(v42 - 4) + (*(v42 - 1) << 24);
      v46 = (*(v42 - 10) << 16) + (*(v42 - 11) << 8) + *(v42 - 12) + (*(v42 - 9) << 24) - v43;
      v42 += 12;
      v47 = v45 + v40;
      v48 = (v46 - v47 + v41) ^ (v47 >> 13);
      v49 = (v43 - v47 - v48) ^ (v48 << 8);
      v50 = (v47 - v48 - v49) ^ (v49 >> 13);
      v51 = (v48 - v49 - v50) ^ (v50 >> 12);
      v52 = (v49 - v50 - v51) ^ (v51 << 16);
      v53 = (v50 - v51 - v52) ^ (v52 >> 5);
      v41 = (v51 - v52 - v53) ^ (v53 >> 3);
      v39 = (v52 - v53 - v41) ^ (v41 << 10);
      v40 = (v53 - v41 - v39) ^ (v39 >> 15);
    }
    while ( v38 > 0xB );
    v36 = v300;
    v54 = (char *)v38;
  }
  v55 = (unsigned int)&format[v40];
  switch ( (unsigned int)v54 )
  {
    case 1u:
      goto LABEL_62;
    case 2u:
      goto LABEL_61;
    case 3u:
      goto LABEL_60;
    case 4u:
      goto LABEL_59;
    case 5u:
      goto LABEL_58;
    case 6u:
      goto LABEL_57;
    case 7u:
      goto LABEL_56;
    case 8u:
      goto LABEL_55;
    case 9u:
      goto LABEL_54;
    case 0xAu:
      goto LABEL_53;
    case 0xBu:
      v55 += v44[10] << 24;
LABEL_53:
      v55 += v44[9] << 16;
LABEL_54:
      v55 += v44[8] << 8;
LABEL_55:
      v39 += v44[7] << 24;
LABEL_56:
      v39 += v44[6] << 16;
LABEL_57:
      v39 += v44[5] << 8;
LABEL_58:
      v39 += v44[4];
LABEL_59:
      v41 += v44[3] << 24;
LABEL_60:
      v41 += v44[2] << 16;
LABEL_61:
      v41 += v44[1] << 8;
LABEL_62:
      v41 += *v44;
      break;
    default:
      break;
  }
  *((_DWORD *)v36 + 22) = v36;
  v56 = (v41 - v39 - v55) ^ (v55 >> 13);
  v57 = (v39 - v55 - v56) ^ (v56 << 8);
  v58 = (v55 - v56 - v57) ^ (v57 >> 13);
  v59 = (v56 - v57 - v58) ^ (v58 >> 12);
  v60 = (v57 - v58 - v59) ^ (v59 << 16);
  v61 = (v58 - v59 - v60) ^ (v60 >> 5);
  v62 = v59 - v60 - v61;
  v63 = (v61 - (v62 ^ (v61 >> 3)) - ((v60 - v61 - (v62 ^ (v61 >> 3))) ^ ((v62 ^ (v61 >> 3)) << 10)))
      ^ (((v60 - v61 - (v62 ^ (v61 >> 3))) ^ ((v62 ^ (v61 >> 3)) << 10)) >> 15);
  *((_DWORD *)v36 + 24) = v63;
  v64 = strlen(v36);
  v65 = v301;
  *((_DWORD *)v36 + 23) = v64;
  v66 = *(_DWORD *)&v65[-1264];
  if ( v66 )
  {
    v67 = *(_DWORD *)(v66 + 68);
    *((_DWORD *)v36 + 19) = 0;
    v68 = v36 + 68;
    *((_DWORD *)v36 + 17) = v67;
    *((_DWORD *)v36 + 18) = *(_DWORD *)(*(_DWORD *)(v66 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v66 + 68) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v66 + 68) + 16) + 8) = v36;
    *(_DWORD *)(*(_DWORD *)(v66 + 68) + 16) = v36 + 68;
  }
  else
  {
    *((_DWORD *)v36 + 19) = 0;
    *((_DWORD *)v36 + 18) = 0;
    *(_DWORD *)&v65[-1264] = v36;
    v141 = malloc(0x2Cu);
    *((_DWORD *)v36 + 17) = v141;
    if ( !v141 )
      goto LABEL_184;
    memset(v141, 0, 0x2Cu);
    v68 = v36 + 68;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 16) = v36 + 68;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 4) = 32;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 8) = 5;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 20) = 68;
    v142 = (void **)*((_DWORD *)v36 + 17);
    *v142 = malloc(0x180u);
    v143 = (void *)**((_DWORD **)v36 + 17);
    if ( !v143 )
      goto LABEL_184;
    memset(v143, 0, 0x180u);
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 40) = -1609490463;
  }
  v69 = *(_DWORD *)&v301[-1264];
  ++*(_DWORD *)(*(_DWORD *)(v69 + 68) + 12);
  v70 = 12 * (v63 & (*(_DWORD *)(*(_DWORD *)(v69 + 68) + 4) - 1));
  ++*(_DWORD *)(**(_DWORD **)(v69 + 68) + v70 + 4);
  v71 = *(_DWORD *)(**(_DWORD **)(v69 + 68) + v70);
  *((_DWORD *)v36 + 20) = 0;
  *((_DWORD *)v36 + 21) = v71;
  v72 = *(_DWORD **)(v69 + 68);
  v73 = *(_DWORD *)(*v72 + v70);
  if ( v73 )
  {
    *(_DWORD *)(v73 + 12) = v68;
    v72 = *(_DWORD **)(v69 + 68);
  }
  *(_DWORD *)(*v72 + v70) = v68;
  if ( *(_DWORD *)(**(_DWORD **)(v69 + 68) + v70 + 4) < (unsigned int)(10
                                                                     * *(_DWORD *)(**(_DWORD **)(v69 + 68) + v70 + 8)
                                                                     + 10)
    || (v74 = *((_DWORD *)v36 + 17), *(_DWORD *)(v74 + 36) == 1) )
  {
LABEL_86:
    strcpy(byte_73324, v36);
    dword_767C0 = (int)&dword_767C0;
    dword_767C4 = (int)&dword_767C0;
    sub_409F8((int)&off_67FE0, (int)"Options for both config file and command line");
    sub_409F8((int)&off_68760, (int)"Options for command line only");
    sub_40ACC(&v305, v303, (void (*)(const char *, ...))sub_2AA90);
    if ( v305 != 1 )
    {
      qmemcpy(v310, "Unexpected extra commandline arguments", 38);
      v124 = aUnexpectedExtr[38];
      v125 = (char *)&v310[9] + 2;
      goto LABEL_142;
    }
    if ( !*(_BYTE *)(v304 + 0x324) )
      sub_2D8F0();
    v18 = *(_BYTE *)(v304 + 0x5A4) == 0;
    v300 = (char *)&dword_766C0;
    if ( !v18 || dword_766C0 )
    {
      v94 = sub_324B8();
      v95 = sub_229BC(0xFFu, "cgminer.c", "main", 11931);
      v96 = v300;
      v97 = v95;
      *((_DWORD *)v94 + 41) = v95;
      if ( *(_DWORD *)v96 )
        LOWORD(v98) = 16788;
      else
        LOWORD(v98) = 16800;
      HIWORD(v98) = 5;
      v99 = *v98;
      v100 = v98[1];
      v101 = *((_WORD *)v98 + 4);
      *v97 = v99;
      v97[1] = v100;
      *((_WORD *)v97 + 4) = v101;
      v102 = *((_DWORD *)v94 + 41);
      *((_DWORD *)v94 + 43) = v102;
      *((_DWORD *)v94 + 44) = v102;
      *((_DWORD *)v94 + 42) = v102;
      *((_DWORD *)v94 + 150) = v102;
      strncpy(v94 + 48, "?", 7u);
      v103 = *((_DWORD *)v94 + 25);
      v94[55] = 0;
      if ( v103 != 1 )
        sub_2B664((_DWORD *)v94 + 25);
      v104 = (char *)&unk_691B0;
      v105 = 0;
      v94[97] = 0;
      v106 = &unk_69BB0;
      byte_68BD6 = 1;
      do
      {
        v107 = v104;
        v104 += 160;
        sub_22CD8(v107, (unsigned __int8 *)&a000000029c6bf4[v105], 160);
        v108 = (unsigned __int8 *)&a00000002c01f50[v105];
        v105 += 324;
        sub_22CD8(v106, v108, 160);
        v106 += 160;
      }
      while ( v105 != 5184 );
      sub_2D950(&unk_6A950);
    }
    if ( *(_DWORD *)(v304 + 0x210) )
      sub_3FB54();
    v109 = v304;
    v110 = *(const char **)(v304 + 0x200);
    if ( v110 )
    {
      *(_BYTE *)v299 = 1;
      strcpy((char *)&dword_68AD4, v110);
      v111 = *(const char **)(v109 + 0x20C);
      if ( v111 )
        strcpy((char *)&word_68AB4, v111);
      if ( !byte_74500 )
      {
        v303 = (const char **)&byte_68BD4;
        if ( !byte_68BD4 && dword_67DB4 <= 2 )
        {
          v112 = *(const char **)(v304 + 0x208);
          if ( !v112 )
          {
LABEL_109:
            if ( dword_67DB4 <= 3 )
            {
              v113 = *(const char **)(v304 + 0x31C);
              if ( !v113 )
                goto LABEL_120;
LABEL_111:
              if ( dword_67DB4 <= 4 )
              {
                v114 = *(_DWORD *)(v304 + 0x3F0);
                if ( v114 != -1 )
                  goto LABEL_113;
LABEL_205:
                if ( !*(_BYTE *)v303 && dword_67DB4 <= 3 )
                {
                  if ( !byte_74488 )
                    goto LABEL_119;
                  goto LABEL_208;
                }
LABEL_210:
                strcpy((char *)v310, "Error in configuration file, partially loaded.");
                sub_20F58(4, (const char *)v310, 0);
                if ( !byte_74488 )
                  goto LABEL_119;
                if ( byte_74500 || *(_BYTE *)v303 )
                  goto LABEL_209;
LABEL_208:
                if ( dword_67DB4 > 3 )
                {
LABEL_209:
                  strcpy((char *)v310, "Start cgminer with -T to see what failed to load.");
                  sub_20F58(4, (const char *)v310, 0);
                }
LABEL_119:
                v115 = v304;
                free(*(void **)(v304 + 0x31C));
                *(_DWORD *)(v115 + 0x31C) = 0;
                goto LABEL_120;
              }
LABEL_112:
              snprintf((char *)v310, 0x800u, "Loaded configuration file %s", v113);
              sub_20F58(5, (const char *)v310, 0);
              v114 = *(_DWORD *)(v304 + 0x3F0);
              if ( v114 != -1 )
              {
LABEL_113:
                if ( !v114 )
                {
                  if ( (byte_74500 || *(_BYTE *)v303 || dword_67DB4 > 3)
                    && ((strcpy((char *)v310, "Fatal JSON error in configuration file."),
                         sub_20F58(4, (const char *)v310, 0),
                         byte_74500)
                     || *(_BYTE *)v303)
                    || dword_67DB4 > 3 )
                  {
                    strcpy((char *)v310, "Configuration file could not be used.");
                    sub_20F58(4, (const char *)v310, 0);
                  }
                }
                goto LABEL_119;
              }
              if ( byte_74500 )
                goto LABEL_210;
              goto LABEL_205;
            }
LABEL_178:
            snprintf((char *)v310, 0x800u, "Started %s", ::s);
            sub_20F58(4, (const char *)v310, 0);
            v113 = *(const char **)(v304 + 0x31C);
            if ( !v113 )
            {
LABEL_120:
              *(_WORD *)(*(_DWORD *)v296 + strlen(*(const char **)v296)) = *v295;
              if ( byte_73388 )
              {
                *(_BYTE *)v303 = 1;
              }
              else if ( !*(_BYTE *)v303 )
              {
                setlogmask(63);
                goto LABEL_123;
              }
              setlogmask(255);
LABEL_123:
              v116 = dword_68754;
              if ( dword_68754 < 0 )
                v116 = 60;
              LOWORD(v117) = (unsigned __int16)&unk_731F0;
              if ( dword_68754 < 0 )
                dword_68754 = v116;
              *(_DWORD *)&v301[-76] = 8;
              HIWORD(v117) = (unsigned int)&unk_731F0 >> 16;
              v299 = &dword_75598;
              dword_75598 = (int)sub_22A44(8u, 0x40u, "cgminer.c", "main", 12093);
              sub_3ECA0((int)&unk_73268);
              sub_3ECA0(v117);
              sub_3ECA0((int)&unk_73110);
              format = (char *)&dword_75588;
              sub_3ECA0((int)&unk_689C8);
              off_73274(0);
              (*(void (__fastcall **)(_DWORD))(v117 + 0xC))(0);
              ((void (__fastcall *)(_DWORD))off_7311C)(0);
              v118 = 0;
              off_689D4();
              dword_75588 = 0;
              while ( dword_755C0 > v118 )
              {
                v119 = *(pthread_rwlock_t **)(dword_7346C + 4 * v118++);
                sub_3EEE8(v119);
              }
              if ( dword_755C0 )
              {
                v120 = *(char **)(v304 + 0x3FC);
                *(_DWORD *)&v301[-1160] = dword_755C0;
                if ( v120 )
                {
                  v121 = 0;
                  v122 = 0;
                  for ( j = strtok(v120, ","); j; j = strtok(v297, ",") )
                  {
                    if ( dword_755C0 <= v121 )
                    {
                      strcpy((char *)v310, "Too many values passed to set temp cutoff");
                      sub_20F58(3, (const char *)v310, 1);
                      sub_2E6B0(1, 1);
                    }
                    v122 = strtol(j, 0, 10);
                    if ( v122 > 0xC8 )
                    {
                      v144 = "ssed to set temp cutoff";
                      qmemcpy(v310, "Invalid value pa", 16);
                      v145 = &v310[4];
                      goto LABEL_188;
                    }
                    if ( pthread_rwlock_rdlock(&stru_7680C) )
                      sub_30138("load_temp_cutoffs", 1336);
                    *(_DWORD *)(*(_DWORD *)(dword_7346C + 4 * v121) + 184) = v122;
                    if ( pthread_rwlock_unlock(&stru_7680C) )
                    {
                      v206 = _errno_location();
                      snprintf(
                        (char *)v310,
                        0x800u,
                        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                        *v206,
                        "cgminer.c",
                        "load_temp_cutoffs",
                        1338);
                      v153 = (const char *)v310;
                      goto LABEL_189;
                    }
                    ++v121;
                    v297 = 0;
                    off_67ED8();
                  }
                  if ( v121 <= 1 )
                  {
                    if ( pthread_rwlock_rdlock(&stru_7680C) )
                      sub_30138("load_temp_cutoffs", 1359);
                    v207 = dword_755C0;
                    v295 = (__int16 *)&dword_7346C;
                    v208 = dword_7346C;
                    while ( v121 < v207 )
                    {
                      v209 = *(_DWORD *)(v208 + 4 * v121++);
                      *(_DWORD *)(v209 + 184) = v122;
                    }
                    sub_2FB80(&stru_7680C, "load_temp_cutoffs", 1365);
                  }
                  else
                  {
                    v295 = (__int16 *)&dword_7346C;
                  }
                }
                else
                {
                  v156 = pthread_rwlock_rdlock(&stru_7680C);
                  if ( v156 )
                    sub_30138("load_temp_cutoffs", 1343);
                  v157 = dword_755C0;
                  v295 = (__int16 *)&dword_7346C;
                  v158 = dword_7346C;
                  while ( v156 < v157 )
                  {
                    v159 = *(_DWORD *)(v158 + 4 * v156++);
                    if ( !*(_DWORD *)(v159 + 184) )
                      *(_DWORD *)(v159 + 184) = 95;
                  }
                  sub_2FB80(&stru_7680C, "load_temp_cutoffs", 1352);
                }
                v160 = dword_755C0;
                v161 = *(_DWORD *)v295;
                for ( k = 0; v160 > k; ++k )
                {
                  v163 = *(_DWORD *)(v161 + 4 * k);
                  *(_DWORD *)(v163 + 312) = 99999999;
                }
                if ( !byte_756B0 )
                  *(_DWORD *)&v301[-644] += *(_DWORD *)&v301[-1160];
                if ( !dword_733CC )
                {
                  if ( byte_74500 || *(_BYTE *)v303 || dword_67DB4 > 3 )
                  {
                    strcpy((char *)v310, "Need to specify at least one pool server.");
                    sub_20F58(4, (const char *)v310, 0);
                  }
                  strcpy((char *)v310, "Pool setup failed");
                  sub_20F58(3, (const char *)v310, 1);
                  sub_2E6B0(1, 0);
                }
                v297 = (char *)&dword_744C8;
                v296 = "cgminer.c";
                for ( m = 0; ; ++m )
                {
                  v165 = *(_DWORD **)v297;
                  if ( dword_733CC <= m )
                    break;
                  v166 = v165[m];
                  v167 = *(_DWORD *)(v166 + 168);
                  *(_DWORD *)(v166 + 404) = 99999999;
                  *(_DWORD *)(v166 + 440) = 99999999;
                  if ( !v167 )
                  {
                    if ( !*(_DWORD *)(v166 + 176) )
                      *(_DWORD *)(v166 + 176) = calloc(1u, 1u);
                    v168 = *(const char **)(v166 + 172);
                    if ( !v168 )
                    {
                      snprintf(
                        (char *)v310,
                        0x800u,
                        "No login credentials supplied for pool %u %s",
                        m,
                        *(const char **)(v166 + 164));
                      sub_20F58(3, (const char *)v310, 1);
                      sub_2E6B0(1, 0);
                    }
                    v169 = strlen(v168);
                    v170 = v169 + strlen(*(const char **)(v166 + 176)) + 2;
                    v171 = (char *)sub_229BC(v170, v296, "main", 12203);
                    v172 = *(const char **)(v166 + 176);
                    *(_DWORD *)(v166 + 168) = v171;
                    snprintf(v171, v170, "%s:%s", *(const char **)(v166 + 172), v172);
                  }
                }
                v18 = byte_74500 == 0;
                *(_DWORD *)(v304 + 0x488) = *v165;
                if ( !v18 )
                  openlog("cgminer", 1, 8);
                v173 = (char *)v310;
                if ( *(_DWORD *)&v301[-72] )
                {
                  if ( pipe(v310) < 0 )
                  {
                    perror("pipe - failed to create pipe for --monitor");
                    exit(1);
                  }
                  fflush((FILE *)stderr);
                  if ( dup2(v310[1], 2) < 0 )
                  {
                    perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                    exit(1);
                  }
                  if ( close(v310[1]) < 0 )
                  {
                    perror("close - failed to close write end of pipe for --monitor");
                    exit(1);
                  }
                  v174 = signal(13, (__sighandler_t)1);
                  v175 = signal(13, (__sighandler_t)1);
                  v176 = (__sighandler_t)((char *)v174 + 1) == 0;
                  if ( v174 != (__sighandler_t)-1 )
                    v176 = (__sighandler_t)((char *)v175 + 1) == 0;
                  if ( v176 )
                  {
                    perror("signal - failed to edit signal mask for --monitor");
                    exit(1);
                  }
                  v177 = fork();
                  v178 = v177;
                  *(_DWORD *)(v304 + 0x424) = v177;
                  if ( v177 < 0 )
                  {
                    perror("fork - failed to fork child process for --monitor");
                    exit(1);
                  }
                  if ( !v177 )
                  {
                    if ( dup2(v310[0], v177) >= 0 )
                    {
                      close(v310[0]);
                      execl("/bin/bash", "/bin/bash", "-c", *(_DWORD *)&v301[-72], v178);
                      perror("execl - in child failed to exec user specified command for --monitor");
                      exit(1);
                    }
                    perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                    exit(1);
                  }
                  if ( close(v310[0]) < 0 )
                  {
                    perror("close - failed to close read end of pipe for --monitor");
                    exit(1);
                  }
                }
                v179 = *(_DWORD *)format;
                v293 = &dword_744A4;
                dword_744A4 = (int)sub_22A44(v179, 4u, "cgminer.c", "main", 12220);
                v296 = (const char *)&dword_755C0;
                for ( n = 0; *(_DWORD *)format > n; ++n )
                {
                  v181 = *v293;
                  *(_DWORD *)(v181 + 4 * n) = sub_22A44(1u, 0x40u, "cgminer.c", "main", 12224);
                }
                v182 = v296;
                v294 = 0;
                v296 = 0;
                v291 = &byte_68BD5;
                v292 = &byte_74500;
                v290 = &dword_733CC;
                while ( *(_DWORD *)v182 > v294 )
                {
                  v183 = 0;
                  v184 = v182;
                  v185 = v173;
                  v186 = *(const char **)(*(_DWORD *)v295 + 4 * v294);
                  v187 = sub_229BC(4 * (*((_DWORD *)v186 + 37) + 1), "cgminer.c", "main", 12233);
                  v188 = *((_DWORD *)v186 + 37);
                  *((_DWORD *)v186 + 38) = v187;
                  v187[v188] = 0;
                  *((_DWORD *)v186 + 24) = 4;
                  while ( 1 )
                  {
                    v191 = &v183[(_DWORD)v296];
                    if ( *((_DWORD *)v186 + 37) <= (int)v183 )
                      break;
                    v189 = (const char **)sub_31B04((int)&v183[(_DWORD)v296]);
                    *v189 = v191;
                    v190 = (sem_t *)v189;
                    v189[9] = v186;
                    v189[1] = v183;
                    if ( (*(int (**)(void))(*((_DWORD *)v186 + 1) + 44))() )
                    {
                      if ( sub_25164((int)v190, 0, (void *(*)(void *))sub_2B500, v190) )
                      {
                        snprintf(v185, 0x800u, "thread %d create failed", v190->__align);
                        sub_20F58(3, v185, 1);
                        sub_2E6B0(1, 0);
                      }
                      *(_DWORD *)(*((_DWORD *)v186 + 38) + 4 * (_DWORD)v183) = v190;
                      if ( *((_DWORD *)v186 + 8) != 1 )
                      {
                        if ( *v291 && (*v292 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                        {
                          snprintf(v185, 0x800u, "Pushing sem post to thread %d", v190->__align);
                          sub_20F58(7, v185, 0);
                        }
                        sub_251AC(v190 + 1, "cgminer.c", "main", 12261);
                      }
                    }
                    ++v183;
                  }
                  v192 = v185;
                  v182 = v184;
                  v173 = v192;
                  v296 = &v183[(_DWORD)v296];
                  ++v294;
                }
                v193 = (int *)v292;
                v194 = v290;
                if ( *(_BYTE *)(v304 + 0x5A4) || (v195 = *(char **)v300) != 0 )
                {
LABEL_284:
                  v196 = (int *)dbl_69088;
                  dbl_756A8 = 0.0;
                  do
                  {
                    *(_QWORD *)v196 = 0;
                    v196 += 2;
                  }
                  while ( &dword_690E8 != v196 );
                  v197 = *(_DWORD *)v182;
                  v198 = v298;
                  v199 = *(_DWORD *)v295;
                  *(_DWORD *)(v304 + 0x510) = 0;
                  while ( v197 > (int)v198 )
                  {
                    v200 = *(_DWORD *)(v199 + 4 * (_DWORD)v198++);
                    *(_QWORD *)(v200 + 80) = 0;
                    *(_QWORD *)(v200 + 48) = 0;
                  }
                  sub_239A4((struct timeval *)&dword_69020);
                  sub_239A4((struct timeval *)&dword_69018);
                  sub_239A4(&stru_6907C);
                  sub_2C610(byte_69028, 0x28u, &dword_69020);
                  v201 = *v299;
                  *(_DWORD *)(v304 + 0x480) = 2;
                  if ( sub_25164(v201 + 128, 0, (void *(*)(void *))sub_34DF4, 0) )
                  {
                    strcpy(v173, "watchpool thread create failed");
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(1, 0);
                  }
                  pthread_detach(*(_DWORD *)(v201 + 140));
                  v202 = *v299;
                  *(_DWORD *)(v304 + 0x484) = 3;
                  if ( sub_25164(v202 + 192, 0, (void *(*)(void *))sub_38D3C, 0) )
                  {
                    strcpy(v173, "watchdog thread create failed");
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(1, 0);
                  }
                  pthread_detach(*(_DWORD *)(v202 + 204));
                  v203 = *v299;
                  *(_DWORD *)(v304 + 0x3F4) = 5;
                  if ( sub_25164(v203 + 320, 0, (void *(*)(void *))sub_2C1A4, (void *)(v203 + 320)) )
                  {
                    strcpy(v173, "API thread create failed");
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(1, 0);
                  }
                  v204 = *(_DWORD *)&v301[-76];
                  if ( v204 != 8 )
                  {
                    snprintf(v173, 0x800u, "incorrect total_control_threads (%d) should be 8", v204);
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(1, 0);
                  }
                  if ( !nice(-10) && byte_68BD5 && (*(_BYTE *)v193 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                  {
                    strcpy(v173, "Unable to set thread to high priority");
                    sub_20F58(7, v173, 0);
                  }
                  v210 = v297;
                  v211 = v301;
                  v298 = &byte_767F0;
                  v299 = v193;
                  v301 = (unsigned __int8 *)&byte_755D4;
                  while ( 1 )
                  {
                    if ( *v298 )
                    {
                      if ( *(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 5 )
                      {
                        strcpy(v173, "Work update message received");
                        sub_20F58(6, v173, 0);
                      }
                      sub_239A4(&stru_68FE0);
                      v273 = pthread_rwlock_rdlock(&stru_744A8);
                      if ( v273 )
                      {
                        v284 = _errno_location();
                        snprintf(
                          v173,
                          0x800u,
                          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                          *v284,
                          "cgminer.c",
                          "signal_work_update",
                          5507);
                        goto LABEL_423;
                      }
                      v274 = *(_DWORD *)format;
                      v275 = *v293;
                      while ( v273 < v274 )
                      {
                        v276 = *(_DWORD *)(v275 + 4 * v273++);
                        *(_BYTE *)(v276 + 63) = 1;
                      }
                      if ( pthread_rwlock_unlock(&stru_744A8) )
                      {
                        v285 = _errno_location();
                        snprintf(
                          v173,
                          0x800u,
                          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                          *v285,
                          "cgminer.c",
                          "signal_work_update",
                          5514);
LABEL_423:
                        v153 = v173;
LABEL_189:
                        sub_20F58(3, v153, 1);
                        sub_2E6B0(1, 1);
                      }
                      off_67ED8();
                    }
                    v212 = *(pthread_mutex_t **)(v304 + 0x438);
                    *v298 = 0;
                    if ( pthread_mutex_lock(v212) )
                    {
                      v272 = _errno_location();
                      snprintf(
                        v173,
                        0x800u,
                        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                        *v272,
                        "cgminer.c",
                        "main",
                        12427);
                      goto LABEL_423;
                    }
                    v213 = *(_DWORD *)(v304 + 0x514);
                    if ( v213
                      && *(int *)(*(_DWORD *)(v213 + 344) + 12) > 1
                      && (v280 = v304,
                          pthread_cond_wait(&stru_744D0, *(pthread_mutex_t **)(v304 + 0x438)),
                          (v281 = *(_DWORD *)(v280 + 0x514)) != 0) )
                    {
                      v282 = *(pthread_mutex_t **)(v280 + 0x438);
                      v283 = *(_DWORD *)(*(_DWORD *)(v281 + 344) + 12);
                      if ( pthread_mutex_unlock(v282) )
                      {
LABEL_422:
                        v268 = _errno_location();
                        snprintf(
                          v173,
                          0x800u,
                          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                          *v268,
                          "cgminer.c",
                          "main",
                          12438);
                        goto LABEL_423;
                      }
                      off_67ED8();
                      if ( v283 > 1 )
                      {
                        v306 = (void **)sub_355FC(0);
                        if ( v306 )
                          sub_2CEA0(&v306, "cgminer.c", "main", 12450);
                        continue;
                      }
                    }
                    else
                    {
                      if ( pthread_mutex_unlock(*(pthread_mutex_t **)(v304 + 0x438)) )
                        goto LABEL_422;
                      off_67ED8();
                    }
                    if ( v306 )
                      sub_2CEA0(&v306, "cgminer.c", "main", 12458);
                    v297 = "Selecting pool %d for work";
                    v306 = (void **)sub_2FD8C();
                    pthread_mutex_lock(&mutex);
LABEL_349:
                    v223 = sub_31FF4();
                    v224 = (unsigned __int8 *)v223;
                    v225 = *(_DWORD *)(v304 + 0x3F8);
                    if ( v225 == 4 )
                      break;
                    if ( v225 != 3 )
                      goto LABEL_331;
                    v214 = *v194;
                    v215 = 0;
                    v216 = *(void ***)v210;
                    while ( v215 < v214 )
                    {
                      if ( *((_DWORD *)v216[v215] + 16) < *((_DWORD *)v216[v215] + 15) )
                        goto LABEL_360;
                      ++v215;
                    }
                    for ( ii = 0; v214 > ii; ++ii )
                    {
                      v227 = v216[ii];
                      v227[16] = 0;
                    }
                    v228 = *(_DWORD *)&v211[-68] + 1;
                    if ( v214 <= v228 )
                      v228 = 0;
                    *(_DWORD *)&v211[-68] = v228;
LABEL_360:
                    v229 = 0;
                    v230 = v210;
                    while ( 1 )
                    {
                      v236 = v229 + 1;
                      if ( v229 >= *v194 )
                        break;
                      v231 = *(_DWORD *)(*(_DWORD *)v230 + 4 * *(_DWORD *)&v211[-68]);
                      v232 = *(_DWORD *)(v231 + 64);
                      v233 = *(_DWORD *)(v231 + 60);
                      *(_DWORD *)(v231 + 64) = v232 + 1;
                      if ( v232 < v233 )
                      {
                        if ( !*(_BYTE *)(v231 + 97)
                          && *(_DWORD *)(v231 + 100) == 1
                          && !sub_2B684((unsigned __int8 *)v231) )
                        {
                          v210 = v230;
                          v224 = v267;
                          goto LABEL_377;
                        }
                        if ( *v301 )
                        {
                          v234 = sub_2B7BC(0);
                          --*(_DWORD *)(v234 + 64);
                        }
                      }
                      v235 = *(_DWORD *)&v211[-68] + 1;
                      v91 = v235 < *v194;
                      *(_DWORD *)&v211[-68] = v235;
                      if ( !v91 )
                        *(_DWORD *)&v211[-68] = 0;
                      v229 = v236;
                    }
                    v210 = v230;
                    for ( jj = 0; ; ++jj )
                    {
                      if ( jj >= *v194 )
                        goto LABEL_331;
                      v238 = sub_2B7BC(jj);
                      if ( !*(_BYTE *)(v238 + 97) && *(_DWORD *)(v238 + 100) == 1 && !sub_2B684((unsigned __int8 *)v238) )
                        break;
                    }
                    v224 = v239;
LABEL_377:
                    if ( !byte_68BD5 )
                      goto LABEL_378;
LABEL_332:
                    if ( *(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6 )
                    {
                      snprintf(v173, 0x800u, v297, *(_DWORD *)v224);
                      sub_20F58(7, v173, 0);
                    }
LABEL_336:
                    if ( v224[97] || *((_DWORD *)v224 + 25) != 1 )
                    {
LABEL_338:
                      sub_34178(0);
                      v217 = sub_31FF4();
                      v218 = (unsigned __int8 *)v217;
                      v219 = *(_DWORD *)(v304 + 0x3F8);
                      if ( v219 == 4 )
                      {
                        v218 = (unsigned __int8 *)sub_2B6A8(v217);
                        goto LABEL_341;
                      }
                      if ( v219 != 3 )
                        goto LABEL_341;
                      v220 = *v194;
                      v221 = 0;
                      v222 = *(void ***)v210;
                      while ( v221 < v220 )
                      {
                        if ( *((_DWORD *)v222[v221] + 16) < *((_DWORD *)v222[v221] + 15) )
                          goto LABEL_398;
                        ++v221;
                      }
                      for ( kk = 0; v220 > kk; ++kk )
                      {
                        v255 = v222[kk];
                        v255[16] = 0;
                      }
                      v256 = *(_DWORD *)&v211[-68] + 1;
                      if ( v220 <= v256 )
                        v256 = 0;
                      *(_DWORD *)&v211[-68] = v256;
LABEL_398:
                      for ( mm = 0; ; mm = v259 )
                      {
                        v259 = mm + 1;
                        if ( mm >= *v194 )
                        {
                          for ( nn = 0; nn < *v194; ++nn )
                          {
                            v265 = sub_2B7BC(nn);
                            if ( !*(_BYTE *)(v265 + 97)
                              && *(_DWORD *)(v265 + 100) == 1
                              && !sub_2B684((unsigned __int8 *)v265) )
                            {
                              goto LABEL_414;
                            }
                          }
LABEL_341:
                          if ( byte_68BD5 )
                            goto LABEL_342;
                          goto LABEL_346;
                        }
                        v260 = *(_DWORD *)(*(_DWORD *)v210 + 4 * *(_DWORD *)&v211[-68]);
                        v261 = *(_DWORD *)(v260 + 64);
                        v262 = *(_DWORD *)(v260 + 60);
                        *(_DWORD *)(v260 + 64) = v261 + 1;
                        if ( v261 < v262 )
                        {
                          if ( !*(_BYTE *)(v260 + 97)
                            && *(_DWORD *)(v260 + 100) == 1
                            && !sub_2B684((unsigned __int8 *)v260) )
                          {
LABEL_414:
                            v218 = v266;
                            if ( !byte_68BD5 )
                              goto LABEL_415;
LABEL_342:
                            if ( *(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6 )
                            {
                              snprintf(v173, 0x800u, v297, *(_DWORD *)v218);
                              sub_20F58(7, v173, 0);
                            }
LABEL_346:
                            if ( !v218[97] && *((_DWORD *)v218 + 25) == 1 )
                            {
LABEL_415:
                              if ( sub_2B684(v218) )
                                goto LABEL_348;
                            }
                            else
                            {
LABEL_348:
                              sub_23B9C();
                            }
                            goto LABEL_349;
                          }
                          if ( *v301 )
                          {
                            v263 = sub_2B7BC(0);
                            --*(_DWORD *)(v263 + 64);
                          }
                        }
                        v258 = *(_DWORD *)&v211[-68] + 1;
                        v91 = v258 < *v194;
                        *(_DWORD *)&v211[-68] = v258;
                        if ( !v91 )
                          *(_DWORD *)&v211[-68] = 0;
                      }
                    }
LABEL_378:
                    if ( sub_2B684(v224) )
                      goto LABEL_338;
                    pthread_mutex_unlock(&mutex);
                    if ( v224[640] )
                    {
                      sub_360B0((int)v224, (int)v306);
                      if ( byte_68BD5 && (*(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                      {
                        strcpy(v173, "Generated stratum work");
                        sub_20F58(7, v173, 0);
                      }
                      sub_3D93C((int)v306);
                      v306 = 0;
                      pthread_mutex_unlock(&mutex);
                    }
                    else
                    {
                      pthread_mutex_unlock(&mutex);
                      v297 = *(char **)v300;
                      if ( v297 )
                      {
                        v269 = v306;
                        v270 = (struct timeval *)(v306 + 100);
                        sub_2EA28(v306);
                        v271 = *(void ***)v210;
                        *((_BYTE *)v269 + 282) = 1;
                        v269[65] = *v271;
                        sub_239A4(v270);
                        sub_257F8(v269 + 102, v270);
                        *((_BYTE *)v269 + 440) = 66;
                        sub_2B1B0((int)v269);
                        if ( byte_68BD5 && (*(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                        {
                          v244 = "Generated benchfile work";
                          v245 = v173;
LABEL_387:
                          v246 = *(_DWORD *)v244;
                          v247 = *((_DWORD *)v244 + 1);
                          v248 = *((_DWORD *)v244 + 2);
                          v249 = *((_DWORD *)v244 + 3);
                          v250 = v244 + 16;
                          *(_DWORD *)v245 = v246;
                          *((_DWORD *)v245 + 1) = v247;
                          *((_DWORD *)v245 + 2) = v248;
                          *((_DWORD *)v245 + 3) = v249;
                          v251 = v245 + 16;
                          v252 = v250[1];
                          v253 = v250[2];
                          *v251 = *v250;
                          v251[1] = v252;
                          *((_BYTE *)v251 + 8) = v253;
                          sub_20F58(7, v173, 0);
                        }
LABEL_388:
                        sub_3D93C((int)v306);
                        v306 = 0;
                      }
                      else if ( *(_BYTE *)(v304 + 0x5A4) )
                      {
                        v240 = v306;
                        *((_QWORD *)v306 + 47) = 0x4040000000000000LL;
                        sub_254E8(v240 + 40, &unk_6A950, 0x20u, (int)"cgminer.c", (int)"get_benchmark_work", 4265);
                        v241 = v297;
                        v242 = *(void ***)v210;
                        *((_BYTE *)v240 + 282) = 1;
                        v240[61] = v241;
                        v240[65] = *v242;
                        sub_239A4((struct timeval *)v240 + 50);
                        sub_257F8(v240 + 102, v240 + 100);
                        v243 = (unsigned __int8)byte_68BD5;
                        *((_BYTE *)v240 + 440) = 66;
                        if ( v243 && (*(_BYTE *)v299 || *(_BYTE *)v303 || dword_67DB4 > 6) )
                        {
                          v244 = "Generated benchmark work";
                          v245 = v173;
                          goto LABEL_387;
                        }
                        goto LABEL_388;
                      }
                    }
                  }
                  v224 = (unsigned __int8 *)sub_2B6A8(v223);
LABEL_331:
                  if ( !byte_68BD5 )
                    goto LABEL_336;
                  goto LABEL_332;
                }
                while ( *v194 > (int)v195 )
                {
                  v205 = *(_DWORD *)(*(_DWORD *)v297 + 4 * (_DWORD)v195);
                  if ( *(_DWORD *)(v205 + 100) != 1 )
                    sub_2B664((_DWORD *)(v205 + 100));
                  ++v195;
                  *(_BYTE *)(v205 + 97) = 1;
                }
                if ( *(_BYTE *)v193 || *(_BYTE *)v303 || dword_67DB4 > 4 )
                {
                  strcpy(v173, "Probing for an alive pool");
                  sub_20F58(5, v173, 0);
                }
                v277 = 0;
                sub_2B41C();
                do
                {
                  ++v277;
                  sleep(1u);
                  if ( v277 == 180 )
                    v278 = 0;
                  else
                    v278 = (*(_BYTE *)(v304 + 0x598) ^ 1) & 1;
                }
                while ( v278 );
                v296 = v182;
                v279 = v303;
                while ( 1 )
                {
                  if ( *(_BYTE *)(v304 + 0x598) )
                  {
                    v182 = v296;
                    goto LABEL_284;
                  }
                  if ( v278 )
                    goto LABEL_456;
                  if ( ((*(_BYTE *)v193 || *(_BYTE *)v279 || dword_67DB4 > 2)
                     && ((strcpy(v173, "No servers were found that could be used to get work from."),
                          sub_20F58(3, v173, 0),
                          *(_BYTE *)v193)
                      || *(_BYTE *)v279)
                     || dword_67DB4 > 2)
                    && ((strcpy(v173, "Please check the details from the list below of the servers you have input"),
                         sub_20F58(3, v173, 0),
                         *(_BYTE *)v193)
                     || *(_BYTE *)v279)
                    || dword_67DB4 > 2 )
                  {
                    strcpy(
                      v173,
                      "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                    sub_20F58(3, v173, 0);
                  }
                  for ( i1 = 0; *v194 > i1; ++i1 )
                  {
                    if ( *(_BYTE *)v193 || *(_BYTE *)v279 || dword_67DB4 > 3 )
                    {
                      snprintf(
                        v173,
                        0x800u,
                        "Pool: %d  URL: %s  User: %s  Password: %s",
                        i1,
                        *(const char **)(*(_DWORD *)(*(_DWORD *)v297 + 4 * i1) + 164),
                        *(const char **)(*(_DWORD *)(*(_DWORD *)v297 + 4 * i1) + 172),
                        *(const char **)(*(_DWORD *)(*(_DWORD *)v297 + 4 * i1) + 176));
                      sub_20F58(4, v173, 0);
                    }
                  }
                  if ( !byte_74488 )
                  {
LABEL_473:
                    strcpy(v173, "No servers could be used! Exiting.");
                    sub_20F58(3, v173, 1);
                    sub_2E6B0(0, 0);
                  }
                  if ( *(_BYTE *)v193 || *(_BYTE *)v279 || dword_67DB4 > 2 )
                    break;
LABEL_457:
                  v278 = 1;
                }
                strcpy(v173, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
                sub_20F58(3, v173, 0);
LABEL_456:
                if ( !byte_74488 )
                  goto LABEL_473;
                goto LABEL_457;
              }
              qmemcpy(v310, "All devices disabled, cannot mint!", 34);
              v124 = aAllDevicesDisa[34];
              v125 = (char *)&v310[8] + 2;
LABEL_142:
              *v125 = v124;
              sub_20F58(3, (const char *)v310, 1);
              sub_2E6B0(1, 0);
            }
            if ( byte_74500 || *(_BYTE *)v303 )
              goto LABEL_112;
            goto LABEL_111;
          }
          goto LABEL_146;
        }
      }
      snprintf((char *)v310, 0x800u, "Log file path: %s Open flag: %s", (const char *)&dword_68AD4, v297);
      sub_20F58(3, (const char *)v310, 0);
    }
    v112 = *(const char **)(v304 + 0x208);
    if ( !v112 )
    {
      v303 = (const char **)&byte_68BD4;
      goto LABEL_176;
    }
LABEL_146:
    memset(v309, 0, sizeof(v309));
    v126 = *(const char **)(v304 + 0x204);
    if ( v126 )
    {
      if ( !*v126 )
      {
        v144 = "Log work asic num empty";
        v145 = v310;
LABEL_188:
        v146 = *(_DWORD *)v144;
        v147 = *((_DWORD *)v144 + 1);
        v148 = *((_DWORD *)v144 + 2);
        v149 = *((_DWORD *)v144 + 3);
        v150 = v144 + 16;
        *v145 = v146;
        v145[1] = v147;
        v145[2] = v148;
        v145[3] = v149;
        v151 = v145 + 4;
        v152 = v150[1];
        *v151 = *v150;
        v151[1] = v152;
        v153 = (const char *)v310;
        goto LABEL_189;
      }
      v127 = strtol(v126, 0, 10);
      v128 = v127 == 1;
      if ( v127 != 1 )
        v128 = ((v127 - 32) & 0xFFFFFFDF) == 0;
      *(_DWORD *)&v301[-608] = v127;
      if ( !v128 )
      {
        strcpy((char *)v310, "Log work asic num must be 1, 32, 64");
        sub_20F58(3, (const char *)v310, 1);
        sub_2E6B0(1, 1);
      }
      v303 = (const char **)&byte_68BD4;
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf(
          (char *)v310,
          0x800u,
          "Log work path: %s Asic num: %s",
          *(const char **)(v304 + 0x208),
          *(const char **)(v304 + 0x204));
        sub_20F58(3, (const char *)v310, 0);
      }
    }
    else
    {
      v303 = (const char **)&byte_68BD4;
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf((char *)v310, 0x800u, "Log work path: %s", v112);
        sub_20F58(3, (const char *)v310, 0);
      }
    }
    sprintf(v309, "%s.txt", *(const char **)(v304 + 0x208));
    v129 = fopen64(v309, &word_5406C);
    v130 = (unsigned __int8)byte_74500;
    *(_DWORD *)&v301[-604] = v129;
    if ( v130 || *(_BYTE *)v303 || dword_67DB4 > 2 )
    {
      snprintf((char *)v310, 0x800u, "Log work open file %s", v309);
      sub_20F58(3, (const char *)v310, 0);
    }
    v131 = *(_DWORD *)&v301[-608];
    if ( v131 == 1 )
    {
      sprintf(v309, "%s%02d.txt", *(const char **)(v304 + 0x208), 1);
      v154 = fopen64(v309, &word_5406C);
      v155 = (unsigned __int8)byte_74500;
      *(_DWORD *)&v301[-600] = v154;
      if ( v155 || *(_BYTE *)v303 || dword_67DB4 > 2 )
      {
        snprintf((char *)v310, 0x800u, "Log work open asic %d file %s", *(_DWORD *)&v301[-608], v309);
        sub_20F58(3, (const char *)v310, 0);
      }
    }
    else if ( ((v131 - 32) & 0xFFFFFFDF) == 0 )
    {
      format = (char *)&word_5406C;
      v132 = 0;
      v133 = v301;
      while ( 1 )
      {
        v136 = *(_DWORD *)&v133[-608];
        if ( v136 < v132 )
          break;
        sprintf(v309, "%s%02d_%02d.txt", *(const char **)(v304 + 0x208), v136, v132);
        v134 = fopen64(v309, format);
        v135 = (unsigned __int8)byte_74500;
        dword_6A978[v132] = v134;
        if ( v135 || *(_BYTE *)v303 || dword_67DB4 > 2 )
        {
          snprintf((char *)v310, 0x800u, "Log work open asic %d file %s", *(_DWORD *)&v133[-608], v309);
          sub_20F58(3, (const char *)v310, 0);
        }
        ++v132;
      }
    }
    if ( v301[-340] )
    {
      v137 = &byte_6AA7C;
      v138 = 0;
      format = "Log work open diff file %s";
      do
      {
        sprintf(v309, "%s_diff_%02d.txt", *(const char **)(v304 + 0x208), v138);
        v139 = fopen64(v309, &word_5406C);
        v140 = (unsigned __int8)byte_74500;
        *((_DWORD *)v137 + 1) = v139;
        v137 += 4;
        if ( v140 || *(_BYTE *)v303 || dword_67DB4 > 2 )
        {
          snprintf((char *)v310, 0x800u, format, v309);
          sub_20F58(3, (const char *)v310, 0);
        }
        ++v138;
      }
      while ( v138 != 65 );
    }
LABEL_176:
    if ( byte_74500 || *(_BYTE *)v303 )
      goto LABEL_178;
    goto LABEL_109;
  }
  v75 = calloc(24 * *(_DWORD *)(v74 + 4), 1u);
  if ( v75 )
  {
    v76 = *((_DWORD *)v36 + 17);
    v77 = v36;
    v300 = 0;
    *(_DWORD *)(v76 + 24) = (((2 * *(_DWORD *)(v76 + 4) - 1) & *(_DWORD *)(v76 + 12)) != 0)
                          + (*(_DWORD *)(v76 + 12) >> (*(_BYTE *)(v76 + 8) + 1));
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 28) = 0;
    v78 = (__int64 *)*((_DWORD *)v36 + 17);
    while ( 1 )
    {
      v79 = *v78;
      if ( *((_DWORD *)v78 + 1) <= (unsigned int)v300 )
        break;
      v80 = *(_DWORD **)(v79 + 12 * (_DWORD)v300);
      if ( v80 )
      {
        do
        {
          v81 = (_DWORD *)v80[4];
          v82 = 3 * ((2 * *((_DWORD *)v78 + 1) - 1) & v80[7]);
          v83 = (char *)&v75[3 * ((2 * *((_DWORD *)v78 + 1) - 1) & v80[7])];
          v84 = *((_DWORD *)v83 + 1) + 1;
          *((_DWORD *)v83 + 1) = v84;
          v85 = *((_DWORD *)v77 + 17);
          if ( v84 > *(_DWORD *)(v85 + 24) )
          {
            v86 = *(_DWORD *)(v85 + 28);
            format = v83;
            *(_DWORD *)(v85 + 28) = v86 + 1;
            *((_DWORD *)format + 2) = *((_DWORD *)v83 + 1) / *(_DWORD *)(*((_DWORD *)v77 + 17) + 24);
          }
          v80[3] = 0;
          v80[4] = v75[v82];
          v87 = v75[v82];
          if ( v87 )
            *(_DWORD *)(v87 + 12) = v80;
          v75[v82] = v80;
          v80 = v81;
          v78 = (__int64 *)*((_DWORD *)v77 + 17);
        }
        while ( v81 );
      }
      ++v300;
    }
    free((void *)v79);
    v36 = v77;
    *(_DWORD *)(*((_DWORD *)v77 + 17) + 4) *= 2;
    ++*(_DWORD *)(*((_DWORD *)v77 + 17) + 8);
    **((_DWORD **)v77 + 17) = v75;
    v88 = (_DWORD *)*((_DWORD *)v77 + 17);
    v89 = v88[7];
    v90 = v88[3];
    v91 = v89 > v90 >> 1;
    if ( v89 <= v90 >> 1 )
      v92 = 0;
    else
      v92 = v88[8];
    if ( v91 )
      ++v92;
    v88[8] = v92;
    v93 = *((_DWORD *)v77 + 17);
    if ( *(_DWORD *)(v93 + 32) > 1u )
      *(_DWORD *)(v93 + 36) = 1;
    goto LABEL_86;
  }
LABEL_184:
  exit(-1);
}
// 12F00: control flows out of bounds to 12F04
// 12A60: variable 'v16' is possibly undefined
// 12A60: variable 'v17' is possibly undefined
// 14FFC: variable 'v239' is possibly undefined
// 15288: variable 'v266' is possibly undefined
// 152D0: variable 'v267' is possibly undefined
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 2C1A4: using guessed type int sub_2C1A4();
// 51DD8: using guessed type __int16 word_51DD8;
// 5406C: using guessed type __int16 word_5406C;
// 55AAC: using guessed type __int16 word_55AAC;
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 67FE0: using guessed type char *off_67FE0;
// 68754: using guessed type int dword_68754;
// 68760: using guessed type char *off_68760;
// 689D4: using guessed type int (*off_689D4)();
// 68A68: using guessed type int stderr;
// 68AAC: using guessed type char byte_68AAC;
// 68AB4: using guessed type __int16 word_68AB4;
// 68AB6: using guessed type char byte_68AB6;
// 68AD4: using guessed type int dword_68AD4;
// 68ADC: using guessed type int dword_68ADC;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 68BD6: using guessed type char byte_68BD6;
// 68FE0: using guessed type struct timeval stru_68FE0;
// 69018: using guessed type int dword_69018;
// 69020: using guessed type int dword_69020;
// 6907C: using guessed type struct timeval stru_6907C;
// 69088: using guessed type double dbl_69088[12];
// 690E8: using guessed type int dword_690E8;
// 6A978: using guessed type int dword_6A978[65];
// 6AA7C: using guessed type char byte_6AA7C;
// 6ABD0: using guessed type unsigned __int8 byte_6ABD0[248];
// 7311C: using guessed type _UNKNOWN *off_7311C;
// 73274: using guessed type int (__fastcall *off_73274)(_DWORD);
// 73388: using guessed type char byte_73388;
// 733CC: using guessed type int dword_733CC;
// 733D0: using guessed type struct sigaction stru_733D0;
// 7346C: using guessed type int dword_7346C;
// 74488: using guessed type char byte_74488;
// 744A4: using guessed type int dword_744A4;
// 744A8: using guessed type pthread_rwlock_t stru_744A8;
// 744C8: using guessed type int dword_744C8;
// 744D0: using guessed type pthread_cond_t stru_744D0;
// 74500: using guessed type char byte_74500;
// 74504: using guessed type pthread_mutex_t stru_74504;
// 7453C: using guessed type pthread_mutex_t stru_7453C;
// 7557C: using guessed type int dword_7557C;
// 75588: using guessed type int dword_75588;
// 75598: using guessed type int dword_75598;
// 755A0: using guessed type pthread_rwlock_t stru_755A0;
// 755C0: using guessed type int dword_755C0;
// 755C4: using guessed type int dword_755C4;
// 755D4: using guessed type char byte_755D4;
// 755E0: using guessed type int dword_755E0;
// 755F8: using guessed type struct sigaction stru_755F8;
// 756A8: using guessed type double dbl_756A8;
// 756B0: using guessed type char byte_756B0;
// 766C0: using guessed type int dword_766C0;
// 766C4: using guessed type pthread_mutex_t stru_766C4;
// 766E4: using guessed type pthread_mutex_t stru_766E4;
// 76700: using guessed type pthread_cond_t stru_76700;
// 76730: using guessed type struct sigaction stru_76730;
// 767C0: using guessed type int dword_767C0;
// 767C4: using guessed type int dword_767C4;
// 767C8: using guessed type pthread_mutex_t stru_767C8;
// 767F0: using guessed type char byte_767F0;
// 767F4: using guessed type pthread_mutex_t stru_767F4;
// 7680C: using guessed type pthread_rwlock_t stru_7680C;
// 76838: using guessed type pthread_mutex_t stru_76838;

//----- (00015A40) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_10,
    a1,
    va);
  abort();
}
// 15A4A: positive sp value 4 has been found
// 15A5C: variable 'v4' is possibly undefined
// 4A330: using guessed type int init();
// 4A36C: using guessed type int nullsub_10();

//----- (00015A70) --------------------------------------------------------
int sub_15A70()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 121FC: using guessed type int _gmon_start__(void);

//----- (00015A94) --------------------------------------------------------
int deregister_tm_clones()
{
  return 428644;
}

//----- (00015AB8) --------------------------------------------------------
int register_tm_clones()
{
  return 428644;
}

//----- (00015AE4) --------------------------------------------------------
int sub_15AE4()
{
  int result; // r0

  if ( !byte_68A78 )
  {
    result = deregister_tm_clones();
    byte_68A78 = 1;
  }
  return result;
}
// 68A78: using guessed type char byte_68A78;

//----- (00015B00) --------------------------------------------------------
int __fastcall sub_15B00(unsigned int *a1, char *s)
{
  size_t v4; // r7
  _BYTE *v5; // r0
  char *v6; // r2
  unsigned int v7; // r1
  int v8; // r8
  unsigned int v9; // r3
  size_t v10; // r5
  char *v11; // r0

  v4 = strlen(s);
  v5 = (_BYTE *)a1[1];
  v6 = (char *)a1[2];
  v7 = *a1;
  v8 = v6 - v5;
  v9 = v6 - v5 + 12 + v4;
  if ( *a1 < v9 )
  {
    v10 = v7 + 0x20000;
    if ( v9 > v7 + 0x20000 )
      v10 = ((unsigned int)vcvts_n_f32_u32(v9, 0x10u) + 2) << 16;
    v11 = (char *)realloc(v5, v10);
    v6 = &v11[v8];
    *a1 = v10;
    a1[1] = (unsigned int)v11;
    a1[2] = (unsigned int)&v11[v8];
  }
  memcpy(v6, s, v4 + 1);
  a1[2] += v4;
  return 1;
}

//----- (00015B94) --------------------------------------------------------
int __fastcall sub_15B94(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // r12
  char *v5; // r1
  int result; // r0

  v4 = *(_BYTE **)(a1 + 4);
  if ( a4 )
  {
    LOBYTE(a4) = 0;
    LOWORD(v5) = -23488;
  }
  else
  {
    LOWORD(v5) = -23472;
  }
  HIWORD(v5) = 4;
  *(_DWORD *)(a1 + 8) = v4;
  *v4 = a4;
  *(_BYTE *)(a1 + 13) = a4;
  result = sub_15B00((unsigned int *)a1, v5);
  byte_68A7C = 1;
  byte_68A7D = 1;
  return result;
}
// 68A7C: using guessed type char byte_68A7C;
// 68A7D: using guessed type char byte_68A7D;

//----- (00015BE0) --------------------------------------------------------
int __fastcall sub_15BE0(int a1, int a2, int a3, int a4)
{
  _BYTE *v4; // r12
  char *v5; // r1
  int result; // r0

  v4 = *(_BYTE **)(a1 + 4);
  if ( a4 )
  {
    LOBYTE(a4) = 0;
    LOWORD(v5) = -23468;
  }
  else
  {
    LOWORD(v5) = -23448;
  }
  HIWORD(v5) = 4;
  *(_DWORD *)(a1 + 8) = v4;
  *v4 = a4;
  *(_BYTE *)(a1 + 13) = a4;
  result = sub_15B00((unsigned int *)a1, v5);
  byte_68A7C = 1;
  byte_68A7E = 1;
  return result;
}
// 68A7C: using guessed type char byte_68A7C;
// 68A7E: using guessed type char byte_68A7E;

//----- (00015C2C) --------------------------------------------------------
const char *__fastcall sub_15C2C(const char *s, int a2)
{
  const char *v2; // r5
  unsigned int v3; // r4
  const char *v5; // r2
  unsigned int v6; // r3
  int v7; // r6
  unsigned int v8; // t1
  unsigned int v9; // t1
  size_t v10; // r6
  char *v11; // r3
  char *v12; // r2
  char *v13; // r1
  unsigned int v14; // t1
  char *v15; // r2
  char *v16; // r1
  char sa[2048]; // [sp+10h] [bp-800h] BYREF

  v2 = s;
  v3 = *(unsigned __int8 *)s;
  if ( *s )
  {
    v5 = s;
    v6 = *(unsigned __int8 *)s;
    v7 = 0;
    while ( 1 )
    {
      if ( v6 == 61 )
        goto LABEL_11;
      if ( v6 <= 0x3D )
      {
        if ( v6 != 34 )
        {
          if ( v6 != 44 )
            goto LABEL_6;
          if ( a2 )
            goto LABEL_12;
LABEL_5:
          ++v7;
          goto LABEL_6;
        }
        if ( a2 )
          goto LABEL_5;
LABEL_6:
        v8 = *(unsigned __int8 *)++v5;
        v6 = v8;
        if ( !v8 )
          goto LABEL_13;
      }
      else
      {
        if ( v6 == 92 )
          goto LABEL_5;
        if ( v6 != 124 )
          goto LABEL_6;
LABEL_11:
        if ( !a2 )
          goto LABEL_5;
LABEL_12:
        v9 = *(unsigned __int8 *)++v5;
        v6 = v9;
        if ( !v9 )
        {
LABEL_13:
          if ( !v7 )
            return s;
          v10 = strlen(s) + v7 + 1;
          s = (const char *)malloc(v10);
          if ( !s )
          {
            snprintf(sa, 0x800u, "Failed to malloc escape buf %d in %s %s():%d", v10, "api.c", "escape_string", 836);
            sub_20F58(3, sa, 1);
            sub_3EBA0(1);
          }
          v11 = (char *)s;
          while ( 2 )
          {
            if ( !v3 )
            {
              *v11 = 0;
              return s;
            }
            if ( v3 != 61 )
            {
              if ( v3 <= 0x3D )
              {
                if ( v3 == 34 )
                {
                  v12 = v11 + 1;
                  if ( a2 )
                  {
                    v13 = v11++;
                    *v13 = 92;
                    v12 = v13 + 2;
                  }
                  *v11 = 34;
                  v11 = v12;
                  goto LABEL_24;
                }
                if ( v3 != 44 )
                  goto LABEL_35;
              }
              else
              {
                if ( v3 == 92 )
                {
                  *v11 = 92;
                  v11[1] = 92;
                  v11 += 2;
LABEL_24:
                  v14 = *(unsigned __int8 *)++v2;
                  v3 = v14;
                  continue;
                }
                if ( v3 != 124 )
                {
LABEL_35:
                  *v11++ = v3;
                  goto LABEL_24;
                }
              }
            }
            break;
          }
          v15 = v11 + 1;
          if ( !a2 )
          {
            v16 = v11++;
            *v16 = 92;
            v15 = v16 + 2;
          }
          *v11 = v3;
          v11 = v15;
          goto LABEL_24;
        }
      }
    }
  }
  return s;
}

//----- (00015E00) --------------------------------------------------------
void sub_15E00()
{
  JUMPOUT(0x15CF0);
}
// 15E04: control flows out of bounds to 15CF0

//----- (00015E08) --------------------------------------------------------
void __fastcall sub_15E08(unsigned int *a1, char *s, int a3, _BYTE *a4)
{
  char *v6; // r5

  if ( *a4 )
  {
    if ( !a3 )
    {
      *a4 = 0;
      goto LABEL_5;
    }
    sub_15B00(a1, "{");
    *a4 = 0;
    v6 = (char *)sub_15C2C(s, 1);
  }
  else
  {
    if ( !a3 )
    {
LABEL_5:
      v6 = (char *)sub_15C2C(s, a3);
      sub_15B00(a1, "CMD=");
      sub_15B00(a1, v6);
      sub_15B00(a1, "|");
      if ( s == v6 )
        return;
      goto LABEL_6;
    }
    sub_15B00(a1, ",");
    v6 = (char *)sub_15C2C(s, 1);
  }
  sub_15B00(a1, "\"");
  sub_15B00(a1, v6);
  sub_15B00(a1, "\":[");
  if ( s != v6 )
LABEL_6:
    free(v6);
}

//----- (00015F14) --------------------------------------------------------
void sub_15F14()
{
  char v0[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    snprintf(v0, 0x800u, "<<<<<<<<<<<<<<<<<<<<exec %s start>>>>>>>>>>>>>>>>", "pool_change");
    sub_20F58(5, v0, 0);
  }
  sub_3FE74();
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    snprintf(v0, 0x800u, "<<<<<<<<<<<<<<<<<<<<exec %s end>>>>>>>>>>>>>>>>>>", "pool_change");
    sub_20F58(5, v0, 0);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00015FF8) --------------------------------------------------------
bool __fastcall sub_15FF8(const struct sockaddr *a1, const char **a2, _BYTE *a3)
{
  char *v6; // r0
  int v7; // r7
  int v8; // r6
  unsigned __int8 *v9; // r0
  int v10; // r2
  int v11; // r1
  int v12; // r3
  int v13; // t1
  int v14; // lr
  int v15; // t1
  int v16; // t1
  int v18; // r5
  _DWORD buf[4]; // [sp+10h] [bp-34h] BYREF
  char s[36]; // [sp+20h] [bp-24h] BYREF

  v6 = (char *)malloc(0x2Eu);
  *a2 = v6;
  getnameinfo(a1, 0x80u, v6, 0x2Eu, 0, 0, 1u);
  if ( a1->sa_family == 2 )
  {
    sprintf(s, "::ffff:%s", *a2);
    inet_pton(10, s, buf);
  }
  else
  {
    inet_pton(10, *a2, buf);
  }
  *a3 = (*_ctype_toupper_loc())[82];
  if ( dword_6ACC8 )
  {
    if ( dword_68A84 > 0 )
    {
      v7 = 0;
      v8 = dword_68A80 + 15;
      while ( 2 )
      {
        v9 = (unsigned __int8 *)buf;
        v10 = v8 - 16;
        v11 = v8;
        while ( 1 )
        {
          v13 = *v9++;
          v12 = v13;
          v15 = *(unsigned __int8 *)++v11;
          v14 = v15;
          v16 = *(unsigned __int8 *)++v10;
          if ( v16 != (v12 & v14) )
            break;
          if ( v10 == v8 )
          {
            v18 = 1;
            *a3 = *(_BYTE *)(v8 + 17);
            return v18;
          }
        }
        ++v7;
        v8 += 36;
        if ( v7 != dword_68A84 )
          continue;
        break;
      }
    }
    return 0;
  }
  else
  {
    v18 = (unsigned __int8)byte_767BC;
    if ( !byte_767BC )
    {
      if ( !strcmp(*a2, "127.0.0.1") )
      {
        return 1;
      }
      else if ( !buf[0] && !buf[1] && !buf[2] )
      {
        return buf[3] == 0x1000000;
      }
    }
    return v18;
  }
}
// 68A80: using guessed type int dword_68A80;
// 68A84: using guessed type int dword_68A84;
// 6ACC8: using guessed type int dword_6ACC8;
// 767BC: using guessed type char byte_767BC;

//----- (000161A0) --------------------------------------------------------
int sub_161A0()
{
  struct addrinfo *v0; // r5
  struct addrinfo *i; // r3
  int v2; // r0
  int v3; // r11
  int *v4; // r0
  char *v5; // r0
  time_t v7; // r9
  int *v8; // r0
  char *v9; // r8
  int ai_family; // r3
  struct sockaddr *ai_addr; // r3
  int v12; // t1
  int v13; // r1
  int v14; // r2
  int v15; // r3
  size_t v16; // r0
  size_t v17; // r10
  int v18; // r6
  ssize_t v19; // r5
  _BOOL4 v20; // r10
  const char *v21; // r1
  socklen_t v22; // r1
  const char *v23; // r5
  int v24; // r0
  int *v25; // r0
  char *v26; // r0
  struct addrinfo *v27; // r5
  struct addrinfo *j; // r3
  int v29; // r0
  size_t v30; // r0
  ssize_t v31; // r5
  int *v32; // r0
  char *v33; // r0
  int *v34; // r0
  char *v35; // r0
  const char *v36; // [sp+10h] [bp-88h]
  size_t n; // [sp+18h] [bp-80h]
  char *v38; // [sp+20h] [bp-78h]
  int fd; // [sp+24h] [bp-74h]
  char v40; // [sp+43h] [bp-55h] BYREF
  socklen_t addr_len; // [sp+44h] [bp-54h] BYREF
  const char *v42; // [sp+48h] [bp-50h] BYREF
  struct addrinfo *pai; // [sp+4Ch] [bp-4Ch] BYREF
  int optval; // [sp+50h] [bp-48h] BYREF
  char v45[12]; // [sp+54h] [bp-44h] BYREF
  char s[12]; // [sp+60h] [bp-38h] BYREF
  char serv[12]; // [sp+6Ch] [bp-2Ch] BYREF
  addrinfo req; // [sp+78h] [bp-20h] BYREF
  struct sockaddr v49[8]; // [sp+98h] [bp+0h] BYREF
  char v50[1016]; // [sp+118h] [bp+80h] BYREF
  int v51; // [sp+518h] [bp+480h] BYREF
  int v52; // [sp+51Ch] [bp+484h]
  int v53; // [sp+520h] [bp+488h]
  int v54; // [sp+524h] [bp+48Ch]
  int v55; // [sp+528h] [bp+490h]
  char v56[2052]; // [sp+918h] [bp+880h] BYREF

  strcpy(v45, "bmminer-");
  sprintf(s, "%d", dword_68804);
  memset(&req, 0, sizeof(req));
  if ( getaddrinfo(off_68810[0], s, &req, &pai) )
  {
    strcpy(v56, "Invalid API Multicast Address");
    sub_20F58(3, v56, 1);
    sub_3EBA0(1);
  }
  v0 = pai;
  if ( !pai )
  {
LABEL_17:
    freeaddrinfo(pai);
    strcpy(v56, "API mcast could not open socket");
    sub_20F58(3, v56, 1);
    sub_3EBA0(1);
  }
  for ( i = pai; ; i = pai )
  {
    v2 = socket(i->ai_family, 2, 0);
    if ( v2 > 0 )
    {
      v3 = v2;
      goto LABEL_9;
    }
    v0 = v0->ai_next;
    if ( !v0 )
      break;
  }
  v3 = v2;
  if ( v2 == -1 )
    goto LABEL_17;
LABEL_9:
  optval = 1;
  if ( setsockopt(v3, 1, 2, &optval, 4u) < 0 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      snprintf(
        v56,
        0x800u,
        "API mcast setsockopt SO_REUSEADDR failed (%s)%s",
        v5,
        " - API multicast listener will not be available");
      goto LABEL_14;
    }
    return close(v3);
  }
  v7 = time(0);
  while ( 1 )
  {
    if ( bind(v3, v0->ai_addr, v0->ai_addrlen) >= 0 )
    {
      ai_family = v0->ai_family;
      if ( ai_family == 2 )
      {
        v51 = 0;
        v52 = 0;
        v51 = *(_DWORD *)&v0->ai_addr->sa_data[2];
        if ( setsockopt(v3, 0, 35, &v51, 8u) >= 0 )
        {
LABEL_25:
          freeaddrinfo(pai);
          v36 = off_6880C[0];
          v16 = strlen(off_6880C[0]);
          v17 = v16 + 10;
          n = v16 + 9;
          v38 = (char *)malloc(v16 + 10);
          if ( !v38 )
          {
            strcpy(v56, "Failed to malloc mcast expect_code");
            sub_20F58(3, v56, 1);
            sub_3EBA0(1);
          }
          fd = -1;
          v18 = 0;
          snprintf(v38, v17, "%s%s-", v45, v36);
          while ( 1 )
          {
            do
            {
              while ( 1 )
              {
                ++v18;
                sub_23B9C();
                addr_len = 128;
                v19 = recvfrom(v3, v50, 0x3FFu, 0, v49, &addr_len);
                if ( v19 >= 0 )
                  break;
                if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                {
                  v25 = _errno_location();
                  v26 = strerror(*v25);
                  snprintf(v56, 0x800u, "API mcast failed count=%d (%s) (%d)", v18, v26, v3);
                  sub_20F58(7, v56, 0);
                }
              }
              v20 = sub_15FF8(v49, &v42, &v40);
              if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
              {
                v21 = "Ignored";
                if ( v20 )
                  v21 = "Accepted";
                snprintf(v56, 0x800u, "API mcast from %s - %s", v42, v21);
                sub_20F58(7, v56, 0);
              }
            }
            while ( !v20 );
            v50[v19] = 0;
            v22 = addr_len;
            if ( v19 )
            {
              if ( v50[v19 - 1] == 10 )
                v50[--v19] = 0;
              getnameinfo(v49, v22, 0, 0, serv, 0xAu, 1u);
              if ( byte_68BD5 )
              {
LABEL_58:
                if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
                {
                  snprintf(v56, 0x800u, "API mcast request rep=%d (%s) from [%s]:%s", v19, v50, v42, serv);
                  sub_20F58(7, v56, 0);
                }
                if ( n < v19 && !memcmp(v50, v38, n) )
                  goto LABEL_42;
                if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                {
                  strcpy(v56, "API mcast request was no good");
                  sub_20F58(7, v56, 0);
                }
              }
              else if ( n < v19 && !memcmp(v50, v38, n) )
              {
LABEL_42:
                v23 = &v50[n];
                v24 = strtol(&v50[n], 0, 10);
                if ( (unsigned int)(v24 - 1) <= 0xFFFE )
                {
                  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                  {
                    snprintf(v56, 0x800u, "API mcast request OK port %s=%d", v23, v24);
                    sub_20F58(7, v56, 0);
                  }
                  if ( getaddrinfo(v42, v23, &req, &pai) )
                  {
                    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
                    {
                      snprintf(v56, 0x800u, "Invalid client address %s", v42);
                      goto LABEL_79;
                    }
                  }
                  else
                  {
                    v27 = pai;
                    if ( pai )
                    {
                      for ( j = pai; ; j = pai )
                      {
                        v29 = socket(j->ai_family, 2, 0);
                        if ( v3 > 0 )
                          break;
                        v27 = v27->ai_next;
                        if ( !v27 )
                          break;
                      }
                      fd = v29;
                    }
                    if ( fd == -1 )
                    {
                      freeaddrinfo(pai);
                      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
                      {
                        snprintf(v56, 0x800u, "API mcast could not open socket to client %s", v42);
LABEL_79:
                        sub_20F58(3, v56, 0);
                      }
                    }
                    else
                    {
                      snprintf((char *)&v51, 0x400u, "cgm-FTW-%d-%s", dword_68818, off_68808);
                      v30 = strlen((const char *)&v51);
                      v31 = sendto(fd, &v51, v30 + 1, 0, v27->ai_addr, v27->ai_addrlen);
                      freeaddrinfo(pai);
                      if ( v31 < 0 )
                      {
                        if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                        {
                          v32 = _errno_location();
                          v33 = strerror(*v32);
                          snprintf(v56, 0x800u, "API mcast send reply failed (%s) (%d)", v33, fd);
                          sub_20F58(7, v56, 0);
                        }
                      }
                      else if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                      {
                        snprintf(v56, 0x800u, "API mcast send reply (%s) succeeded (%d) (%d)", &v51, v31, fd);
                        sub_20F58(7, v56, 0);
                      }
                      close(fd);
                    }
                  }
                }
                else if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                {
                  snprintf(v56, 0x800u, "API mcast request ignored - invalid port (%s)", v23);
                  sub_20F58(7, v56, 0);
                }
              }
            }
            else
            {
              getnameinfo(v49, addr_len, 0, 0, serv, 0xAu, 1u);
              if ( byte_68BD5 )
                goto LABEL_58;
            }
          }
        }
        if ( !byte_74500 && !byte_68BD4 )
          goto LABEL_110;
      }
      else
      {
        if ( ai_family != 10 )
          goto LABEL_25;
        ai_addr = v0->ai_addr;
        v12 = *(_DWORD *)&ai_addr->sa_data[6];
        ai_addr = (struct sockaddr *)((char *)ai_addr + 8);
        v13 = *(_DWORD *)&ai_addr->sa_data[2];
        v14 = *(_DWORD *)&ai_addr->sa_data[6];
        v15 = *(_DWORD *)&ai_addr->sa_data[10];
        v51 = v12;
        v52 = v13;
        v53 = v14;
        v54 = v15;
        v55 = 0;
        if ( setsockopt(v3, 41, 20, &v51, 0x14u) >= 0 )
          goto LABEL_25;
        if ( !byte_74500 && !byte_68BD4 )
        {
LABEL_110:
          if ( dword_67DB4 <= 2 )
            return close(v3);
        }
      }
      v34 = _errno_location();
      v35 = strerror(*v34);
      snprintf(v56, 0x800u, "API mcast join failed (%s)%s", v35, " - API multicast listener will not be available");
LABEL_14:
      sub_20F58(3, v56, 0);
      return close(v3);
    }
    v8 = _errno_location();
    v9 = strerror(*v8);
    if ( time(0) - v7 > 61 )
      break;
    sub_23B9C();
  }
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    snprintf(
      v56,
      0x800u,
      "API mcast bind to port %d failed (%s)%s",
      dword_68804,
      v9,
      " - API multicast listener will not be available");
    goto LABEL_14;
  }
  return close(v3);
}
// 67DB4: using guessed type int dword_67DB4;
// 68804: using guessed type int dword_68804;
// 68808: using guessed type _UNKNOWN *off_68808;
// 6880C: using guessed type char *off_6880C[3];
// 68810: using guessed type char *off_68810[2];
// 68818: using guessed type int dword_68818;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (00016D58) --------------------------------------------------------
void sub_16D58()
{
  JUMPOUT(0x164C8);
}
// 16D5C: control flows out of bounds to 164C8

//----- (00016D60) --------------------------------------------------------
int __fastcall sub_16D60(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_250A8("APIMcast");
  sub_161A0();
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}

//----- (00016D98) --------------------------------------------------------
int __fastcall sub_16D98(int result, int a2)
{
  int v2; // r4

  v2 = result;
  if ( !*(_BYTE *)(result + 13) )
  {
    if ( !a2 )
      return result;
    goto LABEL_3;
  }
  result = sub_15B00((unsigned int *)result, (char *)&word_5616C);
  *(_BYTE *)(v2 + 13) = 0;
  if ( a2 )
  {
LABEL_3:
    sub_15B00((unsigned int *)v2, ",\"id\":1}");
    return sub_15B00((unsigned int *)v2, (char *)&word_5616C);
  }
  return result;
}
// 5616C: using guessed type __int16 word_5616C;

//----- (00016DFC) --------------------------------------------------------
void *__fastcall sub_16DFC(char ***a1, char *s)
{
  char **v2; // r5
  size_t v5; // r0
  char *v6; // r7
  size_t v7; // r4
  unsigned int v8; // r1
  size_t v9; // r9
  char *v10; // r5
  void *result; // r0
  int v12; // r10
  char sa[2048]; // [sp+18h] [bp-800h] BYREF

  v2 = *a1;
  v5 = strlen(s);
  v6 = v2[1];
  v7 = v5;
  v8 = (unsigned int)v2[2];
  v9 = v5 + 1;
  v10 = *v2;
  if ( (unsigned int)&v6[v5 + 1] > v8 )
  {
    v12 = v5 + 4097 - (v9 & 0xFFF);
    v10 = (char *)realloc(v10, v8 + v12);
    **a1 = v10;
    if ( !v10 )
    {
      snprintf(
        sa,
        0x800u,
        "OOM buf siz=%d tot=%d ext=%d in %s %s():%d",
        v7,
        (*a1)[2],
        v12,
        "api.c",
        "add_item_buf",
        1176);
      sub_20F58(3, sa, 1);
      sub_3EBA0(1);
    }
    (*a1)[2] += v12;
  }
  result = memcpy(&v6[(_DWORD)v10], s, v9);
  (*a1)[1] += v7;
  return result;
}

//----- (00016F14) --------------------------------------------------------
void __fastcall sub_16F14(const char *a1, int a2, int a3, int a4)
{
  const char *v7; // r9
  size_t v8; // r0
  size_t v9; // r2
  __int16 *v10; // r3
  signed int v11; // r5
  int v12; // r2
  int v13; // r7
  int v14; // r10
  _BOOL4 v15; // r3
  fd_set *p_tv_usec; // r3
  int v17; // r0
  ssize_t v18; // r0
  ssize_t v19; // r8
  int v20; // r0
  char *v21; // r0
  int v22; // [sp+Ch] [bp-898h]
  signed int v23; // [sp+10h] [bp-894h]
  struct timeval timeout; // [sp+18h] [bp-88Ch] BYREF
  fd_set writefds; // [sp+20h] [bp-884h] BYREF
  char s[2048]; // [sp+A0h] [bp-804h] BYREF

  v7 = a1;
  v8 = strlen(a1);
  v9 = v8;
  if ( a2 )
  {
    v9 = v8 + 1;
    *(_WORD *)&v7[v8] = 93;
  }
  if ( a4 )
  {
    strcpy((char *)&v7[v9], ",\"id\":1}");
    v9 = strlen(v7);
  }
  v23 = v9 + 1;
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    v10 = (__int16 *)"";
    if ( v9 > 0xA )
      v10 = &word_4A834;
    snprintf(s, 0x800u, "API: send reply: (%d) '%.10s%s'", v23, v7, v10);
    sub_20F58(7, s, 0);
  }
  v11 = v23;
  LOBYTE(v12) = a3 & 0x1F;
  if ( a3 <= 0 )
    v12 = -(-a3 & 0x1F);
  v13 = 0;
  v14 = 0;
  v22 = 1 << v12;
  while ( 1 )
  {
    v15 = v14 <= 4;
    if ( v11 <= 0 )
      v15 = 0;
    if ( !v15 )
      break;
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->__fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( &writefds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
    writefds.__fds_bits[a3 / 32] |= v22;
    v17 = select(a3 + 1, 0, &writefds, 0, &timeout);
    if ( v17 <= 0 )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
      {
        snprintf(s, 0x800u, "API: send select failed (%d)", v17);
        sub_20F58(4, s, 0);
      }
      return;
    }
    v18 = send(a3, v7, v11, 0);
    v19 = v18;
    ++v13;
    if ( v18 < 0 )
    {
      v20 = *_errno_location();
      if ( v20 != 11 )
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
        {
          v21 = strerror(v20);
          snprintf(s, 0x800u, "API: send (%d:%d) failed: %s", v23, v23 - v11, v21);
          sub_20F58(4, s, 0);
        }
        return;
      }
LABEL_27:
      ++v14;
    }
    else if ( v13 == 1 )
    {
      if ( v11 != v18 )
      {
        if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
        {
          snprintf(s, 0x800u, "API: sent %d of %d first go", v18, v11);
          sub_20F58(7, s, 0);
        }
        goto LABEL_26;
      }
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        snprintf(s, 0x800u, "API: sent all of %d first go", v11);
        sub_20F58(7, s, 0);
      }
LABEL_47:
      v11 -= v19;
      v7 += v19;
    }
    else if ( v11 == v18 )
    {
      if ( !byte_68BD5 || !byte_74500 && !byte_68BD4 && dword_67DB4 <= 6 )
        goto LABEL_47;
      snprintf(s, 0x800u, "API: sent all of remaining %d (sendc=%d)", v11, v13);
      v11 -= v19;
      sub_20F58(7, s, 0);
      v7 += v19;
    }
    else
    {
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        snprintf(s, 0x800u, "API: sent %d of remaining %d (sendc=%d)", v18, v11, v13);
        sub_20F58(7, s, 0);
      }
LABEL_26:
      v11 -= v19;
      v7 += v19;
      if ( !v19 )
        goto LABEL_27;
    }
  }
}
// 4A834: using guessed type __int16 word_4A834;
// 5616C: using guessed type __int16 word_5616C;
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (00017420) --------------------------------------------------------
int __fastcall sub_17420(unsigned __int8 **a1, int *a2)
{
  _BYTE *v2; // r2
  int v3; // r3
  bool v4; // zf
  _BYTE *v5; // r3
  _BYTE *v6; // r2
  _BYTE *v7; // r3
  int result; // r0

  v2 = *a1;
  v3 = **a1;
  if ( **a1 )
  {
    while ( v3 != 44 )
    {
      v4 = v3 == 92;
      v5 = v2;
      if ( v4 && v2[1] )
        v5 = v2 + 1;
      *a1 = v5 + 1;
      v6 = (_BYTE *)(*a2)++;
      *v6 = *v5;
      v2 = *a1;
      v3 = **a1;
      if ( !**a1 )
        goto LABEL_10;
    }
    *a1 = v2 + 1;
  }
LABEL_10:
  v7 = (_BYTE *)*a2;
  result = *a2 + 1;
  *a2 = result;
  *v7 = 0;
  return result;
}

//----- (000174A0) --------------------------------------------------------
int __fastcall sub_174A0(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  size_t v7; // r0
  void *v8; // r5
  unsigned __int8 *v10[2]; // [sp+4h] [bp-80Ch] BYREF
  void *v11; // [sp+Ch] [bp-804h] BYREF
  char v12[2048]; // [sp+10h] [bp-800h] BYREF

  v10[0] = a1;
  v7 = strlen((const char *)a1);
  v8 = malloc(v7 + 1);
  v11 = v8;
  if ( !v8 )
  {
    strcpy(v12, "Failed to malloc pooldetails buf");
    sub_20F58(3, v12, 1);
    sub_3EBA0(1);
  }
  *a2 = v8;
  sub_17420(v10, (int *)&v11);
  if ( *v10[0] && (*a3 = v11, sub_17420(v10, (int *)&v11), *v10[0]) )
  {
    *a4 = v11;
    sub_17420(v10, (int *)&v11);
    return 1;
  }
  else
  {
    free(v8);
    return 0;
  }
}

//----- (000175A0) --------------------------------------------------------
void __fastcall __noreturn sub_175A0(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_3EBA0(1);
}

//----- (000175F8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_175F8(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 17600: positive sp value 814 has been found
// 17600: unbalanced stack, ignored a potential tail call

//----- (00017604) --------------------------------------------------------
void __fastcall __noreturn sub_17604(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_3EBA0(1);
}

//----- (00017668) --------------------------------------------------------
void __fastcall __noreturn sub_17668(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_3EBA0(1);
}

//----- (000176CC) --------------------------------------------------------
void __fastcall __noreturn sub_176CC(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_3EBA0(1);
}

//----- (00017724) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_17724(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 1772C: positive sp value 814 has been found
// 1772C: unbalanced stack, ignored a potential tail call

//----- (00017730) --------------------------------------------------------
int sub_17730()
{
  int v0; // r4
  int *v1; // r3
  int v2; // t1
  int v3; // r2

  if ( pthread_rwlock_rdlock(&stru_7680C) )
    sub_175A0("numascs", 1381);
  if ( dword_755C0 > 0 )
  {
    v0 = 0;
    v1 = (int *)dword_7346C;
    do
    {
      v2 = *v1++;
      v3 = **(_DWORD **)(v2 + 4);
      if ( v3 == 2 || v3 == 3 )
        ++v0;
    }
    while ( v1 != (int *)(dword_7346C + 4 * dword_755C0) );
  }
  else
  {
    v0 = 0;
  }
  if ( pthread_rwlock_unlock(&stru_7680C) )
    sub_176CC("numascs", 1386);
  off_67ED8();
  return v0;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 7346C: using guessed type int dword_7346C;
// 755C0: using guessed type int dword_755C0;
// 7680C: using guessed type pthread_rwlock_t stru_7680C;

//----- (000177EC) --------------------------------------------------------
int __fastcall sub_177EC(int a1)
{
  int v2; // r4
  int v3; // r2
  int v4; // r1
  int v5; // t1
  int v6; // r3

  if ( pthread_rwlock_rdlock(&stru_7680C) )
    sub_175A0("ascdevice", 1395);
  if ( dword_755C0 <= 0 )
  {
LABEL_11:
    if ( pthread_rwlock_unlock(&stru_7680C) )
      sub_176CC("ascdevice", 1403);
    off_67ED8();
    return -1;
  }
  else
  {
    v2 = 0;
    v3 = 0;
    v4 = dword_7346C - 4;
    while ( 1 )
    {
      v5 = *(_DWORD *)(v4 + 4);
      v4 += 4;
      v6 = **(_DWORD **)(v5 + 4);
      if ( v6 == 2 || v6 == 3 )
        ++v3;
      if ( v3 == a1 + 1 )
        break;
      if ( dword_755C0 == ++v2 )
        goto LABEL_11;
    }
    if ( pthread_rwlock_unlock(&stru_7680C) )
      sub_176CC("ascdevice", 1408);
    off_67ED8();
    return v2;
  }
}
// 67ED8: using guessed type int (*off_67ED8)();
// 7346C: using guessed type int dword_7346C;
// 755C0: using guessed type int dword_755C0;
// 7680C: using guessed type pthread_rwlock_t stru_7680C;

//----- (00017900) --------------------------------------------------------
int __fastcall sub_17900(int *a1)
{
  int v2; // r0
  int v3; // r6
  void **v4; // r4
  void **v5; // r5
  void **v6; // r0

  if ( pthread_mutex_lock(&stru_68A88) )
    sub_17604("tidyup", 4510);
  v2 = *a1;
  byte_68A7C = 1;
  if ( v2 != -1 )
  {
    shutdown(v2, 2);
    close(*a1);
    *a1 = -1;
  }
  if ( dword_68A80 )
  {
    free((void *)dword_68A80);
    dword_68A80 = 0;
  }
  v3 = dword_68AA0;
  if ( dword_68AA0 )
  {
    v4 = (void **)dword_68AA0;
    do
    {
      v5 = (void **)v4[2];
      free(*((void **)*v4 + 1));
      free(*v4);
      v6 = v4;
      v4 = v5;
      free(v6);
    }
    while ( (void **)v3 != v5 );
    dword_68AA0 = 0;
  }
  if ( pthread_mutex_unlock(&stru_68A88) )
    sub_17668("tidyup", 4531);
  return off_67ED8();
}
// 67ED8: using guessed type int (*off_67ED8)();
// 68A7C: using guessed type char byte_68A7C;
// 68A80: using guessed type int dword_68A80;
// 68AA0: using guessed type int dword_68AA0;

//----- (000179F4) --------------------------------------------------------
void __noreturn sub_179F4()
{
  int *v0; // r0
  int *v1; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( !pthread_mutex_lock(&stru_68A88) )
  {
    if ( !pthread_mutex_unlock(&stru_68A88) )
    {
      off_67ED8();
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        strcpy(s, "API: killing bmminer");
        sub_20F58(7, s, 0);
      }
      sub_2E730();
    }
    v1 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v1, "api.c", "quit_thread", 4828);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v0 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v0, "api.c", "quit_thread", 4827);
  sub_20F58(3, s, 1);
  sub_3EBA0(1);
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (00017B7C) --------------------------------------------------------
int sub_17B7C()
{
  int *v1; // r0
  int *v2; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_68A88) )
  {
    v1 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "api.c", "restart_thread", 4841);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( pthread_mutex_unlock(&stru_68A88) )
  {
    v2 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v2, "api.c", "restart_thread", 4842);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  off_67ED8();
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    strcpy(s, "API: restarting bmminer");
    sub_20F58(7, s, 0);
  }
  sub_319C4();
  return 0;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (00017D00) --------------------------------------------------------
int __fastcall sub_17D00(unsigned int *a1, char **a2, int a3, int a4)
{
  int v7; // r5
  int v8; // r11
  int v9; // r5
  char ***v10; // r5
  char *v11; // r3
  unsigned __int8 *v12; // r3
  unsigned __int8 *v13; // r2
  char **v14; // r0
  int v15; // r4
  int v16; // r4
  char *v18; // r3
  char *v19; // r6
  char *v20; // r3
  char *v21; // r1
  char ***v22; // r0
  int *v23; // r0
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  int *v27; // r0
  int *v28; // r0
  int *v29; // r0
  int *v30; // r0
  const char *v32; // [sp+2Ch] [bp-848h]
  const char *v33; // [sp+2Ch] [bp-848h]
  char s[64]; // [sp+30h] [bp-844h] BYREF
  char v35[2052]; // [sp+70h] [bp-804h] BYREF

  v7 = *(_DWORD *)(dword_68AA4 + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v7) )
  {
    v25 = _errno_location();
    snprintf(v35, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v25, "api.c", "print_data", 1193);
    sub_20F58(3, v35, 1);
    sub_3EBA0(1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 24)) )
  {
    v26 = _errno_location();
    snprintf(v35, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v26, "api.c", "print_data", 1193);
    sub_20F58(3, v35, 1);
    sub_3EBA0(1);
  }
  v8 = sub_203A8(dword_68AA4, "api.c", "print_data", 1194);
  v9 = *(_DWORD *)(dword_68AA4 + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v9 + 24)) )
  {
    v29 = _errno_location();
    snprintf(v35, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v29, "api.c", "print_data", 1195);
    sub_20F58(3, v35, 1);
    sub_3EBA0(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v9) )
  {
    v30 = _errno_location();
    snprintf(v35, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v30, "api.c", "print_data", 1195);
    sub_20F58(3, v35, 1);
    sub_3EBA0(1);
  }
  off_67ED8();
  v10 = (char ***)(v8 + 12);
  *(_DWORD *)(*(_DWORD *)(v8 + 12) + 4) = 0;
  if ( a4 )
    sub_16DFC(v10, ",");
  if ( a3 )
  {
    sub_16DFC(v10, "{");
    if ( !a2 )
      goto LABEL_26;
  }
  else if ( !a2 )
  {
    goto LABEL_19;
  }
  if ( a3 )
  {
LABEL_16:
    sub_16DFC(v10, "\"");
    sub_16DFC(v10, a2[1]);
    sub_16DFC(v10, "\"");
    sub_16DFC(v10, ":");
    v11 = *a2;
    switch ( (unsigned int)*a2 )
    {
      case 0u:
        v33 = a2[2];
        v19 = (char *)sub_15C2C(v33, 1);
        sub_16DFC(v10, "\"");
        sub_16DFC(v10, v19);
        sub_16DFC(v10, "\"");
        v20 = (char *)v33;
        goto LABEL_56;
      case 1u:
      case 2u:
        sub_16DFC(v10, "\"");
        v21 = a2[2];
        v22 = (char ***)(v8 + 12);
        goto LABEL_60;
      case 3u:
        goto LABEL_29;
      case 4u:
        goto LABEL_28;
      case 5u:
        goto LABEL_27;
      case 6u:
        goto LABEL_46;
      case 7u:
      case 8u:
        goto LABEL_11;
      case 9u:
        sub_16DFC(v10, "\"");
        snprintf(s, 0x40u, "0x%08x", *(_DWORD *)a2[2]);
        v21 = s;
        v22 = (char ***)(v8 + 12);
        goto LABEL_60;
      case 0xAu:
        goto LABEL_44;
      case 0xBu:
        goto LABEL_43;
      case 0xCu:
        goto LABEL_42;
      case 0xDu:
        goto LABEL_41;
      case 0xEu:
        goto LABEL_38;
      case 0xFu:
        goto LABEL_37;
      case 0x10u:
        goto LABEL_36;
      case 0x11u:
      case 0x14u:
      case 0x15u:
        goto LABEL_35;
      case 0x12u:
        goto LABEL_34;
      case 0x13u:
        goto LABEL_33;
      case 0x16u:
      case 0x1Au:
        goto LABEL_32;
      case 0x17u:
        goto LABEL_31;
      case 0x18u:
        goto LABEL_30;
      case 0x19u:
        goto LABEL_45;
      default:
        goto LABEL_49;
    }
  }
  while ( 1 )
  {
    sub_16DFC(v10, a2[1]);
    sub_16DFC(v10, "=");
    v11 = *a2;
    switch ( (unsigned int)*a2 )
    {
      case 0u:
        v32 = a2[2];
        v19 = (char *)sub_15C2C(v32, 0);
        sub_16DFC(v10, v19);
        v20 = (char *)v32;
LABEL_56:
        if ( v20 != v19 )
          free(v19);
        break;
      case 1u:
      case 2u:
        sub_16DFC(v10, a2[2]);
        break;
      case 3u:
LABEL_29:
        snprintf(s, 0x40u, "%u", (unsigned __int8)*a2[2]);
        goto LABEL_12;
      case 4u:
LABEL_28:
        snprintf(s, 0x40u, "%d", *(__int16 *)a2[2]);
        goto LABEL_12;
      case 5u:
LABEL_27:
        snprintf(s, 0x40u, "%u", *(unsigned __int16 *)a2[2]);
        goto LABEL_12;
      case 6u:
LABEL_46:
        snprintf(s, 0x40u, "%d", *(_DWORD *)a2[2]);
        goto LABEL_12;
      case 7u:
      case 8u:
LABEL_11:
        snprintf(s, 0x40u, "%u", *(_DWORD *)a2[2]);
        goto LABEL_12;
      case 9u:
        snprintf(s, 0x40u, "0x%08x", *(_DWORD *)a2[2]);
        sub_16DFC(v10, s);
        break;
      case 0xAu:
LABEL_44:
        snprintf(s, 0x40u, "%llu", *(_QWORD *)a2[2]);
        goto LABEL_12;
      case 0xBu:
LABEL_43:
        snprintf(s, 0x40u, "%lld", *(_QWORD *)a2[2]);
        goto LABEL_12;
      case 0xCu:
LABEL_42:
        snprintf(s, 0x40u, "%f", *(double *)a2[2]);
        goto LABEL_12;
      case 0xDu:
LABEL_41:
        snprintf(s, 0x40u, "%.0f", *(double *)a2[2]);
        goto LABEL_12;
      case 0xEu:
LABEL_38:
        v18 = "false";
        if ( *a2[2] )
          v18 = "true";
        snprintf(s, 0x40u, "%s", v18);
        goto LABEL_12;
      case 0xFu:
LABEL_37:
        snprintf(s, 0x40u, "%ld.%06ld", *(_DWORD *)a2[2], *((_DWORD *)a2[2] + 1));
        goto LABEL_12;
      case 0x10u:
LABEL_36:
        snprintf(s, 0x40u, "%lu", *(_DWORD *)a2[2]);
        goto LABEL_12;
      case 0x11u:
      case 0x14u:
      case 0x15u:
LABEL_35:
        snprintf(s, 0x40u, "%.2f", *(double *)a2[2]);
        goto LABEL_12;
      case 0x12u:
LABEL_34:
        snprintf(s, 0x40u, "%.4f", *(double *)a2[2]);
        goto LABEL_12;
      case 0x13u:
LABEL_33:
        snprintf(s, 0x40u, "%.2f", *(float *)a2[2]);
        goto LABEL_12;
      case 0x16u:
      case 0x1Au:
LABEL_32:
        snprintf(s, 0x40u, "%.3f", *(float *)a2[2]);
        goto LABEL_12;
      case 0x17u:
LABEL_31:
        snprintf(s, 0x40u, "%.15f", *(double *)a2[2]);
        goto LABEL_12;
      case 0x18u:
LABEL_30:
        snprintf(s, 0x40u, "%.8f", *(double *)a2[2]);
        goto LABEL_12;
      case 0x19u:
LABEL_45:
        snprintf(s, 0x40u, "%.4f", *(double *)a2[2] * 100.0);
LABEL_12:
        sub_16DFC(v10, s);
        break;
      default:
LABEL_49:
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
        {
          snprintf(v35, 0x800u, "API: unknown2 data type %d ignored", v11);
          sub_20F58(3, v35, 0);
        }
        if ( a3 )
        {
          sub_16DFC(v10, "\"");
          v21 = "Unknown";
          v22 = (char ***)(v8 + 12);
LABEL_60:
          sub_16DFC(v22, v21);
          sub_16DFC(v10, "\"");
        }
        else
        {
          sub_16DFC(v10, "Unknown");
        }
        break;
    }
    free(a2[1]);
    if ( !*((_BYTE *)a2 + 12) )
    {
      v12 = (unsigned __int8 *)a2[5];
      if ( v12 == (unsigned __int8 *)a2 )
        break;
      goto LABEL_15;
    }
    free(a2[2]);
    v12 = (unsigned __int8 *)a2[5];
    if ( v12 == (unsigned __int8 *)a2 )
      break;
LABEL_15:
    v13 = (unsigned __int8 *)a2[4];
    v14 = a2;
    a2 = (char **)v12;
    *((_DWORD *)v12 + 4) = v13;
    *((_DWORD *)v13 + 5) = v12;
    free(v14);
    sub_16DFC(v10, ",");
    if ( a3 )
      goto LABEL_16;
  }
  free(a2);
  if ( !a3 )
  {
LABEL_19:
    sub_16DFC(v10, "|");
    goto LABEL_20;
  }
LABEL_26:
  sub_16DFC(v10, "}");
LABEL_20:
  sub_15B00(a1, **(char ***)(v8 + 12));
  v15 = *(_DWORD *)(dword_68AA4 + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v15) )
  {
    v27 = _errno_location();
    snprintf(v35, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v27, "api.c", "print_data", 1365);
    sub_20F58(3, v35, 1);
    sub_3EBA0(1);
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v15 + 24)) )
  {
    v28 = _errno_location();
    snprintf(v35, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v28, "api.c", "print_data", 1365);
    sub_20F58(3, v35, 1);
    sub_3EBA0(1);
  }
  sub_20524(dword_68AA4, v8, "api.c", "print_data", 1366);
  v16 = *(_DWORD *)(dword_68AA4 + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v16 + 24)) )
  {
    v23 = _errno_location();
    snprintf(v35, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v23, "api.c", "print_data", 1367);
    sub_20F58(3, v35, 1);
    sub_3EBA0(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v16) )
  {
    v24 = _errno_location();
    snprintf(v35, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v24, "api.c", "print_data", 1367);
    sub_20F58(3, v35, 1);
    sub_3EBA0(1);
  }
  off_67ED8();
  return 0;
}
// 17E2C: control flows out of bounds to 17E30
// 17F60: control flows out of bounds to 17F64
// 183B0: conditional instruction was optimized away because r7.4!=0
// 183C8: conditional instruction was optimized away because r7.4!=0
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68AA4: using guessed type int dword_68AA4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00018850) --------------------------------------------------------
const char *__fastcall sub_18850(int a1, const char *a2, int a3, const char *a4, char a5)
{
  char *v9; // r4
  int v10; // r3
  const char *result; // r0
  _DWORD *v12; // r0
  int v13; // r3
  _DWORD *v14; // r0
  int v15; // r1
  _DWORD *v16; // r2
  int v17; // r0
  _QWORD *v18; // r0
  __int64 v19; // r2
  _WORD *v20; // r0
  __int16 v21; // r3
  _BYTE *v22; // r0
  char v23; // r3
  _DWORD *v24; // r0
  int v25; // r3
  _BYTE *v26; // r0
  char v27; // r3
  size_t v28; // r5
  void *v29; // r0
  char v30[2052]; // [sp+0h] [bp-804h] BYREF

  v9 = (char *)malloc(0x18u);
  *((_DWORD *)v9 + 1) = _strdup(a2);
  if ( a1 )
    v10 = *(_DWORD *)(a1 + 16);
  else
    a2 = v9;
  if ( a1 )
  {
    *((_DWORD *)v9 + 5) = a1;
    a2 = (const char *)a1;
    *(_DWORD *)(a1 + 16) = v9;
    *((_DWORD *)v9 + 4) = v10;
  }
  *(_DWORD *)v9 = a3;
  if ( a1 )
    *(_DWORD *)(v10 + 20) = v9;
  else
    *((_DWORD *)v9 + 4) = v9;
  if ( !a1 )
    *((_DWORD *)v9 + 5) = v9;
  v9[12] = a5;
  if ( !a4 )
  {
    v9[12] = 0;
    a4 = "(null)";
    *(_DWORD *)v9 = 2;
LABEL_15:
    *((_DWORD *)v9 + 2) = a4;
    return a2;
  }
  if ( !a5 )
    goto LABEL_15;
  switch ( a3 )
  {
    case 0:
    case 1:
    case 2:
      v28 = strlen(a4) + 1;
      v29 = malloc(v28);
      *((_DWORD *)v9 + 2) = v29;
      memcpy(v29, a4, v28);
      return a2;
    case 3:
      v26 = malloc(4u);
      v27 = *a4;
      *((_DWORD *)v9 + 2) = v26;
      *v26 = v27;
      return a2;
    case 4:
    case 5:
      v20 = malloc(4u);
      v21 = *(_WORD *)a4;
      *((_DWORD *)v9 + 2) = v20;
      *v20 = v21;
      return a2;
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
      v12 = malloc(4u);
      v13 = *(_DWORD *)a4;
      *((_DWORD *)v9 + 2) = v12;
      *v12 = v13;
      result = a2;
      break;
    case 10:
    case 11:
      v18 = malloc(8u);
      v19 = *(_QWORD *)a4;
      *((_DWORD *)v9 + 2) = v18;
      *v18 = v19;
      return a2;
    case 12:
    case 13:
    case 15:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      v14 = malloc(8u);
      v15 = *((_DWORD *)a4 + 1);
      v16 = v14;
      v17 = *(_DWORD *)a4;
      *((_DWORD *)v9 + 2) = v16;
      *v16 = v17;
      v16[1] = v15;
      return a2;
    case 14:
      v22 = malloc(1u);
      v23 = *a4;
      *((_DWORD *)v9 + 2) = v22;
      *v22 = v23;
      return a2;
    case 19:
    case 22:
    case 26:
      v24 = malloc(4u);
      v25 = *(_DWORD *)a4;
      *((_DWORD *)v9 + 2) = v24;
      *v24 = v25;
      return a2;
    default:
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf(v30, 0x800u, "API: unknown1 data type %d ignored", a3);
        sub_20F58(3, v30, 0);
      }
      *((_DWORD *)v9 + 2) = "Unknown";
      *(_DWORD *)v9 = 1;
      v9[12] = 0;
      return a2;
  }
  return result;
}
// 188D0: control flows out of bounds to 188D4
// 188A0: variable 'v10' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00018AD4) --------------------------------------------------------
int __fastcall sub_18AD4(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5)
{
  int v8; // r1
  int *v9; // r2
  int v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r7
  const char *v14; // r1
  const char *v15; // r0
  const char *v16; // r0
  char **v17; // r0
  int result; // r0
  int v19; // r4
  const char *v20; // r0
  const char *v21; // r0
  int v22; // r0
  int v23; // r0
  char *v24; // r3
  int v25; // [sp+Ch] [bp-2010h] BYREF
  char v26[4]; // [sp+10h] [bp-200Ch] BYREF
  int v27; // [sp+14h] [bp-2008h] BYREF
  char s[8168]; // [sp+18h] [bp-2004h] BYREF

  v25 = a2;
  if ( a5 )
    sub_15B00(a1, "{\"STATUS\":[");
  v8 = dword_67298[0];
  if ( dword_67298[0] == 4 )
  {
LABEL_9:
    v11 = sub_18850(0, "STATUS", 1, "F", 0);
    v12 = sub_18850((int)v11, "When", 16, (const char *)&dword_68AA8, 0);
    v27 = -1;
    v13 = sub_18850((int)v12, "Code", 6, (const char *)&v27, 0);
    sprintf(s, "%d", v25);
    LOWORD(v14) = (unsigned __int16)"Msg";
    v15 = v13;
    goto LABEL_10;
  }
  if ( dword_6729C != v25 )
  {
    v9 = dword_67298;
    v10 = 0;
    while ( 1 )
    {
      v8 = v9[4];
      ++v10;
      v9 += 4;
      if ( v8 == 4 )
        goto LABEL_9;
      if ( v9[1] == v25 )
        goto LABEL_13;
    }
  }
  v10 = 0;
LABEL_13:
  switch ( v8 )
  {
    case 2:
      v26[0] = 73;
      break;
    case 3:
      v26[0] = 83;
      break;
    case 1:
      v26[0] = 87;
      break;
    default:
      v26[0] = 69;
      break;
  }
  v19 = 4 * v10;
  v26[1] = 0;
  switch ( dword_67298[4 * v10 + 2] )
  {
    case 0:
    case 1:
    case 2:
    case 14:
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], a3);
      break;
    case 4:
      v22 = sub_17730();
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], a3, v22 - 1);
      break;
    case 5:
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], dword_733CC);
      break;
    case 6:
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], a3, dword_733CC - 1);
      break;
    case 7:
      v23 = sub_17730();
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], v23);
      break;
    case 8:
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], "command");
      break;
    case 9:
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], a3, *(_DWORD *)(*(_DWORD *)(dword_744C8 + 4 * a3) + 164));
      break;
    case 10:
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], a4);
      break;
    case 11:
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], a3, a4);
      break;
    case 12:
      v24 = "false";
      if ( a3 )
        v24 = "true";
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], v24);
      break;
    case 13:
      snprintf(s, 0x1FFFu, (const char *)dword_67298[v19 + 3], a4, a3);
      break;
    default:
      strcpy(s, (const char *)dword_67298[v19 + 3]);
      break;
  }
  v20 = sub_18850(0, "STATUS", 1, v26, 0);
  v21 = sub_18850((int)v20, "When", 16, (const char *)&dword_68AA8, 0);
  v15 = sub_18850((int)v21, "Code", 6, (const char *)&v25, 0);
  LOWORD(v14) = -21676;
LABEL_10:
  HIWORD(v14) = (unsigned int)"Msg" >> 16;
  v16 = sub_18850((int)v15, v14, 0, s, 0);
  v17 = (char **)sub_18850((int)v16, "Description", 0, (const char *)off_6881C, 0);
  result = sub_17D00(a1, v17, a5, 0);
  if ( a5 )
    return sub_15B00(a1, (char *)&word_5616C);
  return result;
}
// 18C80: control flows out of bounds to 18C84
// 5616C: using guessed type __int16 word_5616C;
// 67298: using guessed type int dword_67298[];
// 6729C: using guessed type int dword_6729C;
// 6881C: using guessed type _UNKNOWN *off_6881C;
// 68AA8: using guessed type int dword_68AA8;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (00018EF0) --------------------------------------------------------
int __fastcall sub_18EF0(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_18AD4(a1, 46, 0, 0, a4);
}

//----- (00018F04) --------------------------------------------------------
void __fastcall sub_18F04(unsigned int *a1, int a2, const char *a3, int a4)
{
  const char *v4; // r4
  FILE *v7; // r0
  FILE *v8; // r6
  char *v9; // r6
  char *v10; // r8
  char v11[4096]; // [sp+8h] [bp-1000h] BYREF

  v4 = a3;
  if ( !a3 || !*a3 )
  {
    v4 = v11;
    sub_2D7F4(v11);
  }
  v7 = (FILE *)fopen64(v4, "w");
  v8 = v7;
  if ( v7 )
  {
    sub_2D174(v7);
    fclose(v8);
    v9 = (char *)sub_15C2C(v4, a4);
    sub_18AD4(a1, 44, 0, (int)v9, a4);
    if ( v4 != v9 )
      free(v9);
  }
  else
  {
    v10 = (char *)sub_15C2C(v4, a4);
    sub_18AD4(a1, 43, 0, (int)v10, a4);
    if ( v4 != v10 )
      free(v10);
  }
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00018FE8) --------------------------------------------------------
int __fastcall sub_18FE8(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_18AD4(a1, 124, 0, 0, a4);
}

//----- (000191F0) --------------------------------------------------------
int __fastcall sub_191F0(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  int v7; // r5
  void (*v8)(void); // r3
  unsigned int *v9; // r0
  int v10; // r2
  int v11; // r1
  int v12; // r0
  int v13; // r4
  int v14; // r0
  unsigned __int8 v16; // [sp+18h] [bp+18h]

  v7 = sub_17730();
  if ( v7 )
  {
    if ( a3 && *a3 )
    {
      v12 = strtol(a3, 0, 10);
      v13 = v12;
      if ( (v7 <= v12) | ((unsigned int)v12 >> 31) )
      {
        v16 = a4;
        v10 = v12;
        v8 = 0;
        v9 = a1;
        v11 = 107;
      }
      else
      {
        v14 = sub_177EC(v12);
        if ( v14 < 0 )
        {
          v16 = a4;
          v8 = 0;
          v10 = v13;
          v9 = a1;
          v11 = 107;
        }
        else
        {
          v8 = *(void (**)(void))(*(_DWORD *)(sub_3046C(v14) + 4) + 36);
          if ( v8 )
          {
            v8();
            v16 = a4;
            v8 = 0;
            v10 = v13;
            v9 = a1;
            v11 = 113;
          }
          else
          {
            v16 = a4;
            v10 = v13;
            v9 = a1;
            v11 = 114;
          }
        }
      }
    }
    else
    {
      v8 = 0;
      v16 = a4;
      v9 = a1;
      v10 = 0;
      v11 = 15;
    }
  }
  else
  {
    v16 = a4;
    v9 = a1;
    v8 = 0;
    v10 = 0;
    v11 = 105;
  }
  return sub_18AD4(v9, v11, v10, (int)v8, v16);
}

//----- (000197A0) --------------------------------------------------------
int __fastcall sub_197A0(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_18AD4(a1, 102, 0, 0, a4);
}

//----- (000197B4) --------------------------------------------------------
int __fastcall sub_197B4(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v6; // r5
  char *v7; // r0
  char *v8; // r7
  int v9; // r8
  int v10; // r9
  int v11; // r10
  int v12; // r4
  bool v13; // zf
  const char *v15; // r3
  int v16; // r1
  unsigned __int8 v17; // [sp+20h] [bp+20h]

  if ( a3 && *a3 )
  {
    v6 = a1;
    v7 = strchr(a3, 44);
    v8 = v7;
    if ( v7 && (*v7 = 0, v7 != (char *)-1) && (v9 = (unsigned __int8)v7[1], v7[1]) )
    {
      if ( !strcasecmp(a3, "all") )
      {
        v10 = 0;
        v11 = 1;
      }
      else
      {
        v11 = strcasecmp(a3, "bestshare");
        if ( v11 )
        {
          v17 = a4;
          v15 = a3;
          a1 = v6;
          v16 = 95;
          return sub_18AD4(a1, v16, 0, (int)v15, v17);
        }
        v10 = 1;
      }
      v12 = LOBYTE((*_ctype_tolower_loc())[v9]);
      v13 = v12 == 116;
      if ( v12 != 116 )
        v13 = v12 == 102;
      v8[1] = v12;
      if ( v13 )
      {
        if ( v12 == 116 )
          sub_304E0();
        if ( v11 )
          sub_32DA0();
        if ( v10 )
          sub_2D75C();
        v15 = "BestShare";
        if ( v11 )
          v15 = "All";
        v17 = a4;
        a1 = v6;
        if ( v12 == 116 )
          v16 = 96;
        else
          v16 = 97;
      }
      else
      {
        v15 = 0;
        v17 = a4;
        a1 = v6;
        v16 = 76;
      }
    }
    else
    {
      v15 = 0;
      v17 = a4;
      a1 = v6;
      v16 = 75;
    }
  }
  else
  {
    v15 = 0;
    v17 = a4;
    v16 = 94;
  }
  return sub_18AD4(a1, v16, 0, (int)v15, v17);
}

//----- (00019940) --------------------------------------------------------
int __fastcall sub_19940(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_18AD4(a1, 88, 0, 0, a4);
}

//----- (00019954) --------------------------------------------------------
int __fastcall sub_19954(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v6; // r5
  char *v7; // r0
  unsigned int v8; // r0
  int v9; // r7
  int v10; // r3
  int v11; // r2
  int v12; // r1
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  if ( a3 && *a3 )
  {
    v6 = a1;
    v7 = strchr(a3, 44);
    if ( v7 )
    {
      *v7 = 0;
      v8 = strtol(v7 + 1, 0, 10);
      v9 = v8;
      if ( v8 > 0x270F )
      {
        v14 = a4;
        v10 = (int)a3;
        v11 = v8;
        v12 = 84;
        a1 = v6;
      }
      else
      {
        if ( !strcasecmp(a3, "queue") )
        {
          dword_68824 = v9;
        }
        else if ( !strcasecmp(a3, "scantime") )
        {
          dword_68754 = v9;
        }
        else
        {
          if ( strcasecmp(a3, "expiry") )
          {
            v14 = a4;
            v10 = (int)a3;
            v11 = 0;
            a1 = v6;
            v12 = 83;
            return sub_18AD4(a1, v12, v11, v10, v14);
          }
          dword_68758 = v9;
        }
        v14 = a4;
        v10 = (int)a3;
        v11 = v9;
        a1 = v6;
        v12 = 82;
      }
    }
    else
    {
      v14 = a4;
      v10 = (int)a3;
      v11 = 0;
      v12 = 86;
      a1 = v6;
    }
  }
  else
  {
    v10 = 0;
    v14 = a4;
    v11 = 0;
    v12 = 85;
  }
  return sub_18AD4(a1, v12, v11, v10, v14);
}
// 68754: using guessed type int dword_68754;
// 68758: using guessed type int dword_68758;
// 68824: using guessed type int dword_68824;

//----- (00019AA4) --------------------------------------------------------
int __fastcall sub_19AA4(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4)
{
  int v6; // r6
  unsigned int *v7; // r5
  int v8; // r1
  bool v9; // zf
  int v10; // r3
  _BOOL4 v12; // r2
  int v13; // r1
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  if ( a3 && *a3 )
  {
    v7 = a1;
    v6 = (unsigned __int8)*a3;
    v8 = LOBYTE((*_ctype_tolower_loc())[v6]);
    v9 = v8 == 116;
    if ( v8 != 116 )
      v9 = v8 == 102;
    *a3 = v8;
    v10 = !v9;
    if ( v9 )
    {
      v14 = a4;
      a1 = v7;
      byte_755D4 = v8 == 116;
      v12 = v8 == 116;
      v13 = 77;
    }
    else
    {
      v10 = 0;
      v14 = a4;
      a1 = v7;
      v12 = 0;
      v13 = 76;
    }
  }
  else
  {
    v10 = 0;
    v14 = a4;
    v12 = 0;
    v13 = 75;
  }
  return sub_18AD4(a1, v13, v12, v10, v14);
}
// 755D4: using guessed type char byte_755D4;

//----- (00019B4C) --------------------------------------------------------
void __fastcall sub_19B4C(unsigned int *a1, int a2, const char *a3, int a4)
{
  int v5; // r3
  int v6; // r2
  int v7; // r1
  unsigned int *v8; // r6
  int v9; // r0
  int v10; // r7
  int v11; // r4
  char *v12; // r8
  unsigned __int8 v13; // [sp+20h] [bp+18h]

  v5 = dword_733CC;
  if ( !dword_733CC )
  {
    v13 = a4;
    v6 = 0;
    v7 = 8;
LABEL_6:
    sub_18AD4(a1, v7, v6, v5, v13);
    return;
  }
  v8 = a1;
  if ( !a3 || !*a3 )
  {
    v5 = 0;
    v6 = 0;
    v7 = 25;
    v13 = a4;
    goto LABEL_6;
  }
  v9 = strtol(a3, 0, 10);
  v10 = v9;
  if ( v9 < 0 || v9 >= dword_733CC )
  {
    v13 = a4;
    v6 = v9;
    a1 = v8;
    v5 = 0;
    v7 = 26;
    goto LABEL_6;
  }
  if ( dword_733CC <= 1 )
  {
    v13 = a4;
    v6 = v9;
    a1 = v8;
    v5 = 0;
    v7 = 66;
    goto LABEL_6;
  }
  v11 = *(_DWORD *)(dword_744C8 + 4 * v9);
  if ( v11 == sub_31FF4() )
    sub_34178(0);
  if ( v11 == sub_31FF4() )
  {
    v13 = a4;
    v6 = v10;
    a1 = v8;
    v5 = 0;
    v7 = 67;
    goto LABEL_6;
  }
  *(_DWORD *)(v11 + 100) = 0;
  v12 = (char *)sub_15C2C(*(const char **)(v11 + 164), a4);
  if ( v12 == *(char **)(v11 + 164) )
  {
    sub_2D0D8(v11);
    v13 = a4;
    v5 = (int)v12;
    v6 = v10;
    a1 = v8;
    v7 = 68;
    goto LABEL_6;
  }
  sub_2D0D8(v11);
  sub_18AD4(v8, 68, v10, (int)v12, a4);
  free(v12);
}
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (00019CD0) --------------------------------------------------------
int __fastcall sub_19CD0(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  unsigned __int8 v13; // [sp+18h] [bp+18h]

  if ( dword_733CC )
  {
    v6 = a1;
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_733CC )
      {
        v13 = a4;
        v7 = v9;
        a1 = v6;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_744C8 + 4 * v9);
        if ( *(_DWORD *)(v11 + 100) )
        {
          if ( dword_74578 <= 1 )
          {
            v13 = a4;
            v7 = v9;
            a1 = v6;
            v8 = 51;
          }
          else
          {
            *(_DWORD *)(v11 + 100) = 0;
            if ( v11 == sub_31FF4() )
              sub_34178(0);
            v13 = a4;
            v7 = v10;
            a1 = v6;
            v8 = 48;
          }
        }
        else
        {
          v13 = a4;
          v7 = v9;
          a1 = v6;
          v8 = 50;
        }
      }
    }
    else
    {
      v13 = a4;
      v7 = 0;
      v8 = 25;
    }
  }
  else
  {
    v13 = a4;
    v7 = 0;
    v8 = 8;
  }
  return sub_18AD4(a1, v8, v7, 0, v13);
}
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;
// 74578: using guessed type int dword_74578;

//----- (00019E14) --------------------------------------------------------
int __fastcall sub_19E14(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  int v12; // r8
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  if ( dword_733CC )
  {
    v6 = a1;
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_733CC )
      {
        v14 = a4;
        v7 = v9;
        a1 = v6;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_744C8 + 4 * v9);
        if ( *(_DWORD *)(v11 + 100) == 1 )
        {
          v14 = a4;
          v7 = v9;
          a1 = v6;
          v8 = 49;
        }
        else
        {
          v12 = *(_DWORD *)(v11 + 4);
          *(_DWORD *)(v11 + 100) = 1;
          if ( v12 < *(_DWORD *)(sub_31FF4() + 4) )
            sub_34178(v11);
          v14 = a4;
          v7 = v10;
          a1 = v6;
          v8 = 47;
        }
      }
    }
    else
    {
      v14 = a4;
      v7 = 0;
      v8 = 25;
    }
  }
  else
  {
    v14 = a4;
    v7 = 0;
    v8 = 8;
  }
  return sub_18AD4(a1, v8, v7, 0, v14);
}
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (00019F34) --------------------------------------------------------
int __fastcall sub_19F34(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5)
{
  char *v6; // r3
  unsigned int *v7; // r7
  char *v9; // r9
  int v10; // r0
  int v11; // r2
  int v12; // r1
  int v14; // r5
  int v15; // r0
  int v16; // r4
  unsigned __int8 v17; // [sp+20h] [bp+20h]

  v6 = (char *)dword_733CC;
  if ( dword_733CC )
  {
    v7 = a1;
    if ( s && *s )
    {
      v9 = strchr(s, 44);
      if ( v9 )
      {
        *v9 = 0;
        v10 = strtol(s, 0, 10);
        if ( v10 >= 0 && v10 < dword_733CC )
        {
          v14 = *(_DWORD *)(dword_744C8 + 4 * v10);
          v15 = strtol(v9 + 1, 0, 10);
          v16 = v15;
          if ( v15 < 0 )
          {
            v6 = *(char **)(v14 + 164);
            v11 = v15;
            v17 = a4;
            a1 = v7;
            v12 = 121;
          }
          else
          {
            *(_DWORD *)(v14 + 56) = v15;
            sub_2C6A8();
            v6 = *(char **)(v14 + 164);
            v11 = v16;
            v17 = a4;
            a1 = v7;
            v12 = 122;
          }
        }
        else
        {
          v17 = a4;
          v11 = v10;
          a1 = v7;
          v6 = 0;
          v12 = 26;
        }
      }
      else
      {
        v17 = a4;
        v6 = s;
        v11 = 0;
        a1 = v7;
        v12 = 86;
      }
    }
    else
    {
      v6 = 0;
      v17 = a4;
      v11 = 0;
      v12 = 25;
    }
  }
  else
  {
    v17 = a4;
    v11 = 0;
    v12 = 8;
  }
  return sub_18AD4(a1, v12, v11, (int)v6, v17);
}
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (0001A07C) --------------------------------------------------------
int __fastcall sub_1A07C(unsigned int *a1, int a2, char *s, int a4)
{
  const char *v4; // r4
  char *v6; // r2
  char *v7; // r3
  unsigned int *v8; // r6
  char *v9; // r0
  char v10; // r3
  const char *v11; // r9
  int v12; // r0
  char *v13; // r12
  int v14; // r1
  int v15; // r4
  int v16; // r2
  char *v17; // r3
  int v18; // lr
  int v19; // t1
  bool v20; // zf
  int v21; // r6
  char *v22; // r2
  int v23; // r3
  int v25; // r0
  char v26; // [sp+7h] [bp-2Dh] BYREF
  unsigned int *v27; // [sp+8h] [bp-2Ch] BYREF
  int v28; // [sp+Ch] [bp-28h]

  v28 = a4;
  v27 = a1;
  if ( !dword_733CC )
    return sub_18AD4(a1, 8, 0, 0, v28);
  v4 = s;
  if ( !s || !*s )
    return sub_18AD4(v27, 25, 0, 0, v28);
  if ( dword_733CC > 0 )
  {
    v6 = &v26;
    v7 = (char *)&v27 + dword_733CC - 1;
    do
      *++v6 = 0;
    while ( v6 != v7 );
  }
  v8 = 0;
  do
  {
    v9 = strchr(v4, 44);
    if ( v9 )
      v10 = 0;
    v11 = v9 + 1;
    if ( v9 )
      *v9 = v10;
    else
      v11 = 0;
    v12 = strtol(v4, 0, 10);
    v4 = v11;
    v13 = (char *)v8 + 1;
    if ( v12 < 0 )
      return sub_18AD4(v27, 26, v12, 0, v28);
    v14 = dword_733CC;
    if ( dword_733CC <= v12 )
      return sub_18AD4(v27, 26, v12, 0, v28);
    if ( *((_BYTE *)&v27 + v12) )
      return sub_18AD4(v27, 74, v12, 0, v28);
    (&v27)[v12] = v8;
    *((_BYTE *)&v27 + v12) = 1;
    v8 = (unsigned int *)((char *)v8 + 1);
  }
  while ( v11 && *v11 );
  v15 = dword_744C8;
  v16 = 0;
  v17 = &v26;
  do
  {
    v19 = (unsigned __int8)*++v17;
    v18 = v19;
    v20 = v19 == 0;
    if ( v19 )
    {
      v18 = *(_DWORD *)(v15 + 4 * v16);
      v8 = (&v27)[v16];
    }
    ++v16;
    if ( !v20 )
      *(_DWORD *)(v18 + 4) = v8;
  }
  while ( v17 != &v26 + v14 );
  v21 = 0;
  do
  {
    v22 = &v26;
    v23 = 0;
    while ( 1 )
    {
      if ( !*++v22 )
      {
        v25 = *(_DWORD *)(v15 + 4 * v23);
        if ( *(_DWORD *)(v25 + 4) == v21 )
          break;
      }
      if ( v14 == ++v23 )
        goto LABEL_30;
    }
    *(_DWORD *)(v25 + 4) = v13++;
    *((_BYTE *)&v27 + v23) = 1;
LABEL_30:
    ++v21;
  }
  while ( v14 != v21 );
  if ( *(_DWORD *)(sub_31FF4() + 4) )
    sub_34178(0);
  return sub_18AD4(v27, 73, 0, 0, v28);
}
// 1A160: variable 'v10' is possibly undefined
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (0001A2DC) --------------------------------------------------------
void __fastcall sub_1A2DC(unsigned int *a1, int a2, char *a3, int a4)
{
  char *v7; // r7
  int *v8; // r7
  char *v9; // r4
  char *s; // [sp+Ch] [bp-Ch] BYREF
  int v11; // [sp+10h] [bp-8h] BYREF
  int v12; // [sp+14h] [bp-4h] BYREF

  if ( a3 && *a3 )
  {
    if ( sub_174A0((unsigned __int8 *)a3, &s, &v11, &v12) )
    {
      v8 = (int *)sub_324B8();
      sub_2C8A8((int)v8, s);
      sub_3EBAC((int)v8, 1, s, (const char *)v11, (const char *)v12);
      v9 = (char *)sub_15C2C(s, a4);
      sub_18AD4(a1, 55, *v8, (int)v9, a4);
      if ( s != v9 )
        free(v9);
    }
    else
    {
      v7 = (char *)sub_15C2C(a3, a4);
      sub_18AD4(a1, 53, 0, (int)v7, a4);
      if ( a3 != v7 )
        free(v7);
    }
  }
  else
  {
    sub_18AD4(a1, 52, 0, 0, a4);
  }
}

//----- (0001A3E4) --------------------------------------------------------
int __fastcall sub_1A3E4(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r7
  int v11; // r4
  unsigned __int8 v12; // [sp+18h] [bp+18h]

  if ( dword_733CC )
  {
    v6 = a1;
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      if ( pthread_mutex_lock(&stru_7453C) )
        sub_17604("switchpool", 2907);
      if ( pthread_rwlock_rdlock(&rwlock) )
        sub_175A0("switchpool", 2907);
      if ( pthread_mutex_unlock(&stru_7453C) )
        sub_17668("switchpool", 2907);
      if ( v9 >= 0 && v9 < dword_733CC )
      {
        v11 = *(_DWORD *)(dword_744C8 + 4 * v9);
        *(_DWORD *)(v11 + 100) = 1;
        if ( pthread_rwlock_unlock(&rwlock) )
          sub_176CC("switchpool", 2917);
        off_67ED8();
        sub_34178(v11);
        v12 = a4;
        v7 = v9;
        a1 = v6;
        v8 = 27;
      }
      else
      {
        if ( pthread_rwlock_unlock(&rwlock) )
          sub_176CC("switchpool", 2910);
        off_67ED8();
        v12 = a4;
        v7 = v9;
        a1 = v6;
        v8 = 26;
      }
    }
    else
    {
      v12 = a4;
      v7 = 0;
      v8 = 25;
    }
  }
  else
  {
    v12 = a4;
    v7 = 0;
    v8 = 8;
  }
  return sub_18AD4(a1, v8, v7, 0, v12);
}
// 67ED8: using guessed type int (*off_67ED8)();
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;
// 7453C: using guessed type pthread_mutex_t stru_7453C;

//----- (0001A598) --------------------------------------------------------
int __fastcall sub_1A598(int a1, int a2, int a3, int a4)
{
  int v6; // r6
  char **v7; // r0
  int result; // r0
  char **v9; // r0
  int v10; // [sp+Ch] [bp-4h] BYREF

  v10 = sub_17730();
  sub_18AD4((unsigned int *)a1, 104, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_15B00((unsigned int *)a1, ",\"ASCS\":[");
    v7 = (char **)sub_18850(0, "Count", 6, (const char *)&v10, 0);
    result = sub_17D00((unsigned int *)a1, v7, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_15B00((unsigned int *)a1, "ASCS,");
    v9 = (char **)sub_18850(0, "Count", 6, (const char *)&v10, 0);
    return sub_17D00((unsigned int *)a1, v9, 0, 0);
  }
  return result;
}

//----- (0001A678) --------------------------------------------------------
int __fastcall sub_1A678(int a1, int a2, _BYTE *a3, int a4)
{
  int v7; // r2
  int v8; // r3
  int v9; // r6
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  char **v16; // r0
  int result; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  char **v24; // r1
  char *v25; // r3
  int v26; // r2

  if ( a3 )
  {
    v7 = LOBYTE((*_ctype_tolower_loc())[(unsigned __int8)*a3]);
    *a3 = v7;
    switch ( v7 )
    {
      case 'd':
        v8 = (unsigned __int8)byte_68BD5 ^ 1;
        byte_68BD5 ^= 1u;
        byte_68BD4 = v8;
        if ( v8 )
          goto LABEL_4;
        break;
      case 'n':
        byte_68BD4 = 0;
        byte_68BD5 = 0;
        byte_73378 = 0;
        byte_73398 = 0;
        byte_73388 = 0;
        byte_7449C = 0;
        break;
      case 'p':
        byte_73388 ^= 1u;
        byte_68BD4 = byte_73388;
        break;
      case 'q':
        byte_73378 ^= 1u;
        break;
      case 'r':
        v25 = &byte_73398;
        goto LABEL_15;
      case 's':
        byte_7559C = 1;
        break;
      case 'v':
        v25 = &byte_68BD4;
LABEL_15:
        v26 = (unsigned __int8)*v25 ^ 1;
        *v25 = v26;
        if ( v26 )
LABEL_4:
          byte_73378 = 0;
        break;
      case 'w':
        byte_7449C ^= 1u;
        break;
      default:
        break;
    }
  }
  sub_18AD4((unsigned int *)a1, 79, 0, 0, a4);
  if ( a4 )
  {
    v9 = sub_15B00((unsigned int *)a1, ",\"DEBUG\":[");
    v10 = sub_18850(0, "Silent", 14, &byte_7559C, 0);
    v11 = sub_18850((int)v10, "Quiet", 14, &byte_73378, 0);
    v12 = sub_18850((int)v11, "Verbose", 14, &byte_68BD4, 0);
    v13 = sub_18850((int)v12, "Debug", 14, &byte_68BD5, 0);
    v14 = sub_18850((int)v13, "RPCProto", 14, &byte_73398, 0);
    v15 = sub_18850((int)v14, "PerDevice", 14, &byte_73388, 0);
    v16 = (char **)sub_18850((int)v15, "WorkTime", 14, &byte_7449C, 0);
    result = sub_17D00((unsigned int *)a1, v16, 1, 0);
    if ( v9 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_15B00((unsigned int *)a1, "DEBUG,");
    v18 = sub_18850(0, "Silent", 14, &byte_7559C, 0);
    v19 = sub_18850((int)v18, "Quiet", 14, &byte_73378, 0);
    v20 = sub_18850((int)v19, "Verbose", 14, &byte_68BD4, 0);
    v21 = sub_18850((int)v20, "Debug", 14, &byte_68BD5, 0);
    v22 = sub_18850((int)v21, "RPCProto", 14, &byte_73398, 0);
    v23 = sub_18850((int)v22, "PerDevice", 14, &byte_73388, 0);
    v24 = (char **)sub_18850((int)v23, "WorkTime", 14, &byte_7449C, 0);
    return sub_17D00((unsigned int *)a1, v24, 0, 0);
  }
  return result;
}
// 1A6B0: control flows out of bounds to 1A6B4
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 73378: using guessed type char byte_73378;
// 73388: using guessed type char byte_73388;
// 73398: using guessed type char byte_73398;
// 7449C: using guessed type char byte_7449C;
// 7559C: using guessed type char byte_7559C;

//----- (0001AA3C) --------------------------------------------------------
int __fastcall sub_1AA3C(int a1, int a2, const char *a3, int a4, unsigned __int8 a5)
{
  const char *v8; // r3
  _UNKNOWN **v9; // r4
  const char *v10; // t1
  const __int32_t **v11; // r0
  __int32_t v12; // r3
  int v13; // r5
  const char *v14; // r0
  const char *v15; // r3
  char **v16; // r0
  int result; // r0
  int v18; // r0
  const char *v19; // r3
  int v20; // r0
  int v21; // r0
  char s[100]; // [sp+Ch] [bp-64h] BYREF

  if ( !a3 || !*a3 )
    return sub_18AD4((unsigned int *)a1, 71, 0, 0, a4);
  v8 = (const char *)off_677C8;
  if ( off_677C8 )
  {
    v9 = &off_677C8;
    while ( strcmp(v8, a3) )
    {
      v10 = (const char *)v9[3];
      v9 += 3;
      v8 = v10;
      if ( !v10 )
      {
        sub_18AD4((unsigned int *)a1, 72, 0, 0, a4);
        if ( !a4 )
          goto LABEL_20;
        goto LABEL_17;
      }
    }
    sprintf(s, "|%s|", a3);
    v11 = _ctype_toupper_loc();
    v12 = (*v11)[a5];
    if ( v12 == (*v11)[87] || strstr(*((const char **)&unk_73188 + v12 - (*v11)[65]), s) )
    {
      sub_18AD4((unsigned int *)a1, 72, 0, 0, a4);
      if ( a4 )
        v13 = sub_15B00((unsigned int *)a1, ",\"CHECK\":[");
      else
        v13 = sub_15B00((unsigned int *)a1, "CHECK,");
      v14 = sub_18850(0, "Exists", 2, "Y", 0);
      v15 = "Y";
      goto LABEL_12;
    }
    sub_18AD4((unsigned int *)a1, 72, 0, 0, a4);
    if ( a4 )
      v21 = sub_15B00((unsigned int *)a1, ",\"CHECK\":[");
    else
      v21 = sub_15B00((unsigned int *)a1, "CHECK,");
    v19 = "Y";
    v13 = v21;
  }
  else
  {
    sub_18AD4((unsigned int *)a1, 72, 0, 0, a4);
    if ( a4 )
    {
LABEL_17:
      v18 = sub_15B00((unsigned int *)a1, ",\"CHECK\":[");
      v19 = "N";
      v13 = v18;
    }
    else
    {
LABEL_20:
      v20 = sub_15B00((unsigned int *)a1, "CHECK,");
      v19 = "N";
      v13 = v20;
    }
  }
  v14 = sub_18850(0, "Exists", 2, v19, 0);
  v15 = "N";
LABEL_12:
  v16 = (char **)sub_18850((int)v14, "Access", 2, v15, 0);
  result = sub_17D00((unsigned int *)a1, v16, a4, 0);
  if ( (a4 & v13) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 677C8: using guessed type _UNKNOWN *off_677C8;

//----- (0001ACB4) --------------------------------------------------------
int __fastcall sub_1ACB4(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r10
  int v8; // r11
  int v9; // r5
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r3
  const char *v15; // r0
  const char *v16; // r3
  const char *v17; // r0
  const char *v18; // r3
  char **v19; // r1
  _BOOL4 v20; // r3
  int v21; // [sp+Ch] [bp-8h] BYREF

  if ( !dword_755C0 )
    return sub_18AD4((unsigned int *)a1, 10, 0, 0, a4);
  result = sub_18AD4((unsigned int *)a1, 69, 0, 0, a4);
  if ( !a4 )
  {
    v21 = 0;
    if ( dword_755C0 <= 0 )
      return result;
    v7 = 0;
    goto LABEL_6;
  }
  result = sub_15B00((unsigned int *)a1, ",\"DEVDETAILS\":[");
  v7 = result;
  v21 = 0;
  if ( dword_755C0 > 0 )
  {
LABEL_6:
    v8 = 0;
    result = 0;
    do
    {
      v9 = sub_3046C(result);
      v10 = sub_18850(v8, "DEVDETAILS", 6, (const char *)&v21, 0);
      v11 = sub_18850((int)v10, "Name", 1, *(const char **)(*(_DWORD *)(v9 + 4) + 8), 0);
      v12 = sub_18850((int)v11, "ID", 6, (const char *)(v9 + 8), 0);
      v13 = sub_18850((int)v12, "Driver", 1, *(const char **)(*(_DWORD *)(v9 + 4) + 4), 0);
      v14 = *(const char **)(v9 + 168);
      if ( !v14 )
        v14 = "";
      v15 = sub_18850((int)v13, "Kernel", 2, v14, 0);
      v16 = *(const char **)(v9 + 12);
      if ( !v16 )
        v16 = "";
      v17 = sub_18850((int)v15, "Model", 2, v16, 0);
      v18 = *(const char **)(v9 + 16);
      if ( !v18 )
        v18 = "";
      v19 = (char **)sub_18850((int)v17, "Device Path", 2, v18, 0);
      v20 = a4;
      if ( a4 )
        v20 = v21 > 0;
      v8 = sub_17D00((unsigned int *)a1, v19, a4, v20);
      result = ++v21;
    }
    while ( v21 < dword_755C0 );
  }
  if ( v7 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 755C0: using guessed type int dword_755C0;

//----- (0001AE90) --------------------------------------------------------
int __fastcall sub_1AE90(int a1, int a2, int a3, int a4)
{
  int v6; // r5
  char **v7; // r0
  int result; // r0
  char **v9; // r0
  int v10; // [sp+Ch] [bp-4h] BYREF

  v10 = 0;
  sub_18AD4((unsigned int *)a1, 59, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_15B00((unsigned int *)a1, ",\"PGAS\":[");
    v7 = (char **)sub_18850(0, "Count", 6, (const char *)&v10, 0);
    result = sub_17D00((unsigned int *)a1, v7, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_15B00((unsigned int *)a1, "PGAS,");
    v9 = (char **)sub_18850(0, "Count", 6, (const char *)&v10, 0);
    return sub_17D00((unsigned int *)a1, v9, 0, 0);
  }
  return result;
}

//----- (0001AF64) --------------------------------------------------------
int __fastcall sub_1AF64(int a1, int a2, int a3, int a4)
{
  int v6; // r6
  const char *v7; // r0
  const char *v8; // r0
  char **v9; // r0
  int result; // r0
  const char *v11; // r0
  const char *v12; // r0
  char **v13; // r1

  sub_18AD4((unsigned int *)a1, 16, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_15B00((unsigned int *)a1, ",\"NONCENUM\":[");
    v7 = sub_18850(0, "10min nonce", 1, byte_756B4, 0);
    v8 = sub_18850((int)v7, "30min nonce", 1, byte_7457C, 0);
    v9 = (char **)sub_18850((int)v8, "60min nonce", 1, byte_73484, 0);
    result = sub_17D00((unsigned int *)a1, v9, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_15B00((unsigned int *)a1, "NONCENUM,");
    v11 = sub_18850(0, "10min nonce", 1, byte_756B4, 0);
    v12 = sub_18850((int)v11, "30min nonce", 1, byte_7457C, 0);
    v13 = (char **)sub_18850((int)v12, "60min nonce", 1, byte_73484, 0);
    return sub_17D00((unsigned int *)a1, v13, 0, 0);
  }
  return result;
}

//----- (0001B294) --------------------------------------------------------
int __fastcall sub_1B294(int a1, int a2, int a3, int a4)
{
  int v6; // r6
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  char **v11; // r0
  int result; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  char **v17; // r1

  sub_18AD4((unsigned int *)a1, 22, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_15B00((unsigned int *)a1, ",\"VERSION\":[");
    v7 = sub_18850(0, "BMMiner", 1, a10, 0);
    v8 = sub_18850((int)v7, "API", 2, "3.1", 0);
    v9 = sub_18850((int)v8, "Miner", 1, byte_6ABC0, 0);
    v10 = sub_18850((int)v9, "CompileTime", 1, byte_6A74C, 0);
    v11 = (char **)sub_18850((int)v10, "Type", 1, byte_6A84C, 0);
    result = sub_17D00((unsigned int *)a1, v11, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_15B00((unsigned int *)a1, "VERSION,");
    v13 = sub_18850(0, "BMMiner", 1, a10, 0);
    v14 = sub_18850((int)v13, "API", 2, "3.1", 0);
    v15 = sub_18850((int)v14, "Miner", 1, byte_6ABC0, 0);
    v16 = sub_18850((int)v15, "CompileTime", 1, byte_6A74C, 0);
    v17 = (char **)sub_18850((int)v16, "Type", 1, byte_6A84C, 0);
    return sub_17D00((unsigned int *)a1, v17, 0, 0);
  }
  return result;
}

//----- (0001B44C) --------------------------------------------------------
int __fastcall sub_1B44C(int a1, int a2, int a3, int a4)
{
  char *v6; // r1
  int v7; // r8
  const char *v8; // r7
  const char *v9; // r0
  const char *v10; // r9
  const char *v11; // r0
  char **v12; // r0
  int result; // r0

  sub_18AD4((unsigned int *)a1, 78, 0, 0, a4);
  v6 = ",\"COIN\":[";
  if ( !a4 )
    v6 = "COIN,";
  v7 = sub_15B00((unsigned int *)a1, v6);
  v8 = sub_18850(0, "Hash Method", 2, "sha256", 0);
  if ( pthread_mutex_lock(&stru_74504) )
    sub_17604("minecoin", 3633);
  if ( pthread_rwlock_rdlock(&stru_7451C) )
    sub_175A0("minecoin", 3633);
  if ( pthread_mutex_unlock(&stru_74504) )
    sub_17668("minecoin", 3633);
  v9 = sub_18850((int)v8, "Current Block Time", 15, (const char *)&dword_755F0, 1);
  v10 = sub_18850((int)v9, "Current Block Hash", 1, byte_73324, 1);
  if ( pthread_rwlock_unlock(&stru_7451C) )
    sub_176CC("minecoin", 3636);
  off_67ED8();
  v11 = sub_18850((int)v10, "LP", 14, &byte_74502, 0);
  v12 = (char **)sub_18850((int)v11, "Network Difficulty", 24, (const char *)&dbl_68748, 1);
  result = sub_17D00((unsigned int *)a1, v12, a4, 0);
  if ( (a4 & v7) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 68748: using guessed type double dbl_68748;
// 74502: using guessed type char byte_74502;
// 74504: using guessed type pthread_mutex_t stru_74504;
// 755F0: using guessed type int dword_755F0;

//----- (0001B610) --------------------------------------------------------
int __fastcall sub_1B610(unsigned int *a1, int a2, int a3, int a4)
{
  double v4; // d0
  int result; // r0
  _BOOL4 v9; // r1
  int v10; // r4
  float v11; // s14
  int v12; // s15
  int v13; // r10
  int v14; // r1
  const char *v15; // r10
  const char *v16; // r9
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r9
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  int v29; // r2
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  const char *v35; // r0
  const char *v36; // r0
  const char *v37; // r0
  int v38; // r3
  int v39; // r5
  __int64 v40; // r10
  double v41; // d8
  double v42; // r0
  double v43; // d7
  const char *v44; // r5
  __int64 v45; // r0
  double v46; // r0
  double v47; // d7
  const char *v48; // r0
  char **v49; // r0
  int v50; // [sp+Ch] [bp-50h] BYREF
  float v51; // [sp+10h] [bp-4Ch] BYREF
  int v52; // [sp+14h] [bp-48h] BYREF
  double v53; // [sp+18h] [bp-44h] BYREF
  double v54; // [sp+20h] [bp-3Ch] BYREF
  double v55; // [sp+28h] [bp-34h] BYREF
  double v56; // [sp+30h] [bp-2Ch] BYREF
  char s[28]; // [sp+3Ch] [bp-20h] BYREF

  v50 = a2;
  result = sub_17730();
  v9 = (v50 & ~(v50 >> 31)) < result;
  if ( v50 < 0 )
    v9 = 0;
  if ( v9 )
  {
    result = sub_177EC(v50);
    if ( result >= 0 )
    {
      v10 = sub_3046C(result);
      v11 = *(double *)(v10 + 176);
      v51 = v11;
      sub_2CC3C(v10);
      v12 = *(_DWORD *)(v10 + 36);
      v13 = *(_DWORD *)(v10 + 32);
      v14 = *(_DWORD *)(v10 + 96);
      v53 = v4;
      if ( v13 == 1 )
        v15 = "N";
      else
        v15 = "Y";
      *(double *)(v10 + 88) = (double)v12 / v4 * 60.0;
      switch ( v14 )
      {
        case 0:
          v16 = "Alive";
          break;
        case 1:
          v16 = "Sick";
          break;
        case 2:
          v16 = "Dead";
          break;
        case 3:
          v16 = "NoStart";
          break;
        case 4:
          v16 = "Initialising";
          break;
        default:
          v16 = "Unknown";
          break;
      }
      v17 = sub_18850(0, "ASC", 6, (const char *)&v50, 0);
      v18 = sub_18850((int)v17, "Name", 1, *(const char **)(*(_DWORD *)(v10 + 4) + 8), 0);
      v19 = sub_18850((int)v18, "ID", 6, (const char *)(v10 + 8), 0);
      v20 = sub_18850((int)v19, "Enabled", 1, v15, 0);
      v21 = sub_18850((int)v20, "Status", 1, v16, 0);
      v22 = sub_18850((int)v21, "Temperature", 19, (const char *)&v51, 0);
      v54 = *(double *)(v10 + 80) / v53;
      v23 = sub_18850((int)v22, "MHS av", 17, (const char *)&v54, 0);
      sprintf(s, "MHS %ds", dword_68730);
      v24 = sub_18850((int)v23, s, 17, (const char *)(v10 + 48), 0);
      v25 = sub_18850((int)v24, "Accepted", 6, (const char *)(v10 + 36), 0);
      v26 = sub_18850((int)v25, "Rejected", 6, (const char *)(v10 + 40), 0);
      v27 = sub_18850((int)v26, "Hardware Errors", 6, (const char *)(v10 + 44), 0);
      v28 = sub_18850((int)v27, "Utility", 20, (const char *)(v10 + 88), 0);
      if ( *(int *)(v10 + 220) <= 0 )
        v29 = -1;
      else
        v29 = *(_DWORD *)(v10 + 216);
      v52 = v29;
      v30 = sub_18850((int)v28, "Last Share Pool", 6, (const char *)&v52, 0);
      v31 = sub_18850((int)v30, "Last Share Time", 16, (const char *)(v10 + 220), 0);
      v32 = sub_18850((int)v31, "Total MH", 18, (const char *)(v10 + 80), 0);
      v33 = sub_18850((int)v32, "Diff1 Work", 11, (const char *)(v10 + 192), 0);
      v34 = sub_18850((int)v33, "Difficulty Accepted", 24, (const char *)(v10 + 200), 0);
      v35 = sub_18850((int)v34, "Difficulty Rejected", 24, (const char *)(v10 + 208), 0);
      v36 = sub_18850((int)v35, "Last Share Difficulty", 24, (const char *)(v10 + 224), 0);
      v37 = sub_18850((int)v36, "Last Valid Work", 16, (const char *)(v10 + 232), 0);
      v38 = *(_DWORD *)(v10 + 44);
      v39 = (int)v37;
      v40 = *(_QWORD *)(v10 + 192) + v38;
      if ( v40 )
      {
        v41 = (double)v38;
        LODWORD(v42) = sub_4A11C(v40);
        v43 = v41 / v42;
      }
      else
      {
        v43 = 0.0;
      }
      v55 = v43;
      v44 = sub_18850(v39, "Device Hardware%", 25, (const char *)&v55, 0);
      v45 = *(_QWORD *)(v10 + 192);
      if ( v45 )
      {
        LODWORD(v46) = sub_4A11C(v45);
        v47 = *(double *)(v10 + 208) / v46;
      }
      else
      {
        v47 = 0.0;
      }
      v56 = v47;
      v48 = sub_18850((int)v44, "Device Rejected%", 25, (const char *)&v56, 0);
      v49 = (char **)sub_18850((int)v48, "Device Elapsed", 13, (const char *)&v53, 0);
      return sub_17D00(a1, v49, a3, a4);
    }
  }
  return result;
}
// 1B6D0: control flows out of bounds to 1B6D4
// 1B610: too many cbuild loops
// 1B6B0: variable 'v4' is possibly undefined
// 1B95C: variable 'v42' is possibly undefined
// 1B9A4: variable 'v46' is possibly undefined
// 68730: using guessed type int dword_68730;

//----- (0001BD24) --------------------------------------------------------
int __fastcall sub_1BD24(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r9
  int v8; // r3
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  double v12; // d5
  double v13; // d7
  double v14; // d6
  const char *v15; // r0
  double v16; // d5
  double v17; // d7
  double v18; // d6
  char **v19; // r1
  _BOOL4 v20; // r3
  int v21; // r4
  int v22; // r3
  const char *v23; // r6
  const char *v24; // r5
  time_t v25; // r0
  unsigned int v26; // lr
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  const char *v35; // r0
  const char *v36; // r0
  const char *v37; // r0
  const char *v38; // r0
  const char *v39; // r0
  const char *v40; // r0
  const char *v41; // r0
  const char *v42; // r0
  const char *v43; // r0
  int v44; // r6
  char *v45; // r0
  const char *v46; // r0
  const char *v47; // r0
  const char *v48; // r0
  const char *v49; // r0
  const char *v50; // r0
  const char *v51; // r0
  const char *v52; // r0
  const char *v53; // r0
  const char *v54; // r0
  const char *v55; // r6
  const char *v56; // [sp+Ch] [bp-130h]
  int v58; // [sp+1Ch] [bp-120h]
  int v59; // [sp+24h] [bp-118h] BYREF
  double v60; // [sp+28h] [bp-114h] BYREF
  double v61; // [sp+30h] [bp-10Ch] BYREF
  char s[256]; // [sp+38h] [bp-104h] BYREF

  memset(s, 0, sizeof(s));
  if ( !dword_733CC )
    return sub_18AD4((unsigned int *)a1, 8, 0, 0, a4);
  result = sub_18AD4((unsigned int *)a1, 7, 0, 0, a4);
  if ( !a4 )
  {
    v59 = 0;
    if ( dword_733CC <= 0 )
      return result;
    v58 = 0;
    goto LABEL_6;
  }
  result = sub_15B00((unsigned int *)a1, ",\"POOLS\":[");
  v58 = result;
  v59 = 0;
  if ( dword_733CC > 0 )
  {
LABEL_6:
    v7 = 0;
    v8 = 0;
    do
    {
      v21 = *(_DWORD *)(dword_744C8 + 4 * v8);
      if ( !*(_BYTE *)(v21 + 105) )
      {
        v22 = *(_DWORD *)(v21 + 100);
        if ( v22 == 1 )
        {
          v55 = "Alive";
          if ( *(_BYTE *)(v21 + 97) )
            v55 = "Dead";
          v56 = v55;
        }
        else if ( v22 )
        {
          v23 = "Rejecting";
          if ( v22 != 2 )
            v23 = "Unknown";
          v56 = v23;
        }
        else
        {
          v56 = "Disabled";
        }
        v24 = "N";
        if ( *(_DWORD *)(v21 + 108) )
          v24 = "Y";
        if ( *(int *)(v21 + 352) > 0 )
        {
          v25 = time(0);
          v26 = (v25 - *(_DWORD *)(v21 + 352)) & ~((v25 - *(_DWORD *)(v21 + 352)) >> 31);
          sprintf(s, "%d:%02d:%02d", v26 / 0xE10, v26 % 0xE10 / 0x3C, v26 % 0xE10 % 0x3C);
        }
        else
        {
          *(_WORD *)s = 48;
        }
        v27 = sub_18850(v7, "POOL", 6, (const char *)&v59, 0);
        v28 = sub_18850((int)v27, "URL", 0, *(const char **)(v21 + 164), 0);
        v29 = sub_18850((int)v28, "Status", 1, v56, 0);
        v30 = sub_18850((int)v29, "Priority", 6, (const char *)(v21 + 4), 0);
        v31 = sub_18850((int)v30, "Quota", 6, (const char *)(v21 + 56), 0);
        v32 = sub_18850((int)v31, "Long Poll", 1, v24, 0);
        v33 = sub_18850((int)v32, "Getworks", 7, (const char *)(v21 + 116), 0);
        v34 = sub_18850((int)v33, "Accepted", 11, (const char *)(v21 + 8), 0);
        v35 = sub_18850((int)v34, "Rejected", 11, (const char *)(v21 + 16), 0);
        v36 = sub_18850((int)v35, "Discarded", 7, (const char *)(v21 + 124), 0);
        v37 = sub_18850((int)v36, "Stale", 7, (const char *)(v21 + 120), 0);
        v38 = sub_18850((int)v37, "Get Failures", 7, (const char *)(v21 + 128), 0);
        v39 = sub_18850((int)v38, "Remote Failures", 7, (const char *)(v21 + 132), 0);
        v40 = sub_18850((int)v39, "User", 0, *(const char **)(v21 + 172), 0);
        v41 = sub_18850((int)v40, "Last Share Time", 1, s, 0);
        v42 = sub_18850((int)v41, "Diff", 1, (const char *)(v21 + 48), 0);
        v43 = sub_18850((int)v42, "Diff1 Shares", 11, (const char *)(v21 + 40), 0);
        v44 = (int)v43;
        if ( *(_DWORD *)(v21 + 184) )
        {
          v45 = sub_22B68(*(char **)(v21 + 180));
          v46 = sub_18850(v44, "Proxy Type", 2, v45, 0);
          v47 = sub_18850((int)v46, "Proxy", 0, *(const char **)(v21 + 184), 0);
        }
        else
        {
          v54 = sub_18850((int)v43, "Proxy Type", 2, "", *(_DWORD *)(v21 + 184));
          v47 = sub_18850((int)v54, "Proxy", 2, "", 0);
        }
        v48 = sub_18850((int)v47, "Difficulty Accepted", 24, (const char *)(v21 + 72), 0);
        v49 = sub_18850((int)v48, "Difficulty Rejected", 24, (const char *)(v21 + 80), 0);
        v50 = sub_18850((int)v49, "Difficulty Stale", 24, (const char *)(v21 + 88), 0);
        v51 = sub_18850((int)v50, "Last Share Difficulty", 24, (const char *)(v21 + 360), 0);
        v52 = sub_18850((int)v51, "Has Stratum", 14, (const char *)(v21 + 640), 0);
        v53 = sub_18850((int)v52, "Stratum Active", 14, (const char *)(v21 + 641), 0);
        if ( *(_BYTE *)(v21 + 641) )
          v9 = sub_18850((int)v53, "Stratum URL", 0, *(const char **)(v21 + 576), 0);
        else
          v9 = sub_18850((int)v53, "Stratum URL", 2, "", *(_BYTE *)(v21 + 641));
        v10 = sub_18850((int)v9, "Has GBT", 14, (const char *)(v21 + 736), 0);
        v11 = sub_18850((int)v10, "Best Share", 10, (const char *)(v21 + 368), 1);
        v12 = *(double *)(v21 + 80);
        v13 = v12 + *(double *)(v21 + 72) + *(double *)(v21 + 88);
        if ( v13 == 0.0 )
          v14 = 0.0;
        else
          v14 = v12 / v13;
        v60 = v14;
        v15 = sub_18850((int)v11, "Pool Rejected%", 25, (const char *)&v60, 0);
        v16 = *(double *)(v21 + 88);
        v17 = *(double *)(v21 + 72) + *(double *)(v21 + 80) + v16;
        if ( v17 == 0.0 )
          v18 = 0.0;
        else
          v18 = v16 / v17;
        v61 = v18;
        v19 = (char **)sub_18850((int)v15, "Pool Stale%", 25, (const char *)&v61, 0);
        if ( a4 )
          v20 = v59 > 0;
        else
          v20 = 0;
        result = sub_17D00((unsigned int *)a1, v19, a4, v20);
        v7 = result;
      }
      v8 = ++v59;
    }
    while ( v59 < dword_733CC );
  }
  if ( v58 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (0001C5D0) --------------------------------------------------------
int __fastcall sub_1C5D0(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6)
{
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r8
  const char *v16; // r0
  const char *v17; // r0
  double *v18; // r3
  const char *v19; // r0
  const char *v20; // r0
  int v21; // r2
  char **v22; // r1
  int v23; // r3
  int v25; // [sp+Ch] [bp-14h] BYREF
  double v26; // [sp+10h] [bp-10h] BYREF
  double v27; // [sp+18h] [bp-8h] BYREF

  v25 = a2;
  v26 = (dbl_756A8 - dbl_76830) / 1000.0 / (dbl_68720 - dbl_68738);
  v9 = sub_18850(0, "STATS", 6, (const char *)&v25, 0);
  v10 = sub_18850((int)v9, "ID", 1, a3, 0);
  v27 = (double)SLODWORD(flt_6ABA0) + dbl_68720;
  v11 = sub_18850((int)v10, "Elapsed", 13, (const char *)&v27, 0);
  v12 = sub_18850((int)v11, "Calls", 8, a4, 0);
  v13 = sub_18850((int)v12, "Wait", 15, a4 + 4, 0);
  v14 = sub_18850((int)v13, "Max", 15, a4 + 12, 0);
  v15 = sub_18850((int)v14, "Min", 15, a4 + 20, 0);
  if ( !(_BYTE)dword_6ABA4 )
    sprintf((char *)&dword_6ABA4, "%.2f", 0.0);
  v16 = sub_18850((int)v15, "GHS 5s", 1, (const char *)&dword_6ABA4, 0);
  v17 = sub_18850((int)v16, "GHS av", 17, (const char *)&v26, 0);
  v18 = &dbl_6ABB8;
  if ( dbl_6ABB8 < 0.01 )
    v18 = &v26;
  v19 = sub_18850((int)v17, "GHS 30m", 17, (const char *)v18, 0);
  v20 = sub_18850((int)v19, "Mode", 6, (const char *)dword_687F4, 0);
  v22 = (char **)v20;
  if ( a5 )
  {
    if ( v20 )
      v21 = *((_DWORD *)v20 + 4);
    else
      v22 = (char **)a5;
    if ( v20 )
    {
      v23 = *(_DWORD *)(a5 + 16);
      *(_DWORD *)(a5 + 16) = v21;
      *(_DWORD *)(*((_DWORD *)v20 + 4) + 20) = a5;
      *(_DWORD *)(v23 + 20) = v20;
      *((_DWORD *)v20 + 4) = v23;
    }
  }
  sub_17D00(a1, v22, a6, 1);
  return v25 + 1;
}
// 1C7C4: variable 'v21' is possibly undefined
// 68720: using guessed type double dbl_68720;
// 68738: using guessed type double dbl_68738;
// 687F4: using guessed type int dword_687F4[4];
// 6ABA0: using guessed type float flt_6ABA0;
// 6ABA4: using guessed type int dword_6ABA4;
// 6ABB8: using guessed type double dbl_6ABB8;
// 756A8: using guessed type double dbl_756A8;
// 76830: using guessed type double dbl_76830;

//----- (0001C820) --------------------------------------------------------
int __fastcall sub_1C820(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r4
  int v8; // r8
  int v9; // r5
  int v10; // r3
  int (*v11)(void); // r6
  int v12; // r0
  int v13; // [sp+Ch] [bp-20h]
  char s[24]; // [sp+14h] [bp-18h] BYREF

  result = sub_18AD4((unsigned int *)a1, 70, 0, 0, a4);
  if ( !a4 )
  {
    if ( dword_755C0 <= 0 )
      return result;
    v13 = 0;
    goto LABEL_5;
  }
  result = sub_15B00((unsigned int *)a1, ",\"STATS\":[");
  v13 = result;
  if ( dword_755C0 > 0 )
  {
LABEL_5:
    v7 = 0;
    v8 = 0;
    do
    {
      result = sub_3046C(v7);
      v9 = result;
      if ( result )
      {
        v10 = *(_DWORD *)(result + 4);
        if ( v10 )
        {
          v11 = *(int (**)(void))(v10 + 28);
          if ( v11 )
          {
            v12 = v11();
            v10 = *(_DWORD *)(v9 + 4);
            v11 = (int (*)(void))v12;
          }
          sprintf(s, "%s%d", *(const char **)(v10 + 8), *(_DWORD *)(v9 + 8));
          result = sub_1C5D0((unsigned int *)a1, v8, s, (const char *)(v9 + 292), (int)v11, a4);
          v8 = result;
        }
      }
      ++v7;
    }
    while ( dword_755C0 > v7 );
  }
  if ( v13 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 755C0: using guessed type int dword_755C0;

//----- (0001C930) --------------------------------------------------------
int __fastcall sub_1C930(int a1, int a2, int a3, int a4)
{
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  char **v9; // r0
  int result; // r0
  int v11; // r4
  int v12; // r9
  int v13; // r5
  int v14; // r3
  int (*v15)(void); // r6
  int v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  char **v20; // r0
  int v21; // [sp+Ch] [bp-20h]
  char s[24]; // [sp+14h] [bp-18h] BYREF

  sub_18AD4((unsigned int *)a1, 70, 0, 0, a4);
  if ( !a4 )
  {
    v6 = sub_18850(0, "BMMiner", 1, a10, 0);
    v7 = sub_18850((int)v6, "Miner", 1, byte_6ABC0, 0);
    v8 = sub_18850((int)v7, "CompileTime", 1, byte_6A74C, 0);
    v9 = (char **)sub_18850((int)v8, "Type", 1, byte_6A84C, 0);
    result = sub_17D00((unsigned int *)a1, v9, 0, 0);
    if ( dword_755C0 <= 0 )
      return result;
    v21 = 0;
    goto LABEL_5;
  }
  v21 = sub_15B00((unsigned int *)a1, ",\"STATS\":[");
  v17 = sub_18850(0, "BMMiner", 1, a10, 0);
  v18 = sub_18850((int)v17, "Miner", 1, byte_6ABC0, 0);
  v19 = sub_18850((int)v18, "CompileTime", 1, byte_6A74C, 0);
  v20 = (char **)sub_18850((int)v19, "Type", 1, byte_6A84C, 0);
  result = sub_17D00((unsigned int *)a1, v20, 1, 0);
  if ( dword_755C0 > 0 )
  {
LABEL_5:
    v11 = 0;
    v12 = 0;
    do
    {
      result = sub_3046C(v11);
      v13 = result;
      if ( result )
      {
        v14 = *(_DWORD *)(result + 4);
        if ( v14 )
        {
          v15 = *(int (**)(void))(v14 + 28);
          if ( v15 )
          {
            v16 = v15();
            v14 = *(_DWORD *)(v13 + 4);
            v15 = (int (*)(void))v16;
          }
          sprintf(s, "%s%d", *(const char **)(v14 + 8), *(_DWORD *)(v13 + 8));
          result = sub_1C5D0((unsigned int *)a1, v12, s, (const char *)(v13 + 292), (int)v15, a4);
          v12 = result;
        }
      }
      ++v11;
    }
    while ( dword_755C0 > v11 );
  }
  if ( v21 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 755C0: using guessed type int dword_755C0;

//----- (0001CB54) --------------------------------------------------------
int __fastcall sub_1CB54(int a1, int a2, int a3, int a4)
{
  char *v6; // r1
  int v7; // r1
  double v8; // d7
  double v9; // d8
  double v10; // d10
  double v11; // r0
  const char *v12; // r4
  const char *v13; // r0
  const char *v14; // r0
  double *v15; // r3
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r4
  __int64 v35; // r8
  double v36; // d8
  double v37; // r0
  double v38; // d7
  const char *v39; // r4
  double v40; // r0
  double v41; // d7
  const char *v42; // r0
  double v43; // d7
  double v44; // d5
  const char *v45; // r0
  double v46; // d7
  double v47; // d5
  const char *v48; // r0
  char **v49; // r4
  int result; // r0
  int v51; // [sp+10h] [bp-54h]
  __int64 v53; // [sp+18h] [bp-4Ch]
  double v54; // [sp+20h] [bp-44h] BYREF
  double v55; // [sp+28h] [bp-3Ch] BYREF
  double v56; // [sp+30h] [bp-34h] BYREF
  double v57; // [sp+38h] [bp-2Ch] BYREF
  double v58; // [sp+40h] [bp-24h] BYREF
  double v59; // [sp+48h] [bp-1Ch] BYREF
  double v60; // [sp+50h] [bp-14h] BYREF
  double v61; // [sp+58h] [bp-Ch] BYREF

  sub_18AD4((unsigned int *)a1, 11, 0, 0, a4);
  v6 = "SUMMARY,";
  if ( a4 )
    v6 = ",\"SUMMARY\":[";
  v51 = sub_15B00((unsigned int *)a1, v6);
  if ( pthread_mutex_lock(&stru_76838) )
    sub_17604("summary", 2788);
  *(_QWORD *)&dword_76850 = (__int64)(dbl_73370 + dbl_73390 + dbl_766B8);
  v53 = (__int64)(dbl_73370 + dbl_73390 + dbl_766B8);
  LODWORD(v8) = sub_4A11C(qword_755D8);
  HIDWORD(v8) = v7;
  v9 = dbl_68720;
  if ( dbl_68720 == 0.0 )
  {
    v10 = 1.0;
  }
  else
  {
    v8 = v8 / dbl_68720;
    v10 = dbl_68720;
  }
  v54 = v8 * 60.0;
  v55 = (dbl_756A8 - dbl_76830) / 1000.0 / (dbl_68720 - dbl_68738);
  LODWORD(v11) = sub_4A11C(v53);
  v57 = (double)SLODWORD(flt_6ABA0) + v9;
  v56 = v11 / v10 * 60.0;
  v12 = sub_18850(0, "Elapsed", 13, (const char *)&v57, 1);
  if ( !(_BYTE)dword_6ABA4 )
    sprintf((char *)&dword_6ABA4, "%.2f", 0.0);
  v13 = sub_18850((int)v12, "GHS 5s", 1, (const char *)&dword_6ABA4, 0);
  v14 = sub_18850((int)v13, "GHS av", 17, (const char *)&v55, 0);
  v15 = &dbl_6ABB8;
  if ( dbl_6ABB8 < 0.01 )
    v15 = &v55;
  v16 = sub_18850((int)v14, "GHS 30m", 17, (const char *)v15, 0);
  v17 = sub_18850((int)v16, "Found Blocks", 7, (const char *)&dword_7345C, 1);
  v18 = sub_18850((int)v17, "Getworks", 11, (const char *)&dword_755E8, 1);
  v19 = sub_18850((int)v18, "Accepted", 11, (const char *)&qword_755D8, 1);
  v20 = sub_18850((int)v19, "Rejected", 11, (const char *)&qword_767E8, 1);
  v21 = sub_18850((int)v20, "Hardware Errors", 6, (const char *)&dword_73368, 1);
  v22 = sub_18850((int)v21, "Utility", 20, (const char *)&v54, 0);
  v23 = sub_18850((int)v22, "Discarded", 11, (const char *)&qword_73380, 1);
  v24 = sub_18850((int)v23, "Stale", 11, (const char *)&dword_73318, 1);
  v25 = sub_18850((int)v24, "Get Failures", 7, (const char *)&dword_755D0, 1);
  v26 = sub_18850((int)v25, "Local Work", 7, (const char *)&dword_767E0, 1);
  v27 = sub_18850((int)v26, "Remote Failures", 7, (const char *)&dword_74494, 1);
  v28 = sub_18850((int)v27, "Network Blocks", 7, (const char *)&dword_766DC, 1);
  v29 = sub_18850((int)v28, "Total MH", 18, (const char *)&dbl_756A8, 1);
  v30 = sub_18850((int)v29, "Work Utility", 20, (const char *)&v56, 0);
  v31 = sub_18850((int)v30, "Difficulty Accepted", 24, (const char *)&dbl_73370, 1);
  v32 = sub_18850((int)v31, "Difficulty Rejected", 24, (const char *)&dbl_73390, 1);
  v33 = sub_18850((int)v32, "Difficulty Stale", 24, (const char *)&dbl_766B8, 1);
  v34 = sub_18850((int)v33, "Best Share", 10, (const char *)&dword_68FF0, 1);
  v35 = *(_QWORD *)&dword_76850 + dword_73368;
  if ( v35 )
  {
    v36 = (double)dword_73368;
    LODWORD(v37) = sub_4A11C(v35);
    v38 = v36 / v37;
  }
  else
  {
    v38 = 0.0;
  }
  v58 = v38;
  v39 = sub_18850((int)v34, "Device Hardware%", 25, (const char *)&v58, 0);
  if ( *(_QWORD *)&dword_76850 )
  {
    LODWORD(v40) = sub_4A11C(*(__int64 *)&dword_76850);
    v41 = dbl_73390 / v40;
  }
  else
  {
    v41 = 0.0;
  }
  v59 = v41;
  v42 = sub_18850((int)v39, "Device Rejected%", 25, (const char *)&v59, 0);
  v43 = dbl_73390 + dbl_73370 + dbl_766B8;
  if ( v43 == 0.0 )
    v44 = 0.0;
  else
    v44 = dbl_73390 / v43;
  v60 = v44;
  v45 = sub_18850((int)v42, "Pool Rejected%", 25, (const char *)&v60, 0);
  v46 = dbl_73370 + dbl_73390 + dbl_766B8;
  if ( v46 == 0.0 )
    v47 = 0.0;
  else
    v47 = dbl_766B8 / v46;
  v61 = v47;
  v48 = sub_18850((int)v45, "Pool Stale%", 25, (const char *)&v61, 0);
  v49 = (char **)sub_18850((int)v48, "Last getwork", 16, (const char *)&dword_744A0, 0);
  if ( pthread_mutex_unlock(&stru_76838) )
    sub_17668("summary", 2844);
  off_67ED8();
  result = sub_17D00((unsigned int *)a1, v49, a4, 0);
  if ( (a4 & v51) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 1CC1C: variable 'v7' is possibly undefined
// 1CCA4: variable 'v11' is possibly undefined
// 1CF98: variable 'v37' is possibly undefined
// 1D00C: variable 'v40' is possibly undefined
// 67ED8: using guessed type int (*off_67ED8)();
// 68720: using guessed type double dbl_68720;
// 68738: using guessed type double dbl_68738;
// 68FF0: using guessed type int dword_68FF0;
// 6ABA0: using guessed type float flt_6ABA0;
// 6ABA4: using guessed type int dword_6ABA4;
// 6ABB8: using guessed type double dbl_6ABB8;
// 73318: using guessed type int dword_73318;
// 73368: using guessed type int dword_73368;
// 73370: using guessed type double dbl_73370;
// 73380: using guessed type __int64 qword_73380;
// 73390: using guessed type double dbl_73390;
// 7345C: using guessed type int dword_7345C;
// 74494: using guessed type int dword_74494;
// 744A0: using guessed type int dword_744A0;
// 755D0: using guessed type int dword_755D0;
// 755D8: using guessed type __int64 qword_755D8;
// 755E8: using guessed type int dword_755E8;
// 756A8: using guessed type double dbl_756A8;
// 766B8: using guessed type double dbl_766B8;
// 766DC: using guessed type int dword_766DC;
// 767E0: using guessed type int dword_767E0;
// 767E8: using guessed type __int64 qword_767E8;
// 76830: using guessed type double dbl_76830;
// 76838: using guessed type pthread_mutex_t stru_76838;
// 76850: using guessed type int dword_76850;

//----- (0001D184) --------------------------------------------------------
const char *__fastcall sub_1D184(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 0, a3, a4);
}

//----- (0001D1A4) --------------------------------------------------------
const char *__fastcall sub_1D1A4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 1, a3, a4);
}

//----- (0001D1C4) --------------------------------------------------------
const char *__fastcall sub_1D1C4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 2, a3, a4);
}

//----- (0001D1E4) --------------------------------------------------------
const char *__fastcall sub_1D1E4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 3, a3, a4);
}

//----- (0001D204) --------------------------------------------------------
const char *__fastcall sub_1D204(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 4, a3, a4);
}

//----- (0001D224) --------------------------------------------------------
const char *__fastcall sub_1D224(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 5, a3, a4);
}

//----- (0001D244) --------------------------------------------------------
const char *__fastcall sub_1D244(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 6, a3, a4);
}

//----- (0001D264) --------------------------------------------------------
const char *__fastcall sub_1D264(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 7, a3, a4);
}

//----- (0001D284) --------------------------------------------------------
const char *__fastcall sub_1D284(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 8, a3, a4);
}

//----- (0001D2A4) --------------------------------------------------------
const char *__fastcall sub_1D2A4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 9, a3, a4);
}

//----- (0001D2C4) --------------------------------------------------------
const char *__fastcall sub_1D2C4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 10, a3, a4);
}

//----- (0001D2E4) --------------------------------------------------------
const char *__fastcall sub_1D2E4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 11, a3, a4);
}

//----- (0001D304) --------------------------------------------------------
const char *__fastcall sub_1D304(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 12, a3, a4);
}

//----- (0001D324) --------------------------------------------------------
const char *__fastcall sub_1D324(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 13, a3, a4);
}

//----- (0001D344) --------------------------------------------------------
const char *__fastcall sub_1D344(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 14, a3, a4);
}

//----- (0001D364) --------------------------------------------------------
const char *__fastcall sub_1D364(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 15, a3, a4);
}

//----- (0001D384) --------------------------------------------------------
const char *__fastcall sub_1D384(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 16, a3, a4);
}

//----- (0001D3A4) --------------------------------------------------------
const char *__fastcall sub_1D3A4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 17, a3, a4);
}

//----- (0001D3C4) --------------------------------------------------------
const char *__fastcall sub_1D3C4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 18, a3, a4);
}

//----- (0001D3E4) --------------------------------------------------------
const char *__fastcall sub_1D3E4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 19, a3, a4);
}

//----- (0001D404) --------------------------------------------------------
const char *__fastcall sub_1D404(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 20, a3, a4);
}

//----- (0001D424) --------------------------------------------------------
const char *__fastcall sub_1D424(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 21, a3, a4);
}

//----- (0001D444) --------------------------------------------------------
const char *__fastcall sub_1D444(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 22, a3, a4);
}

//----- (0001D464) --------------------------------------------------------
const char *__fastcall sub_1D464(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 23, a3, a4);
}

//----- (0001D484) --------------------------------------------------------
const char *__fastcall sub_1D484(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 24, a3, a4);
}

//----- (0001D4A4) --------------------------------------------------------
const char *__fastcall sub_1D4A4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 25, a3, a4);
}

//----- (0001D4C4) --------------------------------------------------------
const char *__fastcall sub_1D4C4(int a1, const char *a2, const char *a3, char a4)
{
  return sub_18850(a1, a2, 26, a3, a4);
}

//----- (0001D4E4) --------------------------------------------------------
void sub_1D4E4()
{
  ;
}

//----- (0001D538) --------------------------------------------------------
void __fastcall sub_1D538(int *a1)
{
  int v2; // r0
  const char *v3; // r0
  const char *v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  int v29; // [sp+8h] [bp-824h] BYREF
  int v30; // [sp+Ch] [bp-820h] BYREF
  double v31; // [sp+10h] [bp-81Ch] BYREF
  int v32; // [sp+18h] [bp-814h] BYREF
  int v33; // [sp+1Ch] [bp-810h]
  __int64 v34; // [sp+20h] [bp-80Ch] BYREF
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  v2 = *a1;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0;
  v30 = 0;
  v3 = sub_18850(v2, "Elapsed", 13, (const char *)&dbl_68720, 1);
  *a1 = (int)v3;
  v4 = sub_18850((int)v3, "GHS 5s", 1, "14189.74", 0);
  *a1 = (int)v4;
  v31 = 14274.51;
  v5 = sub_18850((int)v4, "GHS av", 17, (const char *)&v31, 1);
  *a1 = (int)v5;
  v6 = sub_18850((int)v5, "Found Blocks", 7, (const char *)&v29, 1);
  *a1 = (int)v6;
  v32 = 20;
  v33 = 0;
  v7 = sub_18850((int)v6, "Getworks", 11, (const char *)&v32, 1);
  *a1 = (int)v7;
  v32 = 82;
  v33 = 0;
  v8 = sub_18850((int)v7, "Accepted", 11, (const char *)&v32, 1);
  *a1 = (int)v8;
  v32 = 0;
  v33 = 0;
  v9 = sub_18850((int)v8, "Rejected", 11, (const char *)&v32, 1);
  *a1 = (int)v9;
  v10 = sub_18850((int)v9, "Hardware Errors", 6, (const char *)&v30, 1);
  *a1 = (int)v10;
  v31 = 5.91;
  v11 = sub_18850((int)v10, "Utility", 20, (const char *)&v31, 0);
  *a1 = (int)v11;
  v32 = 0;
  v33 = 0;
  v12 = sub_18850((int)v11, "Discarded", 11, (const char *)&v32, 1);
  *a1 = (int)v12;
  v32 = 0;
  v33 = 0;
  v13 = sub_18850((int)v12, "Stale", 11, (const char *)&v32, 1);
  *a1 = (int)v13;
  v14 = sub_18850((int)v13, "Get Failures", 7, (const char *)&v29, 1);
  *a1 = (int)v14;
  v15 = sub_18850((int)v14, "Local Work", 7, (const char *)&dword_767E0, 1);
  *a1 = (int)v15;
  v16 = sub_18850((int)v15, "Remote Failures", 7, (const char *)&v29, 1);
  *a1 = (int)v16;
  v17 = sub_18850((int)v16, "Network Blocks", 7, (const char *)&dword_766DC, 1);
  *a1 = (int)v17;
  v18 = sub_18850((int)v17, "Total MH", 18, (const char *)&dbl_756A8, 1);
  *a1 = (int)v18;
  v31 = 0.0;
  v19 = sub_18850((int)v18, "Work Utility", 20, (const char *)&v31, 0);
  *a1 = (int)v19;
  v31 = 1343488.0;
  v20 = sub_18850((int)v19, "Difficulty Accepted", 24, (const char *)&v31, 1);
  *a1 = (int)v20;
  v31 = 16384.0;
  v21 = sub_18850((int)v20, "Difficulty Rejected", 24, (const char *)&v31, 1);
  *a1 = (int)v21;
  v22 = sub_18850((int)v21, "Difficulty Stale", 24, (const char *)&dbl_766B8, 1);
  *a1 = (int)v22;
  v34 = 3432989;
  v23 = sub_18850((int)v22, "Best Share", 10, (const char *)&v34, 1);
  *a1 = (int)v23;
  v31 = 0.0;
  v24 = sub_18850((int)v23, "Device Hardware%", 25, (const char *)&v31, 0);
  *a1 = (int)v24;
  v25 = sub_18850((int)v24, "Device Rejected%", 25, (const char *)&v31, 0);
  *a1 = (int)v25;
  v26 = sub_18850((int)v25, "Pool Rejected%", 25, (const char *)&v31, 0);
  *a1 = (int)v26;
  v27 = sub_18850((int)v26, "Pool Stale%", 25, (const char *)&v31, 0);
  *a1 = (int)v27;
  v28 = sub_18850((int)v27, "Last getwork", 16, (const char *)&dword_744A0, 0);
  *a1 = (int)v28;
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    snprintf(s, 0x800u, "root %d", v28);
    sub_20F58(5, s, 0);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68720: using guessed type double dbl_68720;
// 68BD4: using guessed type char byte_68BD4;
// 744A0: using guessed type int dword_744A0;
// 74500: using guessed type char byte_74500;
// 756A8: using guessed type double dbl_756A8;
// 766B8: using guessed type double dbl_766B8;
// 766DC: using guessed type int dword_766DC;
// 767E0: using guessed type int dword_767E0;

//----- (0001D990) --------------------------------------------------------
int __fastcall sub_1D990(unsigned int *a1, int a2, int a3, int a4)
{
  const char *v4; // r7
  int v6; // r2
  int v8; // r6
  unsigned int v9; // r2
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  char **v25; // r1
  _BOOL4 v26; // r3
  int v28; // [sp+Ch] [bp-4h] BYREF

  v6 = *(_DWORD *)(a3 + 244);
  v8 = a4;
  v28 = a2;
  if ( v6 )
  {
    v9 = *(_DWORD *)(a3 + 248);
    if ( v9 > 8 )
      v4 = (const char *)45680;
    else
      a4 = 41852;
    if ( v9 > 8 )
      HIWORD(v4) = 4;
    else
      HIWORD(a4) = 4;
    if ( v9 <= 8 )
      v4 = *(const char **)(a4 + 4 * v9 + 156);
  }
  else
  {
    v4 = "None";
  }
  v10 = sub_18850(0, "NOTIFY", 6, (const char *)&v28, 0);
  v11 = sub_18850((int)v10, "Name", 1, *(const char **)(*(_DWORD *)(a3 + 4) + 8), 0);
  v12 = sub_18850((int)v11, "ID", 6, (const char *)(a3 + 8), 0);
  v13 = sub_18850((int)v12, "Last Well", 16, (const char *)(a3 + 240), 0);
  v14 = sub_18850((int)v13, "Last Not Well", 16, (const char *)(a3 + 244), 0);
  v15 = sub_18850((int)v14, "Reason Not Well", 1, v4, 0);
  v16 = sub_18850((int)v15, "*Thread Fail Init", 6, (const char *)(a3 + 252), 0);
  v17 = sub_18850((int)v16, "*Thread Zero Hash", 6, (const char *)(a3 + 256), 0);
  v18 = sub_18850((int)v17, "*Thread Fail Queue", 6, (const char *)(a3 + 260), 0);
  v19 = sub_18850((int)v18, "*Dev Sick Idle 60s", 6, (const char *)(a3 + 264), 0);
  v20 = sub_18850((int)v19, "*Dev Dead Idle 600s", 6, (const char *)(a3 + 268), 0);
  v21 = sub_18850((int)v20, "*Dev Nostart", 6, (const char *)(a3 + 272), 0);
  v22 = sub_18850((int)v21, "*Dev Over Heat", 6, (const char *)(a3 + 276), 0);
  v23 = sub_18850((int)v22, "*Dev Thermal Cutoff", 6, (const char *)(a3 + 280), 0);
  v24 = sub_18850((int)v23, "*Dev Comms Error", 6, (const char *)(a3 + 284), 0);
  v25 = (char **)sub_18850((int)v24, "*Dev Throttle", 6, (const char *)(a3 + 288), 0);
  if ( v8 )
    v26 = v28 > 0;
  else
    v26 = 0;
  return sub_17D00(a1, v25, v8, v26);
}
// 1DA74: variable 'v4' is possibly undefined

//----- (0001DB9C) --------------------------------------------------------
int __fastcall sub_1DB9C(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r9
  int v8; // r4
  int v9; // r0
  int v10; // r1

  if ( !dword_755C0 )
    return sub_18AD4((unsigned int *)a1, 10, 0, 0, a4);
  result = sub_18AD4((unsigned int *)a1, 60, 0, 0, a4);
  if ( !a4 )
  {
    if ( dword_755C0 <= 0 )
      return result;
    v7 = 0;
    goto LABEL_6;
  }
  result = sub_15B00((unsigned int *)a1, ",\"NOTIFY\":[");
  v7 = result;
  if ( dword_755C0 > 0 )
  {
LABEL_6:
    v8 = 0;
    do
    {
      v9 = sub_3046C(v8);
      v10 = v8++;
      result = sub_1D990((unsigned int *)a1, v10, v9, a4);
    }
    while ( dword_755C0 > v8 );
  }
  if ( v7 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 755C0: using guessed type int dword_755C0;

//----- (0001DC74) --------------------------------------------------------
int sub_1DC74()
{
  void *v0; // r0
  int result; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = calloc(1u, 0x40u);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc mcast thr");
    sub_20F58(3, v2, 1);
    sub_3EBA0(1);
  }
  result = sub_25164((int)v0, 0, (void *(*)(void *))sub_16D60, v0);
  if ( result )
  {
    strcpy(v2, "API mcast thread create failed");
    sub_20F58(3, v2, 1);
    sub_3EBA0(1);
  }
  return result;
}

//----- (0001DD3C) --------------------------------------------------------
double sub_1DD3C()
{
  double v0; // d7
  double result; // r0

  v0 = dbl_68720;
  result = dbl_756A8;
  if ( dbl_68720 > 0.0 )
    v0 = dbl_68720 - 1.0;
  dbl_76830 = dbl_756A8;
  dbl_68738 = v0;
  return result;
}
// 68720: using guessed type double dbl_68720;
// 68738: using guessed type double dbl_68738;
// 756A8: using guessed type double dbl_756A8;
// 76830: using guessed type double dbl_76830;

//----- (0001DD84) --------------------------------------------------------
void sub_1DD84()
{
  int v0; // r5
  char *v1; // r7
  double v2; // d0
  int v3; // r3
  _BYTE *v4; // r0
  _DWORD *v5; // r0
  char *v6; // r3
  int v7; // r2
  bool v8; // zf
  const char *v9; // r4
  size_t v10; // r0
  unsigned __int8 *v11; // r5
  char *v12; // r0
  char *v13; // r0
  const __int32_t **v14; // r0
  const __int32_t *v15; // r2
  int v16; // r7
  __int32_t v17; // r1
  unsigned __int8 *v18; // r4
  int v19; // r8
  char *v20; // r0
  unsigned __int8 *v21; // r9
  const char *v22; // r5
  _UNKNOWN **v23; // r10
  int v24; // r6
  const char *v25; // t1
  size_t v26; // r0
  int v27; // r5
  char *v28; // r0
  const __int32_t **v29; // r0
  const char *v30; // r5
  _UNKNOWN **v31; // r4
  char *v32; // r7
  const char *v33; // t1
  size_t v34; // r0
  const char *v35; // t1
  char *v36; // r0
  size_t v37; // r0
  __int32_t v38; // r3
  int v39; // r4
  char *v40; // r0
  const char *v41; // r5
  size_t v42; // r0
  char *v43; // r0
  char *v44; // r8
  char *v45; // r2
  size_t v46; // r0
  int v47; // r3
  int v48; // t1
  int v49; // r6
  const char *v50; // r5
  int v51; // r3
  int v52; // t1
  bool v53; // zf
  char *v54; // r0
  char *v55; // r11
  const unsigned __int16 **v56; // r0
  int v57; // r2
  const __int32_t *v58; // r3
  char v59; // r1
  _BYTE *v60; // r4
  int v61; // r8
  char *v62; // r0
  int v63; // r8
  int v64; // r0
  const char **v65; // r4
  char *v66; // r8
  const char *v67; // t1
  const char *v68; // r9
  char *v69; // r0
  const char *v70; // r5
  char *v71; // r0
  _BYTE *v72; // r2
  _BYTE *v73; // r4
  _BYTE *v74; // r1
  _BYTE *v75; // r3
  _BYTE *v76; // r2
  int v77; // r2
  int v78; // lr
  _BYTE *v79; // r3
  int v80; // r1
  int v81; // r1
  _BYTE *v83; // r2
  _BYTE *v84; // r1
  _BYTE *v85; // r4
  _BYTE *v86; // r0
  char v87; // r3
  char v88; // t1
  char v89; // t1
  __int32_t v90; // r2
  struct addrinfo *v91; // r4
  struct addrinfo *i; // r3
  int v93; // r0
  int *v94; // r0
  char *v95; // r0
  time_t v96; // r8
  int *v97; // r0
  int v98; // r7
  int v99; // r4
  _BOOL4 v100; // r9
  const char *v101; // r1
  ssize_t v102; // r0
  int v103; // r5
  const char *v104; // r8
  time_t v105; // r0
  _BYTE *v106; // r3
  int v107; // r3
  char *v108; // r0
  size_t v109; // r0
  char *v110; // r6
  char *v111; // r0
  int v112; // r3
  const char *v113; // r1
  _UNKNOWN **v114; // r5
  int v115; // r4
  const char *v116; // t1
  size_t v117; // r0
  int *v118; // r3
  int v119; // r5
  __int32_t v120; // r2
  int v121; // r9
  int *v122; // r0
  char *v123; // r0
  int *v124; // r0
  char *v125; // r0
  int *v126; // r0
  _DWORD *v127; // r0
  int *v128; // r0
  char *v129; // r0
  const char *v130; // r3
  unsigned int *v131; // r3
  unsigned int v132; // r2
  unsigned int v133; // r2
  int *v134; // r0
  char *v135; // r0
  _DWORD *v136; // r0
  int *v137; // r0
  int v138; // r3
  int v139; // r0
  const __int32_t **v140; // [sp+10h] [bp-16464h]
  unsigned __int8 *v141; // [sp+14h] [bp-16460h]
  int *ptr; // [sp+1Ch] [bp-16458h]
  char *v143; // [sp+20h] [bp-16454h]
  _DWORD *v144; // [sp+28h] [bp-1644Ch]
  __int16 v145; // [sp+34h] [bp-16440h]
  int fd; // [sp+3Ch] [bp-16438h]
  const __int32_t **v147; // [sp+40h] [bp-16434h]
  char *dest; // [sp+44h] [bp-16430h]
  char *v149; // [sp+4Ch] [bp-16428h]
  char *v150; // [sp+58h] [bp-1641Ch]
  unsigned __int8 *v151; // [sp+5Ch] [bp-16418h]
  char *haystack; // [sp+60h] [bp-16414h]
  unsigned __int8 v153; // [sp+76h] [bp-163FEh] BYREF
  char v154; // [sp+77h] [bp-163FDh] BYREF
  const char *v155; // [sp+78h] [bp-163FCh] BYREF
  socklen_t addr_len; // [sp+7Ch] [bp-163F8h] BYREF
  struct addrinfo *ai; // [sp+80h] [bp-163F4h] BYREF
  int v158; // [sp+84h] [bp-163F0h] BYREF
  char service[12]; // [sp+88h] [bp-163ECh] BYREF
  char cp[32]; // [sp+94h] [bp-163E0h] BYREF
  struct addrinfo v161; // [sp+B4h] [bp-163C0h] BYREF
  _BYTE v162[12]; // [sp+D4h] [bp-163A0h] BYREF
  pthread_t th; // [sp+E0h] [bp-16394h]
  char v164; // [sp+114h] [bp-16360h] BYREF
  char v165[99]; // [sp+115h] [bp-1635Fh] BYREF
  char needle[100]; // [sp+178h] [bp-162FCh] BYREF
  struct sockaddr addr; // [sp+1DCh] [bp-16298h] BYREF
  char v168[252]; // [sp+25Ch] [bp-16218h] BYREF
  struct __jmp_buf_tag env; // [sp+358h] [bp-1611Ch] BYREF
  char s[2048]; // [sp+470h] [bp-16004h] BYREF
  char v171[2000]; // [sp+C70h] [bp-15804h] BYREF
  char v172[2000]; // [sp+1470h] [bp-15004h] BYREF
  char v173[2000]; // [sp+1C70h] [bp-14804h] BYREF
  char v174[2000]; // [sp+2470h] [bp-14004h] BYREF
  char v175[2000]; // [sp+2C70h] [bp-13804h] BYREF
  char v176[2000]; // [sp+3470h] [bp-13004h] BYREF
  char v177[1936]; // [sp+3C70h] [bp-12804h] BYREF
  char v178[1936]; // [sp+4470h] [bp-12004h] BYREF
  char v179[1936]; // [sp+4C70h] [bp-11804h] BYREF
  char v180[1936]; // [sp+5470h] [bp-11004h] BYREF
  char v181[1936]; // [sp+5C70h] [bp-10804h] BYREF
  char v182[1936]; // [sp+6470h] [bp-10004h] BYREF
  char v183[1936]; // [sp+6C70h] [bp-F804h] BYREF
  char v184[1936]; // [sp+7470h] [bp-F004h] BYREF
  char v185[1936]; // [sp+7C70h] [bp-E804h] BYREF
  char v186[1936]; // [sp+8470h] [bp-E004h] BYREF
  char v187[1936]; // [sp+8C70h] [bp-D804h] BYREF
  char v188[1936]; // [sp+9470h] [bp-D004h] BYREF
  char v189[1936]; // [sp+9C70h] [bp-C804h] BYREF
  char v190[1936]; // [sp+A470h] [bp-C004h] BYREF
  char v191[1936]; // [sp+AC70h] [bp-B804h] BYREF
  char v192[1936]; // [sp+B470h] [bp-B004h] BYREF
  char v193[1936]; // [sp+BC70h] [bp-A804h] BYREF
  char v194[1936]; // [sp+C470h] [bp-A004h] BYREF
  char v195[1936]; // [sp+CC70h] [bp-9804h] BYREF
  char v196[1936]; // [sp+D470h] [bp-9004h] BYREF
  char v197[1936]; // [sp+DC70h] [bp-8804h] BYREF
  char v198[1936]; // [sp+E470h] [bp-8004h] BYREF
  char v199[1936]; // [sp+EC70h] [bp-7804h] BYREF
  char v200[1936]; // [sp+F470h] [bp-7004h] BYREF
  char v201[1936]; // [sp+FC70h] [bp-6804h] BYREF
  char v202[8080]; // [sp+10470h] [bp-6004h] BYREF
  char v203[8080]; // [sp+12470h] [bp-4004h] BYREF
  _WORD v204[4098]; // [sp+14470h] [bp-2004h] BYREF

  v144 = 0;
  v145 = dword_68818;
  ptr = (int *)malloc(4u);
  v3 = (unsigned __int8)byte_75685;
  *ptr = -1;
  if ( !v3 )
  {
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      snprintf(s, 0x800u, "API not running%s", " - API will not be available");
      sub_20F58(7, s, 0);
    }
    goto LABEL_6;
  }
  v151 = (unsigned __int8 *)malloc(0x10u);
  v4 = malloc(0x10000u);
  *((_DWORD *)v151 + 1) = v4;
  *v4 = 0;
  v151[13] = 0;
  *((_DWORD *)v151 + 2) = v4;
  *(_DWORD *)v151 = 0x10000;
  v151[12] = 1;
  v5 = malloc(0xCu);
  v6 = &byte_68A7C;
  *v5 = v151;
  v7 = dword_68AA0;
  v8 = dword_68AA0 == 0;
  if ( dword_68AA0 )
  {
    v5[2] = dword_68AA0;
    v6 = *(char **)(v7 + 4);
  }
  else
  {
    v5[1] = v5;
    v5[2] = v5;
  }
  if ( v8 )
  {
    *((_DWORD *)v6 + 9) = v5;
  }
  else
  {
    v5[1] = v6;
    *(_DWORD *)(v7 + 4) = v5;
    v6 = (char *)v5[1];
  }
  if ( !v8 )
    *((_DWORD *)v6 + 2) = v5;
  if ( pthread_mutex_init(&stru_68A88, 0) )
  {
    v126 = _errno_location();
    snprintf(v190, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v126, "api.c", "api", 5199);
    sub_20F58(3, v190, 1);
    sub_3EBA0(1);
  }
  if ( _sigsetjmp(&env, 0) )
  {
    sub_17900(ptr);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&env);
LABEL_264:
    freeaddrinfo(ai);
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      snprintf(v176, 0x800u, "API bind to port %d failed (%s)%s", v0, v1, " - API will not be available");
      sub_20F58(3, v176, 0);
    }
    goto LABEL_6;
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&env);
  v9 = (const char *)dword_732E0;
  if ( dword_732E0 )
  {
    v10 = strlen((const char *)dword_732E0) + 1;
  }
  else
  {
    v9 = "";
    v10 = 1;
  }
  dest = (char *)malloc(v10);
  if ( !dest )
  {
    strcpy(v191, "Failed to malloc ipgroups buf");
    sub_20F58(3, v191, 1);
    sub_3EBA0(1);
  }
  v11 = (unsigned __int8 *)dest;
  strcpy(dest, v9);
  if ( *dest )
  {
    do
    {
      v12 = strchr((const char *)v11, 44);
      if ( v12 )
      {
        *v12 = 0;
        v141 = (unsigned __int8 *)(v12 + 1);
      }
      else
      {
        v141 = 0;
      }
      if ( v11[1] != 58 )
      {
        v13 = strchr((const char *)v11, 58);
        if ( v13 )
          *v13 = 0;
        snprintf(v192, 0x800u, "API invalid group name '%s'", v11);
        sub_20F58(3, v192, 1);
        sub_3EBA0(1);
      }
      v14 = _ctype_toupper_loc();
      v15 = *v14;
      v140 = v14;
      v16 = LOBYTE((*v14)[*v11]);
      v17 = (*v14)[v16];
      if ( v17 < (*v14)[65] || v17 > v15[90] )
      {
        snprintf(v193, 0x800u, "API invalid group name '%c'");
        sub_20F58(3, v193, 1);
        sub_3EBA0(1);
      }
      if ( v16 == v15[87] )
      {
        snprintf(v194, 0x800u, "API group name can't be '%c'", v16);
        sub_20F58(3, v194, 1);
        sub_3EBA0(1);
      }
      if ( v16 == v15[82] )
      {
        snprintf(v195, 0x800u, "API group name can't be '%c'", v16);
        sub_20F58(3, v195, 1);
        sub_3EBA0(1);
      }
      if ( *((_DWORD *)&unk_73188 + v15[v16] - v15[65]) )
      {
        snprintf(v196, 0x800u, "API duplicate group name '%c'", *v11);
        sub_20F58(3, v196, 1);
        sub_3EBA0(1);
      }
      v18 = v11 + 2;
      v204[0] = 124;
      if ( v11 != (unsigned __int8 *)-2 && v11[2] )
      {
        v19 = 0;
        v143 = (char *)v204 + 1;
        do
        {
          v20 = strchr((const char *)v18, 58);
          if ( v20 )
          {
            v21 = (unsigned __int8 *)(v20 + 1);
            *v20 = 0;
          }
          else
          {
            v21 = 0;
          }
          if ( *v18 != 42 || v18[1] )
          {
            v22 = (const char *)off_677C8;
            if ( !off_677C8 )
            {
LABEL_104:
              snprintf(v197, 0x800u, "API unknown command '%s' in group '%c'", v18, v16);
              sub_20F58(3, v197, 1);
              sub_3EBA0(1);
            }
            v23 = &off_677C8;
            v24 = 0;
            while ( strcasecmp((const char *)v18, v22) )
            {
              v25 = (const char *)v23[3];
              v23 += 3;
              v22 = v25;
              ++v24;
              if ( !v25 )
                goto LABEL_104;
            }
            sprintf(needle, "|%s|", v22);
            if ( !strstr((const char *)v204, needle) )
            {
              v70 = (const char *)dword_67298[3 * v24 + 332];
              strcpy(v143, v70);
              v71 = &v143[strlen(v70)];
              v71[1] = 0;
              v143 = v71 + 1;
              *v71 = 124;
            }
          }
          else
          {
            v19 = 1;
          }
          if ( !v21 )
            break;
          v18 = v21;
        }
        while ( *v21 );
        if ( v19 && off_677C8 )
        {
          v65 = (const char **)&off_677C8;
          v66 = v143;
          do
          {
            if ( !*((_BYTE *)v65 + 8) )
            {
              sprintf(needle, "|%s|");
              if ( !strstr((const char *)v204, needle) )
              {
                v68 = *v65;
                strcpy(v66, *v65);
                v69 = &v66[strlen(v68)];
                v66 = v69 + 1;
                v69[1] = 0;
                *v69 = 124;
              }
            }
            v67 = v65[3];
            v65 += 3;
          }
          while ( v67 );
        }
      }
      v26 = strlen((const char *)v204);
      v27 = (*v140)[v16] - (*v140)[65];
      v28 = (char *)malloc(v26 + 1);
      *((_DWORD *)&unk_73188 + v27) = v28;
      if ( !v28 )
      {
        strcpy(v198, "Failed to malloc group commands buf");
        sub_20F58(3, v198, 1);
        sub_3EBA0(1);
      }
      strcpy(v28, (const char *)v204);
      if ( !v141 )
        break;
      v11 = v141;
    }
    while ( *v141 );
  }
  v29 = _ctype_toupper_loc();
  v30 = (const char *)off_677C8;
  v147 = v29;
  v204[0] = 124;
  if ( off_677C8 )
  {
    v31 = &off_677C8;
    v32 = (char *)v204 + 1;
    do
    {
      while ( *((_BYTE *)v31 + 8) )
      {
        v33 = (const char *)v31[3];
        v31 += 3;
        v30 = v33;
        if ( !v33 )
          goto LABEL_60;
      }
      strcpy(v32, v30);
      v34 = strlen(v30);
      v35 = (const char *)v31[3];
      v31 += 3;
      v30 = v35;
      v36 = &v32[v34];
      v32 = v36 + 1;
      *v36 = 124;
      v36[1] = 0;
    }
    while ( v35 );
  }
LABEL_60:
  v37 = strlen((const char *)v204) + 1;
  v38 = (*v147)[82];
  if ( (unsigned int)(v38 + 128) < 0x180 )
    v38 = (*v147)[v38];
  v39 = v38 - (*v147)[65];
  v40 = (char *)malloc(v37);
  *((_DWORD *)&unk_73188 + v39) = v40;
  if ( !v40 )
  {
    strcpy(v199, "Failed to malloc noprivgroup commands buf");
    sub_20F58(3, v199, 1);
    sub_3EBA0(1);
  }
  strcpy(v40, (const char *)v204);
  free(dest);
  v41 = (const char *)dword_6ACC8;
  if ( dword_6ACC8 )
  {
    v42 = strlen((const char *)dword_6ACC8);
    v43 = (char *)malloc(v42 + 1);
    v44 = v43;
    if ( !v43 )
    {
      strcpy(v200, "Failed to malloc ipaccess buf");
      sub_20F58(3, v200, 1);
      sub_3EBA0(1);
    }
    strcpy(v43, v41);
    v45 = v44 - 1;
    v46 = 1;
    while ( 1 )
    {
      v48 = (unsigned __int8)*++v45;
      v47 = v48;
      if ( !v48 )
        break;
      if ( v47 == 44 )
        ++v46;
    }
    dword_68A80 = (int)calloc(v46, 0x24u);
    if ( !dword_68A80 )
    {
      strcpy(v201, "Failed to calloc ipaccess");
      sub_20F58(3, v201, 1);
      sub_3EBA0(1);
    }
    v49 = 0;
    v50 = v44;
    v149 = v44;
    dword_68A84 = 0;
    while ( 1 )
    {
      v51 = *(unsigned __int8 *)v50;
      if ( !*v50 )
      {
LABEL_96:
        free(v149);
        if ( v49 )
          goto LABEL_97;
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
        {
          snprintf(v171, 0x800u, "API not running (no valid IPs specified)%s", " - API will not be available");
          sub_20F58(4, v171, 0);
        }
LABEL_6:
        free(ptr);
        return;
      }
      while ( 1 )
      {
        v53 = v51 == 9;
        if ( v51 != 9 )
          v53 = v51 == 32;
        if ( !v53 )
          break;
        v52 = *(unsigned __int8 *)++v50;
        v51 = v52;
      }
      if ( v51 != 44 )
        break;
      ++v50;
LABEL_95:
      if ( !v50 )
        goto LABEL_96;
    }
    v54 = strchr(v50, 44);
    if ( v54 )
    {
      v55 = v54 + 1;
      *v54 = 0;
    }
    else
    {
      v55 = 0;
    }
    v56 = _ctype_b_loc();
    v57 = *(unsigned __int8 *)v50;
    v58 = *v147;
    v59 = *((_BYTE *)*v147 + 328);
    if ( ((*v56)[v57] & 0x400) != 0 && v50[1] == 58 )
    {
      v90 = v58[v57];
      if ( v90 == v58[87] || *((_DWORD *)&unk_73188 + v90 - v58[65]) )
        v59 = v90;
      v50 += 2;
    }
    v60 = (_BYTE *)(dword_68A80 + 36 * v49);
    v60[32] = v59;
    v61 = *(unsigned __int8 *)v50;
    if ( v61 == 48 )
    {
      if ( v50[1] == 47 && v50[2] == 48 && !v50[3] )
      {
        v72 = v60 + 15;
        v73 = v60 - 1;
        v74 = v72;
        do
        {
          *++v73 = 0;
          *++v72 = 0;
        }
        while ( v73 != v74 );
        goto LABEL_118;
      }
      v62 = strchr(v50, 47);
      if ( v62 )
        goto LABEL_88;
    }
    else
    {
      v62 = strchr(v50, 47);
      if ( v62 )
        goto LABEL_86;
    }
    v75 = v60 + 15;
    do
      *++v75 = -1;
    while ( v60 + 31 != v75 );
    v61 = *(unsigned __int8 *)v50;
    v62 = (char *)&v50[strlen(v50)];
LABEL_86:
    if ( v61 == 91 && *(v62 - 1) == 93 )
    {
      v63 = 1;
      *v50++ = 0;
      *(v62 - 1) = 0;
LABEL_89:
      if ( *v62 )
      {
        *v62 = 0;
        v64 = strtol(v62 + 1, 0, 10);
        if ( v64 <= 0 )
          goto LABEL_94;
        if ( !v63 )
          v64 += 96;
        if ( v64 > 128 )
        {
LABEL_94:
          v50 = v55;
          goto LABEL_95;
        }
        v76 = v60 + 15;
        do
          *++v76 = 0;
        while ( v60 + 31 != v76 );
        v77 = 0;
        v78 = 7;
        while ( v64-- != 0 )
        {
          v79 = &v60[v77];
          v80 = (unsigned __int8)v60[v77 + 16];
          if ( !v78 )
            ++v77;
          v81 = v80 | (1 << v78);
          if ( v78 )
            --v78;
          else
            v78 = 7;
          v79[16] = v81;
        }
      }
      v83 = v60 - 1;
      do
        *++v83 = 0;
      while ( v60 + 15 != v83 );
      if ( v63 )
      {
        if ( inet_pton(10, v50, v60) == 1 )
          goto LABEL_137;
      }
      else
      {
        sprintf(cp, "::ffff:%s", v50);
        v49 = dword_68A84;
        v60 = (_BYTE *)(dword_68A80 + 36 * dword_68A84);
        if ( inet_pton(10, cp, v60) == 1 )
        {
LABEL_137:
          v84 = v60 + 15;
          v85 = v60 - 1;
          v86 = v84;
          do
          {
            v88 = *++v85;
            v87 = v88;
            v89 = *++v84;
            *v85 = v87 & v89;
          }
          while ( v85 != v86 );
LABEL_118:
          ++v49;
          v50 = v55;
          dword_68A84 = v49;
          goto LABEL_95;
        }
      }
      goto LABEL_94;
    }
LABEL_88:
    v63 = 0;
    goto LABEL_89;
  }
LABEL_97:
  v0 = v145;
  sub_23B9C();
  sprintf(service, "%d", v145);
  memset(&v161.ai_family, 0, 28);
  v161.ai_flags = 1;
  if ( getaddrinfo(off_68814, service, &v161, &ai) )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      snprintf(v172, 0x800u, "API failed to resolve %s", off_68814);
      sub_20F58(3, v172, 0);
    }
    goto LABEL_6;
  }
  v91 = ai;
  if ( ai )
  {
    for ( i = ai; ; i = ai )
    {
      v93 = socket(i->ai_family, 1, 0);
      *ptr = v93;
      if ( v93 > 0 )
        break;
      v91 = v91->ai_next;
      if ( !v91 )
        goto LABEL_233;
    }
  }
  else
  {
    v93 = *ptr;
LABEL_233:
    if ( v93 == -1 )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        v122 = _errno_location();
        v123 = strerror(*v122);
        snprintf(v173, 0x800u, "API initialisation failed (%s)%s", v123, " - API will not be available");
        sub_20F58(3, v173, 0);
      }
      freeaddrinfo(ai);
      free(ptr);
      return;
    }
    v91 = 0;
  }
  v158 = 1;
  if ( setsockopt(v93, 1, 2, &v158, 4u) < 0 && byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    v94 = _errno_location();
    v95 = strerror(*v94);
    snprintf(v174, 0x800u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v95);
    sub_20F58(7, v174, 0);
  }
  v96 = time(0);
  while ( bind(*ptr, v91->ai_addr, v91->ai_addrlen) < 0 )
  {
    v97 = _errno_location();
    v1 = strerror(*v97);
    if ( time(0) - v96 > 61 )
      goto LABEL_264;
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
    {
      snprintf(v175, 0x800u, "API bind to port %d failed - trying again in 30sec", v145);
      sub_20F58(4, v175, 0);
    }
    sub_23B9C();
  }
  freeaddrinfo(ai);
  if ( listen(*ptr, 100) < 0 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      v134 = _errno_location();
      v135 = strerror(*v134);
      snprintf(v177, 0x800u, "API3 initialisation failed (%s)%s", v135, " - API will not be available");
      sub_20F58(3, v177, 0);
    }
    close(*ptr);
    free(ptr);
    return;
  }
  if ( dword_6ACC8 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
    {
      snprintf(v178, 0x800u, "API running in IP access mode on port %d (%d)", v145, *ptr);
      sub_20F58(4, v178, 0);
    }
  }
  else if ( byte_767BC )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
    {
      snprintf(v179, 0x800u, "API running in UNRESTRICTED read access mode on port %d (%d)", v145, *ptr);
      sub_20F58(4, v179, 0);
    }
  }
  else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
  {
    snprintf(v180, 0x800u, "API running in local read access mode on port %d (%d)", v145, *ptr);
    sub_20F58(4, v180, 0);
  }
  if ( byte_7347D )
    sub_1DC74();
  v98 = 0;
  dword_68AA4 = (int)sub_200F8("StrBufs", 12, 2, 0, 0, "api.c", "api", 5311);
  while ( 1 )
  {
    v99 = (unsigned __int8)byte_68A7C;
    if ( byte_68A7C )
      goto LABEL_283;
    addr_len = 128;
    fd = accept(*ptr, &addr, &addr_len);
    if ( fd < 0 )
      break;
    v100 = sub_15FF8(&addr, &v155, &v153);
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      v101 = "Accepted";
      if ( !v100 )
        v101 = "Ignored";
      snprintf(v182, 0x800u, "API: connection from %s - %s", v155, v101);
      sub_20F58(7, v182, 0);
    }
    if ( v100 )
    {
      v102 = recv(fd, v202, 0xFFFu, 0);
      v103 = v102;
      if ( v102 >= 0 )
      {
        v8 = byte_68BD5 == 0;
        v202[v102] = 0;
        if ( !v8 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
        {
          snprintf(v184, 0x800u, "API: recv command: (%d) '%s'", v102, v202);
          sub_20F58(7, v184, 0);
        }
        v104 = v202;
        v105 = time(0);
        v106 = (_BYTE *)*((_DWORD *)v151 + 1);
        *((_DWORD *)v151 + 2) = v106;
        dword_68AA8 = v105;
        *v106 = 0;
        v107 = (unsigned __int8)v202[0];
        v151[13] = 0;
        if ( v107 == 123 )
        {
          v127 = sub_47320((int)v202, v103, 0, v168);
          v144 = v127;
          if ( v127 && !*v127 )
          {
            v136 = (_DWORD *)sub_480FC(v127, "command");
            if ( v136 )
            {
              if ( *v136 == 2 )
              {
                v104 = (const char *)sub_48630(v136);
                v137 = (int *)sub_480FC(v144, "parameter");
                if ( v137 )
                {
                  v138 = *v137;
                  if ( *v137 == 2 )
                  {
                    v150 = (char *)sub_48630(v137);
                  }
                  else if ( v138 == 3 )
                  {
                    v139 = sub_4888C((int)v137);
                    v150 = v203;
                    sprintf(v203, "%d", v139);
                  }
                  else if ( v138 == 4 )
                  {
                    sub_48938();
                    v150 = v203;
                    sprintf(v203, "%f", v2);
                  }
                  else
                  {
                    v150 = 0;
                  }
                }
                else
                {
                  v150 = 0;
                }
                goto LABEL_200;
              }
              sub_18AD4((unsigned int *)v151, 14, 0, 0, 1u);
            }
            else
            {
              sub_18AD4((unsigned int *)v151, 24, 0, 0, 1u);
            }
          }
          else
          {
            sub_18AD4((unsigned int *)v151, 23, 0, 0, 1u);
          }
          sub_16F14(*((const char **)v151 + 1), v151[13], fd, 1);
LABEL_277:
          if ( v98 )
            sub_16F14(*((const char **)v151 + 1), v151[13], fd, v100);
LABEL_225:
          if ( v144 )
            v121 = v100;
          else
            v121 = 0;
          if ( v121 )
          {
            if ( !*v144 && v144[1] != -1 )
            {
              v131 = v144 + 1;
              __dmb(0xBu);
              do
              {
                v132 = __ldrex(v131);
                v133 = v132 - 1;
              }
              while ( __strex(v133, v131) );
              if ( !v133 )
                sub_48A34(v144);
            }
          }
          goto LABEL_230;
        }
        v108 = strchr(v202, 124);
        if ( v108 )
        {
          v100 = v99;
          *v108 = 0;
          v150 = v108 + 1;
        }
        else
        {
          v150 = 0;
          v100 = v99;
        }
LABEL_200:
        haystack = strchr(v104, 43);
        if ( haystack )
        {
          v98 = 1;
          v154 = 1;
          v109 = strlen(v104);
          haystack = (char *)malloc(v109 + 3);
          if ( !haystack )
          {
            snprintf(v185, 0x800u, "OOM cmdsbuf in %s %s():%d", "api.c", "api", 5422);
            sub_20F58(3, v185, 1);
            sub_3EBA0(1);
          }
          v150 = 0;
          *(_WORD *)haystack = 124;
        }
        else
        {
          v98 = v99;
          v154 = 0;
        }
        v110 = (char *)v104;
        if ( !v98 )
        {
          v113 = (const char *)off_677C8;
          if ( off_677C8 )
            goto LABEL_214;
          goto LABEL_247;
        }
        while ( 2 )
        {
          v111 = strchr(v110, 43);
          if ( v111 )
          {
            v104 = v111 + 1;
            *v111 = 0;
          }
          else
          {
            v104 = 0;
          }
          if ( !*v110 )
          {
LABEL_208:
            if ( v104 )
              v112 = v98 & 1;
            else
              v112 = 0;
            v110 = (char *)v104;
            if ( !v112 )
              goto LABEL_277;
            continue;
          }
          break;
        }
        v113 = (const char *)off_677C8;
        if ( off_677C8 )
        {
LABEL_214:
          v114 = &off_677C8;
          v115 = 0;
          while ( strcmp(v110, v113) )
          {
            v116 = (const char *)v114[3];
            v114 += 3;
            v113 = v116;
            ++v115;
            if ( !v116 )
            {
              if ( !v98 )
                goto LABEL_247;
              goto LABEL_246;
            }
          }
          sprintf(&v164, "|%s|", v110);
          if ( v98 )
          {
            if ( strstr(haystack, &v164) )
              goto LABEL_208;
            v117 = strlen(haystack);
            strcpy((char *)stpcpy(&haystack[v117], v110), "|");
            sub_15E08((unsigned int *)v151, v110, v100, &v154);
            v118 = &dword_67298[3 * v115];
            if ( !*((_BYTE *)v118 + 1337) )
            {
              sub_18AD4((unsigned int *)v151, 45, *((unsigned __int8 *)v118 + 1337), v118[332], v100);
              sub_16D98((int)v151, v100);
              goto LABEL_224;
            }
          }
          v119 = v153;
          v120 = (*v147)[v153];
          if ( v120 == (*v147)[87]
            || strstr(*((const char **)&unk_73188 + v120 - (*v147)[65]), &v164)
            || !strncmp(v165, "pool_change", 0xBu) )
          {
            ((void (__fastcall *)(unsigned __int8 *, int, char *, _BOOL4, int))dword_67298[3 * v115 + 333])(
              v151,
              fd,
              v150,
              v100,
              v119);
          }
          else
          {
            sub_18AD4((unsigned int *)v151, 45, 0, dword_67298[3 * v115 + 332], v100);
            if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
            {
              snprintf(
                v186,
                0x800u,
                "API: access denied to '%s' for '%s' command",
                v155,
                (const char *)dword_67298[3 * v115 + 332]);
              sub_20F58(7, v186, 0);
            }
          }
          if ( (unsigned __int8)v98 == 1 )
            goto LABEL_248;
        }
        else
        {
LABEL_246:
          sub_15E08((unsigned int *)v151, v110, v100, &v154);
LABEL_247:
          sub_18AD4((unsigned int *)v151, 14, 0, 0, v100);
          if ( v98 )
          {
LABEL_248:
            sub_16D98((int)v151, v100);
LABEL_224:
            if ( !v98 )
              goto LABEL_225;
            goto LABEL_208;
          }
        }
        sub_16F14(*((const char **)v151 + 1), v151[13], fd, v100);
        goto LABEL_224;
      }
      v202[0] = 0;
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        v124 = _errno_location();
        v125 = strerror(*v124);
        snprintf(v183, 0x800u, "API: recv failed: %s", v125);
        sub_20F58(7, v183, 0);
      }
    }
LABEL_230:
    close(fd);
  }
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    v128 = _errno_location();
    v129 = strerror(*v128);
    snprintf(v181, 0x800u, "API failed (%s)%s (%d)", v129, " - API will not be available", *ptr);
    sub_20F58(3, v181, 0);
  }
LABEL_283:
  _pthread_unregister_cancel((__pthread_unwind_buf_t *)&env);
  sub_17900(ptr);
  free(ptr);
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    if ( byte_68A7D )
    {
      v130 = "QUIT";
    }
    else if ( byte_68A7E )
    {
      v130 = "RESTART";
    }
    else
    {
      v130 = "UNKNOWN!";
      if ( byte_68A7C )
        v130 = (const char *)&unk_4A450;
    }
    snprintf(v187, 0x800u, "API: terminating due to: %s", v130);
    sub_20F58(7, v187, 0);
  }
  if ( pthread_mutex_lock(&stru_68A88) )
    sub_17604("api", 5521);
  if ( byte_68A7E )
  {
    if ( sub_25164((int)v162, 0, (void *(*)(void *))sub_17B7C, v162) )
    {
      if ( !pthread_mutex_unlock(&stru_68A88) )
      {
        off_67ED8();
        strcpy(v188, "API failed to initiate a restart - aborting");
        sub_20F58(3, v188, 1);
        sub_3EBA0(1);
      }
      sub_17668("api", 5527);
    }
  }
  else
  {
    if ( !byte_68A7D )
      goto LABEL_297;
    if ( sub_25164((int)v162, (const pthread_attr_t *)(unsigned __int8)byte_68A7E, (void *(*)(void *))sub_179F4, v162) )
    {
      if ( pthread_mutex_unlock(&stru_68A88) )
        sub_17668("api", 5536);
      off_67ED8();
      strcpy(v189, "API failed to initiate a clean quit - aborting");
      sub_20F58(3, v189, 1);
      sub_3EBA0(1);
    }
  }
  pthread_detach(th);
LABEL_297:
  if ( pthread_mutex_unlock(&stru_68A88) )
    sub_17668("api", 5542);
  off_67ED8();
}
// 1EF78: conditional instruction was optimized away because r7.4 is in (1..FF)
// 1F4B4: variable 'v0' is possibly undefined
// 1F4B4: variable 'v1' is possibly undefined
// 1FC70: variable 'v2' is possibly undefined
// 12034: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 67298: using guessed type int dword_67298[];
// 677C8: using guessed type _UNKNOWN *off_677C8;
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68730: using guessed type int dword_68730;
// 68814: using guessed type char *off_68814;
// 68818: using guessed type int dword_68818;
// 68A7C: using guessed type char byte_68A7C;
// 68A7D: using guessed type char byte_68A7D;
// 68A7E: using guessed type char byte_68A7E;
// 68A80: using guessed type int dword_68A80;
// 68A84: using guessed type int dword_68A84;
// 68AA0: using guessed type int dword_68AA0;
// 68AA4: using guessed type int dword_68AA4;
// 68AA8: using guessed type int dword_68AA8;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 6ACC8: using guessed type int dword_6ACC8;
// 732E0: using guessed type int dword_732E0;
// 7347D: using guessed type char byte_7347D;
// 74500: using guessed type char byte_74500;
// 75685: using guessed type char byte_75685;
// 767BC: using guessed type char byte_767BC;

//----- (0001FD14) --------------------------------------------------------
void *__fastcall sub_1FD14(const char **a1, const char *a2, const char *a3, int a4)
{
  void *result; // r0
  int v6; // r3
  const char *v7; // r2
  signed int v8; // r6
  char *v9; // r0
  int v10; // r1
  const char *v11; // r0
  char *v12; // r5
  const char *v13; // r3
  const char *v14; // r1
  __int64 v15; // r2
  int v16; // r0
  int v17; // r3
  int v18; // r2
  const char *v19; // r3
  char *v20; // r0
  int v21; // r1
  const char *v22; // r0
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = (void *)*((unsigned __int8 *)a1 + 4);
  if ( result )
  {
    snprintf(
      s,
      0x800u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *a1,
      "k_alloc_items",
      a2,
      a3,
      a4,
      "klist.c",
      "k_alloc_items",
      19);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v6 = (int)a1[10];
  if ( v6 <= 0 )
  {
    v8 = (signed int)a1[9];
  }
  else
  {
    v7 = a1[6];
    if ( v6 <= (int)v7 )
      return result;
    v8 = (signed int)a1[9];
    if ( v6 < (int)&v7[v8] )
      v8 = v6 - (_DWORD)v7;
  }
  v9 = (char *)a1[13];
  v10 = (int)(a1[12] + 1);
  a1[12] = (const char *)v10;
  v11 = (const char *)realloc(v9, 4 * v10);
  a1[13] = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x800u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *a1,
      a1[12],
      "klist.c",
      "k_alloc_items",
      33);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v12 = (char *)calloc(v8, 0x10u);
  if ( !v12 )
  {
    snprintf(
      s,
      0x800u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *a1,
      v8,
      a1[6],
      a1[10],
      "klist.c",
      "k_alloc_items",
      38);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  *(_DWORD *)&a1[13][4 * (_DWORD)(a1[12] + 0x3FFFFFFF)] = v12;
  v13 = a1[6];
  v14 = *a1;
  a1[7] = (const char *)v8;
  a1[8] = (const char *)v8;
  a1[6] = &v13[v8];
  *(_DWORD *)v12 = v14;
  *((_DWORD *)v12 + 1) = 0;
  *((_DWORD *)v12 + 2) = v12 + 16;
  if ( v8 > 2 )
  {
    HIDWORD(v15) = v12 + 32;
    do
    {
      LODWORD(v15) = HIDWORD(v15) - 32;
      *(_DWORD *)(HIDWORD(v15) - 16) = v14;
      *(_QWORD *)(HIDWORD(v15) - 12) = v15;
      HIDWORD(v15) += 16;
    }
    while ( (char *)HIDWORD(v15) != &v12[16 * v8] );
  }
  v16 = *((unsigned __int8 *)a1 + 44);
  v17 = 16 * (v8 + 0xFFFFFFF);
  *(_DWORD *)&v12[v17] = v14;
  a1[3] = v12;
  v18 = v17 - 16;
  v19 = &v12[v17];
  *((_DWORD *)v19 + 1) = &v12[v18];
  *((_DWORD *)v19 + 2) = 0;
  if ( v16 )
    a1[4] = v19;
  do
  {
    v20 = (char *)a1[15];
    v21 = (int)(a1[14] + 1);
    a1[14] = (const char *)v21;
    v22 = (const char *)realloc(v20, 4 * v21);
    a1[15] = v22;
    if ( !v22 )
    {
      snprintf(
        s,
        0x800u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *a1,
        a1[14],
        "klist.c",
        "k_alloc_items",
        69);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
    result = calloc(1u, (size_t)a1[5]);
    *((_DWORD *)v12 + 3) = result;
    if ( !result )
    {
      snprintf(s, 0x800u, "List %s failed to calloc item data in %s %s():%d", *a1, "klist.c", "k_alloc_items", 73);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
    *(_DWORD *)&a1[15][4 * (_DWORD)(a1[14] + 0x3FFFFFFF)] = result;
    v12 = (char *)*((_DWORD *)v12 + 2);
  }
  while ( v12 );
  return result;
}

//----- (00020050) --------------------------------------------------------
_DWORD *__fastcall sub_20050(int a1)
{
  _DWORD *result; // r0
  const char *v3; // r3
  int v4; // r12
  char v5; // r1
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = calloc(1u, 0x40u);
  v3 = *(const char **)a1;
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to calloc store for %s in %s %s():%d", v3, "klist.c", "k_new_store", 85);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_BYTE *)(a1 + 44);
  *result = v3;
  result[2] = v4;
  *((_BYTE *)result + 44) = v5;
  *((_BYTE *)result + 4) = 1;
  return result;
}

//----- (000200F8) --------------------------------------------------------
_BYTE *__fastcall sub_200F8(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8)
{
  _BYTE *v12; // r0
  _BYTE *v13; // r4
  pthread_mutex_t *v14; // r0
  pthread_mutex_t *v15; // r5
  int *v17; // r0
  int *v18; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( a3 <= 0 )
  {
    snprintf(
      s,
      0x800u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      a1,
      a3,
      "klist.c",
      "_k_new_list",
      100);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( a4 < 0 )
  {
    snprintf(
      s,
      0x800u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      a1,
      a4,
      "klist.c",
      "_k_new_list",
      103);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v12 = calloc(1u, 0x40u);
  v13 = v12;
  if ( !v12 )
  {
    snprintf(s, 0x800u, "Failed to calloc list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 107);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v12[4] = 0;
  v14 = (pthread_mutex_t *)calloc(1u, 0x38u);
  v15 = v14;
  *((_DWORD *)v13 + 2) = v14;
  if ( !v14 )
  {
    snprintf(s, 0x800u, "Failed to calloc lock for list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 113);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( pthread_mutex_init(v14, 0) )
  {
    v18 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v18, "klist.c", "_k_new_list", 115);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&v15[1], 0) )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v17, "klist.c", "_k_new_list", 115);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  *(_DWORD *)v13 = a1;
  *((_DWORD *)v13 + 5) = a2;
  *((_DWORD *)v13 + 9) = a3;
  *((_DWORD *)v13 + 10) = a4;
  v13[44] = a5;
  sub_1FD14((const char **)v13, a6, a7, a8);
  return v13;
}

//----- (000203A8) --------------------------------------------------------
int __fastcall sub_203A8(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r12
  int v6; // r3

  v5 = *(_DWORD *)(a1 + 12);
  if ( !v5 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      return 0;
    sub_1FD14((const char **)a1, a2, a3, a4);
    v5 = *(_DWORD *)(a1 + 12);
    if ( !v5 )
      return 0;
  }
  v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 0;
  }
  else if ( *(_BYTE *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return v5;
}

//----- (00020430) --------------------------------------------------------
int __fastcall sub_20430(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r0
  int v6; // r4

  v5 = sub_203A8(a1, a2, a3, a4);
  v6 = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(a1 + 20));
  return v6;
}

//----- (0002045C) --------------------------------------------------------
int __fastcall sub_2045C(int a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( !*(_BYTE *)(a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_tail",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_unlink_tail",
      181);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 4);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v6 )
      a3 = 0;
    else
      *(_DWORD *)(a1 + 12) = 0;
    if ( v6 )
      *(_DWORD *)(v6 + 8) = a3;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    --*(_DWORD *)(a1 + 28);
  }
  return result;
}

//----- (00020524) --------------------------------------------------------
const char *__fastcall sub_20524(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  int v7; // r3
  int v8; // r3
  __int64 v9; // r2
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_add_head",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_head",
      205);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 12);
  if ( v7 )
    *(_DWORD *)(v7 + 4) = a2;
  v8 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = a2;
  if ( v8 && !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = a2;
  v9 = *(_QWORD *)(a1 + 28);
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)(a1 + 28) = v9;
  return result;
}

//----- (000205F8) --------------------------------------------------------
const char **__fastcall sub_205F8(const char **result, int a2, const char *a3, const char *a4, int a5)
{
  const char *v6; // r1
  const char *v7; // r3
  const char *v8; // r3
  const char *v9; // r3
  bool v10; // zf
  __int64 v11; // r2
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v6 = *(const char **)a2;
  if ( v6 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      v6,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( !*((_BYTE *)result + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v7 = result[4];
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = v7;
  v8 = result[4];
  if ( v8 )
    *((_DWORD *)v8 + 2) = a2;
  v9 = result[3];
  result[4] = (const char *)a2;
  v10 = v9 == 0;
  v11 = *(_QWORD *)(result + 7);
  if ( v10 )
    result[3] = (const char *)a2;
  LODWORD(v11) = v11 + 1;
  ++HIDWORD(v11);
  *(_QWORD *)(result + 7) = v11;
  return result;
}

//----- (00020744) --------------------------------------------------------
const char **__fastcall sub_20744(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  __int64 v9; // r2
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_before",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      262);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      267);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  *(_DWORD *)(a2 + 8) = a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  v8 = *(_DWORD *)(a3 + 4);
  if ( v8 )
    *(_DWORD *)(v8 + 8) = a2;
  else
    result[3] = (const char *)a2;
  *(_DWORD *)(a3 + 4) = a2;
  v9 = *(_QWORD *)(result + 7);
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)(result + 7) = v9;
  return result;
}

//----- (0002088C) --------------------------------------------------------
const char **__fastcall sub_2088C(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  __int64 v9; // r2
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_after",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      286);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      291);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  v8 = *(_DWORD *)(a3 + 8);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = a2;
  }
  else if ( *((_BYTE *)result + 44) )
  {
    result[4] = (const char *)a2;
  }
  *(_DWORD *)(a3 + 8) = a2;
  v9 = *(_QWORD *)(result + 7);
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)(result + 7) = v9;
  return result;
}

//----- (000209E0) --------------------------------------------------------
const char *__fastcall sub_209E0(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  __int64 v7; // r2
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_item",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_unlink_item",
      312);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v7 = *(_QWORD *)(a2 + 4);
  if ( (_DWORD)v7 )
  {
    *(_DWORD *)(v7 + 8) = HIDWORD(v7);
    HIDWORD(v7) = *(_DWORD *)(a2 + 8);
  }
  if ( HIDWORD(v7) )
    *(_DWORD *)(HIDWORD(v7) + 4) = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 12) == a2 )
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)(a1 + 44) && *(_DWORD *)(a1 + 16) == a2 )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return result;
}

//----- (00020ACC) --------------------------------------------------------
const char *__fastcall sub_20ACC(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  int v9; // r2
  const char *v10; // r3
  const char *v11; // r1
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *a1;
  v8 = *(const char **)a2;
  if ( result != v8 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_head",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_head",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( a1[3] )
  {
    v9 = *(_DWORD *)(a2 + 12);
    v10 = a1[4];
    if ( v9 )
      *(_DWORD *)(v9 + 4) = v10;
    else
      *(_DWORD *)(a2 + 16) = v10;
    if ( v9 )
      v9 = *(_DWORD *)(a2 + 12);
    *((_DWORD *)a1[4] + 2) = v9;
    *(_DWORD *)(a2 + 12) = a1[3];
    a1[4] = 0;
    v11 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v11;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (00020C3C) --------------------------------------------------------
const char *__fastcall sub_20C3C(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  const char *v9; // r3
  int v10; // r2
  const char *v11; // r1
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *a1;
  v8 = *(const char **)a2;
  if ( result != v8 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_tail",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v9 = a1[3];
  if ( v9 )
  {
    v10 = *(_DWORD *)(a2 + 16);
    if ( v10 )
      *(_DWORD *)(v10 + 8) = v9;
    else
      *(_DWORD *)(a2 + 12) = v9;
    if ( v10 )
      v10 = *(_DWORD *)(a2 + 16);
    *((_DWORD *)a1[3] + 1) = v10;
    *(_DWORD *)(a2 + 16) = a1[4];
    a1[4] = 0;
    v11 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v11;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (00020DA8) --------------------------------------------------------
int __fastcall sub_20DA8(const char **a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  char *v9; // r5
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( *((_BYTE *)a1 + 4) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_free_list",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_list",
      400);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( (int)a1[12] > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(void **)&a1[13][4 * v5++];
      free(v6);
    }
    while ( (int)a1[12] > v5 );
  }
  free((void *)a1[13]);
  if ( (int)a1[14] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)&a1[15][4 * v7++];
      free(v8);
    }
    while ( (int)a1[14] > v7 );
  }
  free((void *)a1[15]);
  v9 = (char *)a1[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(v9 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)v9);
  free((void *)a1[2]);
  free(a1);
  return 0;
}

//----- (00020EC4) --------------------------------------------------------
int __fastcall sub_20EC4(const char **ptr, const char *a2, const char *a3, int a4)
{
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( !*((_BYTE *)ptr + 4) )
  {
    snprintf(
      s,
      0x800u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *ptr,
      "_k_free_store",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_store",
      424);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  free(ptr);
  return 0;
}

//----- (00020F58) --------------------------------------------------------
void __fastcall sub_20F58(int a1, const char *a2, int a3)
{
  int v6; // r4
  struct tm *v7; // r0
  int v8; // r0
  FILE *v9; // r5
  size_t v10; // r0
  size_t v11; // r0
  int v12; // r7
  time_t timer; // [sp+1Ch] [bp-4Ch] BYREF
  struct timeval v14; // [sp+20h] [bp-48h] BYREF
  char s[64]; // [sp+28h] [bp-40h] BYREF

  if ( byte_74500 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v14.tv_sec = 0;
    v14.tv_usec = 0;
    sub_239A4(&v14);
    timer = v14.tv_sec;
    v6 = v14.tv_usec / 1000;
    v7 = localtime(&timer);
    snprintf(
      s,
      0x40u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      v7->tm_year + 1900,
      v7->tm_mon + 1,
      v7->tm_mday,
      v7->tm_hour,
      v7->tm_min,
      v7->tm_sec,
      v6);
    v8 = fileno((FILE *)stderr);
    if ( !isatty(v8) )
    {
      fprintf((FILE *)stderr, "%s%s\n", s, a2);
      fflush((FILE *)stderr);
    }
    if ( byte_68AAC )
    {
      v9 = (FILE *)dword_68AB0;
      if ( dword_68AB0 || (v9 = (FILE *)fopen64(&dword_68AD4, &word_68AB4), (dword_68AB0 = (int)v9) != 0) )
      {
        v10 = strlen(s);
        fwrite(s, v10, 1u, v9);
        v11 = strlen(a2);
        fwrite(a2, v11, 1u, (FILE *)dword_68AB0);
        fwrite(&word_4C858, 1u, 1u, (FILE *)dword_68AB0);
        fflush((FILE *)dword_68AB0);
      }
    }
    if ( a1 == 3 )
      v12 = 0;
    else
      v12 = byte_73378 & 1;
    if ( !v12 )
      sub_21244(s, a2, a3);
  }
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 4C858: using guessed type __int16 word_4C858;
// 68A68: using guessed type int stderr;
// 68AAC: using guessed type char byte_68AAC;
// 68AB0: using guessed type int dword_68AB0;
// 68AB4: using guessed type __int16 word_68AB4;
// 68AD4: using guessed type int dword_68AD4;
// 73378: using guessed type char byte_73378;
// 74500: using guessed type char byte_74500;

//----- (00021138) --------------------------------------------------------
int __fastcall sub_21138(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  result = pthread_mutex_unlock(&stru_766E4);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "logging.c", "my_log_curses", a1);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}
// 20F58: using guessed type int __fastcall sub_20F58(_DWORD, _DWORD, _DWORD);
// 766E4: using guessed type pthread_mutex_t stru_766E4;

//----- (000211B0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_211B0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { POP             {R4,PC} }
}
// 211B4: positive sp value 810 has been found
// 211B4: unbalanced stack, ignored a potential tail call

//----- (000211B8) --------------------------------------------------------
int sub_211B8()
{
  int result; // r0
  int *v1; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_lock(&stru_766E4);
  if ( result )
  {
    v1 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "logging.c", "my_log_curses", 52);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}
// 20F58: using guessed type int __fastcall sub_20F58(_DWORD, _DWORD, _DWORD);
// 766E4: using guessed type pthread_mutex_t stru_766E4;

//----- (00021238) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_21238(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// 21240: positive sp value 814 has been found
// 21240: unbalanced stack, ignored a potential tail call

//----- (00021244) --------------------------------------------------------
int __fastcall sub_21244(const char *a1, const char *a2, int a3)
{
  if ( a3 )
  {
    pthread_mutex_trylock(&stru_766E4);
    sub_21138(41);
    off_67ED8();
  }
  sub_211B8();
  printf("%s%s%s", a1, a2, asc_4C844);
  sub_21138(54);
  return off_67ED8();
}
// 67ED8: using guessed type int (*off_67ED8)();
// 766E4: using guessed type pthread_mutex_t stru_766E4;

//----- (000212BC) --------------------------------------------------------
void __fastcall sub_212BC(int a1, const char *a2, int a3)
{
  int v6; // r0
  int v7; // r0

  if ( byte_74500 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)stderr, "%s\n", a2);
      fflush((FILE *)stderr);
    }
    if ( a1 == 3 )
      v7 = 0;
    else
      v7 = byte_73378 & 1;
    if ( !v7 )
      sub_21244("", a2, a3);
  }
}
// 68A68: using guessed type int stderr;
// 73378: using guessed type char byte_73378;
// 74500: using guessed type char byte_74500;

//----- (00021438) --------------------------------------------------------
__int64 __fastcall sub_21438(int a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // r3
  __int64 result; // r0

  v3 = *(_DWORD *)(a1 + 24);
  if ( v3 )
  {
    *a2 = *(_QWORD *)(v3 + 16);
    result = *(_QWORD *)(v3 + 24);
    *a3 = result;
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
    return 0;
  }
  return result;
}

//----- (00021870) --------------------------------------------------------
int __fastcall sub_21870(int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r0
  int *v4; // lr
  char *v5; // r12
  int v6; // r3
  int v7; // r4
  int v8; // r1
  int v9; // t1
  unsigned int v10; // lr
  char *v11; // r3
  unsigned int v12; // t1
  int *v13; // r0
  int **v14; // r3
  int *v15; // r2
  int *v16; // t1
  int v17; // r6
  int v18; // r3
  int v19; // r4
  int v20; // r10
  int v21; // r9
  int v22; // r5
  int v23; // r8
  int v24; // r7
  int v25; // r11
  int v26; // r2
  int v27; // r12
  int v28; // r3
  int v29; // lr
  int v30; // r1
  int **v31; // r1
  int *v32; // r3
  int *v33; // t1
  bool v34; // zf
  unsigned __int8 *v35; // [sp+4h] [bp-164h]
  int *v36; // [sp+8h] [bp-160h]
  unsigned __int8 *v37; // [sp+14h] [bp-154h]
  int *v38; // [sp+18h] [bp-150h]
  int *v39; // [sp+1Ch] [bp-14Ch] BYREF
  int v40; // [sp+20h] [bp-148h]
  int v41; // [sp+24h] [bp-144h]
  int v42; // [sp+28h] [bp-140h]
  int v43; // [sp+2Ch] [bp-13Ch]
  int v44; // [sp+30h] [bp-138h]
  int v45; // [sp+34h] [bp-134h]
  int v46; // [sp+38h] [bp-130h]
  int v47; // [sp+3Ch] [bp-12Ch] BYREF
  _DWORD v48[15]; // [sp+40h] [bp-128h] BYREF
  char v49; // [sp+7Ch] [bp-ECh] BYREF
  char v50; // [sp+100h] [bp-68h] BYREF

  if ( a3 > 0 )
  {
    v38 = (int *)(result + 136);
    v35 = a2;
    v37 = &a2[64 * a3];
    v39 = (int *)(result + 168);
    do
    {
      v3 = v35;
      v4 = &v47;
      v5 = (char *)v48;
      do
      {
        v6 = v3[1];
        v7 = v3[2];
        v8 = v3[3];
        v9 = *v3;
        v3 += 4;
        v4[1] = (v6 << 16) | (v7 << 8) | v8 | (v9 << 24);
        ++v4;
      }
      while ( &v49 != (char *)v4 );
      do
      {
        v10 = *((_DWORD *)v5 + 14);
        v11 = v5;
        v12 = *((_DWORD *)v5 + 1);
        v5 += 4;
        *((_DWORD *)v5 + 15) = (__ROR4__(v10, 19) ^ __ROR4__(v10, 17) ^ (v10 >> 10))
                             + *((_DWORD *)v11 + 9)
                             + *(_DWORD *)v11
                             + (__ROR4__(v12, 18) ^ __ROR4__(v12, 7) ^ (v12 >> 3));
      }
      while ( &v50 != v5 );
      v13 = v39;
      v14 = &v39;
      v15 = v38;
      do
      {
        v16 = (int *)*v15++;
        v14[1] = v16;
        ++v14;
      }
      while ( v13 != v15 );
      v36 = v15;
      v17 = 0;
      v18 = v47;
      v19 = v44;
      v20 = v45;
      v21 = v46;
      v22 = v40;
      v23 = v41;
      v24 = v42;
      v25 = v43;
      while ( 1 )
      {
        v26 = (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v19, 25)) + (v21 & ~v19 ^ v20 & v19) + v48[v17];
        v27 = dword_67DB8[v17++];
        v28 = v26 + v27 + v18;
        v29 = v25 + v28;
        v30 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((v24 ^ v23) & v22 ^ v24 & v23) + v28;
        v25 = v24;
        v18 = v21;
        if ( v17 == 64 )
          break;
        v24 = v23;
        v21 = v20;
        v23 = v22;
        v20 = v19;
        v22 = v30;
        v19 = v29;
      }
      v40 = v30;
      v31 = &v39;
      v32 = v38;
      v47 = v21;
      v44 = v29;
      v45 = v19;
      v46 = v20;
      v41 = v22;
      v42 = v23;
      v43 = v24;
      do
      {
        result = *v32;
        v33 = v31[1];
        ++v31;
        *v32++ += (int)v33;
      }
      while ( v36 != v32 );
      v34 = v37 == v35 + 64;
      v35 += 64;
    }
    while ( !v34 );
  }
  return result;
}
// 67DB8: using guessed type _DWORD dword_67DB8[63];

//----- (00021A6C) --------------------------------------------------------
_DWORD *__fastcall sub_21A6C(_DWORD *result)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r3
  int v3; // t1

  v1 = &unk_67EB4;
  v2 = result + 34;
  do
  {
    v3 = v1[1];
    ++v1;
    *v2++ = v3;
  }
  while ( v2 != result + 42 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (00021A9C) --------------------------------------------------------
void *__fastcall sub_21A9C(unsigned __int8 *a1, char *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r2
  unsigned __int8 *v8; // r0
  size_t v9; // r6
  void *result; // r0
  unsigned int v11; // r3
  size_t v12; // r5
  unsigned __int8 *v13; // r6
  int v14; // r3

  v4 = *((_DWORD *)a1 + 1);
  v7 = 64 - v4;
  v8 = &a1[v4 + 8];
  if ( v7 >= n )
    v9 = n;
  else
    v9 = v7;
  result = memcpy(v8, a2, v9);
  v11 = n + *((_DWORD *)a1 + 1);
  if ( v11 > 0x3F )
  {
    v12 = n - v9;
    v13 = (unsigned __int8 *)&a2[v9];
    sub_21870((int)a1, a1 + 8, 1);
    sub_21870((int)a1, v13, v12 >> 6);
    result = memcpy(a1 + 8, &v13[v12 & 0xFFFFFFC0], v12 & 0x3F);
    v14 = *(_DWORD *)a1;
    *((_DWORD *)a1 + 1) = v12 & 0x3F;
    *(_DWORD *)a1 = v14 + (((v12 >> 6) + 1) << 6);
  }
  else
  {
    *((_DWORD *)a1 + 1) = v11;
  }
  return result;
}

//----- (00021B48) --------------------------------------------------------
int __fastcall sub_21B48(_DWORD *a1, _BYTE *a2)
{
  int v2; // r8
  int v3; // r9
  int v4; // r10
  int v5; // r11
  int v6; // r3
  unsigned __int8 *v9; // r6
  bool v10; // cf
  int v11; // r2
  int v12; // r7
  size_t v13; // r2
  unsigned __int8 *v14; // r0
  int v15; // r3
  int v16; // r7
  int result; // r0
  int *v18; // r3
  int *v19; // r5
  int v20; // t1
  int v21; // [sp+4h] [bp-8h]

  v6 = a1[1];
  v9 = (unsigned __int8 *)(a1 + 2);
  v10 = (v6 & 0x3Fu) >= 0x38;
  if ( (v6 & 0x3Fu) >= 0x38 )
    v11 = 128;
  else
    v11 = 64;
  v12 = v6 + *a1;
  v13 = v11 - v6;
  v14 = &v9[v6];
  if ( (v6 & 0x3Fu) >= 0x38 )
    v15 = 124;
  else
    v15 = 60;
  v16 = 8 * v12;
  if ( !v10 )
    v2 = 61;
  v21 = v15;
  if ( v10 )
    v2 = 125;
  else
    v3 = 62;
  if ( v10 )
    v3 = 126;
  else
    v4 = 63;
  if ( v10 )
    v4 = 127;
  else
    v5 = 1;
  if ( v10 )
    v5 = 2;
  memset(v14, 0, v13);
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  v9[v4] = v16;
  v9[v3] = BYTE1(v16);
  v9[v2] = BYTE2(v16);
  v9[v21] = HIBYTE(v16);
  result = sub_21870((int)a1, v9, v5);
  v18 = a1 + 34;
  v19 = a1 + 42;
  do
  {
    a2[3] = *v18;
    v20 = *v18++;
    a2[2] = BYTE1(v20);
    a2[1] = *((_WORD *)v18 - 1);
    *a2 = *((_BYTE *)v18 - 1);
    a2 += 4;
  }
  while ( v19 != v18 );
  return result;
}
// 21BDC: variable 'v4' is possibly undefined
// 21BE4: variable 'v3' is possibly undefined
// 21BE8: variable 'v2' is possibly undefined
// 21BF4: variable 'v5' is possibly undefined

//----- (00021C34) --------------------------------------------------------
int __fastcall sub_21C34(char *a1, size_t n, _BYTE *a3)
{
  _DWORD *v3; // r3
  char *v5; // r2
  int v6; // t1
  _DWORD v8[34]; // [sp+0h] [bp-ACh] BYREF
  char v9; // [sp+88h] [bp-24h] BYREF

  v3 = &unk_67EB4;
  v5 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *(_DWORD *)v5 = v6;
    v5 += 4;
  }
  while ( v3 != (_DWORD *)&unk_67ED4 );
  v8[0] = 0;
  v8[1] = 0;
  sub_21A9C((unsigned __int8 *)v8, a1, n);
  return sub_21B48(v8, a3);
}

//----- (00021C98) --------------------------------------------------------
int sub_21C98()
{
  return 0;
}

//----- (00021CA0) --------------------------------------------------------
int __fastcall sub_21CA0(int a1, char *s, int a3)
{
  int v5; // r8
  int v6; // r9
  int v7; // r3
  int v8; // r9
  int v9; // r8
  fd_set *p_tv_usec; // r3
  ssize_t v12; // r0
  __int64 v13; // r4
  unsigned int v14; // r1
  unsigned int v15; // lr
  __int64 v16; // kr00_8
  unsigned int v17; // r2
  unsigned int v18; // r12
  int n; // [sp+Ch] [bp-820h]
  int v20; // [sp+10h] [bp-81Ch]
  int v21; // [sp+18h] [bp-814h]
  struct timeval timeout; // [sp+20h] [bp-80Ch] BYREF
  fd_set writefds; // [sp+28h] [bp-804h] BYREF

  v5 = *(_DWORD *)(a1 + 588);
  if ( byte_73398 && byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf((char *)&writefds, 0x800u, "SEND: %s", s);
    sub_20F58(7, (const char *)&writefds, 0);
  }
  n = a3 + 1;
  *(_WORD *)&s[strlen(s)] = 10;
  if ( a3 + 1 <= 0 )
  {
    v13 = 0;
LABEL_16:
    v14 = *(_DWORD *)(a1 + 504);
    v15 = *(_DWORD *)(a1 + 508);
    v16 = *(_QWORD *)(a1 + 496) + 1LL;
    *(_DWORD *)(a1 + 496) = v16;
    v17 = *(_DWORD *)(a1 + 512);
    *(_DWORD *)(a1 + 500) = HIDWORD(v16);
    v18 = *(_DWORD *)(a1 + 516);
    *(_QWORD *)(a1 + 504) = __PAIR64__(v15, v14) + v13;
    *(_QWORD *)(a1 + 512) = __PAIR64__(v18, v17) + v13;
    return 0;
  }
  else
  {
    LOBYTE(v6) = v5 & 0x1F;
    v7 = v5 / 32;
    if ( v5 <= 0 )
      v6 = -(-v5 & 0x1F);
    v8 = 1 << v6;
    v9 = v5 + 1;
    v21 = v7;
    v20 = 0;
    do
    {
      while ( 1 )
      {
        timeout.tv_usec = 0;
        timeout.tv_sec = 1;
        while ( 1 )
        {
          p_tv_usec = (fd_set *)&timeout.tv_usec;
          do
          {
            p_tv_usec->__fds_bits[1] = 0;
            p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
          }
          while ( &writefds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
          writefds.__fds_bits[v21] |= v8;
          if ( select(v9, 0, &writefds, 0, &timeout) > 0 )
            break;
          if ( *_errno_location() != 4 )
            return 1;
        }
        v12 = send(*(_DWORD *)(a1 + 588), &s[v20], n, 0x4000);
        if ( v12 < 0 )
          break;
        v20 += v12;
        n -= v12;
        if ( n <= 0 )
        {
          v13 = v20;
          goto LABEL_16;
        }
      }
    }
    while ( *_errno_location() == 11 );
    return 2;
  }
}
// 4C858: using guessed type __int16 word_4C858;
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 73398: using guessed type char byte_73398;
// 74500: using guessed type char byte_74500;

//----- (00021F0C) --------------------------------------------------------
int __fastcall sub_21F0C(const char **a1, int a2, int a3)
{
  const char *v5; // r0
  size_t v6; // r0
  ssize_t v7; // r0
  int v8; // r3
  int v9; // r7
  bool v10; // zf
  int v12; // r4
  char s; // [sp+10h] [bp-C00h] BYREF
  char v14; // [sp+11h] [bp-BFFh]
  char v15; // [sp+12h] [bp-BFEh]
  char v16; // [sp+13h] [bp-BFDh]
  char buf[2048]; // [sp+410h] [bp-800h] BYREF

  v5 = a1[150];
  if ( a3 )
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.0\r\n\r\n", v5, a1[146]);
  else
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n", v5, a1[146], v5, a1[146]);
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf(buf, 0x800u, "Sending proxy %s:%s - %s", a1[151], a1[152], &s);
    sub_20F58(7, buf, 0);
  }
  v6 = strlen(&s);
  send(a2, &s, v6, 0);
  v7 = recv(a2, &s, 0xCu, 0);
  if ( v7 > 0 )
  {
    v8 = (unsigned __int8)byte_68BD5;
    *(&s + v7) = 0;
    if ( v8 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      snprintf(buf, 0x800u, "Received from proxy %s:%s - %s", a1[151], a1[152], &s);
      sub_20F58(7, buf, 0);
    }
    v9 = strcmp(&s, "HTTP/1.1 200");
    if ( v9 && (v9 = strcmp(&s, "HTTP/1.0 200")) != 0 )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
      {
        snprintf(buf, 0x800u, "HTTP Error from proxy %s:%s - %s", a1[151], a1[152], &s);
        sub_20F58(4, buf, 0);
        return 0;
      }
    }
    else
    {
      while ( recv(a2, buf, 1u, 0) != -1 )
      {
        v10 = (unsigned __int8)buf[0] == 255;
        *(&s + v9++) = buf[0];
        if ( v10 )
          goto LABEL_27;
        if ( v9 == 4 )
        {
          while ( strncmp(&s, "\r\n\r\n", 4u) )
          {
            s = v14;
            v14 = v15;
            v15 = v16;
            if ( recv(a2, buf, 1u, 0) == -1 )
            {
              v16 = -1;
              goto LABEL_27;
            }
            v16 = buf[0];
            if ( (unsigned __int8)buf[0] == 255 )
              goto LABEL_27;
          }
          v12 = (unsigned __int8)byte_68BD5;
          if ( !byte_68BD5 )
            return 1;
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
          {
            snprintf(buf, 0x800u, "Success negotiating with %s:%s HTTP proxy", a1[151], a1[152]);
            sub_20F58(7, buf, 0);
          }
          return v12;
        }
      }
      *(&s + v9) = -1;
LABEL_27:
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
      {
        v12 = 0;
        snprintf(buf, 0x800u, "Couldn't read HTTP byte from proxy %s:%s", a1[151], a1[152]);
        sub_20F58(4, buf, 0);
        return v12;
      }
    }
    return 0;
  }
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
    return 0;
  snprintf(buf, 0x800u, "Couldn't read from proxy %s:%s after sending CONNECT", a1[151], a1[152]);
  sub_20F58(4, buf, 0);
  return 0;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (000223C0) --------------------------------------------------------
int __fastcall sub_223C0(int a1)
{
  _BYTE *v2; // r3
  int result; // r0

  v2 = *(_BYTE **)(a1 + 592);
  if ( v2 )
    *v2 = 0;
  result = *(_DWORD *)(a1 + 588);
  *(_BYTE *)(a1 + 643) = 0;
  *(_BYTE *)(a1 + 641) = 0;
  if ( result )
    result = close(result);
  *(_DWORD *)(a1 + 588) = 0;
  return result;
}

//----- (00022400) --------------------------------------------------------
int __fastcall sub_22400(int a1)
{
  unsigned int v2; // r2

  v2 = fcntl(a1, 3, 0) & 0xFFFFF7FF;
  return fcntl(a1, 4, v2);
}

//----- (00022428) --------------------------------------------------------
bool __fastcall sub_22428(int a1, int a2)
{
  __time_t v2; // r1
  fd_set *p_tv_usec; // r3
  int v4; // r4
  struct timeval timeout; // [sp+8h] [bp-88h] BYREF
  fd_set readfds; // [sp+10h] [bp-80h] BYREF

  v2 = a2 & ~(a2 >> 31);
  p_tv_usec = (fd_set *)&timeout.tv_usec;
  do
  {
    p_tv_usec->__fds_bits[1] = 0;
    p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
  }
  while ( &readfds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
  timeout.tv_usec = 0;
  timeout.tv_sec = v2;
  LOBYTE(v4) = a1 & 0x1F;
  if ( a1 <= 0 )
    v4 = -(-a1 & 0x1F);
  readfds.__fds_bits[a1 / 32] |= 1 << v4;
  return select(a1 + 1, &readfds, 0, 0, &timeout) > 0;
}

//----- (000224BC) --------------------------------------------------------
_DWORD *__fastcall sub_224BC(_DWORD *a1, unsigned int a2)
{
  _DWORD *v4; // r0

  if ( !a1 || *a1 != 1 )
    return 0;
  if ( (unsigned int)sub_48468(a1) >= a2 )
  {
    v4 = sub_48484(a1, a2);
    if ( v4 )
    {
      if ( *v4 == 2 )
        return sub_48630(v4);
    }
  }
  return 0;
}

//----- (00022520) --------------------------------------------------------
char *__fastcall sub_22520(_DWORD *a1, unsigned int a2)
{
  char *result; // r0

  result = (char *)sub_224BC(a1, a2);
  if ( result )
    return _strdup(result);
  return result;
}

//----- (00022538) --------------------------------------------------------
void __fastcall __noreturn sub_22538(const void *a1, const char *a2, const char *a3, int a4)
{
  int *v8; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v8 = _errno_location();
  snprintf(s, 0x800u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v8, a1, a2, a3, a4);
  sub_20F58(3, s, 1);
  sub_3EBA0(1);
}

//----- (00022594) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_22594(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  __asm { POP             {R4-R7,PC} }
}
// 2259C: positive sp value 814 has been found
// 2259C: unbalanced stack, ignored a potential tail call

//----- (000225A0) --------------------------------------------------------
int __fastcall sub_225A0(const char *a1, const char *a2, int a3)
{
  size_t v6; // r0
  int v7; // r3
  const char *v8; // r2
  const char *v9; // r0
  int v10; // t1
  int result; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( a1 )
  {
    v6 = strlen(a1);
    if ( !v6 )
      return 1;
    v7 = *(unsigned __int8 *)a1;
    if ( (int)dword_4C8CC[v7] >= 0 )
    {
      v8 = a1;
      v9 = &a1[v6 - 1];
      while ( v8 != v9 )
      {
        v10 = *(unsigned __int8 *)++v8;
        v7 = v10;
        if ( (int)dword_4C8CC[v10] < 0 )
          goto LABEL_8;
      }
      return 1;
    }
LABEL_8:
    if ( byte_74500 || (result = (unsigned __int8)byte_68BD4, byte_68BD4) || dword_67DB4 > 2 )
    {
      snprintf(s, 0x800u, "Invalid char 0x%x passed to valid_hex from in %s %s():%d", v7, "util.c", a2, a3);
LABEL_12:
      sub_20F58(3, s, 0);
      return 0;
    }
  }
  else if ( byte_74500 || (result = (unsigned __int8)byte_68BD4, byte_68BD4) || dword_67DB4 > 2 )
  {
    snprintf(s, 0x800u, "Null string passed to valid_hex from in %s %s():%d", "util.c", a2, a3);
    goto LABEL_12;
  }
  return result;
}
// 4C8CC: using guessed type _DWORD dword_4C8CC[256];
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (000226F0) --------------------------------------------------------
int __fastcall sub_226F0(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_wrlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}

//----- (00022760) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_22760(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 22768: positive sp value 814 has been found
// 22768: unbalanced stack, ignored a potential tail call

//----- (0002276C) --------------------------------------------------------
int __fastcall sub_2276C(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}

//----- (000227DC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_227DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 227E4: positive sp value 814 has been found
// 227E4: unbalanced stack, ignored a potential tail call

//----- (000227E8) --------------------------------------------------------
int __fastcall sub_227E8(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}

//----- (00022858) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_22858(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 22860: positive sp value 814 has been found
// 22860: unbalanced stack, ignored a potential tail call

//----- (00022864) --------------------------------------------------------
void __fastcall __noreturn sub_22864(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_3EBA0(1);
}

//----- (000228BC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_228BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 228C4: positive sp value 814 has been found
// 228C4: unbalanced stack, ignored a potential tail call

//----- (000228C8) --------------------------------------------------------
int __fastcall sub_228C8(int a1)
{
  pthread_mutex_t *v1; // r5
  int result; // r0
  _BYTE *v4; // r3

  v1 = (pthread_mutex_t *)(a1 + 704);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
    sub_22864("clear_sock", 1765);
  while ( *(_DWORD *)(a1 + 588) && recv(*(_DWORD *)(a1 + 588), *(void **)(a1 + 592), 0x1FFCu, 0) > 0 )
    ;
  sub_227E8(v1, "clear_sock", 1774);
  result = off_67ED8();
  v4 = *(_BYTE **)(a1 + 592);
  if ( v4 )
    *v4 = 0;
  return result;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (00022958) --------------------------------------------------------
int __fastcall sub_22958(int a1, char a2)
{
  pthread_mutex_t *v2; // r5

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_22864("tq_freezethaw", 1108);
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_227E8(v2, "tq_freezethaw", 1111);
  return off_67ED8();
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (000229BC) --------------------------------------------------------
void *__fastcall sub_229BC(size_t a1, const char *a2, const char *a3, int a4)
{
  size_t v4; // r4
  void *result; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v4 = a1;
  if ( (a1 & 3) != 0 )
    v4 = (a1 & 0xFFFFFFFC) + 4;
  result = malloc(v4);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to malloc size %d from %s %s:%d", v4, a2, a3, a4);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}

//----- (00022A38) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_22A38(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  __asm { POP             {R4-R8,PC} }
}
// 22A40: positive sp value 810 has been found
// 22A40: unbalanced stack, ignored a potential tail call

//----- (00022A44) --------------------------------------------------------
void *__fastcall sub_22A44(size_t a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = calloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to calloc memb %d size %d from %s %s:%d", a1, v5, a3, a4, a5);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}

//----- (00022AC8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_22AC8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  __asm { POP             {R4-R8,PC} }
}
// 22AD0: positive sp value 810 has been found
// 22AD0: unbalanced stack, ignored a potential tail call

//----- (00022AD4) --------------------------------------------------------
void *__fastcall sub_22AD4(void *a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = realloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to realloc size %d from %s %s:%d", v5, a3, a4, a5);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}

//----- (00022B58) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_22B58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  __asm { POP             {R4-R7,PC} }
}
// 22B64: positive sp value 814 has been found
// 22B64: unbalanced stack, ignored a potential tail call

//----- (00022B68) --------------------------------------------------------
char *__fastcall sub_22B68(char *a1)
{
  char **v2; // r3
  char *result; // r0

  if ( !a1 )
    return "http:";
  v2 = &off_4CCE8;
  result = "http0:";
  while ( 1 )
  {
    v2 += 2;
    if ( v2[1] == a1 )
      break;
    result = v2[2];
    if ( !result )
      return "invalid";
  }
  return result;
}
// 4CCE8: using guessed type char *off_4CCE8;

//----- (00022BB4) --------------------------------------------------------
_BYTE *__fastcall sub_22BB4(_BYTE *result, int a2, int a3)
{
  int v3; // r4
  _BYTE *v4; // r1
  _BYTE *v5; // r12
  unsigned int v6; // t1

  if ( a3 <= 0 )
  {
    *result = 0;
  }
  else
  {
    v3 = a2 + a3 - 1;
    v4 = (_BYTE *)(a2 - 1);
    v5 = result + 2;
    do
    {
      v6 = (unsigned __int8)*++v4;
      v5 += 2;
      *(v5 - 4) = *((_BYTE *)&unk_4C8CC + (v6 >> 4) + 1108);
      *(v5 - 3) = *((_BYTE *)&unk_4C8CC + (*v4 & 0xF) + 1108);
    }
    while ( v4 != (_BYTE *)v3 );
    result += 2 * a3;
    *result = 0;
  }
  return result;
}

//----- (00022C24) --------------------------------------------------------
_BYTE *__fastcall sub_22C24(int a1, int a2)
{
  int v2; // r5
  int v4; // r0
  int v6; // r12
  _BYTE *result; // r0
  _BYTE *v8; // r5
  _BYTE *v9; // r2
  char *v10; // r12
  unsigned int v11; // t1

  v2 = 2 * a2;
  v4 = 2 * a2 + 1;
  v6 = v4 & 3;
  if ( v4 <= 0 )
    v6 = -(-v4 & 3);
  result = sub_22A44(4 - v6 + v4, 1u, "util.c", "bin2hex", 789);
  if ( a2 > 0 )
  {
    v9 = (_BYTE *)(a1 - 1);
    v10 = result + 2;
    do
    {
      v11 = (unsigned __int8)*++v9;
      v10 += 2;
      *(v10 - 4) = *((_BYTE *)&dword_4C8CC[277] + (v11 >> 4));
      *(v10 - 3) = *((_BYTE *)&dword_4C8CC[277] + (*v9 & 0xF));
    }
    while ( v9 != (_BYTE *)(a1 - 1 + a2) );
    v8 = &result[v2];
  }
  else
  {
    v8 = result;
  }
  *v8 = 0;
  return result;
}
// 4C8CC: using guessed type _DWORD dword_4C8CC[256];

//----- (00022CD8) --------------------------------------------------------
int __fastcall sub_22CD8(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4; // r3
  unsigned int v5; // r12
  int result; // r0
  unsigned __int8 *v7; // r1
  int v8; // r3
  int v9; // r4
  char v10[2052]; // [sp+0h] [bp-804h] BYREF

  if ( !*a2 )
    return !a3;
  if ( !a3 )
    return 0;
  if ( !a2[1] )
  {
LABEL_16:
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      strcpy(v10, "hex2bin str truncated");
      sub_20F58(3, v10, 0);
    }
    return 0;
  }
  v4 = dword_4C8CC[a2[1]];
  v5 = dword_4C8CC[*a2];
  result = (v4 >> 31) | (v5 >> 31);
  if ( !result )
  {
    v7 = a2 + 4;
    do
    {
      --a3;
      *a1++ = v4 | (16 * v5);
      v8 = *(v7 - 2);
      if ( !*(v7 - 2) )
        return !a3;
      if ( !a3 )
        return result;
      v9 = *(v7 - 1);
      v7 += 2;
      if ( !v9 )
        goto LABEL_16;
      v5 = dword_4C8CC[v8];
      v4 = dword_4C8CC[v9];
    }
    while ( ((v5 | v4) & 0x80000000) == 0 );
  }
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
    return 0;
  strcpy(v10, "hex2bin scan failed");
  sub_20F58(3, v10, 0);
  return 0;
}
// 4C8CC: using guessed type _DWORD dword_4C8CC[256];
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00022E7C) --------------------------------------------------------
void __fastcall sub_22E7C(int a1, char *s)
{
  size_t v4; // r0
  size_t v5; // r3
  char *v6; // r1
  char *v7; // r0
  unsigned __int8 *v8; // r3
  unsigned __int8 v9; // t1
  int v10; // r1
  int v11; // r12
  int i; // r3
  int v13; // [sp+0h] [bp-814h] BYREF
  unsigned __int8 v14[12]; // [sp+4h] [bp-810h] BYREF
  char sa[2052]; // [sp+10h] [bp-804h] BYREF

  qmemcpy(v14, "000000000", 9);
  v4 = strlen(s);
  v13 = 0;
  if ( v4 )
  {
    v5 = 7 - v4;
    v6 = s - 1;
    v7 = &s[v4 - 1];
    v8 = &v14[v5];
    do
    {
      v9 = *++v6;
      *++v8 = v9;
    }
    while ( v6 != v7 );
  }
  v14[8] = 0;
  sub_22CD8(&v13, v14, 4);
  v10 = 0;
  v11 = 0;
  for ( i = 0; i != 32; ++i )
  {
    if ( (((unsigned __int16)(v13 & 0xE000) >> i) & 1) != 0 )
    {
      ++v10;
      v11 |= 1 << i;
      if ( v10 == 3 )
        break;
    }
  }
  v13 = v11;
  if ( (v11 & 0xE000) != 0 )
  {
    *(_BYTE *)(a1 + 644) = 1;
    *(_DWORD *)(a1 + 648) = 8;
  }
  else
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
    {
      snprintf(sa, 0x800u, "Pool %d rolling mask do not match!", *(_DWORD *)a1);
      sub_20F58(5, sa, 0);
    }
    *(_BYTE *)(a1 + 644) = 0;
    *(_DWORD *)(a1 + 648) = 1;
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00022FEC) --------------------------------------------------------
size_t __fastcall sub_22FEC(_BYTE *a1, char *s)
{
  size_t result; // r0
  char v5; // r1
  char *v6; // r7
  unsigned int v7; // r12
  char *v8; // r6
  int v9; // t1
  unsigned int *v10; // r2
  unsigned int v11; // r3
  size_t *v12; // r3
  unsigned int *v13; // r2
  size_t *v14; // r5
  unsigned int v15; // t1
  int v16; // [sp+0h] [bp-20h] BYREF
  int v17; // [sp+4h] [bp-1Ch]
  unsigned int v18[5]; // [sp+8h] [bp-18h] BYREF
  unsigned int v19; // [sp+1Ch] [bp-4h] BYREF

  memset(v18, 0, sizeof(v18));
  v17 = 0;
  v19 = 0;
  result = strlen(s);
  if ( result )
  {
    v6 = s - 1;
    v7 = 0;
    v8 = &v6[result];
    while ( 1 )
    {
      v9 = (unsigned __int8)*++v6;
      v10 = &v19;
      v11 = *((_DWORD *)&unk_4C8CC + v9 + 286);
      while ( 1 )
      {
        *v10-- = 58 * v7 + v11;
        v11 = (58LL * v7 + (unsigned __int64)v11) >> 32;
        if ( &v16 == (int *)v10 )
          break;
        v7 = *v10;
      }
      if ( v8 == v6 )
        break;
      v7 = v19;
    }
    v5 = v17;
    result = bswap32(v18[0]);
  }
  else
  {
    v5 = 0;
  }
  v12 = (size_t *)(a1 + 1);
  v13 = v18;
  *a1 = v5;
  v14 = (size_t *)(a1 + 25);
  while ( 1 )
  {
    *v12++ = result;
    if ( v12 == v14 )
      break;
    v15 = v13[1];
    ++v13;
    result = bswap32(v15);
  }
  return result;
}

//----- (000230C4) --------------------------------------------------------
int __fastcall sub_230C4(int a1, int a2)
{
  char v3; // r2
  int result; // r0
  int v5; // r2

  if ( a2 > 127 )
  {
    LOWORD(v5) = 16511;
    if ( a2 > 16511 )
    {
      HIWORD(v5) = 32;
      if ( a2 <= v5 )
        result = 4;
      else
        result = 5;
      if ( a2 <= v5 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(a1 + 1) = a2;
  *(_BYTE *)a1 = v3;
  return result;
}

//----- (00023110) --------------------------------------------------------
int __fastcall sub_23110(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // r3
  unsigned int *v3; // r2
  unsigned int v4; // lr
  unsigned int v5; // t1
  unsigned int v6; // t1
  bool v7; // cf
  int v8; // r5
  unsigned int v10; // r7
  unsigned int v11; // lr
  unsigned int v12; // r12
  unsigned int v13; // r6
  unsigned int v14; // r7
  unsigned int v15; // r12
  unsigned int v16; // lr
  unsigned int v17; // r3
  unsigned int v18; // lr
  unsigned int v19; // r3
  unsigned int v20; // r6
  unsigned int v21; // r12
  unsigned int v22; // lr
  unsigned int v23; // r3
  unsigned int v24; // r12
  char *v25; // r7
  const char *v26; // r0
  char *v27; // r6
  const char *v28; // r3
  _DWORD v29[8]; // [sp+8h] [bp-844h] BYREF
  _DWORD v30[8]; // [sp+28h] [bp-824h] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  v2 = a1 + 8;
  v3 = a2 + 8;
  while ( 1 )
  {
    v5 = *--v2;
    v4 = v5;
    v6 = *--v3;
    v7 = v4 >= v6;
    if ( v4 > v6 )
      break;
    if ( !v7 || a1 == v2 )
    {
      v8 = 1;
      goto LABEL_7;
    }
  }
  v8 = 0;
LABEL_7:
  if ( !byte_68BD5 )
    return v8;
  v10 = a1[7];
  v11 = a1[5];
  v12 = a1[4];
  v29[1] = bswap32(a1[6]);
  v13 = a1[2];
  v29[0] = bswap32(v10);
  v29[2] = bswap32(v11);
  v14 = a1[3];
  v29[3] = bswap32(v12);
  v15 = *a1;
  v16 = a1[1];
  v29[5] = bswap32(v13);
  v17 = a2[7];
  v29[6] = bswap32(v16);
  v18 = a2[6];
  v29[7] = bswap32(v15);
  v30[0] = bswap32(v17);
  v19 = a2[4];
  v20 = a2[3];
  v21 = bswap32(a2[5]);
  v30[1] = bswap32(v18);
  v22 = a2[2];
  v30[2] = v21;
  v30[3] = bswap32(v19);
  v23 = *a2;
  v24 = a2[1];
  v29[4] = bswap32(v14);
  v30[4] = bswap32(v20);
  v30[6] = bswap32(v24);
  v30[7] = bswap32(v23);
  v30[5] = bswap32(v22);
  v25 = sub_22C24((int)v29, 32);
  v26 = sub_22C24((int)v30, 32);
  v27 = (char *)v26;
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    v28 = "YES (hash <= target)";
    if ( !v8 )
      v28 = "no (false positive; hash > target)";
    snprintf(s, 0x800u, " Proof: %s\nTarget: %s\nTrgVal? %s", v25, v26, v28);
    sub_20F58(7, s, 0);
  }
  free(v25);
  free(v27);
  return v8;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (00023300) --------------------------------------------------------
char *sub_23300()
{
  char *v0; // r4

  v0 = (char *)sub_22A44(1u, 0x58u, "util.c", "tq_new", 1077);
  *(_DWORD *)v0 = v0;
  *((_DWORD *)v0 + 1) = v0;
  pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
  pthread_cond_init((pthread_cond_t *)(v0 + 40), 0);
  return v0;
}

//----- (0002335C) --------------------------------------------------------
void __fastcall sub_2335C(char *a1)
{
  int v2; // r2
  _DWORD *v3; // r0
  _DWORD *v4; // r4
  _DWORD *v5; // r3
  bool v6; // zf

  if ( a1 )
  {
    v2 = **(_DWORD **)a1;
    v3 = (_DWORD *)(*(_DWORD *)a1 - 4);
    v4 = (_DWORD *)(v2 - 4);
    if ( a1 != *(char **)a1 )
    {
      do
      {
        v5 = (_DWORD *)v3[2];
        *(_DWORD *)(v2 + 4) = v5;
        *v5 = v2;
        free(v3);
        v3 = v4;
        v2 = v4[1];
        v6 = v4 + 1 == (_DWORD *)a1;
        v4 = (_DWORD *)(v2 - 4);
      }
      while ( !v6 );
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    free(a1);
  }
}

//----- (000233C4) --------------------------------------------------------
int __fastcall sub_233C4(int a1)
{
  return sub_22958(a1, 1);
}

//----- (000233CC) --------------------------------------------------------
int __fastcall sub_233CC(int a1)
{
  return sub_22958(a1, 0);
}

//----- (000233D4) --------------------------------------------------------
int __fastcall sub_233D4(int a1, int a2)
{
  _DWORD *v4; // r6
  _DWORD *v5; // r4
  _DWORD *v6; // r3
  int v7; // r8

  v4 = sub_22A44(1u, 0xCu, "util.c", "tq_push", 1129);
  *v4 = a2;
  v5 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_22864("tq_push", 1133);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v7 = 0;
    free(v4);
  }
  else
  {
    v6 = *(_DWORD **)(a1 + 4);
    v7 = 1;
    *(_DWORD *)(a1 + 4) = v5;
    v4[1] = a1;
    v4[2] = v6;
    *v6 = v5;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_227E8((pthread_mutex_t *)(a1 + 12), "tq_push", 1146);
  off_67ED8();
  return v7;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (000234A8) --------------------------------------------------------
int __fastcall sub_234A8(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r6
  int *v5; // r4
  _DWORD *v6; // r2
  int v7; // r1
  int v8; // r5
  pthread_cond_t *v10; // r0
  int v11; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_22864("tq_pop", 1158);
  v5 = *(int **)a1;
  if ( a1 == *(_DWORD *)a1 )
  {
    v10 = (pthread_cond_t *)(a1 + 40);
    if ( a2 )
      v11 = pthread_cond_timedwait(v10, v2, a2);
    else
      v11 = pthread_cond_wait(v10, v2);
    if ( v11 )
    {
      v8 = 0;
      goto LABEL_4;
    }
    if ( v5 == *(int **)a1 )
    {
      v8 = 0;
      goto LABEL_4;
    }
    v5 = *(int **)a1;
  }
  v6 = (_DWORD *)v5[1];
  v7 = *v5;
  v8 = *(v5 - 1);
  *(_DWORD *)(v7 + 4) = v6;
  *v6 = v7;
  *v5 = 0;
  v5[1] = 0;
  free(v5 - 1);
LABEL_4:
  sub_227E8(v2, "tq_pop", 1184);
  off_67ED8();
  return v8;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (00023588) --------------------------------------------------------
int __fastcall sub_23588(int result)
{
  int v1; // r4
  pthread_t v2; // r0
  sem_t *v3; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_cancel(v2);
      v3 = (sem_t *)(v1 + 16);
      *(_DWORD *)(v1 + 12) = 0;
    }
    else
    {
      v3 = (sem_t *)(v1 + 16);
    }
    return sem_destroy(v3);
  }
  return result;
}

//----- (000235C4) --------------------------------------------------------
_DWORD *__fastcall sub_235C4(_DWORD *result, int *a2)
{
  int v2; // r12
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result - *a2;
  *a2 = v3;
  v4 = result[1] - v2;
  a2[1] = v4;
  if ( v4 < 0 )
  {
    LODWORD(v5) = v3 - 1;
    HIDWORD(v5) = v4 + 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (000235F8) --------------------------------------------------------
_DWORD *__fastcall sub_235F8(_DWORD *result, int *a2)
{
  int v2; // lr
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result + *a2;
  *a2 = v3;
  v4 = result[1] + v2;
  a2[1] = v4;
  if ( v4 > 999999 )
  {
    LODWORD(v5) = v3 + 1;
    HIDWORD(v5) = v4 - 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (0002363C) --------------------------------------------------------
bool __fastcall sub_2363C(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] > a2[1];
  else
    return *a1 > *a2;
}

//----- (00023670) --------------------------------------------------------
bool __fastcall sub_23670(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] < a2[1];
  else
    return *a1 < *a2;
}

//----- (000236A4) --------------------------------------------------------
_DWORD *__fastcall sub_236A4(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1] / 1000;
  return result;
}

//----- (000236D4) --------------------------------------------------------
_DWORD *__fastcall sub_236D4(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = 1000 * a2[1];
  return result;
}

//----- (000236F0) --------------------------------------------------------
int __fastcall sub_236F0(_QWORD *a1)
{
  int result; // r0
  _DWORD v3[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v3);
  *a1 = __PAIR64__(v3[2], v3[0]);
  return result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (00023728) --------------------------------------------------------
int __fastcall sub_23728(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (00023768) --------------------------------------------------------
int __fastcall sub_23768(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000000 * v4[2];
  *a1 = v3;
  return result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (000237A8) --------------------------------------------------------
int __fastcall sub_237A8(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 12478: using guessed type int __fastcall lldiv(_DWORD);

//----- (000237E4) --------------------------------------------------------
_DWORD *__fastcall sub_237E4(_DWORD *result, _DWORD *a2)
{
  int v2; // r3
  __int64 v3; // r2
  int v4; // lr
  int v5; // r1

  v2 = result[1];
  LODWORD(v3) = *result + *a2;
  *result = v3;
  HIDWORD(v3) = v2 + a2[1];
  result[1] = HIDWORD(v3);
  if ( SHIDWORD(v3) <= 999999999 )
  {
    if ( v3 < 0 )
    {
      do
      {
        HIDWORD(v3) += 1000000000;
        LODWORD(v3) = v3 - 1;
      }
      while ( v3 < 0 );
      *(_QWORD *)result = v3;
    }
  }
  else
  {
    v4 = v3 + 1;
    v5 = HIDWORD(v3) - 1000000000;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
    {
      v5 = -2000000000;
      v4 = v3 + 2;
    }
    *result = v4;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
      v5 += HIDWORD(v3);
    result[1] = v5;
  }
  return result;
}

//----- (0002395C) --------------------------------------------------------
const char *__fastcall sub_2395C(const char **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r0

  v3 = *a1;
  if ( *a1 && (v4 = strpbrk(*a1, a2)) != 0 )
  {
    *v4 = 0;
    *a1 = v4 + 1;
    return v3;
  }
  else
  {
    *a1 = 0;
    return v3;
  }
}

//----- (000239A4) --------------------------------------------------------
int __fastcall sub_239A4(struct timeval *a1)
{
  return gettimeofday(a1, 0);
}

//----- (000239AC) --------------------------------------------------------
int __fastcall sub_239AC(_DWORD *a1)
{
  return a1[1] / 1000000 + 1000 * *a1;
}

//----- (000239DC) --------------------------------------------------------
int __fastcall sub_239DC(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v3; // r3
  int v4; // r1
  int result; // r0

  v3 = *a1 - *a2;
  *a3 = v3;
  v4 = a2[1];
  result = a1[1] - v4;
  if ( result >= 0 )
  {
    a3[1] = result;
  }
  else
  {
    v4 = 1000000000;
    --v3;
  }
  if ( result < 0 )
  {
    *a3 = v3;
    a3[1] = result + v4;
  }
  return result;
}

//----- (00023A18) --------------------------------------------------------
int __fastcall sub_23A18(struct timespec *tp)
{
  return clock_gettime(1, tp);
}

//----- (00023A24) --------------------------------------------------------
int __fastcall sub_23A24(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8; // [sp+0h] [bp-8h] BYREF

  sub_23768(&v8);
  v2 = *a1;
  v8.tv_nsec += a1[1];
  tv_nsec = v8.tv_nsec;
  v4 = v8.tv_sec + v2;
  v8.tv_sec += v2;
  if ( v8.tv_nsec <= 999999999 )
  {
    if ( v8.tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8.tv_sec = v4;
      v8.tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8.tv_nsec - 1000000000;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8.tv_sec = v5;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
      v6 += v8.tv_nsec;
    v8.tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, &v8, 0);
  while ( result == 4 );
  return result;
}

//----- (00023AE4) --------------------------------------------------------
int __fastcall sub_23AE4(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8; // [sp+0h] [bp-8h] BYREF

  sub_23728(&v8);
  v2 = *a1;
  v8.tv_nsec += a1[1];
  tv_nsec = v8.tv_nsec;
  v4 = v8.tv_sec + v2;
  v8.tv_sec += v2;
  if ( v8.tv_nsec <= 999999999 )
  {
    if ( v8.tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8.tv_sec = v4;
      v8.tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8.tv_nsec - 1000000000;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8.tv_sec = v5;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
      v6 += v8.tv_nsec;
    v8.tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, &v8, 0);
  while ( result == 4 );
  return result;
}

//----- (00023B9C) --------------------------------------------------------
int sub_23B9C()
{
  struct timespec v1; // [sp+0h] [bp-8h] BYREF

  clock_gettime(1, &v1);
  return sub_23A24(&v1.tv_sec);
}

//----- (00023BFC) --------------------------------------------------------
int __fastcall sub_23BFC(int result, _DWORD *a2)
{
  if ( *(_DWORD *)result - *a2 <= 60 )
    return 1000000;
  return result;
}

//----- (00023C94) --------------------------------------------------------
void sub_23C94()
{
  ;
}

//----- (00023CD8) --------------------------------------------------------
int __fastcall sub_23CD8(const char *a1, _DWORD *a2, char **a3)
{
  const char *v4; // r4
  char *v6; // r0
  char *v7; // r6
  char *v8; // r0
  char v9; // r5
  int v10; // r5
  char *v11; // r6
  size_t v12; // r0
  int v13; // r3
  int v14; // r7
  char *v16; // r0
  char v17[8]; // [sp+8h] [bp-10Ch] BYREF
  char s[260]; // [sp+10h] [bp-104h] BYREF

  v4 = a1;
  *a2 = a1;
  v6 = strstr(a1, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = (char)v8;
  if ( v8 )
    v9 = 1;
  if ( !v7 )
    v9 = 0;
  if ( v7 < v8 )
    v10 = v9 & 1;
  else
    v10 = 0;
  if ( !v10 )
    v8 = (char *)v4;
  v11 = strchr(v8, 58);
  v12 = strlen(v4);
  if ( v11 )
  {
    v13 = v11 - v4;
    v14 = ~(v11 - v4) + v12;
    if ( v14 <= 0 )
      return 0;
    ++v11;
  }
  else
  {
    v13 = v12;
    v14 = 0;
  }
  if ( v13 <= 0 )
    return 0;
  if ( v10 )
  {
    ++v4;
    v13 -= 2;
  }
  snprintf(s, 0xFEu, "%.*s", v13, v4);
  if ( v14 )
  {
    snprintf(v17, 6u, "%.*s", v14, v11);
    v16 = strpbrk(v17, "/#");
    if ( v16 )
      *v16 = 0;
  }
  else
  {
    strcpy(v17, "80");
  }
  *a3 = _strdup(v17);
  *a2 = _strdup(s);
  return 1;
}

//----- (00023E4C) --------------------------------------------------------
char *__fastcall sub_23E4C(char *s1, int a2)
{
  const char *v2; // r4
  int v4; // r5
  size_t v5; // r6
  char *v7; // r0
  char *v8; // r8
  char *v9; // r0
  const char *v10; // r1

  v2 = "http:";
  v4 = 0;
  v5 = 5;
  *(_DWORD *)(a2 + 184) = 0;
  while ( strncmp(s1, v2, v5) )
  {
    ++v4;
    v2 = (&off_4CCE8)[2 * v4];
    if ( !v2 )
      return s1;
    v5 = strlen((&off_4CCE8)[2 * v4]);
  }
  v7 = strchr(s1, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)sub_229BC(1 - v5 + v7 - s1, "util.c", "get_proxy", 750);
    v10 = &s1[v5];
    *(_DWORD *)(a2 + 184) = v9;
    s1 = v8 + 1;
    strcpy(v9, v10);
    sub_23CD8(*(const char **)(a2 + 184), (_DWORD *)(a2 + 604), (char **)(a2 + 608));
    *(_DWORD *)(a2 + 180) = dword_4C8CC[2 * v4 + 264];
  }
  return s1;
}
// 4C8CC: using guessed type _DWORD dword_4C8CC[256];
// 4CCE8: using guessed type char *off_4CCE8;

//----- (00023F28) --------------------------------------------------------
bool __fastcall sub_23F28(int a1)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(a1 + 592);
  return *v1 || sub_22428(*(_DWORD *)(a1 + 588), (unsigned __int8)*v1);
}

//----- (00023F48) --------------------------------------------------------
void **__fastcall sub_23F48(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6)
{
  _DWORD *v7; // r6

  if ( a3 != a2 )
  {
    v7 = result;
    result = (void **)sub_22AD4(*result, a3, a4, a5, a6);
    *v7 = result;
    if ( a3 > a2 )
      return (void **)memset((char *)result + a2, 0, a3 - a2);
  }
  return result;
}

//----- (00023FB4) --------------------------------------------------------
int __fastcall sub_23FB4(unsigned int a1, int a2)
{
  int v2; // r12
  int v3; // r3
  int result; // r0

  v2 = 0;
  v3 = 0;
  result = 0;
  do
  {
    if ( ((a1 >> v3) & 1) != 0 )
    {
      ++v2;
      result |= 1 << v3;
      if ( v2 == a2 )
        break;
    }
    ++v3;
  }
  while ( v3 != 32 );
  return result;
}

//----- (00023FF8) --------------------------------------------------------
int __fastcall sub_23FF8(_DWORD *a1, int a2)
{
  _DWORD *v3; // r0
  _DWORD *v4; // r5
  _DWORD *v5; // r7
  _DWORD *v6; // r0
  int v7; // r6
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  int v12; // r0
  const char *v13; // r4
  int v14; // r0
  int v15; // r0
  int v16; // r0
  _DWORD *v17; // r9
  char *v18; // r0
  char v19[92]; // [sp+14h] [bp-900h] BYREF
  char v20[160]; // [sp+70h] [bp-8A4h] BYREF
  char s[2052]; // [sp+110h] [bp-804h] BYREF

  v3 = sub_47258(a2, 0, v19);
  v4 = v3;
  if ( v3 )
  {
    v5 = (_DWORD *)sub_480FC(v3, "result");
    v6 = (_DWORD *)sub_480FC(v4, "error");
    if ( v5 && *v5 != 7 && (!v6 || *v6 == 7) && (v12 = sub_48364(v5), (v13 = (const char *)sub_483E4(v12)) != 0) )
    {
      v7 = 0;
      do
      {
        v16 = sub_483FC((int)v13);
        v17 = (_DWORD *)sub_483F0(v16);
        if ( !v17 )
          break;
        if ( !strcasecmp(v13, "version-rolling") && strlen(v13) == 15 )
        {
          if ( *v17 != 5 )
          {
            if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
            {
              snprintf(s, 0x800u, "Pool %d don't support ab!", *a1);
              sub_20F58(5, s, 0);
            }
            *((_BYTE *)a1 + 644) = 0;
            v7 = 1;
            a1[162] = 1;
            break;
          }
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
          {
            snprintf(s, 0x800u, "POOL %d support ab mode!", *a1);
            sub_20F58(5, s, 0);
          }
        }
        else if ( !strcasecmp(v13, "version-rolling.mask") && strlen(v13) == 20 )
        {
          v7 = 1;
          v18 = (char *)sub_48630(v17);
          sub_22E7C((int)a1, v18);
        }
        else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
        {
          snprintf(s, 0x800u, "JSON-RPC unexpected mining.configure value: %s", v13);
          sub_20F58(3, s, 0);
        }
        v14 = sub_483FC((int)v13);
        v15 = sub_483B0(v5, v14);
        v13 = (const char *)sub_483E4(v15);
      }
      while ( v13 );
    }
    else
    {
      v7 = 0;
    }
    if ( v4[1] != -1 )
    {
      v8 = v4 + 1;
      __dmb(0xBu);
      do
      {
        v9 = __ldrex(v8);
        v10 = v9 - 1;
      }
      while ( __strex(v10, v8) );
      if ( !v10 )
        sub_48A34(v4);
    }
    return v7;
  }
  if ( !byte_74500 )
  {
    v7 = (unsigned __int8)byte_68BD4;
    if ( !byte_68BD4 && dword_67DB4 <= 5 )
      return v7;
  }
  snprintf(s, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)v19, v20);
  sub_20F58(6, s, 0);
  return 0;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00024340) --------------------------------------------------------
int __fastcall sub_24340(int a1)
{
  int *v3; // r0
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
  {
    snprintf(s, 0x800u, "Closing socket for stratum pool %d", *(_DWORD *)a1);
    sub_20F58(6, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
  {
    v4 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", "suspend_stratum", 3130);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  sub_223C0(a1);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 704)) )
  {
    v3 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "util.c", "suspend_stratum", 3132);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return off_67ED8();
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (000244A4) --------------------------------------------------------
int __fastcall sub_244A4(int a1, char *a2, int a3)
{
  int *v6; // r0
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_73398 && byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf(s, 0x800u, "SEND: %s", a2);
    sub_20F58(7, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 704)) )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "util.c", "stratum_send", 1688);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( *(_BYTE *)(a1 + 641) )
  {
    v8 = sub_21CA0(a1, a2, a3);
    if ( !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 704)) )
    {
      off_67ED8();
      switch ( v8 )
      {
        case 2:
          if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
          {
            strcpy(s, "Failed to send in stratum_send");
            sub_20F58(7, s, 0);
            sub_24340(a1);
            return 0;
          }
          break;
        case 3:
          goto LABEL_12;
        case 1:
          if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
          {
            snprintf(s, 0x800u, "Write select failed on pool %d sock", *(_DWORD *)a1);
            sub_20F58(7, s, 0);
          }
          break;
        default:
          return v8 == 0;
      }
      sub_24340(a1);
      return 0;
    }
LABEL_7:
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", "stratum_send", 1694);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 704)) )
    goto LABEL_7;
  off_67ED8();
LABEL_12:
  result = (unsigned __int8)byte_68BD5;
  if ( byte_68BD5 )
  {
    if ( byte_74500 || (result = (unsigned __int8)byte_68BD4, byte_68BD4) || dword_67DB4 > 6 )
    {
      strcpy(s, "Stratum send failed due to no pool stratum_active");
      sub_20F58(7, s, 0);
      return 0;
    }
  }
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 73398: using guessed type char byte_73398;
// 74500: using guessed type char byte_74500;

//----- (00024858) --------------------------------------------------------
char *__fastcall sub_24858(int a1)
{
  char *v2; // r7
  signed int v3; // r6
  char *v4; // r0
  char *v5; // r5
  size_t v6; // r0
  size_t v7; // r7
  unsigned int v8; // lr
  __int64 v9; // kr08_8
  unsigned int v10; // r3
  unsigned int v11; // kr04_4
  int v12; // r1
  unsigned int v13; // r2
  ssize_t v15; // r5
  bool v16; // nf
  int v17; // r5
  char *v18; // r9
  size_t v19; // r7
  size_t v20; // r8
  unsigned int v21; // r0
  size_t v22; // r7
  char *v23; // r0
  struct timeval tv; // [sp+8h] [bp-2814h] BYREF
  struct timeval v25; // [sp+10h] [bp-280Ch] BYREF
  char v26[2040]; // [sp+18h] [bp-2804h] BYREF
  char v27[8196]; // [sp+818h] [bp-2004h] BYREF

  v2 = *(char **)(a1 + 592);
  if ( !strchr(v2, 10) )
  {
    gettimeofday(&tv, 0);
    if ( !sub_22428(*(_DWORD *)(a1 + 588), 60) )
    {
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        strcpy(v27, "Timed out waiting for data on socket_full");
        sub_20F58(7, v27, 0);
      }
      goto LABEL_29;
    }
    while ( 1 )
    {
      memset(v27, 0, 0x2000u);
      v15 = recv(*(_DWORD *)(a1 + 588), v27, 0x1FFCu, 0);
      if ( !v15 )
        break;
      gettimeofday(&v25, 0);
      v16 = v15 < 0;
      v17 = (int)((double)(v25.tv_usec - tv.tv_usec) / 1000000.0 + (double)(v25.tv_sec - tv.tv_sec));
      if ( v16 )
      {
        if ( *_errno_location() != 11 || !sub_22428(*(_DWORD *)(a1 + 588), 60 - v17) )
        {
          if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
          {
            strcpy(v26, "Failed to recv sock in recv_line");
            sub_20F58(7, v26, 0);
          }
          goto LABEL_35;
        }
      }
      else
      {
        v18 = *(char **)(a1 + 592);
        v19 = strlen(v27);
        v20 = strlen(v18);
        v21 = v19 + v20 + 1;
        if ( v21 >= *(_DWORD *)(a1 + 596) )
        {
          v22 = (v21 & 0xFFFFE000) + 0x2000;
          v23 = (char *)sub_22AD4(v18, v22, "util.c", "recalloc_sock", 1803);
          *(_DWORD *)(a1 + 592) = v23;
          memset(&v23[v20], 0, v22 - v20);
          v18 = *(char **)(a1 + 592);
          *(_DWORD *)(a1 + 596) = v22;
        }
        strcat(v18, v27);
      }
      v2 = *(char **)(a1 + 592);
      if ( v17 > 59 || strchr(*(const char **)(a1 + 592), 10) )
        goto LABEL_2;
    }
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      strcpy(v26, "Socket closed waiting in recv_line");
      sub_20F58(7, v26, 0);
    }
LABEL_35:
    sub_24340(a1);
    v2 = *(char **)(a1 + 592);
  }
LABEL_2:
  v3 = strlen(v2);
  v4 = strtok(v2, (const char *)&word_4C858);
  if ( !v4 )
  {
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      strcpy(v27, "Failed to parse a \\n terminated string in recv_line");
      sub_20F58(7, v27, 0);
    }
LABEL_29:
    v5 = 0;
    sub_228C8(a1);
    return v5;
  }
  v5 = _strdup(v4);
  v6 = strlen(v5);
  v7 = v6;
  if ( (int)(v6 + 1) < v3 )
    memmove(*(void **)(a1 + 592), (const void *)(*(_DWORD *)(a1 + 592) + v6 + 1), v3 - v6 + 1);
  else
    **(_BYTE **)(a1 + 592) = 0;
  v8 = *(_DWORD *)(a1 + 532);
  v9 = *(_QWORD *)(a1 + 520) + 1LL;
  v10 = *(_DWORD *)(a1 + 536);
  v11 = *(_DWORD *)(a1 + 528);
  *(_DWORD *)(a1 + 520) = v9;
  *(_QWORD *)(a1 + 528) = __PAIR64__(v8, v11) + v7;
  v12 = (unsigned __int8)byte_73398;
  v13 = *(_DWORD *)(a1 + 540);
  *(_DWORD *)(a1 + 524) = HIDWORD(v9);
  *(_QWORD *)(a1 + 536) = __PAIR64__(v13, v10) + v7;
  if ( v12 && byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf(v27, 0x800u, "RECVD: %s", v5);
    sub_20F58(7, v27, 0);
  }
  return v5;
}
// 4C858: using guessed type __int16 word_4C858;
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 73398: using guessed type char byte_73398;
// 74500: using guessed type char byte_74500;

//----- (00024DC4) --------------------------------------------------------
time_t __fastcall sub_24DC4(_DWORD *a1, int a2)
{
  time_t result; // r0

  result = time(0);
  a1[62] = a2;
  a1[61] = result;
  switch ( a2 )
  {
    case 0:
      ++a1[63];
      break;
    case 1:
      ++a1[64];
      break;
    case 2:
      ++a1[65];
      break;
    case 3:
      ++a1[66];
      break;
    case 4:
      ++a1[67];
      break;
    case 5:
      ++a1[68];
      break;
    case 6:
      ++a1[69];
      break;
    case 7:
      ++a1[70];
      break;
    case 8:
      ++a1[71];
      break;
    case 9:
      ++a1[72];
      break;
    default:
      return result;
  }
  return result;
}
// 24DE8: control flows out of bounds to 24DEC

//----- (00024EB4) --------------------------------------------------------
char *__fastcall sub_24EB4(char *a1, char *s)
{
  size_t v4; // r0
  const char *v5; // r1
  char *v6; // r4
  size_t v7; // r4
  size_t v8; // r0
  char *v10; // r4

  v4 = strlen(s);
  if ( !v4 )
    return a1;
  v7 = v4 + 1;
  if ( a1 )
  {
    v8 = strlen(a1) + v7;
    if ( (v8 & 3) != 0 )
      v8 = (v8 & 0xFFFFFFFC) + 4;
    v6 = (char *)sub_229BC(v8, "util.c", "realloc_strcat", 3370);
    sprintf(v6, "%s%s", a1, s);
    free(a1);
    return v6;
  }
  if ( (v7 & 3) != 0 )
    v4 = v7 & 0xFFFFFFFC;
  else
    LOWORD(v5) = -10704;
  if ( (v7 & 3) != 0 )
    LOWORD(v5) = -10704;
  else
    v4 = v7;
  if ( (v7 & 3) != 0 )
    v4 += 4;
  HIWORD(v5) = 4;
  v10 = (char *)sub_229BC(v4, v5, "realloc_strcat", 3370);
  strcpy(v10, s);
  return v10;
}
// 24F60: variable 'v5' is possibly undefined

//----- (00024F88) --------------------------------------------------------
char *__fastcall sub_24F88(const char *a1)
{
  size_t v2; // r0
  char *v3; // r5
  char *v4; // r7
  char *v5; // r4
  char v6; // r3
  char v7; // r2
  int v8; // t1
  char *v10; // r2
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( !a1 )
  {
    v10 = (char *)malloc(7u);
    if ( !v10 )
    {
      snprintf(s, 0x800u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3395);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
    strcpy(v10, "(null)");
  }
  v2 = strlen(a1);
  v3 = (char *)(a1 - 1);
  v4 = (char *)sub_229BC(4 * v2 + 5, "util.c", "str_text", 3400);
  v5 = v4;
  do
  {
    while ( 1 )
    {
      v8 = (unsigned __int8)*++v3;
      v7 = v8;
      if ( (unsigned int)(v8 - 32) <= 0x5E )
        break;
      sprintf(v5, "0x%02x");
      v6 = *v3;
      v5 += 4;
      if ( !*v3 )
        goto LABEL_7;
    }
    *v5++ = v7;
    v6 = *v3;
  }
  while ( *v3 );
LABEL_7:
  *v5 = v6;
  return v4;
}

//----- (000250A8) --------------------------------------------------------
int __fastcall sub_250A8(const char *a1)
{
  char s[20]; // [sp+8h] [bp-14h] BYREF

  snprintf(s, 0x10u, "cg@%s", a1);
  return prctl(15, s, 0);
}

//----- (000250E8) --------------------------------------------------------
int __fastcall sub_250E8(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = sem_init(a1, 0, 0);
  v8 = result;
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, a2, a3, a4);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}

//----- (00025164) --------------------------------------------------------
int __fastcall sub_25164(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4)
{
  sub_250E8((sem_t *)(a1 + 16), "util.c", "thr_info_create", 1191);
  return pthread_create((pthread_t *)(a1 + 12), a2, a3, a4);
}

//----- (000251AC) --------------------------------------------------------
int __fastcall sub_251AC(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0

  result = sem_post(a1);
  if ( result )
    sub_22538(a1, a2, a3, a4);
  return result;
}

//----- (000251E4) --------------------------------------------------------
int __fastcall sub_251E4(int a1)
{
  pthread_setcanceltype(1, 0);
  (*(void (__fastcall **)(_DWORD))(a1 + 16))(*(_DWORD *)(a1 + 20));
  sub_251AC((sem_t *)a1, "util.c", "completion_thread", 3626);
  return 0;
}

//----- (00025228) --------------------------------------------------------
int __fastcall sub_25228(sem_t *sem, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v9; // r3
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  while ( 1 )
  {
    result = sem_wait(sem);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 != 4 )
    {
      snprintf(s, 0x800u, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v9, sem, a2, a3, a4);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
  }
  return result;
}

//----- (000252A8) --------------------------------------------------------
int __fastcall sub_252A8(sem_t *a1, int a2, const char *a3, const char *a4, int a5)
{
  __time_t tv_sec; // r10
  int v8; // r5
  int v9; // r3
  __time_t v10; // r2
  bool v11; // cc
  int v12; // r1
  __time_t v13; // r0
  int result; // r0
  struct timespec abstime; // [sp+18h] [bp-814h] BYREF
  struct timeval tv; // [sp+20h] [bp-80Ch] BYREF
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  gettimeofday(&tv, 0);
  tv_sec = tv.tv_sec;
  v8 = 1000 * tv.tv_usec;
  sub_23768(&abstime);
  while ( 1 )
  {
    v9 = v8 + abstime.tv_nsec;
    v10 = tv_sec + abstime.tv_sec;
    v11 = v8 + abstime.tv_nsec <= 999999999;
    abstime.tv_sec += tv_sec;
    abstime.tv_nsec += v8;
    if ( v11 )
    {
      if ( v9 < 0 )
      {
        do
        {
          v9 += 1000000000;
          --v10;
        }
        while ( v9 < 0 );
        abstime.tv_sec = v10;
        abstime.tv_nsec = v9;
      }
    }
    else
    {
      v12 = v9 - 1000000000;
      v13 = v10 + 1;
      if ( v9 - 1000000000 > 999999999 )
      {
        v12 = v9 - 2000000000;
        v13 = v10 + 2;
      }
      abstime.tv_sec = v13;
      abstime.tv_nsec = v12;
    }
    result = sem_timedwait(a1, &abstime);
    if ( !result )
      break;
    result = *_errno_location();
    if ( result == 110 )
      break;
    if ( result != 4 )
    {
      snprintf(s, 0x800u, "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", result, a1, a3, a4, a5);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
  }
  return result;
}

//----- (000253DC) --------------------------------------------------------
void sub_253DC()
{
  JUMPOUT(0x25364);
}
// 253E0: control flows out of bounds to 25364

//----- (000253E4) --------------------------------------------------------
int *__fastcall sub_253E4(sem_t *sem)
{
  int *result; // r0

  do
  {
    while ( 1 )
    {
      result = (int *)sem_trywait(sem);
      if ( (int)result < 0 )
        break;
      if ( result )
        return result;
    }
    result = _errno_location();
  }
  while ( *result == 4 );
  return result;
}

//----- (0002541C) --------------------------------------------------------
bool __fastcall sub_2541C(int a1, int a2, int a3)
{
  sem_t *v6; // r4
  int v7; // r5
  pthread_t newthread[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = (sem_t *)sub_229BC(0x18u, "util.c", "cg_completion_timeout", 3637);
  sub_250E8(v6, "util.c", "cg_completion_timeout", 3638);
  v6[1].__align = a1;
  *(&v6[1].__align + 1) = a2;
  pthread_create(newthread, 0, (void *(*)(void *))sub_251E4, v6);
  v7 = sub_252A8(v6, a3, "util.c", "cg_completion_timeout", 3644);
  if ( v7 )
  {
    pthread_cancel(newthread[0]);
    return v7 == 0;
  }
  else
  {
    pthread_join(newthread[0], 0);
    free(v6);
    return 1;
  }
}

//----- (000254E8) --------------------------------------------------------
void __fastcall sub_254E8(void *a1, const void *a2, size_t a3, int a4, int a5, int a6)
{
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( (int)(a3 - 1) < 0 )
  {
    if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
      return;
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes from %s %s():%d", a3, a4, a5, a6);
LABEL_9:
    sub_20F58(3, s, 0);
    return;
  }
  if ( !a1 )
  {
    if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
      return;
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d", a3, a4, a5, a6);
    goto LABEL_9;
  }
  if ( a2 )
  {
    memcpy(a1, a2, a3);
    return;
  }
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d", a3, a4, a5, a6);
    goto LABEL_9;
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (000257F8) --------------------------------------------------------
void __fastcall sub_257F8(void *a1, const void *a2)
{
  sub_254E8(a1, a2, 8u, (int)"util.c", (int)"copy_time", 1236);
}

//----- (0002582C) --------------------------------------------------------
int __fastcall sub_2582C(int a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r5
  int v6; // r6
  int v8; // r10
  unsigned int v9; // r4
  unsigned __int8 *v10; // r7
  char *v11; // r4
  _DWORD *v12; // r0
  bool v13; // r7
  signed int v14; // r0
  char *v15; // r2
  int v16; // r3
  int v17; // t1
  void *v18; // r0
  const char *v19; // r3
  int v20; // r6
  double v21; // d7
  size_t v22; // r1
  int v23; // r2
  size_t v24; // r3
  size_t v25; // r1
  void *v26; // r0
  void *v27; // r0
  size_t v28; // r12
  int v29; // r10
  int *v30; // r3
  int v31; // r2
  int v32; // r1
  int *v33; // r12
  int v34; // r0
  int v35; // r1
  int v36; // r2
  int v37; // r3
  int *v38; // r12
  int v39; // r0
  int v40; // r1
  int v41; // r2
  int v42; // r3
  int v43; // r0
  int v44; // r1
  int v45; // r2
  int v46; // r3
  int v47; // r12
  const char *v48; // r0
  char *v49; // r7
  const char *v50; // lr
  int v51; // r0
  int v52; // r1
  int v53; // r2
  int v54; // r3
  int *v55; // lr
  int v56; // r0
  int v57; // r1
  int v58; // r2
  int v59; // r3
  int v60; // r0
  int v61; // r1
  int v62; // r2
  int v63; // r3
  int v64; // r1
  void *v65; // r0
  signed int v66; // r7
  unsigned __int8 *v67; // r4
  int v68; // r6
  void *v69; // r0
  char *v70; // r3
  _BYTE v71[4]; // [sp+18h] [bp-964h] BYREF
  char *v72; // [sp+1Ch] [bp-960h]
  const char *v73; // [sp+20h] [bp-95Ch]
  int v74; // [sp+24h] [bp-958h]
  pthread_rwlock_t *v75; // [sp+28h] [bp-954h]
  pthread_mutex_t *v76; // [sp+2Ch] [bp-950h]
  size_t v77; // [sp+30h] [bp-94Ch]
  const char *v78; // [sp+34h] [bp-948h]
  const char *v79; // [sp+38h] [bp-944h]
  const char *v80; // [sp+3Ch] [bp-940h]
  const char *v81; // [sp+40h] [bp-93Ch]
  char *v82; // [sp+44h] [bp-938h]
  char *v83; // [sp+48h] [bp-934h]
  size_t v84; // [sp+4Ch] [bp-930h]
  size_t v85; // [sp+50h] [bp-92Ch]
  _BOOL4 v86; // [sp+54h] [bp-928h]
  const char *v87; // [sp+58h] [bp-924h]
  const char *v88; // [sp+5Ch] [bp-920h]
  const char *v89; // [sp+60h] [bp-91Ch]
  const char *v90; // [sp+64h] [bp-918h]
  char *s; // [sp+68h] [bp-914h]
  void *ptr; // [sp+6Ch] [bp-910h]
  char v93[228]; // [sp+74h] [bp-908h] BYREF
  _DWORD v94[513]; // [sp+158h] [bp-824h] BYREF

  v4 = sub_48484(a2, 4u);
  v5 = v4;
  if ( !v4 || *v4 != 1 )
    return 0;
  v8 = (int)sub_48468(v4);
  if ( v8 <= 0 )
  {
    v6 = 0;
LABEL_20:
    v11 = sub_22520(a2, 0);
    v90 = (const char *)sub_224BC(a2, 1u);
    ptr = sub_22520(a2, 2u);
    s = sub_22520(a2, 3u);
    v89 = (const char *)sub_224BC(a2, 5u);
    v88 = (const char *)sub_224BC(a2, 6u);
    v87 = (const char *)sub_224BC(a2, 7u);
    v12 = sub_48484(a2, 8u);
    v13 = (char)v12;
    if ( v12 )
    {
      v13 = *sub_48484(a2, 8u) == 5;
      v86 = v13;
    }
    else
    {
      v86 = 0;
    }
    if ( v11 )
    {
      v14 = strlen(v11);
      if ( v14 )
      {
        v15 = v11;
        while ( 1 )
        {
          v17 = (unsigned __int8)*v15++;
          v16 = v17;
          if ( (unsigned int)(v17 - 32) > 0x5E )
            break;
          if ( v14 <= v15 - v11 )
          {
            if ( !sub_225A0(v90, "parse_notify", 1969)
              || !sub_225A0((const char *)ptr, "parse_notify", 1969)
              || !sub_225A0(s, "parse_notify", 1970)
              || !sub_225A0(v89, "parse_notify", 1970)
              || !sub_225A0(v88, "parse_notify", 1970)
              || !sub_225A0(v87, "parse_notify", 1971) )
            {
              goto LABEL_34;
            }
            v76 = (pthread_mutex_t *)(a1 + 212);
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
              sub_22864("parse_notify", 1980);
            v75 = (pthread_rwlock_t *)(a1 + 236);
            sub_226F0((pthread_rwlock_t *)(a1 + 236), "parse_notify", 1980);
            v18 = *(void **)(a1 + 672);
            v81 = (const char *)(a1 + 1712);
            free(v18);
            v19 = v90;
            *(_DWORD *)(a1 + 672) = v11;
            snprintf((char *)(a1 + 1712), 0x41u, "%s", v19);
            v85 = strlen((const char *)ptr) >> 1;
            v80 = (const char *)(a1 + 1780);
            v84 = strlen(s) >> 1;
            snprintf((char *)(a1 + 1780), 9u, "%s", v89);
            v79 = (const char *)(a1 + 1792);
            snprintf((char *)(a1 + 1792), 9u, "%s", v88);
            v78 = (const char *)(a1 + 1804);
            v20 = 0;
            snprintf((char *)(a1 + 1804), 9u, "%s", v87);
            *(_BYTE *)(a1 + 680) = v13;
            v21 = *(double *)(a1 + 1816);
            v22 = v85;
            if ( v21 > 0.0 )
              *(double *)(a1 + 1824) = v21;
            v23 = *(_DWORD *)(a1 + 632);
            v24 = v22 + *(_DWORD *)(a1 + 1564);
            v25 = v84;
            *(_DWORD *)(a1 + 1576) = v24;
            v77 = v25 + v23 + v24;
            *(_DWORD *)(a1 + 1572) = v77;
            while ( *(_DWORD *)(a1 + 1708) > v20 )
            {
              v26 = *(void **)(*(_DWORD *)(a1 + 676) + 4 * v20++);
              free(v26);
            }
            if ( v8 )
            {
              v65 = sub_22AD4(*(void **)(a1 + 676), 4 * v8 + 1, "util.c", "parse_notify", 2001);
              v73 = "util.c";
              v66 = 0;
              *(_DWORD *)(a1 + 676) = v65;
              v83 = &byte_73398;
              v72 = &byte_68BD5;
              v82 = v11;
              do
              {
                v74 = 4 * v66;
                if ( v66 >= v8 )
                {
                  v11 = v82;
                  *(_DWORD *)(a1 + 1708) = v8;
                  if ( v8 > 1 )
                    goto LABEL_58;
                  goto LABEL_57;
                }
                v67 = (unsigned __int8 *)sub_22520(v5, v66);
                v68 = *(_DWORD *)(a1 + 676);
                v69 = sub_229BC(0x20u, v73, "parse_notify", 2006);
                v70 = v83;
                *(_DWORD *)(v68 + 4 * v66) = v69;
                if ( *v70 && *v72 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                {
                  snprintf((char *)v94, 0x800u, "merkle %d: %s", v66, v67);
                  sub_20F58(7, (const char *)v94, 0);
                }
                ++v66;
                v6 = sub_22CD8(*(_BYTE **)(*(_DWORD *)(a1 + 676) + v74), v67, 32);
                free(v67);
              }
              while ( v6 );
              v11 = v82;
              if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
              {
                v50 = "Failed to convert merkle to merkle_bin in parse_notify";
                goto LABEL_129;
              }
              goto LABEL_120;
            }
            *(_DWORD *)(a1 + 1708) = 0;
            v83 = &byte_73398;
LABEL_57:
            ++*(_QWORD *)(a1 + 376);
LABEL_58:
            if ( v86 )
              *(_QWORD *)(a1 + 624) = 0;
            snprintf(
              v93,
              0xE1u,
              "%s%s%s%s%s%s%s",
              v80,
              v81,
              "0000000000000000000000000000000000000000000000000000000000000000",
              v78,
              v79,
              "00000000",
              off_687EC);
            v6 = sub_22CD8((_BYTE *)(a1 + 1580), (unsigned __int8 *)v93, 112);
            if ( v6 )
            {
              v6 = sub_22CD8(v71, (unsigned __int8 *)ptr, v85);
              if ( v6 )
              {
                v6 = sub_22CD8(v71, (unsigned __int8 *)s, v84);
                if ( v6 )
                {
                  free(*(void **)(a1 + 1568));
                  v27 = sub_22A44(v77, 1u, "util.c", "parse_notify", 2063);
                  *(_DWORD *)(a1 + 1568) = v27;
                  sub_254E8(v27, v71, v85, (int)"util.c", (int)"parse_notify", 2064);
                  v28 = *(_DWORD *)(a1 + 1564);
                  if ( v28 )
                  {
                    sub_254E8(
                      (void *)(*(_DWORD *)(a1 + 1568) + v85),
                      *(const void **)(a1 + 616),
                      v28,
                      (int)"util.c",
                      (int)"parse_notify",
                      2066);
                    v28 = *(_DWORD *)(a1 + 1564);
                  }
                  sub_254E8(
                    (void *)(*(_DWORD *)(a1 + 1568) + v28 + *(_DWORD *)(a1 + 632) + v85),
                    v71,
                    v84,
                    (int)"util.c",
                    (int)"parse_notify",
                    2067);
                  v29 = (unsigned __int8)byte_68BD5;
                  if ( byte_68BD5 )
                  {
                    v48 = sub_22C24(*(_DWORD *)(a1 + 1568), *(_DWORD *)(a1 + 1572));
                    v49 = (char *)v48;
                    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                    {
                      snprintf((char *)v94, 0x800u, "Pool %d coinbase %s", *(_DWORD *)a1, v48);
                      sub_20F58(7, (const char *)v94, 0);
                    }
                    v6 = v29;
                    free(v49);
                  }
                  goto LABEL_66;
                }
                if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
                {
                  v33 = (int *)&unk_4DD34;
LABEL_113:
                  v34 = *v33;
                  v35 = v33[1];
                  v36 = v33[2];
                  v37 = v33[3];
                  v38 = v33 + 4;
                  v94[0] = v34;
                  v94[1] = v35;
                  v94[2] = v36;
                  v94[3] = v37;
                  v39 = *v38;
                  v40 = v38[1];
                  v41 = v38[2];
                  v42 = v38[3];
                  v38 += 4;
                  v94[4] = v39;
                  v94[5] = v40;
                  v94[6] = v41;
                  v94[7] = v42;
                  v43 = *v38;
                  v44 = v38[1];
                  v45 = v38[2];
                  v46 = v38[3];
                  v47 = v38[4];
                  v94[8] = v43;
                  v94[9] = v44;
                  v94[10] = v45;
                  v94[11] = v46;
                  LOBYTE(v94[12]) = v47;
                  sub_20F58(3, (const char *)v94, 0);
                  goto LABEL_66;
                }
              }
              else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
              {
                v33 = (int *)&unk_4DD00;
                goto LABEL_113;
              }
LABEL_120:
              v6 = 0;
              goto LABEL_66;
            }
            if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
              goto LABEL_120;
            v50 = "Failed to convert header to header_bin in parse_notify";
LABEL_129:
            v51 = *(_DWORD *)v50;
            v52 = *((_DWORD *)v50 + 1);
            v53 = *((_DWORD *)v50 + 2);
            v54 = *((_DWORD *)v50 + 3);
            v55 = (int *)(v50 + 16);
            v94[0] = v51;
            v94[1] = v52;
            v94[2] = v53;
            v94[3] = v54;
            v56 = *v55;
            v57 = v55[1];
            v58 = v55[2];
            v59 = v55[3];
            v55 += 4;
            v94[4] = v56;
            v94[5] = v57;
            v94[6] = v58;
            v94[7] = v59;
            v60 = *v55;
            v61 = v55[1];
            v62 = v55[2];
            v63 = v55[3];
            v55 += 4;
            v94[8] = v60;
            v94[9] = v61;
            v94[10] = v62;
            v94[11] = v63;
            v64 = v55[1];
            v94[12] = *v55;
            LOWORD(v94[13]) = v64;
            BYTE2(v94[13]) = BYTE2(v64);
            sub_20F58(3, (const char *)v94, 0);
LABEL_66:
            sub_2276C(v75, "parse_notify", 2076);
            sub_227E8(v76, "parse_notify", 2076);
            off_67ED8();
            if ( !*v83 )
              goto LABEL_106;
            if ( !byte_68BD5 )
              goto LABEL_84;
            if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
            {
              snprintf((char *)v94, 0x800u, "job_id: %s", v11);
              sub_20F58(7, (const char *)v94, 0);
              if ( byte_68BD5 )
              {
                if ( !byte_74500 )
                  goto LABEL_73;
LABEL_75:
                snprintf((char *)v94, 0x800u, "prev_hash: %s", v90);
                sub_20F58(7, (const char *)v94, 0);
                if ( byte_68BD5 )
                {
                  if ( !byte_74500 )
                    goto LABEL_77;
                  goto LABEL_79;
                }
LABEL_94:
                if ( byte_68BD5 )
                {
                  if ( !byte_74500 )
                    goto LABEL_96;
LABEL_98:
                  snprintf((char *)v94, 0x800u, "ntime: %s", v87);
                  sub_20F58(7, (const char *)v94, 0);
LABEL_99:
                  if ( byte_68BD5 )
                  {
                    if ( !byte_74500 )
                      goto LABEL_101;
                    goto LABEL_103;
                  }
                }
                goto LABEL_106;
              }
LABEL_89:
              if ( !byte_68BD5 )
                goto LABEL_106;
              if ( !byte_74500 )
              {
LABEL_91:
                if ( !byte_68BD4 && dword_67DB4 <= 6 )
                {
LABEL_96:
                  if ( byte_68BD4 || dword_67DB4 > 6 )
                    goto LABEL_98;
LABEL_101:
                  if ( byte_68BD4 || dword_67DB4 > 6 )
                  {
LABEL_103:
                    v30 = (int *)"yes";
                    if ( !v86 )
                      v30 = &dword_4B184;
                    snprintf((char *)v94, 0x800u, "clean: %s", v30);
                    sub_20F58(7, (const char *)v94, 0);
                  }
LABEL_106:
                  free(ptr);
                  free(s);
                  v31 = dword_755E8;
                  v32 = dword_755EC;
                  ++*(_DWORD *)(a1 + 116);
                  *(_QWORD *)&dword_755E8 = __PAIR64__(v32, v31) + 1;
                  if ( a1 == sub_31FF4() )
                    byte_767F0 = 1;
                  return v6;
                }
              }
              snprintf((char *)v94, 0x800u, "nbit: %s", v88);
              sub_20F58(7, (const char *)v94, 0);
              goto LABEL_94;
            }
LABEL_73:
            if ( byte_68BD4 || dword_67DB4 > 6 )
              goto LABEL_75;
LABEL_77:
            if ( byte_68BD4 || dword_67DB4 > 6 )
            {
LABEL_79:
              snprintf((char *)v94, 0x800u, "coinbase1: %s", (const char *)ptr);
              sub_20F58(7, (const char *)v94, 0);
              if ( !byte_68BD5 )
                goto LABEL_99;
              if ( !byte_74500 )
                goto LABEL_81;
LABEL_83:
              snprintf((char *)v94, 0x800u, "coinbase2: %s", s);
              sub_20F58(7, (const char *)v94, 0);
LABEL_84:
              if ( !byte_68BD5 )
                goto LABEL_106;
              if ( !byte_74500 )
              {
LABEL_86:
                if ( !byte_68BD4 && dword_67DB4 <= 6 )
                  goto LABEL_91;
              }
              snprintf((char *)v94, 0x800u, "bbversion: %s", v89);
              sub_20F58(7, (const char *)v94, 0);
              goto LABEL_89;
            }
LABEL_81:
            if ( byte_68BD4 || dword_67DB4 > 6 )
              goto LABEL_83;
            goto LABEL_86;
          }
        }
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
        {
          snprintf(
            (char *)v94,
            0x800u,
            "Invalid char 0x%x passed to valid_ascii from in %s %s():%d",
            v16,
            "util.c",
            "parse_notify",
            1969);
          goto LABEL_33;
        }
        goto LABEL_34;
      }
      if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
      {
LABEL_34:
        free(v11);
        free(ptr);
        free(s);
        return v6;
      }
      snprintf(
        (char *)v94,
        0x800u,
        "Zero length string passed to valid_ascii from in %s %s():%d",
        "util.c",
        "parse_notify",
        1969);
    }
    else
    {
      if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
        goto LABEL_34;
      snprintf(
        (char *)v94,
        0x800u,
        "Null string passed to valid_ascii from in %s %s():%d",
        "util.c",
        "parse_notify",
        1969);
    }
LABEL_33:
    sub_20F58(3, (const char *)v94, 0);
    goto LABEL_34;
  }
  v9 = 0;
  v6 = 0;
  while ( 1 )
  {
    memset(v93, 0, 0x20u);
    v10 = (unsigned __int8 *)sub_22520(v5, v9);
    if ( !v10 )
      return v6;
    v6 = sub_22CD8(v93, v10, 32);
    if ( !v6 )
    {
      if ( (byte_74500 || byte_68BD4 || dword_67DB4 > 2)
        && ((snprintf((char *)v94, 0x800u, "merkle %d: %s", v9, (const char *)v10),
             sub_20F58(3, (const char *)v94, 0),
             byte_74500)
         || byte_68BD4)
        || dword_67DB4 > 2 )
      {
        strcpy((char *)v94, "Failed to convert merkle to merkle_bin in parse_notify");
        sub_20F58(3, (const char *)v94, 0);
      }
      free(v10);
      return v6;
    }
    ++v9;
    free(v10);
    if ( v8 == v9 )
      goto LABEL_20;
  }
}
// 4B184: using guessed type int dword_4B184;
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 687EC: using guessed type char *off_687EC;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 73398: using guessed type char byte_73398;
// 74500: using guessed type char byte_74500;
// 755E8: using guessed type int dword_755E8;
// 755EC: using guessed type int dword_755EC;
// 767F0: using guessed type char byte_767F0;

//----- (00026830) --------------------------------------------------------
int __fastcall sub_26830(const char **a1, int a2, int a3)
{
  __int16 v6; // kr00_2
  unsigned int v7; // r10
  const char *v9; // r0
  const char *v10; // r10
  size_t v11; // r0
  size_t v12; // r8
  int v13; // r4
  unsigned int v14; // r10
  struct addrinfo *pai; // [sp+8h] [bp-A28h] BYREF
  char v16; // [sp+Ch] [bp-A24h] BYREF
  __int16 v17; // [sp+2Ch] [bp-A04h] BYREF
  char v18; // [sp+2Eh] [bp-A02h]
  char v19; // [sp+2Fh] [bp-A01h]
  int v20; // [sp+30h] [bp-A00h]
  char v21[8]; // [sp+34h] [bp-9FCh] BYREF
  _BYTE v22[500]; // [sp+3Ch] [bp-9F4h] BYREF
  struct addrinfo flags[64]; // [sp+230h] [bp-800h] BYREF

  v17 = 260;
  v6 = strtol(a1[146], 0, 10);
  v18 = HIBYTE(v6);
  v19 = v6;
  strcpy(v21, "CGMINER");
  v7 = bswap32(inet_addr(a1[150]));
  if ( v7 != -1 )
    goto LABEL_2;
  pai = (struct addrinfo *)&v16;
  memset(flags, 0, 0x20u);
  v9 = a1[150];
  flags[0].ai_family = 2;
  if ( !getaddrinfo(v9, 0, flags, &pai) )
  {
    v14 = *(_DWORD *)&pai->ai_addr->sa_data[2];
    freeaddrinfo(pai);
    v7 = bswap32(v14);
    if ( v7 != -1 )
    {
LABEL_2:
      HIBYTE(v20) = v7;
      LOBYTE(v20) = HIBYTE(v7);
      BYTE1(v20) = BYTE2(v7);
      BYTE2(v20) = BYTE1(v7);
      send(a2, &v17, 0x10u, 0);
      goto LABEL_3;
    }
LABEL_23:
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
    {
      snprintf((char *)flags, 0x800u, "Invalid IP address specified for socks4 proxy: %s", a1[150]);
      goto LABEL_9;
    }
    return 0;
  }
  if ( !a3 )
    goto LABEL_23;
  v10 = a1[150];
  v20 = 0x1000000;
  v11 = strlen(v10);
  if ( v11 >= 0xFF )
    v12 = 255;
  else
    v12 = v11;
  sub_254E8(v22, v10, v12, (int)"util.c", (int)"socks4_negotiate", 2898);
  v22[v12] = 0;
  send(a2, &v17, v12 + 17, 0);
LABEL_3:
  if ( recv(a2, flags, 1u, 0) == -1
    || LOBYTE(flags[0].ai_flags)
    || recv(a2, flags, 1u, 0) == -1
    || LOBYTE(flags[0].ai_flags) != 90 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
    {
      snprintf((char *)flags, 0x800u, "Bad response from %s:%s SOCKS4 server", a1[151], a1[152]);
LABEL_9:
      sub_20F58(4, (const char *)flags, 0);
      return 0;
    }
    return 0;
  }
  v13 = 6;
  do
  {
    recv(a2, flags, 1u, 0);
    --v13;
  }
  while ( v13 );
  return 1;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00026AEC) --------------------------------------------------------
int __fastcall sub_26AEC(_DWORD *a1)
{
  int v2; // r0
  int v3; // r3
  int v4; // r0
  int v5; // r5
  const char *v7; // r1
  size_t v8; // r3
  void *v9; // r0
  _BYTE *v10; // r0
  int v11; // r2
  unsigned __int8 *v12; // r1
  int *v13; // r0
  int *v14; // r0
  int v15; // r3
  int v16; // r2
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r2
  struct addrinfo *v20; // r5
  int v21; // r0
  int *v22; // r9
  int v23; // r0
  int v24; // r6
  char *v25; // r12
  int v26; // r0
  int v27; // r1
  int v28; // r2
  __int16 v29; // r3
  int v30; // r7
  int v31; // r3
  int v32; // r8
  char *v33; // r7
  fd_set *v34; // r3
  int v35; // r0
  const char *v36; // r0
  int v37; // r3
  int v38; // r4
  int v39; // r2
  int v40; // r0
  const char *v41; // r3
  int v42; // r2
  size_t v43; // r0
  int v44; // r2
  int *v45; // r0
  int *v46; // r0
  int v47; // r2
  const char *v48; // r0
  size_t v49; // r0
  size_t v50; // r5
  __int16 v51; // r0
  char *v52; // r12
  int v53; // r12
  int v54; // r3
  char *v55; // r0
  char *v56; // r4
  _DWORD *v57; // r4
  _DWORD *v58; // r0
  char *v59; // r4
  unsigned int *v60; // r3
  unsigned int v61; // r2
  unsigned int v62; // r2
  int *v63; // r0
  int *v64; // r0
  int *v65; // r0
  int *v66; // r0
  _DWORD *v67; // r0
  _DWORD *v68; // r9
  _DWORD *v69; // r7
  _DWORD *v70; // r0
  _DWORD *v71; // r8
  char *v72; // r6
  char *v73; // r8
  const char *v74; // r0
  _DWORD *v76; // r0
  char *v77; // r0
  int *v78; // r0
  int v79; // r5
  int v80; // r5
  int v81; // r4
  int v83; // r4
  char *service; // [sp+18h] [bp-2B64h]
  char *servicea; // [sp+18h] [bp-2B64h]
  char *serviceb; // [sp+18h] [bp-2B64h]
  char *name; // [sp+1Ch] [bp-2B60h]
  pthread_mutex_t *mutex; // [sp+20h] [bp-2B5Ch]
  _DWORD *v89; // [sp+2Ch] [bp-2B50h]
  int v90; // [sp+30h] [bp-2B4Ch]
  unsigned int v91; // [sp+34h] [bp-2B48h]
  struct addrinfo *pai; // [sp+44h] [bp-2B38h] BYREF
  socklen_t optlen; // [sp+48h] [bp-2B34h] BYREF
  int optval; // [sp+4Ch] [bp-2B30h] BYREF
  struct timeval timeout; // [sp+50h] [bp-2B2Ch] BYREF
  struct addrinfo s; // [sp+58h] [bp-2B24h] BYREF
  char v97[92]; // [sp+78h] [bp-2B04h] BYREF
  char v98[156]; // [sp+D4h] [bp-2AA8h] BYREF
  char v99; // [sp+170h] [bp-2A0Ch] BYREF
  fd_set writefds; // [sp+174h] [bp-2A08h] BYREF
  char v101[2040]; // [sp+378h] [bp-2804h] BYREF
  char v102[8196]; // [sp+B78h] [bp-2004h] BYREF

  v89 = 0;
  mutex = (pthread_mutex_t *)(a1 + 176);
  v90 = 0;
  while ( 2 )
  {
    if ( pthread_mutex_lock(mutex) )
    {
      v46 = _errno_location();
      snprintf(
        v101,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v46,
        "util.c",
        "setup_stratum_socket",
        2945);
      sub_20F58(3, v101, 1);
      sub_3EBA0(1);
    }
    v2 = a1[147];
    *((_BYTE *)a1 + 641) = 0;
    if ( v2 )
      close(v2);
    a1[147] = 0;
    if ( pthread_mutex_unlock(mutex) )
    {
      v45 = _errno_location();
      snprintf(
        v101,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v45,
        "util.c",
        "setup_stratum_socket",
        2950);
      sub_20F58(3, v101, 1);
      sub_3EBA0(1);
    }
    off_67ED8();
    memset(&s, 0, sizeof(s));
    v3 = a1[46];
    s.ai_socktype = 1;
    if ( v3 )
      goto LABEL_7;
    v36 = (const char *)dword_6AB9C;
    if ( !dword_6AB9C )
    {
      name = (char *)a1[150];
      goto LABEL_104;
    }
    a1[46] = dword_6AB9C;
    sub_23CD8(v36, a1 + 151, (char **)a1 + 152);
    v37 = a1[46];
    a1[45] = 3;
    name = (char *)a1[150];
    if ( !v37 )
    {
LABEL_104:
      service = (char *)a1[146];
      v4 = getaddrinfo(name, service, &s, &pai);
      goto LABEL_8;
    }
LABEL_7:
    name = (char *)a1[151];
    service = (char *)a1[152];
    v4 = getaddrinfo(name, service, &s, &pai);
LABEL_8:
    v91 = v4;
    if ( v4 )
    {
      if ( !*((_BYTE *)a1 + 99) )
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
        {
          snprintf(v101, 0x800u, "Failed to resolve (?wrong URL) %s:%s", name, service);
          sub_20F58(4, v101, 0);
        }
        *((_BYTE *)a1 + 99) = 1;
        goto LABEL_15;
      }
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        snprintf(v101, 0x800u, "Failed to getaddrinfo for %s:%s", name, service);
        sub_20F58(6, v101, 0);
        goto LABEL_15;
      }
      goto LABEL_108;
    }
    v20 = pai;
    if ( !pai )
    {
LABEL_71:
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        snprintf(v101, 0x800u, "Failed to connect to stratum on %s:%s", name, service);
        sub_20F58(6, v101, 0);
      }
      freeaddrinfo(pai);
      goto LABEL_15;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v23 = socket(v20->ai_family, v20->ai_socktype, v20->ai_protocol);
        v24 = v23;
        if ( v23 != -1 )
          break;
        if ( !byte_68BD5 || !byte_74500 && !byte_68BD4 && dword_67DB4 <= 6 )
          goto LABEL_63;
        v25 = v101;
        v26 = *(_DWORD *)"Failed socket";
        v27 = *(_DWORD *)"ed socket";
        v28 = *(_DWORD *)"ocket";
        v29 = *(_WORD *)"t";
LABEL_70:
        *(_DWORD *)v25 = v26;
        *((_DWORD *)v25 + 1) = v27;
        *((_DWORD *)v25 + 2) = v28;
        *((_WORD *)v25 + 6) = v29;
        sub_20F58(7, v101, 0);
        v20 = v20->ai_next;
        if ( !v20 )
          goto LABEL_71;
      }
      v21 = fcntl(v23, 3, 0);
      fcntl(v24, 4, v21 | 0x800);
      if ( connect(v24, v20->ai_addr, v20->ai_addrlen) != -1 )
        break;
      timeout.tv_usec = 0;
      timeout.tv_sec = 1;
      v22 = _errno_location();
      if ( *v22 == 115 )
      {
        v30 = v24 + 31;
        if ( v24 >= 0 )
          v30 = v24;
        LOBYTE(v31) = v24 & 0x1F;
        if ( v24 <= 0 )
          v31 = -(-v24 & 0x1F);
        v32 = 1 << v31;
        v33 = &v102[4 * (v30 >> 5)];
        while ( 1 )
        {
          v34 = (fd_set *)&v99;
          do
          {
            v34->__fds_bits[1] = 0;
            v34 = (fd_set *)((char *)v34 + 4);
          }
          while ( &writefds.__fds_bits[31] != (__fd_mask *)v34 );
          *((_DWORD *)v33 - 641) |= v32;
          v35 = select(v24 + 1, 0, &writefds, 0, &timeout);
          if ( v35 > 0 )
            break;
          if ( !v35 || *v22 != 4 )
            goto LABEL_85;
        }
        if ( (v32 & *((_DWORD *)v33 - 641)) != 0 )
        {
          optlen = 4;
          if ( !getsockopt(v24, 1, 4, &optval, &optlen) && !optval )
          {
            if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
            {
              strcpy(v101, "Succeeded delayed connect");
              sub_20F58(7, v101, 0);
            }
            goto LABEL_100;
          }
        }
LABEL_85:
        close(v24);
        if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
        {
          qmemcpy(v101, "Select timeout/f", 16);
          v25 = &v101[16];
          v26 = *(_DWORD *)"ailed connect";
          v27 = *(_DWORD *)"d connect";
          v28 = *(_DWORD *)"nnect";
          v29 = *(_WORD *)"t";
          goto LABEL_70;
        }
      }
      else
      {
        close(v24);
        if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
        {
          strcpy(v101, "Failed sock connect");
          sub_20F58(7, v101, 0);
        }
      }
LABEL_63:
      v20 = v20->ai_next;
      if ( !v20 )
        goto LABEL_71;
    }
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
    {
      strcpy(v101, "Succeeded immediate connect");
      sub_20F58(4, v101, 0);
    }
LABEL_100:
    sub_22400(v24);
    freeaddrinfo(pai);
    if ( !a1[46] )
    {
LABEL_117:
      if ( !a1[148] )
      {
        a1[148] = sub_22A44(0x2000u, 1u, "util.c", "setup_stratum_socket", 3087);
        a1[149] = 0x2000;
      }
      a1[147] = v24;
      writefds.__fds_bits[0] = 45;
      *(_DWORD *)v101 = 30;
      timeout.tv_sec = 1;
      v40 = fcntl(v24, 3, 0);
      fcntl(v24, 4, v40 | 0x800);
      setsockopt(v24, 1, 9, &timeout, 4u);
      if ( !byte_74501 )
        fcntl(v24, 2, 1);
      setsockopt(v24, 6, 1, &timeout, 4u);
      setsockopt(v24, 6, 6, &timeout, 4u);
      setsockopt(v24, 6, 4, &writefds, 4u);
      setsockopt(v24, 6, 5, v101, 4u);
      if ( v90 )
      {
        sub_228C8((int)a1);
        v44 = dword_7448C++;
        sprintf(v102, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v44);
      }
      else
      {
        v41 = (const char *)a1[159];
        v42 = dword_7448C++;
        if ( v41 )
          sprintf(
            v102,
            "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/1.0.0\", \"%s\"]}",
            v42,
            v41);
        else
          sprintf(v102, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/1.0.0\"]}", v42);
      }
      v43 = strlen(v102);
      if ( sub_21CA0((int)a1, v102, v43) )
      {
        if ( !byte_68BD5 )
          goto LABEL_126;
        if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 6 )
          goto LABEL_130;
        strcpy(v101, "Failed to send s in initiate_stratum");
        sub_20F58(7, v101, 0);
LABEL_137:
        v38 = (unsigned __int8)byte_68BD5;
        if ( !byte_68BD5 )
          goto LABEL_126;
LABEL_131:
        if ( byte_74500 )
          goto LABEL_133;
        goto LABEL_132;
      }
      if ( !sub_22428(a1[147], 60) )
      {
        if ( !byte_68BD5 )
          goto LABEL_126;
        if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 6 )
        {
LABEL_130:
          v38 = 1;
          goto LABEL_131;
        }
        strcpy(v101, "Timed out waiting for response in initiate_stratum");
        sub_20F58(7, v101, 0);
        goto LABEL_137;
      }
      v55 = sub_24858((int)a1);
      v56 = v55;
      if ( !v55 )
        goto LABEL_137;
      v89 = sub_47258((int)v55, 0, v97);
      free(v56);
      if ( !v89 )
      {
        v90 ^= 1u;
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
        {
          snprintf(v101, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)v97, v98);
          sub_20F58(6, v101, 0);
        }
        goto LABEL_189;
      }
      v57 = (_DWORD *)sub_480FC(v89, "result");
      v58 = (_DWORD *)sub_480FC(v89, "error");
      if ( !v57 || *v57 == 7 )
      {
        if ( !v58 )
        {
          v59 = (char *)malloc(0x11u);
          if ( v59 )
            strcpy(v59, "(unknown reason)");
          goto LABEL_184;
        }
      }
      else if ( !v58 || *v58 == 7 )
      {
        v67 = sub_48484(v57, 0);
        v68 = v67;
        if ( v67 )
        {
          if ( *v67 == 1 )
          {
            v69 = sub_48468(v67);
            if ( (int)v69 > 0 )
            {
              do
              {
                v70 = sub_48484(v68, v91);
                v71 = v70;
                if ( !v70 || *v70 != 1 )
                  break;
                v74 = (const char *)sub_224BC(v70, 0);
                if ( v74 && !strncasecmp(v74, "mining.notify", 0xDu) )
                {
                  v72 = sub_22520(v71, 1u);
                  if ( v72 )
                    goto LABEL_233;
                  break;
                }
              }
              while ( v69 != (_DWORD *)++v91 );
            }
          }
        }
        v72 = (char *)(unsigned __int8)byte_68BD5;
        if ( byte_68BD5 )
        {
          if ( byte_74500 || (v72 = (char *)(unsigned __int8)byte_68BD4, byte_68BD4) || dword_67DB4 > 6 )
          {
            v72 = 0;
            strcpy(v101, "Failed to get sessionid in initiate_stratum");
            sub_20F58(7, v101, 0);
          }
        }
LABEL_233:
        v73 = sub_22520(v57, 1u);
        v5 = sub_225A0(v73, "initiate_stratum", 3216);
        if ( v5 )
        {
          v76 = sub_48484(v57, 2u);
          v77 = (char *)sub_4888C((int)v76);
          if ( (unsigned int)(v77 - 2) <= 0xE )
          {
            servicea = v77;
            if ( v72 )
            {
              v7 = (const char *)a1[159];
              if ( v7 )
              {
                if ( !strcmp(v72, v7) && (byte_74500 || byte_68BD4 || dword_67DB4 > 4) )
                {
                  snprintf(v101, 0x800u, "Pool %d successfully negotiated resume with the same session ID", *a1);
                  sub_20F58(5, v101, 0);
                }
              }
            }
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
              sub_22864("initiate_stratum", 3236);
            if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
            {
              v78 = _errno_location();
              snprintf(
                v101,
                0x800u,
                "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                *v78,
                "util.c",
                "initiate_stratum",
                3236);
              sub_20F58(3, v101, 1);
              sub_3EBA0(1);
            }
            free((void *)a1[153]);
            free((void *)a1[159]);
            a1[159] = v72;
            a1[153] = v73;
            v8 = strlen(v73) >> 1;
            v9 = (void *)a1[154];
            a1[391] = v8;
            free(v9);
            v10 = sub_22A44(a1[391], 1u, "util.c", "initiate_stratum", 3243);
            v11 = a1[391];
            v12 = (unsigned __int8 *)a1[153];
            a1[154] = v10;
            sub_22CD8(v10, v12, v11);
            a1[158] = servicea;
            if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
            {
              v13 = _errno_location();
              snprintf(
                v101,
                0x800u,
                "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                *v13,
                "util.c",
                "initiate_stratum",
                3246);
              sub_20F58(3, v101, 1);
              sub_3EBA0(1);
            }
            if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
            {
              v14 = _errno_location();
              snprintf(
                v101,
                0x800u,
                "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                *v14,
                "util.c",
                "initiate_stratum",
                3246);
              sub_20F58(3, v101, 1);
              sub_3EBA0(1);
            }
            off_67ED8();
            if ( v72 && byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
            {
              snprintf(v101, 0x800u, "Pool %d stratum session id: %s", *a1, (const char *)a1[159]);
              sub_20F58(7, v101, 0);
            }
            v15 = a1[144];
            *((_BYTE *)a1 + 641) = 1;
            if ( !v15 )
              a1[144] = a1[150];
            v16 = (unsigned __int8)byte_73398;
            *((_QWORD *)a1 + 227) = 0;
            *((_QWORD *)a1 + 228) = 0x3FF0000000000000LL;
            if ( v16 )
            {
              v5 = (unsigned __int8)byte_68BD5;
              if ( byte_68BD5 )
              {
                if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
                {
                  snprintf(
                    v101,
                    0x800u,
                    "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
                    *a1,
                    (const char *)a1[153],
                    a1[158]);
                  sub_20F58(7, v101, 0);
                }
              }
              else
              {
                v5 = v16;
              }
            }
LABEL_49:
            if ( v89[1] == -1 )
              return v5;
            v17 = v89 + 1;
            __dmb(0xBu);
            do
            {
              v18 = __ldrex(v17);
              v19 = v18 - 1;
            }
            while ( __strex(v19, v17) );
            if ( v19 )
              return v5;
            sub_48A34(v89);
            return v5;
          }
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
          {
            strcpy(v101, "Failed to get valid n2size in initiate_stratum");
            sub_20F58(6, v101, 0);
          }
          v90 ^= 1u;
          free(v72);
          free(v73);
        }
        else
        {
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
          {
            strcpy(v101, "Failed to get valid nonce1 in initiate_stratum");
            sub_20F58(6, v101, 0);
          }
          v90 ^= 1u;
          free(v72);
        }
        goto LABEL_189;
      }
      v59 = sub_45074(v58, 3);
LABEL_184:
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        snprintf(v101, 0x800u, "JSON-RPC decode failed: %s", v59);
        sub_20F58(6, v101, 0);
      }
      v90 ^= 1u;
      free(v59);
LABEL_189:
      if ( !v90 )
        goto LABEL_137;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      {
        v66 = _errno_location();
        snprintf(
          v101,
          0x800u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v66,
          "util.c",
          "initiate_stratum",
          3274);
        sub_20F58(3, v101, 1);
        sub_3EBA0(1);
      }
      if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v65 = _errno_location();
        snprintf(
          v101,
          0x800u,
          "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v65,
          "util.c",
          "initiate_stratum",
          3274);
        sub_20F58(3, v101, 1);
        sub_3EBA0(1);
      }
      free((void *)a1[159]);
      free((void *)a1[153]);
      a1[153] = 0;
      a1[159] = 0;
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v64 = _errno_location();
        snprintf(
          v101,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v64,
          "util.c",
          "initiate_stratum",
          3278);
        sub_20F58(3, v101, 1);
        sub_3EBA0(1);
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
      {
        v63 = _errno_location();
        snprintf(
          v101,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v63,
          "util.c",
          "initiate_stratum",
          3278);
        sub_20F58(3, v101, 1);
        sub_3EBA0(1);
      }
      off_67ED8();
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        strcpy(v101, "Failed to resume stratum, trying afresh");
        sub_20F58(7, v101, 0);
      }
      if ( v89 )
      {
        if ( v89[1] != -1 )
        {
          v60 = v89 + 1;
          __dmb(0xBu);
          do
          {
            v61 = __ldrex(v60);
            v62 = v61 - 1;
          }
          while ( __strex(v62, v60) );
          if ( !v62 )
            sub_48A34(v89);
        }
      }
      continue;
    }
    break;
  }
  switch ( a1[45] )
  {
    case 0:
      v47 = 0;
      goto LABEL_150;
    case 1:
      v47 = 1;
LABEL_150:
      if ( !sub_21F0C((const char **)a1, v24, v47) )
        goto LABEL_15;
      goto LABEL_117;
    case 2:
      v39 = 0;
      goto LABEL_116;
    case 3:
    case 5:
      BYTE2(writefds.__fds_bits[0]) = 0;
      LOWORD(writefds.__fds_bits[0]) = 261;
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        snprintf(
          v101,
          0x800u,
          "Attempting to negotiate with %s:%s SOCKS5 proxy",
          (const char *)a1[151],
          (const char *)a1[152]);
        sub_20F58(7, v101, 0);
      }
      send(v24, &writefds, 3u, 0);
      if ( recv(v24, v101, 1u, 0) != -1
        && v101[0] == 5
        && recv(v24, v101, 1u, 0) != -1
        && BYTE2(writefds.__fds_bits[0]) == (unsigned __int8)v101[0] )
      {
        v48 = (const char *)a1[150];
        serviceb = (char *)v48;
        writefds.__fds_bits[0] = 50331909;
        v49 = strlen(v48);
        if ( v49 >= 0xFF )
          v50 = 255;
        else
          v50 = v49;
        LOBYTE(writefds.__fds_bits[1]) = v50;
        sub_254E8((char *)&writefds.__fds_bits[1] + 1, serviceb, v50, (int)"util.c", (int)"socks5_negotiate", 2796);
        v51 = strtol((const char *)a1[146], 0, 10);
        v52 = &v102[v50];
        *(v52 - 2558) = v51;
        *(v52 - 2559) = HIBYTE(v51);
        send(v24, &writefds, v50 + 7, 0);
        if ( recv(v24, v101, 1u, 0) == -1
          || v101[0] != 5
          || recv(v24, v101, 1u, 0) == -1
          || (v79 = (unsigned __int8)v101[0], v101[0])
          || (recv(v24, v101, 1u, 0), recv(v24, v101, 1u, v79) == -1) )
        {
LABEL_168:
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
          {
            v53 = a1[152];
            v54 = a1[151];
            goto LABEL_176;
          }
          goto LABEL_15;
        }
        if ( v101[0] == 1 )
        {
          v83 = 4;
          do
          {
            recv(v24, v101, 1u, 0);
            --v83;
          }
          while ( v83 );
        }
        else
        {
          if ( v101[0] != 3 )
            goto LABEL_168;
          v80 = 0;
          if ( recv(v24, v101, 1u, 0) == -1 )
            v81 = -1;
          else
            v81 = (unsigned __int8)v101[0];
          while ( v80++ < v81 )
            recv(v24, v101, 1u, 0);
        }
        recv(v24, v101, 1u, 0);
        recv(v24, v101, 1u, 0);
        if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
        {
          snprintf(
            v101,
            0x800u,
            "Success negotiating with %s:%s SOCKS5 proxy",
            (const char *)a1[151],
            (const char *)a1[152]);
          sub_20F58(7, v101, 0);
        }
        goto LABEL_117;
      }
      if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
      {
LABEL_108:
        if ( !byte_68BD5 )
          goto LABEL_16;
        v38 = 0;
LABEL_132:
        if ( !byte_68BD4 && dword_67DB4 <= 6 )
        {
LABEL_134:
          if ( !v38 )
            goto LABEL_16;
LABEL_126:
          sub_24340((int)a1);
          goto LABEL_16;
        }
LABEL_133:
        strcpy(v101, "Initiate stratum failed");
        sub_20F58(7, v101, 0);
        goto LABEL_134;
      }
      v54 = a1[151];
      v53 = a1[152];
LABEL_176:
      snprintf(v101, 0x800u, "Bad response from %s:%s SOCKS5 server", v54, v53);
      sub_20F58(4, v101, 0);
LABEL_15:
      if ( byte_68BD5 )
      {
        v38 = 0;
        goto LABEL_131;
      }
LABEL_16:
      if ( v89 )
      {
        v5 = 0;
        goto LABEL_49;
      }
      return 0;
    case 4:
      v39 = 1;
LABEL_116:
      if ( sub_26830((const char **)a1, v24, v39) )
        goto LABEL_117;
      goto LABEL_15;
    default:
      if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
        goto LABEL_108;
      snprintf(v101, 0x800u, "Unsupported proxy type for %s:%s", (const char *)a1[151], (const char *)a1[152]);
      sub_20F58(4, v101, 0);
      goto LABEL_15;
  }
}
// 27438: control flows out of bounds to 2743C
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 6AB9C: using guessed type int dword_6AB9C;
// 73398: using guessed type char byte_73398;
// 7448C: using guessed type int dword_7448C;
// 74500: using guessed type char byte_74500;
// 74501: using guessed type char byte_74501;

//----- (00028690) --------------------------------------------------------
int __fastcall sub_28690(int a1)
{
  int v3; // r5

  if ( *(_BYTE *)(a1 + 641) )
    sub_24340(a1);
  if ( sub_26AEC((_DWORD *)a1) && (!*(_BYTE *)(a1 + 580) || sub_296D0(a1)) && (v3 = sub_29AC8((_DWORD *)a1)) != 0 )
  {
    sub_32400(a1);
    return v3;
  }
  else
  {
    sub_3466C(a1);
    return 0;
  }
}
// 296D0: using guessed type int __fastcall sub_296D0(_DWORD);

//----- (0002870C) --------------------------------------------------------
int __fastcall sub_2870C(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  const char *v5; // r6
  const char *v6; // r7
  char *v7; // r8
  char *v8; // r1
  _DWORD *v9; // r0
  int v10; // r2
  const char *v11; // r5
  int v12; // r3
  void *v13; // r0
  void *v14; // r0
  _DWORD *v16; // r0
  int *v17; // r0
  int *v18; // r0
  char s[264]; // [sp+10h] [bp-A2Ch] BYREF
  int v20; // [sp+118h] [bp-924h] BYREF
  char *v21; // [sp+11Ch] [bp-920h] BYREF
  char v22[256]; // [sp+120h] [bp-91Ch] BYREF
  char v23[12]; // [sp+220h] [bp-81Ch] BYREF

  memset(v22, 0, 0xFFu);
  v4 = sub_48484(a2, 0);
  v5 = (const char *)sub_48630(v4);
  if ( !v5 )
  {
    v5 = (const char *)a1[150];
    goto LABEL_6;
  }
  v6 = (const char *)a1[150];
  v7 = strchr(v6, 46);
  if ( !v7 )
  {
    if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
      return 0;
    snprintf(v23, 0x800u, "Denied stratum reconnect request for pool without domain '%s'", v6);
    goto LABEL_20;
  }
  v8 = strchr(v5, 46);
  if ( !v8 )
  {
    if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
      return 0;
    snprintf(v23, 0x800u, "Denied stratum reconnect request to url without domain '%s'", v5);
    goto LABEL_20;
  }
  if ( strcmp(v7, v8) )
  {
    if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
      return 0;
    snprintf(v23, 0x800u, "Denied stratum reconnect request to non-matching domain url '%s'", v6);
LABEL_20:
    sub_20F58(3, v23, 0);
    return 0;
  }
LABEL_6:
  v9 = sub_48484(a2, 1u);
  v10 = sub_4888C((int)v9);
  if ( v10 )
  {
    v11 = s;
    sprintf(s, "%d", v10);
  }
  else
  {
    v16 = sub_48484(a2, 1u);
    v11 = (const char *)sub_48630(v16);
    if ( !v11 )
      v11 = (const char *)a1[146];
  }
  snprintf(v22, 0xFEu, "%s:%s", v5, v11);
  if ( !sub_23CD8(v22, &v20, &v21) )
    return 0;
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
  {
    snprintf(v23, 0x800u, "Stratum reconnect requested from pool %d to %s", *a1, v22);
    sub_20F58(4, v23, 0);
  }
  sub_33AB4(a1);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 176)) )
  {
    v17 = _errno_location();
    snprintf(v23, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v17, "util.c", "parse_reconnect", 2370);
    sub_20F58(3, v23, 1);
    sub_3EBA0(1);
  }
  sub_223C0((int)a1);
  v12 = v20;
  v13 = (void *)a1[150];
  a1[144] = v20;
  a1[150] = v12;
  free(v13);
  v14 = (void *)a1[146];
  a1[146] = v21;
  free(v14);
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176)) )
  {
    v18 = _errno_location();
    snprintf(v23, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v18, "util.c", "parse_reconnect", 2379);
    sub_20F58(3, v23, 1);
    sub_3EBA0(1);
  }
  off_67ED8();
  return sub_28690((int)a1);
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00028AE0) --------------------------------------------------------
int __fastcall sub_28AE0(_DWORD *a1, int a2)
{
  double v2; // d0
  _DWORD *v4; // r0
  _DWORD *v5; // r5
  _DWORD *v6; // r7
  _DWORD *v7; // r4
  _DWORD *v8; // r8
  const char *v9; // r0
  const char *v10; // r7
  unsigned int v11; // r4
  _DWORD *i; // r6
  bool v13; // cf
  unsigned int v14; // r1
  _DWORD *v15; // r0
  int v16; // r4
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r2
  const char *v21; // r4
  char *v22; // r0
  int v23; // r0
  int v24; // r0
  size_t v25; // r0
  _DWORD *v26; // r0
  char *v27; // r0
  _DWORD *v28; // r0
  double *v29; // r3
  double v30; // d9
  const char *v31; // r2
  int v32; // r3
  char *v33; // r9
  int v34; // r0
  int v35; // r0
  _DWORD *v36; // r0
  _DWORD *v37; // r0
  _DWORD *v38; // r0
  size_t v39; // r3
  void *v40; // r0
  void *v41; // r0
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  int *v45; // r0
  int *v46; // r0
  int v47; // [sp+0h] [bp-211Ch]
  int v48; // [sp+14h] [bp-2108h]
  char v49[92]; // [sp+1Ch] [bp-2100h] BYREF
  char v50[160]; // [sp+78h] [bp-20A4h] BYREF
  char s[8196]; // [sp+118h] [bp-2004h] BYREF

  v4 = sub_47258(a2, 0, v49);
  v5 = v4;
  if ( v4 )
  {
    v6 = (_DWORD *)sub_480FC(v4, "method");
    if ( !v6 )
      goto LABEL_14;
    v7 = (_DWORD *)sub_480FC(v5, "error");
    v8 = (_DWORD *)sub_480FC(v5, "params");
    if ( v7 && *v7 != 7 )
    {
      v21 = sub_45074(v7, 3);
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        snprintf(s, 0x800u, "JSON-RPC method decode failed: %s", v21);
        sub_20F58(6, s, 0);
      }
      v22 = (char *)v21;
      v16 = 0;
      free(v22);
      goto LABEL_15;
    }
    v9 = (const char *)sub_48630(v6);
    v10 = v9;
    if ( !v9 )
      goto LABEL_14;
    v11 = strncasecmp(v9, "mining.multi_version", 0x14u);
    if ( !v11 )
    {
      *((_BYTE *)a1 + 644) = 1;
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        strcpy(s, "Pool support multi version");
        sub_20F58(6, s, 0);
      }
      for ( i = a1 + 163; ; ++i )
      {
        v13 = v11 >= (unsigned int)sub_48468(v8);
        v14 = v11++;
        if ( v13 )
          break;
        v15 = sub_48484(v8, v14);
        *i = sub_4888C((int)v15);
      }
      goto LABEL_50;
    }
    if ( !strncasecmp(v10, "mining.notify", 0xDu) )
    {
      v16 = sub_2582C((int)a1, v8);
      if ( v16 )
      {
        *((_BYTE *)a1 + 643) = 1;
        goto LABEL_15;
      }
    }
    else
    {
      if ( strncasecmp(v10, "mining.set_version_mask", 0x17u) )
      {
        if ( !strncasecmp(v10, "mining.set_difficulty", 0x15u) )
        {
          v28 = sub_48484(v8, 0);
          sub_489C8((int)v28);
          if ( v2 == 0.0 )
            goto LABEL_14;
          if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
            sub_22864("parse_diff", 2235);
          if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
          {
            v44 = _errno_location();
            snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v44, "util.c", "parse_diff", 2235);
            sub_20F58(3, s, 1);
            sub_3EBA0(1);
          }
          v29 = (double *)(a1 + 456);
          v30 = *((double *)a1 + 227);
          *((double *)a1 + 227) = v2;
          if ( v30 <= 0.0 )
          {
            v30 = *v29;
            *v29 = v2;
          }
          if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
          {
            v43 = _errno_location();
            snprintf(
              s,
              0x800u,
              "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
              *v43,
              "util.c",
              "parse_diff",
              2248);
            sub_20F58(3, s, 1);
            sub_3EBA0(1);
          }
          if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
          {
            v42 = _errno_location();
            snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v42, "util.c", "parse_diff", 2248);
            sub_20F58(3, s, 1);
            sub_3EBA0(1);
          }
          off_67ED8();
          if ( v2 == v30 )
          {
            v16 = (unsigned __int8)byte_68BD5;
            if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
            {
              snprintf(s, 0x800u, "Pool %d difficulty set to %f", *a1, v2);
              sub_20F58(7, s, 0);
              goto LABEL_15;
            }
            goto LABEL_50;
          }
          if ( v2 != (double)(int)v2 )
          {
            if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
            {
              snprintf(s, 0x800u, "Pool %d difficulty changed to %.1f", *a1, v2);
              v16 = 1;
              sub_20F58(5, s, 0);
              goto LABEL_15;
            }
            goto LABEL_50;
          }
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
          {
            v47 = (int)v2;
            v31 = "Pool %d difficulty changed to %d";
            v32 = *a1;
LABEL_65:
            v16 = 1;
            snprintf(s, 0x800u, v31, v32, v47);
            sub_20F58(5, s, 0);
            goto LABEL_15;
          }
        }
        else
        {
          if ( !strncasecmp(v10, "mining.set_extranonce", 0x15u) )
          {
            v33 = sub_22520(v8, 0);
            v16 = sub_225A0(v33, "parse_extranonce", 2278);
            if ( v16 )
            {
              v36 = sub_48484(v8, 1u);
              v48 = sub_4888C((int)v36);
              if ( !v48 )
              {
                if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
                {
                  strcpy(s, "Failed to get valid n2size in parse_extranonce");
                  sub_20F58(6, s, 0);
                }
                v16 = 0;
                free(v33);
                goto LABEL_15;
              }
              if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
                sub_22864("parse_extranonce", 2290);
              if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
              {
                v46 = _errno_location();
                snprintf(
                  s,
                  0x800u,
                  "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                  *v46,
                  "util.c",
                  "parse_extranonce",
                  2290);
                sub_20F58(3, s, 1);
                sub_3EBA0(1);
              }
              free((void *)a1[153]);
              a1[153] = v33;
              v39 = strlen(v33) >> 1;
              v40 = (void *)a1[154];
              a1[391] = v39;
              free(v40);
              v41 = sub_22A44(a1[391], 1u, "util.c", "parse_extranonce", 2295);
              a1[154] = v41;
              if ( !v41 )
              {
                snprintf(
                  s,
                  0x800u,
                  "Failed to calloc pool->nonce1bin in %s %s():%d",
                  "util.c",
                  "parse_extranonce",
                  2297);
                sub_20F58(3, s, 1);
                sub_3EBA0(1);
              }
              sub_22CD8((_BYTE *)a1[154], (unsigned __int8 *)a1[153], a1[391]);
              a1[158] = v48;
              if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
              {
                v45 = _errno_location();
                snprintf(
                  s,
                  0x800u,
                  "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                  *v45,
                  "util.c",
                  "parse_extranonce",
                  2300);
                sub_20F58(3, s, 1);
                sub_3EBA0(1);
              }
              sub_227E8((pthread_mutex_t *)(a1 + 53), "parse_extranonce", 2300);
              off_67ED8();
              if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
              {
                snprintf(s, 0x800u, "Pool %d extranonce change requested", *a1);
                sub_20F58(5, s, 0);
                goto LABEL_15;
              }
              goto LABEL_50;
            }
            if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
            {
              strcpy(s, "Failed to get valid nonce1 in parse_extranonce");
              sub_20F58(6, s, 0);
              goto LABEL_15;
            }
            goto LABEL_14;
          }
          if ( !strncasecmp(v10, "client.reconnect", 0x10u) )
          {
            v16 = sub_2870C(a1, v8);
            goto LABEL_15;
          }
          if ( !strncasecmp(v10, "client.get_version", 0x12u) )
          {
            if ( sub_480FC(v5, "id") )
            {
              v34 = sub_480FC(v5, "id");
              v35 = sub_4888C(v34);
              sprintf(s, "{\"id\": %d, \"result\": \"cgminer/1.0.0\", \"error\": null}", v35);
              goto LABEL_44;
            }
LABEL_14:
            v16 = 0;
LABEL_15:
            if ( v5[1] != -1 )
            {
              v17 = v5 + 1;
              __dmb(0xBu);
              do
              {
                v18 = __ldrex(v17);
                v19 = v18 - 1;
              }
              while ( __strex(v19, v17) );
              if ( !v19 )
                sub_48A34(v5);
            }
            return v16;
          }
          if ( strncasecmp(v10, "client.show_message", 0x13u) )
          {
            if ( !strncasecmp(v10, "mining.ping", 0xBu) )
            {
              if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
              {
                snprintf(s, 0x800u, "Pool %d ping", *a1);
                sub_20F58(6, s, 0);
              }
              if ( !sub_480FC(v5, "id") )
              {
                v16 = 0;
                goto LABEL_15;
              }
              v23 = sub_480FC(v5, "id");
              v24 = sub_4888C(v23);
              sprintf(s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", v24);
LABEL_44:
              v25 = strlen(s);
              v16 = sub_244A4((int)a1, s, v25);
              goto LABEL_15;
            }
            goto LABEL_14;
          }
          if ( !v8 )
            goto LABEL_14;
          if ( *v8 != 1 )
            goto LABEL_14;
          v37 = sub_48484(v8, 0);
          v38 = sub_48630(v37);
          if ( !v38 )
            goto LABEL_14;
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
          {
            v31 = "Pool %d message: %s";
            v47 = (int)v38;
            v32 = *a1;
            goto LABEL_65;
          }
        }
LABEL_50:
        v16 = 1;
        goto LABEL_15;
      }
      v16 = 1;
      v26 = sub_48484(v8, 0);
      v27 = (char *)sub_48630(v26);
      sub_22E7C((int)a1, v27);
    }
    *((_BYTE *)a1 + 643) = v16;
    goto LABEL_15;
  }
  if ( byte_74500 || (v16 = (unsigned __int8)byte_68BD4, byte_68BD4) || dword_67DB4 > 5 )
  {
    v16 = 0;
    snprintf(s, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)v49, v50);
    sub_20F58(6, s, 0);
  }
  return v16;
}
// 28F8C: variable 'v2' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (000296BC) --------------------------------------------------------
int __fastcall sub_296BC(_DWORD *a1, int a2)
{
  if ( a2 )
    return sub_28AE0(a1, a2);
  else
    return 0;
}

//----- (000296D0) --------------------------------------------------------
int __fastcall sub_296D0(_DWORD *a1)
{
  int v2; // r2
  size_t v3; // r0
  int v4; // r7
  char *v5; // r5
  _BOOL4 v6; // r6
  _DWORD *v8; // r8
  _DWORD *v9; // r7
  _DWORD *v10; // r0
  _DWORD *v11; // r5
  const char *v12; // r7
  char *v13; // r5
  unsigned int *v14; // r3
  unsigned int v15; // r2
  unsigned int v16; // r2
  char v17[252]; // [sp+Ch] [bp-28FCh] BYREF
  char s[2040]; // [sp+108h] [bp-2800h] BYREF
  char v19[8192]; // [sp+908h] [bp-2000h] BYREF

  v2 = dword_7448C++;
  sprintf(v19, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v2);
  v3 = strlen(v19);
  v4 = sub_244A4((int)a1, v19, v3);
  if ( v4 )
  {
    while ( 1 )
    {
      v6 = sub_22428(a1[147], 2);
      if ( !v6 )
      {
        if ( byte_68BD5 )
        {
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
          {
            v4 = (unsigned __int8)byte_68BD5;
            strcpy(s, "Timed out waiting for response extranonce.subscribe");
            sub_20F58(7, s, 0);
          }
          else
          {
            return (unsigned __int8)byte_68BD5;
          }
        }
        return v4;
      }
      v5 = sub_24858((int)a1);
      if ( !v5 )
        return 0;
      if ( !sub_28AE0(a1, (int)v5) )
        break;
      free(v5);
    }
    v8 = sub_47258((int)v5, 0, v17);
    free(v5);
    v9 = (_DWORD *)sub_480FC(v8, "result");
    v10 = (_DWORD *)sub_480FC(v8, "error");
    v11 = v10;
    if ( !v9 || *v9 == 6 )
    {
      if ( !v10 )
      {
        v13 = (char *)malloc(0x11u);
        if ( v13 )
          strcpy(v13, "(unknown reason)");
        goto LABEL_30;
      }
    }
    else if ( !v10 || *v10 == 7 )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        v4 = v6;
        snprintf(s, 0x800u, "Stratum extranonce subscribe for pool %d", *a1);
        sub_20F58(6, s, 0);
        goto LABEL_35;
      }
LABEL_26:
      v4 = v6;
LABEL_35:
      if ( v8 )
      {
        if ( v8[1] != -1 )
        {
          v14 = v8 + 1;
          __dmb(0xBu);
          do
          {
            v15 = __ldrex(v14);
            v16 = v15 - 1;
          }
          while ( __strex(v16, v14) );
          if ( !v16 )
            sub_48A34(v8);
        }
      }
      return v4;
    }
    v12 = (const char *)sub_224BC(v10, 1u);
    if ( !v12 && (v12 = (const char *)sub_48630(v11)) == 0
      || strcmp(v12, "Method 'subscribe' not found for service 'mining.extranonce'")
      && strcmp(v12, "Unrecognized request provided") )
    {
      v13 = sub_45074(v11, 3);
LABEL_30:
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        snprintf(s, 0x800u, "Pool %d JSON extranonce subscribe failed: %s", *a1, v13);
        sub_20F58(6, s, 0);
      }
      v4 = 0;
      free(v13);
      goto LABEL_35;
    }
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
    {
      v4 = v6;
      snprintf(s, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", *a1);
      sub_20F58(6, s, 0);
      goto LABEL_35;
    }
    goto LABEL_26;
  }
  return v4;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 7448C: using guessed type int dword_7448C;
// 74500: using guessed type char byte_74500;

//----- (00029AC8) --------------------------------------------------------
int __fastcall sub_29AC8(_DWORD *a1)
{
  const char *v1; // r3
  int v3; // r2
  size_t v4; // r0
  int v5; // r9
  int v6; // r6
  char *v7; // r5
  _DWORD *v9; // r8
  _DWORD *v10; // r5
  _DWORD *v11; // r0
  char *v12; // r5
  unsigned int *v13; // r3
  unsigned int v14; // r2
  unsigned int v15; // r2
  int v16; // r3
  int v17; // r2
  size_t v18; // r0
  int v19; // r2
  size_t v20; // r0
  const char *v21; // [sp+0h] [bp-290Ch]
  char v22[252]; // [sp+Ch] [bp-2900h] BYREF
  char s[2040]; // [sp+108h] [bp-2804h] BYREF
  char v24[8196]; // [sp+908h] [bp-2004h] BYREF

  v1 = (const char *)a1[43];
  v3 = dword_7448C;
  v21 = (const char *)a1[44];
  ++dword_7448C;
  sprintf(v24, "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}", v3, v1, v21);
  v4 = strlen(v24);
  v5 = sub_244A4((int)a1, v24, v4);
  if ( v5 )
  {
    while ( 1 )
    {
      v7 = sub_24858((int)a1);
      if ( !v7 )
        return 0;
      v6 = sub_28AE0();
      if ( !v6 )
        break;
      free(v7);
    }
    v9 = sub_47258((int)v7, 0, v22);
    free(v7);
    v10 = (_DWORD *)sub_480FC(v9, "result");
    v11 = (_DWORD *)sub_480FC(v9, "error");
    if ( !v10 || *v10 == 6 )
    {
      if ( !v11 )
      {
        v12 = (char *)malloc(0x11u);
        if ( v12 )
          strcpy(v12, "(unknown reason)");
        goto LABEL_13;
      }
    }
    else if ( !v11 || *v11 == 7 )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        snprintf(s, 0x800u, "Stratum authorisation success for pool %d", *a1);
        sub_20F58(6, s, 0);
      }
      v16 = dword_73480;
      byte_68BD6 = 1;
      *((_BYTE *)a1 + 99) = 1;
      if ( v16 )
      {
        v19 = dword_7448C++;
        sprintf(v24, "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}", v19, v16);
        v20 = strlen(v24);
        sub_244A4((int)a1, v24, v20);
      }
      v6 = (unsigned __int8)byte_68820;
      if ( byte_68820 )
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
        {
          strcpy(s, "LOW POWER MODE!");
          sub_20F58(5, s, 0);
        }
        v17 = dword_7448C++;
        sprintf(
          v24,
          "{\"id\":%d, \"method\":\"mining.configure\", \"params\":[[\"version-rolling\"],{\"version-rolling.mask\":\"%08"
          "x\",\"version-rolling.min-bit-count\":%d}]}",
          v17,
          14680064,
          3);
        v18 = strlen(v24);
        sub_244A4((int)a1, v24, v18);
        a1[162] = 8;
      }
      else
      {
        v6 = v5;
      }
      goto LABEL_17;
    }
    v12 = sub_45074(v11, 3);
LABEL_13:
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
    {
      snprintf(s, 0x800u, "pool %d JSON stratum auth failed: %s", *a1, v12);
      sub_20F58(6, s, 0);
    }
    free(v12);
    sub_24340((int)a1);
LABEL_17:
    if ( v9 )
    {
      if ( v9[1] != -1 )
      {
        v13 = v9 + 1;
        __dmb(0xBu);
        do
        {
          v14 = __ldrex(v13);
          v15 = v14 - 1;
        }
        while ( __strex(v15, v13) );
        if ( !v15 )
          sub_48A34(v9);
      }
    }
    return v6;
  }
  return 0;
}
// 28AE0: using guessed type int sub_28AE0(void);
// 67DB4: using guessed type int dword_67DB4;
// 68820: using guessed type char byte_68820;
// 68BD4: using guessed type char byte_68BD4;
// 68BD6: using guessed type char byte_68BD6;
// 73480: using guessed type int dword_73480;
// 7448C: using guessed type int dword_7448C;
// 74500: using guessed type char byte_74500;

//----- (00029E78) --------------------------------------------------------
int __fastcall sub_29E78(int *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // r12
  int v4; // r3

  if ( *a2 > *a3 )
    return -1;
  if ( *a2 == *a3 && a2[1] > a3[1] )
    return -1;
  v3 = *a3 - *a2;
  *a1 = v3;
  v4 = a3[1] - a2[1];
  a1[1] = v4;
  if ( v4 < 0 )
  {
    *a1 = v3 - 1;
    a1[1] = v4 + 1000000;
  }
  return 0;
}

//----- (00029EF4) --------------------------------------------------------
_BYTE *__fastcall sub_29EF4(_BYTE *result, int a2)
{
  _BYTE *v2; // r12
  unsigned int v3; // r3
  char v4; // lr
  char v5; // t1
  char v6; // t1

  if ( a2 != 1 )
  {
    v2 = result - 1;
    v3 = 0;
    result += a2;
    do
    {
      ++v3;
      v5 = *++v2;
      v4 = v5;
      v6 = *--result;
      *v2 = v6;
      *result = v4;
    }
    while ( v3 < ~v3 + a2 );
  }
  return result;
}

//----- (00029F34) --------------------------------------------------------
int __fastcall sub_29F34(int result, char a2)
{
  unsigned int v2; // r1
  unsigned int v3; // r1
  int v4; // r1
  unsigned int v5; // r1
  unsigned int v6; // r1

  switch ( result )
  {
    case 1:
      return result;
    case 2:
      if ( (a2 & 0x80) != 0x80 )
        result = 1;
      break;
    case 4:
      v4 = a2 & 0xC0;
      if ( v4 == 128 )
        goto LABEL_29;
      if ( v4 != 192 )
      {
        if ( v4 == 64 )
          result = 2;
        else
          result = 1;
      }
      break;
    case 8:
      v5 = a2 & 0xE0;
      if ( v5 == 128 )
        goto LABEL_50;
      if ( v5 <= 0x80 )
      {
        if ( v5 == 64 )
          goto LABEL_29;
        if ( v5 == 96 )
          goto LABEL_49;
        if ( v5 != 32 )
          goto LABEL_9;
        goto LABEL_25;
      }
      if ( v5 == 192 )
        goto LABEL_48;
      if ( v5 != 224 )
      {
        if ( v5 != 160 )
          goto LABEL_9;
        goto LABEL_39;
      }
      break;
    case 16:
      v2 = a2 & 0xF0;
      if ( v2 == 128 )
      {
        result = 9;
      }
      else if ( v2 > 0x80 )
      {
        if ( v2 == 192 )
        {
          result = 13;
        }
        else if ( v2 <= 0xC0 )
        {
          switch ( v2 )
          {
            case 0xA0u:
              result = 11;
              break;
            case 0xB0u:
              result = 12;
              break;
            case 0x90u:
              result = 10;
              break;
            default:
              goto LABEL_9;
          }
        }
        else if ( v2 == 224 )
        {
          result = 15;
        }
        else if ( v2 != 240 )
        {
          if ( v2 != 208 )
            goto LABEL_9;
          result = 14;
        }
      }
      else if ( v2 == 64 )
      {
LABEL_50:
        result = 5;
      }
      else if ( v2 > 0x40 )
      {
        switch ( v2 )
        {
          case '`':
LABEL_48:
            result = 7;
            break;
          case 'p':
            result = 8;
            break;
          case 'P':
LABEL_39:
            result = 6;
            break;
          default:
            goto LABEL_9;
        }
      }
      else
      {
        switch ( v2 )
        {
          case 0x20u:
LABEL_29:
            result = 3;
            break;
          case 0x30u:
LABEL_49:
            result = 4;
            break;
          case 0x10u:
LABEL_25:
            result = 2;
            break;
          default:
            goto LABEL_9;
        }
      }
      break;
    case 32:
      v6 = (unsigned __int8)((a2 & 0xF8) - 8);
      if ( v6 > 0xF0 )
        goto LABEL_9;
      result = *((char *)&unk_4C8CC + v6 + 2004);
      break;
    case 64:
      v3 = (unsigned __int8)((a2 & 0xFC) - 4);
      if ( v3 > 0xF8 )
LABEL_9:
        result = 1;
      else
        result = *((char *)&unk_4C8CC + v3 + 2248);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 29F40: control flows out of bounds to 29F44

//----- (0002A21C) --------------------------------------------------------
void __fastcall sub_2A21C(int a1, char *a2, int a3)
{
  int v5; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int *v13; // lr
  _DWORD *v14; // r12
  int v15; // r1
  int v16; // r2
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r1
  int v21; // r2
  int v22; // r3
  char v23; // r3
  char v24; // t1
  char v25; // t1
  char *v26; // r2
  _DWORD *v27; // r3
  char v28; // t1
  char v29; // r1
  _DWORD *v30; // r3
  char *v31; // r2
  char v32; // r1
  char v33; // t1
  char v34; // t1
  const char *v35; // r5
  char *v36; // r8
  char *v37; // r7
  char *v38; // r9
  char *v39; // r6
  unsigned __int64 v40; // r0
  size_t v41; // r0
  int v42; // r4
  size_t v43; // r0
  unsigned __int64 v44; // r2
  int i; // r4
  size_t v46; // r0
  size_t v47; // r0
  char *ptr; // [sp+20h] [bp-C7Ch]
  char *v50; // [sp+28h] [bp-C74h]
  __int64 v51; // [sp+2Ch] [bp-C70h]
  char *v52; // [sp+34h] [bp-C68h] BYREF
  _DWORD v53[3]; // [sp+38h] [bp-C64h] BYREF
  _DWORD v54[5]; // [sp+44h] [bp-C58h] BYREF
  int v55; // [sp+58h] [bp-C44h] BYREF
  _DWORD v56[2]; // [sp+5Ch] [bp-C40h] BYREF
  _DWORD v57[4]; // [sp+64h] [bp-C38h] BYREF
  int v58; // [sp+74h] [bp-C28h] BYREF
  _DWORD v59[3]; // [sp+78h] [bp-C24h] BYREF
  _DWORD v60[5]; // [sp+84h] [bp-C18h] BYREF
  char s[1024]; // [sp+98h] [bp-C04h] BYREF
  char v62[2052]; // [sp+498h] [bp-804h] BYREF

  memset(s, 0, sizeof(s));
  v5 = *(_DWORD *)(a1 + 128);
  memset(v57, 0, sizeof(v57));
  v6 = *(_DWORD *)(a1 + 132);
  v7 = *(_DWORD *)(a1 + 136);
  v8 = *(_DWORD *)(a1 + 140);
  v53[0] = v5;
  v53[1] = v6;
  v53[2] = v7;
  v54[0] = v8;
  v9 = *(_DWORD *)(a1 + 144);
  v10 = *(_DWORD *)(a1 + 148);
  v11 = *(_DWORD *)(a1 + 152);
  v12 = *(_DWORD *)(a1 + 156);
  v13 = &v55;
  v58 = 0;
  v54[1] = v9;
  v54[2] = v10;
  v54[3] = v11;
  v54[4] = v12;
  v14 = (char **)((char *)&v52 + 3);
  v15 = *(_DWORD *)(a1 + 68);
  v16 = *(_DWORD *)(a1 + 72);
  v55 = *(_DWORD *)(a1 + 64);
  v56[0] = v15;
  v56[1] = v16;
  v17 = *(_DWORD *)(a1 + 196);
  v18 = *(_DWORD *)(a1 + 200);
  v19 = *(_DWORD *)(a1 + 204);
  v59[0] = *(_DWORD *)(a1 + 192);
  v59[1] = v17;
  v59[2] = v18;
  v60[0] = v19;
  v20 = *(_DWORD *)(a1 + 212);
  v21 = *(_DWORD *)(a1 + 216);
  v22 = *(_DWORD *)(a1 + 220);
  v60[1] = *(_DWORD *)(a1 + 208);
  v60[2] = v20;
  v60[3] = v21;
  v60[4] = v22;
  do
  {
    v24 = *((_BYTE *)v14 + 1);
    v14 = (_DWORD *)((char *)v14 + 1);
    v23 = v24;
    v25 = *((_BYTE *)v13 - 1);
    v13 = (int *)((char *)v13 - 1);
    *(_BYTE *)v14 = v25;
    *(_BYTE *)v13 = v23;
  }
  while ( v14 != (_DWORD *)((char *)v54 + 3) );
  v26 = (char *)&v55;
  v27 = v57;
  do
  {
    v28 = *((_BYTE *)v27 - 1);
    v27 = (_DWORD *)((char *)v27 - 1);
    v29 = *v26;
    *v26++ = v28;
    *(_BYTE *)v27 = v29;
  }
  while ( (_DWORD *)((char *)v56 + 2) != v27 );
  v30 = (int *)((char *)&v58 + 3);
  v31 = s;
  do
  {
    v33 = *((_BYTE *)v30 + 1);
    v30 = (_DWORD *)((char *)v30 + 1);
    v32 = v33;
    v34 = *--v31;
    *(_BYTE *)v30 = v34;
    *v31 = v32;
  }
  while ( v30 != (_DWORD *)((char *)v60 + 3) );
  ptr = sub_22C24(a1, 128);
  v35 = "o";
  v36 = sub_22C24((int)v53, 32);
  v37 = sub_22C24((int)&v55, 12);
  v50 = sub_22C24((int)a2, 4);
  v38 = sub_22C24((int)a2, 5);
  v39 = sub_22C24((int)v59, 32);
  v40 = sub_2CDF0((__int64 *)a1);
  HIDWORD(v51) = HIDWORD(v40);
  if ( !a3 )
    v35 = "x";
  LODWORD(v51) = v40;
  sprintf(
    s,
    "%s %08x midstate %s data %s nonce %s hash %s diff %lld",
    v35,
    *(_DWORD *)(a1 + 340),
    v36,
    v37,
    v38,
    v39,
    v40);
  if ( !strcmp((const char *)dword_68DE0, "screen") )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      snprintf(v62, 0x800u, s);
      sub_20F58(3, v62, 0);
    }
  }
  else
  {
    v52 = &byte_74500;
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      snprintf(v62, 0x800u, s);
      sub_20F58(3, v62, 0);
    }
    if ( dword_6A974 )
    {
      sprintf(
        s,
        "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
        v35,
        *(_DWORD *)(a1 + 340),
        ptr,
        v36,
        v37,
        v38,
        v39,
        v51);
      v41 = strlen(s);
      fwrite(s, v41, 1u, (FILE *)dword_6A974);
      fwrite(&word_4C858, 1u, 1u, (FILE *)dword_6A974);
      fflush((FILE *)dword_6A974);
      if ( a3 )
      {
        if ( dword_6A970 == 1 )
        {
          sprintf(s, "midstate %s data %s nonce %s hash %s", v36, v37, v50, v39);
          v47 = strlen(s);
          fwrite(s, v47, 1u, (FILE *)dword_6A978[0]);
          fwrite(&word_4C858, 1u, 1u, (FILE *)dword_6A978[0]);
          fflush((FILE *)dword_6A978[0]);
        }
        else if ( ((dword_6A970 - 32) & 0xFFFFFFDF) == 0 )
        {
          sprintf(s, "midstate %s data %s nonce %s hash %s", v36, v37, v50, v39);
          v42 = sub_29F34(dword_6A970, *a2);
          v43 = strlen(s);
          fwrite(s, v43, 1u, (FILE *)dword_6A978[v42]);
          fwrite(&word_4C858, 1u, 1u, (FILE *)dword_6A978[v42]);
          fflush((FILE *)dword_6A978[v42]);
        }
        if ( byte_6AA7C )
        {
          v44 = v51;
          for ( i = 0; i != 64; ++i )
          {
            v44 >>= 1;
            if ( !v44 )
              break;
          }
          if ( byte_68BD5 && (*v52 || byte_68BD4 || dword_67DB4 > 6) )
          {
            snprintf(v62, 0x800u, "work diff %lld diffnum %d", v51, i);
            sub_20F58(7, v62, 0);
          }
          sprintf(s, "midstate %s data %s nonce %s hash %s", v36, v37, v50, v39);
          v46 = strlen(s);
          fwrite(s, v46, 1u, *((FILE **)&unk_6AA80 + i));
          fwrite(&word_4C858, 1u, 1u, *((FILE **)&unk_6AA80 + i));
          fflush(*((FILE **)&unk_6AA80 + i));
        }
      }
    }
  }
  if ( ptr )
    free(ptr);
  if ( v36 )
    free(v36);
  if ( v37 )
    free(v37);
  if ( v50 )
    free(v50);
  if ( v38 )
    free(v38);
  if ( v39 )
    free(v39);
}
// 4C858: using guessed type __int16 word_4C858;
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 68DE0: using guessed type int dword_68DE0;
// 6A970: using guessed type int dword_6A970;
// 6A974: using guessed type int dword_6A974;
// 6A978: using guessed type int dword_6A978[65];
// 6AA7C: using guessed type char byte_6AA7C;
// 74500: using guessed type char byte_74500;

//----- (0002A83C) --------------------------------------------------------
void __fastcall sub_2A83C(int a1, char *a2, int a3)
{
  if ( dword_68DE0 )
    sub_2A21C(a1, a2, a3);
}
// 68DE0: using guessed type int dword_68DE0;

//----- (0002A854) --------------------------------------------------------
void __fastcall sub_2A854(int a1, int a2, int a3)
{
  int v3; // [sp+0h] [bp-10h] BYREF
  char v4; // [sp+4h] [bp-Ch]

  if ( dword_68DE0 )
  {
    v3 = a2;
    v4 = 0;
    sub_2A21C(a1, (char *)&v3, a3);
  }
}
// 68DE0: using guessed type int dword_68DE0;

//----- (0002A9C4) --------------------------------------------------------
int __fastcall sub_2A9C4(int result, unsigned int *a2, unsigned int a3)
{
  unsigned int v3; // r2
  unsigned int *v4; // r2
  unsigned int v5; // t1

  v3 = a3 >> 2;
  if ( v3 )
  {
    v4 = &a2[v3];
    result -= 4;
    do
    {
      v5 = *a2++;
      *(_DWORD *)(result + 4) = bswap32(v5);
      result += 4;
    }
    while ( a2 != v4 );
  }
  return result;
}

//----- (0002A9F0) --------------------------------------------------------
int __fastcall sub_2A9F0(_DWORD *a1)
{
  *a1 = 4;
  return 0;
}

//----- (0002AA00) --------------------------------------------------------
int __fastcall sub_2AA00(_DWORD *a1)
{
  *a1 = 3;
  return 0;
}

//----- (0002AA10) --------------------------------------------------------
int __fastcall sub_2AA10(_DWORD *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0002AA20) --------------------------------------------------------
int __fastcall sub_2AA20(_BYTE *a1)
{
  *a1 = 1;
  byte_68BD4 = 1;
  return 0;
}
// 68BD4: using guessed type char byte_68BD4;

//----- (0002AA3C) --------------------------------------------------------
int sub_2AA3C()
{
  return 0;
}

//----- (0002AA4C) --------------------------------------------------------
int sub_2AA4C()
{
  return 1;
}

//----- (0002AA54) --------------------------------------------------------
__int64 sub_2AA54()
{
  return 0xFFFFFFFFLL;
}

//----- (0002AA60) --------------------------------------------------------
int sub_2AA60()
{
  return 1;
}

//----- (0002AA6C) --------------------------------------------------------
int sub_2AA6C()
{
  return 0;
}

//----- (0002AA74) --------------------------------------------------------
int __fastcall sub_2AA74(int result)
{
  *(_QWORD *)(result + 208) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_QWORD *)(result + 200) = 0;
  return result;
}

//----- (0002AA90) --------------------------------------------------------
void __noreturn sub_2AA90(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  vsnprintf(byte_68BD8, 0x200u, a1, varg_r1);
  sub_20F58(3, byte_68BD8, 1);
  exit(1);
}

//----- (0002AAD8) --------------------------------------------------------
int __fastcall sub_2AAD8(int a1)
{
  sub_4014C(a1, &dword_68DD8);
  return 0;
}
// 68DD8: using guessed type int dword_68DD8;

//----- (0002AAF0) --------------------------------------------------------
int __fastcall sub_2AAF0(int a1)
{
  sub_4014C(a1, &dword_68DDC);
  return 0;
}
// 68DDC: using guessed type int dword_68DDC;

//----- (0002AB08) --------------------------------------------------------
int __fastcall sub_2AB08(int a1)
{
  sub_4014C(a1, &dword_68DE0);
  return 0;
}
// 68DE0: using guessed type int dword_68DE0;

//----- (0002AB20) --------------------------------------------------------
int __fastcall sub_2AB20(int a1)
{
  sub_4014C(a1, &dword_68DE4);
  return 0;
}
// 68DE4: using guessed type int dword_68DE4;

//----- (0002AB38) --------------------------------------------------------
int __fastcall sub_2AB38(int a1)
{
  sub_4014C(a1, &dword_68DE8);
  return 0;
}
// 68DE8: using guessed type int dword_68DE8;

//----- (0002AB50) --------------------------------------------------------
int __fastcall sub_2AB50(int a1)
{
  sub_4014C(a1, &dword_73478);
  return 0;
}
// 73478: using guessed type int dword_73478;

//----- (0002AD7C) --------------------------------------------------------
_BYTE *__fastcall sub_2AD7C(const char *a1)
{
  const char *v1; // r4
  size_t v2; // r0
  _BYTE *v3; // r5
  _DWORD *v4; // r0
  int v5; // r2
  _BYTE *v6; // r2
  int i; // r3
  bool v8; // zf
  _BYTE *v9; // r3
  char v10; // t1

  v1 = a1;
  v2 = strlen(a1);
  v3 = sub_229BC(2 * v2 + 1, "cgminer.c", "json_escape", 5921);
  v4 = sub_229BC(8u, "cgminer.c", "json_escape", 5922);
  *v4 = v3;
  v5 = dword_68DF0;
  dword_68DF0 = (int)v4;
  v4[1] = v5;
  v6 = v3;
  for ( i = *(unsigned __int8 *)v1; *v1; i = *(unsigned __int8 *)v1 )
  {
    v8 = i == 34;
    if ( i != 34 )
      v8 = i == 92;
    v9 = v6 + 1;
    if ( v8 )
    {
      *v6 = 92;
      v6 += 2;
    }
    else
    {
      v9 = v6++;
    }
    v10 = *v1++;
    *v9 = v10;
  }
  *v6 = 0;
  return v3;
}
// 68DF0: using guessed type int dword_68DF0;

//----- (0002AE34) --------------------------------------------------------
void __fastcall __noreturn sub_2AE34(const char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", s);
  v2 = sub_410E8((const char *)dword_76868, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 68A74: using guessed type int stdout;
// 76868: using guessed type int dword_76868;

//----- (0002AE8C) --------------------------------------------------------
time_t __fastcall sub_2AE8C(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 1;
  sub_239A4((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (0002AEC4) --------------------------------------------------------
time_t __fastcall sub_2AEC4(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 0;
  sub_239A4((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (0002AEF8) --------------------------------------------------------
int __fastcall sub_2AEF8(unsigned __int64 a1, char *s, size_t maxlen, int a4)
{
  double v6; // d8
  int v8; // r1
  double v9; // r0
  __int16 v10; // [sp+1Ch] [bp-4h] BYREF

  v10 = 0;
  if ( a1 <= 0xDE0B6B3A763FFFFLL )
  {
    if ( a1 <= 0x38D7EA4C67FFFLL )
    {
      if ( a1 > 0xE8D4A50FFFLL )
      {
        LODWORD(a1) = sub_4A178(a1, 0x3B9ACA00u);
        v10 = 84;
        v6 = (double)(int)a1 / 1000.0;
        if ( !a4 )
          return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
      }
      else if ( a1 <= 0x3B9AC9FF )
      {
        if ( a1 > 0xF423F )
        {
          LODWORD(a1) = sub_4A178(a1, 0x3E8u);
          v10 = 77;
          v6 = (double)(int)a1 / 1000.0;
          if ( !a4 )
            return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
        }
        else
        {
          v6 = (double)(int)a1;
          if ( a1 <= 0x3E7 )
          {
            if ( !a4 )
              return snprintf(s, maxlen, "%d%s", (_DWORD)a1, (const char *)&v10);
          }
          else
          {
            v10 = 75;
            v6 = v6 / 1000.0;
            if ( !a4 )
              return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
          }
        }
      }
      else
      {
        LODWORD(a1) = sub_4A178(a1, 0xF4240u);
        v10 = 71;
        v6 = (double)(int)a1 / 1000.0;
        if ( !a4 )
          return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
      }
    }
    else
    {
      LODWORD(a1) = sub_4A178(a1, 0xE8D4A51000uLL);
      v10 = 80;
      v6 = (double)(int)a1 / 1000.0;
      if ( !a4 )
        return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
    }
  }
  else
  {
    LODWORD(a1) = sub_4A178(a1, 0x38D7EA4C68000uLL);
    v10 = 69;
    v6 = (double)(int)a1 / 1000.0;
    if ( !a4 )
      return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
  }
  if ( v6 > 0.0 )
  {
    v9 = log10(*(double *)&a1);
    floor(v9);
    v8 = (int)(3.0 - v6);
  }
  else
  {
    v8 = 3;
  }
  return snprintf(s, maxlen, "%*.*f%s", a4 + 1, v8, v6, (const char *)&v10);
}
// 2B0B4: variable 'a1' is possibly undefined

//----- (0002B1B0) --------------------------------------------------------
int __fastcall sub_2B1B0(int a1)
{
  double v1; // d0
  int v3; // r4
  double v4; // d8
  unsigned __int64 v5; // r0
  int result; // r0
  double v7; // d7
  double v8; // d7
  double v9; // r0
  double v10; // d8
  double v11; // r0
  double v12; // d8
  double v13; // r0
  double v14; // d8
  double v15; // r0
  double v16; // d7

  v3 = *(_DWORD *)(a1 + 260);
  if ( v1 == 0.0 )
  {
    LODWORD(v9) = sub_4A10C(*(_QWORD *)(a1 + 184));
    v10 = v9 * 6.27710174e57;
    LODWORD(v11) = sub_4A10C(*(_QWORD *)(a1 + 176));
    v12 = v10 + v11 * 3.40282367e38;
    LODWORD(v13) = sub_4A10C(*(_QWORD *)(a1 + 168));
    v14 = v12 + v13 * 1.84467441e19;
    LODWORD(v15) = sub_4A10C(*(_QWORD *)(a1 + 160));
    v16 = v15 + v14;
    if ( v15 + v14 == 0.0 )
    {
      v4 = 2.69595353e67;
      v5 = -1;
    }
    else
    {
      v4 = 2.69595353e67 / v16;
      round();
      v5 = (unsigned __int64)(2.69595353e67 / v16);
    }
    *(double *)(a1 + 376) = v4;
  }
  else
  {
    *(double *)(a1 + 376) = v1;
    v4 = v1;
    round();
    v5 = (unsigned __int64)v1;
  }
  *(double *)(v3 + 480) = v4;
  result = sub_2AEF8(v5, (char *)(*(_DWORD *)(a1 + 260) + 48), 8u, 0);
  v7 = *(double *)(v3 + 464);
  if ( v7 == v4 )
  {
    ++*(_DWORD *)(v3 + 488);
    goto LABEL_5;
  }
  if ( v7 <= v4 )
  {
    if ( v7 != 0.0 )
    {
LABEL_5:
      v8 = *(double *)(v3 + 472);
      if ( v8 != v4 )
        goto LABEL_6;
LABEL_15:
      ++*(_DWORD *)(v3 + 492);
      return result;
    }
    *(double *)(v3 + 464) = v4;
    *(_DWORD *)(v3 + 488) = 1;
  }
  else
  {
    *(double *)(v3 + 464) = v4;
    *(_DWORD *)(v3 + 488) = 1;
  }
  v8 = *(double *)(v3 + 472);
  if ( v8 == v4 )
    goto LABEL_15;
LABEL_6:
  if ( v8 < v4 )
  {
    *(double *)(v3 + 472) = v4;
    *(_DWORD *)(v3 + 492) = 1;
  }
  return result;
}
// 2B1CC: variable 'v1' is possibly undefined
// 2B260: variable 'v9' is possibly undefined
// 2B274: variable 'v11' is possibly undefined
// 2B288: variable 'v13' is possibly undefined
// 2B294: variable 'v15' is possibly undefined
// 1225C: using guessed type int round(void);

//----- (0002B350) --------------------------------------------------------
int __fastcall sub_2B350(int a1)
{
  int v2; // r1
  char *v3; // r2
  unsigned int v4; // t1
  char v6[28]; // [sp+0h] [bp-70h] BYREF
  char v7; // [sp+1Ch] [bp-54h] BYREF
  char v8[76]; // [sp+20h] [bp-50h] BYREF
  char v9; // [sp+6Ch] [bp-4h] BYREF

  v2 = a1 - 4;
  v3 = &v7;
  do
  {
    v4 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    *((_DWORD *)v3 + 1) = bswap32(v4);
    v3 += 4;
  }
  while ( v3 != &v9 );
  sub_21C34(v8, 0x50u, v6);
  return sub_21C34(v6, 0x20u, (_BYTE *)(a1 + 192));
}

//----- (0002B3A4) --------------------------------------------------------
void __fastcall sub_2B3A4(int a1)
{
  int v2; // r1
  int *v3; // r2
  unsigned int v4; // t1
  int v5; // [sp+4h] [bp-ECh] BYREF
  char v6[60]; // [sp+8h] [bp-E8h] BYREF
  char v7; // [sp+44h] [bp-ACh] BYREF
  _DWORD v8[34]; // [sp+48h] [bp-A8h] BYREF
  _BYTE v9[32]; // [sp+D0h] [bp-20h] BYREF

  v2 = a1 - 4;
  v3 = &v5;
  do
  {
    v4 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    v3[1] = bswap32(v4);
    ++v3;
  }
  while ( v3 != (int *)&v7 );
  sub_21A6C(v8);
  sub_21A9C((unsigned __int8 *)v8, v6, 0x40u);
  sub_254E8((void *)(a1 + 128), v9, 0x20u, (int)"cgminer.c", (int)"calc_midstate", 2256);
}

//----- (0002B41C) --------------------------------------------------------
void sub_2B41C()
{
  int v0; // r4
  int v1; // r3
  int v2; // r3
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( dword_733CC > 0 )
  {
    v0 = 0;
    do
    {
      v1 = *(_DWORD *)(dword_744C8 + 4 * v0);
      *(_BYTE *)(v1 + 284) = 1;
      pthread_create((pthread_t *)(v1 + 280), 0, (void *(*)(void *))sub_35D3C, (void *)v1);
      v2 = v0++;
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
      {
        snprintf(v3, 0x800u, "create test_pool_thread pool[%d]\n", v2);
        sub_20F58(5, v3, 0);
      }
    }
    while ( dword_733CC > v0 );
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;

//----- (0002B4EC) --------------------------------------------------------
int sub_2B4EC()
{
  pthread_t v0; // r0

  v0 = pthread_self();
  pthread_detach(v0);
  return 0;
}

//----- (0002B500) --------------------------------------------------------
int __fastcall sub_2B500(int a1)
{
  _DWORD *v1; // r6
  int v3; // r5
  char v5[16]; // [sp+0h] [bp-810h] BYREF
  char v6[2048]; // [sp+10h] [bp-800h] BYREF

  v1 = *(_DWORD **)(a1 + 36);
  v3 = v1[1];
  snprintf(v5, 0x10u, "%d/Miner", *(_DWORD *)a1);
  sub_250A8(v5);
  sub_2AE8C(a1);
  if ( (*(int (__fastcall **)(int))(v3 + 52))(a1) )
  {
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      strcpy(v6, "Waiting on sem in miner thread");
      sub_20F58(7, v6, 0);
    }
    sub_25228((sem_t *)(a1 + 16), "cgminer.c", "miner_thread", 9801);
    v1[58] = time(0);
    (*(void (__fastcall **)(int))(v3 + 60))(a1);
    (*(void (__fastcall **)(int))(v3 + 88))(a1);
    return 0;
  }
  else
  {
    sub_24DC4(v1, 0);
    return 0;
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (0002B63C) --------------------------------------------------------
void __noreturn sub_2B63C()
{
  pthread_t v0; // r0

  v0 = pthread_self();
  pthread_detach(v0);
  pthread_setcanceltype(1, 0);
  sleep(7u);
  exit(1);
}

//----- (0002B664) --------------------------------------------------------
_DWORD *__fastcall sub_2B664(_DWORD *result)
{
  ++dword_74578;
  *result = 1;
  return result;
}
// 74578: using guessed type int dword_74578;

//----- (0002B684) --------------------------------------------------------
int __fastcall sub_2B684(unsigned __int8 *a1)
{
  int v1; // r3

  v1 = a1[640];
  if ( a1[640] && a1[641] )
    return a1[643] ^ 1;
  return v1;
}

//----- (0002B6A8) --------------------------------------------------------
int __fastcall sub_2B6A8(int a1)
{
  int v1; // r7
  int v2; // r5
  int *v3; // r4
  int v4; // r6
  int v5; // r1
  int v6; // t1
  int v7; // r1

  v1 = *(_DWORD *)(a1 + 156);
  v2 = a1;
  if ( dword_733CC > 0 )
  {
    v3 = (int *)dword_744C8;
    v4 = dword_744C8 + 4 * dword_733CC;
    do
    {
      v6 = *v3++;
      v5 = v6;
      if ( !*(_BYTE *)(v6 + 97)
        && *(_DWORD *)(v5 + 100) == 1
        && !sub_2B684((unsigned __int8 *)v5)
        && *(_DWORD *)(v7 + 156) < v1 )
      {
        v2 = v7;
        v1 = *(_DWORD *)(v7 + 156);
      }
    }
    while ( v3 != (int *)v4 );
    v1 = *(_DWORD *)(v2 + 156);
  }
  *(_DWORD *)(v2 + 156) = v1 + 1;
  return v2;
}
// 2B704: variable 'v7' is possibly undefined
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (0002B730) --------------------------------------------------------
int __fastcall sub_2B730(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    snprintf(v3, 0x800u, "WTF No pool %d found!", a1);
    sub_20F58(3, v3, 0);
  }
  return *(_DWORD *)(dword_744C8 + 4 * a1);
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;

//----- (0002B7BC) --------------------------------------------------------
int __fastcall sub_2B7BC(int a1)
{
  int v1; // r2
  int v2; // r1
  int v3; // r3
  int v4; // t1

  if ( dword_733CC <= 0 )
    return sub_2B730(a1);
  v1 = dword_744C8;
  v2 = *(_DWORD *)dword_744C8;
  if ( *(_DWORD *)(*(_DWORD *)dword_744C8 + 4) != a1 )
  {
    v3 = 0;
    while ( ++v3 != dword_733CC )
    {
      v4 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      v2 = v4;
      if ( *(_DWORD *)(v4 + 4) == a1 )
        return v2;
    }
    return sub_2B730(a1);
  }
  return v2;
}
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (0002B824) --------------------------------------------------------
const char *__fastcall sub_2B824(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_732F0, &dword_732EC) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_732F0 > 0x17 || (unsigned int)dword_732EC > 0x3B )
    return "Invalid time set.";
  byte_732E4 = 1;
  return 0;
}
// 732E4: using guessed type char byte_732E4;
// 732EC: using guessed type int dword_732EC;
// 732F0: using guessed type int dword_732F0;

//----- (0002B890) --------------------------------------------------------
char *__fastcall sub_2B890(char *a1)
{
  bool v2; // nf
  _DWORD *v4; // r0
  size_t v5; // r6
  size_t v6; // r6
  char *v7; // r4
  char v8[92]; // [sp+Ch] [bp-100h] BYREF
  char v9[164]; // [sp+68h] [bp-A4h] BYREF

  if ( !dword_68EF4 )
    dword_68EF4 = (int)_strdup(a1);
  v2 = dword_68EF8 - 9 < 0;
  ++dword_68EF8;
  if ( !(v2 ^ __OFSUB__(dword_68EF8, 10) | (dword_68EF8 == 10)) )
    return "Too many levels of JSON includes (limit 10) or a loop";
  v4 = sub_475B0(a1, 0, v8);
  if ( v4 && !*v4 )
  {
    byte_68EFC = 1;
    return sub_2B98C(v4, 1);
  }
  else
  {
    v5 = strlen(a1);
    v6 = v5 + strlen(v9) + 35;
    v7 = (char *)sub_229BC(v6, "cgminer.c", "load_config", 2124);
    snprintf(v7, v6, "JSON decode of file '%s' failed\n %s", a1, v9);
    return v7;
  }
}
// 68EF4: using guessed type int dword_68EF4;
// 68EF8: using guessed type int dword_68EF8;
// 68EFC: using guessed type char byte_68EFC;

//----- (0002B98C) --------------------------------------------------------
char *__fastcall sub_2B98C(_DWORD *a1, int a2)
{
  _DWORD *v3; // r4
  int v4; // r3
  const char *v5; // r0
  char *v6; // r10
  char *v7; // r5
  _DWORD *v8; // r0
  int v9; // r1
  int v10; // r3
  const char *v11; // r3
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _BYTE *v15; // r0
  int v16; // r0
  _DWORD *v17; // r10
  unsigned int v18; // r5
  _DWORD *v19; // r0
  int v20; // r0
  _DWORD *v22; // [sp+10h] [bp-814h]
  char *v23; // [sp+10h] [bp-814h]
  const char *v24; // [sp+14h] [bp-810h]
  char *v25; // [sp+14h] [bp-810h]
  _DWORD *v26; // [sp+18h] [bp-80Ch]
  const char *v27; // [sp+1Ch] [bp-808h]
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a2 && !dword_68FC8 )
    dword_68FC8 = 1;
  if ( dword_67FE4 == 16 )
    goto LABEL_28;
  if ( (dword_67FE4 & 8) != 0 )
LABEL_53:
    _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x7A4u, "parse_config");
  v3 = &unk_67FFC;
  while ( 1 )
  {
    v5 = (const char *)*(v3 - 7);
    if ( !v5 )
    {
      v4 = v3[1];
      if ( v4 == 16 )
        break;
      goto LABEL_8;
    }
    v6 = _strdup(v5);
    v7 = strtok(v6, "|");
    if ( !v7 )
      goto LABEL_27;
    while ( 2 )
    {
      if ( v7[1] != 45 )
        goto LABEL_12;
      v8 = (_DWORD *)sub_480FC(a1, v7 + 2);
      if ( !v8 )
        goto LABEL_12;
      v9 = *(v3 - 6);
      v10 = *v8;
      if ( (v9 & 6) == 0 )
      {
LABEL_18:
        if ( (unsigned int)(v10 - 5) > 1 )
        {
          v11 = "Invalid value";
          goto LABEL_21;
        }
        v15 = (_BYTE *)*(v3 - 2);
        if ( (v9 & 1) == 0 )
        {
          if ( v10 == 5 )
            sub_40068(v15);
          else
            sub_40078(v15);
          goto LABEL_12;
        }
        v11 = (const char *)((int (__fastcall *)(_BYTE *))*(v3 - 5))(v15);
        goto LABEL_33;
      }
      if ( v10 == 2 )
      {
        v22 = sub_48630(v8);
        v16 = ((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v22, *(v3 - 2));
        v11 = (const char *)v16;
        if ( *(v3 - 6) == 4 )
        {
          v24 = (const char *)v16;
          sub_4014C((int)v22, (_DWORD *)*(v3 - 2));
          v11 = v24;
        }
LABEL_33:
        if ( !v11 )
          goto LABEL_12;
        if ( a2 )
          goto LABEL_22;
LABEL_35:
        snprintf(byte_68F00, 0xC8u, "Parsing JSON option %s: %s", v7, v11);
        return byte_68F00;
      }
      if ( v10 != 1 )
        goto LABEL_18;
      v23 = v6;
      v17 = v8;
      v25 = v7;
      v18 = 0;
      if ( !sub_48468(v8) )
      {
LABEL_46:
        v6 = v23;
        goto LABEL_12;
      }
      while ( 1 )
      {
        v19 = sub_48484(v17, v18);
        if ( !v19 )
          goto LABEL_46;
        if ( *v19 == 2 )
          break;
        if ( !*v19 )
        {
          v11 = (const char *)sub_2B98C();
          goto LABEL_49;
        }
LABEL_45:
        if ( (unsigned int)sub_48468(v17) <= ++v18 )
          goto LABEL_46;
      }
      v26 = sub_48630(v19);
      v20 = ((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v26, *(v3 - 2));
      v11 = (const char *)v20;
      if ( *(v3 - 6) == 4 )
      {
        v27 = (const char *)v20;
        sub_4014C((int)v26, (_DWORD *)*(v3 - 2));
        v11 = v27;
      }
LABEL_49:
      if ( !v11 )
        goto LABEL_45;
      v6 = v23;
      v7 = v25;
LABEL_21:
      if ( !a2 )
        goto LABEL_35;
LABEL_22:
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf(s, 0x800u, "Invalid config option %s: %s", v7, v11);
        sub_20F58(3, s, 0);
      }
      dword_68FC8 = -1;
LABEL_12:
      v7 = strtok(0, "|");
      if ( v7 )
        continue;
      break;
    }
LABEL_27:
    free(v6);
    v4 = v3[1];
    if ( v4 == 16 )
      break;
LABEL_8:
    v3 += 7;
    if ( (v4 & 8) != 0 )
      goto LABEL_53;
  }
LABEL_28:
  v12 = (_DWORD *)sub_480FC(a1, "include");
  if ( !v12 || *v12 != 2 )
    return 0;
  v13 = sub_48630(v12);
  return (char *)sub_2B890(v13, 0);
}
// 2B890: using guessed type int __fastcall sub_2B890(_DWORD, _DWORD);
// 67DB4: using guessed type int dword_67DB4;
// 67FE4: using guessed type int dword_67FE4;
// 68BD4: using guessed type char byte_68BD4;
// 68FC8: using guessed type int dword_68FC8;
// 74500: using guessed type char byte_74500;

//----- (0002BD14) --------------------------------------------------------
int sub_2BD14()
{
  struct tm *v0; // r0
  int v1; // r12
  int v2; // r7
  int tm_min; // r6
  int tm_hour; // r4
  int v7; // r12
  _BOOL4 v8; // r7
  _BOOL4 v9; // r1
  _BOOL4 v10; // r5
  _BOOL4 v11; // r2
  time_t tv_sec; // [sp+4h] [bp-10h] BYREF
  struct timeval v13; // [sp+8h] [bp-Ch] BYREF

  sub_239A4(&v13);
  tv_sec = v13.tv_sec;
  v0 = localtime(&tv_sec);
  v1 = (unsigned __int8)byte_7339C;
  if ( byte_7339C )
  {
    v2 = (unsigned __int8)byte_732E4;
    tm_min = v0->tm_min;
    tm_hour = v0->tm_hour;
    if ( byte_732E4 )
    {
      if ( dword_732F0 > dword_733A8 || (dword_732EC > dword_733A4 ? (v9 = dword_732F0 == dword_733A8) : (v9 = 0), v9) )
      {
        if ( dword_732F0 > tm_hour || (dword_732EC > tm_min ? (v2 = dword_732F0 == tm_hour) : (v2 = 0), v2) )
        {
          if ( dword_733A8 <= tm_hour )
          {
            v11 = dword_733A4 > tm_min && dword_733A8 == tm_hour;
            return !v11;
          }
          else
          {
            return 0;
          }
        }
      }
      else if ( dword_733A8 > tm_hour || (dword_733A4 > tm_min ? (v10 = dword_733A8 == tm_hour) : (v10 = 0), v10) )
      {
        if ( dword_732F0 <= tm_hour )
          return dword_732EC > tm_min && dword_732F0 == tm_hour;
      }
    }
    else if ( dword_733A8 <= tm_hour && (dword_733A4 <= tm_min || dword_733A8 != tm_hour) )
    {
      byte_7339C = byte_732E4;
      return v1;
    }
    return v2;
  }
  v7 = v0->tm_hour;
  if ( v7 < dword_732F0 )
    return 1;
  v8 = v0->tm_min < dword_732EC;
  if ( v7 != dword_732F0 )
    return 0;
  return v8;
}
// 2BD84: masking with 0x1 was optimized away because r1.4 <= 0x1
// 2BE28: masking with 0x1 was optimized away because r1.4 <= 0x1
// 732E4: using guessed type char byte_732E4;
// 732EC: using guessed type int dword_732EC;
// 732F0: using guessed type int dword_732F0;
// 7339C: using guessed type char byte_7339C;
// 733A4: using guessed type int dword_733A4;
// 733A8: using guessed type int dword_733A8;

//----- (0002BEA0) --------------------------------------------------------
char *__fastcall sub_2BEA0(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_40158(a1, a2);
  if ( !result )
  {
    if ( *a2 < 100.0 )
    {
      return "Value out of range";
    }
    else if ( *a2 > 250.0 )
    {
      return "Value out of range";
    }
  }
  return result;
}

//----- (0002BEF8) --------------------------------------------------------
char *__fastcall sub_2BEF8(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_40158(a1, a2);
  if ( !result )
  {
    if ( *a2 < 125.0 )
    {
      return "Value out of range";
    }
    else if ( *a2 > 500.0 )
    {
      return "Value out of range";
    }
  }
  return result;
}

//----- (0002BF50) --------------------------------------------------------
int __fastcall sub_2BF50(int a1, int a2, int (__fastcall **a3)(int))
{
  int v6; // r3
  char v8[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
  {
    snprintf(v8, 0x800u, "Thread %d being disabled", a2);
    sub_20F58(4, v8, 0);
  }
  v6 = (unsigned __int8)byte_68BD5;
  *(_QWORD *)(*(_DWORD *)(a1 + 36) + 48) = 0;
  if ( v6 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    strcpy(v8, "Waiting on sem in miner thread");
    sub_20F58(7, v8, 0);
  }
  sub_25228((sem_t *)(a1 + 16), "cgminer.c", "mt_disable", 9153);
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
  {
    snprintf(v8, 0x800u, "Thread %d being re-enabled", a2);
    sub_20F58(4, v8, 0);
  }
  return (*a3)(a1);
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (0002C0F8) --------------------------------------------------------
void sub_2C0F8()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "Unable to set thread to low priority");
  sub_20F58(6, v0, 0);
}

//----- (0002C148) --------------------------------------------------------
void sub_2C148()
{
  if ( !nice(10) && (byte_74500 || byte_68BD4 || dword_67DB4 > 5) )
    sub_2C0F8();
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (0002C1A4) --------------------------------------------------------
int __fastcall sub_2C1A4(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_250A8("API");
  sub_2C148();
  sub_1DD84();
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}
// 68FCC: using guessed type int dword_68FCC;

//----- (0002C1EC) --------------------------------------------------------
char *__fastcall sub_2C1EC(const char *a1)
{
  char *result; // r0

  dword_68FD0 = 2;
  result = sub_40268(a1, &dword_73464);
  if ( !result && (unsigned int)dword_73464 > 0x270F )
    return "Value out of range";
  return result;
}
// 68FD0: using guessed type int dword_68FD0;
// 73464: using guessed type int dword_73464;

//----- (0002C234) --------------------------------------------------------
char *__fastcall sub_2C234(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && *a2 > 0x270Fu )
    return "Value out of range";
  return result;
}

//----- (0002C264) --------------------------------------------------------
char *__fastcall sub_2C264(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 0xFFFE )
    return "Value out of range";
  return result;
}

//----- (0002C298) --------------------------------------------------------
char *__fastcall sub_2C298(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && (unsigned int)(*a2 - 42) > 0x14 )
    return "Value out of range";
  return result;
}

//----- (0002C2C8) --------------------------------------------------------
char *__fastcall sub_2C2C8(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && (unsigned int)(*a2 - 22) > 0x21 )
    return "Value out of range";
  return result;
}

//----- (0002C2F8) --------------------------------------------------------
char *__fastcall sub_2C2F8(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && (unsigned int)(*a2 - 42) > 0x2B )
    return "Value out of range";
  return result;
}

//----- (0002C328) --------------------------------------------------------
char *__fastcall sub_2C328(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && (unsigned int)(*a2 - 22) > 0x35 )
    return "Value out of range";
  return result;
}

//----- (0002C358) --------------------------------------------------------
char *__fastcall sub_2C358(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && (unsigned int)(*a2 - 32) > 0x1F )
    return "Value out of range";
  return result;
}

//----- (0002C388) --------------------------------------------------------
char *__fastcall sub_2C388(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && *a2 > 4u )
    return "Value out of range";
  return result;
}

//----- (0002C3B4) --------------------------------------------------------
char *__fastcall sub_2C3B4(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && *a2 > 0xC8u )
    return "Value out of range";
  return result;
}

//----- (0002C3E0) --------------------------------------------------------
char *__fastcall sub_2C3E0(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && *a2 > 0x1E00u )
    return "Value out of range";
  return result;
}

//----- (0002C40C) --------------------------------------------------------
char *__fastcall sub_2C40C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 0xFE )
    return "Value out of range";
  return result;
}

//----- (0002C43C) --------------------------------------------------------
char *__fastcall sub_2C43C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && *a2 > 0xFFu )
    return "Value out of range";
  return result;
}

//----- (0002C468) --------------------------------------------------------
char *__fastcall sub_2C468(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && *a2 > 0x64u )
    return "Value out of range";
  return result;
}

//----- (0002C494) --------------------------------------------------------
char *__fastcall sub_2C494(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 9 )
    return "Value out of range";
  return result;
}

//----- (0002C4C4) --------------------------------------------------------
char *__fastcall sub_2C4C4(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_40268(a1, a2);
  if ( !result && *a2 > 0xAu )
    return "Value out of range";
  return result;
}

//----- (0002C4F0) --------------------------------------------------------
void __fastcall sub_2C4F0(const char *a1, const char *a2, int a3)
{
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  snprintf(s, 0x800u, "Free work called with NULL work from %s %s:%d", a1, a2, a3);
  sub_20F58(3, s, 0);
}

//----- (0002C538) --------------------------------------------------------
double __fastcall sub_2C538(double a1)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double *v4; // r4
  double result; // r0

  v4 = (double *)LODWORD(a1);
  result = exp(a1);
  *v4 = (*v4 + v1 / v2 * (1.0 - 1.0 / (v2 / v3))) / (1.0 - 1.0 / (v2 / v3) + 1.0);
  return result;
}
// 2C558: variable 'v1' is possibly undefined
// 2C558: variable 'v2' is possibly undefined
// 2C548: variable 'v3' is possibly undefined

//----- (0002C588) --------------------------------------------------------
int sub_2C588()
{
  return 1;
}

//----- (0002C590) --------------------------------------------------------
int sub_2C590()
{
  return 1;
}

//----- (0002C5A4) --------------------------------------------------------
const char *__fastcall sub_2C5A4(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_733A8, &dword_733A4) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_733A8 > 0x17 || (unsigned int)dword_733A4 > 0x3B )
    return "Invalid time set.";
  byte_7339C = 1;
  return 0;
}
// 7339C: using guessed type char byte_7339C;
// 733A4: using guessed type int dword_733A4;
// 733A8: using guessed type int dword_733A8;

//----- (0002C610) --------------------------------------------------------
int __fastcall sub_2C610(char *a1, size_t a2, time_t *a3)
{
  time_t v3; // r3
  int v6; // r4
  struct tm *v7; // r0
  time_t v9; // [sp+1Ch] [bp-8h] BYREF

  v3 = a3[1];
  v9 = *a3;
  v6 = v3 / 1000;
  v7 = localtime(&v9);
  return snprintf(
           a1,
           a2,
           "[%d-%02d-%02d %02d:%02d:%02d.%03d]",
           v7->tm_year + 1900,
           v7->tm_mon + 1,
           v7->tm_mday,
           v7->tm_hour,
           v7->tm_min,
           v7->tm_sec,
           v6);
}

//----- (0002C6A8) --------------------------------------------------------
void sub_2C6A8()
{
  unsigned int v0; // r4
  int *v1; // r7
  int *v2; // r5
  int v3; // t1
  unsigned int v4; // r3
  bool v5; // cf
  int *v6; // r8
  int v7; // t1
  unsigned int v8; // r6
  int v9; // r1
  int v10; // r1
  int v11; // r8
  _DWORD *v12; // t1
  char v13[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_733CC <= 0 )
  {
    v0 = 1;
  }
  else
  {
    v0 = -1;
    v1 = (int *)dword_744C8;
    v2 = (int *)dword_744C8;
    do
    {
      v3 = *v2++;
      v4 = *(_DWORD *)(v3 + 56);
      v5 = 1;
      if ( v4 )
        v5 = v4 >= v0;
      if ( !v5 )
        v0 = v4;
    }
    while ( (int *)(dword_744C8 + 4 * dword_733CC) != v2 );
    if ( v0 == -1 )
    {
      v0 = 1;
    }
    else
    {
      v6 = (int *)dword_744C8;
      do
      {
        v7 = *v6++;
        v8 = *(_DWORD *)(v7 + 56);
        if ( v8 )
        {
          sub_49B34(v8, v0);
          if ( v9 )
          {
            do
              sub_49B34(v8, --v0);
            while ( v10 );
          }
        }
      }
      while ( v2 != v6 );
    }
    v11 = dword_68718;
    do
    {
      v12 = (_DWORD *)*v1++;
      v12[16] = v12[16] * v11 / v0;
      v12[15] = v12[14] / v0;
    }
    while ( v2 != v1 );
  }
  dword_68718 = v0;
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf(v13, 0x800u, "Global quota greatest common denominator set to %lu", v0);
    sub_20F58(7, v13, 0);
  }
}
// 2C728: variable 'v9' is possibly undefined
// 2C740: variable 'v10' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 68718: using guessed type int dword_68718;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;

//----- (0002C82C) --------------------------------------------------------
char *__fastcall sub_2C82C(const char *a1, _DWORD *a2, int a3, int a4)
{
  char *result; // r0
  _BOOL4 v8; // r4
  int v9; // r3

  result = sub_40268(a1, a2);
  if ( !result )
  {
    v8 = *a2 < a3;
    if ( *a2 > a4 )
      v9 = v8 | 1;
    else
      v9 = v8;
    if ( v9 )
      return "Value out of range";
  }
  return result;
}

//----- (0002C878) --------------------------------------------------------
int __fastcall sub_2C878(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0

  result = sscanf(a1, "%d-%d", a2, a3);
  if ( result == 1 )
    *a3 = *a2;
  return result;
}

//----- (0002C8A8) --------------------------------------------------------
int __fastcall sub_2C8A8(int a1, const char *a2)
{
  int v4; // r6
  char *v5; // r0
  int v6; // r3

  v4 = sub_23CD8(a2, (_DWORD *)(a1 + 600), (char **)(a1 + 584));
  if ( v4 )
  {
    if ( !strncasecmp(a2, "stratum+tcp://", 0xEu) )
    {
      v5 = _strdup(a2);
      v6 = *(_DWORD *)(a1 + 600);
      *(_DWORD *)(a1 + 164) = v5;
      *(_BYTE *)(a1 + 640) = 1;
      *(_DWORD *)(a1 + 576) = v6;
      return v4;
    }
    return 0;
  }
  return v4;
}

//----- (0002C918) --------------------------------------------------------
int __fastcall sub_2C918(int a1, char *s1)
{
  char *v3; // r5
  char *v5; // r6

  v3 = sub_23E4C(s1, a1);
  if ( !sub_2C8A8(a1, v3) )
  {
    sub_4014C((int)v3, (_DWORD *)(a1 + 164));
    if ( strncmp(v3, "http://", 7u) )
    {
      if ( strncmp(v3, "https://", 8u) )
      {
        v5 = (char *)sub_229BC(0x100u, "cgminer.c", "setup_url", 1042);
        strcpy(v5, "stratum+tcp://");
        strncat(v5, v3, 0xF2u);
        sub_2C8A8(a1, v5);
      }
    }
  }
  return *(_DWORD *)(a1 + 164);
}

//----- (0002C9F8) --------------------------------------------------------
const char *__fastcall sub_2C9F8(const char *a1)
{
  if ( !a1 || !*a1 )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol(a1, 0, 10) > 0xC8 )
    return "Invalid value passed to set temp cutoff";
  dword_68FD4 = (int)a1;
  return 0;
}
// 68FD4: using guessed type int dword_68FD4;

//----- (0002CA54) --------------------------------------------------------
void *__fastcall sub_2CA54(void **a1)
{
  free(a1[72]);
  free(a1[77]);
  free(a1[82]);
  free(a1[80]);
  return memset(a1, 0, 0x1C0u);
}

//----- (0002CA90) --------------------------------------------------------
char *__fastcall sub_2CA90(int a1, int a2, int a3)
{
  int v6; // r7
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  char *result; // r0
  unsigned int v11[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = *(_DWORD *)(a1 + 340);
  sub_2CA54((void **)a1);
  sub_254E8((void *)a1, (const void *)a2, 0x1C0u, (int)"cgminer.c", (int)"_copy_work", 4951);
  *(_DWORD *)(a1 + 340) = v6;
  v7 = *(const char **)(a2 + 288);
  if ( v7 )
    *(_DWORD *)(a1 + 288) = _strdup(v7);
  v8 = *(const char **)(a2 + 320);
  if ( v8 )
    *(_DWORD *)(a1 + 320) = _strdup(v8);
  v9 = *(const char **)(a2 + 308);
  if ( v9 )
  {
    if ( a3 )
    {
      *(_DWORD *)(a1 + 68) = bswap32(a3 + bswap32(*(_DWORD *)(a1 + 68)));
      sub_22CD8(v11, *(unsigned __int8 **)(a2 + 308), 4);
      v11[0] = bswap32(a3 + bswap32(v11[0]));
      *(_DWORD *)(a1 + 308) = sub_22C24((int)v11, 4);
    }
    else
    {
      *(_DWORD *)(a1 + 308) = _strdup(v9);
    }
  }
  else if ( a3 )
  {
    *(_DWORD *)(a1 + 68) = bswap32(a3 + bswap32(*(_DWORD *)(a1 + 68)));
  }
  result = *(char **)(a2 + 328);
  if ( result )
  {
    result = _strdup(result);
    *(_DWORD *)(a1 + 328) = result;
  }
  *(_DWORD *)(a1 + 444) = *(_DWORD *)(a2 + 444);
  return result;
}

//----- (0002CBA8) --------------------------------------------------------
void __fastcall sub_2CBA8(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v4; // r5

  v4 = *a1;
  if ( *a1 )
  {
    sub_2CA54(*a1);
    free(v4);
    *a1 = 0;
  }
  else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    sub_2C4F0(a2, a3, a4);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (0002CC3C) --------------------------------------------------------
void __fastcall sub_2CC3C(int a1)
{
  struct timeval v1; // [sp-10h] [bp-10h] BYREF

  if ( *(_DWORD *)(a1 + 368) )
  {
    sub_239A4(&v1);
    sub_23C94();
  }
}
// 68720: using guessed type double dbl_68720;

//----- (0002CCA0) --------------------------------------------------------
void sub_2CCA0()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_239A4(&v0);
  sub_23C94();
}

//----- (0002CCC8) --------------------------------------------------------
void sub_2CCC8()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_239A4(&v0);
  sub_23C94();
}

//----- (0002CCF0) --------------------------------------------------------
void __fastcall sub_2CCF0(int a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r4
  int v4; // r3
  char v5[1016]; // [sp+8h] [bp-C00h] BYREF
  char v6[2048]; // [sp+408h] [bp-800h] BYREF

  v2 = 4;
  v3 = 0;
  do
  {
    v4 = (unsigned __int8)a2;
    --v2;
    a2 >>= 8;
    v3 = v4 + (v3 << 8);
  }
  while ( v2 );
  sub_22BB4(v5, a1, 128);
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    snprintf(v6, 0x800u, "BENCHFILE nonce %u=0x%08x for work=%s", v3, v3, v5);
    sub_20F58(3, v6, 0);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (0002CDB8) --------------------------------------------------------
_BYTE *__fastcall sub_2CDB8(_BYTE *result, unsigned int a2)
{
  void *v2; // r3
  _BYTE *v3; // r4

  v2 = (void *)*((_DWORD *)result + 77);
  *((_DWORD *)result + 17) = bswap32(a2);
  if ( v2 )
  {
    v3 = result;
    free(v2);
    result = sub_22C24((int)(v3 + 68), 4);
    *((_DWORD *)v3 + 77) = result;
  }
  return result;
}

//----- (0002CDF0) --------------------------------------------------------
unsigned __int64 __fastcall sub_2CDF0(__int64 *a1)
{
  double v2; // r0
  double v3; // d8
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d6
  double v8; // r0
  double v9; // d8

  if ( !a1 )
    return 0;
  LODWORD(v2) = sub_4A10C(a1[27]);
  v3 = v2 * 6.27710174e57;
  LODWORD(v4) = sub_4A10C(a1[26]);
  v5 = v3 + v4 * 3.40282367e38;
  LODWORD(v6) = sub_4A10C(a1[25]);
  v7 = v6;
  LODWORD(v8) = sub_4A10C(a1[24]);
  v9 = v8 + v5 + v7 * 1.84467441e19;
  if ( v9 == 0.0 )
    return 0;
  else
    return (unsigned __int64)(2.69595353e67 / v9);
}
// 2CE14: variable 'v2' is possibly undefined
// 2CE28: variable 'v4' is possibly undefined
// 2CE34: variable 'v6' is possibly undefined
// 2CE48: variable 'v8' is possibly undefined

//----- (0002CEA0) --------------------------------------------------------
void __fastcall sub_2CEA0(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v5; // r1
  _DWORD *v9; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v5 = *a1;
  if ( *a1 )
  {
    if ( *((_BYTE *)v5 + 273) || v5[60] || *((_BYTE *)v5 + 272) )
    {
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        strcpy(s, "Discarded cloned or rolled work");
        sub_20F58(7, s, 0);
      }
    }
    else
    {
      v9 = v5[65];
      if ( v9 )
      {
        ++v9[31];
        --*((_DWORD *)v5[65] + 16);
        --*((_DWORD *)v5[65] + 17);
      }
      ++qword_73380;
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        strcpy(s, "Discarded work");
        sub_20F58(7, s, 0);
      }
    }
    sub_2CBA8(a1, a2, a3, a4);
  }
  else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    snprintf(s, 0x800u, "Discard work called with NULL work from %s %s:%d", a2, a3, a4);
    sub_20F58(3, s, 0);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 73380: using guessed type __int64 qword_73380;
// 74500: using guessed type char byte_74500;

//----- (0002D0D8) --------------------------------------------------------
int __fastcall sub_2D0D8(int result)
{
  int v1; // r5
  int v2; // r6
  int *v3; // r2
  int v4; // r4
  int v5; // r1
  int v6; // t1
  int v7; // r3
  bool v8; // cc
  int v9; // r3
  int v10; // r3

  v1 = dword_733CC;
  v2 = dword_733CC - 1;
  if ( dword_733CC > 0 )
  {
    v3 = (int *)dword_744C8;
    v4 = dword_744C8 + 4 * dword_733CC;
    do
    {
      v6 = *v3++;
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v8 = v7 <= *(_DWORD *)(result + 4);
      v9 = v7 - 1;
      if ( !v8 )
        *(_DWORD *)(v5 + 4) = v9;
    }
    while ( v3 != (int *)v4 );
  }
  if ( *(_DWORD *)result < v2 )
  {
    **(_DWORD **)(dword_744C8 + 4 * v2) = *(_DWORD *)result;
    *(_DWORD *)(dword_744C8 + 4 * *(_DWORD *)result) = *(_DWORD *)(dword_744C8 + 4 * v2);
    v1 = dword_733CC;
  }
  *(_DWORD *)result = v1;
  v10 = dword_733CC;
  *(_BYTE *)(result + 105) = 1;
  dword_733CC = v10 - 1;
  return result;
}
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (0002D174) --------------------------------------------------------
void __fastcall sub_2D174(FILE *s)
{
  int v2; // r6
  const char *v3; // r11
  char *v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  char *v7; // r2
  int v8; // r3
  const char *v9; // r10
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  int v13; // r0
  int v14; // r4
  const char *v15; // r10
  char *v16; // r0
  const char *v17; // r0
  const char *v18; // r11
  char *v19; // r3
  const char *v20; // r0
  const char *v21; // r0
  const char **v22; // r4
  char *v23; // r8
  char *v24; // r11
  char *(__fastcall *v25)(const char *, _DWORD *); // r2
  bool v26; // zf
  int v27; // r3
  int v28; // r1
  int (__fastcall *v29)(_BYTE *); // r2
  bool v30; // zf
  const char **v31; // r3
  const char *v32; // r0
  int v33; // r1
  int v34; // r4
  int v35; // r5
  bool v36; // zf
  int v37; // [sp+14h] [bp-10h]
  const char *v38; // [sp+14h] [bp-10h]
  const char *v39; // [sp+18h] [bp-Ch]
  const char *v40; // [sp+18h] [bp-Ch]
  const char *v41; // [sp+1Ch] [bp-8h]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, s);
  if ( dword_733CC > 0 )
  {
    v2 = 0;
    do
    {
      v13 = sub_2B7BC(v2);
      v8 = *(_DWORD *)(v13 + 56);
      v14 = v13;
      if ( v8 == 1 )
      {
        if ( v2 )
          v15 = ",";
        else
          v15 = "";
        if ( *(_DWORD *)(v13 + 184) )
        {
          v16 = sub_22B68(*(char **)(v13 + 180));
          v40 = sub_2AD7C(v16);
          v17 = *(const char **)(v14 + 184);
          if ( v17 )
          {
            v20 = sub_2AD7C(v17);
            v19 = "|";
            v18 = v20;
            if ( !*(_DWORD *)(v14 + 184) )
              v19 = "";
          }
          else
          {
            v18 = "";
            v19 = "";
          }
        }
        else
        {
          v18 = "";
          v40 = "";
          v19 = "";
        }
        v38 = v19;
        v21 = sub_2AD7C(*(const char **)(v14 + 164));
        fprintf(s, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v15, v40, v18, v38, v21);
        if ( !*(_BYTE *)(v14 + 580) )
          goto LABEL_11;
      }
      else
      {
        if ( v2 )
          v3 = ",";
        else
          v3 = "";
        if ( *(_DWORD *)(v13 + 184) )
        {
          v4 = sub_22B68(*(char **)(v13 + 180));
          v41 = sub_2AD7C(v4);
          v5 = *(const char **)(v14 + 184);
          if ( v5 )
          {
            v6 = sub_2AD7C(v5);
            v7 = "|";
            v8 = *(_DWORD *)(v14 + 56);
            v9 = v6;
            if ( !*(_DWORD *)(v14 + 184) )
              v7 = "";
          }
          else
          {
            v8 = *(_DWORD *)(v14 + 56);
            v9 = "";
            v7 = "";
          }
        }
        else
        {
          v9 = "";
          v41 = "";
          v7 = "";
        }
        v39 = v7;
        v37 = v8;
        v10 = sub_2AD7C(*(const char **)(v14 + 164));
        fprintf(s, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v3, v41, v9, v39, v37, v10);
        if ( !*(_BYTE *)(v14 + 580) )
          goto LABEL_11;
      }
      fwrite(&unk_51CDC, 1u, 0x21u, s);
LABEL_11:
      ++v2;
      v11 = sub_2AD7C(*(const char **)(v14 + 172));
      fprintf(s, "\n\t\t\"user\" : \"%s\",", v11);
      v12 = sub_2AD7C(*(const char **)(v14 + 176));
      fprintf(s, "\n\t\t\"pass\" : \"%s\"\n\t}", v12);
    }
    while ( dword_733CC > v2 );
  }
  fwrite("\n]\n", 1u, 3u, s);
  if ( dword_67FE4 != 16 )
  {
    v22 = (const char **)&unk_67FFC;
    while ( 1 )
    {
      v23 = _strdup(*(v22 - 7));
      v24 = strtok(v23, "|");
      if ( v24 )
        break;
LABEL_77:
      v22 += 7;
      free(v23);
      if ( *(v22 - 6) == (const char *)16 )
        goto LABEL_78;
    }
    while ( 1 )
    {
      if ( v24[1] == 45 && *(v22 - 1) != (const char *)&unk_76870 )
      {
        v28 = (int)*(v22 - 6);
        if ( (v28 & 1) == 0 )
          goto LABEL_72;
        v29 = (int (__fastcall *)(_BYTE *))*(v22 - 5);
        v30 = v29 == sub_40068;
        if ( v29 != sub_40068 )
          v30 = v29 == sub_40088;
        if ( v30 && **(v22 - 2) == (v29 == sub_40068) )
        {
          fprintf(s, ",\n\"%s\" : true", v24 + 2);
        }
        else
        {
LABEL_72:
          if ( (v28 & 2) == 0 )
            goto LABEL_73;
          v25 = (char *(__fastcall *)(const char *, _DWORD *))*(v22 - 4);
          v26 = v25 == sub_2C234;
          if ( v25 != sub_2C234 )
            v26 = v25 == sub_40268;
          v27 = v26;
          if ( v25 == sub_2C264 )
            v27 |= 1u;
          if ( v25 == sub_2C4C4 )
            v27 |= 1u;
          if ( v25 == sub_2C494 )
            v27 |= 1u;
          if ( v25 == sub_2C468 )
            v27 |= 1u;
          if ( v25 == sub_2C43C )
            v27 |= 1u;
          if ( v25 == sub_2C40C )
            v27 |= 1u;
          if ( v25 == sub_2C3E0 )
            v27 |= 1u;
          if ( v25 == sub_2C3B4 )
            v27 |= 1u;
          if ( v25 == sub_2C388 )
            v27 |= 1u;
          if ( v25 == sub_2C358 )
            v27 |= 1u;
          if ( v25 == sub_2C328 )
            v27 |= 1u;
          if ( v25 == sub_2C2F8 )
            v27 |= 1u;
          if ( v25 == sub_2C2C8 )
            v27 |= 1u;
          if ( v25 == sub_2C298 )
            v27 |= 1u;
          if ( v27 )
          {
            fprintf(s, ",\n\"%s\" : \"%d\"", v24 + 2, *(_DWORD *)*(v22 - 2));
          }
          else
          {
            v36 = (char *)v25 == (char *)sub_2BEF8;
            if ( (char *)v25 != (char *)sub_2BEF8 )
              v36 = (char *)v25 == (char *)sub_2BEA0;
            if ( !v36 )
            {
LABEL_73:
              if ( (v28 & 6) != 0 )
              {
                v31 = (const char **)*(v22 - 2);
                if ( v31 != (const char **)&unk_68FE8 )
                {
                  if ( *v31 )
                  {
                    v32 = sub_2AD7C(*v31);
                    fprintf(s, ",\n\"%s\" : \"%s\"", v24 + 2, v32);
                  }
                }
              }
              goto LABEL_63;
            }
            fprintf(s, ",\n\"%s\" : \"%.1f\"", v24 + 2, *(float *)*(v22 - 2));
          }
        }
      }
LABEL_63:
      v24 = strtok(0, "|");
      if ( !v24 )
        goto LABEL_77;
    }
  }
LABEL_78:
  v33 = dword_68FD0;
  if ( dword_68FD0 == 4 )
  {
    fwrite(",\n\"balance\" : true", 1u, 0x12u, s);
    v33 = dword_68FD0;
  }
  if ( v33 == 3 )
  {
    fwrite(",\n\"load-balance\" : true", 1u, 0x17u, s);
    v33 = dword_68FD0;
  }
  if ( v33 == 1 )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, s);
    v33 = dword_68FD0;
  }
  if ( v33 == 2 )
    fprintf(s, ",\n\"rotate\" : \"%d\"", dword_73464);
  fwrite("\n}\n", 1u, 3u, s);
  v34 = dword_68DF0;
  dword_68DF0 = 0;
  if ( v34 )
  {
    do
    {
      v35 = *(_DWORD *)(v34 + 4);
      free(*(void **)v34);
      free((void *)v34);
      v34 = v35;
    }
    while ( v35 );
  }
}
// 67FE4: using guessed type int dword_67FE4;
// 68DF0: using guessed type int dword_68DF0;
// 68FD0: using guessed type int dword_68FD0;
// 733CC: using guessed type int dword_733CC;
// 73464: using guessed type int dword_73464;

//----- (0002D75C) --------------------------------------------------------
int sub_2D75C()
{
  int result; // r0
  int *v1; // r2
  int v2; // r12
  int v3; // t1

  *(_DWORD *)dword_68728 = 0;
  dword_6872C = 0;
  dword_68FF0 = 0;
  dword_68FF4 = 0;
  result = sub_2AEF8(0, dword_68728, 8u, 0);
  if ( dword_733CC > 0 )
  {
    result = 0;
    v1 = (int *)dword_744C8;
    v2 = dword_744C8 + 4 * dword_733CC;
    do
    {
      v3 = *v1++;
      *(_DWORD *)(v3 + 368) = 0;
      *(_DWORD *)(v3 + 372) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  return result;
}
// 6872C: using guessed type int dword_6872C;
// 68FF0: using guessed type int dword_68FF0;
// 68FF4: using guessed type int dword_68FF4;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (0002D7F4) --------------------------------------------------------
char *__fastcall sub_2D7F4(char *a1)
{
  size_t v2; // r0
  char *v3; // r12
  size_t v4; // lr
  char *v6; // r0

  if ( dword_73478 && *(_BYTE *)dword_73478 )
    return strcpy(a1, (const char *)dword_73478);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    v6 = getenv("HOME");
    *(_WORD *)stpcpy(a1, v6) = 47;
  }
  else
  {
    *a1 = 0;
  }
  strcat(a1, ".bmminer/");
  mkdir(a1, 0x1FFu);
  v2 = strlen(a1);
  v3 = &a1[v2];
  v4 = v2;
  *(_DWORD *)&a1[v4] = *(_DWORD *)"bmminer.conf";
  strcpy(v3 + 4, "ner.conf");
  return *(char **)"bmminer.conf";
}
// 12034: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 73478: using guessed type int dword_73478;

//----- (0002D8F0) --------------------------------------------------------
void sub_2D8F0()
{
  dword_68EF4 = (int)sub_229BC(0x1000u, "cgminer.c", "load_default_config", 2149);
  sub_2D7F4((char *)dword_68EF4);
  if ( access((const char *)dword_68EF4, 4) )
  {
    free((void *)dword_68EF4);
    dword_68EF4 = 0;
  }
  else
  {
    sub_2B890((char *)dword_68EF4);
  }
}
// 68EF4: using guessed type int dword_68EF4;

//----- (0002D950) --------------------------------------------------------
void __fastcall sub_2D950(void *a1)
{
  double v1; // d0
  __int64 v3; // r6
  double v4; // r0
  double v5; // d8
  __int64 v6; // kr00_8
  double v7; // r0
  double v8; // d8
  __int64 v9; // kr08_8
  double v10; // r0
  unsigned __int64 v11; // r0
  char *v12; // r6
  _QWORD v13[4]; // [sp+8h] [bp-824h] BYREF
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  if ( v1 == 0.0 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      v3 = 4294901760LL;
      strcpy(s, "Diff zero passed to set_target");
      sub_20F58(3, s, 0);
      v11 = 0;
      v6 = 0;
      v9 = 0;
    }
    else
    {
      v11 = 0;
      v3 = 4294901760LL;
      v6 = 0;
      v9 = 0;
    }
  }
  else
  {
    v3 = (unsigned __int64)(2.69595353e67 / v1 * 1.59309191e-58);
    LODWORD(v4) = sub_4A10C(v3);
    v5 = 2.69595353e67 / v1 - v4 * 6.27710174e57;
    v6 = (unsigned __int64)(v5 * 2.93873588e-39);
    LODWORD(v7) = sub_4A10C(v6);
    v8 = v5 - v7 * 3.40282367e38;
    v9 = (unsigned __int64)(v8 * 5.42101086e-20);
    LODWORD(v10) = sub_4A10C(v9);
    v11 = (unsigned __int64)(v8 - v10 * 1.84467441e19);
  }
  v13[3] = v3;
  v13[2] = v6;
  v13[1] = v9;
  v13[0] = v11;
  if ( byte_68BD5 )
  {
    v12 = sub_22C24((int)v13, 32);
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      snprintf(s, 0x800u, "Generated target %s", v12);
      sub_20F58(7, s, 0);
    }
    free(v12);
  }
  sub_254E8(a1, v13, 0x20u, (int)"cgminer.c", (int)"set_target", 8316);
}
// 2D96C: variable 'v1' is possibly undefined
// 2D9A0: variable 'v4' is possibly undefined
// 2D9C8: variable 'v7' is possibly undefined
// 2D9EC: variable 'v10' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (0002DBE4) --------------------------------------------------------
int __fastcall sub_2DBE4(int a1)
{
  return dword_744A0 - *(_DWORD *)(a1 + 232);
}
// 744A0: using guessed type int dword_744A0;

//----- (0002DBFC) --------------------------------------------------------
bool __fastcall sub_2DBFC(int a1, int a2)
{
  *(_DWORD *)(a1 + 76) = a2;
  sub_2B350(a1);
  return *(_DWORD *)(a1 + 220) == 0;
}

//----- (0002DC1C) --------------------------------------------------------
bool __fastcall sub_2DC1C(int a1, int a2)
{
  double v2; // d0

  *(_DWORD *)(a1 + 76) = a2;
  sub_2B350(a1);
  return *(_QWORD *)(a1 + 216) <= (unsigned __int64)(4294901760.0 / v2);
}
// 2DC3C: variable 'v2' is possibly undefined

//----- (0002DC68) --------------------------------------------------------
int __fastcall sub_2DC68(int a1, int a2)
{
  _DWORD *v2; // r3
  int result; // r0
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  v2 = *(_DWORD **)(a1 + 36);
  if ( v2[59] == a2 )
  {
    if ( byte_74500 || (result = (unsigned __int8)byte_68BD4, byte_68BD4) || dword_67DB4 > 5 )
    {
      snprintf(s, 0x800u, "%s %d duplicate share detected as HW error", *(const char **)(v2[1] + 8), v2[2]);
      sub_20F58(6, s, 0);
      return 0;
    }
  }
  else
  {
    v2[59] = a2;
    return 1;
  }
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (0002DD0C) --------------------------------------------------------
void __fastcall sub_2DD0C(int *a1, int a2)
{
  _BYTE *v4; // r6
  int *v5; // r12
  int v6; // r0
  int v7; // r1
  _DWORD *v8; // lr
  int v9; // r2
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r1
  int v18; // r2
  int v19; // r1
  int v20; // r3
  int v21; // r2
  int v22; // r1
  int v23; // r2
  int v24; // r3
  _BYTE *v25; // r11
  char *v26; // r8
  char *v27; // r7
  char *v28; // r6
  _BYTE *v29; // r10
  _BYTE *v30; // r9
  char *v31; // r5
  size_t v32; // r0
  _BYTE *ptr; // [sp+Ch] [bp-4A8h]
  _DWORD v34[8]; // [sp+10h] [bp-4A4h] BYREF
  _DWORD v35[8]; // [sp+30h] [bp-484h] BYREF
  _DWORD v36[8]; // [sp+50h] [bp-464h] BYREF
  _BYTE v37[64]; // [sp+70h] [bp-444h] BYREF
  char s[1028]; // [sp+B0h] [bp-404h] BYREF

  if ( !dword_68FF8 )
    dword_68FF8 = fopen64("/nvdata/worklog.txt", "wb");
  v4 = v37;
  memset(s, 0, 0x400u);
  v5 = a1;
  memset(&v35[3], 0, 20);
  do
  {
    v6 = *v5;
    v5 += 4;
    v7 = *(v5 - 3);
    v8 = v4;
    v9 = *(v5 - 2);
    v4 += 16;
    v10 = *(v5 - 1);
    *v8 = v6;
    v8[1] = v7;
    v8[2] = v9;
    v8[3] = v10;
  }
  while ( v5 != a1 + 16 );
  v11 = a1[33];
  v12 = a1[34];
  v13 = a1[35];
  v34[0] = a1[32];
  v34[1] = v11;
  v34[2] = v12;
  v34[3] = v13;
  v14 = a1[37];
  v15 = a1[38];
  v16 = a1[39];
  v34[4] = a1[36];
  v34[5] = v14;
  v34[6] = v15;
  v34[7] = v16;
  v17 = v5[1];
  v18 = v5[2];
  v35[0] = *v5;
  v35[1] = v17;
  v35[2] = v18;
  v19 = a1[49];
  v20 = a1[51];
  v21 = a1[50];
  v36[0] = a1[48];
  v36[1] = v19;
  v36[2] = v21;
  v36[3] = v20;
  v22 = a1[53];
  v23 = a1[54];
  v24 = a1[55];
  v36[4] = a1[52];
  v36[5] = v22;
  v36[6] = v23;
  v36[7] = v24;
  sub_29EF4(v37, 64);
  sub_29EF4(v34, 32);
  sub_29EF4(v35, 12);
  sub_29EF4(v36, 32);
  ptr = sub_22C24((int)a1, 128);
  v25 = sub_22C24((int)v37, 64);
  v26 = sub_22C24((int)v34, 32);
  v27 = sub_22C24((int)v35, 12);
  v28 = sub_22C24(a2, 4);
  v29 = sub_22C24(a2, 5);
  v30 = sub_22C24((int)v36, 32);
  v31 = sub_22C24((int)(a1 + 111), 4);
  sprintf(s, "midstate %s data %s nonce %s version %s \r\n", v26, v27, v28, v31);
  v32 = strlen(s);
  fwrite(s, v32, 1u, (FILE *)dword_68FF8);
  fflush((FILE *)dword_68FF8);
  if ( ptr )
    free(ptr);
  if ( v25 )
    free(v25);
  if ( v26 )
    free(v26);
  if ( v27 )
    free(v27);
  if ( v28 )
    free(v28);
  if ( v29 )
    free(v29);
  if ( v30 )
    free(v30);
  if ( v31 )
    free(v31);
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 68FF8: using guessed type int dword_68FF8;

//----- (0002DFC0) --------------------------------------------------------
void __fastcall sub_2DFC0(int *a1, unsigned int a2)
{
  unsigned int v2; // [sp+0h] [bp-Ch] BYREF
  char v3; // [sp+4h] [bp-8h]

  v2 = bswap32(a2);
  v3 = 0;
  sub_2DD0C(a1, (int)&v2);
}

//----- (0002DFE8) --------------------------------------------------------
int __fastcall sub_2DFE8(int *a1, unsigned int a2)
{
  unsigned int v5; // [sp+0h] [bp-Ch] BYREF
  char v6; // [sp+4h] [bp-8h]

  a1[19] = a2;
  sub_2B350((int)a1);
  if ( a1[55] )
    return 0;
  v5 = bswap32(a2);
  v6 = 0;
  sub_2DD0C(a1, (int)&v5);
  return 1;
}

//----- (0002E034) --------------------------------------------------------
void __fastcall sub_2E034(int a1, int a2)
{
  int v4; // r5
  int v5; // r12
  int v6; // r1
  unsigned int v7; // r3
  unsigned int v8; // r2
  int v9; // r1
  unsigned int v10; // r3
  unsigned int v11; // r2
  int v12; // r1
  unsigned int v13; // r5
  int v14; // r6
  int v15; // r3
  int v16; // r1
  __int64 v17; // r2
  int v18; // r5
  int v19; // r2
  _DWORD *v20; // r3
  __int64 v21; // r2
  int v22; // r4
  _DWORD *v23; // r6
  int v24; // r7
  int v25; // r3
  unsigned int v26; // r4
  _DWORD *v27; // r5
  _DWORD *v28; // r11
  int v29; // r4
  char *v30; // r8
  unsigned int v31; // r1
  int v32; // r3
  _DWORD *v33; // r3
  unsigned int v34; // r2
  unsigned int v35; // r1
  bool v36; // cc
  int v37; // r2
  int v38; // r3
  void *v39; // r0
  void **v40; // r7
  void *v41; // r0
  unsigned int i; // [sp+4h] [bp-8h]

  ++*(_DWORD *)(a1 + 360);
  v4 = *(unsigned __int8 *)(a2 + 340);
  v5 = *(unsigned __int8 *)(a2 + 343);
  *(_DWORD *)(a2 + 364) = a2 + 340;
  *(_DWORD *)(a2 + 368) = 4;
  v6 = (v4 + 17973517 + (v5 << 24) + (*(unsigned __int8 *)(a2 + 342) << 16) + (*(unsigned __int8 *)(a2 + 341) << 8))
     ^ 0x7F76D;
  v7 = (-1622558010 - v6) ^ (v6 << 8);
  v8 = (-17973517 - v6 - v7) ^ (v7 >> 13);
  v9 = (v6 - v7 - v8) ^ (v8 >> 12);
  v10 = (v7 - v8 - v9) ^ (v9 << 16);
  v11 = (v8 - v9 - v10) ^ (v10 >> 5);
  v12 = (v9 - v10 - v11) ^ (v11 >> 3);
  v13 = (v11 - v12 - ((v10 - v11 - v12) ^ (v12 << 10))) ^ (((v10 - v11 - v12) ^ (v12 << 10)) >> 15);
  *(_DWORD *)(a2 + 372) = v13;
  v14 = *(_DWORD *)(a1 + 352);
  if ( v14 )
  {
    v15 = *(_DWORD *)(v14 + 344);
    *(_DWORD *)(a2 + 352) = 0;
    v16 = a2 + 344;
    *(_DWORD *)(a2 + 344) = v15;
    *(_DWORD *)(a2 + 348) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16)
                          - *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) + 8) = a2;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) = a2 + 344;
  }
  else
  {
    *(_DWORD *)(a2 + 352) = 0;
    *(_DWORD *)(a2 + 348) = 0;
    *(_DWORD *)(a1 + 352) = a2;
    *(_DWORD *)(a2 + 344) = malloc(0x2Cu);
    v39 = *(void **)(*(_DWORD *)(a1 + 352) + 344);
    if ( !v39 )
      goto LABEL_31;
    memset(v39, 0, 0x2Cu);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) = *(_DWORD *)(a1 + 352) + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 4) = 32;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 8) = 5;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20) = 344;
    v40 = *(void ***)(*(_DWORD *)(a1 + 352) + 344);
    *v40 = malloc(0x180u);
    v41 = **(void ***)(*(_DWORD *)(a1 + 352) + 344);
    if ( !v41 )
      goto LABEL_31;
    memset(v41, 0, 0x180u);
    v16 = a2 + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 12);
  v17 = *(_QWORD *)*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344);
  v18 = 12 * (v13 & (HIDWORD(v17) - 1));
  ++*(_DWORD *)(v17 + v18 + 4);
  HIDWORD(v17) = *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v18);
  *(_DWORD *)(a2 + 356) = 0;
  *(_DWORD *)(a2 + 360) = HIDWORD(v17);
  HIDWORD(v17) = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
  v19 = *(_DWORD *)(HIDWORD(v17) + v18);
  v20 = (_DWORD *)(HIDWORD(v17) + v18);
  if ( v19 )
  {
    *(_DWORD *)(v19 + 12) = v16;
    v20 = (_DWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v18);
  }
  *v20 = v16;
  v21 = *(_QWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v18 + 4);
  if ( (unsigned int)v21 >= 10 * (HIDWORD(v21) + 1) )
  {
    v22 = *(_DWORD *)(a2 + 344);
    if ( *(_DWORD *)(v22 + 36) != 1 )
    {
      v23 = calloc(24 * *(_DWORD *)(v22 + 4), 1u);
      if ( v23 )
      {
        v24 = 0;
        *(_DWORD *)(v22 + 24) = (((2 * *(_DWORD *)(v22 + 4) - 1) & *(_DWORD *)(v22 + 12)) != 0)
                              + (*(_DWORD *)(v22 + 12) >> (*(_BYTE *)(v22 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a2 + 344) + 28) = 0;
        v25 = *(_DWORD *)(a2 + 344);
        v26 = *(_DWORD *)(v25 + 4);
        if ( v26 )
        {
          for ( i = 0; i < v26; ++i )
          {
            v27 = *(_DWORD **)(*(_DWORD *)v25 + v24);
            if ( v27 )
            {
              while ( 1 )
              {
                v28 = (_DWORD *)v27[4];
                v29 = 3 * ((2 * v26 - 1) & v27[7]);
                v30 = (char *)&v23[v29];
                v31 = *((_DWORD *)v30 + 1) + 1;
                *((_DWORD *)v30 + 1) = v31;
                if ( v31 > *(_DWORD *)(v25 + 24) )
                {
                  ++*(_DWORD *)(v25 + 28);
                  *((_DWORD *)v30 + 2) = *((_DWORD *)v30 + 1) / *(_DWORD *)(*(_DWORD *)(a2 + 344) + 24);
                }
                v27[3] = 0;
                v27[4] = v23[v29];
                v32 = v23[v29];
                if ( v32 )
                  *(_DWORD *)(v32 + 12) = v27;
                v23[v29] = v27;
                v25 = *(_DWORD *)(a2 + 344);
                if ( !v28 )
                  break;
                v26 = *(_DWORD *)(v25 + 4);
                v27 = v28;
              }
              v26 = *(_DWORD *)(v25 + 4);
            }
            v24 += 12;
          }
        }
        free(*(void **)v25);
        *(_DWORD *)(*(_DWORD *)(a2 + 344) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a2 + 344) + 8);
        **(_DWORD **)(a2 + 344) = v23;
        v33 = *(_DWORD **)(a2 + 344);
        v34 = v33[7];
        v35 = v33[3];
        v36 = v34 > v35 >> 1;
        if ( v34 <= v35 >> 1 )
          v37 = 0;
        else
          v37 = v33[8];
        if ( v36 )
          ++v37;
        v33[8] = v37;
        v38 = *(_DWORD *)(a2 + 344);
        if ( *(_DWORD *)(v38 + 32) > 1u )
          *(_DWORD *)(v38 + 36) = 1;
        return;
      }
LABEL_31:
      exit(-1);
    }
  }
}

//----- (0002E46C) --------------------------------------------------------
int __fastcall sub_2E46C(int a1, void *s2, size_t n, const void *a4, int a5, size_t na)
{
  int v6; // r5
  int v7; // r4

  v6 = a1;
  if ( a1 )
  {
    v7 = *(_DWORD *)(a1 + 352);
    while ( memcmp((const void *)(v6 + 128), s2, n) || memcmp((const void *)(v6 + a5), a4, na) )
    {
      v6 = v7;
      if ( !v7 )
        return v7;
      v7 = *(_DWORD *)(v7 + 352);
    }
  }
  return v6;
}

//----- (0002E4DC) --------------------------------------------------------
int __fastcall sub_2E4DC(int result, int a2)
{
  int v2; // r3

  if ( result )
  {
    v2 = *(_DWORD *)(result + 352);
    if ( a2 != *(_DWORD *)(result + 340) )
    {
      if ( v2 )
      {
        result = *(_DWORD *)(v2 + 352);
        while ( *(_DWORD *)(v2 + 340) != a2 )
        {
          v2 = result;
          if ( !result )
            return result;
          result = *(_DWORD *)(result + 352);
        }
      }
      return v2;
    }
  }
  return result;
}

//----- (0002E528) --------------------------------------------------------
void __fastcall sub_2E528(int a1, _DWORD *a2)
{
  int v2; // r12
  int v3; // r2
  int v4; // lr
  _DWORD *v5; // r12
  int v6; // r3
  int v7; // r4
  int v8; // r3
  _DWORD *v9; // r2
  int v10; // r3
  int v11; // r2
  int v12; // r2
  int v13; // r3

  v2 = *(_DWORD *)(a1 + 352);
  --*(_DWORD *)(a1 + 360);
  v3 = a2[87];
  if ( !v3 )
  {
    v7 = a2[88];
    v4 = *(_DWORD *)(v2 + 344);
    if ( !v7 )
    {
      free(*(void **)v4);
      free(*(void **)(*(_DWORD *)(a1 + 352) + 344));
      *(_DWORD *)(a1 + 352) = 0;
      return;
    }
    v6 = *(_DWORD *)(v4 + 20);
    v5 = a2 + 86;
    if ( a2 != (_DWORD *)(*(_DWORD *)(v4 + 16) - v6) )
      goto LABEL_17;
    goto LABEL_13;
  }
  v4 = *(_DWORD *)(v2 + 344);
  v5 = a2 + 86;
  v6 = *(_DWORD *)(v4 + 20);
  if ( a2 == (_DWORD *)(*(_DWORD *)(v4 + 16) - v6) )
  {
LABEL_13:
    *(_DWORD *)(v4 + 16) = v3 + v6;
    v3 = a2[87];
    if ( v3 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20);
      goto LABEL_3;
    }
    v7 = a2[88];
LABEL_17:
    *(_DWORD *)(a1 + 352) = v7;
    goto LABEL_4;
  }
LABEL_3:
  *(_DWORD *)(v3 + v6 + 8) = a2[88];
  v7 = *(_DWORD *)(a1 + 352);
LABEL_4:
  v8 = a2[88];
  v9 = *(_DWORD **)(v7 + 344);
  if ( v8 )
  {
    *(_DWORD *)(v8 + v9[5] + 4) = a2[87];
    v9 = *(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
  }
  v10 = 12 * ((v9[1] - 1) & a2[93]);
  --*(_DWORD *)(*v9 + v10 + 4);
  v11 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
  if ( *(_DWORD **)(v11 + v10) == v5 )
    *(_DWORD *)(v11 + v10) = a2[90];
  v12 = a2[89];
  v13 = a2[90];
  if ( v12 )
  {
    *(_DWORD *)(v12 + 16) = v13;
    v13 = a2[90];
  }
  if ( v13 )
    *(_DWORD *)(v13 + 12) = a2[89];
  --*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 12);
}

//----- (0002E698) --------------------------------------------------------
int __fastcall sub_2E698(int result)
{
  if ( *(_DWORD *)(result + 32) != 1 )
    return (*(int (**)(void))(*(_DWORD *)(result + 4) + 16))();
  return result;
}

//----- (0002E6B0) --------------------------------------------------------
void __fastcall __noreturn sub_2E6B0(int a1, int a2)
{
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  if ( !pthread_create(newthread, 0, (void *(*)(void *))sub_2B63C, 0) )
  {
    if ( a2 )
      sub_3189C(0);
    if ( dword_68FFC > 0 )
    {
      kill(dword_68FFC, 15);
      dword_68FFC = 0;
    }
    pthread_cancel(newthread[0]);
    exit(a1);
  }
  exit(1);
}
// 68FFC: using guessed type int dword_68FFC;

//----- (0002E730) --------------------------------------------------------
void __noreturn sub_2E730()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  sub_2541C((int)sub_31ECC, 0, 5000);
  strcpy(v0, "Shutdown signal received.");
  sub_20F58(3, v0, 1);
  sub_2E6B0(0, 1);
}

//----- (0002E78C) --------------------------------------------------------
void __noreturn sub_2E78C()
{
  sigaction(15, &stru_755F8, 0);
  sigaction(2, &stru_76730, 0);
  sigaction(6, &stru_733D0, 0);
  sub_2E730();
}
// 733D0: using guessed type struct sigaction stru_733D0;
// 755F8: using guessed type struct sigaction stru_755F8;
// 76730: using guessed type struct sigaction stru_76730;

//----- (0002E7D0) --------------------------------------------------------
int __fastcall sub_2E7D0(char *a1, size_t a2, int a3)
{
  double v3; // d0
  double v7; // r0
  double v8; // d8
  unsigned __int64 v9; // r8
  size_t v10; // r7
  char v12[16]; // [sp+28h] [bp-864h] BYREF
  char v13[16]; // [sp+38h] [bp-854h] BYREF
  char s[64]; // [sp+48h] [bp-844h] BYREF
  char v15[2052]; // [sp+88h] [bp-804h] BYREF

  sub_2CC3C(a3);
  LODWORD(v7) = sub_4A11C(*(_QWORD *)(a3 + 192));
  v8 = v7 / v3 * 60.0;
  v9 = (unsigned __int64)(*(double *)(a3 + 48) * 1000000.0);
  sub_2AEF8((unsigned __int64)(*(double *)(a3 + 80) / v3 * 1000000.0), v12, 0x10u, 4);
  sub_2AEF8(v9, v13, 0x10u, 4);
  snprintf(a1, a2, "%s%d ", *(const char **)(*(_DWORD *)(a3 + 4) + 8), *(_DWORD *)(a3 + 8));
  (*(void (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 20))(a1, a2, a3);
  v10 = strlen(a1);
  snprintf(
    s,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    dword_68730,
    v13,
    v12,
    *(double *)(a3 + 200),
    *(double *)(a3 + 208),
    *(_DWORD *)(a3 + 44),
    v8);
  if ( v10 + strlen(s) >= a2 )
  {
    snprintf(v15, 0x800u, "tailsprintf buffer overflow in %s %s line %d", "cgminer.c", "get_statline", 3118);
    sub_20F58(3, v15, 1);
    sub_2E6B0(1);
  }
  strcat(a1, s);
  return (*(int (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 24))(a1, a2, a3);
}
// 2E814: variable 'v7' is possibly undefined
// 2E814: variable 'v3' is possibly undefined
// 20F58: using guessed type int __fastcall sub_20F58(_DWORD, _DWORD, _DWORD);
// 2E6B0: using guessed type void __fastcall __noreturn sub_2E6B0(_DWORD);
// 68730: using guessed type int dword_68730;

//----- (0002E9A4) --------------------------------------------------------
void __noreturn sub_2E9A4()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "Failed to create restart thread");
  sub_20F58(3, v0, 1);
  sub_2E6B0(1, 1);
}

//----- (0002E9E8) --------------------------------------------------------
int sub_2E9E8()
{
  int result; // r0
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  sub_239A4(&stru_68FD8);
  result = pthread_create(newthread, 0, (void *(*)(void *))sub_3747C, 0);
  if ( result )
    sub_2E9A4();
  return result;
}
// 68FD8: using guessed type struct timeval stru_68FD8;

//----- (0002EA28) --------------------------------------------------------
int __fastcall sub_2EA28(_BYTE *a1)
{
  char *v2; // r4
  bool v3; // r4
  int v4; // r5
  FILE *v6; // r2
  char *v7; // r0
  char **v8; // r9
  int v9; // r11
  char *v10; // r0
  int v11; // r1
  int v12; // r12
  char *v13; // lr
  int v14; // r11
  char *v15; // r12
  _BOOL4 v16; // r2
  size_t v17; // r0
  size_t v18; // r10
  char *v19; // r9
  const char *v20; // r5
  const char *v21; // r6
  const char *v22; // r2
  char *v23; // r9
  const char *v24; // r5
  const char *v25; // r6
  const char *v26; // r2
  int v27; // r0
  const char *nptr; // [sp+14h] [bp-C20h]
  char *v29; // [sp+1Ch] [bp-C18h] BYREF
  int v30; // [sp+20h] [bp-C14h]
  int v31; // [sp+24h] [bp-C10h]
  char *src; // [sp+28h] [bp-C0Ch]
  char *v33; // [sp+2Ch] [bp-C08h]
  char s[1024]; // [sp+30h] [bp-C04h] BYREF
  char v35[2052]; // [sp+430h] [bp-804h] BYREF

  if ( !dword_69000 )
  {
    if ( !dword_766C0 )
    {
      strcpy(v35, "BENCHFILE Invalid benchfile NULL");
      sub_20F58(3, v35, 1);
      sub_2E6B0(1, 1);
    }
    v6 = (FILE *)fopen64(dword_766C0, "r");
    dword_69000 = (int)v6;
    if ( v6 )
    {
      dword_69004 = 0;
      if ( !fgets(s, 1024, v6) )
      {
        snprintf(v35, 0x800u, "BENCHFILE Failed to read benchfile '%s'", dword_766C0);
        goto LABEL_13;
      }
      dword_69008 = 0;
      while ( 1 )
      {
LABEL_3:
        v3 = s[0] != 35;
        if ( !s[0] )
          v3 = 0;
        v4 = dword_69004 + 1;
        v2 = (char *)(s[0] != 47 && v3);
        ++dword_69004;
        if ( v2 )
          break;
        if ( !fgets(s, 1024, (FILE *)dword_69000) )
          goto LABEL_10;
      }
      v7 = s;
      v8 = &v29;
      v9 = 0;
      v29 = s;
      do
      {
        v10 = strchr(v7, 44);
        v8[1] = v10;
        v11 = v9 + 1;
        if ( !v10 )
        {
          snprintf(
            v35,
            0x800u,
            "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
            v4,
            v9 + 1,
            5);
          goto LABEL_13;
        }
        v12 = (int)*v8++;
        v13 = (char *)dword_4EABC[2 * v9];
        v14 = 8 * v9;
        v15 = &v10[-v12];
        v16 = v13 != v15;
        if ( !v13 )
          v16 = 0;
        if ( v16 )
        {
          snprintf(
            v35,
            0x800u,
            "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
            v4,
            v11,
            *(const char **)&aJsonEscape[v14 + 160],
            v15,
            v13);
          goto LABEL_13;
        }
        *v10 = 0;
        v7 = v10 + 1;
        v9 = v11;
        *v8 = v7;
      }
      while ( v11 != 4 );
      nptr = v33;
      v17 = strlen(v33);
      if ( v17 > 9 )
      {
        sprintf(v35, "0000000%c", (unsigned __int8)*v29);
        v18 = strlen(v35);
        v19 = &v35[v18];
        v20 = (const char *)(v31 + 56);
        v21 = (const char *)(v31 - 8);
        do
        {
          v22 = v20;
          v20 -= 8;
          sprintf(v19, "%.8s", v22);
          v19 += 8;
        }
        while ( v21 != v20 );
        v23 = &v35[v18 + 64];
        v24 = (const char *)(v30 + 56);
        v25 = (const char *)(v30 - 8);
        do
        {
          v26 = v24;
          v24 -= 8;
          sprintf(v23, "%.8s", v26);
          v23 += 8;
        }
        while ( v25 != v24 );
        v27 = strtol(nptr, 0, 10);
        sprintf(&v35[v18 + 128], "%08lx", v27);
        strcpy(&v35[v18 + 136], src);
        memset(a1, 0, 0x1C0u);
        sub_22CD8(a1, (unsigned __int8 *)v35, (int)(v18 + 144) >> 1);
        sub_2B3A4((int)a1);
        ++dword_69008;
        return (int)v2;
      }
      snprintf(
        v35,
        0x800u,
        "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
        v4,
        5,
        "NonceTime",
        v17,
        10);
    }
    else
    {
      snprintf(v35, 0x800u, "BENCHFILE Failed to open benchfile '%s'", dword_766C0);
    }
LABEL_13:
    sub_20F58(3, v35, 1);
    sub_2E6B0(1, 1);
  }
  v2 = fgets(s, 1024, (FILE *)dword_69000);
  if ( v2 )
    goto LABEL_3;
LABEL_10:
  if ( !dword_69008 )
  {
    snprintf(v35, 0x800u, "BENCHFILE No work in benchfile '%s'", dword_766C0);
    goto LABEL_13;
  }
  fclose((FILE *)dword_69000);
  dword_69000 = (int)v2;
  return sub_2EA28(a1);
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 4EABC: using guessed type _DWORD[10];
// 69000: using guessed type int dword_69000;
// 69004: using guessed type int dword_69004;
// 69008: using guessed type int dword_69008;
// 766C0: using guessed type int dword_766C0;

//----- (0002EE34) --------------------------------------------------------
void __fastcall __noreturn sub_2EE34(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_2E6B0(1, 1);
}

//----- (0002EE90) --------------------------------------------------------
int __fastcall sub_2EE90(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_mutex_init(a1, 0);
  if ( result )
    sub_2EE34(a2, a3);
  return result;
}

//----- (0002EEB8) --------------------------------------------------------
void __fastcall __noreturn sub_2EEB8(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_2E6B0(1, 1);
}

//----- (0002EF14) --------------------------------------------------------
int __fastcall sub_2EF14(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_rwlock_init(a1, 0);
  if ( result )
    sub_2EEB8(a2, a3);
  return result;
}

//----- (0002EF3C) --------------------------------------------------------
int __fastcall sub_2EF3C(int a1, const char *a2, int a3)
{
  int result; // r0

  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    sub_2EE34(a2, a3);
  result = pthread_rwlock_init((pthread_rwlock_t *)(a1 + 24), 0);
  if ( result )
    sub_2EEB8(a2, a3);
  return result;
}

//----- (0002EF84) --------------------------------------------------------
void __fastcall __noreturn sub_2EF84(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_2E6B0(1, 1);
}

//----- (0002EFE0) --------------------------------------------------------
void __fastcall __noreturn sub_2EFE0(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_2E6B0(1, 1);
}

//----- (0002F03C) --------------------------------------------------------
void __fastcall __noreturn sub_2F03C(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_2E6B0(1, 1);
}

//----- (0002F098) --------------------------------------------------------
int __fastcall sub_2F098(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_mutex_t *v4; // r0
  int v5; // r4

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    sub_2EFE0("pool_tset", 808);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 1;
  if ( pthread_mutex_unlock(v4) )
    sub_2F03C("pool_tset", 813);
  off_67ED8();
  return v5;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (0002F104) --------------------------------------------------------
int __fastcall sub_2F104(int a1, int a2)
{
  if ( pthread_mutex_lock(&stru_766C4) )
    sub_2EFE0("inc_dev_status", 8783);
  dword_75580 = a1;
  dword_75584 = a2;
  if ( pthread_mutex_unlock(&stru_766C4) )
    sub_2F03C("inc_dev_status", 8786);
  return off_67ED8();
}
// 67ED8: using guessed type int (*off_67ED8)();
// 75580: using guessed type int dword_75580;
// 75584: using guessed type int dword_75584;
// 766C4: using guessed type pthread_mutex_t stru_766C4;

//----- (0002F180) --------------------------------------------------------
int __fastcall sub_2F180(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_mutex_t *v4; // r0
  int v5; // r4

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    sub_2EFE0("pool_tclear", 823);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 0;
  if ( pthread_mutex_unlock(v4) )
    sub_2F03C("pool_tclear", 828);
  off_67ED8();
  return v5;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (0002F1E8) --------------------------------------------------------
int __fastcall sub_2F1E8(_DWORD *a1, int a2)
{
  int v4; // r7
  int v5; // r2
  int v6; // r3
  const char *v7; // r0
  int v9; // r6
  int *v10; // r12
  int v11; // r0
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int *v15; // r12
  int v16; // r0
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r12
  const char *v21; // r1
  size_t v22; // r2
  int v23; // r3
  struct timeval v24; // [sp+8h] [bp-814h] BYREF
  struct timeval v25; // [sp+10h] [bp-80Ch] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  if ( *((_BYTE *)a1 + 736) )
  {
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      snprintf(s, 0x800u, "Retrieving block template from pool %s", (const char *)a1[41]);
      sub_20F58(7, s, 0);
    }
  }
  else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
  {
    snprintf(s, 0x800u, "Testing pool %s", (const char *)a1[41]);
    sub_20F58(6, s, 0);
  }
  v4 = *((unsigned __int8 *)a1 + 640);
  if ( *((_BYTE *)a1 + 640) )
    goto LABEL_38;
  if ( off_68734 )
  {
    if ( *((_BYTE *)a1 + 99) )
      goto LABEL_15;
    if ( !byte_68BD5 )
    {
      *((_BYTE *)a1 + 99) = v4;
      goto LABEL_15;
    }
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
    {
      strcpy(s, "Probing for GBT support");
      sub_20F58(7, s, 0);
      v5 = *((unsigned __int8 *)a1 + 736);
      v6 = (unsigned __int8)byte_68BD5;
      *((_BYTE *)a1 + 99) = 0;
      if ( !v5 )
      {
        if ( !*((_BYTE *)a1 + 900) )
        {
          if ( !v6 )
            goto LABEL_15;
          if ( byte_74500 )
            goto LABEL_65;
LABEL_63:
          if ( byte_68BD4 || dword_67DB4 > 6 )
            goto LABEL_65;
LABEL_15:
          sub_239A4(&v24);
          sub_239A4(&v25);
          v7 = (const char *)a1[144];
          if ( !v7 || byte_6900C )
            goto LABEL_97;
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
          {
            snprintf(s, 0x800u, "Testing pool %d stratum %s", *a1, (const char *)a1[144]);
            sub_20F58(6, s, 0);
            v7 = (const char *)a1[144];
          }
          if ( !sub_23CD8(v7, a1 + 150, (char **)a1 + 146) || !sub_26AEC(a1) )
          {
LABEL_97:
            if ( *((_BYTE *)a1 + 640) || *((_BYTE *)a1 + 900) || *((_BYTE *)a1 + 736) )
            {
              if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
              {
                snprintf(s, 0x800u, "FAILED to retrieve work from pool %u %s", *a1, (const char *)a1[41]);
                sub_20F58(7, s, 0);
              }
              if ( !a2 && !*((_BYTE *)a1 + 97) && (byte_74500 || byte_68BD4 || dword_67DB4 > 3) )
              {
                v4 = 0;
                snprintf(s, 0x800u, "Pool %u slow/down or URL or credentials invalid", *a1);
                sub_20F58(4, s, 0);
              }
            }
            else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
            {
              v4 = 0;
              snprintf(
                s,
                0x800u,
                "No Stratum, GBT or Solo support in pool %d %s unable to use",
                *a1,
                (const char *)a1[41]);
              sub_20F58(4, s, 0);
            }
            return v4;
          }
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
          {
            snprintf(s, 0x800u, "Switching pool %d %s to %s", *a1, (const char *)a1[41], (const char *)a1[144]);
            sub_20F58(5, s, 0);
          }
          if ( !a1[41] )
            a1[41] = _strdup((const char *)a1[144]);
          *((_BYTE *)a1 + 640) = 1;
LABEL_38:
          v4 = sub_2F098((int)a1, (_BYTE *)a1 + 642);
          if ( v4 )
            return *((unsigned __int8 *)a1 + 641);
          if ( !sub_26AEC(a1) || *((_BYTE *)a1 + 580) && !sub_296D0(a1) || (v9 = sub_29AC8(a1)) == 0 )
          {
            sub_2F180((int)a1, (_BYTE *)a1 + 642);
            return v4;
          }
          byte_74502 = 1;
          if ( pthread_create(a1 + 174, 0, (void *(*)(void *))sub_3958C, a1) )
          {
            v10 = (int *)&unk_5212C;
          }
          else
          {
            if ( !pthread_create(a1 + 175, 0, (void *(*)(void *))sub_3BECC, a1) )
              return v9;
            v10 = (int *)&unk_52150;
          }
          v11 = *v10;
          v12 = v10[1];
          v13 = v10[2];
          v14 = v10[3];
          v15 = v10 + 4;
          *(_DWORD *)s = v11;
          *(_DWORD *)&s[4] = v12;
          *(_DWORD *)&s[8] = v13;
          *(_DWORD *)&s[12] = v14;
          v16 = *v15;
          v17 = v15[1];
          v18 = v15[2];
          v19 = v15[3];
          v20 = v15[4];
          *(_DWORD *)&s[16] = v16;
          *(_DWORD *)&s[20] = v17;
          *(_DWORD *)&s[24] = v18;
          *(_DWORD *)&s[28] = v19;
          s[32] = v20;
          sub_20F58(3, s, 1);
          sub_2E6B0(1, 1);
        }
        if ( !v6 )
          goto LABEL_15;
LABEL_54:
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
        {
          v21 = "GBT coinbase without append found, switching to GBT solo protocol";
          v22 = 66;
LABEL_58:
          memcpy(s, v21, v22);
          sub_20F58(7, s, 0);
          goto LABEL_15;
        }
        goto LABEL_15;
      }
      if ( !v6 )
        goto LABEL_15;
    }
    else
    {
      v23 = *((unsigned __int8 *)a1 + 736);
      *((_BYTE *)a1 + 99) = v4;
      if ( !v23 )
      {
        if ( !*((_BYTE *)a1 + 900) )
        {
          if ( byte_74500 )
          {
LABEL_65:
            v21 = "No GBT coinbase + append support found, pool unusable if it has no stratum";
            v22 = 75;
            goto LABEL_58;
          }
          goto LABEL_63;
        }
        goto LABEL_54;
      }
    }
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
    {
      strcpy(s, "GBT coinbase + append support found, switching to GBT protocol");
      sub_20F58(7, s, 0);
    }
    goto LABEL_15;
  }
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
    return v4;
  strcpy(s, "CURL initialisation failed");
  sub_20F58(3, s, 0);
  return v4;
}
// 67DB4: using guessed type int dword_67DB4;
// 68734: using guessed type char *off_68734;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 6900C: using guessed type char byte_6900C;
// 74500: using guessed type char byte_74500;
// 74502: using guessed type char byte_74502;

//----- (0002F9C0) --------------------------------------------------------
int sub_2F9C0()
{
  if ( pthread_mutex_lock((pthread_mutex_t *)dword_69010) )
    sub_2EFE0("wake_gws", 5369);
  pthread_cond_signal(&stru_744D0);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_69010) )
    sub_2F03C("wake_gws", 5371);
  return off_67ED8();
}
// 67ED8: using guessed type int (*off_67ED8)();
// 69010: using guessed type int dword_69010;
// 744D0: using guessed type pthread_cond_t stru_744D0;

//----- (0002FA28) --------------------------------------------------------
int __fastcall sub_2FA28(int a1, unsigned int a2)
{
  unsigned int v4; // r4
  int v5; // r1
  __time_t v6; // r4
  int v7; // r1
  int v8; // r4
  struct timeval v10; // [sp+0h] [bp-10h] BYREF
  struct timespec abstime; // [sp+8h] [bp-8h] BYREF

  v4 = a2 / 0x3E8;
  sub_239A4(&v10);
  v5 = 1000 * a2 - 1000000 * v4;
  v6 = v4 + v10.tv_sec;
  v7 = v5 + v10.tv_usec;
  if ( v7 > 999999 )
  {
    ++v6;
    v7 -= 1000000;
  }
  abstime.tv_sec = v6;
  abstime.tv_nsec = 1000 * v7;
  v8 = pthread_mutex_lock(&stru_767F4);
  if ( v8 )
    sub_2EFE0("restart_wait", 5422);
  if ( !*(_BYTE *)(a1 + 62) )
    v8 = pthread_cond_timedwait(&stru_76700, &stru_767F4, &abstime);
  if ( pthread_mutex_unlock(&stru_767F4) )
    sub_2F03C("restart_wait", 5432);
  off_67ED8();
  return v8;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 76700: using guessed type pthread_cond_t stru_76700;
// 767F4: using guessed type pthread_mutex_t stru_767F4;

//----- (0002FB24) --------------------------------------------------------
void __fastcall __noreturn sub_2FB24(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_2E6B0(1);
}
// 20F58: using guessed type int __fastcall sub_20F58(_DWORD, _DWORD, _DWORD);
// 2E6B0: using guessed type void __fastcall __noreturn sub_2E6B0(_DWORD);

//----- (0002FB80) --------------------------------------------------------
int __fastcall sub_2FB80(pthread_rwlock_t *a1, const char *a2, int a3)
{
  if ( pthread_rwlock_unlock(a1) )
    sub_2FB24(a2, a3);
  return off_67ED8();
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (0002FBB8) --------------------------------------------------------
int sub_2FBB8()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_7453C) )
    sub_2EFE0("total_work_inc", 2265);
  if ( pthread_rwlock_wrlock(&rwlock) )
    sub_2EF84("total_work_inc", 2265);
  v0 = dword_69014++;
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_2FB24("total_work_inc", 2267);
  if ( pthread_mutex_unlock(&stru_7453C) )
    sub_2F03C("total_work_inc", 2267);
  off_67ED8();
  return v0;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 69014: using guessed type int dword_69014;
// 7453C: using guessed type pthread_mutex_t stru_7453C;

//----- (0002FC68) --------------------------------------------------------
int __fastcall sub_2FC68(int a1)
{
  int v2; // r1
  bool v3; // zf
  unsigned int v4; // r3
  int v5; // r0
  _BYTE *v6; // r5
  int result; // r0
  unsigned int v8[513]; // [sp+0h] [bp-804h] BYREF

  v2 = dword_767E0;
  v3 = byte_68BD5 == 0;
  v4 = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + 1);
  v5 = *(_DWORD *)(a1 + 240) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  *(_DWORD *)(a1 + 240) = v5;
  *(_DWORD *)(a1 + 248) = 0;
  dword_767E0 = v2 + 1;
  if ( !v3 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    strcpy((char *)v8, "Successfully rolled work");
    sub_20F58(7, (const char *)v8, 0);
  }
  v6 = *(_BYTE **)(a1 + 308);
  if ( v6 )
  {
    sub_22CD8(v8, *(unsigned __int8 **)(a1 + 308), 4);
    v8[0] = bswap32(bswap32(v8[0]) + 1);
    sub_22BB4(v6, (int)v8, 4);
  }
  result = sub_2FBB8();
  *(_DWORD *)(a1 + 340) = result;
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;
// 767E0: using guessed type int dword_767E0;

//----- (0002FD8C) --------------------------------------------------------
_DWORD *sub_2FD8C()
{
  _DWORD *v0; // r4
  char v2[2048]; // [sp+8h] [bp-800h] BYREF

  v0 = sub_22A44(1u, 0x1C0u, "cgminer.c", "make_work", 2274);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc work in make_work");
    sub_20F58(3, v2, 1);
    sub_2E6B0(1, 1);
  }
  v0[85] = sub_2FBB8();
  return v0;
}

//----- (0002FE24) --------------------------------------------------------
_DWORD *__fastcall sub_2FE24(int a1, int a2)
{
  _DWORD *v4; // r4

  v4 = sub_2FD8C();
  sub_2CA90((int)v4, a1, a2);
  return v4;
}

//----- (0002FE4C) --------------------------------------------------------
_DWORD *__fastcall sub_2FE4C(int a1)
{
  _DWORD *v2; // r4
  int v3; // r3

  v2 = sub_2FD8C();
  sub_2CA90((int)v2, a1, 0);
  *((_BYTE *)v2 + 273) = 1;
  sub_239A4((struct timeval *)v2 + 52);
  v3 = v2[66];
  *((_BYTE *)v2 + 280) = 0;
  *((_BYTE *)v2 + 282) = 0;
  v2[66] = v3 - 1;
  return v2;
}

//----- (0002FE98) --------------------------------------------------------
int __fastcall sub_2FE98(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2EF84("add_queued", 9449);
  sub_2E034((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    sub_2FB24("add_queued", 9451);
  return off_67ED8();
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (0002FF04) --------------------------------------------------------
void __fastcall sub_2FF04(pthread_rwlock_t *a1, void **a2)
{
  pthread_rwlock_t *v2; // r4
  void **v4; // [sp+4h] [bp-8h] BYREF

  v2 = a1 + 10;
  v4 = a2;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2EF84("work_completed", 9601);
  sub_2E528((int)a1, v4);
  if ( pthread_rwlock_unlock(v2) )
    sub_2FB24("work_completed", 9603);
  off_67ED8();
  sub_2CBA8(&v4, "cgminer.c", "work_completed", 9605);
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (0002FF90) --------------------------------------------------------
_DWORD *__fastcall sub_2FF90(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r5
  _DWORD *v11; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2EF84("take_queued_work_bymidstate", 9614);
  v11 = (_DWORD *)sub_2E46C(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
    sub_2E528((int)a1, v11);
  if ( pthread_rwlock_unlock(v6) )
    sub_2FB24("take_queued_work_bymidstate", 9618);
  off_67ED8();
  return v11;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (0003003C) --------------------------------------------------------
int __fastcall sub_3003C(pthread_rwlock_t *a1)
{
  int i; // r4
  int lock; // [sp+4h] [bp-10h]
  struct timeval v5; // [sp+8h] [bp-Ch] BYREF

  sub_239A4(&v5);
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2EF84("age_queued_work", 9580);
  lock = a1[11].__lock;
  if ( lock )
  {
    for ( i = *(_DWORD *)(lock + 352); ; i = *(_DWORD *)(i + 352) )
    {
      sub_23C94();
      if ( !i )
        break;
    }
  }
  if ( pthread_rwlock_unlock(a1 + 10) )
    sub_2FB24("age_queued_work", 9591);
  off_67ED8();
  return 0;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (00030138) --------------------------------------------------------
void __fastcall __noreturn sub_30138(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_2E6B0(1);
}
// 20F58: using guessed type int __fastcall sub_20F58(_DWORD, _DWORD, _DWORD);
// 2E6B0: using guessed type void __fastcall __noreturn sub_2E6B0(_DWORD);

//----- (00030194) --------------------------------------------------------
_DWORD *__fastcall sub_30194(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r7
  _DWORD *lock; // r4
  int v6; // r5

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_30138("clone_queued_work_byid", 9554);
  lock = (_DWORD *)a1[11].__lock;
  if ( lock )
  {
    v6 = lock[88];
    if ( a2 == lock[85] )
    {
      v6 = (int)lock;
    }
    else
    {
      if ( !v6 )
      {
        lock = 0;
        goto LABEL_10;
      }
      lock = *(_DWORD **)(v6 + 352);
      while ( a2 != *(_DWORD *)(v6 + 340) )
      {
        if ( !lock )
          goto LABEL_10;
        v6 = (int)lock;
        lock = (_DWORD *)lock[88];
      }
    }
    lock = sub_2FD8C();
    sub_2CA90((int)lock, v6, 0);
  }
LABEL_10:
  if ( pthread_rwlock_unlock(v2) )
    sub_2FB24("clone_queued_work_byid", 9558);
  off_67ED8();
  return lock;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (00030260) --------------------------------------------------------
_DWORD *__fastcall sub_30260(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5
  _DWORD *v12; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_30138("clone_queued_work_bymidstate", 9507);
  v11 = sub_2E46C(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
  {
    v12 = sub_2FD8C();
    sub_2CA90((int)v12, v11, 0);
  }
  else
  {
    v12 = 0;
  }
  if ( pthread_rwlock_unlock(v6) )
    sub_2FB24("clone_queued_work_bymidstate", 9511);
  off_67ED8();
  return v12;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (0003031C) --------------------------------------------------------
int __fastcall sub_3031C(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r6
  int lock; // r4
  int v6; // r3

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_30138("find_queued_work_byid", 9542);
  lock = a1[11].__lock;
  if ( lock )
  {
    v6 = *(_DWORD *)(lock + 352);
    if ( a2 != *(_DWORD *)(lock + 340) )
    {
      if ( v6 )
      {
        lock = *(_DWORD *)(v6 + 352);
        while ( a2 != *(_DWORD *)(v6 + 340) )
        {
          if ( !lock )
            goto LABEL_10;
          v6 = lock;
          lock = *(_DWORD *)(lock + 352);
        }
      }
      lock = v6;
    }
  }
LABEL_10:
  if ( pthread_rwlock_unlock(v2) )
    sub_2FB24("find_queued_work_byid", 9544);
  off_67ED8();
  return lock;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (000303D0) --------------------------------------------------------
int __fastcall sub_303D0(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_30138("find_queued_work_bymidstate", 9495);
  v11 = sub_2E46C(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( pthread_rwlock_unlock(v6) )
    sub_2FB24("find_queued_work_bymidstate", 9497);
  off_67ED8();
  return v11;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (0003046C) --------------------------------------------------------
int __fastcall sub_3046C(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&stru_7680C) )
    sub_30138("get_devices", 629);
  v2 = *(_DWORD *)(dword_7346C + 4 * a1);
  if ( pthread_rwlock_unlock(&stru_7680C) )
    sub_2FB24("get_devices", 631);
  off_67ED8();
  return v2;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 7346C: using guessed type int dword_7346C;
// 7680C: using guessed type pthread_rwlock_t stru_7680C;

//----- (000304E0) --------------------------------------------------------
int sub_304E0()
{
  int v0; // r12
  int v1; // r2
  double v2; // d9
  int v3; // r8
  int v4; // r6
  int v5; // r10
  double v6; // r0
  double v7; // d10
  double v8; // r0
  double v9; // d10
  double v10; // d8
  double v11; // d7
  __int64 v12; // r6
  __int64 v13; // kr08_8
  __int64 v14; // r0
  int v15; // r1
  double v16; // d9
  double v17; // r0
  int v18; // r8
  int v19; // r6
  int v20; // r3
  const char *v21; // r1
  __int64 v22; // r10
  __int64 v23; // r0
  int v24; // r1
  double v25; // d8
  double v26; // r0
  int v27; // r5
  int v28; // r0
  int v29; // r1
  int v30; // r3
  double v31; // d7
  unsigned int v33; // [sp+10h] [bp-91Ch]
  unsigned int v34; // [sp+14h] [bp-918h]
  char v35[256]; // [sp+28h] [bp-904h] BYREF
  char s[2052]; // [sp+128h] [bp-804h] BYREF

  v0 = dword_69018 - dword_69020;
  LOWORD(v1) = -30583;
  if ( dword_6901C - dword_69024 < 0 )
    --v0;
  HIWORD(v1) = -30584;
  v2 = dbl_68720;
  v3 = v0 / 3600;
  v4 = v0 - 60 * (((int)(v0 + ((unsigned __int64)(v0 * (__int64)v1) >> 32)) >> 5) - (v0 >> 31));
  v5 = ((int)(v0 % 3600 + ((unsigned __int64)(v0 % 3600 * (__int64)v1) >> 32)) >> 5) - ((v0 % 3600) >> 31);
  LODWORD(v6) = sub_4A11C(*(__int64 *)&dword_755D8);
  v7 = v6 / v2;
  LODWORD(v8) = sub_4A11C(*(__int64 *)&dword_76850);
  v9 = v7 * 60.0;
  v10 = v8 / v2 * 60.0;
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3
    || (strcpy(s, "\nSummary of runtime statistics:\n"), sub_20F58(4, s, 0), !byte_74500)
    && !byte_68BD4
    && dword_67DB4 <= 3 )
  {
    if ( dword_733CC == 1 )
      goto LABEL_156;
LABEL_8:
    if ( byte_74500 || byte_68BD4 )
      goto LABEL_10;
    goto LABEL_137;
  }
  snprintf(s, 0x800u, "Started at %s", byte_69028);
  sub_20F58(4, s, 0);
  if ( dword_733CC != 1 )
    goto LABEL_8;
  if ( byte_74500 || byte_68BD4 )
    goto LABEL_157;
LABEL_156:
  if ( dword_67DB4 > 3 )
  {
LABEL_157:
    snprintf(s, 0x800u, "Pool: %s", *(const char **)(*(_DWORD *)dword_744C8 + 164));
    sub_20F58(4, s, 0);
    goto LABEL_8;
  }
LABEL_137:
  if ( dword_67DB4 <= 3 )
  {
    v11 = dbl_756A8 / dbl_68720;
    goto LABEL_139;
  }
LABEL_10:
  snprintf(s, 0x800u, "Runtime: %d hrs : %d mins : %d secs", v3, v5, v4);
  sub_20F58(4, s, 0);
  v11 = dbl_756A8 / dbl_68720;
  if ( byte_74500 || byte_68BD4 )
  {
LABEL_12:
    snprintf(s, 0x800u, "Average hashrate: %.1f Mhash/s", v11);
    sub_20F58(4, s, 0);
    if ( byte_74500 || byte_68BD4 )
      goto LABEL_14;
    goto LABEL_189;
  }
LABEL_139:
  if ( dword_67DB4 > 3 )
    goto LABEL_12;
LABEL_189:
  if ( dword_67DB4 <= 3 )
    goto LABEL_190;
LABEL_14:
  snprintf(s, 0x800u, "Solved blocks: %d", dword_7345C);
  sub_20F58(4, s, 0);
  if ( !byte_74500 && !byte_68BD4 )
  {
LABEL_190:
    if ( dword_67DB4 <= 3 )
      goto LABEL_158;
  }
  snprintf(s, 0x800u, "Best share difficulty: %s", dword_68728);
  sub_20F58(4, s, 0);
  if ( byte_74500 || byte_68BD4 )
  {
LABEL_18:
    snprintf(s, 0x800u, "Share submissions: %lld", *(_QWORD *)&dword_755D8 + qword_767E8);
    sub_20F58(4, s, 0);
    if ( byte_74500 || byte_68BD4 )
      goto LABEL_20;
    goto LABEL_159;
  }
LABEL_158:
  if ( dword_67DB4 > 3 )
    goto LABEL_18;
LABEL_159:
  if ( dword_67DB4 <= 3 )
    goto LABEL_160;
LABEL_20:
  snprintf(s, 0x800u, "Accepted shares: %lld", *(_QWORD *)&dword_755D8);
  sub_20F58(4, s, 0);
  if ( !byte_74500 && !byte_68BD4 )
  {
LABEL_160:
    if ( dword_67DB4 <= 3 )
      goto LABEL_161;
  }
  snprintf(s, 0x800u, "Rejected shares: %lld", qword_767E8);
  sub_20F58(4, s, 0);
  if ( byte_74500 || byte_68BD4 )
  {
LABEL_24:
    snprintf(s, 0x800u, "Accepted difficulty shares: %1.f", dbl_73370);
    sub_20F58(4, s, 0);
    if ( byte_74500 || byte_68BD4 )
      goto LABEL_26;
    goto LABEL_162;
  }
LABEL_161:
  if ( dword_67DB4 > 3 )
    goto LABEL_24;
LABEL_162:
  if ( dword_67DB4 <= 3 )
  {
    v12 = *(_QWORD *)&dword_755D8;
    if ( *(_QWORD *)&dword_755D8 )
      goto LABEL_164;
    goto LABEL_54;
  }
LABEL_26:
  snprintf(s, 0x800u, "Rejected difficulty shares: %1.f", dbl_73390);
  sub_20F58(4, s, 0);
  v12 = *(_QWORD *)&dword_755D8;
  if ( *(_QWORD *)&dword_755D8 )
  {
    if ( !byte_74500 )
      goto LABEL_28;
LABEL_29:
    v13 = qword_767E8;
    HIDWORD(v14) = (unsigned __int64)(3 * qword_767E8) >> 32;
    LODWORD(v14) = 96 * qword_767E8;
    LODWORD(v16) = sub_4A11C(__PAIR64__((unsigned __int64)(96 * qword_767E8) >> 32, 3 * (int)qword_767E8) + v14 + qword_767E8);
    HIDWORD(v16) = v15;
    LODWORD(v17) = sub_4A11C(v13 + v12);
    snprintf(s, 0x800u, "Reject ratio: %.1f%%", v16 / v17);
    sub_20F58(4, s, 0);
LABEL_30:
    if ( byte_74500 || byte_68BD4 )
      goto LABEL_32;
    goto LABEL_145;
  }
LABEL_54:
  if ( !qword_767E8 )
    goto LABEL_30;
  v12 = 0;
  if ( byte_74500 )
    goto LABEL_29;
LABEL_28:
  if ( byte_68BD4 )
    goto LABEL_29;
LABEL_164:
  if ( dword_67DB4 > 3 )
    goto LABEL_29;
LABEL_145:
  if ( dword_67DB4 <= 3 )
    goto LABEL_146;
LABEL_32:
  snprintf(s, 0x800u, "Hardware errors: %d", dword_73368);
  sub_20F58(4, s, 0);
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
  {
LABEL_146:
    if ( dword_67DB4 <= 3 )
      goto LABEL_147;
    goto LABEL_36;
  }
  snprintf(s, 0x800u, "Utility (accepted shares / min): %.2f/min", v9);
  sub_20F58(4, s, 0);
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
  {
LABEL_147:
    if ( dword_67DB4 <= 3 )
      goto LABEL_148;
    goto LABEL_38;
  }
LABEL_36:
  snprintf(s, 0x800u, "Work Utility (diff1 shares solved / min): %.2f/min\n", v10);
  sub_20F58(4, s, 0);
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
  {
LABEL_148:
    if ( dword_67DB4 <= 3 )
      goto LABEL_149;
    goto LABEL_40;
  }
LABEL_38:
  snprintf(s, 0x800u, "Stale submissions discarded due to new blocks: %lld", *(_QWORD *)&dword_73318);
  sub_20F58(4, s, 0);
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
  {
LABEL_149:
    if ( dword_67DB4 <= 3 )
      goto LABEL_150;
    goto LABEL_42;
  }
LABEL_40:
  snprintf(s, 0x800u, "Unable to get work from server occasions: %d", dword_755D0);
  sub_20F58(4, s, 0);
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
  {
LABEL_150:
    if ( dword_67DB4 <= 3 )
      goto LABEL_151;
    goto LABEL_44;
  }
LABEL_42:
  snprintf(s, 0x800u, "Work items generated locally: %d", dword_767E0);
  sub_20F58(4, s, 0);
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
  {
LABEL_151:
    if ( dword_67DB4 <= 3 )
      goto LABEL_152;
    goto LABEL_46;
  }
LABEL_44:
  snprintf(s, 0x800u, "Submitting work remotely delay occasions: %d", dword_74494);
  sub_20F58(4, s, 0);
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
  {
LABEL_152:
    if ( dword_733CC <= 1 )
      goto LABEL_141;
    goto LABEL_47;
  }
LABEL_46:
  snprintf(s, 0x800u, "New blocks detected on network: %d\n", dword_766DC);
  sub_20F58(4, s, 0);
  if ( dword_733CC > 1 )
  {
LABEL_47:
    v18 = 0;
    while ( 1 )
    {
      v19 = *(_DWORD *)(dword_744C8 + 4 * v18);
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
        break;
      v20 = *(_DWORD *)(v19 + 32);
      if ( v20 )
        goto LABEL_52;
LABEL_63:
      if ( !byte_68BD4 )
      {
LABEL_110:
        if ( dword_67DB4 <= 3 )
          goto LABEL_111;
      }
LABEL_64:
      snprintf(s, 0x800u, " Share submissions: %lld", *(_QWORD *)(v19 + 8) + *(_QWORD *)(v19 + 16));
      sub_20F58(4, s, 0);
      if ( byte_74500 || byte_68BD4 )
      {
LABEL_66:
        snprintf(s, 0x800u, " Accepted shares: %lld", *(_QWORD *)(v19 + 8));
        sub_20F58(4, s, 0);
        if ( byte_74500 || byte_68BD4 )
          goto LABEL_68;
        goto LABEL_112;
      }
LABEL_111:
      if ( dword_67DB4 > 3 )
        goto LABEL_66;
LABEL_112:
      if ( dword_67DB4 <= 3 )
        goto LABEL_113;
LABEL_68:
      snprintf(s, 0x800u, " Rejected shares: %lld", *(_QWORD *)(v19 + 16));
      sub_20F58(4, s, 0);
      if ( !byte_74500 && !byte_68BD4 )
      {
LABEL_113:
        if ( dword_67DB4 <= 3 )
          goto LABEL_114;
      }
      snprintf(s, 0x800u, " Accepted difficulty shares: %1.f", *(double *)(v19 + 72));
      sub_20F58(4, s, 0);
      if ( byte_74500 || byte_68BD4 )
      {
LABEL_72:
        snprintf(s, 0x800u, " Rejected difficulty shares: %1.f", *(double *)(v19 + 80));
        sub_20F58(4, s, 0);
        v22 = *(_QWORD *)(v19 + 8);
        if ( v22 )
          goto LABEL_75;
        goto LABEL_73;
      }
LABEL_114:
      if ( dword_67DB4 > 3 )
        goto LABEL_72;
      v22 = *(_QWORD *)(v19 + 8);
      if ( v22 )
      {
        if ( dword_67DB4 <= 3 )
          goto LABEL_117;
        goto LABEL_77;
      }
LABEL_73:
      if ( *(_QWORD *)(v19 + 16) )
      {
        v22 = 0;
LABEL_75:
        if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
        {
LABEL_117:
          if ( dword_67DB4 <= 3 )
            goto LABEL_118;
          goto LABEL_80;
        }
LABEL_77:
        v34 = *(_DWORD *)(v19 + 16);
        HIDWORD(v23) = (unsigned __int64)(3LL * *(_QWORD *)(v19 + 16)) >> 32;
        LODWORD(v23) = 96 * v34;
        v33 = *(_DWORD *)(v19 + 20);
        LODWORD(v25) = sub_4A11C(
                         __PAIR64__((unsigned __int64)(96LL * *(_QWORD *)(v19 + 16)) >> 32, 3 * v34)
                       + v23
                       + *(_QWORD *)(v19 + 16));
        HIDWORD(v25) = v24;
        LODWORD(v26) = sub_4A11C(__PAIR64__(v33, v34) + v22);
        snprintf(s, 0x800u, " Reject ratio: %.1f%%", v25 / v26);
        sub_20F58(4, s, 0);
      }
      if ( !byte_74500 && !byte_68BD4 )
        goto LABEL_117;
LABEL_80:
      snprintf(s, 0x800u, " Items worked on: %d", *(_DWORD *)(v19 + 68));
      sub_20F58(4, s, 0);
      if ( byte_74500 || byte_68BD4 )
      {
LABEL_82:
        snprintf(s, 0x800u, " Stale submissions discarded due to new blocks: %d", *(_DWORD *)(v19 + 120));
        sub_20F58(4, s, 0);
        if ( byte_74500 || byte_68BD4 )
          goto LABEL_84;
        goto LABEL_119;
      }
LABEL_118:
      if ( dword_67DB4 > 3 )
        goto LABEL_82;
LABEL_119:
      if ( dword_67DB4 <= 3 )
        goto LABEL_120;
LABEL_84:
      snprintf(s, 0x800u, " Unable to get work from server occasions: %d", *(_DWORD *)(v19 + 128));
      sub_20F58(4, s, 0);
      if ( !byte_74500 && !byte_68BD4 )
      {
LABEL_120:
        if ( dword_67DB4 <= 3 )
          goto LABEL_87;
      }
      snprintf(s, 0x800u, " Submitting work remotely delay occasions: %d\n", *(_DWORD *)(v19 + 132));
      sub_20F58(4, s, 0);
LABEL_87:
      if ( dword_733CC <= ++v18 )
        goto LABEL_88;
    }
    snprintf(s, 0x800u, "Pool: %s", *(const char **)(v19 + 164));
    sub_20F58(4, s, 0);
    v20 = *(_DWORD *)(v19 + 32);
    if ( v20 )
    {
      if ( !byte_74500 && !byte_68BD4 )
      {
LABEL_52:
        if ( dword_67DB4 <= 3 )
          goto LABEL_110;
      }
      v21 = "S";
      if ( v20 <= 1 )
        v21 = "";
      snprintf(s, 0x800u, "SOLVED %d BLOCK%s!", v20, v21);
      sub_20F58(4, s, 0);
    }
    if ( byte_74500 )
      goto LABEL_64;
    goto LABEL_63;
  }
LABEL_88:
  if ( byte_74500 || byte_68BD4 )
    goto LABEL_90;
LABEL_141:
  if ( dword_67DB4 > 3 )
  {
LABEL_90:
    strcpy(s, "Summary of per device statistics:\n");
    sub_20F58(4, s, 0);
  }
  if ( dword_755C0 > 0 )
  {
    v27 = 0;
    do
    {
      v28 = sub_3046C(v27++);
      *(_DWORD *)(*(_DWORD *)(v28 + 4) + 20) = nullsub_1;
      *(_DWORD *)(*(_DWORD *)(v28 + 4) + 24) = nullsub_2;
      sub_2E7D0(v35, 0xFFu, v28);
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
      {
        snprintf(s, 0x800u, "%s", v35);
        sub_20F58(4, s, 0);
      }
    }
    while ( dword_755C0 > v27 );
  }
  v29 = dword_69050;
  v30 = (unsigned __int8)byte_74500;
  if ( dword_69050 )
  {
    v31 = dbl_73370;
    if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
    {
      if ( (double)dword_69050 <= dbl_73370 )
        goto LABEL_143;
      goto LABEL_103;
    }
    snprintf(s, 0x800u, "Mined %.0f accepted shares of %d requested\n", dbl_73370, dword_69050);
    sub_20F58(4, s, 0);
    v31 = dbl_73370;
    v29 = dword_69050;
    v30 = (unsigned __int8)byte_74500;
    if ( (double)dword_69050 > dbl_73370 )
    {
      if ( byte_74500 )
      {
LABEL_105:
        snprintf(s, 0x800u, "WARNING - Mined only %.0f shares of %d requested.", v31, v29);
        sub_20F58(4, s, 0);
        v30 = (unsigned __int8)byte_74500;
        goto LABEL_106;
      }
LABEL_103:
      if ( !byte_68BD4 && dword_67DB4 <= 3 )
      {
LABEL_143:
        if ( dword_67DB4 <= 3 )
          goto LABEL_109;
        goto LABEL_108;
      }
      goto LABEL_105;
    }
  }
LABEL_106:
  if ( !v30 && !byte_68BD4 )
    goto LABEL_143;
LABEL_108:
  strcpy(s, " ");
  sub_20F58(4, s, 0);
LABEL_109:
  fflush((FILE *)stderr);
  return fflush((FILE *)stdout);
}
// 3059C: variable 'v6' is possibly undefined
// 305AC: variable 'v8' is possibly undefined
// 309E8: variable 'v15' is possibly undefined
// 30A10: variable 'v17' is possibly undefined
// 30FD8: variable 'v24' is possibly undefined
// 31000: variable 'v26' is possibly undefined
// 20F58: using guessed type int __fastcall sub_20F58(_DWORD, _DWORD, _DWORD);
// 2AA48: using guessed type int nullsub_1();
// 2C580: using guessed type int nullsub_2();
// 67DB4: using guessed type int dword_67DB4;
// 68720: using guessed type double dbl_68720;
// 68A68: using guessed type int stderr;
// 68A74: using guessed type int stdout;
// 68BD4: using guessed type char byte_68BD4;
// 69018: using guessed type int dword_69018;
// 6901C: using guessed type int dword_6901C;
// 69020: using guessed type int dword_69020;
// 69024: using guessed type int dword_69024;
// 69050: using guessed type int dword_69050;
// 73318: using guessed type int dword_73318;
// 73368: using guessed type int dword_73368;
// 73370: using guessed type double dbl_73370;
// 73390: using guessed type double dbl_73390;
// 733CC: using guessed type int dword_733CC;
// 7345C: using guessed type int dword_7345C;
// 74494: using guessed type int dword_74494;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;
// 755C0: using guessed type int dword_755C0;
// 755D0: using guessed type int dword_755D0;
// 755D8: using guessed type int dword_755D8;
// 756A8: using guessed type double dbl_756A8;
// 766DC: using guessed type int dword_766DC;
// 767E0: using guessed type int dword_767E0;
// 767E8: using guessed type __int64 qword_767E8;
// 76850: using guessed type int dword_76850;

//----- (0003189C) --------------------------------------------------------
int __fastcall sub_3189C(int a1)
{
  int v2; // r5
  char *v3; // r0
  int result; // r0
  struct sysinfo info; // [sp+8h] [bp-844h] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  if ( !sysinfo(&info) )
  {
    dword_74484 = info.uptime;
    result = sub_239A4((struct timeval *)&dword_69018);
    if ( a1 )
      return result;
    goto LABEL_8;
  }
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
  {
    v2 = *_errno_location();
    v3 = strerror(v2);
    snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v2, v3);
    sub_20F58(6, s, 0);
  }
  dword_74484 = time(0);
  result = sub_239A4((struct timeval *)&dword_69018);
  if ( !a1 )
  {
LABEL_8:
    if ( !byte_7559C )
    {
      if ( byte_68BD6 )
        return sub_304E0();
    }
  }
  return result;
}
// 20F58: using guessed type int __fastcall sub_20F58(_DWORD, _DWORD, _DWORD);
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD6: using guessed type char byte_68BD6;
// 69018: using guessed type int dword_69018;
// 74484: using guessed type int dword_74484;
// 74500: using guessed type char byte_74500;
// 7559C: using guessed type char byte_7559C;

//----- (000319C4) --------------------------------------------------------
void sub_319C4()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
  {
    snprintf(v0, 0x800u, "Attempting to restart %s", s);
    sub_20F58(4, v0, 0);
  }
  sub_2541C((int)sub_31ECC, 0, 5000);
  sub_3189C(1);
  if ( dword_68FFC > 0 )
  {
    kill(dword_68FFC, 15);
    dword_68FFC = 0;
  }
  execv(*(const char **)dword_69054, (char *const *)dword_69054);
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
  {
    strcpy(v0, "Failed to restart application");
    sub_20F58(4, v0, 0);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68FFC: using guessed type int dword_68FFC;
// 69054: using guessed type int dword_69054;
// 74500: using guessed type char byte_74500;

//----- (00031B04) --------------------------------------------------------
int __fastcall sub_31B04(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&stru_744A8) )
    sub_30138("get_thread", 609);
  v2 = *(_DWORD *)(dword_744A4 + 4 * a1);
  if ( pthread_rwlock_unlock(&stru_744A8) )
    sub_2FB24("get_thread", 611);
  off_67ED8();
  return v2;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 744A4: using guessed type int dword_744A4;
// 744A8: using guessed type pthread_rwlock_t stru_744A8;

//----- (00031B78) --------------------------------------------------------
int __fastcall sub_31B78(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(sub_31B04(a1) + 36) + 8);
}

//----- (00031B8C) --------------------------------------------------------
bool sub_31B8C()
{
  int v0; // r4
  int v1; // r0
  int v2; // r0
  int v3; // r3
  char v5[2048]; // [sp+0h] [bp-800h] BYREF

  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 5 )
  {
    if ( !byte_68BD5 )
      goto LABEL_7;
    goto LABEL_28;
  }
  strcpy(v5, "Received kill message");
  sub_20F58(6, v5, 1);
  if ( byte_68BD5 )
  {
    if ( byte_74500 || byte_68BD4 )
    {
LABEL_6:
      strcpy(v5, "Killing off watchpool thread");
      sub_20F58(7, v5, 1);
      goto LABEL_7;
    }
LABEL_28:
    if ( dword_67DB4 <= 6 )
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_7:
  sub_2541C((int)sub_23588, dword_75598 + (dword_69058 << 6), 1000);
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    strcpy(v5, "Killing off watchdog thread");
    sub_20F58(7, v5, 1);
  }
  sub_2541C((int)sub_23588, dword_75598 + (dword_6905C << 6), 1000);
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    strcpy(v5, "Shutting down mining threads");
    sub_20F58(7, v5, 1);
  }
  if ( dword_75588 > 0 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      v2 = sub_31B04(v1);
      if ( v2 )
      {
        v3 = *(_DWORD *)(v2 + 36);
        if ( v3 )
          *(_BYTE *)(v3 + 364) = 1;
      }
    }
    while ( v0 < dword_75588 );
  }
  sleep(1u);
  sub_2541C((int)sub_31EE4, 0, 3000);
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    strcpy(v5, "Killing off API thread");
    sub_20F58(7, v5, 1);
  }
  return sub_2541C((int)sub_23588, dword_75598 + (dword_68FCC << 6), 1000);
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 68FCC: using guessed type int dword_68FCC;
// 69058: using guessed type int dword_69058;
// 6905C: using guessed type int dword_6905C;
// 74500: using guessed type char byte_74500;
// 75588: using guessed type int dword_75588;
// 75598: using guessed type int dword_75598;

//----- (00031ECC) --------------------------------------------------------
bool sub_31ECC()
{
  _BOOL4 result; // r0

  if ( byte_68BD6 )
    return sub_31B8C();
  return result;
}
// 68BD6: using guessed type char byte_68BD6;

//----- (00031EE4) --------------------------------------------------------
void sub_31EE4()
{
  int i; // r4
  int v1; // r0
  int v2; // r5
  pthread_t v3; // r0
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    strcpy(v4, "Killing off mining threads");
    sub_20F58(7, v4, 1);
  }
  if ( dword_75588 > 0 )
  {
    for ( i = 0; dword_75588 > i; ++i )
    {
      while ( 1 )
      {
        v1 = sub_31B04(i);
        v2 = v1;
        if ( v1 )
        {
          if ( *(_DWORD *)(v1 + 12) )
            break;
        }
        sub_23588(v1);
LABEL_8:
        if ( dword_75588 <= ++i )
          return;
      }
      sub_23588(v1);
      v3 = *(_DWORD *)(v2 + 12);
      if ( !v3 )
        goto LABEL_8;
      pthread_join(v3, 0);
    }
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;
// 75588: using guessed type int dword_75588;

//----- (00031FF4) --------------------------------------------------------
int sub_31FF4()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_7453C) )
    sub_2EFE0("current_pool", 838);
  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_30138("current_pool", 838);
  if ( pthread_mutex_unlock(&stru_7453C) )
    sub_2F03C("current_pool", 838);
  v0 = dword_69060;
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_2FB24("current_pool", 842);
  off_67ED8();
  return v0;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 69060: using guessed type int dword_69060;
// 7453C: using guessed type pthread_mutex_t stru_7453C;

//----- (0003209C) --------------------------------------------------------
int __fastcall sub_3209C(int a1, int a2, int a3)
{
  int v6; // r1
  unsigned int v7; // r2
  unsigned int v8; // r12
  int v9; // r4
  int v11; // r0

  if ( pthread_mutex_lock(&stru_766C4) )
    sub_2EFE0("inc_work_stats", 8846);
  v6 = *(_DWORD *)(a1 + 36);
  v7 = *(_DWORD *)(v6 + 192);
  v8 = *(_DWORD *)(v6 + 196);
  qword_76850 += a3;
  *(_QWORD *)(v6 + 192) = __PAIR64__(v8, v7) + a3;
  if ( a2 )
  {
    *(_QWORD *)(a2 + 40) += a3;
  }
  else
  {
    v11 = sub_31FF4();
    *(_QWORD *)(v11 + 40) += a3;
  }
  v9 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v9 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_766C4) )
    sub_2F03C("inc_work_stats", 8860);
  return off_67ED8();
}
// 67ED8: using guessed type int (*off_67ED8)();
// 766C4: using guessed type pthread_mutex_t stru_766C4;
// 76850: using guessed type __int64 qword_76850;

//----- (0003218C) --------------------------------------------------------
int sub_3218C()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_7453C) )
    sub_2EFE0("cp_prio", 7418);
  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_30138("cp_prio", 7418);
  if ( pthread_mutex_unlock(&stru_7453C) )
    sub_2F03C("cp_prio", 7418);
  v0 = *(_DWORD *)(dword_69060 + 4);
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_2FB24("cp_prio", 7420);
  off_67ED8();
  return v0;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 69060: using guessed type int dword_69060;
// 7453C: using guessed type pthread_mutex_t stru_7453C;

//----- (00032238) --------------------------------------------------------
void __fastcall sub_32238(_DWORD *a1)
{
  int v2; // r3
  int v3; // r5
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v2 = dword_68FD0;
  a1[7] = 0;
  if ( v2 || (v3 = a1[1], v3 >= sub_3218C()) )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
    {
      snprintf(s, 0x800u, "Pool %d %s alive", *a1, (const char *)a1[41]);
      sub_20F58(6, s, 0);
    }
  }
  else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
  {
    snprintf(s, 0x800u, "Pool %d %s alive, testing stability", *a1, (const char *)a1[41]);
    sub_20F58(4, s, 0);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68FD0: using guessed type int dword_68FD0;
// 74500: using guessed type char byte_74500;

//----- (00032370) --------------------------------------------------------
void __fastcall sub_32370(_DWORD *a1)
{
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
  {
    snprintf(v2, 0x800u, "Stratum connection to pool %d resumed", *a1);
    sub_20F58(6, v2, 0);
    sub_32238(a1);
  }
  else
  {
    sub_32238(a1);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00032400) --------------------------------------------------------
void __fastcall sub_32400(int a1)
{
  if ( sub_2F180(a1, (_BYTE *)(a1 + 97)) )
    sub_32370((_DWORD *)a1);
}

//----- (00032424) --------------------------------------------------------
int __fastcall sub_32424(int a1)
{
  int v3; // r4

  if ( *(_DWORD *)(a1 + 100) != 1 )
    return 0;
  if ( (unsigned int)(dword_68FD0 - 3) <= 1 || *(_BYTE *)(a1 + 640) && *(_BYTE *)(a1 + 97) )
    return 1;
  if ( a1 == sub_31FF4() )
    return 1;
  if ( *(_DWORD *)(a1 + 732) )
    return 1;
  if ( !dword_68FD0 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 < sub_3218C() )
      return 1;
  }
  return (unsigned __int8)byte_69064;
}
// 68FD0: using guessed type int dword_68FD0;
// 69064: using guessed type char byte_69064;

//----- (000324B8) --------------------------------------------------------
_BYTE *sub_324B8()
{
  _BYTE *v0; // r0
  int v1; // r12
  _BYTE *v2; // r4
  int v3; // r1
  _DWORD *v4; // r0
  int v5; // r2
  int v7; // r3
  int v8; // r1
  int *v9; // r0
  int *v10; // r0
  int *v11; // r0
  int *v12; // r0
  int *v13; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v0 = sub_22A44(0x738u, 1u, "cgminer.c", "add_pool", 762);
  v1 = dword_733CC;
  v2 = v0;
  *(_DWORD *)v0 = dword_733CC;
  v3 = dword_733CC;
  v0[644] = 0;
  *((_DWORD *)v0 + 1) = v1;
  v4 = sub_22AD4((void *)dword_744C8, 4 * (v3 + 2), "cgminer.c", "add_pool", 774);
  v5 = dword_733CC;
  dword_744C8 = (int)v4;
  ++dword_733CC;
  v4[v5] = v2;
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 188), 0) )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v9, "cgminer.c", "add_pool", 777);
    goto LABEL_11;
  }
  if ( pthread_cond_init((pthread_cond_t *)(v2 + 296), 0) )
  {
    strcpy(s, "Failed to pthread_cond_init in add_pool");
    goto LABEL_11;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 212), 0) )
  {
    v10 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v10, "cgminer.c", "add_pool", 784);
    goto LABEL_11;
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v2 + 236), 0) )
  {
    v11 = _errno_location();
    v8 = 784;
    v7 = *v11;
    goto LABEL_10;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 704), 0) )
  {
    v12 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v12, "cgminer.c", "add_pool", 785);
    goto LABEL_11;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 740), 0) )
  {
    v13 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v13, "cgminer.c", "add_pool", 786);
LABEL_11:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v2 + 764), 0) )
  {
    v7 = *_errno_location();
    v8 = 786;
LABEL_10:
    snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", v7, "cgminer.c", "add_pool", v8);
    goto LABEL_11;
  }
  *((_DWORD *)v2 + 34) = -1;
  *((_DWORD *)v2 + 46) = 0;
  *((_DWORD *)v2 + 40) = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  *((_DWORD *)v2 + 86) = v2 + 344;
  *((_DWORD *)v2 + 87) = v2 + 344;
  *((_DWORD *)v2 + 14) = 1;
  sub_2C6A8();
  v2[580] = 0;
  return v2;
}
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (00032704) --------------------------------------------------------
const char *__fastcall sub_32704(char *s)
{
  int v2; // r3
  _DWORD *v3; // r6
  char *v4; // r4
  char *v5; // r0
  char *v6; // r4

  if ( dword_69068 || dword_6906C )
    return "Use only user + pass or userpass, but not both";
  v2 = dword_69070 + 1;
  dword_69070 = v2;
  if ( v2 > dword_733CC )
  {
    sub_324B8();
    v2 = dword_69070;
  }
  v3 = *(_DWORD **)(dword_744C8 + 4 * (v2 + 0x3FFFFFFF));
  v4 = _strdup(s);
  sub_4014C((int)s, v3 + 42);
  v5 = strtok(v4, ":");
  v3[43] = v5;
  if ( !v5 )
    return "Failed to find : delimited user info";
  v6 = strtok(0, ":");
  v3[44] = v6;
  if ( v6 )
    return 0;
  v3[44] = calloc(1u, 1u);
  return v6;
}
// 69068: using guessed type int dword_69068;
// 6906C: using guessed type int dword_6906C;
// 69070: using guessed type int dword_69070;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (000327F0) --------------------------------------------------------
const char *__fastcall sub_327F0(int a1)
{
  int v3; // r3

  if ( dword_69070 )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_69068 + 1;
  dword_69068 = v3;
  if ( v3 > dword_733CC )
  {
    sub_324B8();
    v3 = dword_69068;
  }
  sub_4014C(a1, (_DWORD *)(*(_DWORD *)(dword_744C8 + 4 * (v3 + 0x3FFFFFFF)) + 172));
  return 0;
}
// 69068: using guessed type int dword_69068;
// 69070: using guessed type int dword_69070;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (0003286C) --------------------------------------------------------
int sub_3286C()
{
  int v0; // r3

  v0 = ++dword_69074;
  if ( dword_69074 > dword_733CC )
  {
    sub_324B8();
    v0 = dword_69074;
  }
  return *(_DWORD *)(dword_744C8 + 4 * (v0 + 0x3FFFFFFF));
}
// 69074: using guessed type int dword_69074;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (00032AD4) --------------------------------------------------------
const char *__fastcall sub_32AD4(int a1)
{
  int v3; // r3

  if ( dword_69070 )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_6906C + 1;
  dword_6906C = v3;
  if ( v3 > dword_733CC )
  {
    sub_324B8();
    v3 = dword_6906C;
  }
  sub_4014C(a1, (_DWORD *)(*(_DWORD *)(dword_744C8 + 4 * (v3 + 0x3FFFFFFF)) + 176));
  return 0;
}
// 6906C: using guessed type int dword_6906C;
// 69070: using guessed type int dword_69070;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;

//----- (00032B50) --------------------------------------------------------
int sub_32B50()
{
  int v0; // r3
  int v1; // r4
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = ++dword_69078;
  if ( dword_69078 > dword_733CC )
  {
    sub_324B8();
    v0 = dword_69078;
  }
  v1 = *(_DWORD *)(dword_744C8 + 4 * (v0 + 0x3FFFFFFF));
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf(v3, 0x800u, "Enable extranonce subscribe on %d", *(_DWORD *)v1);
    sub_20F58(7, v3, 0);
  }
  sub_40068((_BYTE *)(v1 + 580));
  return 0;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 69078: using guessed type int dword_69078;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;

//----- (00032C30) --------------------------------------------------------
void __fastcall sub_32C30(pthread_rwlock_t *a1)
{
  void **nr_readers; // r2
  int *v3; // r0
  void **v4; // [sp+14h] [bp-808h] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v4 = 0;
  if ( a1 && !pthread_rwlock_trywrlock(a1 + 10) )
  {
    nr_readers = (void **)a1[11].__nr_readers;
    a1[11].__nr_readers = 0;
    v4 = nr_readers;
    if ( pthread_rwlock_unlock(a1 + 10) )
    {
      v3 = _errno_location();
      snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "cgminer.c", "flush_queue", 9641);
      sub_20F58(3, s, 1);
      sub_2E6B0(1, 1);
    }
    off_67ED8();
    if ( v4 )
    {
      sub_2CBA8(&v4, "cgminer.c", "flush_queue", 9645);
      if ( byte_68BD5 )
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
        {
          strcpy(s, "Discarded queued work item");
          sub_20F58(7, s, 0);
        }
      }
    }
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (00032DA0) --------------------------------------------------------
int sub_32DA0()
{
  int v0; // r4
  char *v1; // r0
  int *v2; // r3
  int *v3; // r12
  int v4; // lr
  int v5; // t1
  int result; // r0
  int v7; // r5
  int v8; // r4
  int *v9; // r0
  int *v10; // r0
  struct sysinfo info; // [sp+10h] [bp-840h] BYREF
  char s[2048]; // [sp+50h] [bp-800h] BYREF

  if ( sysinfo(&info) )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
    {
      v0 = *_errno_location();
      v1 = strerror(v0);
      snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
      sub_20F58(6, s, 0);
    }
    dword_73320 = time(0);
  }
  else
  {
    dword_73320 = info.uptime;
  }
  sub_239A4((struct timeval *)&dword_69020);
  sub_257F8(&unk_6907C, &dword_69020);
  v2 = (int *)&unk_69088;
  dbl_75590 = 0.0;
  dbl_75690 = 0.0;
  dbl_75688 = 0.0;
  dbl_75698 = 0.0;
  dbl_756A8 = 0.0;
  dbl_76830 = 0.0;
  do
  {
    *(_QWORD *)v2 = 0;
    v2 += 2;
  }
  while ( v2 != &dword_690E8 );
  dbl_68740 = 1.0;
  dbl_68720 = 1.0;
  dbl_68738 = 1.0;
  dword_73368 = 0;
  dword_690E8 = 0;
  dword_75580 = 0;
  dword_75584 = 0;
  dword_767E0 = 0;
  dword_7345C = 0;
  dword_755D0 = 0;
  dword_74494 = 0;
  *(_QWORD *)&dword_755E8 = 0;
  qword_755D8 = 0;
  qword_767E8 = 0;
  *(_QWORD *)&dword_73318 = 0;
  qword_73380 = 0;
  *(_QWORD *)&dword_76850 = 0;
  dbl_73370 = 0.0;
  dbl_73390 = 0.0;
  dbl_766B8 = 0.0;
  if ( dword_733CC > 0 )
  {
    v3 = (int *)dword_744C8;
    v4 = dword_744C8 + 4 * dword_733CC;
    do
    {
      v5 = *v3++;
      *(_DWORD *)(v5 + 116) = 0;
      *(_QWORD *)(v5 + 8) = 0;
      *(_QWORD *)(v5 + 16) = 0;
      *(_DWORD *)(v5 + 120) = 0;
      *(_DWORD *)(v5 + 124) = 0;
      *(_DWORD *)(v5 + 128) = 0;
      *(_DWORD *)(v5 + 132) = 0;
      *(_DWORD *)(v5 + 352) = 0;
      *(_QWORD *)(v5 + 40) = 0;
      *(_QWORD *)(v5 + 72) = 0;
      *(_QWORD *)(v5 + 80) = 0;
      *(_QWORD *)(v5 + 88) = 0;
      *(_DWORD *)(v5 + 360) = 0;
      *(_DWORD *)(v5 + 364) = 0;
    }
    while ( (int *)v4 != v3 );
  }
  result = sub_2D75C();
  if ( dword_755C0 > 0 )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = sub_3046C(v7);
      sub_257F8((void *)(v8 + 368), &dword_69020);
      if ( pthread_mutex_lock(&stru_76838) )
        break;
      *(_QWORD *)(v8 + 80) = 0;
      *(_DWORD *)(v8 + 36) = 0;
      *(_DWORD *)(v8 + 40) = 0;
      *(_DWORD *)(v8 + 44) = 0;
      *(_QWORD *)(v8 + 88) = 0;
      *(_DWORD *)(v8 + 220) = 0;
      *(_QWORD *)(v8 + 200) = 0;
      *(_QWORD *)(v8 + 208) = 0;
      *(_QWORD *)(v8 + 224) = 0;
      *(_QWORD *)(v8 + 192) = 0;
      if ( pthread_mutex_unlock(&stru_76838) )
      {
        v10 = _errno_location();
        snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v10, "cgminer.c", "zero_stats", 6188);
LABEL_19:
        sub_20F58(3, s, 1);
        sub_2E6B0(1, 1);
      }
      ++v7;
      off_67ED8();
      result = (*(int (__fastcall **)(int))(*(_DWORD *)(v8 + 4) + 96))(v8);
      if ( dword_755C0 <= v7 )
        return result;
    }
    v9 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "cgminer.c", "zero_stats", 6175);
    goto LABEL_19;
  }
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68720: using guessed type double dbl_68720;
// 68738: using guessed type double dbl_68738;
// 68740: using guessed type double dbl_68740;
// 68BD4: using guessed type char byte_68BD4;
// 69020: using guessed type int dword_69020;
// 690E8: using guessed type int dword_690E8;
// 73318: using guessed type int dword_73318;
// 73320: using guessed type int dword_73320;
// 73368: using guessed type int dword_73368;
// 73370: using guessed type double dbl_73370;
// 73380: using guessed type __int64 qword_73380;
// 73390: using guessed type double dbl_73390;
// 733CC: using guessed type int dword_733CC;
// 7345C: using guessed type int dword_7345C;
// 74494: using guessed type int dword_74494;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;
// 75580: using guessed type int dword_75580;
// 75584: using guessed type int dword_75584;
// 75590: using guessed type double dbl_75590;
// 755C0: using guessed type int dword_755C0;
// 755D0: using guessed type int dword_755D0;
// 755D8: using guessed type __int64 qword_755D8;
// 755E8: using guessed type int dword_755E8;
// 75688: using guessed type double dbl_75688;
// 75690: using guessed type double dbl_75690;
// 75698: using guessed type double dbl_75698;
// 756A8: using guessed type double dbl_756A8;
// 766B8: using guessed type double dbl_766B8;
// 767E0: using guessed type int dword_767E0;
// 767E8: using guessed type __int64 qword_767E8;
// 76830: using guessed type double dbl_76830;
// 76838: using guessed type pthread_mutex_t stru_76838;
// 76850: using guessed type int dword_76850;

//----- (000331A4) --------------------------------------------------------
int __fastcall sub_331A4(int a1)
{
  int v2; // r12
  int v3; // r2
  int result; // r0
  int (__fastcall *v5)(int); // r3
  int *v6; // r0
  int *v7; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
  {
    snprintf(
      s,
      0x800u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_20F58(6, s, 0);
  }
  if ( pthread_mutex_lock(&stru_766C4) )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "cgminer.c", "inc_hw_errors", 8756);
    goto LABEL_12;
  }
  v2 = *(_DWORD *)(a1 + 36);
  v3 = *(_DWORD *)(v2 + 44) + 1;
  ++dword_73368;
  *(_DWORD *)(v2 + 44) = v3;
  if ( pthread_mutex_unlock(&stru_766C4) )
  {
    v7 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v7, "cgminer.c", "inc_hw_errors", 8759);
LABEL_12:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  result = off_67ED8();
  v5 = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84);
  if ( v5 )
    return v5(a1);
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 73368: using guessed type int dword_73368;
// 74500: using guessed type char byte_74500;
// 766C4: using guessed type pthread_mutex_t stru_766C4;

//----- (0003332C) --------------------------------------------------------
int __fastcall sub_3332C(int a1, int a2)
{
  int v4; // r12
  int v5; // r1
  int result; // r0
  int (__fastcall *v7)(int); // r3
  int *v8; // r0
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    snprintf(
      s,
      0x800u,
      "%s%d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_20F58(3, s, 0);
  }
  if ( pthread_mutex_lock(&stru_766C4) )
  {
    v8 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v8,
      "cgminer.c",
      "inc_hw_errors_with_diff",
      8770);
    goto LABEL_12;
  }
  v4 = *(_DWORD *)(a1 + 36);
  v5 = *(_DWORD *)(v4 + 44) + a2;
  dword_73368 += a2;
  *(_DWORD *)(v4 + 44) = v5;
  if ( pthread_mutex_unlock(&stru_766C4) )
  {
    v9 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v9,
      "cgminer.c",
      "inc_hw_errors_with_diff",
      8773);
LABEL_12:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  result = off_67ED8();
  v7 = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84);
  if ( v7 )
    return v7(a1);
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 73368: using guessed type int dword_73368;
// 74500: using guessed type char byte_74500;
// 766C4: using guessed type pthread_mutex_t stru_766C4;

//----- (000334C0) --------------------------------------------------------
unsigned __int64 __fastcall sub_334C0(int a1)
{
  double v2; // r0
  double v3; // d8
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d6
  double v8; // r0
  double v9; // d8
  unsigned __int64 v10; // r6
  int v11; // r8
  unsigned __int64 *v12; // r3
  int *v14; // r0
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  LODWORD(v2) = sub_4A10C(*(_QWORD *)(a1 + 216));
  v3 = v2 * 6.27710174e57;
  LODWORD(v4) = sub_4A10C(*(_QWORD *)(a1 + 208));
  v5 = v3 + v4 * 3.40282367e38;
  LODWORD(v6) = sub_4A10C(*(_QWORD *)(a1 + 200));
  v7 = v6;
  LODWORD(v8) = sub_4A10C(*(_QWORD *)(a1 + 192));
  v9 = v8 + v5 + v7 * 1.84467441e19;
  if ( v9 == 0.0 )
    v9 = 0.0;
  round();
  v10 = (unsigned __int64)(2.69595353e67 / v9);
  if ( pthread_mutex_lock(&stru_7453C) )
  {
    v14 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v14, "cgminer.c", "share_diff", 5150);
    goto LABEL_14;
  }
  v11 = pthread_rwlock_wrlock(&rwlock);
  if ( v11 )
  {
    v15 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v15, "cgminer.c", "share_diff", 5150);
    goto LABEL_14;
  }
  if ( qword_68FF0 < v10 )
  {
    qword_68FF0 = (unsigned __int64)(2.69595353e67 / v9);
    v11 = 1;
    sub_2AEF8(v10, dword_68728, 8u, 0);
  }
  v12 = (unsigned __int64 *)(*(_DWORD *)(a1 + 260) + 368);
  if ( *v12 < v10 )
    *v12 = v10;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v16 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v16, "cgminer.c", "share_diff", 5164);
    goto LABEL_14;
  }
  if ( pthread_mutex_unlock(&stru_7453C) )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "share_diff", 5164);
LABEL_14:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  off_67ED8();
  if ( v11 && (byte_74500 || byte_68BD4 || dword_67DB4 > 5) )
  {
    snprintf(s, 0x800u, "New best share: %s", dword_68728);
    sub_20F58(6, s, 0);
  }
  return (unsigned __int64)(2.69595353e67 / v9);
}
// 334E4: variable 'v2' is possibly undefined
// 334F8: variable 'v4' is possibly undefined
// 33504: variable 'v6' is possibly undefined
// 3351C: variable 'v8' is possibly undefined
// 1225C: using guessed type int round(void);
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68FF0: using guessed type __int64 qword_68FF0;
// 74500: using guessed type char byte_74500;
// 7453C: using guessed type pthread_mutex_t stru_7453C;

//----- (00033790) --------------------------------------------------------
int __fastcall sub_33790(int *a1, int a2)
{
  double v4; // d8
  unsigned __int64 v5; // r0
  double v6; // r0
  double v7; // d8
  double v8; // r0
  int v9; // r5
  double v10; // r0
  int v11; // r5
  double v12; // r0
  int v13; // r4
  int v15; // r12
  int v16; // r2
  bool v17; // zf
  int v18; // r2
  int *v19; // r0
  int *v20; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = dbl_68748;
  v5 = sub_334C0(a2);
  *(_QWORD *)(a2 + 232) = v5;
  LODWORD(v6) = sub_4A10C(v5);
  if ( v4 <= v6 )
  {
    v15 = *(_DWORD *)(a2 + 260);
    v16 = (unsigned __int8)byte_74500;
    *(_BYTE *)(a2 + 283) = 1;
    v17 = v16 == 0;
    v18 = dword_7345C + 1;
    ++*(_DWORD *)(v15 + 32);
    dword_7345C = v18;
    *(_BYTE *)(a2 + 282) = 1;
    if ( !v17 || byte_68BD4 || dword_67DB4 > 4 )
    {
      snprintf(s, 0x800u, "Found block for pool %d!", **(_DWORD **)(a2 + 260));
      sub_20F58(5, s, 0);
    }
  }
  if ( pthread_mutex_lock(&stru_766C4) )
  {
    v19 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v19, "cgminer.c", "update_work_stats", 8836);
    goto LABEL_10;
  }
  v7 = *(double *)(a2 + 224);
  LODWORD(v8) = sub_4A11C(qword_76850);
  qword_76850 = (__int64)(v8 + v7);
  v9 = *a1;
  LODWORD(v10) = sub_4A11C(*(_QWORD *)(*a1 + 192));
  *(_QWORD *)(v9 + 192) = (__int64)(v10 + v7);
  v11 = *(_DWORD *)(a2 + 260);
  LODWORD(v12) = sub_4A11C(*(_QWORD *)(v11 + 40));
  *(_QWORD *)(v11 + 40) = (__int64)(v12 + *(double *)(a2 + 224));
  v13 = *a1;
  *(_DWORD *)(v13 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_766C4) )
  {
    v20 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v20,
      "cgminer.c",
      "update_work_stats",
      8841);
LABEL_10:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  return off_67ED8();
}
// 337CC: variable 'v6' is possibly undefined
// 33800: variable 'v8' is possibly undefined
// 33820: variable 'v10' is possibly undefined
// 33844: variable 'v12' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68748: using guessed type double dbl_68748;
// 68BD4: using guessed type char byte_68BD4;
// 7345C: using guessed type int dword_7345C;
// 74500: using guessed type char byte_74500;
// 766C4: using guessed type pthread_mutex_t stru_766C4;
// 76850: using guessed type __int64 qword_76850;

//----- (000339BC) --------------------------------------------------------
int __fastcall sub_339BC(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  bool v4; // zf
  _DWORD *v5; // r5
  int v8; // r4
  char v10[2048]; // [sp+0h] [bp-800h] BYREF

  v5 = a4;
  v4 = a4 == 0;
  if ( a4 )
    a4 = 0;
  if ( !v4 )
    *v5 = a4;
  a2[19] = a3;
  sub_2B350((int)a2);
  if ( a2[55] )
  {
    sub_331A4(a1);
    return 0;
  }
  else
  {
    sub_33790((int *)(a1 + 36), (int)a2);
    v8 = sub_23110(a2 + 48, a2 + 40);
    if ( !v8 )
    {
      if ( v5 )
        *v5 = 1;
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        strcpy(v10, "Share above target");
        sub_20F58(6, v10, 0);
      }
      else
      {
        return (unsigned __int8)byte_68BD4;
      }
    }
    return v8;
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00033AB4) --------------------------------------------------------
void __fastcall sub_33AB4(_DWORD *a1)
{
  int v2; // r7
  _DWORD *v3; // r3
  int v4; // r4
  int v5; // r10
  int v6; // r1
  int v7; // r0
  int v8; // r2
  _DWORD *v9; // r12
  int v10; // r9
  _DWORD *v11; // r0
  int v12; // r2
  int v13; // r0
  _DWORD *v14; // lr
  int v15; // r0
  int v16; // r2
  int *v17; // r0
  int *v18; // r0
  void **v19; // [sp+14h] [bp-804h] BYREF
  char s[2048]; // [sp+18h] [bp-800h] BYREF

  v2 = pthread_mutex_lock((pthread_mutex_t *)dword_69010);
  if ( v2 )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "clear_pool_work", 7398);
    goto LABEL_37;
  }
  v3 = (_DWORD *)dword_690EC;
  v19 = (void **)dword_690EC;
  if ( !dword_690EC )
  {
    if ( !pthread_mutex_unlock((pthread_mutex_t *)dword_69010) )
    {
      off_67ED8();
      return;
    }
    goto LABEL_38;
  }
  v4 = *(_DWORD *)(dword_690EC + 352);
  if ( *(_DWORD **)(dword_690EC + 260) == a1 )
    goto LABEL_6;
LABEL_4:
  v19 = (void **)v4;
  if ( v4 )
  {
    while ( 1 )
    {
      v3 = (_DWORD *)v4;
      v4 = *(_DWORD *)(v4 + 352);
      if ( (_DWORD *)v3[65] != a1 )
        goto LABEL_4;
LABEL_6:
      v5 = v3[87];
      v6 = dword_690EC;
      v7 = *(_DWORD *)(dword_690EC + 344);
      if ( v5 )
        break;
      v10 = v3[88];
      if ( v10 )
      {
        v8 = *(_DWORD *)(v7 + 20);
        v9 = v3 + 86;
        if ( v3 != (_DWORD *)(*(_DWORD *)(v7 + 16) - v8) )
          goto LABEL_29;
LABEL_30:
        *(_DWORD *)(v7 + 16) = v5 + v8;
        v5 = v3[87];
        if ( v5 )
        {
          v8 = *(_DWORD *)(*(_DWORD *)(v6 + 344) + 20);
          goto LABEL_8;
        }
        v10 = v3[88];
LABEL_29:
        v6 = v10;
        dword_690EC = v10;
LABEL_9:
        v11 = *(_DWORD **)(v6 + 344);
        if ( v10 )
        {
          *(_DWORD *)(v10 + v11[5] + 4) = v3[87];
          v11 = *(_DWORD **)(v6 + 344);
        }
        v12 = 3 * ((v11[1] - 1) & v3[93]);
        --*(_DWORD *)(*v11 + 4 * v12 + 4);
        v13 = **(_DWORD **)(v6 + 344);
        v14 = *(_DWORD **)(v13 + 4 * v12);
        if ( v14 == v9 )
        {
          v6 = v3[90];
          *(_DWORD *)(v13 + 4 * v12) = v6;
        }
        v15 = v3[89];
        v16 = v3[90];
        if ( v14 == v9 )
          v6 = dword_690EC;
        if ( v15 )
        {
          *(_DWORD *)(v15 + 16) = v16;
          v16 = v3[90];
        }
        if ( v16 )
          *(_DWORD *)(v16 + 12) = v3[89];
        --*(_DWORD *)(*(_DWORD *)(v6 + 344) + 12);
        goto LABEL_20;
      }
      free(*(void **)v7);
      free(*(void **)(dword_690EC + 344));
      dword_690EC = 0;
LABEL_20:
      ++v2;
      sub_2CBA8(&v19, "cgminer.c", "clear_pool_work", 7404);
      v19 = (void **)v4;
      if ( !v4 )
        goto LABEL_21;
    }
    v8 = *(_DWORD *)(v7 + 20);
    v9 = v3 + 86;
    if ( v3 == (_DWORD *)(*(_DWORD *)(v7 + 16) - v8) )
      goto LABEL_30;
LABEL_8:
    *(_DWORD *)(v5 + v8 + 8) = v3[88];
    v10 = v3[88];
    goto LABEL_9;
  }
LABEL_21:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_69010) )
  {
LABEL_38:
    v18 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v18, "cgminer.c", "clear_pool_work", 7408);
LABEL_37:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  off_67ED8();
  if ( v2 && (byte_74500 || byte_68BD4 || dword_67DB4 > 5) )
  {
    snprintf(s, 0x800u, "Cleared %d work items due to stratum disconnect on pool %d", v2, *a1);
    sub_20F58(6, s, 0);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 69010: using guessed type int dword_69010;
// 690EC: using guessed type int dword_690EC;
// 74500: using guessed type char byte_74500;

//----- (00033DDC) --------------------------------------------------------
int *__fastcall sub_33DDC(int a1)
{
  int v2; // r8
  int v3; // r4
  int v4; // r5
  double v5; // d8
  int v6; // r0
  void **v7; // r11
  int v8; // r1
  __int64 v9; // r2
  __int64 v11; // r2
  int *result; // r0
  double v13; // d6
  double v14; // d8
  __int64 v15; // r4
  int v16; // r8
  int *v17; // r0
  int *v18; // r0
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v2 = pthread_mutex_lock(&stru_690F0);
  if ( v2 )
  {
    v17 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v17,
      "cgminer.c",
      "clear_stratum_shares",
      7367);
    goto LABEL_36;
  }
  v3 = dword_69108;
  if ( !dword_69108 )
  {
    if ( !pthread_mutex_unlock(&stru_690F0) )
      return (int *)off_67ED8();
    goto LABEL_37;
  }
  v4 = *(_DWORD *)(dword_69108 + 8);
  v5 = 0.0;
  if ( *(_DWORD *)(*(_DWORD *)(dword_69108 + 36) + 260) == a1 )
    goto LABEL_6;
LABEL_4:
  if ( v4 )
  {
    while ( 1 )
    {
      v3 = v4;
      v4 = *(_DWORD *)(v4 + 8);
      if ( *(_DWORD *)(*(_DWORD *)(v3 + 36) + 260) != a1 )
        goto LABEL_4;
LABEL_6:
      v6 = *(_DWORD *)(v3 + 4);
      v7 = (void **)dword_69108;
      v8 = *(_DWORD *)dword_69108;
      if ( v6 )
        break;
      LODWORD(v9) = *(_DWORD *)(v3 + 8);
      if ( (_DWORD)v9 )
      {
        HIDWORD(v9) = *(_DWORD *)(v8 + 20);
        if ( v3 != *(_DWORD *)(v8 + 16) - HIDWORD(v9) )
          goto LABEL_30;
LABEL_28:
        *(_DWORD *)(v8 + 16) = v6 + HIDWORD(v9);
        v6 = *(_DWORD *)(v3 + 4);
        if ( !v6 )
        {
          LODWORD(v9) = *(_DWORD *)(v3 + 8);
LABEL_30:
          HIDWORD(v9) = v9;
          v7 = (void **)v9;
          dword_69108 = v9;
LABEL_9:
          LODWORD(v9) = *v7;
          if ( HIDWORD(v9) )
          {
            *(_DWORD *)(HIDWORD(v9) + *(_DWORD *)(v9 + 20) + 4) = *(_DWORD *)(v3 + 4);
            LODWORD(v9) = *v7;
          }
          HIDWORD(v9) = 3 * ((*(_DWORD *)(v9 + 4) - 1) & *(_DWORD *)(v3 + 28));
          --*(_DWORD *)(*(_DWORD *)v9 + 4 * HIDWORD(v9) + 4);
          LODWORD(v9) = *(_DWORD *)*v7;
          if ( *(_DWORD *)(v9 + 4 * HIDWORD(v9)) == v3 )
            *(_DWORD *)(v9 + 4 * HIDWORD(v9)) = *(_DWORD *)(v3 + 16);
          v11 = *(_QWORD *)(v3 + 12);
          if ( (_DWORD)v11 )
          {
            *(_DWORD *)(v11 + 16) = HIDWORD(v11);
            HIDWORD(v11) = *(_DWORD *)(v3 + 16);
          }
          if ( HIDWORD(v11) )
            *(_DWORD *)(HIDWORD(v11) + 12) = *(_DWORD *)(v3 + 12);
          --*((_DWORD *)*v7 + 3);
          goto LABEL_18;
        }
        HIDWORD(v9) = *((_DWORD *)*v7 + 5);
LABEL_8:
        *(_DWORD *)(v6 + HIDWORD(v9) + 8) = *(_DWORD *)(v3 + 8);
        HIDWORD(v9) = *(_DWORD *)(v3 + 8);
        goto LABEL_9;
      }
      free(*(void **)v8);
      free(*v7);
      dword_69108 = 0;
LABEL_18:
      ++v2;
      v5 = v5 + *(double *)(*(_DWORD *)(v3 + 36) + 376);
      sub_2CBA8((void ***)(v3 + 36), "cgminer.c", "clear_stratum_shares", 7375);
      --*(_DWORD *)(a1 + 732);
      free((void *)v3);
      if ( !v4 )
        goto LABEL_19;
    }
    v9 = *(_QWORD *)(v8 + 16);
    if ( v3 == (_DWORD)v9 - HIDWORD(v9) )
      goto LABEL_28;
    goto LABEL_8;
  }
LABEL_19:
  if ( pthread_mutex_unlock(&stru_690F0) )
  {
LABEL_37:
    v18 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v18,
      "cgminer.c",
      "clear_stratum_shares",
      7381);
LABEL_36:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  result = (int *)off_67ED8();
  if ( v2 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
    {
      snprintf(s, 0x800u, "Lost %d shares due to stratum disconnect on pool %d", v2, *(_DWORD *)a1);
      sub_20F58(4, s, 0);
    }
    result = &dword_73318;
    v13 = *(double *)(a1 + 88) + v5;
    v14 = dbl_766B8 + v5;
    v15 = *(_QWORD *)&dword_73318 + v2;
    v16 = *(_DWORD *)(a1 + 120) + v2;
    *(double *)(a1 + 88) = v13;
    *(_QWORD *)&dword_73318 = v15;
    *(_DWORD *)(a1 + 120) = v16;
    dbl_766B8 = v14;
  }
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 69108: using guessed type int dword_69108;
// 73318: using guessed type int dword_73318;
// 74500: using guessed type char byte_74500;
// 766B8: using guessed type double dbl_766B8;

//----- (00034178) --------------------------------------------------------
int __fastcall sub_34178(int a1)
{
  int v2; // r9
  unsigned __int8 *v3; // r6
  int v4; // lr
  int v5; // r7
  int v6; // r11
  int v7; // r12
  int v8; // r1
  int *v9; // r2
  int v10; // r12
  int v11; // r0
  int v12; // t1
  int v13; // r3
  int v14; // r0
  _DWORD *v15; // r1
  unsigned __int8 *v16; // r5
  int v18; // r10
  int v19; // r8
  int v20; // r9
  int v21; // r3
  int v22; // r3
  int v23; // r12
  int *v24; // r0
  int *v25; // r0
  int v26; // r3
  int v27; // r12
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_7453C) )
  {
    v22 = *_errno_location();
    v23 = 5243;
LABEL_55:
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v22, "cgminer.c", "switch_pools", v23);
    goto LABEL_56;
  }
  v2 = pthread_rwlock_wrlock(&rwlock);
  if ( v2 )
  {
    v24 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v24, "cgminer.c", "switch_pools", 5243);
    goto LABEL_56;
  }
  v3 = (unsigned __int8 *)dword_69060;
  v4 = dword_68FD0;
  v5 = *(_DWORD *)dword_69060;
  if ( a1 )
  {
    v6 = *(_DWORD *)(a1 + 4);
    if ( v6 )
    {
      v7 = dword_733CC;
      if ( dword_733CC > 0 )
      {
        v8 = dword_744C8;
        v9 = (int *)dword_744C8;
        v10 = dword_744C8 + 4 * dword_733CC;
        while ( 1 )
        {
          v12 = *v9++;
          v11 = v12;
          v13 = *(_DWORD *)(v12 + 4);
          if ( v13 < v6 )
            *(_DWORD *)(v11 + 4) = v13 + 1;
          if ( (int *)v10 == v9 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            switch ( v4 )
            {
              case 0:
              case 3:
              case 4:
                goto LABEL_15;
              case 1:
              case 2:
                goto LABEL_38;
              default:
                goto LABEL_51;
            }
          }
          v6 = *(_DWORD *)(a1 + 4);
        }
      }
      *(_DWORD *)(a1 + 4) = 0;
      switch ( v4 )
      {
        case 0:
        case 3:
        case 4:
          goto LABEL_14;
        case 1:
        case 2:
          goto LABEL_37;
        default:
          goto LABEL_22;
      }
    }
    switch ( dword_68FD0 )
    {
      case 0:
      case 3:
      case 4:
        goto LABEL_13;
      case 1:
      case 2:
LABEL_37:
        v8 = dword_744C8;
LABEL_38:
        if ( *(_BYTE *)(a1 + 97) )
          goto LABEL_41;
        v16 = *(unsigned __int8 **)(v8 + 4 * *(_DWORD *)a1);
        break;
      default:
        goto LABEL_22;
    }
  }
  else
  {
    switch ( dword_68FD0 )
    {
      case 0:
      case 3:
      case 4:
LABEL_13:
        v7 = dword_733CC;
LABEL_14:
        if ( v7 <= 0 )
          goto LABEL_22;
        do
        {
LABEL_15:
          v14 = sub_2B7BC(v2);
          if ( !*(_BYTE *)(v14 + 97) && *(_DWORD *)(v14 + 100) == 1 && !sub_2B684((unsigned __int8 *)v14) )
          {
            v16 = *(unsigned __int8 **)(dword_744C8 + 4 * *v15);
            goto LABEL_23;
          }
          ++v2;
        }
        while ( dword_733CC > v2 );
        v16 = *(unsigned __int8 **)(dword_744C8 + 4 * v5);
        break;
      case 1:
      case 2:
        v8 = dword_744C8;
LABEL_41:
        v18 = dword_733CC;
        if ( dword_733CC <= 1 )
        {
LABEL_51:
          v16 = *(unsigned __int8 **)(v8 + 4 * v5);
        }
        else
        {
          v19 = v5;
          v20 = 1;
          while ( 1 )
          {
            if ( ++v19 >= v18 )
            {
              v21 = v8;
              v19 = 0;
            }
            else
            {
              v21 = v8 + 4 * v19;
            }
            v16 = *(unsigned __int8 **)v21;
            if ( !*(_BYTE *)(*(_DWORD *)v21 + 97) && *((_DWORD *)v16 + 25) == 1 && !sub_2B684(v16) )
              break;
            if ( ++v20 == v18 )
              goto LABEL_51;
          }
        }
        break;
      default:
LABEL_22:
        v16 = *(unsigned __int8 **)(dword_744C8 + 4 * v5);
        break;
    }
  }
LABEL_23:
  dword_69060 = (int)v16;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v25 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v25, "cgminer.c", "switch_pools", 5324);
    goto LABEL_56;
  }
  if ( pthread_mutex_unlock(&stru_7453C) )
  {
    v26 = *_errno_location();
    v27 = 5324;
LABEL_60:
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v26, "cgminer.c", "switch_pools", v27);
LABEL_56:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  off_67ED8();
  if ( v3 != v16 && (unsigned int)(dword_68FD0 - 3) > 1 )
  {
    if ( (byte_74500 || byte_68BD4 || dword_67DB4 > 3)
      && ((snprintf(s, 0x800u, "Switching to pool %d %s", *(_DWORD *)v16, *((const char **)v16 + 41)),
           sub_20F58(4, s, 0),
           byte_74500)
       || byte_68BD4)
      || dword_67DB4 > 3 )
    {
      snprintf(
        s,
        0x800u,
        "last_pool->pool_no = %d, last_pool->pool->rpc_url = %s",
        *(_DWORD *)v3,
        *((const char **)v3 + 41));
      sub_20F58(4, s, 0);
    }
    sub_33AB4(v3);
  }
  if ( pthread_mutex_lock(&stru_6910C) )
  {
    v22 = *_errno_location();
    v23 = 5333;
    goto LABEL_55;
  }
  pthread_cond_broadcast(&cond);
  if ( pthread_mutex_unlock(&stru_6910C) )
  {
    v26 = *_errno_location();
    v27 = 5335;
    goto LABEL_60;
  }
  return off_67ED8();
}
// 34230: control flows out of bounds to 34234
// 34250: control flows out of bounds to 34254
// 342E4: control flows out of bounds to 342E8
// 34644: control flows out of bounds to 34648
// 342B0: variable 'v15' is possibly undefined
// 344B8: variable 'v8' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68FD0: using guessed type int dword_68FD0;
// 69060: using guessed type int dword_69060;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;
// 7453C: using guessed type pthread_mutex_t stru_7453C;

//----- (0003466C) --------------------------------------------------------
void __fastcall sub_3466C(int a1)
{
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( !sub_2F098(a1, (_BYTE *)(a1 + 97)) )
  {
    sub_239A4((struct timeval *)(a1 + 136));
    if ( a1 == sub_31FF4() )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
      {
        snprintf(s, 0x800u, "Pool %d %s not responding!", *(_DWORD *)a1, *(const char **)(a1 + 164));
        sub_20F58(4, s, 0);
      }
      sub_34178(0);
    }
    else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
    {
      snprintf(s, 0x800u, "Pool %d %s failed to return work", *(_DWORD *)a1, *(const char **)(a1 + 164));
      sub_20F58(6, s, 0);
    }
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (0003479C) --------------------------------------------------------
int sub_3479C()
{
  pthread_t v0; // r0
  int v1; // r9
  int v2; // r6
  int v3; // r3
  int v4; // r11
  int v5; // r10
  int v6; // r6
  int v7; // r6
  int v8; // r6
  int v9; // r12
  int v10; // r1
  int v11; // r2
  int v12; // r11
  int v13; // r6
  int v14; // r5
  int v15; // r5
  int v17; // r6
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v0 = pthread_self();
  pthread_detach(v0);
  sub_2541C((int)sub_23588, dword_75598 + (dword_69058 << 6), 1000);
  sleep(1u);
  pthread_mutex_lock(&mutex);
  if ( dword_68EF4 )
    free((void *)dword_68EF4);
  v1 = dword_733CC;
  if ( dword_733CC > 0 )
  {
    v2 = 0;
    do
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
      {
        snprintf(
          s,
          0x800u,
          "before add pool, pool->pool_no = %d, pool->rpc_url = %s\n",
          **(_DWORD **)(dword_744C8 + 4 * v2),
          *(const char **)(*(_DWORD *)(dword_744C8 + 4 * v2) + 164));
        sub_20F58(5, s, 0);
      }
      ++v2;
    }
    while ( v1 != v2 );
  }
  sub_2D8F0();
  v3 = dword_733CC;
  if ( dword_733CC == v1 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
    {
      strcpy(s, "Input pool error, try again\n");
      sub_20F58(4, s, 0);
    }
  }
  else
  {
    byte_69170 = 0;
    if ( dword_733CC > v1 )
    {
      v4 = 4 * v1;
      v5 = v1;
      do
      {
        v6 = *(_DWORD *)(dword_744C8 + v4);
        if ( *(_DWORD *)(v6 + 100) != 1 )
          sub_2B664((_DWORD *)(v6 + 100));
        v3 = dword_733CC;
        ++v5;
        *(_BYTE *)(v6 + 97) = 1;
        v4 += 4;
      }
      while ( v3 > v5 );
    }
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
    {
      snprintf(s, 0x800u, "total_pools = %d, need to remove %d pools\n", v3, v1);
      sub_20F58(5, s, 0);
    }
    if ( dword_733CC > 0 )
    {
      v7 = 0;
      do
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
        {
          snprintf(
            s,
            0x800u,
            "after add pool, pool->pool_no = %d, pool->rpc_url = %s\n",
            **(_DWORD **)(dword_744C8 + 4 * v7),
            *(const char **)(*(_DWORD *)(dword_744C8 + 4 * v7) + 164));
          sub_20F58(5, s, 0);
        }
        ++v7;
      }
      while ( dword_733CC > v7 );
    }
    if ( v1 > 0 )
    {
      v8 = 0;
      do
      {
        v12 = *(_DWORD *)(dword_744C8 + 4 * v8);
        if ( v12 == sub_31FF4() )
          sub_34178(0);
        v9 = dword_74578;
        v10 = dword_6906C;
        ++v8;
        v11 = dword_69068;
        *(_DWORD *)(v12 + 100) = 0;
        dword_74578 = v9 - 1;
        dword_6906C = v10 - 1;
        dword_69068 = v11 - 1;
        --dword_69074;
        sub_2D0D8(v12);
      }
      while ( v1 != v8 );
    }
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
    {
      snprintf(s, 0x800u, "total_pools after removed = %d\n", dword_733CC);
      sub_20F58(5, s, 0);
    }
    if ( dword_733CC > 0 )
    {
      v13 = 0;
      do
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
        {
          snprintf(
            s,
            0x800u,
            "after remove pool, pool->pool_no = %d, pool->rpc_url = %s\n",
            **(_DWORD **)(dword_744C8 + 4 * v13),
            *(const char **)(*(_DWORD *)(dword_744C8 + 4 * v13) + 164));
          sub_20F58(5, s, 0);
        }
        ++v13;
      }
      while ( dword_733CC > v13 );
    }
    v14 = 180;
    sub_2B41C();
    do
    {
      sleep(1u);
      if ( byte_69170 )
      {
        dword_69178 = 1;
        goto LABEL_47;
      }
      --v14;
    }
    while ( v14 );
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      strcpy(s, "error pool input");
      sub_20F58(3, s, 0);
    }
    if ( dword_733CC > 0 )
    {
      v17 = 0;
      do
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
        {
          snprintf(
            s,
            0x800u,
            "pool%d, url = %s, user = %s, pass = %s\n",
            **(_DWORD **)(dword_744C8 + 4 * v17),
            *(const char **)(*(_DWORD *)(dword_744C8 + 4 * v17) + 164),
            *(const char **)(*(_DWORD *)(dword_744C8 + 4 * v17) + 172),
            *(const char **)(*(_DWORD *)(dword_744C8 + 4 * v17) + 176));
          sub_20F58(3, s, 0);
        }
        ++v17;
      }
      while ( dword_733CC > v17 );
    }
  }
LABEL_47:
  pthread_mutex_unlock(&mutex);
  v15 = dword_75598 + (dword_69058 << 6);
  if ( sub_25164(v15, 0, (void *(*)(void *))sub_34DF4, 0) )
  {
    strcpy(s, "watchpool thread create failed");
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 0);
  }
  pthread_detach(*(_DWORD *)(v15 + 12));
  sleep(1u);
  newthread = 0;
  return 0;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68EF4: using guessed type int dword_68EF4;
// 69058: using guessed type int dword_69058;
// 69068: using guessed type int dword_69068;
// 6906C: using guessed type int dword_6906C;
// 69074: using guessed type int dword_69074;
// 69170: using guessed type char byte_69170;
// 69178: using guessed type int dword_69178;
// 733CC: using guessed type int dword_733CC;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;
// 74578: using guessed type int dword_74578;
// 75598: using guessed type int dword_75598;

//----- (00034DF4) --------------------------------------------------------
void __noreturn sub_34DF4()
{
  int v0; // r11
  int v1; // r5
  _DWORD *v2; // r4
  __int64 v3; // r6
  double v4; // r0
  double v5; // d7
  double v6; // d6
  int v7; // r6
  int *v8; // r12
  int v9; // r7
  bool v10; // zf
  int *v11; // r12
  int v12; // r7
  int v13; // lr
  int v14; // r5
  int v15; // r1
  _DWORD *v16; // r3
  int v17; // r6
  int v18; // r7
  int v19; // r0
  int **v20; // r2
  int v21; // r12
  int v22; // r3
  int v23; // r3
  int v24; // r3
  int v25; // r1
  int v26; // r1
  int v27; // r3
  int v28; // r3
  __int64 v29; // r2
  int v30; // r6
  char *v31; // r1
  int v32; // r1
  int *v33; // r0
  int *v34; // r0
  int *v35; // r0
  const char *v36; // r12
  int v37; // r1
  int v38; // [sp+14h] [bp-838h]
  int v39; // [sp+14h] [bp-838h]
  pthread_mutex_t *mutex; // [sp+18h] [bp-834h]
  pthread_mutex_t *mutexa; // [sp+18h] [bp-834h]
  void **v42; // [sp+28h] [bp-824h]
  struct timespec tp; // [sp+30h] [bp-81Ch] BYREF
  struct timeval v44; // [sp+38h] [bp-814h] BYREF
  struct timeval v45; // [sp+40h] [bp-80Ch] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  pthread_setcanceltype(1, 0);
  sub_250A8("Watchpool");
  sub_2C148();
  v0 = 0;
  sub_23A18(&tp);
  while ( 1 )
  {
    if ( ++v0 >= 121 )
      v0 = 0;
    sub_239A4(&v44);
    if ( dword_733CC > 0 )
      break;
LABEL_19:
    if ( *(_BYTE *)(sub_31FF4() + 97) )
      sub_34178(0);
    if ( dword_68FD0 == 2 && v44.tv_sec - dword_69180 > 60 * dword_73464 )
    {
      sub_239A4((struct timeval *)&dword_69180);
      sub_34178(0);
    }
    sub_23A24(&tp.tv_sec);
    sub_23A18(&tp);
  }
  v1 = 0;
  while ( 1 )
  {
    v2 = *(_DWORD **)(dword_744C8 + 4 * v1);
    if ( !byte_6917C && !dword_766C0 )
      break;
LABEL_13:
    if ( v0 == 120 )
    {
      v3 = *((_QWORD *)v2 + 5);
      LODWORD(v4) = sub_4A11C(v3 - (int)v2[38]);
      v5 = *((double *)v2 + 18);
      v2[38] = v3;
      v6 = (v5 + v4 * 0.63) / 1.63;
      *((double *)v2 + 18) = v6;
      v2[39] = (int)v6;
    }
    if ( v2[25] && !*((_BYTE *)v2 + 284) )
    {
      if ( sub_2F1E8(v2, 1) )
      {
        if ( sub_2F180((int)v2, (_BYTE *)v2 + 97) )
          sub_32238(v2);
      }
      else
      {
        sub_239A4((struct timeval *)v2 + 17);
      }
      if ( !*((_BYTE *)v2 + 97) && !dword_68FD0 )
      {
        v7 = v2[1];
        if ( v7 < sub_3218C() && v44.tv_sec - v2[34] > dword_68750 )
        {
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
          {
            snprintf(s, 0x800u, "Pool %d %s stable for >%d seconds", *v2, (const char *)v2[41], dword_68750);
            sub_20F58(4, s, 0);
          }
          sub_34178(0);
        }
      }
    }
    if ( dword_733CC <= ++v1 )
      goto LABEL_19;
  }
  mutex = (pthread_mutex_t *)(v2 + 47);
  sub_239A4(&v45);
  if ( pthread_mutex_lock((pthread_mutex_t *)(v2 + 47)) )
  {
    v33 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v33, "cgminer.c", "reap_curl", 10158);
    goto LABEL_90;
  }
  v8 = (int *)v2[86];
  v9 = *v8;
  v10 = v2 + 86 == v8;
  v11 = v8 - 1;
  v12 = v9 - 4;
  if ( v10 )
  {
    if ( pthread_mutex_unlock(mutex) )
      goto LABEL_96;
    off_67ED8();
  }
  else
  {
    v13 = v2[72];
    if ( v13 > 1 )
    {
      v38 = v1;
      v14 = 0;
      while ( 1 )
      {
        if ( v45.tv_sec - v11[3] > 300 )
        {
          v2[72] = v13 - 1;
          ++v14;
          v15 = v11[1];
          v16 = (_DWORD *)v11[2];
          *(_DWORD *)(v15 + 4) = v16;
          *v16 = v15;
          free(v11);
        }
        if ( v2 + 86 == (_DWORD *)(v12 + 4) )
          break;
        v13 = v2[72];
        v11 = (int *)v12;
        if ( v13 <= 1 )
        {
          v1 = v38;
          goto LABEL_41;
        }
        v12 = *(_DWORD *)(v12 + 4) - 4;
      }
      v30 = v14;
      v1 = v38;
      if ( pthread_mutex_unlock(mutex) )
      {
LABEL_96:
        v35 = _errno_location();
        v36 = "reap_curl";
        v37 = 10176;
LABEL_93:
        snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v35, "cgminer.c", v36, v37);
LABEL_90:
        sub_20F58(3, s, 1);
        sub_2E6B0(1, 1);
      }
      off_67ED8();
      if ( v30 && byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        v31 = "";
        if ( v30 != 1 )
          v31 = "s";
        snprintf(s, 0x800u, "Reaped %d curl%s from pool %d", v30, v31, *v2);
        sub_20F58(7, s, 0);
      }
    }
  }
LABEL_41:
  mutexa = (pthread_mutex_t *)time(0);
  v39 = pthread_mutex_lock(&stru_690F0);
  if ( v39 )
  {
    v34 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v34,
      "cgminer.c",
      "prune_stratum_shares",
      10194);
    goto LABEL_90;
  }
  v17 = dword_69108;
  if ( !dword_69108 )
  {
    if ( pthread_mutex_unlock(&stru_690F0) )
    {
LABEL_92:
      v35 = _errno_location();
      v36 = "prune_stratum_shares";
      v37 = 10207;
      goto LABEL_93;
    }
    off_67ED8();
    goto LABEL_13;
  }
  v18 = *(_DWORD *)(dword_69108 + 8);
  if ( v2 == *(_DWORD **)(*(_DWORD *)(dword_69108 + 36) + 260) )
    goto LABEL_46;
LABEL_44:
  if ( !v18 )
  {
LABEL_60:
    if ( pthread_mutex_unlock(&stru_690F0) )
      goto LABEL_92;
    off_67ED8();
    if ( v39 )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
      {
        snprintf(s, 0x800u, "Lost %d shares due to no stratum share response from pool %d", v39, *v2);
        sub_20F58(4, s, 0);
      }
      v29 = *(_QWORD *)&dword_73318;
      v2[30] += v39;
      *(_QWORD *)&dword_73318 = v29 + v39;
    }
    goto LABEL_13;
  }
  while ( 1 )
  {
    v17 = v18;
    v18 = *(_DWORD *)(v18 + 8);
    if ( v2 != *(_DWORD **)(*(_DWORD *)(v17 + 36) + 260) )
      goto LABEL_44;
LABEL_46:
    if ( (int)mutexa <= *(_DWORD *)(v17 + 44) + 120 )
      goto LABEL_44;
    v19 = *(_DWORD *)(v17 + 4);
    v20 = (int **)dword_69108;
    v21 = *(_DWORD *)dword_69108;
    if ( v19 )
      break;
    v32 = *(_DWORD *)(v17 + 8);
    if ( v32 )
    {
      v22 = *(_DWORD *)(v21 + 20);
      if ( v17 != *(_DWORD *)(v21 + 16) - v22 )
        goto LABEL_81;
LABEL_82:
      *(_DWORD *)(v21 + 16) = v19 + v22;
      v19 = *(_DWORD *)(v17 + 4);
      if ( !v19 )
      {
        v32 = *(_DWORD *)(v17 + 8);
LABEL_81:
        v20 = (int **)v32;
        dword_69108 = v32;
LABEL_50:
        v23 = *(_DWORD *)(v17 + 8);
        if ( v23 )
          *(_DWORD *)(v23 + (*v20)[5] + 4) = *(_DWORD *)(v17 + 4);
        v24 = 3 * (((*v20)[1] - 1) & *(_DWORD *)(v17 + 28));
        v25 = **v20 + 12 * (((*v20)[1] - 1) & *(_DWORD *)(v17 + 28));
        --*(_DWORD *)(v25 + 4);
        v26 = **v20;
        if ( *(_DWORD *)(v26 + 4 * v24) == v17 )
          *(_DWORD *)(v26 + 4 * v24) = *(_DWORD *)(v17 + 16);
        v27 = *(_DWORD *)(v17 + 12);
        if ( v27 )
          *(_DWORD *)(v27 + 16) = *(_DWORD *)(v17 + 16);
        v28 = *(_DWORD *)(v17 + 16);
        if ( v28 )
          *(_DWORD *)(v28 + 12) = *(_DWORD *)(v17 + 12);
        --(*v20)[3];
        goto LABEL_59;
      }
      v22 = (*v20)[5];
LABEL_49:
      *(_DWORD *)(v19 + v22 + 8) = *(_DWORD *)(v17 + 8);
      goto LABEL_50;
    }
    v42 = (void **)dword_69108;
    free(*(void **)v21);
    free(*v42);
    dword_69108 = 0;
LABEL_59:
    ++v39;
    sub_2CBA8((void ***)(v17 + 36), "cgminer.c", "prune_stratum_shares", 10201);
    free((void *)v17);
    if ( !v18 )
      goto LABEL_60;
  }
  v22 = *(_DWORD *)(v21 + 20);
  if ( v17 == *(_DWORD *)(v21 + 16) - v22 )
    goto LABEL_82;
  goto LABEL_49;
}
// 34F34: variable 'v4' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68750: using guessed type int dword_68750;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 68FD0: using guessed type int dword_68FD0;
// 69108: using guessed type int dword_69108;
// 6917C: using guessed type char byte_6917C;
// 69180: using guessed type int dword_69180;
// 73318: using guessed type int dword_73318;
// 733CC: using guessed type int dword_733CC;
// 73464: using guessed type int dword_73464;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;
// 766C0: using guessed type int dword_766C0;

//----- (000355FC) --------------------------------------------------------
int __fastcall sub_355FC(int a1)
{
  int v2; // r2
  int v3; // r1
  int v4; // r3
  int v5; // r12
  int v6; // r0
  int v7; // r1
  int v8; // r6
  _DWORD *v9; // r2
  int v10; // r3
  int v11; // r2
  int v12; // r12
  int v13; // r2
  int v14; // r3
  int v16; // r0
  int *v17; // r0
  int *v18; // r0
  struct timespec abstime; // [sp+10h] [bp-810h] BYREF
  struct timeval v20; // [sp+18h] [bp-808h] BYREF
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_69010) )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "hash_pop", 8182);
    goto LABEL_58;
  }
  if ( !dword_690EC || !*(_DWORD *)(*(_DWORD *)(dword_690EC + 344) + 12) )
  {
    if ( !a1 )
      goto LABEL_35;
    do
    {
      sub_239A4(&v20);
      abstime.tv_sec = v20.tv_sec + 10;
      abstime.tv_nsec = 1000 * v20.tv_usec;
      pthread_cond_signal(&stru_744D0);
      if ( pthread_cond_timedwait((pthread_cond_t *)(dword_755E0 + 40), (pthread_mutex_t *)dword_69010, &abstime) )
      {
        if ( !byte_69064 )
        {
          byte_69064 = 1;
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
          {
            strcpy(s, "Waiting for work to be available from pools.");
            sub_20F58(4, s, 0);
          }
        }
      }
    }
    while ( !dword_690EC || !*(_DWORD *)(*(_DWORD *)(dword_690EC + 344) + 12) );
  }
  if ( byte_69064 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
    {
      strcpy(s, "Work available from pools, resuming.");
      sub_20F58(4, s, 0);
    }
    v2 = dword_690EC;
    byte_69064 = 0;
    if ( !dword_690EC )
      goto LABEL_43;
  }
  else
  {
    v2 = dword_690EC;
  }
  v3 = *(_DWORD *)(v2 + 344);
  if ( *(_DWORD *)(v3 + 12) <= dword_69188 || *(_BYTE *)(v2 + 273) || !*(_DWORD *)(v2 + 276) )
  {
    a1 = v2;
    goto LABEL_17;
  }
  a1 = *(_DWORD *)(v2 + 352);
  if ( !a1 )
LABEL_43:
    __und(0);
  while ( !*(_BYTE *)(a1 + 273) )
  {
    v16 = *(_DWORD *)(a1 + 352);
    if ( !*(_DWORD *)(a1 + 276) )
      break;
    a1 = *(_DWORD *)(a1 + 352);
    if ( !v16 )
      goto LABEL_43;
  }
LABEL_17:
  v4 = *(_DWORD *)(a1 + 348);
  if ( v4 )
  {
    v5 = *(_DWORD *)(v3 + 20);
    v6 = a1 + 344;
    if ( a1 != *(_DWORD *)(v3 + 16) - v5 )
    {
LABEL_19:
      v7 = dword_690EC;
      *(_DWORD *)(v4 + v5 + 8) = *(_DWORD *)(a1 + 352);
      v8 = *(_DWORD *)(a1 + 352);
LABEL_20:
      v9 = *(_DWORD **)(v7 + 344);
      if ( v8 )
      {
        *(_DWORD *)(v8 + v9[5] + 4) = *(_DWORD *)(a1 + 348);
        v9 = *(_DWORD **)(v7 + 344);
      }
      v10 = 12 * ((v9[1] - 1) & *(_DWORD *)(a1 + 372));
      --*(_DWORD *)(*v9 + v10 + 4);
      v11 = **(_DWORD **)(v7 + 344);
      v12 = *(_DWORD *)(v11 + v10);
      if ( v12 == v6 )
      {
        v7 = *(_DWORD *)(a1 + 360);
        *(_DWORD *)(v11 + v10) = v7;
      }
      v13 = *(_DWORD *)(a1 + 356);
      v14 = *(_DWORD *)(a1 + 360);
      if ( v12 == v6 )
        v7 = dword_690EC;
      if ( v13 )
      {
        *(_DWORD *)(v13 + 16) = v14;
        v14 = *(_DWORD *)(a1 + 360);
      }
      if ( v14 )
        *(_DWORD *)(v14 + 12) = *(_DWORD *)(a1 + 356);
      --*(_DWORD *)(*(_DWORD *)(v7 + 344) + 12);
      goto LABEL_31;
    }
LABEL_47:
    *(_DWORD *)(v3 + 16) = v4 + v5;
    v4 = *(_DWORD *)(a1 + 348);
    if ( v4 )
    {
      v5 = *(_DWORD *)(*(_DWORD *)(v2 + 344) + 20);
      goto LABEL_19;
    }
    v8 = *(_DWORD *)(a1 + 352);
LABEL_46:
    v7 = v8;
    dword_690EC = v8;
    goto LABEL_20;
  }
  v8 = *(_DWORD *)(a1 + 352);
  if ( v8 )
  {
    v5 = *(_DWORD *)(v3 + 20);
    v6 = a1 + 344;
    if ( a1 != *(_DWORD *)(v3 + 16) - v5 )
      goto LABEL_46;
    goto LABEL_47;
  }
  free(*(void **)v3);
  free(*(void **)(dword_690EC + 344));
  dword_690EC = 0;
LABEL_31:
  if ( !*(_BYTE *)(a1 + 273) && *(_DWORD *)(a1 + 276) )
    --dword_69188;
  pthread_cond_signal(&stru_744D0);
  pthread_cond_signal((pthread_cond_t *)(dword_755E0 + 40));
  dword_744A0 = time(0);
LABEL_35:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_69010) )
  {
    v18 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v18, "cgminer.c", "hash_pop", 8254);
LABEL_58:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  off_67ED8();
  return a1;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 69010: using guessed type int dword_69010;
// 69064: using guessed type char byte_69064;
// 690EC: using guessed type int dword_690EC;
// 69188: using guessed type int dword_69188;
// 744A0: using guessed type int dword_744A0;
// 744D0: using guessed type pthread_cond_t stru_744D0;
// 74500: using guessed type char byte_74500;
// 755E0: using guessed type int dword_755E0;

//----- (00035A94) --------------------------------------------------------
void __fastcall sub_35A94(const char *a1, _DWORD *a2)
{
  int v4; // r10
  int v5; // r11
  char *v6; // r9
  char *v7; // r8
  char *v8; // r7
  signed int v9; // r4
  size_t v10; // r4
  const char *v11; // r12
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  _DWORD *v16; // r12
  int v17; // r1
  int *v18; // r0
  int v19; // r3
  int v20; // [sp+20h] [bp-C0Ch]
  int v21; // [sp+24h] [bp-C08h]
  char s[1024]; // [sp+28h] [bp-C04h] BYREF
  _DWORD v23[5]; // [sp+428h] [bp-804h] BYREF
  __int16 v24; // [sp+43Ch] [bp-7F0h]

  if ( !dword_68DEC )
    return;
  v21 = a2[64];
  v4 = *(_DWORD *)(sub_31B04(v21) + 36);
  v5 = a2[65];
  v20 = a2[108];
  v6 = sub_22C24((int)(a2 + 40), 32);
  v7 = sub_22C24((int)(a2 + 48), 32);
  v8 = sub_22C24((int)a2, 128);
  v9 = snprintf(
         s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         v20,
         a1,
         v6,
         *(const char **)(v5 + 164),
         *(const char **)(*(_DWORD *)(v4 + 4) + 8),
         *(_DWORD *)(v4 + 8),
         v21,
         v7,
         v8);
  free(v6);
  free(v7);
  free(v8);
  if ( v9 >= 1024 )
  {
    s[1023] = 0;
    goto LABEL_5;
  }
  if ( v9 >= 0 )
  {
LABEL_5:
    if ( pthread_mutex_lock(&stru_6918C) )
    {
      v18 = _errno_location();
      snprintf(
        (char *)v23,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v18,
        "cgminer.c",
        "sharelog",
        677);
    }
    else
    {
      v10 = fwrite(s, v9, 1u, (FILE *)dword_68DEC);
      fflush((FILE *)dword_68DEC);
      if ( !pthread_mutex_unlock(&stru_6918C) )
      {
        off_67ED8();
        if ( v10 != 1 && (byte_74500 || byte_68BD4 || dword_67DB4 > 2) )
        {
          v11 = "sharelog fwrite error";
LABEL_12:
          v12 = *(_DWORD *)v11;
          v13 = *((_DWORD *)v11 + 1);
          v14 = *((_DWORD *)v11 + 2);
          v15 = *((_DWORD *)v11 + 3);
          v16 = v11 + 16;
          v23[0] = v12;
          v23[1] = v13;
          v23[2] = v14;
          v23[3] = v15;
          v17 = v16[1];
          v23[4] = *v16;
          v24 = v17;
          sub_20F58(3, (const char *)v23, 0);
          return;
        }
        return;
      }
      v19 = *_errno_location();
      snprintf(
        (char *)v23,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        v19,
        "cgminer.c",
        "sharelog",
        680);
    }
    sub_20F58(3, (const char *)v23, 1);
    sub_2E6B0(1, 1);
  }
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    v11 = "sharelog printf error";
    goto LABEL_12;
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68DEC: using guessed type int dword_68DEC;
// 74500: using guessed type char byte_74500;

//----- (00035D3C) --------------------------------------------------------
int __fastcall sub_35D3C(_DWORD *a1)
{
  int v2; // r5
  pthread_t v4; // r0
  int v5; // r5
  int *v6; // r0
  int *v7; // r0
  int *v8; // r0
  int *v9; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( !*((_BYTE *)a1 + 107) )
  {
    v4 = pthread_self();
    pthread_detach(v4);
  }
LABEL_3:
  v2 = *((unsigned __int8 *)a1 + 105);
  if ( !*((_BYTE *)a1 + 105) )
  {
    while ( !sub_2F1E8(a1, v2) )
    {
      sub_3466C((int)a1);
      if ( *((_BYTE *)a1 + 107) )
        goto LABEL_23;
      sleep(0x1Eu);
      if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 4 )
        goto LABEL_3;
      snprintf(s, 0x800u, "%s pool[%d] url = %s retry\n", "test_pool_thread", *a1, (const char *)a1[41]);
      sub_20F58(5, s, 0);
      v2 = *((unsigned __int8 *)a1 + 105);
      if ( *((_BYTE *)a1 + 105) )
        goto LABEL_10;
    }
    sub_2F180((int)a1, (_BYTE *)a1 + 97);
    if ( pthread_mutex_lock(&stru_7453C) )
    {
      v6 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v6,
        "cgminer.c",
        "test_pool_thread",
        10771);
    }
    else if ( pthread_rwlock_wrlock(&rwlock) )
    {
      v7 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v7,
        "cgminer.c",
        "test_pool_thread",
        10771);
    }
    else
    {
      if ( !byte_69170 )
      {
        v5 = *a1;
        dword_69060 = (int)a1;
        byte_69170 = 1;
        v2 = v5 != 0;
      }
      if ( pthread_rwlock_unlock(&rwlock) )
      {
        v8 = _errno_location();
        snprintf(
          s,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v8,
          "cgminer.c",
          "test_pool_thread",
          10785);
      }
      else
      {
        if ( !pthread_mutex_unlock(&stru_7453C) )
        {
          off_67ED8();
          if ( v2 && (byte_74500 || byte_68BD4 || dword_67DB4 > 4) )
          {
            snprintf(s, 0x800u, "Switching to pool %d %s - first alive pool", *a1, (const char *)a1[41]);
            sub_20F58(5, s, 0);
          }
          sub_32238(a1);
          sub_34178(0);
LABEL_23:
          *((_BYTE *)a1 + 284) = 0;
          goto LABEL_10;
        }
        v9 = _errno_location();
        snprintf(
          s,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v9,
          "cgminer.c",
          "test_pool_thread",
          10785);
      }
    }
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
LABEL_10:
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    snprintf(s, 0x800u, "end test_pool_thread pool[%d]\n", *a1);
    sub_20F58(5, s, 0);
  }
  return 0;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 69060: using guessed type int dword_69060;
// 69170: using guessed type char byte_69170;
// 74500: using guessed type char byte_74500;
// 7453C: using guessed type pthread_mutex_t stru_7453C;

//----- (000360B0) --------------------------------------------------------
int __fastcall sub_360B0(int a1, int a2)
{
  pthread_mutex_t *v2; // r8
  size_t v5; // r11
  int v6; // lr
  int v7; // r0
  int v8; // r3
  int v9; // r2
  int v10; // r5
  const void *v11; // r1
  int *v12; // r2
  char *v13; // r0
  unsigned int v14; // t1
  int v15; // r0
  char *v17; // r9
  const char *v18; // r0
  char *v19; // r8
  int *v20; // r0
  int *v21; // r0
  int *v22; // r0
  int *v23; // r0
  int *v24; // r0
  int *v25; // r0
  __int64 v26; // [sp+18h] [bp-86Ch] BYREF
  _BYTE v27[28]; // [sp+20h] [bp-864h] BYREF
  char v28; // [sp+3Ch] [bp-848h] BYREF
  char v29[28]; // [sp+40h] [bp-844h] BYREF
  int v30; // [sp+5Ch] [bp-828h] BYREF
  _BYTE v31[32]; // [sp+60h] [bp-824h] BYREF
  char s[2052]; // [sp+80h] [bp-804h] BYREF

  v2 = (pthread_mutex_t *)(a1 + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
  {
    v20 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v20, "cgminer.c", "gen_stratum_work", 8360);
    goto LABEL_29;
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v21 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v21, "cgminer.c", "gen_stratum_work", 8360);
    goto LABEL_29;
  }
  v5 = *(_DWORD *)(a1 + 632);
  v6 = *(_DWORD *)(a1 + 1568);
  v7 = *(_DWORD *)(a1 + 1576);
  v26 = *(_QWORD *)(a1 + 624);
  sub_254E8((void *)(v6 + v7), &v26, v5, (int)"cgminer.c", (int)"gen_stratum_work", 8365);
  v8 = *(_DWORD *)(a1 + 624);
  v9 = *(_DWORD *)(a1 + 628);
  ++*(_QWORD *)(a1 + 624);
  *(_DWORD *)(a2 + 296) = v8;
  *(_DWORD *)(a2 + 300) = v9;
  *(_DWORD *)(a2 + 304) = *(_DWORD *)(a1 + 632);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v22 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v22,
      "cgminer.c",
      "gen_stratum_work",
      8371);
    goto LABEL_29;
  }
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v23 = _errno_location();
    snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v23, "cgminer.c", "gen_stratum_work", 8371);
    goto LABEL_29;
  }
  v10 = pthread_mutex_unlock(v2);
  if ( v10 )
  {
    v24 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v24,
      "cgminer.c",
      "gen_stratum_work",
      8371);
    goto LABEL_29;
  }
  sub_21C34(*(char **)(a1 + 1568), *(_DWORD *)(a1 + 1572), s);
  sub_21C34(s, 0x20u, v27);
  sub_254E8(v29, v27, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8375);
  if ( *(int *)(a1 + 1708) > 0 )
  {
    do
    {
      v11 = *(const void **)(*(_DWORD *)(a1 + 676) + 4 * v10++);
      sub_254E8(v31, v11, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8379);
      sub_21C34(v29, 0x40u, s);
      sub_21C34(s, 0x20u, v27);
      sub_254E8(v29, v27, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8381);
    }
    while ( *(_DWORD *)(a1 + 1708) > v10 );
  }
  v12 = (int *)&v28;
  v13 = (char *)&v26 + 4;
  do
  {
    v14 = v12[1];
    ++v12;
    *((_DWORD *)v13 + 1) = bswap32(v14);
    v13 += 4;
  }
  while ( &v30 != v12 );
  sub_254E8((void *)a2, (const void *)(a1 + 1580), 0x70u, (int)"cgminer.c", (int)"gen_stratum_work", 8390);
  sub_254E8((void *)(a2 + 36), v27, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8391);
  *(_QWORD *)(a2 + 312) = *(_QWORD *)(a1 + 1824);
  *(_DWORD *)(a2 + 288) = _strdup(*(const char **)(a1 + 672));
  *(_DWORD *)(a2 + 320) = _strdup(*(const char **)(a1 + 612));
  *(_DWORD *)(a2 + 308) = _strdup((const char *)(a1 + 1804));
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v25 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v25,
      "cgminer.c",
      "gen_stratum_work",
      8402);
LABEL_29:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  off_67ED8();
  if ( !byte_68BD5 )
    goto LABEL_12;
  v17 = sub_22C24(a2, 112);
  v18 = sub_22C24((int)v27, 32);
  v19 = (char *)v18;
  if ( byte_68BD5 )
  {
    if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 6 )
      goto LABEL_21;
    snprintf(s, 0x800u, "Generated stratum merkle %s", v18);
    sub_20F58(7, s, 0);
    if ( !byte_68BD5 )
      goto LABEL_27;
    if ( !byte_74500 )
    {
LABEL_21:
      if ( !byte_68BD4 && dword_67DB4 <= 6 )
        goto LABEL_24;
    }
    snprintf(s, 0x800u, "Generated stratum header %s", v17);
    sub_20F58(7, s, 0);
    if ( byte_68BD5 )
    {
      if ( byte_74500 )
      {
LABEL_26:
        snprintf(
          s,
          0x800u,
          "Work job_id %s nonce2 %llu ntime %s",
          *(const char **)(a2 + 288),
          *(_QWORD *)(a2 + 296),
          *(const char **)(a2 + 308));
        sub_20F58(7, s, 0);
        goto LABEL_27;
      }
LABEL_24:
      if ( !byte_68BD4 && dword_67DB4 <= 6 )
        goto LABEL_27;
      goto LABEL_26;
    }
  }
LABEL_27:
  free(v17);
  free(v19);
LABEL_12:
  sub_2B3A4(a2);
  sub_2D950((void *)(a2 + 160));
  ++dword_767E0;
  if ( time(0) - dword_691A4 > 5 )
  {
    dword_691A4 = time(0);
    dword_691A8 = dword_767E0;
  }
  v15 = dword_691AC;
  *(_BYTE *)(a2 + 284) = 1;
  *(_DWORD *)(a2 + 336) = v15;
  *(_DWORD *)(a2 + 248) = 0;
  *(_BYTE *)(a2 + 280) = 0;
  *(_BYTE *)(a2 + 440) = 83;
  *(_DWORD *)(a2 + 244) = 60;
  *(_DWORD *)(a2 + 260) = a1;
  sub_2B1B0(a2);
  return sub_239A4((struct timeval *)(a2 + 264));
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 691A4: using guessed type int dword_691A4;
// 691A8: using guessed type int dword_691A8;
// 691AC: using guessed type int dword_691AC;
// 74500: using guessed type char byte_74500;
// 767E0: using guessed type int dword_767E0;

//----- (00036690) --------------------------------------------------------
int __fastcall sub_36690(int *a1, int *a2, int a3, int a4, __int64 a5, unsigned int a6)
{
  pthread_mutex_t *v8; // r6
  unsigned int v11; // r2
  int v12; // r2
  unsigned int v14; // r1
  int v15; // [sp+Ch] [bp-8h]

  v8 = (pthread_mutex_t *)(a3 + 212);
  *a2 = (int)sub_2FD8C();
  v15 = *a1;
  if ( pthread_mutex_lock(v8) )
    sub_2EFE0("get_work_by_nonce2", 8330);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a3 + 236)) )
    sub_2EF84("get_work_by_nonce2", 8330);
  v11 = bswap32(a6);
  *(_QWORD *)(a3 + 624) = a5;
  a6 = v11;
  sub_254E8((void *)(a3 + 1580), &a6, 4u, (int)"cgminer.c", (int)"get_work_by_nonce2", 8333);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a3 + 236)) )
    sub_2FB24("get_work_by_nonce2", 8334);
  if ( pthread_mutex_unlock(v8) )
    sub_2F03C("get_work_by_nonce2", 8334);
  off_67ED8();
  sub_360B0(a3, *a2);
  v12 = dword_691AC;
  *(_DWORD *)(*a2 + 260) = a4;
  v14 = a6;
  *(_DWORD *)(*a2 + 256) = v15;
  *(_DWORD *)(*a2 + 336) = v12;
  ++*(_DWORD *)(*(_DWORD *)(*a2 + 260) + 68);
  *(_BYTE *)(*a2 + 272) = 1;
  *(_DWORD *)(*a2 + 444) = v14;
  return 1;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 691AC: using guessed type int dword_691AC;

//----- (000367EC) --------------------------------------------------------
int __fastcall sub_367EC(int a1, int a2)
{
  int v2; // r5
  int v6; // r8
  int v7; // r9
  int v8; // r8
  const char *v9; // lr
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // lr
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r1
  int v20; // r2
  int *v21; // r0
  int *v22; // r0
  struct timeval v23; // [sp+10h] [bp-80Ch] BYREF
  _DWORD s[10]; // [sp+18h] [bp-804h] BYREF
  __int16 v25; // [sp+40h] [bp-7DCh]

  v2 = (unsigned __int8)byte_6917C;
  if ( !byte_6917C )
  {
    if ( dword_766C0 )
      return v2;
    if ( *(_DWORD *)(a1 + 336) != dword_691AC )
    {
      v2 = (unsigned __int8)byte_68BD5;
      if ( byte_68BD5 )
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
        {
          strcpy((char *)s, "Work stale due to block mismatch");
          sub_20F58(7, (const char *)s, 0);
        }
        return v2;
      }
      return 1;
    }
    v6 = *(_DWORD *)(a1 + 276);
    v7 = *(_DWORD *)(a1 + 260);
    if ( v6 <= dword_68754 )
      v6 = dword_68758;
    if ( !a2 && *(_BYTE *)(v7 + 640) )
    {
      if ( !*(_BYTE *)(v7 + 641) || !*(_BYTE *)(v7 + 643) )
      {
        v2 = (unsigned __int8)byte_68BD5;
        if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
        {
          strcpy((char *)s, "Work stale due to stratum inactive");
          sub_20F58(7, (const char *)s, 0);
          return v2;
        }
        return 1;
      }
      if ( pthread_mutex_lock((pthread_mutex_t *)(v7 + 212)) )
        sub_2EFE0("stale_work", 5089);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v7 + 236)) )
        sub_30138("stale_work", 5089);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(v7 + 212)) )
      {
        v22 = _errno_location();
        snprintf(
          (char *)s,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v22,
          "cgminer.c",
          "stale_work",
          5089);
LABEL_56:
        sub_20F58(3, (const char *)s, 1);
        sub_2E6B0(1, 1);
      }
      if ( strcmp(*(const char **)(a1 + 288), *(const char **)(v7 + 672)) )
      {
        if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
        {
          off_67ED8();
          v2 = (unsigned __int8)byte_68BD5;
          if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
          {
            v9 = "Work stale due to stratum job_id mismatch";
            goto LABEL_42;
          }
          return 1;
        }
        goto LABEL_55;
      }
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
      {
LABEL_55:
        v21 = _errno_location();
        snprintf(
          (char *)s,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v21,
          "cgminer.c",
          "stale_work",
          5096);
        goto LABEL_56;
      }
      off_67ED8();
    }
    v8 = v6 - (int)(*(double *)(v7 + 448) * 5.0 + 1.0);
    sub_239A4(&v23);
    if ( v8 < 5 )
      v8 = 5;
    if ( v8 <= v23.tv_sec - *(_DWORD *)(a1 + 264) )
    {
      v2 = (unsigned __int8)byte_68BD5;
      if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
      {
        strcpy((char *)s, "Work stale due to expiry");
        sub_20F58(7, (const char *)s, 0);
        return v2;
      }
      return 1;
    }
    if ( a2 | (unsigned __int8)byte_755D4 ^ 1
      || v7 == sub_31FF4()
      || *(_BYTE *)(a1 + 282)
      || (unsigned int)(dword_68FD0 - 3) <= 1 )
    {
      return v2;
    }
    v2 = (unsigned __int8)byte_68BD5;
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      v9 = "Work stale due to fail only pool mismatch";
LABEL_42:
      v10 = *(_DWORD *)v9;
      v11 = *((_DWORD *)v9 + 1);
      v12 = *((_DWORD *)v9 + 2);
      v13 = *((_DWORD *)v9 + 3);
      v14 = (int *)(v9 + 16);
      s[0] = v10;
      s[1] = v11;
      s[2] = v12;
      s[3] = v13;
      v15 = *v14;
      v16 = v14[1];
      v17 = v14[2];
      v18 = v14[3];
      v14 += 4;
      s[4] = v15;
      s[5] = v16;
      s[6] = v17;
      s[7] = v18;
      v19 = v14[1];
      v20 = v14[2];
      s[8] = *v14;
      s[9] = v19;
      v25 = v20;
      sub_20F58(7, (const char *)s, 0);
      return v2;
    }
    return 1;
  }
  return 0;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68754: using guessed type int dword_68754;
// 68758: using guessed type int dword_68758;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 68FD0: using guessed type int dword_68FD0;
// 6917C: using guessed type char byte_6917C;
// 691AC: using guessed type int dword_691AC;
// 74500: using guessed type char byte_74500;
// 755D4: using guessed type char byte_755D4;
// 766C0: using guessed type int dword_766C0;

//----- (00036CD4) --------------------------------------------------------
void **__fastcall sub_36CD4(int a1, void *a2)
{
  _DWORD *v4; // r5
  time_t v5; // r9
  int v6; // r9
  int v7; // r3
  void **v8; // r0
  int v9; // r3
  void **v10; // r3
  void **result; // r0
  double v12; // d7
  int v13; // r2
  int v14; // r3
  int v15; // r3
  int v16; // r2
  char *v17; // r1
  int v18; // r3
  bool v19; // cc
  void **v20; // [sp+Ch] [bp-804h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v20 = 0;
  v4 = *(_DWORD **)(a1 + 36);
  sub_2AE8C(a1);
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    strcpy(s, "Popping work from get queue to get work");
    sub_20F58(7, s, 0);
  }
  v5 = time(0);
  while ( !v20 )
  {
    v20 = (void **)sub_355FC(1);
    if ( sub_367EC((int)v20, 0) )
    {
      sub_2CEA0(&v20, "cgminer.c", "get_work", 8644);
      sub_2F9C0();
    }
  }
  v6 = time(0) - v5;
  v7 = (unsigned __int8)byte_68BD5;
  if ( v6 <= 0 )
  {
LABEL_16:
    if ( !v7 )
      goto LABEL_20;
    goto LABEL_17;
  }
  if ( !byte_68BD5 )
  {
    v4[58] += v6;
    goto LABEL_20;
  }
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
  {
    snprintf(s, 0x800u, "Get work blocked for %ld seconds", v6);
    sub_20F58(7, s, 0);
    v7 = (unsigned __int8)byte_68BD5;
    v4[58] += v6;
    goto LABEL_16;
  }
  v4[58] += v6;
LABEL_17:
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
  {
    snprintf(s, 0x800u, "Got work from get queue to get work for thread %d", a2);
    sub_20F58(7, s, 0);
  }
LABEL_20:
  v8 = v20;
  v9 = (unsigned __int8)byte_6917C;
  v20[64] = a2;
  if ( !v9 )
    goto LABEL_21;
  v14 = v4[95] + v4[96];
  v4[95] = v14;
  if ( v14 <= 0 )
  {
    v4[96] = 1;
LABEL_40:
    sub_254E8(v8, (char *)&unk_69BB0 + 160 * v14, 0xA0u, (int)"cgminer.c", (int)"set_benchmark_work", 8625);
    goto LABEL_21;
  }
  if ( v14 <= 15 )
    goto LABEL_40;
  v15 = v4[94];
  v16 = -1;
  v17 = (char *)&unk_691B0;
  v4[96] = -1;
  v18 = v15 + 1;
  v19 = v18 <= 15;
  if ( v18 > 15 )
    v18 = 0;
  else
    v16 = 5 * v18;
  v4[94] = v18;
  if ( v19 )
    v17 = (char *)&unk_691B0 + 32 * v16;
  sub_254E8(v8, v17, 0xA0u, (int)"cgminer.c", (int)"set_benchmark_work", 8621);
LABEL_21:
  sub_2AEC4(a1);
  v10 = v20;
  *((_BYTE *)v20 + 272) = 1;
  result = v10;
  v12 = *(double *)(v4[1] + 104);
  if ( v12 > *((double *)v10 + 47) )
    v12 = *((double *)v10 + 47);
  *((double *)v10 + 28) = v12;
  v13 = v4[1];
  if ( *(double *)(v13 + 112) > v12 )
    v12 = *(double *)(v13 + 112);
  *((double *)v10 + 28) = v12;
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 6917C: using guessed type char byte_6917C;
// 74500: using guessed type char byte_74500;

//----- (00037020) --------------------------------------------------------
void **__fastcall sub_37020(int a1, pthread_rwlock_t *a2, void *a3)
{
  void **v4; // r4

  v4 = sub_36CD4(a1, a3);
  sub_2FE98(a2, (int)v4);
  return v4;
}

//----- (00037048) --------------------------------------------------------
void **__fastcall sub_37048(int a1)
{
  int v1; // r3
  void **v3; // r3
  void **v5; // [sp+4h] [bp-Ch] BYREF

  v1 = *(_DWORD *)(a1 + 356);
  if ( !v1 )
    return 0;
  v5 = *(void ***)(a1 + 356);
  if ( sub_367EC(v1, 0) )
  {
    sub_2CEA0(&v5, "cgminer.c", "__get_queued", 9419);
    sub_2F9C0();
  }
  else
  {
    sub_2E034(a1, (int)v5);
  }
  v3 = v5;
  *(_DWORD *)(a1 + 356) = 0;
  return v3;
}

//----- (000370C8) --------------------------------------------------------
void **__fastcall sub_370C8(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r4
  void **v3; // r5

  v1 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2EF84("get_queued", 9440);
  v3 = sub_37048((int)a1);
  if ( pthread_rwlock_unlock(v1) )
    sub_2FB24("get_queued", 9442);
  off_67ED8();
  return v3;
}
// 67ED8: using guessed type int (*off_67ED8)();

//----- (00037134) --------------------------------------------------------
void sub_37134()
{
  int v0; // r6
  int v1; // r4
  void **v2; // r3
  int v3; // r1
  char *v4; // r9
  int v5; // r0
  int v6; // r2
  void **v7; // r12
  char *v8; // r8
  _DWORD *v9; // r0
  int v10; // r2
  int v11; // r0
  void **v12; // lr
  _DWORD *v13; // r0
  _DWORD *v14; // r2
  int v15; // r0
  int *v16; // r0
  int *v17; // r0
  void **v18; // [sp+14h] [bp-808h] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v0 = pthread_mutex_lock((pthread_mutex_t *)dword_69010);
  if ( v0 )
  {
    v16 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v16, "cgminer.c", "discard_stale", 5379);
    goto LABEL_39;
  }
  v18 = (void **)dword_690EC;
  if ( !dword_690EC )
  {
    pthread_cond_signal(&stru_744D0);
    if ( !pthread_mutex_unlock((pthread_mutex_t *)dword_69010) )
    {
      off_67ED8();
      return;
    }
    goto LABEL_41;
  }
  v1 = *(_DWORD *)(dword_690EC + 352);
  if ( !sub_367EC(dword_690EC, 0) )
    goto LABEL_19;
LABEL_4:
  v2 = v18;
  v3 = dword_690EC;
  v4 = (char *)v18[87];
  v5 = *(_DWORD *)(dword_690EC + 344);
  if ( v4 )
  {
    v6 = *(_DWORD *)(v5 + 20);
    v7 = v18 + 86;
    if ( v18 != (void **)(*(_DWORD *)(v5 + 16) - v6) )
    {
LABEL_6:
      *(_DWORD *)&v4[v6 + 8] = v2[88];
      v8 = (char *)v2[88];
LABEL_7:
      v9 = *(_DWORD **)(v3 + 344);
      if ( v8 )
      {
        *(_DWORD *)&v8[v9[5] + 4] = v2[87];
        v9 = *(_DWORD **)(v3 + 344);
      }
      v10 = 3 * ((v9[1] - 1) & (unsigned int)v2[93]);
      --*(_DWORD *)(*v9 + 4 * v10 + 4);
      v11 = **(_DWORD **)(v3 + 344);
      v12 = *(void ***)(v11 + 4 * v10);
      if ( v12 == v7 )
      {
        v3 = (int)v2[90];
        *(_DWORD *)(v11 + 4 * v10) = v3;
      }
      v13 = v2[89];
      v14 = v2[90];
      if ( v12 == v7 )
        v3 = dword_690EC;
      if ( v13 )
      {
        v13[4] = v14;
        v14 = v2[90];
      }
      if ( v14 )
        v14[3] = v2[89];
      --*(_DWORD *)(*(_DWORD *)(v3 + 344) + 12);
      goto LABEL_18;
    }
LABEL_25:
    *(_DWORD *)(v5 + 16) = &v4[v6];
    v4 = (char *)v2[87];
    if ( v4 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(v3 + 344) + 20);
      goto LABEL_6;
    }
    v8 = (char *)v2[88];
LABEL_24:
    v3 = (int)v8;
    dword_690EC = (int)v8;
    goto LABEL_7;
  }
  v8 = (char *)v18[88];
  if ( v8 )
  {
    v6 = *(_DWORD *)(v5 + 20);
    v7 = v18 + 86;
    if ( v18 != (void **)(*(_DWORD *)(v5 + 16) - v6) )
      goto LABEL_24;
    goto LABEL_25;
  }
  free(*(void **)v5);
  free(*(void **)(dword_690EC + 344));
  dword_690EC = 0;
LABEL_18:
  ++v0;
  sub_2CEA0(&v18, "cgminer.c", "discard_stale", 5386);
LABEL_19:
  while ( 1 )
  {
    v18 = (void **)v1;
    if ( !v1 )
      break;
    v15 = v1;
    v1 = *(_DWORD *)(v1 + 352);
    if ( sub_367EC(v15, 0) )
      goto LABEL_4;
  }
  pthread_cond_signal(&stru_744D0);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_69010) )
  {
LABEL_41:
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "discard_stale", 5392);
LABEL_39:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  off_67ED8();
  if ( v0 && byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf(s, 0x800u, "Discarded %d stales that didn't match current hash", v0);
    sub_20F58(7, s, 0);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 69010: using guessed type int dword_69010;
// 690EC: using guessed type int dword_690EC;
// 744D0: using guessed type pthread_cond_t stru_744D0;
// 74500: using guessed type char byte_74500;

//----- (0003747C) --------------------------------------------------------
int sub_3747C()
{
  pthread_t v0; // r0
  int v1; // r8
  int v2; // r5
  int v3; // r3
  pthread_rwlock_t *v4; // r4

  v0 = pthread_self();
  pthread_detach(v0);
  sub_37134();
  if ( pthread_rwlock_rdlock(&stru_744A8) )
    sub_30138("restart_thread", 5445);
  v1 = dword_75588;
  v2 = pthread_rwlock_unlock(&stru_744A8);
  if ( v2 )
    sub_2FB24("restart_thread", 5447);
  off_67ED8();
  if ( v1 > 0 )
  {
    do
    {
      v3 = *(_DWORD *)(dword_744A4 + 4 * v2);
      v4 = *(pthread_rwlock_t **)(v3 + 36);
      if ( v4 && !v4[1].__lock )
      {
        *(_BYTE *)(v3 + 62) = 1;
        sub_32C30(v4);
        if ( pthread_mutex_lock(&stru_767C8) )
          sub_2EFE0("restart_thread", 5466);
        (*(void (__fastcall **)(pthread_rwlock_t *))(v4->__nr_readers + 76))(v4);
        if ( pthread_mutex_unlock(&stru_767C8) )
          sub_2F03C("restart_thread", 5468);
        off_67ED8();
      }
      ++v2;
    }
    while ( v1 != v2 );
  }
  if ( pthread_mutex_lock(&stru_767F4) )
    sub_2EFE0("restart_thread", 5472);
  pthread_cond_broadcast(&stru_76700);
  if ( pthread_mutex_unlock(&stru_767F4) )
    sub_2F03C("restart_thread", 5474);
  off_67ED8();
  return 0;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 744A4: using guessed type int dword_744A4;
// 744A8: using guessed type pthread_rwlock_t stru_744A8;
// 75588: using guessed type int dword_75588;
// 76700: using guessed type pthread_cond_t stru_76700;
// 767C8: using guessed type pthread_mutex_t stru_767C8;
// 767F4: using guessed type pthread_mutex_t stru_767F4;

//----- (000375EC) --------------------------------------------------------
void __fastcall sub_375EC(int a1, unsigned __int64 a2)
{
  double v3; // d0
  int v5; // r4
  char *v6; // r0
  int v7; // r5
  double v8; // d9
  int v9; // r6
  int v10; // r5
  double v11; // r0
  double v12; // r0
  double v13; // r0
  double v14; // r0
  double v15; // r0
  double v16; // d10
  int v17; // r3
  int v18; // r3
  int v19; // r6
  unsigned __int64 v20; // r0
  int *v21; // r11
  double v22; // d8
  double v23; // r0
  int v24; // r11
  int v25; // r3
  double v26; // d5
  int v27; // r0
  int v28; // r6
  double v29; // r0
  int v30; // r1
  double v31; // r0
  double v32; // d10
  double v33; // d6
  double v34; // d7
  double v35; // d5
  double v36; // d7
  double v37; // r0
  double v38; // r0
  double v39; // r0
  double v40; // r0
  double v41; // r0
  double v42; // r0
  int *v43; // r0
  int *v44; // r0
  int v45; // r3
  int v46; // r12
  int v47; // r3
  int v48; // r12
  char v50[16]; // [sp+28h] [bp-884h] BYREF
  char v51[16]; // [sp+38h] [bp-874h] BYREF
  char v52[16]; // [sp+48h] [bp-864h] BYREF
  char v53[16]; // [sp+58h] [bp-854h] BYREF
  struct sysinfo info; // [sp+68h] [bp-844h] BYREF
  char s[2052]; // [sp+A8h] [bp-804h] BYREF

  if ( sysinfo(&info) )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
    {
      v5 = *_errno_location();
      v6 = strerror(v5);
      snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v5, v6);
      sub_20F58(6, s, 0);
    }
    dword_74484 = time(0);
  }
  else
  {
    dword_74484 = info.uptime;
  }
  sub_239A4((struct timeval *)&dword_69018);
  sub_23C94();
  v7 = dword_69018;
  v8 = v3;
  if ( dword_68730 > dword_69018 - dword_6A5B0 )
  {
    if ( a1 < 0 )
      return;
    v24 = 0;
    sub_257F8(&unk_6907C, &dword_69018);
  }
  else
  {
    dword_6A5B0 = dword_69018;
    sub_257F8(&unk_6907C, &dword_69018);
    if ( a1 < 0 )
    {
      v9 = pthread_mutex_lock(&stru_76838);
      if ( !v9 )
      {
        if ( dword_75588 > 0 )
        {
          do
          {
            while ( 1 )
            {
              v10 = *(_DWORD *)(sub_31B04(v9) + 36);
              sub_23C94();
              sub_257F8((void *)(v10 + 140), &dword_69018);
              if ( v3 > 0.0 )
                break;
              if ( dword_75588 <= ++v9 )
                goto LABEL_15;
            }
            LODWORD(v11) = v10 + 48;
            v12 = sub_2C538(v11);
            LODWORD(v12) = v10 + 56;
            v13 = sub_2C538(v12);
            LODWORD(v13) = v10 + 64;
            v14 = sub_2C538(v13);
            LODWORD(v14) = v10 + 72;
            ++v9;
            v3 = 0.0;
            sub_2C538(v14);
          }
          while ( dword_75588 > v9 );
        }
LABEL_15:
        if ( pthread_mutex_unlock(&stru_76838) )
        {
          v47 = *_errno_location();
          v48 = 7106;
          goto LABEL_74;
        }
        off_67ED8();
        if ( !pthread_mutex_lock(&stru_76838) )
        {
          LODWORD(v15) = sub_4A10C(a2);
          v16 = v15;
          v17 = dword_690E8;
          dbl_756A8 = dbl_756A8 + v15;
          goto LABEL_18;
        }
LABEL_68:
        v43 = _errno_location();
        snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v43, "cgminer.c", "hashmeter", 7109);
        goto LABEL_69;
      }
      v45 = *_errno_location();
      v46 = 7091;
LABEL_72:
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v45, "cgminer.c", "hashmeter", v46);
      goto LABEL_69;
    }
    v24 = 1;
  }
  v27 = sub_31B04(a1);
  v28 = *(_DWORD *)(v27 + 36);
  sub_257F8((void *)(v27 + 44), &dword_69018);
  *(_DWORD *)(v28 + 240) = v7;
  sub_23C94();
  sub_257F8((void *)(v28 + 140), &dword_69018);
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    LODWORD(v29) = sub_4A10C(a2);
    snprintf(s, 0x800u, "[thread %d: %llu hashes, %.1f mhash/sec]", a1, a2, v29 / v3 / 1000000.0);
    sub_20F58(7, s, 0);
  }
  LODWORD(a2) = sub_4A178(a2, 0xF4240u);
  HIDWORD(a2) = v30;
  if ( pthread_mutex_lock(&stru_76838) )
  {
    v45 = *_errno_location();
    v46 = 7062;
    goto LABEL_72;
  }
  LODWORD(v31) = sub_4A10C(a2);
  v16 = v31;
  *(double *)(v28 + 80) = *(double *)(v28 + 80) + v31;
  if ( v3 > 0.0 )
  {
    LODWORD(v31) = v28 + 48;
    v37 = sub_2C538(v31);
    LODWORD(v37) = v28 + 56;
    v38 = sub_2C538(v37);
    LODWORD(v38) = v28 + 64;
    v39 = sub_2C538(v38);
    LODWORD(v39) = v28 + 72;
    sub_2C538(v39);
  }
  if ( pthread_mutex_unlock(&stru_76838) )
  {
    v47 = *_errno_location();
    v48 = 7069;
    goto LABEL_74;
  }
  off_67ED8();
  if ( ((unsigned __int8)v24 & (unsigned __int8)byte_73388) != 0 )
  {
    sub_2E7D0(s, 0x100u, v28);
    printf("%s          \r", s);
    fflush((FILE *)stdout);
    if ( pthread_mutex_lock(&stru_76838) )
      goto LABEL_68;
    v17 = dword_690E8;
    dbl_756A8 = dbl_756A8 + v16;
    goto LABEL_18;
  }
  if ( pthread_mutex_lock(&stru_76838) )
    goto LABEL_68;
  v17 = dword_690E8;
  dbl_756A8 = dbl_756A8 + v16;
  if ( v24 )
  {
LABEL_18:
    v18 = v17 + 1;
    v19 = 0;
    LODWORD(v20) = 0;
    if ( v18 > 11 )
      v18 = 0;
    HIDWORD(v20) = 0;
    dword_690E8 = v18;
    v21 = (int *)dbl_69088;
    do
    {
      v22 = *(double *)v21;
      v21 += 2;
      if ( v22 >= 0.0 )
      {
        LODWORD(v23) = sub_4A10C(v20);
        ++v19;
        v20 = (unsigned __int64)(v23 + v22);
      }
    }
    while ( v21 != &dword_690E8 );
    if ( v19 )
    {
      LODWORD(a2) = sub_4A178(v20, v19);
      HIDWORD(a2) = HIDWORD(v20);
    }
    if ( (double)dword_68730 > 0.0 )
    {
      sub_4A10C(a2);
      LODWORD(v42) = &dbl_75590;
      *(double *)&v20 = sub_2C538(v42);
      if ( v8 <= 0.0 )
        goto LABEL_28;
    }
    else if ( v8 <= 0.0 )
    {
LABEL_28:
      v24 = 1;
      *(_QWORD *)&dword_73470 = (unsigned __int64)(dbl_75590 * 1000000.0);
      v25 = dword_690E8;
      v26 = 0.0;
      dbl_69088[dword_690E8] = 0.0;
      goto LABEL_44;
    }
    LODWORD(v20) = &dbl_75690;
    v40 = sub_2C538(*(double *)&v20);
    LODWORD(v40) = &dbl_75688;
    v41 = sub_2C538(v40);
    if ( v8 > 0.0 )
    {
      LODWORD(v41) = &dbl_75698;
      sub_2C538(v41);
    }
    goto LABEL_28;
  }
  v25 = dword_690E8;
  v26 = dbl_69088[dword_690E8];
LABEL_44:
  v32 = v16 + v26;
  v33 = (double)dword_74484;
  v34 = (double)dword_73320;
  v35 = dbl_68740;
  dbl_69088[v25] = v32;
  v36 = v33 - v34;
  dbl_68720 = v36;
  if ( v36 - v35 > 86400.0 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      snprintf(s, 0x800u, "cgminer time error total_secs = %f last_total_secs = %f", v36, v35);
      sub_20F58(3, s, 0);
    }
    if ( !pthread_mutex_unlock(&stru_76838) )
    {
      off_67ED8();
      sub_32DA0();
      if ( !pthread_mutex_lock(&stru_76838) )
      {
        if ( !v24 )
          goto LABEL_51;
LABEL_56:
        sub_2AEF8((unsigned __int64)(dbl_756A8 / dbl_68720 * 1000000.0), v50, 0x10u, 4);
        dbl_6A5B8 = (double)((int)dbl_75590 / 10) / 100.0;
        sub_2AEF8((unsigned __int64)(dbl_75590 * 1000000.0), v51, 0x10u, 4);
        sub_2AEF8((unsigned __int64)(dbl_75690 * 1000000.0), v52, 0x10u, 4);
        sub_2AEF8((unsigned __int64)(dbl_75688 * 1000000.0), v53, 0x10u, 4);
        sub_2AEF8((unsigned __int64)(dbl_75698 * 1000000.0), s, 0x10u, 4);
        snprintf(
          byte_6A5C0,
          0x100u,
          "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
          dword_68730,
          v51,
          v52,
          v53,
          s,
          v50);
        if ( !pthread_mutex_unlock(&stru_76838) )
        {
          off_67ED8();
          printf("%s          \r", byte_6A5C0);
          fflush((FILE *)stdout);
          return;
        }
        goto LABEL_70;
      }
      v45 = *_errno_location();
      v46 = 7159;
      goto LABEL_72;
    }
    v47 = *_errno_location();
    v48 = 7157;
LABEL_74:
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v47, "cgminer.c", "hashmeter", v48);
LABEL_69:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  dbl_68740 = v36;
  if ( v24 )
    goto LABEL_56;
LABEL_51:
  if ( pthread_mutex_unlock(&stru_76838) )
  {
LABEL_70:
    v44 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v44, "cgminer.c", "hashmeter", 7200);
    goto LABEL_69;
  }
  off_67ED8();
}
// 376DC: variable 'v3' is possibly undefined
// 377A4: variable 'v11' is possibly undefined
// 37854: variable 'v15' is possibly undefined
// 378B4: variable 'v23' is possibly undefined
// 378D8: variable 'v20' is possibly undefined
// 37A40: variable 'v29' is possibly undefined
// 37A88: variable 'v30' is possibly undefined
// 37AAC: variable 'v31' is possibly undefined
// 37F24: variable 'v42' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68720: using guessed type double dbl_68720;
// 68730: using guessed type int dword_68730;
// 68740: using guessed type double dbl_68740;
// 68A74: using guessed type int stdout;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 69018: using guessed type int dword_69018;
// 69088: using guessed type double dbl_69088[12];
// 690E8: using guessed type int dword_690E8;
// 6A5B0: using guessed type int dword_6A5B0;
// 6A5B8: using guessed type double dbl_6A5B8;
// 73320: using guessed type int dword_73320;
// 73388: using guessed type char byte_73388;
// 73470: using guessed type int dword_73470;
// 74484: using guessed type int dword_74484;
// 74500: using guessed type char byte_74500;
// 75588: using guessed type int dword_75588;
// 75590: using guessed type double dbl_75590;
// 75688: using guessed type double dbl_75688;
// 75690: using guessed type double dbl_75690;
// 75698: using guessed type double dbl_75698;
// 756A8: using guessed type double dbl_756A8;
// 76838: using guessed type pthread_mutex_t stru_76838;

//----- (00038678) --------------------------------------------------------
void __fastcall sub_38678(int a1)
{
  int v2; // r8
  int v3; // r3
  int v4; // r3
  int v5; // r9
  int v6; // r11
  unsigned __int64 v7; // r6
  int v8; // r3
  void **v9; // r3
  double v10; // d7
  void **v11; // r2
  int *v12; // r5
  struct timeval *v13; // r0
  __int64 v14; // r4
  __suseconds_t tv_usec; // r4
  __time_t tv_sec; // r3
  int v17; // r1
  int v18; // r5
  bool v19; // nf
  int v20; // r4
  int v21; // r4
  int v22; // r3
  bool v23; // cc
  unsigned __int64 v24; // r2
  _BOOL4 v25; // r1
  int v26; // r3
  int v27; // r1
  unsigned int v28; // r0
  int v29; // [sp+Ch] [bp-868h]
  _DWORD *v30; // [sp+10h] [bp-864h]
  _DWORD *v31; // [sp+14h] [bp-860h]
  unsigned int v32; // [sp+18h] [bp-85Ch]
  int v33; // [sp+24h] [bp-850h]
  void *v34; // [sp+28h] [bp-84Ch]
  __time_t v35; // [sp+2Ch] [bp-848h]
  __time_t v36; // [sp+2Ch] [bp-848h]
  struct timespec *remaining; // [sp+30h] [bp-844h]
  unsigned int v38; // [sp+38h] [bp-83Ch]
  unsigned int v39; // [sp+44h] [bp-830h]
  void **v40; // [sp+4Ch] [bp-828h] BYREF
  struct timeval v41; // [sp+50h] [bp-824h] BYREF
  struct timeval v42; // [sp+58h] [bp-81Ch] BYREF
  struct timeval v43; // [sp+60h] [bp-814h] BYREF
  struct timeval v44; // [sp+68h] [bp-80Ch] BYREF
  struct timespec requested_time; // [sp+70h] [bp-804h] BYREF

  v2 = *(_DWORD *)(a1 + 36);
  v29 = *(_DWORD *)(v2 + 4);
  v3 = dword_68730 / 5;
  if ( (int)((unsigned __int64)(1717986919LL * dword_68730) >> 32) >> 1 == dword_68730 >> 31 )
    v3 = 1;
  v33 = v3;
  if ( *(_DWORD *)(a1 + 4) )
    v4 = *(unsigned __int8 *)(a1 + 8);
  else
    v4 = 1;
  v34 = *(void **)a1;
  remaining = (struct timespec *)v4;
  v32 = (*(int (__fastcall **)(int))(v29 + 48))(a1);
  sub_239A4(&v41);
  sub_239A4(&v44);
  if ( *(_BYTE *)(v2 + 364) )
    goto LABEL_53;
  v5 = *(unsigned __int8 *)(v2 + 364);
  v6 = v5;
  v7 = 0;
  v8 = 1000000 * v33 + 1023;
  if ( 1000000 * v33 >= 0 )
    v8 = 1000000 * v33;
  v38 = v8 >> 10;
  do
  {
    v40 = sub_36CD4(a1, v34);
    *(_BYTE *)(a1 + 62) = 0;
    *(_BYTE *)(v2 + 172) = 1;
    sub_239A4(&v43);
    v40[62] = 0;
    *(_QWORD *)(v2 + 160) = 0;
    if ( !(*(int (__fastcall **)(int))(v29 + 56))(a1) )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf((char *)&requested_time, 0x800u, "work prepare failed, exiting mining thread %d", v34);
        sub_20F58(3, (const char *)&requested_time, 0);
      }
      break;
    }
    v9 = v40;
    v31 = (_DWORD *)(v2 + 304);
    v10 = *(double *)(v29 + 104);
    v30 = (_DWORD *)(v2 + 312);
    if ( v10 > *((double *)v40 + 47) )
      v10 = *((double *)v40 + 47);
    *((double *)v40 + 28) = v10;
    if ( *(double *)(v29 + 112) > v10 )
      v10 = *(double *)(v29 + 112);
    *((double *)v9 + 28) = v10;
    while ( 1 )
    {
      sub_239A4(&v42);
      sub_235C4(&v42, &v41.tv_sec);
      sub_235F8(&v41, (int *)(v2 + 296));
      if ( sub_2363C(&v41, v31) )
        sub_257F8(v31, &v41);
      if ( sub_23670(&v41, v30) )
        sub_257F8(v30, &v41);
      v11 = v40;
      ++*(_DWORD *)(v2 + 292);
      v12 = (int *)v11[65];
      sub_235F8(&v41, v12 + 97);
      if ( sub_2363C(&v41, v12 + 99) )
        sub_257F8(v12 + 99, &v41);
      if ( sub_23670(&v41, v12 + 101) )
        sub_257F8(v12 + 101, &v41);
      v13 = (struct timeval *)v40;
      ++v12[96];
      sub_239A4(v13 + 53);
      pthread_setcancelstate(1, 0);
      sub_2AEC4(a1);
      v14 = ((__int64 (__fastcall *)(int, void **, char *, _DWORD))*(_DWORD *)(v29 + 64))(
              a1,
              v40,
              (char *)v40[62] + v32,
              0);
      sub_2AE8C(a1);
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      sub_239A4(&v41);
      if ( v14 == -1 )
        break;
      v7 += v14;
      if ( *(_QWORD *)(v2 + 160) < v14 )
        *(_QWORD *)(v2 + 160) = v14;
      tv_usec = v41.tv_usec;
      tv_sec = v41.tv_sec;
      v17 = v41.tv_sec - v42.tv_sec;
      v5 += v41.tv_usec - v42.tv_usec + (v41.tv_usec - v42.tv_usec < 0 ? 0xF4240 : 0);
      if ( v41.tv_usec - v42.tv_usec < 0 )
        --v17;
      v6 += v17;
      if ( v5 > 1000000 )
      {
        ++v6;
        v5 -= 1000000;
      }
      v18 = v41.tv_sec - v43.tv_sec;
      if ( v41.tv_usec - v43.tv_usec < 0 )
        --v18;
      if ( v33 > v6 )
      {
        if ( v32 == -1 )
          goto LABEL_48;
        v27 = v5 + 1024;
        v35 = v41.tv_sec;
        if ( v5 + 1024 < 0 )
          v27 = v5 + 2047;
        v39 = (sub_49B50(1000000, v27 >> 10) + 16) * v33;
        tv_sec = v35;
        if ( 0xFFFFFC00 / v39 >= v32 )
          v32 = (v32 * v39) >> 10;
        else
          v32 = -1;
      }
      else if ( v33 < v6 )
      {
        tv_sec = v41.tv_sec;
        v32 = v33 * v32 / v6;
      }
      else if ( v5 > 100000 )
      {
        v36 = v41.tv_sec;
        v28 = sub_49B50(1000000 * v33 + v5, v38);
        tv_sec = v36;
        v32 = (v32 << 10) / v28;
      }
      v20 = tv_usec - v44.tv_usec;
      v19 = v20 < 0;
      v21 = v20 + (v20 < 0 ? 0xF4000 : 0);
      v22 = tv_sec - v44.tv_sec;
      if ( v19 )
      {
        --v22;
        v21 += 576;
      }
      if ( v7 )
      {
        v23 = v22 <= 0;
        if ( v22 <= 0 )
          v23 = v21 <= 200000;
        if ( !v23 )
          goto LABEL_43;
      }
      if ( dword_68730 <= v22 )
      {
LABEL_43:
        v24 = v7;
        v7 = 0;
        sub_375EC((int)v34, v24);
        sub_257F8(&v44, &v41);
        if ( *(_BYTE *)(a1 + 62) )
          goto LABEL_56;
      }
      else if ( *(_BYTE *)(a1 + 62) )
      {
LABEL_56:
        if ( !remaining )
        {
          v26 = *(_DWORD *)(a1 + 4);
          requested_time.tv_sec = 0;
          requested_time.tv_nsec = 250000000 * v26;
          nanosleep(&requested_time, 0);
        }
        goto LABEL_52;
      }
      if ( *(_BYTE *)(a1 + 60) || (v5 = *(_DWORD *)(v2 + 32)) != 0 )
      {
        v5 = 0;
        v6 = 0;
        sub_2BF50(a1, (int)v34, (int (__fastcall **)(int))(v29 + 92));
      }
      else
      {
        v6 = 0;
      }
LABEL_48:
      v25 = *(_QWORD *)(v2 + 160) > 0xFFFFFFFD;
      if ( dword_68754 < v18 )
        v25 = 1;
      if ( v25 || sub_367EC((int)v40, 0) )
        goto LABEL_52;
    }
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      snprintf(
        (char *)&requested_time,
        0x800u,
        "%s %d failure, disabling!",
        *(const char **)(v29 + 8),
        *(_DWORD *)(v2 + 8));
      sub_20F58(3, (const char *)&requested_time, 0);
    }
    *(_DWORD *)(v2 + 32) = 1;
    sub_24DC4((_DWORD *)v2, 1);
    *(_BYTE *)(v2 + 364) = 1;
LABEL_52:
    sub_2CBA8(&v40, "cgminer.c", "hash_sole_work", 9351);
  }
  while ( !*(_BYTE *)(v2 + 364) );
LABEL_53:
  *(_DWORD *)(v2 + 32) = 1;
}
// 67DB4: using guessed type int dword_67DB4;
// 68730: using guessed type int dword_68730;
// 68754: using guessed type int dword_68754;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00038D3C) --------------------------------------------------------
void __noreturn sub_38D3C()
{
  int v0; // r5
  int v1; // r3
  int v2; // r0
  int v3; // r4
  int v4; // r6
  int v5; // r1
  int v6; // r3
  int v7; // r3
  int *v8; // r3
  int v9; // r1
  int v10; // t1
  int v11; // r4
  int v12; // r0
  sem_t *v13; // r5
  int v14; // r3
  int *v15; // r0
  int *v16; // r0
  struct timeval v17; // [sp+28h] [bp-814h] BYREF
  char v18[8]; // [sp+30h] [bp-80Ch] BYREF
  char s[2052]; // [sp+38h] [bp-804h] BYREF

  pthread_setcanceltype(1, 0);
  sub_250A8("Watchdog");
  sub_2C148();
  sub_239A4((struct timeval *)&dword_69180);
LABEL_2:
  while ( 1 )
  {
    sleep(2u);
    sub_37134();
    sub_375EC(-1, 0);
    sub_239A4(&v17);
    if ( byte_73460 )
      goto LABEL_91;
    if ( byte_7339C || byte_732E4 )
    {
      if ( !sub_2BD14() )
      {
        if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
        {
          if ( !byte_7339C )
            goto LABEL_85;
          goto LABEL_50;
        }
        snprintf(s, 0x800u, "Pausing execution as per stop time %02d:%02d scheduled", dword_732F0, dword_732EC);
        sub_20F58(4, s, 0);
        if ( !byte_7339C )
        {
LABEL_85:
          strcpy(s, "Terminating execution as planned");
          sub_20F58(3, s, 1);
          sub_2E6B0(0, 1);
        }
        if ( byte_74500 || byte_68BD4 )
        {
LABEL_60:
          snprintf(s, 0x800u, "Will restart execution as scheduled at %02d:%02d", dword_733A8, dword_733A4);
          sub_20F58(4, s, 0);
        }
        else
        {
LABEL_50:
          if ( dword_67DB4 > 3 )
            goto LABEL_60;
        }
        byte_73460 = 1;
        if ( pthread_rwlock_rdlock(&stru_744A8) )
        {
          v15 = _errno_location();
          snprintf(
            s,
            0x800u,
            "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
            *v15,
            "cgminer.c",
            "watchdog_thread",
            10425);
          goto LABEL_87;
        }
        if ( dword_75588 > 0 )
        {
          v8 = (int *)dword_744A4;
          v9 = dword_744A4 + 4 * dword_75588;
          do
          {
            v10 = *v8++;
            *(_BYTE *)(v10 + 60) = 1;
          }
          while ( v8 != (int *)v9 );
        }
        if ( pthread_rwlock_unlock(&stru_744A8) )
        {
          v16 = _errno_location();
          snprintf(
            s,
            0x800u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v16,
            "cgminer.c",
            "watchdog_thread",
            10432);
LABEL_87:
          sub_20F58(3, s, 1);
          sub_2E6B0(1, 1);
        }
        off_67ED8();
        goto LABEL_6;
      }
      if ( byte_73460 )
      {
LABEL_91:
        if ( !byte_7339C && !byte_732E4 || sub_2BD14() )
          break;
      }
    }
LABEL_6:
    if ( dword_755C0 > 0 )
    {
      v0 = 0;
      while ( 1 )
      {
        v2 = sub_3046C(v0);
        v3 = v2;
        v4 = **(_DWORD **)(v2 + 152);
        if ( !v4 )
          goto LABEL_20;
        (*(void (**)(void))(*(_DWORD *)(v2 + 4) + 32))();
        snprintf(v18, 8u, "%s %d", *(const char **)(*(_DWORD *)(v3 + 4) + 8), *(_DWORD *)(v3 + 8));
        if ( *(_BYTE *)(v4 + 61) || *(_DWORD *)(v3 + 32) == 1 )
          goto LABEL_20;
        v5 = *(_DWORD *)(v3 + 96);
        v6 = v17.tv_sec - *(_DWORD *)(v4 + 44);
        if ( !v5 )
        {
          if ( v6 <= 120 )
            goto LABEL_20;
          v1 = (unsigned __int8)byte_74500;
          *(_QWORD *)(v3 + 48) = 0;
          *(_DWORD *)(v3 + 96) = 1;
          if ( v1 || byte_68BD4 || dword_67DB4 > 2 )
          {
            snprintf(s, 0x800u, "%s: Idle for more than 60 seconds, declaring SICK!", v18);
            sub_20F58(3, s, 0);
          }
          sub_239A4((struct timeval *)(v4 + 52));
          sub_24DC4((_DWORD *)v3, 3);
          if ( !byte_6875C )
            goto LABEL_20;
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
          {
            snprintf(s, 0x800u, "%s: Attempting to restart", v18);
            sub_20F58(3, s, 0);
          }
LABEL_18:
          if ( *(_DWORD *)(v3 + 32) != 1 )
            (*(void (__fastcall **)(int))(*(_DWORD *)(v3 + 4) + 16))(v3);
          goto LABEL_20;
        }
        if ( v6 <= 119 )
        {
          if ( v5 != 4 && (byte_74500 || byte_68BD4 || dword_67DB4 > 2) )
          {
            snprintf(s, 0x800u, "%s: Recovered, declaring WELL!", v18);
            sub_20F58(3, s, 0);
          }
          *(_DWORD *)(v3 + 96) = 0;
          *(_DWORD *)(v3 + 240) = time(0);
          goto LABEL_20;
        }
        if ( v5 != 1 )
          break;
        if ( v6 > 600 )
        {
          v7 = (unsigned __int8)byte_74500;
          *(_DWORD *)(v3 + 96) = 2;
          if ( v7 || byte_68BD4 || dword_67DB4 > 2 )
          {
            snprintf(s, 0x800u, "%s: Not responded for more than 10 minutes, declaring DEAD!", v18);
            sub_20F58(3, s, 0);
          }
          sub_239A4((struct timeval *)(v4 + 52));
          sub_24DC4((_DWORD *)v3, 4);
          goto LABEL_20;
        }
        if ( v17.tv_sec - *(_DWORD *)(v4 + 52) > 60 )
          goto LABEL_41;
LABEL_20:
        if ( dword_755C0 <= ++v0 )
          goto LABEL_2;
      }
      if ( v17.tv_sec - *(_DWORD *)(v4 + 52) <= 60 || v5 != 2 )
        goto LABEL_20;
LABEL_41:
      sub_239A4((struct timeval *)(v4 + 52));
      if ( byte_6875C )
        goto LABEL_18;
      goto LABEL_20;
    }
  }
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
  {
    snprintf(s, 0x800u, "Restarting execution as per start time %02d:%02d scheduled", dword_733A8, dword_733A4);
    sub_20F58(4, s, 0);
    if ( !byte_732E4 )
      goto LABEL_67;
    if ( byte_74500 || byte_68BD4 )
    {
LABEL_81:
      snprintf(s, 0x800u, "Will pause execution as scheduled at %02d:%02d", dword_732F0, dword_732EC);
      sub_20F58(4, s, 0);
LABEL_67:
      v11 = 0;
      for ( byte_73460 = 0; dword_75588 > v11; ++v11 )
      {
        v12 = sub_31B04(v11);
        v13 = (sem_t *)v12;
        if ( *(_DWORD *)(*(_DWORD *)(v12 + 36) + 32) != 1 )
        {
          v14 = (unsigned __int8)byte_68BD5;
          *(_BYTE *)(v12 + 60) = 0;
          if ( v14 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
          {
            snprintf(s, 0x800u, "Pushing sem post to thread %d", *(_DWORD *)v12);
            sub_20F58(7, s, 0);
          }
          sub_251AC(v13 + 1, "cgminer.c", "watchdog_thread", 10459);
        }
      }
      goto LABEL_6;
    }
  }
  else if ( !byte_732E4 )
  {
    goto LABEL_67;
  }
  if ( dword_67DB4 <= 3 )
    goto LABEL_67;
  goto LABEL_81;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 6875C: using guessed type char byte_6875C;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 69180: using guessed type int dword_69180;
// 732E4: using guessed type char byte_732E4;
// 732EC: using guessed type int dword_732EC;
// 732F0: using guessed type int dword_732F0;
// 7339C: using guessed type char byte_7339C;
// 733A4: using guessed type int dword_733A4;
// 733A8: using guessed type int dword_733A8;
// 73460: using guessed type char byte_73460;
// 744A4: using guessed type int dword_744A4;
// 744A8: using guessed type pthread_rwlock_t stru_744A8;
// 74500: using guessed type char byte_74500;
// 75588: using guessed type int dword_75588;
// 755C0: using guessed type int dword_755C0;

//----- (0003958C) --------------------------------------------------------
int __fastcall sub_3958C(_DWORD *a1)
{
  pthread_t v2; // r0
  char *v3; // r0
  const struct timespec *v4; // r1
  int v5; // r6
  __int64 v6; // r4
  int v7; // r0
  int v8; // r1
  __int64 v9; // r2
  bool v10; // zf
  char v11; // r7
  int v12; // r7
  void ***v13; // r6
  void **v14; // r4
  time_t v15; // r0
  void **v16; // r3
  int v17; // r2
  void **v18; // r8
  size_t v19; // r0
  int v20; // r3
  int v21; // r12
  int v22; // r1
  void ***v23; // r5
  int v24; // r3
  unsigned int v25; // r2
  unsigned int v26; // r1
  int v27; // r3
  unsigned int v28; // r2
  unsigned int v29; // r1
  int v30; // r3
  unsigned int v31; // r4
  void **v32; // r3
  int v33; // r2
  void **v34; // r3
  char *v35; // r3
  int v36; // r1
  void ****v37; // r3
  __int64 v38; // r2
  time_t v39; // r0
  void **v40; // r2
  int v41; // r3
  int v42; // r0
  _DWORD *v44; // r7
  void **v45; // r3
  unsigned int v46; // r4
  int v47; // r11
  _DWORD *v48; // r5
  _DWORD *v49; // r8
  int v50; // r4
  char *v51; // r9
  unsigned int v52; // r3
  int v53; // r3
  void **v54; // r3
  void *v55; // r2
  unsigned int v56; // r1
  bool v57; // cc
  char *v58; // r2
  char *v59; // lr
  char *v60; // r12
  int v61; // r0
  int v62; // r1
  int v63; // r2
  int v64; // r3
  _DWORD *v65; // lr
  char *v66; // r12
  int v67; // r1
  int v68; // r2
  int v69; // r3
  void **v70; // r0
  void **v71; // r7
  void *v72; // r0
  int *v73; // r0
  int v74; // r3
  const char *v75; // r1
  int v76; // r3
  int v77; // r3
  int v78; // r3
  int v79; // r2
  int v80; // r1
  int v81; // r3
  int v82; // r3
  int v83; // r3
  int v84; // r3
  unsigned int v85; // [sp+20h] [bp-C7Ch]
  int v86; // [sp+24h] [bp-C78h]
  __int64 v87; // [sp+28h] [bp-C74h]
  _DWORD *v88; // [sp+4Ch] [bp-C50h]
  int v89; // [sp+54h] [bp-C48h] BYREF
  void **v90; // [sp+58h] [bp-C44h] BYREF
  int v91; // [sp+5Ch] [bp-C40h] BYREF
  __int64 v92; // [sp+60h] [bp-C3Ch] BYREF
  char v93[12]; // [sp+68h] [bp-C34h] BYREF
  char s[16]; // [sp+74h] [bp-C28h] BYREF
  char v95[20]; // [sp+84h] [bp-C18h] BYREF
  char v96[1024]; // [sp+98h] [bp-C04h] BYREF
  char v97[2052]; // [sp+498h] [bp-804h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf(s, 0x10u, "%d/SStratum", *a1);
  sub_250A8(s);
  v3 = sub_23300();
  a1[182] = v3;
  if ( !v3 )
  {
    v59 = " stratum_q in stratum_sthread";
    qmemcpy(v97, "Failed to create", 16);
    v60 = &v97[16];
    goto LABEL_84;
  }
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    snprintf(v97, 0x800u, "in %s , pool: %d, pool_url: %s", "stratum_sthread", *a1, (const char *)a1[41]);
    sub_20F58(5, v97, 0);
    v3 = (char *)a1[182];
  }
  v4 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
  v5 = 0;
  v6 = 0;
  if ( *((_BYTE *)a1 + 105) )
    goto LABEL_48;
  do
  {
    v7 = sub_234A8((int)v3, v4);
    v90 = (void **)v7;
    if ( !v7 )
    {
      v59 = "Stratum q returned empty work";
      v60 = v97;
LABEL_84:
      v61 = *(_DWORD *)v59;
      v62 = *((_DWORD *)v59 + 1);
      v63 = *((_DWORD *)v59 + 2);
      v64 = *((_DWORD *)v59 + 3);
      v65 = v59 + 16;
      *(_DWORD *)v60 = v61;
      *((_DWORD *)v60 + 1) = v62;
      *((_DWORD *)v60 + 2) = v63;
      *((_DWORD *)v60 + 3) = v64;
      v66 = v60 + 16;
      v67 = v65[1];
      v68 = v65[2];
      v69 = v65[3];
      *(_DWORD *)v66 = *v65;
      *((_DWORD *)v66 + 1) = v67;
      *((_DWORD *)v66 + 2) = v68;
      *((_WORD *)v66 + 6) = v69;
      sub_20F58(3, v97, 1);
      sub_2E6B0(1, 1);
    }
    if ( *(_DWORD *)(v7 + 304) > 8u )
    {
      if ( (byte_74500 || byte_68BD4 || dword_67DB4 > 2)
        && ((snprintf(
               v97,
               0x800u,
               "Pool %d asking for inappropriately long nonce2 length %d",
               *a1,
               *(_DWORD *)(v7 + 304)),
             sub_20F58(3, v97, 0),
             byte_74500)
         || byte_68BD4)
        || dword_67DB4 > 2 )
      {
        strcpy(v97, "Not attempting to submit shares");
        sub_20F58(3, v97, 0);
      }
      sub_2CBA8(&v90, "cgminer.c", "stratum_sthread", 7656);
      goto LABEL_47;
    }
    v8 = *(_DWORD *)(v7 + 76);
    v9 = *(_QWORD *)(v7 + 296);
    v86 = v8;
    v10 = HIDWORD(v9) == HIDWORD(v6);
    v87 = v9;
    if ( HIDWORD(v9) == HIDWORD(v6) )
      v10 = (_DWORD)v9 == (_DWORD)v6;
    v89 = *(_DWORD *)(v7 + 76);
    v11 = v10;
    if ( v8 == v5 )
      v12 = v11 & 1;
    else
      v12 = 0;
    v92 = v9;
    if ( v12 )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        snprintf(v97, 0x800u, "Filtering duplicate share to pool %d", *a1);
        sub_20F58(6, v97, 0);
      }
      sub_2CBA8(&v90, "cgminer.c", "stratum_sthread", 7668);
      goto LABEL_47;
    }
    sub_22BB4(v93, (int)&v89, 4);
    sub_22BB4(v95, (int)&v92, (int)v90[76]);
    v13 = (void ***)sub_22A44(0x34u, 1u, "cgminer.c", "stratum_sthread", 7677);
    v14 = v90;
    v15 = time(0);
    v16 = v90;
    v13[11] = (void **)v15;
    v13[9] = v16;
    memset(v96, 0, sizeof(v96));
    if ( pthread_mutex_lock(&stru_690F0) )
    {
      v73 = _errno_location();
      snprintf(
        v97,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v73,
        "cgminer.c",
        "stratum_sthread",
        7686);
      goto LABEL_99;
    }
    v17 = dword_7448C;
    v13[10] = (void **)dword_7448C;
    dword_7448C = v17 + 1;
    if ( pthread_mutex_unlock(&stru_690F0) )
    {
      v74 = *_errno_location();
      snprintf(
        v97,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        v74,
        "cgminer.c",
        "stratum_sthread",
        7689);
      goto LABEL_99;
    }
    off_67ED8();
    v91 = 0;
    sub_22CD8(&v91, (unsigned __int8 *)a1 + 1780, 4);
    if ( *((_BYTE *)a1 + 644) )
      snprintf(
        v96,
        0x400u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%08x\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        (const char *)v90[72],
        v95,
        (const char *)v90[77],
        v93,
        bswap32((unsigned int)v90[111] & ~v91),
        v13[10]);
    else
      snprintf(
        v96,
        0x400u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        (const char *)v90[72],
        v95,
        (const char *)v90[77],
        v93,
        v13[10]);
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
    {
      snprintf(v97, 0x800u, "Submitting share %08lx to pool %d", v14[54], *a1);
      sub_20F58(6, v97, 0);
    }
    while ( 1 )
    {
      v18 = v13[11];
      if ( (int)v18 + 119 < time(0) )
        goto LABEL_119;
      v19 = strlen(v96);
      if ( sub_244A4((int)a1, v96, v19) )
      {
        if ( pthread_mutex_lock(&stru_690F0) )
        {
          v77 = *_errno_location();
          snprintf(
            v97,
            0x800u,
            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
            v77,
            "cgminer.c",
            "stratum_sthread",
            7733);
          goto LABEL_99;
        }
        v20 = *((unsigned __int8 *)v13 + 40);
        v21 = *((unsigned __int8 *)v13 + 43);
        v22 = *((unsigned __int8 *)v13 + 42);
        v13[5] = (void **)(v13 + 10);
        v23 = (void ***)dword_69108;
        v24 = v20 + 17973517 + (v21 << 24) + (v22 << 16) + (*((unsigned __int8 *)v13 + 41) << 8);
        v13[6] = (void **)4;
        v24 ^= 0x7F76Du;
        v25 = (-1622558010 - v24) ^ (v24 << 8);
        v26 = (-17973517 - v24 - v25) ^ (v25 >> 13);
        v27 = (v24 - v25 - v26) ^ (v26 >> 12);
        v28 = (v25 - v26 - v27) ^ (v27 << 16);
        v29 = (v26 - v27 - v28) ^ (v28 >> 5);
        v30 = (v27 - v28 - v29) ^ (v29 >> 3);
        v31 = (v29 - v30 - ((v28 - v29 - v30) ^ (v30 << 10))) ^ (((v28 - v29 - v30) ^ (v30 << 10)) >> 15);
        v13[7] = (void **)v31;
        if ( v23 )
        {
          v32 = *v23;
          v13[2] = 0;
          *v13 = v32;
          v13[1] = (void **)((_BYTE *)(*v23)[4] - (_BYTE *)(*v23)[5]);
          *((_DWORD *)(*v23)[4] + 2) = v13;
          (*v23)[4] = v13;
        }
        else
        {
          v13[2] = 0;
          v13[1] = 0;
          dword_69108 = (int)v13;
          v70 = (void **)malloc(0x2Cu);
          *v13 = v70;
          if ( !v70 )
            goto LABEL_145;
          memset(v70, 0, 0x2Cu);
          (*v13)[4] = v13;
          (*v13)[1] = (void *)32;
          (*v13)[2] = (void *)5;
          (*v13)[5] = 0;
          v71 = *v13;
          *v71 = malloc(0x180u);
          v72 = **v13;
          if ( !v72 )
            goto LABEL_145;
          memset(v72, 0, 0x180u);
          v23 = v13;
          (*v13)[10] = (void *)-1609490463;
        }
        (*v23)[3] = (char *)(*v23)[3] + 1;
        v33 = 12 * (v31 & ((unsigned int)(*v23)[1] - 1));
        ++*(_DWORD *)((char *)**v23 + v33 + 4);
        v34 = *(void ***)((char *)**v23 + v33);
        v13[3] = 0;
        v13[4] = v34;
        v35 = (char *)**v23;
        v36 = *(_DWORD *)&v35[v33];
        v37 = (void ****)&v35[v33];
        if ( v36 )
        {
          *(_DWORD *)(v36 + 12) = v13;
          v37 = (void ****)((char *)**v23 + v33);
        }
        *v37 = v13;
        v38 = *(_QWORD *)((char *)**v23 + v33 + 4);
        if ( (unsigned int)v38 < 10 * (HIDWORD(v38) + 1) || (*v13)[9] == (void *)1 )
          goto LABEL_33;
        v44 = calloc(24 * (_DWORD)(*v13)[1], 1u);
        if ( v44 )
        {
          (*v13)[6] = (void *)((((2 * (_DWORD)(*v13)[1] - 1) & (unsigned int)(*v13)[3]) != 0)
                             + ((unsigned int)(*v13)[3] >> (*((_BYTE *)*v13 + 8) + 1)));
          (*v13)[7] = 0;
          v45 = *v13;
          v46 = (unsigned int)(*v13)[1];
          if ( v46 )
          {
            v47 = 0;
            v85 = 0;
            v88 = a1;
            do
            {
              v48 = *(_DWORD **)((char *)*v45 + v47);
              if ( v48 )
              {
                while ( 1 )
                {
                  v49 = (_DWORD *)v48[4];
                  v50 = 3 * ((2 * v46 - 1) & v48[7]);
                  v51 = (char *)&v44[v50];
                  v52 = *((_DWORD *)v51 + 1) + 1;
                  *((_DWORD *)v51 + 1) = v52;
                  if ( v52 > (unsigned int)(*v13)[6] )
                  {
                    (*v13)[7] = (char *)(*v13)[7] + 1;
                    *((_DWORD *)v51 + 2) = *((_DWORD *)v51 + 1) / (unsigned int)(*v13)[6];
                  }
                  v48[3] = 0;
                  v48[4] = v44[v50];
                  v53 = v44[v50];
                  if ( v53 )
                    *(_DWORD *)(v53 + 12) = v48;
                  v44[v50] = v48;
                  v45 = *v13;
                  if ( !v49 )
                    break;
                  v46 = (unsigned int)v45[1];
                  v48 = v49;
                }
                v46 = (unsigned int)v45[1];
              }
              v47 += 12;
              ++v85;
            }
            while ( v85 < v46 );
            a1 = v88;
          }
          free(*v45);
          (*v13)[1] = (void *)(2 * (_DWORD)(*v13)[1]);
          (*v13)[2] = (char *)(*v13)[2] + 1;
          **v13 = v44;
          v54 = *v13;
          v55 = (*v13)[7];
          v56 = (unsigned int)(*v13)[3];
          v57 = (unsigned int)v55 > v56 >> 1;
          if ( (unsigned int)v55 <= v56 >> 1 )
            v58 = 0;
          else
            v58 = (char *)v54[8];
          if ( v57 )
            ++v58;
          v54[8] = v58;
          if ( (unsigned int)(*v13)[8] > 1 )
            (*v13)[9] = (void *)1;
LABEL_33:
          ++a1[183];
          if ( !pthread_mutex_unlock(&stru_690F0) )
          {
            off_67ED8();
            if ( sub_2F180((int)a1, (_BYTE *)a1 + 96) )
            {
              if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 3 )
              {
                if ( !byte_68BD5 )
                {
LABEL_39:
                  v39 = time(0);
                  v40 = v13[11];
                  v41 = (unsigned __int8)byte_68BD5;
                  v13[12] = (void **)v39;
                  v42 = v39 - (_DWORD)v40;
                  if ( v42 > 0 )
                    v41 |= 1u;
                  if ( v41 && (byte_74500 || byte_68BD4 || dword_67DB4 > 5) )
                  {
                    snprintf(v97, 0x800u, "Pool %d stratum share submission lag time %d seconds", *a1, v42);
                    sub_20F58(6, v97, 0);
                  }
                  goto LABEL_46;
                }
                goto LABEL_81;
              }
              snprintf(v97, 0x800u, "Pool %d communication resumed, submitting work", *a1);
              sub_20F58(4, v97, 0);
            }
            if ( !byte_68BD5 )
              goto LABEL_39;
            if ( byte_74500 || byte_68BD4 )
            {
LABEL_53:
              strcpy(v97, "Successfully submitted, adding to stratum_shares db");
              sub_20F58(7, v97, 0);
              goto LABEL_39;
            }
LABEL_81:
            if ( dword_67DB4 <= 6 )
              goto LABEL_39;
            goto LABEL_53;
          }
          v78 = *_errno_location();
          snprintf(
            v97,
            0x800u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            v78,
            "cgminer.c",
            "stratum_sthread",
            7736);
LABEL_99:
          sub_20F58(3, v97, 1);
          sub_2E6B0(1, 1);
        }
LABEL_145:
        exit(-1);
      }
      if ( !sub_2F098((int)a1, (_BYTE *)a1 + 96) && sub_32424((int)a1) )
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
        {
          snprintf(v97, 0x800u, "Pool %d stratum share submission failure", *a1);
          sub_20F58(4, v97, 0);
        }
        v81 = a1[33] + 1;
        ++dword_74494;
        a1[33] = v81;
      }
      if ( byte_75684 )
        break;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      {
        v82 = *_errno_location();
        snprintf(
          v97,
          0x800u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          v82,
          "cgminer.c",
          "stratum_sthread",
          7758);
        goto LABEL_99;
      }
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v83 = *_errno_location();
        snprintf(
          v97,
          0x800u,
          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          v83,
          "cgminer.c",
          "stratum_sthread",
          7758);
        goto LABEL_99;
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
      {
        v84 = *_errno_location();
        snprintf(
          v97,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v84,
          "cgminer.c",
          "stratum_sthread",
          7758);
        goto LABEL_99;
      }
      v75 = (const char *)a1[153];
      if ( !v75 || strcmp((const char *)v90[80], v75) )
      {
        if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        {
          off_67ED8();
          if ( !byte_68BD5 )
            goto LABEL_124;
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
          {
            strcpy(v97, "No matching session id for resubmitting stratum share");
            sub_20F58(7, v97, 0);
            goto LABEL_119;
          }
LABEL_121:
          if ( byte_68BD4 || dword_67DB4 > 6 )
            goto LABEL_123;
          goto LABEL_124;
        }
LABEL_111:
        v76 = *_errno_location();
        snprintf(
          v97,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v76,
          "cgminer.c",
          "stratum_sthread",
          7760);
        goto LABEL_99;
      }
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        goto LABEL_111;
      off_67ED8();
      sleep(2u);
    }
    if ( !byte_68BD5 )
      goto LABEL_124;
    if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 6 )
      goto LABEL_121;
    strcpy(v97, "Lowmem option prevents resubmitting stratum share");
    sub_20F58(7, v97, 0);
LABEL_119:
    if ( byte_68BD5 )
    {
      if ( !byte_74500 )
        goto LABEL_121;
LABEL_123:
      strcpy(v97, "Failed to submit stratum share, discarding");
      sub_20F58(7, v97, 0);
    }
LABEL_124:
    sub_2CBA8(&v90, "cgminer.c", "stratum_sthread", 7775);
    free(v13);
    v79 = dword_73318;
    v80 = dword_7331C;
    ++a1[30];
    *(_QWORD *)&dword_73318 = __PAIR64__(v80, v79) + 1;
LABEL_46:
    v5 = v86;
    v6 = v87;
LABEL_47:
    v4 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
    v3 = (char *)a1[182];
  }
  while ( !*((_BYTE *)a1 + 105) );
LABEL_48:
  sub_233C4((int)v3);
  return 0;
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 69108: using guessed type int dword_69108;
// 73318: using guessed type int dword_73318;
// 7331C: using guessed type int dword_7331C;
// 7448C: using guessed type int dword_7448C;
// 74494: using guessed type int dword_74494;
// 74500: using guessed type char byte_74500;
// 75684: using guessed type char byte_75684;

//----- (0003A5D0) --------------------------------------------------------
int __fastcall sub_3A5D0(int a1)
{
  _DWORD *v1; // r2
  int v2; // r1
  int v3; // r4
  size_t v4; // r5
  __int64 v6; // r2
  char *v7; // r6
  int v8; // r12
  int v9; // r12
  int v10; // r12
  unsigned int v11; // r7
  size_t v12; // r5
  int v13; // r3
  unsigned __int8 *v14; // r10
  int v15; // r0
  unsigned int v16; // r11
  unsigned int v17; // r7
  unsigned __int8 *v18; // r4
  unsigned int v19; // r1
  unsigned int v20; // r3
  int v21; // r2
  unsigned int v22; // r1
  unsigned int v23; // r3
  int v24; // r2
  unsigned int v25; // r1
  unsigned int v26; // r3
  size_t v27; // r3
  int v28; // r2
  unsigned int v29; // r1
  unsigned int v30; // r0
  int v31; // r2
  unsigned int v32; // r3
  unsigned int v33; // r1
  unsigned int v34; // r2
  unsigned int v35; // r7
  _DWORD *v36; // r2
  int v37; // r4
  int v38; // r8
  int v39; // r4
  int v40; // r3
  int v41; // r3
  char *v42; // r0
  int v43; // r7
  int v44; // r4
  int v45; // r5
  int v46; // r3
  int v47; // r10
  int v48; // r9
  int v49; // r2
  int v50; // r12
  unsigned int v51; // lr
  int v52; // r3
  int v53; // r0
  int v54; // r1
  int v55; // r0
  int v56; // r8
  bool v57; // zf
  int v58; // r3
  bool v59; // zf
  bool v60; // zf
  int v61; // r11
  int v62; // r10
  int v63; // r1
  int v64; // r2
  int v65; // r0
  int v66; // r3
  int v67; // r4
  _DWORD *v68; // r2
  int v69; // r3
  int v70; // r2
  __int64 v71; // r2
  unsigned int v72; // r8
  unsigned int v73; // lr
  unsigned __int8 *v74; // r11
  int v75; // r3
  int v76; // r7
  int v77; // r4
  int v78; // r0
  unsigned __int8 *v79; // r10
  int v80; // r1
  unsigned int v81; // r2
  unsigned int v82; // r7
  int v83; // r3
  unsigned int v84; // r1
  unsigned int v85; // r2
  int v86; // r3
  unsigned int v87; // r1
  unsigned int v88; // r2
  int v89; // r1
  unsigned int v90; // r2
  size_t v91; // lr
  int v92; // r3
  unsigned int v93; // r2
  unsigned int v94; // r12
  int v95; // r3
  unsigned int v96; // r1
  unsigned int v97; // r2
  unsigned int v98; // r3
  unsigned int v99; // r4
  int v100; // r3
  int v101; // r8
  __int64 v102; // r2
  int v103; // r3
  int v104; // r1
  int *v105; // r2
  __int64 v106; // r2
  int v107; // r3
  int v108; // r0
  signed int v109; // r7
  char v110; // r1
  int v111; // r2
  __int64 v112; // r0
  double v113; // r0
  double v114; // d8
  int v115; // kr00_4
  struct tm *v116; // r0
  int v117; // r11
  char *v118; // r3
  int v119; // t1
  int v120; // r1
  const char *v121; // r2
  int v122; // r12
  char *v123; // r3
  _DWORD *v124; // r8
  int v125; // r3
  int v126; // r10
  int v127; // r3
  unsigned int v128; // r4
  _DWORD *v129; // r5
  _DWORD *v130; // r6
  int v131; // r4
  char *v132; // r9
  unsigned int v133; // r3
  int v134; // r2
  int v135; // r3
  _DWORD *v136; // r3
  unsigned int v137; // r2
  unsigned int v138; // r1
  bool v139; // cc
  int v140; // r2
  int v141; // r3
  int v142; // r4
  int *v143; // r0
  int v144; // r3
  int *v145; // r0
  int *v146; // r0
  const char *v147; // lr
  int v148; // r3
  int v149; // r12
  int *v150; // r0
  int *v151; // r0
  int *v152; // r0
  int *v153; // r0
  char *v154; // r3
  void *v155; // r0
  void **v156; // r9
  void *v157; // r0
  int *v158; // r0
  int *v159; // r0
  int v160; // r3
  _DWORD *v161; // [sp+10h] [bp-88Ch]
  int v162; // [sp+14h] [bp-888h]
  int v163; // [sp+1Ch] [bp-880h]
  size_t v164; // [sp+24h] [bp-878h]
  unsigned int v165; // [sp+24h] [bp-878h]
  char *v166; // [sp+2Ch] [bp-870h]
  char *v167; // [sp+2Ch] [bp-870h]
  int v168; // [sp+30h] [bp-86Ch] BYREF
  _DWORD s2[8]; // [sp+34h] [bp-868h] BYREF
  char s[12]; // [sp+54h] [bp-848h] BYREF
  char v171; // [sp+60h] [bp-83Ch] BYREF
  time_t v172[513]; // [sp+98h] [bp-804h] BYREF

  v1 = *(_DWORD **)(a1 + 260);
  v2 = *(unsigned __int8 *)(a1 + 282);
  v168 = 0;
  v3 = v1[392];
  v161 = v1;
  v162 = v2;
  v4 = *(unsigned __int8 *)(v3 + 42);
  if ( v2 )
    return v162;
  v6 = *(_QWORD *)(a1 + 28);
  v7 = (char *)a1;
  v8 = *(_DWORD *)(a1 + 24);
  s2[0] = *(_DWORD *)(a1 + 32);
  HIDWORD(v6) = *(_DWORD *)(a1 + 20);
  s2[2] = v8;
  v9 = *(_DWORD *)(a1 + 16);
  s2[3] = HIDWORD(v6);
  HIDWORD(v6) = *(_DWORD *)(a1 + 12);
  s2[4] = v9;
  v10 = *(_DWORD *)(a1 + 8);
  s2[5] = HIDWORD(v6);
  HIDWORD(v6) = *(_DWORD *)(a1 + 4);
  s2[1] = v6;
  s2[6] = v10;
  s2[7] = HIDWORD(v6);
  sub_22BB4(s, (int)s2, 32);
  if ( v4 <= 4 )
  {
    sub_254E8(&v168, (const void *)(v3 + 43), v4, (int)"cgminer.c", (int)"test_work_current", 5650);
    --v168;
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(v161 + 53)) )
  {
    v145 = _errno_location();
    snprintf(
      (char *)v172,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v145,
      "cgminer.c",
      "test_work_current",
      5655);
    goto LABEL_203;
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v161 + 59)) )
  {
    v146 = _errno_location();
    v147 = "test_work_current";
    v148 = *v146;
    v149 = 5655;
LABEL_222:
    snprintf((char *)v172, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v148, "cgminer.c", v147, v149);
    goto LABEL_203;
  }
  if ( *((_BYTE *)v161 + 680) )
  {
    *((_BYTE *)v161 + 680) = 0;
    v7[280] = 1;
  }
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v161 + 59)) )
  {
    v150 = _errno_location();
    snprintf(
      (char *)v172,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v150,
      "cgminer.c",
      "test_work_current",
      5663);
    goto LABEL_203;
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(v161 + 53)) )
  {
    v151 = _errno_location();
    snprintf(
      (char *)v172,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v151,
      "cgminer.c",
      "test_work_current",
      5663);
    goto LABEL_203;
  }
  off_67ED8();
  v163 = pthread_rwlock_wrlock(&stru_6A6C0);
  if ( v163 )
  {
    v152 = _errno_location();
    v147 = "block_exists";
    v148 = *v152;
    v149 = 5576;
    goto LABEL_222;
  }
  v11 = -1640531527;
  v12 = strlen(s);
  LOWORD(v13) = -16657;
  if ( v12 <= 0xB )
  {
    HIWORD(v13) = -275;
    v15 = -1640531527;
    v16 = v12;
    v18 = (unsigned __int8 *)s;
  }
  else
  {
    v14 = (unsigned __int8 *)&v171;
    v15 = -1640531527;
    HIWORD(v13) = -275;
    v16 = v12;
    do
    {
      v16 -= 12;
      v17 = (*(v14 - 6) << 16) + (*(v14 - 7) << 8) + *(v14 - 8) + (*(v14 - 5) << 24) + v11;
      v18 = v14;
      v19 = (*(v14 - 10) << 16) + (*(v14 - 11) << 8) + *(v14 - 12) + (*(v14 - 9) << 24) - v17;
      v20 = (*(v14 - 2) << 16) + (*(v14 - 3) << 8) + *(v14 - 4) + (*(v14 - 1) << 24) + v13;
      v14 += 12;
      v21 = (v19 - v20 + v15) ^ (v20 >> 13);
      v22 = (v17 - v20 - v21) ^ (v21 << 8);
      v23 = (v20 - v21 - v22) ^ (v22 >> 13);
      v24 = (v21 - v22 - v23) ^ (v23 >> 12);
      v25 = (v22 - v23 - v24) ^ (v24 << 16);
      v26 = (v23 - v24 - v25) ^ (v25 >> 5);
      v15 = (v24 - v25 - v26) ^ (v26 >> 3);
      v11 = (v25 - v26 - v15) ^ (v15 << 10);
      v13 = (v26 - v15 - v11) ^ (v11 >> 15);
    }
    while ( v16 > 0xB );
  }
  v27 = v12 + v13;
  switch ( v16 )
  {
    case 1u:
      goto LABEL_26;
    case 2u:
      goto LABEL_25;
    case 3u:
      goto LABEL_24;
    case 4u:
      goto LABEL_23;
    case 5u:
      goto LABEL_22;
    case 6u:
      goto LABEL_21;
    case 7u:
      goto LABEL_20;
    case 8u:
      goto LABEL_19;
    case 9u:
      goto LABEL_18;
    case 0xAu:
      goto LABEL_17;
    case 0xBu:
      v27 += v18[10] << 24;
LABEL_17:
      v27 += v18[9] << 16;
LABEL_18:
      v27 += v18[8] << 8;
LABEL_19:
      v11 += v18[7] << 24;
LABEL_20:
      v11 += v18[6] << 16;
LABEL_21:
      v11 += v18[5] << 8;
LABEL_22:
      v11 += v18[4];
LABEL_23:
      v15 += v18[3] << 24;
LABEL_24:
      v15 += v18[2] << 16;
LABEL_25:
      v15 += v18[1] << 8;
LABEL_26:
      v15 += *v18;
      break;
    default:
      break;
  }
  v28 = (v15 - v11 - v27) ^ (v27 >> 13);
  v29 = (v11 - v27 - v28) ^ (v28 << 8);
  v30 = (v27 - v28 - v29) ^ (v29 >> 13);
  v31 = (v28 - v29 - v30) ^ (v30 >> 12);
  v32 = (v29 - v30 - v31) ^ (v31 << 16);
  v33 = (v30 - v31 - v32) ^ (v32 >> 5);
  v34 = v31 - v32 - v33;
  v35 = (v33 - (v34 ^ (v33 >> 3)) - ((v32 - v33 - (v34 ^ (v33 >> 3))) ^ ((v34 ^ (v33 >> 3)) << 10)))
      ^ (((v32 - v33 - (v34 ^ (v33 >> 3))) ^ ((v34 ^ (v33 >> 3)) << 10)) >> 15);
  if ( dword_6A6E0 )
  {
    v36 = *(_DWORD **)(dword_6A6E0 + 68);
    v37 = *(_DWORD *)(*v36 + 12 * ((v36[1] - 1) & v35));
    if ( v37 )
    {
      v38 = -v36[5];
      v39 = v37 - v36[5];
      if ( v39 )
      {
        while ( v35 != *(_DWORD *)(v39 + 96)
             || v12 != *(_DWORD *)(v39 + 92)
             || memcmp(*(const void **)(v39 + 88), s, v12) )
        {
          v40 = *(_DWORD *)(v39 + 84);
          if ( v40 )
          {
            v39 = v40 + v38;
            if ( v40 + v38 )
              continue;
          }
          goto LABEL_55;
        }
        if ( pthread_rwlock_unlock(&stru_6A6C0) )
          goto LABEL_232;
        off_67ED8();
        if ( !memcmp(v161 + 136, s2, 0x20u) )
        {
          v162 = 1;
        }
        else
        {
          if ( !memcmp(s2, &unk_6A6EC, 0x20u) )
          {
            if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
            {
              snprintf((char *)v172, 0x800u, "Pool %d now up to date at height %d", *v161, v168);
              sub_20F58(6, (const char *)v172, 0);
            }
            v162 = 1;
            sub_254E8(v161 + 136, s2, 0x20u, (int)"cgminer.c", (int)"test_work_current", 5721);
            goto LABEL_46;
          }
          v41 = (unsigned __int8)byte_68BD5;
          if ( byte_68BD5 )
          {
            if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
            {
              snprintf((char *)v172, 0x800u, "Stale data from pool %d at height %d", *v161, v168);
              sub_20F58(7, (const char *)v172, 0);
              goto LABEL_46;
            }
            v41 = 0;
          }
          v162 = v41;
        }
LABEL_46:
        if ( v7[280] )
        {
          v139 = (unsigned int)(dword_68FD0 - 3) > 1;
          *((_DWORD *)v7 + 84) = ++dword_691AC;
          if ( !v139 || (v142 = *((_DWORD *)v7 + 65), v142 == sub_31FF4()) )
          {
            if ( v7[284] )
            {
              if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
              {
                snprintf((char *)v172, 0x800u, "Stratum from pool %d requested work restart", *v161);
                sub_20F58(5, (const char *)v172, 0);
              }
            }
            else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
            {
              v154 = "";
              if ( v7[324] )
                v154 = "GBT ";
              snprintf(
                (char *)v172,
                0x800u,
                "%sLONGPOLL from pool %d requested work restart",
                v154,
                **((_DWORD **)v7 + 65));
              sub_20F58(5, (const char *)v172, 0);
            }
            sub_2E9E8();
          }
        }
        goto LABEL_54;
      }
    }
  }
LABEL_55:
  v42 = (char *)sub_22A44(0x68u, 1u, "cgminer.c", "block_exists", 5580);
  v43 = (int)v42;
  if ( !v42 )
  {
    strcpy((char *)v172, "block_exists OOM");
    sub_20F58(3, (const char *)v172, 1);
    sub_2E6B0(1, 1);
  }
  v44 = (unsigned __int16)&dword_766DC;
  strcpy(v42, s);
  v45 = dword_6A6E0;
  v46 = dword_766DC;
  *(_DWORD *)(v43 + 100) = dword_766DC;
  dword_766DC = v46 + 1;
  if ( !v45 || *(_DWORD *)(*(_DWORD *)(v45 + 68) + 12) <= 3u )
    goto LABEL_114;
  v47 = v45 + 68;
  v48 = 1;
  do
  {
    v49 = v47;
    v47 = 0;
    v50 = 0;
    v51 = 0;
    do
    {
      ++v51;
      if ( v48 )
      {
        v52 = *(_DWORD *)(v49 + 8);
        if ( v52 && (v53 = *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20), (v52 += v53) != 0) )
        {
          v54 = 1;
          do
          {
            if ( v54 == v48 )
            {
              v55 = v54;
              goto LABEL_68;
            }
            v52 = *(_DWORD *)(v52 + 8);
            ++v54;
            if ( !v52 )
              break;
            v52 += v53;
          }
          while ( v52 );
          v55 = v48;
        }
        else
        {
          v55 = v48;
          v54 = 1;
        }
      }
      else
      {
        v52 = v49;
        v55 = 0;
        v54 = 0;
      }
LABEL_68:
      v56 = v49;
      v49 = v52;
      while ( v54 )
      {
        v60 = v49 == 0;
        if ( v49 )
          v60 = v55 == 0;
        if ( v60 )
        {
          if ( v56 )
          {
            v44 = *(_DWORD *)(v56 + 8);
            if ( v44 )
              v44 += *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
            goto LABEL_91;
          }
        }
        else
        {
          v44 = *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
          if ( *(_DWORD *)(v56 - v44 + 100) - *(_DWORD *)(v49 - v44 + 100) > 0 )
          {
            v58 = *(_DWORD *)(v49 + 8);
            if ( v58 )
              v58 += v44;
LABEL_78:
            --v55;
            if ( !v50 )
            {
              v50 = v49;
              v49 = v58;
              goto LABEL_205;
            }
            v44 = v49 - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
            *(_DWORD *)(v50 + 8) = v44;
            if ( !v49 )
            {
              v50 = 0;
              v49 = v58;
              continue;
            }
            goto LABEL_82;
          }
          if ( v56 )
          {
            v144 = *(_DWORD *)(v56 + 8);
            if ( v144 )
              v44 += v144;
            else
              v44 = 0;
            goto LABEL_91;
          }
        }
        v44 = v56;
LABEL_91:
        --v54;
        if ( !v50 )
        {
          v50 = v56;
          v56 = v44;
LABEL_205:
          v47 = v50;
          if ( v50 )
          {
            v44 = 0;
            goto LABEL_83;
          }
          continue;
        }
        if ( !v56 )
        {
          *(_DWORD *)(v50 + 8) = 0;
          v50 = 0;
          v56 = v44;
          continue;
        }
        v58 = v49;
        v49 = v56;
        v61 = v56 - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
        v56 = v44;
        *(_DWORD *)(v50 + 8) = v61;
LABEL_82:
        v44 = v50 - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
        v50 = v49;
        v49 = v58;
LABEL_83:
        *(_DWORD *)(v50 + 4) = v44;
      }
      v57 = v55 == 0;
      if ( v55 )
        v57 = v49 == 0;
      if ( !v57 )
      {
        v58 = *(_DWORD *)(v49 + 8);
        v59 = v58 == 0;
        if ( v58 )
          v44 = *(_DWORD *)(v45 + 68);
        else
          v58 = v54;
        if ( !v59 )
        {
          v44 = *(_DWORD *)(v44 + 20);
          v58 += v44;
        }
        goto LABEL_78;
      }
    }
    while ( v49 );
    if ( v50 )
      *(_DWORD *)(v50 + 8) = 0;
    if ( v51 <= 1 )
      goto LABEL_101;
    v48 *= 2;
  }
  while ( v47 );
  v50 = 0;
LABEL_101:
  *(_DWORD *)(*(_DWORD *)(v45 + 68) + 16) = v50;
  v62 = v47 - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
  v63 = *(_DWORD *)(v62 + 72);
  dword_6A6E0 = v62;
  v163 = *(_DWORD *)(v62 + 100);
  if ( v63 )
  {
    v64 = *(_DWORD *)(v62 + 68);
    v65 = v62 + 68;
    v66 = *(_DWORD *)(v64 + 20);
    if ( v62 != *(_DWORD *)(v64 + 16) - v66 )
      goto LABEL_103;
LABEL_261:
    *(_DWORD *)(v64 + 16) = v63 + v66;
    v63 = *(_DWORD *)(v62 + 72);
    if ( !v63 )
    {
      v67 = *(_DWORD *)(v62 + 76);
      goto LABEL_264;
    }
    v66 = *(_DWORD *)(*(_DWORD *)(v62 + 68) + 20);
LABEL_103:
    v45 = v62;
    *(_DWORD *)(v63 + v66 + 8) = *(_DWORD *)(v62 + 76);
    v67 = *(_DWORD *)(v62 + 76);
LABEL_104:
    v68 = *(_DWORD **)(v45 + 68);
    if ( v67 )
    {
      *(_DWORD *)(v67 + v68[5] + 4) = *(_DWORD *)(v62 + 72);
      v68 = *(_DWORD **)(v45 + 68);
    }
    v69 = 12 * (*(_DWORD *)(v62 + 96) & (v68[1] - 1));
    --*(_DWORD *)(*v68 + v69 + 4);
    v70 = **(_DWORD **)(v45 + 68);
    if ( *(_DWORD *)(v70 + v69) == v65 )
      *(_DWORD *)(v70 + v69) = *(_DWORD *)(v62 + 84);
    v71 = *(_QWORD *)(v62 + 80);
    if ( (_DWORD)v71 )
    {
      *(_DWORD *)(v71 + 16) = HIDWORD(v71);
      HIDWORD(v71) = *(_DWORD *)(v62 + 84);
    }
    if ( HIDWORD(v71) )
      *(_DWORD *)(HIDWORD(v71) + 12) = *(_DWORD *)(v62 + 80);
    --*(_DWORD *)(*(_DWORD *)(v45 + 68) + 12);
  }
  else
  {
    v67 = *(_DWORD *)(v62 + 76);
    v64 = *(_DWORD *)(v62 + 68);
    if ( v67 )
    {
      v66 = *(_DWORD *)(v64 + 20);
      v65 = v62 + 68;
      if ( v62 == *(_DWORD *)(v64 + 16) - v66 )
        goto LABEL_261;
LABEL_264:
      v45 = v67;
      dword_6A6E0 = v67;
      goto LABEL_104;
    }
    v45 = 0;
    free(*(void **)v64);
    free(*(void **)(v62 + 68));
    dword_6A6E0 = 0;
  }
  free((void *)v62);
LABEL_114:
  LOWORD(v72) = 31161;
  v164 = strlen((const char *)v43);
  v73 = v164;
  if ( v164 <= 0xB )
  {
    HIWORD(v72) = -25033;
    v73 = v164;
    v89 = -17973521;
    v79 = (unsigned __int8 *)v43;
    v75 = v72;
  }
  else
  {
    HIWORD(v72) = -25033;
    v74 = (unsigned __int8 *)(v43 + 12);
    v166 = (char *)v43;
    v75 = v72;
    v76 = -17973521;
    do
    {
      v73 -= 12;
      v77 = *(v74 - 1);
      v78 = (*(v74 - 10) << 16) + (*(v74 - 11) << 8) + *(v74 - 12) + (*(v74 - 9) << 24);
      v79 = v74;
      v80 = (*(v74 - 2) << 16) + (*(v74 - 3) << 8) + *(v74 - 4);
      v81 = (*(v74 - 6) << 16) + (*(v74 - 7) << 8) + *(v74 - 8) + (*(v74 - 5) << 24) + v72;
      v74 += 12;
      v82 = v80 + (v77 << 24) + v76;
      v83 = (v78 - v81 - v82 + v75) ^ (v82 >> 13);
      v84 = (v81 - v82 - v83) ^ (v83 << 8);
      v85 = (v82 - v83 - v84) ^ (v84 >> 13);
      v86 = (v83 - v84 - v85) ^ (v85 >> 12);
      v87 = (v84 - v85 - v86) ^ (v86 << 16);
      v88 = (v85 - v86 - v87) ^ (v87 >> 5);
      v75 = (v86 - v87 - v88) ^ (v88 >> 3);
      v72 = (v87 - v88 - v75) ^ (v75 << 10);
      v76 = (v88 - v75 - v72) ^ (v72 >> 15);
    }
    while ( v73 > 0xB );
    v89 = (v88 - v75 - v72) ^ (v72 >> 15);
    v43 = (int)v166;
  }
  v90 = v73 - 1;
  v91 = v89 + v164;
  switch ( v90 )
  {
    case 0u:
      goto LABEL_129;
    case 1u:
      goto LABEL_128;
    case 2u:
      goto LABEL_127;
    case 3u:
      goto LABEL_126;
    case 4u:
      goto LABEL_125;
    case 5u:
      goto LABEL_124;
    case 6u:
      goto LABEL_123;
    case 7u:
      goto LABEL_122;
    case 8u:
      goto LABEL_121;
    case 9u:
      goto LABEL_120;
    case 0xAu:
      v91 += v79[10] << 24;
LABEL_120:
      v91 += v79[9] << 16;
LABEL_121:
      v91 += v79[8] << 8;
LABEL_122:
      v72 += v79[7] << 24;
LABEL_123:
      v72 += v79[6] << 16;
LABEL_124:
      v72 += v79[5] << 8;
LABEL_125:
      v72 += v79[4];
LABEL_126:
      v75 += v79[3] << 24;
LABEL_127:
      v75 += v79[2] << 16;
LABEL_128:
      v75 += v79[1] << 8;
LABEL_129:
      v75 += *v79;
      break;
    default:
      break;
  }
  *(_DWORD *)(v43 + 88) = v43;
  v92 = (v75 - v72 - v91) ^ (v91 >> 13);
  v93 = (v72 - v91 - v92) ^ (v92 << 8);
  v94 = (v91 - v92 - v93) ^ (v93 >> 13);
  v95 = (v92 - v93 - v94) ^ (v94 >> 12);
  v96 = (v93 - v94 - v95) ^ (v95 << 16);
  v97 = (v94 - v95 - v96) ^ (v96 >> 5);
  v98 = v95 - v96 - v97;
  v99 = (v97 - (v98 ^ (v97 >> 3)) - ((v96 - v97 - (v98 ^ (v97 >> 3))) ^ ((v98 ^ (v97 >> 3)) << 10)))
      ^ (((v96 - v97 - (v98 ^ (v97 >> 3))) ^ ((v98 ^ (v97 >> 3)) << 10)) >> 15);
  *(_DWORD *)(v43 + 96) = v99;
  *(_DWORD *)(v43 + 92) = strlen((const char *)v43);
  if ( v45 )
  {
    v100 = *(_DWORD *)(v45 + 68);
    *(_DWORD *)(v43 + 76) = 0;
    v101 = v43 + 68;
    *(_DWORD *)(v43 + 68) = v100;
    *(_DWORD *)(v43 + 72) = *(_DWORD *)(*(_DWORD *)(v45 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v45 + 68) + 16) + 8) = v43;
    *(_DWORD *)(*(_DWORD *)(v45 + 68) + 16) = v43 + 68;
    goto LABEL_132;
  }
  *(_DWORD *)(v43 + 76) = 0;
  *(_DWORD *)(v43 + 72) = 0;
  dword_6A6E0 = v43;
  v155 = malloc(0x2Cu);
  *(_DWORD *)(v43 + 68) = v155;
  if ( !v155 )
    goto LABEL_270;
  memset(v155, 0, 0x2Cu);
  v101 = v43 + 68;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 16) = v43 + 68;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 4) = 32;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 8) = 5;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 20) = 68;
  v156 = *(void ***)(v43 + 68);
  *v156 = malloc(0x180u);
  v157 = **(void ***)(v43 + 68);
  if ( !v157 )
    goto LABEL_270;
  memset(v157, 0, 0x180u);
  v45 = v43;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 40) = -1609490463;
LABEL_132:
  ++*(_DWORD *)(*(_DWORD *)(v45 + 68) + 12);
  v102 = *(_QWORD *)*(_DWORD *)(v45 + 68);
  v103 = 12 * (v99 & (HIDWORD(v102) - 1));
  ++*(_DWORD *)(v102 + v103 + 4);
  LODWORD(v102) = *(_DWORD *)(**(_DWORD **)(v45 + 68) + v103);
  *(_DWORD *)(v43 + 80) = 0;
  *(_DWORD *)(v43 + 84) = v102;
  LODWORD(v102) = **(_DWORD **)(v45 + 68);
  v104 = *(_DWORD *)(v102 + v103);
  v105 = (int *)(v102 + v103);
  if ( v104 )
  {
    *(_DWORD *)(v104 + 12) = v101;
    v105 = (int *)(**(_DWORD **)(v45 + 68) + v103);
  }
  *v105 = v101;
  v106 = *(_QWORD *)(**(_DWORD **)(v45 + 68) + v103 + 4);
  if ( (unsigned int)v106 >= 10 * (HIDWORD(v106) + 1) )
  {
    v107 = *(_DWORD *)(v43 + 68);
    if ( *(_DWORD *)(v107 + 36) != 1 )
    {
      v124 = calloc(24 * *(_DWORD *)(v107 + 4), 1u);
      if ( v124 )
      {
        v125 = *(_DWORD *)(v43 + 68);
        v126 = 0;
        *(_DWORD *)(v125 + 24) = (((2 * *(_DWORD *)(v125 + 4) - 1) & *(_DWORD *)(v125 + 12)) != 0)
                               + (*(_DWORD *)(v125 + 12) >> (*(_BYTE *)(v125 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(v43 + 68) + 28) = 0;
        v127 = *(_DWORD *)(v43 + 68);
        v128 = *(_DWORD *)(v127 + 4);
        if ( v128 )
        {
          v165 = 0;
          v167 = v7;
          do
          {
            v129 = *(_DWORD **)(*(_DWORD *)v127 + v126);
            if ( v129 )
            {
              while ( 1 )
              {
                v130 = (_DWORD *)v129[4];
                v131 = 3 * ((2 * v128 - 1) & v129[7]);
                v132 = (char *)&v124[v131];
                v133 = *((_DWORD *)v132 + 1) + 1;
                *((_DWORD *)v132 + 1) = v133;
                v134 = *(_DWORD *)(v43 + 68);
                if ( v133 > *(_DWORD *)(v134 + 24) )
                {
                  ++*(_DWORD *)(v134 + 28);
                  *((_DWORD *)v132 + 2) = *((_DWORD *)v132 + 1) / *(_DWORD *)(*(_DWORD *)(v43 + 68) + 24);
                }
                v129[3] = 0;
                v129[4] = v124[v131];
                v135 = v124[v131];
                if ( v135 )
                  *(_DWORD *)(v135 + 12) = v129;
                v124[v131] = v129;
                v127 = *(_DWORD *)(v43 + 68);
                if ( !v130 )
                  break;
                v128 = *(_DWORD *)(v127 + 4);
                v129 = v130;
              }
              v128 = *(_DWORD *)(v127 + 4);
            }
            v126 += 12;
            ++v165;
          }
          while ( v165 < v128 );
          v7 = v167;
        }
        free(*(void **)v127);
        *(_DWORD *)(*(_DWORD *)(v43 + 68) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(v43 + 68) + 8);
        **(_DWORD **)(v43 + 68) = v124;
        v136 = *(_DWORD **)(v43 + 68);
        v137 = v136[7];
        v138 = v136[3];
        v139 = v137 > v138 >> 1;
        if ( v137 <= v138 >> 1 )
          v140 = 0;
        else
          v140 = v136[8];
        if ( v139 )
          ++v140;
        v136[8] = v140;
        v141 = *(_DWORD *)(v43 + 68);
        if ( *(_DWORD *)(v141 + 32) > 1u )
          *(_DWORD *)(v141 + 36) = 1;
        goto LABEL_136;
      }
LABEL_270:
      exit(-1);
    }
  }
LABEL_136:
  v108 = 8 * (29 - (unsigned __int8)v7[72]);
  v109 = bswap32(*((_DWORD *)v7 + 18)) & 0xFFFFFF;
  if ( v108 < 8 )
    LOBYTE(v108) = 8;
  v110 = 32 - v108;
  v111 = 0xFFFF << (v108 - 32);
  LODWORD(v112) = 0xFFFF << v108;
  HIDWORD(v112) = v111 | (0xFFFFu >> v110);
  LODWORD(v113) = sub_4A10C(v112);
  v114 = v113 / (double)v109;
  if ( v114 != dbl_68748 )
  {
    sub_2AEF8((unsigned __int64)v114, byte_6A6E4, 8u, 0);
    dbl_68748 = v114;
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
    {
      snprintf((char *)v172, 0x800u, "Network diff set to %s", byte_6A6E4);
      sub_20F58(5, (const char *)v172, 0);
    }
  }
  if ( v163 && byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf((char *)v172, 0x800u, "Deleted block %d from database", v163);
    sub_20F58(7, (const char *)v172, 0);
  }
  if ( pthread_rwlock_unlock(&stru_6A6C0) )
  {
LABEL_232:
    v153 = _errno_location();
    snprintf(
      (char *)v172,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v153,
      "cgminer.c",
      "block_exists",
      5614);
    goto LABEL_203;
  }
  off_67ED8();
  if ( pthread_mutex_lock(&stru_74504) )
  {
    v158 = _errno_location();
    snprintf(
      (char *)v172,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v158,
      "cgminer.c",
      "set_curblock",
      5521);
    goto LABEL_203;
  }
  if ( pthread_rwlock_wrlock(&stru_7451C) )
  {
    v159 = _errno_location();
    snprintf(
      (char *)v172,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v159,
      "cgminer.c",
      "set_curblock",
      5521);
    goto LABEL_203;
  }
  sub_239A4((struct timeval *)&dword_755F0);
  strcpy(byte_73324, s);
  sub_254E8(&unk_6A6EC, s2, 0x20u, (int)"cgminer.c", (int)"set_curblock", 5524);
  v115 = dword_755F4;
  v172[0] = dword_755F0;
  v116 = localtime(v172);
  snprintf(byte_6A70C, 0x20u, "[%02d:%02d:%02d.%03d]", v116->tm_hour, v116->tm_min, v116->tm_sec, v115 / 1000);
  if ( pthread_rwlock_unlock(&stru_7451C) )
  {
    v143 = _errno_location();
    snprintf(
      (char *)v172,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v143,
      "cgminer.c",
      "set_curblock",
      5526);
    goto LABEL_203;
  }
  v117 = pthread_mutex_unlock(&stru_74504);
  if ( v117 )
  {
    v160 = *_errno_location();
    snprintf(
      (char *)v172,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      v160,
      "cgminer.c",
      "set_curblock",
      5526);
LABEL_203:
    sub_20F58(3, (const char *)v172, 1);
    sub_2E6B0(1, 1);
  }
  off_67ED8();
  v118 = byte_73324;
  do
  {
    v119 = (unsigned __int8)*v118++;
    if ( v119 != 48 )
      break;
    ++v117;
  }
  while ( v117 != 57 );
  strncpy(dest, &byte_73324[v117], 8u);
  byte_6A734 = 0;
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
  {
    snprintf((char *)v172, 0x800u, "New block: %s... diff %s", byte_73324, byte_6A6E4);
    sub_20F58(6, (const char *)v172, 0);
  }
  if ( v163 && byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf((char *)v172, 0x800u, "Deleted block %d from database", v163);
    sub_20F58(7, (const char *)v172, 0);
  }
  sub_254E8(v161 + 136, s2, 0x20u, (int)"cgminer.c", (int)"test_work_current", 5671);
  if ( dword_766DC != 1 )
  {
    v120 = (unsigned __int8)v7[280];
    *((_DWORD *)v7 + 84) = ++dword_691AC;
    if ( v120 )
    {
      if ( v7[284] )
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
        {
          v121 = "Stratum from pool %d detected new block at height %d";
          v122 = v168;
          v123 = (char *)*v161;
          goto LABEL_170;
        }
      }
      else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
      {
        v123 = "";
        v122 = **((_DWORD **)v7 + 65);
        v121 = "%sLONGPOLL from pool %d detected new block";
        if ( v7[324] )
          v123 = "GBT ";
LABEL_170:
        snprintf((char *)v172, 0x800u, v121, v123, v122);
        sub_20F58(5, (const char *)v172, 0);
      }
    }
    else if ( byte_74502 )
    {
      if ( !*((_BYTE *)v161 + 900) && (byte_74500 || byte_68BD4 || dword_67DB4 > 4) )
      {
        strcpy((char *)v172, "New block detected on network before pool notification");
        sub_20F58(5, (const char *)v172, 0);
      }
    }
    else if ( !*((_BYTE *)v161 + 900) && (byte_74500 || byte_68BD4 || dword_67DB4 > 4) )
    {
      strcpy((char *)v172, "New block detected on network");
      sub_20F58(5, (const char *)v172, 0);
    }
    sub_2E9E8();
    v162 = 1;
  }
LABEL_54:
  v7[280] = 0;
  return v162;
}
// 3A830: control flows out of bounds to 3A834
// 3AF84: control flows out of bounds to 3AF88
// 3B1CC: variable 'v113' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68748: using guessed type double dbl_68748;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 68FD0: using guessed type int dword_68FD0;
// 691AC: using guessed type int dword_691AC;
// 6A6E0: using guessed type int dword_6A6E0;
// 6A734: using guessed type char byte_6A734;
// 74500: using guessed type char byte_74500;
// 74502: using guessed type char byte_74502;
// 74504: using guessed type pthread_mutex_t stru_74504;
// 755F0: using guessed type int dword_755F0;
// 755F4: using guessed type int dword_755F4;
// 766DC: using guessed type int dword_766DC;

//----- (0003BECC) --------------------------------------------------------
int __fastcall sub_3BECC(_DWORD *a1)
{
  int v2; // r9
  pthread_t v3; // r0
  int v4; // r10
  int v5; // r0
  fd_set *v6; // r3
  int v7; // r3
  int v8; // r2
  bool v9; // nf
  int v10; // r1
  void ***v11; // r2
  int v12; // r0
  char *v13; // r4
  int v15; // r3
  int v16; // r2
  int v17; // r4
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  int v20; // r5
  _DWORD *v21; // r3
  unsigned int *v22; // r3
  unsigned int v23; // r2
  unsigned int v24; // r2
  void **v25; // r0
  void **v26; // r0
  char *v27; // r5
  int *v28; // r0
  const char *v29; // lr
  int v30; // r3
  int v31; // r12
  int *v32; // r0
  int *v33; // r0
  const char *v34; // lr
  int v35; // r3
  int v36; // r12
  int *v37; // r0
  int *v38; // r0
  int *v39; // r0
  int v40; // r5
  void **v41; // r11
  unsigned int v42; // r3
  unsigned int v43; // r2
  unsigned int v44; // r1
  int v45; // r3
  unsigned int v46; // r2
  unsigned int v47; // r1
  int v48; // r3
  unsigned int v49; // r3
  int v50; // r2
  int v51; // r1
  int v52; // r6
  int v53; // r7
  int v54; // r10
  _DWORD *v55; // r9
  char *v56; // r5
  unsigned int v57; // r4
  int v58; // r7
  int v59; // r3
  _DWORD *v60; // r5
  int v61; // r3
  int **v62; // r2
  int *v63; // r1
  int v64; // r3
  int v65; // r1
  int v66; // r1
  int v67; // r3
  int v68; // r6
  int v69; // r5
  time_t v70; // r0
  int v71; // r3
  int v72; // r0
  void ***v73; // r2
  int v74; // t1
  double v75; // d0
  unsigned int v76; // r6
  char *v77; // r12
  _DWORD *v78; // r6
  unsigned int v79; // r3
  unsigned int v80; // r12
  double v81; // d5
  unsigned int v82; // kr00_4
  int v83; // r3
  int v84; // r2
  double v85; // d7
  double v86; // d5
  double v87; // d7
  size_t v88; // r0
  size_t v89; // lr
  double v90; // r0
  _DWORD *v91; // r3
  unsigned int *v92; // r3
  unsigned int v93; // r2
  unsigned int v94; // r2
  double v95; // d8
  unsigned int v96; // r0
  __int64 v97; // kr18_8
  double v98; // d6
  double v99; // d7
  unsigned int v100; // kr08_4
  double v101; // d6
  int v102; // r3
  int v103; // r2
  double v104; // d7
  int v105; // r2
  int v106; // r3
  _DWORD *v107; // r0
  const char *v108; // r0
  int *v109; // r0
  int v110; // r1
  int *v111; // r0
  unsigned int v112; // kr0C_4
  int v113; // r0
  unsigned __int64 v114; // kr20_8
  double v115; // d5
  double v116; // d7
  double v117; // d5
  double v118; // d7
  int v119; // r2
  time_t v120; // r0
  int v121; // r3
  int *v122; // r0
  int v123; // [sp+4h] [bp-A78h]
  _DWORD *v124; // [sp+20h] [bp-A5Ch]
  _DWORD *v125; // [sp+30h] [bp-A4Ch]
  char *v126; // [sp+30h] [bp-A4Ch]
  int v127; // [sp+30h] [bp-A4Ch]
  time_t *timer; // [sp+34h] [bp-A48h]
  time_t *timera; // [sp+34h] [bp-A48h]
  int v130; // [sp+38h] [bp-A44h]
  int v131; // [sp+38h] [bp-A44h]
  _DWORD *ptr; // [sp+40h] [bp-A3Ch]
  void *ptra; // [sp+40h] [bp-A3Ch]
  int v134; // [sp+44h] [bp-A38h]
  int s2; // [sp+48h] [bp-A34h] BYREF
  struct timeval timeout; // [sp+4Ch] [bp-A30h] BYREF
  char s[16]; // [sp+54h] [bp-A28h] BYREF
  char v138[20]; // [sp+64h] [bp-A18h] BYREF
  __int16 v139; // [sp+78h] [bp-A04h] BYREF
  __int16 v140; // [sp+7Ah] [bp-A02h] BYREF
  char v141[36]; // [sp+98h] [bp-9E4h] BYREF
  char v142[60]; // [sp+BCh] [bp-9C0h] BYREF
  char v143; // [sp+F8h] [bp-984h] BYREF
  fd_set readfds; // [sp+FCh] [bp-980h] BYREF
  int v145[23]; // [sp+17Ch] [bp-900h] BYREF
  char v146[160]; // [sp+1D8h] [bp-8A4h] BYREF
  void **v147[513]; // [sp+278h] [bp-804h] BYREF

  v2 = -1622558010;
  v3 = pthread_self();
  pthread_detach(v3);
  v4 = -17973517;
  snprintf(s, 0x10u, "%d/RStratum", *a1);
  sub_250A8(s);
  do
  {
LABEL_2:
    v5 = (int)a1;
    if ( *((_BYTE *)a1 + 105) )
    {
LABEL_17:
      sub_24340(v5);
      return 0;
    }
    while ( 1 )
    {
      if ( !sub_23F28(v5) && !sub_32424((int)a1) )
      {
        sub_24340((int)a1);
        sub_33DDC((int)a1);
        sub_33AB4(a1);
        if ( sub_32424((int)a1) )
          goto LABEL_65;
        while ( !a1[25] || a1 != (_DWORD *)sub_31FF4() && (unsigned int)(dword_68FD0 - 3) > 1 )
        {
          if ( pthread_mutex_lock(&stru_6910C) )
          {
            v38 = _errno_location();
            v29 = "wait_lpcurrent";
            v30 = *v38;
            v31 = 9913;
            goto LABEL_86;
          }
          pthread_cond_wait(&cond, &stru_6910C);
          if ( pthread_mutex_unlock(&stru_6910C) )
          {
            v39 = _errno_location();
            v34 = "wait_lpcurrent";
            v35 = *v39;
            v36 = 9915;
LABEL_90:
            snprintf(
              (char *)v147,
              0x800u,
              "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
              v35,
              "cgminer.c",
              v34,
              v36);
LABEL_87:
            sub_20F58(3, (const char *)v147, 1);
            sub_2E6B0(1, 1);
          }
          off_67ED8();
          if ( sub_32424((int)a1) )
            break;
        }
LABEL_65:
        while ( !sub_28690((int)a1) )
        {
          sub_3466C((int)a1);
          if ( *((_BYTE *)a1 + 105) )
            return 0;
          sub_23B9C();
        }
      }
      v6 = (fd_set *)&v143;
      do
      {
        v6->__fds_bits[1] = 0;
        v6 = (fd_set *)((char *)v6 + 4);
      }
      while ( &readfds.__fds_bits[31] != (__fd_mask *)v6 );
      v7 = a1[147];
      timeout.tv_usec = 0;
      timeout.tv_sec = 90;
      v8 = v7 + 31;
      if ( v7 >= 0 )
        v8 = v7;
      v9 = -v7 < 0;
      v10 = -v7 & 0x1F;
      LOBYTE(v7) = v7 & 0x1F;
      v11 = &v147[(v8 >> 5) + 512];
      if ( !v9 )
        v7 = -v10;
      *(v11 - 607) = (void **)((unsigned int)*(v11 - 607) | (1 << v7));
      if ( !sub_23F28((int)a1) )
      {
        v12 = select(a1[147] + 1, &readfds, 0, 0, &timeout);
        if ( v12 <= 0 )
        {
          v15 = (unsigned __int8)byte_74500;
          if ( !byte_68BD5 )
            goto LABEL_29;
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
          {
            snprintf((char *)v147, 0x800u, "Stratum select failed on pool %d with value %d", *a1, v12);
            sub_20F58(7, (const char *)v147, 0);
            v15 = (unsigned __int8)byte_74500;
            goto LABEL_29;
          }
          goto LABEL_54;
        }
      }
      v13 = sub_24858((int)a1);
      if ( !v13 )
        break;
      sub_32400((int)a1);
      if ( sub_296BC(a1, (int)v13) )
        goto LABEL_14;
      v18 = sub_47258((int)v13, 0, (char *)v145);
      v124 = v18;
      if ( v18 )
      {
        v125 = (_DWORD *)sub_480FC(v18, "result");
        timer = (time_t *)sub_480FC(v124, "error");
        v19 = (_DWORD *)sub_480FC(v124, "id");
        v20 = (int)v19;
        if ( !v19 || *v19 == 7 )
        {
          if ( timer )
          {
            v27 = sub_45074(timer, 3);
          }
          else
          {
            v27 = (char *)malloc(0x11u);
            if ( v27 )
              strcpy(v27, "(unknown reason)");
          }
          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
          {
            snprintf((char *)v147, 0x800u, "JSON-RPC non method decode failed: %s", v27);
            sub_20F58(6, (const char *)v147, 0);
          }
          free(v27);
          if ( v124[1] != -1 )
            goto LABEL_50;
        }
        else
        {
          if ( sub_480FC(v125, "version-rolling.mask")
            || strstr(v13, "mining.configure")
            || strstr(v13, "mining.set_version_mask") )
          {
            goto LABEL_49;
          }
          v40 = sub_4888C(v20);
          s2 = v40;
          if ( pthread_mutex_lock(&stru_690F0) )
            sub_2EFE0("parse_stratum_response", 7292);
          v41 = (void **)dword_69108;
          v42 = ((v40 & 0xFF0000FF) + 17973517 + (v40 & 0xFF0000) + (v40 & 0xFF00)) ^ 0x7F76D;
          v43 = (v2 - v42) ^ (v42 << 8);
          v44 = (v4 - v42 - v43) ^ (v43 >> 13);
          v45 = (v42 - v43 - v44) ^ (v44 >> 12);
          v46 = (v43 - v44 - v45) ^ (v45 << 16);
          v47 = (v44 - v45 - v46) ^ (v46 >> 5);
          v48 = (v45 - v46 - v47) ^ (v47 >> 3);
          v49 = (v47 - v48 - ((v46 - v47 - v48) ^ (v48 << 10))) ^ (((v46 - v47 - v48) ^ (v48 << 10)) >> 15);
          if ( dword_69108 )
          {
            ptr = **(_DWORD ***)dword_69108;
            v50 = ptr[3 * ((*(_DWORD *)(*(_DWORD *)dword_69108 + 4) - 1) & v49)];
            if ( v50 )
            {
              v51 = *(_DWORD *)(*(_DWORD *)dword_69108 + 20);
              v52 = -v51;
              v134 = v51;
              v53 = v50 - v51;
              if ( v50 != v51 )
              {
                v130 = v4;
                v54 = v2;
                v55 = *(_DWORD **)dword_69108;
                v56 = v13;
                v57 = v49;
                while ( v57 != *(_DWORD *)(v53 + 28)
                     || *(_DWORD *)(v53 + 24) != 4
                     || memcmp(*(const void **)(v53 + 20), &s2, 4u) )
                {
                  v58 = *(_DWORD *)(v53 + 16);
                  if ( v58 )
                  {
                    v53 = v58 + v52;
                    if ( v53 )
                      continue;
                  }
                  v2 = v54;
                  v4 = v130;
                  v13 = v56;
                  goto LABEL_181;
                }
                v59 = *(_DWORD *)(v53 + 4);
                v13 = v56;
                v60 = v55;
                v2 = v54;
                v4 = v130;
                if ( v59 )
                {
                  if ( v53 != v60[4] + v52 )
                    goto LABEL_108;
LABEL_214:
                  v60[4] = v59 + v134;
                  v59 = *(_DWORD *)(v53 + 4);
                  if ( !v59 )
                  {
                    v105 = *(_DWORD *)(v53 + 8);
                    goto LABEL_211;
                  }
                  v60 = *v41;
LABEL_108:
                  *(_DWORD *)(v59 + v60[5] + 8) = *(_DWORD *)(v53 + 8);
LABEL_109:
                  v61 = *(_DWORD *)(v53 + 8);
                  v62 = (int **)dword_69108;
                  v63 = *(int **)dword_69108;
                  if ( v61 )
                  {
                    *(_DWORD *)(v61 + v63[5] + 4) = *(_DWORD *)(v53 + 4);
                    v63 = *v62;
                  }
                  v64 = 12 * ((v63[1] - 1) & *(_DWORD *)(v53 + 28));
                  --*(_DWORD *)(*v63 + v64 + 4);
                  v65 = **v62;
                  if ( *(_DWORD *)(v65 + v64) == v53 )
                    *(_DWORD *)(v65 + v64) = *(_DWORD *)(v53 + 16);
                  v66 = *(_DWORD *)(v53 + 12);
                  v67 = *(_DWORD *)(v53 + 16);
                  if ( v66 )
                  {
                    *(_DWORD *)(v66 + 16) = v67;
                    v67 = *(_DWORD *)(v53 + 16);
                  }
                  if ( v67 )
                    *(_DWORD *)(v67 + 12) = *(_DWORD *)(v53 + 12);
                  --(*v62)[3];
                }
                else
                {
                  v105 = *(_DWORD *)(v53 + 8);
                  if ( v105 )
                  {
                    if ( v53 == v60[4] + v52 )
                      goto LABEL_214;
LABEL_211:
                    dword_69108 = v105;
                    goto LABEL_109;
                  }
                  free(ptr);
                  free(*v41);
                  dword_69108 = 0;
                }
                --a1[183];
                v68 = pthread_mutex_unlock(&stru_690F0);
                if ( v68 )
                  goto LABEL_212;
                off_67ED8();
                v69 = *(_DWORD *)(v53 + 36);
                v70 = time(0);
                v71 = (unsigned __int8)byte_68BD5;
                v72 = v70 - *(_DWORD *)(v53 + 48);
                if ( v72 > 0 )
                  v71 = (unsigned __int8)byte_68BD5 | 1;
                if ( v71 && (byte_74500 || byte_68BD4 || dword_67DB4 > 5) )
                {
                  snprintf(
                    (char *)v147,
                    0x800u,
                    "Pool %d stratum share result lag time %d seconds",
                    **(_DWORD **)(v69 + 260),
                    v72);
                  sub_20F58(6, (const char *)v147, 0);
                }
                v73 = v147;
                v147[0] = (void **)bswap32(*(_DWORD *)(v69 + 220));
                v147[1] = (void **)bswap32(*(_DWORD *)(v69 + 216));
                v147[2] = (void **)bswap32(*(_DWORD *)(v69 + 212));
                v147[3] = (void **)bswap32(*(_DWORD *)(v69 + 208));
                v147[4] = (void **)bswap32(*(_DWORD *)(v69 + 204));
                v147[5] = (void **)bswap32(*(_DWORD *)(v69 + 200));
                v147[6] = (void **)bswap32(*(_DWORD *)(v69 + 196));
                v147[7] = (void **)bswap32(*(_DWORD *)(v69 + 192));
                do
                {
                  v74 = *(unsigned __int8 *)v73;
                  v73 = (void ***)((char *)v73 + 1);
                  if ( v74 )
                    break;
                  ++v68;
                }
                while ( v68 != 29 );
                v75 = *(double *)(v69 + 376);
                v76 = bswap32(*(unsigned int *)((char *)v147 + v68));
                round();
                sub_2AEF8(*(_QWORD *)(v69 + 232), v141, 0x10u, 0);
                if ( *(_BYTE *)(v69 + 283) )
                  v77 = " BLOCK!";
                else
                  v77 = "";
                snprintf(v142, 0x40u, "%08lx Diff %s/%llu%s", v76, v141, v123, (unsigned __int64)v75, v77);
                v78 = *(_DWORD **)(v69 + 260);
                v131 = *(_DWORD *)(sub_31B04(*(_DWORD *)(v69 + 256)) + 36);
                if ( v125 && (*v125 == 5 || *(_BYTE *)(v69 + 324) && *v125 == 7) )
                {
                  if ( pthread_mutex_lock(&stru_766C4) )
                  {
                    v122 = _errno_location();
                    snprintf(
                      (char *)v147,
                      0x800u,
                      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                      *v122,
                      "cgminer.c",
                      "share_result",
                      3528);
                    goto LABEL_87;
                  }
                  v112 = qword_755D8;
                  v113 = *(_DWORD *)(v131 + 36) + 1;
                  LODWORD(qword_755D8) = qword_755D8 + 1;
                  v114 = __PAIR64__(HIDWORD(qword_755D8), v112) + 1;
                  *(_DWORD *)(v131 + 36) = v113;
                  HIDWORD(qword_755D8) = HIDWORD(v114);
                  v115 = dbl_73370;
                  ++*((_QWORD *)v78 + 1);
                  *(double *)(v131 + 200) = *(double *)(v131 + 200) + *(double *)(v69 + 376);
                  v116 = *(double *)(v69 + 376);
                  v117 = v115 + v116;
                  v118 = *((double *)v78 + 9) + v116;
                  dbl_73370 = v117;
                  *((double *)v78 + 9) = v118;
                  if ( pthread_mutex_unlock(&stru_766C4) )
                  {
                    v109 = _errno_location();
                    v110 = 3538;
                    goto LABEL_226;
                  }
                  off_67ED8();
                  v119 = *v78;
                  v78[6] = 0;
                  *(_DWORD *)(v131 + 216) = v119;
                  v120 = time(0);
                  v121 = (unsigned __int8)byte_68BD5;
                  *(_DWORD *)(v131 + 220) = v120;
                  *(_QWORD *)(v131 + 224) = *(_QWORD *)(v69 + 376);
                  v78[88] = v120;
                  *((_QWORD *)v78 + 45) = *(_QWORD *)(v69 + 376);
                  if ( v121 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                  {
                    strcpy((char *)v147, "PROOF OF WORK RESULT: true (yay!!!)");
                    sub_20F58(7, (const char *)v147, 0);
                  }
                  if ( !byte_73378 && !byte_7559C )
                  {
                    if ( dword_733CC <= 1 )
                    {
                      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
                      {
                        snprintf(
                          (char *)v147,
                          0x800u,
                          "Accepted %s %s %d %s%s",
                          v142,
                          *(const char **)(*(_DWORD *)(v131 + 4) + 8),
                          *(_DWORD *)(v131 + 8),
                          "",
                          "");
                        sub_20F58(5, (const char *)v147, 0);
                      }
                    }
                    else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
                    {
                      snprintf(
                        (char *)v147,
                        0x800u,
                        "Accepted %s %s %d pool %d %s%s",
                        v142,
                        *(const char **)(*(_DWORD *)(v131 + 4) + 8),
                        *(_DWORD *)(v131 + 8),
                        **(_DWORD **)(v69 + 260),
                        "",
                        "");
                      sub_20F58(5, (const char *)v147, 0);
                    }
                  }
                  sub_35A94("accept", (_DWORD *)v69);
                  if ( dword_69050 && (double)dword_69050 <= dbl_73370 )
                  {
                    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
                    {
                      snprintf(
                        (char *)v147,
                        0x800u,
                        "Successfully mined %d accepted shares as requested and exiting.",
                        dword_69050);
                      sub_20F58(4, (const char *)v147, 0);
                    }
                    sub_2E730();
                  }
                  if ( v78[25] == 2 )
                  {
                    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
                    {
                      snprintf((char *)v147, 0x800u, "Rejecting pool %d now accepting shares, re-enabling!", *v78);
                      sub_20F58(4, (const char *)v147, 0);
                    }
                    if ( v78[25] != 1 )
                      sub_2B664(v78 + 25);
                    sub_34178(0);
                  }
                  if ( *(_BYTE *)(v69 + 283) )
                    sub_2E9E8();
                }
                else
                {
                  if ( pthread_mutex_lock(&stru_766C4) )
                  {
                    v111 = _errno_location();
                    snprintf(
                      (char *)v147,
                      0x800u,
                      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                      *v111,
                      "cgminer.c",
                      "share_result",
                      3591);
                    goto LABEL_87;
                  }
                  v80 = HIDWORD(qword_767E8);
                  v79 = qword_767E8;
                  v81 = dbl_73390;
                  ++*(_DWORD *)(v131 + 40);
                  v82 = v79;
                  v83 = v78[4];
                  qword_767E8 = __PAIR64__(v80, v82) + 1;
                  v84 = v78[5];
                  v78[4] = v83 + 1;
                  v78[5] = __CFADD__(v83, 1) + v84;
                  *(double *)(v131 + 208) = *(double *)(v131 + 208) + *(double *)(v69 + 376);
                  v85 = *(double *)(v69 + 376);
                  v86 = v81 + v85;
                  v87 = *((double *)v78 + 10) + v85;
                  ++v78[6];
                  dbl_73390 = v86;
                  *((double *)v78 + 10) = v87;
                  if ( pthread_mutex_unlock(&stru_766C4) )
                  {
                    v109 = _errno_location();
                    v110 = 3599;
LABEL_226:
                    snprintf(
                      (char *)v147,
                      0x800u,
                      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                      *v109,
                      "cgminer.c",
                      "share_result",
                      v110);
                    goto LABEL_87;
                  }
                  off_67ED8();
                  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                  {
                    strcpy((char *)v147, "PROOF OF WORK RESULT: false (booooo)");
                    sub_20F58(7, (const char *)v147, 0);
                  }
                  if ( !byte_73378 && !byte_7559C )
                  {
                    strcpy(v141, "reject");
                    memset(&v141[7], (unsigned __int8)byte_7559C, 0x1Du);
                    LOBYTE(v139) = byte_7559C;
                    if ( dword_733CC > 1 )
                      snprintf(v138, 0x14u, "pool %d", **(_DWORD **)(v69 + 260));
                    else
                      v138[0] = byte_7559C;
                    if ( !*(_BYTE *)(v69 + 324) )
                      v125 = (_DWORD *)sub_480FC(v124, "reject-reason");
                    if ( v125 )
                    {
                      timera = sub_48630(v125);
                      v88 = strlen((const char *)timera);
                      if ( v88 >= 0x1C )
                        v89 = 28;
                      else
                        v89 = v88;
                      v139 = 10272;
                      ptra = (void *)v89;
                      v126 = (char *)&v147[512] + v89;
                      sub_254E8(&v140, timera, v89, (int)"cgminer.c", (int)"share_result", 3639);
                      *(v126 - 2558) = 41;
                      *(v126 - 2557) = 0;
                      sub_254E8(&v141[7], timera, (size_t)ptra, (int)"cgminer.c", (int)"share_result", 3644);
                      v141[6] = 58;
                      *(v126 - 2521) = 0;
                    }
                    else
                    {
                      if ( timer )
                        v106 = *(_BYTE *)(v69 + 284) & 1;
                      else
                        v106 = 0;
                      if ( v106 )
                      {
                        if ( *timer == 1 )
                        {
                          v107 = sub_48484(timer, 1u);
                          if ( !v107 || *v107 != 2 )
                            goto LABEL_155;
                        }
                        else
                        {
                          if ( *timer != 2 )
                            goto LABEL_155;
                          v107 = timer;
                        }
                        v108 = (const char *)sub_48630(v107);
                        snprintf((char *)&v139, 0x1Fu, " (%s)", v108);
                      }
                    }
LABEL_155:
                    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
                    {
                      snprintf(
                        (char *)v147,
                        0x800u,
                        "Rejected %s %s %d %s%s %s%s version 0x%x",
                        v142,
                        *(const char **)(*(_DWORD *)(v131 + 4) + 8),
                        *(_DWORD *)(v131 + 8),
                        v138,
                        (const char *)&v139,
                        "",
                        "",
                        *(_DWORD *)(v69 + 444));
                      sub_20F58(5, (const char *)v147, 0);
                    }
                    sub_35A94(v141, (_DWORD *)v69);
                  }
                  v127 = v78[6];
                  if ( v127 > 10 && !*(_BYTE *)(v69 + 281) )
                  {
                    if ( byte_766E0 )
                    {
                      if ( dword_74578 > 1 )
                      {
                        LODWORD(v90) = sub_4A11C(qword_755D8);
                        if ( (double)v127 > v90 / dbl_68720 * 60.0 * 3.0 )
                        {
                          if ( byte_74500 || byte_68BD4 || dword_67DB4 > 3 )
                          {
                            snprintf(
                              (char *)v147,
                              0x800u,
                              "Pool %d rejected %d sequential shares, disabling!",
                              *v78,
                              v127);
                            sub_20F58(4, (const char *)v147, 0);
                          }
                          if ( v78[25] == 1 )
                            --dword_74578;
                          v78[25] = 2;
                          if ( v78 == (_DWORD *)sub_31FF4() )
                            sub_34178(0);
                          v78[6] = 0;
                        }
                      }
                    }
                  }
                }
                sub_2CBA8((void ***)(v53 + 36), "cgminer.c", "parse_stratum_response", 7345);
                free((void *)v53);
                if ( v124[1] != -1 )
                {
                  v91 = v124;
                  __dmb(0xBu);
                  v92 = v91 + 1;
                  do
                  {
                    v93 = __ldrex(v92);
                    v94 = v93 - 1;
                  }
                  while ( __strex(v94, v92) );
                  if ( !v94 )
                    sub_48A34(v124);
                }
                goto LABEL_14;
              }
            }
          }
LABEL_181:
          if ( pthread_mutex_unlock(&stru_690F0) )
LABEL_212:
            sub_2F03C("parse_stratum_response", 7300);
          off_67ED8();
          if ( !v125 )
          {
LABEL_49:
            if ( v124[1] == -1 )
              goto LABEL_59;
LABEL_50:
            v21 = v124;
            __dmb(0xBu);
            v22 = v21 + 1;
            do
            {
              v23 = __ldrex(v22);
              v24 = v23 - 1;
            }
            while ( __strex(v24, v22) );
            if ( !v24 )
              sub_48A34(v124);
            goto LABEL_59;
          }
          if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
            sub_2EFE0("parse_stratum_response", 7312);
          if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
            sub_30138("parse_stratum_response", 7312);
          if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
            sub_2F03C("parse_stratum_response", 7312);
          v95 = *((double *)a1 + 228);
          sub_2FB80((pthread_rwlock_t *)(a1 + 59), "parse_stratum_response", 7314);
          if ( *v125 == 5 )
          {
            if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
            {
              snprintf((char *)v147, 0x800u, "Accepted untracked stratum share from pool %d", *a1);
              sub_20F58(5, (const char *)v147, 0);
            }
            if ( pthread_mutex_lock(&stru_766C4) )
              sub_2EFE0("parse_stratum_response", 7322);
            v101 = *((double *)a1 + 9) + v95;
            ++qword_755D8;
            v102 = a1[2];
            v103 = a1[3];
            v104 = dbl_73370 + v95;
            *((double *)a1 + 9) = v101;
            a1[2] = v102 + 1;
            a1[3] = __CFADD__(v102, 1) + v103;
            dbl_73370 = v104;
            if ( pthread_mutex_unlock(&stru_766C4) )
              sub_2F03C("parse_stratum_response", 7327);
          }
          else
          {
            if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
            {
              snprintf((char *)v147, 0x800u, "Rejected untracked stratum share from pool %d", *a1);
              sub_20F58(5, (const char *)v147, 0);
            }
            if ( pthread_mutex_lock(&stru_766C4) )
              sub_2EFE0("parse_stratum_response", 7333);
            v96 = a1[5];
            v97 = qword_767E8 + 1;
            v98 = *((double *)a1 + 10) + v95;
            v99 = dbl_73390 + v95;
            v100 = a1[4];
            LODWORD(qword_767E8) = qword_767E8 + 1;
            a1[4] = v100 + 1;
            *((double *)a1 + 10) = v98;
            a1[5] = (__PAIR64__(v96, v100) + 1) >> 32;
            HIDWORD(qword_767E8) = HIDWORD(v97);
            dbl_73390 = v99;
            if ( pthread_mutex_unlock(&stru_766C4) )
              sub_2F03C("parse_stratum_response", 7338);
          }
          off_67ED8();
          if ( v124[1] != -1 )
            goto LABEL_50;
        }
      }
      else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
      {
        snprintf((char *)v147, 0x800u, "JSON decode failed(%d): %s", v145[0], v146);
        sub_20F58(6, (const char *)v147, 0);
      }
LABEL_59:
      if ( !sub_23FF8(a1, (int)v13) )
      {
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
        {
          snprintf((char *)v147, 0x800u, "Unknown stratum msg: %s", v13);
          sub_20F58(6, (const char *)v147, 0);
        }
        goto LABEL_16;
      }
LABEL_14:
      if ( *((_BYTE *)a1 + 680) )
      {
        v25 = (void **)sub_2FD8C();
        *((_BYTE *)a1 + 680) = 0;
        v147[0] = v25;
        sub_360B0((int)a1, (int)v25);
        v26 = v147[0];
        *((_BYTE *)v147[0] + 280) = 1;
        sub_3A5D0((int)v26);
        sub_2CBA8(v147, "cgminer.c", "stratum_rthread", 7601);
      }
LABEL_16:
      free(v13);
      v5 = (int)a1;
      if ( *((_BYTE *)a1 + 105) )
        goto LABEL_17;
    }
    v15 = (unsigned __int8)byte_74500;
LABEL_29:
    if ( v15 || byte_68BD4 )
    {
LABEL_31:
      snprintf((char *)v147, 0x800u, "Stratum connection to pool %d interrupted", *a1);
      sub_20F58(5, (const char *)v147, 0);
      goto LABEL_32;
    }
LABEL_54:
    if ( dword_67DB4 > 4 )
      goto LABEL_31;
LABEL_32:
    v16 = dword_755D0;
    ++a1[32];
    dword_755D0 = v16 + 1;
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
    {
      v28 = _errno_location();
      v29 = "supports_resume";
      v30 = *v28;
      v31 = 7483;
LABEL_86:
      snprintf((char *)v147, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v30, "cgminer.c", v29, v31);
      goto LABEL_87;
    }
    if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v32 = _errno_location();
      snprintf(
        (char *)v147,
        0x800u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v32,
        "cgminer.c",
        "supports_resume",
        7483);
      goto LABEL_87;
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
    {
      v33 = _errno_location();
      v34 = "supports_resume";
      v35 = *v33;
      v36 = 7483;
      goto LABEL_90;
    }
    v17 = a1[159];
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v37 = _errno_location();
      snprintf(
        (char *)v147,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v37,
        "cgminer.c",
        "supports_resume",
        7485);
      goto LABEL_87;
    }
    off_67ED8();
    if ( !v17 || byte_75684 )
      sub_33DDC((int)a1);
    sub_33AB4(a1);
    if ( a1 == (_DWORD *)sub_31FF4() )
      sub_2E9E8();
  }
  while ( sub_28690((int)a1) );
  while ( 1 )
  {
    sub_3466C((int)a1);
    if ( *((_BYTE *)a1 + 105) )
      return 0;
    sub_23B9C();
    if ( sub_28690((int)a1) )
      goto LABEL_2;
  }
}
// 3CB80: variable 'v123' is possibly undefined
// 3CF88: variable 'v90' is possibly undefined
// 1225C: using guessed type int round(void);
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68720: using guessed type double dbl_68720;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 68FD0: using guessed type int dword_68FD0;
// 69050: using guessed type int dword_69050;
// 69108: using guessed type int dword_69108;
// 73370: using guessed type double dbl_73370;
// 73378: using guessed type char byte_73378;
// 73390: using guessed type double dbl_73390;
// 733CC: using guessed type int dword_733CC;
// 74500: using guessed type char byte_74500;
// 74578: using guessed type int dword_74578;
// 7559C: using guessed type char byte_7559C;
// 755D0: using guessed type int dword_755D0;
// 755D8: using guessed type __int64 qword_755D8;
// 75684: using guessed type char byte_75684;
// 766C4: using guessed type pthread_mutex_t stru_766C4;
// 766E0: using guessed type char byte_766E0;
// 767E8: using guessed type __int64 qword_767E8;

//----- (0003D93C) --------------------------------------------------------
int __fastcall sub_3D93C(int a1)
{
  pthread_mutex_t *v2; // r0
  int v3; // r0
  int v4; // r2
  int v5; // r4
  int v6; // r0
  unsigned int v7; // r3
  unsigned int v8; // r1
  int v9; // r0
  unsigned int v10; // r3
  unsigned int v11; // r1
  int v12; // r0
  unsigned int v13; // r5
  int v14; // r3
  int v15; // r7
  char *v16; // r8
  __int64 v17; // r2
  int v18; // r3
  int v19; // r1
  int *v20; // r2
  int v21; // r4
  __int64 v22; // r2
  int v23; // r5
  _DWORD *v24; // r7
  int v25; // r10
  int v26; // r0
  unsigned int v27; // r3
  char *v28; // r5
  unsigned int v29; // r4
  int v30; // r4
  char *v31; // r9
  unsigned int v32; // r3
  int v33; // r3
  _DWORD *v34; // r3
  unsigned int v35; // r2
  unsigned int v36; // r1
  bool v37; // cc
  int v38; // r2
  int v39; // r3
  int v40; // r6
  int v41; // r5
  char *v42; // r3
  _DWORD *v43; // r1
  unsigned int v44; // r7
  char *v45; // r12
  int v46; // lr
  int v47; // r2
  int v48; // lr
  char *v49; // r10
  bool v50; // zf
  int v51; // r12
  bool v52; // zf
  bool v53; // zf
  char *v54; // r11
  int v55; // r12
  char *v57; // r0
  void *v58; // r0
  int *v59; // r0
  int *v60; // r0
  unsigned int i; // [sp+14h] [bp-810h]
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf(s, 0x800u, "Pushing work from pool %d to hash queue", **(_DWORD **)(a1 + 260));
    sub_20F58(7, s, 0);
  }
  *(_DWORD *)(a1 + 336) = dword_691AC;
  sub_3A5D0(a1);
  v2 = (pthread_mutex_t *)dword_69010;
  ++*(_DWORD *)(*(_DWORD *)(a1 + 260) + 68);
  if ( pthread_mutex_lock(v2) )
  {
    v60 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v60, "cgminer.c", "hash_push", 5777);
LABEL_107:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  if ( !*(_BYTE *)(a1 + 273) && *(_DWORD *)(a1 + 276) )
    ++dword_69188;
  v3 = dword_755E0;
  v4 = *(unsigned __int8 *)(dword_755E0 + 8);
  if ( *(_BYTE *)(dword_755E0 + 8) )
    goto LABEL_95;
  v5 = dword_690EC;
  v6 = (*(unsigned __int8 *)(a1 + 340)
      + 17973517
      + (*(unsigned __int8 *)(a1 + 343) << 24)
      + (*(unsigned __int8 *)(a1 + 342) << 16)
      + (*(unsigned __int8 *)(a1 + 341) << 8))
     ^ 0x7F76D;
  v7 = (-1622558010 - v6) ^ (v6 << 8);
  *(_DWORD *)(a1 + 364) = a1 + 340;
  v8 = (-17973517 - v6 - v7) ^ (v7 >> 13);
  *(_DWORD *)(a1 + 368) = 4;
  v9 = (v6 - v7 - v8) ^ (v8 >> 12);
  v10 = (v7 - v8 - v9) ^ (v9 << 16);
  v11 = (v8 - v9 - v10) ^ (v10 >> 5);
  v12 = (v9 - v10 - v11) ^ (v11 >> 3);
  v13 = (v11 - v12 - ((v10 - v11 - v12) ^ (v12 << 10))) ^ (((v10 - v11 - v12) ^ (v12 << 10)) >> 15);
  *(_DWORD *)(a1 + 372) = v13;
  if ( v5 )
  {
    v14 = *(_DWORD *)(v5 + 344);
    v15 = a1 + 344;
    *(_DWORD *)(a1 + 352) = v4;
    *(_DWORD *)(a1 + 344) = v14;
    *(_DWORD *)(a1 + 348) = *(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) - *(_DWORD *)(*(_DWORD *)(v5 + 344) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) + 8) = a1;
    *(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) = a1 + 344;
    v16 = *(char **)(v5 + 344);
  }
  else
  {
    *(_DWORD *)(a1 + 352) = 0;
    *(_DWORD *)(a1 + 348) = 0;
    dword_690EC = a1;
    v57 = (char *)malloc(0x2Cu);
    v16 = v57;
    *(_DWORD *)(a1 + 344) = v57;
    if ( !v57 )
      goto LABEL_109;
    memset(v57 + 12, 0, 0x20u);
    v15 = a1 + 344;
    *((_DWORD *)v16 + 1) = 32;
    *((_DWORD *)v16 + 4) = a1 + 344;
    *((_DWORD *)v16 + 2) = 5;
    *((_DWORD *)v16 + 5) = 344;
    v58 = calloc(0x180u, 1u);
    *(_DWORD *)v16 = v58;
    if ( !v58 )
      goto LABEL_109;
    v5 = a1;
    *((_DWORD *)v16 + 10) = -1609490463;
  }
  ++*((_DWORD *)v16 + 3);
  v17 = *(_QWORD *)*(_DWORD *)(v5 + 344);
  v18 = 12 * ((HIDWORD(v17) - 1) & v13);
  ++*(_DWORD *)(v17 + v18 + 4);
  LODWORD(v17) = *(_DWORD *)(**(_DWORD **)(v5 + 344) + v18);
  *(_DWORD *)(a1 + 356) = 0;
  *(_DWORD *)(a1 + 360) = v17;
  LODWORD(v17) = **(_DWORD **)(v5 + 344);
  v19 = *(_DWORD *)(v17 + v18);
  v20 = (int *)(v17 + v18);
  if ( v19 )
  {
    *(_DWORD *)(v19 + 12) = v15;
    v20 = (int *)(**(_DWORD **)(v5 + 344) + v18);
  }
  *v20 = v15;
  v21 = dword_690EC;
  v22 = *(_QWORD *)(**(_DWORD **)(dword_690EC + 344) + v18 + 4);
  if ( (unsigned int)v22 >= 10 * (HIDWORD(v22) + 1) )
  {
    v23 = *(_DWORD *)(a1 + 344);
    if ( *(_DWORD *)(v23 + 36) != 1 )
    {
      v24 = calloc(24 * *(_DWORD *)(v23 + 4), 1u);
      if ( v24 )
      {
        v25 = 0;
        *(_DWORD *)(v23 + 24) = (((2 * *(_DWORD *)(v23 + 4) - 1) & *(_DWORD *)(v23 + 12)) != 0)
                              + (*(_DWORD *)(v23 + 12) >> (*(_BYTE *)(v23 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 28) = 0;
        v26 = *(_DWORD *)(a1 + 344);
        v27 = *(_DWORD *)(v26 + 4);
        if ( v27 )
        {
          for ( i = 0; i < v27; ++i )
          {
            v28 = *(char **)(*(_DWORD *)v26 + v25);
            if ( v28 )
            {
              v29 = v27;
              while ( 1 )
              {
                v16 = (char *)*((_DWORD *)v28 + 4);
                v30 = 3 * ((2 * v29 - 1) & *((_DWORD *)v28 + 7));
                v31 = (char *)&v24[v30];
                v32 = *((_DWORD *)v31 + 1) + 1;
                *((_DWORD *)v31 + 1) = v32;
                if ( v32 > *(_DWORD *)(v26 + 24) )
                {
                  ++*(_DWORD *)(v26 + 28);
                  *((_DWORD *)v31 + 2) = *((_DWORD *)v31 + 1) / *(_DWORD *)(*(_DWORD *)(a1 + 344) + 24);
                }
                *((_DWORD *)v28 + 3) = 0;
                *((_DWORD *)v28 + 4) = v24[v30];
                v33 = v24[v30];
                if ( v33 )
                  *(_DWORD *)(v33 + 12) = v28;
                v24[v30] = v28;
                v26 = *(_DWORD *)(a1 + 344);
                if ( !v16 )
                  break;
                v29 = *(_DWORD *)(v26 + 4);
                v28 = v16;
              }
              v27 = *(_DWORD *)(v26 + 4);
            }
            v25 += 12;
          }
        }
        free(*(void **)v26);
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 344) + 8);
        **(_DWORD **)(a1 + 344) = v24;
        v34 = *(_DWORD **)(a1 + 344);
        v21 = dword_690EC;
        v35 = v34[7];
        v36 = v34[3];
        v37 = v35 > v36 >> 1;
        if ( v35 <= v36 >> 1 )
          v38 = 0;
        else
          v38 = v34[8];
        if ( v37 )
          ++v38;
        v34[8] = v38;
        v39 = *(_DWORD *)(a1 + 344);
        if ( *(_DWORD *)(v39 + 32) > 1u )
          *(_DWORD *)(v39 + 36) = 1;
        v3 = dword_755E0;
        if ( !v21 )
          goto LABEL_95;
        goto LABEL_38;
      }
LABEL_109:
      exit(-1);
    }
  }
  v3 = dword_755E0;
LABEL_38:
  v40 = v21 + 344;
  v41 = 1;
  do
  {
    v42 = (char *)v40;
    v40 = 0;
    v43 = 0;
    v44 = 0;
    do
    {
      ++v44;
      if ( v41 )
      {
        v45 = (char *)*((_DWORD *)v42 + 2);
        if ( v45 && (v46 = *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20), (v45 += v46) != 0) )
        {
          v47 = 1;
          do
          {
            if ( v47 == v41 )
            {
              v48 = v47;
              goto LABEL_48;
            }
            v45 = (char *)*((_DWORD *)v45 + 2);
            ++v47;
            if ( !v45 )
              break;
            v45 += v46;
          }
          while ( v45 );
          v48 = v41;
        }
        else
        {
          v48 = v41;
          v47 = 1;
        }
      }
      else
      {
        v45 = v42;
        v48 = 0;
        v47 = 0;
      }
LABEL_48:
      v49 = v42;
      v42 = v45;
      while ( v47 )
      {
        v53 = v42 == 0;
        if ( v42 )
          v53 = v48 == 0;
        if ( v53 )
        {
          if ( v49 )
          {
            v16 = (char *)*((_DWORD *)v49 + 2);
            if ( v16 )
              v16 += *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20);
            goto LABEL_71;
          }
        }
        else
        {
          v16 = *(char **)(*(_DWORD *)(v21 + 344) + 20);
          if ( *(_DWORD *)(v49 - v16 + 264) - *(_DWORD *)(v42 - v16 + 264) > 0 )
          {
            v51 = *((_DWORD *)v42 + 2);
            if ( v51 )
              v51 += (int)v16;
LABEL_58:
            --v48;
            if ( !v43 )
            {
              v43 = v42;
              v42 = (char *)v51;
              goto LABEL_76;
            }
            v16 = &v42[-*(_DWORD *)(*(_DWORD *)(v21 + 344) + 20)];
            v43[2] = v16;
            if ( !v42 )
            {
              v43 = 0;
              v42 = (char *)v51;
              continue;
            }
            goto LABEL_62;
          }
          if ( v49 )
          {
            v55 = *((_DWORD *)v49 + 2);
            if ( v55 )
              v16 += v55;
            else
              v16 = 0;
            goto LABEL_71;
          }
        }
        v16 = v49;
LABEL_71:
        --v47;
        if ( !v43 )
        {
          v43 = v49;
          v49 = v16;
LABEL_76:
          v40 = (int)v43;
          if ( v43 )
          {
            v16 = 0;
            goto LABEL_63;
          }
          continue;
        }
        if ( !v49 )
        {
          v43[2] = 0;
          v43 = 0;
          v49 = v16;
          continue;
        }
        v51 = (int)v42;
        v42 = v49;
        v54 = &v49[-*(_DWORD *)(*(_DWORD *)(v21 + 344) + 20)];
        v49 = v16;
        v43[2] = v54;
LABEL_62:
        v16 = (char *)v43 - *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20);
        v43 = v42;
        v42 = (char *)v51;
LABEL_63:
        v43[1] = v16;
      }
      v50 = v48 == 0;
      if ( v48 )
        v50 = v42 == 0;
      if ( !v50 )
      {
        v51 = *((_DWORD *)v42 + 2);
        v52 = v51 == 0;
        if ( v51 )
          v16 = *(char **)(v21 + 344);
        else
          v51 = v47;
        if ( !v52 )
        {
          v16 = (char *)*((_DWORD *)v16 + 5);
          v51 += (int)v16;
        }
        goto LABEL_58;
      }
    }
    while ( v42 );
    if ( v43 )
      v43[2] = 0;
    if ( v44 <= 1 )
      goto LABEL_94;
    v41 *= 2;
  }
  while ( v40 );
  v43 = 0;
LABEL_94:
  *(_DWORD *)(*(_DWORD *)(v21 + 344) + 16) = v43;
  dword_690EC = v40 - *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20);
LABEL_95:
  pthread_cond_broadcast((pthread_cond_t *)(v3 + 40));
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_69010) )
  {
    v59 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v59, "cgminer.c", "hash_push", 5795);
    goto LABEL_107;
  }
  return off_67ED8();
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 69010: using guessed type int dword_69010;
// 690EC: using guessed type int dword_690EC;
// 69188: using guessed type int dword_69188;
// 691AC: using guessed type int dword_691AC;
// 74500: using guessed type char byte_74500;
// 755E0: using guessed type int dword_755E0;

//----- (0003E108) --------------------------------------------------------
void __fastcall sub_3E108(struct timeval *a1)
{
  _DWORD *tv_usec; // r4
  int v2; // r5
  double *v3; // r12
  __int64 v4; // kr08_8
  double v5; // d6
  double v6; // d5
  double v7; // d7
  _BYTE *v8; // r3
  int v9; // r0
  int *v10; // r0
  double *v11; // r0
  double v12; // d6
  double v13; // d7
  double v14; // d5
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  void *arg[2]; // [sp+14h] [bp-80Ch] BYREF
  pthread_t v19; // [sp+1Ch] [bp-804h] BYREF
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  arg[0] = a1;
  tv_usec = (_DWORD *)a1[32].tv_usec;
  sub_239A4(a1 + 54);
  if ( byte_6917C )
  {
    v2 = *(_DWORD *)(sub_31B04(*((_DWORD *)arg[0] + 64)) + 36);
    if ( pthread_mutex_lock(&stru_766C4) )
    {
      v10 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v10,
        "cgminer.c",
        "submit_work_async",
        8688);
    }
    else
    {
      v3 = (double *)arg[0];
      v4 = qword_755D8;
      ++*(_DWORD *)(v2 + 36);
      qword_755D8 = v4 + 1;
      v5 = dbl_73370;
      ++*((_QWORD *)tv_usec + 1);
      *(double *)(v2 + 200) = *(double *)(v2 + 200) + v3[47];
      v6 = v3[47];
      v7 = *((double *)tv_usec + 9) + v6;
      dbl_73370 = v5 + v6;
      *((double *)tv_usec + 9) = v7;
      if ( !pthread_mutex_unlock(&stru_766C4) )
      {
        off_67ED8();
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
        {
          snprintf(
            s,
            0x800u,
            "Accepted %s %d benchmark share nonce %08x",
            *(const char **)(*(_DWORD *)(v2 + 4) + 8),
            *(_DWORD *)(v2 + 8),
            *((_DWORD *)arg[0] + 19));
          sub_20F58(5, s, 0);
        }
        return;
      }
      v15 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v15,
        "cgminer.c",
        "submit_work_async",
        8695);
    }
LABEL_49:
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
  if ( !sub_367EC((int)arg[0], 1) )
  {
    v8 = arg[0];
    if ( *((_BYTE *)arg[0] + 284) )
      goto LABEL_10;
    goto LABEL_24;
  }
  if ( byte_6875D )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
    {
      snprintf(s, 0x800u, "Pool %d stale share detected, submitting as user requested", *tv_usec);
LABEL_22:
      sub_20F58(5, s, 0);
    }
  }
  else
  {
    if ( !*((_BYTE *)tv_usec + 104) )
    {
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
      {
        snprintf(s, 0x800u, "Pool %d stale share detected, discarding", *tv_usec);
        sub_20F58(5, s, 0);
      }
      sub_35A94("discard", (_DWORD *)arg[0]);
      if ( pthread_mutex_lock(&stru_766C4) )
      {
        v16 = _errno_location();
        snprintf(
          s,
          0x800u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v16,
          "cgminer.c",
          "submit_work_async",
          8716);
      }
      else
      {
        v11 = (double *)arg[0];
        v12 = *((double *)tv_usec + 11);
        v13 = dbl_766B8;
        ++tv_usec[30];
        v14 = v11[47];
        ++qword_73318;
        *((double *)tv_usec + 11) = v12 + v14;
        dbl_766B8 = v13 + v14;
        if ( !pthread_mutex_unlock(&stru_766C4) )
        {
          off_67ED8();
          sub_2CBA8((void ***)arg, "cgminer.c", "submit_work_async", 8725);
          return;
        }
        v17 = _errno_location();
        snprintf(
          s,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v17,
          "cgminer.c",
          "submit_work_async",
          8723);
      }
      goto LABEL_49;
    }
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
    {
      snprintf(s, 0x800u, "Pool %d stale share detected, submitting as pool requested", *tv_usec);
      goto LABEL_22;
    }
  }
  v8 = arg[0];
  *((_BYTE *)arg[0] + 281) = 1;
  if ( v8[284] )
  {
LABEL_10:
    if ( byte_68BD5 )
    {
      if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 6 )
      {
        v9 = tv_usec[182];
        if ( !v9 )
        {
LABEL_15:
          if ( dword_67DB4 <= 3 )
          {
            if ( tv_usec[182] )
            {
LABEL_17:
              sub_2CBA8((void ***)arg, "cgminer.c", "submit_work_async", 8739);
              return;
            }
            goto LABEL_63;
          }
LABEL_37:
          strcpy(s, "Discarding work from removed pool");
          sub_20F58(4, s, 0);
          if ( tv_usec[182] )
            goto LABEL_17;
          if ( byte_74500 || byte_68BD4 )
          {
LABEL_40:
            snprintf(s, 0x800u, "Pushing pool %d work to stratum queue", *tv_usec);
            sub_20F58(5, s, 0);
            goto LABEL_17;
          }
LABEL_63:
          if ( dword_67DB4 <= 4 )
            goto LABEL_17;
          goto LABEL_40;
        }
        goto LABEL_34;
      }
      snprintf(s, 0x800u, "Pushing pool %d work to stratum queue", *tv_usec);
      sub_20F58(7, s, 0);
    }
    v9 = tv_usec[182];
    if ( !v9 )
      goto LABEL_35;
    v8 = arg[0];
LABEL_34:
    if ( sub_233D4(v9, (int)v8) )
      return;
LABEL_35:
    if ( byte_74500 || byte_68BD4 )
      goto LABEL_37;
    goto LABEL_15;
  }
LABEL_24:
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    strcpy(s, "Pushing submit work to work thread");
    sub_20F58(5, s, 0);
    v8 = arg[0];
  }
  if ( pthread_create(&v19, 0, (void *(*)(void *))sub_2B4EC, v8) )
  {
    strcpy(s, "Failed to create submit_work_thread");
    sub_20F58(3, s, 1);
    sub_2E6B0(1, 1);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 6875D: using guessed type char byte_6875D;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 6917C: using guessed type char byte_6917C;
// 73318: using guessed type __int64 qword_73318;
// 73370: using guessed type double dbl_73370;
// 74500: using guessed type char byte_74500;
// 755D8: using guessed type __int64 qword_755D8;
// 766B8: using guessed type double dbl_766B8;
// 766C4: using guessed type pthread_mutex_t stru_766C4;

//----- (0003E82C) --------------------------------------------------------
int __fastcall sub_3E82C(int a1, int a2)
{
  int v4; // r6
  struct timeval *v6; // r5
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  sub_33790((int *)(a1 + 36), a2);
  v4 = sub_23110((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160));
  if ( v4 )
  {
    v6 = (struct timeval *)sub_2FD8C();
    sub_2CA90((int)v6, a2, 0);
    sub_3E108(v6);
    return v4;
  }
  else
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
    {
      snprintf(
        s,
        0x800u,
        "%s %s %d: Share above target",
        "submit_tested_work",
        *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
        *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
      sub_20F58(6, s, 0);
    }
    return 0;
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (0003E918) --------------------------------------------------------
int __fastcall sub_3E918(int a1, int a2, unsigned int a3)
{
  int v6; // r5

  v6 = sub_2DC68(a1, a3);
  if ( v6 && (*(_DWORD *)(a2 + 76) = a3, sub_2B350(a2), !*(_DWORD *)(a2 + 220)) )
  {
    sub_3E82C(a1, a2);
    if ( dword_766C0 && byte_7449D )
    {
      v6 = (unsigned __int8)byte_7449D;
      sub_2CCF0(a2, a3);
    }
  }
  else
  {
    v6 = 0;
    sub_331A4(a1);
  }
  return v6;
}
// 7449D: using guessed type char byte_7449D;
// 766C0: using guessed type int dword_766C0;

//----- (0003E9AC) --------------------------------------------------------
void __fastcall sub_3E9AC(int a1)
{
  struct timeval *v2; // r4

  v2 = (struct timeval *)sub_2FD8C();
  sub_2CA90((int)v2, a1, 0);
  sub_3E108(v2);
}

//----- (0003E9D4) --------------------------------------------------------
int __fastcall sub_3E9D4(int a1, int a2, int a3)
{
  struct timeval *v4; // r5

  *(_DWORD *)(a2 + 76) = a3;
  v4 = (struct timeval *)sub_2FD8C();
  sub_2CA90((int)v4, a2, 0);
  sub_3E108(v4);
  return 1;
}

//----- (0003EBA0) --------------------------------------------------------
void __fastcall __noreturn sub_3EBA0(int a1)
{
  sub_2E6B0(a1, 1);
}

//----- (0003EBAC) --------------------------------------------------------
int __fastcall sub_3EBAC(int a1, int a2, char *s1, const char *a4, const char *a5)
{
  char *v8; // r0
  size_t v9; // r5
  size_t v10; // r5
  char *v11; // r0
  const char *v12; // r12
  const char *v13; // r3
  int v14; // r2

  v8 = sub_23E4C(s1, a1);
  *(_DWORD *)(a1 + 172) = a4;
  *(_DWORD *)(a1 + 164) = v8;
  *(_DWORD *)(a1 + 176) = a5;
  v9 = strlen(a4);
  v10 = v9 + strlen(a5) + 2;
  v11 = (char *)sub_229BC(v10, "cgminer.c", "add_pool_details", 10826);
  v12 = *(const char **)(a1 + 176);
  v13 = *(const char **)(a1 + 172);
  *(_DWORD *)(a1 + 168) = v11;
  snprintf(v11, v10, "%s:%s", v13, v12);
  v14 = *(_DWORD *)(a1 + 100);
  *(_BYTE *)(a1 + 284) = 1;
  *(_BYTE *)(a1 + 107) = a2 ^ 1;
  *(_BYTE *)(a1 + 97) = 1;
  if ( v14 != 1 )
    sub_2B664((_DWORD *)(a1 + 100));
  pthread_create((pthread_t *)(a1 + 280), 0, (void *(*)(void *))sub_35D3C, (void *)a1);
  if ( !a2 )
  {
    pthread_join(*(_DWORD *)(a1 + 280), 0);
    return (unsigned __int8)byte_69170;
  }
  return a2;
}
// 69170: using guessed type char byte_69170;

//----- (0003ECA0) --------------------------------------------------------
int __fastcall sub_3ECA0(int result)
{
  if ( !*(_DWORD *)(result + 12) )
    *(_DWORD *)(result + 12) = 174696;
  if ( !*(_DWORD *)(result + 16) )
    *(_DWORD *)(result + 16) = 174660;
  if ( !*(_DWORD *)(result + 20) )
    *(_DWORD *)(result + 20) = 174664;
  if ( !*(_DWORD *)(result + 24) )
    *(_DWORD *)(result + 24) = 181632;
  if ( !*(_DWORD *)(result + 32) )
    *(_DWORD *)(result + 32) = 174668;
  if ( !*(_DWORD *)(result + 44) )
    *(_DWORD *)(result + 44) = 181640;
  if ( !*(_DWORD *)(result + 52) )
    *(_DWORD *)(result + 52) = 181648;
  if ( !*(_DWORD *)(result + 56) )
    *(_DWORD *)(result + 56) = 174688;
  if ( !*(_DWORD *)(result + 84) )
    *(_DWORD *)(result + 84) = 181656;
  if ( !*(_DWORD *)(result + 88) )
    *(_DWORD *)(result + 88) = 181660;
  if ( !*(_DWORD *)(result + 92) )
    *(_DWORD *)(result + 92) = 181664;
  if ( !*(_DWORD *)(result + 60) )
    *(_DWORD *)(result + 60) = sub_38678;
  if ( !*(_DWORD *)(result + 76) )
    *(_DWORD *)(result + 76) = 174660;
  if ( !*(_DWORD *)(result + 80) )
    *(_DWORD *)(result + 80) = 174660;
  if ( !*(_DWORD *)(result + 72) )
    *(_DWORD *)(result + 72) = 174668;
  if ( !*(_DWORD *)(result + 96) )
    *(_DWORD *)(result + 96) = 174708;
  if ( *(double *)(result + 104) == 0.0 )
    *(_QWORD *)(result + 104) = 0x3FF0000000000000LL;
  return result;
}

//----- (0003EE00) --------------------------------------------------------
int __fastcall sub_3EE00(int result)
{
  *(_DWORD *)(result + 28) = sub_2AA6C;
  *(_DWORD *)(result + 12) = nullsub_4;
  *(_DWORD *)(result + 20) = nullsub_1;
  *(_DWORD *)(result + 24) = nullsub_2;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = sub_2C588;
  *(_DWORD *)(result + 48) = sub_2AA54;
  *(_DWORD *)(result + 52) = sub_2C590;
  *(_DWORD *)(result + 56) = sub_2AA60;
  *(_DWORD *)(result + 60) = nullsub_5;
  *(_DWORD *)(result + 84) = nullsub_6;
  *(_DWORD *)(result + 88) = nullsub_7;
  *(_DWORD *)(result + 92) = nullsub_8;
  *(_DWORD *)(result + 96) = sub_2AA74;
  *(_DWORD *)(result + 16) = nullsub_3;
  *(_DWORD *)(result + 36) = nullsub_3;
  *(_DWORD *)(result + 76) = nullsub_3;
  *(_DWORD *)(result + 80) = nullsub_3;
  *(_DWORD *)(result + 32) = sub_2AA4C;
  *(_DWORD *)(result + 72) = sub_2AA4C;
  *(_QWORD *)(result + 104) = 0x3FF0000000000000LL;
  *(_QWORD *)(result + 112) = 0x3FF0000000000000LL;
  return result;
}
// 2AA44: using guessed type int nullsub_3();
// 2AA48: using guessed type int nullsub_1();
// 2AA68: using guessed type int nullsub_4();
// 2C580: using guessed type int nullsub_2();
// 2C584: using guessed type int nullsub_5();
// 2C598: using guessed type int nullsub_6();
// 2C59C: using guessed type int nullsub_7();
// 2C5A0: using guessed type int nullsub_8();

//----- (0003EEE8) --------------------------------------------------------
int __fastcall sub_3EEE8(pthread_rwlock_t *a1)
{
  int v2; // r1
  int v3; // r3
  int v4; // r1
  int v5; // r2
  int nr_writers_queued; // r3
  int result; // r0

  a1[1].__lock = 0;
  if ( pthread_rwlock_wrlock(&stru_7680C) )
    sub_2EF84("enable_device", 11236);
  v2 = dword_7346C;
  v3 = dword_6A738;
  a1->__lock = dword_6A738;
  *(_DWORD *)(v2 + 4 * v3) = a1;
  dword_6A738 = v3 + 1;
  if ( pthread_rwlock_unlock(&stru_7680C) )
    sub_2FB24("enable_device", 11238);
  off_67ED8();
  if ( byte_7347C )
    nr_writers_queued = a1[4].__nr_writers_queued;
  else
    nr_writers_queued = 21896;
  if ( byte_7347C )
    v5 = dword_6A73C;
  else
    HIWORD(nr_writers_queued) = 7;
  if ( byte_7347C )
  {
    nr_writers_queued += v5;
    dword_6A73C = nr_writers_queued;
  }
  else
  {
    v4 = *(_DWORD *)nr_writers_queued;
    v5 = a1[4].__nr_writers_queued;
  }
  if ( !byte_7347C )
    *(_DWORD *)nr_writers_queued = v5 + v4;
  result = pthread_rwlock_init(a1 + 10, 0);
  if ( result )
    sub_2EEB8("enable_device", 11249);
  a1[11].__lock = 0;
  return result;
}
// 3EF84: variable 'v5' is possibly undefined
// 3EF8C: variable 'v4' is possibly undefined
// 67ED8: using guessed type int (*off_67ED8)();
// 6A738: using guessed type int dword_6A738;
// 6A73C: using guessed type int dword_6A73C;
// 7346C: using guessed type int dword_7346C;
// 7347C: using guessed type char byte_7347C;
// 7680C: using guessed type pthread_rwlock_t stru_7680C;

//----- (0003EFD4) --------------------------------------------------------
int __fastcall sub_3EFD4(_DWORD *a1)
{
  unsigned int v1; // r5
  const char *v2; // r4
  size_t v3; // r0
  int v4; // r3
  size_t v5; // r6
  int v6; // r0
  unsigned __int8 *v7; // r9
  int v8; // lr
  int v9; // r2
  int v10; // r1
  int v11; // r4
  unsigned int v12; // r5
  unsigned int v13; // r3
  int v14; // r2
  unsigned int v15; // r1
  unsigned int v16; // r3
  int v17; // r2
  unsigned int v18; // r1
  unsigned int v19; // r3
  size_t v20; // r3
  int v21; // r0
  unsigned int v22; // r2
  unsigned int v23; // r7
  int v24; // r3
  unsigned int v25; // r2
  unsigned int v26; // r7
  int v27; // r3
  unsigned int v28; // r7
  _DWORD *v29; // r1
  int v30; // r2
  int v31; // r8
  int v32; // r5
  int v33; // r5
  int v34; // r3
  int v35; // r0
  int v36; // r2
  int v37; // r3
  int v38; // r1
  int result; // r0
  _DWORD *v40; // r5
  unsigned int v41; // r7
  size_t v42; // r0
  int v43; // r12
  unsigned int v44; // r11
  int v45; // r3
  unsigned __int8 *v46; // r10
  unsigned int v47; // r7
  unsigned __int8 *v48; // r2
  unsigned int v49; // r0
  unsigned int v50; // r1
  int v51; // r3
  unsigned int v52; // r0
  unsigned int v53; // r1
  int v54; // r3
  unsigned int v55; // r0
  unsigned int v56; // r1
  unsigned int v57; // r12
  int v58; // r3
  unsigned int v59; // r2
  unsigned int v60; // r1
  int v61; // r3
  unsigned int v62; // r2
  unsigned int v63; // r1
  int v64; // r3
  unsigned int v65; // r6
  int v66; // r7
  int v67; // r3
  _DWORD *v68; // r8
  __int64 v69; // r2
  int v70; // r3
  int v71; // r1
  _DWORD *v72; // r2
  __int64 v73; // r2
  int v74; // r3
  _DWORD *v75; // r8
  int v76; // r2
  int v77; // r10
  int v78; // r3
  unsigned int v79; // r6
  _DWORD *v80; // r7
  unsigned int v81; // r4
  _DWORD *v82; // r6
  int v83; // r4
  char *v84; // r9
  unsigned int v85; // r3
  int v86; // r2
  int v87; // r3
  _DWORD *v88; // r3
  unsigned int v89; // r2
  unsigned int v90; // r1
  bool v91; // cc
  int v92; // r2
  int v93; // r3
  unsigned __int8 *v94; // r11
  unsigned int v95; // r10
  void *v96; // r0
  void **v97; // r9
  void *v98; // r0
  const char *s2; // [sp+10h] [bp-Ch]
  char *s2a; // [sp+10h] [bp-Ch]
  char *s2b; // [sp+10h] [bp-Ch]

  v1 = -1640531527;
  v2 = *(const char **)(a1[1] + 8);
  s2 = v2;
  v3 = strlen(v2);
  v91 = v3 > 0xB;
  v4 = -17973521;
  v5 = v3;
  v6 = -1640531527;
  if ( v91 )
  {
    v7 = (unsigned __int8 *)(v2 + 12);
    v95 = v5;
    do
    {
      v8 = *(v7 - 6);
      v95 -= 12;
      v9 = *(v7 - 2);
      v10 = *(v7 - 10);
      v94 = v7;
      v11 = *(v7 - 7);
      v7 += 12;
      v12 = (v8 << 16) + (v11 << 8) + *(v7 - 20) + (*(v7 - 17) << 24) + v1;
      v13 = (v9 << 16) + (*(v7 - 15) << 8) + *(v7 - 16) + (*(v7 - 13) << 24) + v4;
      v14 = ((v10 << 16) + (*(v7 - 23) << 8) + *(v7 - 24) + (*(v7 - 21) << 24) - v12 - v13 + v6) ^ (v13 >> 13);
      v15 = (v12 - v13 - v14) ^ (v14 << 8);
      v16 = (v13 - v14 - v15) ^ (v15 >> 13);
      v17 = (v14 - v15 - v16) ^ (v16 >> 12);
      v18 = (v15 - v16 - v17) ^ (v17 << 16);
      v19 = (v16 - v17 - v18) ^ (v18 >> 5);
      v6 = (v17 - v18 - v19) ^ (v19 >> 3);
      v1 = (v18 - v19 - v6) ^ (v6 << 10);
      v4 = (v19 - v6 - v1) ^ (v1 >> 15);
    }
    while ( v95 > 0xB );
  }
  else
  {
    v94 = (unsigned __int8 *)v2;
    v95 = v5;
  }
  v20 = v5 + v4;
  switch ( v95 )
  {
    case 1u:
      goto LABEL_16;
    case 2u:
      goto LABEL_15;
    case 3u:
      goto LABEL_14;
    case 4u:
      goto LABEL_13;
    case 5u:
      goto LABEL_12;
    case 6u:
      goto LABEL_11;
    case 7u:
      goto LABEL_10;
    case 8u:
      goto LABEL_9;
    case 9u:
      goto LABEL_8;
    case 0xAu:
      goto LABEL_7;
    case 0xBu:
      v20 += v94[10] << 24;
LABEL_7:
      v20 += v94[9] << 16;
LABEL_8:
      v20 += v94[8] << 8;
LABEL_9:
      v1 += v94[7] << 24;
LABEL_10:
      v1 += v94[6] << 16;
LABEL_11:
      v1 += v94[5] << 8;
LABEL_12:
      v1 += v94[4];
LABEL_13:
      v6 += v94[3] << 24;
LABEL_14:
      v6 += v94[2] << 16;
LABEL_15:
      v6 += v94[1] << 8;
LABEL_16:
      v6 += *v94;
      break;
    default:
      break;
  }
  v21 = (v6 - v1 - v20) ^ (v20 >> 13);
  v22 = (v1 - v20 - v21) ^ (v21 << 8);
  v23 = (v20 - v21 - v22) ^ (v22 >> 13);
  v24 = (v21 - v22 - v23) ^ (v23 >> 12);
  v25 = (v22 - v23 - v24) ^ (v24 << 16);
  v26 = (v23 - v24 - v25) ^ (v25 >> 5);
  v27 = (v24 - v25 - v26) ^ (v26 >> 3);
  v28 = (v26 - v27 - ((v25 - v26 - v27) ^ (v27 << 10))) ^ (((v25 - v26 - v27) ^ (v27 << 10)) >> 15);
  if ( !dword_6A740
    || (v29 = *(_DWORD **)(dword_6A740 + 8), (v30 = *(_DWORD *)(*v29 + 12 * ((v29[1] - 1) & v28))) == 0)
    || (v31 = -v29[5], v32 = v30 - v29[5], v30 == v29[5]) )
  {
LABEL_46:
    v40 = sub_229BC(0x28u, "cgminer.c", "add_cgpu", 11283);
    sub_254E8(v40, *(const void **)(a1[1] + 8), 4u, (int)"cgminer.c", (int)"add_cgpu", 11284);
    v40[1] = 0;
    a1[2] = 0;
    v41 = -1640531527;
    v42 = strlen((const char *)v40);
    v43 = -17973521;
    s2a = (char *)v42;
    v44 = v42;
    v45 = -1640531527;
    if ( v42 <= 0xB )
    {
      v48 = (unsigned __int8 *)v40;
      v44 = v42;
    }
    else
    {
      v46 = (unsigned __int8 *)(v40 + 3);
      do
      {
        v44 -= 12;
        v47 = (*(v46 - 6) << 16) + (*(v46 - 7) << 8) + *(v46 - 8) + (*(v46 - 5) << 24) + v41;
        v48 = v46;
        v49 = (*(v46 - 10) << 16) + (*(v46 - 11) << 8) + *(v46 - 12) + (*(v46 - 9) << 24) - v47;
        v50 = (*(v46 - 2) << 16) + (*(v46 - 3) << 8) + *(v46 - 4) + (*(v46 - 1) << 24) + v43;
        v46 += 12;
        v51 = (v49 - v50 + v45) ^ (v50 >> 13);
        v52 = (v47 - v50 - v51) ^ (v51 << 8);
        v53 = (v50 - v51 - v52) ^ (v52 >> 13);
        v54 = (v51 - v52 - v53) ^ (v53 >> 12);
        v55 = (v52 - v53 - v54) ^ (v54 << 16);
        v56 = (v53 - v54 - v55) ^ (v55 >> 5);
        v45 = (v54 - v55 - v56) ^ (v56 >> 3);
        v41 = (v55 - v56 - v45) ^ (v45 << 10);
        v43 = (v56 - v45 - v41) ^ (v41 >> 15);
      }
      while ( v44 > 0xB );
    }
    v57 = (unsigned int)&s2a[v43];
    switch ( v44 )
    {
      case 1u:
        goto LABEL_60;
      case 2u:
        goto LABEL_59;
      case 3u:
        goto LABEL_58;
      case 4u:
        goto LABEL_57;
      case 5u:
        goto LABEL_56;
      case 6u:
        goto LABEL_55;
      case 7u:
        goto LABEL_54;
      case 8u:
        goto LABEL_53;
      case 9u:
        goto LABEL_52;
      case 0xAu:
        goto LABEL_51;
      case 0xBu:
        v57 += v48[10] << 24;
LABEL_51:
        v57 += v48[9] << 16;
LABEL_52:
        v57 += v48[8] << 8;
LABEL_53:
        v41 += v48[7] << 24;
LABEL_54:
        v41 += v48[6] << 16;
LABEL_55:
        v41 += v48[5] << 8;
LABEL_56:
        v41 += v48[4];
LABEL_57:
        v45 += v48[3] << 24;
LABEL_58:
        v45 += v48[2] << 16;
LABEL_59:
        v45 += v48[1] << 8;
LABEL_60:
        v45 += *v48;
        break;
      default:
        break;
    }
    v40[7] = v40;
    v58 = (v45 - v41 - v57) ^ (v57 >> 13);
    v59 = (v41 - v57 - v58) ^ (v58 << 8);
    v60 = (v57 - v58 - v59) ^ (v59 >> 13);
    v61 = (v58 - v59 - v60) ^ (v60 >> 12);
    v62 = (v59 - v60 - v61) ^ (v61 << 16);
    v63 = (v60 - v61 - v62) ^ (v62 >> 5);
    v64 = (v61 - v62 - v63) ^ (v63 >> 3);
    v65 = (v63 - v64 - ((v62 - v63 - v64) ^ (v64 << 10))) ^ (((v62 - v63 - v64) ^ (v64 << 10)) >> 15);
    v40[9] = v65;
    v66 = dword_6A740;
    v40[8] = strlen((const char *)v40);
    if ( v66 )
    {
      v67 = *(_DWORD *)(v66 + 8);
      v40[4] = 0;
      v68 = v40 + 2;
      v40[2] = v67;
      v40[3] = *(_DWORD *)(*(_DWORD *)(v66 + 8) + 16) - *(_DWORD *)(*(_DWORD *)(v66 + 8) + 20);
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v66 + 8) + 16) + 8) = v40;
      *(_DWORD *)(*(_DWORD *)(v66 + 8) + 16) = v40 + 2;
    }
    else
    {
      v40[4] = 0;
      v40[3] = 0;
      dword_6A740 = (int)v40;
      v96 = malloc(0x2Cu);
      v40[2] = v96;
      if ( !v96 )
        goto LABEL_96;
      memset(v96, 0, 0x2Cu);
      v68 = v40 + 2;
      *(_DWORD *)(v40[2] + 16) = v40 + 2;
      *(_DWORD *)(v40[2] + 4) = 32;
      *(_DWORD *)(v40[2] + 8) = 5;
      *(_DWORD *)(v40[2] + 20) = 8;
      v97 = (void **)v40[2];
      *v97 = malloc(0x180u);
      v98 = *(void **)v40[2];
      if ( !v98 )
        goto LABEL_96;
      memset(v98, 0, 0x180u);
      v66 = (int)v40;
      *(_DWORD *)(v40[2] + 40) = -1609490463;
    }
    ++*(_DWORD *)(*(_DWORD *)(v66 + 8) + 12);
    v69 = *(_QWORD *)*(_DWORD *)(v66 + 8);
    v70 = 12 * ((HIDWORD(v69) - 1) & v65);
    ++*(_DWORD *)(v69 + v70 + 4);
    LODWORD(v69) = *(_DWORD *)(**(_DWORD **)(v66 + 8) + v70);
    v40[5] = 0;
    v40[6] = v69;
    LODWORD(v69) = **(_DWORD **)(v66 + 8);
    v71 = *(_DWORD *)(v69 + v70);
    v72 = (_DWORD *)(v69 + v70);
    if ( v71 )
    {
      *(_DWORD *)(v71 + 12) = v68;
      v72 = (_DWORD *)(**(_DWORD **)(v66 + 8) + v70);
    }
    *v72 = v68;
    v73 = *(_QWORD *)(**(_DWORD **)(v66 + 8) + v70 + 4);
    if ( (unsigned int)v73 < 10 * (HIDWORD(v73) + 1) )
      goto LABEL_27;
    v74 = v40[2];
    if ( *(_DWORD *)(v74 + 36) == 1 )
      goto LABEL_27;
    v75 = calloc(24 * *(_DWORD *)(v74 + 4), 1u);
    if ( v75 )
    {
      v76 = v40[2];
      v77 = 0;
      *(_DWORD *)(v76 + 24) = (((2 * *(_DWORD *)(v76 + 4) - 1) & *(_DWORD *)(v76 + 12)) != 0)
                            + (*(_DWORD *)(v76 + 12) >> (*(_BYTE *)(v76 + 8) + 1));
      *(_DWORD *)(v40[2] + 28) = 0;
      v78 = v40[2];
      v79 = *(_DWORD *)(v78 + 4);
      if ( v79 )
      {
        for ( s2b = 0; (unsigned int)s2b < v79; ++s2b )
        {
          v80 = *(_DWORD **)(*(_DWORD *)v78 + v77);
          if ( v80 )
          {
            v81 = v79;
            while ( 1 )
            {
              v82 = (_DWORD *)v80[4];
              v83 = 3 * ((2 * v81 - 1) & v80[7]);
              v84 = (char *)&v75[v83];
              v85 = *((_DWORD *)v84 + 1) + 1;
              *((_DWORD *)v84 + 1) = v85;
              v86 = v40[2];
              if ( v85 > *(_DWORD *)(v86 + 24) )
              {
                ++*(_DWORD *)(v86 + 28);
                *((_DWORD *)v84 + 2) = *((_DWORD *)v84 + 1) / *(_DWORD *)(v40[2] + 24);
              }
              v80[3] = 0;
              v80[4] = v75[v83];
              v87 = v75[v83];
              if ( v87 )
                *(_DWORD *)(v87 + 12) = v80;
              v75[v83] = v80;
              v78 = v40[2];
              if ( !v82 )
                break;
              v81 = *(_DWORD *)(v78 + 4);
              v80 = v82;
            }
            v79 = *(_DWORD *)(v78 + 4);
          }
          v77 += 12;
        }
      }
      free(*(void **)v78);
      *(_DWORD *)(v40[2] + 4) *= 2;
      ++*(_DWORD *)(v40[2] + 8);
      *(_DWORD *)v40[2] = v75;
      v88 = (_DWORD *)v40[2];
      v89 = v88[7];
      v90 = v88[3];
      v91 = v89 > v90 >> 1;
      if ( v89 <= v90 >> 1 )
        v92 = 0;
      else
        v92 = v88[8];
      if ( v91 )
        ++v92;
      v88[8] = v92;
      v93 = v40[2];
      if ( *(_DWORD *)(v93 + 32) > 1u )
        *(_DWORD *)(v93 + 36) = 1;
      goto LABEL_27;
    }
LABEL_96:
    exit(-1);
  }
  while ( *(_DWORD *)(v32 + 36) != v28 || *(_DWORD *)(v32 + 32) != v5 || memcmp(*(const void **)(v32 + 28), s2, v5) )
  {
    v33 = *(_DWORD *)(v32 + 24);
    if ( v33 )
    {
      v32 = v33 + v31;
      if ( v32 )
        continue;
    }
    goto LABEL_46;
  }
  v34 = *(_DWORD *)(v32 + 4) + 1;
  *(_DWORD *)(v32 + 4) = v34;
  a1[2] = v34;
LABEL_27:
  if ( pthread_rwlock_wrlock(&stru_7680C) )
    sub_2EF84("add_cgpu", 11289);
  dword_7346C = (int)sub_22AD4((void *)dword_7346C, 4 * (dword_755C0 + dword_6A744 + 2), "cgminer.c", "add_cgpu", 11290);
  if ( pthread_rwlock_unlock(&stru_7680C) )
    sub_2FB24("add_cgpu", 11291);
  off_67ED8();
  if ( pthread_mutex_lock(&stru_766C4) )
    sub_2EFE0("add_cgpu", 11293);
  a1[58] = time(0);
  if ( pthread_mutex_unlock(&stru_766C4) )
    sub_2F03C("add_cgpu", 11295);
  v35 = off_67ED8();
  if ( byte_7347C )
    v37 = dword_6A744;
  else
    v37 = dword_755C0;
  if ( byte_7347C )
  {
    v35 = dword_755C0;
    v38 = v37 + 1;
    v36 = dword_7346C;
  }
  else
  {
    v38 = v37 + 1;
  }
  if ( byte_7347C )
    dword_6A744 = v38;
  else
    dword_755C0 = v38;
  if ( byte_7347C )
    v37 += v35;
  else
    v36 = dword_7346C;
  result = 1;
  *(_DWORD *)(v36 + 4 * v37) = a1;
  if ( dword_755C0 - dword_74498 > dword_6A748 )
    dword_6A748 = dword_755C0 - dword_74498;
  return result;
}
// 3F118: control flows out of bounds to 3F11C
// 3F558: control flows out of bounds to 3F55C
// 3F3A8: variable 'v36' is possibly undefined
// 67ED8: using guessed type int (*off_67ED8)();
// 6A740: using guessed type int dword_6A740;
// 6A744: using guessed type int dword_6A744;
// 6A748: using guessed type int dword_6A748;
// 7346C: using guessed type int dword_7346C;
// 7347C: using guessed type char byte_7347C;
// 74498: using guessed type int dword_74498;
// 755C0: using guessed type int dword_755C0;
// 766C4: using guessed type pthread_mutex_t stru_766C4;
// 7680C: using guessed type pthread_rwlock_t stru_7680C;

//----- (0003F9E0) --------------------------------------------------------
_BYTE *__fastcall sub_3F9E0(const void *a1)
{
  _BYTE *v2; // r5

  v2 = sub_229BC(0x78u, "cgminer.c", "copy_drv", 11319);
  sub_254E8(v2, a1, 0x78u, (int)"cgminer.c", (int)"copy_drv", 11320);
  v2[100] = 1;
  return v2;
}

//----- (0003FA44) --------------------------------------------------------
void sub_3FA44()
{
  int v0; // r4
  char *v1; // r0
  struct sysinfo v2; // [sp+0h] [bp-940h] BYREF
  char s[256]; // [sp+40h] [bp-900h] BYREF
  char v4[2048]; // [sp+140h] [bp-800h] BYREF

  if ( sysinfo(&v2) )
  {
    v0 = *_errno_location();
    v1 = strerror(v0);
    sprintf(s, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
    dword_73320 = time(0);
    dword_74484 = dword_73320 + 1;
  }
  else
  {
    dword_73320 = v2.uptime;
    dword_74484 = v2.uptime + 1;
    sprintf(s, "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n", v2.uptime, v2.uptime + 1);
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
    {
      snprintf(v4, 0x800u, "%s", s);
      sub_20F58(5, v4, 0);
    }
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 73320: using guessed type int dword_73320;
// 74484: using guessed type int dword_74484;
// 74500: using guessed type char byte_74500;

//----- (0003FB54) --------------------------------------------------------
void sub_3FB54()
{
  FILE *v0; // r6
  signed int v1; // r0
  char *v2; // r7
  unsigned __int8 *v3; // r4
  int v4; // r7
  char *v5; // r0
  size_t v6; // r0
  int v7; // r3
  size_t v8; // r0
  int v9; // r3
  bool v10; // zf
  int v11; // r5
  char v12[256]; // [sp+8h] [bp-900h] BYREF
  char s[2048]; // [sp+108h] [bp-800h] BYREF

  v0 = (FILE *)fopen64(dword_68DE8, "rb");
  memset(v12, 0, sizeof(v12));
  if ( v0 )
  {
    v1 = fread(v12, 1u, 0x100u, v0);
    if ( v1 <= 0 )
    {
      v11 = (int)&byte_74500;
      if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
        goto LABEL_24;
      snprintf(s, 0x800u, "Read miner version file %s error %d", (const char *)dword_68DE8, v1);
      sub_20F58(3, s, 0);
    }
    else
    {
      v2 = strchr(v12, 10);
      if ( v2 )
      {
        v3 = byte_6ABD0;
        sub_254E8(byte_6A74C, v12, v2 - v12, (int)"cgminer.c", (int)"read_version_file", 11549);
        v4 = stpcpy(v12, v2 + 1);
        v5 = strchr(v12, 10);
        if ( v5 )
          sub_254E8(byte_6A84C, v12, v5 - v12, (int)"cgminer.c", (int)"read_version_file", 11558);
        else
          memcpy(byte_6A84C, v12, v4 - (_DWORD)v12 + 1);
      }
      else
      {
        v3 = byte_6ABD0;
        strcpy(byte_6A74C, v12);
      }
      v6 = strlen(byte_6A74C) - 1;
      v7 = byte_6ABD0[v6 - 1156];
      if ( v7 == 10 )
      {
        byte_6ABD0[v6 - 1156] = 0;
        v6 = strlen(byte_6A74C) - 1;
        v7 = byte_6ABD0[v6 - 1156];
      }
      if ( v7 == 13 )
        byte_6ABD0[v6 - 1156] = 0;
      v8 = strlen(byte_6A84C) - 1;
      v9 = byte_6ABD0[v8 - 900];
      if ( v9 == 10 )
      {
        byte_6ABD0[v8 - 900] = 0;
        v8 = strlen(byte_6A84C) - 1;
        v9 = byte_6ABD0[v8 - 900];
      }
      v10 = v9 == 13;
      v11 = 17664;
      if ( v9 == 13 )
      {
        v3 = &byte_6ABD0[v8];
        LOBYTE(v9) = 0;
      }
      else
      {
        HIWORD(v11) = 7;
      }
      if ( v10 )
      {
        HIWORD(v11) = 7;
        *(v3 - 900) = v9;
      }
    }
  }
  else
  {
    v11 = (int)&byte_74500;
    if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
      goto LABEL_24;
    snprintf(s, 0x800u, "Open miner version file %s error", (const char *)dword_68DE8);
    sub_20F58(3, s, 0);
  }
  if ( *(_BYTE *)v11 || byte_68BD4 )
    goto LABEL_23;
LABEL_24:
  if ( dword_67DB4 > 2 )
  {
LABEL_23:
    snprintf(s, 0x800u, "Miner compile time: %s type: %s", byte_6A74C, byte_6A84C);
    sub_20F58(3, s, 0);
  }
}
// 12034: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68DE8: using guessed type int dword_68DE8;
// 6ABD0: using guessed type unsigned __int8 byte_6ABD0[248];
// 74500: using guessed type char byte_74500;

//----- (0003FE74) --------------------------------------------------------
void sub_3FE74()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    snprintf(v0, 0x800u, "START %s", "load_default_config_new");
    sub_20F58(5, v0, 0);
    if ( newthread )
    {
      if ( byte_74500 || byte_68BD4 )
        goto LABEL_6;
      goto LABEL_10;
    }
  }
  else if ( newthread )
  {
LABEL_10:
    if ( dword_67DB4 <= 2 )
      return;
LABEL_6:
    strcpy(v0, "config too fast, pool is changing, please wait\n");
    sub_20F58(3, v0, 0);
    return;
  }
  if ( pthread_create(&newthread, 0, (void *(*)(void *))sub_3479C, 0) && (byte_74500 || byte_68BD4 || dword_67DB4 > 2) )
  {
    strcpy(v0, "Failed to create pool_change_thread");
    sub_20F58(3, v0, 0);
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (0004002C) --------------------------------------------------------
char *__fastcall sub_4002C(const char *a1, const char *a2)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = (char *)malloc(v4 + v5);
  sprintf(v6, a1, a2);
  return v6;
}

//----- (00040068) --------------------------------------------------------
int __fastcall sub_40068(_BYTE *a1)
{
  *a1 = 1;
  return 0;
}

//----- (00040078) --------------------------------------------------------
int __fastcall sub_40078(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (00040088) --------------------------------------------------------
int __fastcall sub_40088(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (00040098) --------------------------------------------------------
char *__fastcall sub_40098(const char *a1, _BYTE *a2)
{
  if ( !strcasecmp(a1, "yes") || !strcasecmp(a1, "true") )
  {
    *a2 = 1;
    return 0;
  }
  else if ( !strcasecmp(a1, (const char *)&dword_4B184) || !strcasecmp(a1, "false") )
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    return sub_40BD0(a1);
  }
}
// 4B184: using guessed type int dword_4B184;

//----- (0004012C) --------------------------------------------------------
char *__fastcall sub_4012C(const char *a1, _BYTE *a2)
{
  char *result; // r0

  result = sub_40098(a1, a2);
  if ( !result )
    *a2 ^= 1u;
  return result;
}

//----- (0004014C) --------------------------------------------------------
int __fastcall sub_4014C(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0;
}

//----- (00040158) --------------------------------------------------------
char *__fastcall sub_40158(const char *a1, _DWORD *a2)
{
  int v2; // s0
  int *v5; // r5
  _BYTE *v6; // r3
  char *result; // r0
  _BYTE *v8; // [sp+4h] [bp-4h] BYREF

  v5 = _errno_location();
  *v5 = 0;
  strtof(a1, &v8);
  v6 = v8;
  *a2 = v2;
  if ( *v6 || !*a1 )
    return sub_4002C("'%s' is not a number", a1);
  result = (char *)*v5;
  if ( *v5 )
    return sub_4002C("'%s' is out of range", a1);
  return result;
}
// 40188: variable 'v2' is possibly undefined
// 12160: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (000401E0) --------------------------------------------------------
char *__fastcall sub_401E0(const char *a1, int *a2)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(a1, &endptr, 0);
  v6 = endptr;
  *a2 = v5;
  if ( *v6 || !*a1 )
    return sub_4002C("'%s' is not a number", a1);
  result = (char *)*v4;
  if ( *v4 )
    return sub_4002C("'%s' is out of range", a1);
  return result;
}

//----- (00040268) --------------------------------------------------------
char *__fastcall sub_40268(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  result = sub_401E0(a1, &v4);
  if ( !result )
    *a2 = v4;
  return result;
}

//----- (00040330) --------------------------------------------------------
int __fastcall sub_40330(_DWORD *a1)
{
  ++*a1;
  return 0;
}

//----- (00040348) --------------------------------------------------------
void __fastcall __noreturn sub_40348(const char *a1)
{
  puts(a1);
  fflush((FILE *)stdout);
  exit(0);
}
// 68A74: using guessed type int stdout;

//----- (00040368) --------------------------------------------------------
void __fastcall __noreturn sub_40368(int a1)
{
  const char *v1; // r0

  v1 = (const char *)sub_410E8(dword_76868, a1);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 410E8: using guessed type int __fastcall sub_410E8(_DWORD, _DWORD);
// 68A74: using guessed type int stdout;
// 76868: using guessed type int dword_76868;

//----- (000403A8) --------------------------------------------------------
char *__fastcall sub_403A8(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "true";
  if ( !v2 )
    v3 = "false";
  return strncpy(a1, v3, 0x50u);
}

//----- (000403CC) --------------------------------------------------------
char *__fastcall sub_403CC(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "false";
  if ( !v2 )
    v3 = "true";
  return strncpy(a1, v3, 0x50u);
}

//----- (000403F0) --------------------------------------------------------
char *__fastcall sub_403F0(_BYTE *a1, const char **a2)
{
  size_t v4; // r0
  bool v5; // cc
  size_t v6; // r5
  char *v7; // r0
  const char *v8; // r1
  _BYTE *v9; // r4
  char *result; // r0

  v4 = strlen(*a2);
  v5 = v4 > 0x4E;
  v6 = v4;
  *a1 = 34;
  v7 = a1 + 1;
  v8 = *a2;
  if ( v5 )
  {
    result = strncpy(v7, v8, 0x4Eu);
    a1[79] = 34;
  }
  else
  {
    v9 = &a1[v6];
    result = strncpy(v7, v8, v6);
    v9[1] = 34;
    if ( v6 != 78 )
      v9[2] = 0;
  }
  return result;
}

//----- (00040450) --------------------------------------------------------
int __fastcall sub_40450(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%i", *a2);
}

//----- (00040464) --------------------------------------------------------
int __fastcall sub_40464(char *a1, float *a2)
{
  return snprintf(a1, 0x50u, "%.1f", *a2);
}

//----- (00040490) --------------------------------------------------------
int __fastcall sub_40490(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%u", *a2);
}

//----- (000404A4) --------------------------------------------------------
int __fastcall sub_404A4(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%li", *a2);
}

//----- (000404B8) --------------------------------------------------------
int __fastcall sub_404B8(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%lu", *a2);
}

//----- (000404CC) --------------------------------------------------------
const char *__fastcall sub_404CC(unsigned int *a1, size_t *a2)
{
  _DWORD *v2; // r12
  const char *v3; // r4
  int v5; // r4
  unsigned int v6; // lr

  *a1 = 0;
  if ( !dword_7686C )
    return 0;
  v2 = (_DWORD *)dword_76864;
  if ( *(_DWORD *)(dword_76864 + 4) == 8 )
  {
    v5 = 28;
    v6 = 1;
    do
    {
      *a1 = v6;
      if ( dword_7686C <= v6++ )
        return 0;
      v2 = (_DWORD *)(dword_76864 + v5);
      v5 += 28;
    }
    while ( v2[1] == 8 );
  }
  v3 = (const char *)(*v2 + 1);
  *a2 = strcspn(v3, "|= ");
  return v3;
}
// 76864: using guessed type int dword_76864;
// 7686C: using guessed type int dword_7686C;

//----- (0004056C) --------------------------------------------------------
int __fastcall sub_4056C(int a1, size_t *a2)
{
  int v2; // r3
  size_t v3; // r0
  bool v4; // zf
  int v5; // r4

  v2 = *(unsigned __int8 *)(a1 + *a2);
  v3 = a1 + *a2;
  v4 = (v2 & 0xDF) == 0;
  if ( (v2 & 0xDF) != 0 )
    v4 = v2 == 61;
  if ( v4 )
    return 0;
  v5 = v3 + 2;
  *a2 = strcspn((const char *)(v3 + 2), "|= ");
  return v5;
}

//----- (000405B4) --------------------------------------------------------
int __fastcall sub_405B4(int a1, unsigned int *a2, size_t *a3)
{
  unsigned int v3; // r3
  _DWORD *v7; // r2
  int result; // r0
  const char *v9; // r4

  v3 = *a2;
  if ( *a2 >= dword_7686C )
    return 0;
  while ( 1 )
  {
    v7 = (_DWORD *)(dword_76864 + 28 * v3);
    if ( v7[1] != 8 )
      break;
LABEL_6:
    *a2 = ++v3;
    if ( v3 >= dword_7686C )
      return 0;
  }
  if ( a1 )
  {
    result = sub_4056C(a1, a3);
    a1 = result;
    if ( result )
      return result;
    v3 = *a2;
    goto LABEL_6;
  }
  v9 = (const char *)(*v7 + 1);
  *a3 = strcspn(v9, "|= ");
  return (int)v9;
}
// 76864: using guessed type int dword_76864;
// 7686C: using guessed type int dword_7686C;

//----- (0004066C) --------------------------------------------------------
int __fastcall sub_4066C(const char **a1)
{
  __int64 v1; // r2
  bool v2; // cc
  _BYTE *v4; // r4
  int v5; // r0
  const char *v6; // r12
  unsigned int v7; // r3
  int v8; // r3
  bool v9; // zf
  int result; // r0
  int status; // [sp+Ch] [bp-4h] BYREF

  v1 = *(_QWORD *)a1;
  v2 = (unsigned int)a1[1] > 4;
  if ( a1[1] != (const char *)4 )
    v2 = (unsigned int)(a1[1] - 1) > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", (const char *)v1, HIDWORD(v1));
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", (const char *)v1);
  if ( *(_BYTE *)v1 != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)v1);
  v4 = (_BYTE *)(v1 + 1);
  v5 = strcspn((const char *)(v1 + 1), "|= ");
  for ( status = v5; ; v5 = status )
  {
    if ( *v4 == 45 )
    {
      if ( v5 == 1 )
        errx(1, "Option %s: invalid long option '--'", *a1);
      v6 = a1[1];
      ++dword_7685C;
    }
    else
    {
      if ( v5 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *a1, v5 + 1, v4 - 1);
      v6 = a1[1];
      v7 = (unsigned int)(v6 - 2) & 0xFFFFFFFD;
      if ( !v7 )
        v7 = dword_76858;
      ++dword_76860;
      if ( ((unsigned int)(v6 - 2) & 0xFFFFFFFD) == 0 )
        dword_76858 = v7 + 1;
    }
    if ( v6 == (const char *)1 )
    {
      v8 = (unsigned __int8)v4[v5];
      v9 = v8 == 61;
      if ( v8 != 61 )
        v9 = v8 == 32;
      if ( v9 )
        errx(1, "Option %s: does not take arguments '%s'", *a1, &v4[v5 + 1]);
    }
    result = sub_4056C((int)v4, (size_t *)&status);
    v4 = (_BYTE *)result;
    if ( !result )
      break;
  }
  return result;
}
// 76858: using guessed type int dword_76858;
// 7685C: using guessed type int dword_7685C;
// 76860: using guessed type int dword_76860;

//----- (000407E0) --------------------------------------------------------
int __fastcall sub_407E0(int *a1)
{
  char *v2; // r0
  int v3; // r3
  int *v4; // lr
  char *v5; // r12
  int v6; // r4
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  char *v11; // r12
  int result; // r0
  int v13; // r1
  int v14; // r2

  v2 = (char *)realloc((void *)dword_76864, 28 * (dword_7686C + 1));
  v3 = dword_7686C;
  v4 = a1;
  v5 = v2;
  dword_76864 = (int)v2;
  ++dword_7686C;
  v6 = 7 * v3;
  v7 = *v4;
  v8 = v4[1];
  v9 = v4[2];
  v10 = v4[3];
  v4 += 4;
  v11 = &v5[4 * v6];
  *(_DWORD *)v11 = v7;
  *((_DWORD *)v11 + 1) = v8;
  *((_DWORD *)v11 + 2) = v9;
  *((_DWORD *)v11 + 3) = v10;
  v11 += 16;
  result = *v4;
  v13 = v4[1];
  v14 = v4[2];
  *(_DWORD *)v11 = *v4;
  *((_DWORD *)v11 + 1) = v13;
  *((_DWORD *)v11 + 2) = v14;
  return result;
}
// 76864: using guessed type int dword_76864;
// 7686C: using guessed type int dword_7686C;

//----- (00040844) --------------------------------------------------------
const char *__fastcall sub_40844(unsigned int *a1, size_t *a2)
{
  const char *v4; // r0

  v4 = sub_404CC(a1, a2);
  if ( !v4 )
    return 0;
  while ( *v4 != 45 )
  {
    v4 = (const char *)sub_405B4((int)v4, a1, a2);
    if ( !v4 )
      return 0;
  }
  --*a2;
  return v4 + 1;
}

//----- (0004089C) --------------------------------------------------------
_BYTE *__fastcall sub_4089C(int a1, unsigned int *a2, size_t *a3)
{
  _BYTE *v5; // r0

  v5 = (_BYTE *)sub_405B4(a1, a2, a3);
  if ( !v5 )
    return 0;
  while ( *v5 != 45 )
  {
    v5 = (_BYTE *)sub_405B4((int)v5, a2, a3);
    if ( !v5 )
      return 0;
  }
  --*a3;
  return v5 + 1;
}

//----- (000408F4) --------------------------------------------------------
const char *__fastcall sub_408F4(unsigned int *a1)
{
  const char *result; // r0
  size_t v3; // [sp+4h] [bp-8h] BYREF

  v3 = 0;
  result = sub_404CC(a1, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (const char *)sub_405B4((int)result, a1, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00040954) --------------------------------------------------------
_BYTE *__fastcall sub_40954(int a1, unsigned int *a2)
{
  _BYTE *result; // r0
  size_t v4; // [sp+4h] [bp-8h] BYREF

  v4 = 1;
  result = (_BYTE *)sub_405B4(a1, a2, &v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (_BYTE *)sub_405B4((int)result, a2, &v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (000409B4) --------------------------------------------------------
int __fastcall sub_409B4(
        const char *a1,
        const char *a2,
        const char *a3,
        const char *a4,
        const char *a5,
        const char *a6,
        const char *a7)
{
  const char *v8[8]; // [sp+4h] [bp-20h] BYREF

  v8[1] = a2;
  v8[0] = a1;
  v8[2] = a3;
  v8[3] = a4;
  v8[4] = a5;
  v8[5] = a6;
  v8[6] = a7;
  sub_4066C(v8);
  return sub_407E0((int *)v8);
}

//----- (000409F8) --------------------------------------------------------
int __fastcall sub_409F8(int result, int a2)
{
  const char **v3; // r4
  int v4; // r6
  const char *v5; // r3
  int v6[8]; // [sp+4h] [bp-20h] BYREF

  v3 = (const char **)result;
  v4 = dword_7686C;
  if ( a2 )
  {
    v6[0] = 0;
    memset(&v6[2], 0, 16);
    v6[6] = a2;
    v6[1] = 8;
    sub_407E0(v6);
    v5 = v3[1];
    if ( v5 == (const char *)16 )
    {
LABEL_7:
      result = 7 * v4;
      *(_DWORD *)(dword_76864 + 28 * v4 + 20) = dword_7686C - v4;
      return result;
    }
  }
  else
  {
    v5 = *(const char **)(result + 4);
    if ( v5 == (const char *)16 )
      return result;
  }
  do
  {
    if ( v5 == (const char *)8 )
    {
      result = sub_409F8(*v3, v3[6]);
    }
    else
    {
      sub_4066C(v3);
      result = sub_407E0((int *)v3);
    }
    v3 += 7;
    v5 = v3[1];
  }
  while ( v5 != (const char *)16 );
  if ( a2 )
    goto LABEL_7;
  return result;
}
// 76864: using guessed type int dword_76864;
// 7686C: using guessed type int dword_7686C;

//----- (00040ACC) --------------------------------------------------------
bool __fastcall sub_40ACC(_DWORD *a1, const char **a2, void (*a3)(const char *, ...))
{
  int v6; // r0
  int v8; // [sp+4h] [bp-8h] BYREF

  dword_76868 = (int)*a2;
  v8 = 0;
  do
    v6 = sub_40C38(a1, a2, &v8, a3);
  while ( v6 == 1 );
  return v6 == 0;
}
// 76868: using guessed type int dword_76868;

//----- (00040B28) --------------------------------------------------------
void sub_40B28()
{
  free((void *)dword_76864);
  dword_76864 = 0;
}
// 76864: using guessed type int dword_76864;

//----- (00040B48) --------------------------------------------------------
int sub_40B48(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  return fputc(10, (FILE *)stderr);
}
// 68A68: using guessed type int stderr;

//----- (00040B90) --------------------------------------------------------
void __noreturn sub_40B90(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 68A68: using guessed type int stderr;

//----- (00040BD0) --------------------------------------------------------
char *__fastcall sub_40BD0(const char *a1)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen(a1);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", a1);
  return v3;
}

//----- (00040C00) --------------------------------------------------------
void *__fastcall sub_40C00(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memmove((void *)(a2 + 4 * a3), (const void *)(a2 + 4 * a3 + 4), 4 * (*a1 - a3));
  --*a1;
  return result;
}

//----- (00040C38) --------------------------------------------------------
int __fastcall sub_40C38(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  bool v8; // zf
  int result; // r0
  const char **v10; // r6
  int *v11; // r3
  int v12; // r4
  int v13; // t1
  unsigned __int8 *v14; // r0
  int v15; // lr
  unsigned int v16; // r12
  int v17; // r1
  int v18; // r3
  char *v19; // r10
  int v20; // r3
  int v21; // r1
  char *v22; // r11
  int v23; // r10
  const char *v24; // r0
  int *v25; // r3
  const char *v26; // r7
  int *v27; // r11
  const char *v28; // r10
  size_t v29; // r4
  size_t v30; // lr
  int *v31; // r3
  const char *v32; // r11
  size_t v33; // r0
  int *v34; // r2
  const char *v35; // r11
  const char *v36; // r3
  size_t v37; // r10
  const char *v38; // [sp+8h] [bp-14h]
  int v39; // [sp+Ch] [bp-10h]
  unsigned int v40; // [sp+10h] [bp-Ch] BYREF
  size_t n[2]; // [sp+14h] [bp-8h] BYREF

  v8 = getenv("POSIXLY_CORRECT") == 0;
  result = (int)a2[1];
  if ( !v8 )
  {
    v10 = a2 + 1;
    if ( !result )
      return result;
    if ( *(_BYTE *)result != 45 )
      return 0;
    v12 = 1;
    if ( *(_BYTE *)(result + 1) == 45 )
      goto LABEL_23;
LABEL_15:
    v14 = (unsigned __int8 *)sub_408F4(&v40);
    if ( v14 )
    {
      v15 = *a3 + 1;
      if ( *v14 == (unsigned __int8)(*v10)[v15] )
      {
LABEL_17:
        v16 = v40;
        v38 = (const char *)(v14 - 1);
        *a3 = v15;
        n[0] = 2;
        v17 = 28 * v16;
        v18 = dword_76864 + 28 * v16;
        if ( *(_DWORD *)(v18 + 4) != 1 )
        {
LABEL_18:
          if ( v15 )
          {
            v19 = (char *)&(*v10)[v15 + 1];
            if ( *v19 )
            {
              *a3 = 0;
              goto LABEL_20;
            }
          }
          v19 = (char *)a2[v12 + 1];
          if ( v19 )
            goto LABEL_20;
          a4("%s: %.*s: %s", *a2, n[0], v38, "requires an argument");
          return -1;
        }
LABEL_37:
        v19 = 0;
        v22 = (char *)(*(int (__fastcall **)(_DWORD))(v18 + 8))(*(_DWORD *)(v18 + 20));
        goto LABEL_38;
      }
      while ( 1 )
      {
        v14 = sub_40954((int)v14, &v40);
        if ( !v14 )
          break;
        v15 = *a3 + 1;
        if ( (unsigned __int8)(*v10)[v15] == *v14 )
          goto LABEL_17;
      }
    }
LABEL_36:
    v33 = strlen(*v10);
    a4("%s: %.*s: %s", *a2, v33, *v10, "unrecognized option");
    return -1;
  }
  if ( !result )
    return result;
  if ( *(_BYTE *)result == 45 )
  {
    v10 = a2 + 1;
    v12 = 1;
  }
  else
  {
    v11 = (int *)(a2 + 2);
    v12 = 1;
    do
    {
      v10 = (const char **)v11;
      v13 = *v11++;
      result = v13;
      ++v12;
      if ( !v13 )
        return result;
    }
    while ( *(_BYTE *)result != 45 );
  }
  if ( *(_BYTE *)(result + 1) != 45 )
    goto LABEL_15;
LABEL_23:
  v23 = *(unsigned __int8 *)(result + 2);
  if ( !*(_BYTE *)(result + 2) )
  {
    sub_40C00(a1, (int)a2, v12);
    return v23;
  }
  if ( *a3 )
    _assert_fail("*offset == 0", "ccan/opt/parse.c", 0x3Bu, "parse_one");
  v24 = sub_40844(&v40, n);
  if ( !v24 )
    goto LABEL_36;
  v25 = a3;
  v26 = v24;
  v27 = v25;
  v39 = v12;
  while ( 1 )
  {
    v28 = *v10;
    v29 = n[0];
    if ( strncmp(*v10 + 2, v26, n[0]) )
      goto LABEL_35;
    v30 = v29 + 2;
    if ( v28[v29 + 2] == 61 )
      break;
    if ( !v28[v29 + 2] )
    {
      v16 = v40;
      v31 = v27;
      v32 = v26;
      a3 = v31;
      v12 = v39;
      v38 = v32 - 2;
      v17 = 28 * v40;
      n[0] = v30;
      v18 = dword_76864 + 28 * v40;
      if ( *(_DWORD *)(v18 + 4) == 1 )
        goto LABEL_37;
      goto LABEL_34;
    }
LABEL_35:
    v26 = sub_4089C((int)v26, &v40, n);
    if ( !v26 )
      goto LABEL_36;
  }
  v16 = v40;
  v34 = v27;
  v35 = v26;
  a3 = v34;
  v36 = v28;
  v37 = v29 + 3;
  v12 = v39;
  v17 = 28 * v40;
  v19 = (char *)&v36[v37];
  n[0] = v30;
  v38 = v35 - 2;
  v18 = dword_76864 + 28 * v40;
  if ( *(_DWORD *)(v18 + 4) == 1 )
  {
    if ( v19 )
    {
      a4("%s: %.*s: %s", *a2, v30, v38, "doesn't allow an argument");
      return -1;
    }
    goto LABEL_37;
  }
  if ( !v19 )
  {
LABEL_34:
    v15 = *a3;
    goto LABEL_18;
  }
LABEL_20:
  v20 = dword_76864;
  v21 = dword_76864 + v17;
  if ( *(_DWORD *)(v21 + 4) == 4 )
  {
    sub_4014C((int)v19, *(_DWORD **)(v21 + 20));
    v16 = v40;
    v20 = dword_76864;
  }
  v22 = (char *)(*(int (__fastcall **)(char *, _DWORD))(v20 + 28 * v16 + 12))(v19, *(_DWORD *)(v20 + 28 * v16 + 20));
LABEL_38:
  if ( v22 )
  {
    a4("%s: %.*s: %s", *a2, n[0], v38, v22);
    free(v22);
    return -1;
  }
  else
  {
    if ( *a3 )
    {
      if ( !(*v10)[*a3 + 1] )
      {
        *a3 = 0;
        goto LABEL_42;
      }
    }
    else
    {
LABEL_42:
      sub_40C00(a1, (int)a2, v12);
      if ( v19 )
      {
        if ( *v10 == v19 )
          sub_40C00(a1, (int)a2, v12);
      }
    }
    return 1;
  }
}
// 76864: using guessed type int dword_76864;

//----- (000410E8) --------------------------------------------------------
char *__fastcall sub_410E8(const char *a1, const char *a2)
{
  size_t v3; // r7
  int v4; // r4
  unsigned int v5; // r8
  size_t v6; // r7
  size_t v7; // r0
  size_t v8; // r7
  size_t v9; // r5
  const char *v10; // r11
  char *v11; // r0
  char *v12; // r4
  int v13; // r0
  char *v14; // r1
  char *v15; // r4
  char *v16; // r7
  char *v17; // r12
  int v18; // r8
  int v19; // r0
  int v20; // r2
  char *v21; // r5
  int v22; // r7
  unsigned int v23; // r8
  int v24; // r2
  unsigned int v25; // r4
  unsigned int v26; // r4
  char *v27; // r3
  int v28; // r3
  const char *v29; // r2
  int v30; // r0
  unsigned int v31; // r4
  char *v32; // r3
  char *v33; // r0
  char *v34; // r0
  int v36; // r2
  int v37; // r3
  __int16 *v39; // [sp+0h] [bp-74h]
  const char *v40; // [sp+4h] [bp-70h]
  char *s; // [sp+8h] [bp-6Ch]
  char *v42; // [sp+10h] [bp-64h]
  char *v43; // [sp+14h] [bp-60h]
  unsigned int v44[22]; // [sp+1Ch] [bp-58h] BYREF

  v3 = dword_76860 + 20 + strlen(a1);
  if ( a2 )
  {
    v3 += strlen(a2);
    if ( !dword_7686C )
      goto LABEL_13;
    v4 = dword_76864;
  }
  else
  {
    if ( !dword_7686C )
    {
      a2 = "";
      goto LABEL_13;
    }
    v36 = 0;
    v4 = dword_76864;
    v37 = dword_76864;
    do
    {
      ++v36;
      if ( *(void (__fastcall __noreturn **)(int))(v37 + 8) == sub_40368 )
      {
        a2 = *(const char **)(v37 + 20);
        if ( a2 )
        {
          v3 += strlen(*(const char **)(v37 + 20));
          goto LABEL_4;
        }
      }
      v37 += 28;
    }
    while ( v36 != dword_7686C );
    a2 = "";
  }
LABEL_4:
  v5 = 0;
  v40 = a2;
  do
  {
    while ( 1 )
    {
      v9 = v3 + 6;
      v10 = *(const char **)(v4 + 24);
      if ( *(_DWORD *)(v4 + 4) != 8 )
        break;
      ++v5;
      v3 += strlen(*(const char **)(v4 + 24)) + 3;
      v4 += 28;
      if ( v5 >= dword_7686C )
        goto LABEL_12;
    }
    if ( v10 != (const char *)&unk_76870 )
    {
      v6 = strlen(*(const char **)v4);
      v7 = v6 + v9 + strlen(v10);
      v8 = v7 + 118;
      if ( !*(_DWORD *)(v4 + 16) )
        v8 = v7 + 21;
      v3 = v8 + 1;
    }
    ++v5;
    v4 += 28;
  }
  while ( v5 < dword_7686C );
LABEL_12:
  a2 = v40;
LABEL_13:
  v11 = (char *)malloc(v3);
  v12 = v11;
  v43 = v11;
  if ( v11 )
  {
    v13 = sprintf(v11, "Usage: %s", a1);
    v14 = v12;
    v15 = &v12[v13];
    v16 = v15 + 3;
    strcpy(&v14[v13], " [-");
    v17 = (char *)sub_408F4(v44);
    if ( v17 )
    {
      v18 = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_76864 + 28 * v44[0] + 24) != &unk_76870 )
          v16[v18++] = *v17;
        v17 = sub_40954((int)v17, v44);
      }
      while ( v17 );
      if ( v18 )
      {
        v15 = &v16[v18 + 1];
        *(_WORD *)&v16[v18] = 93;
      }
    }
    v19 = sprintf(v15, " %s", a2);
    v20 = dword_7686C;
    v39 = &word_4C858;
    v21 = &v15[v19 + 1];
    *(_WORD *)&v15[v19] = 10;
    if ( v20 )
    {
      v22 = 0;
      v23 = 0;
      do
      {
        v28 = dword_76864 + v22;
        v29 = *(const char **)(dword_76864 + v22 + 24);
        if ( v29 != (const char *)&unk_76870 )
        {
          if ( *(_DWORD *)(v28 + 4) == 8 )
          {
            v21 += sprintf(v21, "%s:\n", v29);
          }
          else
          {
            v30 = sprintf(v21, "%s", *(const char **)v28);
            v31 = v30;
            v32 = &v21[v30];
            if ( *(_DWORD *)(dword_76864 + v22 + 4) == 2 )
            {
              v42 = &v21[v30];
              s = *(char **)(dword_76864 + v22);
              v33 = strchr(s, 32);
              v32 = v42;
              if ( !v33 )
              {
                v34 = strchr(s, 61);
                v32 = v42;
                if ( !v34 )
                {
                  v31 += 6;
                  strcpy(v42, " <arg>");
                  v32 = &v21[v31];
                }
              }
            }
            if ( v31 > 0x13 )
              v24 = 1;
            else
              v24 = 20 - v31;
            v25 = sprintf(v32, "%.*s", v24, "                    ", v39) + v31;
            v26 = sprintf(&v21[v25], "%s", *(const char **)(dword_76864 + v22 + 24)) + v25;
            v27 = &v21[v26];
            if ( *(_DWORD *)(dword_76864 + v22 + 16) )
            {
              v44[20] = 3026478;
              (*(void (__fastcall **)(unsigned int *, _DWORD))(dword_76864 + v22 + 16))(
                v44,
                *(_DWORD *)(dword_76864 + v22 + 20));
              v27 = &v21[sprintf(&v21[v26], " (default: %s)", (const char *)v44) + v26];
            }
            *(_WORD *)v27 = *v39;
            v21 = v27 + 1;
          }
        }
        ++v23;
        v22 += 28;
      }
      while ( dword_7686C > v23 );
    }
    *v21 = 0;
  }
  return v43;
}
// 41314: variable 'v39' is possibly undefined
// 4C858: using guessed type __int16 word_4C858;
// 5616C: using guessed type __int16 word_5616C;
// 76860: using guessed type int dword_76860;
// 76864: using guessed type int dword_76864;
// 7686C: using guessed type int dword_7686C;

//----- (0004152C) --------------------------------------------------------
char *__fastcall sub_4152C(char *result, __int16 a2, unsigned int a3)
{
  _DWORD *v3; // r3
  bool v4; // zf
  int v5; // r4
  char *v6; // r12
  char *v7; // r2
  char *v8; // r3

  if ( !a3 )
    return 0;
  if ( ((unsigned __int8)result & 3) != 0 )
  {
    if ( (unsigned __int8)*result == (unsigned __int8)a2 )
      return result;
    v3 = result + 1;
    while ( 1 )
    {
      --a3;
      result = (char *)v3;
      if ( !a3 )
        return 0;
      v4 = ((unsigned __int8)v3 & 3) == 0;
      v3 = (_DWORD *)((char *)v3 + 1);
      if ( v4 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
  }
  v5 = (unsigned __int16)(a2 << 8) | (unsigned __int8)a2 | (((unsigned __int16)(a2 << 8) | (unsigned __int8)a2) << 16);
  if ( a3 > 3 && (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) == 0 )
  {
    v6 = result + 4;
    while ( 1 )
    {
      a3 -= 4;
      result = v6;
      v6 += 4;
      if ( a3 <= 3 )
        break;
      if ( (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) != 0 )
        goto LABEL_16;
    }
    if ( !a3 )
      return 0;
  }
LABEL_16:
  if ( (unsigned __int8)*result != (unsigned __int8)a2 )
  {
    v7 = &result[a3];
    v8 = result + 1;
    while ( 1 )
    {
      result = v8++;
      if ( result == v7 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (00041640) --------------------------------------------------------
unsigned int __fastcall sub_41640(int a1, unsigned int a2, int *a3)
{
  int v3; // r6
  int v4; // r12
  unsigned int v5; // r4
  int v6; // lr
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // r5
  unsigned int v10; // r7
  int v11; // r8
  unsigned int v12; // r4
  int v13; // r12
  int v14; // r5
  unsigned int v15; // r3
  int v16; // r6
  unsigned int v17; // r6
  unsigned int v18; // r7
  unsigned int result; // r0
  unsigned int v20; // r5
  bool v21; // zf

  v3 = 1;
  v4 = 1;
  v5 = 0;
  v6 = -1;
  while ( 1 )
  {
    v7 = v4 + v5;
    v8 = a1 + v6;
    if ( v4 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)(v8 + v4);
      v10 = *(unsigned __int8 *)(a1 + v7);
      if ( v10 >= v9 )
        break;
      v5 = v7;
      v4 = 1;
      v3 = v7 - v6;
      ++v7;
      v8 = a1 + v6;
      if ( v7 >= a2 )
        goto LABEL_5;
    }
    if ( v10 == v9 )
    {
      v21 = v4++ == v3;
      if ( v21 )
      {
        v5 = v7;
        v4 = 1;
      }
    }
    else
    {
      v3 = 1;
      v6 = v5;
      v4 = 1;
      ++v5;
    }
  }
LABEL_5:
  v11 = 1;
  v12 = 0;
  v13 = 1;
  v14 = -1;
  *a3 = v3;
  while ( 1 )
  {
    v15 = v13 + v12;
    v16 = a1 + v14;
    if ( a2 <= v13 + v12 )
      break;
    while ( 1 )
    {
      v17 = *(unsigned __int8 *)(v16 + v13);
      v18 = *(unsigned __int8 *)(a1 + v15);
      if ( v18 <= v17 )
        break;
      v12 = v15;
      v13 = 1;
      v11 = v15 - v14;
      ++v15;
      v16 = a1 + v14;
      if ( a2 <= v15 )
        goto LABEL_9;
    }
    if ( v18 == v17 )
    {
      v21 = v13++ == v11;
      if ( v21 )
      {
        v12 = v15;
        v13 = 1;
      }
    }
    else
    {
      v11 = 1;
      v14 = v12;
      v13 = 1;
      ++v12;
    }
  }
LABEL_9:
  result = v6 + 1;
  v20 = v14 + 1;
  if ( v20 >= v6 + 1 )
  {
    *a3 = v11;
    return v20;
  }
  return result;
}

//----- (00041750) --------------------------------------------------------
int __fastcall sub_41750(int a1, int a2, char *s1, unsigned int a4)
{
  size_t v8; // r4
  size_t v9; // r6
  int *v10; // r3
  char *v11; // r1
  int v12; // r3
  int v13; // t1
  unsigned int v14; // r0
  unsigned int v15; // r3
  bool v16; // cf
  unsigned int v17; // r1
  unsigned int v18; // r1
  char *v19; // lr
  unsigned __int8 *v20; // r12
  int v21; // r9
  int v22; // t1
  int v23; // t1
  unsigned int v24; // lr
  unsigned __int8 *v25; // r1
  char *v26; // r8
  int v27; // r10
  int v28; // t1
  int v29; // t1
  int result; // r0
  size_t v31; // r3
  size_t v32; // r2
  unsigned int v33; // r10
  unsigned int v34; // r9
  int v35; // r3
  unsigned __int8 *v36; // r1
  size_t v37; // r3
  char *v38; // r12
  int v39; // r8
  int v40; // t1
  int v41; // t1
  unsigned __int8 *v42; // r3
  char *v43; // r1
  int v44; // lr
  int v45; // t1
  int v46; // t1
  unsigned int v47; // [sp+0h] [bp-424h]
  unsigned int v48; // [sp+4h] [bp-420h]
  int v49; // [sp+4h] [bp-420h]
  unsigned int v50; // [sp+Ch] [bp-418h]
  int v51[253]; // [sp+1Ch] [bp-408h] BYREF
  int v52; // [sp+41Ch] [bp-8h] BYREF

  v8 = a4 - 1;
  if ( a4 > 2 )
  {
    v9 = sub_41640((int)s1, a4, v51);
    v48 = v51[0];
  }
  else
  {
    v9 = a4 - 1;
    v48 = 1;
    v51[0] = 1;
  }
  v10 = v51;
  do
  {
    v10[1] = a4;
    ++v10;
  }
  while ( v10 != &v52 );
  if ( a4 )
  {
    v11 = s1 - 1;
    v12 = v8;
    do
    {
      v13 = (unsigned __int8)*++v11;
      v51[v13 + 1] = v12;
      v16 = v12-- != 0;
    }
    while ( v16 );
  }
  v14 = memcmp(s1, &s1[v48], v9);
  if ( !v14 )
  {
    v47 = a2 - a4;
    v50 = a4 - v48;
    v15 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = v51[*(unsigned __int8 *)(a1 + v15 + v8) + 1];
        if ( v17 )
        {
          v16 = 1;
          if ( v14 )
            v16 = v17 >= v48;
          v14 = 0;
          if ( !v16 )
            v17 = v50;
          v15 += v17;
          goto LABEL_15;
        }
        v18 = v9 < v14 ? v14 : v9;
        if ( v18 < v8 )
          break;
LABEL_25:
        v24 = v9 - 1;
        if ( v9 > v14 && (v25 = (unsigned __int8 *)(a1 + v9 - 1 + v15), (unsigned __int8)s1[v9 - 1] == *v25) )
        {
          v26 = &s1[v9 - 1];
          while ( v24 - 1 != v14 - 1 )
          {
            v28 = (unsigned __int8)*--v26;
            v27 = v28;
            v29 = *--v25;
            if ( v27 != v29 )
              break;
            --v24;
          }
        }
        else
        {
          v24 = v9;
        }
        if ( v14 + 1 > v24 )
          return a1 + v15;
        v14 = v50;
        v15 += v48;
        if ( v47 < v15 )
          return 0;
      }
      v19 = &s1[v18];
      v20 = (unsigned __int8 *)(a1 + v18 + v15);
      if ( *v20 == (unsigned __int8)s1[v18] )
      {
        while ( ++v18 < v8 )
        {
          v22 = (unsigned __int8)*++v19;
          v21 = v22;
          v23 = *++v20;
          if ( v21 != v23 )
            goto LABEL_35;
        }
        goto LABEL_25;
      }
LABEL_35:
      v14 = 0;
      v15 += v18 + 1 - v9;
LABEL_15:
      if ( v47 < v15 )
        return 0;
    }
  }
  v31 = a4 - v9;
  v32 = v9 - 1;
  v33 = a2 - a4;
  if ( a4 - v9 < v9 )
    v31 = v9;
  v34 = 0;
  v49 = v31 + 1;
  while ( 1 )
  {
    result = a1 + v34;
    v35 = v51[*(unsigned __int8 *)(a1 + v34 + v8) + 1];
    if ( !v35 )
      break;
LABEL_52:
    v34 += v35;
LABEL_53:
    if ( v34 > v33 )
      return 0;
  }
  if ( v9 < v8 )
  {
    v36 = (unsigned __int8 *)(a1 + v9 + v34);
    if ( *v36 != (unsigned __int8)s1[v9] )
    {
      v37 = v9;
LABEL_55:
      v34 += v37 + 1 - v9;
      goto LABEL_53;
    }
    v38 = &s1[v9];
    v37 = v9;
    while ( ++v37 < v8 )
    {
      v40 = (unsigned __int8)*++v38;
      v39 = v40;
      v41 = *++v36;
      if ( v39 != v41 )
        goto LABEL_55;
    }
  }
  if ( !v9 )
    return result;
  v42 = (unsigned __int8 *)(a1 + v32 + v34);
  if ( *v42 != (unsigned __int8)s1[v32] )
  {
LABEL_51:
    v35 = v49;
    goto LABEL_52;
  }
  v43 = &s1[v32];
  while ( v43 != s1 )
  {
    v45 = (unsigned __int8)*--v43;
    v44 = v45;
    v46 = *--v42;
    if ( v44 != v46 )
      goto LABEL_51;
  }
  return result;
}

//----- (00041A7C) --------------------------------------------------------
int __fastcall memmem(char *a1, unsigned int a2, char *a3, unsigned int a4)
{
  char *v6; // r5
  char *v9; // r0
  _BOOL4 v10; // r3
  unsigned int v11; // r7
  size_t v12; // r6
  unsigned int v13; // r0
  unsigned int v14; // r2
  size_t v15; // r12
  size_t v16; // r3
  char *v17; // lr
  char *v18; // r1
  int v19; // r8
  int v20; // t1
  int v21; // t1
  unsigned int v22; // lr
  char *v23; // r3
  char *v24; // r7
  int v25; // r9
  int v26; // t1
  int v27; // t1
  size_t v29; // r3
  size_t v30; // r9
  unsigned int v31; // r0
  unsigned int v32; // r7
  char *v33; // r2
  size_t v34; // r3
  char *v35; // r1
  int v36; // lr
  int v37; // t1
  int v38; // t1
  char *v39; // r3
  char *v40; // r2
  int v41; // r12
  int v42; // t1
  int v43; // t1
  int v44; // [sp+4h] [bp-20h]
  int v45; // [sp+8h] [bp-1Ch]
  int v46; // [sp+1Ch] [bp-8h] BYREF

  if ( !a4 )
    return (int)a1;
  if ( a4 > a2 )
    return 0;
  if ( a4 > 0x1F )
    return sub_41750((int)a1, a2, a3, a4);
  v9 = sub_4152C(a1, (unsigned __int8)*a3, a2);
  v6 = v9;
  v10 = a4 == 1;
  if ( !v9 )
    v10 = 1;
  if ( v10 )
    return (int)v6;
  v11 = a2 - (v9 - a1);
  if ( a4 > v11 )
    return 0;
  if ( a4 > 2 )
  {
    v12 = sub_41640((int)a3, a4, &v46);
    v45 = v46;
  }
  else
  {
    v12 = a4 - 1;
    v45 = 1;
    v46 = 1;
  }
  v13 = memcmp(a3, &a3[v45], v12);
  if ( !v13 )
  {
    v14 = v11 - a4;
    v15 = 0;
    while ( 1 )
    {
      if ( v12 < v15 )
        v16 = v15;
      else
        v16 = v12;
      if ( a4 > v16 )
      {
        v17 = &a3[v16];
        v18 = &v6[v16 + v13];
        if ( a3[v16] != *v18 )
        {
LABEL_32:
          v15 = 0;
          v13 += 1 - v12 + v16;
          goto LABEL_29;
        }
        while ( a4 != ++v16 )
        {
          v20 = (unsigned __int8)*++v17;
          v19 = v20;
          v21 = (unsigned __int8)*++v18;
          if ( v19 != v21 )
            goto LABEL_32;
        }
      }
      v22 = v12 - 1;
      if ( v12 > v15 && (v23 = &v6[v12 - 1 + v13], a3[v12 - 1] == *v23) )
      {
        v24 = &a3[v12 - 1];
        while ( v22 - 1 != v15 - 1 )
        {
          v26 = (unsigned __int8)*--v24;
          v25 = v26;
          v27 = (unsigned __int8)*--v23;
          if ( v25 != v27 )
            break;
          --v22;
        }
      }
      else
      {
        v22 = v12;
      }
      if ( v15 + 1 > v22 )
      {
        v6 += v13;
        return (int)v6;
      }
      v15 = a4 - v45;
      v13 += v45;
LABEL_29:
      if ( v14 < v13 )
        return 0;
    }
  }
  v29 = a4 - v12;
  v30 = v12 - 1;
  v31 = v11 - a4;
  if ( a4 - v12 < v12 )
    v29 = v12;
  v32 = 0;
  v44 = v29 + 1;
  while ( 1 )
  {
    if ( a4 > v12 )
    {
      v33 = &v6[v12 + v32];
      if ( *v33 != a3[v12] )
      {
        v34 = v12;
LABEL_49:
        v32 += 1 - v12 + v34;
        goto LABEL_50;
      }
      v35 = &a3[v12];
      v34 = v12;
      while ( a4 != ++v34 )
      {
        v37 = (unsigned __int8)*++v35;
        v36 = v37;
        v38 = (unsigned __int8)*++v33;
        if ( v36 != v38 )
          goto LABEL_49;
      }
    }
    if ( !v12 )
      return (int)&v6[v32];
    v39 = &v6[v30 + v32];
    if ( *v39 == a3[v30] )
      break;
LABEL_52:
    v32 += v44;
LABEL_50:
    if ( v31 < v32 )
      return 0;
  }
  v40 = &a3[v30];
  while ( v40 != a3 )
  {
    v42 = (unsigned __int8)*--v40;
    v41 = v42;
    v43 = (unsigned __int8)*--v39;
    if ( v41 != v43 )
      goto LABEL_52;
  }
  return (int)&v6[v32];
}

//----- (00041D64) --------------------------------------------------------
int __fastcall sub_41D64(unsigned __int8 *a1, int a2)
{
  int v3; // r8
  unsigned int v4; // r7
  size_t v5; // r10
  void *v6; // r0
  void *v7; // r0
  size_t v8; // r9
  unsigned __int8 *v9; // r4
  void *v10; // r0
  void *v11; // r0
  size_t v12; // r10
  void *v13; // r0
  int result; // r0
  _DWORD v15[112]; // [sp+0h] [bp-9C0h] BYREF
  char s[2048]; // [sp+1C0h] [bp-800h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    snprintf(s, 0x800u, "got nonce sz %d", a2);
    sub_20F58(5, s, 0);
  }
  v3 = *a1;
  v4 = *(_DWORD *)(a1 + 1);
  memcpy(v15, a1 + 5, sizeof(v15));
  v5 = a1[453];
  v6 = calloc(1u, v5);
  v7 = memcpy(v6, a1 + 454, v5);
  v8 = a1[v5 + 454];
  v9 = &a1[v5 + 455];
  v15[72] = v7;
  v10 = calloc(1u, v8);
  v11 = memcpy(v10, v9, v8);
  v12 = v9[v8];
  v15[77] = v11;
  v13 = calloc(1u, v12);
  v15[80] = memcpy(v13, &v9[v8 + 1], v12);
  v15[82] = calloc(1u, 1u);
  v15[65] = *(_DWORD *)(dword_744C8 + 4 * v3);
  v15[63] = *(_DWORD *)dword_744A4;
  v15[64] = **(_DWORD **)dword_744A4;
  if ( sub_2DC68(*(_DWORD *)dword_744A4, v4) && sub_2DBFC((int)v15, v4) )
  {
    sub_3E82C(*(_DWORD *)dword_744A4, (int)v15);
    if ( dword_766C0 && byte_7449D )
      sub_2CCF0((int)v15, v4);
    if ( byte_74500 || (result = (unsigned __int8)byte_68BD4, byte_68BD4) || dword_67DB4 > 4 )
    {
      snprintf(s, 0x800u, "%s nonce submited", "cb_bitmain_submit_nonce");
      sub_20F58(5, s, 0);
      return 0;
    }
  }
  else
  {
    sub_331A4(*(_DWORD *)dword_744A4);
    return -1;
  }
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 7449D: using guessed type char byte_7449D;
// 744A4: using guessed type int dword_744A4;
// 744C8: using guessed type int dword_744C8;
// 74500: using guessed type char byte_74500;
// 766C0: using guessed type int dword_766C0;

//----- (00041FA8) --------------------------------------------------------
int __fastcall sub_41FA8(const void *a1, size_t a2)
{
  _BOOL4 v2; // r4
  void *v5; // r0
  int *v6; // r2
  int v7; // r1
  size_t v8; // r10
  int v9; // r6
  int v10; // r1
  int v11; // lr
  size_t v12; // r4
  int v13; // r12
  int v14; // r8
  _DWORD *v15; // r6
  int v16; // r1
  int *v18; // r0
  int *v19; // r0
  int *v20; // r0
  int *v21; // r0
  int *v22; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( a1 )
    v2 = a2 == 0;
  else
    v2 = 1;
  if ( !byte_68BD5 )
  {
LABEL_26:
    if ( !v2 )
      goto LABEL_9;
    if ( byte_74500 || byte_68BD4 )
    {
LABEL_31:
      snprintf(s, 0x800u, "%s input err: data @ %p; len is %d", "cb_bitmain_api_stats", a1, a2);
      sub_20F58(3, s, 0);
      return -1;
    }
LABEL_29:
    if ( dword_67DB4 <= 2 )
      return -1;
    goto LABEL_31;
  }
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
  {
    snprintf(s, 0x800u, "got api len %d", a2);
    sub_20F58(7, s, 0);
    goto LABEL_26;
  }
  if ( v2 )
    goto LABEL_29;
LABEL_9:
  if ( pthread_mutex_lock(&stru_76874) )
  {
    v18 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v18,
      "socketa_api.c",
      "cb_bitmain_api_stats",
      116);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  dword_6ACD0 = a2;
  if ( dword_6ACD4 )
    free((void *)dword_6ACD4);
  v5 = malloc(a2);
  dword_6ACD4 = (int)v5;
  if ( v5 )
  {
    memcpy(v5, a1, dword_6ACD0);
    if ( pthread_mutex_lock(&stru_7688C) )
    {
      v19 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v19,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        134);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
    v6 = (int *)(dword_6ACD4 + a2 - 296);
    v7 = v6[1];
    dword_6ACD8 = *v6;
    dword_6ACDC = v7;
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      snprintf(s, 0x800u, "[%s], hash 0x%llx", "cb_bitmain_api_stats", *(_QWORD *)&dword_6ACD8);
      sub_20F58(7, s, 0);
    }
    if ( pthread_mutex_unlock(&stru_7688C) )
    {
      v21 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v21,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        138);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
    v8 = a2 - 284;
    off_67ED8();
    v9 = dword_6ACD4;
    v10 = *(_DWORD *)(dword_6ACD4 + a2 - 288);
    dword_73368 = v10;
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      snprintf(s, 0x800u, "[%s], hwerr %d", "cb_bitmain_api_stats", v10);
      sub_20F58(7, s, 0);
      v9 = dword_6ACD4;
    }
    v11 = *(_DWORD *)(v9 + v8 + 8);
    v12 = v9 + a2;
    v13 = *(_DWORD *)(v9 + v8 + 12);
    v14 = *(_DWORD *)(v9 + v8);
    dword_6ABA8 = *(_DWORD *)(v9 + v8 + 4);
    dword_6ABAC = v11;
    dword_6ABB0 = v13;
    v15 = (_DWORD *)(v9 + a2 - 12);
    dword_6ABA4 = v14;
    memcpy(byte_6ABC0, (const void *)(v12 - 268), 0x100u);
    v16 = v15[1];
    LODWORD(dbl_6ABB8) = *v15;
    HIDWORD(dbl_6ABB8) = v16;
    dword_687F4[0] = *(_DWORD *)(v12 - 4);
    if ( pthread_mutex_unlock(&stru_76874) )
    {
      v20 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v20,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        157);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
    off_67ED8();
    return 0;
  }
  else
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      snprintf(s, 0x800u, "%s, alloc failed", "cb_bitmain_api_stats");
      sub_20F58(3, s, 0);
    }
    if ( pthread_mutex_unlock(&stru_76874) )
    {
      v22 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v22,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        126);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
    off_67ED8();
    return -2;
  }
}
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 687F4: using guessed type int dword_687F4[4];
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 6ABA4: using guessed type int dword_6ABA4;
// 6ABA8: using guessed type int dword_6ABA8;
// 6ABAC: using guessed type int dword_6ABAC;
// 6ABB0: using guessed type int dword_6ABB0;
// 6ABB8: using guessed type double dbl_6ABB8;
// 6ACD0: using guessed type int dword_6ACD0;
// 6ACD4: using guessed type int dword_6ACD4;
// 6ACD8: using guessed type int dword_6ACD8;
// 6ACDC: using guessed type int;
// 73368: using guessed type int dword_73368;
// 74500: using guessed type char byte_74500;
// 76874: using guessed type pthread_mutex_t stru_76874;
// 7688C: using guessed type pthread_mutex_t stru_7688C;

//----- (00042554) --------------------------------------------------------
int __fastcall sub_42554(const void *a1, size_t a2)
{
  char v5[2048]; // [sp+8h] [bp-800h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    strcpy(v5, "about to send detect");
    sub_20F58(5, v5, 0);
  }
  return sub_44264((int)aBitmainApiDete, a1, a2, v5);
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00042610) --------------------------------------------------------
int __fastcall sub_42610(const void *a1, size_t a2)
{
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    snprintf(s, 0x800u, "about to send job, size is %d", a2);
    sub_20F58(5, s, 0);
  }
  return sub_44264((int)aBitmainUpdateJ, a1, a2, s);
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (000426C4) --------------------------------------------------------
int __fastcall sub_426C4(const void *a1, size_t a2)
{
  char v5[2048]; // [sp+8h] [bp-800h] BYREF

  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    strcpy(v5, "about to send shutdown");
    sub_20F58(7, v5, 0);
  }
  return sub_44264((int)aBitmainShutdow, a1, a2, v5);
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 74500: using guessed type char byte_74500;

//----- (0004279C) --------------------------------------------------------
int sub_4279C()
{
  int v0; // r5
  char *v1; // r4
  int *v3; // r0
  int *v4; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( pthread_mutex_init(&stru_76874, 0) )
  {
    v3 = _errno_location();
    snprintf(
      s,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v3,
      "socketa_api.c",
      "cgminer_socket_init",
      256);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( pthread_mutex_init(&stru_7688C, 0) )
  {
    v4 = _errno_location();
    snprintf(
      s,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      "socketa_api.c",
      "cgminer_socket_init",
      257);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  v0 = sub_43D64((int)&off_55DAC, 2);
  sleep(6u);
  if ( v0 )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      snprintf(s, 0x800u, "%s trans init failed: %d", "cgminer_socket_init", v0);
      sub_20F58(3, s, 0);
    }
  }
  else
  {
    while ( 1 )
    {
      v1 = aBitmainApiDete;
      v0 = 0;
      do
      {
        v0 |= sub_43FA4((int)v1);
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
        {
          snprintf(s, 0x800u, "%s reg %s return: %d", "cgminer_socket_init", v1, v0);
          sub_20F58(5, s, 0);
        }
        v1 += 132;
      }
      while ( v1 != (char *)&unk_689C8 );
      if ( !v0 )
        break;
      sleep(5u);
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf(s, 0x800u, "%s reg failed wait 5s", "cgminer_socket_init");
        sub_20F58(3, s, 0);
      }
    }
  }
  return v0;
}
// 55DAC: using guessed type int (*off_55DAC)();
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;
// 76874: using guessed type pthread_mutex_t stru_76874;
// 7688C: using guessed type pthread_mutex_t stru_7688C;

//----- (00042A18) --------------------------------------------------------
int sub_42A18()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  int result; // r0
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = calloc(1u, 0x188u);
  v1 = v0;
  if ( !v0 )
    _assert_fail("cgpu", "driver-btm-c5_socketa.c", 0x28u, "bitmain_c5_detect");
  v0[1] = &unk_689C8;
  v0[8] = 0;
  v0[37] = 1;
  if ( sub_4279C() )
  {
    if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
    {
      strcpy(v3, "cgminer socket init failes.");
      sub_20F58(3, v3, 0);
    }
  }
  else if ( byte_74500 || byte_68BD4 || dword_67DB4 > 5 )
  {
    strcpy(v3, "cgminer socket init succeeds.");
    sub_20F58(6, v3, 0);
  }
  if ( dword_68DE8 )
    sub_3FB54();
  result = sub_3EFD4(v1);
  if ( !result )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-c5_socketa.c", 0x3Cu, "bitmain_c5_detect");
  return result;
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 68DE8: using guessed type int dword_68DE8;
// 74500: using guessed type char byte_74500;

//----- (00042BA0) --------------------------------------------------------
void sub_42BA0()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  snprintf(v0, 0x800u, "%s: bitmain_shutdown failed.", "bitmain_c5_shutdown");
  sub_20F58(3, v0, 0);
}

//----- (00042BE4) --------------------------------------------------------
void sub_42BE4()
{
  if ( sub_426C4(0, 0) && (byte_74500 || byte_68BD4 || dword_67DB4 > 2) )
    sub_42BA0();
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (00042C44) --------------------------------------------------------
int sub_42C44()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  snprintf(v1, 0x800u, "%s: api detect failed.", "bitmain_c5_prepare");
  sub_20F58(3, v1, 0);
  return 0;
}

//----- (00042DD4) --------------------------------------------------------
int __fastcall sub_42DD4(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "driver-btm-c5_socketa.c", a2, a3);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  return result;
}

//----- (00042E50) --------------------------------------------------------
void __fastcall __noreturn sub_42E50(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "driver-btm-c5_socketa.c", a1, a2);
  sub_20F58(3, s, 1);
  sub_3EBA0(1);
}

//----- (00042EB4) --------------------------------------------------------
__int64 sub_42EB4()
{
  __int64 v0; // r6

  v0 = qword_6ACD8;
  if ( qword_6ACD8 )
  {
    if ( pthread_mutex_lock(&stru_7688C) )
      sub_42E50("bitmain_c5_scanhash", 159);
    qword_6ACD8 = 0;
    sub_42DD4(&stru_7688C, "bitmain_c5_scanhash", 161);
    off_67ED8();
  }
  sub_23B9C();
  return v0;
}
// 67ED8: using guessed type int (*off_67ED8)();
// 6ACD8: using guessed type __int64 qword_6ACD8;
// 7688C: using guessed type pthread_mutex_t stru_7688C;

//----- (00042F3C) --------------------------------------------------------
const char *sub_42F3C()
{
  const char *v0; // r7
  unsigned int v1; // r4
  const char *v2; // r5
  int v3; // r6
  size_t v4; // r0
  const char *v5; // r8
  size_t v6; // r5
  size_t v7; // r0
  int v8; // r3
  int *v10; // r0
  int *v11; // r0
  int *v12; // r0
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v0 = (const char *)dword_6ACD4;
  if ( !dword_6ACD4 )
    return v0;
  if ( pthread_mutex_lock(&stru_76874) )
  {
    v10 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v10,
      "driver-btm-c5_socketa.c",
      "bitmain_api_stats",
      387);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  if ( dword_6ACD0 == 296 )
  {
    v0 = 0;
LABEL_14:
    if ( pthread_mutex_unlock(&stru_76874) )
    {
      v11 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v11,
        "driver-btm-c5_socketa.c",
        "bitmain_api_stats",
        413);
      sub_20F58(3, s, 1);
      sub_3EBA0(1);
    }
    off_67ED8();
    return v0;
  }
  v1 = 0;
  v0 = 0;
  do
  {
    v2 = (const char *)(dword_6ACD4 + v1 + 4);
    v3 = *(_DWORD *)(dword_6ACD4 + v1);
    v4 = strlen(v2) + v1 + 5;
    v5 = (const char *)(dword_6ACD4 + v4);
    if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
    {
      snprintf(
        s,
        0x800u,
        "[%s], update %s type %d value 0x%x",
        "bitmain_api_stats",
        v2,
        v3,
        *(unsigned __int8 *)(dword_6ACD4 + v4));
      sub_20F58(7, s, 0);
    }
    v0 = sub_18850((int)v0, v2, v3, v5, 1);
    v6 = strlen(v2);
    switch ( v3 )
    {
      case 0:
      case 1:
      case 2:
        v7 = strlen(v5) + 1;
        break;
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 16:
      case 19:
      case 22:
      case 26:
        v7 = 4;
        break;
      case 10:
      case 11:
      case 12:
      case 13:
      case 15:
      case 17:
      case 18:
      case 20:
      case 21:
      case 23:
      case 24:
      case 25:
        v7 = 8;
        break;
      case 14:
        v7 = 1;
        break;
      default:
        if ( byte_74500 || (v7 = (unsigned __int8)byte_68BD4, byte_68BD4) || dword_67DB4 > 2 )
        {
          snprintf(s, 0x800u, "Should not happy for unknown data type %d", v3);
          sub_20F58(3, s, 0);
          v7 = 0;
        }
        break;
    }
    v1 += v7 + v6 + 5;
    v8 = dword_6ACD0 - 296;
  }
  while ( dword_6ACD0 - 296 > v1 );
  if ( v8 == v1 )
    goto LABEL_14;
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
  {
    snprintf(s, 0x800u, "length mismatch; sckt %d; actual %d", v8, v1);
    sub_20F58(3, s, 0);
  }
  if ( pthread_mutex_unlock(&stru_76874) )
  {
    v12 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v12,
      "driver-btm-c5_socketa.c",
      "bitmain_api_stats",
      407);
    sub_20F58(3, s, 1);
    sub_3EBA0(1);
  }
  off_67ED8();
  return 0;
}
// 43084: control flows out of bounds to 43088
// 67DB4: using guessed type int dword_67DB4;
// 67ED8: using guessed type int (*off_67ED8)();
// 68BD4: using guessed type char byte_68BD4;
// 68BD5: using guessed type char byte_68BD5;
// 6ACD0: using guessed type int dword_6ACD0;
// 6ACD4: using guessed type int dword_6ACD4;
// 74500: using guessed type char byte_74500;
// 76874: using guessed type pthread_mutex_t stru_76874;

//----- (00043370) --------------------------------------------------------
char *__fastcall sub_43370(int a1, size_t *a2)
{
  __int64 v2; // d0
  const char *v4; // r7
  int v5; // r10
  size_t v6; // r11
  const char *v7; // r6
  size_t v8; // r5
  int v9; // r8
  size_t v10; // r4
  char *v11; // r0
  char *v12; // r5
  size_t v13; // r2
  size_t v14; // r11
  _DWORD **v15; // r11
  char *v16; // r3
  _DWORD **v17; // r10
  _DWORD *v18; // t1
  int v19; // lr
  int v20; // r12
  int v21; // r0
  int v22; // lr
  int v23; // r12
  int v24; // r0
  size_t v25; // r8
  size_t v26; // r11
  size_t v27; // r7
  size_t v28; // r11
  int v29; // lr
  double *v30; // r3
  size_t v31; // r11
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  sub_1D4E4();
  v4 = *(const char **)(a1 + 672);
  v5 = *(_DWORD *)(a1 + 1708);
  v6 = *(_DWORD *)(a1 + 1572);
  v7 = *(const char **)(a1 + 612);
  v8 = strlen(v4);
  v9 = 32 * v5;
  v10 = v6 + 1866 + 32 * v5 + v8 + strlen(v7);
  v11 = (char *)calloc(1u, v10);
  v12 = v11;
  if ( v11 )
  {
    memcpy(v11, (const void *)a1, 0x738u);
    memcpy(v12 + 1848, *(const void **)(a1 + 1568), v6);
    v13 = v6 + 1848;
    v14 = v6 + 1848;
    if ( v5 > 0 )
    {
      v15 = *(_DWORD ***)(a1 + 676);
      v16 = &v12[v13];
      v17 = &v15[v5];
      do
      {
        v18 = *v15++;
        v16 += 32;
        v19 = v18[1];
        v20 = v18[2];
        v21 = v18[3];
        *((_DWORD *)v16 - 8) = *v18;
        *((_DWORD *)v16 - 7) = v19;
        *((_DWORD *)v16 - 6) = v20;
        *((_DWORD *)v16 - 5) = v21;
        v22 = v18[5];
        v23 = v18[6];
        v24 = v18[7];
        *((_DWORD *)v16 - 4) = v18[4];
        *((_DWORD *)v16 - 3) = v22;
        *((_DWORD *)v16 - 2) = v23;
        *((_DWORD *)v16 - 1) = v24;
      }
      while ( v15 != v17 );
      v14 = v9 + v13;
    }
    v25 = strlen(v4) + 1;
    memcpy(&v12[v14], v4, v25);
    v26 = v25 + v14;
    v27 = strlen(v7);
    memcpy(&v12[v26], v7, v27 + 1);
    v28 = v26 + v27;
    v29 = (unsigned __int8)byte_74500;
    *(_QWORD *)&v12[v28 + 1] = v2;
    v30 = (double *)&v12[v28 + 9];
    v31 = v28 + 17;
    *v30 = dbl_68748;
    if ( v29 || byte_68BD4 || dword_67DB4 > 4 )
    {
      snprintf(s, 0x800u, "job buf total len:%d, offset:%d\n", v10, v31);
      sub_20F58(5, s, 0);
    }
    *a2 = v10;
    return v12;
  }
  if ( !byte_74500 && !byte_68BD4 && dword_67DB4 <= 2 )
    return v12;
  snprintf(s, 0x800u, "malloc temp job data buf failed: %d\n", v10);
  sub_20F58(3, s, 0);
  return 0;
}
// 434D0: variable 'v2' is possibly undefined
// 67DB4: using guessed type int dword_67DB4;
// 68748: using guessed type double dbl_68748;
// 68BD4: using guessed type char byte_68BD4;
// 74500: using guessed type char byte_74500;

//----- (000435E4) --------------------------------------------------------
void __fastcall sub_435E4(int a1)
{
  int v1; // r5
  void *v2; // r1
  int v3; // r0
  char *v4; // r0
  char *v5; // r5
  void **v6; // [sp+0h] [bp-808h] BYREF
  size_t v7; // [sp+4h] [bp-804h] BYREF
  char v8[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = **(_DWORD **)(a1 + 152);
  if ( byte_74500 || byte_68BD4 || dword_67DB4 > 4 )
  {
    strcpy(v8, "update job");
    sub_20F58(5, v8, 0);
  }
  v2 = *(void **)v1;
  *(_BYTE *)(v1 + 63) = 0;
  *(_BYTE *)(v1 + 62) = 0;
  v6 = sub_36CD4(v1, v2);
  sub_2CEA0(&v6, "driver-btm-c5_socketa.c", "bitmain_c5_update", 261);
  v3 = sub_31FF4();
  if ( !*(_BYTE *)(v3 + 640) )
  {
    strcpy(v8, "Bitmain S9 has to use stratum pools");
    sub_20F58(3, v8, 1);
    sub_3EBA0(1);
  }
  if ( dword_69178 )
  {
    *(_BYTE *)(v3 + 680) = 1;
    dword_69178 = 0;
  }
  v4 = sub_43370(v3, &v7);
  v5 = v4;
  if ( v7 && sub_42610(v4, v7) && (byte_74500 || byte_68BD4 || dword_67DB4 > 2) )
  {
    snprintf(v8, 0x800u, "%s: update job failed.", "bitmain_c5_update");
    sub_20F58(3, v8, 0);
  }
  free(v5);
}
// 67DB4: using guessed type int dword_67DB4;
// 68BD4: using guessed type char byte_68BD4;
// 69178: using guessed type int dword_69178;
// 74500: using guessed type char byte_74500;

//----- (000437BC) --------------------------------------------------------
int __fastcall sub_437BC(int a1)
{
  pthread_t v2; // r0
  int v3; // r7
  int v4; // r4
  int v5; // r4
  _DWORD *v6; // r0
  int v7; // r11
  _DWORD *v8; // r10
  const char *v9; // r5
  int v10; // r0
  int v11; // r3
  size_t v12; // r0
  int v13; // r10
  size_t v14; // r0
  size_t v16; // r0
  int v17; // [sp+10h] [bp-1DCh] BYREF
  pthread_t newthread; // [sp+14h] [bp-1D8h] BYREF
  _BYTE v19[8]; // [sp+18h] [bp-1D4h] BYREF
  int v20; // [sp+20h] [bp-1CCh]
  int v21; // [sp+24h] [bp-1C8h]
  char src[4]; // [sp+28h] [bp-1C4h] BYREF
  int v23; // [sp+2Ch] [bp-1C0h]
  int v24; // [sp+30h] [bp-1BCh]
  int v25; // [sp+34h] [bp-1B8h]
  int v26; // [sp+38h] [bp-1B4h]
  int v27; // [sp+3Ch] [bp-1B0h]
  int v28; // [sp+40h] [bp-1ACh]
  int v29; // [sp+44h] [bp-1A8h]
  char s1[4]; // [sp+48h] [bp-1A4h] BYREF
  int v31; // [sp+4Ch] [bp-1A0h]
  int v32; // [sp+50h] [bp-19Ch]
  int v33; // [sp+54h] [bp-198h]
  int v34; // [sp+58h] [bp-194h]
  int v35; // [sp+5Ch] [bp-190h]
  int v36; // [sp+60h] [bp-18Ch]
  int v37; // [sp+64h] [bp-188h]
  _DWORD buf[32]; // [sp+68h] [bp-184h] BYREF
  char v39[4]; // [sp+E8h] [bp-104h] BYREF
  _BYTE v40[252]; // [sp+ECh] [bp-100h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v21 = 0;
  qmemcpy(v19, "ct_a/mai", sizeof(v19));
  v20 = *(unsigned __int16 *)"n";
  prctl(15, v19);
  v3 = *(_DWORD *)(a1 + 8);
  while ( 1 )
  {
    memset(buf, 0, sizeof(buf));
    if ( recv(v3, buf, 0x80u, 0) <= 0 )
      return 0;
    *(_DWORD *)src = 0;
    v23 = 0;
    *(_DWORD *)s1 = 0;
    v31 = 0;
    v17 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    _isoc99_sscanf(buf, "%x%s%s", &v17, s1, src);
    v4 = strcmp(s1, "regist");
    if ( v4 )
    {
      v5 = dword_6ACE0 + 1;
      memcpy((char *)&unk_6AD08 + 128 * dword_6ACE0, buf, 0x80u);
      dword_6ACE0 = v5;
    }
    else
    {
      v6 = calloc(0x98u, 1u);
      v7 = dword_6ACE4;
      v8 = v6;
      if ( !dword_6ACE4 )
        goto LABEL_18;
      v9 = s2;
      while ( 1 )
      {
        v10 = strcmp(src, v9);
        v9 += 136;
        if ( !v10 )
          break;
        if ( ++v4 == v7 )
          goto LABEL_11;
      }
      v11 = *((_DWORD *)&unk_6ED08 + 34 * v4 + 33);
      v8[3] = *((_DWORD *)&unk_6ED08 + 34 * v4);
      v8[37] = v11;
LABEL_11:
      if ( v7 == v4 )
      {
LABEL_18:
        *(_DWORD *)v39 = 0;
        memset(v40, 0, sizeof(v40));
        sprintf(v39, "%x %d %s %s %s", 63, 0, "reg_resp", "no_name", src);
        v16 = strlen(v39);
        send(v3, v39, v16 + 1, 0);
        free(v8);
      }
      else
      {
        *v8 = dword_68A40;
        v12 = strlen(src);
        memcpy(v8 + 4, src, v12 + 1);
        v8[36] = 0;
        pthread_create(&newthread, 0, (void *(*)(void *))sub_43ADC, v8);
        while ( !v8[36] )
          usleep(0x2710u);
        v13 = *v8;
        *(_DWORD *)v39 = 0;
        if ( v13 != dword_68A40 )
          dword_68A40 = v13;
        memset(v40, 0, sizeof(v40));
        sprintf(v39, "%x %d %s %s %s", 63, v13, "reg_resp", "OK", src);
        v14 = strlen(v39);
        send(v3, v39, v14 + 1, 0);
        ++dword_68A40;
      }
    }
  }
}
// 122D4: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 68A40: using guessed type int dword_68A40;
// 6ACE0: using guessed type int dword_6ACE0;
// 6ACE4: using guessed type int dword_6ACE4;

//----- (00043ADC) --------------------------------------------------------
int __fastcall sub_43ADC(int a1)
{
  pthread_t v2; // r0
  unsigned int v3; // r2
  int v4; // r0
  int v5; // r4
  unsigned int i; // r3
  int v7; // r5
  size_t v8; // r0
  void *v9; // r6
  ssize_t v10; // r1
  int (__fastcall *v11)(void *, ssize_t); // r4
  size_t v12; // r0
  size_t n; // [sp+Ch] [bp-240h]
  int v15; // [sp+10h] [bp-23Ch] BYREF
  socklen_t v16; // [sp+14h] [bp-238h] BYREF
  char s[4]; // [sp+18h] [bp-234h] BYREF
  int v18; // [sp+1Ch] [bp-230h]
  int v19; // [sp+20h] [bp-22Ch]
  int v20; // [sp+24h] [bp-228h]
  struct sockaddr addr; // [sp+28h] [bp-224h] BYREF
  struct sockaddr v22; // [sp+38h] [bp-214h] BYREF
  char buf[4]; // [sp+48h] [bp-204h] BYREF
  char v24[252]; // [sp+4Ch] [bp-200h] BYREF
  char v25[4]; // [sp+148h] [bp-104h] BYREF
  _BYTE v26[252]; // [sp+14Ch] [bp-100h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v3 = *(_DWORD *)a1;
  *(_DWORD *)s = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  sprintf(s, "ct_a/fcb/%d", v3);
  prctl(15, s);
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  v4 = socket(2, 1, 0);
  v5 = v4;
  if ( v4 < 0 )
  {
    perror("socket error");
    return 0;
  }
  else
  {
    v15 = 1;
    if ( setsockopt(v4, 1, 2, &v15, 4u) < 0 )
    {
      perror("set sockopt err");
      return 0;
    }
    else
    {
      for ( i = *(_DWORD *)a1; ; *(_DWORD *)a1 = i )
      {
        *(_WORD *)addr.sa_data = __rev16(i);
        if ( bind(v5, &addr, 0x10u) >= 0 )
          break;
        perror("bind error");
        i = *(_DWORD *)a1 + 1;
      }
      if ( listen(v5, 5) < 0 )
      {
        perror("listen error");
      }
      else
      {
        v16 = 16;
        *(_DWORD *)(a1 + 144) = 1;
        v7 = accept(v5, &v22, &v16);
        if ( v7 >= 0 )
        {
          *(_DWORD *)buf = 0;
          memset(v24, 0, sizeof(v24));
          sprintf(buf, "%x %s\n", 63, (const char *)(a1 + 16));
          v8 = strlen(buf);
          send(v7, buf, v8 + 1, 0);
          n = *(_DWORD *)(a1 + 148);
          v9 = malloc(n);
          recv(v7, v9, n, 0);
          while ( 1 )
          {
            v10 = recv(v7, v9, *(_DWORD *)(a1 + 148), 0);
            if ( v10 > 0 )
            {
              v11 = *(int (__fastcall **)(void *, ssize_t))(a1 + 12);
              if ( v11 )
                v11 = (int (__fastcall *)(void *, ssize_t))v11(v9, v10);
            }
            else
            {
              v11 = 0;
            }
            *(_DWORD *)v25 = 0;
            memset(v26, 0, sizeof(v26));
            sprintf(v25, "%x %d %s %s", 63, v11, a1 + 16, "OK");
            v12 = strlen(v25);
            send(v7, v25, v12 + 1, 0);
          }
        }
        perror("accept error");
      }
      return 0;
    }
  }
}

//----- (00043D64) --------------------------------------------------------
int __fastcall sub_43D64(int a1, int a2)
{
  int v2; // r6
  char *v5; // r4
  char *v6; // r3
  char *v7; // r7
  char *v8; // r0
  int v9; // r0
  int v10; // r4
  ssize_t v11; // r0
  _BYTE *v12; // r3
  bool v13; // cc
  int *v14; // r12
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int *v19; // r12
  int v20; // r1
  ssize_t v21; // r0
  _BYTE *v22; // r3
  int *v23; // r12
  int v24; // r0
  int v25; // r1
  int v26; // r2
  int v27; // r3
  int *v28; // r12
  int v29; // r1
  _DWORD *v30; // r0
  pthread_t newthread; // [sp+4h] [bp-314h] BYREF
  struct sockaddr addr; // [sp+8h] [bp-310h] BYREF
  int v34; // [sp+18h] [bp-300h] BYREF
  int v35; // [sp+1Ch] [bp-2FCh]
  int v36; // [sp+20h] [bp-2F8h]
  int v37; // [sp+24h] [bp-2F4h]
  int v38; // [sp+28h] [bp-2F0h]
  int v39; // [sp+2Ch] [bp-2ECh]
  _BYTE v40[232]; // [sp+30h] [bp-2E8h] BYREF
  _DWORD buf[128]; // [sp+118h] [bp-200h] BYREF
  _BYTE vars0[24]; // [sp+318h] [bp+0h] BYREF

  v2 = dword_6ACE8;
  if ( dword_6ACE8 )
    return -1;
  pthread_mutex_init(&stru_6ACEC, 0);
  if ( a2 )
  {
    v5 = (char *)(a1 + 4);
    v6 = s2;
    v7 = &v5[136 * a2];
    do
    {
      v8 = (char *)memcpy(v6, v5, 0x80u);
      v5 += 136;
      v6 = v8 + 136;
      v9 = *((_DWORD *)v5 - 35);
      *((_DWORD *)v6 - 2) = *((_DWORD *)v5 - 2);
      *((_DWORD *)v6 - 35) = v9;
    }
    while ( v5 != v7 );
  }
  *(_WORD *)&addr.sa_data[6] = 0;
  *(_DWORD *)&addr.sa_data[8] = 0;
  *(_WORD *)&addr.sa_data[12] = 0;
  dword_6ACE4 = a2;
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)addr.sa_data = 2646;
  v10 = socket(2, 1, 0);
  if ( v10 < 0 )
  {
    v2 = -4;
    perror("socket err:");
  }
  else
  {
    while ( connect(v10, &addr, 0x10u) < 0 )
    {
      perror("connect err:");
      sleep(1u);
    }
    memset(buf, 0, sizeof(buf));
    v11 = recv(v10, buf, 0x100u, 0);
    v13 = v11 <= 0;
    LOWORD(v14) = (unsigned __int16)"func1 func2 func3 func4";
    if ( v11 > 0 )
      v12 = vars0;
    HIWORD(v14) = (unsigned int)"func1 func2 func3 func4" >> 16;
    if ( v11 > 0 )
      v11 += (ssize_t)v12;
    if ( !v13 )
      *(_BYTE *)(v11 - 512) = 0;
    v15 = *v14;
    v16 = v14[1];
    v17 = v14[2];
    v18 = v14[3];
    v19 = v14 + 4;
    v34 = v15;
    v35 = v16;
    v36 = v17;
    v37 = v18;
    v20 = v19[1];
    v38 = *v19;
    v39 = v20;
    memset(v40, 0, sizeof(v40));
    send(v10, &v34, 0x18u, 0);
    v21 = recv(v10, buf, 0x100u, 0);
    LOWORD(v23) = (unsigned __int16)"3f heart-beats 22027";
    if ( v21 > 0 )
      v22 = vars0;
    HIWORD(v23) = (unsigned int)"3f heart-beats 22027" >> 16;
    if ( v21 > 0 )
      v22[v21 - 512] = 0;
    v24 = *v23;
    v25 = v23[1];
    v26 = v23[2];
    v27 = v23[3];
    v28 = v23 + 4;
    v34 = v24;
    v35 = v25;
    v36 = v26;
    v37 = v27;
    v29 = v28[1];
    v38 = *v28;
    LOBYTE(v39) = v29;
    send(v10, &v34, 0x15u, 0);
    dword_6AD04 = v10;
    v30 = malloc(0xCu);
    v30[2] = v10;
    *v30 = 22026;
    pthread_create(&newthread, 0, (void *(*)(void *))sub_437BC, v30);
    dword_6ACE8 = 1;
  }
  return v2;
}
// 43EA0: variable 'v12' is possibly undefined
// 43F04: variable 'v22' is possibly undefined
// 6ACE4: using guessed type int dword_6ACE4;
// 6ACE8: using guessed type int dword_6ACE8;
// 6ACEC: using guessed type pthread_mutex_t;
// 6AD04: using guessed type int dword_6AD04;

//----- (00043FA4) --------------------------------------------------------
int __fastcall sub_43FA4(int a1)
{
  pthread_mutex_t *v2; // r8
  int v3; // r9
  int v4; // r5
  size_t v5; // r0
  int v6; // r0
  int v7; // r5
  ssize_t v8; // r0
  unsigned int v9; // r3
  int result; // r0
  unsigned int v11; // [sp+10h] [bp-47Ch] BYREF
  int v12; // [sp+14h] [bp-478h] BYREF
  struct sockaddr addr; // [sp+18h] [bp-474h] BYREF
  _DWORD v14[8]; // [sp+28h] [bp-464h] BYREF
  _DWORD v15[8]; // [sp+48h] [bp-444h] BYREF
  _DWORD v16[8]; // [sp+68h] [bp-424h] BYREF
  _DWORD dest[32]; // [sp+88h] [bp-404h] BYREF
  _DWORD v18[32]; // [sp+108h] [bp-384h] BYREF
  char buf[4]; // [sp+188h] [bp-304h] BYREF
  _BYTE s[252]; // [sp+18Ch] [bp-300h] BYREF
  _DWORD v21[129]; // [sp+288h] [bp-204h] BYREF

  if ( !dword_6ACE8 )
    return -1;
  v2 = (pthread_mutex_t *)malloc(0x24u);
  pthread_mutex_init(v2, 0);
  v3 = dword_6AD04;
  *(_DWORD *)buf = 0;
  memset(s, 0, sizeof(s));
  sprintf(buf, "%x regist %s", 63, (const char *)a1);
  v4 = dword_6ACE0;
  v5 = strlen(buf);
  send(v3, buf, v5 + 1, 0);
  memset(dest, 0, sizeof(dest));
  while ( dword_6ACE0 == v4 )
    usleep(0x3E8u);
  memcpy(dest, (char *)&unk_6AD08 + 128 * v4, sizeof(dest));
  v11 = 0;
  v12 = 0;
  memset(v14, 0, sizeof(v14));
  memset(v15, 0, sizeof(v15));
  memset(v16, 0, sizeof(v16));
  _isoc99_sscanf(dest, "%x%d%s%s%s", &v12, &v11, v14, v15, v16);
  if ( !v11 )
    return -4;
  addr.sa_family = 2;
  memset(addr.sa_data, 0, sizeof(addr.sa_data));
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)addr.sa_data = __rev16(v11);
  v6 = socket(2, 1, 0);
  v7 = v6;
  if ( v6 < 0 )
  {
    perror("socket err:");
    return -4;
  }
  else if ( connect(v6, &addr, 0x10u) < 0 )
  {
    perror("connect err:");
    return -3;
  }
  else
  {
    memset(v21, 0, 512);
    v8 = recv(v7, v21, 0x200u, 0);
    if ( v8 > 0 )
      *((_BYTE *)v21 + v8) = 0;
    memset(&v18[1], 0, 0x7Cu);
    v18[0] = 2181967;
    send(v7, v18, 4u, 0);
    v9 = v11;
    result = 0;
    v2[1].__owner = v7;
    *(_DWORD *)(a1 + 128) = v2;
    v2[1].__lock = v9;
  }
  return result;
}
// 122D4: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 6ACE0: using guessed type int dword_6ACE0;
// 6ACE8: using guessed type int dword_6ACE8;
// 6AD04: using guessed type int dword_6AD04;

//----- (0004424C) --------------------------------------------------------
int __fastcall sub_4424C(int a1, int a2, int a3, int a4)
{
  return a4;
}

//----- (00044264) --------------------------------------------------------
int __fastcall sub_44264(int a1, const void *a2, size_t a3, _DWORD *a4)
{
  pthread_mutex_t *v4; // r5
  int v8; // r4
  ssize_t v9; // r0
  int v11; // [sp+8h] [bp-148h] BYREF
  int v12; // [sp+Ch] [bp-144h] BYREF
  int v13; // [sp+10h] [bp-140h] BYREF
  int v14; // [sp+14h] [bp-13Ch]
  int v15; // [sp+18h] [bp-138h]
  int v16; // [sp+1Ch] [bp-134h]
  int v17; // [sp+20h] [bp-130h]
  int v18; // [sp+24h] [bp-12Ch]
  int v19; // [sp+28h] [bp-128h]
  int v20; // [sp+2Ch] [bp-124h]
  int v21; // [sp+30h] [bp-120h] BYREF
  int v22; // [sp+34h] [bp-11Ch]
  int v23; // [sp+38h] [bp-118h]
  int v24; // [sp+3Ch] [bp-114h]
  int v25; // [sp+40h] [bp-110h]
  int v26; // [sp+44h] [bp-10Ch]
  int v27; // [sp+48h] [bp-108h]
  int v28; // [sp+4Ch] [bp-104h]
  _DWORD buf[64]; // [sp+50h] [bp-100h] BYREF

  if ( !dword_6ACE8 )
    return -1;
  v4 = *(pthread_mutex_t **)(a1 + 128);
  if ( !v4 )
    return -2;
  v8 = pthread_mutex_trylock(*(pthread_mutex_t **)(a1 + 128));
  if ( v8 )
    return -3;
  if ( send(v4[1].__owner, a2, a3, 0) <= 0 )
  {
    v8 = -4;
    pthread_mutex_unlock(v4);
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    v9 = recv(v4[1].__owner, buf, 0x100u, 0);
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v21 = 0;
    v22 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    if ( v9 > 0 )
      _isoc99_sscanf(buf, "%x%d%s%s", &v11, &v12, &v13, &v21);
    if ( a4 )
      *a4 = v12;
    pthread_mutex_unlock(v4);
  }
  return v8;
}
// 122D4: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 6ACE8: using guessed type int dword_6ACE8;

//----- (000443B4) --------------------------------------------------------
int __fastcall sub_443B4(void *src, size_t n, const void **a3)
{
  return sub_478B0(a3, src, n);
}

//----- (000443C8) --------------------------------------------------------
int __fastcall sub_443C8(void *src, size_t n, _DWORD *a3)
{
  int v4; // r12
  size_t v5; // r3

  v4 = a3[1];
  v5 = v4 + n;
  if ( v4 + n <= *a3 )
  {
    memcpy((void *)(a3[2] + v4), src, n);
    v5 = n + a3[1];
  }
  a3[1] = v5;
  return 0;
}

//----- (0004440C) --------------------------------------------------------
size_t __fastcall sub_4440C(const void *a1, size_t a2, FILE *s)
{
  size_t result; // r0

  result = fwrite(a1, a2, 1u, s) - 1;
  if ( result )
    return -1;
  return result;
}

//----- (00044428) --------------------------------------------------------
int __fastcall sub_44428(void *buf, size_t n, int *a3)
{
  int result; // r0

  result = n - write(*a3, buf, n);
  if ( result )
    return -1;
  return result;
}

//----- (00044450) --------------------------------------------------------
int __fastcall sub_44450(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (0004445C) --------------------------------------------------------
int __fastcall sub_4445C(char *a1, int a2, int (__fastcall *a3)(char *, int, int), int a4, unsigned int a5)
{
  unsigned int v9; // r8
  char *i; // r10
  char *v12; // r5
  bool v13; // zf
  int v14; // r1
  char *v15; // r0
  int v16; // r1
  unsigned int v17; // r3
  int v18; // [sp+0h] [bp-2Ch]
  int v19; // [sp+14h] [bp-18h] BYREF
  char s[20]; // [sp+18h] [bp-14h] BYREF

  v19 = 0;
  if ( a3("\"", 1, a4) )
    return -1;
  v9 = (unsigned int)&a1[a2];
  for ( i = a1; (unsigned int)i < v9; i = v12 )
  {
    v12 = sub_47E38(i, v9 - (_DWORD)i, &v19);
    if ( !v12 )
      return -1;
    v13 = v19 == 34;
    if ( v19 != 34 )
      v13 = v19 == 92;
    v14 = v13;
    if ( v19 <= 31 )
      v14 |= 1u;
    if ( !v14 && ((v19 == 47) & (a5 >> 10)) == 0 && ((v19 > 127) & (a5 >> 6)) == 0 )
      continue;
    if ( a1 != i && a3(a1, i - a1, a4) )
      return -1;
    if ( i == v12 )
      return a3("\"", 1, a4);
    if ( v19 == 12 )
    {
      v16 = 2;
      v15 = "\\f";
      goto LABEL_26;
    }
    if ( v19 <= 12 )
    {
      switch ( v19 )
      {
        case 9:
          v15 = "\\t";
          v16 = 2;
          goto LABEL_26;
        case 10:
          v15 = "\\n";
          v16 = 2;
          goto LABEL_26;
        case 8:
          v15 = "\\b";
          v16 = 2;
          goto LABEL_26;
      }
LABEL_32:
      if ( v19 >= 0x10000 )
      {
        v17 = ((unsigned int)(v19 - 0x10000) >> 10) & 0x3FF | 0xD800;
        v18 = (v19 - 0x10000) & 0x3FF | 0xDC00;
        v19 -= 0x10000;
        snprintf(s, 0xDu, "\\u%04X\\u%04X", v17, v18);
        v15 = s;
        v16 = 12;
        goto LABEL_26;
      }
LABEL_33:
      snprintf(s, 0xDu, "\\u%04X");
      v15 = s;
      v16 = 6;
      goto LABEL_26;
    }
    if ( v19 == 34 )
    {
      v15 = "\\\"";
      v16 = 2;
      goto LABEL_26;
    }
    if ( v19 <= 34 )
    {
      if ( v19 == 13 )
      {
        v15 = "\\r";
        v16 = 2;
        goto LABEL_26;
      }
      goto LABEL_33;
    }
    if ( v19 == 47 )
    {
      v15 = "\\/";
      v16 = 2;
      goto LABEL_26;
    }
    if ( v19 != 92 )
      goto LABEL_32;
    v15 = "\\\\";
    v16 = 2;
LABEL_26:
    if ( a3(v15, v16, a4) )
      return -1;
    a1 = v12;
  }
  if ( a1 == i || !a3(a1, i - a1, a4) )
    return a3("\"", 1, a4);
  return -1;
}
// 445FC: conditional instruction was optimized away because %var_18.4 is in (E..21)

//----- (000446E4) --------------------------------------------------------
int __fastcall sub_446E4(char a1, int a2, int a3, int (__fastcall *a4)(__int16 *, int, int), int a5)
{
  unsigned int v6; // r4
  int v7; // r5

  if ( (a1 & 0x1F) != 0 )
  {
    v6 = (a1 & 0x1F) * a2;
    if ( a4(&word_4C858, 1, a5) )
      return -1;
    if ( v6 )
    {
      while ( 1 )
      {
        v7 = v6 >= 0x20 ? 32 : v6;
        if ( a4((__int16 *)"                                ", v7, a5) )
          break;
        v6 -= v7;
        if ( !v6 )
          return 0;
      }
      return -1;
    }
    return 0;
  }
  if ( !a3 || (a1 & 0x20) != 0 )
    return 0;
  return a4((__int16 *)" ", 1, a5);
}
// 4C858: using guessed type __int16 word_4C858;

//----- (00044794) --------------------------------------------------------
int __fastcall sub_44794(int a1, const void *a2, char *s)
{
  void *v5; // r0

  snprintf(s, 0xBu, "%p", a2);
  if ( sub_45B10(a1, s) )
    return -1;
  v5 = sub_48A28();
  return sub_4587C(a1, s, (int)v5);
}

//----- (000447EC) --------------------------------------------------------
int __fastcall sub_447EC(_DWORD *a1, int a2, int a3, int a4, int (__fastcall *a5)(__int16 *, int, int), int a6)
{
  _DWORD *v7; // r5
  int v8; // r8
  unsigned int v9; // r7
  char v11; // r9
  char *v12; // r3
  int v13; // r3
  int v14; // r6
  char *v16; // r5
  _DWORD *v17; // r0
  __int64 v18; // r0
  int v19; // r0
  int v20; // r1
  int v21; // r8
  int v22; // r6
  int v23; // r11
  int v24; // r9
  char *v25; // r10
  size_t v26; // r0
  int v27; // r0
  unsigned int v28; // r9
  int v29; // r8
  _DWORD *v30; // r3
  _DWORD *v31; // r11
  unsigned int v32; // r10
  _DWORD *v33; // r0
  char *v34; // r0
  char *v35; // r9
  unsigned int v36; // r7
  int v37; // r5
  char *v38; // r8
  int v39; // r11
  unsigned int v40; // r6
  char *v41; // r10
  char *v42; // t1
  int v43; // r9
  size_t v44; // r0
  int v45; // r8
  char *v46; // [sp+Ch] [bp-98h]
  _DWORD *v47; // [sp+Ch] [bp-98h]
  int v48; // [sp+Ch] [bp-98h]
  int v49; // [sp+10h] [bp-94h]
  int v50; // [sp+10h] [bp-94h]
  int v51; // [sp+14h] [bp-90h]
  int v52; // [sp+14h] [bp-90h]
  size_t nmemb; // [sp+18h] [bp-8Ch]
  int v54; // [sp+1Ch] [bp-88h]
  int v55; // [sp+20h] [bp-84h]
  void *base; // [sp+24h] [bp-80h]
  _DWORD *v57; // [sp+28h] [bp-7Ch]
  int v58; // [sp+28h] [bp-7Ch]
  char *v59; // [sp+2Ch] [bp-78h]
  unsigned int v60; // [sp+30h] [bp-74h]
  _DWORD *v61; // [sp+34h] [bp-70h]
  __int16 s[52]; // [sp+3Ch] [bp-68h] BYREF

  if ( !a1 )
    return -1;
  v7 = (_DWORD *)a4;
  v8 = a2 & 0x10000;
  v9 = a2 & 0xFFFEFFFF;
  v11 = a2;
  switch ( *a1 )
  {
    case 0:
      v12 = ":";
      if ( (a2 & 0x20) == 0 )
        v12 = ": ";
      v46 = v12;
      if ( (a2 & 0x20) != 0 )
        v13 = 1;
      else
        v13 = 2;
      v49 = v13;
      v14 = sub_44794((int)v7, a1, (char *)s);
      if ( v14 )
        return -1;
      v51 = sub_48364(a1);
      if ( v8 )
      {
        if ( !v51 )
          goto LABEL_45;
      }
      else
      {
        if ( a5((__int16 *)"{", 1, a6) )
          return -1;
        if ( !v51 )
        {
          sub_45B70(v7, (char *)s);
          return a5((__int16 *)"}", 1, a6);
        }
      }
      if ( sub_446E4(v9, a3 + 1, 0, a5, a6) )
        return -1;
      if ( (v11 & 0x80) == 0 )
      {
        v55 = v8;
        v21 = a3 + 1;
        v22 = v51;
        v23 = v49;
        v50 = a3;
        while ( 1 )
        {
          v24 = sub_483B0(a1, v22);
          v25 = (char *)sub_483E4(v22);
          v26 = strlen(v25);
          sub_4445C(v25, v26, (int (__fastcall *)(char *, int, int))a5, a6, v9);
          if ( a5((__int16 *)v46, v23, a6) )
            return -1;
          v27 = sub_483F0(v22);
          if ( sub_447EC(v27, v9, v21, v7, a5, a6) )
            return -1;
          if ( !v24 )
          {
            v45 = v55;
            v14 = 0;
            if ( sub_446E4(v9, v50, 0, a5, a6) )
              return -1;
            goto LABEL_68;
          }
          if ( !a5((__int16 *)",", 1, a6) )
          {
            v22 = v24;
            if ( !sub_446E4(v9, v21, 1, a5, a6) )
              continue;
          }
          return -1;
        }
      }
      v57 = sub_480E0(a1);
      v34 = (char *)sub_4774C((void *)(4 * (_DWORD)v57));
      base = v34;
      if ( !v34 )
        return -1;
      v60 = v9;
      v61 = v7;
      v35 = v34 - 4;
      v59 = v34 - 4;
      v36 = 0;
      v37 = v51;
      while ( 1 )
      {
        *((_DWORD *)v35 + 1) = sub_483E4(v37);
        v35 += 4;
        v37 = sub_483B0(a1, v37);
        if ( !v37 )
          break;
        ++v36;
      }
      nmemb = v36 + 1;
      v7 = v61;
      if ( v57 != (_DWORD *)(v36 + 1) )
        _assert_fail("i == size", "dump.c", 0x160u, "do_dump");
      qsort(base, nmemb, 4u, (__compar_fn_t)sub_44450);
      v58 = v8;
      v38 = v59;
      v39 = a3 + 1;
      v40 = 0;
      v54 = a3;
      do
      {
        v42 = (char *)*((_DWORD *)v38 + 1);
        v38 += 4;
        v41 = v42;
        v43 = sub_480FC(a1, v42);
        if ( !v43 )
          _assert_fail("value", "dump.c", 0x16Bu, "do_dump");
        v44 = strlen(v41);
        sub_4445C(v41, v44, (int (__fastcall *)(char *, int, int))a5, a6, v60);
        if ( a5((__int16 *)v46, v49, a6) || sub_447EC(v43, v60, v39, v61, a5, a6) )
        {
LABEL_64:
          v14 = -1;
          sub_47764(base);
          return v14;
        }
        if ( v40 < v36 )
        {
          if ( a5((__int16 *)",", 1, a6) || sub_446E4(v60, v39, 1, a5, a6) )
            goto LABEL_64;
        }
        else if ( sub_446E4(v60, v54, 0, a5, a6) )
        {
          goto LABEL_64;
        }
        ++v40;
      }
      while ( v40 != nmemb );
      v45 = v58;
      v14 = 0;
      sub_47764(base);
LABEL_68:
      sub_45B70(v7, (char *)s);
      if ( !v45 )
        return a5((__int16 *)"}", 1, a6);
      return v14;
    case 1:
      v14 = sub_44794(a4, a1, (char *)s);
      if ( v14 )
        return -1;
      v47 = sub_48468(a1);
      if ( v8 )
      {
        if ( !v47 )
        {
LABEL_45:
          sub_45B70(v7, (char *)s);
          return v14;
        }
      }
      else
      {
        if ( a5((__int16 *)"[", 1, a6) )
          return -1;
        if ( !v47 )
        {
          sub_45B70(v7, (char *)s);
          return a5(&word_5616C, 1, a6);
        }
      }
      v28 = sub_446E4(v9, a3 + 1, 0, a5, a6);
      if ( v28 )
        return -1;
      v52 = v8;
      v29 = a3 + 1;
      v30 = v47;
      v48 = a3;
      v31 = v30;
      v32 = (unsigned int)v30 - 1;
      break;
    case 2:
      v16 = (char *)sub_48630(a1);
      v17 = sub_4864C(a1);
      return sub_4445C(v16, (int)v17, (int (__fastcall *)(char *, int, int))a5, a6, v9);
    case 3:
      v18 = sub_4888C((int)a1);
      v19 = snprintf((char *)s, 0x64u, "%lld", v18);
      return a5(s, v19, a6);
    case 4:
      sub_48938();
      v20 = sub_47AB8((char *)s, 0x64u, (unsigned __int16)v9 >> 11);
      if ( v20 < 0 )
        return -1;
      return a5(s, v20, a6);
    case 5:
      return a5((__int16 *)"true", 4, a6);
    case 6:
      return a5((__int16 *)"false", 5, a6);
    case 7:
      return a5((__int16 *)"null", 4, a6);
    default:
      return -1;
  }
  do
  {
    v33 = sub_48484(a1, v28);
    v14 = sub_447EC(v33, v9, v29, v7, a5, a6);
    if ( v14 )
      return -1;
    if ( v32 <= v28 )
    {
      if ( sub_446E4(v9, v48, 0, a5, a6) )
        return -1;
    }
    else if ( a5((__int16 *)",", 1, a6) || sub_446E4(v9, v29, 1, a5, a6) )
    {
      return -1;
    }
    ++v28;
  }
  while ( v31 != (_DWORD *)v28 );
  sub_45B70(v7, (char *)s);
  if ( !v52 )
    return a5(&word_5616C, 1, a6);
  return v14;
}
// 4481C: control flows out of bounds to 44820
// 5616C: using guessed type __int16 word_5616C;

//----- (00044FFC) --------------------------------------------------------
int __fastcall sub_44FFC(_DWORD *a1, int (__fastcall *a2)(__int16 *, int, int), int a3, int a4)
{
  int v8; // r4
  _DWORD v10[8]; // [sp+Ch] [bp-20h] BYREF

  if ( (a4 & 0x200) == 0 && (!a1 || *a1 > 1u) || sub_457E8(v10) )
    return -1;
  v8 = sub_447EC(a1, a4, 0, (int)v10, a2, a3);
  sub_45864((int)v10);
  return v8;
}

//----- (00045074) --------------------------------------------------------
_BYTE *__fastcall sub_45074(_DWORD *a1, int a2)
{
  _BYTE *v4; // r4
  const char *v6; // r0
  _DWORD v7[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = (_BYTE *)sub_47820(v7);
  if ( v4 )
    return 0;
  if ( !sub_44FFC(a1, (int (__fastcall *)(__int16 *, int, int))sub_443B4, (int)v7, a2) )
  {
    v6 = (const char *)sub_47894((int)v7);
    v4 = sub_477C8(v6);
  }
  sub_47854((int)v7);
  return v4;
}

//----- (0004511C) --------------------------------------------------------
int __fastcall sub_4511C(_DWORD *a1, int a2, int a3)
{
  return sub_44FFC(a1, (int (__fastcall *)(__int16 *, int, int))sub_4440C, a2, a3);
}

//----- (00045130) --------------------------------------------------------
int __fastcall sub_45130(_DWORD *a1, int a2, int a3)
{
  FILE *v5; // r4
  int v6; // r5

  v5 = (FILE *)fopen64(a2, "w");
  if ( !v5 )
    return -1;
  v6 = sub_44FFC(a1, (int (__fastcall *)(__int16 *, int, int))sub_4440C, (int)v5, a3);
  if ( fclose(v5) )
    return -1;
  return v6;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00045194) --------------------------------------------------------
int __fastcall sub_45194(_DWORD *a1, int a2, int a3)
{
  int v4; // [sp+4h] [bp-8h] BYREF

  v4 = a2;
  return sub_44FFC(a1, (int (__fastcall *)(__int16 *, int, int))sub_44428, (int)&v4, a3);
}

//----- (000451C0) --------------------------------------------------------
int __fastcall sub_451C0(unsigned __int16 *a1, unsigned int a2, int a3)
{
  unsigned int v3; // r12
  unsigned __int16 *v4; // r4
  int v5; // r3
  int v6; // lr
  int v7; // r6
  int v8; // r5
  int v9; // r3
  int v10; // lr
  int v11; // r2
  int v12; // r3
  int v13; // r5
  int v14; // r2
  int v15; // r12
  int v16; // r2
  int v17; // lr
  int v18; // r3
  int v19; // r2
  int v20; // r2
  int v21; // r3
  unsigned __int16 *v22; // r4
  int v23; // r6
  int v24; // r5
  int v25; // r7
  int v26; // r2
  int v27; // r3
  int v28; // r12
  int v29; // lr
  int v30; // r2
  int v31; // lr
  int v32; // r3
  int v33; // r12
  int v34; // r2
  int v35; // r5
  int v36; // r2
  int v37; // r3
  int v38; // r2
  unsigned __int16 *v39; // r4
  int v40; // r6
  int v41; // r2
  int v42; // r7
  int v43; // r8
  int v44; // r3
  int v45; // r12
  int v46; // lr
  int v47; // r2
  int v48; // lr
  int v49; // r3
  int v50; // r12
  int v51; // r2
  int v52; // r5
  int v53; // r2
  int v54; // r3
  int v55; // r2
  int v56; // r12
  int v57; // r3
  int v58; // r12
  int v59; // lr
  int v60; // r3
  int v61; // r12
  int v62; // r12
  int v64; // r4

  v3 = a3 - 559038737 + a2;
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
    if ( a2 <= 0xC )
    {
      v5 = a3 - 559038737 + a2;
      v6 = v5;
    }
    else
    {
      v4 = a1 + 6;
      v5 = a3 - 559038737 + a2;
      v6 = v5;
      do
      {
        a2 -= 12;
        v7 = *((_DWORD *)v4 - 3);
        v8 = *((_DWORD *)v4 - 2);
        a1 = v4;
        v9 = v5 + *((_DWORD *)v4 - 1);
        v4 += 6;
        v10 = v6 + v8;
        v11 = (v7 - v9 + v3) ^ __ROR4__(v9, 28);
        v12 = v10 + v9;
        v13 = v11 + v12;
        v14 = (v10 - v11) ^ __ROR4__(v11, 26);
        v15 = v14 + v13;
        v16 = (v12 - v14) ^ __ROR4__(v14, 24);
        v17 = v16 + v15;
        v18 = (v13 - v16) ^ __ROR4__(v16, 16);
        v19 = v15 - v18;
        v3 = v18 + v17;
        v20 = v19 ^ __ROR4__(v18, 13);
        v21 = v17 - v20;
        v6 = v20 + v3;
        v5 = v21 ^ __ROR4__(v20, 28);
      }
      while ( a2 > 0xC );
    }
    switch ( a2 )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        v56 = (*(_DWORD *)a1 & 0xFFFFFF) + v3;
        goto LABEL_28;
      case 4u:
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 5u:
        v6 += *((unsigned __int8 *)a1 + 4);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 6u:
        v6 += a1[2];
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 7u:
        v56 = v3 + *(_DWORD *)a1;
        v6 += *((_DWORD *)a1 + 1) & 0xFFFFFF;
        goto LABEL_28;
      case 8u:
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 9u:
        v64 = *((unsigned __int8 *)a1 + 8);
        goto LABEL_35;
      case 0xAu:
        v64 = a1[4];
        goto LABEL_35;
      case 0xBu:
        v5 += *((_DWORD *)a1 + 2) & 0xFFFFFF;
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 0xCu:
        v64 = *((_DWORD *)a1 + 2);
LABEL_35:
        v5 += v64;
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      default:
        return v5;
    }
  }
  if ( ((unsigned __int8)a1 & 1) == 0 )
  {
    if ( a2 <= 0xC )
    {
      v5 = a3 - 559038737 + a2;
      v6 = v5;
    }
    else
    {
      v22 = a1 + 6;
      v5 = a3 - 559038737 + a2;
      v6 = v5;
      do
      {
        v23 = *(v22 - 1);
        a2 -= 12;
        v24 = *(v22 - 2);
        v25 = *(v22 - 5);
        a1 = v22;
        v26 = *(v22 - 6);
        v22 += 6;
        v27 = v24 + (v23 << 16) + v5;
        v28 = (v26 + (v25 << 16) - v27 + v3) ^ __ROR4__(v27, 28);
        v29 = *(v22 - 10) + (*(v22 - 9) << 16) + v6;
        v30 = v29 - v28;
        v31 = v29 + v27;
        v32 = v30 ^ __ROR4__(v28, 26);
        v33 = v28 + v31;
        v34 = (v31 - v32) ^ __ROR4__(v32, 24);
        v35 = v34 + v32 + v33;
        v36 = (v33 - v34) ^ __ROR4__(v34, 16);
        v37 = v32 + v33 - v36;
        v3 = v36 + v35;
        v38 = v37 ^ __ROR4__(v36, 13);
        v6 = v38 + v3;
        v5 = (v35 - v38) ^ __ROR4__(v38, 28);
      }
      while ( a2 > 0xC );
    }
    switch ( a2 )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        v3 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_32:
        v56 = *a1 + v3;
        goto LABEL_28;
      case 4u:
        goto LABEL_50;
      case 5u:
        v6 += *((unsigned __int8 *)a1 + 4);
LABEL_50:
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      case 6u:
        goto LABEL_44;
      case 7u:
        v6 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_44:
        v56 = *a1 + v3 + (a1[1] << 16);
        v6 += a1[2];
        goto LABEL_28;
      case 8u:
        goto LABEL_46;
      case 9u:
        v5 += *((unsigned __int8 *)a1 + 8);
LABEL_46:
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      case 0xAu:
        goto LABEL_48;
      case 0xBu:
        v5 += *((unsigned __int8 *)a1 + 10) << 16;
LABEL_48:
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        v5 += a1[4];
        goto LABEL_28;
      case 0xCu:
        v5 += a1[4] + (a1[5] << 16);
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      default:
        return v5;
    }
  }
  if ( a2 > 0xC )
  {
    v39 = a1 + 6;
    v5 = a3 - 559038737 + a2;
    v6 = v5;
    do
    {
      v40 = *((unsigned __int8 *)v39 - 2);
      a2 -= 12;
      v41 = *((unsigned __int8 *)v39 - 10);
      v42 = *((unsigned __int8 *)v39 - 3);
      a1 = v39;
      v43 = *((unsigned __int8 *)v39 - 11);
      v39 += 6;
      v44 = (v40 << 16) + (v42 << 8) + *((unsigned __int8 *)v39 - 16) + (*((unsigned __int8 *)v39 - 13) << 24) + v5;
      v45 = ((v41 << 16)
           + (v43 << 8)
           + *((unsigned __int8 *)v39 - 24)
           + (*((unsigned __int8 *)v39 - 21) << 24)
           - v44
           + v3)
          ^ __ROR4__(v44, 28);
      v46 = (*((unsigned __int8 *)v39 - 18) << 16)
          + (*((unsigned __int8 *)v39 - 19) << 8)
          + *((unsigned __int8 *)v39 - 20)
          + (*((unsigned __int8 *)v39 - 17) << 24)
          + v6;
      v47 = v46 - v45;
      v48 = v46 + v44;
      v49 = v47 ^ __ROR4__(v45, 26);
      v50 = v45 + v48;
      v51 = (v48 - v49) ^ __ROR4__(v49, 24);
      v52 = v51 + v49 + v50;
      v53 = (v50 - v51) ^ __ROR4__(v51, 16);
      v54 = v49 + v50 - v53;
      v3 = v53 + v52;
      v55 = v54 ^ __ROR4__(v53, 13);
      v6 = v55 + v3;
      v5 = (v52 - v55) ^ __ROR4__(v55, 28);
    }
    while ( a2 > 0xC );
  }
  else
  {
    v5 = a3 - 559038737 + a2;
    v6 = v5;
  }
  switch ( a2 )
  {
    case 1u:
      goto LABEL_27;
    case 2u:
      goto LABEL_26;
    case 3u:
      goto LABEL_25;
    case 4u:
      goto LABEL_24;
    case 5u:
      goto LABEL_23;
    case 6u:
      goto LABEL_22;
    case 7u:
      goto LABEL_21;
    case 8u:
      goto LABEL_20;
    case 9u:
      goto LABEL_19;
    case 0xAu:
      goto LABEL_18;
    case 0xBu:
      goto LABEL_17;
    case 0xCu:
      v5 += *((unsigned __int8 *)a1 + 11) << 24;
LABEL_17:
      v5 += *((unsigned __int8 *)a1 + 10) << 16;
LABEL_18:
      v5 += *((unsigned __int8 *)a1 + 9) << 8;
LABEL_19:
      v5 += *((unsigned __int8 *)a1 + 8);
LABEL_20:
      v6 += *((unsigned __int8 *)a1 + 7) << 24;
LABEL_21:
      v6 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_22:
      v6 += *((unsigned __int8 *)a1 + 5) << 8;
LABEL_23:
      v6 += *((unsigned __int8 *)a1 + 4);
LABEL_24:
      v3 += *((unsigned __int8 *)a1 + 3) << 24;
LABEL_25:
      v3 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_26:
      v3 += *((unsigned __int8 *)a1 + 1) << 8;
LABEL_27:
      v56 = *(unsigned __int8 *)a1 + v3;
LABEL_28:
      v57 = (v5 ^ v6) - __ROR4__(v6, 18);
      v58 = (v56 ^ v57) - __ROR4__(v57, 21);
      v59 = (v6 ^ v58) - __ROR4__(v58, 7);
      v60 = (v57 ^ v59) - __ROR4__(v59, 16);
      v61 = (v58 ^ v60) - __ROR4__(v60, 28);
      v62 = (v59 ^ v61) - __ROR4__(v61, 18);
      v5 = (v60 ^ v62) - __ROR4__(v62, 8);
      break;
    default:
      return v5;
  }
  return v5;
}
// 45270: control flows out of bounds to 45274
// 45358: control flows out of bounds to 4535C
// 4547C: control flows out of bounds to 45480

//----- (00045704) --------------------------------------------------------
int __fastcall sub_45704(int a1, int *a2, char *s2, int a4)
{
  int v4; // r4

  v4 = *a2;
  if ( *a2 == a1 + 12 && v4 == a2[1] )
    return 0;
  while ( *(_DWORD *)(v4 + 16) != a4 || strcmp((const char *)(v4 + 24), s2) )
  {
    if ( a2[1] == v4 )
      return 0;
    v4 = *(_DWORD *)(v4 + 4);
  }
  return v4;
}

//----- (00045778) --------------------------------------------------------
void __fastcall sub_45778(int a1)
{
  _DWORD *v1; // r6
  _DWORD *v2; // r4
  int v3; // r0
  _DWORD *v4; // r5
  unsigned int *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r2
  void *v8; // r0

  v1 = (_DWORD *)(a1 + 12);
  v2 = *(_DWORD **)(a1 + 16);
  if ( v2 != (_DWORD *)(a1 + 12) )
  {
    do
    {
      v3 = v2[5];
      v4 = (_DWORD *)v2[1];
      if ( v3 )
      {
        v5 = (unsigned int *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 4) != -1 )
        {
          __dmb(0xBu);
          do
          {
            v6 = __ldrex(v5);
            v7 = v6 - 1;
          }
          while ( __strex(v7, v5) );
          if ( !v7 )
            sub_48A34();
        }
      }
      v8 = v2;
      v2 = v4;
      sub_47764(v8);
    }
    while ( v4 != v1 );
  }
}
// 48A34: using guessed type int sub_48A34(void);

//----- (000457E8) --------------------------------------------------------
int __fastcall sub_457E8(_DWORD *a1)
{
  _DWORD *v2; // r0
  int v3; // r12
  _DWORD *v4; // r3
  _DWORD *v5; // r2

  *a1 = 0;
  a1[2] = 3;
  v2 = sub_4774C((void *)0x40);
  a1[1] = v2;
  if ( !v2 )
    return -1;
  v3 = a1[2];
  v4 = a1 + 3;
  a1[4] = a1 + 3;
  a1[3] = a1 + 3;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  if ( 1 << v3 )
  {
    v5 = (_DWORD *)((char *)v2 + (8 << v3));
    do
    {
      v2[1] = v4;
      *v2 = v4;
      v2 += 2;
    }
    while ( v2 != v5 );
  }
  return 0;
}

//----- (00045864) --------------------------------------------------------
void __fastcall sub_45864(int a1)
{
  sub_45778(a1);
  sub_47764(*(void **)(a1 + 4));
}

//----- (0004587C) --------------------------------------------------------
int __fastcall sub_4587C(int a1, char *a2, int a3)
{
  int v4; // r8
  int v7; // r8
  _DWORD *v8; // r5
  _DWORD *v9; // r1
  _DWORD *v10; // r3
  _DWORD *v11; // r3
  int v12; // r8
  int v13; // lr
  _DWORD *v14; // r12
  int v15; // r0
  _DWORD *v16; // r2
  _DWORD *v17; // r0
  int v18; // r2
  size_t v19; // r10
  int v20; // r9
  int *v21; // r5
  int v22; // r0
  int v23; // r8
  _DWORD *v24; // r0
  unsigned int *v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r2
  void *v29; // r0
  _DWORD *v30; // r8
  int v31; // r3
  _DWORD *v32; // r2
  int v33; // r1
  int v34; // r3

  v4 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)a1 >> v4 )
  {
    v7 = v4 + 1;
    v8 = sub_4774C((void *)(8 << v7));
    if ( !v8 )
      return -1;
    sub_47764(*(void **)(a1 + 4));
    *(_DWORD *)(a1 + 4) = v8;
    *(_DWORD *)(a1 + 8) = v7;
    v9 = (_DWORD *)(a1 + 12);
    if ( 1 << v7 )
    {
      v10 = v8;
      do
      {
        v10[1] = v9;
        *v10 = v9;
        v10 += 2;
      }
      while ( (_DWORD *)((char *)v8 + (8 << v7)) != v10 );
    }
    v11 = *(_DWORD **)(a1 + 16);
    *(_DWORD *)(a1 + 12) = v9;
    v12 = ~(-1 << v7);
    *(_DWORD *)(a1 + 16) = v9;
    if ( v11 != v9 )
    {
      do
      {
        while ( 1 )
        {
          v14 = (_DWORD *)v11[1];
          v15 = v11[4] & v12;
          v16 = (_DWORD *)v8[2 * v15];
          v17 = &v8[2 * v15];
          if ( v16 == v9 && v9 == (_DWORD *)v17[1] )
            break;
          v13 = *v16;
          v11[1] = v16;
          *v11 = v13;
          *(_DWORD *)(*v16 + 4) = v11;
          *v16 = v11;
          *v17 = v11;
          v11 = v14;
          if ( v14 == v9 )
            goto LABEL_12;
        }
        v18 = *(_DWORD *)(a1 + 12);
        v11[1] = v9;
        *v11 = v18;
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) = v11;
        *(_DWORD *)(a1 + 12) = v11;
        v17[1] = v11;
        *v17 = v11;
        v11 = v14;
      }
      while ( v14 != v9 );
LABEL_12:
      v8 = *(_DWORD **)(a1 + 4);
      v12 = ~(-1 << *(_DWORD *)(a1 + 8));
    }
  }
  else
  {
    v8 = *(_DWORD **)(a1 + 4);
    v12 = ~(-1 << v4);
  }
  v19 = strlen(a2);
  v20 = sub_451C0((unsigned __int16 *)a2, v19, dword_73108);
  v21 = &v8[2 * (v12 & v20)];
  v22 = sub_45704(a1, v21, a2, v20);
  v23 = v22;
  if ( v22 )
  {
    v24 = *(_DWORD **)(v22 + 20);
    if ( v24 && v24[1] != -1 )
    {
      v25 = v24 + 1;
      __dmb(0xBu);
      do
      {
        v26 = __ldrex(v25);
        v27 = v26 - 1;
      }
      while ( __strex(v27, v25) );
      if ( !v27 )
        sub_48A34(v24);
    }
    *(_DWORD *)(v23 + 20) = a3;
    return 0;
  }
  v29 = sub_4774C((void *)(v19 + 25));
  v30 = v29;
  if ( !v29 )
    return -1;
  *((_DWORD *)v29 + 4) = v20;
  strncpy((char *)v29 + 24, a2, v19 + 1);
  v31 = *v21;
  v32 = v30 + 2;
  v30[5] = a3;
  v30[1] = v30;
  *v30 = v30;
  v30[3] = v30 + 2;
  v30[2] = v30 + 2;
  if ( v31 == a1 + 12 && v31 == v21[1] )
  {
    *v30 = *(_DWORD *)(a1 + 12);
    v30[1] = v31;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) = v30;
    *(_DWORD *)(a1 + 12) = v30;
    v21[1] = (int)v30;
    *v21 = (int)v30;
  }
  else
  {
    *v30 = *(_DWORD *)v31;
    v30[1] = v31;
    *(_DWORD *)(*(_DWORD *)v31 + 4) = v30;
    *(_DWORD *)v31 = v30;
    *v21 = (int)v30;
  }
  v33 = *(_DWORD *)(a1 + 20);
  v34 = *(_DWORD *)a1;
  v30[3] = a1 + 20;
  v30[2] = v33;
  *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4) = v32;
  *(_DWORD *)(a1 + 20) = v32;
  *(_DWORD *)a1 = v34 + 1;
  return 0;
}
// 73108: using guessed type int dword_73108;

//----- (00045B10) --------------------------------------------------------
int __fastcall sub_45B10(int a1, char *s)
{
  size_t v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = sub_451C0((unsigned __int16 *)s, v4, dword_73108);
  result = sub_45704(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v5 & ~(-1 << *(_DWORD *)(a1 + 8)))), s, v5);
  if ( result )
    return *(_DWORD *)(result + 20);
  return result;
}
// 73108: using guessed type int dword_73108;

//----- (00045B70) --------------------------------------------------------
int __fastcall sub_45B70(_DWORD *a1, char *s)
{
  size_t v4; // r0
  int v5; // r0
  int v6; // r9
  int v7; // r5
  int *v8; // r7
  _DWORD *v9; // r0
  _DWORD *v10; // r4
  _DWORD *v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // r1
  int v15; // r2
  _DWORD *v16; // r0
  int v17; // r3
  unsigned int *v19; // r3
  unsigned int v20; // r2
  unsigned int v21; // r2
  bool v22; // zf

  v4 = strlen(s);
  v5 = sub_451C0((unsigned __int16 *)s, v4, dword_73108);
  v6 = a1[1];
  v7 = v5 & ~(-1 << a1[2]);
  v8 = (int *)(v6 + 8 * v7);
  v9 = (_DWORD *)sub_45704((int)a1, v8, s, v5);
  v10 = v9;
  if ( !v9 )
    return -1;
  v11 = (_DWORD *)v8[1];
  v12 = v9[1];
  v13 = *v9;
  if ( v9 == *(_DWORD **)(v6 + 8 * v7) )
  {
    v22 = v9 == v11;
    if ( v9 == v11 )
      v11 = a1 + 3;
    else
      *(_DWORD *)(v6 + 8 * v7) = v12;
    if ( v22 )
    {
      v8[1] = (int)v11;
      *(_DWORD *)(v6 + 8 * v7) = v11;
    }
  }
  else if ( v9 == v11 )
  {
    v8[1] = v13;
  }
  *(_DWORD *)(v13 + 4) = v12;
  v14 = (int *)v9[1];
  v15 = v9[3];
  v16 = (_DWORD *)v9[5];
  *v14 = v13;
  v17 = v10[2];
  *(_DWORD *)(v17 + 4) = v15;
  *(_DWORD *)v10[3] = v17;
  if ( v16 && v16[1] != -1 )
  {
    v19 = v16 + 1;
    __dmb(0xBu);
    do
    {
      v20 = __ldrex(v19);
      v21 = v20 - 1;
    }
    while ( __strex(v21, v19) );
    if ( !v21 )
      sub_48A34(v16);
  }
  sub_47764(v10);
  --*a1;
  return 0;
}
// 73108: using guessed type int dword_73108;

//----- (00045C90) --------------------------------------------------------
int __fastcall sub_45C90(_DWORD *a1)
{
  _DWORD *v2; // r2
  int result; // r0
  _DWORD *v4; // r3
  _DWORD *v5; // r1

  sub_45778((int)a1);
  v2 = a1 + 3;
  result = a1[2];
  if ( 1 << result )
  {
    v4 = (_DWORD *)a1[1];
    v5 = (_DWORD *)((char *)v4 + (8 << result));
    do
    {
      v4[1] = v2;
      *v4 = v2;
      v4 += 2;
    }
    while ( v4 != v5 );
  }
  a1[4] = v2;
  a1[3] = v2;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  *a1 = 0;
  return result;
}

//----- (00045CEC) --------------------------------------------------------
int __fastcall sub_45CEC(int a1)
{
  if ( *(_DWORD *)(a1 + 24) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a1 + 24);
}

//----- (00045D04) --------------------------------------------------------
int __fastcall sub_45D04(int a1, char *s)
{
  size_t v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = sub_451C0((unsigned __int16 *)s, v4, dword_73108);
  result = sub_45704(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v5 & ~(-1 << *(_DWORD *)(a1 + 8)))), s, v5);
  if ( result )
    result += 8;
  return result;
}
// 73108: using guessed type int dword_73108;

//----- (00045D64) --------------------------------------------------------
int __fastcall sub_45D64(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 4) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a2 + 4);
}

//----- (00045D7C) --------------------------------------------------------
int __fastcall sub_45D7C(int a1)
{
  return a1 + 16;
}

//----- (00045D84) --------------------------------------------------------
int __fastcall sub_45D84(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (00045D8C) --------------------------------------------------------
void __fastcall sub_45D8C(int a1, int a2)
{
  _DWORD *v3; // r0
  unsigned int *v4; // r3
  unsigned int v5; // r2
  unsigned int v6; // r2

  v3 = *(_DWORD **)(a1 + 12);
  if ( !v3 )
    goto LABEL_6;
  if ( v3[1] == -1 )
    goto LABEL_6;
  v4 = v3 + 1;
  __dmb(0xBu);
  do
  {
    v5 = __ldrex(v4);
    v6 = v5 - 1;
  }
  while ( __strex(v6, v4) );
  if ( v6 )
  {
LABEL_6:
    *(_DWORD *)(a1 + 12) = a2;
  }
  else
  {
    sub_48A34(v3);
    *(_DWORD *)(a1 + 12) = a2;
  }
}

//----- (00045DF8) --------------------------------------------------------
int __fastcall sub_45DF8(int result)
{
  int v1; // r1
  unsigned __int8 v2; // r2
  int v3; // r3
  int v4; // r0
  int v5; // r5
  ssize_t v6; // r7
  int v7; // r5
  struct timeval v8; // [sp+0h] [bp-Ch] BYREF

  if ( !dword_73108 )
  {
    v1 = result;
    result = 1;
    do
      v2 = __ldrex(algn_7310C);
    while ( __strex(1u, algn_7310C) );
    if ( v2 )
    {
      do
      {
        result = sched_yield();
        v3 = dword_73108;
        __dmb(0xBu);
      }
      while ( !v3 );
    }
    else
    {
      if ( !v1 )
      {
        v4 = open64("/dev/urandom");
        v5 = v4;
        if ( v4 == -1 || (v6 = read(v4, &v8, 4u), close(v5), v6 != 4) )
        {
          gettimeofday(&v8, 0);
          v7 = v8.tv_usec ^ v8.tv_sec;
          result = getpid();
          v1 = result ^ v7;
        }
        else
        {
          result = LOBYTE(v8.tv_sec);
          v1 = HIBYTE(v8.tv_sec) | ((BYTE2(v8.tv_sec) | ((BYTE1(v8.tv_sec) | (LOBYTE(v8.tv_sec) << 8)) << 8)) << 8);
        }
        if ( !v1 )
          v1 = 1;
      }
      __dmb(0xBu);
      dword_73108 = v1;
    }
  }
  return result;
}
// 1216C: using guessed type int __fastcall open64(_DWORD);
// 73108: using guessed type int dword_73108;
// 7310C: using guessed type _BYTE[4];

//----- (00045EF4) --------------------------------------------------------
int __fastcall sub_45EF4(_DWORD *a1)
{
  int v1; // r2
  int v2; // r3
  bool v3; // zf

  v1 = a1[1];
  v2 = *(unsigned __int8 *)(*a1 + v1);
  v3 = v2 == 0;
  if ( *(_BYTE *)(*a1 + v1) )
    ++v1;
  else
    v2 = -1;
  if ( !v3 )
    a1[1] = v1;
  return v2;
}

//----- (00045F18) --------------------------------------------------------
int __fastcall sub_45F18(int a1)
{
  __int64 v1; // r2

  v1 = *(_QWORD *)(a1 + 4);
  if ( HIDWORD(v1) >= (unsigned int)v1 )
    return -1;
  LODWORD(v1) = HIDWORD(v1) + 1;
  HIDWORD(v1) = *(unsigned __int8 *)(*(_DWORD *)a1 + HIDWORD(v1));
  *(_DWORD *)(a1 + 8) = v1;
  return HIDWORD(v1);
}

//----- (00045F3C) --------------------------------------------------------
int __fastcall sub_45F3C(_DWORD *a1)
{
  unsigned int v1; // r3
  int (__fastcall *v3)(_DWORD *, int, _DWORD); // r3
  int v4; // r0
  int result; // r0

  v1 = a1[257];
  if ( v1 < a1[256] )
    goto LABEL_4;
  v3 = (int (__fastcall *)(_DWORD *, int, _DWORD))a1[258];
  a1[257] = 0;
  v4 = v3(a1, 1024, a1[259]);
  a1[256] = v4;
  if ( (unsigned int)(v4 - 1) <= 0xFFFFFFFD )
  {
    v1 = a1[257];
LABEL_4:
    result = *((unsigned __int8 *)a1 + v1);
    a1[257] = v1 + 1;
    return result;
  }
  return -1;
}

//----- (00045F98) --------------------------------------------------------
int sub_45F98(int result, _DWORD *a2, int a3, const char *a4, ...)
{
  int v4; // r6
  const char *v7; // r0
  int v8; // r8
  int v9; // r7
  int v10; // r9
  char *v11; // r3
  char s[160]; // [sp+18h] [bp-144h] BYREF
  char v13[159]; // [sp+B8h] [bp-A4h] BYREF
  char v14; // [sp+157h] [bp-5h]
  const char *varg_r3; // [sp+17Ch] [bp+20h]
  va_list va; // [sp+180h] [bp+24h] BYREF

  va_start(va, a4);
  varg_r3 = a4;
  v4 = result;
  if ( result )
  {
    vsnprintf(s, 0xA0u, varg_r3, va);
    s[159] = 0;
    if ( a2 )
    {
      v7 = (const char *)sub_47894((int)(a2 + 10));
      v8 = a2[6];
      v9 = a2[7];
      v10 = a2[9];
      if ( v7 && *v7 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v13, 0xA0u, "%s near '%s'", s, v7);
          v11 = v13;
          v14 = 0;
          return sub_49824(v4, v8, v9, v10, a3, "%s", v11);
        }
      }
      else
      {
        if ( a3 == 8 )
          LOBYTE(a3) = 6;
        if ( a2[5] != -2 )
        {
          snprintf(v13, 0xA0u, "%s near end of file", s);
          v11 = v13;
          v14 = 0;
          return sub_49824(v4, v8, v9, v10, a3, "%s", v11);
        }
      }
      v11 = s;
    }
    else
    {
      v9 = -1;
      v11 = s;
      v10 = 0;
      v8 = -1;
    }
    return sub_49824(v4, v8, v9, v10, a3, "%s", v11);
  }
  return result;
}

//----- (000460C8) --------------------------------------------------------
void __fastcall sub_460C8(int a1)
{
  if ( *(_DWORD *)(a1 + 60) == 256 )
  {
    sub_47764(*(void **)(a1 + 64));
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 68) = 0;
    sub_47854(a1 + 40);
  }
  else
  {
    sub_47854(a1 + 40);
  }
}

//----- (00046108) --------------------------------------------------------
int __fastcall sub_46108(int *a1)
{
  _BYTE buf[5]; // [sp+7h] [bp-5h] BYREF

  if ( read(*a1, buf, 1u) == 1 )
    return buf[0];
  else
    return -1;
}

//----- (00046134) --------------------------------------------------------
int __fastcall sub_46134(_BYTE *a1)
{
  _BYTE *v1; // r3
  int result; // r0
  _BYTE *v3; // lr
  int v4; // r2
  int v5; // t1
  int v6; // r0
  int v7; // r1

  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 0x135u, "decode_unicode_escape");
  v1 = a1;
  result = 0;
  v3 = v1 + 4;
  while ( 1 )
  {
    v5 = (unsigned __int8)*++v1;
    v4 = v5;
    v6 = 16 * result;
    v7 = v5 - 48;
    if ( (unsigned __int8)(v5 - 48) > 9u )
      break;
    result = v7 + v6;
LABEL_10:
    if ( v1 == v3 )
      return result;
  }
  if ( (unsigned int)(v4 - 97) <= 0x19 )
  {
    result = v4 - 87 + v6;
    goto LABEL_10;
  }
  if ( (unsigned int)(v4 - 65) <= 0x19 )
  {
    result = v4 - 55 + v6;
    goto LABEL_10;
  }
  return -1;
}

//----- (000461C8) --------------------------------------------------------
_DWORD *__fastcall sub_461C8(_DWORD *result, int a2)
{
  _DWORD *v2; // r4
  int v4; // r2
  int v5; // r3
  int v6; // r3

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    --result[9];
    if ( a2 == 10 )
    {
      v4 = result[8];
      --result[6];
      result[7] = v4;
    }
    else
    {
      result = (_DWORD *)sub_47CE4((unsigned __int8)a2);
      if ( result )
        --v2[7];
    }
    v5 = v2[4];
    if ( !v5 )
      _assert_fail("stream->buffer_pos > 0", "load.c", 0xEEu, "stream_unget");
    v6 = v5 - 1;
    v2[4] = v6;
    if ( *((unsigned __int8 *)v2 + v6 + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 0xF0u, "stream_unget");
  }
  return result;
}

//----- (00046284) --------------------------------------------------------
int __fastcall sub_46284(int a1, int a2)
{
  int v2; // r2
  int v4; // r3
  int v5; // r6
  int v6; // r1
  int v8; // r0
  int v9; // r5
  int v11; // r3
  int v12; // r2
  unsigned int v13; // r0
  unsigned int v14; // r8
  _BYTE *v15; // r6
  _BYTE *v16; // r9
  int v17; // r2
  char arg[4]; // [sp+0h] [bp-8h]

  v2 = *(_DWORD *)(a1 + 16);
  v4 = a1 + v2;
  v5 = *(unsigned __int8 *)(a1 + v2 + 8);
  if ( *(_BYTE *)(a1 + v2 + 8) )
  {
    v6 = v2 + 1;
    goto LABEL_8;
  }
  v8 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  v9 = v8;
  if ( v8 == -1 )
  {
    *(_DWORD *)(a1 + 20) = -1;
    return v9;
  }
  *(_DWORD *)(a1 + 16) = v5;
  *(_BYTE *)(a1 + 8) = v8;
  if ( (unsigned int)(v8 - 128) <= 0x7F )
  {
    v13 = sub_47CE4((unsigned __int8)v8);
    v14 = v13;
    if ( !v13 )
      goto LABEL_20;
    if ( v13 <= 1 )
      _assert_fail("count >= 2", "load.c", 0xBDu, "stream_get");
    v15 = (_BYTE *)(a1 + 9);
    v16 = (_BYTE *)(a1 + 8 + v13);
    do
      *v15++ = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    while ( v16 != v15 );
    if ( !sub_47D50((char *)(a1 + 8), v14, 0) )
    {
LABEL_20:
      *(_DWORD *)arg = v9;
      v9 = -2;
      *(_DWORD *)(a1 + 20) = -2;
      sub_45F98(a2, (_DWORD *)a1, 5, "unable to decode byte 0x%x", *(_DWORD *)arg);
      return v9;
    }
    *(_BYTE *)(a1 + v14 + 8) = 0;
    v17 = *(_DWORD *)(a1 + 16);
    v6 = v17 + 1;
    v4 = a1 + v17;
  }
  else
  {
    v6 = 1;
    v4 = a1;
    *(_BYTE *)(a1 + 9) = v5;
  }
LABEL_8:
  *(_DWORD *)(a1 + 16) = v6;
  v9 = *(unsigned __int8 *)(v4 + 8);
  ++*(_DWORD *)(a1 + 36);
  if ( v9 != 10 )
  {
    if ( sub_47CE4(v9) )
      ++*(_DWORD *)(a1 + 28);
    return v9;
  }
  v11 = *(_DWORD *)(a1 + 24);
  v12 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = v11 + 1;
  *(_DWORD *)(a1 + 32) = v12;
  return 10;
}

//----- (0004640C) --------------------------------------------------------
int __fastcall sub_4640C(int a1, int a2)
{
  int v3; // r4

  v3 = *(_DWORD *)(a1 + 20);
  if ( !v3 )
    v3 = sub_46284(a1, a2);
  if ( (unsigned int)(v3 + 2) > 1 )
    fh_buffer_putc((const void **)(a1 + 40), v3);
  return v3;
}

//----- (0004644C) --------------------------------------------------------
_DWORD *__fastcall sub_4644C(_DWORD *result, int a2)
{
  _DWORD *v2; // r5
  char v4; // r1
  int v5; // r2

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    sub_461C8(result, a2);
    result = (_DWORD *)sub_479A0(v2 + 10, v4, v5);
    if ( result != (_DWORD *)a2 )
      _assert_fail("c == d", "load.c", 0x11Au, "lex_unget_unsave");
  }
  return result;
}
// 4646C: variable 'v4' is possibly undefined
// 4646C: variable 'v5' is possibly undefined

//----- (00046498) --------------------------------------------------------
unsigned int __fastcall sub_46498(int a1, int a2)
{
  const void **v2; // r7
  unsigned int v5; // r4
  bool v6; // cc
  int v7; // r3
  int v8; // r4
  bool v9; // zf
  _BOOL4 v10; // r2
  bool v11; // cc
  int v12; // r0
  const char *v13; // r4
  int v15; // r1
  int v16; // r0
  unsigned int v17; // r4
  int v18; // r0
  bool v19; // zf
  int v20; // r0
  bool v21; // zf
  const char *v22; // r4
  int *v23; // r7
  __int64 v24; // r0
  char i; // r1
  int v26; // r3
  int v27; // r2
  double v28; // r2
  int v29; // r8
  unsigned int v30; // r3
  unsigned int v31; // r4
  bool v32; // cc
  int v33; // r1
  _BYTE *v34; // r8
  unsigned __int8 *j; // r4
  int v36; // r3
  unsigned int v37; // r3
  int v38; // r0
  int v39; // r11
  int v40; // r0
  int v41; // r1
  int v42; // r0
  int v43; // r2
  const char *v44; // r3
  const char *v45; // r3
  char arg[4]; // [sp+0h] [bp-1Ch]
  int v47; // [sp+Ch] [bp-10h]
  double endptr; // [sp+10h] [bp-Ch] BYREF

  v2 = (const void **)(a1 + 40);
  sub_47880(a1 + 40);
  if ( *(_DWORD *)(a1 + 60) == 256 )
  {
    sub_47764(*(void **)(a1 + 64));
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 68) = 0;
  }
  do
  {
    v5 = *(_DWORD *)(a1 + 20);
    if ( !v5 )
      v5 = sub_46284(a1, a2);
    v6 = v5 > 0x20;
    if ( v5 != 32 )
      v6 = v5 - 9 > 1;
    v7 = !v6;
  }
  while ( !v6 || v5 == 13 );
  if ( v5 == -1 )
  {
    *(_DWORD *)(a1 + 60) = v7;
    return v7;
  }
  if ( v5 == -2 )
    goto LABEL_35;
  fh_buffer_putc(v2, v5);
  if ( (((v5 & 0xFFFFFFDF) - 91) & 0xFFFFFFFD) == 0 )
    goto LABEL_38;
  v9 = v5 == 44;
  if ( v5 != 44 )
    v9 = v5 == 58;
  v10 = v9;
  if ( v9 )
    goto LABEL_38;
  if ( v5 != 34 )
  {
    v11 = v5 > 0x2D;
    if ( v5 != 45 )
      v11 = v5 - 48 > 9;
    if ( !v11 )
    {
      *(_DWORD *)(a1 + 60) = -1;
      if ( v5 == 45 )
      {
        v42 = sub_4640C(a1, a2);
        v41 = v42;
        if ( v42 != 48 )
        {
          if ( (unsigned int)(v42 - 48) > 9 )
            goto LABEL_118;
          goto LABEL_58;
        }
      }
      else if ( v5 != 48 )
      {
        do
LABEL_58:
          v20 = sub_4640C(a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
        goto LABEL_59;
      }
      v20 = sub_4640C(a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
LABEL_117:
        v41 = v20;
LABEL_118:
        sub_4644C((_DWORD *)a1, v41);
        return *(_DWORD *)(a1 + 60);
      }
LABEL_59:
      if ( (*(_DWORD *)(a1 + 52) & 8) != 0 )
        goto LABEL_70;
      v21 = v20 == 46;
      if ( v20 != 46 )
        v21 = v20 == 69;
      if ( v21 )
      {
LABEL_70:
        if ( v20 == 46 )
        {
          v33 = *(_DWORD *)(a1 + 20);
          if ( !v33 )
            v33 = sub_46284(a1, a2);
          if ( (unsigned int)(v33 - 48) > 9 )
          {
            sub_461C8((_DWORD *)a1, v33);
            return *(_DWORD *)(a1 + 60);
          }
          fh_buffer_putc(v2, v33);
          do
            v20 = sub_4640C(a1, a2);
          while ( (unsigned int)(v20 - 48) <= 9 );
        }
        if ( (v20 & 0xFFFFFFDF) != 0x45 )
          goto LABEL_72;
      }
      else if ( v20 != 101 )
      {
        sub_4644C((_DWORD *)a1, v20);
        v22 = (const char *)sub_47894((int)v2);
        v23 = _errno_location();
        *v23 = 0;
        v24 = strtoll(v22, (char **)&endptr, 10);
        if ( *v23 == 34 )
        {
          if ( v24 >= 0 )
            LOWORD(v45) = 26404;
          else
            LOWORD(v45) = 26376;
          HIWORD(v45) = 5;
          sub_45F98(a2, (_DWORD *)a1, 15, v45);
          return *(_DWORD *)(a1 + 60);
        }
        else
        {
          if ( (const char *)LODWORD(endptr) != &v22[*(_DWORD *)(a1 + 44)] )
            _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 0x21Du, "lex_scan_number");
          v8 = 257;
          *(_QWORD *)(a1 + 64) = v24;
          *(_DWORD *)(a1 + 60) = 257;
        }
        return v8;
      }
      v20 = sub_4640C(a1, a2);
      if ( ((v20 - 43) & 0xFFFFFFFD) == 0 )
        v20 = sub_4640C(a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
        do
          v20 = sub_4640C(a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
LABEL_72:
        sub_4644C((_DWORD *)a1, v20);
        if ( sub_479C8((int)v2, &endptr) )
        {
          sub_45F98(a2, (_DWORD *)a1, 15, "real number overflow");
          return *(_DWORD *)(a1 + 60);
        }
        else
        {
          v28 = endptr;
          v8 = 258;
          *(_DWORD *)(a1 + 60) = 258;
          *(double *)(a1 + 64) = v28;
        }
        return v8;
      }
      goto LABEL_117;
    }
    if ( (v5 & 0xFFFFFFDF) - 65 <= 0x19 )
    {
      do
        v12 = sub_4640C(a1, a2);
      while ( (v12 & 0xFFFFFFDF) - 65 <= 0x19 );
      sub_4644C((_DWORD *)a1, v12);
      v13 = (const char *)sub_47894((int)v2);
      if ( !strcmp(v13, "true") )
      {
        v8 = 259;
        *(_DWORD *)(a1 + 60) = 259;
        return v8;
      }
      if ( strcmp(v13, "false") )
      {
        if ( !strcmp(v13, "null") )
        {
          v8 = 261;
          *(_DWORD *)(a1 + 60) = 261;
          return v8;
        }
        goto LABEL_35;
      }
      v5 = 260;
LABEL_38:
      *(_DWORD *)(a1 + 60) = v5;
      return v5;
    }
    for ( i = *(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8); i; i = *(_BYTE *)(a1 + v26 + 8) )
    {
      fh_buffer_putc(v2, i);
      v26 = *(_DWORD *)(a1 + 16) + 1;
      v27 = *(_DWORD *)(a1 + 36) + 1;
      *(_DWORD *)(a1 + 16) = v26;
      *(_DWORD *)(a1 + 36) = v27;
    }
LABEL_35:
    v8 = -1;
    *(_DWORD *)(a1 + 60) = -1;
    return v8;
  }
  *(_DWORD *)(a1 + 64) = v10;
  *(_DWORD *)(a1 + 60) = -1;
LABEL_40:
  v15 = a2;
  v16 = a1;
  while ( 1 )
  {
    v17 = sub_4640C(v16, v15);
LABEL_42:
    if ( v17 == 34 )
    {
      v34 = sub_4774C((void *)(*(_DWORD *)(a1 + 44) + 1));
      if ( !v34 )
        goto LABEL_55;
      *(_DWORD *)(a1 + 64) = v34;
      for ( j = (unsigned __int8 *)(sub_47894((int)v2) + 1); ; j += 2 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v36 = *j;
            if ( v36 == 34 )
            {
              *v34 = 0;
              v8 = 256;
              v43 = *(_DWORD *)(a1 + 64);
              *(_DWORD *)(a1 + 60) = 256;
              *(_DWORD *)(a1 + 68) = &v34[-v43];
              return v8;
            }
            if ( v36 == 92 )
              break;
            *v34 = v36;
            ++j;
            ++v34;
          }
          v37 = j[1];
          if ( v37 != 117 )
            break;
          v38 = sub_46134(j + 1);
          v39 = v38;
          if ( v38 < 0 )
          {
            LOWORD(v44) = (unsigned __int16)"invalid Unicode escape '%.6s'";
            *(_DWORD *)arg = j;
LABEL_138:
            HIWORD(v44) = (unsigned int)"invalid Unicode escape '%.6s'" >> 16;
            sub_45F98(a2, (_DWORD *)a1, 8, v44, *(_DWORD *)arg);
            goto LABEL_55;
          }
          v47 = v38 - 55296;
          if ( (unsigned int)(v38 - 55296) >= 0x400 )
          {
            if ( (unsigned int)(v38 - 56320) < 0x400 )
              goto LABEL_142;
            j += 6;
          }
          else
          {
            if ( j[6] != 92 || j[7] != 117 )
            {
LABEL_142:
              sub_45F98(a2, (_DWORD *)a1, 8, "invalid Unicode '\\u%04X'", v38);
              goto LABEL_55;
            }
            v40 = sub_46134(j + 7);
            if ( v40 < 0 )
            {
              LOWORD(v44) = 26284;
              *(_DWORD *)arg = j + 6;
              goto LABEL_138;
            }
            j += 12;
            if ( (unsigned int)(v40 - 56320) >= 0x400 )
            {
              sub_45F98(a2, (_DWORD *)a1, 8, "invalid Unicode '\\u%04X\\u%04X'", v39, v40);
              goto LABEL_55;
            }
            v39 = v40 - 56320 + (v47 << 10) + 0x10000;
          }
          if ( sub_47BF8(v39, v34, &endptr) )
            _assert_fail((const char *)&word_55AAC, "load.c", 0x1C4u, "lex_scan_string");
          v34 += LODWORD(endptr);
        }
        if ( v37 == 98 )
        {
          *v34 = 8;
        }
        else
        {
          if ( v37 <= 0x62 )
          {
            if ( v37 != 47 && v37 != 92 && v37 != 34 )
LABEL_130:
              _assert_fail((const char *)&word_55AAC, "load.c", 0x1D0u, "lex_scan_string");
            goto LABEL_125;
          }
          if ( v37 == 110 )
          {
            *v34 = 10;
          }
          else
          {
            if ( v37 <= 0x6E )
            {
              if ( v37 != 102 )
                goto LABEL_130;
              LOBYTE(v37) = 12;
LABEL_125:
              *v34 = v37;
              goto LABEL_106;
            }
            if ( v37 == 114 )
            {
              *v34 = 13;
            }
            else
            {
              if ( v37 != 116 )
                goto LABEL_130;
              *v34 = 9;
            }
          }
        }
LABEL_106:
        ++v34;
      }
    }
    if ( v17 == -2 )
      goto LABEL_55;
    if ( v17 == -1 )
    {
      sub_45F98(a2, (_DWORD *)a1, 6, "premature end of input");
      goto LABEL_55;
    }
    if ( v17 <= 0x1F )
      break;
    v15 = a2;
    v16 = a1;
    if ( v17 == 92 )
    {
      v18 = sub_4640C(a1, a2);
      if ( v18 == 117 )
      {
        v29 = 4;
        v17 = sub_4640C(a1, a2);
        while ( 1 )
        {
          v30 = v17 & 0xFFFFFFDF;
          v31 = v17 - 48;
          v30 -= 65;
          v32 = v30 > 5;
          if ( v30 > 5 )
            v32 = v31 > 9;
          if ( v32 )
            break;
          --v29;
          v17 = sub_4640C(a1, a2);
          if ( !v29 )
            goto LABEL_42;
        }
LABEL_54:
        sub_45F98(a2, (_DWORD *)a1, 8, "invalid escape");
        goto LABEL_55;
      }
      v19 = v18 == 92;
      if ( v18 != 92 )
        v19 = (v18 & 0xFFFFFFBF) == 34;
      if ( !v19 && v18 != 47 && (v18 & 0xFFFFFFF7) != 0x66 && ((v18 - 114) & 0xFFFFFFFD) != 0 )
        goto LABEL_54;
      goto LABEL_40;
    }
  }
  sub_4644C((_DWORD *)a1, v17);
  if ( v17 == 10 )
    sub_45F98(a2, (_DWORD *)a1, 8, "unexpected newline");
  else
    sub_45F98(a2, (_DWORD *)a1, 8, "control character 0x%x", v17);
LABEL_55:
  sub_47764(*(void **)(a1 + 64));
  v8 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  return v8;
}
// 55AAC: using guessed type __int16 word_55AAC;

//----- (00046CB0) --------------------------------------------------------
_DWORD *__fastcall sub_46CB0(int a1, int a2, int a3)
{
  unsigned int v5; // r3
  int v6; // r3
  _DWORD *v7; // r6
  _BYTE *v10; // r7
  size_t v11; // r9
  int v12; // r3
  void *v13; // r7
  size_t v14; // r2
  _DWORD *v15; // r2
  int v16; // r3
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r2
  int v20; // r3
  int v21; // r3
  _DWORD *v22; // r1
  unsigned int *v23; // r3
  unsigned int v24; // r2
  _DWORD *v25; // r0

  v5 = *(_DWORD *)(a1 + 56) + 1;
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 > 0x800 )
  {
    v7 = 0;
    sub_45F98(a3, (_DWORD *)a1, 2, "maximum parsing depth reached");
    return v7;
  }
  v6 = *(_DWORD *)(a1 + 60);
  if ( v6 == 257 )
  {
    v7 = sub_48858(*(_QWORD *)(a1 + 64));
    goto LABEL_9;
  }
  if ( v6 <= 257 )
  {
    if ( v6 == 91 )
    {
      v7 = sub_48408();
      if ( !v7 )
        return 0;
      sub_46498(a1, a3);
      v20 = *(_DWORD *)(a1 + 60);
      if ( v20 == 93 )
        goto LABEL_10;
      if ( v20 )
      {
        while ( 1 )
        {
          v22 = (_DWORD *)sub_46CB0(a1, a2, a3);
          if ( !v22 || sub_4935C(v7, v22) )
            break;
          sub_46498(a1, a3);
          v21 = *(_DWORD *)(a1 + 60);
          if ( v21 != 44 )
          {
            if ( v21 == 93 )
              goto LABEL_10;
            goto LABEL_62;
          }
          sub_46498(a1, a3);
          if ( !*(_DWORD *)(a1 + 60) )
            goto LABEL_62;
        }
      }
      else
      {
LABEL_62:
        sub_45F98(a3, (_DWORD *)a1, 8, "']' expected");
      }
      if ( v7[1] == -1 )
        return 0;
      v23 = v7 + 1;
      __dmb(0xBu);
      do
      {
        v24 = __ldrex(v23);
        v19 = v24 - 1;
      }
      while ( __strex(v19, v23) );
    }
    else
    {
      if ( v6 <= 91 )
      {
        if ( v6 == -1 )
        {
          v7 = 0;
          sub_45F98(a3, (_DWORD *)a1, 8, "invalid token");
          return v7;
        }
        goto LABEL_57;
      }
      if ( v6 != 123 )
      {
        if ( v6 != 256 )
          goto LABEL_57;
        v10 = *(_BYTE **)(a1 + 64);
        v11 = *(_DWORD *)(a1 + 68);
        if ( (a2 & 0x10) == 0 && memchr(*(const void **)(a1 + 64), 0, *(_DWORD *)(a1 + 68)) )
        {
          v7 = 0;
          sub_45F98(a3, (_DWORD *)a1, 11, "\\u0000 is not allowed without JSON_ALLOW_NUL");
          return v7;
        }
        v7 = sub_485C0(v10, v11);
        *(_DWORD *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 68) = 0;
        goto LABEL_9;
      }
      v7 = sub_48078();
      if ( !v7 )
        return 0;
      sub_46498(a1, a3);
      v12 = *(_DWORD *)(a1 + 60);
      if ( v12 == 125 )
        goto LABEL_10;
      if ( v12 == 256 )
      {
        v13 = *(void **)(a1 + 64);
        v14 = *(_DWORD *)(a1 + 68);
        *(_DWORD *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 68) = 0;
        if ( !v13 )
          return 0;
        while ( 1 )
        {
          if ( memchr(v13, 0, v14) )
          {
            sub_47764(v13);
            sub_45F98(a3, (_DWORD *)a1, 13, "NUL byte in object key not supported");
            goto LABEL_36;
          }
          if ( (a2 & 1) != 0 && sub_480FC(v7, (char *)v13) )
          {
            sub_47764(v13);
            sub_45F98(a3, (_DWORD *)a1, 14, "duplicate object key");
            goto LABEL_36;
          }
          sub_46498(a1, a3);
          if ( *(_DWORD *)(a1 + 60) != 58 )
          {
            sub_47764(v13);
            sub_45F98(a3, (_DWORD *)a1, 8, "':' expected");
            goto LABEL_36;
          }
          sub_46498(a1, a3);
          v15 = (_DWORD *)sub_46CB0(a1, a2, a3);
          if ( !v15 || sub_48CF4(v7, (char *)v13, v15) )
          {
            sub_47764(v13);
            goto LABEL_36;
          }
          sub_47764(v13);
          sub_46498(a1, a3);
          v16 = *(_DWORD *)(a1 + 60);
          if ( v16 != 44 )
            break;
          sub_46498(a1, a3);
          if ( *(_DWORD *)(a1 + 60) != 256 )
            goto LABEL_63;
          v13 = *(void **)(a1 + 64);
          v14 = *(_DWORD *)(a1 + 68);
          *(_DWORD *)(a1 + 64) = 0;
          *(_DWORD *)(a1 + 68) = 0;
          if ( !v13 )
            return 0;
        }
        if ( v16 == 125 )
          goto LABEL_10;
        sub_45F98(a3, (_DWORD *)a1, 8, "'}' expected");
      }
      else
      {
LABEL_63:
        sub_45F98(a3, (_DWORD *)a1, 8, "string or '}' expected");
      }
LABEL_36:
      if ( v7[1] == -1 )
        return 0;
      v17 = v7 + 1;
      __dmb(0xBu);
      do
      {
        v18 = __ldrex(v17);
        v19 = v18 - 1;
      }
      while ( __strex(v19, v17) );
    }
    if ( !v19 )
    {
      v25 = v7;
      v7 = 0;
      sub_48A34(v25);
      return v7;
    }
    return 0;
  }
  if ( v6 == 259 )
  {
    v7 = sub_48A10();
  }
  else if ( v6 < 259 )
  {
    v7 = sub_488DC();
  }
  else
  {
    if ( v6 != 260 )
    {
      if ( v6 == 261 )
      {
        v7 = sub_48A28();
        goto LABEL_9;
      }
LABEL_57:
      v7 = 0;
      sub_45F98(a3, (_DWORD *)a1, 8, "unexpected token");
      return v7;
    }
    v7 = sub_48A1C();
  }
LABEL_9:
  if ( v7 )
  {
LABEL_10:
    --*(_DWORD *)(a1 + 56);
    return v7;
  }
  return 0;
}

//----- (00047154) --------------------------------------------------------
_DWORD *__fastcall sub_47154(_DWORD *a1, int a2, int a3)
{
  _DWORD *v6; // r7
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  _DWORD *v11; // r0

  a1[14] = 0;
  sub_46498((int)a1, a3);
  v6 = (_DWORD *)(a2 & 4);
  if ( (a2 & 4) == 0 && (a1[15] & 0xFFFFFFDF) != 0x5B )
  {
    sub_45F98(a3, a1, 8, "'[' or '{' expected");
    return v6;
  }
  v6 = sub_46CB0((int)a1, a2, a3);
  if ( v6 )
  {
    if ( (a2 & 2) != 0 || (sub_46498((int)a1, a3), !a1[15]) )
    {
      if ( a3 )
        *(_DWORD *)(a3 + 8) = a1[9];
      return v6;
    }
    sub_45F98(a3, a1, 7, "end of file expected");
    if ( v6[1] != -1 )
    {
      v8 = v6 + 1;
      __dmb(0xBu);
      do
      {
        v9 = __ldrex(v8);
        v10 = v9 - 1;
      }
      while ( __strex(v10, v8) );
      if ( !v10 )
      {
        v11 = v6;
        v6 = 0;
        sub_48A34(v11);
        return v6;
      }
    }
  }
  return 0;
}

//----- (00047258) --------------------------------------------------------
_DWORD *__fastcall sub_47258(int a1, int a2, char *a3)
{
  _DWORD *v6; // r4
  _DWORD v8[2]; // [sp+0h] [bp-54h] BYREF
  _DWORD v9[2]; // [sp+8h] [bp-4Ch] BYREF
  char v10; // [sp+10h] [bp-44h]
  int v11; // [sp+18h] [bp-3Ch]
  int v12; // [sp+1Ch] [bp-38h]
  int v13; // [sp+20h] [bp-34h]
  int v14; // [sp+24h] [bp-30h]
  int v15; // [sp+2Ch] [bp-28h]
  _DWORD v16[9]; // [sp+30h] [bp-24h] BYREF

  sub_497D4(a3, "<string>");
  if ( a1 )
  {
    v6 = 0;
    v8[0] = a1;
    v9[0] = sub_45EF4;
    v8[1] = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v9[1] = v8;
    v13 = 1;
    if ( !sub_47820(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v6 = sub_47154(v9, a2, (int)a3);
      sub_460C8((int)v9);
    }
  }
  else
  {
    v6 = 0;
    sub_45F98((int)a3, 0, 4, "wrong arguments");
  }
  return v6;
}

//----- (00047320) --------------------------------------------------------
_DWORD *__fastcall sub_47320(int a1, int a2, int a3, char *a4)
{
  _DWORD *v8; // r4
  _DWORD v10[3]; // [sp+4h] [bp-54h] BYREF
  _DWORD v11[2]; // [sp+10h] [bp-48h] BYREF
  char v12; // [sp+18h] [bp-40h]
  int v13; // [sp+20h] [bp-38h]
  int v14; // [sp+24h] [bp-34h]
  int v15; // [sp+28h] [bp-30h]
  int v16; // [sp+2Ch] [bp-2Ch]
  int v17; // [sp+34h] [bp-24h]
  _DWORD v18[8]; // [sp+38h] [bp-20h] BYREF

  sub_497D4(a4, "<buffer>");
  if ( a1 )
  {
    v8 = 0;
    v10[0] = a1;
    v10[1] = a2;
    v11[0] = sub_45F18;
    v10[2] = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v16 = 0;
    v17 = 0;
    v11[1] = v10;
    v15 = 1;
    if ( !sub_47820(v18) )
    {
      v18[3] = a3;
      v18[5] = -1;
      v8 = sub_47154(v11, a3, (int)a4);
      sub_460C8((int)v11);
    }
  }
  else
  {
    v8 = 0;
    sub_45F98((int)a4, 0, 4, "wrong arguments");
  }
  return v8;
}

//----- (000473F4) --------------------------------------------------------
_DWORD *__fastcall sub_473F4(int a1, int a2, char *a3)
{
  char *v6; // r1
  _DWORD *v7; // r4
  _DWORD v9[2]; // [sp+0h] [bp-4Ch] BYREF
  char v10; // [sp+8h] [bp-44h]
  int v11; // [sp+10h] [bp-3Ch]
  int v12; // [sp+14h] [bp-38h]
  int v13; // [sp+18h] [bp-34h]
  int v14; // [sp+1Ch] [bp-30h]
  int v15; // [sp+24h] [bp-28h]
  _DWORD v16[9]; // [sp+28h] [bp-24h] BYREF

  if ( stdin == a1 )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  sub_497D4(a3, v6);
  if ( a1 )
  {
    v7 = 0;
    v9[1] = a1;
    v9[0] = fgetc;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !sub_47820(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v7 = sub_47154(v9, a2, (int)a3);
      sub_460C8((int)v9);
    }
  }
  else
  {
    v7 = 0;
    sub_45F98((int)a3, 0, 4, "wrong arguments");
  }
  return v7;
}
// 68A70: using guessed type int stdin;

//----- (000474D4) --------------------------------------------------------
_DWORD *__fastcall sub_474D4(int a1, int a2, char *a3)
{
  char *v4; // r1
  _DWORD *v6; // r4
  int v8; // [sp+4h] [bp-4Ch] BYREF
  _DWORD v9[2]; // [sp+8h] [bp-48h] BYREF
  char v10; // [sp+10h] [bp-40h]
  int v11; // [sp+18h] [bp-38h]
  int v12; // [sp+1Ch] [bp-34h]
  int v13; // [sp+20h] [bp-30h]
  int v14; // [sp+24h] [bp-2Ch]
  int v15; // [sp+2Ch] [bp-24h]
  _DWORD v16[8]; // [sp+30h] [bp-20h] BYREF

  v8 = a1;
  if ( a1 )
    v4 = "<stream>";
  else
    v4 = "<stdin>";
  sub_497D4(a3, v4);
  if ( v8 < 0 )
  {
    v6 = 0;
    sub_45F98((int)a3, 0, 4, "wrong arguments");
  }
  else
  {
    v6 = 0;
    v9[0] = sub_46108;
    v9[1] = &v8;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !sub_47820(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v6 = sub_47154(v9, a2, (int)a3);
      sub_460C8((int)v9);
    }
  }
  return v6;
}

//----- (000475B0) --------------------------------------------------------
_DWORD *__fastcall sub_475B0(char *a1, int a2, char *a3)
{
  int v6; // r0
  FILE *v7; // r7
  _DWORD *v8; // r6
  int *v10; // r0
  char *v11; // r0

  sub_497D4(a3, a1);
  if ( a1 )
  {
    v6 = fopen64(a1, "rb");
    v7 = (FILE *)v6;
    if ( v6 )
    {
      v8 = sub_473F4(v6, a2, a3);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      sub_45F98((int)a3, 0, 3, "unable to open %s: %s", a1, v11);
    }
  }
  else
  {
    v8 = 0;
    sub_45F98((int)a3, 0, 4, "wrong arguments");
  }
  return v8;
}
// 124E4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0004774C) --------------------------------------------------------
void *__fastcall sub_4774C(void *result)
{
  if ( result )
    return off_68A44((size_t)result);
  return result;
}
// 68A44: using guessed type void *(*off_68A44)(size_t size);

//----- (00047764) --------------------------------------------------------
void __fastcall sub_47764(void *a1)
{
  if ( a1 )
    off_68A48(a1);
}
// 68A48: using guessed type void (*off_68A48)(void *ptr);

//----- (0004777C) --------------------------------------------------------
_BYTE *__fastcall sub_4777C(const void *a1, size_t a2)
{
  _BYTE *v2; // r5
  _BYTE *v5; // r0

  v2 = (_BYTE *)(a2 + 1);
  if ( a2 != -1 )
  {
    v5 = off_68A44(a2 + 1);
    v2 = v5;
    if ( v5 )
    {
      memcpy(v5, a1, a2);
      v2[a2] = 0;
    }
  }
  return v2;
}
// 68A44: using guessed type void *(*off_68A44)(size_t size);

//----- (000477C8) --------------------------------------------------------
_BYTE *__fastcall sub_477C8(const char *a1)
{
  size_t v2; // r1

  v2 = strlen(a1);
  return sub_4777C(a1, v2);
}

//----- (000477E4) --------------------------------------------------------
int __fastcall sub_477E4(__int64 a1)
{
  *(_QWORD *)&off_68A44 = a1;
  return a1;
}
// 68A44: using guessed type void *(*off_68A44)(size_t size);

//----- (000477F4) --------------------------------------------------------
_DWORD *__fastcall sub_477F4(_DWORD *result, _DWORD *a2)
{
  if ( result )
    *result = off_68A44;
  if ( a2 )
    *a2 = off_68A48;
  return result;
}
// 68A44: using guessed type void *(*off_68A44)(size_t size);
// 68A48: using guessed type void (*off_68A48)(void *ptr);

//----- (00047820) --------------------------------------------------------
int __fastcall sub_47820(_DWORD *a1)
{
  _BYTE *v2; // r0

  a1[2] = 16;
  a1[1] = 0;
  v2 = sub_4774C((void *)0x10);
  *a1 = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (00047854) --------------------------------------------------------
void __fastcall sub_47854(int a1)
{
  void *v2; // r0

  v2 = *(void **)a1;
  if ( v2 )
    sub_47764(v2);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
}

//----- (00047880) --------------------------------------------------------
int __fastcall sub_47880(int result)
{
  _BYTE *v1; // r2

  v1 = *(_BYTE **)result;
  *(_DWORD *)(result + 4) = 0;
  *v1 = 0;
  return result;
}

//----- (00047894) --------------------------------------------------------
int __fastcall sub_47894(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0004789C) --------------------------------------------------------
int __fastcall sub_4789C(int *a1)
{
  int result; // r0

  result = *a1;
  *a1 = 0;
  return result;
}

//----- (000478B0) --------------------------------------------------------
int __fastcall sub_478B0(const void **a1, void *src, size_t n)
{
  unsigned int v4; // r3
  size_t v7; // r0
  char *v8; // r8
  unsigned int v9; // r3
  unsigned int v10; // r0
  void *v11; // r6
  char *v12; // r0
  char *v13; // r2
  size_t v15; // r5

  v4 = (unsigned int)a1[2];
  v7 = (size_t)a1[1];
  if ( v4 - v7 > n )
  {
    v8 = (char *)*a1;
LABEL_10:
    memcpy(&v8[v7], src, n);
    v13 = (char *)*a1;
    v15 = (size_t)a1[1] + n;
    a1[1] = (const void *)v15;
    v13[v15] = 0;
    return 0;
  }
  if ( !((n == -1) | (v4 >> 31)) && -2 - n >= v7 )
  {
    v9 = 2 * v4;
    v10 = n + 1 + v7;
    v11 = (void *)(v10 < v9 ? v9 : v10);
    v12 = (char *)sub_4774C(v11);
    v8 = v12;
    if ( v12 )
    {
      memcpy(v12, *a1, (size_t)a1[1]);
      sub_47764((void *)*a1);
      v7 = (size_t)a1[1];
      *a1 = v8;
      a1[2] = v11;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (0004797C) --------------------------------------------------------
int __fastcall fh_buffer_putc(const void **a1, char a2)
{
  char v3; // [sp+7h] [bp-5h] BYREF

  v3 = a2;
  return sub_478B0(a1, &v3, 1u);
}

//----- (000479A0) --------------------------------------------------------
int __fastcall sub_479A0(int *a1, char a2, int a3)
{
  int v3; // r3
  bool v4; // zf
  int result; // r0

  v3 = a1[1];
  v4 = v3 == 0;
  if ( v3 )
  {
    a3 = *a1;
    --v3;
    a2 = 0;
    a1[1] = v3;
    result = *(unsigned __int8 *)(a3 + v3);
  }
  else
  {
    result = 0;
  }
  if ( !v4 )
    *(_BYTE *)(a3 + v3) = a2;
  return result;
}

//----- (000479C8) --------------------------------------------------------
int __fastcall sub_479C8(int a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *endptr; // [sp+4h] [bp-8h] BYREF

  v5 = localeconv();
  v6 = *(const char **)a1;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*(const char **)a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *(const char **)a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( endptr != (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 0x4Eu, "jsonp_strtod");
  if ( (v2 > 1.79769313e308 || v2 < -1.79769313e308) && *v9 == 34 )
    return -1;
  result = 0;
  *a2 = v2;
  return result;
}
// 47A48: variable 'v2' is possibly undefined

//----- (00047AB8) --------------------------------------------------------
int __fastcall sub_47AB8(char *a1, size_t a2, int a3)
{
  int v3; // s0
  int v4; // s1
  int v5; // r3
  unsigned int v8; // r0
  unsigned int v9; // r6
  int v10; // r1
  char *v11; // r0
  char *v12; // r5
  char *v13; // r0
  unsigned __int8 *v14; // r4
  int v15; // r3
  _BYTE *v16; // r5
  int v17; // t1
  size_t v18; // r2
  char *v20; // r3

  if ( a3 )
    v5 = a3;
  else
    v5 = 17;
  v8 = snprintf(a1, a2, "%.*g", v5, v3, v4);
  if ( a2 > v8 )
  {
    v9 = v8;
    v10 = *(unsigned __int8 *)localeconv()->decimal_point;
    if ( v10 != 46 )
    {
      v11 = strchr(a1, v10);
      if ( v11 )
        *v11 = 46;
    }
    v12 = strchr(a1, 46);
    v13 = strchr(a1, 101);
    if ( v12 )
    {
LABEL_9:
      if ( !v13 )
        return v9;
      goto LABEL_10;
    }
    if ( v13 )
    {
LABEL_10:
      v14 = (unsigned __int8 *)(v13 + 2);
      v15 = (unsigned __int8)v13[2];
      if ( v13[1] != 45 )
      {
        v16 = v13 + 1;
        if ( v15 != 48 )
        {
LABEL_13:
          if ( v14 != v16 )
          {
            v18 = v9 - (v14 - (unsigned __int8 *)a1);
            v9 -= v14 - v16;
            memmove(v16, v14, v18);
          }
          return v9;
        }
        do
LABEL_12:
          v17 = *++v14;
        while ( v17 == 48 );
        goto LABEL_13;
      }
      if ( v15 == 48 )
      {
        v16 = v13 + 2;
        goto LABEL_12;
      }
      return v9;
    }
    if ( v9 + 3 < a2 )
    {
      a1[v9] = 46;
      v20 = &a1[v9];
      v9 += 2;
      v20[1] = 48;
      a1[v9] = 0;
      v13 = strchr(a1, 101);
      goto LABEL_9;
    }
  }
  return -1;
}
// 47AE0: variable 'v3' is possibly undefined
// 47AE0: variable 'v4' is possibly undefined

//----- (00047BF8) --------------------------------------------------------
int __fastcall sub_47BF8(int a1, _BYTE *a2, _DWORD *a3)
{
  char v3; // r3
  char v5; // r3
  char v6; // r3
  int v7; // r12

  if ( a1 < 0 )
    return -1;
  if ( a1 <= 127 )
  {
    *a2 = a1;
    *a3 = 1;
    return 0;
  }
  else if ( a1 < 2048 )
  {
    v5 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 6) - 64;
    a2[1] = v5;
    *a3 = 2;
    return 0;
  }
  else if ( a1 < 0x10000 )
  {
    v6 = (a1 & 0x3F) + 0x80;
    v7 = (((unsigned int)a1 >> 6) & 0x3F) - 128;
    *a2 = (a1 >> 12) - 32;
    a2[1] = v7;
    a2[2] = v6;
    *a3 = 3;
    return 0;
  }
  else if ( a1 >= 1114112 )
  {
    return -1;
  }
  else
  {
    v3 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 18) - 16;
    a2[1] = (((unsigned int)a1 >> 12) & 0x3F) + 0x80;
    a2[2] = (((unsigned int)a1 >> 6) & 0x3F) + 0x80;
    a2[3] = v3;
    *a3 = 4;
    return 0;
  }
}

//----- (00047CE4) --------------------------------------------------------
int __fastcall sub_47CE4(int a1)
{
  if ( (a1 & 0x80) == 0 )
    return 1;
  if ( (a1 ^ 0x80u) <= 0x41 )
    return 0;
  if ( (unsigned __int8)(a1 + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(a1 + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(a1 + 16) <= 4u )
    return 4;
  return 0;
}

//----- (00047D50) --------------------------------------------------------
int __fastcall sub_47D50(char *a1, unsigned int a2, int *a3)
{
  char v3; // lr
  int v4; // lr
  int result; // r0
  int v6; // r3
  _BYTE *v7; // r0
  unsigned int v8; // r12
  int v9; // t1
  bool v10; // zf
  _BOOL4 v11; // r3
  _BOOL4 v12; // r1

  v3 = *a1;
  switch ( a2 )
  {
    case 2u:
      v4 = v3 & 0x1F;
      break;
    case 3u:
      v4 = v3 & 0xF;
      break;
    case 4u:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = (unsigned __int8)a1[1];
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = a1 + 1;
  v8 = 1;
  while ( 1 )
  {
    ++v8;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( a2 <= v8 )
      break;
    v9 = (unsigned __int8)*++v7;
    LOBYTE(v6) = v9;
    if ( (v9 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) < 0x800 )
    return 0;
  v10 = v4 == 127;
  if ( v4 <= 127 )
    v10 = a2 == 2;
  result = v10;
  if ( v10 )
    return 0;
  v11 = a2 == 3;
  if ( v4 >= 2048 )
    v11 = 0;
  if ( !v11 )
  {
    v12 = a2 == 4;
    if ( v4 >= 0x10000 )
      v12 = 0;
    if ( !v12 )
    {
      result = 1;
      if ( a3 )
        *a3 = v4;
      return result;
    }
    return 0;
  }
  return result;
}

//----- (00047E38) --------------------------------------------------------
char *__fastcall sub_47E38(char *result, int a2, _DWORD *a3)
{
  char *v4; // r4
  unsigned int v5; // r0
  unsigned int v6; // r1
  int v7; // r2
  unsigned int v8; // r6
  int v9; // [sp+4h] [bp-14h] BYREF

  if ( a2 )
  {
    v4 = result;
    v5 = sub_47CE4((unsigned __int8)*result);
    v8 = v5;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v9 = v7;
LABEL_7:
        result = &v4[v8];
        if ( a3 )
          *a3 = v9;
        return result;
      }
      if ( v6 >= v5 && sub_47D50(v4, v5, &v9) )
        goto LABEL_7;
    }
    return 0;
  }
  return result;
}
// 47E68: variable 'v7' is possibly undefined
// 47E74: variable 'v6' is possibly undefined

//----- (00047EB4) --------------------------------------------------------
int __fastcall sub_47EB4(int a1, unsigned int a2)
{
  int v4; // r4
  unsigned int v5; // r5
  char *v6; // r0

  if ( !a2 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_47CE4(*(unsigned __int8 *)(a1 + v4));
    v6 = (char *)(a1 + v4);
    if ( !v5 )
      break;
    if ( v5 > 1 )
    {
      if ( a2 - v4 < v5 )
        break;
      v4 = v5 + v4 - 1;
      if ( !sub_47D50(v6, v5, 0) )
        break;
    }
    if ( a2 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (00047F30) --------------------------------------------------------
_QWORD *__fastcall sub_47F30(int a1)
{
  __int64 v1; // r4
  _QWORD *result; // r0

  if ( a1 && *(_DWORD *)a1 == 3 )
    v1 = *(_QWORD *)(a1 + 8);
  else
    v1 = 0;
  result = sub_4774C((void *)0x10);
  if ( result )
  {
    result[1] = v1;
    *(_DWORD *)result = 3;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}

//----- (00047F80) --------------------------------------------------------
void *__fastcall sub_47F80(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // r12
  void *v4; // r5
  unsigned int v6; // r3
  unsigned int v7; // r12
  unsigned int v10; // r7
  void *v11; // r0

  v3 = a1[2];
  v4 = (void *)a1[4];
  if ( a2 + a1[3] <= v3 )
    return v4;
  v6 = 2 * v3;
  v7 = v3 + a2;
  if ( v6 < v7 )
    v10 = v7;
  else
    v10 = v6;
  v11 = sub_4774C((void *)(4 * v10));
  if ( !v11 )
    return 0;
  a1[2] = v10;
  a1[4] = v11;
  if ( !a3 )
    return v4;
  memcpy(v11, v4, 4 * a1[3]);
  sub_47764(v4);
  return (void *)a1[4];
}

//----- (0004800C) --------------------------------------------------------
_DWORD *__fastcall sub_4800C(_BYTE *a1, size_t a2, int a3)
{
  _BYTE *v3; // r5
  _DWORD *result; // r0

  v3 = a1;
  if ( !a1 )
    return 0;
  if ( !a3 )
  {
    v3 = sub_4777C(a1, a2);
    if ( !v3 )
      return 0;
  }
  result = sub_4774C((void *)0x10);
  if ( result )
  {
    result[2] = v3;
    result[3] = a2;
    *result = 2;
    result[1] = 1;
  }
  else
  {
    sub_47764(v3);
    return 0;
  }
  return result;
}

//----- (00048078) --------------------------------------------------------
_DWORD *sub_48078()
{
  _DWORD *v0; // r4
  void *v2; // r0

  v0 = sub_4774C((void *)0x24);
  if ( v0 )
  {
    if ( !dword_73108 )
      sub_45DF8(0);
    v0[1] = 1;
    *v0 = 0;
    if ( sub_457E8(v0 + 2) )
    {
      v2 = v0;
      v0 = 0;
      sub_47764(v2);
    }
  }
  return v0;
}
// 73108: using guessed type int dword_73108;

//----- (000480E0) --------------------------------------------------------
_DWORD *__fastcall sub_480E0(_DWORD *result)
{
  if ( result )
  {
    if ( *result )
      return 0;
    else
      return (_DWORD *)result[2];
  }
  return result;
}

//----- (000480FC) --------------------------------------------------------
int __fastcall sub_480FC(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_45B10((int)(a1 + 2), a2);
}

//----- (00048124) --------------------------------------------------------
bool __fastcall sub_48124(int *a1, int *a2)
{
  int v2; // r3
  int v6; // r7
  int v7; // r2
  unsigned int v8; // r6
  int v9; // r1
  bool v10; // zf
  int v11; // r0
  int v12; // r8
  int v13; // r0
  int v14; // r1
  int v15; // r0
  char *v16; // r6
  int v17; // r7
  int v18; // r0
  char *v19; // r1
  int v20; // r6
  size_t v21; // r2

  v2 = *a1;
  if ( *a1 != *a2 )
    return 0;
  if ( a1 == a2 )
    return 1;
  switch ( v2 )
  {
    case 0:
      if ( a1[2] != a2[2] )
        return 0;
      v12 = (int)(a1 + 2);
      v13 = sub_45CEC((int)(a1 + 2));
      if ( !v13 )
        return 1;
      while ( 1 )
      {
        v15 = sub_45D7C(v13);
        v16 = (char *)v15;
        if ( !v15 )
          break;
        v17 = v15 - 16;
        v18 = sub_45D84(v15 - 16);
        v19 = v16;
        v20 = v18;
        if ( !v18 )
          break;
        v14 = sub_480FC(a2, v19);
        if ( !v14 || !sub_48124(v20, v14) )
          return 0;
        if ( !*a1 )
        {
          v13 = sub_45D64(v12, v17);
          if ( v13 )
            continue;
        }
        return 1;
      }
      return 1;
    case 1:
      v6 = a1[3];
      if ( v6 != a2[3] )
        return 0;
      if ( !v6 )
        return 1;
      v7 = *a1;
      v8 = 0;
      break;
    case 2:
      v21 = a1[3];
      return v21 == a2[3] && !memcmp((const void *)a1[2], (const void *)a2[2], v21);
    case 3:
      return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
    case 4:
      return *((double *)a1 + 1) == *((double *)a2 + 1);
    default:
      return 0;
  }
  while ( 1 )
  {
    if ( v2 == 1 && a1[3] > v8 )
      v11 = *(_DWORD *)(a1[4] + 4 * v8);
    else
      v11 = 0;
    if ( v7 != 1 || a2[3] <= v8 )
      return 0;
    v9 = *(_DWORD *)(a2[4] + 4 * v8);
    v10 = v9 == 0;
    if ( v9 )
      v10 = v11 == 0;
    if ( v10 || !sub_48124(v11, v9) )
      return 0;
    if ( v6 == ++v8 )
      break;
    v2 = *a1;
    v7 = *a2;
  }
  return 1;
}
// 48158: control flows out of bounds to 4815C

//----- (00048304) --------------------------------------------------------
int __fastcall sub_48304(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return -1;
  else
    return sub_45B70(a1 + 2, a2);
}

//----- (00048364) --------------------------------------------------------
int __fastcall sub_48364(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return sub_45CEC((int)(a1 + 2));
}

//----- (00048388) --------------------------------------------------------
int __fastcall sub_48388(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_45D04((int)(a1 + 2), a2);
}

//----- (000483B0) --------------------------------------------------------
int __fastcall sub_483B0(_DWORD *a1, int a2)
{
  _BOOL4 v2; // r3

  if ( !a1 )
    return 0;
  v2 = a2 == 0;
  if ( *a1 )
    v2 = 1;
  if ( v2 )
    return 0;
  else
    return sub_45D64((int)(a1 + 2), a2);
}

//----- (000483E4) --------------------------------------------------------
int __fastcall sub_483E4(int a1)
{
  if ( a1 )
    return sub_45D7C(a1);
  return a1;
}

//----- (000483F0) --------------------------------------------------------
int __fastcall sub_483F0(int a1)
{
  if ( a1 )
    return sub_45D84(a1);
  return a1;
}

//----- (000483FC) --------------------------------------------------------
int __fastcall sub_483FC(int result)
{
  if ( result )
    result -= 16;
  return result;
}

//----- (00048408) --------------------------------------------------------
_DWORD *sub_48408()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r0
  void *v4; // r0

  v0 = sub_4774C((void *)0x14);
  v1 = v0;
  if ( v0 )
  {
    *v0 = 1;
    v0[1] = 1;
    v0[3] = 0;
    v0[2] = 8;
    v2 = sub_4774C((void *)0x20);
    v1[4] = v2;
    if ( !v2 )
    {
      v4 = v1;
      v1 = 0;
      sub_47764(v4);
    }
  }
  return v1;
}

//----- (00048468) --------------------------------------------------------
_DWORD *__fastcall sub_48468(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 1 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (00048484) --------------------------------------------------------
_DWORD *__fastcall sub_48484(_DWORD *result, unsigned int a2)
{
  if ( result )
  {
    if ( *result == 1 && result[3] > a2 )
      return *(_DWORD **)(result[4] + 4 * a2);
    else
      return 0;
  }
  return result;
}

//----- (000484B8) --------------------------------------------------------
int __fastcall sub_484B8(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r4
  __int64 v5; // r0
  size_t v6; // r2
  unsigned int v7; // r3
  int v8; // r2
  int v9; // r12
  unsigned int *v10; // r2
  unsigned int v11; // r1

  if ( !a1 )
    return -1;
  v3 = *a1 != 1 || a2 == 0;
  if ( v3 || *a2 != 1 || !sub_47F80(a1, a2[3], 1) )
    return -1;
  v5 = *(_QWORD *)(a2 + 3);
  v6 = a2[3];
  if ( (_DWORD)v5 )
  {
    v7 = 0;
    do
    {
      v8 = *(_DWORD *)(HIDWORD(v5) + 4 * v7);
      if ( v8 )
      {
        v9 = *(_DWORD *)(v8 + 4);
        v10 = (unsigned int *)(v8 + 4);
        if ( v9 != -1 )
        {
          do
            v11 = __ldrex(v10);
          while ( __strex(v11 + 1, v10) );
          __dmb(0xBu);
          v5 = *(_QWORD *)(a2 + 3);
        }
      }
      ++v7;
    }
    while ( (unsigned int)v5 > v7 );
    v6 = 4 * v5;
  }
  memcpy((void *)(a1[4] + 4 * a1[3]), (const void *)HIDWORD(v5), v6);
  a1[3] += a2[3];
  return 0;
}

//----- (00048590) --------------------------------------------------------
const char *__fastcall sub_48590(const char *result)
{
  char *v1; // r4
  size_t v2; // r0

  if ( result )
  {
    v1 = (char *)result;
    v2 = strlen(result);
    return (const char *)sub_4800C(v1, v2, 0);
  }
  return result;
}

//----- (000485B8) --------------------------------------------------------
_DWORD *__fastcall sub_485B8(_BYTE *a1, size_t a2)
{
  return sub_4800C(a1, a2, 0);
}

//----- (000485C0) --------------------------------------------------------
_DWORD *__fastcall sub_485C0(_BYTE *a1, size_t a2)
{
  return sub_4800C(a1, a2, 1);
}

//----- (000485C8) --------------------------------------------------------
_DWORD *__fastcall sub_485C8(_BYTE *a1, size_t a2)
{
  if ( !a1 )
    return 0;
  if ( sub_47EB4((int)a1, a2) )
    return sub_4800C(a1, a2, 0);
  return 0;
}

//----- (0004860C) --------------------------------------------------------
const char *__fastcall BUFX_strdup(const char *result)
{
  char *v1; // r4
  size_t v2; // r0

  if ( result )
  {
    v1 = (char *)result;
    v2 = strlen(result);
    return (const char *)sub_485C8(v1, v2);
  }
  return result;
}

//----- (00048630) --------------------------------------------------------
_DWORD *__fastcall sub_48630(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[2];
    else
      return 0;
  }
  return result;
}

//----- (0004864C) --------------------------------------------------------
_DWORD *__fastcall sub_4864C(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (00048668) --------------------------------------------------------
int __fastcall sub_48668(int a1, const void *a2, size_t a3)
{
  _BYTE *v6; // r7

  if ( !a1 )
    return -1;
  if ( *(_DWORD *)a1 != 2 || a2 == 0 )
    return -1;
  v6 = sub_4777C(a2, a3);
  if ( !v6 )
    return -1;
  sub_47764(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 12) = a3;
  return 0;
}

//----- (000486CC) --------------------------------------------------------
int __fastcall sub_486CC(int a1, const char *a2)
{
  size_t v4; // r0

  if ( !a2 )
    return -1;
  v4 = strlen(a2);
  return sub_48668(a1, a2, v4);
}

//----- (00048700) --------------------------------------------------------
int __fastcall sub_48700(int a1, const void *a2, size_t a3)
{
  if ( a2 && sub_47EB4((int)a2, a3) )
    return sub_48668(a1, a2, a3);
  else
    return -1;
}

//----- (00048744) --------------------------------------------------------
int __fastcall sub_48744(int a1, const char *a2)
{
  size_t v4; // r0

  if ( !a2 )
    return -1;
  v4 = strlen(a2);
  return sub_48700(a1, a2, v4);
}

//----- (00048778) --------------------------------------------------------
_DWORD *__fastcall sub_48778(char *format, __gnuc_va_list arg)
{
  int v3; // r0
  size_t v4; // r4
  char *v5; // r0
  char *v6; // r7

  v3 = vsnprintf(0, 0, format, arg);
  v4 = v3;
  if ( !v3 )
    return sub_485C8("", 0);
  v5 = (char *)sub_4774C((void *)(v3 + 1));
  v6 = v5;
  if ( !v5 )
    return 0;
  vsnprintf(v5, v4 + 1, format, arg);
  if ( sub_47EB4((int)v6, v4) )
    return sub_4800C(v6, v4, 1);
  sub_47764(v6);
  return 0;
}

//----- (00048828) --------------------------------------------------------
_DWORD *ipcomx_vprintf(char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  return sub_48778(a1, varg_r1);
}

//----- (00048858) --------------------------------------------------------
_QWORD *__fastcall sub_48858(__int64 a1)
{
  _QWORD *result; // r0

  result = sub_4774C((void *)0x10);
  if ( result )
  {
    result[1] = a1;
    *(_DWORD *)result = 3;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}

//----- (0004888C) --------------------------------------------------------
__int64 __fastcall sub_4888C(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

//----- (000488B4) --------------------------------------------------------
int __fastcall sub_488B4(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (000488DC) --------------------------------------------------------
double *sub_488DC()
{
  double v0; // d0
  double *result; // r0

  if ( fabs(v0) > 1.79769313e308 )
    return 0;
  result = (double *)sub_4774C((void *)0x10);
  if ( result )
  {
    result[1] = v0;
    *(_DWORD *)result = 4;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}
// 488EC: variable 'v0' is possibly undefined

//----- (00048938) --------------------------------------------------------
void sub_48938()
{
  ;
}

//----- (000489C8) --------------------------------------------------------
int __fastcall sub_489C8(int result)
{
  if ( result )
  {
    if ( *(_DWORD *)result == 3 )
      return sub_4A11C(*(_QWORD *)(result + 8));
  }
  return result;
}

//----- (00048A10) --------------------------------------------------------
void *sub_48A10()
{
  return &unk_68A4C;
}

//----- (00048A1C) --------------------------------------------------------
void *sub_48A1C()
{
  return &unk_68A54;
}

//----- (00048A28) --------------------------------------------------------
void *sub_48A28()
{
  return &unk_68A5C;
}

//----- (00048A34) --------------------------------------------------------
void __fastcall sub_48A34(_DWORD *a1)
{
  _DWORD *v2; // r0
  unsigned int v3; // r1
  unsigned int i; // r5
  int v5; // r3
  unsigned int *v6; // r2
  unsigned int v7; // r1
  unsigned int v8; // r1

  if ( a1 )
  {
    switch ( *a1 )
    {
      case 0:
        sub_45864((int)(a1 + 2));
        sub_47764(a1);
        return;
      case 1:
        v3 = a1[3];
        v2 = (_DWORD *)a1[4];
        if ( v3 )
        {
          for ( i = 0; i < v3; ++i )
          {
            v5 = v2[i];
            if ( v5 )
            {
              v6 = (unsigned int *)(v5 + 4);
              if ( *(_DWORD *)(v5 + 4) != -1 )
              {
                __dmb(0xBu);
                do
                {
                  v7 = __ldrex(v6);
                  v8 = v7 - 1;
                }
                while ( __strex(v8, v6) );
                if ( !v8 )
                  sub_48A34(v5);
                v2 = (_DWORD *)a1[4];
                v3 = a1[3];
              }
            }
          }
        }
        goto LABEL_4;
      case 2:
        v2 = (_DWORD *)a1[2];
LABEL_4:
        sub_47764(v2);
        goto LABEL_5;
      case 3:
      case 4:
LABEL_5:
        sub_47764(a1);
        break;
      default:
        return;
    }
  }
}
// 48A4C: control flows out of bounds to 48A50

//----- (00048B00) --------------------------------------------------------
int __fastcall sub_48B00(_DWORD *a1)
{
  unsigned int v2; // r2
  unsigned int i; // r4
  _DWORD *v4; // r0
  unsigned int *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r2

  if ( !a1 || *a1 != 1 )
    return -1;
  v2 = a1[3];
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(_DWORD **)(a1[4] + 4 * i);
      if ( v4 )
      {
        v5 = v4 + 1;
        if ( v4[1] != -1 )
        {
          __dmb(0xBu);
          do
          {
            v6 = __ldrex(v5);
            v7 = v6 - 1;
          }
          while ( __strex(v7, v5) );
          if ( !v7 )
            sub_48A34(v4);
          v2 = a1[3];
        }
      }
    }
  }
  a1[3] = 0;
  return 0;
}

//----- (00048B90) --------------------------------------------------------
int __fastcall sub_48B90(_DWORD *a1, int a2, _DWORD *a3)
{
  unsigned int *v4; // r3
  unsigned int v5; // r1
  unsigned int v6; // r1
  _BOOL4 v7; // r4

  if ( !a1 || *a1 || (a2 ? (v7 = a3 == 0) : (v7 = 1), v7) )
  {
    if ( !a3 )
      return -1;
    if ( a3[1] == -1 )
      return -1;
    v4 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v5 = __ldrex(v4);
      v6 = v5 - 1;
    }
    while ( __strex(v6, v4) );
    if ( v6 )
    {
      return -1;
    }
    else
    {
      sub_48A34(a3);
      return -1;
    }
  }
  else
  {
    sub_45D8C(a2, (int)a3);
    return 0;
  }
}

//----- (00048C28) --------------------------------------------------------
int __fastcall sub_48C28(_DWORD *a1, unsigned int a2)
{
  unsigned int v3; // r12
  int v5; // r6
  _DWORD *v6; // r0
  int v7; // r3
  unsigned int *v9; // r3
  unsigned int v10; // r2
  unsigned int v11; // r2

  if ( a1 )
  {
    if ( *a1 == 1 )
    {
      v3 = a1[3];
      if ( v3 > a2 )
      {
        v5 = 4 * a2;
        v6 = *(_DWORD **)(a1[4] + 4 * a2);
        if ( v6 && v6[1] != -1 )
        {
          v9 = v6 + 1;
          __dmb(0xBu);
          do
          {
            v10 = __ldrex(v9);
            v11 = v10 - 1;
          }
          while ( __strex(v11, v9) );
          if ( !v11 )
            sub_48A34(v6);
          v3 = a1[3];
          v7 = v3 - 1;
          if ( v3 - 1 <= a2 )
            goto LABEL_7;
        }
        else
        {
          v7 = v3 - 1;
          if ( v3 - 1 <= a2 )
          {
LABEL_7:
            a1[3] = v7;
            return 0;
          }
        }
        memmove((void *)(a1[4] + v5), (const void *)(a1[4] + v5 + 4), 4 * (~a2 + v3));
        v7 = a1[3] - 1;
        goto LABEL_7;
      }
    }
  }
  return -1;
}

//----- (00048CF4) --------------------------------------------------------
int __fastcall sub_48CF4(_DWORD *a1, char *a2, _DWORD *a3)
{
  bool v4; // zf
  int result; // r0
  _BOOL4 v6; // r3
  unsigned int *v7; // r3
  unsigned int v8; // r2
  unsigned int v9; // r2
  unsigned int *v10; // r3
  unsigned int v11; // r2

  if ( !a3 )
    return -1;
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( !v4 )
  {
    v6 = a3 == a1;
    if ( *a1 )
      v6 = 1;
    if ( !v6 )
    {
      result = sub_4587C((int)(a1 + 2), a2, (int)a3);
      if ( !result )
        return result;
      if ( a3[1] != -1 )
      {
        v7 = a3 + 1;
        __dmb(0xBu);
        do
        {
          v8 = __ldrex(v7);
          v9 = v8 - 1;
        }
        while ( __strex(v9, v7) );
        goto LABEL_18;
      }
      return -1;
    }
  }
  if ( a3[1] == -1 )
    return -1;
  v10 = a3 + 1;
  __dmb(0xBu);
  do
  {
    v11 = __ldrex(v10);
    v9 = v11 - 1;
  }
  while ( __strex(v9, v10) );
LABEL_18:
  if ( v9 )
    return -1;
  sub_48A34(a3);
  return -1;
}

//----- (00048DB0) --------------------------------------------------------
int __fastcall sub_48DB0(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r9
  int i; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  int v10; // r0
  char *v11; // r4
  _DWORD *v12; // r8

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  for ( i = sub_45CEC((int)(a2 + 2)); i; i = sub_45D64(v4, (int)(v11 - 16)) )
  {
    v10 = sub_45D7C(i);
    v11 = (char *)v10;
    if ( !v10 )
      break;
    v12 = (_DWORD *)sub_45D84(v10 - 16);
    if ( !v12 )
      break;
    if ( !sub_480FC(a1, v11) )
    {
      v8 = v12 + 1;
      if ( v12[1] != -1 )
      {
        do
          v9 = __ldrex(v8);
        while ( __strex(v9 + 1, v8) );
        __dmb(0xBu);
      }
      sub_48CF4(a1, v11, v12);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (00048E9C) --------------------------------------------------------
int __fastcall sub_48E9C(_DWORD *a1, char *a2, _DWORD *a3)
{
  size_t v6; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2

  if ( a2 )
  {
    v6 = strlen(a2);
    if ( sub_47EB4((int)a2, v6) )
      return sub_48CF4(a1, a2, a3);
  }
  if ( !a3 )
    return -1;
  if ( a3[1] == -1 )
    return -1;
  v8 = a3 + 1;
  __dmb(0xBu);
  do
  {
    v9 = __ldrex(v8);
    v10 = v9 - 1;
  }
  while ( __strex(v10, v8) );
  if ( v10 )
    return -1;
  sub_48A34(a3);
  return -1;
}

//----- (00048F30) --------------------------------------------------------
int __fastcall sub_48F30(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r8
  int v6; // r0
  unsigned int v8; // r1
  int v9; // r0
  char *v10; // r5
  _DWORD *v11; // r0
  unsigned int *v12; // r3

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  v6 = sub_45CEC((int)(a2 + 2));
  if ( v6 )
  {
    while ( 1 )
    {
      v9 = sub_45D7C(v6);
      v10 = (char *)v9;
      if ( !v9 )
        break;
      v11 = (_DWORD *)sub_45D84(v9 - 16);
      v12 = v11 + 1;
      if ( !v11 )
        return 0;
      if ( v11[1] != -1 )
      {
        do
          v8 = __ldrex(v12);
        while ( __strex(v8 + 1, v12) );
        __dmb(0xBu);
      }
      if ( sub_48CF4(a1, v10, v11) )
        return -1;
      if ( !*a2 )
      {
        v6 = sub_45D64(v4, (int)(v10 - 16));
        if ( v6 )
          continue;
      }
      return 0;
    }
  }
  return 0;
}

//----- (00049010) --------------------------------------------------------
int __fastcall sub_49010(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r9
  int i; // r0
  unsigned int *v7; // r3
  unsigned int v8; // r2
  int v9; // r0
  char *v10; // r4
  _DWORD *v11; // r6

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  for ( i = sub_45CEC((int)(a2 + 2)); i; i = sub_45D64(v4, (int)(v10 - 16)) )
  {
    v9 = sub_45D7C(i);
    v10 = (char *)v9;
    if ( !v9 )
      break;
    v11 = (_DWORD *)sub_45D84(v9 - 16);
    if ( !v11 )
      break;
    if ( sub_480FC(a1, v10) )
    {
      v7 = v11 + 1;
      if ( v11[1] != -1 )
      {
        do
          v8 = __ldrex(v7);
        while ( __strex(v8 + 1, v7) );
        __dmb(0xBu);
      }
      sub_48CF4(a1, v10, v11);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (00049100) --------------------------------------------------------
int __fastcall sub_49100(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  int v6; // r2
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  char *v11; // r8
  char *v12; // r0
  int v13; // r7
  int v14; // r3
  unsigned int *v15; // r3
  unsigned int v16; // r2

  if ( !a3 )
    return -1;
  if ( !a1 )
    goto LABEL_6;
  v6 = a3 == a1;
  if ( *a1 != 1 )
    v6 |= 1u;
  if ( v6 || a1[3] < a2 )
  {
LABEL_6:
    if ( a3[1] == -1 )
      return -1;
    v8 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v9 = __ldrex(v8);
      v10 = v9 - 1;
    }
    while ( __strex(v10, v8) );
LABEL_10:
    if ( !v10 )
    {
      sub_48A34(a3);
      return -1;
    }
    return -1;
  }
  v11 = (char *)sub_47F80(a1, 1, 0);
  if ( !v11 )
  {
    if ( a3[1] == -1 )
      return -1;
    v15 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v16 = __ldrex(v15);
      v10 = v16 - 1;
    }
    while ( __strex(v10, v15) );
    goto LABEL_10;
  }
  v12 = (char *)a1[4];
  v13 = 4 * (a2 + 1);
  if ( v12 == v11 )
  {
    memmove(&v12[v13], &v11[v13 - 4], 4 * (a1[3] - a2));
  }
  else
  {
    memcpy(v12, v11, v13 - 4);
    memcpy((void *)(a1[4] + v13), &v11[v13 - 4], 4 * (a1[3] - a2));
    sub_47764(v11);
  }
  v14 = a1[3] + 1;
  *(_DWORD *)(a1[4] + v13 - 4) = a3;
  a1[3] = v14;
  return 0;
}

//----- (0004935C) --------------------------------------------------------
int __fastcall sub_4935C(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v4; // r5
  unsigned int *v6; // r3
  unsigned int v7; // r2
  unsigned int v8; // r2
  int v9; // r3
  unsigned int *v10; // r3
  unsigned int v11; // r2

  if ( !a2 )
    return -1;
  if ( !a1 )
    goto LABEL_6;
  v4 = a2 == a1;
  if ( *a1 != 1 )
    v4 = 1;
  if ( !v4 )
  {
    if ( sub_47F80(a1, 1, 1) )
    {
      v9 = a1[3];
      *(_DWORD *)(a1[4] + 4 * v9) = a2;
      a1[3] = v9 + 1;
      return 0;
    }
    if ( a2[1] == -1 )
      return -1;
    v10 = a2 + 1;
    __dmb(0xBu);
    do
    {
      v11 = __ldrex(v10);
      v8 = v11 - 1;
    }
    while ( __strex(v8, v10) );
  }
  else
  {
LABEL_6:
    if ( a2[1] == -1 )
      return -1;
    v6 = a2 + 1;
    __dmb(0xBu);
    do
    {
      v7 = __ldrex(v6);
      v8 = v7 - 1;
    }
    while ( __strex(v8, v6) );
  }
  if ( v8 )
    return -1;
  sub_48A34(a2);
  return -1;
}

//----- (00049438) --------------------------------------------------------
bool __fastcall sub_49438(int *a1, int *a2)
{
  bool v2; // zf

  v2 = a2 == 0;
  if ( a2 )
    v2 = a1 == 0;
  return !v2 && sub_48124(a1, a2);
}

//----- (00049450) --------------------------------------------------------
double *__fastcall sub_49450(int a1)
{
  _DWORD *v2; // r7
  int i; // r0
  unsigned int v4; // r1
  int v5; // r0
  char *v6; // r5
  _DWORD *v7; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r3
  unsigned int j; // r5
  _DWORD *v11; // r1
  unsigned int *v12; // r2
  unsigned int v13; // r3

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v2 = sub_48078();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)a1 )
        {
          for ( i = sub_45CEC(a1 + 8); i; i = sub_45D64(a1 + 8, (int)(v6 - 16)) )
          {
            v5 = sub_45D7C(i);
            v6 = (char *)v5;
            if ( !v5 )
              break;
            v7 = (_DWORD *)sub_45D84(v5 - 16);
            v8 = v7 + 1;
            if ( !v7 )
              break;
            if ( v7[1] != -1 )
            {
              do
                v4 = __ldrex(v8);
              while ( __strex(v4 + 1, v8) );
              __dmb(0xBu);
            }
            sub_48CF4(v2, v6, v7);
            if ( *(_DWORD *)a1 )
              break;
          }
        }
        return (double *)v2;
      case 1:
        v2 = sub_48408();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)a1 == 1 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( v9 )
          {
            for ( j = 0; j < v9; ++j )
            {
              v11 = 0;
              if ( v9 > j )
              {
                v11 = *(_DWORD **)(*(_DWORD *)(a1 + 16) + 4 * j);
                v12 = v11 + 1;
                if ( v11 )
                {
                  if ( v11[1] != -1 )
                  {
                    do
                      v13 = __ldrex(v12);
                    while ( __strex(v13 + 1, v12) );
                    __dmb(0xBu);
                  }
                }
              }
              sub_4935C(v2, v11);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v9 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return (double *)v2;
      case 2:
        return (double *)sub_4800C(*(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      case 3:
        return (double *)sub_47F30(a1);
      case 4:
        return sub_488DC();
      case 5:
      case 6:
      case 7:
        return (double *)a1;
      default:
        return 0;
    }
  }
  return 0;
}
// 49468: control flows out of bounds to 4946C

//----- (0004960C) --------------------------------------------------------
double *__fastcall sub_4960C(int a1)
{
  _DWORD *v2; // r6
  int i; // r5
  char *v4; // r7
  int v5; // r0
  _DWORD *v6; // r0
  unsigned int v7; // r3
  unsigned int j; // r5
  int v9; // r0
  _DWORD *v10; // r0

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v2 = sub_48078();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)a1 )
        {
          for ( i = sub_45CEC(a1 + 8); i; i = sub_45D64(a1 + 8, i) )
          {
            v4 = (char *)sub_45D7C(i);
            v5 = sub_45D84(i);
            v6 = (_DWORD *)sub_4960C(v5);
            sub_48CF4(v2, v4, v6);
            if ( *(_DWORD *)a1 )
              break;
          }
        }
        return (double *)v2;
      case 1:
        v2 = sub_48408();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)a1 == 1 )
        {
          v7 = *(_DWORD *)(a1 + 12);
          if ( v7 )
          {
            for ( j = 0; j < v7; ++j )
            {
              v9 = 0;
              if ( v7 > j )
                v9 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * j);
              v10 = (_DWORD *)sub_4960C(v9);
              sub_4935C(v2, v10);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v7 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return (double *)v2;
      case 2:
        return (double *)sub_4800C(*(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      case 3:
        return (double *)sub_47F30(a1);
      case 4:
        return sub_488DC();
      case 5:
      case 6:
      case 7:
        return (double *)a1;
      default:
        return 0;
    }
  }
  return 0;
}
// 49624: control flows out of bounds to 49628

//----- (00049770) --------------------------------------------------------
char *__fastcall sub_49770(char *a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  if ( v4 <= 0x4F )
    return strncpy(a1 + 12, s, v4 + 1);
  *((_WORD *)a1 + 6) = 11822;
  a1[14] = 46;
  return strncpy(a1 + 15, &s[v4 - 76], 0x4Du);
}

//----- (000497D4) --------------------------------------------------------
char *__fastcall sub_497D4(char *result, char *a2)
{
  if ( result )
  {
    result[92] = 0;
    *((_DWORD *)result + 2) = 0;
    *(_DWORD *)result = -1;
    *((_DWORD *)result + 1) = -1;
    if ( a2 )
      return sub_49770(result, a2);
    else
      result[12] = 0;
  }
  return result;
}

//----- (00049814) --------------------------------------------------------
char *__fastcall sub_49814(char *a1, char *s)
{
  bool v2; // zf

  v2 = s == 0;
  if ( s )
    v2 = a1 == 0;
  if ( !v2 )
    return sub_49770(a1, s);
  return a1;
}

//----- (00049824) --------------------------------------------------------
int sub_49824(int result, int a2, int a3, int a4, char a5, char *format, ...)
{
  int v6; // r4
  va_list va; // [sp+20h] [bp+14h] BYREF

  va_start(va, format);
  v6 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, va);
      *(_BYTE *)(v6 + 250) = 0;
      *(_BYTE *)(v6 + 251) = a5;
    }
  }
  return result;
}

//----- (00049888) --------------------------------------------------------
int __fastcall sub_49888(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg)
{
  int v7; // r4

  v7 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, arg);
      *(_BYTE *)(v7 + 250) = 0;
      *(_BYTE *)(v7 + 251) = a5;
    }
  }
  return result;
}

//----- (00049B34) --------------------------------------------------------
int __fastcall sub_49B34(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x49B2A);
  return a1 / a2;
}
// 49B36: control flows out of bounds to 49B2A

//----- (00049B50) --------------------------------------------------------
int __fastcall sub_49B50(int result, unsigned int a2)
{
  int v2; // r12
  unsigned int v3; // r3

  if ( !a2 )
    JUMPOUT(0x4A1A8);
  v2 = result ^ a2;
  if ( (a2 & 0x80000000) != 0 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v2 ^ result) < 0 )
      return -result;
  }
  else
  {
    v3 = result;
    if ( result < 0 )
      v3 = -result;
    if ( v3 <= a2 )
    {
      if ( v3 < a2 )
        result = 0;
      if ( v3 == a2 )
        return (v2 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_49B98 + 16 * (31 - (__clz(a2) - __clz(v3)))))(0);
    }
    else
    {
      result = v3 >> (31 - __clz(a2));
      if ( v2 < 0 )
        return -result;
    }
  }
  return result;
}
// 49DE0: control flows out of bounds to 4A1A8

//----- (0004A10C) --------------------------------------------------------
int __fastcall sub_4A10C(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x4A132);
  return a1;
}
// 4A11A: control flows out of bounds to 4A132

//----- (0004A11C) --------------------------------------------------------
int __fastcall sub_4A11C(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (0004A178) --------------------------------------------------------
int __fastcall sub_4A178(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return _udivmoddi4(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (0004A218) --------------------------------------------------------
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}
// 4A218: invalid function type 'UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp)' has been ignored

//----- (0004A330) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_66F00;
  v8 = &off_66F04 - &off_66F00;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 66F00: using guessed type _UNKNOWN *off_66F00;
// 66F04: using guessed type _UNKNOWN *off_66F04;

//----- (0004A370) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=979 queued=642 decompiled=642 lumina nreq=0 worse=0 better=0
// ALL OK, 642 function(s) have been successfully decompiled
